{"id": "WlyfRy", "name": "Tunneling through golden fractal", "author": "mrange", "description": "Licence CC0: Tunneling through golden fractal III\n", "tags": ["2d", "fractal"], "likes": 15, "viewed": 527, "published": 3, "date": "1614540506", "time_retrieved": "2024-07-30T19:35:21.011856", "image_code": "// Licence CC0: Tunneling through golden fractal III\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x, x)\n#define PLANE_PERIOD    5.0\n\nconst vec3 std_gamma   = vec3(2.2, 2.2, 2.2);\nconst vec3 planeCol    = vec3(1.0, 1.15, 1.5)*0.95;\nconst vec3 baseRingCol = pow(vec3(1.0, 0.65, 0.25), vec3(0.6));\nconst vec3 sunCol      = vec3(1.25, 1.0, 1.1)/1.25;\n\nstruct effect {\n  float lw;\n  float tw;\n  float sk;\n  float cs;\n};\n\nconst effect effects[] = effect[](\n    effect(0.5, 0.0, 0.0, 0.0)\n  , effect(0.5, 0.0, 0.0, 1.0)\n  , effect(0.5, 0.0, 1.0, 1.0)\n  , effect(0.5, 1.0, 1.0, 1.0)\n  , effect(0.5, 1.0, 1.0, 0.0)\n  , effect(0.5, 1.0, 0.0, 0.0)\n  );\neffect current_effect = effects[5];\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n  hp = toRect(hpp);\n  p = hp;\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n  for(int i=0; i<7; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = dot(p,p);\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n\n  float lw = 0.00125*current_effect.lw;\n  \n  float d0 = abs(p.y)-lw*scale;\n  float d1 = abs(circle(p.xz, 0.005*scale))-lw*scale;\n  float d = d0;\n  d = mix(d, min(d, d1), current_effect.tw);\n  return (d/scale);\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\nfloat weird3(vec2 p, float h) {\n  vec2  c = vec2(-1.25,  -1.25)+0.15*vec2(sin(0.2*TIME+TAU*h*vec2(1.0, sqrt(0.5)*0.5)));\n  vec2 ot = mix(1.5, -1.5, h)*vec2(cos(TAU*h*sqrt(0.5)), sin(TAU*h));\n  vec2 u = p;\n  float lx = 1E6;\n  float ly = 1E6;\n  float lp = 1E6;\n  const int maxi = 7;\n  float s = 1.0;\n\n  for (int i = 0; i < maxi; ++i) {\n    float m = dot(u, u);\n    u = SABS(u, 0.05)/m + c;\n    s *= m;\n    float dx = abs(u.x - ot.x);\n    float dy = abs(u.y - ot.y);\n    float dp = abs(1.65-length(u));\n    if(m > 0.05) {\n      lx = min(lx, dx);\n      ly = min(ly, dy);\n    }\n    lp = min(lp, dp);\n  }\n  \n  \n  float l = lp;\n  l = pmin(l, lx, 0.05);\n  l = pmin(l, ly, 0.05);\n  l -= 0.025;\n  return l*s;\n}\n\n\nfloat circles(vec2 p) {\n  vec2 pp = toPolar(p);\n  const float ss = 2.0;\n  pp.x = fract(pp.x/ss)*ss;\n  p = toRect(pp);\n  float d = circle(p, 1.0);\n  return d;\n}\n\nvec2 df(vec2 p, float h) {\n  vec2 wp = p;\n  float rep = 2.0*round(mix(3.0, 12.0, h*h));\n  float ss = 0.05*6.0/rep;\n\n  if (current_effect.sk > 0.0) {\n    smoothKaleidoscope(wp, ss, rep);\n  }\n  \n  float sss = mix(3.0, 6.0, h*h);\n  float d0 = weird3(wp/sss, h)*sss;\n  float d1 = hex(p, 0.25)-0.1;\n  float d2 = circles(p);\n  const float lw = 0.0125;\n  d2 = abs(d2)-lw;\n  float d = d0;\n\n  if (current_effect.cs > 0.0) {\n    d  = pmin(d, d2, 0.1);\n  }\n\n  d  = pmin(d, abs(d1)-lw, 0.1);\n  d  = max(d, -(d1+lw));\n  return vec2(d, d1+lw);\n}\n\nvec2 df(vec3 p, vec3 off, float s, mat2 rot, float h) {\n  vec2 p2 = p.xy;\n  p2 -= off.xy;\n  p2 *= rot;\n  return df(p2/s, h)*s;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return 1.0*sunCol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float pd, vec3 off, float aa, float n) {\n  int pi = int(mod(n/PLANE_PERIOD, float(effects.length())));\n  current_effect = effects[pi];\n  \n  float h = hash(n);\n  float s = 0.25*mix(0.5, 0.25, h);\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 loff = 2.0*vec3(0.25*0.5, 0.125*0.5, -0.125);\n  vec3 lp1  = ro + loff;\n  vec3 lp2  = ro + loff*vec3(-2.0, 1.0, 1.0);\n\n  vec2 p = pp.xy-off.xy;\n\n  mat2 rot = ROT(TAU*h);\n\n  vec2 d2 = df(pp, off, s, rot, h);\n\n  float hh = -1.0*smoothstep(-aa, aa*3.0, -d2.x);\n  // Well this doesn't seem to work in shadertoy.\n  float hhx = dFdx(hh);\n  float hhy = dFdy(hh);\n  vec3  hn = normalize(vec3(hhx, hhy, -1));\n\n  const vec3 nn  = vec3(0.0, 0.0, -1.0);\n  vec3 ld1   = normalize(lp1 - pp);\n  vec3 ld2   = normalize(lp2 - pp);\n  float dif1 = pow(max(dot(nn, ld1), 0.0), 5.0);\n  float dif2 = pow(max(dot(nn, ld2), 0.0), 5.0);\n  vec3 ref   = reflect(rd, hn);\n  float spe1= pow(max(dot(ref, ld1), 0.0), 30.0);\n  float spe2= pow(max(dot(ref, ld2), 0.0), 30.0);\n\n  const float boff = 0.0125*0.5;\n  float dbt = boff/rd.z;\n  \n  vec3 bpp = ro + (pd + dbt)*rd;\n  vec2 bp = bpp.xy - off.xy;\n\n  vec3 srd1 = normalize(lp1-bpp);\n  vec3 srd2 = normalize(lp2-bpp);\n  float bl21= L2(lp1-bpp);\n  float bl22= L2(lp2-bpp);\n\n  float st1 = -boff/srd1.z;\n  float st2 = -boff/srd2.z;\n\n  vec3 spp1 = bpp + st1*srd1;\n  vec3 spp2 = bpp + st2*srd2;\n  \n  vec2 bd  = df(bpp, off, s, rot, h);\n  vec2 sd1 = df(spp1, off, s, rot, h);\n  vec2 sd2 = df(spp2, off, s, rot, h);\n\n  vec3 col  = vec3(0.0);\n  const float ss = 200.0;\n\n  col       += 0.1125*planeCol*dif1*(1.0-exp(-ss*(max((sd1.x), 0.0))))/bl21;\n  col       += 0.1125*planeCol*dif2*0.5*(1.0-exp(-ss*(max((sd2.x), 0.0))))/bl22;\n  \n  vec3 ringCol = baseRingCol;\n  ringCol *= vec3(clamp(0.1+2.5*(0.1+0.25*((dif1*dif1/bl21+dif2*dif2/bl22))), 0.0, 1.0));\n  ringCol += sqrt(baseRingCol)*spe1*2.0;\n  ringCol += sqrt(baseRingCol)*spe2*2.0;\n  col       = mix(col, ringCol, smoothstep(-aa, aa, -d2.x));  \n\n  float ha = smoothstep(-aa, aa, bd.y);\n\n  return vec4(col, mix(0.0, 1.0, ha));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0-0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 9;\n  const int fadeFrom = max(furthest-4, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, pd, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 color(vec2 p, vec2 q) {\n  float tm  = TIME*0.15+0.3;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1190, 1190, 1212, 1212, 1275], [1277, 1277, 1299, 1299, 1343], [1345, 1345, 1366, 1366, 1411], [1413, 1413, 1458, 1458, 1612], [1614, 1614, 1675, 1675, 1883], [1885, 1885, 1925, 1925, 2084], [2086, 2086, 2126, 2126, 2168], [2170, 2170, 2198, 2218, 2294], [2296, 2296, 2335, 2335, 2423], [2425, 2425, 2456, 2456, 2482], [2484, 2484, 2512, 2512, 2712], [2714, 2714, 2747, 2747, 3131], [3304, 3325, 3347, 3347, 3481], [3483, 3562, 3585, 3585, 3660], [3662, 3732, 3756, 3756, 3835], [4017, 4017, 4048, 4048, 4717], [4720, 4720, 4743, 4743, 4879], [4881, 4881, 4907, 4907, 5412], [5414, 5414, 5469, 5469, 5542], [5544, 5544, 5577, 5577, 5685], [5687, 5687, 5765, 5765, 7774], [7776, 7776, 7832, 7832, 9375], [9377, 9377, 9413, 9413, 9646], [9648, 9648, 9676, 9676, 10008], [10010, 10010, 10065, 10065, 10222]], "test": "untested"}
{"id": "WtGfzG", "name": "Sphere repetitions for clubber", "author": "xenn", "description": "My first raymarching\nReference: http://wgld.org/d/glsl/g012.html", "tags": ["3d", "fractal"], "likes": 1, "viewed": 302, "published": 3, "date": "1614532494", "time_retrieved": "2024-07-30T19:35:21.776811", "image_code": "// Fork of \"Sphere repetitions\" by xenn. https://shadertoy.com/view/WsGfzy\n// 2021-02-28 17:13:06\n\n// Fork of \"Sphere repetition\" by FMS_Cat. https://shadertoy.com/view/4sXSWX\n// 2020-12-07 18:20:04\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R 0.0\n#define CLUBBER_G 0.0\n#define CLUBBER_B  0.10\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\nvec4 Clubber = vec4(0.);\nfloat distFunc(vec3 p){\n    return length(mod(p+vec3(0,0,mod(-iTime*10.,4.)),4.)-2.)-.4;\n}\n\nvec3 getNormal(vec3 p){\n\tfloat d=01.1;\n\treturn normalize(vec3(\n\t\tdistFunc(p+vec3(  d, 0.0, 0.0))-distFunc(p+vec3( -d, 0.0, 0.0)),\n\t\tdistFunc(p+vec3(0.0,   d, 0.0))-distFunc(p+vec3(0.0,  -d, 0.0)),\n\t\tdistFunc(p+vec3(0.0, 0.0,   d))-distFunc(p+vec3(0.0, 0.0,  -d))\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n\tvec3 camP=vec3(0.,0.,1.);\n\tvec3 camC=vec3(sin(iTime*.7)*.3,0.,0.);\n\tvec3 camU=normalize(vec3(sin(iTime)*.1,1.,0.));\n\tvec3 camS=cross(normalize(camC-camP),camU);\n\tvec3 ray=normalize(camS*p.x+camU*p.y+(camC-camP));\n\t\n\tfloat dist=01.;\n\tfloat rayL=02.5;\n\tvec3  rayP=camP;\n\tfor(int i=0;i<64;i++){\n\t\tdist=distFunc(rayP);\n\t\trayL+=dist;\n\t\trayP=camP+ray*rayL;\n\t}\n\t\n\tif(abs(dist)<0.01){\n\t\tfloat fragR=dot(-ray,getNormal(rayP));\n\t\tfloat fragG=.0+(02.251*CLUBBER_G);\n\t\tfloat fragB=dot(vec3(0,1,1),getNormal(rayP));\n\t\tfragColor=vec4(vec3(fragR,fragG,fragB)*10./rayL,1.);\n\t}else{\n\t\tfragColor=vec4(vec3(0.0), 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[456, 456, 479, 479, 546], [548, 548, 571, 571, 817], [819, 819, 875, 875, 1537]], "test": "untested"}
{"id": "wlKfDm", "name": "Draw with mouse [antialiased]", "author": "avin", "description": "Simple demo for learning purposes", "tags": ["mouse", "draw", "buffer", "learn"], "likes": 11, "viewed": 507, "published": 3, "date": "1614521713", "time_retrieved": "2024-07-30T19:35:22.556725", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{          \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define S(d,r,pix) smoothstep( .75, -.75, (d)/(pix)-(r))\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord.xy)/iResolution.y;\n       \n    vec2 pos1 = iMouse.xy/iResolution.y;\n    vec4 prevMouse = texture(iChannel1, ouv).rgba;\n    vec2 pos2 = prevMouse.rg;\n       \n    vec3 backCol = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n                \n    float d = 0.;\n    if(prevMouse.w > 0.){\n        // d = clamp(drawLine(pos2, pos1, ouv, 3., 1.), 0., 1.);\n        d = S( line( ouv,pos2, pos1), 3., 2./iResolution.x);\n    }  \n    \n    // vec3 col = backCol + vec3(d);\n    \n    vec3 col = max(backCol, vec3(d));\n    \n    fragColor = vec4(col, 1.);    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse.xy/iResolution.y,1.0,iMouse.z);    \n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 131]], "test": "untested"}
{"id": "ttGfz1", "name": "Quick Lighting Tech", "author": "blackle", "description": "See the tutorial video for a walkthrough of each of these: [url]https://youtu.be/FilPE91ACOA[/url]", "tags": ["lighting"], "likes": 41, "viewed": 1353, "published": 3, "date": "1614521475", "time_retrieved": "2024-07-30T19:35:23.330656", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat lighting(vec3 normal, int type) {\n    if (type == 0) {\n        //phong diffuse lighting\n        vec3 lightDir = normalize(vec3(1));\n        return max(dot(lightDir, normal), 0.);\n    }\n    if (type == 1) {\n        //hemispherical lighting\n        vec3 lightDir = normalize(vec3(1));\n        return dot(lightDir, normal) * .5 + .5;\n    }\n    if (type == 2) {\n        //\"leaky\" phong diffuse lighting\n        vec3 lightDir = normalize(vec3(1));\n        float shade = dot(lightDir, normal);\n        return mix(max(shade, 0.), shade * .5 + .5, .05);\n    }\n    if (type == 3) {\n        //axis lighting\n        return dot(max(normal, 0.), vec3(.4));\n    }\n    if (type == 4) {\n        //downward pointing axis lighting\n        normal = erot(normal, normalize(vec3(-1,1,0)), .96);\n        return dot(max(normal, 0.), vec3(.4));\n    }\n    if (type == 5) {\n        //image based lighting\n        return pow(textureLod(iChannel0, normal.xzy, 7.).x, 2.);\n    }\n    if (type == 6) {\n        //fake image based lighting (\"studio lighting\")\n        return pow(length(sin(normal*2.)*.5+.5)/sqrt(3.), 2.);\n    }\n    if (type == 7) {\n        //fake image based lighting (\"outdoor lighting\")\n        return length(sin(normal*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,normal.z);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int type = int(mod(iTime/3.14159, 8.));\n    \n    if (fragCoord.x < iResolution.x/3. && fragCoord.y < iResolution.y/3.) {\n        vec2 uv = (vec2(1) - fragCoord/iResolution.xy*3.) * vec2(2., 1.) * 3.1415;\n        vec3 dir = vec3(sin(uv.y)*cos(uv.x), sin(uv.y)*sin(uv.x), cos(uv.y));\n        fragColor = sqrt(vec4(lighting(dir, type)));\n        return;\n    }\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-3,0,0);\n    \n    float zrot = iTime+3.14;\n    float yrot = .2;\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += cam*dist;\n        if (distance(p, init) > 10.) break;\n    }\n\n    vec3 n = norm(p);\n    \n    float shade = lighting(n, type);\n\n    fragColor = vec4(hit ? shade : 0.);\n    fragColor = sqrt(fragColor);\n    \n\n    float num = 1.-smoothstep(0.48, 0.51, char((uv+vec2(.85,-.3))*6.,48+type,iChannel1));\n    fragColor = max(fragColor, vec4(num));\n\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat torus(vec3 p, float r1, float r2) {\n    return length(vec2(length(p.xz)-r1, p.y)) - r2;\n}\n\nfloat super(vec3 x) {\n    return sqrt(length(x*x));\n}\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return super(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nfloat scene(vec3 p) {\n    vec3 p2 = abs(erot(p - vec3(0,0,.4), vec3(1,0,0), radians(45.)));\n    p2.yz = vec2(-smin(-p2.y,-p2.z, .1), smin(p2.y,p2.z,.1));\n    float bx = box(p2, vec3(.05, .75, .15))-.1;\n    float sph = length(p2) - .8;\n    float tor = torus(p - vec3(0,0,-.35), .78, .15);\n    return smin(tor, mix(bx, sph, .15), .1);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\n//////////////////////////////////////////\n//adapted from https://www.shadertoy.com/view/llySRh\nfloat char(vec2 p, int c, sampler2D sampler) {\n    if (p.x < .0 || p.x > 1. || p.y < 0. || p.y > 1.) return 1.;\n\treturn texture( sampler, p/16. + fract( vec2(c, 15-c/16) / 16. ) ).w;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGfz1.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 233, 233, 1478], [1480, 1480, 1537, 1537, 2757]], "test": "untested"}
{"id": "wtKBDD", "name": "APIC Reintegration tracking", "author": "michael0884", "description": "Basically combining APIC with reintegration tracking. Surprisingly works really well! The affine velocity matrix gives close to perfect angular momentum conservation, as can be seen from the rainbow vortices(the color shows velocity direction).", "tags": ["fluid", "particles", "reintegration", "mpm", "apic"], "likes": 51, "viewed": 1472, "published": 3, "date": "1614517115", "time_retrieved": "2024-07-30T19:35:24.291088", "image_code": "//MIT License\n//Copyright 2021 Mykhailo Moroz\n\n//This shader is a proof of concept of combining\n//reintegration tracking (https://michaelmoroz.github.io/Reintegration-Tracking/) with\n//affine particle-in-cell (https://www.math.ucla.edu/~jteran/papers/JSSTS15.pdf)\n\n//the reintegration part is used to advect the density and the APIC part is used to advect velocity\n//the usage of affine particle-to-grid transfers gives angular momentum conservation\n//you can see the vortices as the rainbow circles\n//the color here shows velocity direction & magnitude\n\n//the combination was surprisingly simple,\n//just replacing particles with cell density distributions was enough\n//the velocity advection part from reintegration tracking is not needed\n\n//the APIC velocity transfers use a quadratic kernel(linear is unstable)\n\n//PS you can technically add deformation gradients here too, as in MPM, to model solids,\n//but the diffusion resulting from reintegration tracking will \"melt\" the solids with time\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    P = floor(P);\n    \n    if(iMouse.z < 0.)\n    {\n        //P = iMouse.xy + 100.*(P/R.x - 0.5); \n    }\n    \n    float m = 0.0;\n    float rho = 0.0;\n    vec2 v = vec2(0.0);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = A(P + di);\n        vec4 data1 = B(P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        vec2 x0 = decode(data0.x) - fract(P);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        //update particle position\n        x0 = x0 + di + v0*dt;\n        \n        //find cell contribution\n        vec3 o = overlap(x0, vec2(1.0));\n        \n        m += m0*o.z;\n        \n        float w = k1(x0);\n        \n        v += (v0 + 4.0*B0*x0)*w;\n        rho += m0*w;\n    }\n    \n    float arg = 0.5*(atan(v.y, v.x)/PI + 1.0);\n    float d = 2.5*length(v);\n    vec3 fluid = hsv2rgb(vec3(arg, 0.5, d));\n    \n    C = vec4(mix( vec3(0.541,0.824,1.000),fluid, smoothstep(0.,0.5,sqrt(rho))), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R;\nvec4 Mouse;\nfloat time;\nint frame;\n\n#define A(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define B(p) texelFetch(iChannel1, ivec2(mod(p,R)), 0)\n\n#define CH(c, p) texelFetch(c, ivec2(mod(p,R)), 0)\n\n//loop in range\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.0\n#define max_vel 1.0\n#define rad 2\n\n#define diffusion 0.25\n#define gravity 0.005\n\n#define PI 3.14159265\n\n#define rest_rho 1.0\n#define eos_pressure 0.5\n\n//reduce rotation/shearing of low density particles\n//without this the vacuum and border state very chaotic, but it still works fine\n//in usual MPM that isn't necessary since the particles don't change mass\nfloat affine_str(float m)\n{\n    return 1.0; //full APIC\n    //return smoothstep(0.5*rest_rho,0.55*rest_rho,m);\n}\n\n//pressure equation of state\nfloat pressure(float rho)\n{\n    return 1.2*(rho - 0.25); //gas\n   // return eos_pressure*(pow(rho/rest_rho,4.) - 1.0); //Tait EOS (water)\n}\n\nvoid InitialConditions(inout float m, inout vec2 v, vec2 P)\n{\n    vec2 dx = P - R*vec2(0.3, 0.5);\n\n    float d = smoothstep(R.y*0.5, R.y*0.49, length(dx));  \n    m = 2.0*d;\n\n    v = d*0.3*normalize(vec2(dx.y,-dx.x));\n}\n\n//KERNEL FUNCTIONS\n\nfloat k0(vec2 dx) //linear kernel\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return k.x*k.y;\n}\n\nvec3 K0(vec2 dx) //linear kernel with the center of mass\n{\n    vec2 k = max(1.0 - abs(dx), 0.);\n    return vec3(dx*0.5, k.x*k.y);\n}\n\nfloat k1(vec2 dx) //quadratic kernel\n{\n    vec2 f = max(1.5 - abs(dx), 0.0);\n    vec2 k = min(max(0.75 - dx*dx, 0.5), 0.5*f*f);\n    return k.x*k.y;\n}\n\n//box size enstimator\nvec2 destimator(vec2 dx)\n{\n    return clamp(1.0 - 2.0*abs(dx), 0.001, 1.0);\n}\n\n//box overlap with center of mass\nvec3 overlap(vec2 dx, vec2 box)\n{\n    vec2 min0 = max(dx - box*0.5, -0.5); \n    vec2 max0 = min(dx + box*0.5, 0.5); \n    vec2 size = max(max0 - min0, 0.); \n    return vec3(0.5*(max0 + min0), size.x*size.y/(box.x*box.y));\n}\n\n//boundary\n#define border_h 3.\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -border_h-sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n\n    return bound;\n}\n\n#define h 2.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n//DATA PACKING\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\n//particle to grid\nvec4 P2G(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 x = vec2(0.0);\n    vec2 v = vec2(0.0);\n    float m = 0.0;\n    float rho = 0.0;\n    \n    range(i, -rad, rad) range(j, -rad, rad)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        vec4 data1 = CH(b, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float r0 = data0.w;\n        vec2 x0 = decode(data0.x);\n        vec2 v0 = decode(data1.x);\n        mat2 B0 = mat2(decode(data1.y),decode(data1.z)); //velocity gradient\n        \n        //estimate the shape of the distribution\n        vec2 box = destimator(x0);\n        \n        //update particle position\n        x0 = x0 + di + v0*dt;\n    \n        //find cell contribution\n        vec3 o = overlap(x0, box);\n         \n        //update distribution\n        x += m0*o.xy*o.z;\n        m += m0*o.z;\n        \n        //find grid node contribution\n        float w = k1(x0);\n        \n        //distribute momentum onto grid\n        v += (v0 + 4.0*B0*x0)*w*m0;\n        rho += m0*w;\n    }\n    \n    //normalize\n    if(rho > 0.0) v /= rho;\n    if(m > 0.0) x /= m;\n    \n    //initial conditions\n    if(frame < 1)\n    {\n        InitialConditions(m, v, P);\n    }\n    \n    v = (length(v)>max_vel)?normalize(v)*max_vel:v;\n    \n    return vec4(encode(x), m, encode(v), rho);\n}\n\n//grid to particle\nvec4 G2P(sampler2D a, sampler2D b, vec2 P)\n{\n    vec2 V = vec2(0.0);\n    mat2 B = mat2(0.0);\n    \n    vec4 data = CH(a, P);\n    float m = data.y;\n    vec2 x = decode(data.x);\n    \n    range(i, -rad, rad) range(j, -rad, rad)\n    {\n        //load data\n        vec2 di = vec2(i,j);\n        vec4 data0 = CH(a, P + di);\n        \n        //unpack data\n        float m0 = data0.y;\n        float rho = data0.w;\n        vec2 dx = x - di;\n        vec2 v0 = decode(data0.z);\n        \n        //find grid node contribution\n        float w = k1(dx);\n        \n        float P = clamp(pressure(rho), -0.5, 0.5);\n        vec2 F = rho*dx*P;\n        \n        //distribute velocities/forces to particles\n        V += (v0 + F*dt)*w;\n        B += affine_str(m)*mat2(v0*dx.x,v0*dx.y)*w;\n    }\n    \n    //gravity\n    V += vec2(0.0, -gravity)*dt;\n    \n    //push fluid\n    V += vec2(0.0, 0.5)*exp(-0.02*pow(distance(P, R*vec2(0.7,0.3)), 2.));\n    \n    if(Mouse.z > 0.)\n    {\n        vec2 dx = (Mouse.xy - P); \n        V += -0.05*exp(-0.05*length(dx))*dx*dt; \n    }\n    \n    //border \n    vec3 N = bN(P + x);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, V);\n    //V *= 1. - 0.1*exp(-N.z);\n    V += (0. + 1.5*max(vdotN, 0.0))*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    V = (length(V)>max_vel)?normalize(V)*max_vel:V;\n    return vec4(encode(V), encode(B[0]), encode(B[1]), 1.0);\n}\n\n", "buffer_a_code": "//Advect mass distributions and distrubute the momentum and density to grid\n\n//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Distribute grid velocities to the mass distributions\n\n//G2P\n\n//technically its more correct to do the force in the P2G step 2\n//but I didn't want to waste a buffer here\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Advect + P2G\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n   \n    C = P2G(iChannel0,iChannel1,P);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//G2P\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse; frame = iFrame;\n    P = floor(P);\n    C = G2P(iChannel0, iChannel1, P);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBDD.jpg", "access": "api", "license": "mit", "functions": [[996, 996, 1023, 1023, 1181]], "test": "untested"}
{"id": "ttKfDm", "name": "The vanishing of Ashlar Denoise", "author": "spawner64", "description": "Initial toy by @NuSan: \"The vanishing of Ashlar by NuSan, PC 4k intro made for Outline Online 2020\"\n\nAdded 2 serial EMA IIR filters with Variance Clipping (filtered temporal integration) to slightly denoise the output. It's smudgy, but less noisy.", "tags": ["intro", "4k", "outline", "denoise", "taa"], "likes": 10, "viewed": 729, "published": 3, "date": "1614516996", "time_retrieved": "2024-07-30T19:35:25.264485", "image_code": "// The vanishing of Ashlar by NuSan\n// PC 4k intro made for Outline Online 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth based on Oidos, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/lAvug7LKiIE\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    float time = iTime - .9;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*36./vec2(1920.,1080.), iResolution.y>720. ? 6. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.2,0.,1.)*0.1;\n    \n    // 'tone mapping'\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(.6));\n    \n    // fade in / fade out\n    col *= sat(time*2.) * sat(127.-time);\n    \n    // grain\n    vec3 grain = textureLod(iChannel1, uv, 0.0).rgb;\n    col = mix(col, grain, 0.125);\n    \n    fragColor = vec4(col, 1);\n    \n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    fragColor = renderVSplitLine(fragColor, vec3(0), 1.0, fragCoord.xy, phase * iResolution.x);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22886, "src": "https://soundcloud.com/antoine-zanuttini/the-vanishing-of-ashlar", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define EMA_IIR_INVERSE_CUTOFF_FREQUENCY        (0.785)      // 0.0 - 0.999\n#define VARIANCE_CLIPPING_COLOR_BOX_SIGMA       (0.975)      // 0.5 - 1.0\n#define SPLIT_SCREEN_SWEEP_SPEED                (1.5)\n\n#define SAMPLE_RGBA(sampler, coord) (texture((sampler), (coord)))\n#define SAMPLE_RGB(sampler, coord) (SAMPLE_RGBA((sampler), (coord)).rgb)\n\nfloat pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// https://www.shadertoy.com/view/4dSBDt\nvec3 RGBToYCoCg(vec3 RGB) {\n    float cTerm = 0.5 * 256.0 / 255.0;\n\tfloat Y  = dot(RGB, vec3( 1, 2,  1)) * 0.25;\n\tfloat Co = dot(RGB, vec3( 2, 0, -2)) * 0.25 + cTerm;\n\tfloat Cg = dot(RGB, vec3(-1, 2, -1)) * 0.25 + cTerm;\n\treturn vec3(Y, Co, Cg);\n}\n\n// https://www.shadertoy.com/view/4dSBDt\nvec3 YCoCgToRGB(vec3 YCoCg) {\n\tfloat cTerm = 0.5 * 256.0 / 255.0;\n\tfloat Y  = YCoCg.x;\n\tfloat Co = YCoCg.y - cTerm;\n\tfloat Cg = YCoCg.z - cTerm;\n\tfloat R  = Y + Co - Cg;\n\tfloat G  = Y + Cg;\n\tfloat B  = Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\n// based on https://www.shadertoy.com/view/4dSBDt\nvoid getVarianceClippingBounds(vec3 color, sampler2D colorSampler, ivec2 screenSpaceUV, float colorBoxSigma, out vec3 colorMin, out vec3 colorMax) {\n    vec3 colorAvg = color;\n    vec3 colorVar = color * color;\n\n    // Marco Salvi's Implementation (by Chris Wyman)\n    // unrolled loop version\n    \n    vec3 fetch = vec3(0);\n\n    // unwinded the for loop\n    {\n        // top\n        {\n            // left / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // center / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 0, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // right / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n\n        // center\n        {\n            // left / center\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1,  0), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            \n            // center / center is intentionally skipped\n            \n\n            // right / center\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1,  0), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n\n        // bottom\n        {\n            // left / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // center / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 0,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // right / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n    }\n\n    colorAvg *= 0.111111111;\n    colorVar *= 0.111111111;\n\n    vec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg * colorAvg));\n\tcolorMin = colorAvg - colorBoxSigma * sigma;\n\tcolorMax = colorAvg + colorBoxSigma * sigma;\n}\n\nvec4 renderVSplitLine(vec4 fragColor, vec3 lineColor, float lineThickness, vec2 screenSpaceUV, float splitScreenSpaceX) {\n    if (abs(screenSpaceUV.x - splitScreenSpaceX) < lineThickness) {\n        fragColor.rgb = lineColor;\n\t}\n\n    return fragColor;\n}", "buffer_a_code": "\n// Lower that value if it's too slow\n#define SAMPLE_COUNT 30.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,r,n=vec3(0);\nfloat d=10000.;\nvec3 boxid=vec3(0);\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// Compute octahedron distance from center, os is the size of each of the 4 'axis'\nfloat octaedge(vec3 p, vec4 os) {\n    \n    vec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\n    vec4 popo = p.xxyy*vv.xyww + p.yyzz*vv.zzxy;\n    popo=abs(popo)-os;\n          \n    float d = max(max(popo.x,popo.y),max(popo.z,popo.w));\n\n    return d;\n}\n\nvec4 osize1 = vec4(10);\nvec4 osize2 = vec4(2);\nvec3 boxrepeat = vec3(1,8,8);\nvec3 centerrepeat = vec3(.4,2,2);\nfloat boxanim = 0.;\nfloat centeranim = 0.;\nfloat boxtime = 0.;\nfloat insidedist(vec3 p) {\n\treturn max(octaedge(p, osize1), -octaedge(p, osize2));\n}\n\n// analytical box intersection\nvoid box(vec3 basepos, int side) {\n\t\n    // are we on the outside octahedron or the center one\n\tbool iscenter = octaedge(basepos,osize2)<.1;\n\tvec3 rep = iscenter ? centerrepeat : boxrepeat;\n\t\n    // main repetition is based on the x axis\n\tvec3 id2 = floor(basepos.x/rep.x)+vec3(1.7,3,7);\n\t\n    // then we can have integer multiplier subdivision without breaking the illusion\n\trep = (rep/(floor(rnd33(id2)*vec3(6))+1.));\n\t\n\tvec3 pos=vec3(0);\t\n    \n    // offset on yz axis, box animation\n\tvec2 ooo = fract(rnd(floor(basepos.x/rep.x)+.7)*vec2(1,3.7))*8.*7.;\n    ooo*=boxtime*vec2(1,1.3)*(iscenter?centeranim:boxanim)*rep.yz*0.03;\n    basepos.yz += ooo;\n\tpos.yz += ooo;\n  \n    // here we are applying the box repetition\n\tboxid = (floor(basepos/rep)+0.5)*rep;\n\n\tvec3 size = rep*0.4;\n  \n\tvec3 vr = r;\n\tpos=s+pos-boxid;\n  \n\tvec3 box=max((size-pos)/vr,(-size-pos)/vr);\n\tfloat bd = min(min(box.x,box.y),box.z);\n\tif(bd>0. && bd>d*float(side)) {\n\t\tvec3 cur = step(abs(pos+vr*d),size);\n\t\tif(side>0 ? (min(cur.x,min(cur.y,cur.z))>0.) : insidedist(s+r*bd)>0.) {\n\t\t\td=bd;\n\t\t\tn=-step(box-bd,vec3(0))*sign(pos+vr*d);\n\t\t}\n\t}\n}\n\n\n// analytical octrahedron intersection, with customisable size for each of the 4 'axis'\nvoid frontocta(vec4 size, int side) {\n    \n  \tvec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\n    vec4 invd = 1. / (r.xxyy*vv.xyww + r.yyzz*vv.zzxy);\n  \tvec4 popo = -s.xxyy*vv.xyww - s.yyzz*vv.zzxy;\n    \n    vec4 t0 = (popo - size) * invd;\n    vec4 t1 = (popo + size) * invd;\n    vec4 mi = min(t0, t1);\n    vec4 ma = max(t0, t1);\n\n    float front = min(min(ma.x,ma.y),min(ma.z,ma.w));\n    float back = max(max(mi.x,mi.y),max(mi.z,mi.w));\n    if(back>front) return;\n\n    if(side==0) {\n        back=front;\n    }\n\n    if(back<d && back > 0.) {\n        d = back;\n        vec4 vo = sign(t0-t1) * (side==0 ? step(-back,-ma) : step(back,mi));\n\n        n = vo.xxz - vo.yzw;\n        n.y += vo.y-vo.w;\n        n*=-sign(float(side)-.5)*vec3(0.817,0.5777,0.817); // = vec3(1,0.5 * 1.4142,1)/1.224 = 1.224 = cos(45) * tan(60)\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\t\n\tvec3 col = vec3(0);\n\t\t\n\tfloat time =iTime-.9;\n\tboxtime = time;\n\n    // Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, negative value makes the DOF bigger\n    // third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\n\tvec3 mot[16] = vec3[16]( \n\t\t\t\t\t\t vec3(12,2,14.19)\n\t\t\t\t\t\t,vec3(-4.7,11,29)\n\t\t\t\t\t\t,vec3(7,10,7.2)\n\t\t\t\t\t\t,vec3(11,-5,5.63)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(16.45,5,17.4)\n\t\t\t\t\t\t,vec3(-12,5,12.2)\n\t\t\t\t\t\t,vec3(2,5,12.2)\n\t\t\t\t\t\t,vec3(0.4,9,10)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(17.8,7,11.1)\n\t\t\t\t\t\t,vec3(-7.6,-20,15)\n\t\t\t\t\t\t,vec3(-13,-30,2.2)\n\t\t\t\t\t\t,vec3(7,40,3)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(17,20,6)\n\t\t\t\t\t\t,vec3(-5.4,50,15.4)\n\t\t\t\t\t\t,vec3(16,30,13)\n\t\t\t\t\t\t,vec3(12,10,7)\n\t\t\t\t\t\t);\n\n\n\tfloat light = 0.;\n\tint section = int(min(16.,time/8.));\n\tfloat rest = mod(time,8.);\n\n\tvec3 mval = mot[section];\n\tif(section>5 && section<9) mval.z+=floor(rest)*2.2;\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\n\t\t\n\t//////// SIZES ////////\n\tif(section==0) osize2 = vec4(6);\n\t\n    // extruding the shapes\n\tfloat push2 = max(0.,time-48.)*1.5;\n\tif(section>7) push2 = 10000.;\n\tfloat push = 2.+max(0.,time-40.)*.5+push2;\n\tfloat decol=max(0.,time-70.);\n\tif(section>14) {\n\t\tdecol=0.;\n\t\tpush=0.;\n\t\tpush2=0.;\n\t}\n\n\tif(section>4)osize2 = vec4(2,push,push,2);\n\tif(section>6)osize1 = vec4(10,10.+push2,10.+push2,10);\n\t\n\t//////// REPEATS ////////\n\tboxrepeat = rnd23(vec2(floor(mval.z),0))*50.;\n\tcenterrepeat = pow(rnd23(vec2(0,fract(mval.z)*31.5+28.)),vec3(2))*10.+.2;\n\n\tif(section==3) osize1=vec4(20);\n\t\t\n\t//////// NIGHT ////////\n\tfloat skydist = 1.;\n\tfloat bright=0.;\n\tif(section>8 && section<15) {\n\t\tboxanim = .3;\n\t\tboxrepeat *= 2.;\n\t\tcenterrepeat *= 10.;\n\t\tif(section>11) {\n            // transition to night section, with light appearing\n\t\t\tlight = sat((time/8.-12.));\n\t\t\tskydist = section>12?200.:20.*light;\n\t\t\tosize1 = vec4(20,push2,push2,20);\n\t\t\tboxanim=0.;\n\t\t\tif(section==14) {\n                // center brightening and vanishing\n\t\t\t\tcenterrepeat.xy*=1.1;\n\t\t\t\tbright=pow(sat(time/8.-14.07),2.);\n\t\t\t\tosize2.xw = vec2(2.-sqrt(bright+.01-uv.y*.02+uv.x*.001)*2.3,17.*bright+2.);\n\t\t\t}\n\t\t}\n\t}\n\tcenteranim = section>2?(section>7?0.3:0.3):0.;\n\n\t//////// CAMERA ANIMATION ////////\n    // array value is a seed to an offset on lissajous curves, with various speed factor\n\tfloat avance = pcam.x*200. + (rest+(fract(mval.x+.5)-.5)*8.) * (pcam.y-0.2);\n\tif(mval.x<0.) avance += floor(rest/4.)*3.;\n\t\n\tfloat focusdist = abs(mval.y);\n\tfloat dofamount = mval.y>0. ? .05 : .15;\n    // extrapush is used to put the camera outside the room without colliding, so we can zoom more\n\tfloat extrapush = max(fract(pcam.z*17.23)-.5,0.)*15.;\n\tfloat fov = pcam.z*1.5+.5 + extrapush/2.;\n\tvec3 bs=vec3(0,-1.5 + sin(avance*.2)*1.,0);\n\tvec3 t = vec3(0,-1.5 + sin(avance*.3)*3.,0);\n\n    // lissajous curve to makes interesting camera motion\n\tbs.x += 5.*sin(avance*.4 + 0.7);\n\tbs.z += 5.*sin(avance*.9);\n\n    // camera target is following the same curve in front of the camera but with a random factor to focus more on the center\n\tfloat dt=max(0.,fract(pcam.z*24.81)-.2)*6.;\n\tt.x += dt*sin(avance*.4 + 0.7 + 1.);\n\tt.z += dt*sin(avance*.9 + 1.);\n\t\n\t//////// SKYDIVING ////////\n\tvec3 govec = vec3(-1,1.41,-1);\n\tvec3 poff = govec*decol*min(2.,decol)*2.5;\n\tt -= poff + govec*10.*(step(2.,decol)-bright);\n\tbs -= poff;\n    \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(t-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n\n\t// Main path tracing loop, do many samples to reduce the noise\n    float ZERO=min(0.,iTime); // this is a trick to force the GPU to keep the loop\n    // instead of trying to compile a giant shader by duplicating what's inside\n\tfor(float i=ZERO; i<SAMPLE_COUNT; ++i) {\n    \t\t\n\t\ts=bs;\t\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\n\t\t// DOF\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tr=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\n\n\t\ts += (r-cz) * extrapush;\n\t\t\n        // number of bounces is 3\n\t\tfor(float j=0.; j<3.; ++j) {\n\t\t\t////////// TRACE //////////\n\t\t\td=100000.;\n  \n            // find instersection with geometry\n            \n            // first test if we started inside a repeating box\n\t\t\tbox(s,-1);\n  \n            // then intersect with the background octahedron\n\t\t\tfrontocta(osize1, 0);\n  \n            // save that intersection for latter\n\t\t\tfloat d2=d;\n\t\t\tvec3 s2=s;\n\t\t\tvec3 n2=n;\n\n            // intersect with the center shape\n\t\t\tfrontocta(osize2, 1);\n  \n            // now use that position to carve the repeating box\n\t\t\tbox(s+r*d,1);\n\n            // if intersection position is outside the center octahedron, it means that we went trough the shape\n            // so we back to the background intersection\n\t\t\tif(octaedge(s+r*d,osize2)>0.01) {\n\t\t\t\td=d2;\n\t\t\t\tn=n2;\n                // last possible repeating box intersection on the background octahedron\n\t\t\t\tbox(s+r*d,1);\n\t\t\t}\n    \n            // and finally the ground plane intersection\n\t\t\tfloat curplane=(1.1-s.y)/r.y;\n\t\t\tif(curplane>0. && curplane<d) {\n\t\t\t\td=curplane;\n\t\t\t\tn=sign(s.y)*vec3(0,1,0);\n\t\t\t}\n    \t\t\t\n\t\t\tif(d>10000.) break;\n\t\t\t\n\t\t\t// go to the intersection point\n\t\t\ts = s + r * d;\n\t\t\n            // test if we are outside the 'sky distance'\n\t\t\tfloat edge1 = octaedge(s,osize1);\t\t\t\t\t\t\n\t\t\tif(edge1>skydist) {\n                // if so, we just push the sky color and early out\n\t\t\t\tcol += mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tbreak;\n\t\t\t}\n\n            // if we are in the light section\n\t\t\tif(light>0.) {\n\t\t\t\tfloat middle = step(7.,edge1);\n\n                // center burning\n\t\t\t\tcol += bright * step(1.,-edge1) * vec3(.5,.7,1)*3.;\n\t\t\t\t\n                // side lights in two colors\n\t\t\t\tcol += middle * vec3(0.4,0.5,0.8) * 1.2 * step(0.7,rnd(dot(boxid,vec3(1,4,7))+floor(time)*0.1));\n\t\t\t\tcol += middle * vec3(0.2,0.5,0.9) * 1.2 * step(0.1,fract(.2+boxid.z*0.01 + floor(time)*13.2)*3.-1.5);\t\t\t\n\t\t\t}\n\n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2.) break;\n\n            // roughness computing, depending on if we are on the center shape or not\n\t\t\tvec3 grid = step(fract(s*4.-.1),vec3(.8));\n\t\t\tfloat rough = octaedge(s,osize2)<.1 ? .5 : mix(1.,0.45*rnd31(floor(s*4.-.1)*27.33),min(grid.x,min(grid.y,grid.z)));\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375.)+fract(time))-.5)*rough);\n\t\t}\n\t}\n\tcol *= .6/SAMPLE_COUNT;\n\t\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    if (normalizedSpaceUV.x < phase) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n    history = clamp(history, colorMin, colorMax);\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    float phase = sin(iTime * SPLIT_SCREEN_SWEEP_SPEED) * 0.5 + 0.5;\n    if (normalizedSpaceUV.x < phase) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n    history = clamp(history, colorMin, colorMax);\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[680, 680, 737, 737, 1686]], "test": "untested"}
{"id": "tlKBWm", "name": "Packed Single Rotation Rule", "author": "SlackermanzCA", "description": "The 'Single Rotation Rule' using a 1:1 pixel ratio by encoding/decoding the block phase and state information\nhttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule\nhttps://www.reddit.com/user/slackermanz/\nhttps://www.reddit.com/r/cellular_automata\n", "tags": ["2d", "simulation", "diffusion", "automata", "cellular", "rotation", "conway", "gameoflife", "cellularautomata", "single", "cgol", "singlerotation"], "likes": 5, "viewed": 561, "published": 3, "date": "1614510850", "time_retrieved": "2024-07-30T19:35:26.396459", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Packed Single Rotation Rule\n//\tTYPE:Encoded Margolus Neighbourhood Block Cellular Automata\n//\tRULE:Single Rotation Rule\n//\t\thttp://dmishin.blogspot.com/2013/11/the-single-rotation-rule-remarkably.html\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\nfloat margo() {\n\tfloat\tstates\t\t= 15.0;\n\tfloat\tblock_phase\t= mod(float(iFrame), 2.0);\n\n//\tGet the values of the Red Channel pixels that contain the encoded substates for the Margolus Neighbourhood\n\tfloat[4] block_neighbourhood = float[4]\n\t(\tround(gdv(-1.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0, -1.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv(-1.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states),\n\t\tround(gdv( 0.0+block_phase*1.0,  0.0+block_phase*1.0, 0, 1.0) * states)\t);\n\n//\tContainers for the substates\n\tfloat[4] neighbour_0_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_1_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_2_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\tfloat[4] neighbour_3_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tDecode the substates (binary representation) of the neighbourhood pixels' values\n\tfloat m = states + 1.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tneighbour_0_substates[i] = round( mod( (block_neighbourhood[0]), m ) / (m-1.0) );\n\t\tneighbour_1_substates[i] = round( mod( (block_neighbourhood[1]), m ) / (m-1.0) );\n\t\tneighbour_2_substates[i] = round( mod( (block_neighbourhood[2]), m ) / (m-1.0) );\n\t\tneighbour_3_substates[i] = round( mod( (block_neighbourhood[3]), m ) / (m-1.0) );\n\t\tm = m / 2.0; }\n\n//\tContainer for the new/recombined substate\n\tfloat[4] new_substates = float[4] ( 0.0, 0.0, 0.0, 0.0 );\n\n//\tGet the relevant substates\n\tnew_substates[0] = neighbour_0_substates[3];\n\tnew_substates[1] = neighbour_1_substates[2];\n\tnew_substates[2] = neighbour_2_substates[1];\n\tnew_substates[3] = neighbour_3_substates[0];\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tApply the 'Single Rotation Rule' transition\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tIf the current-phased block of substates contains only one value ...\n\tfloat sum\t= new_substates[0] \n\t\t\t\t+ new_substates[1] \n\t\t\t\t+ new_substates[2] \n\t\t\t\t+ new_substates[3];\n\n//\tContainer for the transformed substates\n    float[4] final_substates;\n        final_substates[0] = new_substates[0];\n        final_substates[1] = new_substates[1];\n        final_substates[2] = new_substates[2];\n        final_substates[3] = new_substates[3];\n\n//\tIf the condition is met, apply the transformation, remapping the substates within the block\n    if(sum == 1.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\tAdditional transition / SRR variant\n    if(sum == 3.0) {\n        final_substates[0] = new_substates[1];\n        final_substates[1] = new_substates[3];\n        final_substates[2] = new_substates[0];\n        final_substates[3] = new_substates[2]; }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPack the pixel from the final substate data\n\tfloat res\t= 0.0;\n\tfloat n \t= (states + 1.0) / 2.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tres = res + final_substates[i] * n;\tn = n / 2.0; }\n\tres = res / states;\n\n//\tReturn the encoded pixel value\n\treturn res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tPrecision\n\tfloat \tpsn\t\t= 250.0;\n    \n//\tMinimum Precision Value : (1.0 / psn);\n\tfloat \tmnp\t\t= 0.004;\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, 1.0 );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, 1.0 );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, 1.0 );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\tOutput value\n\tres_r = margo();\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0r \t= nhd( vec2( 4.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, 1.0 );\n\tfloat \tn0rw \t= n0r[0] / n0r[2];\n\tres_g = (res_r > 0.0) ? res_g + mnp * 2.0 : (mod(float(iFrame),32.0) == 0.0) ? res_g - mnp * 2.0 : res_g;\n\tres_g = (n0rw > 0.06) ? res_g - mnp * 4.0 : res_g;\n\tres_b = (res_r > 0.0) ? 1.0 : res_b - mnp * 2.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 24.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 112.0) { res_r = reseed(); }\n    if (iFrame == 0 && length(vec2(400.0,225.0) - fragCoord) < 96.0) { res_r = 0.0; }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1271, 1271, 1328, 1378, 1508]], "test": "untested"}
{"id": "ttVBDw", "name": "Sunday fractals 2", "author": "mrange", "description": "License CC0: Sunday Fractals 2\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nSABS from ollj", "tags": ["2d", "fractals"], "likes": 9, "viewed": 413, "published": 3, "date": "1614505148", "time_retrieved": "2024-07-30T19:35:27.165403", "image_code": "// License CC0: Sunday Fractals 2\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// SABS from ollj\n\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x,x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat hash(float co) {\n  co += 1234.;\n  return fract(sin(dot(co, 12.9898)) * 13758.5453);\n}\n\nfloat maxComp(vec3 c) {\n  return max(c.x, max(c.y, c.z));\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat fractal(vec2 p, vec2 c, vec2 ot) {\n  vec2 u = p;\n  float lx = 1E6;\n  float ly = 1E6;\n  float lp = 1E6;\n  const int maxi = 9;\n  float s = 1.0;\n\n  for (int i = 0; i < maxi; ++i) {\n    float m = dot(u, u);\n    u = SABS(u, 0.075)/m + c;\n    s *= m;\n    float dx = abs(u.x - ot.x);\n    float dy = abs(u.y - ot.y);\n    float dp = abs(1.65-length(u));\n    if(m > 0.033) {\n      lx = min(lx, dx);\n      ly = min(ly, dy);\n    }\n    lp = min(lp, dp);\n  }\n  \n  float l = lp;\n  l = pmin(l, lx, 0.05);\n  l = pmin(l, ly, 0.05);\n  l -= 0.025;\n  return l*s;\n}\n\nfloat df(vec2 p, vec2 c, float hh) {\n  p *= ROT(TIME*TAU/120.0);\n  float rep = 2.0*round(mix(3.0, 12.0, hh));\n  float sm = 0.025*10.0/rep;\n  smoothKaleidoscope(p, sm, rep);\n  p *= ROT(hh*TAU+0.05);\n  vec2 u = p;\n  vec2 ot = mix(1.5, -1.5, hh)*vec2(cos(TAU*hh*sqrt(0.5)), sin(TAU*hh));\n  return fractal(p, c, ot);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 color(vec2 p, vec2 c, float hh, float aa) {\n  float d = df(p, c, hh);\n  vec3 col = vec3(0.0);\n  float l2 = tanh_approx(L2(p));\n  vec3 hsv = vec3(0.0+hh+l2*0.5, mix(0.5, 0.75, l2), 1.0);\n  vec3 glowCol = hsv2rgb(hsv)*2.0;\n//  vec3 glowCol = vec3(0.5, 0.5, 1.0)*mix(2.0, 2.0, l2);\n  glowCol = d < 0.0 ? glowCol : glowCol.zxy;\n  col += glowCol*exp(-mix(300.0, 900.0, l2)*max(abs(d), 0.0));\n  col += glowCol*abs(tanh_approx(d));\n//  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  const float period = 10.0;\n  float nperiod = floor(TIME/period);\n  float tperiod = mod(TIME, period);\n  float hh = hash(nperiod);\n  vec2  c = vec2(-1.30,  -1.30)+0.2*vec2(sin(0.05*TIME+TAU*hh*vec2(1.0, sqrt(0.5)*0.5)));\n  \n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*aa;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*aa;\n  \n  vec3 col = color(p+o1, c, hh, aa);\n  float mc = maxComp(clamp(col, 0.0, 1.0));\n  float dmc = length(vec2(dFdx(mc), dFdy(mc)))/(mc+0.075);\n  if (dmc > 0.5) {\n    col += color(p-o1, c, hh, aa);\n    col += color(p+o2, c, hh, aa);\n    col += color(p-o2, c, hh, aa);\n    col *= 0.25;\n//    col += vec3(1.0, 0.0, 0.0);\n  }\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 0.5, tperiod);\n  col *= 1.0-smoothstep(period-0.5, period, tperiod);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBDw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[513, 513, 535, 535, 604], [606, 606, 629, 629, 665], [667, 667, 689, 689, 858], [860, 860, 888, 908, 984], [986, 986, 1025, 1025, 1110], [1112, 1112, 1151, 1151, 1180], [1182, 1182, 1212, 1212, 1239], [1241, 1241, 1263, 1263, 1307], [1309, 1309, 1330, 1330, 1375], [1377, 1377, 1422, 1422, 1576], [1578, 1578, 1639, 1639, 1852], [1854, 1854, 1894, 1894, 2403], [2405, 2405, 2441, 2441, 2719], [2721, 2721, 2757, 2757, 2990], [2992, 2992, 3040, 3040, 3493], [3495, 3495, 3547, 3547, 4486]], "test": "untested"}
{"id": "tlycDK", "name": "Trilinear Surface Intersect", "author": "oneshade", "description": "Analytic intersection with the zero isosurface of a trilinear interpolation. It involves solving a cubic.", "tags": ["raytracing", "ray", "intersection", "cubic", "trilinear", "analytic", "interpolation"], "likes": 8, "viewed": 220, "published": 3, "date": "1614499058", "time_retrieved": "2024-07-30T19:35:28.031088", "image_code": "/*\nI finally have a working ray vs. trilinear surface intersector!\n\na, b, c, d, e, f, g, and h correspond to the corners of a cube through which they\nare trilinearly interpolated. ASCII figure showing the orientation:\n\n c        d\n |\\‾‾‾‾‾‾‾|\\\n | \\        \\\n |  \\g    |  \\h\n |   |‾‾‾‾‾‾‾‾|\na|- -| - -|b  |\n  \\  |     \\  |\n   \\ |      \\ |\n    \\|_______\\|\n    e         f\n\na is at (0, 0, 0) and h is at (1, 1, 1).\n*/\n\n// Cubic solver\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float aa = a * a, bb = b * b;\n\n    float denom = 3.0 * aa;\n    float inflect = b / (3.0 * a);\n\n    float p = c / a - bb / denom;\n    float q = bb * b / (13.5 * aa * a) - b * c / denom + d / a;\n    float ppp = p * p * p, qq = q * q;\n\n    float p2 = abs(p);\n    float v1 = 1.5 / p * q;\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, 1.0);\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (p < 0.0) roots[0] = sign(q) * cosh(acosh(v2 * -sign(q)) / 3.0);\n        else roots[0] = sinh(asinh(v2) / 3.0);\n        roots[0] = -2.0 * sqrt(p2 / 3.0) * roots[0] - inflect;\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / p)) / 3.0; // 0π/3,       2π/3,               4π/3\n        roots = vec4(2.0 * sqrt(-p / 3.0) * cos(vec3(ac, ac - 2.09439510239, ac - 4.18879020479)) - inflect, 3.0);\n    }\n\n    return roots;\n}\n\n// mla's suggestion to reverse the coefficients and reciprocate the results\n// Better at handling extreme cases and seems to work fine here\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n/*\n// Old trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Basically three nested linear interpolations expanded and regrouped\n    float coeff1 = -a * u * v * w + b * u * v * w + c * u * v * w - d * u * v * w + e * u * v * w - f * u * v * w - g * u * v * w + h * u * v * w;\n    float coeff2 = a * u * w + a * v * w + a * u * v - a * x * v * w - a * u * y * w - a * u * v * z - b * u * w - b * u * v + b * x * v * w + b * u * y * w + b * u * v * z - c * v * w - c * u * v + c * x * v * w + c * u * y * w + c * u * v * z + d * u * v - d * x * v * w - d * u * y * w - d * u * v * z - e * u * w - e * v * w + e * x * v * w + e * u * y * w + e * u * v * z + f * u * w - f * x * v * w - f * u * y * w - f * u * v * z + g * v * w - g * x * v * w - g * u * y * w - g * u * v * z + h * x * v * w + h * u * y * w + h * u * v * z;\n    float coeff3 = -a * w - a * u + a * x * w + a * u * z - a * v + a * y * w + a * v * z + a * x * v + a * u * y - a * x * y * w - a * x * v * z - a * u * y * z + b * u - b * x * w - b * u * z - b * x * v - b * u * y + b * x * y * w + b * x * v * z + b * u * y * z + c * v - c * y * w - c * v * z - c * x * v - c * u * y + c * x * y * w + c * x * v * z + c * u * y * z + d * x * v + d * u * y - d * x * y * w - d * x * v * z - d * u * y * z + e * w - e * x * w - e * u * z - e * y * w - e * v * z + e * x * y * w + e * x * v * z + e * u * y * z + f * x * w + f * u * z - f * x * y * w - f * x * v * z - f * u * y * z + g * y * w + g * v * z - g * x * y * w - g * x * v * z - g * u * y * z + h * x * y * w + h * x * v * z + h * u * y * z;\n    float coeff4 = a - a * z - a * x + a * x * z - a * y + a * y * z + a * x * y - a * x * y * z + b * x - b * x * z - b * x * y + b * x * y * z + c * y - c * y * z - c * x * y + c * x * y * z + d * x * y - d * x * y * z + e * z - e * x * z - e * y * z + e * x * y * z + f * x * z - f * x * y * z + g * y * z - g * x * y * z + h * x * y * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\n// Normalized partial derivatives with respect to x, y, and z of:\n// f(x, y, z) = a - az - ax + axz - ay + ayz + axy - axyz + bx - bxz - bxy + bxyz + cy - cyz - cxy + cxyz + dxy - dxyz + ez - exz - eyz + exyz + fxz - fxyz + gyz - gxyz + hxyz\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float pdx = -a + a * z + a * y - a * y * z + b - b * z - b * y + b * y * z - c * y + c * y * z + d * y - d * y * z - e * z + e * y * z + f * z - f * y * z - g * y * z + h * y * z;\n    float pdy = -a + a * z + a * x - a * x * z - b * x + b * x * z + c - c * z - c * x + c * x * z + d * x - d * x * z - e * z + e * x * z - f * x * z + g * z - g * x * z + h * x * z;\n    float pdz = -a + a * x + a * y - a * x * y - b * x + b * x * y - c * y + c * x * y - d * x * y + e - e * x - e * y + e * x * y + f * x - f * x * y + g * y - g * x * y + h * x * y;\n\n    return normalize(vec3(pdx, pdy, pdz));\n}\n*/\n\n// Simplified trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    // Reused values (reusing themselves too :D)\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv = u * v;\n    float xvuy = x * v + u * y;\n\n    // Coefficients of the cubic intersection function\n    float coeff1 = q * uv * w;\n    float coeff2 = dbac * uv + (fbae * u + gcae * v) * w + (xvuy * w + uv * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\n/*\nNormalized partial derivatives with respect to x, y, and z of:\nf(x, y, z) = a - az - ax + axz - ay + ayz + axy - axyz + bx - bxz - bxy + bxyz + cy - cyz - cxy + cxyz + dxy - dxyz + ez - exz - eyz + exyz + fxz - fxyz + gyz - gxyz + hxyz\n*/\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\n// To see only the unit cube, change the return statement to:\n// return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(0.5)));\n// You may want to bring the ray origin closer to the origin though.\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(2.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - screenCenter) / iResolution.y * 3.14 : vec2(-0.85, -0.5);\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    ro += 0.5;\n\n    // Isovalues\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    vec4 intersect = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    if (intersecting) {\n        vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlycDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 462, 527, 527, 1380], [1382, 1522, 1588, 1588, 1731], [4944, 5000, 5149, 5149, 5967], [5969, 6211, 6347, 6347, 6734], [6736, 6928, 6974, 6974, 7038], [7040, 7040, 7095, 7095, 8706]], "test": "untested"}
{"id": "wtKfWw", "name": "Fork Re Generat anotherpla 166", "author": "anotherplatypus", "description": "Experimenting on clubber.js and some shaders alters by Wizgrav to function with it.\nClubber rewired version of the awesome shader by kali  https://www.shadertoy.com/view/Xtf3Rn This guy is the math sculptor <3\n\nBoom Generators: https://goo.gl/XH88Gf", "tags": ["raymarching", "fractal", "clubber"], "likes": 2, "viewed": 342, "published": 3, "date": "1614497298", "time_retrieved": "2024-07-30T19:35:28.807014", "image_code": "\n// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R abs(sin(iTime))\n#define CLUBBER_G abs(cos(iTime))\n#define CLUBBER_B abs(sin(iTime*2.))\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n// \"GENERATORS REDUX\" by Kali \n\n// Reworked by eiffie to run faster and under ANGLE:\n//\n// -Made the sphere raytraced \n// -Soft AO shadows\n// -Various great optimizations\n// \n// Thanks eiffie!!!\n\n\n// Original description:\n// Same fractal as \"Ancient Temple\" + rotations, improved shading \n// (better coloring, AO and  shadows), some lighting effects, and a path for the camera  \n// following a liquid metal ball. \n\n\n//#define ENABLE_HARD_SHADOWS // turn off to enable faster AO soft shadows \n//#define ENABLE_VIBRATION\n//#define ENABLE_POSTPROCESS // Works better on window view rather than full screen\n\n\n#define RAY_STEPS 70\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(.85,.9,1.)\n#define AMBIENT_COLOR vec3(.8,.83,1.)\n#define FLOOR_COLOR vec3(1.,.7,.9)\n#define ENERGY_COLOR vec3(1.,.7,.4)\n#define BRIGHTNESS .9\n#define GAMMA 1.3\n#define SATURATION .85\n\n\n#define detail .00005\n#define t iTime*.25\n\n\n\nvec3 lightdir=normalize(vec3(0.5,-0.3,-1.));\nvec3 ambdir=normalize(vec3(0.,0.,1.));\nconst vec3 origin=vec3(0.,3.11,0.);\nvec3 energy=vec3(0.01);\n#ifdef ENABLE_VIBRATION\nfloat vibration=sin(iTime*60.)*.0013;\n#else\nfloat vibration=0.;\n#endif\nfloat det=0.0;\nvec3 pth1;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nvec3 path(float ti) {\nreturn vec3(sin(ti),.4-sin(ti*.632)*.3,cos(ti*.5))*.5;\n}\n\nfloat Sphere(vec3 p, vec3 rd, float r){//A RAY TRACED SPHERE\n\tfloat b = dot( -p, rd );\n\tfloat inner = b * b - dot( p, p ) + r * r;\n\tif( inner < 0.0 ) return -1.0;\n\treturn b - sqrt( inner ) / dot(CLUBBER_R,CLUBBER_G);\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.xz=abs(.5-mod(tpos.xz,1.));\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n\tfor (int i=0; i<8; i++) {//LOWERED THE ITERS\n\t\tp.xyz = abs(p.xyz)-vec3(-0.02,1.98,-0.02);\n\t\tp=p*(2.0+vibration*y)/clamp(dot(p.xyz,p.xyz),.4,1.)-vec4(0.5,1.,0.4,0.);\n\t\tp.xz*=mat2(-0.416, -0.91,mix(0.7,.91,CLUBBER_G),mix(-0.8,-.416,CLUBBER_B));\n\t}\n\tfloat fl=pos.y-3.013;\n\tfloat fr=(length(max(abs(p.xyz)-vec3(0.1,5.0,0.1),vec3(0.0)))-0.05)/p.w;//RETURN A RRECT\n\t//float fr=length(p.xyz)/p.w;\n\tfloat d=min(fl,fr);\n\td=min(d,-pos.y+3.95);\n\tif (abs(d-fl)<.001) hid=1.;\n\treturn vec2(d,hid);\n}\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\tfloat t1=Sphere((pos-.005*sdir)-pth1,-sdir,0.015);\n\tif (t1>0. && t1<.5) {\n\t\tvec3 sphglowNorm=normalize(pos-t1*sdir-pth1);\n\t\tsh=1.-pow(max(.0,dot(sphglowNorm,sdir))*1.2,3.);\n\t} \n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<.6 && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 14.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\nfloat texture2(vec3 p) {\n\tp=abs(.5-fract(p*10.));\n\tvec3 c=vec3(3.);\n\tfloat es, l=es=0.;\n\tfor (int i = 0; i < 10; i++) { \n\t\t\tp = abs(p + c) - abs(p - c) - p; \n\t\t\tp/= clamp(dot(p, p), .0, 1.);\n\t\t\tp = p* -1.5 + c;\n\t\t\tif ( mod(float(i), 2.) < 1. ) { \n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-1. / abs(l - pl));\n\t\t\t}\n\t}\n\treturn es;\n}\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL\n\t#ifdef ENABLE_HARD_SHADOWS\n\t\tfloat sh=shadow(p, lightdir);\n\t#else\n\t\tfloat sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS\n\t#endif\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh;\n\tfloat y=3.35-p.y;\n\tvec3 amb=max(.5,dot(dir,-n))*.5*AMBIENT_COLOR;\n\tif (hid<.5) {\n\t\tamb+=max(0.2,dot(vec3(0.,1.,0.),-n))*FLOOR_COLOR*pow(max(0.,.2-abs(3.-p.y))/.2,1.5)*2.;\n\t\tamb+=energy*pow(max(0.,.4-abs(y))/.4,2.)*max(0.2,dot(vec3(0.,-sign(y),0.),-n))*2.;\n\t}\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,10.);\n\tvec3 col;\n\tfloat energysource=pow(max(0.,.04-abs(y))/.04,4.)*2.;\n\tif (hid>1.5) {col=vec3(1.); spec=spec*spec;}\n\telse{\n\t\tfloat k=texture2(p)*.23+.2; \n\t\tk=min(k,1.5-energysource);\n\t\tcol=mix(vec3(k,k*k,k*k*k),vec3(k),.3);\n\t\tif (abs(hid-1.)<.001) col*=FLOOR_COLOR*1.3;\n\t}\n\tcol=col*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\tif (hid<.5) { \n\t\tcol=max(col,energy*2.*energysource);\n\t}\n\tcol*=min(1.,ao+length(energy)*.5*max(0.,.1-abs(y))/.1);\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat ey=mod(t*.5 + (CLUBBER_A),1.);\n\tfloat glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\tvec3 origdir=dir,origfrom=from,sphNorm;\n\t\n\t//FAKING THE SQUISHY BALL BY MOVING A RAY TRACED BALL\n\tvec3 wob=cos(dir*500.0*length(from-pth1)+(from-pth1)*250.+iTime*10.)*0.0005;\n\tfloat t1=Sphere(from-pth1+wob,dir,mix(0.,0.02,CLUBBER_R));\n\tfloat tg=Sphere(from-pth1+wob,dir,mix(0.0,0.03,CLUBBER_R));\n\tif(t1>0.){\n\t\tref=1.0;from+=t1*dir;sphdist=t1;\n\t\tsphNorm=normalize(from-pth1+wob);\n\t\tdir=reflect(dir,sphNorm);\n\t} \n\telse if (tg>0.) { \n\t\tvec3 sphglowNorm=normalize(from+tg*dir-pth1+wob);\n\t\tglow+=pow(max(0.,dot(sphglowNorm,-dir)),5.);\n\t};\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<3.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*60.)*(1.+ref*5.);\n\t\t\ttotdist+=d.x; \n\t\t\tenergy=ENERGY_COLOR*(1.5+sin(iTime*20.+p.z*10. + 6.*(CLUBBER_R)))*.25;\n\t\t\tif(d.x<0.015)glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t\tif (d.y<.5 && d.x<0.03){//ONLY DOING THE GLOW WHEN IT IS CLOSE ENOUGH\n\t\t\t\tfloat glw=min(abs(3.35-p.y-ey),abs(3.35-p.y+ey));//2 glows at once\n\t\t\t\teglow+=max(0.,.03-d.x)/.03*\n\t\t\t\t(pow(max(0.,.05-glw)/.05,5.)\n\t\t\t\t+pow(max(0.,.15-abs(3.35-p.y))/.15,8.))*1.5;\n\t\t\t}\n\t\t}\n\t}\n\tfloat l=pow(max(0.,dot(normalize(-dir.xz),normalize(lightdir.xz))),2.);\n\tl*=max(0.2,dot(-dir,lightdir));\n\tvec3 backg=.5*(1.2-l)+LIGHT_COLOR*l*.7;\n\tbackg*=AMBIENT_COLOR;\n\tif (d.x<=det) {\n\t\tvec3 norm=normal(p-abs(d.x-det)*dir);//DO THE NORMAL CALC OUTSIDE OF LIGHTING (since we already have the sphere normal)\n\t\tcol=light(p-abs(d.x-det)*dir, dir, norm, d.y)*exp(-.2*totdist*totdist); \n\t\tcol = mix(col, backg, 1.0-exp(-1.*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t}\n\tvec3 lglow=LIGHT_COLOR*pow(l,30.)*.5;\n\tcol+=glow*(backg+lglow)*1.3;\n\tcol+=pow(eglow,2.)*energy*.015;\n\tcol+=lglow*min(1.,totdist*totdist*.3);\n\tif (ref>0.5) {\n\t\tvec3 sphlight=light(origfrom+sphdist*origdir,origdir,sphNorm,2.);\n\t\tcol=mix(col*.3+sphlight*.7,backg,1.0-exp(-1.*pow(sphdist,1.5)));\n\t}\n\treturn col; \n}\n\nvec3 move(inout mat2 rotview1,inout mat2 rotview2) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tvec3 advec=normalize(adv-go);\n\tfloat an=atan(advec.x,advec.z);\n\trotview1=mat2(cos(an),sin(an),-sin(an),cos(an));\n\t\t  an=advec.y*1.7;\n\trotview2=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpth1 = path(t+.3)+origin+vec3(0.,.01,0.);\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tvec2 uv2=uv;\n#ifdef ENABLE_POSTPROCESS\n\tuv*=1.+pow(length(uv2*uv2*uv2*uv2),4.)*.07;\n#endif\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.);\n\tmat2 rotview1, rotview2;\n\tvec3 from=origin+move(rotview1,rotview2);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tdir.yz*=rotview2;\n\tdir.xz*=rotview1;\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n#ifdef ENABLE_POSTPROCESS\n\tvec3 rain=pow(texture2(iChannel0,uv2+iTime*7.25468).rgb,vec3(1.5));\n\tcolor=mix(rain,color,clamp(iTime*.5-.5,0.,1.));\n\tcolor*=1.-pow(length(uv2*uv2*uv2*uv2)*1.1,6.);\n\tuv2.y *= iResolution.y / 360.0;\n\tcolor.r*=(.5+abs(.5-mod(uv2.y     ,.021)/.021)*.5)*1.5;\n\tcolor.g*=(.5+abs(.5-mod(uv2.y+.007,.021)/.021)*.5)*1.5;\n\tcolor.b*=(.5+abs(.5-mod(uv2.y+.014,.021)/.021)*.5)*1.5;\n\tcolor*=.9+rain*.35;\n#endif\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1443, 1443, 1462, 1462, 1509], [1512, 1512, 1533, 1533, 1590], [1592, 1592, 1631, 1652, 1810], [1812, 1812, 1831, 1831, 2448], [2451, 2451, 2472, 2472, 2635], [2637, 2637, 2672, 2711, 3208], [3211, 3211, 3259, 3259, 3581], [3583, 3583, 3607, 3607, 3921], [3923, 3923, 3984, 4007, 5004], [5006, 5006, 5050, 5050, 7075], [7077, 7077, 7129, 7129, 7367], [7370, 7370, 7427, 7427, 8535]], "test": "untested"}
{"id": "tlKBWw", "name": "Fork Re Cypher anotherpla 424", "author": "anotherplatypus", "description": "Experimenting with clubber.js and shaders edited by wizgrav\nAudio reactive version of https://www.shadertoy.com/view/MlsGRS by  @dila,  rewired for clubber. \n", "tags": ["block", "world", "ass", "clubber"], "likes": 6, "viewed": 312, "published": 3, "date": "1614495029", "time_retrieved": "2024-07-30T19:35:29.567979", "image_code": "// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n#define CLUBBER_R len * 0.3\n#define CLUBBER_G len * 0.3\n#define CLUBBER_B len * 0.3\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\n#define PI 3.14159\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 pos)\n{\n    float speed = 1.0;\n    vec3 grid = floor(pos);\n    vec3 gmod = mod(grid, 3.);\n    vec3 rmod = mod(grid, 4.0) - 2.0;\n    float j = iTime * speed + (CLUBBER_A);\n    float tm = fract(j);\n    rmod *= (cos(tm*PI)-1.0);\n    \n    float g = floor(mod(j,2.0));\n    if (g==0.0){\n        if (gmod.y*gmod.x==1.0) {\n            pos.z += rmod.x*rmod.y*0.5;\n        }\n    } else if (g==1.0){\n        if (gmod.y*gmod.z==1.0) {\n            pos.x += rmod.y;\n        }\n    } else if (g==2.0){\n        if (gmod.z==0.0) {\n            pos.y += rmod.z*rmod.x*0.5;\n        }\n    }\n        \n    grid = floor(pos);\n    pos = pos - grid;\n    pos = pos * 2.0 - 1.0;\n\n    float len = 0.9;\n\tvec3 sc = mix(vec3(0.5), vec3(0.96), vec3(CLUBBER_R,CLUBBER_G,CLUBBER_B));\n    float d = sdBox(pos, sc);\n\n    bool skip = false;\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.y,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.y,2.0)==0.0 && mod(grid.z,2.0)==1.0) {\n        skip = true;\n    }\n\t\n    if (skip) {\n        d = 100.0;\n        vec3 off = vec3(2.0,0.0,0.0);\n        for (int i = 0; i < 3; ++i) {\n            float a = sdBox(pos + off,vec3(sc));\n            float b = sdBox(pos - off,vec3(sc));\n            d = min(d,min(a,b));\n            off = off.zxy;\n        }\n        d *= 0.5 *(sc.x+sc.y +sc.z) * 0.33 ;\n    } else {\n        d *= 0.8 * (sc.x+sc.y +sc.z) * 0.33;   \n    }\n    \n    return d;\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat aoc(vec3 origin, vec3 ray)\n{\n    float delta = 0.05;\n    const int samples = 8;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = map(pos);\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 origin = vec3(0.0);\n    \n    eye = eye * yrot(iTime) * xrot(iTime);\n    \n    float speed = 0.5;\n    \n    float j = iTime * speed + CLUBBER_A;\n    \n    float f = fract(j);\n    float g = 1.0 - f;\n    f = f*f * g + (1.0-g*g) * f;\n    f = f * 2.0 - 1.0;\n\tfloat a = floor(j) + f * floor(mod(j,2.0));\n    float b = floor(j) + f * floor(mod(j+1.0,2.0));\n    \n    origin.x += 0.5 + a;\n    origin.y += 0.5;\n    origin.z += 0.5 + b;\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for (int i = 0; i < 32; ++i){\n        vec3 pos = origin + eye * t;\n        d = map(pos);\n        t += d;\n    }\n    \n    vec3 worldPos = origin + eye * t;\n    \n    vec3 norm = surfaceNormal(worldPos);\n    \n    float prod = max(0.0, dot(norm, -eye));\n    \n    float amb = aoc(worldPos, -eye);\n    \n    vec3 ref = reflect(eye, norm);\n    \n    vec3 spec = vec3(0.0);//texture(iChannel0, ref).xyz;\n    \n    prod = pow(1.0 - prod, 2.0);\n    \n    vec3 col = vec3(0.1, 0.3, 0.5);\n    \n    spec *= col;\n    \n    col = mix(col, spec, prod);\n    \n    float shade = pow(max(1.0 - amb, 0.0), 4.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.2) * shade;\n    \n    vec3 final = col;\n    \n    final = mix(final, vec3(1.0), fog);\n    \n    fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    float len = 0.9;\n\tvec3 sc = mix(vec3(0.5), vec3(0.96), vec3(CLUBBER_R,CLUBBER_G,CLUBBER_B));\n    \n\tfragColor = vec4(final*fog*sc,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 289, 289, 398], [400, 400, 420, 420, 529], [531, 531, 551, 551, 660], [662, 662, 693, 693, 789], [791, 791, 812, 812, 2272], [2274, 2274, 2304, 2304, 2570], [2572, 2572, 2606, 2606, 2916], [2918, 2918, 2975, 2975, 4533]], "test": "untested"}
{"id": "WlVfDm", "name": "Fork Waves Remi anotherpla 266", "author": "anotherplatypus", "description": "simple audio visualizer (also pretty without audio) based upon \"waves\" by bonniem, with added travelling pulse effect, color cycling, and of course, the requested audio sensitivity. Each wave is particularly responsive to a specific range of frequencies.", "tags": ["waves", "sound", "wave", "music", "colors", "beginner", "audio", "visualizer", "easy", "sounds"], "likes": 13, "viewed": 404, "published": 3, "date": "1614491589", "time_retrieved": "2024-07-30T19:35:30.340913", "image_code": "// The following block is needed for Clubber integration\n#ifndef CLUBBER\nvec4 iMusic[4];\nconst float iTransition = 1.0;\n\n#define CLUBBER_R 0.3\n#define CLUBBER_G 0.3\n#define CLUBBER_B 0.3\n#define CLUBBER_A 0.0\n#endif\n// Clubber end\n\nfloat squared(float value) { return value * value; }\n\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\n\nfloat getWeight(float f) {\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\tfor(float i = 0.0; i < 5.0; i++) {\n        \n\t\tuv.y += (0.2 * sin(uv.x + i/7.0 - iTime * 0.6));\n        float Y = uv.y + getWeight(squared(i) * 20.0) *\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x + i / 1.3 + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n\t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\n\t}\t\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[232, 232, 260, 260, 284], [286, 286, 317, 317, 376], [378, 378, 404, 404, 502], [504, 504, 561, 561, 1298]], "test": "untested"}
{"id": "WlVBWm", "name": "Random procedural textures 3", "author": "jarble", "description": "This shader makes procedural textures with many different colors and patterns.", "tags": ["procedural", "texture", "random"], "likes": 3, "viewed": 377, "published": 3, "date": "1614478737", "time_retrieved": "2024-07-30T19:35:31.104870", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 8.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        float scale = 3.0;\n        \n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0))*2.0;\n        float scale1 = .5+(random.z)/2.0;\n        //random.xy = random.z;\n        //vec3 random = hash31(10.0);\n        scale = scale1 * 1.5;\n        \n        for(int i=0;i<3;i++)\n        {\n            \n            random = (hash33(random)+vec3(.5))*2.0;\n            //scale1 *= 1.+random.z/1.7/2.0;\n            uv.y /= -scale1;\n            //uv=fract(uv.yx+(uv)/scale);\n            uv=fract(uv/scale1+uv.yx/scale);\n\n            uv = fract1(uv/scale1,random.yx,scale1)*scale1;\n            uv /= scale;\n            uv=uv.yx+col.yx;\n            uv.y *= -scale+uv.y;\n            col = col.yzx;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 425, 447, 447, 572], [574, 574, 619, 619, 672], [674, 674, 731, 731, 1843]], "test": "untested"}
{"id": "WlKBDw", "name": "Look At Transform", "author": "oneshade", "description": "Look at transform.", "tags": ["tracking", "target", "transform", "lookat"], "likes": 8, "viewed": 204, "published": 3, "date": "1614466400", "time_retrieved": "2024-07-30T19:35:31.868827", "image_code": "mat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\n// Default position should be facing along the Z axis\nfloat trackerObj(in vec3 p) {\n    return max(abs(p.z) - 2.0, max(abs(p.x), abs(p.y)) - 0.25 + p.z * 0.25) * 0.4; // Woefully inexact\n}\n\nvec2 mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    vec3 target = vec3(c * 5.0, 3.0 * s, c * s * 5.0) * 2.0;\n\n    float targetShape = length(p - target) - 0.5;\n\n    // Hexagonal tiling\n    vec2 rep = vec2(6.0, 10.39);\n    vec2 hrep = vec2(3.0, 5.195);\n    vec2 a = mod(p.xz, rep) - hrep;\n    vec2 b = mod(p.xz - hrep, rep) - hrep;\n    vec2 local = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cell = p.xz - local;\n\n    // Transform to local coordinates and apply look at transform\n    p.xz = local;\n    p *= lookAt(vec3(cell.x, 0.0, cell.y), target);\n    float trackerShape = trackerObj(p);\n\n    return vec2(min(targetShape, trackerShape), targetShape < trackerShape); // vec2(distance, id)\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(1.0);\n\n    vec3 ro = vec3(0.0, 3.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 250; i++) {\n        vec3 p = ro + rd * t;\n        vec2 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n\n            float diff = max(0.0, dot(n, l));\n            fragColor.rgb = d.y < 0.5 ? vec3(diff, 0.0, 0.0) : vec3(0.0, 0.0, diff);\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 234], [236, 290, 319, 319, 424], [426, 426, 452, 452, 1134], [1136, 1136, 1163, 1163, 1422], [1424, 1424, 1479, 1479, 2480]], "test": "untested"}
{"id": "3lKfWw", "name": "Random procedural textures 2", "author": "jarble", "description": "This shader makes procedural textures with many different colors and patterns.", "tags": ["procedural", "texture", "random"], "likes": 2, "viewed": 248, "published": 3, "date": "1614462354", "time_retrieved": "2024-07-30T19:35:32.755456", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 8.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        float scale = 3.0;\n        \n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0))*2.0;\n        float scale1 = .5+(random.z)/2.0;\n        //random.xy = random.z;\n        //vec3 random = hash31(10.0);\n        scale = scale1 * 3.0;\n        \n        for(int i=0;i<3;i++)\n        {\n            \n            random = (hash33(random)-vec3(.5))*2.0;\n            //scale1 *= 1.+random.z/1.7/2.0;\n            uv.y /= scale1;\n            uv=fract(uv/(scale1)+(uv.yx/(scale1))/scale);\n            uv = fract1(uv/scale1,random.yx,scale1)*scale1;\n            uv /= scale;\n            uv=uv.yx+col.yx;\n            uv.y *= -scale+uv.x;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 425, 447, 447, 572], [574, 574, 619, 619, 672], [674, 674, 731, 731, 1785]], "test": "untested"}
{"id": "WtKfWw", "name": "mouse calles y edificio v4", "author": "jorge2017a1", "description": "mouse calles y edificio v4", "tags": ["mousecallesyedificiov4"], "likes": 3, "viewed": 202, "published": 3, "date": "1614461496", "time_retrieved": "2024-07-30T19:35:33.733841", "image_code": "//por jorge2017a1-\n\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nfloat iTimeGlobal;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec3 Casa1(vec3 p)\n{\n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    float anchoZ=5.0;\n    float  sdCasa= sdBox(p-vec3(0.0,0.0,0.0), vec3(10.0,8.0,anchoZ) );\n    \n    float  sdventana1dif= sdBox(p-vec3(-7.0,-1.0,0.0), vec3(2.2,3.2,anchoZ+ .2) );\n    float  sdventana2=    sdBox(p-vec3(-7.0,-1.0,-2.5), vec3(2.0,3.0,0.5) );\n    float  sdProteccion1=  sdBox(p-vec3(-8.0,-1.0,-3.5), vec3(0.25,3.0,0.5) );\n    float  sdProteccion2=  sdBox(p-vec3(-7.0,1.0,-3.5), vec3(2.0,0.25,0.5) );\n    \n    float  sdpuerta1dif= sdBox(p-vec3(0.0,-4.2, 0.0), vec3(2.5,4.0,anchoZ+.2) );\n    float  sdpuerta2=    sdBox(p-vec3(0.0,-4.2,-3.5), vec3(2.5,4.0,0.5) );\n    \n    \n    //diferencia casa y ventana\n    float difcasa= differenceSDF(sdCasa, sdventana1dif);\n    difcasa= differenceSDF(difcasa, sdpuerta1dif);\n    \n    \n    res =opU3(res, vec3(difcasa, -1.0, 6.0)); \n    res =opU3(res, vec3(sdventana2,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdProteccion1,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdProteccion2,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdpuerta2,2.0,MATERIAL_NO)); \n    return res;\n}      \n        \n        \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n    float planeDist1 = p.y+0.0;  //piso inf\n    \n    vec3 posA=p;\n    posA.z= opRep1D(posA.z, 60.0 );\n    posA.x= opRep1D(posA.x, 60.0 );\n    vec3 prepLinea1=posA;\n    \n    prepLinea1.z= opRep1D( prepLinea1.z, 10.0 );\n    \n    \n    //hacer calle A\n    float sdr1A= sdRoundBox(posA-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr1B= sdRoundBox(posA-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr1C= sdRoundBox(posA-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea1= sdRoundBox(prepLinea1-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    \n    \n    //hacer calle B\n    vec3 posB=p-vec3(-30.0,0.0,30.0);\n    posB.z= opRep1D(posB.z, 60.0 );\n    posB.x= opRep1D(posB.x, 60.0 );\n    posB= rotate_y(posB, radians(90.0));\n    vec3 prepLinea2=posB;\n    \n    prepLinea2.z= opRep1D( prepLinea2.z, 10.0 );\n    \n    float sdr2A= sdRoundBox(posB-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr2B= sdRoundBox(posB-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr2C= sdRoundBox(posB-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea2= sdRoundBox(prepLinea2-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    //calle centro\n    vec3 posC=p-vec3(0.0,0.0,30.0);\n     posC.z= opRep1D(posC.z, 60.0 );\n     posC.x= opRep1D(posC.x, 60.0 );\n     \n    float sdr3A= sdRoundBox(posC-vec3(0.0), vec3(10.0,1.0,10.0), 0.2 );\n    \n   \n     //jardin\n     vec3 posD=p-vec3(-30.0,0.0,-13.0);\n     posD.z= opRep1D(posD.z, 58.0 );\n     posD.x= opRep1D(posD.x, 55.0 );\n \n     vec3 vdr4A= Casa1(posD-vec3(.0,8.0,12.));\n     \n   \n    //calle a\n    res =opU3(res, vec3(sdr1A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr1B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr1C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea1,2.0,-1.0)); \n    // calle b\n    res =opU3(res, vec3(sdr2A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr2B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr2C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea2,2.0,-1.0)); \n    //calle c\n    res =opU3(res, vec3(sdr3A,-1.0,4.0)); \n    res =opU3(res, vdr4A ); \n    \n    res =opU3(res, vec3(planeDist1,3.0,-1.0)); \n \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro, vec3 col) \n{\n    vec3 l = lp - p;\n   \n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*col;\n   \n    return lin*atten*col*2.0;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    mObj.hitbln =false;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; break; }\n        \n        if(dO>MAX_DIST)\n        {   mObj.hitbln = false; break; }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro,colobj);\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n//------------------------------------------------\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Created by dr2 in 2016-01-24\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\n\nvec3 sky(vec3 rd, vec3 L)\n{\n  return vec3(1.-rd.y,0.9,1.+(rd.y-dot(rd,L))*.5)*(0.4*dot(rd,L)+0.6);\n}\n\n\n//https://www.shadertoy.com/view/ld3XWr\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n  return a + b*cos( 6.28318*(c*t+d) );\n}\n\n////--------------trueno\n\nfloat Hash( vec2 p)\n{\n     vec3 p2 = vec3(p.xy,1.0);\n    return fract(sin(dot(p2,vec3(37.1,61.7, 12.4)))*3758.5453123);\n}\n\nfloat noise(in vec2 p)\n{\n    vec2 i = floor(p);\n     vec2 f = fract(p);\n     f *= f * (3.0-2.0*f);\n\n    return mix(mix(Hash(i + vec2(0.,0.)), Hash(i + vec2(1.,0.)),f.x),\n               mix(Hash(i + vec2(0.,1.)), Hash(i + vec2(1.,1.)),f.x),\n               f.y);\n}\n\nfloat fbm(vec2 p)\n{\n     float v = 0.0;\n     v += noise(p*1.0)*.5;\n     v += noise(p*2.)*.25;\n     v += noise(p*4.)*.125;\n     return v;\n}\n\nvec3 clouds( vec2 uv, vec2 dir )\n{\n\tdir *= iTime;\n\tvec3 finalColor = fbm( (uv * 1.5) + dir ) * vec3( 1.0 );\t\n\t\n\treturn finalColor;\n}\n\nvec3 lightning( vec2 uv )\n{\n\tfloat timeVal = iTime;\n\tvec3 finalColor = vec3( 0.0 );\n\tfor( int i=0; i < 3; ++i )\n\t{\n\t\tfloat indexAsFloat = float(i);\n\t\tfloat amp = 40.0 + (indexAsFloat*1.0);\n\t\tfloat period = 2.0 + (indexAsFloat+2.0);\n\t\t\n\t\tfloat thickness = mix( 0.1, 0.7, uv.y * 0.5 + 0.5 );\n\t\t\n\t\tfloat intensity = mix( 0.5, 1.5, noise(uv*10.0) );\n\t\tfloat t = abs( thickness / (sin(uv.x + fbm( uv + timeVal * period )) * amp) * intensity );\n\t\tfloat show = fract(abs(sin(timeVal))) >= 0.95 ? 1.0 : 0.0;\n\t\tshow *= step( abs(fbm( vec2( sin(iTime * 50.0), 0.0 ) )), 0.4);\n\t\t\n\t\t\n\t\tfinalColor +=  t * vec3( 0.3, 0.5, 2.0 ) * show;\n\t}\n\t\n\treturn finalColor;\n}\n\n\n///--------------------------\n// Stormy Night\n// By: Brandon Fogerty\n// bfogerty at gmail dot com \n// xdpixel.com\n\nvec3 NubeyTrueno(  vec2 rd )\n{\n    vec2 uv = rd;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\n\tvec3 finalColor = vec3( 0.0 );\n\tfinalColor += sin( clouds( uv, vec2( 1.0, 0.1 ) ));\n\t\n\tfloat xOffset = mix( 1.5, -1.5, fbm(vec2( fract(iTime), 0.00 ) ) );\n\tvec2 uvOffset = vec2( xOffset, 0.0 );\n\t\n\tvec2 lightningUV = uv + uvOffset;\n\t\n\tfloat theta = 3.14159 * 2.1;\n\tlightningUV.x = uv.x * cos(theta) - uv.y*sin(theta); \n\tlightningUV.y = uv.x * sin(theta) + uv.y*cos(theta); \n\t\n\tfinalColor += lightning( lightningUV + uvOffset );\n\tfinalColor -= sin( clouds( uv, vec2( 2.0 ) )) * 0.30;\n    return finalColor;\n\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n     //float cc=mObj.id_color;\n     float cc=10.0;\n     float nMol=10.0;\n     return   HsvToRgb (vec3 (mod (1.7 * cc / float (nMol), 1.), 1. - 0.3 * mod (cc, 3.), 1. - 0.3 * mod (cc, 2.))); \n            \n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t;\n    t=mod(iTime*1.0,1000.0);\n    iTimeGlobal=t;\n        itime=t;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;    \n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 8., -2.+t);\n    \n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.01);\n    dir = rotate(dir, mouse);\n   \n    mObj.uv=uv;\n    \n\tmObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 0.0, 20.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n\n \n    vec3 ro=camera;\n    \n    \n    \n    vec3 rd=dir;\n    rd.xz= rotatev2(rd.xz, radians(180.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    \n    \n    Obj=mObj;\n    \n    vec3 p = (ro + rd * d ); \n    \n    if(mObj.hitbln) \n    {\n   \n    \n        mObj.p=p;\n        mObj.dist =d;\n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n         result/=1.25;\n        col=result;\n\n        //sugerencia por dean_the_coder,\n        //col *= 1.0 - pow(d / 100.0, 1.5);\n\n        col *= 1.0 - pow(d /(MAX_DIST) , 2.5);    \n        col = pow(col, vec3(1.0/2.2));  \n\n    }   \n    else if(d>MAX_DIST)\n    {\n        float t1=mod(iTime, 2.0);\n        float t2=mod(iTime, 1.);\n        if (t2<t1)\n            col= NubeyTrueno(rd.xy*3.0 );\n    \n        else {\n        float a = dot(rd.xy, rd.xy);\n        vec3 h = sqrt(1000.0 * a) / a * 0.5 * rd;\n        col= NubeyTrueno(vec2(atan(h.y, h.x), h.z / 3.0));\n     }\n   }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n    bool hitbln;\n   \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n//https://www.shadertoy.com/view/3stXR2 \n\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 424, 460, 460, 481], [482, 482, 514, 514, 598], [599, 599, 645, 645, 732], [734, 778, 825, 825, 852], [854, 854, 897, 897, 924], [926, 926, 974, 974, 1002], [1003, 1087, 1123, 1123, 1168], [1169, 1234, 1268, 1268, 1366], [1367, 1367, 1401, 1401, 1493], [1494, 1494, 1528, 1528, 1620], [1621, 1661, 1695, 1695, 1792], [1795, 1795, 1815, 1815, 2890], [2916, 2956, 2981, 2981, 5249], [5253, 5253, 5328, 5328, 5929], [5933, 5984, 6008, 6008, 6196], [6197, 6260, 6293, 6293, 6886], [6888, 6942, 6978, 6978, 7212], [7213, 7302, 7382, 7382, 7649], [7651, 7702, 7724, 7724, 7893], [7895, 7926, 7950, 7950, 8086], [8089, 8089, 8116, 8116, 8189], [8192, 8232, 8304, 8304, 8345], [8373, 8373, 8394, 8394, 8494], [8496, 8496, 8520, 8520, 8758], [8760, 8760, 8779, 8779, 8898], [8900, 8900, 8934, 8934, 9032], [9034, 9034, 9061, 9061, 9683], [9801, 9801, 9831, 9831, 10399], [10402, 10453, 10500, 10500, 11293], [11347, 11347, 11440, 11440, 11720], [11724, 11773, 11830, 11830, 13705]], "test": "untested"}
{"id": "3lKfzm", "name": "3x3 Convolution Experiment", "author": "oneshade", "description": "A cool embossing filter with a 3x3 convolution kernel.", "tags": ["imageprocessing", "effect", "convolution", "emboss", "kernel", "3x3"], "likes": 9, "viewed": 360, "published": 3, "date": "1614458933", "time_retrieved": "2024-07-30T19:35:34.505777", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n\n    float emb = 1.5 + 1.5 * sin(iTime);\n    mat3 kernel = mat3(emb,  0.0,  0.0,\n                       0.0,  1.0,  0.0,\n                       0.0,  0.0, -emb);\n\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec4 color = texture(iChannel0, (fragCoord + vec2(i, j)) / iResolution.xy);\n            float convWeight = kernel[j + 1][i + 1];\n            fragColor += color * convWeight;\n        }\n    }\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 519]], "test": "untested"}
{"id": "wlyBWm", "name": "Smooth Repetition", "author": "PauloFalcao", "description": "Smooth Repetition by @paulofalcao\nIt's possible to create a smooth repetition using asin(sin(x)*S) like blackle said in the comments :)\nMade a video playing with this and Material Maker https://www.youtube.com/watch?v=HoAQ7DFRzQE\n", "tags": ["repetition"], "likes": 29, "viewed": 727, "published": 3, "date": "1614449666", "time_retrieved": "2024-07-30T19:35:35.279708", "image_code": "// Smooth Repetition\n// by @paulofalcao\n//\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//\n// Twitter: @paulofalcao\n// https://twitter.com/paulofalcao/status/1365726720695934979\n//\n// YouTube playing with this and Material Maker\n// https://www.youtube.com/watch?v=HoAQ7DFRzQE\n//\n// I was using smooth abs p=sqrt(p*p+a) introduced by omeometo\n// at https://shadertoy.com/view/wljXzh\n// and iteratively doing smooth abs and translations\n// the number of objects is exponencial\n//\n// But it's possible to use asin(sin(x)*S) with S between 0 and 1 \n// like blackle said in the comments!\n// Creates infinite repetitions and it's even faster! :)\n// Change asin_sin_mode to true to use this mode (this is now the default mode)\n//\n// Using IQ \"Raymarching - Primitives\" as sandbox\n// https://www.shadertoy.com/view/Xds3zN\n//\n\n#define asin_sin_mode true\n\n//Change asin_sin_mode to true to use this mode (default)\n//blackle mode asin(sin(x)*S) with S between 0 and 1 (higher values less smooth)\nvec2 smoothrepeat_asin_sin(vec2 p,float smooth_size,float size){\n    p/=size;\n    p=asin(sin(p)*(1.0-smooth_size));\n    return p*size;\n}\n\n//Change asin_sin_mode to false to use this mode\n//6 iterations create 2^6 objects for each axis\n#define smoothrepeat_iterations 6\nvec2 smoothrepeat(vec2 p,float smooth_size,float size){\n    size/=2.0;\n    float w=pow(2.0,float(smoothrepeat_iterations));\n\tfor(int i=0;i<smoothrepeat_iterations;i++){\n        p=sqrt(p*p+smooth_size);//smooth abs\n\t\tp-=size*w;//translate\n\t\tw=w/2.0;\n\t}\n\treturn p;\n}\n\n\n//\n// The code from now on is the same as IQ \"Raymarching - Primitives\"\n// with minor modifications and different map function\n// https://www.shadertoy.com/view/Xds3zN\n//\n\n#if HW_PERFORMANCE==1\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n// PRIMITIVES\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rot(vec2 p, float r) {\n\tfloat s=sin(r);float c=cos(r);\n\treturn p*mat2(c,-s,s,c);\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n\n      float sm=(smoothstep(0.0,1.0,sin(iTime)+0.5)-0.5)*0.01+0.005;\n      float dist=sin(iTime*0.35)*0.2+0.3;\n      \n      if (asin_sin_mode){\n          pos.xz=smoothrepeat_asin_sin(pos.xz,sm*10.0,dist);\n      } else {\n          pos.xz=smoothrepeat(pos.xz,sm,dist);\n      }\n\n      \n      pos.xz=rot(pos.xz,sin(iTime*0.5));\n      pos.xy=rot(pos.xy,sin(iTime*0.7)*0.4);\n      pos.yz=rot(pos.yz,sin(iTime)*0.3);\n\n      pos-=vec3(0.0,0.2, 0.0);\n      float b=sdRoundBox( pos, vec3(0.4,0.02,0.1),0.02);\n      \n      res = opU( res, vec2(b ,1.5) );\n    }\n\n    \n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.1;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n\n    float t = tmin;\n    for( int i=0; i<70 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     10.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0, 0, 0 );\n    \n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.0 + 4.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBWm.jpg", "access": "api", "license": "cc0-1.0", "functions": [[873, 1012, 1076, 1076, 1148], [1281, 1281, 1336, 1336, 1545], [1974, 1974, 1999, 1999, 2014], [2016, 2016, 2061, 2061, 2152], [2154, 2154, 2187, 2187, 2242], [2315, 2315, 2345, 2345, 2378], [2380, 2380, 2407, 2407, 2467], [2639, 2639, 2664, 2664, 3279], [3281, 3281, 3321, 3321, 3837], [3839, 3884, 3962, 3985, 4372], [4374, 4420, 4452, 4452, 5022], [5024, 5024, 5066, 5066, 5375], [5377, 5429, 5493, 5514, 5747], [5749, 5749, 5814, 5833, 8313], [8315, 8315, 8367, 8367, 8544]], "test": "untested"}
{"id": "tsdfzM", "name": "Wallpaper", "author": "JennySchub", "description": "Wallpaper kinda thing", "tags": ["wallpaper"], "likes": 3, "viewed": 596, "published": 3, "date": "1614449001", "time_retrieved": "2024-07-30T19:35:36.121457", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t/*vec2 coord = uv-.5;\n\tcoord.x*=iResolution.x/iResolution.y;\n    // Time varying pixel color\n    \n    float size = .2;\n    float blur = .;\n    \n    \n    vec2 shift = vec2(sin(iTime), cos(iTime));\n    float brightness = smoothstep(size,size-size*blur, length(coord));\n*/\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat orb(float size, float blur, float amp, vec2 coord, float time){\n    \n    vec2 shift = vec2(sin(time*13.1624351), cos(time*17.3241561))*amp;\n    return smoothstep(size,size-size*blur, length(coord-shift));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 coord = uv-.5;\n\tcoord.x*=iResolution.x/iResolution.y;\n    // Time varying pixel color\n    float timescale = .1;\n    float size = .01;\n    float blur = 1.;\n    float amp = .02;\n    float speed = .5;\n    float time = iTime*timescale;\n    \n    vec3 col = vec3(0.);\n    for(float i=1.; i<6.; i++){\n        vec3 tint = normalize(abs(vec3(cos(time+i*1561.241556), cos(time+i*123.1515), cos(time+i*14.15134))))*timescale*.5;\n        col += tint*orb(size, blur, amp, coord, time*speed + i);\n\t}\n\n    // Output to screen\n    fragColor = clamp(texture(iChannel0,(uv-.5)*(1.-.3*timescale)+.5)+vec4(vec3(col),.0)-.05*timescale, 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 484]], "test": "untested"}
{"id": "wlyBDw", "name": "Over the Moon_", "author": "YitingLiu", "description": "following the two tutorials to create the over the moon. \nhttps://youtu.be/LLZPnh_LK8c\nhttps://youtu.be/XaiYKkxvrFM", "tags": ["moon"], "likes": 2, "viewed": 298, "published": 3, "date": "1614439241", "time_retrieved": "2024-07-30T19:35:36.887409", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nfloat TaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur){\n    float m = S(-blur,blur,p.y-yb);\n    m *= S(blur,-blur,p.y-yt);\n    p.x=abs(p.x);\n    \n    // taper 0 p.y = yb 1 p.y = wt\n    float w =mix(wb,wt,(p.y-yb)/(yt-yb));\n    m *= S(blur,-blur,p.x-w);\n\n    return m;\n\n}\n\n// conver the taperbox into sugar lollipop in the sugar land \nvec4 Tree(vec2 uv, vec3 col, float blur){\n\n    float m = TaperBox(uv, .03, .03, -.05, .25, blur);// trunk\n    m += TaperBox(uv, .2, .1, .25, .5, blur);// canopy1\n    m += TaperBox(uv, .15, .05, .5, .75, blur);// canopy2\n    m += TaperBox(uv, .1, .0, .75, 1., blur);// canopy3\n \n    //shadow - opposite of taperbox \n    //changing the light shadow angle based on time \n\n    float angle = sin(iTime);\n    float shadow = TaperBox(uv+vec2(0.25,0)*angle*-1., .1, .5, .15, .25, blur);// trunk\n    shadow += TaperBox(uv+vec2(0.3,.0)*angle, .1, .7, .4, .5, blur);// trunk\n    shadow += TaperBox(uv+vec2(0.3,.0)*angle*-1., .1, .5, .7, .75, blur);// trunk\n    \n    \n    col-=shadow*.8;\n    \n    \n    return vec4(col,m);\n    }\n\nfloat GetHeight(float x){\n    return sin(x*.432)+sin(x)*.3;\n}\n\nvec4 Layer(vec2 uv, float blur){\n vec4 col = vec4(0);\n    \n    float id = floor(uv.x);\n    float n = fract(sin(id*234.51)*251.2)*2.-1.;// -1. to 1. //random val\n    float x =n*.3;\n    float y =GetHeight(uv.x);\n\n    float ground = S(blur,-blur,uv.y+GetHeight(uv.x));// ground \n    col+=ground;\n    y = GetHeight(id+.5+x);\n\n    uv.x=fract(uv.x)-.5;\n\n    vec4 tree = Tree((uv-vec2(x,-y))*vec2(1,1.+n*.2), vec3(1), blur);\n    col = mix(col, tree, tree.a);\n    col.a=max(ground, tree.a);\n    return col; \n    }\n    \n    \nfloat Hash21(vec2 p){\n    p = fract(p*vec2(234.45,4532.24));\n    p+=dot(p,p+45632.23);\n    return fract(p.x*p.y);\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy/iResolution.xy)*2.-1.;\n    float fft  = texelFetch( iChannel0, ivec2(0.5,0.2), 0 ).x; \n\n    float t = iTime*.2;\n    vec3 colVal =vec3(Hash21(uv)*(sin(t)*.5+.5),.9,cos(t)*.5+.8)*fft;\n\n\n    float blur = .005;\n    float twinkle = dot(length(sin(uv+t)),length(cos(uv*vec2(22,6.7)-t*5.)));\n    twinkle = sin(twinkle*20.)*.5+.5;\n\n    float stars = pow(Hash21(uv),8.)*twinkle/fft;\n    vec4 col = vec4(stars)*vec4(colVal,twinkle);\n    \n   float moon = S(.02*fft ,-.01,length(uv-vec2(.4,.2))-.15);\n   moon*=fft*2.;\n   col*=1.-moon+fft ;\n   \n   moon *= S(-.01,.2,length(uv-vec2(.5,.25))-.15);\n\n\n   col+=moon*vec4(colVal,1.);\n      float bg = 1.-moon-stars;\n\n   col+=bg*.5*vec4(fft-colVal,1.2);\n\n    \n    vec4 layer;\n    \n    for(float i =0.; i<1.; i +=1./10.){\n        float scale = mix(30., 1., i);\n        blur = mix(.05,.005,i);\n        layer = Layer(uv*scale+vec2(t+i*100.,i)-M,blur);\n       vec3 colVal =vec3(Hash21(uv*fft)*(sin(t)*.5+.5),.9*(1.-.5*i),cos(t)*.5+.5);\n       layer.rgb*=mix(i*colVal,(1.-i)*colVal,uv.x*(1.-fft));\n        col = 1.-.5*fft-mix(col, layer,layer.a);\n    \n    \n    }\n          layer = Layer(uv+vec2(t,1.2)-M,blur*2.);\n          \n          layer.rgb*=colVal*.1;\n          col = mix(col, layer,layer.a);\n    \n    col/=mix(0.75,1.,uv.x+fft);\n    \n    \n    /*\n    if(abs(uv.x)<thickness) col.g=1.;\n    if(abs(uv.y)<thickness) col.r=1.;\n    */\n\n    fragColor = col;\n}", "image_inputs": [{"id": 25908, "src": "https://soundcloud.com/themarias/over-the-moon", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 111, 111, 326], [328, 390, 431, 431, 1105], [1107, 1107, 1132, 1132, 1168], [1170, 1170, 1202, 1202, 1675], [1686, 1686, 1707, 1707, 1806], [1807, 1807, 1864, 1864, 3331]], "test": "untested"}
{"id": "3sGBDm", "name": "Rolling Polygon", "author": "Shane", "description": "A simulation of an n-gon rolling along an undulating surface.", "tags": ["collision", "terrain", "square", "physics", "polygon", "ngon", "roll", "rigid"], "likes": 63, "viewed": 988, "published": 3, "date": "1614427130", "time_retrieved": "2024-07-30T19:35:37.833878", "image_code": "/*\n\n\tRolling Polygon\n\t---------------\n\n\tThis is yet another shader that has been sitting in my account for too \n    long. I was going to code a rolling polyhedron on terrain, but it'd been \n    a while since I'd applied collision-based physics, rigid body or otherwise, \n    so I decided to quickly code up a 2D n-gon rolling across an undulating 1D \n    noisy surface. It took me longer than the five minutes I expected it to \n    take, and that was without applying proper physical forces... The math and \n    physics student in me would be disappointed in what I've become. :D\n    \n    Even so, the idea is very simple: The lowest vertex is always in contact \n    with the ground, so determine which vertex it is and its distance from the \n    contact surface, then use it to offset all vertices... You could use repeat \n    polar coordinates to do this. However, I wanted to test the mid points \n    between vertices to gain a little more ground contact collision accuracy. \n    Plus, I also wanted infrastructure that could deal with haphazard shapes.\n    \n    Anyway, this example is not that important, and the code was rushed. I've \n    also added a heap of window dressing. Everything works, but there'd be \n    cleaner ways to do what I'm doing here, so you can ignore most of it. \n    Having said that, there isn't a great deal of code featuring rolling 2D \n    polygons along an undulating surface, so at least this is a start. :)\n    \n\n\n    Other examples:\n    \n    // Much... much more difficult terrain collision, and far more interesting, \n    // but still based on similar principles. By the way, Dr2 has dozens more\n    // collision based examples worth looking at.\n    Leaping Snakes 2 - dr2\n    https://www.shadertoy.com/view/3lBXWV\n\t\n\n*/\n\n\n// Number of Polygon vertices:\n// Positive integers ranging from 2 to about 8 will work.\n// 2 (just a line) looks a bit odd, but is interesting.\n// Also, the speeds below may need adjusting.\n#define VERTICES 5\n\n\n// Polygon speed and rotation speed -- Technically, the forward motion should be\n// based mostly on the rotation speed, but I'm fudging things a little.\nfloat speed = .4;\n// Higher rotational speeds simulate spinning on the surface... Kind of. :)\nfloat rotSpeed = .42;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n \n\n// I searched Shadertoy for a robust regular polygon routine and came across\n// the following example:\n//\n// Regular Polygon SDF - BasmanovDaniil\n// https://www.shadertoy.com/view/MtScRG\n//\n// To use the functions in more intensive scenes, some optimization would be\n// necessary, but I've left them in their original form to show the working.\n\nfloat Polygon(vec2 p, float vertices, float radius){\n\n    float segmentAngle = 6.2831853/vertices;\n    \n    float angleRadians = atan(p.x, p.y);\n    float repeat = mod(angleRadians, segmentAngle) - segmentAngle/2.;\n    float inradius = radius*cos(segmentAngle/2.);\n    float circle = length(p);\n    float x = sin(repeat)*circle;\n    float y = cos(repeat)*circle - inradius;\n\n    float inside = min(y, 0.);\n    float corner = radius*sin(segmentAngle/2.);\n    float outside = length(vec2(max(abs(x) - corner, 0.0), y))*step(0.0, y);\n    return inside + outside;\n}\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); // p *= p*p*(p*(p*6. - 15.) + 10.); //\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\nfloat height(vec2 p){\n    \n    \n    p.x += iTime*speed;\n    p *= 3.;\n    float ns = n2D(p)*.57 + n2D(p*2.)*.28 + n2D(p*4.)*.15;\n    //float ns = n2D(p)*.67 + n2D(p*2.)*.33;\n    return (mix(ns, smoothstep(.25, 1., ns), .5) - .5)*.25;\n}\n\n// The map function. Just two layers of gradient noise. Way more interesting\n// functions are possible, but we're keeping things simple.\nfloat map(vec2 p){\n\n    float ns = height(vec2(p.x, 0.));\n    float ter = p.y + ns + .075;\n    \n    return ter;\n  \n}\n\n\n\n// 2D derivative function.\nvec2 getNormal(in vec2 p, float m) {\n\t\n    vec2 e = vec2(.001, 0);\n    \n    // Four extra samples. Slightly better, but not really needed here.\n\t//return (vec2(map(p + e.xy, i) - map(p - e.xy, i), map(p + e.yx, i) - map(p - e.yx, i)))/e.x*.7071;\n\n    // Three samples, but only two extra sample calculations. \n    return vec2(m - map(p - e.xy), m - map(p - e.yx))/e.x*1.4142;\n}\n\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p){\n    \n    float res = iResolution.y;\n    \n    // Produce the pattern.\n    \n    \n        \n    \n        // The pattern is physically based, so needs to factor in screen resolution.\n        p *= res/16.;\n    \n    \t// Just a hack to deal with large \"p\" values as time progresses.\n    \tp = mod(p, 64.);\n\n        // Random looking diagonal hatch lines.\n        float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n        // Slight randomization of the diagonal lines, but the trick is to do it with\n        // tiny squares instead of pixels.\n        float hRnd = hash21(floor(p*6.) + .73);\n        if(hRnd>.66) hatch = hRnd;  \n\n\n        hatch = hatch*.2 + .8;\n        \n\n        return hatch;\n    \n}\n\n\n\n// The polygon line pattern.\nfloat linePattern(vec2 p, vec2 a, vec2 b){\n  \n    // Determine the angle between the vertical 12 o'clock vector and the edge\n    // we wish to decorate (put lines on), then rotate \"p\" by that angle prior\n    // to decorating. Simple.\n    vec2 v1 = vec2(0, 1);\n    vec2 v2 = (b - a); \n \n    // Angle between vectors.\n    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.\n    float ang = acos(v2.y/length(v2)); // Trimed down.\n    p = rot2(ang)*p; // Putting the angle slightly past 90 degrees is optional.\n\n    float ln = doHatch(p);//clamp(cos(p.x*96.*6.2831)*.35 + .95, 0., 1.);\n\n    return ln;// *clamp(sin(p.y*96.*6.2831)*.35 + .95, 0., 1.); // Ridges.\n \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/res;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv - vec2(.25, 0);\n    \n    // Keep a copy.\n    vec2 oP = p;\n\n    // Smoothing factor.\n    float sf = 1./iResolution.y;\n    \n    // Number of Polygon vertices:\n    // Positive integers ranging from 2 to about 8 will work.\n    // 2 (just a line) looks a bit odd, but is interesting.\n    const int sNum = VERTICES;\n    const float fsNum = float(sNum);\n    \n    \n    // Gradient at the center of the shape.\n    float grad = (map(vec2(.03, 0)) - map(vec2(-.03, 0)));\n\n    // Rotating time, based on vertice number.\n    float t = fract(iTime*min(mix(fsNum, 5., .5), 6.)*rotSpeed);\n    t = pow(t, .8);\n    t *= 6.283185/fsNum;\n    t -= sign(grad)*grad*grad*4.;\n   \n    \n    // Emulating friction -- very badly. :)\n    p.xy += vec2(-.5, 1.5)*(cos(t*fsNum - 1.57*.5)*.5 + .5)*.005;\n \n    \n    // Various distance field values, etc.\n    float d = 1e5, vert = d, vert2 = d, poly = d, ln = d, gP = d, ico = d, ico2 = d;\n    \n    // Polygon side length and vertex size.\n    float l = .18;\n    float pSz = .015;\n    \n    \n    // Point and transformed point holders.\n    vec2[sNum] pnt;\n    vec2[sNum] tPnt;\n    \n    // Create the points, then rotate them.\n    for(int i = 0; i<sNum; i++){\n        \n        pnt[i] = rot2(6.283185/fsNum*float(i))*vec2(0, 1./sqrt(2.))*l;\n        tPnt[i] = rot2(t)*pnt[i];\n    }\n    \n    // Line pattern.\n    float sLinePat = linePattern(p - vec2(-iTime*speed*1.2, 0), vec2(1, 1), vec2(1, -1));\n    \n    // Bottom dashed line:\n    float xOffs = -.15 - .25;//-.35\n    float yOffs = -.43;\n    if(res>500.) yOffs -= .1;\n    float g = abs(p.y - yOffs + .018) - .0025;\n    vec2 q = mod(p + vec2(iTime*speed, 0), 1./32.) - .5/32.;\n    float dash = abs(q.x) - .2/32.;\n    g = max(g, -dash);\n    \n\n    // Find the minimum vertex point height, since that will be the vertex\n    // in contact with the ground.\n    int lvert = 0;\n    for(int i = 0; i<sNum; i++){ \n        \n        if(tPnt[i].y<gP) {\n            gP = tPnt[i].y;\n            lvert = i;\n        }\n\n    }\n    // Adjust every transformed point by the minimum. \n    for(int i = 0; i<sNum; i++) tPnt[i].y -= gP - yOffs;\n   \n    // Keeping a copy for the ground based polygon below. Normally, this \n    // wouldn't be necessary.\n    float gP2 = gP;\n\n    \n    // Previous and next vertex numbers.\n    int lvertp = int(mod(float(lvert) + 1., fsNum));\n    int lvertn = int(mod(float(lvert) - 1., fsNum));\n    \n    // Number of midpoints between successive vertices. We test these against\n    // the terrain also. More contact points mean more accurate collision.\n    const int midPoints = 2;\n    \n    gP = 1e5;\n    \n    for(int i = 0; i<sNum; i++){ \n        \n        // Terrain height.\n        float h = map(vec2(tPnt[i].x, 0));\n        \n        // If the current vertex plus height is lowest, it becomes the new lowest point.\n        if(tPnt[i].y + h<gP) {\n            gP = tPnt[i].y + h;\n        }\n        \n        // Add the vertex point to the overall distance field.\n        vert2 = min(vert2, length(p - tPnt[i]*.16/.18 - vec2(xOffs, .115*yOffs)) - pSz);\n        \n        // Get the next vertex point index.\n        int inext = (i + sNum - 1)%sNum;\n        \n        // Check the midpoints between the current and next point, the perform a\n        // collision check with the terrain.\n        for(int j = 0; j<midPoints; j++){\n            \n            // Current midpoint... Hmm, midpoint was probably a poor choice of \n            // word, since there can be more than one... Pretend that I mean, waypoint. :)\n            vec2 mid = mix(tPnt[i], tPnt[inext], float(j + 1)/float(midPoints + 1));\n            float hmid = map(vec2(mid.x, 0)); // Midpoint height.\n\n            // If the current midpoint plus height is lowest, it becomes the new lowest point.\n            if(mid.y + hmid<gP) {\n                gP = mid.y + hmid;\n            }\n            \n            // Add the midpointto the overall distance field.\n            vert2 = min(vert2, length(p - mid*.16/.18 - vec2(xOffs, .115*yOffs)) - pSz*.5);\n             \n             \n        }\n    } \n \n   \n \n    \n    ///////////////////\n    \n    // Terrain calculations.\n    \n    float ter = map(p);\n    vec2 n = getNormal(p, ter);\n    float len = length(n);\n   \n    vec2 p2 = p*vec2(1, -1) - vec2(75.3, -.3);\n    float ter2 = map(p2); \n    vec2 n2 = getNormal(p2, ter2);\n    float len2 = length(n2);\n \n    \n    // Polygon contruction.\n    q = rot2(-t)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    poly = Polygon(q, fsNum, l/sqrt(2.)); \n    poly = max(poly, -(poly + .06)); // Hole.\n   \n    \n    // Polygon line pattern. \n    float t2 = (iTime*rotSpeed*(4.));\n    t2 *= 6.283185/4.;\n    vec2 qp = rot2(-t2)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    float patPoly = clamp(sin((qp.y)*6.283185*50.*sqrt(2.))*.5 + 1., 0., 1.);\n    //\n    vec2 qq = rot2(-t2)*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    //qq = (rot2(-t2))*(p - vec2(0, -gP  - (gP2 - yOffs)));\n    patPoly = linePattern(qq, pnt[0], pnt[1]);\n    \n\n    \n    // Polygon vertices.\n    q = rot2(6.283185/2./fsNum)*q;\n    float a = atan(q.x, q.y);\n    float ia = (floor(a*fsNum/6.283185) + .5)/fsNum;\n    q = rot2(-ia*6.283185)*q;\n    q.y -= l/sqrt(2.);\n    // \n    vert = min(vert, length(q) - pSz);\n    \n    \n    // Terrain overlay line pattern.\n    float pat = linePattern(p - vec2(-iTime*speed, 0), vec2(1, 1), vec2(1, -1));\n    \n    // Dashes.\n    q = p;\n    q.x = mod(q.x + iTime*speed, 1./36.) - .5/36.;\n    q.y -= -map(vec2(p.x, 0));//-gP - (gP2 - yOffs);\n    // Rotating by the half the tangent. Normally, you'd use the whole tangent, but\n    // I wanted to rotate the lines toward the curve, but not all the way, for \n    // aesthetic purposes.\n    q = rot2(atan(-n.x, n.y)/2.)*q;\n    dash = abs(q.x) - .2/36.;\n    \n    q = p2;\n    q.x = mod(q.x + iTime*speed, 1./36.) - .5/36.;\n    q.y -= -map(vec2(p2.x, 0));//-gP - (gP2 - yOffs);\n    // Rotating by the half the tangent. Normally, you'd use the whole tangent, but\n    // I wanted to rotate the lines toward the curve, but not all the way, for \n    // aesthetic purposes.\n    q = rot2(atan(-n2.x, n2.y)/2.)*q;\n    float dash2 = abs(q.x) - .2/36.;\n    \n    \n    // Noise texture.\n    q = (p - vec2(-iTime*speed, 0));\n    q *= vec2(2, 4. + ter)*32.;\n    float ns = n2D(q)*.57 + n2D(q*2.)*.28 + n2D(q*4.)*.15;\n    vec3 tx = vec3(1);//*(smoothstep(0., .1, ns - .5)*.1 + .9);\n\n\n \n    // Tunnel background.\n    vec3 col = vec3(1, .92, .75)*.8;\n    col *= sLinePat;\n    \n    // Resolution shadow factor.\n    float shF = res/450.;\n   \n    // Top terrain overlay.    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n2)*8.*shF, ter2 - length(n2)*.00))*.3);    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n2), max(ter2, -dash2))));//vec3(.7, .8, .5)\n    col = mix(col, vec3(1, .94, .78)*pat*tx, (1. - smoothstep(0., sf*length(n2), ter2 + length(n2)*.005)));\n    \n    // Bottom terrain overlay.\n    float sh = clamp(clamp(sin(ter*250. - 3.14159) + .9, 0., 1.), 0., 1.);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n)*8.*shF, ter - length(n)*.00))*.3);    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*length(n), max(ter, -dash))));//vec3(.7, .8, .5)\n    col = mix(col, vec3(1, .94, .78)*pat*tx, (1. - smoothstep(0., sf*length(n), ter + length(n)*.005)));\n   \n    \n   \n    // Polygon lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8.*shF, min(poly, vert - .003) - .004))*.3);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, poly - .004));\n    col = mix(col, vec3(1, .97, .92)*patPoly, 1. - smoothstep(0., sf, poly + .004));\n\n    // Bottom straight faded line.\n    float fade = min(abs(uv.x - (xOffs + .25)), 1.);\n    col = mix(col, mix(col, vec3(0), 1. - smoothstep(0., .15, fade - .3)), (1. - smoothstep(0., sf, g)));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n   \n    // Polygon vertices.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert - .003));\n    col = mix(col, mix(vec3(1, .8, .42), vec3(.8, 1, .35)*1.3, .4), 1. - smoothstep(0., sf, vert + .003));\n\n    // Bottom polygon vertices.\n    vec3 bg = col;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert2 - .003));  \n    col = mix(col, mix(vec3(1, .8, .42), vec3(.8, 1, .35)*1.3, .2), 1. - smoothstep(0., sf, vert2 + .003));  \n    \n    \n    // Render some border objects to frame things a little bit.\n    //\n    // Border sights: The background corners looked a little empty, so I threw \n    // these in to balance things out... Not sure if it worked, but it's done now. :)\n    vec2 b = vec2(iResolution.x/iResolution.y, 1) - .1;\n    q = (uv*2.);\n    q.x = abs(q.x);\n    q.y = -q.y;\n    float bord = max(q.x - b.x, q.y - b.y);\n    bord = max(bord, -(bord + .11));\n    bord = max(bord, -min(q.x - b.x + .22, q.y - b.y + .22));\n    //bord = max(bord, -(bord + .02));\n\n    \n    // Render the border sight... edge things, or whatever they are.\n    float falloff = 1./res;\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff*12.*shF, bord ))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord))*.7);\n    col = mix(col, bg*1., (1. - smoothstep(0., falloff, bord + .01)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., falloff, bord + .035)));\n    col = mix(col, bg*1.3, (1. - smoothstep(0., falloff, bord + .044)));    \n    ////\n     \n    // Very subtle sepia tone with a sprinkling of noise, just to even things up a bit more.\n    p.xy += iTime*speed*vec2(1, .0);\n    col *= vec3(1.03, 1, .97);\n    // Noise, with custom frequency and amplitude distribution.\n    col *= ((n2D(p*16.)*.4 + n2D(p*36.)*.25 + n2D(p*80.)*.2 + n2D(p*180.)*.15)*.2 + .9);\n    \n    // Failed color experiment.\n    //col = mix(col, col.zyx, uv.y*.5);\n  \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2243, 2276, 2298, 2298, 2356], [2359, 2387, 2408, 2408, 2470], [2820, 2820, 2872, 2872, 3381], [3385, 3609, 3628, 3628, 3870], [3873, 3873, 3894, 3894, 4107], [4109, 4246, 4264, 4264, 4362], [4366, 4393, 4429, 4429, 4770], [4774, 4851, 4873, 4873, 5601], [5605, 5634, 5676, 5867, 6315]], "test": "untested"}
{"id": "wtGfWw", "name": "shader challenge 20210227", "author": "butadiene", "description": "shader challenge ", "tags": ["2d"], "likes": 8, "viewed": 314, "published": 3, "date": "1614425950", "time_retrieved": "2024-07-30T19:35:38.599831", "image_code": "#define time mod(iTime,1000.)\nfloat PI = 3.1415926535;\n#define bpm 120.\nvec2 pmod(vec2 p,float n){\n  float np = 2.0*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n  \n  }\n\nfloat func(float x, float y, float z) {\n    z = fract(z), x /= pow(2.,z), x += z*y;\n    float v = 0.;\n    for(int i=0;i<6;i++) {\n        v += asin(sin(x)) * (1.-cos((float(i)+z)*1.0472));\n        v /= 2., x /= 2., x += y;\n    }\n    return v * pow(2.,z);\n}\n\n\nmat2 rot (float r){\n  \n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n\n vec3 outco(vec2 p){\n  vec3 col = vec3(0);\n   vec2 ssp = p;\n  float iter = 6.;\n  float sit = 1.+floor(mod(time*bpm/60.,iter));\n  for(int i = 0;i<6;i++){\n    if(sit>float(i)){\n       p *= rot(PI*float(i)/iter);\n       p = pmod(p,3.);\n    \n      col += vec3(func(p.x,time*3.,-0.1*time));\n      p = ssp;\n     }\n   \n  }\n  col /= sit;\n  col *= (12.+sit)/12.;\n  return col;\n  }\n  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p =uv- 0.5;\n\tp /= vec2(iResolution.y / iResolution.x, 1);\n    vec2 sp = p;\n    vec3 col = vec3(0);\n  \n    p *= 100.;\n\n    p = sp;\n    p += 0.1*func(uv.x*100.,uv.y*100.,time)*pow(abs(sin(8.*time*bpm/60.)),16.);\n    float  scale = 800.;\n    p *= scale;\n    vec2 ep = 0.5*scale*vec2(0.01,0.01)*(uv-0.5);\n    col.b += outco(p).r;\n    p += ep;\n    col.g += outco(p).r;\n    p -=2.*ep; \n    col.r += outco(p).r;\n\n  \n  col *= 0.2+pow(abs(sin(4.*time*108./60.)),2.);\n  col = 1.5*pow(col,vec3(1.4,1.4,1.2));\n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 98, 98, 229], [489, 489, 508, 508, 560], [563, 563, 582, 582, 933], [939, 939, 996, 1046, 1625]], "test": "untested"}
{"id": "WtyBDm", "name": "iceberger 3 - object space", "author": "FabriceNeyret2", "description": "variant preserving drawing (but limited bound)\nreproducing [url]https://joshdata.me/iceberger.html[/url] Using smart MIPmaps.\nDraw iceberg (TAB to erase).    SPACE to start/pause the physics.\nRed dot = center of mass, \nGreen dot = immerged center of mass.", "tags": ["simulation", "physics", "reproduction", "gpmipmap", "iceberger"], "likes": 5, "viewed": 409, "published": 3, "date": "1614419077", "time_retrieved": "2024-07-30T19:35:39.374759", "image_code": "// reference-space variant of https://shadertoy.com/view/3tGfzW\n// power-of-2 variant of \"iceberger\" https://shadertoy.com/view/tlKfzz\n// ( otherwise MIPmap is way to bugged )\n// reproducing https://joshdata.me/iceberger.html\n\nvoid mainImage( out vec4 O, vec2 U )\n{ \n    U = 1024.*( .56* ( U - L*iResolution.xy ) / iResolution.y + L );\n    O = T2(U).x - T2(U).y *vec4(.3,.3,-1,0); \n      \n    O = mix(O, vec4(1,0,0,0), D( G.xy, 10.) );\n    O = mix(O, vec4(0,1,0,0), D( G.zw, 10.) );\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define L              vec2(.5,.7)\n#define R              vec2(1024) // iResolution.xy\n#define dt            ( .5*iTimeDelta )\n#define T(U)           texture( iChannel0, vec3( 2.*(U)/R -1., 1 ).xzy )\n#define T1(U)          texture( iChannel0,(vec3( 2.*(U)/R -1., 1 )*vec3( 1,-1,-1)).xzy )\n#define T2(U)          texture( iChannel0,(vec3( 2.*(U)/R -1., 1 )*vec3(-1,-1, 1)).zyx )\n#define M            ( textureLod(iChannel0,vec3(1, 0, 0) , 20.) +1e-9 ) // total mass\n#define G              textureLod(iChannel0,vec3(0,-1, 0) , 20.)         // center of mass\n#define D(C,r)         smoothstep( 1.5, 0., length(C-U) - r )            // antialiased disk\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define rot(a)         mat2( cos(a), -sin(a), sin(a), cos(a) )", "cube_a_code": "// transform Word coords to Object coords.  T(.5).zw = trans.y, rot \n#define transform(V) ( ( V-G.xy ) * rot( T(.5).w ) + G.xy - vec2(0,T(.5).z) )\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    if (D.y > max(A.x,A.z)) {       // --- side 1 -------------\n                                                            // O.x = iceberg\n        O = T(U);                                           // previous step \n        if ( U.x < 2. && U.y < 2.) {\n            vec3 F = keyToggle(32.)                         // --- physics \n                // ? G.zww - G.xyy*vec3(1,1,.95) : vec3(0); // torque+force applying on the iceberg\n                   ? vec3(G.z - G.x,-.1*M.z/M.x*.1*R.y, -(.9 - M.z/M.x)*4.*R.y) : vec3(0); // correct physics\n            F.x = sign(F.x) * max(0., abs(F.x)-2.);         // stabilizer (because delayed reaction)\n            if (U.x>1.)\n                O.z = .98*O.z + F.z*dt,                     // vertical velocity\n                O.w = .98*O.w + F.x*F.y*dt*dt;              // angular velocity\n            else\n                O.zw += T(1.5).zw*dt;                       // vertical position; rotation\n        } \n   \n        vec2 s = iChannelResolution[1].xy,                  // screen resolution\n             m = 1024.*( .56* ( iMouse.xy - L*s ) / s.y + L ); // transform screen to 1024x1024 cubemap coords\n        m = transform(m);                                   // transform mouse to object frame \n        if (iMouse.z>0.)                                    // --- paint\n               O.x = keyToggle(9) \n                       ? max( 0., O.x - D( m, .05*R.y ) )   // erase iceberg\n                       : max(O.x,       D( m, .05*R.y ) );  // paint iceberg\n\n     // U = R-1.-abs(2.*U-R); if (U.x*U.y<.5) O.x = 0.;     // clamp paint\n    }\n    else if (-D.y >  max(A.x,A.z)) { // --- side 2 -------------\n    \n    // ultimate MIPmap of O.xy = center of mass\n    // ultimate MIPmap of O.zw = immerged center of mass\n                                                            // --- physics ( rot+translate transforms )\n                                                            // redond side 3 to avoid loosing 1 frame\n        vec2 V = transform(U);\n        O.x = T(V).x;                                       // object transformed by physics ( rot+translate )\n        O.y = step( U.y/R.y , L.y );                        // ocean\n        O.z = O.x*O.y;                                      // immerged part of the iceberg    \n        O /= M;                                             // density field\n\n        O.xy = O.x * U;     // prepare spatial moments of iceberg shape (total vs immerged)\n        O.zw = O.z * U;\n    }\n\n    else if ( D.x >  max(A.y,A.z)) { // --- side 3 -------------\n    // O.x = iceberg, O.y = ocean, O.z = immerged iceberg.  \n    // Ultimate MIPmap = mass (i.e., volume )\n                                                            // --- physics ( rot+translate transforms )\n        vec2 V = transform(U);\n        O.x = T(V).x;                                       // object transformed by physics ( rot+translate )\n        O.y = step( U.y/R.y , L.y );                        // ocean\n        O.z = O.x*O.y;                                      // immerged part of the iceberg    \n    }\n    \n    if (iFrame<1) O=vec4(0);\n}\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// guess what is the purpose of this buffer ;-)\nvoid mainImage( out vec4 O, vec2 U ) {}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 265, 265, 484]], "test": "untested"}
{"id": "WtyfWm", "name": "Random procedural textures", "author": "jarble", "description": "This shader makes procedural textures with many different colors and patterns.", "tags": ["procedural", "texture", "random"], "likes": 1, "viewed": 272, "published": 3, "date": "1614404761", "time_retrieved": "2024-07-30T19:35:40.203543", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 8.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        float scale = 2.0;\n        float scale1 = 1.7;\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0))*scale1;\n        //vec3 random = hash31(10.0);\n        \n        for(int i=0;i<3;i++)\n        {\n            uv.y *= scale1;\n            uv=fract(uv/(scale1)+(uv.yx/(scale1))/scale);\n            uv = fract1(uv/scale1,random.xy,scale1)*scale1;\n            uv /= scale;\n            uv=uv.yx+col.yx;\n            uv.y *= -1.0;\n            //col = col.yzx;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 359, 359, 412], [414, 414, 471, 471, 1355]], "test": "untested"}
{"id": "WlyBWm", "name": "Abstract snowflake patterns", "author": "jarble", "description": "This fractal formula makes a kaleidoscopic snowflake pattern.", "tags": ["fractal", "mechanical", "robotic"], "likes": 1, "viewed": 253, "published": 3, "date": "1614402348", "time_retrieved": "2024-07-30T19:35:40.968497", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 2.0;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 1.5;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0));\n        //vec3 random = hash31(10.0);\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy,scale1)*scale1;\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(uv/(scale1+(-fract(uv.x+uv.y)))+(uv.yx/(scale1))/scale);\n            uv /= scale1;\n\n            uv=uv.yx+col.yx;\n            uv.y *= -1.0;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 359, 359, 412], [414, 414, 471, 471, 1472]], "test": "untested"}
{"id": "3lGfDw", "name": "Kaleidoscopic fractal", "author": "jarble", "description": "This simple fractal formula makes a kaleidoscope pattern.", "tags": ["fractal", "mechanical", "robotic"], "likes": 2, "viewed": 239, "published": 3, "date": "1614394607", "time_retrieved": "2024-07-30T19:35:41.737441", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        //float scale = 4.0;\n        float scale1 = 2.5;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0));\n        //vec3 random = hash31(21.0);\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy,scale1)+fract1(uv/scale1,random.xy,scale1);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(uv/(scale1)+(uv.yx));\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= scale1;\n            uv = uv.yx;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 359, 359, 412], [414, 414, 471, 471, 1492]], "test": "untested"}
{"id": "WlGBWw", "name": "mouse calles y edificio v3", "author": "jorge2017a1", "description": "mouse calles y edificio v3", "tags": ["mousecallesyedificiov3"], "likes": 5, "viewed": 228, "published": 3, "date": "1614376122", "time_retrieved": "2024-07-30T19:35:42.691889", "image_code": "//por jorge2017a1-\n\n//Referencia\n// GRacias a ollj, por la referencia\n///https://www.shadertoy.com/view/3stXR2 ........Created by munrocket in 2019-10-29\n/* quaternions */\n///https://www.shadertoy.com/view/WdyyRt\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nfloat iTimeGlobal;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec3 Casa1(vec3 p)\n{\n    vec3 res;\n    res = vec3(9999.0, -1.0,-1.0);\n    float anchoZ=5.0;\n    float  sdCasa= sdBox(p-vec3(0.0,0.0,0.0), vec3(10.0,8.0,anchoZ) );\n    \n    float  sdventana1dif= sdBox(p-vec3(-7.0,-1.0,0.0), vec3(2.2,3.2,anchoZ+ .2) );\n    float  sdventana2=    sdBox(p-vec3(-7.0,-1.0,-2.5), vec3(2.0,3.0,0.5) );\n    float  sdProteccion1=  sdBox(p-vec3(-8.0,-1.0,-3.5), vec3(0.25,3.0,0.5) );\n    float  sdProteccion2=  sdBox(p-vec3(-7.0,1.0,-3.5), vec3(2.0,0.25,0.5) );\n    \n    float  sdpuerta1dif= sdBox(p-vec3(0.0,-4.2, 0.0), vec3(2.5,4.0,anchoZ+.2) );\n    float  sdpuerta2=    sdBox(p-vec3(0.0,-4.2,-3.5), vec3(2.5,4.0,0.5) );\n    \n    \n    //diferencia casa y ventana\n    float difcasa= differenceSDF(sdCasa, sdventana1dif);\n    difcasa= differenceSDF(difcasa, sdpuerta1dif);\n    \n    \n    res =opU3(res, vec3(difcasa, -1.0, 6.0)); \n    res =opU3(res, vec3(sdventana2,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdProteccion1,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdProteccion2,0.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdpuerta2,2.0,MATERIAL_NO)); \n    return res;\n}      \n        \n        \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n    float planeDist1 = p.y+0.0;  //piso inf\n    \n    vec3 posA=p;\n    posA.z= opRep1D(posA.z, 60.0 );\n    posA.x= opRep1D(posA.x, 60.0 );\n    vec3 prepLinea1=posA;\n    \n    prepLinea1.z= opRep1D( prepLinea1.z, 10.0 );\n    \n    \n    //hacer calle A\n    float sdr1A= sdRoundBox(posA-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr1B= sdRoundBox(posA-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr1C= sdRoundBox(posA-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea1= sdRoundBox(prepLinea1-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    \n    \n    //hacer calle B\n    vec3 posB=p-vec3(-30.0,0.0,30.0);\n    posB.z= opRep1D(posB.z, 60.0 );\n    posB.x= opRep1D(posB.x, 60.0 );\n    posB= rotate_y(posB, radians(90.0));\n    vec3 prepLinea2=posB;\n    \n    prepLinea2.z= opRep1D( prepLinea2.z, 10.0 );\n    \n    float sdr2A= sdRoundBox(posB-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr2B= sdRoundBox(posB-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr2C= sdRoundBox(posB-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea2= sdRoundBox(prepLinea2-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    //calle centro\n    vec3 posC=p-vec3(0.0,0.0,30.0);\n     posC.z= opRep1D(posC.z, 60.0 );\n     posC.x= opRep1D(posC.x, 60.0 );\n     \n    float sdr3A= sdRoundBox(posC-vec3(0.0), vec3(10.0,1.0,10.0), 0.2 );\n    \n   \n     //jardin\n     vec3 posD=p-vec3(-30.0,0.0,-13.0);\n     posD.z= opRep1D(posD.z, 58.0 );\n     posD.x= opRep1D(posD.x, 55.0 );\n \n     vec3 vdr4A= Casa1(posD-vec3(.0,8.0,12.));\n     \n   \n    //calle a\n    res =opU3(res, vec3(sdr1A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr1B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr1C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea1,2.0,-1.0)); \n    // calle b\n    res =opU3(res, vec3(sdr2A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr2B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr2C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea2,2.0,-1.0)); \n    //calle c\n    res =opU3(res, vec3(sdr3A,-1.0,4.0)); \n    res =opU3(res, vdr4A ); \n    \n    res =opU3(res, vec3(planeDist1,3.0,-1.0)); \n \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro, vec3 col) \n{\n    vec3 l = lp - p;\n   \n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*col;\n   \n    return lin*atten*col*2.0;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    mObj.hitbln =false;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if ( abs(dS.x)<MIN_DIST)\n        { mObj.hitbln = true; break; }\n        \n        if(dO>MAX_DIST)\n        {   mObj.hitbln = false; break; }\n        \n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro,colobj);\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n//------------------------------------------------\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//Created by dr2 in 2016-01-24\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\n\nvec3 sky(vec3 rd, vec3 L)\n{\n  return vec3(1.-rd.y,0.9,1.+(rd.y-dot(rd,L))*.5)*(0.4*dot(rd,L)+0.6);\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n     //float cc=mObj.id_color;\n     float cc=10.0;\n     float nMol=10.0;\n     return   HsvToRgb (vec3 (mod (1.7 * cc / float (nMol), 1.), 1. - 0.3 * mod (cc, 3.), 1. - 0.3 * mod (cc, 2.))); \n            \n    }\n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n// Thanks to Baron for this\nvec3 getSkyCol(vec3 rd) {\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t;\n    t=mod(iTime*2.0,1000.0);\n    iTimeGlobal=t;\n    \n    itime=t;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;    \n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 8., -2.+t);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.01);\n    dir = rotate(dir, mouse);\n   \n   mObj.uv=uv;\n    \n\tmObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 0.0, 20.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n\n \n    vec3 ro=camera;\n    vec3 rd=dir;\n    rd.xz= rotatev2(rd.xz, radians(180.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    \n    \n    Obj=mObj;\n    \n    vec3 p = (ro + rd * d ); \n    \n    if(mObj.hitbln) \n    {\n   \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    \n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n     result/=1.25;\n    col=result;\n    \n    //sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n     \n    col *= 1.0 - pow(d /(MAX_DIST) , 2.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    }\n    else if(d>MAX_DIST)\n    col= getSkyCol(rd);\n    \n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n    bool hitbln;\n    //https://www.shadertoy.com/view/WdyyRt\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n//https://www.shadertoy.com/view/3stXR2 \n\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[616, 616, 652, 652, 673], [674, 674, 706, 706, 790], [791, 791, 837, 837, 924], [926, 970, 1017, 1017, 1044], [1046, 1046, 1089, 1089, 1116], [1118, 1118, 1166, 1166, 1194], [1195, 1279, 1315, 1315, 1360], [1361, 1426, 1460, 1460, 1558], [1559, 1559, 1593, 1593, 1685], [1686, 1686, 1720, 1720, 1812], [1813, 1853, 1887, 1887, 1984], [1987, 1987, 2007, 2007, 3082], [3108, 3148, 3173, 3173, 5441], [5445, 5445, 5520, 5520, 6121], [6125, 6176, 6200, 6200, 6388], [6389, 6452, 6485, 6485, 7078], [7080, 7134, 7170, 7170, 7404], [7405, 7494, 7574, 7574, 7841], [7843, 7894, 7916, 7916, 8085], [8087, 8118, 8142, 8142, 8278], [8281, 8281, 8308, 8308, 8381], [8383, 8434, 8481, 8481, 9274], [9328, 9328, 9421, 9421, 9701], [9703, 9731, 9756, 9756, 9866], [9869, 9918, 9975, 9975, 11510]], "test": "untested"}
{"id": "wlVfDD", "name": "Psychedelic Bacteria", "author": "dlozeve", "description": "What if?", "tags": ["psychedelic"], "likes": 1, "viewed": 322, "published": 3, "date": "1614374647", "time_retrieved": "2024-07-30T19:35:43.465820", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                           vec4(0.0, i1.y, i2.y, 1.0)) +\n                   i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  // vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  // vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 105.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord.xy / iResolution.xy;\n  float h = snoise(vec3(7.0 * p, iTime / 10.0) + vec3(iTime) / 10.0);\n  float m = sin(33.0 * h + iTime * 2.0) * 0.2 + 0.5;\n  vec3 color = hsv2rgb(vec3(m, 1.0, float(abs(h) > 0.15)));\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfDD.jpg", "access": "api", "license": "mit", "functions": [[450, 450, 471, 471, 518], [519, 519, 540, 540, 587], [588, 588, 610, 610, 651], [652, 652, 680, 680, 730], [732, 732, 754, 754, 2908], [2910, 2910, 2932, 2932, 3095], [3097, 3097, 3154, 3154, 3414]], "test": "untested"}
{"id": "wtKfDD", "name": "Vorofbm", "author": "mrange", "description": "License CC0: Metallic Voronot Roses\nIf you got a decent height function, apply FBM and see if it makes it more interesting\nBased upon: https://www.shadertoy.com/view/4tXGW4\n", "tags": ["2d", "fbm", "voronot"], "likes": 34, "viewed": 743, "published": 3, "date": "1614373123", "time_retrieved": "2024-07-30T19:35:44.236759", "image_code": "// License CC0: Metallic Voronot Roses\n//  If you got a decent height function, apply FBM and see if it makes it more interesting\n//  Based upon: https://www.shadertoy.com/view/4tXGW4\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 hash(vec2 p) {\n  p += 0.5;\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\nfloat height_(vec2 p, float tm) {  \n  p *= 0.125*1.5;\n  vec2 n = floor(p + 0.5);\n  vec2 r = hash(n);\n  p = fract(p+0.5)-0.5;\n  float d = length(p);\n//  p.x = pabs(p.x, 0.025);\n//  p.x = abs(p.x);\n//  p *= ROT(-TIME*0.1-1.5*d-(-0.5*p.y+2*p.x)*1) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float ltm = tm+10.0*(r.x+r.y);\n    float v = length(fract(vec2(x - ltm*i*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.125*pabs(1.0-tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\n\nfloat height(vec2 p) {\n  float tm = TIME*0.00075;\n  p += 100.0*vec2(cos(tm), sin(tm));\n  const float aa = -0.35;\n  const mat2  pp = 0.9*(1.0/aa)*ROT(1.0);\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 6; ++i) {\n    h += a*height_(p, 0.125*TIME+10.0*sqrt(float(i)));\n    h = pmin(h, -h, 0.025);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  return (h/d);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = tanh(0.33*col);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfDD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[393, 393, 421, 441, 517], [519, 519, 558, 558, 643], [645, 645, 684, 684, 713], [715, 715, 745, 745, 772], [774, 774, 793, 793, 928], [929, 929, 962, 962, 1524], [1527, 1527, 1549, 1549, 1909], [1911, 1911, 1932, 1932, 2138], [2140, 2140, 2160, 2160, 3192], [3194, 3194, 3230, 3230, 3463], [3465, 3465, 3520, 3520, 3729]], "test": "untested"}
{"id": "wtKfWW", "name": "Dither fractal, scalable, no rng", "author": "danielsturk", "description": "Predictable noise", "tags": ["noise"], "likes": 1, "viewed": 89, "published": 3, "date": "1614355705", "time_retrieved": "2024-07-30T19:35:45.120396", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    uv /= 10.;\n    \n    float weight = 1.;\n    float value = .5;\n    mat2 rotate = mat2(0, -1, 1, 0);\n    for(int i = 0; i < 3; i++) {\n        vec2 xy = vec2(greaterThan(fract(uv * .5), vec2(.5, .5)));\n        xy = rotate * (xy - vec2(.5)) + vec2(.5);\n        xy.y = xy.x * (1. - xy.y) +  (1. - xy.x) * xy.y; //if(xy.x) xy.y = !xy.y;\n        float delta = dot(\n            xy,\n            vec2(.25, .5)\n        ) - (3. / 8.);\n        delta *= weight;\n        \n        value += delta;\n        weight *= .25;\n        \n        uv *= .5;\n        rotate *= rotate;\n    }\n    \n    // value = fract(value + iTime * .01);\n    fragColor = vec4(vec3(value),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 735]], "test": "untested"}
{"id": "WtKBDD", "name": "Cybercity Block", "author": "YitingLiu", "description": "creating a city block that responds to music ", "tags": ["grid", "rotate", "star", "galaxy", "starfield", "infinite", "food", "artofthecode", "cereal", "dinner"], "likes": 0, "viewed": 307, "published": 3, "date": "1614353427", "time_retrieved": "2024-07-30T19:35:45.988077", "image_code": "// followed tutorials https://youtu.be/rvDo9LvfoVE\n//https://youtu.be/dhuigO4A7RY\n\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n\n}\n//creating different shapes\n//responsive to audio \nfloat Star(vec2 uv, float flare){\n    float d = dot(uv.x,uv.y/2.);//distance to the center \n    float m = .005/d;//more light like than smoothstep(.1,.05,d);\n   // uv*=Rot(3.1415/4.);\n    float rays= max(0.,1.-abs(uv.x*uv.y*10.)); \n   //m =flare*rays;\n    \n \n   m=smoothstep(.025,.05,d/8.);\n  // m=1.-smoothstep(.08,.05,d);\n    \n    return m;\n\n\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y*p.x*p.y/atan(p.x,p.y));\n    \n\n}\n\nvec3 StarLayer(vec2 uv) {\n\tvec3 col = vec3(0);\n\t\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    // should add <=\n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            \n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.6, .5, size)*.6);\n            \n            vec3 color = sin(vec3(.5, .1, .9)*fract(n*520.)*1238.2)*.5+.5;\n            color = color*vec3(1,.2,.8+size)+vec3(.2, .2, .1)*2.;\n            \n            star+= sin(iTime*2.+n*6.2831)*.5+1.;\n            col =star*size*color;\n        }\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.03;\n       float fft  = texelFetch( iChannel0, ivec2(0.5,0.2), 0 ).x; \n    \n     \n \n    vec3 col = vec3(0);\n\n    for (float i =0.; i <1.;i+=1./NUM_LAYERS){\n\n        float depth = fract(i+t);\n        //if mouse is engaged\n      float scale = mix (mix(10.,100.,length(uv-M)),.8,depth);\n        // if mouse is not engaged\n        \n       scale -= mix (mix(10.,50.,length(uv-1.-mix(-2.,2.,fft*max(uv.y,uv.x)))),.2,depth);\n\n       //scale *= mix (mix(1.,5.,length(min(uv.y,uv.x)*.5+.5+fft)),.5,depth);\n\n       // scale = mix (mix(10.,100.,length(uv-M)),.8,depth);\n        float fade = depth*(1.-smoothstep(.5, .8, depth));\n        col += StarLayer(tan(t)-uv*scale+i*20.*M)*fade-Hash21(uv);\n\n    }\n    \n     uv*=Rot(t);\n     uv.x+=max(t*.0001,.8);\n    uv.y-=max(t*.0001,.5);\n\n\n    \n        col = pow(col, vec3(.85));\t// gamma correction\n \n    \n    //if(gv.x>.48|| gv.y>.48) col.r=1.;//coloring the grid\n  \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25635, "src": "https://soundcloud.com/biiggpiigg/cuenta-lo", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 124, 124, 184], [185, 236, 269, 269, 582], [584, 584, 605, 605, 726], [728, 728, 753, 753, 1449], [1450, 1450, 1507, 1507, 2588]], "test": "untested"}
{"id": "WlXcRM", "name": "Raytracing kaoD", "author": "kaoD", "description": "Ray. Tracing.\n\nRaytracing.", "tags": ["raytracing"], "likes": 6, "viewed": 375, "published": 3, "date": "1614348370", "time_retrieved": "2024-07-30T19:35:46.815863", "image_code": "vec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color *= .5;\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* CONSTANTS */\nconst float PI = 3.14159;\n\nconst float TWO_PI = 2. * PI;\n\nconst float TO_RAD = PI / 180.;\n\n/* TYPES */\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n};\n\nstruct RayHit {\n    float d;\n    vec3 n;\n    Material m;\n};\n    \nstruct Sphere {\n    vec3 p;\n    float r;\n};\n    \nstruct Quad {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n\n/* CONFIG */\n\n// Coordinate system -- Right handed\nconst vec3 UP = vec3(0, 1, 0);\n\n// Camera\nconst vec3 RO = vec3(0, 0, 0);\nconst vec3 RT = vec3(0, 0, 10);\nconst float FOVX = 120. * TO_RAD;\n\n// Ray tracing\nconst float MIN_RAY_HIT_DIST = .01;\nconst float FAR_DIST = 10000.;\nconst uint NUM_BOUNCES = 8u;\nconst float NORMAL_NUDGE = .01;\nconst uint SAMPLES = 10u;\n\n\n/* FUNCTIONS */\n\nvec3 LessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}", "buffer_a_code": "vec3 SRGBToLinear(vec3 rgb)\n{\n    return rgb;\n     \n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 rd, float fovx) {\n    vec3 f = rd;\n    vec3 r = cross(UP, f);\n    vec3 u = cross(f, r);\n    \n    float zoom = 1. / tan(fovx / 2.);\n    vec3 c = ro + rd*zoom;\n    vec3 i = c + r*uv.x + u*uv.y;\n    \n    return normalize(i - ro);\n}\n\n\n// ¿?¿?\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w) {\n    return dot(cross(u, v), w);\n}\n\n//\n \nbool testQuadTrace(vec3 ro, vec3 rd, inout RayHit hit, Quad quad) {\n    vec3 a = quad.a, b = quad.b, c = quad.c, d = quad.d;\n    \n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(quad.c-quad.a, quad.c-quad.b));\n    \n    if (dot(normal, rd) > 0.) {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f) {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    } else {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rd.x) > .1) {\n        dist = (intersectPos.x - ro.x) / rd.x;\n    } else if (abs(rd.y) > .1) {\n        dist = (intersectPos.y - ro.y) / rd.y;\n    } else {\n        dist = (intersectPos.z - ro.z) / rd.z;\n    }\n    \n\tif (dist > MIN_RAY_HIT_DIST && dist < hit.d) {\n        hit.d = dist;        \n        hit.n = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n \nbool testSphereTrace(vec3 ro, vec3 rd, inout RayHit hit, Sphere sphere) {\n    vec3 m = ro - sphere.p;\n\tfloat b = dot(m, rd);\n\tfloat c = dot(m, m) - sphere.r * sphere.r;\n\n    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0) return false;\n\n\tfloat discr = b * b - c;\n\n    //a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.) return false;\n    \n    //ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat d = -b - sqrt(discr);\n    \n    if (d < 0.) {\n        fromInside = true;\n        d = -b + sqrt(discr);\n    }\n    \n\tif (d > MIN_RAY_HIT_DIST && d < hit.d) {\n        hit.d = d;        \n        hit.n = normalize((ro + rd*d) - sphere.p) * (fromInside ? -1. : 1.);\n        return true;\n    }\n    \n    return false;\n}\n\nconst Quad BOX_BACK = Quad(\n    vec3(-12.6, -12.6, 25),\n    vec3( 12.6, -12.6, 25),\n    vec3( 12.6,  12.6, 25),\n    vec3(-12.6,  12.6, 25)\n);\nconst Quad BOX_FLOOR = Quad(\n    vec3(-12.6, -12.45, 25),\n    vec3( 12.6, -12.45, 25),\n    vec3( 12.6, -12.45, 5),\n    vec3(-12.6, -12.45, 5)\n);\nconst Quad BOX_CEILING = Quad(\n    vec3(-12.6, 12.5, 25),\n    vec3( 12.6, 12.5, 25),\n    vec3( 12.6, 12.5, 15),\n    vec3(-12.6, 12.5, 15)\n);\nconst Quad BOX_LEFT = Quad(\n    vec3(-12.5, -12.6, 25),\n    vec3(-12.5, -12.6, 15),\n    vec3(-12.5,  12.6, 15),\n    vec3(-12.5,  12.6, 25)\n);\nconst Quad BOX_RIGHT = Quad(\n    vec3( 12.5, -12.6, 25),\n    vec3( 12.5, -12.6, 15),\n    vec3( 12.5,  12.6, 15),\n    vec3( 12.5,  12.6, 25)\n);\nconst Quad QUAD_LIGHT = Quad(\n    vec3(-5, 12.4, 22.5),\n    vec3( 5, 12.4, 22.5),\n    vec3( 5, 12.4, 17.5),\n    vec3(-5, 12.4, 17.5)\n);\nconst Sphere SPHERE_LEFT = Sphere(vec3(-9, -9.5, 20), 3.);\nconst Sphere SPHERE_CENTER = Sphere(vec3( 0, -9.5, 20), 3.);\nconst Sphere SPHERE_RIGHT = Sphere(vec3( 9, -9.5, 20), 3.);\n\nconst Material MATERIAL_METAL = Material(vec3(.7), vec3(0), .7);\nconst Material MATERIAL_WHITE = Material(vec3(.7), vec3(0), 1.);\nconst Material MATERIAL_RED = Material(vec3(.7, .1, .1), vec3(0), 0.);\nconst Material MATERIAL_GREEN = Material(vec3(.1, .7, .1), vec3(0), 1.);\nconst Material MATERIAL_LIGHT = Material(vec3(0), vec3(1., .9, .7) * 20., 1.);\nconst Material MATERIAL_YELLOW = Material(vec3(.9, .9, .5), vec3(0), 0.);\nconst Material MATERIAL_PINK = Material(vec3(.9, .5, .9), vec3(0), 1.);\nconst Material MATERIAL_CYAN = Material(vec3(.5, .9, .9), vec3(0), 1.);\n\nvoid testSceneTrace(vec3 ro, vec3 rd, inout RayHit hit) {\n    if (testQuadTrace(ro, rd, hit, BOX_BACK)) {\n        hit.m = MATERIAL_METAL;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_FLOOR)) {\n        hit.m = MATERIAL_WHITE;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_CEILING)) {\n        hit.m = MATERIAL_WHITE;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_LEFT)) {\n        hit.m = MATERIAL_RED;\n    }\n    if (testQuadTrace(ro, rd, hit, BOX_RIGHT)) {\n        hit.m = MATERIAL_GREEN;\n    }\n    if (testQuadTrace(ro, rd, hit, QUAD_LIGHT)) {\n        hit.m = MATERIAL_LIGHT;\n    }\n\tif (testSphereTrace(ro, rd, hit, SPHERE_LEFT)) {\n        hit.m = MATERIAL_YELLOW;\n    } \n    if (testSphereTrace(ro, rd, hit, SPHERE_CENTER)) {\n        hit.m = MATERIAL_PINK;\n    }\n\tif (testSphereTrace(ro, rd, hit, SPHERE_RIGHT)) {\n        hit.m = MATERIAL_CYAN;\n    }\n}\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * TWO_PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n \nvec3 getRayColor(vec3 ro, vec3 rd, inout uint rngState) {\n    vec3 ret = vec3(0);\n    vec3 throughput = vec3(1);\n     \n    for (uint i = 0u; i <= NUM_BOUNCES; i++) {\n        // shoot a ray out into the world\n        RayHit hit;\n        hit.d = FAR_DIST;\n        testSceneTrace(ro, rd, hit);\n         \n        // if the ray missed, we are done\n        if (hit.d == FAR_DIST) {\n            ret += SRGBToLinear(texture(iChannel1, rd).rgb) * throughput * .5;\n            break;\n        }\n            \n        // update the ray position\n        ro = (ro + rd * hit.d) + hit.n * NORMAL_NUDGE;\n\n        // Calculate a new ray direction.\n        // Diffuse uses a normal oriented cosine weighted hemisphere sample.\n        // Perfectly smooth specular uses the reflection ray.\n        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared\n        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.\n        vec3 diffuseRayDir = normalize(hit.n + RandomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rd, hit.n);\n        rd = normalize(mix(specularRayDir, diffuseRayDir, hit.m.roughness * hit.m.roughness));\n\n        // add in emissive lighting\n        ret += hit.m.emissive * throughput;\n\n        // update the colorMultiplier\n        throughput *= hit.m.albedo;\n        \n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (RandomFloat01(rngState) > p)\n                break;\n\n            // Add the energy we 'lose' by randomly terminating paths\n            throughput *= 1.0f / p;\n        }\n    }\n  \n    // return pixel color\n    return ret;\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    float AR = iResolution.x/iResolution.y;\n    \n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    \n    vec2 uv = (fragCoord + jitter)/iResolution.xy;\n    uv *= 2.;\n    uv -= 1.;\n    uv.y /= AR;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    m *= 2.;\n    m -= 1.;\n    m.y /= AR;\n    \n    vec3 ro = RO - vec3(m * 10., 0);\n    vec3 rd = normalize(RT - ro);\n    vec3 rdd = getRayDir(uv, ro, rd, FOVX);\n\n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    //bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    bool spacePressed = iMouse.xy != vec2(0,0) && iMouse.z >= 0. && iMouse.w >= 0.;\n\n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    lastFrameColor.a = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : lastFrameColor.a;\n    \n    for (uint i = 0u; i < SAMPLES; i++) {\n        vec3 color = getRayColor(ro, rdd, rngState);\n        color = mix(lastFrameColor.rgb, color, lastFrameColor.a);\n        lastFrameColor = vec4(color, 1.0f / (1.0f + (1.0f / lastFrameColor.a)));\n    }\n\n    // show the result\n    fragColor = lastFrameColor;\n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlXcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 205], [207, 338, 361, 361, 533], [535, 535, 587, 587, 769]], "test": "untested"}
{"id": "tl3fRS", "name": "Coaster Jungle", "author": "Plento", "description": "A lil raymarch scene. Next I want to make an actual train like a few examples I've seen on here. ", "tags": ["3d", "rollercoaster"], "likes": 26, "viewed": 489, "published": 3, "date": "1614336704", "time_retrieved": "2024-07-30T19:35:47.624701", "image_code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// Dave Hashkin hash\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// Reflect across an axis\nvec3 ref(vec3 rp, vec3 q){\n    return -vec3(abs(rp.x), abs(rp.y), abs(rp.z)) + q*step(vec3(0), q);\n}\n\n\nfloat rbox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat line( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat rcyl( vec3 p, float ra, float rb, float h ){\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n// track height\nfloat h(float x){\n    return cos(x * 3.4) * .18 + cos(x * 1.2)*.1;\n}\n\n// Slope\nfloat hp(float x){\n    return (-3.4*sin(x * 3.4) * .18) + (-1.2*sin(x *1.2)*.1);\n}\n\n// Track width\n#define tw 0.12\n// Car size\n#define cs vec3(.08, .03, .04)\n//Car seperation\n#define sep 1.5\n\n\n\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    rp.xy*=rot(rp.z*.23);\n    vec3 p = rp, p0 = rp;\n    \n    float tId = floor(p.z / sep);\n    float to = hash11(tId*999.)*5.;\n   \n    p.y -= cos(tId*2.) * .2;\n    float tX = iTime*.78 * sign(cos(tId*4.))*min(to, .8);\n    \n    float trackHeight = h(p.x + to);\n    \n    p.zy = mod(p.zy, sep)-sep*.5;\n    p.y += trackHeight;\n    \n    p.x = mod(p.x, 0.2)-0.2*.5;\n    d = min(line(p, vec3(0., 0., -tw), vec3(0., 0., tw), 0.01), d);\n    p.xy*=rot(3.14/2.);\n    d = min(rcyl(ref(p, vec3(0., 0.0, tw)), .006, .001, .2), d);\n    \n    p = p0;\n    p.y -= cos(tId*2.) * .2;\n    p.x -= tX;\n    \n    float cId = floor(p.x);\n    \n    float carHeight = h(tX + cId + cs.x*2. + .35 + to);\n    float trackDer = hp(tX + cId + cs.x*2. + .35 + to);\n    \n    p.x = mod(p.x, 1.)-1.*.5;\n    p.zy = mod(p.zy, sep)-sep*.5;\n    \n    p.xy *= rot(trackDer);\n    p.y += carHeight - cs.y + .11;\n    \n    d = min(rbox(p + vec3(0., 0., 0.), cs, 0.05), d);\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 1.7));\n    vec3 ro = vec3(0., .0, iTime+10.);\n    \n    float d = 0.0, t = 0.0;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(abs(d) < 0.003 || t > 20.) break;\n        \n        t += abs(d) * .62;\n    }\n    \n    vec3 p = ro + rd*t;\n    \n    vec3 sky = mix(vec3(0.7, 0.9, 0.9), vec3(0.95, 0.47, 0.36), (uv.y+.15)*2.);\n    vec3 col = mix(sky, vec3(0), exp(-t*t*t*0.001));\n    col *= ss(.54, .1, abs(uv.y));\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 167, 189, 189, 274], [276, 302, 328, 328, 402], [405, 405, 443, 443, 534], [536, 536, 582, 582, 703], [705, 705, 755, 755, 872], [875, 891, 908, 908, 959], [961, 970, 988, 988, 1052], [1164, 1164, 1183, 1183, 2152], [2155, 2155, 2195, 2195, 2761]], "test": "untested"}
{"id": "tlyBWW", "name": "Spaghetti Worms 3D", "author": "oneshade", "description": "Now I've got to do [url=https://www.youtube.com/watch?v=MKqrLGFoK9E]Microsoft pipes[/url]! :D", "tags": ["3d", "raymarching", "sdf", "worms", "buffering", "spaghetti"], "likes": 22, "viewed": 404, "published": 3, "date": "1614315095", "time_retrieved": "2024-07-30T19:35:48.396637", "image_code": "// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\n#define fetch(p) texelFetch(iChannel0, ivec2(_322(p, SIZE, RESOLUTION, iChannelResolution[0].xy)), 0)\nvec4 sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        vec3 sp = mod(p + halfSize, SIZE) - halfSize;\n        if (filt == 0) {\n            return fetch(sp);\n        }\n\n        else {\n            vec3 UNIT = SIZE / RESOLUTION;\n            vec3 cell = floor(sp / UNIT) * UNIT;\n            vec3 local = fract(sp / UNIT);\n\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            // Sample at cell corners (8 tap)\n            vec4 ldb = fetch(cell);\n            vec4 rdb = fetch(cell + vec3(UNIT.x, 0.0, 0.0));\n            vec4 lub = fetch(cell + vec3(0.0, UNIT.y, 0.0));\n            vec4 rub = fetch(cell + vec3(UNIT.xy, 0.0));\n            vec4 ldf = fetch(cell + vec3(0.0, 0.0, UNIT.z));\n            vec4 rdf = fetch(cell + vec3(UNIT.x, 0.0, UNIT.z));\n            vec4 luf = fetch(cell + vec3(0.0, UNIT.yz));\n            vec4 ruf = fetch(cell + UNIT);\n\n            // Interpolate\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.25;\n    float bbox = max(q.x, max(q.y, q.z));\n    return vec4(0.0, 0.0, 0.0, bbox);\n}\n\nvec4 mapScene(in vec3 p) {\n    vec4 worms = sampleDistanceField(p, 1);\n    return worms;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.05, 0.0, 0.0); // Hacky smoothing effect\n    return normalize(vec3(mapScene(p + e.xyy).w - mapScene(p - e.xyy).w,\n                          mapScene(p + e.yxy).w - mapScene(p - e.yxy).w,\n                          mapScene(p + e.yyx).w - mapScene(p - e.yyx).w));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        vec4 d = mapScene(p);\n        if (d.w < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += d.rgb;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            fragColor.rgb += pow(max(0.0, dot(reflect(rd, n), l)), 50.0);\n            break;\n        }\n\n        if (t > 8.0) {\n            break;\n        }\n\n        t += d.w;\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// RESOLUTION is the number of distance samples, SIZE is the space it maps to\n#define RESOLUTION vec3(45.0)\n#define SIZE vec3(3.5)\n\n// Simulation settings\n#define NUMBER_OF_PARTICLES 20\n#define PARTICLE_RADIUS 0.08\n\n#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xyz\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xyz\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash13(in float x) {\n   vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(in float x, in float scale, in int octaves) {\n    x *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}\n\n// Distance field sampling utilities\nvec3 _223(in vec2 p2D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p2D = floor(p2D);\n    float p1D = p2D.y * res2D.x + p2D.x;\n    float x = mod(p1D, res3D.x);\n    float y = mod(p1D - x, res3D.x * res3D.y) / res3D.x;\n    float z = (p1D - x - y * res3D.x) / res3D.x / res3D.y;\n    return vec3(x, y, z) / res3D * size3D - 0.5 * size3D;\n}\n\nvec2 _322(in vec3 p3D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p3D = floor(p3D / size3D * res3D + 0.5 * res3D);\n    float p1D = p3D.z * res3D.x * res3D.y + p3D.y * res3D.x + p3D.x;\n    float x = mod(p1D, res2D.x);\n    float y = (p1D - x) / res2D.x;\n    return vec2(x, y);\n}", "buffer_a_code": "mat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n// Rotate on axis, from tdhooper (https://www.shadertoy.com/view/WlKyzW) who in turn got it from blackle\nvec3 RotateAxis(in vec3 p, in vec3 ax, in float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x < NUMBER_OF_PARTICLES && iFragCoord.y == 0) {\n        vec3 randPos = Hash13(fragCoord.x + iDate.w) * 2.0 - 1.0;\n        fragColor = vec4(randPos, 1.0);\n    }\n\n    if (iFragCoord.x < NUMBER_OF_PARTICLES && iFragCoord.y == 1) {\n        vec3 randVel = Hash13(fragCoord.x * 365.748 + 478.487 + iDate.w) * 0.02 - 0.01;\n        fragColor = vec4(randVel, 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < NUMBER_OF_PARTICLES) {\n            vec3 pos = getParticlePos(iFragCoord.x);\n            vec3 vel = getParticleVel(iFragCoord.x);\n\n            // Bounce off boundaries (2 * radius to give extra room)\n            vel *= sign(0.5 * SIZE - abs(pos) - 2.0 * PARTICLE_RADIUS);\n\n            float twist = fbm(iTime + fragCoord.x * 487.385 + 247.374, 1.0, 5) * 3.14 - 1.57;\n            vec3 twistAxis = normalize(Hash13(iTime * 467.378 + 843.346) - 0.5);\n            vel = RotateAxis(vel, twistAxis, twist);\n\n            pos += vel;\n\n            if (iFragCoord.y == 0) {\n                fragColor = vec4(pos, 1.0);\n            }\n\n            if (iFragCoord.y == 1) {\n                fragColor = vec4(vel, 1.0);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Precalulated distance field and colors\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) fragColor = vec4(0.0, 0.0, 0.0, 1000000.0);\n    else fragColor = texelFetch(iChannel1, iFragCoord, 0);\n\n    float c = cos(iTime), s = sin(iTime);\n    mat2 colorRot = mat2(c, s, -s, c);\n\n    vec3 p = _223(fragCoord, SIZE, RESOLUTION, iResolution.xy);\n    for (int id=0; id < NUMBER_OF_PARTICLES; id++) {\n        vec3 particlePos = getParticlePos(id);\n        float newShape = length(p - particlePos) - PARTICLE_RADIUS;\n        if (newShape < fragColor.w) {\n            float fid = float(id);\n            vec3 newColor = 0.5 + 0.5 * vec3(sin(fid), 0.25 * cos(fid), 0.0);\n            fragColor.rgb = newColor;\n            fragColor.w = newShape;\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 214, 214, 1458], [1460, 1460, 1486, 1486, 1550], [1552, 1552, 1579, 1579, 1863], [1865, 1865, 1920, 1920, 2969]], "test": "untested"}
{"id": "3tGfDD", "name": "mouse calles y edificio v2 ", "author": "jorge2017a1", "description": "Usar Mouse\nmouse calles y edificio v2", "tags": ["mousecallesyedificiov2"], "likes": 2, "viewed": 435, "published": 3, "date": "1614311509", "time_retrieved": "2024-07-30T19:35:49.164584", "image_code": "//por jorge2017a1-\n// GRacias a ollj, por la referencia\n///https://www.shadertoy.com/view/3stXR2 ........Created by munrocket in 2019-10-29\n/* quaternions */\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nfloat iTimeGlobal;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n    float planeDist1 = p.y+0.0;  //piso inf\n    \n    vec3 posA=p;\n    posA.z= opRep1D(posA.z, 60.0 );\n    posA.x= opRep1D(posA.x, 60.0 );\n    vec3 prepLinea1=posA;\n    \n    prepLinea1.z= opRep1D( prepLinea1.z, 10.0 );\n    \n    \n    //hacer calle A\n    float sdr1A= sdRoundBox(posA-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr1B= sdRoundBox(posA-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr1C= sdRoundBox(posA-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea1= sdRoundBox(prepLinea1-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    \n    \n    //hacer calle B\n    vec3 posB=p-vec3(-30.0,0.0,30.0);\n    posB.z= opRep1D(posB.z, 60.0 );\n    posB.x= opRep1D(posB.x, 60.0 );\n    posB= rotate_y(posB, radians(90.0));\n    vec3 prepLinea2=posB;\n    \n    prepLinea2.z= opRep1D( prepLinea2.z, 10.0 );\n    \n    float sdr2A= sdRoundBox(posB-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr2B= sdRoundBox(posB-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr2C= sdRoundBox(posB-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea2= sdRoundBox(prepLinea2-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    //calle centro\n    vec3 posC=p-vec3(0.0,0.0,30.0);\n     posC.z= opRep1D(posC.z, 60.0 );\n     posC.x= opRep1D(posC.x, 60.0 );\n     \n    float sdr3A= sdRoundBox(posC-vec3(0.0), vec3(10.0,1.0,10.0), 0.2 );\n    \n   \n   \n   \n   \n   //jardin\n     vec3 posD=p-vec3(-31.0,0.0,-13.0);\n     posD.z= opRep1D(posD.z, 60.0 );\n     posD.x= opRep1D(posD.x, 62.0 );\n     float sdr4A=  sdBox(posD-vec3(0.0,0.0,12.), vec3(17.0,150.0,15.0));\n   \n    //calle a\n    res =opU3(res, vec3(sdr1A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr1B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr1C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea1,2.0,-1.0)); \n    // calle b\n    res =opU3(res, vec3(sdr2A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr2B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr2C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea2,2.0,-1.0)); \n    //calle c\n    res =opU3(res, vec3(sdr3A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr4A,3.0,-1.0)); \n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro, vec3 col) \n{\n    vec3 l = lp - p;\n   \n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*col;\n   \n    return lin*atten*col*2.0;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro,colobj);\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;    \n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 8., -2.+iTime*2.0);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.01);\n    dir = rotate(dir, mouse);\n   \n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,1000.0);\n    iTimeGlobal=t;\n    \n    itime=t;\n\tmObj.blnShadow=false;\n    //mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 0.0, 20.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n\n \n    vec3 ro=camera;\n    vec3 rd=dir;\n    rd.xz= rotatev2(rd.xz, radians(180.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n     result/=1.25;\n    col=result;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 2.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n//https://www.shadertoy.com/view/3stXR2 \n\n#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\nvec4 slerp(vec3 u0, vec3 u1, float t) {\n    return qrotor(cross(u0, u1), t * acos(dot(u0, u1)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 561, 597, 597, 618], [619, 619, 651, 651, 735], [736, 736, 782, 782, 869], [871, 915, 962, 962, 989], [991, 991, 1034, 1034, 1061], [1063, 1063, 1111, 1111, 1139], [1140, 1224, 1260, 1260, 1305], [1306, 1371, 1405, 1405, 1503], [1504, 1504, 1538, 1538, 1630], [1631, 1631, 1665, 1665, 1757], [1758, 1798, 1832, 1832, 1929], [1930, 1970, 1995, 1995, 4308], [4312, 4312, 4387, 4387, 4988], [4992, 5043, 5067, 5067, 5255], [5256, 5319, 5352, 5352, 5813], [5815, 5869, 5905, 5905, 6139], [6140, 6229, 6309, 6309, 6576], [6577, 6628, 6675, 6675, 7231], [7285, 7285, 7378, 7378, 7658], [7663, 7712, 7769, 7769, 9174]], "test": "untested"}
{"id": "WtGfDD", "name": "Spraypaint Worms", "author": "oneshade", "description": "Exponential smoothing is so nice! (and FBM motion too)", "tags": ["fbm", "worms", "exponential", "spraypaint", "softbrush"], "likes": 14, "viewed": 307, "published": 3, "date": "1614311247", "time_retrieved": "2024-07-30T19:35:49.938514", "image_code": "// Inspired by Fabrice's graffiti worms: https://www.shadertoy.com/results?query=graffitis\n// and continuing to play around with FBM controlled motion.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PARTICLES 50\n#define PARTICLE_RADIUS 0.01\n\n#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n\n#define getColor(id) 0.5 + 0.5 * vec3(sin(id), cos(id), sin(cos(id)) * cos(sin(id)))\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(in float x, in float scale, in int octaves) {\n    x *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec2 randomPos(in float x) {\n    x += iDate.w;\n    return Hash12(x) - 0.5;\n}\n\nvec2 randomVel(in float x) {\n    x += iDate.w;\n    return Hash12(x * 847.586 + 285.364) * 0.01 - 0.005;\n}", "buffer_a_code": "mat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 corner = vec2(0.5 * (iResolution.x / iResolution.y), 0.5);\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x < PARTICLES && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xy = randomPos(fragCoord.x);\n            if (iFragCoord.y == 1) fragColor.xy = randomVel(fragCoord.x);\n        }\n\n        if (iFrame > 0) {\n            vec2 pos = getParticlePos(iFragCoord.x);\n            vec2 vel = getParticleVel(iFragCoord.x);\n\n            vel *= Rotate(fbm(iTime + fragCoord.x * 487.385 + 247.374, 1.0, 5) * 0.4 - 0.2);\n            pos += vel;\n\n            if (iFragCoord.y == 0) fragColor.xy = pos;\n            if (iFragCoord.y == 1) fragColor.xy = vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) fragColor = vec4(getColor(1.0), 1.0);\n    if (iFrame > 0) {\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n        float unit = 2.0 / iResolution.y;\n        for (int p=0; p < PARTICLES; p++) {\n            float id = float(p);\n            vec2 particlePos = getParticlePos(p);\n            float dist = length(uv - particlePos) - PARTICLE_RADIUS;\n            fragColor.rgb = mix(fragColor.rgb, getColor(id), min(0.75, exp(-100.0 * dist)));\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 152, 207, 207, 273]], "test": "untested"}
{"id": "WtGBDD", "name": "Cereal for Dinner?", "author": "YitingLiu", "description": "Cereal rings in the galaxy. Who wouldn't want that?", "tags": ["grid", "rotate", "star", "galaxy", "starfield", "infinite", "food", "artofthecode", "cereal", "dinner"], "likes": 3, "viewed": 316, "published": 3, "date": "1614310317", "time_retrieved": "2024-07-30T19:35:50.800210", "image_code": "// followed tutorials https://youtu.be/rvDo9LvfoVE\n//https://youtu.be/dhuigO4A7RY\n\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);//distance to the center \n    float m = .03/d;//more light like than smoothstep(.1,.05,d);\n    \n    //float rays= max(0.,1.-abs(uv.x*uv.y*1000.)); \n    //m +=rays*flare;\n    \n    //uv*=Rot(3.1415/4.);\n    //rays= max(0.,1.-abs(uv.x*uv.y*1000.));\n    //m+=rays*.5*flare;\n    m=2.*smoothstep(.3,.1,d);\n    m-=smoothstep(.2,.0,d);\n    m*=smoothstep(1.,mix(.8,.5,uv.y),d);\n\n    return m;\n\n\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n    \n\n}\n\nvec3 StarLayer(vec2 uv) {\n\tvec3 col = vec3(0);\n\t\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    // should add <=\n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            \n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.6, 1., size)*.6);\n            \n            vec3 color = sin(vec3(.5, .1, .9)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1,.2,.8+size)+vec3(.2, .2, .1)*2.;\n            \n            star *= sin(iTime*2.+n*6.2831)*.5+1.;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.03;\n      // float fft  = texelFetch( iChannel0, ivec2(0.,0), 0 ).x; \n    \n\n \n    vec3 col = vec3(0);\n    \n    for (float i =0.; i <1.;i+=1./NUM_LAYERS){\n\n        float depth = fract(i+t);\n        //if mouse is engaged\n        float scale = mix (mix(0.,100.,length(uv-M)),2.,depth);\n        // if mouse is not engaged \n       // float scale = mix (mix(0.,100.,length(uv-(mix(0.4,0.9,fft)))),2.,depth);\n//https://www.shadertoy.com/img/close2.png\n        float fade = depth*smoothstep(1., .8, depth);\n        col += StarLayer(uv*scale+i*532.*M)*fade-.2*Hash21(uv);\n\n    }\n       uv*=Rot(t);\n    uv.x+=max(t*.0001,1.);\n    uv.y-=max(t*.0001,.5);\n\n    \n        col = pow(col, vec3(.85));\t// gamma correction\n \n    \n    //if(gv.x>.48|| gv.y>.48) col.r=1.;//coloring the grid\n  \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 124, 124, 184], [186, 186, 219, 219, 632], [634, 634, 655, 655, 754], [756, 756, 781, 781, 1481], [1482, 1482, 1539, 1539, 2493]], "test": "untested"}
{"id": "WlGBDD", "name": "Abstract machine patterns 2", "author": "jarble", "description": "This fractal formula makes some mechanical-looking patterns.", "tags": ["fractal", "mechanical", "robotic"], "likes": 3, "viewed": 270, "published": 3, "date": "1614308606", "time_retrieved": "2024-07-30T19:35:51.574141", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random,float scale1){\n    return (abs(fract(a*scale1+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 2.7;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor((iTime+uv.x)/5.0));\n        //vec3 random = hash31(21.0);\n        \n        for(int i=0;i<12;i++)\n        {\n            uv = fract1(uv/scale1,random.xy,scale1)+fract1(uv/scale*1.5,random.xy,scale1);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(-uv/(2.5+(-fract(uv.x+uv.y)))+(uv.yx/(2.5))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= -1.0;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 359, 359, 412], [414, 414, 471, 471, 1521]], "test": "untested"}
{"id": "WtGBW1", "name": "HODL", "author": "BigWIngs", "description": "See comments for details. Use mouse to scrub time.", "tags": ["crypto", "coin", "blockchain", "bitcoin", "btc", "nft", "currency"], "likes": 103, "viewed": 4709, "published": 3, "date": "1614300308", "time_retrieved": "2024-07-30T19:35:52.529587", "image_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// I had started a bitcoin texture a couple of years ago but\n// never finished it. With the recent bullrun I got motivated\n// again to finish it. I tried to use symmetries as much as possible\n// but in the end, its still a shitload of manual tweaks because\n// the thing really isn't as symmetrical as it looks. Oww well.\n//\n// Music: Fly Me To The Moon (prod. ibrahim) - Going Spaceward\n// https://soundcloud.com/going-spaceward/fly-me-to-the-moon\n\n//#define SHOW_COIN_TEXTURE\n//#define SHOW_BACKGROUND\n#if HW_PERFORMANCE!=0\n#define USE_AA\n#endif\n \n#define MAX_STEPS 100\n#define MAX_DIST 5.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nvec3 Transform(vec3 p) {\n    vec4 pr = GetProgress(iTime, iMouse.xy/iResolution.xy);\n    \n    float a = 10.*pr.x-4.*pr.x*pr.x;\n    \n    p.xz *= Rot(pr.x*6.2832);\n    p.yz *= Rot(a*6.2832);\n    \n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    \n    p = Transform(p);\n    \n    float \n        dist = length(p.xy),\n        d = dist-.5,\n        side = -sign(p.z);\n    \n    d = max(d, abs(p.z)-.03);\n   \t\n    p.x /= iResolution.x/iResolution.y;\n    \n    vec2 uv = vec2(p.x*side, p.y)+.5;\n    d -= .003*texture(iChannel0, uv).r*S(.0, .01, abs(p.z));\n    \n    float a = atan(p.x, p.y)*200.;\n    d += S(.025, .015, abs(p.z))*(sin(a)+sin(3.*a)*.25+sin(5.*a)*.0625)*.003;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.,dS;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec4 GetNormal(in vec3 p) {\n    vec2 e = vec2(-1., 1.)*1e-3;   \n    float \n        t1 = GetDist(p + e.yxx), \n        t2 = GetDist(p + e.xxy),\n        t3 = GetDist(p + e.xyx), \n        t4 = GetDist(p + e.yyy),\n        c = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n        \n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n        \n    return normalize(i);\n}\n\nvec3 Bg(vec3 rd, float lod) {\n    \n    lod = mix(5., 10., lod);\n    \n    vec3 \n        xy = textureLod(iChannel1, rd.xy+.5, lod).rgb,\n        xz = textureLod(iChannel1, rd.xz+.5, lod).rgb,\n        yz = textureLod(iChannel1, rd.yz+.5, lod).rgb;\n    \n    rd = abs(rd);\n    \n    return rd.x*yz + rd.y*xz + rd.z*xy+pow(rd.z*rd.z, 3.);\n}\n\nvec4 Render(vec2 frag, vec2 res) {\n    vec2 \n        uv = (frag-.5*res.xy)/res.y,\n        m = iMouse.xy/res.xy;\n    \n    vec4 pr = GetProgress(iTime, m);\n    \n    float \n        t = pr.x,\n        alpha = 0.,\n        d;\n    \n    vec3 \n        ro = vec3(0, 0, -4)*mix(.2, 1., S(.5, 0., abs(t-.5))),\n        rd = GetRayDir(uv, ro, vec3(0), 1.),\n        col=vec3(0);\n  \n    vec2 i = RaySphere(ro, rd, vec3(0), .5);\n    \n    \n    if(i.x>-1.) {\n        d = RayMarch(ro, rd);\n\n        if(d<MAX_DIST) {\n            vec3 p = ro + rd * d;\n            vec4 n = GetNormal(p);\n            vec3 r = reflect(rd, n.xyz);\n\n            p = Transform(p);\n            \n            float \n                bump = WaveletNoise(p.xy*10.,3.,2.),\n                dif = dot(n.xyz, normalize(vec3(1,2,3)))*.5+.5,\n                dirt = 1.-max(0., -n.w);\n            \n            col = Bg(r, max(0., n.w))+dif*.03;\n            col *= vec3(255,150,40)/255.; \n            col *= pow(dirt, 10.);\n            col *= mix(1., bump, .2);\n            \n            vec3 spec = vec3( pow(abs(r.y),10.) );\n            spec *= mix(vec3(1), GetBgCol(iTime)*(1.-pr.z), step(r.y, 0.));\n            col += spec;\n            \n            alpha = 1.;\n        }\n    }\n    return vec4(col, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(0);\n    \n    #ifdef SHOW_COIN_TEXTURE\n    col = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    #else\n    #ifdef SHOW_BACKGROUND\n    col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    #else\n   \n    col = texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    \n    vec4 coin = Render(fragCoord, iResolution.xy);  \n    #ifdef USE_AA\n    coin += Render(fragCoord+vec2(.5,0), iResolution.xy);  \n    coin += Render(fragCoord+vec2(0,.5), iResolution.xy);  \n    coin += Render(fragCoord+vec2(.5,.5), iResolution.xy);  \n    coin /= 4.;\n    #endif\n    \n    col = mix(col, coin.rgb, coin.a);\n    #endif\n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    // vignette\n    vec2 uv = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    float d = dot(uv, uv);\t\t\n    col /= d*d+1.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25563, "src": "https://soundcloud.com/going-spaceward/fly-me-to-the-moon", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Bitcoin texture. \n// I tried to make use of symmetries as much as possible\n// but in the end its just a lot of detail that needs to be hand coded.\n\n#define SS smoothstep\n#define sat(x) clamp(x, 0., 1.)\n\nfloat box(vec2 p, float x, float y, float z, float w, float b) {\n\tfloat \n        v = SS(x-b, x+b, p.x)*SS(z+b, z-b, p.x),\n        h = SS(y-b, y+b, p.y)*SS(w+b, w-b, p.y);\n    return v*h;\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.)) + min(max(p.x, p.y), 0.);\n}\n\nfloat cir(vec2 uv, float x, float y, float r, float w, float b) {\n\treturn SS(w+b, w-b, abs(r-length(uv-vec2(x, y))));\n}\n\nfloat r = .05;\nfloat _A(vec2 uv) {return box(uv, .1, .1, .9, .5, r)-box(uv, .2, .1, .8, .4, r)+(box(uv, .15, .5, .8, .9, r)-box(uv, .25, .5, .7, .8, r));}\nfloat _B(vec2 uv) {\n    uv.y = abs(uv.y-.5);\n    return max(min(box(uv, .1, -.1, .74, .4, r),1.-box(uv, .2, .05, .9, .3, r)), step(.675,uv.x)*cir(uv, .675, .175, .175, .05, r));\n}\nfloat _D(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .2, .8, .8, r);}\nfloat _F(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, 1., .8, r)+box(uv, .1, .1, .2, .5, r);}\nfloat _I(vec2 uv) {return box(uv, .1, .1, .2, .9, r);}\nfloat _L(vec2 uv) {return max(box(uv, .1, .1, .9, .2, r), box(uv, .1, .1, .2, .9, r));}\nfloat _O(vec2 uv) {return _D(uv);}\nfloat _J(vec2 uv) {return min(_O(uv), 1.-box(uv, .0, .3, .8, 1.1, r));}\nfloat _P(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, .8, .8, r)+box(uv, .1, .1, .2, .5, r);}\nfloat _C(vec2 uv) {return min(_O(uv), 1.-box(uv, .5, .4, 1., .6, r));}\nfloat _G(vec2 uv) {return max(min(_O(uv), 1.-box(uv, .5, .5, 1., .7, r)), box(uv, .6, .4, .9, .5, r));}\nfloat _E(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .2, 1., .8, r)+box(uv, .2, .45, .9, .55, r);}\nfloat _M(vec2 uv) {return box(uv, .1, .1, .9, .9, r)-box(uv, .2, .0, .8, .8, r)+box(uv, .45, .1, .55, .8, r);}\nfloat _N(vec2 uv) {\n    return max(box(vec2(abs(uv.x-.5),uv.y), .3, .1, .4, .9, r), \n               box(vec2(uv.x-(.9-uv.y)*.82, uv.y), .1, .1, .25, .9, r));\n}\nfloat _R(vec2 uv) {return _A(uv);}\nfloat _S(vec2 uv) {\n    float y = 1.-uv.x;\n    y = y*y*y*.15;\n    return max(min(max(box(uv, .1, .45, .9, .9, r)\n        -box(uv, .2, .55, .8, .8, r),\n        +box(uv, .8, .1, .9, .6, r)),\n        1.-box(uv, .5, .55, 1., .7, r)),\n               box(vec2(uv.x, uv.y-y), .1, .1, .9, .2, r));\n}\nfloat _T(vec2 uv) {return max(box(uv, .1, .8, .9, .9, r), box(uv, .45, .1, .55, .85, r));}\nfloat _Y(vec2 uv) {return box(uv, .1, .5, .9, .9, r)-box(uv, .2, .6, .8, 1., r)+box(uv, .45, .1, .55, .5, r);}\nfloat _Z(vec2 uv) {\n    float y = abs(uv.y-.5);\n    float x = uv.y>.5 ? uv.x : 1.-uv.x;\n    return sat(box(vec2(x, y), .1, .3, .9, .4, r)+ \n               box(vec2(uv.y-uv.x*.95+.15, uv.y), .1, .2, .25, .8, r)+\n             box(vec2(x,y), .1, .2, .2, .3, r));\n}\nfloat _dot(vec2 uv) { return SS(.3+r, .3-r, length(uv-vec2(.5)));}\nfloat _ONE(vec2 uv) {return max(max(box(uv, .2, .1, .3, .9, r), box(uv, .1, .1, .4, .2, r)),box(vec2(uv.x, uv.y-uv.x*.5), .1, .66, .26, .785, r));}\nfloat _NINE(vec2 uv) {return _P(vec2(1.-uv.x, uv.y));}\n\n#define _w if(within(uv, c+=s, .0, c+w, 1.)) e +=\n#define _d _w _dot(local(uv, c, .0, c+w, 1.));\n#define _s _w 0.;\n#define _1 _w _ONE(local(uv, c, .0, c+w, 1.));\n#define _9 _w _NINE(local(uv, c, .0, c+w, 1.));\n#define A _w _A(local(uv, c, .0, c+w, 1.));\n#define B _w _B(local(uv, c, .0, c+w, 1.));\n#define D _w _D(local(uv, c, .0, c+w, 1.));\n#define E _w _E(local(uv, c, .0, c+w, 1.));\n#define F _w _F(local(uv, c, .0, c+w, 1.));\n#define G _w _G(local(uv, c, .0, c+w, 1.));\n#define I _w _I(local(uv, c, .0, c+w, 1.)); c-=s*.75;\n#define J _w _J(local(uv, c, .0, c+w, 1.));\n#define L _w _L(local(uv, c, .0, c+w, 1.));\n#define R _w _R(local(uv, c, .0, c+w, 1.));\n#define S _w _S(local(uv, c, .0, c+w, 1.));\n#define T _w _T(local(uv, c, .0, c+w, 1.));\n#define C _w _C(local(uv, c, .0, c+w, 1.));\n#define M _w _M(local(uv, c, .0, c+w, 1.));\n#define N _w _N(local(uv, c, .0, c+w, 1.));\n#define O _w _O(local(uv, c, .0, c+w, 1.));\n#define P _w _P(local(uv, c, .0, c+w, 1.));\n#define Y _w _Y(local(uv, c, .0, c+w, 1.));\n#define Z _w _Z(local(uv, c, .0, c+w, 1.));\n\nfloat Text(vec2 uv) {\n    float \n        e = 0.,\n        c = 0.,\n        w = 1./76.,\n        s = w *.9;\n    \n    if( uv.x<.536) {\n        if(uv.x<.287) {\n            if(uv.x<.145) {\n                _1 T R O Y O Z _s _9 _9 _9 _s\n            } else {\n                c=.14;\n                F I N E _s C O P P E R _s _s\n            }\n        } else {\n            c=.287;\n            if(uv.x<.445) {\n                M J B _s M O N E T A R Y _s \n            } else {\n                c=.44;\n                M E T A L S _s _s\n            }\n        }\n    } else {\n        c = .532;\n\n        if(uv.x<.70) {\n            if(uv.x<.62) {\n                B I T C O I N _d \n            } else {\n                c = .61;\n                D I G I T A L _d\n            }\n        } else {\n            c=.687;\n\n            if(uv.x<.857) {\n                D E C E N T R A L I Z E D _d\n            } else {\n                c=.845;\n                P E E R _s T O _s P E E R\n            }\n        }\n    }\n    return e;\n}\n\nfloat DooHicky(vec2 p, float reps, float h, float w, float x1, float y1, float x2, float y2) {\n    float m = 0.;\n    vec2 lp = local(p, x1,y1,x2,y2);\n    if(lp.y>0. && lp.y<1.&&lp.x>0.&&lp.x<1.) {\n        lp.x-=.5;\n        lp.y = fract(lp.y*reps)-.5;\n        float d = sdBox(lp, vec2(h));\n        m = SS(.1,.0, d)*2.;\n        m = max(m, SS(.05, .0, abs(abs(lp.x)-.15)-w));\n    }\n    return m*.5;\n}\n\nfloat Bitcoin(vec2 uv) {\n    // https://www.shadertoy.com/view/WtGBW1\n    vec2 m = iMouse.xy/iResolution.xy;\n    //uv *= .4; uv -= (m-.5);\n    \n    float \n        e = 0., d, x, y, k, holes, rings, id;\n    r = .05;\n    \n    vec2 \n        st = vec2(atan(uv.x, uv.y)/6.283+.5, length(uv)),\n        lp, //used for local coordinates\n        p = uv;\n    \n    st.x = fract(st.x+.29);\n    if(st.y>.425 && st.y<.462) {\n     \te = Text(local(st, .0917, .425, 1., .462));\n    } else if (st.y>.472 && st.y<.5) {\n    \ty = 1.-(abs(.486-st.y)/.014);\n        e = sat(y*2.);\n    }\n    else \n    if(st.y>.4){ \n        x = fract(st.x*36.-.25);\n        y = remap01(.4, .423, st.y);\n        e = max(e, box(vec2(x, y), .15, .0, .85, 1., r));\n        e = max(e, SS(.2, .1, abs(y-.5))*.5);\n    } else { // center \n        d = sdBox(uv-vec2(-.063,-.198), vec2(.027, .1));  // bottom left\n        d = min(d, sdBox(uv-vec2(.032,-.178), vec2(.027, .12))); // bottom right\n        d = min(d, sdBox(uv-vec2(-.073,.171), vec2(.14, .028)));// top\n        d = min(d, sdBox(uv-vec2(-.04+uv.y*.2,-.18-uv.x*.03), vec2(.12, .031)));//bottom\n        d = min(d, sdBox(uv-vec2(-.07,.198), vec2(.027, .1))); // top left\n        d = min(d, sdBox(uv-vec2(.021,.198), vec2(.028, .1))); // top left\n        d = min(d, sdBox(uv, vec2(.135, .17))); // center fill\n        d = min(d, length((uv-vec2(.075, .101))*vec2(.82,1))-.098);// top arc\n        d = min(d, length((uv-vec2(.075, -.085))*vec2(.82,1))-.12);// bottom arc\n        \n        holes = length((uv-vec2(.02, .092))*vec2(.9,1))-.055;\n        holes = min(holes, sdBox(uv-vec2(-.012,.092), vec2(.034, .055)));   \n        holes = min(holes, length((uv-vec2(.04, -.084))*vec2(.8,1))-.06);\n        holes = min(holes, sdBox(uv-vec2(-.0,-.084), vec2(.045, .06)));\n        \n        d = max(d, -holes);\n \n        y = st.y*78.;\n        id = floor(y);\n        rings = fract(y)-.5;\n        \n        k = 18.\n            +step(abs(st.x-.3)-.2, 0.)\n            -step(abs(st.x-.6)-.05, 0.)*2.;\n        if(d*holes>0. && (id>k||abs(uv.x)<.05)) {\n            r = 0.;\n            // concentric circles\n            if(id>19.&&id<27. && mod(id,2.)==0.) { // resistors\n                float len = .55/(id+1.);\n                float s = remap01(20.,26., id);\n                float ph = mix(.65, .5, pow(s, .8))+.18;\n                x = fract(st.x*4.);\n                r=SS(.01, .0, abs(x-ph)-len);\n            }\n            rings = SS(.2, .0, abs(rings)-r*.2)*mix(.5, 1., r);\n            lp = uv-vec2(-.024,0);\n                \n            if(lp.y>.3&&lp.y<.35&&abs(lp.x)<.075) {\n                x = remap(.3, .35, .075, .015, uv.y);\n                k = step(0., abs(lp.x)-x);\n                rings *= k;\n                x = Min(abs(lp.x-.06), abs(lp.x-.044), abs(lp.x-.027));\n                y = Min(abs(lp.x+.033), abs(lp.x+.054), abs(lp.x+.018));\n                x = min(x, y);\n                rings += (1.-k)*SS(.003,.0, x)*.5;\n            } else if(lp.y<-.3 && lp.y>-.35) {\n                lp.x -=.008;\n                x = remap(-.3, -.35, .078, .015, uv.y);\n                k = step(0., abs(lp.x)-x);\n                rings *= k;\n                x = Min(abs(lp.x-.065), abs(lp.x-.045), abs(lp.x-.028));\n                y = Min(abs(lp.x+.032), abs(lp.x+.053), abs(lp.x+.018));\n                x = min(x, y);\n                rings += (1.-k)*SS(.003,.0, x)*.5;\n            }\n            e = max(e, rings);\n        }\n        \n        e = max(e, SS(.005, .0, abs(d)));\n        \n        // stuff in holes\n        if(holes<-.01) {\n            lp = local(uv, -.038,-.139+.006,-.022-.005,.141-.004);\n            if(lp.x>0.&& lp.x<1.&&lp.y>0.&&lp.y<1.) {\n                y = lp.y;\n                d = length(fract(lp*vec2(1,27))-.5);\n                d = SS(.3, .0, d)*step(.05, abs(abs(y-.573)-.335));\n                e = max(e, d);\n            }\n            e = max(e, DooHicky(uv, 1., .25, .01, -.032,-.137, -.008,-.114));\n            e = max(e, DooHicky(uv, 1., .25, .01, -.032,.069, -.005,.046));\n            \n            d = sdBox(uv-vec2(.045, .097), vec2(.008,.012));\n            d = min(d, sdBox(uv-vec2(-.028,.11), vec2(.001,.008))-.001);\n            \n            r = abs(sdBox(uv-vec2(-.015,.094), vec2(.03,.006))-.03)-.0005;\n            d = min(d, max(r, -uv.x-.02));\n            d = min(d, sdBox(vec2(abs(uv.x)-.012, uv.y-.113), vec2(.008,.012)));\n            \n            \n            lp = uv-vec2(.017,-.014);\n            lp.y = abs(lp.y)-.09;\n            d = min(d, sdBox(lp, vec2(.014,.004)));\n            d = max(d, -sdBox(lp, vec2(.005,.004)));\n            // lines\n            lp.x -= lp.y*.3-.01;\n            lp.y = abs(lp.y-.0016)-.007;\n            d = min(d, sdBox(lp, vec2(.028,.0)));\n            \n            x = abs(abs(uv.x-.03)-.026)-.013;\n            d = min(d, sdBox(vec2(x, uv.y+.068), vec2(.007,.011))-.003);\n           \n            r = sdBox((uv-vec2(-.015,-.083))*vec2(1,1.4), vec2(.04,.0))-.055;\n            r = max(r, uv.x-.056);\n            \n            r = abs(abs(r)-.011)-.0005;\n            d = min(d, max(r, -uv.x-.02));\n                  \n            e = max(e, SS(.003,-.002, d)); \n        }\n        \n        x = abs(abs(uv.y-.03)-.022)-.011;\n        d = sdBox(vec2(uv.x-.22, x), vec2(.013,.004))-.002; \n        d = min(d, sdBox(uv-vec2(.22, .095), vec2(.013,.015))-.002);\n        d = max(d, length(uv)-.24);\n        d = min(d, sdBox(uv-vec2(.22, .04), vec2(.001,.05))+.002);\n        e = max(e, SS(.004, .0, d));\n        \n        lp = uv-vec2(-.28,-.037);\n        \n        if(uv.x<0.) {\n            if(lp.y>.0) {\n                e *= SS(.00, .001, Line(lp,vec2(-.017,.0125),vec2(.08,.105))-.022);\n            \n                d = Line(lp,vec2(0,0),vec2(-.034,.027));\n                d = min(d, Line(lp,vec2(.026,0),vec2(-.021,.04)));\n                d = min(d, Line(lp,vec2(.026,0.025),vec2(-.008,.052)));\n                d = min(d, Line(lp,vec2(.04,0.037),vec2(.006,.065)));\n                d = min(d, Line(lp,vec2(.066,0.037),vec2(.021,.078)));\n                d = min(d, Line(lp,vec2(.068,0.062),vec2(.0365,.094)));\n                d = min(d, Line(lp,vec2(.082,0.075),vec2(.055,.112)));\n                d = min(d, Line(lp,vec2(.095,0.088),vec2(.075,.126)));\n                \n                lp.y = abs(lp.y-.135); \n                d = min(d, Line(lp,vec2(.11,.023),vec2(.14,.023)));\n                d = min(d, Line(lp,vec2(.11,.023),vec2(.097,.0)));\n            } else {\n                d = Line(lp,vec2(.015,-.013),vec2(-.026,-.033));\n                d = min(d, Line(lp,vec2(.03,-.025),vec2(-.009,-.047)));\n                d = min(d, Line(lp,vec2(.045,-.038),vec2(.01,-.063)));\n                d = min(d, Line(lp,vec2(.06,-.051),vec2(.031,-.08)));\n                d = min(d, Line(lp,vec2(.04,-.072),vec2(.045,-.08)));\n                d = min(d, Line(lp,vec2(.09,-.076),vec2(.07,-.09)));\n                d = min(d, Line(lp,vec2(.09,-.12),vec2(.07,-.09)));\n                      \n               e *= SS(.00, .001, Line(lp,vec2(.04,-.06),vec2(-.018,-.01))-.022);\n            }\n            e = max(e, SS(.003, .0, d)*.5);\n        } else {\n            if(uv.y>-.07) {\n                d = Line(uv,vec2(.38,.05),vec2(.3365,.106));\n                d = min(d, Line(uv,vec2(.36,.05),vec2(.326,.095)));\n                d = min(d, Line(uv,vec2(.362,.107),vec2(.349,.107)));\n                d = min(d, Line(uv,vec2(.347,.038),vec2(.3175,.08)));\n                d = min(d, Line(uv,vec2(.336,.026),vec2(.307,.067)));\n                d = min(d, Line(uv,vec2(.325,.014),vec2(.2965,.054)));\n                d = min(d, Line(uv,vec2(.314,.00),vec2(.286,.039)));\n                d = min(d, Line(uv,vec2(.303,-.012),vec2(.275,.024)));\n                d = min(d, Line(uv,vec2(.292,-.025),vec2(.263,.008)));\n                d = min(d, Line(uv,vec2(.28,-.037),vec2(.25,-.01)));\n                d = min(d, Line(uv,vec2(.27,-.05),vec2(.218,-.01)));\n                e *= SS(.00, .001, Line(uv,vec2(.352,.08),vec2(.255,-.05))-.028);\n            } else {\n                d = Line(uv,vec2(.237,-.115),vec2(.278,-.076));\n                d = min(d, Line(uv,vec2(.245,-.127),vec2(.288,-.088)));\n                d = min(d, Line(uv,vec2(.252,-.141),vec2(.297,-.101)));\n                d = min(d, Line(uv,vec2(.26,-.153),vec2(.306,-.114)));\n                d = min(d, Line(uv,vec2(.267,-.165),vec2(.315,-.125)));\n                e *= SS(.00, .001, Line(uv,vec2(.295,-.18),vec2(.323,-.14))-.01);\n                e *= SS(.00, .001, Line(uv,vec2(.259,-.093),vec2(.291,-.147))-.03);\n            }\n            \n            e = max(e, SS(.003, .0, d)*.5);   \n        }\n    }\n    \n     // straight lines\n    y = remap01(-.132, .082, p.y);\n    y += clamp(remap01(.45, .475, st.y),0.,1.)*.05;\n   \n    if(st.y<.475 && y>0. && y<1.) {\n        bool \n            rightSide = (p.x-.197-.19*y>.0 && p.x-.321+.16*y>.0),\n            leftSide = (p.x<-.14 && y>.05 && y<.88 && p.x+p.y*1.2>-.325 && p.x-p.y*1.1>-.24);\n    \n        if ( rightSide || leftSide) {\n            y *= 17.;\n            id = floor(y);\n            y = fract(y)-.5;\n            \n            r = 0.;\n            if(id==7.||id==9.||id==11.)\n                r = SS(.002, .0, abs(p.x-.4)-.015);\n                \n            e = SS(.2, .0, abs(y)-.2*r)*mix(.5, 1., r);\n            \n            // diagonal lines\n            d = sdBox(uv-vec2(.336,-.065), vec2(.03, .03));\n            r = SS(-.2, .2, sin((uv.x+uv.y)*250.));\n            r *= SS(.01, .0, d+.013);\n            d = SS(.003,-.002, d)*.7+r;\n            e = max(e, d); \n        }\n        \n        lp = (uv - vec2(.26,-.063))*.7;\n        d = max(sdBox(lp, vec2(.014,.004)), -sdBox(lp, vec2(.005,.004)));\n        e = max(e, SS(.003, .0, d));\n    }\n    \n    e = max(e, DooHicky(p, 5., .35, .01, -.212,.02, -.159,-.107));\n    e = max(e, DooHicky(p, 2., .35, .05, -.125,-.22, -.099,-.268));\n    e = max(e, DooHicky(p, 2., .3, .05, -.143,.12, -.17,.076));\n    e = max(e, DooHicky(p, 1., .3, .05, -.143,-.141, -.17,-.114));\n   \n    lp = vec2(p.x-step(p.y,0.)*.01, abs(p.y+.004));\n    e = max(e, DooHicky(lp, 1., .2, .02, .045,.245, .095,.205));\n    \n    lp = vec2(p.x-step(p.y,0.)*.01, abs(p.y));\n    e = max(e, DooHicky(lp, 2., .3, .02, -.045,.3, -.005,.35));\n    \n    return e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float e = 0.;\n    \n    vec2 oldRes = texture(iChannel0, vec2(.5)/iResolution.xy).rg;\n    \n    if(oldRes.x!=iResolution.x)\n        e = Bitcoin((fragCoord.xy-.5*iResolution.xy) / iResolution.y);   \n    else\n        e = texture(iChannel0, fragCoord.xy/iResolution.xy).r;\n    \n    if(fragCoord == vec2(1,1))\n        fragColor = vec4(iResolution.xy, 0,0);\n    else    \n        fragColor = vec4(e);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"HODL\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// Background layer. See my tutorial about this here:\n// https://www.youtube.com/watch?v=3CycKKJiwis\n\n#define S smoothstep\n#define NUM_LAYERS 4.\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float \n        n = N21(id+offs),\n        n1 = fract(n*10.),\n        n2 = fract(n*100.),\n        a = t+n;\n        \n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat Connect(vec2 a, vec2 b, vec2 uv, float t) {\n    t = .5-abs(t-.5);\n    float \n        d = Line(uv, a, b),\n        d2 = length(a-b),\n        fade = S(1.5, .5, d2+t)*S(.9,.6, t*2.),\n        r = 6./iResolution.y;\n    \n    return S(r, 0., d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float T) {\n    vec2 \n        id = floor(st)+n,\n        p[9];\n\n    float \n        t = iTime+10.,\n        m=0., d, s,\n        pulse, sparkle=0.;\n    \n    st = fract(st)-.5;\n    \n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    for(int i=0; i<9; i++) {\n        m += Connect(p[4], p[i], st, T);\n\n        d = length(st-p[i]);\n\n        s = (.005/(d*d));\n        s *= S(1., .7, d);\n        pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += Connect(p[1], p[3], st, T);\n\tm += Connect(p[1], p[5], st, T);\n    m += Connect(p[7], p[5], st, T);\n    m += Connect(p[7], p[3], st, T);\n    m += sparkle*S(.05, .5, abs(T-.5));\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \n        t, y, m = 0., r, d, glow, moon;\n        \n    vec2 \n        uv = (fragCoord-iResolution.xy*.5)/iResolution.y,\n        M = iMouse.xy/iResolution.xy,\n        st = uv,\n        offs = vec2(0, -y*300.);\n    \n    vec4 p = GetProgress(iTime, M);\n    t = p.x;\n    y = p.z;\n    offs.y = -p.w;\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float \n            size = mix(15., 1., i),\n            fade = S(0., .6, i)*S(1., .8, i);\n            \n        m += fade * NetLayer(st*size-offs, i, t);\n    }\n\t\n    vec3 \n        baseCol = GetBgCol(iTime),\n        col = baseCol*m*.2;\n    \n    glow = max(0., -t*(1.-t)*4.+.5-uv.y);\n    col += baseCol*(exp(offs.y/10.)+glow*glow);\n    \n    y = remap01(1., .92, y);\n    r = .12;\n    st = uv-vec2(0, y);\n    d=length(st);\n    moon = S(.002, -.002, d-r);\n    glow = S(.0,.01,  y)*.0005/(d*d*d);\n    glow = mix(glow, .4, moon);\n    if(d<r) {\n        r = .135; \n        moon *= WaveletNoise(st*5./(sqrt(r*r-d*d)/r), .1, 2.)*.5+.5;\n    }\n    col += moon+glow;\n    \n    fragColor = vec4(min(col,vec3(1)),1);\n}", "buffer_b_inputs": [], "common_code": "float remap01(float a, float b, float t) {\n\treturn (t-a)/(b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n    return ((t-a)/(b-a))*(d-c)+c;\n}\n\nvec2 local(vec2 uv, float x1, float y1, float x2, float y2) {\n\treturn vec2(uv.x-x1, uv.y-y1)/vec2(x2-x1, y2-y1);\n}\nvec2 local(vec2 uv, vec4 p) { return local(uv, p.x, p.y, p.z, p.w);}\n\nbool within(vec2 uv, float x1, float y1, float x2, float y2) {\n\treturn uv.x>x1&&uv.x<x2&&uv.y>y1&&uv.y<y2;\n}\nbool within(vec2 uv, vec4 p) {\n    return within(uv, p.x, p.y, p.z, p.w);\n}\nfloat Line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 \n        pa = p - a, \n        ba = b - a;\n        \n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\n\t\n    return length(pa - ba * h);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    float t = dot(s-ro, rd);\n    vec3 p = ro+rd*t;\n    float y = length(s-p);\n    if(y<r) {\n        float x = sqrt(r*r-y*y);\n        return vec2(t-x, t+x);\n    }\n    return vec2(-1, -1);\n}\n\nvec4 GetProgress(float T, vec2 M) {\n    T += M.x/.03; \n    float \n        t = fract(T*.03),\n        y = t*(1.-t)*4.;\n    return vec4(t, 1.-abs(t-.5)*2., y, y*75.);\n}\n\nvec3 GetBgCol(float T) {\n    return vec3(1., .7, .2).brg;\n}\n\nfloat WaveletNoise(vec2 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<4.; i++) {\n        vec2 q = p*s, g=fract(floor(q)*vec2(123.34,233.53));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3;// +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5)*mat2(cos(a),-sin(a),sin(a),cos(a));\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = p*mat2(.54,-.84, .84, .54)+i;\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Min(float a, float b, float c) {\n  return min(a, min(b, c));\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[961, 961, 985, 985, 1170], [1172, 1172, 1195, 1195, 1633], [1635, 1635, 1669, 1669, 1877], [1879, 1879, 1906, 1906, 2251], [2253, 2253, 2303, 2303, 2497], [2499, 2499, 2528, 2528, 2831], [2833, 2833, 2867, 2867, 4083], [4085, 4085, 4142, 4142, 5016]], "test": "untested"}
{"id": "3tyBDW", "name": "Limited Mirrored Repetition SDF", "author": "Dain", "description": "Every other cell is mirrored so that none symmetric SDFs are valid when repeated\n-Left is limited repeat, requires symmetric shape \n-Right is limited mirror repeat, can handle any shape ", "tags": ["2d", "sdf", "repetition", "mirror"], "likes": 7, "viewed": 504, "published": 3, "date": "1614299396", "time_retrieved": "2024-07-30T19:35:53.295539", "image_code": "//Most of this besides the mirror repeat is from IQ Limited Repetition SDF https://www.shadertoy.com/view/3syGzz\n\n/*\nEvery other cell is mirrored so that none symmetric SDFs are valid when repeated\n-Left is limited repeat, requires symmetric shape \n-Right is limited mirror repeat, can handle any shape \n*/\n\n//Limited mirrored repetition\nvec2 opMirrorLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    //This part is same as IQ's limited repeat\n    //The limits should be integers\n    vec2 c = clamp( round(p/s),lima,limb);\n    vec2 o= p-s*c;\n    \n    //Now adjust for mirroring\n    //flip in every other cell\n    if((int(c.x)&1) == 1){\n         o.x = -o.x;\n    }\n    \n     if((int(c.y)&1) == 1){\n         o.y = -o.y;\n     }\n    \n    return o;\n}\n\n\n// Create multiple copies of an object - https://iquilezles.org/articles/distfunctions\nvec2 opRepLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//SDF that is not symetric goes here\nfloat NotSymmetricShape(vec2 r){\n  float d = sdBox( r+vec2(0.0, -.3), vec2(0.4,0.2) ) -  0.1;\n  d= min(d,sdBox( r+vec2(0.41,0.1), vec2(0.1,0.7) ) -  0.061);\n  return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    float scale = abs(sin(iTime*.5))*2.0+.5;\n    float cellX = round(2.0*abs(cos(iTime*.5)));\n    float cellY = round(2.0*abs(sin(iTime*.5+.25)));\n    // sdf\n    float d;\n    if( p.x<0.0 ) // standard repetition, only works if SDF is symmetric \n    {\n    \tvec2 q = p*6.0 + vec2(5.0,0.0);\n        vec2 r = opRepLim(q,scale,vec2(-cellX,-1),vec2(cellX,cellY));\n        d = NotSymmetricShape(r);\n    }\n    else         // mirrored repitition, works for anything\n    {\n      \tvec2 q = p*6.0 - vec2(5.0,0.0);\n        vec2 r = opMirrorLim(q,scale,vec2(-cellX,-1),vec2(cellX,cellY));\n        d = NotSymmetricShape(r);\n    }\n\n    // colorize\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(40.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.05,abs(d)) );\n\n    col *= smoothstep(0.005,0.010,abs(p.x));\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[760, 847, 915, 915, 961], [963, 1051, 1088, 1088, 1123], [1125, 1174, 1218, 1218, 1243], [1245, 1294, 1332, 1332, 1414], [1416, 1453, 1485, 1485, 1623], [1624, 1624, 1681, 1681, 2633]], "test": "untested"}
{"id": "wtKfD1", "name": "Glow Worm", "author": "oneshade", "description": "A glowing worm trying to get nowhere. Makes me think of slither.io", "tags": ["fbm", "animation", "glow", "moving", "worm"], "likes": 4, "viewed": 191, "published": 3, "date": "1614297701", "time_retrieved": "2024-07-30T19:35:54.159229", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(in float x, in float scale, in int octaves) {\n    x *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec2 motion = sin(fbm(iTime, 1.0, 5) * 6.28 + vec2(1.57, 0.0)) * 0.025;\n    fragColor = texture(iChannel0, fract(((uv + motion) * iResolution.y + center) / iResolution.xy));\n\n    float c = exp((0.01 - length(uv)) * 25.0);\n    fragColor.rgb = mix(fragColor.rgb, vec2(0.0, 1.5).rgg, c);\n\n    fragColor *= 0.98;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "tlGBW1", "name": "Evo32 SMNCA - Slackermanz", "author": "SlackermanzCA", "description": "Evo32 SMNCA: Selective Multiple Neighbourhood Cellular Automata by Slackermanz\nPattern variant created through manual searching and variation with evolutionary functions\nhttps://www.reddit.com/user/slackermanz/\nhttps://www.reddit.com/r/cellular_automata\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 66, "viewed": 2227, "published": 3, "date": "1614291388", "time_retrieved": "2024-07-30T19:35:55.243331", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Evo32 Selective MNCA\n//\tTYPE:Selective Multiple Neighbourhood Cellular Automata\n//\tRULE:Pattern coordinates hardcoded into 'demo' array\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSpecification: SlackCA_Specification_2021_02_23:\n//\t\thttps://mega.nz/file/yRliVDJT#6CUlcGma4DpfXI4S8j0VoUi8Vju0vwRXwVI4klyiNXg\n//\tAdapted for Shadertoy. FPS compared to the C++/Vulkan application is about 20% of maximum\n//\n//\tText file containing other pattern coordinates:\n//\t\thttps://mega.nz/file/uY0GjSjJ#-TvjklejZBh3O5DfqtLXFtjZaoVetqHPgotdYLH5xoQ\n//\tVisualisation of a small subset of rules recorded by Softology:\n//\t\thttps://www.youtube.com/watch?v=LtdKNso0DwE\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nprecision highp int;\nprecision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tNAME:Evo32 Selective MNCA\n//\tTYPE:Selective Multiple Neighbourhood Cellular Automata\n//\tRULE:Pattern coordinates hardcoded into 'demo' array\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSpecification: SlackCA_Specification_2021_02_23:\n//\t\thttps://mega.nz/file/yRliVDJT#6CUlcGma4DpfXI4S8j0VoUi8Vju0vwRXwVI4klyiNXg\n//\tAdapted for Shadertoy. FPS compared to the C++/Vulkan application is about 20% of maximum\n//\n//\tText file containing other pattern coordinates:\n//\t\thttps://mega.nz/file/uY0GjSjJ#-TvjklejZBh3O5DfqtLXFtjZaoVetqHPgotdYLH5xoQ\n//\tVisualisation of a small subset of rules recorded by Softology:\n//\t\thttps://www.youtube.com/watch?v=LtdKNso0DwE\n//\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define tex0_in (iChannel0)\n#define tex_size (iResolution.xy)\n\nprecision highp int;\nprecision highp float;\n\nfloat gdv(float x, float y, int v, float div) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n//\t\tdiv\t :\tInteger-spaced number of toroidal divisions of the surface/medium\n\tvec4\tfc \t\t= gl_FragCoord;\n\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\n    float \tdivx\t= dm[0] / div;\n\tfloat \tdivy\t= dm[1] / div;\n\tfloat \tpxo \t= 1.0 / dm[0];\n\tfloat \tpyo \t= 1.0 / dm[1];\n\tfloat \tfcxo \t= fc[0] + x;\n\tfloat \tfcyo \t= fc[1] + y;\n\tfloat \tfcx \t= (mod(fcxo,divx) + floor(fc[0]/divx)*divx ) * pxo;\n\tfloat \tfcy \t= (mod(fcyo,divy) + floor(fc[1]/divy)*divy ) * pyo;\n    vec4 \tpxdata \t= texture( tex0_in, vec2(fcx, fcy) );\n\treturn pxdata[v];\n}\n\nvec3 nhd( vec2 nbhd, vec2 ofst, float psn, float thr, int col, float div ) {\n//\tNeighbourhood: Return information about the specified group of pixels\n\tfloat dist \t\t= 0.0;\n\tfloat cval \t\t= 0.0;\n\tfloat c_total \t= 0.0;\n\tfloat c_valid \t= 0.0;\n\tfloat c_value \t= 0.0;\n\tfor(float i = -nbhd[0]; i <= nbhd[0]; i += 1.0) {\n\t\tfor(float j = -nbhd[0]; j <= nbhd[0]; j += 1.0) {\n\t\t\tdist = round(sqrt(i*i+j*j));\n\t\t\tif( dist <= nbhd[0] && dist > nbhd[1] && dist != 0.0 ) {\n\t\t\t\tcval = gdv(i+ofst[0],j+ofst[1],col,div);\n\t\t\t\tc_total += psn;\n\t\t\t\tif( cval > thr ) {\n\t\t\t\t\tc_valid += psn;\n\t\t\t\t\tcval = psn * cval;\n\t\t\t\t\tc_value += cval-fract(cval); } } } } \n\treturn vec3( c_value, c_valid, c_total );\n}\n\nfloat get_xc(float x, float y, float xmod) {\n//\tUsed to reseed the surface with noise\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0);\n}\nfloat shuffle(float x, float y, float xmod, float val) {\n//\tUsed to reseed the surface with noise\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val));\n}\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n//\tUsed to reseed the surface with noise\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc);\n}\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n//\tUsed to reseed the surface with noise\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf;\n}\nfloat reseed() {\n//\tUsed to reseed the surface with noise\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1], 2.0, 19.0 + mod(iDate[3],17.0), 23.0 + mod(iDate[3],43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 24.0, 13.0 + mod(iDate[3],29.0), 17.0 + mod(iDate[3],31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1], 8.0, 13.0 + mod(iDate[3],11.0), 51.0 + mod(iDate[3],37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tInitilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\t\t\tvec4\tfc \t\t= gl_FragCoord;\t\t\t\t\t\t\t// \tFrag Coords\n\t\t\tvec2 \tdm \t\t= vec2(iResolution.x, iResolution.y);\t//\tSurface Dimensions\n\tconst \tint \tVMX \t= 32;\t\t\t\t\t\t\t\t\t//\tEvolution Variables\n\t\t\tfloat \tpsn\t\t= 250.0;\t\t\t\t\t\t\t\t//\tPrecision\n\t\t\tfloat \tmnp\t\t= 0.004;\t\t\t\t\t\t\t\t//\tMinimum Precision Value : (1.0 / psn);\n\t\t\tfloat\tdiv\t\t= 2.0;\t\t\t\t\t\t\t\t\t//\tToroidal Surface Divisions\n\t\t\tfloat \tdivi \t= floor((fc[0]*div)/(dm[0]))\t\t\n\t\t\t\t\t\t\t+ floor((fc[1]*div)/(dm[1]))*div;\t\t//\tDivision Index\n\tfloat \tdspace  = (divi+1.0)/(div*div);\n\t\t\tdspace  = (div == 1.0) ? 1.0 : dspace;\t\t\t\t\t//\tDivision Weight\n\tvec3 \tcol \t= vec3( 0.0, 0.0, 0.0 );\t\t\t\t\t\t//\tFinal colour value output container\n\n//\tPattern coordinates hardcoded for demonstration purposes\n//\tText file containing other pattern coordinates:\n//\t\thttps://mega.nz/file/uY0GjSjJ#-TvjklejZBh3O5DfqtLXFtjZaoVetqHPgotdYLH5xoQ\n\tfloat[VMX] \tdemo_0 \t= float[VMX]\n\t(\t0.264000,\t0.293000,\t0.156000,\t0.287000,\t\n\t\t0.411000,\t0.305000,\t0.200000,\t0.093000,\t\n\t\t0.467000,\t0.345000,\t0.127000,\t-0.016000,\t\n\t\t-0.108000,\t0.079000,\t0.098000,\t0.370000,\t\n\t\t0.209000,\t0.030000,\t0.222000,\t0.144000,\t\n\t\t0.187000,\t0.199000,\t0.294000,\t0.194000,\t\n\t\t0.277000,\t0.170000,\t0.178000,\t0.007000,\t\n\t\t0.261000,\t0.335000,\t-0.093000,\t0.138000\t);\n        \n\tfloat[VMX] \tdemo_1 \t= float[VMX]\n\t(\t0.352000,\t0.236000,\t0.313000,\t0.197000,\t\n\t\t0.140000,\t0.443000,\t0.252000,\t0.394000,\t\n\t\t0.450000,\t0.567000,\t0.233000,\t0.387000,\t\n\t\t0.273000,\t0.489000,\t0.190000,\t0.374000,\t\n\t\t0.215000,\t0.241000,\t0.264000,\t0.387000,\t\n\t\t0.308000,\t0.373000,\t0.263000,\t0.499000,\t\n\t\t0.225000,\t0.252000,\t0.168000,\t0.344000,\t\n\t\t0.179000,\t0.324000,\t0.391000,\t0.327000\t);\n        \n\tfloat[VMX] \tdemo_2 \t= float[VMX]\n\t(\t0.534000,\t-0.129000,\t0.041000,\t0.683000,\t\n\t\t0.228000,\t0.562000,\t-0.097000,\t0.340000,\t\n\t\t-0.043000,\t0.209000,\t-0.136000,\t0.746000,\t\n\t\t0.663000,\t0.222000,\t0.768000,\t0.299000,\t\n\t\t0.354000,\t0.449000,\t0.172000,\t0.263000,\t\n\t\t0.074000,\t0.760000,\t-0.020000,\t0.060000,\t\n\t\t0.133000,\t0.198000,\t0.200000,\t0.516000,\t\n\t\t0.320000,\t0.429000,\t0.378000,\t0.710000\t);\n        \n\tfloat[VMX] \tdemo_3 \t= float[VMX]\n\t(\t0.378000,\t0.228000,\t0.196000,\t-0.046000,\t\n\t\t0.156000,\t-0.055000,\t0.017000,\t0.055000,\t\n\t\t0.065000,\t0.255000,\t0.115000,\t0.395000,\t\n\t\t-0.041000,\t0.029000,\t0.000000,\t0.125000,\t\n\t\t0.352000,\t0.346000,\t0.178000,\t0.305000,\t\n\t\t0.020000,\t0.237000,\t0.397000,\t0.311000,\t\n\t\t0.215000,\t0.048000,\t0.344000,\t-0.009000,\t\n\t\t0.359000,\t0.244000,\t0.022000,\t0.174000\t);\n\n//\tDivision Weighted V number\n\tfloat[VMX] \tdvmd;\n    if(divi == 0.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_0[i]; } }\n    if(divi == 1.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_1[i]; } }\n    if(divi == 2.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_2[i]; } }\n    if(divi == 3.0) {\n\t\tfor(int i = 0; i < VMX; i++) { dvmd[i] = demo_3[i]; } }\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRULE:Evo32 Selective MNCA\n//\tTYPE:Selective Multiple Neighbourhood Cellular Automata\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n\n//\tGet the reference frame's origin pixel values\n\tfloat\tres_r\t= gdv( 0.0, 0.0, 0, div );\n\tfloat\tres_g\t= gdv( 0.0, 0.0, 1, div );\n\tfloat\tres_b\t= gdv( 0.0, 0.0, 2, div );\n\n//\tIntended rate of change\n\tfloat \ts \t\t= mnp * 12.0;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSTAGE:MNCA\n//\t\tDOMAIN: \tTotalistic Multiple Neighbourhood Continuous\n//\t\tREQUIRES:\tConditional Range\n//\t\tUPDATE:\t\tAdditive\n//\t\tVALUE:\t\tOrigin\n//\t\tBLUR:\t\tRelative\n//\t\tRESULT:\t\tMultiple\n\n//\tNumber of Individual Neighbourhoods\n\tconst \tint \t\tnhds\t= 8;\n//\tContainer for Neighbourhood Totalistic values\n\t\t\tfloat[nhds] nhdt;\n\n//\tNumber of MNCA Groups\n\tconst \tint \t\tsets\t= 4;\n//\tContainer for STAGE:MNCA results\n\t\t\tfloat[sets] rslt;\n\t\t\t\t\t\trslt[0] = res_r;\n\t\t\t\t\t\trslt[1] = res_r;\n\t\t\t\t\t\trslt[2] = res_r;\n\t\t\t\t\t\trslt[3] = res_r;\n\n//\tDefine and assess the Individual Neighbourhoods\n\tvec3 \tn00r \t= nhd( vec2( 1.0, \t0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn01r \t= nhd( vec2( 3.0, \t0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn10r \t= nhd( vec2( 2.0, \t0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn11r \t= nhd( vec2( 5.0, \t3.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn20r \t= nhd( vec2( 5.0, \t2.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn21r \t= nhd( vec2( 9.0, \t7.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn30r \t= nhd( vec2( 4.0, \t2.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\tvec3 \tn31r \t= nhd( vec2( 12.0, \t9.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 0, div );\n\n//\tGet the Totalistic value of each Individual Neighbourhood\n\tnhdt[0] = n00r[0] / n00r[2];\n\tnhdt[1] = n01r[0] / n01r[2];\n\tnhdt[2] = n10r[0] / n10r[2];\n\tnhdt[3] = n11r[0] / n11r[2];\n\tnhdt[4] = n20r[0] / n20r[2];\n\tnhdt[5] = n21r[0] / n21r[2];\n\tnhdt[6] = n30r[0] / n30r[2];\n\tnhdt[7] = n31r[0] / n31r[2];\n    \n\n//\tUPDATE:Additive the VALUE:Origin according to REQUIRES:Conditional Range\n\tif(\tnhdt[0] >= dvmd[0] \t&& nhdt[0] <= dvmd[1] \t) { rslt[0] += s; }\n\tif(\tnhdt[0] >= dvmd[2] \t&& nhdt[0] <= dvmd[3] \t) { rslt[0] -= s; }\n\tif( nhdt[1] >= dvmd[4] \t&& nhdt[1] <= dvmd[5] \t) { rslt[0] += s; }\n\tif( nhdt[1] >= dvmd[6] \t&& nhdt[1] <= dvmd[7] \t) { rslt[0] -= s; }\n\n\tif( nhdt[2] >= dvmd[8] \t&& nhdt[2] <= dvmd[9] \t) { rslt[1] += s; }\n\tif( nhdt[2] >= dvmd[10] && nhdt[2] <= dvmd[11] \t) { rslt[1] -= s; }\n\tif( nhdt[3] >= dvmd[12] && nhdt[3] <= dvmd[13] \t) { rslt[1] += s; }\n\tif( nhdt[3] >= dvmd[14] && nhdt[3] <= dvmd[15] \t) { rslt[1] -= s; }\n\n\tif(\tnhdt[4] >= dvmd[16] && nhdt[4] <= dvmd[17] \t) { rslt[2] += s; }\n\tif(\tnhdt[4] >= dvmd[18] && nhdt[4] <= dvmd[19] \t) { rslt[2] -= s; }\n\tif( nhdt[5] >= dvmd[20] && nhdt[5] <= dvmd[21] \t) { rslt[2] += s; }\n\tif( nhdt[5] >= dvmd[22] && nhdt[5] <= dvmd[23] \t) { rslt[2] -= s; }\n\n\tif( nhdt[6] >= dvmd[24] && nhdt[6] <= dvmd[25] \t) { rslt[3] += s; }\n\tif( nhdt[6] >= dvmd[26] && nhdt[6] <= dvmd[27] \t) { rslt[3] -= s; }\n\tif( nhdt[7] >= dvmd[28] && nhdt[7] <= dvmd[29] \t) { rslt[3] += s; }\n\tif( nhdt[7] >= dvmd[30] && nhdt[7] <= dvmd[31] \t) { rslt[3] -= s; }\n\n//\tApply a BLUR:Relative to the result\n\trslt[0] = (rslt[0] + nhdt[0] * s * 0.5 + nhdt[1] * s * 0.5) / (1.0 + s * 1.0 );\n\trslt[1] = (rslt[1] + nhdt[2] * s * 0.5 + nhdt[3] * s * 0.5) / (1.0 + s * 1.0 );\n\trslt[2] = (rslt[2] + nhdt[4] * s * 0.5 + nhdt[5] * s * 0.5) / (1.0 + s * 1.0 );\n\trslt[3] = (rslt[3] + nhdt[6] * s * 0.5 + nhdt[7] * s * 0.5) / (1.0 + s * 1.0 );\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSTAGE:Variance\n//\t\tDOMAIN: \tMNCA\n//\t\tREQUIRES:\tUnconditional\n//\t\tUPDATE:\t\tSubtract\n//\t\tVALUE:\t\tOrigin\n//\t\tBLUR:\t\tSpecific\n//\t\tRESULT:\t\tMultiple\n\n//\tContainer for STAGE:Variance results\n\tfloat[sets] variance;\n\n//\tUPDATE:Subtract the REQUIRES:Previous value\n\tfor(int i = 0; i < sets; i++) { \n\t\t{ variance[i] = res_r - rslt[i]; } }\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tSTAGE:Output\n//\t\tDOMAIN: \tMNCA, Variance\n//\t\tREQUIRES:\tMaximumABS_Match\n//\t\tUPDATE:\t\tSelect\n//\t\tVALUE:\t\tDomain[0]\n//\t\tBLUR:\t\tSpecific\n//\t\tRESULT:\t\tSingle\n\n//\tIndex of an element in DOMAIN:Variance\n\tint von = 0;\n\n//\tGet the index of the element in DOMAIN:Variance that meets REQUIRES:MaximumABS_Match\n\tfor( int i = 0; i < sets; i++ ) { if( abs(variance[von]) < abs(variance[i]) ) { von = i; } }\n\n//\tUPDATE:Select the DOMAIN:MNCA value with the REQUIRES:MaximumABS_Match index\n\tfloat maxvar = rslt[von];\n\n//\tOutput that value\n\tres_r = maxvar;\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tPresentation Filtering\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\tvec3 \tn0g \t= nhd( vec2( 1.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 1, div );\n\tvec3 \tn0b \t= nhd( vec2( 2.0, 0.0 ), vec2( 0.0, 0.0 ), psn, 0.0, 2, div );\n\tfloat \tn0gw \t= n0g[0] / n0g[2];\n\tfloat \tn0bw \t= n0b[0] / n0b[2];\n\tres_g = ( res_g + n0gw * s * 2.0 + res_r * s * 2.0 ) / (1.0 + s * 4.0);\n\tres_b = ( res_b + n0bw * s * 1.0 + res_r * s * 1.0 ) / (1.0 + s * 2.0);\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tFragment Shader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n    \n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 32.0) { res_r = mod(float(iFrame),2.0); }\n    if (iFrame == 0) { res_r = reseed(); }\n    fragColor=vec4(clamp(res_r,0.0,1.0),clamp(res_g,0.0,1.0),clamp(res_b,0.0,1.0),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1788, 1788, 1845, 1895, 2025]], "test": "untested"}
{"id": "WlGfWW", "name": "Abstract machine patterns", "author": "jarble", "description": "This fractal formula makes some mechanical-looking patterns.", "tags": ["fractal", "mechanical", "robotic"], "likes": 2, "viewed": 260, "published": 3, "date": "1614289977", "time_retrieved": "2024-07-30T19:35:56.111011", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random){\n    return (abs(fract(a*2.0+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 2.7;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor(iTime/5.0));\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy)+fract1(uv/scale*1.5,random.xy);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(-uv/(2.5+(-fract(uv.x+uv.y)))+(uv.yx/(2.5))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= -1.0;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 346, 346, 396], [398, 398, 455, 455, 1445]], "test": "untested"}
{"id": "tlVfD1", "name": "calles y edificio", "author": "jorge2017a1", "description": "calles y edificio", "tags": ["callesyedificio"], "likes": 4, "viewed": 200, "published": 3, "date": "1614288173", "time_retrieved": "2024-07-30T19:35:56.989661", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nfloat iTimeGlobal;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n   \n   \n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   float planeDist1 = p.y+0.0;  //piso inf\n    \n    vec3 posA=p;\n    posA.z= opRep1D(posA.z, 60.0 );\n    posA.x= opRep1D(posA.x, 60.0 );\n    vec3 prepLinea1=posA;\n    \n    prepLinea1.z= opRep1D( prepLinea1.z, 10.0 );\n    \n    \n    //hacer calle A\n    float sdr1A= sdRoundBox(posA-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr1B= sdRoundBox(posA-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr1C= sdRoundBox(posA-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea1= sdRoundBox(prepLinea1-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    \n    \n    //hacer calle B\n    vec3 posB=p-vec3(-30.0,0.0,30.0);\n    posB.z= opRep1D(posB.z, 60.0 );\n    posB.x= opRep1D(posB.x, 60.0 );\n    posB= rotate_y(posB, radians(90.0));\n    vec3 prepLinea2=posB;\n    \n    prepLinea2.z= opRep1D( prepLinea2.z, 10.0 );\n    \n    \n    \n    float sdr2A= sdRoundBox(posB-vec3(0.0), vec3(10.0,1.0,20.0), 0.2 );\n    float sdr2B= sdRoundBox(posB-vec3(-12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdr2C= sdRoundBox(posB-vec3(12.0,0.0,0.0), vec3(2.0,1.5,20.0), 0.2 );\n    float sdrLinea2= sdRoundBox(prepLinea2-vec3(.0,0.0,0.0), vec3(0.05,1.1,1.0), 0.2 );\n    \n    //calle centro\n    vec3 posC=p-vec3(0.0,0.0,30.0);\n     posC.z= opRep1D(posC.z, 60.0 );\n     posC.x= opRep1D(posC.x, 60.0 );\n     \n    float sdr3A= sdRoundBox(posC-vec3(0.0), vec3(10.0,1.0,10.0), 0.2 );\n    \n     //jardin\n   vec3 posD=p-vec3(-31.0,0.0,-13.0);\n     posD.z= opRep1D(posD.z, 60.0 );\n     posD.x= opRep1D(posD.x, 62.0 );\n     \n   float sdr4A= sdRoundBox(posD-vec3(0.0,0.0,12.), vec3(17.0,18.0+22.0*sin(iTime),15.0), 0.2 );\n   \n   \n      //calle a\n    res =opU3(res, vec3(sdr1A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr1B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr1C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea1,2.0,-1.0)); \n    \n    \n    // calle b\n    res =opU3(res, vec3(sdr2A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr2B,8.0,-1.0)); \n    res =opU3(res, vec3(sdr2C,8.0,-1.0)); \n    res =opU3(res, vec3(sdrLinea2,2.0,-1.0)); \n    \n    //calle c\n    res =opU3(res, vec3(sdr3A,-1.0,4.0)); \n    res =opU3(res, vec3(sdr4A,-1.0,2.0)); \n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n   \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n    vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n//-------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\t  if(id_material== 2.0 )\n    {  return vec3( 0.3, 1.0, 1.0 )*1.25;    }\n    \n\n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n       if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,1000.0);\n    iTimeGlobal=t;\n    \n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 0.0, 20.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0,10.0,0.0+t);\n     vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 2.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 454, 454, 475], [476, 476, 508, 508, 592], [593, 593, 639, 639, 726], [728, 772, 819, 819, 846], [848, 848, 891, 891, 918], [920, 920, 968, 968, 996], [997, 1081, 1117, 1117, 1162], [1168, 1168, 1207, 1207, 1251], [1252, 1252, 1291, 1291, 1335], [1341, 1341, 1373, 1373, 1398], [1407, 1472, 1506, 1506, 1604], [1605, 1605, 1639, 1639, 1731], [1732, 1732, 1766, 1766, 1858], [1859, 1899, 1933, 1933, 2030], [2033, 2073, 2098, 2098, 4450], [4453, 4453, 4518, 4518, 5101], [5105, 5156, 5180, 5180, 5368], [5369, 5432, 5465, 5465, 5926], [5928, 5982, 6018, 6018, 6252], [6253, 6379, 6415, 6415, 6620], [6621, 6692, 6716, 6716, 6971], [7019, 7053, 7133, 7133, 7404], [7447, 7498, 7545, 7545, 8180], [8234, 8234, 8327, 8327, 8605], [8610, 8659, 8716, 8716, 9919]], "test": "untested"}
{"id": "tlKfDh", "name": "sRGB gamut clipping", "author": "FabriceNeyret2", "description": "How to best display out-of-gamut colors. \nmouse.y to choose ref vs 5 methods. bottom-left to go back to auto-demo.\n\nPorting to GLSL Björn Ottosson [url]https://bottosson.github.io/posts/gamutclipping/[/url]", "tags": ["saturation", "lab", "colorspace", "gamutclipping"], "likes": 3, "viewed": 530, "published": 3, "date": "1614277755", "time_retrieved": "2024-07-30T19:35:58.063790", "image_code": "// ported to GLSL from https://bottosson.github.io/posts/gamutclipping/\n\n/*\nCopyright (c) 2021 Björn Ottosson\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#define cbrtf(x)  ( sign(x)*pow(abs(x),1./3.) )\n#define FLT_MAX     3.402823466e+38\n\n\nstruct Lab {float L; float a; float b;};\nstruct RGB {float r; float g; float b;};\n\nLab linear_srgb_to_oklab(RGB c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrtf(l);\n\tfloat m_ = cbrtf(m);\n\tfloat s_ = cbrtf(s);\n\n\treturn Lab(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nRGB oklab_to_linear_srgb(Lab c)\n{\n    float l_ = c.L + 0.3963377774f * c.a + 0.2158037573f * c.b;\n    float m_ = c.L - 0.1055613458f * c.a - 0.0638541728f * c.b;\n    float s_ = c.L - 0.0894841775f * c.a - 1.2914855480f * c.b;\n\n    float l = l_ * l_ * l_;\n    float m = m_ * m_ * m_;\n    float s = s_ * s_ * s_;\n\n    return RGB(\n        +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n        -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n        -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n    );\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps \n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nstruct LC { float L; float C; };\nLC find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tRGB rgb_at_max = oklab_to_linear_srgb(Lab( 1., S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrtf(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn LC( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tLC cusp = find_cusp(a, b);\n\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.C - (cusp.L - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.C * L0 / (C1 * cusp.L + cusp.C * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.C * (L0 - 1.f) / (C1 * (cusp.L - 1.f) + cusp.C * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\t\t\t\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3. * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3. * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3. * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6. * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6. * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6. * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.;\n\t\t\t\tfloat g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : FLT_MAX;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : FLT_MAX;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\n/*\nfloat clamp(float x, float min, float max)\n{\n\tif (x < min)\n\t\treturn min;\n\tif (x > max)\n\t\treturn max;\n\n\treturn x;\n}\n\nfloat sgn(float x)\n{\n\treturn (float)(0.f < x) - (float)(x < 0.f);\n}\n*/\n\nRGB gamut_clip_preserve_chroma(RGB rgb)\n{\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\tfloat L0 = clamp(L, 0., 1.);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1. - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_project_to_0_5(RGB rgb)\n{\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1. - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_project_to_L_cusp(RGB rgb)\n{\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tLC cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.L;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1. - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_adaptive_L0_0_5(RGB rgb, float alpha) // alpha = 0.05f\n{\n    if (alpha<0.) alpha = 0.05; // default\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f*(1. + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nRGB gamut_clip_adaptive_L0_L_cusp(RGB rgb, float alpha) // alpha = 0.05f\n{\n    if (alpha<0.) alpha = 0.05; // default\n\tif (rgb.r < 1. && rgb.g < 1. && rgb.b < 1. && rgb.r > 0. && rgb.g > 0. && rgb.b > 0.)\n\t\treturn rgb;\n\n\tLab lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.L;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.a * lab.a + lab.b * lab.b));\n\tfloat a_ = lab.a / C;\n\tfloat b_ = lab.b / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tLC cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.L;\n\tfloat k = 2. * (Ld > 0. ? 1. - cusp.L : cusp.L);\n\n\tfloat e1 = 0.5*k + abs(Ld) + alpha * C/k;\n\tfloat L0 = cusp.L + 0.5 * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(Lab( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n#define toRGB(C)   RGB((C).r,(C).g,(C).b)\n#define fromRGB(C) vec4(C.r,C.g,C.b,1)\n\nvoid mainImage( out vec4 O, vec2 u ) // ----------------------------------------\n{\n    vec2 R = iResolution.xy,\n         U = u/R;\n    int t = ( length(iMouse.xy)<10.) ? int(iTime)%6          // method ref,1..5 :\n                                     : int(6.*iMouse.y/R.y); // demo or tune\n    U.x = 1.05*U.x - .05;\n    if (U.x>0.) {\n        O = texture(iChannel0, U);\n        \n        O = 3.*O-1.;                 // put here your out of gamut transform\n        \n        RGB C = toRGB( O );\n        switch(t) {\n            case 0: break;\n            case 1: C = gamut_clip_preserve_chroma(C);           break;\n            case 2: C = gamut_clip_project_to_0_5(C);            break;\n            case 3: C = gamut_clip_project_to_L_cusp(C);         break;\n            case 4: C = gamut_clip_adaptive_L0_0_5( C, -1. );    break;\n            case 5: C = gamut_clip_adaptive_L0_L_cusp( C, -1. ); break;\n        }\n        O = fromRGB( C );\n    }\n    else {                           // buttons\n      O = vec4( smoothstep(1.5/R.y,0., length( u/R.y - vec2(.04,(float(t)+.5)/6.) ) -.03 ) );\n      if (t==0) O.gb*=0.;\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfDh.jpg", "access": "api", "license": "mit", "functions": [[1308, 1308, 1341, 1341, 1847], [1849, 1849, 1882, 1882, 2388], [2390, 2554, 2602, 2760, 4785], [4911, 4911, 4943, 5003, 5361], [5363, 5502, 5581, 5621, 8028], [8221, 8221, 8262, 8262, 8785], [8787, 8787, 8827, 8827, 9337], [9339, 9339, 9382, 9382, 10039], [10041, 10041, 10112, 10112, 10779], [10781, 10781, 10855, 10855, 11735]], "test": "untested"}
{"id": "wlVBWh", "name": "low discrepancy nD open sequence", "author": "FabriceNeyret2", "description": "from Martin Roberts [url]http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/[/url]\nProbably implemented 50x in Shadertoy...\nBlue, White, Disk, Sphere. left half: fading old points\n(not so good even distribution, to my taste)", "tags": ["hash", "bluenoise", "goldenratio", "lowdiscrepancy", "quasimontecarlo"], "likes": 12, "viewed": 434, "published": 3, "date": "1614273554", "time_retrieved": "2024-07-30T19:35:58.932467", "image_code": "// from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\nvoid mainImage( out vec4 O, vec2 U ) {   O = T(U);   }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// from Martin Roberts  http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\nvec2 rand(float n) {\n    float g = 1.32471795724474602596; // Phi_2.  Phi_n: solve x^(n+1) = x+1\n    vec2 a = 1./vec2(g,g*g);          // a = 1/Phi_n^(1,2...n)\n    return fract( .5 + a * n );\n}\n\n#define hash(n)  fract(sin( (n) * vec2(12.9898, 78.233) ) * 43758.5453)  // old uniform hash\n\n\nint N = 10;                           // number of samples per frame\n#define sqr(x) ( (x) * (x) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n\n    ivec2 I = ivec2(2.*U/R); int i = I.x+2*I.y; // tile ID\n    U = mod(2.*U,R);\n    \n    if ( U.x < R.x/2. ) O *= .99;\n    for( int k=0; k < N; k++ ) {\n        float n =  float(k + N*iFrame);\n        vec2 r = rand(n),\n        P = i==2 ? R * r\n          : i==3 ? R * hash(n)\n       // : i==0 ? R/2. + R.y/2.            * sqrt(r.x)   * cos(6.283*(r.y+vec2(0,.25)))\n          : i==0 ? R/2. + R.y/2.            *(2.*r.x-1.)  * cos(6.283*(r.y+vec2(0,.25)))\n          :        R/2. + R.y/2.* sqrt(1.-sqr(2.*r.x-1.)) * cos(6.283*(r.y+vec2(0,.25)));\n        O += clamp(1.5-length( U - P ), 0., 1.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 130, 130, 146]], "test": "untested"}
{"id": "tlVBWh", "name": "Squaring the Area", "author": "eiffie", "description": "Anyone can construct a square with the same area as a circle. Child's play. Try constructing another circle with the squared area of the first using a compass and straight edge. ;)", "tags": ["squaredcircle"], "likes": 6, "viewed": 357, "published": 3, "date": "1614271387", "time_retrieved": "2024-07-30T19:35:59.813112", "image_code": "//Squaring the Circle by eiffie\n//The green circle has area pi^2\n#define rez iResolution.xy\n\n//#define GETABITCLOSER\nfloat hash(vec2 v){return fract(sin(dot(v,vec2(17.1,113.3)))*436.123);}\nvec2 norm(float a){return vec2(cos(a),sin(a));}\nvec3 compass(vec2 v, vec2 c, float r){\n  v-=c;\n  return vec3(10.0,0.3*length(v),abs(length(v)-r));\n}\nvec3 edge(vec2 v, vec2 a, vec2 b){\n  vec2 p=b-a;a=v-a;p*=clamp(dot(a,p)/dot(p,p),0.0,1.0);\n  return vec3(distance(a,p),0.3*min(length(a),length(v-b)),10.0);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 p=2.0*(2.0*U.xy-rez)/rez.y;\n  float rnd=hash(U)*0.8+0.2;\n  vec3 blue=vec3(0.5,0.6,0.7),red=vec3(0.9,0.6,0.5),green=vec3(0.6,0.7,0.5),col=vec3(10.0);\n  col=min(col,edge(p,vec2(0.0,-2.0),vec2(0.0,2.0)));\n  col=min(col,edge(p,vec2(2.0,0.0),vec2(-2.0,0.0)));\n  col=min(col,compass(p,vec2(0),1.));\n  col=min(col,compass(p,vec2(0),sqrt(3.14159)).xzy);\n  col=min(col,edge(p,vec2(0.0,0.0),vec2(2.0,2.0)));\n #ifdef GETABITCLOSER\n  col=min(col,compass(p,vec2(.5,0),.5));\n  col=min(col,compass(p,vec2(.75,0),.25));\n  col=min(col,compass(p,vec2(1,0),.25));\n  col=min(col,edge(p,vec2(1.25,0.0),vec2(1.25,1.25)));\n #else\n  float t2=1./sqrt(2.);\n  col=min(col,compass(p,vec2(t2),length(vec2(t2,1.-t2))));\n #endif\n  col=smoothstep(vec3(5.0/rez.y),vec3(0.0),col)*0.85+vec3(0.0,0.0,0.15);\n  O=vec4(rnd*(red*col.r+green*col.g+blue*col.b),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 117, 136, 136, 188], [189, 189, 208, 208, 236], [237, 237, 275, 275, 337], [338, 338, 372, 372, 496], [497, 497, 535, 535, 1369]], "test": "untested"}
{"id": "3lVBD1", "name": "SCP-1968 shape", "author": "DukeOfStraylight", "description": "A reproduction of the shape of http://scp-wiki.wdfiles.com/local--files/scp-1968/bronzetorus.gif\nI was originally going to try to do the refractions too, but just getting the shape done was pretty advanced for me, so I won't work on this more yet.", "tags": ["raymarch", "torus", "scp", "scp1968"], "likes": 1, "viewed": 79, "published": 3, "date": "1614268265", "time_retrieved": "2024-07-30T19:36:00.662840", "image_code": "// 0 = loop through all toruses to see which one's closest\n// 1 = use atan() to figure out which toruses might be closest, try two\n#define IMPLEMENTATION 1\n\nmat2 rotate(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nconst float pi = 3.14159;\nconst float tau = 2.*pi;\n\n// Just the tiniest bit of in-out easing\nfloat ssmooth(float z, float x) {\n  return x-sin(x*tau)*z;\n}\n\nconst float toruses = 7.;\nconst float twist = 3.;\n// Weird name, but: how much slower the inside moves than the outside.\n// Starts breaking optimizations at 0.08ish or so.\nconst float sinification = 0.06;\nconst vec2 scale = vec2(1.8, 2.5);\nconst float speed = 0.15;\n\n// czm_ prefixed functions from\n// https://github.com/CesiumGS/cesium/blob/master/Source/Shaders/Builtin/Functions/fastApproximateAtan.glsl\nfloat czm_fastApproximateAtan(float x) {\n    return x * (-0.1784 * x - 0.0663 * x * x + 1.0301);\n}\n\nfloat czm_fastApproximateAtan(float x, float y) {\n    // atan approximations are usually only reliable over [-1, 1], or, in our case, [0, 1] due to modifications.\n    // So range-reduce using abs and by flipping whether x or y is on top.\n    float t = abs(x); // t used as swap and atan result.\n    float opposite = abs(y);\n    float adjacent = max(t, opposite);\n    opposite = min(t, opposite);\n\n    t = czm_fastApproximateAtan(opposite / adjacent);\n\n    // Undo range reduction\n    t = (abs(y) > abs(x)) ? (pi*0.5) - t : t;\n    t = (x < 0.0) ? pi - t : t;\n    t = (y < 0.0) ? -t : t;\n    return t;\n}\n\n\nfloat scene(vec3 p) {\n    p.y = abs(p.y);\n    float a = atan(p.x, p.z)*(twist/tau/toruses);\n    vec2 q = vec2(length(p.xz)-4.,p.y-4.);\n\n#if IMPLEMENTATION == 0\n    float minl = 10000.;\n    for (float n = 0.; n < 1.; n += (1./toruses)) {\n        float t = iTime*speed - a + n;\n        t = ssmooth(sinification, t) * tau + pi;\n        vec2 ep = vec2(cos(t), sin(t))*scale;\n        vec2 l = q-ep;\n        minl = min(minl, dot(l, l));\n    }\n#endif\n\n#if IMPLEMENTATION == 1\n    // Loopless implementation: Make two reasonable guesses\n    // about which torus is actually closest, and only draw those.\n    // This does slightly warp space in the middle, but not so much\n    // as to cause any artifacts that I can see.\n    // No need for high precision in our atan here because we're just\n    // using it to figure out what general neighborhood we're in;\n    // we're also using the somewhat squished q without normalizing it\n    // first, based on the guess that that's less work overall\n    float uta = (czm_fastApproximateAtan(q.x, q.y) + pi)/tau;\n    // Just assume that ssmooth(sinification, x) =~ x (i.e. that the toruses\n    // are uniformly spaced), again because we don't need high precision\n    float nt = (uta - iTime*speed + a)*toruses;\n    vec2 ns = vec2(floor(nt), ceil(nt))/toruses;\n\n    vec2 t = iTime*speed - a + ns;\n    t = vec2(ssmooth(sinification, t.x), ssmooth(sinification, t.y)) * tau + pi;\n    vec2 epx = vec2(cos(t.x), sin(t.x)) * scale;\n    vec2 lx = q-epx;\n    vec2 epy = vec2(cos(t.y), sin(t.y)) * scale;\n    vec2 ly = q-epy;\n    float minl = min(dot(lx, lx), dot(ly, ly));\n#endif\n\n    float od = sqrt(minl) - .5;\n    return od;\n}\n\n// iq's tetrahedral normals from\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.01; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\n// stolen from wherever, http://glslsandbox.com/e#48598.1 I think\nfloat hash21(vec2 p) {\n  p = fract(p * vec2(233.34, 851.74));\n  p += dot(p, p + 23.45);\n  return fract(p.x * p.y);\n}\n\nconst vec3 uglybrown = vec3(.4, .4, .25);\nconst vec3 lovelyblue = 1.-uglybrown;\n\nvec2 castRay(vec3 ro, vec3 rd, float t) {\n    float minD = 20.;\n    for (int n = 0; n < 200; n++) {\n        vec3 p = ro + t * rd;\n        float d = scene(p);\n        t += d;\n        minD = min(minD, d);\n        if (d < 0.001 || d > 20.) {\n            break;\n        }\n    }\n    return vec2(minD, t);\n}\n\nvec3 sceneColor(vec3 ro, vec3 rd, float initT) {\n    vec2 ray = castRay(ro, rd, initT);\n    float minD = ray.x;\n    float t = ray.y;\n\n    vec3 p = ro + t * rd;\n    vec2 floorHit = ro.xz - ro.y/rd.y * rd.xz;\n    float floorBrightness = smoothstep(7., 4., length(floorHit))*0.8;\n    if (minD < 0.001) {\n        vec3 normal = normal(p);\n        if (p.y > 0.) {\n            float d = dot(normal, normalize(vec3(1, 0.2, 0.2)));\n            d = mix(d, 1.0, 0.4);\n            return mix(vec3(.4, .7, 1.), vec3(.1, .3, 1.), 1.-d);\n        } else {\n            float d = -dot(normal, rd);\n            d *= d * d;\n            vec3 c = mix(vec3(d), uglybrown, 0.9);\n            return mix(c, vec3(1), floorBrightness);\n        }\n    } else {\n        return mix(lovelyblue, vec3(1), floorBrightness);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 9, 14);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.4, -1));\n    fragColor = vec4(sceneColor(ro, rd, 0.), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 179, 179, 255], [309, 350, 383, 383, 410], [679, 819, 859, 859, 917], [919, 919, 968, 1156, 1520], [1523, 1523, 1544, 1544, 3176], [3178, 3257, 3304, 3304, 3606], [3608, 3674, 3696, 3696, 3790], [3873, 3873, 3914, 3914, 4174], [4176, 4176, 4224, 4224, 4972], [4974, 4974, 5031, 5031, 5224]], "test": "untested"}
{"id": "3tKfW1", "name": "Sine Moiré", "author": "dlozeve", "description": "Moiré pattern with high-frequency sine curve", "tags": ["moire", "trig"], "likes": 1, "viewed": 241, "published": 3, "date": "1614263906", "time_retrieved": "2024-07-30T19:36:01.546478", "image_code": "float angle(vec2 u, vec2 v) {\n  return acos(dot(u, v) / (length(u) * length(v)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = fragCoord.xy / iResolution.xy;\n  float color = 0.0;\n  vec2 c = vec2(0.5);\n  float i = float(int(iFrame) % 1000) / 200.0;\n  float border = 0.5 * sin(i * 1000.0 * angle(fract(p) - c, vec2(1.0, 0.0)));\n  if (length(fract(p) - c) < border) {\n    color = 1.0;\n  }\n  fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 83], [86, 86, 143, 143, 453]], "test": "untested"}
{"id": "3lKBW1", "name": "iso fun", "author": "gourki", "description": "fun iso?", "tags": ["isofun"], "likes": 2, "viewed": 235, "published": 3, "date": "1614263437", "time_retrieved": "2024-07-30T19:36:02.403693", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI acos(-1.)\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p =abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\n\nfloat signed_box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat SDF (vec3 position)\n{\n    position.yz *=rot(iTime/2.*-atan(1./sqrt(2.)));\n    position.xz *=rot(PI/4.*iTime/2.);\n    \n    //mo(position.xz,vec2(1.));\n    mo(position.xz,vec2(abs(sin(iTime/2.)),abs(cos(iTime/2.))));\n    mo(position.yz,vec2(abs(cos(iTime/2.)),abs(sin(iTime/2.))));\n    position.x -= sin(iTime/2.)+1.;\n    position.y -= cos(iTime/2.)+1.;\n    //position.xz *= rot(iTime);\n    //position.yz *= rot(iTime);\n    return signed_box(position, vec3(.5));\n}\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize( SDF(p) - vec3(SDF(p-eps.xyy), SDF(p-eps.yxy),SDF(p-eps.yyx)) );\n   //return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n     // thanks remy ! random qui va noise les uvs, rendant un effet sur le rendu\n    float rand = 0.;fract(sin(length(uv)*64.125 + fract(iTime*.001))*752.3216) * sin(iTime/3.)/100.;\n    \n    \n    // perspective camera\n    /*vec3 ray_origin = vec3(0.,0.,-2.),\n    ray_direction = normalize( vec3(uv,1.) ),\n    pos = ray_origin,\n    */\n    \n    \n    //orthographic camera\n    vec3 ray_origin = vec3(uv*2.,-20.),\n    ray_direction = normalize( vec3(vec2(0.+rand, 0.+rand),1.) ),\n    pos = ray_origin,\n    \n    //light \n    dir_light = normalize( vec3(-1.,1.,-2.) ),\n    //background color\n    col = vec3(0.);\n    \n    bool hit = false;\n    float shading;\n    for (float i=0.; i<64.; i++)\n    {\n        float dist = SDF(pos);\n        if(dist < 0.001)\n        {\n            hit = true;\n            shading = i/64.;\n            break;\n        }\n        pos += dist * ray_direction;\n    }\n    \n    if (hit)\n    {\n        vec3 normal = get_normals(pos);\n        float lighting = max(dot(normal,dir_light),0.);\n        col = normal*vec3(lighting);\n    }\n    \n    \n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(2.)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 103, 103, 148], [151, 151, 186, 186, 273], [275, 275, 302, 302, 743], [745, 745, 772, 772, 913], [915, 915, 972, 1022, 2213]], "test": "untested"}
{"id": "3tKfWh", "name": "Agnes Hailstone's caribou hunt", "author": "evvvvil", "description": "Agnes Hailstone's caribou hunt - Result of an improvised live coding session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "glow", "ghost", "life", "monster", "god", "zero", "horror", "spirit", "ghoul", "deity", "goddess", "below", "witch"], "likes": 19, "viewed": 807, "published": 3, "date": "1614258933", "time_retrieved": "2024-07-30T19:36:03.281347", "image_code": "// Agnes Hailstone's caribou hunt - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"I just gave this caribou its last drink.\" - Agnes Hailstone \n\n//EDIT 27-02-21: LINE 26: Found a nifty way to drastically reduce artifact as it swirls by reusing the swirl value to contrl the definition of the distance field, does a cool \"warpy motion blur\"\n\nvec2 z,v,e=vec2(.001,-.001);float t,tt,b,ct,g=0.,gg=0.,tnoi;vec3 bp,pp,po,no,ld,al,cp,op;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25;\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p, float ga )\n{\n  op=p;p.xy+=v;  \n  p.yz*=r2(-1.2+sin(op.z*.02-tt)*0.5);  \n  float bro=smoothstep(0.,1.,(clamp(cos(p.y*.04+tt*0.5+1.),-.33,.33)+.33)*1.51);\n  p.xz*=r2(ct*.75+bro*6.28);\n  tnoi=texNoise(p.xy*.12+3.,iChannel0).r;  \n  float sinner =sin(p.y*.5+1.0),xd=sin(p.x*(10.-sinner*5.))*.15,zd=pow((cos(p.y*.5+tt))*1.3,2.); \n  cp=p+tnoi; cp.xz+=xd; cp.z-=zd;  \n  float head=abs(length(cp-vec3(xd,6,0))-2.)-.1;//HOOD\n  head=0.6*max(head,-cp.z);    \n  float art=clamp(sin(bro*-3.14)*.5+.5,0.1,0.5);\n  float coat=bo(cp,vec3(2.+sinner*1.75+sin(p.y*10.)*0.03,6,0.04 ));/////CLOAK\n  coat=max(coat,-(length(cp.xz)+sin(p.y*.5+0.75)-tnoi*2.));  \n  pp=p-vec3(0,2,0);pp.xy=abs(pp.xy)-vec2(1.+sin(p.y+p.x*.2-.1)*1.5,1);\n  pp.x=abs(pp.x)-1.;\n  coat=art*max(coat,-(length(pp.yx)+.2-tnoi*3.8));\n  vec2 h,t=vec2(coat,5);  \n  t.x=smin(t.x,head,.25);  \n  vec3 ep=p-vec3(0,6.4,0); ////EYESSSSSS   \n  ep.xz=vec2(abs(ep.x)-0.5,ep.z-zd+.1);\n  ep.xy*=r2(.3);\n  float eyes=0.6*length(ep)-cos(clamp(ep.y*15.,-5.,5.))*.2;  \n  t.x=min(t.x,eyes);   \n  pp=p-vec3(0,0,2.7);//SPINES\n  pp.x=abs(pp.x)-.5+(p.y-9.)*.3; pp.xz-=vec2(xd*.5,zd); \n  pp.yz*=r2(-0.3);\n  float spines=length(pp.xz)-0.1+sin(p.y*.2-1.8)*.5;\n  spines=max(spines,abs(p.y-1.)-9.);\n  t.x=smin(art*spines,t.x,.5);     \n  pp=p-vec3(0,5.5,zd+1.);//FACE\n  cp=pp;\n  h=vec2(length(pp)-1.15-sin(p.y+.3),3);   \n  pp.y-=1.5; //HEADLINES\n  pp.xy=abs(pp.xy);\n  pp.xy*=r2(.3);\n  pp.z-=pow(abs(pp.x*.2+sin(p.x*.5+tt)*.5),2.)*2.0;  \n  float headline=(art-.04)*(length(pp.yz)-.4+abs(p.x*.04));\n  h.x=min(h.x,headline);\n  t=t.x<h.x?t:h;\n  b=texNoise((op.xz+vec2(0,-tt*5.))*0.03,iChannel0).r; //TERRAIN\n  op.y=abs(op.y)-9.;\n  h=vec2(op.y+5.+b*5.+cos(op.x*.1)*5.,6);\n  pp=op;pp.x=abs(pp.x)-15.;\n  pp.z=mod(pp.z-tt*5.,20.)-10.;  \n  h.x=smin(0.9*h.x,length(pp.xz)-2.0+b+op.y*.1,10.);\n  t=t.x<h.x?t:h;  \n  if(ga>0.){\n    p.x=mod(abs(p.x)-tt*2.,2.)-1.;\n    headline=max(headline,abs(p.x));\n    g+=0.1/(0.1+eyes*eyes*120.);\n    g+=0.1/(0.1+headline*headline*120.);\n    op.xy*=r2(sin(op.z*.03+tt*.5));\n    op.z=mod(op.z-tt*10.,10.)-5.;\n    float part=length(abs(op)-5.);\n    gg+=0.1/(0.1+part*part*120.);\n    t.x=min(t.x,part);\n  }  \n\treturn t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x,1.);\n    if(t.x<.0001||t.x>40.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>40.) t.y=0.;\n\treturn t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82)+12.;\n  ct=cos(tt); v=ct*vec2(3,2)-vec2(0,9);\n  bp=vec3(v,0);  b=sin(tt*.4);\n  vec3 ro=mix(vec3(cos(tt*.4)*5.,-2,-10),vec3(sin(tt*.4)*7.,-4.0,-cos(tt*.4)*10.),ceil(b)),\n  cw=normalize(-bp-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5+b*.5*ceil(b))),co,fo;\n  co=fo=vec3(.14,.11,.12)-length(uv)*.15;\n  ld=normalize(vec3(.2,-.2,-.5));\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){\n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n    al=mix(vec3(0.4,0.5,0.6),vec3(0),min(1.,tnoi*3.));    \n    if(z.y<5.)al=mix(vec3(1.-ceil(sin(cp.y*3.5-1.))),vec3(0),ceil(min(1.,abs(abs(abs(cp.x*7.)-.9)-0.5)-.15)));\n    if(z.y>5.)al=vec3(1,.2,.5)*b;\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);\n    co=mix(al*(a(.5)+.5)*(dif+s(.1)+s(.5)),fo,min(fr,1.));\n    co=mix(fo,co,exp(-.00007*t*t*t));\n  }  \n  fragColor = vec4(pow(co+g*.2*vec3(.7,.2,.1)+gg*.2,vec3(.65)),1);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[554, 554, 578, 578, 619], [620, 620, 637, 637, 680], [681, 681, 717, 717, 771], [772, 772, 810, 810, 1006], [1007, 1007, 1036, 1036, 3181], [3182, 3182, 3210, 3210, 3376], [3472, 3472, 3529, 3529, 4632]], "test": "untested"}
{"id": "ttyBW1", "name": "Yusef28's lens flare examined", "author": "jstrom2002", "description": "Breakdown of Yusef28's lens flare shadertoy with some minor changes and tidying of the code for clarity. Customizing the look of the flare is possible by editing values in the 'LensHighlight()' function.", "tags": ["lensflare"], "likes": 6, "viewed": 604, "published": 3, "date": "1614249155", "time_retrieved": "2024-07-30T19:36:04.049294", "image_code": "// Based on an OpenGL implementation of Yusef28's code.\n// Yusef28's ' Circle & Polygon Lens Flare' shadertoy: https://www.shadertoy.com/view/Xlc3D2\n// This shadertoy is a work-in-progress.\n\n// Uniforms. Hardcoded for this shadertoy, pass in vals for your impl.\nint MAX_ITERATIONS = 4;\nvec3 cameraPosition = vec3(0.0);\n//vec3 lightPosition;//replace local var in 'mainImage()' w/ your uniform here\nvec3 lightColor = vec3(1.0);\nmat4 viewProjection;//Unused in shadertoy, use in your 3D impl.\n\n// Tweakable uniforms\nfloat lensFlareExposure = 1.0;\nfloat lensFlareBrightness = 1.0;\nfloat lensFlareScale = 0.175;\nfloat lensFlareFade = 1.0;//fades over 3D position between light and camera, unused for this shadertoy\n\n\n\nvec3 modelToScreen(vec3 v){//Unused in shadertoy, use in your 3D impl.\n\tvec4 v_2 = viewProjection * vec4(v,1.0);\n\tv_2.xyz = v_2.xyz / v_2.w;//to NDC\n\treturn vec3(v_2.xy * 0.5 + 0.5, v_2.z);//to [0,1]\n}\nfloat rnd(float w){\n    //Use bluenoise texture for fast lds random values in range [0,1]\n    return texture(iChannel0, vec2(w)).r;\n}\n\nfloat regularPolygon(vec2 p, int N){// Produces a regular polygon defined by N points on the unit circle.\n    float a=atan(p.x,p.y)+.2;\n    float b=6.28319/float(N);\n    return smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));        \n}\n\nfloat renderSmallCircle(vec2 pos, vec2 ltpos, float dist, vec2 offsetFromCenter, float size)\n{\n\tvec2 coord = pos - ltpos * dist/2.0 + offsetFromCenter;\n\tfloat radiusVal =  0.04 / length(coord)*size;\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\n}\n\nfloat renderBigCircle(vec2 pos, vec2 ltpos, float dist, vec2 offsetFromCenter, float size)\n{\n\tvec2 coord = pos + ltpos*dist + offsetFromCenter;\n\tfloat radiusVal =  0.01 - pow(length(coord), size * 1.4);\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\t\n}\n\nfloat renderRing(float r, float offsetFromCenter, float fade)\n{\n\tfloat radiusVal = 0.001 - pow(r - offsetFromCenter, 1.0/fade) + sin(r * 30.0);\n\tradiusVal = max(radiusVal, 0.0);//filter negative vals.\n\treturn radiusVal;\t\n}\n\nfloat renderHexagon(vec2 uv, vec2 lightPos, vec2 offsetFromCenter, \n\tfloat hexagonIntervalDist, float size)\n{\n\tconst int hexagonPoints = 6;\n\tvec2 hexagonCoord = uv*size + lightPos*hexagonIntervalDist*size + offsetFromCenter;\n\tfloat hexValue = 0.01 - regularPolygon(hexagonCoord, hexagonPoints);\n   \thexValue = max(hexValue, 0.0);//filter negative vals.\n\treturn hexValue;\n}\n\nvec3 chromaticAberration(vec3 color, vec2 pos, vec2 ltpos, int iter)\n{   // NOTE: This function still needs some work.\n\n\tconst float intensity = 0.075;//adjust as needed.\n\tfloat amount = intensity * length(pos-ltpos) * \n\t\trnd(float(iter)*0.713) * float(iter);\t\n\n\t// Rotate which channels are being offset per iteration (i).\n\tvec3 cyclic_amt = (vec3(-0.95,-0.98,-1.0) + amount * \n\t\tvec3(iter%3,(iter+1)%3,(iter+2)%3));//vec3 of ints ranged [-1,1]\n\n    vec3 col = color + cyclic_amt;\n\treturn col * (1.0 - amount * 0.5);\n}\n\n// 'LensHighlight()' -- Generates 4 lens artifacts: a single large circle, small circle, ring, and hexagon.\n// Params:\n// pos: current fragment's screen-space position\n// lightPos: light's screen-space position\n// color: base color of highlight\n// size: size of lens highlight diameter\n// dist: distance between lens flare highlights in screen space\nvec3 LensHighlight(vec2 pos, vec2 lightPos, vec3 color, float size, float dist, int i)\n{   \n    // Create a big circle, ring, small circle, and hexagon and control blending with a vec4.\n\tconst vec4 blend_val = 0.01 * vec4(2500.0, 20.0, 1.50, 2000.0);//adjust as necessary per-object.\n\t\n    float bigCircle_size = size * 0.2 * float(i);\n    vec2 bigCircle_offset = -lightPos * vec2(2.0);\n    float bigCircle = renderBigCircle(pos,lightPos,dist,bigCircle_offset, bigCircle_size) * blend_val.x;    \n    \n    float ring_fade = 7.0 * float(i);\n\tvec2 ring_offset = \n        //vec2(0.0);//<== rings around light source.\n        -lightPos * vec2(2.5) * float(i);//<== ring halos in light ray.\n    float ring_size = size * 5.0 * float(i);\n    float lt_coord = length(pos - lightPos - ring_offset);\n    float ring_radius  = lt_coord + ring_size; \n\tfloat ring = renderRing(ring_radius, ring_size, ring_fade) * blend_val.y;   \n\n\tvec2 smallCircle_offset = lightPos * vec2(0.0159);\n    float smallCircle_size = 84.0;\n\tfloat smallCircle = renderSmallCircle(pos,lightPos,dist,smallCircle_offset, smallCircle_size) * blend_val.z;\n    \n    // Draws hexagons in order closest to light to farthest.\n\tvec2 hexagon_offset = -lightPos * vec2(1.5) * float(i) + lightPos * 0.32;\n\tfloat hexagon_size = 11.0 - 2.0 * float(i);\n    float hexagon_fade = 0.25 * pow(float(i), 2.5);\n\tfloat hexagon  = renderHexagon(pos,lightPos,hexagon_offset,dist,hexagon_size)*hexagon_fade*blend_val.w;\n    \n\t// Slightly offset colors to simulate chromatic abberration.\n\tcolor = chromaticAberration(color, pos, lightPos, i);\n \treturn (smallCircle + bigCircle + ring + hexagon) * color;\n}\n\n// 'LensFlare()' -- Main function for accumulating flare color.\n// Params:\n// currPos: current fragment's screen-space position\n// lightPos: light's screen-space position\n// distToLight: world space distance between camera and light.\nvec3 Lensflare(vec2 currPos, vec2 lightPos, float distToLight)\n{\n\n\tvec3 flareColor = vec3(0.0);\n\tfloat lt_dist = distToLight+1.0f;//prevent division by val < 1.\n\tfloat proximity_divisor = length(currPos-lightPos);\n\tfloat loopVal = 1.0f;\n\tint i = 1;\n\n\tconst float epsiln = 0.0001f;\n\twhile(loopVal > epsiln && i < MAX_ITERATIONS)\n\t{\n\t\tfloat i_f = float(i);\n\t\tvec2 pos = currPos;//square value to produce appropriate warping effect\n\t\tvec2 lpos = lightPos;\n\t\tvec3 color_rand = 2.0 * i_f * vec3(rnd(i_f * 3.0913));\n\t\tvec3 col = lightColor + clamp(color_rand, 0.0, 1.0);\n\t\tfloat flareSize = \n\t\t\t i_f*i_f*pow(rnd(i_f * 21.773) * 1.8, 1.0) + 0.5;\n\t\tfloat flareInterval = \n\t\t\t(lensFlareScale/lt_dist) * pow(rnd(i_f * 7.11) * 3.0, 2.5) + 0.05;\n\t\t\t\t\t\n\t\tvec3 passColor = LensHighlight(pos,lpos,col,flareSize,flareInterval,i); \n\n\t\tpassColor *= lensFlareBrightness / (i_f * 1.15);\n\t\tflareColor += passColor;\n\t\tloopVal /= proximity_divisor;\n\t\ti++;\n\t}\n\n\treturn flareColor;\n}\nfloat scaleDepth(float depth)\n{// Intended to map values in range d = (0,1] to range (1,0] to rolloff values by distance.\n\treturn exp(-abs(depth * lensFlareFade * 0.01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Get screen space pixel position. Note that in view space, camera is at vec3(0).\n\tvec3 uv = vec3(fragCoord/iResolution.xy,0)-0.5;\n\tuv.x *= iResolution.x/iResolution.y; // aspect correct\n    \n\t// Get screen space light position.\n    vec3 lightPosition = 0.25*(vec3(cos(iTime),sin(iTime),-0.1) - 0.5);//hardcoded for shader\n\tvec3 lightPos = lightPosition;\n    //vec3 lightPos = modelToScreen(lightPosition3D)-0.5; <== implementation for world space light pos\t\n    lightPos.x *= iResolution.x/iResolution.y; // aspect correct\n\n\tfloat distToLight = length(lightPosition - cameraPosition);\n\n\t// Bail early conditions.\n\tif(lensFlareScale <= 0.000001 || distToLight <= 0.00001)\n\t\treturn;\n\n\t// Calculate lens flare effect.\n\tfloat depthFade = scaleDepth(distToLight);\n\tvec3 color = Lensflare(uv.xy, lightPos.xy, distToLight);\n\t\n\t// Post-process, scaling strength by distance of observer to light source.\n\tcolor *= depthFade;//Adjust lens flare for camera distance to light.\n\tcolor = vec3(1.0) - exp(-color.rgb * lensFlareExposure * depthFade);// exposure tone mapping\n\tcolor = max(color, 0.0);//remove negative values\n\n    // Add faked light source.\n    float uvDistToLight = length(uv.xy - lightPos.xy);\n    float lightsrc = clamp(1.0-uvDistToLight*7.0, 0.0, 1.0);\n    \n    // Add rays from light source -- a rough approximation of volumetric light rays.\n    float ray_factor = 1.00;\n    float a = ray_factor * atan(uv.y-lightPos.y, uv.x-lightPos.x);\n    lightsrc += max(0.1/pow(length(uvDistToLight)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    lightsrc += max(0.1/pow(length(uvDistToLight)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    float lightsrc_attenuation = depthFade * (1.0-uvDistToLight*uvDistToLight) * 1.0;\n    color += lightsrc * lightsrc_attenuation;\n\n    // Output final color.\n\tfloat alpha = depthFade*(color.r + color.g + color.b) / 3.0f; //optional alpha blending.\n\tfragColor = vec4(color.rgb, alpha);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[714, 714, 741, 784, 915], [916, 916, 935, 1005, 1049], [1051, 1051, 1087, 1156, 1294], [1296, 1296, 1390, 1390, 1572], [1574, 1574, 1666, 1666, 1855], [1857, 1857, 1920, 1920, 2079], [2081, 2081, 2190, 2190, 2453], [2455, 2455, 2525, 2573, 2974], [2976, 3326, 3414, 3511, 4966], [4968, 5202, 5266, 5266, 6160], [6161, 6161, 6192, 6282, 6333], [6335, 6335, 6392, 6477, 8339]], "test": "untested"}
{"id": "ttGBDh", "name": "audioreactif test", "author": "gourki", "description": "test how it work", "tags": ["audioreactivetest"], "likes": 2, "viewed": 261, "published": 3, "date": "1614246198", "time_retrieved": "2024-07-30T19:36:04.816243", "image_code": "// swizzling\n// p.rgb = p.gbr\n// monvecteur.xyz = monvecteur.yzx\n\n//vec2 epsilon = vec2(0.001,0.);\n//vec3 epsilon_3 = vec3(0.1,0.,0.) > vec3 epsilon_3 = epsilon.xyy\n\n// normal calculation\n// vec3(SDF(p-epsilon.xyy),(SDF(p_epsilon.yxy), SDF(p-epsilon.yyx))\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centered_uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    centered_uv = abs(centered_uv*sin(iTime)*cos(iTime));\n    \n    vec4 fft = texture(iChannel0, vec2(centered_uv.x*sin(iTime)*0.2+centered_uv.y*cos(iTime)*0.2,0.25 ) );\n    \n    fft = vec4( smoothstep(0.5,0.8,fft) );\n    \n    vec3 color = fft.x * vec3(abs(sin(iTime/2.)),abs(cos(iTime)),abs(tan(iTime)));\n    \n    fragColor = vec4(color,1.);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 316, 366, 819]], "test": "untested"}
{"id": "3tyBD1", "name": "Abstract gem pattern", "author": "jarble", "description": "This fractal formula makes an unusual \"gem\" pattern.", "tags": ["fractal", "frost"], "likes": 2, "viewed": 246, "published": 3, "date": "1614226795", "time_retrieved": "2024-07-30T19:36:05.593166", "image_code": "\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 fract1(vec2 a,vec2 random){\n    return (abs(fract(a*2.0+100.0*random)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    float t2=iTime/20.0;\n    float t3 = 1.5;\n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0*t3;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0*t3;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 1.7;\n        //uv = fract(uv/scale);\n        \n        //vec3 random = vec3(sin(t2/13.0),sin(t2/17.0),sin(t2/19.0))/2.0+.5;\n        vec3 random = hash31(floor(iTime/5.0));\n        \n        for(int i=0;i<6;i++)\n        {\n            uv = fract1(uv/scale1,random.xy)+fract1(uv/scale*1.5,random.xy);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(-uv/(2.5+(-fract(uv.x+uv.y)))+(uv.yx/(2.0))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n\n            uv=uv.yx+col.x;\n            uv.y *= -1.0;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 312], [314, 314, 346, 346, 396], [398, 398, 455, 455, 1445]], "test": "untested"}
{"id": "WlGBD1", "name": "Arno river ♫", "author": "TheNosiriN", "description": "Inspired by reinder's Venice shader: https://www.shadertoy.com/view/MdXGW2\nAnd Kendall Miles' amazing track: Lost in florence.\nlook in common tab for settings.\ntry clicking", "tags": ["reflection", "music", "blur", "light", "dof", "audio", "bloom", "city", "river", "bridge", "buildings"], "likes": 38, "viewed": 1128, "published": 3, "date": "1614226391", "time_retrieved": "2024-07-30T19:36:06.551603", "image_code": "//Made by: TheNosiriN\n//Move the camera with the mouse\n//Look in \"Common\" tab for define settings\n//When it compiles restart the timer so the song starts with the shader\n\n//dont mind the horrible buildings in the distance ._.\n\n\n\nvec3 bloomQuery(vec2 coord){\n    vec4 col = texture(iChannel0, coord);\n    if (col.a == EPSILON){ return col.rgb; }\n    return vec3(0);\n}\n\nvec3 bloom(vec2 uv, vec4 inColor)\n{\n\tfloat numSamples = 1.0;\n    vec3 color = inColor.rgb;\n\n\tfor (float x=-2.0; x<=2.0; x++){\n\t\tfor (float y=-2.0; y<=2.0; y++)\n\t\t{\n\t\t\tvec2 uv2 = uv + (vec2(x, y) * (1./iResolution.xy));\n            color += bloomQuery(uv2);\n            numSamples++;\n\t\t}\n\t}\n    \n\treturn saturate(color / numSamples + inColor.rgb);\n}\n\n\n\n\nfloat Gaussian (float x, float sigma){\n    return exp(-(x*x) / (2.0 * sigma*sigma));\n}\n\nvec3 blur(in vec2 uv, float size, float sigma, bool query)\n{\n    float total = 0.0;\n    vec3 ret = vec3(0);\n    \n    for (float iy=0.0; iy<size; iy++)\n    {\n        float fy = Gaussian(iy-size/2.0, sigma);\n        float ofy = (iy-size/2.0) * (1./iResolution.y);\n        \n        for (float ix=0.0; ix<size; ix++)\n        {\n            float fx = Gaussian(ix-size/2.0, sigma);\n            float ofx = (ix-size/2.0) * (1./iResolution.x);\n            \n            float f = fx*fy;\n            total += f;\n            if (query){\n                ret += bloomQuery(uv + vec2(ofx, ofy)).rgb * f;\n            }else{\n                ret += texture(iChannel0, uv + vec2(ofx, ofy)).rgb * f;\n            }\n        }\n    }\n    return ret / total;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    \n    vec4 tex = texture(iChannel0, uv);\n    \n    #ifdef POSTPROCESS\n    if (tex.a != 0.0){\n        #ifdef SOFTER\n            float dist = saturate(pow(abs((tex.a*2.0-1.0)+0.7), 0.8));\n            color = mix(bloom(uv,tex), blur(uv,16.0,40.0,false), dist);\n        #else\n            color = mix(bloom(uv,tex), blur(uv,16.0,40.0,false), saturate(tex.a*2.0-0.3));\n        #endif\n    }else{\n        color.rgb = tex.rgb;\n    }\n    #else\n    color = tex.rgb;\n    #endif\n    \n    color *= 0.2 + 0.9*pow(32.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2);\n    color *= min(1.0, iTime/7.0); //fade in\n    //color *= saturate((92.0-iTime)/7.0); //fade out in 92 sec\n    \n\tfragColor = vec4(vec3(color), tex.a);\n  \n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25547, "src": "https://soundcloud.com/darius-bailey-667130523/kendall-miles-x-i-eat-plants-for-a-living-lost-in-florence", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "\nvec4 building(vec3 p, vec2 wh, vec2 roof, float scale)\n{\n    p.y -= wh.y;\n    p /= scale;\n    \n    vec3 ap = abs(p);\n    vec3 q = ap - vec3(wh, wh.x);\n    vec2 d = vec2(mv3(q), 0);\n    \n    p.xz = abs(p.xz);\n    \n    //roof\n    float rf = MAX_DIST; roof.y /= wh.x;\n    vec3 rp = p-vec3(0,wh.y+roof.y,0); rp.xz *= roof.y;\n    if (roof.x == 0.0){\n        rf = max(max(mv2(p.xz)-wh.x, mv2(rp.xz)+rp.y), -rp.y-roof.y)-wh.x/5.0;\n    }else if(roof.x == 1.0){\n        float rfn = abs(rp.x)+rp.y; rf = max(-rfn, rfn-wh.x/5.0);\n        rf = max(rf, mv2(p.xz)-wh.x*1.25);\n        rf = min(rf, max(rfn, mv2(p.xz)-wh.x));\n    }\n    d.x = min(rf, d.x);\n    \n    //windows\n    vec2 wp = p.xy;\n    float wl = 0.2, ww = 0.15;\n    float v = pModInterval1(wp.x, ww*4.0, -floor(wh.x), floor(wh.x))+floor(wh.x);\n    float c = pModInterval1(wp.y, 1.0, -floor(wh.y)+1., floor(wh.y)-1.)+floor(wh.y);\n    float wd = min(length(wp.xy)-ww, max(abs(wp.x)-ww, abs(wp.y+wl)-wl));\n    //wd = max(wd, abs(p.z-wh.x)-0.1);\n    \n    d = maxd(d, vec2(-wd, 2));\n    \n    return vec4(d, v, c);\n}\n\n\nvec3 scene(vec3 p, float depth, float maxdist){\n    vec3 d = vec3(0);\n    p.xz *= rotate(remap(p.z, 0.0, 100.0, 0.0, 45.0));\n    setpz(p);\n    //p.x = abs(p.x);//-10.0;\n    \n    \n    //river side\n    d.x = max(p.y-1.0, -abs(p.x)+15.);\n    d.x = min(d.x, max(abs(p.y-0.8)-0.2, -abs(p.x)+14.5));\n    vec3 rp = p;\n    \n    \n    //buildings\n    p.x += 20.0; p.y-=0.5;\n    vec3 brp = p;\n    vec2 bdim = vec2(1), rdim = vec2(1);\n    vec2 c = vec2(-pModInterval1(p.x, 4.0, -20.0, 0.0), 0);\n    c.y = pMod1(p.z, c.x+3.5);\n    \n    vec4 rand = iHash(c);\n    \n    rdim.y = rand.w*1.5;\n    rdim.x = round(rand.z);\n    bdim.x = remap(round(rand.x),0.,1.,1.,1.5);\n    bdim.y = remap(round(rand.y),0.,1.,1.,2.+c.x*0.3);\n    \n    vec4 bu = building(p.zyx, bdim, rdim, 1.0);\n    vec2 b = bu.xy;\n    if (b.y == 2.0){\n        b.y = iHash(bu.zw+bu.wz+c).x > 0.2 ? 2. : 0.;\n    }\n    \n    /* cant get it working\n    vec2 neighbor = c+face(p).xy*vec2(4.0, c.x+3.2);\n    float ne = length(p+vec3(neighbor.x,0,neighbor.y))-bdim.x;\n    b.x = min(b.x, ne);\n    */\n    \n    //the buildings have a very horrible stepping problem\n    //this doesnt remove everything but its not as noticeable\n    b.x *= remap(depth,0.0,maxdist,0.5,0.1);\n    //\n    d = mind(d, vec3(b.x,b.y, 0));\n    \n    \n    //riverside cont.\n    vec3 rvs = vec3(length(p.yz+vec2(1.5,0))-1.5, 0,0);\n    d = maxd(d, -rvs);\n    \n    //bridge\n    vec3 bp = rp; float space = 80.0;\n    float cf = pMod1(bp.z, space);\n    float shape = abs(bp.z)-space/2.+2.0;\n    rvs.x = max(length(bp.xy*vec2(0.2,1))-2.8, -shape);\n    rvs.x = min(rvs.x, max(max(rvs.x-0.25, -shape), shape-0.5));\n    cf = abs(pMod1(rp.x, 3.0));\n    \n    float bh = 1.2-(cf*0.4); float bw = 1.1;\n    float edge = min(length(rp.xy-vec2(0,bh))-bw, max(abs(rp.x)-bw,rp.y-bh));\n    rvs.x = min(rvs.x, max(edge-0.25, -abs(bp.z)+space/2.-2.2));\n    rvs = maxd(rvs, vec3(-edge,3,0));\n    \n    //doing mod again for the bridge inside thingys\n    //bp = rp;\n    cf = pMod1(bp.z, 1.25);\n    \n    #ifdef YELLOW_BRIDGE\n    rvs = maxd(rvs, vec3(-max(edge-0.25, abs(bp.z)-0.2),2,0));\n    #else\n    rvs = maxd(rvs, vec3(-max(edge-0.25, abs(bp.z)-0.2),3,0));\n    #endif\n    \n    \n    d = mind(d, rvs);\n    \n    \n    //water\n    return mind(d, vec3(p.y+1.,1,0));\n}\n\n\n\nvec4 raymarch(vec3 eye, vec3 dir, float maxdist)\n{\n    vec3 info = vec3(0);\n    float depth = 0.0, i;\n    for (i=0.0; i<256.0 && depth<maxdist; i++){\n        vec3 p = eye + depth * dir;\n        info = scene(p, depth, maxdist);\n        if (abs(info.x) < EPSILON * depth)break;\n        depth += info.x;\n    }\n    return vec4(min(depth,maxdist), info.yz, i/256.0);\n}\n\n\n\nvec3 normal(vec3 p, float depth, float maxdist)\n{\n \tvec3 P = vec3(-4, 4, 0) * 0.001;\n \treturn normalize(\n        scene(p+P.xyy, depth, maxdist).x * \n        P.xyy + scene(p+P.yxy, depth, maxdist).x * \n        P.yxy + scene(p+P.yyx, depth, maxdist).x * \n        P.yyx + scene(p+P.xxx, depth, maxdist).x * \n        P.xxx\n    );\n}\n\n\n\n\n\n\nvec4 makePixel(vec3 eye, vec3 dir, vec4 dist, vec3 P, vec3 N, int bounce)\n{\n    vec4 color;\n    \n    setpz(P);\n    if (dist.y == 3.0){ N = triplanarNormal(iChannel1, P, N, 1.0, 2.0, 1.0); }\n    \n    float shading = saturate(dot(N, light)*0.5+0.25);\n    shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n\n    color.x = (shading+0.1)+(dist.x/MAX_DIST)*0.1;\n    \n    if (bounce == 0){\n        color.y = 1.0-saturate(pow(dist.w,1.)*4.0);\n    }else{\n        color.y = saturate(pow(dist.w,3.0)*3.0);\n    }\n    //color.y = saturate(pow(dist.w,1.)*4.0);\n    \n    if (dist.y == 2.0){ color.xyz = vec3(0,0,1); }\n    color.a = saturate(dist.x/MAX_DIST);\n    \n    return color;\n}\n\n\n\nfloat getBackground(vec3 dir){\n    //dir.y -= light.y;\n    float sun = smoothstep(0.005, -0.005, length(dir.xy-vec2(0.3,0.09))-0.05);\n    \n    return sun*0.4;\n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    vec2 uv = P/iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ O = vec4(0.0); return; }\n    #endif\n    uv = (P-iResolution.xy*0.5)/iResolution.y;\n    \n    float fv = 2.0;\n    vec3 eye = vec3(0,1.8,-10);\n    vec3 lookAt = vec3(0, 2.5, 10.0);\n    \n    if (iMouse.z>0.0){\n        fv = 2.5;\n        eye = vec3(-20.0,7.0,-30);\n        lookAt = vec3(-10.0, 5.0, 10.0);\n    }\n    \n    \n    vec3 f = normalize(lookAt - eye);\n    vec3 s = normalize(cross(f, vec3(0,1,0)));\n    mat4 view = mat4(vec4(s, 0.0), vec4(cross(s, f), 0.0), vec4(-f, 0.0), vec4(0,0,0,1));\n    vec3 dir = vec3(view * vec4(normalize(vec3(uv, -fv)), 0.0));\n    \n    dir.xy *= rotate(sin(TIME));\n    dir.yz *= rotate(sin(TIME*0.5));\n    dir.xz *= rotate(sin(TIME*0.25));\n    \n    \n    vec4 color;\n    \n    vec4 dist = raymarch(eye, dir, MAX_DIST);\n    \n    if (dist.x < MAX_DIST)\n    {\n        vec3 P = eye + dir * dist.x;\n        vec3 N = normal(P, dist.x, MAX_DIST);\n        if (dist.y == 1.0){\n            eye = P;\n            float noise = pow(sin(dir.x*1000.0)*0.5+0.5,1.)*0.02*(dist.x/MAX_DIST);\n            \n            setpz(P);\n            N = triplanarNormal(iChannel0, P, N, 0.2, 0.2, 4.0);\n            N = normalize(N+noise);\n            \n            dir = normalize(reflect(dir, N));\n            dist = raymarch(eye, dir, MAX_DIST/2.0);\n            \n            if (dist.x < MAX_DIST/2.0){\n                P = eye + dir * dist.x;\n                N = normal(P, dist.x, MAX_DIST/2.0);\n                color = makePixel(eye, dir, dist, P, N, 1);\n            }else{\n                color.z = 0.5;\n                color.x = getBackground(dir);\n            }\n            color.x *= 0.5;\n        }else{\n            color = makePixel(eye, dir, dist, P, N, 0);\n        }\n    }else{\n        color.z = 0.5;\n        color.x = getBackground(dir);\n    }\n    \n\n    // Output to screen\n    O = color;\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MARGIN //for just a bit more fps\n#define YELLOW_BRIDGE //how does it look?\n#define SOFTER //I cant decide between soft and softer\n#define POSTPROCESS //comment this if you have a really bad pc\n//for color switching over the song, its not perfectly in synch but it looks nice\n#define SWITCH_COLORS\n//\n\n\nconst float marginSize = 0.08; //letterbox size\n\nconst vec3 light = normalize(vec3(1.0, 0.25, 1.0));\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst float PI = 3.1415972;\nconst mat2 M2 = mat2(0.8,-0.6,0.6,0.8);\n\n\n\n#define TIME (iTime+40.0)\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define setpz(p) (p.z += TIME + (iMouse.z>0.0 ? iMouse.x/iResolution.x*80.0 : 0.0))\n//my attempt at synching audio\n#define SUNTIME saturate(sin((iTime-9.0)*0.75)*3.0)\n//\n\n\n\nfloat mv2(vec2 v){ return max(v.x, v.y); }\nfloat mv3(vec3 v){ return max(v.x, max(v.z, v.y)); }\n//float hash21(vec2 p){ return fract(sin(dot(p, p+5373.836))*9272.8363); }\n\n// simple 4 channel Hash by: James_Harnett, https://www.shadertoy.com/view/4dVBzz\nvec4 iHash(vec2 c){\n    uvec2 uc = uvec2(abs(c));\n    uint n = uint(uc.x*1597334677U^uc.y*3812015801U);\n    return vec4( (n*(n^(n>>15)))*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU) ) * 1.0/float(0xffffffffU);\n}\n\n\n\nmat2 rotate(float angle){\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 face(vec3 p){\n    vec3 ap = abs(p);\n    float mx = mv3(ap);\n    return step(0., ap-mx)*sign(p);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) {\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale, float lod)\n{\n    p *= scale;\n    \n    return  (textureLod(tex,p.xy,lod).rgb*n.z*n.z\n            +textureLod(tex,p.zy,lod).rgb*n.x*n.x\n            +textureLod(tex,p.xz,lod).rgb*n.y*n.y);\n}\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale, float lod)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B;\n    B.x = triplanarMap(tex, p+P.xzz, N, scale, lod).r;\n    B.y = triplanarMap(tex, p+P.zxz, N, scale, lod).r;\n    B.z = triplanarMap(tex, p+P.zzx, N, scale, lod).r;\n    B -= triplanarMap(tex, p, N, scale, lod).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n\n\n\nfloat remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}\n", "buffer_b_code": "\nconst vec3 day1 = vec3(0.671,0.216,0.341);\nconst vec3 day2 = vec3(0.984,0.388,0.043);\nconst vec3 day3 = vec3(0.490,0.478,0.635);\n\nconst vec3 night1 = vec3(0.157,0.059,0.212);\nconst vec3 night2 = vec3(0.784,0.420,0.596);\nconst vec3 night3 = vec3(1.000,0.757,0.627);\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51; float b = 0.03;\n    float c = 2.43; float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec4 cheapAA(sampler2D tex, vec2 fragCoord, float blur)\n{\n\tvec4 pixelColor;\n\tpixelColor =  texture(tex, (fragCoord + vec2( 0.0, 0.0)) / iResolution.xy).rgba / 2.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur, blur)) / iResolution.xy).rgba / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur,-blur)) / iResolution.xy).rgba / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur,-blur)) / iResolution.xy).rgba / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur, blur)) / iResolution.xy).rgba / 8.0;\n\treturn pixelColor;\n}\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    vec3 color;\n    vec2 uv = P/iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ O = vec4(0.0); return; }\n    #endif\n    \n    vec3 col;\n    vec4 rtex = texture(iChannel0, uv);\n    \n    #ifdef SWITCH_COLORS\n    float suntime = SUNTIME;\n    vec3 sky1 = mix((day1+night1)/3.0, night1, suntime);\n    vec3 sky2 = mix(day2, night2, suntime);\n    vec3 sky3 = mix(day3, night3, suntime);\n    #else\n    vec3 sky1 = night1;\n    vec3 sky2 = night2;\n    vec3 sky3 = night3;\n    #endif\n    \n    if (rtex.z == 1.0){\n        color = vec3(1,1,0);\n        rtex.a = EPSILON;\n    }else{\n        vec4 tex = cheapAA(iChannel0, P, 0.5);\n        \n        vec3 sky = mix(sky2, sky1, abs(uv.y*2.0-1.0)+0.2);\n\n        if (rtex.z == 0.5){\n            color = mix(sky2+rtex.r, sky1, abs(uv.y*2.0-1.0)+0.2);//+tex.x;\n        }else{\n            color = mix(sky1, sky2, tex.a);\n            color = mix(color, mix(tex.r*sky3, sky, tex.a), tex.y);\n        }\n        \n        \n    }\n    \n    color = smoothstep(0.0,1.0,color);\n    color = ACESFilm(color);\n    O = vec4(color,rtex.a);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 257, 257, 366], [368, 368, 403, 403, 716], [721, 721, 759, 759, 807], [809, 809, 869, 869, 1545], [1550, 1550, 1607, 1607, 2489]], "test": "untested"}
{"id": "3lGBD1", "name": "Distance Propagation", "author": "oneshade", "description": "First try at making an algorithm that calculates the distance to a bitmap. I originally considered some sort of pixel search but later thought a cellular automaton would be faster. The distances are NOT exact but seem pretty decent (except on interiors).", "tags": ["2d", "sdf", "bitmap", "cellular", "ca", "cellularautomata", "propagation"], "likes": 4, "viewed": 203, "published": 3, "date": "1614226327", "time_retrieved": "2024-07-30T19:36:07.324537", "image_code": "// You can test the distance field by moving the mouse around\nfloat getDistance(in vec2 p) {\n    return texture(iChannel0, p / iResolution.xy).x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy * vec2(0.5, 2.0));\n    fragColor.rgb -= getDistance(fragCoord) / 50.0;\n\n    fragColor.rgb += (0.25 + 0.25 * sin(getDistance(fragCoord))) * (1.0 - fragColor.a);\n\n    float bcircle = abs(length(fragCoord - iMouse.xy) - getDistance(iMouse.xy)) - 1.0;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 1.0), smoothstep(1.0, 0.0, bcircle));\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nThe idea is that each cell carries a piece of distance information that gets passed\nalong from cell to cell. The outline of the algorithm is extremely simple:\n1. If the current cell is filled, ignore it but retain its distance.\n2. If any neighboring cell is filled, update the current cell's distance to the\n   minimum of its distance and the distance of the neighboring cell plus the\n   distance between both cells.\n*/\n\n#define textureLoaded(s) (textureSize(s, 0).x > 1) // https://www.shadertoy.com/view/wldGW8\n#define bufferResized() ivec2(iResolution.xy) != ivec2(texelFetch(iChannel1, ivec2(0), 0).xy)\n#define SQRT_2 sqrt(2.0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame > 0 && textureLoaded(iChannel1)) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n\n        // Only update if the current cell has not been filled\n        if (fragColor.y < 0.5) {\n            float closest;\n            bool foundCandid = false; // Flags whether a first candidate for the shortest distance has been found\n\n            // Loop over neighboring cells\n            for (int i=-1; i < 2; i++) {\n                for (int j=-1; j < 2; j++) {\n\n                    // Ignore the center (current) cell\n                    if (!(i == 0 && j == 0)) {\n                        vec2 cell = texelFetch(iChannel0, iFragCoord + ivec2(i, j), 0).xy;\n                        if (cell.y > 0.5) {\n                            // The distance is 1 if the cell is on an edge and sqrt(2) if it is on a corner\n                            float dist = (i == 0 || j == 0) ? cell.x + 1.0 : cell.x + SQRT_2;\n                            closest = !foundCandid ? dist : min(closest, dist);\n\n                            // Cells on the edges are always the closest so we might be able to break out early\n                            if (i == 0 || j == 0) break;\n\n                            foundCandid = true;\n                        }\n\n                        // Update filled status of the current cell\n                        fragColor.y = max(fragColor.y, cell.y);\n                    }\n                }\n            }\n\n            // Store closest distance if one has been found\n            if (foundCandid) fragColor.x = closest;\n        }\n    }\n\n    if (iFrame == 0 || bufferResized() || !textureLoaded(iChannel1)) {\n        // Scale texture and read from the alpha (opacity) channel\n        fragColor.x = 0.0;\n        fragColor.y = round(texture(iChannel2, fragCoord / iResolution.xy * vec2(0.5, 2.0)).w);\n    }\n}", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(iChannelResolution[0].xy, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 92, 92, 147], [149, 149, 204, 204, 608]], "test": "untested"}
{"id": "WtGfW1", "name": "Fast implicit random walk 2", "author": "ttg", "description": "Animation of https://www.shadertoy.com/view/WtGfDh", "tags": ["random", "brownian"], "likes": 5, "viewed": 378, "published": 3, "date": "1614223601", "time_retrieved": "2024-07-30T19:36:08.120409", "image_code": "/*\n\nFast implicit random walk 2\nCreated by Theron Tarigo, 2021\nhttps://www.shadertoy.com/view/WtGfW1\n\nRandom walk (brownian motion) implies integration to know particle position as\na function of time, but a recursive solution can provide a qualitatively and\nstatistically equivalent result.\n\nAnimation of https://www.shadertoy.com/view/WtGfDh\n\n*/\n\nvec2 randwalk_dumb (int i, uint seed) {\n  vec2 x = vec2(0.);\n  for (int j=0; j<i; j++) {\n    x+= rnd2_gaussian(uint(j)+0xda6cu*seed);\n  }\n  return x;\n}\n\nvec2 randwalk_fast (int i, uint seed) {\n  vec2 x = vec2(0.);\n  for (int j=1; j<20; j++) {\n    uint n = uint(i)>>j;\n    uint k = uint(i)-(uint(n)<<j);\n    float l = 1.-abs(1.-float(k)*exp2(-float(j))*2.);\n    x+=rnd2_gaussian(((2u*n+1u)<<(j-1))+0xda6cu*seed)*l*exp2(.5*float(j)-1.);\n  }\n  return x;\n}\n\nvoid mainImage( out vec4 fd, in vec2 fc ) {\n\n  fd = vec4(0.);\n\n  vec3 col = vec3(0.);\n\n  float R = iResolution.y * .01;\n  vec2 uv = (2.*fc - iResolution.xy) / R;\n  \n  for (uint seed=0u; seed<64u; seed++) {\n    vec2 p = randwalk_fast(iFrame,seed);\n    col+=max(0., (1.-length(p-uv))*R);\n  }\n\n  // Convert to Gamma=2.2 and output to screen\n  fd.rgb = pow(col, vec3(1./2.2));\n}\n", "image_inputs": [], "common_code": "\n//////  COMPLEX ARITHMETIC  ///////////////////////////////////////////////////\nconst float pi = 3.1415927;\nvec2 compmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 compsin(float x){return vec2(cos(x),sin(x));}\nvec2 compinv(vec2 a){return vec2(1,-1)*a/dot(a,a);}\nfloat comparg(vec2 a){return atan(a.y,a.x);}\nvec2 comppow(vec2 a, float n){return compsin(comparg(a)*n)*pow(dot(a,a),n/2.);}\nvec2 compconj(vec2 a){return vec2(a.x,-a.y);}\n\nvec4 compmul(vec4 a, vec2 b){return vec4(compmul(a.xy,b),compmul(a.zw,b));}\n\n// https://www.shadertoy.com/view/WttXWX\n// --- triple32 from Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec2 rnd2_gaussian(uint seed) {\n  uint r = triple32(seed);\n  uvec2 r2 = (uvec2(r)>>uvec2(0,16))&0xFFFFu;\n  vec2 U = vec2(r2+1u)/float(0x10000u);\n  U = sqrt(abs(2.*log(U.x)))*compsin(2.*pi*U.y);\n  return U;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 387, 387, 499], [501, 501, 540, 540, 800], [802, 802, 845, 845, 1176]], "test": "untested"}
{"id": "WtGfDh", "name": "Fast implicit random walk", "author": "ttg", "description": "Random walk (brownian motion) implies integration to know particle position as a function of time, but a recursive solution can provide a qualitatively and statistically equivalent result.\n\nFull description in source.\n\nMouse control.", "tags": ["random", "brownian"], "likes": 4, "viewed": 389, "published": 3, "date": "1614222741", "time_retrieved": "2024-07-30T19:36:09.003049", "image_code": "/*\n\nFast implicit random walk\nCreated by Theron Tarigo, 2021\nhttps://www.shadertoy.com/view/WtGfDh\n\nRandom walk (brownian motion) implies integration to know particle position as\na function of time, but a recursive solution can provide a qualitatively and\nstatistically equivalent result.\n\nComparison:\n  Top: simple integration (slow)\n  Bottom: optimized solution\n\nMouse x to change seeds.\n\n*/\n\nfloat randwalk_dumb (int i, uint seed) {\n  float x = 0.;\n  for (int j=0; j<i; j++) {\n    x+= rnd2_gaussian(uint(j)+0xda6cu*seed).x;\n  }\n  return x;\n}\n\nfloat randwalk_fast (int i, uint seed) {\n  float x = 0.;\n  for (int j=1; j<20; j++) {\n    uint n = uint(i)>>j;\n    uint k = uint(i)-(uint(n)<<j);\n    float l = 1.-abs(1.-float(k)*exp2(-float(j))*2.);\n    x+=rnd2_gaussian(((2u*n+1u)<<(j-1))+0xda6cu*seed).x*l*exp2(.5*float(j)-1.);\n  }\n  return x;\n}\n\nvoid mainImage( out vec4 fd, in vec2 fc ) {\n\n  fd = vec4(0.);\n\n  vec3 col = vec3(0.);\n\n  vec2 uv = fc/iResolution.xy;\n  \n  uint s = uint(iMouse.x);\n  \n  // top\n  PLOT_CONTINUOUS(col, uv, mat2(0,.5,1,.5), mat2(0,-1,800,1),\n    vec3(1), 1, 1, 1., randwalk_dumb(int(x), s+128u)/100.);\n\n  // bottom\n  PLOT_CONTINUOUS(col, uv, mat2(0,0,1,.5), mat2(0,-1,800,1),\n    vec3(1), 1, 1, 1., randwalk_fast(int(x), s)/100.);\n  \n#if 0 // (visually) compare statistics\n  uint seed = uint(fc.x)+uint(iResolution.x*round(fc.y));\n  int n = 37*int(1.+fc.y/iResolution.y*8.);\n  float r = randwalk_fast(n, seed);\n  if (uv.x>.5) r = randwalk_dumb(n, seed);\n  col = vec3(r*r*.0003);\n#endif\n\n  // Convert to Gamma=2.2 and output to screen\n  fd.rgb = pow(col, vec3(1./2.2));\n}\n", "image_inputs": [], "common_code": "\n//////  COMPLEX ARITHMETIC  ///////////////////////////////////////////////////\nconst float pi = 3.1415927;\nvec2 compmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 compsin(float x){return vec2(cos(x),sin(x));}\nvec2 compinv(vec2 a){return vec2(1,-1)*a/dot(a,a);}\nfloat comparg(vec2 a){return atan(a.y,a.x);}\nvec2 comppow(vec2 a, float n){return compsin(comparg(a)*n)*pow(dot(a,a),n/2.);}\nvec2 compconj(vec2 a){return vec2(a.x,-a.y);}\n\nvec4 compmul(vec4 a, vec2 b){return vec4(compmul(a.xy,b),compmul(a.zw,b));}\n\n// https://www.shadertoy.com/view/WttXWX\n// --- triple32 from Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec2 rnd2_gaussian(uint seed) {\n  uint r = triple32(seed);\n  uvec2 r2 = (uvec2(r)>>uvec2(0,16))&0xFFFFu;\n  vec2 U = vec2(r2+1u)/float(0x10000u);\n  U = sqrt(abs(2.*log(U.x)))*compsin(2.*pi*U.y);\n  return U;\n}\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 395, 435, 435, 544], [546, 546, 586, 586, 843], [845, 845, 888, 888, 1595]], "test": "untested"}
{"id": "tltBDX", "name": "Psychedelic tapestry", "author": "jarble", "description": "This fractal looks like some kind of psychedelic vision.", "tags": ["fractal", "frost"], "likes": 5, "viewed": 296, "published": 3, "date": "1614214694", "time_retrieved": "2024-07-30T19:36:09.767006", "image_code": "\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    //from David Hoskins' \"Hash without Sine\"\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a*2.0+10.0*hash21(floor(iTime/5.0)))-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n        t = iTime+float(c)/10.;\n        float scale = 4.0;\n        float scale1 = 1.7;\n        //uv = fract(uv/scale);\n        \n        for(int i=0;i<9;i++)\n        {\n            uv = fract1(uv/scale1)+fract1(uv/scale/2.0);\n            //scale *= 1.0+fract((uv.x+uv.y)/50.0)/1000.0;\n            uv=fract(-uv/(2.5+(-fract(uv.x+uv.y)))+(uv.yx/(2.0))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n\n            uv=uv.yx+col.xy;\n            //col = fract(col.yzx);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 111, 133, 179, 308], [310, 310, 330, 330, 397], [399, 399, 456, 456, 1221]], "test": "untested"}
{"id": "wlKfDR", "name": "3D Feedback Particles", "author": "oneshade", "description": "Bouncy particle simulation in 3D! (with feedback effects and cheap hacky smoothing)", "tags": ["3d", "raymarching", "particles", "bouncy", "buffering"], "likes": 13, "viewed": 214, "published": 3, "date": "1614209817", "time_retrieved": "2024-07-30T19:36:10.559886", "image_code": "// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\n#define fetch(p) texelFetch(iChannel0, ivec2(_322(p, SIZE, RESOLUTION, iChannelResolution[0].xy)), 0)\nvec4 sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        vec3 sp = mod(p + halfSize, SIZE) - halfSize;\n        if (filt == 0) {\n            return fetch(sp);\n        }\n\n        else {\n            vec3 UNIT = SIZE / RESOLUTION;\n            vec3 cell = floor(sp / UNIT) * UNIT;\n            vec3 local = fract(sp / UNIT);\n\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            // Sample at cell corners (8 tap)\n            vec4 ldb = fetch(cell);\n            vec4 rdb = fetch(cell + vec3(UNIT.x, 0.0, 0.0));\n            vec4 lub = fetch(cell + vec3(0.0, UNIT.y, 0.0));\n            vec4 rub = fetch(cell + vec3(UNIT.xy, 0.0));\n            vec4 ldf = fetch(cell + vec3(0.0, 0.0, UNIT.z));\n            vec4 rdf = fetch(cell + vec3(UNIT.x, 0.0, UNIT.z));\n            vec4 luf = fetch(cell + vec3(0.0, UNIT.yz));\n            vec4 ruf = fetch(cell + UNIT);\n\n            // Interpolate\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.25;\n    float bbox = max(q.x, max(q.y, q.z));\n    return vec4(0.0, 0.0, 0.0, bbox);\n}\n\nvec4 mapScene(in vec3 p) {\n    float env = mapEmptyEnvironment(p);\n    vec4 balls = sampleDistanceField(p, 1);\n    return env < balls.w ? vec4(0.6, 0.3, 0.0, env) : balls;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.05, 0.0, 0.0); // Hacky smoothing effect\n    return normalize(vec3(mapScene(p + e.xyy).w - mapScene(p - e.xyy).w,\n                          mapScene(p + e.yxy).w - mapScene(p - e.yxy).w,\n                          mapScene(p + e.yyx).w - mapScene(p - e.yyx).w));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        vec4 d = mapScene(p);\n        if (d.w < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += d.rgb;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 8.0) {\n            break;\n        }\n\n        t += d.w;\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// RESOLUTION is the number of distance samples, SIZE is the space it maps to\n#define RESOLUTION vec3(45.0)\n#define SIZE vec3(3.5)\n\n// Simulation settings\n#define NUMBER_OF_BALLS 100\n#define BALL_RADIUS 0.08\n\n#define GRAVITY 0.001\n#define FRICTION 0.95\n\n#define INFINITY 1000000.0\n#define DELTA 0.001\n\n#define getBallPos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xyz\n#define getBallVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xyz\n\n// SDFs\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// Environment SDF\nfloat mapEmptyEnvironment(in vec3 p) {\n    float ground = sdBox(p + vec3(0.0, 1.0, 0.0), vec3(2.0, 0.1, 2.0)) - 0.1;\n\n    vec3 wp = vec3(abs(p.xz), p.y).xzy;\n    float walls = sdBox(wp - vec3(0.0, -0.5, 1.9), vec3(2.0, 0.5, 0.1));\n    walls = min(walls, sdBox(wp - vec3(1.9, -0.5, 0.0), vec3(0.1, 0.5, 2.0)));\n    walls -= 0.1;\n\n    float ball = sdSphere(p + vec3(0.5, 0.0, 0.8), 0.5);\n    float box = sdBox(p - vec3(0.25, -0.45, 0.5), vec3(0.125, 0.25, 0.5)) - 0.1;\n    return min(min(ground, walls), min(ball, box));\n}\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash13(in float x) {\n   vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Distance field sampling utilities\nvec3 _223(in vec2 p2D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p2D = floor(p2D);\n    float p1D = p2D.y * res2D.x + p2D.x;\n    float x = mod(p1D, res3D.x);\n    float y = mod(p1D - x, res3D.x * res3D.y) / res3D.x;\n    float z = (p1D - x - y * res3D.x) / res3D.x / res3D.y;\n    return vec3(x, y, z) / res3D * size3D - 0.5 * size3D;\n}\n\nvec2 _322(in vec3 p3D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p3D = floor(p3D / size3D * res3D + 0.5 * res3D);\n    float p1D = p3D.z * res3D.x * res3D.y + p3D.y * res3D.x + p3D.x;\n    float x = mod(p1D, res2D.x);\n    float y = (p1D - x) / res2D.x;\n    return vec2(x, y);\n}", "buffer_a_code": "// Convenience struct\nstruct EnvData {\n    float distToEnv;\n    vec3 colliderVel;\n    int colliderType;\n};\n\n// Generates an arbitrary perpendicular vector\nvec3 getPerpVec3(in vec3 v) {\n    vec3 perp = vec3(-v.y, v.x, 0.0), a = abs(v);\n    if (a.x <= a.y && a.x <= a.z) perp = vec3(0.0, -v.z, v.y);\n    if (a.y < a.x && a.y < a.z) perp = vec3(-v.z, 0.0, v.x);\n    return perp;\n}\n\n// Gets information about the environment\nEnvData mapEnvironment(in vec3 p, in int ballID) {\n    vec3 ballPos = getBallPos(ballID);\n\n    float distToEnv = mapEmptyEnvironment(p);\n    vec3 colliderVel = vec3(0.0, 0.0, 0.0);\n    int colliderType = 0;\n\n    for (int id=0; id < NUMBER_OF_BALLS; id++) {\n        if (id != ballID) {\n            vec3 colliderPos = getBallPos(id);\n            distToEnv = min(distToEnv, length(p - colliderPos) - BALL_RADIUS);\n\n            if (length(ballPos - colliderPos) < 2.0 * BALL_RADIUS) {\n                colliderVel = getBallVel(id);\n                colliderType = 1;\n            }\n        }\n    }\n\n    return EnvData(distToEnv, colliderVel, colliderType);\n}\n\nvec3 getNormal(in vec3 p, in int id) {\n    vec2 e = vec2(DELTA, 0.0);\n    return normalize(vec3(mapEnvironment(p + e.xyy, id).distToEnv - mapEnvironment(p - e.xyy, id).distToEnv,\n                          mapEnvironment(p + e.yxy, id).distToEnv - mapEnvironment(p - e.yxy, id).distToEnv,\n                          mapEnvironment(p + e.yyx, id).distToEnv - mapEnvironment(p - e.yyx, id).distToEnv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x < NUMBER_OF_BALLS && iFragCoord.y == 0) {\n        vec3 randPos = Hash13(fragCoord.x + iDate.w) * 2.0 - 1.0;\n        fragColor = vec4(randPos, 1.0);\n    }\n\n    if (iFragCoord.x < NUMBER_OF_BALLS && iFragCoord.y == 1) {\n        vec3 randVel = Hash13(fragCoord.x * 365.748 + 478.487 + iDate.w) * 0.02 - 0.01;\n        fragColor = vec4(randVel, 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < NUMBER_OF_BALLS) {\n            vec3 ballPos = getBallPos(iFragCoord.x);\n            vec3 ballVel = getBallVel(iFragCoord.x);\n\n            // Accelerate and update\n            ballVel.y -= GRAVITY;\n            ballPos += ballVel;\n\n            EnvData envData = mapEnvironment(ballPos, iFragCoord.x);\n            if (envData.distToEnv < BALL_RADIUS) {\n                vec3 hitNormal = getNormal(ballPos, iFragCoord.x);\n                ballPos += hitNormal * (BALL_RADIUS - envData.distToEnv); // Decollide\n\n                // Bounce off other balls\n                if (envData.colliderType > 0) {\n                    vec3 perpNormal = getPerpVec3(hitNormal);\n                    vec3 ballVel2 = envData.colliderVel;\n                    ballVel = dot(ballVel2, hitNormal) * hitNormal + dot(ballVel, perpNormal) * perpNormal;\n                }\n\n                // Bounce off static objects\n                else {\n                    ballVel = reflect(ballVel, hitNormal);\n                }\n\n                ballVel *= FRICTION; // Decelerate\n            }\n\n            // Store\n            if (iFragCoord.y == 0) {\n                fragColor = vec4(ballPos, 1.0);\n            }\n\n            if (iFragCoord.y == 1) {\n                fragColor = vec4(ballVel, 1.0);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Precalulated distance field and colors\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) fragColor = vec4(0.0, 0.0, 0.0, INFINITY);\n    else fragColor = texelFetch(iChannel1, iFragCoord, 0);\n\n    float c = cos(iTime), s = sin(iTime);\n    mat2 colorRot = mat2(c, s, -s, c);\n\n    vec3 p = _223(fragCoord, SIZE, RESOLUTION, iResolution.xy);\n    for (int id=0; id < NUMBER_OF_BALLS; id++) {\n        vec3 ballPos = getBallPos(id);\n        float newShape = sdSphere(p - ballPos, BALL_RADIUS);\n        if (newShape < fragColor.w) {\n            vec3 newColor = Hash13(float(id) * 483.385 + 343.747);\n            newColor.rb *= colorRot;\n            newColor.gb *= colorRot;\n            newColor = 0.5 + 0.5 * newColor;\n\n            fragColor.rgb = newColor;\n            fragColor.w = newShape;\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 214, 214, 1458], [1460, 1460, 1486, 1486, 1633], [1635, 1635, 1662, 1662, 1946], [1948, 1948, 2003, 2003, 2978]], "test": "untested"}
{"id": "wtVfWR", "name": "Dance Till Your Toes Off", "author": "YitingLiu", "description": "The universe is no longer round. It has a flower shape but it changes with the sound in space. ", "tags": ["noise", "time", "sin", "color", "circle", "rotate", "cos", "galaxy", "distance", "radius", "pancake", "shadershop"], "likes": 0, "viewed": 393, "published": 3, "date": "1614202629", "time_retrieved": "2024-07-30T19:36:11.341795", "image_code": "// 2D Noise exercise with distance field \n\n\n#define PI 3.14159265359\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle (in vec2 _st, in float _radius, in float _size){\n    vec2 dist = _st-vec2(0.5);\n    return smoothstep(_radius-_radius*_size,_radius+_radius*_size,dot(dist,dist)*4.0) ;       \n}\n\n//shadershop function generation:http://tobyschachman.com/Shadershop/editor/\nfloat extension(in float x){\n        return ((abs( x/3. )) + floor( x / 3. / 4.22 ) + ((x / 3.)) + (fract( x / 3. ))) * 0.35;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec3 color=vec3(0.0);\n    float t = iTime*0.2;\n    float fft = texelFetch(iChannel1, ivec2(0,0),0).x;\n\n    // assign color value to the vec3 color with the extension function\n    // smoothstep to create blur effect of the middle circle \n    float colorVal = circle(fft/st/5.+.5,extension(abs(tan(iTime))),random(vec2(100.)*smoothstep(0.,PI,tan(iTime))));\n\n    st*=rotate2d(t);\n\n    colorVal *= circle(fft/st/5.+.5,extension(abs(tan(iTime))),random(vec2(100.)*smoothstep(0.,PI,tan(iTime))));\n   \n    st*=rotate2d(t+PI*2.)/2.;\n\n    colorVal /= circle(fft/st/5.+.5,extension(abs(tan(iTime))),random(vec2(100.)*smoothstep(0.,PI,tan(iTime))));\n  \n    \n    // find the center of the shortest side \n    st-=st.x*2./sin(t);\n    st = 1.-rotate2d( sin(cos(iTime))*PI*(abs(cos(iTime))/1e2+1.)) * st/abs(sin(iTime));\n    vec2 pos = vec2(st*0.756*abs(tan(iTime))*10.);\n        st+=st.x*2./sin(t);\nst+=min(st.x/2.,st.y/2.);\n\n\n    st-=st.y/sin(t);\n    st *= fft/rotate2d( PI*(fract(iTime))/1e3+fract(sin(t))) * st/(0.1+abs(sin(iTime)));\n    st *= rotate2d( PI*(cos(iTime))/1e2+1.) * st/3.280;\n    // Use the noise function with distance field \n    float n = noise(pos)*distance(st-vec2(.5)*abs(tan(t)),pos);\n    st+=st.y/sin(t);\n   //st+=min(st.y/2.,st.x/2.);\n    \n    // color manipulation based on time and shapes \n    color=texture(iChannel0,st*20.).rgb;\n\n    color+=vec3(n+fft,colorVal*abs(cos(t)),random(st-vec2(t/20.)));\n    color*=vec3(st.x/st.y*fft,colorVal*abs(cos(t))*st.y,random(st-vec2(clamp(abs(sin(t)),0.2,0.8))));\n    color-=color*colorVal*10.;\n\n\nfragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25502, "src": "https://soundcloud.com/yitingliu/dance-till-your-toes-off", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 82, 109, 109, 226], [228, 315, 341, 341, 858], [860, 860, 888, 888, 974], [976, 976, 1037, 1037, 1165], [1167, 1244, 1272, 1272, 1372], [1373, 1373, 1430, 1430, 3109]], "test": "untested"}
{"id": "wtKBDR", "name": "Marble Onion Skin", "author": "MacSlow", "description": "Quickly thrown together shader to play around with abs() to get the 'onion skin' effect (see https://iquilezles.org/articles/distfunctions/distfunctions.htm). Added a pillar and some domain repetition to not look too boring.", "tags": ["3d", "fbm", "marble", "skin", "onion", "cineshader"], "likes": 4, "viewed": 1115, "published": 3, "date": "1614201172", "time_retrieved": "2024-07-30T19:36:12.103758", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Marble Onion Skin - Trying out the 'onion effect' as stated on iq's website,\n// see https://iquilezles.org/articles/distfunctions for\n// details. The code is almost not commented at all, thus not the best example\n// to learn from.\n//\n// Copyright 2021 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smin (float d1, float d2, float k) {\n    float h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\n// hash(), noise(), fbm() are from an example by iq and/or Shane\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    mat2 m = r2d (1.1);\n\n    f  = .5*noise( p ); p.xz *= m*2.02;\n    f += .25*noise( p ); p.xy *= m*2.23;\n    f += .125*noise( p ); p.yz *= m*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\n#define PI 3.14159265\n\nfloat modPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat opSlice (float dist, float thickness) {\n\treturn abs (dist) - thickness;\n}\n\nfloat cylinderd = .0;\n\nfloat map (vec3 p, inout vec3 pout, inout int id) {\n    p.xy *= r2d (12.*cos(iTime));\n    p.xz *= r2d (45.*iTime);\n\n    vec2 cell = vec2(2.5);\n    p.xz = mod (p.xz + .5*cell, cell) - .5*cell;\n\n\tvec3 boxCutterSize = vec3 (.7, .6, .7);\n\tvec3 tmp = abs (p - vec3(.0, 2.25 + .75*(.5+.5*cos(iTime)), .0)) - boxCutterSize;\n\tfloat boxCutter = length (max (vec3 (.0), tmp)) +\n\t\t\t\t\t\t\t  min (max (tmp.x, max (tmp.y, tmp.z)), .0);\n\tfloat ball = opSlice (length (p - vec3(.0, 1.6, .0)) - .5, .1);\n\tball = opSlice (ball, .05);\n\tball = opSlice (ball, .025);\n\tball = opSlice (ball, .0125);\n\tball = max (ball, -boxCutter);\n\n    float ground = p.y + 1.;\n    vec3 size = vec3 (.7, .1, .7);\n\tfloat plate = length (max (vec3 (.0), abs (p - vec3(.0, 1., .0)) - size)) - .025;\n\n    float cyl = sdCappedCylinder (p, vec2 (.5, 1.));\n    modPolar (p.xz, 9.);\n    float cut = sdVerticalCapsule (p - vec3 (.55, -1., .0), 1.6, .1);\n\n    float d = smin (cyl, -cut, -.02);\n\tcylinderd = d;\n    d = min (d, plate);\n    d = min (d, ground);\n    d = min (d, ball);\n\n\tif (d == cyl) id = 1;\n\tif (d == plate) id = 2;\n\tif (d == ground) id = 3;\n\tif (d == ball) id = 4;\n\n    pout = p;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout vec3 pout, inout int id) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < 48; ++i) {\n        t = map (ro+d*rd, pout, id);\n        if (abs (t) < .0001*(1. + .126*t)) break;\n        d += t*.95;\n    }\n    return  d;\n}\n\nvec3 norm (vec3 p) {\n    vec3 dummy;\n\tint dummy2;\n    float d = map (p, dummy, dummy2);\n    vec2 e = vec2 (.001, .0);\n    return normalize (vec3 (map (p + e.xyy, dummy, dummy2), map (p + e.yxy, dummy, dummy2), map (p + e.yyx, dummy, dummy2))  - d);\n}\n\n// hard shadows\nfloat sha (vec3 p, vec3 n, vec3 ldir, float ldist) {\n    vec3 dummy;\n    int dummy2;\n    float d2w = march (p  + .01*n, ldir, dummy, dummy2);\n    return ldist < d2w ? 1. : .3;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 p, vec3 n, vec3 lp, vec3 lc, vec3 pout, int id) {\n    float v = fbm (30.*pout);\n    vec3 mat = mix (vec3 (.0), vec3 (1.), v);\n\tif (id == 4) mat = vec3 (1., .0, .0);\n    vec3 am = vec3 (.05);\n    vec3 ldir = normalize (lp - p);\n    vec3 h = normalize (-rd + ldir);\n\tif (id != 4) n = normalize (n + .125*vec3 (fbm (20.*pout), .0, fbm (10.*pout)));\n\tif (id == 3) {\n\t\tfloat m = smoothstep (.9, 1., fract (7.*cylinderd));\n\t\tmat = mix (vec3 (0.), vec3 (1.), m);\n\t}\n    float sp = pow (max (.0, dot (n, h)), 80.*v);\n    float ldist = distance (lp, p);\n    float s = sha (p, n, ldir, ldist);\n    float att = 3. / (ldist*ldist);\n    float li = 2.;\n    float diff = v*max (.0, dot (n, ldir));\n    return att*s*(am + diff*mat*li*lc + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1. + .35*length (uv);\n\n    vec3 ro = vec3 (-.3, 2.75, 1.);\n    vec3 aim = vec3 (.0, 1.25, .0);\n    float z = 1.25;\n    vec3 rd = cam (uv, ro, aim, z);\n    vec3 pout;\n\tint id;\n    float d = march (ro, rd, pout, id);\n    float fog = 1. / (1. + d*d*.1);\n    vec3 p = ro+d*rd;\n    vec3 n = norm (p);\n    vec3 lp1 = vec3 (1.0, 3.0, 2.);\n    vec3 lp2 = vec3 (2.0, 2.5, 5.);\n    vec3 lp3 = vec3 (.1, 4.0, 7.);\n    vec3 lc1 = vec3 (.9, .8, .7);\n    vec3 lc2 = vec3 (.2, .3, .9);\n    vec3 lc3 = vec3 (.9, .3, .2);\n    vec3 col = shade (ro, rd, d, p, n, lp1, lc1, pout, id);\n    col += shade (ro, rd, d, p, n, lp2, lc2, pout, id);\n    col += shade (ro, rd, d, p, n, lp3, lc3, pout, id);\n\n    ro = p +.01*n;\n    rd = normalize (reflect (rd, n));\n    d = march (ro, rd, pout, id);\n    p = ro+d*rd;\n    n = norm (p);\n\n    vec3 rcol = shade (ro, rd, d, p, n, lp1, lc1, pout, id);\n    rcol += shade (ro, rd, d, p, n, lp2, lc2, pout, id);\n    rcol += shade (ro, rd, d, p, n, lp3, lc3, pout, id);\n    col += .25*rcol;\n\n    col *= fog;\n    col = col / (1. + col);\n    col *= 1. - .2*length (uv);\n    col = pow (col, vec3 (1./2.2));\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [{"id": 25489, "src": "https://soundcloud.com/michaelschofield/jinny-keep-warm", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBDR.jpg", "access": "api", "license": "gpl-3.0", "functions": [[1114, 1114, 1136, 1136, 1244], [1246, 1246, 1288, 1288, 1384], [1386, 1451, 1474, 1474, 1513], [1515, 1515, 1541, 1541, 1936], [1938, 1938, 1959, 1959, 2164], [2189, 2189, 2238, 2238, 2500], [2502, 2502, 2544, 2544, 2643], [2645, 2645, 2698, 2698, 2761], [2763, 2763, 2808, 2808, 2842], [2867, 2867, 2918, 2918, 4027], [4029, 4029, 4092, 4092, 4293], [4295, 4295, 4315, 4315, 4545], [4547, 4563, 4615, 4615, 4740], [4742, 4742, 4835, 4835, 5525], [5527, 5527, 5575, 5575, 5796], [5798, 5798, 5855, 5855, 7137]], "test": "untested"}
{"id": "3lGfz1", "name": "Circle Inverted Koch Snowflake", "author": "oneshade", "description": "Cool result of circle inverting a koch snowflake.", "tags": ["snowflake", "inverted", "koch", "circleinversion"], "likes": 6, "viewed": 143, "published": 3, "date": "1614199458", "time_retrieved": "2024-07-30T19:36:12.870708", "image_code": "#define R120 2.09439510239\n#define R150 2.61799387799\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float r = 0.3;\n    uv = uv * r * r / dot(uv, uv); // Circle inversion\n\n    uv *= 1.25;\n    uv.x = abs(uv.x);\n    uv.y -= 0.28867513459;\n\n    vec2 n = vec2(sin(R150), cos(R150));\n    uv -= n * max(0.0, dot(uv - vec2(0.5, 0.0), n)) * 2.0;\n\n    n = vec2(sin(R120), cos(R120));\n    float scale = 1.0;\n    uv.x += 0.5;\n\n    int iters = int(iTime) % 10;\n    for (int i=0; i < iters; i++) {\n        uv *= 3.0;\n        scale *= 3.0;\n        uv.x -= 1.5;\n\n        uv.x = abs(uv.x);\n        uv.x -= 0.5;\n        uv -= n * min(0.0, dot(uv, n)) * 2.0;\n    }\n\n    float line = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0)) * sign(uv.y) / scale;\n    color += smoothstep(unit, 0.0, line);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 110, 110, 959]], "test": "untested"}
{"id": "ttKBWR", "name": "Circle Pulse", "author": "lambmeow", "description": " ", "tags": ["circle"], "likes": 3, "viewed": 279, "published": 3, "date": "1614194348", "time_retrieved": "2024-07-30T19:36:13.640649", "image_code": "\n#define PI 3.1415926535\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //get uv coordinates\n   vec2 uv = (fragCoord.xy - iResolution.xy)/iResolution.y;\n   \n   //set offset and scale\n   uv += vec2(1.4, 1);\n   uv *= 0.5;\n   \n   //store color\n   vec3 color = vec3(0);\n   \n   //create overlap pattern\n  \n   //get circle shape\n   float circle = sin((uv.x + uv.y)* PI ) + cos( (uv.y - uv.x) * PI);\n   \n   //create pulse pattern\n   circle = 1.- mod(circle + time , .3 * pow(time * 0.8, .06));\n        \n   //apply color to pattern\n   color = (vec3(0., .5, .7) * sin(time + circle) + vec3(.5, 0,1) * cos(circle + time * PI) + vec3(1, 0,0))  * circle;\n   \n   \n   fragColor = vec4(color, 0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 128, 724]], "test": "untested"}
{"id": "3lVfWz", "name": "katari??", "author": "eiffie", "description": "Everyone knows the spider, monkey and now that crazy cat but there are also geometric Nazca Lines. I would love to find a diagram for katari (pi) which the Inca calculated as sqrt(10) but this looks like my bogus math. Any ideas what it refers to?", "tags": ["nazca"], "likes": 14, "viewed": 385, "published": 3, "date": "1614190368", "time_retrieved": "2024-07-30T19:36:14.405604", "image_code": "//katari by eiffie\n//The Nazca Lines on hills were for people but those on plains were prayers to the gods.\n//This looks like the kind of prayer I would make.\n//Hey God I squared the circle give me magic powers! No you didn't.\n//I doubled the cube. Not even close.\n//Its a trig table. Only the easy ones are correct. What do the 22.5 degrees even point to?\n//Its a chakana! Nope.\n//Its the world's biggest corn hole game. Fine whatever.\n\n#define tim iTime*.3\n#define rez iResolution.xy\n// Based on a simple 2d noise algorithm contributed by Trisomie21 (Thanks!) \nfloat noyz(vec2 v){ \n  vec4 h=fract(sin(vec4(floor(v.x)+floor(v.y)*1000.)+vec4(0,1,1000,1001))*1000.); \n  v=smoothstep(0.,1.,fract(v));return mix(mix(h.x,h.y,v.x),mix(h.z,h.w,v.x),v.y); \n}\nfloat bumpz(vec2 p, float d){\n  return (noyz(p)+noyz(vec2(p.x+p.y,p.x-p.y)))*d;\n}\nfloat box(vec2 p){p=abs(p);return max(p.x,p.y);}\nfloat tbox(vec2 p){p=abs(p);return min(abs(max(p.x,p.y)-.5),abs(p.x-p.y));}\nfloat DE(vec2 p){\n  float b=box(p),r=length(p);\n  float d=abs(b-4.);\n  d=min(d,abs(-abs(p.x)*3.-(p.y+p.x*.2)+20.));//randoms\n  d=min(d,abs(box(vec2(p.x-p.y,p.x+p.y)*.707)-4.));\n  for(float i=1.;i<=4.;i+=1.)d=min(d,abs(r-i));\n  vec2 ap=abs(p);\n  if(ap.y>ap.x)ap=ap.yx;\n  if(r<1.5){d=min(d,min(abs(ap.x-ap.y),abs(ap.x-ap.y*3.5)));}\n  if(r>2.5){ap-=1.62;ap*=.83;}\n  float t=tbox(fract(ap)-.5);\n  ap=floor(ap);\n  if(ap.x==1. && (ap.y==0. || (r>2.5 && ap.y==1.)))d=min(d,t);\n  return d;\n}\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=(2.0*U-rez)/rez;\n  uv.xy*=(1.75+.5*sin(tim)+uv.y*.2);\n  uv+=vec2(sin(tim*.7),sin(tim*.5))*.2;\n  uv=rotate(uv,(tim+sin(tim))*1.3);\n  float d=DE(uv*5.);\n  d=.75-.4*pow(bumpz(uv*(30.+3.*sin(uv.yx*2.)),d),.25);\n  O=vec4(d,d,d*.9,1.0);\n}", "image_inputs": [], "sound_code": "float ntof(int n){return pow(2.,float(n)/12.);}\nint scale(int n0){\n  int n=n0%12;\n  if(n==0||n==2||n==3||n==5||n==7||n==10)return n0;\n  return 0;\n}\nfloat rand(float time){return fract(sin(time*313.234+sin(time*23.12))*4534.125);}\nint N[8]=int[8](0,7,10,7,5,3,2,3);\nvec2 mainSound(int samp, float time){\n  vec2 a=vec2(0);\n  time+=.001*sin(time*20.);\n  time=mod(time,60.);\n  int t=int(time*2.);\n  int n=N[t%8]+N[(t/4)%8]+N[(t/8)%8],n1=scale(n);\n  n=scale(n+7);\n  a+=mix(vec2(rand(time)),sin(time*vec2(ntof(n),ntof(n1))*3141.59/2.),fract(time*2.));\n  return a*.125;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 563, 582, 582, 751], [752, 752, 781, 781, 833], [834, 834, 852, 852, 882], [883, 883, 902, 902, 958], [959, 959, 976, 976, 1442], [1443, 1443, 1477, 1477, 1524], [1525, 1525, 1563, 1563, 1806]], "test": "untested"}
{"id": "WtKfWR", "name": "two balls shadow version", "author": "gourki", "description": "its rolling", "tags": ["shadowraymarchin"], "likes": 1, "viewed": 222, "published": 3, "date": "1614177011", "time_retrieved": "2024-07-30T19:36:15.175545", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks inigo quilez !\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n\nvec3 opRep(vec3 p, vec3 c){\n    return mod(p+0.5*c,c) -0.5*c;\n\n}\n\nvec2 uVec2(vec2 s1, vec2 s2)\n{\n    return (s1.x < s2.x) ? s1 : s2;\n}\n\nvec2 opSmoothUnionVec2( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n    }\n    \n    \n\n        \nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nvec2 minVec2(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// ****** MAP ******\nvec2 map(vec3 pos)\n{\n    vec3 pos2 = pos;\n    \n    //pos = opRep(pos,vec3(30.,0.0,10.0));\n    vec2 s1 = vec2(sdSphere(pos+vec3(2.*sin(iTime),.0,2.*cos(iTime)), 1.0),.0);\n    vec2 s2 = vec2(sdSphere(pos+vec3(-2.*sin(0.5*iTime),.0,-2.*cos(0.5*iTime)), 1.0),1.0);\n    \n    //ground.x += 1. + sin(iTime);  \n    //ground *= rot(0.1*mod(iTime,26.));\n    \n    vec2 world = opSmoothUnionVec2(s1, s2,0.5);\n    vec2 ground = vec2(sin(iTime)+pos2.y+1.0,2.0);\n   \n    world = opSmoothUnionVec2(ground, world,0.5);\n   \n    return world;\n}\n\n\nfloat GetShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = 0.001*50.;\n    for (float i = 0.; i <= 10.0; i += .1) {\n        float dist = map(pos + dir * t).x;\n        if (dist < 0.001) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvec3 Getnormal(vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x) - v);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // si y a contact, \"c\" va stocker sa distance\n    \n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c); // POUR LE MOMENT, on va changer après\n    \n        if(ray.x < (0.0001*c))\n        {\n            return vec2(c,ray.y);\n        }\n        \n        c += ray.x;\n    }\n    \n    // si la marche est trop longue, ca renvoit -1.0\n    return vec2(-1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) // ray origin & ray direction)\n{\n    // *** RAYMARCHING\n    vec2 contact = CastRay(ro, rd); // ici on ajoutera le raymarching\n    // simulation de raymarching\n    \n    vec3 pos = ro + rd * contact.x;\n    vec3 nor = Getnormal(pos);\n    \n    vec3 lightPos = vec3(sin(iTime), -1.0, cos(iTime))*5.0;\n    vec3 lightTar = vec3(0.,0.,0.);\n    vec3 lightDir = normalize(lightTar -lightPos);\n    \n    float shade = GetShadow(pos, -lightPos,8.);\n    \n    float lambert = dot(nor,lightDir);\n    float blinn = pow(lambert,16.0);\n    float toon = step(lambert, 0.5);\n    // *** Traitement du contact\n    vec3 col = vec3(0.0);\n    \n    if(contact.y == -1.0)\n    {\n        // y a pas de contact\n        col = vec3(mix(vec3(.8, .8, .0), vec3(.5,.0, 0.0), abs(rd.y)));\n    }\n    else\n    {\n        if(contact.y == 0.0)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n        else if (contact.y == 1.0)\n        {\n            col = vec3(0.0, 1.0, 0.0);\n        }\n        else {\n            col = vec3(0.,0.,1.);\n        }\n        //col *= lambert*(1.-contact.y);\n        //col -= nor;\n         \n        col *= shade*lightDir*(lambert*.8)+.2;\n        //col += blinn*.8;\n        //col*=(1.0-toon)*.5+.5;\n        \n        float fresnel = pow((dot(nor, rd)+.8)*.9,2.)*2.0;\n       \n        col += fresnel;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centrer camera\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera\n    vec3 cameraPos = vec3(.0, 3.0, 10.0);\n    vec3 cameraTar = vec3(0.,0.0,1.0);\n    \n    // view Direction / Ray Direction\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward * 2.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, 0.0);\n\n    col = render(cameraPos, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 75, 108, 108, 134], [137, 137, 164, 164, 201], [203, 203, 233, 233, 271], [273, 273, 326, 326, 434], [455, 455, 507, 507, 606], [608, 608, 680, 680, 723], [726, 726, 758, 758, 796], [798, 819, 839, 839, 1344], [1347, 1347, 1393, 1393, 1738], [1740, 1740, 1766, 1766, 1936], [1939, 1939, 1971, 1971, 2360], [2362, 2362, 2424, 2447, 3713], [3715, 3715, 3772, 3794, 4445]], "test": "untested"}
{"id": "wlyBWz", "name": "Procedural color pallette", "author": "almeynman", "description": "Procedurally generated color pallette", "tags": ["proceduralcolorpallette"], "likes": 0, "viewed": 246, "published": 3, "date": "1614166340", "time_retrieved": "2024-07-30T19:36:15.975407", "image_code": "// https://iquilezles.org/articles/palettes\n\nvec3 pallete(float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1.,1.,1.);\n    col = pallete(uv.y,vec3(0.8, 0.5, 0.4),vec3(0.2, 0.4, 0.2),vec3(2.0, 1.0, 1.0),vec3(0.00, 0.25, 0.25));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 101, 101, 144], [146, 146, 203, 203, 415]], "test": "untested"}
{"id": "tlyBWz", "name": "two balls neo version", "author": "gourki", "description": "deux boules qui se traversent", "tags": ["raymarching", "balls"], "likes": 1, "viewed": 279, "published": 3, "date": "1614164650", "time_retrieved": "2024-07-30T19:36:16.744351", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks inigo quilez !\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n\n\n\n        \nvec2 opSmoothUnionVec2( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n    }\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nvec2 minVec2(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// ****** MAP ******\nvec2 map(vec3 pos)\n{\n\n    vec2 s1 = vec2(sdSphere(pos+vec3(2.*sin(2.*iTime),.0,2.*cos(2.*iTime)), 1.0), 0.0);\n    vec2 s2 = vec2(sdSphere(pos+vec3(-2.*sin(iTime),.0,-2.*cos(iTime)), 1.0), 1.0);\n    vec2 ground = vec2(pos.z+1.0,2.0);\n    \n    vec2 world = opSmoothUnionVec2(s1, s2,0.5);\n    world = opSmoothUnionVec2(ground, world,0.5);\n   \n    return world;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        vec2 h = map(ro + rd*t);\n        if( h.x<0.001 )\n            return 0.0;\n        t += h.x;\n    }\n    return 1.0;\n}\n\nvec3 Getnormal(vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x) - v);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // si y a contact, \"c\" va stocker sa distance\n    \n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c); \n    \n        if(ray.x < (0.0001*c))\n        {\n            return vec2(c, ray.y);\n        }\n        \n        c += ray.x;\n    }\n    \n    // si la marche est trop longue, ca renvoit -1.0\n    return vec2(-1.0, 0.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) // ray origin & ray direction)\n{\n    // *** RAYMARCHING\n    vec2 contact = CastRay(ro, rd); // ici on ajoutera le raymarching\n    // simulation de raymarching\n    \n    vec3 nor = Getnormal(ro + rd * contact.x);\n    \n    vec3 lightPos = vec3(0.,2.,2.);\n    lightPos.xz *=rot(0.33*iTime);\n    vec3 lightTar = vec3(0.,0.,0.);\n    vec3 lightDir = normalize(lightTar - lightPos);\n    \n    float shade = shadow(lightPos, lightDir,0.0,1.0);\n    \n    float lambert = dot(nor,lightDir);\n    float blinn = pow(lambert,16.0);\n    float toon = step(lambert, 0.5);\n    // *** Traitement du contact\n    vec3 col = vec3(0.0);\n    \n    if(contact.x == -1.0)\n    {\n        // y a pas de contact\n        col = vec3(mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), abs(rd.y)));\n    }\n    else\n    {\n        if(contact.y == 0.0)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            col = vec3(0.0, 1.0, 0.0);\n        }\n        //col *= lambert*(1.-contact.y);\n        //col -= nor;\n         \n        col *= shade*(lambert*.8)+.2;\n        //col += blinn*.8;\n        //col*=(1.0-toon)*.5+.5;\n        \n        float fresnel = pow((dot(nor, rd)+.9)*.8,1.)*2.0;\n       \n        col += fresnel;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centrer camera\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera\n    vec3 cameraPos = vec3(0.0, 0.0, 5.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    \n    // view Direction / Ray Direction\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward * 2.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, 0.0);\n\n    col = render(cameraPos, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 75, 108, 108, 134], [148, 148, 201, 201, 309], [311, 311, 383, 383, 426], [429, 429, 461, 461, 499], [501, 522, 542, 542, 881], [883, 883, 947, 947, 1109], [1111, 1111, 1137, 1137, 1307], [1310, 1310, 1342, 1342, 1698], [1700, 1700, 1762, 1785, 2965], [2967, 2967, 3024, 3046, 3700]], "test": "untested"}
{"id": "wtGBWz", "name": "D3.js logo lunch activity", "author": "mrange", "description": "License CC0: D3.js logo created when I should be lunching instead\nI thought the result turned out quite nice so I share the code.\nLogo is trademark of D3.js (https://d3js.org/)", "tags": ["2d", "d3"], "likes": 5, "viewed": 258, "published": 3, "date": "1614163314", "time_retrieved": "2024-07-30T19:36:17.519279", "image_code": "// License CC0: D3.js logo created when I should be lunching instead\n//  I thought the result turned out quite nice so I share the code.\n//  Logo is trademark of D3.js (https://d3js.org/)\n#define RESOLUTION iResolution\n#define TIME       iTime\n#define PSIN(x)    (0.5+0.5*sin(x))\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(-a, a, k);\n}\n\nfloat linex(vec2 p, float w) {\n  float d0 = length(p)-w;\n  float d1 = abs(p.y)-w;\n  return p.x > 0.0 ? d0 : d1;\n}\n\nfloat d3(vec2 p) {\n  const float sm = 7.0;\n  p.x -= -125.0;\n  p.y = pabs(p.y, sm);\n  float d0 = linex(p - vec2(235.0, 100), 45.0);\n  float d1 = linex(p - vec2(235.0, 100), 155.0);\n  float d2 = linex(p - vec2(-100.0, 0), 297.0);\n  float d3 = linex(p - vec2(-100.0, 0), 255.0);\n  float d4 = linex(p - vec2(-100.0, 0), 145.0);\n  float d5 = (p - vec2(-145.0, 0.0)).x;\n    \n  float d = 1E6;\n  d = min(d, d1);\n  d = max(d, -d0);\n  d = pmax(d, -d2, sm);\n  d = min(d, d3);\n  d = max(d, -d4);\n  d = pmax(d, -d5, sm);\n  return d;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  const float s = 1.0/300.0;\n\n  float d = d3(p/s)*s;\n  float sd = d3((p-vec2(-0.025))/s)*s;\n\n  vec3 col = vec3(1.0);\n  float m = max(tanh(2.0*(q.x+q.y)-1.125), 0.0);\n  vec3 hsv = vec3((mix(-40.0, 00.0, PSIN(0.25*TIME)) +30.0*m)/360.0, 1.0-m*m*m*m, m*m);\n  vec3 logocol = hsv2rgb(hsv);\n  col = mix(col, 0.25*col, exp(-20.0*max(sd, 0.0)));\n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d+0.025));\n  col = mix(col, logocol, smoothstep(-aa, aa, -d));\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGBWz.jpg", "access": "api", "license": "cc0-1.0", "functions": [[281, 281, 320, 320, 405], [407, 407, 446, 446, 475], [477, 477, 507, 507, 534], [536, 536, 566, 566, 649], [651, 651, 669, 669, 1172], [1174, 1174, 1210, 1210, 1443], [1445, 1445, 1467, 1467, 1636], [1638, 1638, 1693, 1693, 2334]], "test": "untested"}
{"id": "3tGBDz", "name": "one more cubemap access", "author": "FabriceNeyret2", "description": "( why is CubeMap face mapping so painful ? )\n\nFor instance, can be used as 6 buffers 1024x1024 ( power of 2 is nice, & const whatever screen resolution )\nT(U,n) mimic access to  buffer n = 0..5.  MIPmap can be used as well\n( attention: half-floats only )", "tags": ["cubemapa"], "likes": 7, "viewed": 430, "published": 3, "date": "1614153111", "time_retrieved": "2024-07-30T19:36:18.284234", "image_code": "#define hue(v)  ( .6 + .6 * cos( (v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/ll2cDc\n \nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 R = iResolution.xy,\n         U = vec2(3,2)*u/R,                      // tileId\n         F = fract(U);                           // tileCoord\n         \n    int n = int(U.x) + 3*int(U.y);               // cubeMap faceId\n    O = T(F,n);                                  // return E: cubemap 3coord\n    O = O.z * hue ( F.y>.5 ? O.x : O.y );        // face: top:    O.x = init n  \n                                                 //       bottom: O.y = test reconstructed n\n                                                 //               O.z = ground texture\n    if ( min(F.x,F.y) < .01 ) O-=O;              // borders\n    if (U.x<.05) O = hue( floor(6.*(.5*U.y)) );  // color scheme\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": " void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n    \n    O = texture(iChannel0,D);                                  // restore global state\n    \n    if (iFrame<1) { O = vec4(n,0,0,0); return; }               // init\n    \n    O.y = T(U/1024.,n).x;                                      // access to face n\n                                                               // test rebuild E = D\n    \n    O.z = texture(iChannel1, U/1024. ).r;                      // texture, to check orientation\n}\n\n", "cube_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 E;\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 142, 142, 835]], "test": "untested"}
{"id": "3tyBWz", "name": "Edge fade test", "author": "jstrom2002", "description": "Testing different edge fading functions.", "tags": ["edge"], "likes": 1, "viewed": 324, "published": 3, "date": "1614144537", "time_retrieved": "2024-07-30T19:36:19.051183", "image_code": "#define PI 3.1415926\n#define HALF_PI 1.5717\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat edgeFade(vec2 uv, float taper, float fade_begin){\n    return 1.0-pow(length(uv*fade_begin), taper);\n}\nfloat edgeFade2(vec2 uv, float taper, float fade_begin){\n    return exp(-length(uv*fade_begin) * taper);\n}\nfloat edgeFade3(vec2 uv, float taper, float fade_begin){\n    float l = length(uv*fade_begin);\n    float val = 0.0;\n    val += l * l / l * taper;\n    val += l * l / l * taper;\n    val += l * l / l * taper;\n    val += l * l / l * taper;\n    val += l * l / l * taper;\n    return 1.0 - val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0; // [-1,1] uv range.\n\n    // Arbitrary pixel color\n    vec3 col = vec3(rand(uv.xy));\n    float fade_val =\n    \n        //edgeFade(uv, 0.4, 0.3);\n        //edgeFade2(uv, 1.0, 1.0);\n        edgeFade3(uv, 0.5, 0.3);\n\n    \n    fragColor = vec4(col * fade_val,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 65, 65, 128], [130, 130, 185, 185, 237], [238, 238, 294, 294, 344], [345, 345, 401, 401, 633], [635, 635, 692, 692, 1019]], "test": "untested"}
{"id": "WtGBWz", "name": "Procedural Warping", "author": "ArenaGrenade", "description": "Organic looking Procedural warping with colourful shading.", "tags": ["noisewarpingproceduralorganic"], "likes": 7, "viewed": 399, "published": 3, "date": "1614141051", "time_retrieved": "2024-07-30T19:36:19.824117", "image_code": "#define NUM_OCTAVES 3\n#define SPEED_SCALE 0.5\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 - one of the best gists to exist\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// Rotation matrix\nconst mat2 rot_mat = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvoid rotate_point(inout vec2 p) {\n    // This line just generates a random value between 2.01 and 2.04\n    float factor = 2.01 + float(int(rand(p) * 100.0) % 4) * 0.01;\n    p *= (rot_mat * 2.04);\n}\nfloat calculate_iteration(inout float frequency, inout float amplitude, vec2 p, float addend) {\n    float f = amplitude * noise(frequency * p + addend);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n    return f;\n}\nfloat fbm(vec2 p) {\n    float amplitude = 0.5;\n    float frequency = 0.5;\n    float f = 0.0;\n    \n    for (int i = 0 ; i < NUM_OCTAVES; i++) {\n        if (i == 0) {\n            f += calculate_iteration(frequency, amplitude, p, iTime * SPEED_SCALE);\n        } else {\n            f += calculate_iteration(frequency, amplitude, p, sin(iTime * SPEED_SCALE + noise(p)));\n        }\n        rotate_point(p);\n    }\n    \n    return f / 0.96975;\n}\n\n// A very simple warping\nfloat warp(vec2 p, int depth) {\n    float val = fbm(p);\n    for (int i = 0; i < depth; i++) val = fbm(p + val);\n    return val;\n}\n\nvec3 calculate_normal(vec2 p) {\n    float d = warp(p, 2);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        warp(p - e.xy, 2),\n        2.0 * e.x,\n        warp(p - e.yx, 2)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float density = warp(uv, 2);\n    \n    vec3 col = vec3(0.0);\n    // Apply Density based color-gradient from a lagoon blue\n    col = mix(vec3(2.0, 83.0, 125.0) / 255.0, vec3(1.0, 132.0, 169.0) / 255.0, smoothstep(0.0, 0.05, density));\n    col = mix(col, vec3(1.0, 191.0, 196.0) / 255.0, smoothstep(0.05, 0.3, density));\n    col = mix(col, vec3(169.0, 232.0, 219.0) / 255.0, smoothstep(0.3, 0.5, density));\n    col = mix(col, vec3(224.0, 247.0, 230.0) / 255.0, smoothstep(0.5, 0.7, density));\n    \n    col = 1.0 - col;\n    \n    // Lighting\n    vec3 n = calculate_normal(uv);\n    vec3 l = vec3(0.9, -0.02, -0.4);\n    // vec3 lig = normalize(l - vec3(uv.xy, density));\n    vec3 lig = l;\n    \n    float diffuse_intensity = 0.3;\n    float diffuse = clamp(diffuse_intensity + (1.0 - diffuse_intensity) * dot(n, lig), 0.0, 1.0);\n\n    vec3 i = vec3(0.85,0.90,0.95);\n    vec3 bdrf = clamp(i * (n.y * 0.5 + 0.5) + (1.0 - i) * diffuse, 0.8, 1.0);\n    \n    col *= bdrf;\n    col = vec3(1.0)-col;\n    col = col*col;\n    col *= vec3(1.2,1.2,1.2);\n    col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 149, 169, 169, 236], [238, 238, 258, 258, 467], [545, 545, 578, 647, 742], [743, 743, 838, 838, 955], [956, 956, 975, 975, 1393], [1395, 1420, 1451, 1451, 1549], [1551, 1551, 1582, 1582, 1775], [1777, 1777, 1834, 1834, 2985]], "test": "untested"}
{"id": "3tyBDR", "name": "move camera v-1", "author": "jorge2017a1", "description": "move and rotate camera", "tags": ["moveandrotatecamera"], "likes": 3, "viewed": 240, "published": 3, "date": "1614132587", "time_retrieved": "2024-07-30T19:36:20.592063", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nfloat iTimeGlobal;\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    \n    if (iTimeGlobal<5.0)\n    {\n        \n        p=p+vec3(14.0+iTimeGlobal,0.0,0.0);\n        \n    }\n    else if(iTimeGlobal<15.0)\n    {\n        p=p+vec3(18.0,0.0,0.0+iTimeGlobal*2.0);\n     }else if(iTimeGlobal>15.0)\n     {\n        p=p+vec3(18.0,0.0,0.0-iTimeGlobal*5.0);\n     }\n    \n    \n    \n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    p= rotate_z(p-vec3(0.0,0.0,0.0), radians(45.0));\n    p= rotate_x(p-vec3(0.0,0.0,0.0), radians(90.0));\n\t\n\t vec3 repcA=p;\n     repcA.x= opRep1D( repcA.x, 5.0 );\n     repcA.y= opRep1D( repcA.y, 8.0 );\n     \n  \n     vec3 pnewA=p;\n     pnewA.y= opRep1D( pnewA.y, 10.0 );\n    \n    float db1A= sdBox( pnewA-vec3(0.0), vec3(10.0,20.0,10.0) );\n    float db2A= sdBox( repcA-vec3(0.0), vec3(2.0,2.0,15.0) );\n    db1A= differenceSDF( db1A,db2A);\n    \n    \n    ///-------------\n    \n     vec3 posmov=vec3(30.0,0.0,0.0);\n    vec3 repcB=p-posmov;\n     repcB.x= opRep1D( repcB.x, 8.0 );\n     repcB.y= opRep1D( repcB.y, 8.0 ); \n     \n     \n    vec3 pnewB=p-posmov;\n    pnewB.y= opRep1D( pnewB.y, 10.0 );\n    float db1B= sdBox( pnewB-vec3(0.0), vec3(10.0,20.0,15.0) );\n    \n    float db3B= sdBox( repcB-vec3(0.0), vec3(15.0,20.0,5.0) );\n    float db2B= sdBox( repcB-vec3(0.0), vec3(2.0,2.0,20.0) );\n    \n   \n    float dif3= unionSDF(db3B,db2B);\n    dif3= intersectSDF(db1B,dif3);\n    \n    \n    res =opU3(res, vec3(db1A,-1.0,3.0)); \n    res =opU3(res, vec3(dif3,-1.0,4.0)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n   \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if (id_material==3.0)\n    { return vec3(0.952, 0.32, 0.42) *1.25; }\n    \n    \n    if (id_material==4.0)\n    { return vec3(0.52, 0.82, 0.42) *1.25; }\n\n    if (id_material==5.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*2.0,30.0);\n    iTimeGlobal=t;\n    \n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0);\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    if (iTimeGlobal>15.0 &&  iTimeGlobal<22.0 )\n    {\n        rd.xz= rotatev2(rd.xz, radians(160.0));    \n    }\n    else if(iTimeGlobal>22.0 &&  iTimeGlobal<30.0 )   \n   {    \n        ro=vec3(8.0,10.0,5.0);\n   }\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 454, 454, 475], [476, 476, 508, 508, 592], [594, 638, 685, 685, 712], [714, 714, 757, 757, 784], [786, 786, 834, 834, 862], [863, 947, 983, 983, 1028], [1029, 1094, 1128, 1128, 1226], [1227, 1227, 1261, 1261, 1353], [1354, 1354, 1388, 1388, 1480], [1481, 1521, 1555, 1555, 1652], [1654, 1694, 1719, 1719, 3259], [3262, 3262, 3327, 3327, 3910], [3914, 3965, 3989, 3989, 4177], [4178, 4241, 4274, 4274, 4735], [4737, 4791, 4827, 4827, 5061], [5118, 5152, 5232, 5232, 5503], [5504, 5555, 5602, 5602, 5944], [5998, 5998, 6091, 6091, 6366], [6371, 6420, 6477, 6477, 7882]], "test": "untested"}
{"id": "wlVfRm", "name": "logistic adherances", "author": "Lordinator", "description": "Represents the logistic serie adherance graph. Logistic series are related to mandelbrot, population growth & water drips. If you want to learn more about the logisitc series, https://www.youtube.com/watch?v=ovJcsL7vyrk", "tags": ["mathematics"], "likes": 2, "viewed": 324, "published": 3, "date": "1614120180", "time_retrieved": "2024-07-30T19:36:21.355023", "image_code": "#define minX 0.1\n#define maxX 4.0\n\n#define minY -0.01\n#define maxY 1.0\n\n#define nbRep 1000\n\nfloat closeNumberOfNumberInLogistic(float r, float goal, float epsilon){\n    float res = 0.0;//cumulated closeness to the goal\n    float u = 0.5 + .25 * sin(iTime); //series calc\n    for (int i = 0; i < nbRep; i +=1){\n        u = r * u * (1.0-u); //next logistic term calculated\n        res += (epsilon - min(epsilon, (goal - u)*(goal - u)))/epsilon; //close to 1.0 if u is close to goal in epsilon range\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float r = minX + uv.x * (maxX - minX);\n    float goal = minY + uv.y * (maxY - minY);\n    \n    fragColor = vec4(log(1.0 + closeNumberOfNumberInLogistic(r,goal,1e-6)/log(100.0*float(nbRep))));\n    //log (1+x)/log(nbRep) heuristic order of repetition \n    //but this formula might --> to give all the adherance values when nbRep --> +inf\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 164, 164, 520], [522, 522, 579, 579, 960]], "test": "untested"}
{"id": "tlVBRm", "name": "Bouncy Castle Outerspace", "author": "YitingLiu", "description": "Made customizable functions for paired toruses. I made four pairs of toruses with blend function. ", "tags": ["raymarching", "template", "artofcode"], "likes": 0, "viewed": 240, "published": 3, "date": "1614119776", "time_retrieved": "2024-07-30T19:36:22.124965", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat torus(vec3 p, vec2 offs, mat2 rotVal, float t, float merge){\n\n    //offs=vec2(1.5,.2);\n    \n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    \n    float y = -fract(t)*(fract(t)-1.)*merge;\t\t\t// repeating parabola\n    vec3 tp = p;\n    tp -= vec3(-5, .8+2.*y, -5.*(sin(t)*.5+.5));\t\t\t\t\t// translate\n   \n    float squash = 1.+smoothstep(.5, .25, y)*2.;// scale\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t// flip torus on its side\n   \n    vec3 tp2 = p;\n   \n    tp2 -= vec3(-3, .8+1.*y, -3.*(cos(t)*.5+.5));\t\t\t\t\t// translate\n    tp2.y *= squash;\n    tp2 = tp2.xyz;\t\t\t\t\t\t\t\t// flip torus on its side\n\n    tp.yz*=rotVal;\n    tp2.xy*=Rot(t);\n    float scale = sdTorus(tp, offs)/squash;\n    float scale2 = sdTorus(tp2, vec2(offs*(sin(t)*.5+1.)))/squash;\n    \n   // vec2 pairs = vec2(scale,scale2);\n        \n    float blendTorus = smin(\n        scale,\n        scale2,\n        .8\n    );\n    return blendTorus; \n\n}\n\nfloat mergeBoxes(vec3 p, vec3 offs, vec3 size1, vec3 size2, float strength, float t){\n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float rotate = dBox(bp, vec3(.75));\n    \n    /**\n    offs=vec3(3,1.,-3);\n    size1 =vec3(.5,.8*sin(t),.5*cos(t));\n    size2 = vec3(.5,.2,1.);\n    **/\n    float blendBoxes = smin(\n        dBox(p-offs, size1),    \n        dBox(p-offs, size2),strength);\n        \n   return blendBoxes;\n}\n\nfloat subtract(vec3 p, vec3 s, vec3 offs){\n// -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n//offs vec3(0,1,0)\n    float subtract = max(\n        -dBox(p,s), \n        length(p-offs)-.8\n    );\n    \n    return subtract; \n}\n\n\n\nfloat GetDist(vec3 p) {\n    \n    float t = iTime;\n    \n    // ground plane\n    float pd = p.y;\n    float blendTorus = torus(p,vec2(2.,.5),Rot(t),t,1.);\n    float blendTorus2 = torus(p-.5,vec2(7.,.1),Rot(t*2.),t*.5,.7);\n    float blendTorus3 = torus(p-2.,vec2(5.,.2),Rot(sin(t)),t,1.);\n    float blendTorus4 = torus(p-3.,vec2(4.,.3),Rot(sin(t)),t,1.);\n    \n    //merging boxes in 90 degrees \n    vec3 offs=vec3(3,1.,-3), size1 =vec3(2.,.8*(sin(t)*.5+.5),2.*cos(t)), size2 = vec3(.5,2.,1.);\n    float strength = 1.; // 0 1 \n    float blendBoxes = mergeBoxes(p,offs, size1, size2,strength, t);\n    \n  \n   float subVal = subtract(p-vec3(3.+sin(t)*.5,2.,0.8), vec3(2.,.5,2),vec3(0,2.5,0));\n\n /**   // rotating box\n    vec3 bp = p;\n    bp -= vec3(0,.75,3);\t\t// translation\n    //bp.xz *= Rot(iTime);\t\t// rotation\n    float rotate = dBox(bp, vec3(.75));\n    \n    // jumping torus\n    float y = -fract(t)*(fract(t)-1.);\t\t\t// repeating parabola\n    vec3 tp = p;\n    tp -= vec3(-3, .8+1.*y, -3.*(sin(t)*.5+.5));\t\t\t\t\t// translate\n   \n    float squash = 1.+smoothstep(.5, .25, y)*.5;// scale\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t// flip torus on its side\n   \n   vec3 tp2 = p;\n   \n    tp2 -= vec3(-3, .8+1.*y, -3.*(cos(t)*.5+.5));\t\t\t\t\t// translate\n    tp2.y *= squash;\n    tp2 = tp2.xyz;\t\t\t\t\t\t\t\t// flip torus on its side\n\n    tp.yz*=Rot(t);\n    tp2.xy*=Rot(t);\n    float scale = sdTorus(tp, vec2(1.5, .2))/squash;\n    float scale2 = sdTorus(tp2, vec2(.5*(sin(t)*.5+2.), .1))/squash;\n    \n    float torus= sdTorus(p-vec3(sin(iTime)*.5-1.,2.,0.5), vec2(.5,.2));\n    float torus2 =sdTorus(p+vec3(sin(iTime)*.8-2.,0.,2.), vec2(.2*(sin(t)*.5+2.),.5));\n\n  \n    float morph2 = mix(\n        length(p-vec3(4,1,2))-1., \n        torus2,\n        sin(t)*.5+.5\n    );\n    \n    float morph3= mix(\n       torus2,\n       torus,\n        sin(t)*.5+.5\n    );\n  \n   \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n    float subtract = max(\n        -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n        length(p-vec3(0,1,0))-.8\n    );\n    \n    float intersect = max(\n        dBox(p-vec3(sin(iTime)*.5-3.,1,0), vec3(1,.5,2)), \n        length(p-vec3(-4,1,0))-1.\n    );\n    \n    float blend = smin(\n        length(p-vec3(1.,(sin(t)*.5+.5),-2))-(sin(t)*.5+.5)*.8-.2,\n        dBox(p-vec3(1,1,-2), vec3(.5,1.,.2*(sin(t)*.5+.6))),\n        .2\n    );\n    \n    float blendBoxes = smin(\n        dBox(p-vec3(3,1.,-3), vec3(.5,.8*sin(t),.5*cos(t))),    \n        dBox(p-vec3(3,1,-3), vec3(.5,.2,1.)),.2);\n      **/\n      \n  \n    \n    /**\n      float subtract = max(\n        -sdCapsule(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.2,2),vec3(1,.25,2.),2.), \n        length(p-vec3(0,1,0))-.5\n    );\n    \n    **/\n   /*** \n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n    float subtract = max(\n        -dBox(p-vec3(1.+sin(t)*.5,1,0), vec3(1,.5,2)), \n        length(p-vec3(0,1,0))-.8\n    );\n    \n    float intersect = max(\n        dBox(p-vec3(sin(iTime)*.5-3.,1,0), vec3(1,.5,2)), \n        length(p-vec3(-4,1,0))-1.\n    );\n    \n    float blend = smin(\n        length(p-vec3(3,1,-3))-.75,\n        length(p-vec3(3.+.5,1.5,-3))-.5,\n        .2\n    );\n    \n    **/\n    \n    \n    float d;\n //d=pd;\n    d=min(pd,blendTorus);\n   //d= min(morph, pd);\n   //d = min(d, subVal);\n   //d = min(d, intersect);\n   //d = min(d, rotate);\n   // d = min(d, scale2);\n   // d=min(d,blend);\n   // d=min(d,blendBoxes);\n    d = min(d, blendTorus);\n    d = min(d, blendTorus2);\n    d = min(d, blendTorus3);\n    d = min(d, blendTorus4);\n    d *= min(blendTorus, blendTorus4);\n    d /= min(blendTorus2, blendTorus3);\n   // d = mix(blendTorus, blendTorus4,pd*.8);\n    //d = 100.*(sin(d*.2)*.5+.5);\n\n    //d = min(d, blendTo2rus);\n\n   // d = min(d, blend);\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = abs( GetDist(p) );\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 8, -8);\n    \n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n\n    float d = RayMarch(ro, rd);\n    float gradient = rd.y+.5;\n    col=texture(iChannel0, 2.*rd.xy*Rot(iTime*0.05)).rgb;\n\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n\n    \tcol = vec3(dif);\n\n    }\n     col = pow(col, vec3(.4545));\t// gamma correction\n //adding filter \n     col -= mix(vec3((cos(iTime)*.5+.5),.5,.2)*max((cos(iTime)*.5+.5),.8),vec3(.8,.2,.3),rd.y);\n\n    col+=vec3(.2*gradient);\n\n\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 163], [165, 165, 206, 206, 297], [299, 299, 349, 349, 517], [519, 519, 570, 570, 882], [884, 884, 915, 915, 983], [985, 985, 1013, 1013, 1094], [1096, 1096, 1162, 1188, 2014], [2016, 2016, 2101, 2101, 2485], [2487, 2487, 2529, 2599, 2708], [2712, 2712, 2735, 2735, 6578], [6581, 6581, 6615, 6615, 6828], [6830, 6830, 6854, 6854, 7044], [7046, 7046, 7070, 7070, 7340], [7342, 7342, 7384, 7384, 7579], [7583, 7583, 7640, 7640, 8389]], "test": "untested"}
{"id": "wtVBRw", "name": "Voronot Rose", "author": "mrange", "description": "Voronot Rose", "tags": ["2d", "voronot"], "likes": 52, "viewed": 765, "published": 3, "date": "1614104267", "time_retrieved": "2024-07-30T19:36:22.886927", "image_code": "// License CC0: Voronot Rose\n//  Based upon: https://www.shadertoy.com/view/4tXGW4\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define L2(x)       dot(x, x)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nfloat height(vec2 p) {\n  p *= 0.45;\n  float d = length(p);\n  p *= ROT(TIME*0.1-1.5*d) ;\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = atan(p.x, p.y) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - TIME*(i)*.005123, fract(y + i*.125)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  return -0.0125*pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).xzy;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = 4.5*col;\n  // Workaround for some environments that seems to lack a vec3 version of tanh\n  col = vec3(tanh(col.x), tanh(col.y), tanh(col.z));\n  col = 1.0 -col;\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVBRw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[291, 291, 319, 339, 415], [417, 417, 456, 456, 541], [543, 543, 582, 582, 611], [613, 613, 643, 643, 670], [672, 672, 694, 694, 1073], [1075, 1075, 1096, 1096, 1302], [1304, 1304, 1324, 1324, 2356], [2358, 2358, 2394, 2394, 2627], [2629, 2629, 2684, 2684, 3040]], "test": "untested"}
{"id": "WlKfRm", "name": "Day 432", "author": "jeyko", "description": "potat  ", "tags": ["game", "life", "gameoflife", "of", "gol", "mdtmjvm", "continous"], "likes": 13, "viewed": 513, "published": 3, "date": "1614095656", "time_retrieved": "2024-07-30T19:36:23.659861", "image_code": "// Fork of \"Day 431\" by jeyko. https://shadertoy.com/view/ttKBzD\n// 2021-02-23 15:15:41\n\n// tried to make a continous Game of Life\n// ended up being too wormy to be Game of Life, but cool in its own right! \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C = C*.0;\n    \n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    //C += T1(U);\n    C = T1(U);\n    \n    \n    \n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(U + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(U  + n1d*200. ,256.)),0).xyz;\n    \n    \n    C *= 1. - dot(uv,uv*0.25);\n    C = smoothstep(0.,1.,C);\n    \n    C.xyz = pow(max(C.xyz,0.), vec3(0.55) + dot(uv,uv)*0.6);\n    \n    \n    \n    C.xyz += smoothstep(1.,0.,length(C))*n*0.15;\n    \n    C.xyz -= smoothstep(0.,1.,length(C))*n*0.05;\n    \n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    vec2 OU = U;\n    U += 0.25;\n    //U -= 0.5*R;   \n    //U *= 1. - fract(iTime*kTimeCoeff)*0.002;\n    //U *= rot(0.1*pow(fract(iTime*kTimeCoeff*0.125/2.),17.1)*0.1);\n    \n    //U *= 1. - dot(uv,uv)*0.001;\n    //U += 0.5*R;\n    //vec2 grady = getGradient( iChannel0, U, 3., 1, R);\n    //vec2 gradz = getGradient( iChannel0, U, 3., 2, R);\n        \n    \n    float neighrange = 25. - sin(iTime*0.25)*5.;\n    neighrange *= 0.65;\n    vec2 muv = (iMouse.xy - 0.5*R)/R.y;   \n    \n    if(iMouse.z > 0.)\n        neighrange *= 1. + 1.*smoothstep(0.01,0.,length(uv - muv) - .3);\n\n    \n    \n    vec2 grad = getGradient( iChannel0, U, neighrange*0.4, 0, R);\n       \n    \n    \n    \n      \n    float neighs = 0.;\n    \n    float iiters = 64.*0.5;            \n    float jiters = 64.*0.5;\n    \n    for(float i = 0.; i < iiters; i++){\n        vec2 p = U; \n        \n        vec2 offs = vec2(0,1.)*rot(2.*pi*(i + 0.)/iiters);\n        \n        float samp = 0.;\n        float jiters = 16.;\n        for(float j = 0.; j < jiters; j++){\n            vec2 ioffs = p + offs*mix(neighrange*0.2,neighrange,j/jiters);\n            samp += texture(iChannel0,fract(ioffs/R),0.5).x/jiters;\n        \n        }\n        \n        neighs += samp/iiters*4.;\n    }\n   \n    C = T(U);\n    \n    float deadness = smoothstep(1.,0.,abs(C.x));\n    float aliveness = smoothstep(0.,1.,abs(C.x));\n    //deadness = 1. - C.x;\n    //aliveness = C.x;\n    \n    //U += grad*.01*smoothstep(1.8,0.1,abs(neighs - 3.))*aliveness;\n    //U += grad*1.9*smoothstep(2.4,1.,abs(neighs - 2.))*aliveness;\n    \n    \n    \n    C = T(U);\n    \n    //deadness = smoothstep(1.,0.,abs(C.x));\n    //aliveness = smoothstep(0.,1.,abs(C.x));\n    //deadness = 1. - C.x;\n    //aliveness = C.x;\n    \n    \n    \n    float speed = 0.8;\n    C = mix(C,vec4(0),smoothstep(.5,0.,neighs - 1.)*aliveness*speed);\n    C = mix(C,vec4(0),smoothstep(-0.125,0.,neighs - 3.)*aliveness*speed);\n    \n    \n    C = mix(C,vec4(1),\n            smoothstep(0.5,0.,abs(neighs - 2.5))*\n        deadness*\n        speed);\n    \n    \n    //vec2 gradw = getGradient( iChannel0, U, 3., 3, R);\n    \n    //grad *= rot(.2);\n    \n    //U += grad[(iFrame/30)%0]*.1*sin(iTime);\n    \n    \n    //if(iMouse.z > 0.)\n    \n    //C = blur(iChannel0, U, R);\n    \n    \n    \n    if(iFrame%4 > 0){\n        //C = T(OU);\n    }\n    \n    \n    if(iFrame == 0){\n        C = T3(U*2.2);\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 fr = texture(iChannel0,(U)/iResolution.xy);\n   \n    float r = 17.4\n        + sin(fr.x*2. - 1.)*1.4;\n    int didx = 0;\n    \n    vec2 dfn = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n    \n    vec2 sc = vec2(0)\n        + pow(smoothstep(0.,1.,length(dfn.xy)*4.),.2)*.15*dfn;\n    \n    \n    \n    C.x =texture(iChannel0,(U + sc*vec2(0,2))/iResolution.xy).x;\n    \n    C.y =texture(iChannel0,(U + sc*vec2(0,-5))/iResolution.xy).y;\n    \n    C.z =texture(iChannel0,(U + sc*vec2(5,-5.))/iResolution.xy).z;\n    \n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define T(u) texture(iChannel0,fract((u)/R))\n#define T1(u) texture(iChannel1,fract((u)/R))\n#define T2(u) texture(iChannel2,fract((u)/R))\n#define T3(u) texture(iChannel3,fract((u)/R))\n\n#define TT(u,T) texture(T,fract((u)/res))\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n\n#define kTimeCoeff 60./167.85*4.\n\nvec2 getGradient(sampler2D tex, vec2 u, float offset, int channel, vec2 res){\n    return vec2(\n         TT(u + vec2(1,0)*offset,tex)[channel] - TT(u - vec2(1,0)*offset,tex)[channel],\n         TT(u + vec2(0,1)*offset,tex)[channel] - TT(u - vec2(0,1)*offset,tex)[channel]  \n    );\n}\n//#define Neighbordhood() vec4 me = T() \n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 sharpen(sampler2D channel,vec2 fragCoord, vec2 resolution){\n    float kernel [9];vec2 offset [9];\n    \n    vec2 step = vec2(1);\n    \n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    \n    kernel[0] = 0.0; kernel[1] = -0.25; kernel[2] = 0.0;\n    kernel[3] = -0.25; kernel[4] = 1.0; kernel[5] = -0.25;\n    kernel[6] = 0.0; kernel[7] = -0.25; kernel[8] = 0.0;\n    \n    vec4 sum = texture(channel, (fragCoord)/resolution);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, (fragCoord + offset[i])/resolution);\n        sum += color * kernel[i];\n    }\n    \n    sum = clamp(sum,0.,1.);\n    \n    return sum;\n}\n\nvec4 blur(sampler2D channel,vec2 fragCoord, vec2 resolution){\n    \n    float kernel [9];vec2 offset [9];\n\n     vec2 step = vec2(0.5);\n    \n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 1.0; kernel[1] = 1.0; kernel[2] = 1.0;\n    kernel[3] = 1.0; kernel[4] = 1.0; kernel[5] = 1.0;\n    kernel[6] = 1.0; kernel[7] = 1.0; kernel[8] = 1.0;\n    \n    vec4 sum = vec4(0);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, (fragCoord + offset[i])/resolution);\n        sum += color * kernel[i];\n    }\n    \n    sum /= 9.;\n    sum = clamp(sum,0.,1.);\n    \n    return sum;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 249, 249, 788]], "test": "untested"}
{"id": "3tKfRm", "name": "sphere mapping-v0.0.2 jf", "author": "jorge2017a1", "description": "sphere mapping-v0.0.2 jf", "tags": ["spheremappingv002jf"], "likes": 3, "viewed": 337, "published": 3, "date": "1614094567", "time_retrieved": "2024-07-30T19:36:24.608325", "image_code": "\n//por jorge2017a1\n\n//referencia\n//https://www.shadertoy.com/view/3tyBRW\n//https://www.shadertoy.com/view/WtV3Dz\n\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n/// Sphere UV Sphere UVv0\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    \n    //vec3(20.0,20.0,25.0)\n    ////vec3 posLocal = pos - SpherePos;\n    vec3 SpherePos=vec3(20.0,20.0,25.0);\n    vec3 posLocal = pos - SpherePos;\n    //vec3 posLocal = pos ;\n    float SphereRadius=20.0;\n    //经纬角度\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n///------------------------------------\n\n\n\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n     float planeDist1 = p.y+5.0;  //piso inf\n     float planeDist5 = -p.z+40.0;  //pared frente\n     \n    res =opU3(res, vec3(planeDist1,-1.0,8.)); \n  \n    \n    \n    float ds1= sdSphere(  p-vec3(0.0,0.0,-5.0), 5.0 );\n    float ds2= sdSphere(  p-vec3(5.0,5.0,10.0), 10.0 );\n    float ds3= sdSphere(  p-vec3(20.0,20.0,25.0), 20.0 );\n    \n    res =opU3(res, vec3(ds1,-1.0,11.0)); \n    res =opU3(res, vec3(ds2,-1.0,16.0)); \n    res =opU3(res, vec3(ds3,-1.0,14.0)); \n   \n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    \n    \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n     if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//Mercurial Gold\n //https://www.shadertoy.com/view/3tyBRW\n //Created by morphix in 2021-02-21\nvec3 MercurialGold( vec2 puv )\n{\n    //vec2 p = 5.*(( fragCoord.xy-.5* iResolution.xy )/iResolution.y)-.5 ;\n    vec2 p =puv;\n    \n    vec2 i = p;\n\tfloat c = 0.0;\n\tfloat r = length(p+vec2(sin(iTime),sin(iTime*.222+99.))*1.5);\n\tfloat d = length(p);\n\tfloat rot = d+iTime+p.x*.15; \n\tfor (float n = 0.0; n < 4.0; n++) {\n\t\tp *= mat2(cos(rot-sin(iTime/4.)), sin(rot), -sin(cos(rot)-iTime), cos(rot))*-0.15;\n\t\tfloat t = r-iTime/(n+1.5);\n\t\ti -= p + vec2(cos(t - i.x-r) + sin(t + i.y),sin(t - i.y) + cos(t + i.x)+r);\n\t\tc += 1.0/length(vec2((sin(i.x+t)/.15), (cos(i.y+t)/.15)));\n\t}\n\tc /= 4.0;\n\t//fragColor = vec4(vec3(c)*vec3(4.3, 3.4, 0.1)-0.35, .1);\n    vec3 col = vec3(vec3(c)*vec3(4.3, 3.4, 0.1)-0.35);\n    return col;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n   \n     if (id_material==6.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(1.00,0.5,0.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    \n    \n     if (id_material==7.0)\n    {\n        float escala=0.25;\n    \t//float d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        float d = mod(floor(p.x*escala*0.5)+floor(p.z*escala*1.0),2.0);\n\t\t\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n     if (id_material==8.0)\n    {\n    //float generateCheckerboard(vec2 uv)\n\n        vec2 p2 = floor(p.xz*0.5);\n        float s = mod( p2.x + p2.y, 2.0 );\n        return vec3(1.0)*s;\n    }\n    \n    if (id_material==9.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(0.02,0.35,1.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    if (id_material==10.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(1.32,0.35,0.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    \n    \n    \n    if (id_material==11.0)\n    {\n         vec2 uv=p.xy;\n          uv*=0.25;\n        float r=sqrt(uv.x*uv.x+uv.y*uv.y);\n        float phi=atan(uv.y,uv.x);\n        float x=r*cos(phi);\n        float y=r*sin(phi);\n        \n         \n         col=  NoisePerlinAndInverseWorley(uv +vec2(x,y),iTime*10.0);\n         return col;\n    }\n    \n    \n     if (id_material==12.0)\n    {\n        vec2 uv=p.xy;\n         uv*=0.25;\n         col=vec3(1.32,0.35,0.20)*1.25; \n         col*=  NoisePerlinAndInverseWorley(uv , 10.0*cos(iTime*10.0));\n         return col;\n    }\n    \n    if (id_material==13.0)\n    {\n        vec2 uv=p.xy;\n         uv*=0.25;\n         col=vec3(0.02,0.35,1.20)*1.25;  \n         vec3 tmpcol= sin(iTime)* NoisePerlinAndInverseWorley(uv , 10.0*cos(iTime*10.0));\n         col+=tmpcol;\n         return col;\n    }\n    \n    \n    if (id_material==14.0)\n    {\n    \n      vec2 uv = getSphereUV(p);\n      col = vec3(checkersGradBox(uv*0.1));\n         return col;\n    }\n    \n    \n    if (id_material==15.0)\n    {\n        \n        vec2 p2=p.xy;\n        float d = length(p2);\n        p2 *= (acos(d) - 1.57079632)/d;\n        col = vec3(0.5+NoisePerlinAndInverseWorleyF(p2+p.xy, iTime)*max(0.5+d, 0.0));\n        return col;\n    }\n    \n    \n    if (id_material==16.0)\n    {\n        \n        vec2 uv=p.xy;\n        float r=sqrt(uv.x*uv.x+uv.y*uv.y);\n        float phi=atan(uv.y,uv.x);\n        float x=r*cos(phi);\n        float y=r*sin(phi);\n        col= MercurialGold( vec2(x,y)+p.xy );\n        \n        \n        \n        return col;\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*2.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(4.,2.0,-25.0);\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n\n//referencia\n//2D Perlin and inverse Worley\n\n//// *** noisemaking in here *** ////\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec2 poi_gen (vec2 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    return fract(sin(vec2(dot(gridIndex + 1.0, vec2(127.4, 723.8)), \n                dot(gridIndex + 1.0, vec2(837.7, 208.7)))) * 25787.33);\n}\n\n/// Inverse Worley Noise \nfloat worley(vec2 p, float freq) {\n    // assume p is normalized\n    // split p into id and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    float minDist = 100.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 poi = poi_gen(mod(id + offset, vec2(freq))); // use mod for tiling\n            poi += offset;\n            vec2 diff = poi - pos;\n            minDist = min(minDist, length(diff));\n        }\n    }\n    return 1.0 - minDist; // inverting noise\n}\n\n/// Compound Worley Noise\n// uses the Worley FBM described by Schneider's chapter in GPU Pro 7\nfloat worleyFBM(vec2 p, float freq) {\n    return worley(p * freq, freq) * 0.625 +\n           worley(p * freq * 2., freq * 2.) * 0.25 +\n           worley(p * freq * 4., freq * 4.) * 0.125;\n}\n\n/// PERLIN\n// modified to tile from thebookofshaders.com\nfloat perlin(vec2 uv, float freq) {\n    vec2 p = uv * freq;\n    // split into ID and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    // tile corners\n    float a = poi_gen(id).x;\n    float b = poi_gen(mod(id + vec2(1., 0.), freq)).x;\n    float c = poi_gen(mod(id + vec2(0., 1.), freq)).x;\n    float d = poi_gen(mod(id + vec2(1., 1.), freq)).x;\n    \n    //smooth interpolation\n    vec2 u = smoothstep(0., 1., pos);\n    //u = pos * pos * (3. - 2. * pos);\n    \n    // mix 4 corners using position as percentage\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1. - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n\n/// Multi-octave perlin noise compounder\nfloat perlinFBM(vec2 p, float freq, int octaves) {\n    float noise = 0.;\n    float w = 0.5;\n    float c = 1.;\n    for (int i = 0; i < octaves; ++i) {\n        noise += w * perlin(p , freq * c);\n        c = c * 2.;\n        w *= 0.5;\n    }\n\n    return noise;\n}\n\n\n/// PerlinWorley\n// remapping as described by Schneider's chapter in GPU Pro 7\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\nfloat perlin_worley(vec2 uv, float freq) {\n    float w = worleyFBM(uv, freq);\n    float p = perlinFBM(uv, freq, 5);\n    p = abs(p * 2. - 1.);\n    return remap(p, 0., 1., w, 1.);\n}\n\n///cloud\nfloat cloud(vec2 uv, float freq) {\n    float pw = perlin_worley(uv, freq);\n    float wg = worleyFBM(uv, freq);\n    float wb = worleyFBM(uv, freq * 2.);\n    float wa = worleyFBM(uv, freq * 4.);\n    \n    float wfbm = wg * .625 + wb * .25 + wa * 0.125;\n    \n    return remap(pw, wfbm - 1., 1., 0., 1.);\n}\n\n\n\n///------\n// image will be comprised of t x t tiles\nfloat t = 2.0; \n// noises start generation with freq x freq cells\nfloat freq = 4.0;\n\nvec3  NoisePerlinAndInverseWorley(vec2 uv, float ptime ) \n{\n    uv -= 0.05 * ptime;\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n       col = vec3(remap(cloud(uv, freq), 0.1275, 1.25, 0., 1.));\n   \n    return col;\n}\n\n\nfloat  NoisePerlinAndInverseWorleyF(vec2 uv, float ptime ) \n{\n    uv -= 0.05 * ptime;\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n  \n    float res= remap(cloud(uv, freq), 0.1275, 1.25, 0., 1.);\n    return res;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 561, 597, 597, 618], [619, 619, 651, 651, 735], [737, 781, 828, 828, 855], [857, 857, 900, 900, 927], [929, 929, 977, 977, 1005], [1006, 1090, 1126, 1126, 1171], [1173, 1238, 1272, 1272, 1370], [1371, 1371, 1405, 1405, 1497], [1498, 1498, 1532, 1532, 1624], [1625, 1665, 1699, 1699, 1796], [1799, 1825, 1861, 1882, 2105], [2107, 2107, 2138, 2211, 2564], [2608, 2608, 2633, 2633, 3226], [3230, 3230, 3295, 3295, 3889], [3893, 3944, 3968, 3968, 4156], [4157, 4220, 4253, 4253, 4714], [4716, 4770, 4806, 4806, 5040], [5097, 5131, 5211, 5211, 5484], [5485, 5620, 5652, 5727, 6333], [6334, 6385, 6432, 6432, 9677], [9731, 9731, 9824, 9824, 10104], [10109, 10158, 10215, 10215, 11400]], "test": "untested"}
{"id": "WtKBRm", "name": "sphere mapping-jf", "author": "jorge2017a1", "description": "sphere mapping-jf", "tags": ["spheremappingjf"], "likes": 2, "viewed": 288, "published": 3, "date": "1614093899", "time_retrieved": "2024-07-30T19:36:25.560778", "image_code": "//referencia\n//por jorge2017a1\n\n///noise referencia\n//http://glslsandbox.com/e#70291.7\n//https://www.shadertoy.com/view/3lcfz7\n\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n/// Sphere UV Sphere UVv0\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    \n    //vec3(20.0,20.0,25.0)\n    ////vec3 posLocal = pos - SpherePos;\n    vec3 SpherePos=vec3(20.0,20.0,25.0);\n    vec3 posLocal = pos - SpherePos;\n    //vec3 posLocal = pos ;\n    float SphereRadius=20.0;\n    //经纬角度\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\n\n///-----------------------------------\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    float planeDist1 = p.y+5.0;  //piso inf\n      \n    float MAP_HEIGHT= 0.4;\n    float valorNoise=fnoise(p);\n    float off1 = valorNoise * MAP_HEIGHT;\n    float off2 = valorNoise * 1.0;\n    \n    float ds1= sdSphere(  p-vec3(0.0,0.0,-5.0), 5.0 );\n    ds1 = smin(ds1,planeDist1+off1,0.15)+off1;\n    planeDist1-=off2;\n    \n    float ds2= sdSphere(  p-vec3(5.0,5.0,10.0), 10.0 );\n    float ds3= sdSphere(  p-vec3(20.0,20.0,25.0), 20.0 );\n    res =opU3(res, vec3(ds1,-1.0,11.0)); \n    res =opU3(res, vec3(ds2,-1.0,13.0)); \n    res =opU3(res, vec3(ds3,-1.0,14.0)); \n    res =opU3(res, vec3(planeDist1,-1.0,11.)); \n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    \n    \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n     if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n   \n    if (id_material==9.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(0.02,0.35,1.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    if (id_material==10.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(1.32,0.35,0.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    \n    \n    \n    if (id_material==11.0)\n    {\n        vec2 uv=p.xy;\n         uv*=0.25;\n         col=  NoisePerlinAndInverseWorley(uv , iTime*10.0);\n         return col;\n    }\n    \n    \n     if (id_material==12.0)\n    {\n        vec2 uv=p.xy;\n         uv*=0.25;\n         col=vec3(1.32,0.35,0.20)*1.25; \n         col*=  NoisePerlinAndInverseWorley(uv , 10.0*cos(iTime*10.0));\n         return col;\n    }\n    \n    if (id_material==13.0)\n    {\n        vec2 uv=p.xy;\n         uv*=0.25;\n         col=vec3(0.02,0.35,1.20)*1.25;  \n         vec3 tmpcol= sin(iTime)* NoisePerlinAndInverseWorley(uv , 10.0*cos(iTime*10.0));\n         col+=tmpcol;\n         return col;\n    }\n    \n    \n    if (id_material==14.0)\n    {\n    \n      vec2 uv = getSphereUV(p);\n      col = vec3(checkersGradBox(uv*0.1));\n         return col;\n    }\n    \n    \n    if (id_material==15.0)\n    {\n        //https://www.shadertoy.com/view/WtV3Dz\n        vec2 p2=p.xy;\n        float d = length(p2);\n        p2 *= (acos(d) - 1.57079632)/d;\n        //fragColor = vec4(func(p)*max(1.-d*d*d, 0.), 1.0);\n        col = vec3(0.5+NoisePerlinAndInverseWorleyF(p2+p.xy, iTime)*max(0.5+d, 0.0));\n        //col=vec3(1.0);\n        return col;\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*2.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(5.,3.0+7.0*sin(iTime),-20.0);\n   // ro= getMouse(ro);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n\n//referencia\n//2D Perlin and inverse Worley\n\n//// *** noisemaking in here *** ////\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec2 poi_gen (vec2 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    return fract(sin(vec2(dot(gridIndex + 1.0, vec2(127.4, 723.8)), \n                dot(gridIndex + 1.0, vec2(837.7, 208.7)))) * 25787.33);\n}\n\n/// Inverse Worley Noise \nfloat worley(vec2 p, float freq) {\n    // assume p is normalized\n    // split p into id and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    float minDist = 100.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 poi = poi_gen(mod(id + offset, vec2(freq))); // use mod for tiling\n            poi += offset;\n            vec2 diff = poi - pos;\n            minDist = min(minDist, length(diff));\n        }\n    }\n    return 1.0 - minDist; // inverting noise\n}\n\n/// Compound Worley Noise\n// uses the Worley FBM described by Schneider's chapter in GPU Pro 7\nfloat worleyFBM(vec2 p, float freq) {\n    return worley(p * freq, freq) * 0.625 +\n           worley(p * freq * 2., freq * 2.) * 0.25 +\n           worley(p * freq * 4., freq * 4.) * 0.125;\n}\n\n/// PERLIN\n// modified to tile from thebookofshaders.com\nfloat perlin(vec2 uv, float freq) {\n    vec2 p = uv * freq;\n    // split into ID and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    // tile corners\n    float a = poi_gen(id).x;\n    float b = poi_gen(mod(id + vec2(1., 0.), freq)).x;\n    float c = poi_gen(mod(id + vec2(0., 1.), freq)).x;\n    float d = poi_gen(mod(id + vec2(1., 1.), freq)).x;\n    \n    //smooth interpolation\n    vec2 u = smoothstep(0., 1., pos);\n    //u = pos * pos * (3. - 2. * pos);\n    \n    // mix 4 corners using position as percentage\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1. - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n\n/// Multi-octave perlin noise compounder\nfloat perlinFBM(vec2 p, float freq, int octaves) {\n    float noise = 0.;\n    float w = 0.5;\n    float c = 1.;\n    for (int i = 0; i < octaves; ++i) {\n        noise += w * perlin(p , freq * c);\n        c = c * 2.;\n        w *= 0.5;\n    }\n\n    return noise;\n}\n\n\n/// PerlinWorley\n// remapping as described by Schneider's chapter in GPU Pro 7\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\nfloat perlin_worley(vec2 uv, float freq) {\n    float w = worleyFBM(uv, freq);\n    float p = perlinFBM(uv, freq, 5);\n    p = abs(p * 2. - 1.);\n    return remap(p, 0., 1., w, 1.);\n}\n\n///cloud\nfloat cloud(vec2 uv, float freq) {\n    float pw = perlin_worley(uv, freq);\n    float wg = worleyFBM(uv, freq);\n    float wb = worleyFBM(uv, freq * 2.);\n    float wa = worleyFBM(uv, freq * 4.);\n    \n    float wfbm = wg * .625 + wb * .25 + wa * 0.125;\n    \n    return remap(pw, wfbm - 1., 1., 0., 1.);\n}\n\n\n\n///------\n// image will be comprised of t x t tiles\nfloat t = 2.0; \n// noises start generation with freq x freq cells\nfloat freq = 4.0;\n\nvec3  NoisePerlinAndInverseWorley(vec2 uv, float ptime ) \n{\n    // create tiles\n    //uv *= t;\n    // add time animation\n    uv -= 0.05 * ptime;\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n  \n        col = vec3(remap(cloud(uv, freq), 0.1275, 1.25, 0., 1.));\n    \n    // Output color\n    //fragColor = vec4(col,1.0);\n    return col;\n}\n\n\nfloat  NoisePerlinAndInverseWorleyF(vec2 uv, float ptime ) \n{\n    uv -= 0.05 * ptime;\n    uv = fract(uv);\n    \n    vec3 col = vec3(0.0);\n  \n    float res= remap(cloud(uv, freq), 0.1275, 1.25, 0., 1.);\n    return res;\n}\n\n\n\n\n///----------NOISE II\n//http://glslsandbox.com/e#70291.7\n#define MAP_ROUGHNESS 5.0\n#define MAP_SCALE 2.0\n\nvec3 Hash33(in vec3 p) {\n    return vec3(fract(sin(dot(p, vec3(7643.54, 6854.95, 356.6765))) * 234.752),\n                fract(sin(dot(p, vec3(7853.67, 5214.327, 435.6437))) * 6734.8275),\n                fract(sin(dot(p, vec3(7546.754, 683.2647, 358.2431))) * 257.8643));\n}\n\nfloat noise(in vec3 p) {\n    return fract(sin(dot(p, vec3(3743.54, 2754.23, 578.537))) * 5664.865);\n}\n\nfloat snoise(in vec3 p) {\n\n\tvec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(lub, rub, local.x),\n                   local.y),\n\n               mix(mix(ldf, rdf, local.x),\n                   mix(luf, ruf, local.x),\n                   local.y),\n\n               local.z);\n}\n\nfloat fnoise(in vec3 p) {\n\n    p *= MAP_SCALE;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < MAP_ROUGHNESS; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n\tfloat nn = value / tscale;\n\tnn = clamp(nn,0.5,1.0);\n\t\n\t\n\treturn nn;\n\t//return value / tscale;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[575, 575, 611, 611, 632], [633, 633, 665, 665, 749], [751, 795, 842, 842, 869], [871, 871, 914, 914, 941], [943, 943, 991, 991, 1019], [1020, 1104, 1140, 1140, 1185], [1187, 1252, 1286, 1286, 1384], [1385, 1385, 1419, 1419, 1511], [1512, 1512, 1546, 1546, 1638], [1639, 1679, 1713, 1713, 1810], [1813, 1839, 1875, 1896, 2119], [2121, 2121, 2152, 2225, 2578], [2581, 2620, 2661, 2661, 2754], [2755, 2795, 2820, 2820, 3556], [3560, 3560, 3625, 3625, 4219], [4223, 4274, 4298, 4298, 4486], [4487, 4550, 4583, 4583, 5044], [5046, 5100, 5136, 5136, 5370], [5427, 5461, 5541, 5541, 5814], [5857, 5908, 5955, 5955, 7473], [7527, 7527, 7620, 7620, 7900], [7905, 7954, 8011, 8011, 9230]], "test": "untested"}
{"id": "3tKBRm", "name": "raymarchingbasicTuTo", "author": "gourki", "description": "first raymarching shader made in a cours at my university", "tags": ["raymarching"], "likes": 2, "viewed": 281, "published": 3, "date": "1614093066", "time_retrieved": "2024-07-30T19:36:26.340693", "image_code": "//thanks remy\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n   p.x += sin(p.y*10.+iTime*2.0)*0.1;\n   p.y += sin(p.z*10.+iTime*5.0)*0.1;\n   p.z += sin(p.x*10.+iTime*2.0)*0.1;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\nvec3 opRep(vec3 p, vec3 c){\n    return mod(p+0.5*c,c) -0.5*c;\n\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat map(vec3 pos)\n{\n    pos = opRep(pos,vec3(6));\n    \n    float world = sdRoundBox(pos, vec3(0.5),0.5);\n    pos.xz *= rot(iTime);\n    pos.yz *= rot(iTime);\n    pos.xy += sin(iTime)*2.0;\n    world = opSmoothUnion(world, sdRoundBox(pos, vec3(0.5),0.5),0.5);\n    return world;\n}\n\n\n\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0;\n    \n    for(int i = 0; i<64; i++)\n    {\n        float ray = map(ro + rd *c);\n        \n        if(ray < (0.001*c))\n        {\n            return float(i)/32.;\n        }\n        \n        c += ray;\n    }    \n\n    return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd)// ray origin & ray direction )\n{\n    float contact = CastRay(ro,rd); \n    \n    \n    vec3 col = vec3(0.0);\n    \n    if (contact == -1.0)\n    {\n    col = vec3(mix(vec3(0.0,1.0,1.0),vec3(0.,0.,1.),abs(rd.y)));\n    }\n    else{\n        col = palette(contact, vec3(0.5), vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.));\n        //col = mix(vec3(0.2,0.0,0.0),vec3(1.0,0.0,0.0),(1.0-contact));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //Centrer camera \n   vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n   uv.x *= iResolution.x/iResolution.y;\n   \n   //Camera\n   \n   vec3 cameraPos = vec3(iTime*10.0,-10.*cos(iTime*1.), -10.*sin(iTime*1.));\n   vec3 cameraTar = vec3(iTime,0.0,5.0);\n   \n   // view Direction / Ray Direction \n   vec3 forward = normalize(cameraTar - cameraPos);\n   vec3 right = normalize(cross(vec3(0.0, -1.0,0.0), forward));\n   vec3 up = normalize(cross(right, forward));\n   vec3 viewDir = normalize(uv.x* right + uv.y * up + forward * 2.0);\n   \n   //Time varying pixel color\n   vec3 col = vec3(uv.x, uv.y, 0.0);\n   \n   col = render(cameraPos, viewDir);\n   \n   //output to screen \n   fragColor = vec4(col,1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 77, 122, 122, 327], [329, 329, 401, 401, 444], [448, 448, 475, 475, 512], [514, 514, 566, 566, 665], [668, 668, 689, 689, 946], [951, 951, 984, 984, 1228], [1231, 1231, 1293, 1293, 1661], [1663, 1663, 1720, 1741, 2420]], "test": "untested"}
{"id": "3tKBzw", "name": "Controllable Hexapod 2", "author": "dr2", "description": "Bug wanders autonomously; use the buttons to take control.", "tags": ["interactive", "robot", "walk"], "likes": 47, "viewed": 4127, "published": 3, "date": "1614086050", "time_retrieved": "2024-07-30T19:36:27.288159", "image_code": "// \"Controllable Hexapod 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 footPos[6], legAng[6], bdyPos, ltPos[3], ltCol[3], qHit;\nvec2 hipPos[6], kneePos[6];\nfloat tCur, dstFar, bdyRad, legLen, walkDir, hdAng;\nint idObj;\nbool doSh;\nconst int idLeg = 1, idPiv = 2, idFoot = 3, idBod = 4, idAx = 5, idNek = 6, idRad = 7, idLmp = 8,\n   idHead = 9, idEye = 10, idAnt = 11;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid BugGeom ()\n{\n  float dr, dxz, dy, ll;\n  ll = 4. * legLen * legLen;\n  for (int m = VAR_ZERO; m < 6; m ++) {\n    dr = length (footPos[m].xz);\n    hipPos[m] = bdyRad * vec2 (sin (pi * float (2 * m + 1) / 6. + vec2 (0.5 * pi, 0.)));\n    legAng[m].x = - atan (footPos[m].z, footPos[m].x);\n    dxz = 0.5 * dr + bdyPos.y * sqrt (ll / dot (footPos[m], footPos[m]) - 0.25);\n    dy = sqrt (ll - dxz * dxz);\n    kneePos[m] = vec2 (dxz, dy);\n    legAng[m].y = atan (dxz, dy);\n    legAng[m].z = atan (dr - dxz, - sqrt (ll - (dr - dxz) * (dr - dxz)));\n  }\n}\n\nfloat BugDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, y, a;\n  for (int m = VAR_ZERO; m < 6; m ++) {\n    q = p;\n    q.xz = Rot2D (q.xz - hipPos[m], legAng[m].x);\n    q.xy = Rot2D (q.xy, legAng[m].y);\n    d = PrRoundCylDf (q, 0.12, 0.02, 0.08);\n    DMINQ (idPiv);\n    q.y -= legLen;\n    y = q.y / legLen;\n    d = PrCylDf (vec3 (abs (q.xz) - 0.032 * (1. - 0.375 * y), q.y), 0.02 * (1. + 0.1 * abs (cos (16. * pi * y))), legLen);\n    DMINQ (idLeg);\n    q.y -= legLen;\n    d = PrRoundCylDf (q, 0.05, 0.02, 0.03);\n    DMINQ (idPiv);\n    q.xy = Rot2D (q.xy, legAng[m].z - legAng[m].y);\n    q.y -= legLen;\n    y = q.y / legLen;\n    d = PrCylDf (vec3 (q.x, abs (q.z) - 0.02 * (1. - 0.25 * y), q.y), 0.012 * (1. + 0.1 * abs (cos (16. * pi * y))), legLen);\n    DMINQ (idLeg);\n    q.y -= legLen;\n    q.xy = Rot2D (q.xy, - legAng[m].z);\n    q.y -= 0.04 * legLen;\n    d = PrCylDf (q.xzy, 0.08, 0.04 * legLen);\n    DMINQ (idFoot);\n  }\n  q = p;\n  q.xz = Rot2D (q.xz, pi / 6.);\n  qq = q;\n  a = atan (q.z, - q.x) / (2. * pi);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * a + 0.5) / 6.));\n  q.x -= - bdyRad + 0.1;\n  d = PrRoundCylDf (q.xzy, 0.13, 0.02, 0.15);\n  DMINQ (idAx);\n  q = qq;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (18. * a + 0.5) / 18.));\n  q.x -= - bdyRad;\n  d = PrRoundCylDf (q.yzx, 0.025, 0.01, 0.03);\n  q = vec3 (q.yz, a).xzy;\n  DMINQ (idLmp);\n  q = p;\n  d = min (PrTorusDf (vec3 (q.xz, abs (q.y) - 0.06), 0.015, bdyRad - 0.016),\n      length (vec2 (q.y - 0.2, abs (abs (q.z) - 0.36) - 0.16)) - 0.012);\n  d = SmoothMax (PrRoundCylDf (q.xzy, bdyRad - 0.12, 0.1, 0.1), - d, 0.01);\n  d = max (d, - PrSphDf (vec3 (mod (q.x + 0.06, 0.12) - 0.06, q.y - 0.2, abs (q.z) - 0.36), 0.025));\n  DMINQ (idBod);\n  q = p;\n  q.xy -= vec2 (-0.7 * bdyRad, 0.2);\n  d = PrCylDf (q.xzy, 0.05, 0.08);\n  DMINQ (idRad);\n  q.y -= 0.22;\n  q.xz = Rot2D (q.xz, 2. * tCur);\n  d = PrTorusDf (q, 0.02, 0.15);\n  DMINQ (idRad);\n  q = p;\n  q.xy -= vec2 (0.7 * bdyRad, 0.25);\n  d = PrCylDf (q.xzy, 0.12, 0.08);\n  DMINQ (idNek);\n  q.y -= 0.24;\n  q.xz = Rot2D (q.xz, hdAng);\n  d = PrRoundBoxDf (q, vec3 (0.3, 0.2, 0.27) - 0.1, 0.1);\n  d = max (d, - PrCylDf (vec3 (q.x - 0.3, q.y + 0.07, q.z).xzy, 0.1, 0.02));\n  d = max (d, - min (PrSphDf (vec3 (q.x, abs (q.yz)) - vec3 (-0.3, 0.05, 0.1), 0.03),\n     PrSphDf (vec3 (q.x, abs (q.yz)) - vec3 (-0.15, 0.05, 0.27), 0.03)));\n  DMINQ (idHead);\n  qq = q;\n  q.z = abs (q.z);\n  q -= vec3 (0.15, 0.25, 0.15);\n  q.yz = Rot2D (q.yz, -0.1 * pi);\n  q.xy = Rot2D (q.xy, 0.05 * pi);\n  d = min (PrCylDf (q.xzy, 0.02, 0.25), PrRoundCylDf (vec3 (q.xz, q.y - 0.26), 0.06, 0.01, 0.01));\n  DMINQ (idAnt);\n  q = qq;\n  q.xy -= vec2 (0.1, 0.08);\n  d = PrRoundCylDf (q.xzy, 0.3, 0.02, 0.04);\n  DMINQ (idEye);\n  return 0.95 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= bdyPos;\n  if (! doSh) d = PrCylDf (q.xzy, bdyRad + 1.6, 1.1);\n  if (doSh || d < 0.1) {\n    q.xz = Rot2D (q.xz, - walkDir);\n    dMin = BugDf (q, dMin);\n  } else dMin = d;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  doSh = true;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  doSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, int wgSel)\n{\n  vec4 wgBx[4], w1, w2;\n  vec2 s;\n  float asp, d, w;\n  bool isCol;\n  asp = canvas.x / canvas.y;\n  w1 = vec4 (0.42 * asp, -0.35, 0.025, 0.);\n  w2 = vec4 (0.06, 0., 0., 0.);\n  wgBx[0] = w1 + w2.yxzw;\n  wgBx[1] = w1 - w2.yxzw;\n  wgBx[2] = w1 - w2;\n  wgBx[3] = w1 + w2;\n  for (int k = 0; k < 4; k ++) {\n    s = 0.5 * uv - wgBx[k].xy;\n    w = (length (s) - wgBx[k].z) * canvas.y;\n    isCol = false;\n    if (w < 1.5) {\n      isCol = (abs (w) < 1.5);\n      if (! isCol) {\n        if (k == 0) d = max (abs (s.x) + s.y, -2. * s.y);\n        else if (k == 1) d = max (abs (s.x), abs (s.y));\n        else if (k == 2) d = max (abs (s.y) - s.x, 2. * s.x);\n        else if (k == 3) d = max (abs (s.y) + s.x, -2. * s.x);\n        isCol = (d < 0.4 * wgBx[k].z);\n      }\n    }\n    if (isCol) col = mix (col, (k == wgSel) ? vec3 (1.) : vec3 (0.3), 0.7);\n  }\n  return col;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4, col4B, col4H;\n  float s;\n  s = length (qHit.xz);\n  col4B = vec4 (0.95, 0.95, 1., 0.2);\n  col4H = vec4 (0.9, 0.95, 0.9, 0.2);\n  if (idObj == idLeg) col4 = vec4 (1., 0.8, 0.8, 0.2);\n  else if (idObj == idPiv) col4 = col4B * (0.5 + 0.5 * smoothstep (0., 0.01, length (qHit.xy) - 0.03));\n  else if (idObj == idAx) col4 =  col4B * (0.5 + 0.5 * smoothstep (0., 0.01, s - 0.08));\n  else if (idObj == idBod) col4 = col4B;\n  else if (idObj == idHead) col4 = mix (col4H, vec4 (1., 0., 0., -1.), step (abs (qHit.y + 0.07), 0.02) *\n     step (0., qHit.x) * step (abs (qHit.z), 0.1));\n  else if (idObj == idAnt) col4 = mix (col4B * (0.6 + 0.4 * SmoothBump (0.1, 0.9, 0.05, mod (32. * qHit.y, 1.))),\n     vec4 (1., 1., 0., -1.), step (0.26, qHit.y) * step (s, 0.05) * step (-0.5, sin (8. * pi * tCur)));\n  else if (idObj == idEye) col4 = mix (col4H, vec4 (0., 0., 1., -1.), step (-0.12, qHit.x) *\n     step (cos (16. * atan (qHit.z, qHit.x)), 0.7) * step (abs (qHit.y), 0.03));\n  else if (idObj == idFoot) col4 = 0.8 * col4B * (0.5 + 0.5 * smoothstep (0., 0.01, s - 0.04));\n  else if (idObj == idNek) col4 = col4H;\n  else if (idObj == idRad) col4 = 0.9 * col4B;\n  else if (idObj == idLmp) col4 = mix (col4B, vec4 (HsvToRgb (vec3 (mod (qHit.y + 0.3 * tCur, 1.), 0.8, 1.)), -1.),\n     step (s, 0.03));\n  return col4;\n}\n\n#define REFLECT 0 // optional reflection\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, ltDir, ltAx, c;\n  float dstObj, nDotL, sh, att, ltDst;\n  BugGeom ();\n  doSh = false;\n  dstObj = ObjRay (ro, rd);\n#if REFLECT\n  if (dstObj >= dstFar && rd.y < 0.) {\n    roo = ro;\n    ro += (- ro.y / rd.y) * rd;\n    if (length (max (abs (mod (ro.xz + 0.5, 1.) - 0.5) - 0.4, 0.)) < 0.05) {\n      rd = reflect (rd, vec3 (0., 1., 0.));\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n    } else ro = roo;\n  }\n#endif\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n  } else if (rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = vec4 (0.7, 0.7, 0.7, 0.) * (1. - 0.1 * Noisefv2 (256. * ro.xz)) * (1. - 0.2 * Fbm2 (4. * ro.xz));\n    col4.rgb = mix (col4.rgb, vec3 (0.5), smoothstep (0.05, 0.08,\n       length (max (abs (mod (ro.xz + 0.5, 1.) - 0.5) - 0.4, 0.))));\n  }\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) {\n      col = vec3 (0.);\n      for (int k = VAR_ZERO; k < 3; k ++) {\n        ltDir = ltPos[k] - ro;\n        ltDst = length (ltDir);\n        ltDir /= ltDst;\n        ltAx = normalize (ltPos[k] - vec3 (bdyPos.xz, 0.).xzy);\n        att = smoothstep (0., 0.01, dot (ltDir, ltAx) - 0.985);\n        sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDst) : 1.;\n        nDotL = max (dot (vn, ltDir), 0.);\n        if (col4.a > 0.) nDotL *= nDotL * nDotL;\n        c = att * ltCol[k] * (col4.rgb * (0.15 + 0.85 * sh * nDotL) +\n           col4.a * step (0.95, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n        col += pow (c, vec3 (2.));\n      }\n      col = pow (col, 1. / vec3 (2.));\n    } else col = col4.rgb * (0.2 + 0.8 * max (0., - dot (vn, rd)));\n  } else col = vec3 (0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az;\n  int wgSel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  hdAng = 0.2 * pi * sin (tCur);\n  legLen = 0.5;\n  for (int k = VAR_ZERO; k < 6; k ++) {\n    stDat = Loadv4 (k);\n    footPos[k] = stDat.xyz;\n  }\n  stDat = Loadv4 (6);\n  bdyPos = stDat.xyz;\n  walkDir = stDat.w;\n  stDat = Loadv4 (9);\n  bdyRad = stDat.y;\n  stDat = Loadv4 (10);\n  az = stDat.x;\n  el = stDat.y;\n  wgSel = int (stDat.z);\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  ro = bdyPos * vec3 (1., 0., 1.) + vuMat * vec3 (0., 0.2, -10.);\n  dstFar = 30.;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 30., 0.);\n    ltPos[k].xy = Rot2D (ltPos[k].xy, 0.25 * pi * (1. + 0.2 * sin (0.05 * pi * tCur - pi * float (k) / 3.)));\n    ltPos[k].xz = Rot2D (ltPos[k].xz, 0.1 * pi * tCur + pi * float (k) / 3.);\n    ltPos[k].xz += bdyPos.xz;\n  }\n  ltCol[0] = vec3 (1., 0.5, 0.5);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  dstFar = 30.;\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, wgSel);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Controllable Hexapod 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 footPos[6], bdyPos;\nfloat tCur, bdyRad, bdyHt, footSpeedV, footDir, stepCount, stepLim, \n   wkPhase, wkChange, walking, walkDir, turnDir, turnDirN;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nvoid Step ()\n{\n  vec2 b, c;\n  float stepLimM, walkSpeed, turnSpeed, u, mm;\n  stepLimM = 64.;\n  walkSpeed = 0.8 / stepLimM;\n  turnSpeed = 0.5 * walkSpeed;\n  if (stepCount == 0.) {\n    if (wkChange != 0. && (wkPhase == 0. || wkPhase == 2.)) {\n      ++ wkPhase;\n      wkChange = 0.;\n    }\n    if (wkPhase == 2. && turnDir != turnDirN) {\n      ++ wkPhase;\n      wkChange = 1.;\n    }\n    if (wkPhase == 1. || wkPhase == 4.) walking = 1. - walking;\n    stepLim = stepLimM;\n    if (wkPhase == 1. || wkPhase == 3.) stepLim *= 0.5;\n    else if (wkPhase == 0. || wkPhase == 4.) stepLim = 0.;\n    if (stepLim > 0.) {\n      footSpeedV = 0.6 * bdyHt / (stepLim * 0.5);\n      if (wkPhase == 1. || wkPhase == 3.) footSpeedV *= 0.5;\n    }\n    if (wkPhase == 1.) {\n      turnDir = turnDirN;\n      footDir = 1.;\n    } else footDir = - footDir;\n    if (wkPhase == 4.) {\n      wkPhase = 0.;\n      turnDir = 0.;\n    }\n    if (wkPhase == 1. || wkPhase == 3.) ++ wkPhase;\n    stepCount = stepLim;\n  }\n  if (walking == 0. && turnDir == 0.) {\n    bdyPos.y = max (0.97 * bdyPos.y, 0.6 * bdyHt);\n    for (int m = 0; m < 6; m ++) footPos[m].y = - bdyPos.y;\n  } else if (bdyPos.y != bdyHt) {\n    bdyPos.y = min (1.1 * bdyPos.y, bdyHt);\n    for (int m = 0; m < 6; m ++) footPos[m].y = - bdyPos.y;\n  }  \n  if (stepLim > 0.) {\n    -- stepCount;\n    if (turnDir == 0.) {\n      bdyPos.xz += walkSpeed * sin (walkDir + vec2 (0.5 * pi, 0.));\n    } else {\n      walkDir = mod (walkDir + turnSpeed * turnDir, 2. * pi);\n      c = sin (turnSpeed * turnDir + vec2 (0.5 * pi, 0.));\n    }\n    for (int m = 0; m < 6; m ++) {\n      mm = float (m);\n      u = footDir * (2. * mod (mm, 2.) - 1.);\n      if (u > 0.) footPos[m].y += footSpeedV * sign (stepLim * 0.5 - 0.5 - stepCount);\n      if (turnDir == 0.) {\n        footPos[m].x += u * walkSpeed;\n      } else {\n        b = bdyRad * sin (pi * (2. * mm + 1.) / 6. + vec2 (0.5 * pi, 0.));\n        footPos[m].xz = Rot2Cs (footPos[m].xz + b, vec2 (c.x, u * c.y)) - b;\n      }      \n    }\n  }\n}\n\nvoid Init ()\n{\n  float footDist;\n  bdyRad = 0.8;\n  bdyHt = 0.6;\n  bdyPos = vec3 (0., bdyHt, 0.);\n  footDist = 1.1;\n  for (int m = 0; m < 6; m ++) {\n    footPos[m].xz = footDist * sin (pi * (2. * float (m) + 1.) / 6. + vec2 (0.5 * pi, 0.));\n    footPos[m].y = - bdyPos.y;\n  }\n  footSpeedV = 0.;\n  footDir = 0.;\n  stepCount = 0.;\n  stepLim = 0.;\n  wkPhase = 0.;\n  wkChange = 0.;\n  walking = 0.;\n  walkDir = - 0.5 * pi;\n  turnDir = 0.;\n  turnDirN = 0.;\n}\n\nvoid SetMode (int m)\n{\n  if (m == 0) {\n    turnDirN = 0.;\n    if (walking == 0.) wkChange = 1.;\n  } else if (m == 1) {\n    turnDirN = 0.;\n    if (walking != 0.) wkChange = 1.;\n  } else if (m == 2) {\n    turnDirN = 1.;\n    if (turnDir != turnDirN && walking == 0.) wkChange = 1.;\n  } else if (m == 3) {\n    turnDirN = -1.;\n    if (turnDir != turnDirN && walking == 0.) wkChange = 1.;\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[4], mPtr, mPtrP, stDat, w1, w2;\n  vec2 canvas, iFrag;\n  float asp, el, az, autMode, tChMode;\n  int pxId, wgSel, wgReg, im;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 12) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  wgReg = -2;\n  doInit = false;\n  autMode = 1.;\n  tChMode = tCur;\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    az = 0.;\n    el = 0.;\n    wgSel = -1;\n    doInit = true;\n  } else {\n    for (int k = 0; k < 6; k ++) {\n      stDat = Loadv4 (k);\n      footPos[k] = stDat.xyz;\n    }\n    stDat = Loadv4 (6);\n    bdyPos = stDat.xyz;\n    walkDir = stDat.w;\n    stDat = Loadv4 (7);\n    walking = stDat.x;\n    footDir = stDat.y;\n    turnDir = stDat.z;\n    turnDirN = stDat.w;\n    stDat = Loadv4 (8);\n    stepCount = stDat.x;\n    stepLim = stDat.y;\n    wkPhase = stDat.z;\n    wkChange = stDat.w;\n    stDat = Loadv4 (9);\n    footSpeedV = stDat.x;\n    bdyRad = stDat.y;\n    bdyHt = stDat.z;\n    tChMode = stDat.w;\n    stDat = Loadv4 (10);\n    az = stDat.x;\n    el = stDat.y;\n    wgSel = int (stDat.z);\n    autMode = stDat.w;\n    mPtrP = Loadv4 (11);\n  }\n  asp = canvas.x / canvas.y;\n  if (mPtr.z > 0.) {\n    w1 = vec4 (0.42 * asp, -0.35, 0.025, 0.);\n    w2 = vec4 (0.06, 0., 0., 0.);\n    wgBx[0] = w1 + w2.yxzw;\n    wgBx[1] = w1 - w2.yxzw;\n    wgBx[2] = w1 - w2;\n    wgBx[3] = w1 + w2;\n    for (int k = 0; k < 4; k ++) {\n      if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) < wgBx[k].z) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    az = 0.02 * pi * tCur;\n    el = -0.15 * pi + 0.07 * pi * sin (0.033 * pi * tCur);\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {   \n      az = 2. * pi * mPtr.x;\n      el = -0.1 * pi + pi * mPtr.y;\n      el = clamp (el, -0.4 * pi, -0.01 * pi);\n    }\n  } else if (mPtrP.z <= 0.) {\n    autMode = 0.;\n    tChMode = tCur + 10.;\n    SetMode (wgSel);\n  }\n  if (tCur > tChMode) autMode = 1.;\n  if (autMode != 0. && tCur > tChMode) {\n    tChMode = tCur + 2.;\n    im = int (100. * Hashff (17. * tChMode));\n    tChMode += 3. * Hashff (23. * tChMode);\n    if (im < 60) im = 0;\n    else if (im < 75) im = 2;\n    else if (im < 90) im = 3;\n    else im = 1;\n    SetMode (im);\n  }\n  if (doInit) Init ();\n  else Step ();\n  if (pxId < 6) {\n    for (int k = 0; k < 6; k ++) {\n      if (pxId == k) stDat = vec4 (footPos[k], 0.);\n    }\n  }\n  else if (pxId == 6) stDat = vec4 (bdyPos, walkDir);\n  else if (pxId == 7) stDat = vec4 (walking, footDir, turnDir, turnDirN);\n  else if (pxId == 8) stDat = vec4 (stepCount, stepLim, wkPhase, wkChange);\n  else if (pxId == 9) stDat = vec4 (footSpeedV, bdyRad, bdyHt, tChMode);\n  else if (pxId == 10) stDat = vec4 (az, el, float (wgSel), autMode);\n  else if (pxId == 11) stDat = mPtr;\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBzw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1120, 1120, 1137, 1137, 1668], [1670, 1670, 1704, 1704, 4390], [4392, 4392, 4414, 4414, 4661], [4663, 4663, 4696, 4696, 4880], [4882, 4882, 4903, 4903, 5155], [5157, 5157, 5206, 5206, 5479], [5481, 5481, 5538, 5538, 6392], [6394, 6394, 6410, 6410, 7726], [7770, 7770, 7805, 7805, 9582], [9584, 9584, 9640, 9640, 10837], [10839, 10839, 10885, 10885, 10932], [10934, 10934, 10967, 10967, 10994], [10996, 10996, 11038, 11038, 11089], [11091, 11091, 11148, 11148, 11224], [11226, 11226, 11272, 11272, 11329], [11331, 11331, 11376, 11376, 11479], [11481, 11481, 11526, 11526, 11564], [11566, 11566, 11623, 11623, 11706], [11708, 11708, 11738, 11738, 11851], [11853, 11853, 11889, 11889, 12095], [12097, 12097, 12121, 12121, 12238], [12272, 12272, 12296, 12296, 12426], [12428, 12428, 12453, 12453, 12639], [12641, 12641, 12662, 12662, 12817], [12911, 12911, 12936, 12936, 13059]], "test": "untested"}
{"id": "3lVfRw", "name": "gamma correction tester", "author": "Ric3cir121", "description": "drag the mouse along the y axis to change gamma until the right color match the left one", "tags": ["light", "gamma", "correction", "gammacorrection", "monitor"], "likes": 0, "viewed": 237, "published": 3, "date": "1614085209", "time_retrieved": "2024-07-30T19:36:28.062091", "image_code": "void mainImage(out vec4 o,vec2 u){\n    ivec2 me = ivec2(u);\n    int pos = (me.x+me.y/2)%2;\n    o = pos==1?vec4(1,0,1,0):vec4(0,1,0,0);\n    if(u.x+u.x<iResolution.x)o=pow(vec4(.5),1./vec4(iMouse.y/iResolution.y*2.+1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 220]], "test": "untested"}
{"id": "wlyfzw", "name": "blur pyramid 2 - distance field", "author": "FabriceNeyret2", "description": "Paint, and display the weighted sum of MIPmaps. Curves = local grey level.\n\nWIP - test ( power-of-2 version for correct MIPmaps ).\nFinal goal is auto-built of distance field using MIPmap.\n", "tags": ["distancefield", "sdf", "bloom", "pyramid", "gpmipmap"], "likes": 4, "viewed": 364, "published": 3, "date": "1614069895", "time_retrieved": "2024-07-30T19:36:28.830037", "image_code": "// CubeMap version of https://www.shadertoy.com/view/wtyfRw\n// CubeMap management from https://shadertoy.com/view/3tGfzW\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 U = map( u , R );\n\n#define S(v)     smoothstep( 1.5, 0., abs(v)/fwidth(v) )\n#define sqr(v) ( (v)*(v) )\n    O-=O;\n    float L = 10.; // floor(log2(iChannelResolution[0].y));\n    for (float l = 0.; l < L; l++ )\n        O +=    (l+1.)   * T( U, l );\n     // O += sqr(l+1.)/L * T( U, l );\n         \n // O /= L;\n // O = .5+.5*sin(10.*O);\n    float  x = fract(u.x/40.),\n           y = fract(u.y/40.),\n          vx = S( x - O.x/L ),\n          vy = S( y - O.x/L ),\n           g = vx+vy<.5 ? S( min( x, y) ) : 0.; \n    O = mix( min(O,1.),  vec4(vy,vx,g,0), max(max(vx,vy),g) );\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R              iResolution.xy\n#define T(U,l)         textureLod( iChannel0, vec3( 2.*(U)/1024. -1., 1 ).xzy , l+0. )\n//#define D(C,r)       smoothstep( 1.5, 0., length(C-U) - r )           // antialiased disk\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define map(U,R)     ( 1024.*( .56* ( U - .5*R ) / R.y + .5 ) )", "cube_a_code": "void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    if (D.y > max(abs(D.x),abs(D.z))) {       // --- side 1 -------------\n    \n        vec2 s = iChannelResolution[1].xy,    // screen resolution\n             M = map( iMouse.xy , s );\n\n        O = max( T(U,) , smoothstep( 3.,0., length(U-M) ) );\n        \n        U = U/1024.*2.-1.;\n     // if ( min(U.x,U.y) > 0. ) O = .02*texture(iChannel2,U);  // cheap blur\n     // if ( min(U.x,U.y) > 0. ) O = .3*abs(texture(iChannel2,U) - texture(iChannel2,U,1.));\n     }\n}\n\n", "cube_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// guess what is the purpose of this buffer ;-)\nvoid mainImage( out vec4 O, vec2 U ) {}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 160, 160, 741]], "test": "untested"}
{"id": "wtyfRw", "name": "blur pyramid - distance field", "author": "FabriceNeyret2", "description": "Paint, and display the weighted sum of MIPmaps. Curves = local grey level.\n\nWIP - test ( won't work properly on systems with wrong MIPmap, like windows... and linux at some resolutions ).\nFinal goal is auto-built of distance field using MIPmap.\n", "tags": ["distancefield", "sdf", "pyramid", "gpmipmap"], "likes": 5, "viewed": 369, "published": 3, "date": "1614066938", "time_retrieved": "2024-07-30T19:36:29.601974", "image_code": "#define S(v)  smoothstep( 1.5, 0., abs(v)/fwidth(v) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    float L = floor(log2(R.y));\n    for (float l = 0.; l < L; l++ )\n         O += (l+1.)*textureLod(iChannel0, U/R, l);\n         \n // O /= L;\n // O = .5+.5*sin(10.*O);\n    float vx = S( fract(U.x/40.) - O.x/L ),\n          vy = S( fract(U.y/40.) - O.x/L );\n    O = mix( min(O,1.),  vec4(vy,vx,0,0), max(vx,vy) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = max( T(U) , smoothstep( 3.,0., length(U-iMouse.xy) ) );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 93, 93, 417]], "test": "untested"}
{"id": "ttVBzR", "name": "Area-Preserving Disk<->Sphere", "author": "TinyTexel", "description": "An invertible, area-preserving mapping from the unit disk to the unit sphere.\n\nleft:  unit disk with a checkerboard pattern where each cell has the same area + a number of random points\nright: pattern + points shown on the left mapped to the unit sphere", "tags": ["sphere", "map", "sampling", "mapping", "disk", "unitdisk", "unitsphere"], "likes": 16, "viewed": 731, "published": 3, "date": "1614063253", "time_retrieved": "2024-07-30T19:36:30.553429", "image_code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\n\nAn invertible, area-preserving mapping from the unit disk to the unit sphere.\n\nleft:  unit disk with a checkerboard pattern where each cell has the same area + a number of random points\nright: the pattern + the points shown on the left mapped to the unit sphere in an area-preserving manner\n\nSpace - toggle points off/on\nTab   - toggle checkerboard pattern off/on\nCtrl  - toggle animation of points on/off\nShift - toggle between sampling the whole sphere and just a spherical cap\n        A/D - controls polar angle of spherical cap\n\nCamera controls via mouse.\n\nDerivation:\nGiven a point u on the unit disk the idea is to feed normalize(u) and length(u)² into the following sampling routine: */\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng05..1]\n// samples hemisphere if s1 [0..1]\nvec3 SampleSphere(float s0, float s1)\n{\n    float phi = s0 * Pi;\n    \n    float cosPhi = cos(phi);\n    float sinPhi = sin(phi);\n    \n    float cosTheta = s1;\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    \n    return vec3(cosPhi * sinTheta, \n                         cosTheta, \n                sinPhi * sinTheta);\n}\n\n/*\nAs we can see s0 is just the angle phi divided by Pi. So we can replace cosPhi and sinPhi by the x and y coords of normalize(u).\ns1 is the cosine of theta and ranges from -1 to 1. So we first square length(u) to get a uniformly distributed value between 0 and 1.\nWe then expand its range to -1 to 1 by a simple linear mapping: cosTheta = 1.0 - 2.0 * dot(u, u);\nOur sampling routine looks this now:\n*/\n\n// u [-1,1]²\nvec3 _SphereFromDisk(vec2 u)\n{\n    vec2 dir = normalize(u);\n    \n    float cosPhi = dir.x;\n    float sinPhi = dir.y;\n    \n    float cosTheta = 1.0 - 2.0 * dot(u, u);\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    \n    return vec3(cosPhi * sinTheta, \n                         cosTheta, \n                sinPhi * sinTheta);\n}\n\n/*\nWe can now apply a series of optimization steps:\n*/\n// u [-1,1]²\nvec3 _SphereFromDisk_(vec2 u)\n{\n    float cosTheta = 1.0 - 2.0 * dot(u, u);\n\n   #if 0\n   // 1. fold the normalization of u and the multiplication with sinTheta into a single factor l\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    float l = (1.0/sqrt(dot(u, u))) * sinTheta;\n   #elif 0\n   // 2. move sinTheta inside the sqrt()\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    float l = sqrt((sinTheta * sinTheta) / dot(u, u));\n   #elif 0\n   // 3. insert the expressions of cosTheta and sinTheta..\n    float l = sqrt((1.0 - (1.0 - 4.0*dot(u,u) + 4.0*dot(u,u)*dot(u,u))) / dot(u, u));\n   #elif 1\n   // 4. ..and simplify\n    float l = sqrt(4.0 - 4.0 * dot(u,u));\n   #endif\n   \n    return vec3(u.x * l, \n               cosTheta, \n                u.y * l);\n}\n\n/*\nAs we can see the optimized result is pretty compact.\nIts inversion even more so; it is just one-liner: s.xz * inversesqrt(s.y * 2.0 + 2.0);\n\nInstead of mapping to the whole sphere we can also restrict the map to a spherical cap.\nWe do this by scaling u before feeding it into the routine: u *= sqrt(1.0 - cosAng).\n\nOne practical use case for this mapping is to sample the solid angle subtended by a spherical light source using a low discrepancy sequence. \nTo do this we would first map the LDS output to the unit disk using an area-preserving mapping like the concentric mapping: \nhttp://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\n(or this one https://www.shadertoy.com/view/wtcfWl; although the concentric one causes less extreme distortions).\nThe advantage of this approach is that we potentialy distort our LDS points less compared to feeding them directly into SampleSphere(s0, s1).\nThis does, however, also depend on the type of LD sequence and the size of the polar angle of the spherical cap \n(smaller angles work better; the mapping quality gets worse towards the south pole).\n\nA good strategy for sampling the entire unit sphere seems to be to only sample the upper hemisphere (cosAng=0) and then \nfor every other sample to not actually generate a new LDS point but to just reuse the last one multiplied with -1 \n(placing it not only as far away from the previous point as possible but also putting it in the lower hemisphere).\n\n\nThe mapping is area-preserving when the determinant of its Jacobian matrix is constant.\nThe following Mathematica code performs the necessary computations to verify this:\n\ns := Sqrt[1 - c]\nmap[x_, y_] := {s x Sqrt[2 - (x x + y y) s s], 1 - (x x + y y) s s, \n  s y Sqrt[2 - (x x + y y) s s]}\nphi := ArcTan[map[x, y][[1]], map[x, y][[3]]]\ncosTheta := map[x, y][[2]]\nmap2[x_, y_] := {phi, cosTheta}\ndet[x_, y_] = \n FullSimplify[\n  Det[{{D[map2[x, y][[1]], x], \n     D[map2[x, y][[2]], x]}, {D[map2[x, y][[1]], y], \n     D[map2[x, y][[2]], y]}}]]\n     \nThis code evaluates to 2-2c (c is the cosine of the polar angle of the spherical cap (c=cos(Pi)=-1 if we map to the entire unit sphere)     \n*/\n\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_TAB 9\n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n\nvec3 SphereFromDisk(vec2 u)\n{\n    float d = dot(u, u);\n    float l = sqrt(4.0 - 4.0 * d);\n    \n    return vec3(u.x * l, \n          1.0 - 2.0 * d, \n                u.y * l);\n}\n\nvec3 SphericalCapFromDisk(vec2 u, float cosAng)\n{\n    u *= sqrt(1.0 - cosAng);\n    \n    float d = dot(u, u);\n    float l = sqrt(2.0 - d);\n    \n    return vec3(u.x * l, \n                1.0 - d, \n                u.y * l);\n}\n\nvec2 DiskFromSphere(vec3 s)\n{\n    return s.xz * inversesqrt(s.y * 2.0 + 2.0);\n}\n\n\n// checkerboard test texture\nvec3 SampleDiskTexture(vec2 u)\n{\n    float mC = clamp01(rescale(1.0-dot(u,u))-0.5);\n    \n   #if 1\n    float r = dot(u, u);\n   #else\n    float r = length(u);\n   #endif\n   \n    float n = sin(-r*8.0*Pi);\n\n    float mA = sin(-r*2.0*Pi);\n\n    n *= u.x*u.y;\n    n *= (u.x+u.y)*(u.x-u.y)*0.5;\n\n    vec2 k = cmul(u, Pi*0.125);\n\n    n *= k.x*k.y;\n    n *= (k.x+k.y)*(k.x-k.y)*0.5;\n\n    u.x = rescale(u.x)*0.5+0.+0.5;\n    u.x = clamp01(u.x+0.25);\n\n    u.y = rescale(u.y)*0.5+0.+0.5;\n    u.y = clamp01(u.y-0.25);\n\n    mA = rescale(mA)*0.5+0.+0.5;\n    mA = clamp01(mA+0.25);\n\n    n = rescale(n)*0.5+0.5;\n    n = cubic(cubic(clamp01(n)));\n\n    vec3 col = vec3(0.0);\n\n    col  = mix(vec3(1.0, 0.125, 0.125), vec3(0.125, 0.  , 1.0  ), u.x);\n    col += mix(vec3(0.0, 0.   , 0.25 ), vec3(0.   , 0.25, 0.125), u.y);\n    \n    col = mix(col.rgb, vec3(1.0), mix(0.5, 0., mA));\n    col *= max(0.05, n);\n\n    if(ReadKeyToggle(KEY_TAB) != 0.0) col.rgb = vec3(0.01);\n\n    col *= mC;\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n    vec2 uv = uv0 - 0.5;\n    vec2 tc = uv0/iResolution.xy;\n\n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n    float angAccuLast = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n        \n    col = vec4(0.0);\n    \n    float l = iResolution.x*0.5;\n    \n    uv0.y -= max(0.0, (iResolution.y-l)*0.5);\n    \n    vec2 u = vec2(0.0);\n    vec3 s = vec3(0.0);\n    float mask = 1.0;\n    \n    bool isLeft = uv0.x < l;\n    \n    if(isLeft)// LEFT\n    {\n        vec2 tc = uv0 / l;\n        \n        u = tc * 2.0 - 1.0;\n        \n        if(abs(u.x) > 1.01 || abs(u.y) > 1.01) return;\n        \n    }\n    else // RIGHT\n    {\n        vec2 tc = (uv0-vec2(l,0.0)) / l;\n        \n        vec2 p0 = tc * 2.0 - 1.0;\n        \n        if(abs(p0.x) > 1.01 || abs(p0.y) > 1.01) return;\n    \n        vec2 ang = vec2(Pi * -0.5, -Pi * 0.23);\n        ang += mouseAccu.xy * 0.008;\n\n        mat3 cmat;\n        {\n            float sinPhi   = sin(ang.x);\n            float cosPhi   = cos(ang.x);\n            float sinTheta = sin(ang.y);\n            float cosTheta = cos(ang.y);    \n\n            vec3 front = vec3(cosPhi * cosTheta, \n                                       sinTheta, \n                              sinPhi * cosTheta);\n\n            vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n\n            vec3 up    = vec3(-cosPhi * sinTheta,\n                                        cosTheta,\n                              -sinPhi * sinTheta);\n\n            cmat = mat3(right, up, front);\n        }\n\n        float cdist = exp2(-0.5 + mouseAccu.w * 0.02);\n        vec3 cpos = -cmat[2] * cdist;\n\n        float focalLen = 2.0;// = 0.5 * tan(Pi05 - fov * 0.5)\n        vec3 rd = normalize(cmat * vec3(p0, focalLen));\n        \n        vec2 t;\n        Intersect_Ray_Sphere(cpos, rd, vec3(0.0), 0.095, t);\n        \n        vec3 N = normalize(cpos + rd * t.x);\n        \n        s = N;\n        s.z = -s.z;// swap to left-handed to make side-by-side comparison easier\n                    \n        u = DiskFromSphere(s);\n        \n        mask = clamp01(rescale(1.0-dot(p0,p0)*1.065)-0.5);\n        mask *= dot(N, -rd)*0.5+0.5;\n    }\n\n    col.rgb = SampleDiskTexture(u);\n\n    if(ReadKeyToggle(KEY_SPACE) == 0.0)\n    {\n        uint count = 64u;\n\n        float m = -1024.0;\n        for(uint i = 0u; i < count; ++i)\n        {\n            uint j = i + 1033u;\n            \n            if(ReadKeyToggle(KEY_CTRL) != 0.0)\n            j += uint(iFrame)*(count/8u);\n\n            // 2d Roberts LDS\n            vec2 p = vec2(j * uvec2(2447445413u, 3242174889u)) * (1.0/4294967296.0);\n            \n           #if 1\n            {\n                // jitter points\n                float ang = float(WellonsHash(j))*(Pi*2.0/4294967296.0);\n\n                p = fract(p + vec2(cos(ang), sin(ang)) * 0.03);\n            }\n           #endif\n\n            vec2 u0 = DiskFromSquare(p * 2.0 - 1.0);\n            \n            float pt;\n            if(isLeft)\n            {\n                vec2 vec = u0 - u;\n                pt = 1.0-dot(vec, vec)*(64.0*64.0);\n            }\n            else\n            {\n                vec3 vec = SphereFromDisk(u0) - s;\n                \n                if(ReadKeyToggle(KEY_SHIFT) != 0.0)\n                vec = SphericalCapFromDisk(u0, cos(angAccuLast))-s;\n                \n                pt = 1.0-dot(vec, vec)*(64.0*64.0);\n            }\n            \n            m = max(m, pt);\n        }\n        \n        col.rgb *= 1.0-clamp01(rescale(m+8.0))*0.9;\n        col.rgb += clamp01(rescale(m+.0))*0.8;\n    }\n    \n    col.rgb *= mask;\n        \n    col.rgb = GammaEncode(clamp(col.rgb, 0.0, 1.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define clamp11(x) clamp(x,-1.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\nconst float Pi025 = Pi * 0.25;\nconst float Phi    = 1.61803399;\nconst float PhiRcp = 0.61803399;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nvec2 cmul(vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\n\n// http://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\nvec2 DiskFromSquare(vec2 p) \n{\n    float phi, r;\n\n    if (abs(p.x) > abs(p.y))\n    { \n        r = p.x;\n        phi = Pi025 * (p.y / p.x);\n    } \n    else \n    {\n        r = p.y;\n        phi = Pi05 - Pi025 * (p.x / p.y);\n    }\n    \n    return r * vec2(cos(phi), sin(phi));\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nbool Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n    bool didHit = D >= 0.0;\n    \n\tif(!didHit) D = 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n        \n    return didHit;\n}", "buffer_a_code": "/* program state */\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    if(uv0.y != 0.5) discard;\n    \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    vec4 iMouseLast      = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast  = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast    = texelFetch(iChannel0, ivec2(2, 0), 0);\n    float angAccuLast = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    float angAccu = clamp(angAccuLast + (kD - kA)*0.05, 0.0, Pi);\n    \n    if(iFrame == 0 || iFrame == 1) angAccu = Pi * 0.25;\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n    if(uv.x == 3.0 && uv.y == 0.0) col = vec4(angAccu);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVBzR.jpg", "access": "api", "license": "cc0-1.0", "functions": [[930, 1037, 1076, 1076, 1361], [1768, 1782, 1812, 1812, 2114], [2116, 2185, 2216, 2216, 2953], [5202, 5202, 5236, 5236, 5290], [5293, 5293, 5322, 5322, 5467], [5469, 5469, 5518, 5518, 5691], [5693, 5693, 5722, 5722, 5772], [5775, 5804, 5836, 5836, 6784], [6787, 6787, 6830, 6830, 10445]], "test": "untested"}
{"id": "WtGfRm", "name": "Growing Blood", "author": "oneshade", "description": "Its growing blood! Draw more with the mouse.", "tags": ["2d", "red", "blood", "reactiondiffusion", "glowing", "growing"], "likes": 3, "viewed": 249, "published": 3, "date": "1614051457", "time_retrieved": "2024-07-30T19:36:31.411136", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ab = texture(iChannel0, fragCoord / iResolution.xy).xy;\n    fragColor = vec4(ab.y * 3.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Algorithm from https://www.karlsims.com/rd.html\n#define Da 0.8 // Diffusion rate of A\n#define Db 0.4 // Diffusion rate of B\n#define f 0.01 // Feed rate\n#define k 0.035 // Kill rate\n#define dt 1.4 // Time step\n\n// Convolution weights\nconst mat3 weights = mat3(0.05,  0.2, 0.05,\n                          0.20, -1.0, 0.20,\n                          0.05,  0.2, 0.05);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 ab;\n    if (iFrame == 0) {\n        ab = texture(iChannel1, fragCoord / iResolution.xy).xy;\n    }\n\n    if (iFrame > 0) {\n        ab = texelFetch(iChannel0, iFragCoord, 0).xy;\n        vec2 laplacian = vec2(0.0);\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                ivec2 offs = ivec2(i, j);\n                vec2 c = texelFetch(iChannel0, iFragCoord + offs, 0).xy; // Neighboring cell\n                float w = weights[j + 1][i + 1]; // Weight\n                laplacian += c * w; // Weighted sum\n            }\n        }\n\n        ab.x += (Da * laplacian.x - ab.x * ab.y * ab.y + f * (1.0 - ab.x)) * dt; // Update A\n        ab.y += (Db * laplacian.y + ab.x * ab.y * ab.y - (k + f) * ab.y) * dt; // Update B\n    }\n\n    if (length(fragCoord - iMouse.xy) < 10.0 && iMouse.z > 0.0) {\n        ab.y += 0.01;\n    }\n\n    fragColor = vec4(ab, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 171]], "test": "untested"}
{"id": "Wlyfzw", "name": "Oriental rug", "author": "jarble", "description": "This fractal pattern looks like an oriental rug!", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 435, "published": 3, "date": "1614043983", "time_retrieved": "2024-07-30T19:36:32.291782", "image_code": "//vec3 c1 = vec3(7.0,5.0,1.4); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.0,9.0,1.4);\nvec3 c1 = vec3(2.0,2.5,1.4); //looks like a carpet\n//vec3 c1 = vec3(1.7,1.9,1.3);\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .16;\n    float scale2 = 1.02;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;   \n        for(int i=0;i<6;i++)\n        {          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n            scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlyfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 235, 235, 280], [282, 282, 339, 339, 978]], "test": "untested"}
{"id": "3lyfzw", "name": "Neural Fox", "author": "PauloFalcao", "description": "A fox\n\nMade using blackle https://www.shadertoy.com/view/wtVyWK\nAnd this wonderful tutorial https://www.youtube.com/watch?v=8pwXpfi-0bU\n\nUsing Ida Faber model - CC Attribution\nhttps://sketchfab.com/3d-models/stylized-fox-92c2a35e54664974b8564c674cc712da\n", "tags": ["neural", "fox", "neuralnetworks"], "likes": 30, "viewed": 736, "published": 3, "date": "1614043700", "time_retrieved": "2024-07-30T19:36:33.132534", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// Model trained by PauloFalcao\n//\n// Made using blackle https://www.shadertoy.com/view/wtVyWK\n// And this wonderful tutorial https://www.youtube.com/watch?v=8pwXpfi-0bU\n//\n// Using Ida Faber model - CC Attribution - https://creativecommons.org/licenses/by/4.0/\n// https://sketchfab.com/3d-models/stylized-fox-92c2a35e54664974b8564c674cc712da\n//\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    p.y=-sqrt(p.y*p.y+0.001)+0.01;\n    //neural networks can be really compact... when they want to be\nvec4 f0_0=sin(p.y*vec4(1.627,-3.273,.822,-1.929)+p.z*vec4(4.114,.716,-3.074,2.185)+p.x*vec4(2.235,.937,3.908,-1.072)+vec4(6.915,3.461,-1.359,1.899));\nvec4 f0_1=sin(p.y*vec4(-.001,-3.255,1.831,.966)+p.z*vec4(-3.328,.890,1.475,-.323)+p.x*vec4(.290,-1.169,-4.054,3.146)+vec4(-4.517,-2.674,6.099,.070));\nvec4 f0_2=sin(p.y*vec4(3.113,-1.089,2.397,-.459)+p.z*vec4(-4.309,1.202,1.134,2.052)+p.x*vec4(-1.018,.550,-3.955,4.027)+vec4(-7.136,2.863,-1.640,-5.590));\nvec4 f0_3=sin(p.y*vec4(.343,1.509,4.401,-1.962)+p.z*vec4(1.198,1.852,2.207,-4.658)+p.x*vec4(2.067,.056,-.156,-.631)+vec4(-4.943,.051,7.095,3.128));\nvec4 f1_0=sin(mat4(.234,.264,-.181,.015,1.018,-.023,.417,-.338,.527,-.030,.056,-.005,-.843,.446,-.139,-.079)*f0_0+\n    mat4(-.512,.346,-.264,.380,.135,.249,.118,-.188,-.110,.210,.101,-.157,.126,.259,.262,.446)*f0_1+\n    mat4(.595,.318,.262,-.279,.802,.891,-.050,-.347,.131,-.369,.420,-.025,-.217,-.197,.152,.931)*f0_2+\n    mat4(.522,.906,-.530,.246,.685,.684,-.106,.175,.437,.507,-.459,.127,.342,-.398,-.243,.008)*f0_3+\n    vec4(.376,-.814,1.500,-1.007))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.124,.489,-.159,-.094,.099,.611,-.257,-.614,-.108,.309,-.121,-.389,.049,-.606,.030,-.723)*f0_0+\n    mat4(.511,.456,-.645,-1.008,.009,-.461,-.198,-.754,.978,.413,-.641,-.412,-1.068,-.308,.291,-.170)*f0_1+\n    mat4(.428,-.220,-.163,-.356,.744,.548,.221,.563,.242,-.214,-.224,-.567,.391,.045,-.061,-.186)*f0_2+\n    mat4(-.001,-.252,.747,-.435,.539,.003,-.305,-.643,-.261,.164,-.336,.295,.383,-.395,-.136,-.008)*f0_3+\n    vec4(-1.007,-1.304,1.076,1.194))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.502,.308,-.174,.023,-.560,-.534,.624,-.555,.309,.630,-.122,.310,.368,.878,-.206,-.350)*f0_0+\n    mat4(.684,.334,-.702,.420,-.698,.960,-.053,-.676,-.272,.365,-.074,.407,-.375,.202,.532,-.207)*f0_1+\n    mat4(-.116,-.269,.153,-.453,-.530,.488,-.724,.065,.405,.667,-.642,.043,-.103,.430,-.562,.346)*f0_2+\n    mat4(.472,-.026,-.433,.070,-.210,-.057,-.253,.310,-.344,.047,.386,.552,.246,-.111,.331,.350)*f0_3+\n    vec4(-.725,-1.197,.825,-3.455))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.027,.173,.253,-.822,-.478,.458,.101,.045,.025,.248,.759,.184,-.317,-.014,-.077,-.353)*f0_0+\n    mat4(-.283,-.201,.219,-.248,-.571,-.458,.401,-.226,.432,.245,-.160,-.065,-.421,-1.315,-.569,-.520)*f0_1+\n    mat4(.313,-.258,.291,-.284,-.732,.295,-.087,-.441,.836,-.701,.566,.889,-.116,-.252,-.542,-.396)*f0_2+\n    mat4(-.381,-.907,.516,.431,-.273,.257,.027,-.179,-.214,.077,-.130,-.282,-.368,-.270,.618,-.041)*f0_3+\n    vec4(2.580,-.950,1.416,.227))/1.0+f0_3;\nvec4 f2_0=sin(mat4(.288,.277,.179,.290,-.968,-1.492,.495,-.421,.153,-.177,.580,-.388,.971,-.335,.007,.032)*f1_0+\n    mat4(-.194,-.137,.202,.157,-.160,1.025,-.550,-.053,.485,.030,-.537,.065,.021,-.384,-.109,-.452)*f1_1+\n    mat4(-.748,.241,.386,-.441,-.620,-.869,.559,.681,.367,.256,-.459,-1.047,.260,.241,-.793,.494)*f1_2+\n    mat4(-.958,-.093,-.110,-.074,-.260,-.856,.521,.613,-.562,.079,.238,.056,-.413,-1.011,.118,-.104)*f1_3+\n    vec4(.980,1.564,-2.935,-.589))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.181,.166,-.082,.469,.474,.703,.969,.559,.998,-.016,.193,-.363,.452,.152,.543,-.394)*f1_0+\n    mat4(-.711,-.586,.015,.459,.404,.538,.575,-.249,-.562,-.484,.549,.673,-1.160,.144,-.010,-.093)*f1_1+\n    mat4(.663,.424,.164,.089,1.168,.000,.636,-.309,.088,-.779,.352,-.722,-1.071,-.059,-.089,.310)*f1_2+\n    mat4(-.156,-.515,.176,-.125,.034,.431,.367,.228,.394,.263,.039,.195,1.077,.460,-.456,-.031)*f1_3+\n    vec4(.495,.756,-2.986,-1.239))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.586,-.569,-.492,-.407,-.224,-.624,.373,-.080,-.216,.279,.704,.072,-.780,-.607,.575,.568)*f1_0+\n    mat4(.070,-.760,.980,.566,-.124,-.326,.463,.559,-.297,.161,-.449,-.236,-.369,-.591,-.190,-.548)*f1_1+\n    mat4(.054,.276,-.894,-.120,.795,1.111,-.473,.031,.387,.292,.974,1.024,.150,.184,.253,-.287)*f1_2+\n    mat4(.435,1.658,.294,-.403,-.377,.175,-.493,.204,-.499,-.614,.119,-.557,-.799,-.168,-.481,-.192)*f1_3+\n    vec4(-2.130,-2.233,-.605,-3.251))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.884,.369,.064,-.009,.434,.437,-.618,.117,.046,-.601,-.376,-.182,1.130,-.913,-.029,.602)*f1_0+\n    mat4(.314,-1.064,.861,-.572,-.633,.111,-.122,-.179,.277,-.615,-.069,.678,.109,.024,-1.124,-.553)*f1_1+\n    mat4(.243,.009,.461,.333,-.624,-.670,.328,.350,1.132,-.523,-.099,.402,.183,.245,-.232,.186)*f1_2+\n    mat4(-.057,.076,.660,-.139,.729,.450,.109,-.177,.088,-.111,.020,-.546,-.487,-1.286,.100,.117)*f1_3+\n    vec4(.529,-2.910,3.311,2.936))/1.4+f1_3;\nreturn dot(f2_0,vec4(.021,-.057,.076,-.038))+\n    dot(f2_1,vec4(-.022,-.081,.064,-.063))+\n    dot(f2_2,vec4(-.049,-.057,.048,.076))+\n    dot(f2_3,vec4(.014,-.049,.060,.071))+\n    -0.010;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyfzw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[419, 419, 457, 457, 519], [521, 521, 542, 628, 5368], [5370, 5370, 5389, 5389, 5505], [5507, 5507, 5564, 5564, 6832]], "test": "untested"}
{"id": "tlVBzD", "name": "2D Reaction Diffusion", "author": "oneshade", "description": "First reaction diffusion shader.", "tags": ["2d", "diffusion", "reactiondiffusion"], "likes": 4, "viewed": 204, "published": 3, "date": "1614039107", "time_retrieved": "2024-07-30T19:36:33.982262", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ab = texture(iChannel0, fragCoord / iResolution.xy).xy;\n    fragColor = vec4(ab.x, ab.x, ab.x + ab.y, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Algorithm from https://www.karlsims.com/rd.html\n#define Da 1.0 // Diffusion rate of A\n#define Db 0.5 // Diffusion rate of B\n#define f 0.0545 // Feed rate\n#define k 0.062 // Kill rate\n#define dt 1.0 // Time step\n\n// Convolution weights\nconst mat3 weights = mat3(0.05,  0.2, 0.05,\n                          0.20, -1.0, 0.20,\n                          0.05,  0.2, 0.05);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec2 ab;\n    if (iFrame == 0) {\n        ab = texture(iChannel1, fragCoord / iResolution.xy).xy;\n    }\n\n    if (iFrame > 0) {\n        ab = texelFetch(iChannel0, iFragCoord, 0).xy;\n        vec2 laplacian = vec2(0.0);\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                ivec2 offs = ivec2(i, j);\n                vec2 c = texelFetch(iChannel0, iFragCoord + offs, 0).xy; // Neighboring cell\n                float w = weights[j + 1][i + 1]; // Weight\n                laplacian += c * w; // Weighted sum\n            }\n        }\n\n        ab.x += (Da * laplacian.x - ab.x * ab.y * ab.y + f * (1.0 - ab.x)) * dt; // Update A\n        ab.y += (Db * laplacian.y + ab.x * ab.y * ab.y - (k + f) * ab.y) * dt; // Update B\n    }\n\n    fragColor = vec4(ab, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 174]], "test": "untested"}
{"id": "3tyBzw", "name": "Gyro texture for gyro", "author": "illus0r", "description": "Raymarching as a texture for another raymarching", "tags": ["raymarching"], "likes": 5, "viewed": 294, "published": 3, "date": "1614036129", "time_retrieved": "2024-07-30T19:36:34.849942", "image_code": "mat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat sdSphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  return abs(dot(sin(p*.5), cos(p.zxy * 1.23)) - bias) / scale - thickness;\n}\nfloat dist(vec3 p){\n    //return length(vec2(length(p.xy)-.5,p.z))-.2;\n    float gyroid = sdGyroid(p, 10., .01, 0.) * .55;\n    return max(sdSphere(p, .75), gyroid)*.8;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(.001,0.);\n\treturn normalize(vec3(\n    \tdist(p+e.xyy)-dist(p-e.xyy),\n    \tdist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float d=0.,i,j,e=1.;\n    vec3 p_;\n    for(i=0.;i<99.&&e>.001;i++){\n            p=vec3(d*uv,d-3.);\n        p_ = p;\n        mat2 rotXZ = rot(iTime*.2);\n        mat2 rotXY = rot(iTime*.2);\n        p.xz*=rotXZ;\n        p.xy*=rotXY;\n\n        float gyroid = sdGyroid(p, 10., .01, 0.) * .55;\n        d+=e=max(sdSphere(p, 2.), gyroid)*.8;\n    }\n    fragColor += .4/d;\n    fragColor = clamp(fragColor, 0., 1.);\n    d=0.;\n    e=1.;\n    for(j=0.;j<99.&&e>.001;j++){\n            p=vec3(d*p_.xy,d-1.);\n            //p=mod(p,2.)-1.;\n            p.xz*=rot(-iTime);\n        d+=e=dist(p);\n    }\n\n    fragColor.rgb += clamp(norm(p)*.5+.5, 0., 1.);\n}\n\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [67, 67, 112, 112, 203], [207, 207, 245, 245, 276], [278, 278, 344, 344, 436], [437, 437, 456, 507, 606], [608, 608, 626, 626, 792], [796, 796, 853, 853, 1560]], "test": "untested"}
{"id": "WlGBzw", "name": "interference frenzy ", "author": "not_a_user", "description": "triangles forming waves forming triangles", "tags": ["2d", "simple", "quantum"], "likes": 4, "viewed": 244, "published": 3, "date": "1614033776", "time_retrieved": "2024-07-30T19:36:35.735574", "image_code": "#define KMAX 256 // increase for detail, decrease for frame rate\n#define PERIOD 600.0 // in seconds\n#define SKIP (1.0 / 5.0) // in PERIODs\n#define GAMMA (1.0 / 4.0) // \"inverse brightness\"\n\nvec2 omega(float k, float t)\n{\n    float p = k * k * t;\n    return vec2(sin(p), cos(p));\n}\n\nfloat psi(float k, vec2 s)\n{\n    return sin(k * s.y) - sin(k * s.x) - sin(k * (s.y - s.x));\n}\n\nvec2 phi(vec2 s, float t)\n{\n    vec2 p = vec2(0.0, 0.0);\n    for (int j = 1; j < KMAX; j++)\n    {\n        float k = float(j) * 6.2831853;\n        p += omega(k, t) * psi(k, s) / k;\n    }\n    return p;\n}\n\nvec4 color(vec2 p)\n{\n    vec2 s = p * p;\n\tfloat a = 3.1415926 * exp(GAMMA * log(s.x + s.y));\n    vec3 c = abs(vec3(p.xy, p.x - p.y));\n    return vec4(a * c, 1.0);\n}\n\nvec2 coord(vec2 c, vec2 r)\n{\n    return vec2\n    (\n        (c.x - ((r.x - r.y) / 2.0)) / r.y,\n        c.y / r.y\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = coord(fragCoord, iResolution.xy);\n    float t = (iTime / PERIOD + SKIP) / 6.2831853;\n    vec2 p = phi(s, t);\n    fragColor = color(p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 220, 220, 280], [282, 282, 310, 310, 375], [377, 377, 404, 404, 578], [580, 580, 600, 600, 744], [746, 746, 774, 774, 866], [868, 868, 925, 925, 1075]], "test": "untested"}
{"id": "WtGfRw", "name": "Acid Jelly", "author": "yozic", "description": "In my tooling I'm passing all of these #define declarations as uniforms and tweening between sets.", "tags": ["colorful", "psychedelic", "trippy", "gloop"], "likes": 24, "viewed": 900, "published": 3, "date": "1614030212", "time_retrieved": "2024-07-30T19:36:36.553388", "image_code": "#define PI 3.141592\n#define orbs 20.\n\n\n/*\n\nVariant 01 \n\n*/\n\n#define zoom 0.07\n#define contrast 0.13\n#define orbSize 6.46\n#define radius 11.\n#define colorShift 10.32\n#define sides 1.\n#define rotation 1.\n#define sinMul 0.\n#define cosMul 2.38\n#define yMul 0.\n#define xMul 0.28\n#define xSpeed 0.\n#define ySpeed 0.\n#define gloop 0.003;\n#define yDivide 4.99\n#define xDivide 6.27\n\n/*\n\nVariant 02\n\n#define zoom 0.27\n#define contrast 0.13\n#define orbSize 4.25\n#define radius 11.\n#define colorShift 10.32\n#define sides 1.\n#define rotation 1.\n#define sinMul 0.\n#define cosMul 2.38\n#define yMul 0.\n#define xMul 0.28\n#define xSpeed 0.\n#define ySpeed 0.\n#define gloop 0.003\n#define yDivide 11.\n#define xDivide 12.4\n\n*/\n\n/*\n\nVariant 03\n\n#define zoom 0.02\n#define contrast 0.13\n#define orbSize 11.\n#define radius 3.21\n#define colorShift 10.32\n#define sides 1.\n#define rotation 1.\n#define sinMul 0.\n#define cosMul 5.\n#define yMul 0.\n#define xMul 0.28\n#define xSpeed 0.\n#define ySpeed 0.\n#define gloop 0.003\n#define yDivide 10.99\n#define xDivide 12.\n\n*/\n\nvec4 orb(vec2 uv, float s, vec2 p, vec3 color, float c) {\n  return pow(vec4(s / length(uv + p) * color, 1.), vec4(c));\n}\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n  fragColor = vec4(0.);\n  uv *= zoom;\n  uv /= dot(uv, uv);\n  uv *= rotate(rotation * iTime / 10.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += sinMul * sin(uv.y * yMul + iTime * xSpeed) + cos(uv.y / yDivide - iTime);\n    uv.y += cosMul * cos(uv.x * xMul - iTime * ySpeed) - sin(uv.x / xDivide - iTime);\n    float t = i * PI / orbs * 2.;\n    float x = radius * tan(t);\n    float y = radius * cos(t + iTime / 10.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(.02 * uv.x + .02 * uv.y * vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / colorShift)) * 0.5 + 0.5;\n    fragColor += .65 - orb(uv, orbSize, position, 1. - color, contrast);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1037, 1037, 1094, 1094, 1157], [1159, 1159, 1181, 1181, 1231]], "test": "untested"}
{"id": "wtVfzD", "name": "Circuit board fractal 9", "author": "jarble", "description": "I found a fractal pattern that looks like a circuit board.", "tags": ["fractal", "circuit"], "likes": 3, "viewed": 321, "published": 3, "date": "1614027157", "time_retrieved": "2024-07-30T19:36:37.414087", "image_code": "vec2 c = vec2(7.0,5.0); //change this constant to get different patterns!\n//vec2 c = vec2(7.0,9.0);\n//vec2 c = vec2(2.0,2.5); //looks like a maze\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .16;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = 1.4;\n        \n        \n        \n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n            //uv.y *= -1.0;\n            scale /= scale2+col.x;\n            offset /= scale2;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 187, 187, 228], [230, 230, 287, 287, 953]], "test": "untested"}
{"id": "ttKBzD", "name": "Day 431", "author": "jeyko", "description": "FLASHING potate", "tags": ["blur", "reactiondiffusion", "dnb", "mdtmjvm", "sharpenfeedback"], "likes": 18, "viewed": 542, "published": 3, "date": "1614019063", "time_retrieved": "2024-07-30T19:36:38.182033", "image_code": "// blur and sharpen from https://www.shadertoy.com/view/MtdXW4\n\n// LOOKS BETTER ON 144 HZ\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C = C*0.;\n    \n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    //C += T1(U);\n    C = T1(U);\n    \n    \n    float md = kTimeCoeff;\n    float fac = fract(iTime*md*0.25);\n    \n    fac = pow(fac,10.5)*smoothstep(1.,0.96,fac);\n    C = mix(C.xxxx, C.yyyy,fac);\n    \n    //C = mix(C,T1(U).zxzy,dot(uv,uv)*0.1);\n\n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(U + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(U  + n1d*200. ,256.)),0).xyz;\n    \n    C.xyz = pow(max(C.xyz,0.), vec3(1.,1.,1.) + dot(uv,uv)*0.6);\n    \n    \n    \n    \n    C.xyz += smoothstep(1.,0.,length(C))*n*0.1;\n    \n    C.xyz -= smoothstep(0.,1.,length(C))*n*0.05;\n    \n    if(mod(iTime*kTimeCoeff,10.) < 1.){\n        C = 1. - C;\n    }\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    \n    U -= 0.5*R;\n    U *= 1. - fract(iTime*kTimeCoeff)*0.002;\n    U *= rot(0.1*pow(fract(iTime*kTimeCoeff*0.125/2.),17.1)*0.1);\n    \n    U += 0.5*R;\n    vec2 grad = getGradient( iChannel0, U, 3., 0, R);\n    vec2 grady = getGradient( iChannel0, U, 3., 1, R);\n    vec2 gradz = getGradient( iChannel0, U, 3., 2, R);\n    //vec2 gradw = getGradient( iChannel0, U, 3., 3, R);\n    \n    //grad *= rot(.2);\n    \n    U -= grad*.2*sin(iTime);\n    \n    float id = floor(iTime*kTimeCoeff/10.); \n    float md = mod(iTime*kTimeCoeff, 10.);\n    if(md < 1.){\n        if (id == 0.){\n            U -= grady*14.5;\n        \n        } else {\n            U -= gradz*14.5;\n    \n        }\n    }\n    \n    C = blur(iChannel0, U, R);\n\n    \n    if(iFrame%2100 == 0){\n    \n        C = 1. - C;\n    }\n    \n    \n    if(iFrame == 0){\n        C = T3(U*0.2);\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C = sharpen(iChannel0, U, R);\n    \n    vec2 uv = (U - 0.5*R)/R.y;   \n    \n    vec2 muv = (iMouse.xy - 0.5*R)/R.y;   \n    if(iMouse.z > 0.)\n        C = mix(C,pow(T2(U)*1.,vec4(5.)),smoothstep(0.01,0.,length(uv - muv) - .1));\n    \n    \n    vec4 r = texture(iChannel2,(vec2(iFrame%256,floor(float(iFrame)/256.)) + 0.5 )/256.).xyzw;\n    \n    if(iFrame % 40 < 2){\n        C = mix(C,vec4(0),\n                smoothstep(0.01,0.,sdSegment( uv, vec2(r.x,r.y)*2. - 1., vec2(r.z,r.w)*2. - 1. ) - 0.0\n            ));\n\n    }\n   \n}\n", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25473, "src": "https://soundcloud.com/sofasoundbristol/ssdigi010-dlr-ill-truth-cyclotron", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define R (iResolution.xy)\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n\n#define TT(u,T) texture(T,(u)/res)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n#define kTimeCoeff 60./167.85*4.\n\nvec2 getGradient(sampler2D tex, vec2 u, float offset, int channel, vec2 res){\n    return vec2(\n         TT(u + vec2(1,0)*offset,tex)[channel] - TT(u - vec2(1,0)*offset,tex)[channel],\n         TT(u + vec2(0,1)*offset,tex)[channel] - TT(u - vec2(0,1)*offset,tex)[channel]  \n    );\n}\n//#define Neighbordhood() vec4 me = T() \n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 sharpen(sampler2D channel,vec2 fragCoord, vec2 resolution){\n    float kernel [9];vec2 offset [9];\n    \n    vec2 step = vec2(1);\n    \n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    \n    kernel[0] = 0.0; kernel[1] = -0.25; kernel[2] = 0.0;\n    kernel[3] = -0.25; kernel[4] = 1.0; kernel[5] = -0.25;\n    kernel[6] = 0.0; kernel[7] = -0.25; kernel[8] = 0.0;\n    \n    vec4 sum = texture(channel, (fragCoord)/resolution);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, (fragCoord + offset[i])/resolution);\n        sum += color * kernel[i];\n    }\n    \n    sum = clamp(sum,0.,1.);\n    \n    return sum;\n}\n\nvec4 blur(sampler2D channel,vec2 fragCoord, vec2 resolution){\n    \n    float kernel [9];vec2 offset [9];\n\n     vec2 step = vec2(0.5);\n    \n    offset[0] = vec2(-step.x, -step.y);\n    offset[1] = vec2(0.0, -step.y);\n    offset[2] = vec2(step.x, -step.y);\n    \n    offset[3] = vec2(-step.x, 0.0);\n    offset[4] = vec2(0.0, 0.0);\n    offset[5] = vec2(step.x, 0.0);\n    \n    offset[6] = vec2(-step.x, step.y);\n    offset[7] = vec2(0.0, step.y);\n    offset[8] = vec2(step.x, step.y);\n    \n    kernel[0] = 1.0; kernel[1] = 1.0; kernel[2] = 1.0;\n    kernel[3] = 1.0; kernel[4] = 1.0; kernel[5] = 1.0;\n    kernel[6] = 1.0; kernel[7] = 1.0; kernel[8] = 1.0;\n    \n    vec4 sum = vec4(0);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 color = texture(channel, (fragCoord + offset[i])/resolution);\n        sum += color * kernel[i];\n    }\n    \n    sum /= 9.;\n    sum = clamp(sum,0.,1.);\n    \n    return sum;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 132, 132, 872]], "test": "untested"}
{"id": "wlVfzW", "name": "Raymarching as texture for raym…", "author": "illus0r", "description": "Raymarching as a texture for another raymarching", "tags": ["raymarching"], "likes": 9, "viewed": 400, "published": 3, "date": "1614014629", "time_retrieved": "2024-07-30T19:36:38.956961", "image_code": "mat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat dist(vec3 p){\n    return length(vec2(length(p.xy)-.5,p.z))-.2;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(.001,0.);\n\treturn normalize(vec3(\n    \tdist(p+e.xyy)-dist(p-e.xyy),\n    \tdist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\n\n//vec4 raymarch(vec2 uv){\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float d=0.,i,j,e=1.;\n    vec3 p_;\n    for(i=0.;i<99.&&e>.001;i++){\n            p=vec3(d*uv,d-3.);\n        p_ = p;\n        mat2 rotXZ = rot(iTime);\n        mat2 rotXY = rot(iTime);\n        p.xz*=rotXZ;\n        p.xy*=rotXY;\n        d+=e=sdRoundBox(p,vec3(1.3),0.);\n    }\n    fragColor += .4/d;\n    fragColor = clamp(fragColor, 0., 1.);\n    d=0.;\n    e=1.;\n    for(j=0.;j<99.&&e>.001;j++){\n            p=vec3(d*p_.xy,d-1.);\n            //p=mod(p,2.)-1.;\n            p.xz*=rot(-iTime);\n        d+=e=dist(p);\n    }\n\n    fragColor.rgb += clamp(norm(p)*.5+.5, 0., 1.);\n}\n\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [67, 67, 112, 112, 203], [206, 206, 225, 225, 276], [278, 278, 296, 296, 462], [496, 496, 553, 553, 1192]], "test": "untested"}
{"id": "wlVBRD", "name": "Reflection Tunnel (731 chars)", "author": "TheNosiriN", "description": "My attempt at golfing a raymarcher", "tags": ["reflection", "tunnel", "raymarch", "short", "golf", "golfed"], "likes": 3, "viewed": 347, "published": 3, "date": "1614013667", "time_retrieved": "2024-07-30T19:36:39.730892", "image_code": "#define v vec3\n#define n normalize\n#define T (iTime*7.)\n#define P(p) -vec2(sin((p+T)*.1), sin((p+T*.2)*.1))*10.\n\n// Tunnel sdf (try playing with it)\nfloat M(v p) {\n    p.xy-=P(p.z),\n    p.z = mod(p.z+T+1., 2.) - 1.,\n    p.yz = abs(p.yz)-.6, p.x = length(p.xy);\n    return max(max(p.x-2., -p.x+1.7), -max(p.y,p.z));\n}\n\n//ray marcher\nvec2 R(v s, v r) {\n    float t,i,d;\n    for (; i<1. && t<99. && (d=M(s + t * r))>.001*t; t+=d*.7, i+=.01);\n    return vec2(t, i);\n}\n\n//main\nvoid mainImage( out vec4 O, vec2 C ) {\n    //constructing the projection\n    v L = iResolution,\n    t = v(P(0.), 0),\n    f = n(t - v(P(2.), 2)),\n    s = n(cross(f, v(0,1,0))),\n    r = (\n        mat4(s,0,cross(s, f),0,-f,0,vec4(1)) * \n        vec4(n(v((C-L.xy*.5)/L.y, 1.)), 0)\n    ).xyz;\n    \n    //first hit\n    t += r * (C = R(t, r)).x;\n    \n    //first bounce for reflection\n    f = v(-4, 4, 0) * .005;\n    O.x = C.x<99. ? (\n        C = R(t, reflect(r, n(\n            M(t+f.xyy) * f.xyy + \n            M(t+f.yxy) * f.yxy + \n            M(t+f.yyx) * f.yyx + \n            M(t+f.xxx) * f.xxx\n        )))\n    ).y*C.y*4. : .5;\n\n    //color by lerping using the distance\n    O.xyz = sqrt(mix(v(.9,.65,.83), v(.94,.78,.92), C.x*.2)*O.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 149, 163, 163, 316], [318, 332, 350, 350, 463], [465, 472, 510, 544, 1207]], "test": "untested"}
{"id": "WtGBRD", "name": "Möbius torus ", "author": "Encharm", "description": "https://twitter.com/EncharmDre\n\nhttps://t.me/creative_coder\n\nInspired by https://twitter.com/muratpak", "tags": ["raymarching", "iridescent"], "likes": 17, "viewed": 666, "published": 3, "date": "1614007665", "time_retrieved": "2024-07-30T19:36:40.502828", "image_code": "#define AA 4\n#define drawEdge .875\n#define torus .9\n#define tri .3\n#define corner .02\n#define pi 3.141592653589793\n#define sqrt3 1.7320508075688772\n#define time iTime\n\nfloat random(vec2 v2) {\n    return fract(sin(dot(v2, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 opRevolution(in vec3 p, float w) {\n    return vec2(length(p.xy) - w, p.z);\n}\n\nmat2 rot(float a) {\n  float s = sin(a),\n        c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdEquilateralTriangle(in vec2 p, in float r ) {\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / sqrt3;\n    if (p.x + sqrt3 * p.y > 0.)\n        p = vec2(p.x - sqrt3 * p.y, -sqrt3 * p.x - p.y) * .5;\n    p.x -= clamp(p.x, -2. * r, 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat map(in vec3 pos) {\n    pos.xz *= rot(time * .5);\n    vec2 revolution = opRevolution(pos, torus);\n    vec2 rotated = revolution * rot(pi * .5 - atan(pos.y, pos.x) * .33333333 + time);\n    \n    float d = sdEquilateralTriangle(rotated, tri) - corner;\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float ep = .01;\n    vec2 e = vec2(1., -1.) * .5773;\n    return normalize(e.xyy * map(pos + e.xyy * ep) + \n\t\t\t\t\t e.yyx * map(pos + e.yyx * ep) + \n\t\t\t\t\t e.yxy * map(pos + e.yxy * ep) + \n\t\t\t\t\t e.xxx * map(pos + e.xxx * ep));\n}\n\nvec3 draw(vec2 st) {\n    vec3 color = vec3(0.);\n    vec3 normal = vec3(0.);\n    float needAA = 0.;\n    vec2 p = st / iResolution.y;\n\n    vec3 ro = vec3(0., 0., -8.);\n    vec3 rd = normalize(vec3(p, 5.));\n\n    float t = 5.0;\n    for (int i = 0; i < 30; i++) {\n        vec3 p = ro + t * rd;\n        float mapped = map(p);\n        if (abs(mapped) < 0.001 || t > 20.) break;\n        t += .9 * mapped;\n    }\n    \n    if (t < 10.) {\n        vec3 pos = ro + t * rd;\n        normal = calcNormal(pos);\n        normal.xy += random(pos.xy) * .05 - .025;\n        normal = normalize(normal);\n        float height = atan(normal.y, normal.x);\n        color = cos((height + vec3(0., .33, .67) * pi) * 2.) * .5 + .5;\n        color *= smoothstep(.95, .25, abs(normal.z));\n    }\n    \n    return color; \n}\nvec4 aaTrace(vec2 st) {\n    vec3 tot = vec3(0.);\n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - .5;\n        tot += draw(st + o * 2.);\n    }\n    tot /= float(AA * AA);\n    \n    tot = pow(tot, vec3(.45)) * 1.25;\n    tot = pow(tot, vec3(1.25));\n    \t\n    return vec4(tot, 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0., 0., 0., 1.);\n    vec2 st = (-iResolution.xy + 2.0 * fragCoord);\n    float dc = length(st / iResolution.y);\n    if (dc < drawEdge) {\n        fragColor = aaTrace(st);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 191, 191, 261], [263, 263, 302, 302, 344], [346, 346, 365, 365, 435], [437, 437, 490, 490, 708], [710, 710, 734, 734, 984], [986, 986, 1016, 1016, 1250], [1252, 1252, 1272, 1272, 2037], [2038, 2038, 2061, 2061, 2390], [2391, 2391, 2446, 2446, 2644]], "test": "untested"}
{"id": "tlKfRW", "name": "8 Track", "author": "eiffie", "description": "much cheating, maybe too much", "tags": ["racing"], "likes": 26, "viewed": 507, "published": 3, "date": "1614005092", "time_retrieved": "2024-07-30T19:36:41.278753", "image_code": "//8 Track by eiffie, lots of trucks, only want to check 1, much cheating\n#define time iTime\nfloat T=-1.,ff=.5;vec2 pos;mat2 wrm,brm;//T=closest truck,ff=fudge factor (.5,.25)\nmat2 face(vec2 a){a=normalize(a);return mat2(a.y,-a.x,a.x,a.y);}\nfloat trk(vec2 pG){//mimic cos(t/2),sin(t)\n  pG=abs(pG);\n  float d2=abs(pG.x*2.0-pG.y-pG.x*pG.x*0.69);\n  float d3=abs(length(vec2((pG.x-0.7)*3.3333,pG.y))-1.0);\n  return mix(d2,d3,smoothstep(0.55,0.66,pG.x));\n}\nfloat GetT(vec2 p){//get closest truck\n  vec4 O=texture(iChannel0,(p+vec2(25.))/50.);\n  if(T!=O.x){\n    T=O.x;ff=O.w;pos=path(O.z,T);\n    vec2 p2=path(O.z+.314159,T);\n    brm=face(p2-pos);wrm=face(path(O.z+.6283,T)*brm-p2*brm);//body and steering rots\n  }\n  float d=(trk(p/20.)-.4)*20.;//distance to track .25\n  return max(0.,min((O.y-70./rez.y-1.)*.5,d));//subtract size of pixel and truck\n}\nvec4 mcol=vec4(0);\n\nfloat DE(vec3 p0){\n  float st=sin(T);//\"random\" number\n  float AX=.33+st*.02,AZ=.5;//axle\n  float TW=.05,TR=.125,TS=.02;//tire\n  float BH=.1,BL=.75,BS=.04;//body\n  p0.xz=(p0.xz-pos)*brm;p0.y-=TR;//rotate body\n  vec3 p=p0;p.xz=abs(p.xz)-vec2(AX,AZ);\n  float yz=length(p.yz)-TR;\n  if(p0.z>0.)p.xz=(p0.x>0.?p.xz*wrm:wrm*p.xz);//steer\n  float dT=length(max(vec2(abs(p.x)-TW,length(p.yz)-TR),0.0))-TS;\n  float dB=length(max(vec3(abs(p0.x)-AX,abs(p0.y-BH)-BH+p0.z*0.01,abs(p0.z)-BL),0.0))-BS;\n  float dP=max(abs(p0.x)-AX,max(abs(p0.y-BH-.14)-.2,abs(p0.z+BL*.6)-BL*.4));\n  dB=min(dB,length(max(vec3(abs(p0.x)-AX+p0.y*0.1,abs(p0.y-BH*2.75)-BH,abs(p0.z-BL*.15+(p0.z>0.?p0.y-.23:0.))-BL*.3),0.))-BS)*.7;\n  dB=max(dB,-min(p0.z>0.?yz-.05:dT-.05,dP));\n  float d=min(dT,dB);\n  if(mcol.x>0.){//coloring when needed\n    if(d==dT){//tire\n      if(p0.z>0.)yz=length(p.yz)-TR;\n      mcol+=vec4(vec3(abs(sin(yz*16.+.52))*.5-yz*2.),0);\n    }else{\n      p=sin(p0*20.+2.4*sin(p0.zxy*17.));\n      vec4 BC=abs(vec4(sin(T*1.3),st,sin(T+2.),.5+(p.x+p.y+p.z)*.1));//base color\n      BC.rgb+=p*.1;\n      float ax=abs(p0.x)-AX+p0.y*0.1;\n      if(ax<d){\n        if(abs(p0.y-BH*3.-BS*.75)<BH-BS*.5){\n          mcol+=vec4(.1,.1,.2,1);//windshield\n        }else if(abs(p0.z)>BL){\n          float lt=length(vec2(abs(p0.x)-.28,p0.y-.15));\n          if(lt<.06){\n            lt=sqrt(.06-lt)*5.;\n            mcol+=(p0.z>0.?vec4(lt,lt,lt,2):vec4(lt,lt*.3,0,2));//lights\n          }else{\n            if(abs(p0.x)<.22-p0.z*.1)mcol+=vec4(vec3(abs(sin(p0.y*61.+1.34))),.7);//chrome\n            else mcol+=BC;\n          }\n        }else{\n          mcol+=BC;\n        }\n      }else{\n        if(abs(p0.y-BH*3.-BS*.75)<BH-BS*.5 && p0.z<.57-p0.y&& p0.z>-BL*.13){\n          mcol+=vec4(.1,.1,.2,1);//side window\n        }else{\n          mcol+=BC;\n        }\n      }\n    }\n  }\n  return d*ff;\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nfloat rand(vec2 p){return fract(sin(dot(p,vec2(13.3145,117.7391)))*4237.76543);}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=rand(p+mod(time*10.,150.));}//fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*4237.76543);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;ff=1.;//turn off fudge\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\n\nvec3 sky(vec3 rd, vec3 L){return vec3(1.-rd.y,0.9,1.+(rd.y-dot(rd,L))*.5)*(0.4*dot(rd,L)+0.6);}\nvec3 bg(vec3 ro, vec3 rd, float t, vec3 L){//background\n  if(rd.y<0. && t<250.){//track\n    vec2 pG=ro.xz+rd.xz*t;\n    float d3=trk(pG/20.),r1=rand(floor(pG*3.*(d3+.1))),r2=rand(floor(pG.yx*10.));\n    return (mix(vec3(.4,.3,.1),vec3(.3,.4,.2),smoothstep(.2,.25,d3))\n     +(r1*vec3(.0,.1,.2)+r2*vec3(.05))/(1.+.05*length(pG)))*(.5+.5*ShadAO(ro+rd*t,L));\n  }else return sky(rd,L);\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float st=clamp(-(ro.y-.55)/rd.y,0.,250.);//start just above trucks\n  st+=GetT(ro.xz+rd.xz*st);\n  float t=st+DE(ro+rd*st)*rnd,d,px=1.0/rez.x;\n  float dG=rd.y<0.?min(-ro.y/rd.y,250.):250.;//end at the ground\n  for(int i=0;i<99;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>dG || d<px*t)break;\n    t+=GetT(ro.xz+rd.xz*t);\n  }\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  t=min(dG,t);\n  vec3 col=bg(ro,rd,t,L);\n  if(d<px*t*2.0){\n    mcol=vec4(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);\n    vec4 scol=mcol*0.25;\n    if(scol.w>1.5)col=scol.rgb;\n    else{\n      float dif=0.5+0.5*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.0,.9);\n      float fr=pow(1.-vis,5.0)*scol.w;\n      float shad=0.5+.5*ShadAO(so,L);\n      if(d<0.){shad=.5;fr=0.;}\n      col=mix((scol.xyz*dif)*shad+fr*sky(reflect(rd,N),L),col,d/(px*t*2.0));\n    }\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){ \n  fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0,1,0)));return mat3(rt,cross(rt,fw),fw); \n} \nvoid mainImage(out vec4 O, in vec2 U){\n  randomize(U);\n  vec2 uv=(2.*U-rez)/rez.x;\n  float t=iTime*RS;\n  vec2 p1=path(t-t*t*.006,13.)*.8,p2=path(iTime*RS,11.);\n  vec3 ro=vec3(1)+vec3(p1.x,1.75+2.*sin(iTime*.3),p1.y),rd=lookat(vec3(p2.x,0,p2.y)-ro)*normalize(vec3(uv,1));\n  O=vec4(scene(ro,rd),1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//less than half way between a hack and a physical model\nvec2 mainSound(int samp, float time){\n  float t=time*RS;\n  vec2 a=vec2(0);\n  vec2 ear=vec2(1)+path(t-t*t*.006,13.)*.8,fw=normalize(path(t,11.)-ear);\n  for(float i=0.;i<32.;i+=1.){\n    vec2 car=path(t,i);\n    float d=length(ear-car)*.1;\n    float s=(125.-abs(car.y)*.5)/(1.+time*.025);//should be length(path(t+?,i)-car...\n    car=normalize(car-ear);\n    float f=dot(car,fw);\n    float p=.5+.5*dot(car,vec2(-fw.y,fw.x));//should be 2 ears so timing is correct\n    //p=pan,s=speed,d=distance,f=front facing\n    a+=vec2(1.-p,p)*pow(abs(fract((time-d)*s)-.5),1.5+f)/(1.+d*d-f*.5);\n  }\n  return a; \n}", "sound_inputs": [], "buffer_a_code": "//find the closest truck with minimal checks then fudge\n#define time iTime\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=25.*(2.0*U-rez)/rez;\n  float t=time*RS,dm=250.,c=-1.,ff=.5;\n  for(float i=0.;i<32.;i+=1.){\n    float d=length(uv-path(t,i));\n    if(d<dm){if(dm<2.)ff=.25;dm=d;c=i;}\n  }\n  O=vec4(c,dm,t,ff);//car,min dist,time,fudge factor \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rez iResolution.xy\n#define RS .5\nvec2 path(float t, float i){\n  t+=i;\n  vec2 p=vec2(cos(t/2.),sin(t))*20.;\n  p*=vec2(1)+vec2(sin(i*.35),sin(2.+i*.21))*.08;\n  return p;\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 175, 193, 193, 239], [240, 240, 259, 282, 450], [451, 451, 470, 489, 843], [864, 864, 882, 882, 2702], [2703, 2703, 2732, 2742, 2878], [2879, 2879, 2898, 2898, 2959], [2971, 2971, 2997, 2997, 3029], [3099, 3099, 3136, 3136, 3292], [3294, 3294, 3320, 3320, 3389], [3390, 3390, 3433, 3445, 3770], [3771, 3771, 3800, 3800, 4638], [4639, 4639, 4660, 4660, 4757], [4759, 4759, 4797, 4797, 5057]], "test": "untested"}
{"id": "3tKfzR", "name": "SandSim", "author": "0x1D", "description": "sand simulation inspired by Noita\n- Click+drag to add sand\n- Space & click+drag to remove sand", "tags": ["sand"], "likes": 11, "viewed": 416, "published": 3, "date": "1614004381", "time_retrieved": "2024-07-30T19:36:42.101553", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.4, 0.3, 0.01, 1.0) * texture( iChannel0, fragCoord.xy / iResolution.xy );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nvoid computeMovement(in vec2 fragCoord, out float remaining, out float under, out float left, out float right)\n{\n    // Under\n    float under_capacity = 0.0;\n    {\n        ivec2 uv_under = ivec2(fragCoord.xy) + ivec2(0, -1);\n        ivec2 clamped_uv_under = clamp(uv_under, ivec2(0.0), ivec2(iResolution.xy) - 1);\n        if(uv_under.x == clamped_uv_under.x && uv_under.y == clamped_uv_under.y)\n        {\n            float under = texelFetch(iChannel0, uv_under, 0).x;\n            under_capacity = 1.0 - under;\n        }\n    }\n    // sides\n    float left_capacity = 0.0;\n    float right_capacity = 0.0;    \n    // Left\n    {\n        ivec2 uv_under_left = ivec2(fragCoord.xy) + ivec2(-1, -1);\n        ivec2 clamped_uv_under_left = clamp(uv_under_left, ivec2(0.0), ivec2(iResolution.xy) - 1);\n        if(uv_under_left.x == clamped_uv_under_left.x && uv_under_left.y == clamped_uv_under_left.y)\n        {\n            float under_left = texelFetch(iChannel0, uv_under_left, 0).x;\n            left_capacity = 1.0 - under_left;\n        }\n    }\n    // Right\n    {\n        ivec2 uv_under_right = ivec2(fragCoord.xy) + ivec2(1, -1);\n        ivec2 clamped_uv_under_right = clamp(uv_under_right, ivec2(0.0), ivec2(iResolution.xy) - 1);\n        if(uv_under_right.x == clamped_uv_under_right.x && uv_under_right.y == clamped_uv_under_right.y)\n        {\n            float under_right = texelFetch(iChannel0, uv_under_right, 0).x;\n            right_capacity = 1.0 - under_right;\n        }\n    }\n    remaining = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    // give under\n    under = min(remaining, under_capacity);\n    remaining -= under;\n    // give sides\n    float split = remaining / 2.0;\n    float min_capacity = min(left_capacity, right_capacity);   \n    float split_that_fits  = min(min_capacity, split);\n    left = split_that_fits;\n    right = split_that_fits;\n    left_capacity -= split_that_fits;\n    right_capacity -= split_that_fits;\n    left += min(remaining, left_capacity);\n    right += min(remaining, right_capacity);\n    remaining -= left;\n    remaining -= right;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float fall_direction = 1.0;\n    if(texelFetch(iChannel1, ivec2(37, 0), 0).x > 0.0)\n        fall_direction = -1.0;\n\n    float remaining;\n    float under;\n    float left;\n    float right;\n    computeMovement(\n        fragCoord.xy,\n        remaining,\n        under,\n        left,\n        right);\n\n    // Recieving\n    {\n        float dontcare;\n        float under;\n        float left;\n        float right;\n        computeMovement(\n            fragCoord.xy + vec2(0, 1),\n            dontcare,\n            under,\n            left,\n            right);\n        remaining += under;\n    }\n    {\n        float dontcare;\n        float under;\n        float left;\n        float right;\n        computeMovement(\n            fragCoord.xy + vec2(-1, 1),\n            dontcare,\n            under,\n            left,\n            right);\n        remaining += left;\n    }\n    {\n        float dontcare;\n        float under;\n        float left;\n        float right;\n        computeMovement(\n            fragCoord.xy + vec2(1, 1),\n            dontcare,\n            under,\n            left,\n            right);\n        remaining += right;\n    }\n\n    if(iMouse.z > 0.0)\n    {\n        float created = 50.0 * iTimeDelta * clamp(1.0 - distance(iMouse.xy, fragCoord.xy) / 50.0, 0.0, 1.0);\n        if(texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x > 0.0)\n            remaining -= created;\n        else\n            remaining += min(1.0 - remaining, created);\n    }\n    \n    remaining = max(remaining, 0.0);\n    remaining = min(remaining, 1.0);\n    fragColor = vec4(remaining);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]], "test": "untested"}
{"id": "WtVfRD", "name": "Animus", "author": "rge15", "description": "Isn't my tutorial.\nYoutube Tutorial : https://www.youtube.com/watch?v=3CycKKJiwis&t=1329s", "tags": ["animus"], "likes": 0, "viewed": 160, "published": 3, "date": "1613995069", "time_retrieved": "2024-07-30T19:36:42.943303", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n , N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offs)\n{\n    vec2 n = N22(id+offs)*iTime;\n    return offs+sin(n)*0.3;\n}\n\nfloat Line(vec2 p , vec2 a, vec2 b)\n{\n    float d = DistLine(p,a,b);\n    float m = S(.03,.01,d);\n    m *= S(1.2,.8,length(a-b));\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Origin at the middle and aspect ratio correct\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    float m = 0.;\n    \n    uv *= 10.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    for(float y=-1. ; y<=1. ; y++)\n    {\n        for(float x =-1. ; x<=1. ; x++)\n        {\n            p[i++] = GetPos(id,vec2(x,y));         \n        }\n    }   \n    \n    for(int i = 0 ; i<9 ; i++)\n    {\n        m += Line(gv, p[4] , p[i]);\n        \n        vec2 j = (p[i]-gv)*15.;\n        float spk = 1./ dot(j,j);\n        m += spk*(sin(iTime+p[i].x*5.)*.5+.5);\n    }\n    \n    m += Line(gv, p[1] , p[3]);\n    m += Line(gv, p[1] , p[5]);\n    m += Line(gv, p[7] , p[3]);\n    m += Line(gv, p[7] , p[5]);\n    \n    vec3 col = vec3(m);\n    \n    //if(gv.x > .48 || gv.y > .48) col = vec3(1,0,0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 76, 76, 194], [196, 196, 215, 215, 308], [310, 310, 328, 328, 383], [385, 385, 418, 418, 481], [483, 483, 520, 520, 627], [629, 629, 686, 738, 1551]], "test": "untested"}
{"id": "3tGfzW", "name": "iceberger 2 - pow2(via cubemap)", "author": "FabriceNeyret2", "description": "reproducing [url]https://joshdata.me/iceberger.html[/url] Using smart MIPmaps.\nDraw iceberg (TAB to erase).    SPACE to start/pause the physics.\nRed dot = center of mass, \nGreen dot = immerged center of mass.", "tags": ["simulation", "physics", "reproduction", "gpmipmap", "iceberger"], "likes": 7, "viewed": 551, "published": 3, "date": "1613941851", "time_retrieved": "2024-07-30T19:36:43.717233", "image_code": "// power-of-2 variant of \"iceberger\" https://shadertoy.com/view/tlKfzz\n// ( otherwise MIPmap is way to bugged )\n// reproducing https://joshdata.me/iceberger.html\n\nvoid mainImage( out vec4 O, vec2 U )\n{ \n    U = 1024.*( .56* ( U - L*iResolution.xy ) / iResolution.y + L );\n    O = T(U).x  - T(U).y *vec4(.3,.3,-1,0); \n    O = mix(O, vec4(1,0,0,0), D( G.xy, 10.) );\n    O = mix(O, vec4(0,1,0,0), D( G.zw, 10.) );\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define L              vec2(.5,.7)\n#define R              vec2(1024) // iResolution.xy\n#define dt            ( .5*iTimeDelta )\n#define T(U)           texture( iChannel0, vec3( 2.*(U)/R -1., 1 ).xzy )\n#define M            ( textureLod(iChannel0,vec3(0, 1, 0) , 20.) +1e-9 ) // total mass\n#define G              textureLod(iChannel0,vec3(0,-1, 0) , 20.)         // center of mass\n#define D(C,r)         smoothstep( 1.5, 0., length(C-U) - r )           // antialiased disk\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define rot(a)         mat2( cos(a), -sin(a), sin(a), cos(a) )", "cube_a_code": "void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    if (D.y > max(abs(D.x),abs(D.z))) {       // --- side 1 -------------\n\n    // O.x = iceberg, O.y = ocean, O.z = immerged iceberg.  \n    // Ultimate MIPmap = mass (i.e., volume )\n                                                            // --- physics   \n        float da = T(1.5).w*dt, dy = T(.5).w*dt;            //T(.5) = V.y  T(1.5) = Vrot\n        mat2 r = rot( da );                        \n        O = T( (U-G.xy) * r + G.xy  - vec2(0,dy) );         // previous step + physics ( dynamics, via rot+translate )\n\n     // O.x = smoothstep(0.,1.,O.x);                        // --- recontrast\n     // O.x = mix(O.x,smoothstep(0.,1.,O.x),.1);            \n        O.x = mix( O.x, smoothstep(0.,1.,O.x), abs(da)+abs(dy) ); \n     // O.x *= O.x > .25 ? 1. : O.x*4.;                     // Eric Huber variant\n     \n        vec2 s = iChannelResolution[1].xy,                  // screen resolution\n             m = 1024.*( .56* ( iMouse.xy - L*s ) / s.y + L );\n        if (iMouse.z>0.)                                    // --- paint\n               O.x = keyToggle(9) \n                       ? max( 0., O.x - D( m, .05*R.y ) )   // erase iceberg\n                       : max(O.x,       D( m, .05*R.y ) );  // paint iceberg\n\n        O.y = step( U.y/R.y , L.y );                        // ocean\n        O.z = O.x*O.y;                                      // immerged part of the iceberg\n\n        if ( U.x<2. && U.y<2. ) {\n            vec3 F = keyToggle(32.)                         // --- physics \n                // ? G.zww - G.xyy*vec3(1,1,.95) : vec3(0); // torque+force applying on the iceberg\n                   ? vec3(G.z - G.x,-.1*M.z/M.x*.1*R.y, -(.9 - M.z/M.x)*4.*R.y) : vec3(0); // correct physics\n         // F.x = sign(F.x) * max(0., abs(F.x)-2.);                 // stabilizer (because delayed reaction)\n            O.w = .98*T(U).w + ( U.x<1. ? F.z*dt : F.x*F.y*dt*dt ); // update ( 0,0: Vy  1,1: Vrot )\n        } \n        \n        U = R-1.-abs(2.*U-R); if (U.x*U.y<.5) O.xz = vec2(0);// clamp paint\n    }\n    else if (-D.y > max(abs(D.x),abs(D.z))) { // --- side 2 -------------\n    \n    // ultimate MIPmap of O.xy = center of mass\n    // ultimate MIPmap of O.zw = immerged center of mass\n    \n        vec4 D = T(U) / M;  // density field\n        O.xy = D.x * U;     // prepare spatial moments of iceberg shape (total vs immerged)\n        O.zw = D.z * U;\n    }\n}\n\n\n\n\n/*  // old static physics\n        vec3 F = keyToggle(32.)\n                   ? G.zww - G.xyy*vec3(1,1,.95) : vec3(0); // moment+force applying on the iceberg\n                // ? vec2((G.z-G.x)/R.y*10., .9 - M.z/M.x).xyy : vec3(0); // WIP: \"better\" physics don't work\n        F.x = sign(F.x) * max(0., abs(F.x)-2.);             // stabilizer (because delayed reaction)\n        \n        mat2 r = rot( F.x*F.y*dt*.01 );\n        O = T( (U-G.xy) * r + G.xy  - vec2(0,F.z)*dt );     // previous step + physics ( statics, via rot+translate )\n*/\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// guess what is the purpose of this buffer ;-)\nvoid mainImage( out vec4 O, vec2 U ) {}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 201, 201, 412]], "test": "untested"}
{"id": "WlGBzD", "name": "shadertoy bug in cubMapA", "author": "FabriceNeyret2", "description": "( bug now fixed ).\nDisplay this at resolution 640x360.\nsee CubeA:\nin cubeMap, all buffers iChannelResolution are wrongly set to 1024.\n( Beside, iMouse range is still windowResolution, which you can access here and thus can't normalize ).", "tags": ["shadertoy", "bug"], "likes": 0, "viewed": 297, "published": 3, "date": "1613940463", "time_retrieved": "2024-07-30T19:36:44.599874", "image_code": "void mainImage( out vec4 O, vec2 U ) { \n   O = texture(iChannel0, vec3( 2.*U/iResolution.xy - 1., 1) );\n}\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U ) {\n    O.xy = iResolution.xy;  // store window resolution\n}", "buffer_a_inputs": [], "cube_a_code": "void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D ) {\n\n    vec2 R = texelFetch(iChannel0,ivec2(0),0).xy;  // read screen resolution\n    \n    if ( U.x < 512. ) \n        O.r = float( iChannelResolution[0].xy ==  vec2(640,360) ), // false !\n        O.g = float( iChannelResolution[0].xy ==  vec2(1024) ),    // true !\n        O.b = float( R == vec2(640,360) ); \n    if (U.x > 512. ) \n        O.r = float( R == iChannelResolution[0].xy ),              // false !\n        O.g = float( R == iChannelResolution[1].xy ), \n        O.b = float( R == iResolution.xy ); \n}\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 105]], "test": "untested"}
{"id": "WtycRz", "name": "Screens", "author": "afaq", "description": "An endless array of abstract screens. \nPress to zoom and move around. Still some artifacts to fix when zooming in.\n\nUsed Inigo Quilezs distance functions page as references:\nhttps://iquilezles.org/articles/distfunctions/distfunctions.htm", "tags": ["2d", "raymarching", "interactive", "animated", "glow", "flash", "neon", "screens"], "likes": 9, "viewed": 586, "published": 3, "date": "1613932114", "time_retrieved": "2024-07-30T19:36:45.366823", "image_code": "#define saturate(x) clamp(x, 0.0, 1.0)\n#define BPM 120.0\n#define _beat (iTime * BPM / 1000.0)\n#define beat (mod(_beat, 32.0))\n\n// Taken from. https://www.shadertoy.com/view/3ls3zM\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Zoom\n    uv = uv * 2.0 - 1.0;\n    uv *= 0.9 - (sin(iTime) * 0.005);\n    uv = (uv + 1.0) * 0.5;\n    \n    // Camera shake\n    uv += 0.02 * sin(PI2 * beat / 32. * 10.0) + 0.01 * sin(PI2 * beat / 32. * 20.0);\n    \n    // Lens distortion\n    vec2 dir = uv - vec2(0.5);\n    uv += dir * dot(dir, dir) * 0.2;\n    \n    vec3 colour = texture(iChannel0, uv).rgb;\n    \n    // Vignette\n    vec2 d = abs(uv - vec2(0.5)) * 1.6;\n    d = pow(d, vec2(2.0));\n    colour.rgb *= pow(saturate(1.0 - dot(d, d)), 3.0);\n\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RAYMARCHING_MAX_STEPS 200\n#define RAYMARCHING_MAX_DEPTH 1000.0\n#define RAYMARCHING_THRESHOLD 0.01\n#define REPEAT_AMOUNT 500.0\n#define REPEAT_DIST 3.0\n#define REPEAT_HALF_DIST REPEAT_DIST * 0.5\n\nint layerID = 0;\n\nfloat SceneSD(vec3 position)\n{\n    float distance = 1.0;\n    \n    vec3 repeat = RepeatLimited(position, REPEAT_DIST, vec2(-REPEAT_AMOUNT, REPEAT_AMOUNT));\n    \n    repeat = Elongate(repeat, vec3(0.5, 0.0, 0.35));\n    repeat.y = position.y;\n    \n    vec3 id = GetID(position, REPEAT_DIST, REPEAT_HALF_DIST);\n    \n    if(Rand(id.xx) <= Rand(id.zx))\n    {\n        vec3 offset = repeat + vec3(0.0, -1.0, 0.0);  \n        offset.y += sin(iTime * Rand(id.xz));\n        \n        float newDistance = TorusSD(offset, vec2(0.25, 0.1));\n        if(distance > newDistance)\n        {\n            distance = newDistance;\n            layerID = 3;\n        }\n    }\n    \n    if(Rand(id.zz) <= Rand(id.xz))\n    {\n        vec3 offset = repeat + vec3(0.0, -0.5, 0.0);  \n        offset.y += sin((iTime * 0.75) * Rand(id.xz));\n        \n        float newDistance = TorusSD(offset, vec2(0.5, 0.1));\n        if(distance > newDistance)\n        {\n            distance = newDistance;\n            layerID = 2;\n        }\n    }\n\n    {\n        vec3 offset = repeat + vec3(0.0, -0.25, 0.0);  \n        offset.y += cos((iTime * 0.15) * Rand(id.xz));\n\n        float newDistance =  TorusSD(offset, vec2(0.75, 0.1));\n        if(distance > newDistance)\n        {\n            distance = newDistance;\n            layerID = 1;\n        }\n    }\n    \n    float newDistance = PlaneSD(position, vec3(0.0, 1.0, 0.0), 2.25);\n    if(distance > newDistance)\n    {\n        distance = newDistance;\n        layerID = 0;\n    }\n    \n    return distance;\n}\n\nvec4 Raymarch(Ray ray)\n{\n    float depth = 0.0;\n    vec3 position = vec3(0.0);\n    for(int i = 0; i < RAYMARCHING_MAX_STEPS; ++i)\n    {\n        position = ray.origin + (depth * ray.direction);\n        float distance = SceneSD(position);\n        \n        if(distance < RAYMARCHING_THRESHOLD || distance >= RAYMARCHING_MAX_DEPTH)\n        {\n            break;\n        }\n        \n        depth += distance;\n    }\n    \n    return vec4(position, depth);\n}\n\nvec3 Normal(vec3 position)\n{\n    float distance = SceneSD(position);\n    vec2 offset = vec2(0.001, 0.0);\n    \n    vec3 normal = distance - vec3(\n        SceneSD(position-offset.xyy),\n        SceneSD(position-offset.yxy),\n        SceneSD(position-offset.yyx));\n    \n    return normalize(normal);\n}\n\nfloat Shadow(Ray ray, vec3 light)\n{\n    float depth = Raymarch(ray).w;\n    if(depth < length(light))\n    {\n        return 0.1;\n    }\n    return 1.0;\n}\n\nvec3 Light(vec3 position, float depth)\n{   \n    vec3 colours[4];\n    colours[0] = vec3( 1.0, 1.0, 1.0 );\n    colours[1] = vec3( 0.839, 0.450, 0.337 );\n    colours[2] = vec3( 0.631, 0.839, 0.427 );\n    colours[3] = vec3( 0.294, 0.403, 0.839 );\n    \n    vec3 id = GetID(position, REPEAT_DIST, REPEAT_HALF_DIST);\n    vec3 offset = position + ((floor(sin(Rand(id.xz) * (iTime * 0.2)) * 80.0) - (40.0)) * REPEAT_DIST);\n    offset.y = position.y;\n    \n    vec3 diffuse = colours[layerID];\n    vec3 colour = (diffuse * position.y) * 0.5;\n    float glow = Glow(offset.xyx, 50.0, 0.2);\n\n    return colour + (diffuse * glow);\n}\n\nvec3 Render(Ray ray)\n{\n    vec4 position = Raymarch(ray);\n    vec3 colour = Light(position.xyz, position.w);\n    return colour;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 m = iMouse / iResolution.x;\n    \n    vec3 origin = vec3(0.0, 120.0, 0.0);\n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    \n\tif(m.z > 0.0)\n\t{\n        origin = vec3(m.x * 50.0, 30.0, m.y * 50.0);\n        target = vec3(origin.x, 1.0, origin.y);\n    }\n    \n    Ray ray = LookAt(uv, origin, target, up);\n    fragColor = vec4(Render(ray), 1.0);\n}", "buffer_a_inputs": [], "common_code": "#define EPSILON 1e-5f\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nmat3 Transform(vec3 direction, vec3 up)\n{\n    vec3 z = direction;\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    return mat3(x, y, z);\n}\n\nfloat PlaneSD(vec3 position, vec3 normal, float height)\n{\n    return dot(position, normal) + height;\n}\n\nfloat SphereSD(vec3 position, vec3 center, float radius)\n{\n    return length(position - center) - radius;\n}\n\nfloat BoxSD(vec3 position, vec3 bounds)\n{\n    vec3 q = abs(position) - bounds;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat BoundingBoxSD(vec3 position, vec3 bounds, float edge, float bevel)\n{\n    position = abs(position) - bounds;\n    vec3 q = abs(position + edge) - edge;\n    return min(min(\n        length(max(vec3(position.x, q.y, q.z), 0.0)) + min(max(position.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, position.y, q.z), 0.0)) + min(max(q.x, max(position.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, position.z), 0.0)) + min(max(q.x, max(q.y, position.z)), 0.0))- bevel;\n}\n\nfloat TorusSD(vec3 position, vec2 dimensions)\n{\n    vec2 q = vec2(length(position.xz) - dimensions.x, position.y);\n    return length(q) - dimensions.y;\n}\n\nvec3 RepeatLimited(vec3 position, float dist, vec2 limits)\n{\n    return position-dist*clamp(round(position/dist), vec3(limits.x), vec3(limits.y));\n}\n\nvec3 Repeat(vec3 p, vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nvec3 Elongate(vec3 position, vec3 amount)\n{\n     return position - clamp(position, -amount, amount);\n}\n\nvec3 GetID(vec3 position, float dist, float halfDist)\n{\n    return floor((position + halfDist) / dist);\n}\n\nfloat Glow(vec3 position, float strength, float radius)\n{\n    float glow = 1.0 / length(position);\n    glow *= strength;\n    return pow(glow, radius);\n}\n\nfloat Rand(vec2 v)\n{\n    return fract(sin(dot(v.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Hash(float n) \n{ \n    return fract(sin(n)*43758.5453123); \n}\n\nfloat CheckerPattern(vec3 position)\n{\n    float sx = sin(2.0 * position.x);\n\tfloat cy = cos(2.0 * position.z);\n    return sx * cy / 0.001;\n}\n\nRay LookAt(vec2 uv, vec3 origin, vec3 target, vec3 up)\n{   \n    vec3 direction = normalize(target - origin);\n    mat3 transform = Transform(direction, up);\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = transform * normalize(vec3(uv.x, uv.y, 1.0));\n    return ray;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtycRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 180, 235, 235, 818]], "test": "untested"}
{"id": "WlGBzW", "name": "space web", "author": "YitingLiu", "description": "exploring the space as a web.", "tags": ["spider", "universe", "web", "ethereal"], "likes": 9, "viewed": 446, "published": 3, "date": "1613925288", "time_retrieved": "2024-07-30T19:36:46.141751", "image_code": "//tutorial https://www.youtube.com/watch?v=KGJUl8Teipk\n//tutorial https://www.youtube.com/watch?v=3CycKKJiwis\n\n#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34,4564.2));\n    p+=dot(p,p+23.45);\n    return fract(p.x*p.y);\n\n}\n\n//make it more efficient \nvec2 N22 (vec2 p){\n    float n = N21(p);\n    return vec2(n,N21(n+p));\n\n}\n\nvec2 GetPos(vec2 id, vec2 offs){\n   \n   vec2 n = N22(id+offs)*iTime;\n\n   return offs+sin(n);//*.4;\n}\nfloat Line(vec2 p, vec2 a, vec2 b){\n\n    float d = DistLine(p,a,b);\n    float m = S(.02,.01,d);\n    float d2 = length(a-b);\n    m*=S(1.2,.8,d2)+S(.05,.03,abs(d2-.75));// the second smoothstep add flash effect \n    return m;\n}\n\nfloat Layer(vec2 uv, float fft){\n   float m =0.;\n   float t = iTime*10.;\n\n   vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n   // vec2 p = GetPos(id);// can make firefly\n   \n   vec2 p[9];//determining array sizes \n   \n   int i =0; \n   \n   for(float y = -1.; y <=1.; y++){\n       for(float x = -1.; x <=1.; x++){\n       vec2 offs= vec2(x,y);\n       p[i++]=GetPos(id,offs);\n       \n       }\n   \n   }\n   \n   for (int i = 0; i <9; i++){\n       m+=Line(gv, p[4],p[i]);\n       vec2 j = (p[i]-gv)*20.;\n       float sparkle = 1./dot(j,j)*fft*10.;\n       m+=sparkle*(sin(t+fract(p[i].x*10.))*.5+.5);// add fract to avoid obvioux grid \n   }\n   \n   m+=Line(gv, p[1],p[3]);\n   m+=Line(gv, p[1],p[5]);\n   m+=Line(gv, p[7],p[3]);\n   m+=Line(gv, p[7],p[5]);\n   \n   \n//       if(gv.x>.48||gv.y>.48) col = vec3(1,0,0);\n\n   return m;\n   \n}\n\nmat2 Rot(float a){\n    float c =cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n        float gradient = uv.y;\n\n    vec3 col = vec3(0);\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n \n\n    float fft  = texelFetch( iChannel0, ivec2(0.,0), 0 ).x; \n\n    float t = iTime*0.05;\n\n    float m = 0.;\n    \n    uv*=Rot(t) ;\n    mouse *=Rot(t);\n    \n     for (float i =0.; i <1.; i+=1./4.){\n         float z = fract(i+t);\n         float size = mix(10.,.52,z);\n         float fade = S(0.,.5,z)*S(1.,.8,z);\n         m+=Layer(uv*size+i*20.-mouse,fft*2.)*fade;\n\n     }\n     \n   vec3 base = sin(t*vec3(.556,.456,.548))*.4+.6;\n     \n   col=m*base;\n\n   \n   gradient-=fft;\n   \n   col-=base*gradient;\n\n   \n    fragColor = vec4(col*(fft+1.),1.);\n}", "image_inputs": [{"id": 25469, "src": "https://soundcloud.com/yitingliu/afar", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 186, 186, 304], [306, 306, 324, 324, 415], [417, 443, 461, 461, 515], [517, 517, 549, 549, 617], [618, 618, 653, 653, 843], [845, 845, 877, 877, 1673], [1675, 1675, 1693, 1693, 1755], [1757, 1757, 1814, 1814, 2522]], "test": "untested"}
{"id": "WlGfRW", "name": "sonrisa v2", "author": "jorge2017a1", "description": "sonrisa v2", "tags": ["sonrisav2"], "likes": 6, "viewed": 295, "published": 3, "date": "1613924087", "time_retrieved": "2024-07-30T19:36:47.101186", "image_code": "//referencia \n///http://xdpixel.com/page/12/\n//http://xdpixel.com/wp-content/uploads/2019/02/opengl-texture-mapping-example.png\n//por jorge2017a1\n\n\n\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n     float planeDist1 = p.y+5.0;  //piso inf\n     float planeDist5 = -p.z+40.0;  //pared frente\n     \n    res =opU3(res, vec3(planeDist1,-1.0,8.)); \n    res =opU3(res, vec3(planeDist5,-1.0,12.)); \n    \n    \n    vec3 prA=p;\n    vec3 prB=p-vec3(2.,0.0,4.0);\n    \n    prA.x= opRep1D( prA.x, 4. );\n    prA.z= opRep1D( prA.z, 8. );\n    prB.x= opRep1D( prB.x, 4. );\n    prB.z= opRep1D( prB.z, 8. );\n    \n    float ds1=sdSphere(  prA, 2.0 );\n    float ds2=sdSphere(  prB, 2.0 );\n    \n    res =opU3(res, vec3(ds1,-1.0,10.)); \n    res =opU3(res, vec3(ds2,-1.0,11.)); \n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    \n    \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n     if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nvec3 Ojo(vec2 uv, vec3 col )\n{\n    vec2 res=vec2(9999.0,-1.0);\n    \n    float radioOjo=0.15;\n    \n    float d0= sdCircle( uv-vec2(0.05,0.1), 0.07 );\n    \n    float d1= sdCircle( uv, radioOjo );\n    float d2= sdCircle( uv, radioOjo+0.05 );\n    float d3= sdBox( uv-vec2(0.0,-0.02), vec2(0.2,0.02) );\n    float d4= sdBox( uv-vec2(0.0,-0.13), vec2(0.2,0.12) );\n     \n    float dS= opS( d1,d2 );\n    dS= opS( d4,dS );\n    dS= opU( d3, dS );\n    \n    //mitad ojo\n    float dmitad= opS( d4,d1 );\n    dmitad= opU( d3,dmitad );\n    \n    d1= opS( d3,d1 );\n   \n    col = mix(col,vec3(0.0,0.0,0.)*1.2,S(dS,0.0));\n    col = mix(col,vec3(1.0)*1.2,S(dmitad,0.0));\n    col = mix(col,vec3(0.0)*1.2,S(d3,0.0));\n    col = mix(col,vec3(0.0,0.0,0.)*1.2,S(d0,0.0));\n    \n    return col;\n}\n\n\n\nvec3 Boca(vec2 uv, vec3 col )\n{\n    vec2 res=vec2(9999.0,-1.0);\n    \n    float radioOjo=0.4;\n    \n    float d0= sdCircle( uv-vec2(0.07,-0.35), 0.2 );\n    \n    float d1= sdCircle( uv, radioOjo );\n    float d2= sdCircle( uv, radioOjo+0.05 );\n    float d3= sdBox( uv-vec2(0.0,-0.02), vec2(radioOjo,0.02) );\n    float d4= sdBox( uv-vec2(0.0,0.25), vec2(radioOjo+0.1,radioOjo/2.0+radioOjo/8.0) );\n     \n    float dS= opS( d1,d2 );\n    dS= opS( d4,dS );\n    dS= opU( d3, dS );\n    \n    float bocaint=opS( d4,d2 );\n    d1= opS( d3,d1 );\n    d0= opI( d1,d0 );\n    \n    col = mix(col,vec3(1.)*1.2,S(bocaint,0.0));\n    col = mix(col,vec3(0.,.0,0.)*1.2,S(dS,0.0));\n    col = mix(col,vec3(1.0,0.465,0.3)*1.2,S(d0,0.0));\n    \n    \n    return col;\n}\n\n\n\nvec3 Sonrisa2d(vec2 uv )\n{\n    vec3 col =vec3(0.02,0.35,1.20)*1.25;\n    \n    float radio1=0.8;\n    float d1= sdCircle( uv, radio1 );\n    float d2= sdCircle( uv, radio1 +0.05 );\n    \n     \n    float dI= opS( d1,d2 );\n    col = mix(col,vec3(1.0,0.82,0.0)*1.2,S(d1,0.0));\n    col = mix(col,vec3(0.0,0.0,0.)*1.2,S(dI,0.0));\n    col= Ojo(uv-vec2(-0.3,0.2), col);\n    col= Ojo(uv-vec2(0.3,0.2), col);\n    \n    col= Boca( uv-vec2(0.0,-0.2), col );\n   \n    //fragColor = vec4(col,1.0);\n    return col;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n   \n     if (id_material==6.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(1.00,0.5,0.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    \n    \n     if (id_material==7.0)\n    {\n        float escala=0.25;\n    \t//float d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n        float d = mod(floor(p.x*escala*0.5)+floor(p.z*escala*1.0),2.0);\n\t\t\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n     if (id_material==8.0)\n    {\n    \n\n        vec2 p2 = floor(p.xz*0.5);\n        float s = mod( p2.x + p2.y, 2.0 );\n        return vec3(1.0)*s;\n    }\n    \n    if (id_material==9.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(0.02,0.35,1.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    if (id_material==10.0)\n    {\n     vec3 pos=pp;\n    \n     vec4 mate = vec4(1.32,0.35,0.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    \n    //para esfera\n    if (id_material==11.0)\n    {\n        \n        vec2 uv=p.xy;\n        \n        uv=rotatev2(uv, radians(75.0));\n        \n        uv.y-=7.0;\n        uv*=0.625;\n        col= Sonrisa2d(uv);\n        \n        return col;\n    }\n    \n    \n    // pared\n    if (id_material==12.0)\n    {\n        \n        vec2 uv=p.xy;\n        uv=rotatev2(uv, radians(45.0));\n        uv.y-=20.0;\n        //uv*=0.065;\n        uv*=0.0325;\n        col= Sonrisa2d(uv);\n        return col;\n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(8.,8.0+6.0*sin(t),0);\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 596, 632, 632, 653], [654, 654, 686, 686, 770], [772, 816, 863, 863, 890], [892, 892, 935, 935, 962], [964, 964, 1012, 1012, 1040], [1041, 1125, 1161, 1161, 1206], [1208, 1273, 1307, 1307, 1405], [1406, 1406, 1440, 1440, 1532], [1533, 1533, 1567, 1567, 1659], [1660, 1700, 1734, 1734, 1831], [1834, 1874, 1899, 1899, 2585], [2589, 2589, 2654, 2654, 3248], [3252, 3303, 3327, 3327, 3515], [3517, 3517, 3550, 3550, 4011], [4013, 4067, 4103, 4103, 4337], [4394, 4428, 4508, 4508, 4781], [5151, 5151, 5184, 5184, 5206], [5207, 5207, 5240, 5240, 5262], [5263, 5263, 5296, 5296, 5317], [5319, 5319, 5356, 5356, 5436], [5439, 5439, 5474, 5474, 5502], [5505, 5505, 5535, 5535, 6271], [6275, 6275, 6306, 6306, 7010], [7014, 7014, 7040, 7040, 7509], [7510, 7561, 7608, 7608, 9765], [9819, 9819, 9912, 9912, 10192], [10197, 10246, 10303, 10303, 11492]], "test": "untested"}
{"id": "3lcfWB", "name": "[Sound] Drum beat synthesis", "author": "public_int_i", "description": "Attempting to figure out audio synthesis with a basic drum loop. The code also includes some other sounds I found in the process.", "tags": ["sound", "beat", "audio", "synthesis", "drum"], "likes": 8, "viewed": 360, "published": 3, "date": "1613923137", "time_retrieved": "2024-07-30T19:36:47.973852", "image_code": "//See Common for code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //display multiple bar graphs of different scales over top each other\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y -= .5;\n    float s = 0.;\n    for (float i = .00001; i < .002; i += i) {\n        s += step(uv.y,song(floor(iTime*10.)/10.+floor(uv.x*100.)/100.*i)*1.3);\n    }\n    fragColor = vec4(s/15.);\n}", "image_inputs": [], "common_code": "/*Ethan Alexander Shulman 2021 - https://xaloez.com/\nCC0, public domain*/\n\n\n//How often the instrument seed is switched.\n#define SWITCH_DELAY .4\n\n\n//Modified FNV-1A hash https://www.shadertoy.com/view/WtdfRX\nuvec4 hash(uvec4 seed) {\n    uvec4 h = (0x6A7F8FAAu^seed)*0x01000193u;\n    h = ((h.wxyz>>3u)^h^seed.yzwx)*0x01000193u;\n    h = ((h.zwxy>>8u)^h^seed.wxyz)*0x01000193u;\n    return h^(h>>11u);\n}\n#define I2F (1./float(0xFFFFFFFFu))\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\n//Variable Fractal Synthesizer https://www.shadertoy.com/view/3l3BWS\nfloat fractal(float t, float repX, float repY, float freq, uvec4 p) {\n    vec4 h = vec4(hash(p))*I2F;\n    vec2 pos = fract(vec2(t/repX,floor(t/repX)/repY));\n    \n    //apply folds based off hash\n    for (int i = 0; i < 8; i++) {\n        float fi = h[i/2], rv = h[(i+1)%4];\n        if (i%2 == 0) fi = fract(fi*10.)*10.;\n        else fi = floor(fi*10.);\n           \n        int id = int(fi)%4;\n        if (id == 0) {//mirror rotate fold\n            pos = (abs(pos)-.5)*r2(rv*6.28);\n        } else if (id == 1) {//plane fold\n            rv *= 6.28;\n            vec2 pnorm = vec2(sin(rv),cos(rv));\n            pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n        } else {//polar fold\n            float sz = .04+rv*1.6,\n                ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n            pos = vec2(sin(ang),cos(ang))*length(pos);\n        }\n        //apply box fold\n        float ext = h[i%4];\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n    float l = length(pos)*freq;\n    return sin(l*6.28);\n}\n\n\nfloat roughbasswobble(float t) {\n    return fractal(t, .3, 4., 1., uvec4(8232))*\n            fractal(t,.02,1424.,16.,uvec4(187))*.5;\n}\nfloat bass(float t) {\n    return fractal(t,.02-t*.00001,128.,4.,uvec4(11111))*max(0.,1.-t*8.);\n}\nfloat tomdrum(float t) {\n    return fractal(t,.3,150.,4.,uvec4(9234))*\n        fractal(t,.085,1.,7.,uvec4(0))*8.*max(0.,1.-t*8.);\n}\nfloat kickdrum(float t) {\n    return fractal(t,.03+t*.04, 64.,16.,uvec4(45,21,3,52))*max(0.,1.-t*8.);\n}\nfloat hatdrum(float t) {\n    return fractal(t,.001-t*.1,128.,64.,uvec4(111111111))*max(0.,1.-t*32.);\n}\nfloat snaredrum(float t) {\n    return (fractal(t,.002+t*.08,128.,4.,uvec4(1122343))+\n            fractal(t,.003+fract(t*121.273)*.02,128.,4.,uvec4(11111))*0.)*max(0.,1.-t*8.);\n}\nfloat rimdrum(float t) {\n    return fractal(t, .0013-t*.001, 64., 48., uvec4(334))*max(0.,1.-t*42.);\n}\nfloat laser(float t) {\n    return fractal(t, .001+t*.01, 24., 15., uvec4(451))*mod(max(0.,fract(t+.5)*2.-1.),2.);\n}\nfloat whine(float t) {\n    return fractal(t, .005, 24., 15., uvec4(451))*mod(max(0.,fract(t+.5)*2.-1.),2.);\n}\n\nfloat song(float t) {\n    return snaredrum(mod(t+.8,1.6))*0.2+\n           kickdrum(mod(t,1.6))*0.15+\n           hatdrum(mod(t,1./10.))*0.05*step(.7,mod(t-.2,1.6));\n}\n", "sound_code": "//See Common\n\nvec2 mainSound( int samp, float time )\n{\n    return vec2(song(time));\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 154, 392]], "test": "untested"}
{"id": "WlKBz1", "name": "TURN IT ON", "author": "yasuo", "description": "XS 7000 OG", "tags": ["puma"], "likes": 9, "viewed": 323, "published": 3, "date": "1613888564", "time_retrieved": "2024-07-30T19:36:48.840535", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat charD(vec2 p) {\n    float d = sdRoundedBox(p,vec2(0.035,0.05),vec4(0.035,0.035,0.0,0.0));\n    float d2 = sdRoundedBox(p,vec2(0.019,0.035),vec4(0.02,0.02,0.0,0.0));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat charI(vec2 p) {\n    float d = sdBox(p, vec2(0.01,0.05));\n    return d;\n}\n\nfloat charS(vec2 p) {\n    vec2 prevP = p;\n    p *= vec2(1.1,1.5);\n    p.y = abs(p.y);\n    p.y-=0.038;\n    float d = length(p)-0.04;\n    float d2 = length(p)-0.02;\n    d = max(-d2,d);\n    p = prevP;\n    \n    d2 = sdBox((p-vec2(0.023,0.0075))*Rot(radians(-60.5)), vec2(0.01,0.031));\n\n    d = max(-d2,d);\n    \n    d2 = sdBox((p-vec2(-0.019,-0.007))*Rot(radians(-60.5)), vec2(0.009,0.031));\n    d = max(-d2,d);\n    \n    d2 = sdBox((p-vec2(0.025,0.012)), vec2(0.012,0.008));\n    d = max(-d2,d);\n    \n    d2 = sdBox((p-vec2(-0.025,-0.012)), vec2(0.012,0.008));\n    d = max(-d2,d);\n    \n    return d;\n}\n\nfloat charC(vec2 p) {\n    p.x *= 1.15;\n    float d = abs(length(p)-0.041)-0.009;\n    float d2 = sdBox((p-vec2(0.03,0.0)), vec2(0.03,0.017));\n    d = max(-d2,d);\n    return d;\n}\n\nvec3 drawDiscChars(vec2 p, vec3 col) {\n    float d = charD(p-vec2(-0.12,0.0));\n    float i = charI(p-vec2(-0.05,0.0));\n    float s = charS(p-vec2(0.02,0.0));\n    float c = charC(p-vec2(0.115,0.0));\n    d = min(d,i);\n    d = min(d,s);\n    d = min(d,c);\n    col = mix(col,vec3(0.9,1.0,0.3),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer0(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p.y*=1.3;\n    p.y-=0.06;\n    p.x = abs(p.x);\n    p.x-=0.6;\n    p.x*=-1.0;\n    float d = sdBox(p, vec2(0.25,0.05));\n    float d2 = sdBox(p-vec2(-0.15,0.0), vec2(0.25,0.015));\n    d = max(-d2,d);\n    \n    float d3 = sdBox(p-vec2(0.0,-0.13), vec2(0.25,0.05));\n    d2 = sdBox(p-vec2(-0.07,-0.13), vec2(0.25,0.015));\n    d = min(d,max(-d2,d3));\n    \n    p*=vec2(0.3,0.3);\n    \n    d2 = sdRoundedBox(p-vec2(-0.09,-0.13),vec2(0.15,0.15),vec4(0.15,0.0,0.0,0.0));\n    d = max(-d2,d);\n    \n    col = mix(col,vec3(0.1,0.4,0.5),S(d,0.0));\n    \n    p = prevP;\n    \n    p = abs(p);\n    p -= vec2(0.83,0.44);\n    d = sdBox(p, vec2(0.003,0.03));\n    d2 = sdBox(p, vec2(0.03,0.003));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(1.0,1.0,0.2),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer1(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p-=vec2(0.0,-0.01);\n    p*=0.98;\n    p = abs(p);\n    \n    p-=vec2(0.5,0.25);\n    \n    float d = sdRoundedBox(p,vec2(0.2,0.1),vec4(0.0,0.1,0.0,0.0));\n    float d2 = sdRoundedBox(p-vec2(-0.022,0.023),vec2(0.181,0.081),vec4(0.0,0.07,0.0,0.0));\n    d = max(-d2,d);\n    \n    d2 = sdRhombus(p-vec2(0.179,0.1),vec2(0.05,0.09));\n    d2 = max(-p.y+0.1,d2);\n    \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.1,0.4,0.5),S(d,0.0));\n    \n    p = prevP;\n    p = abs(p);\n    p-=vec2(0.5,0.25);\n    \n    d = sdRoundedBox(p,vec2(0.2,0.1),vec4(0.0,0.1,0.0,0.0));\n    d2 = sdRoundedBox(p-vec2(-0.022,0.023),vec2(0.181,0.081),vec4(0.0,0.07,0.0,0.0));\n    d = max(-d2,d);\n    \n    d2 = sdRhombus(p-vec2(0.179,0.1),vec2(0.05,0.09));\n    d2 = max(-p.y+0.1,d2);\n    \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.9,0.1,0.3),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer2(vec2 p, vec3 col) {\n    p = DF(p,12.0);\n    p -= vec2(0.28);\n    float d = sdBox(p*Rot(radians(45.0)), vec2(0.02,0.02));\n    col = mix(col,vec3(0.2),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawDiscGraphicLayer3(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = abs(length(p) - 0.19)-0.01;\n    p.x = abs(p.x);\n    p.x -= 0.2;\n    float d2 = length(p) - 0.19;\n    d = max(-d2,d);\n    \n    p = prevP;\n    \n    d2 = length(p) - 0.32;\n    float d3 = sdBox(p, vec2(0.14,0.33));\n    d2 = max(-d3,d2);\n    \n    p -=vec2(0.01,0.04);\n    p.y*=1.1;\n    d3 = sdHexagon(p*Rot(radians(-30.0)),0.2);\n    d2 = max(-max(p.x,d3),d2);\n    \n    p = prevP;\n    \n    p +=vec2(0.01,0.05);\n    p.y*=1.1;\n    d3 = sdHexagon(p*Rot(radians(-30.0)),0.2);\n    d2 = max(-max(-p.x,d3),d2);\n    \n    d = min(d,d2);\n    \n    p.x += 0.23;\n    d = max(-dot(p,vec2(0.25,-0.03)),d);\n    \n    p = prevP;\n    \n    p.x -= 0.23;\n    d = max(-dot(p,vec2(-0.25,-0.03)),d);\n    \n    p = prevP;\n    \n    p.x = abs(p.x);\n    p.x -= 0.27;\n    d2 = sdBox(p*Rot(radians(-10.0)), vec2(0.005,0.09));\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = sdBox(p, vec2(0.01,0.29));\n    d3 = sdBox(p, vec2(0.02,0.22));\n    d = min(d,max(-d3,d2));\n    \n    p*=Rot(radians(10.0));\n    p.x+=0.032;\n    \n    d2 = sdBox(p, vec2(0.03,0.275));\n    d3 = sdBox(p-vec2(0.0,0.1), vec2(0.05,0.34));\n    d = min(d,max(-d3,d2));\n    \n    p = prevP;\n    d2 = length(p) - 0.4;\n    col = mix(col,vec3(.1),S(d2,0.0));\n    \n    col = mix(col,vec3(0.9,1.0,0.3),S(d,0.0));\n    \n    d = abs(length(p) - 0.35)-0.01;\n    col = mix(col,vec3(0.95),S(d,0.0));\n    \n    return col;\n}\n\nvec3 generativeBgGraphic(vec2 p, vec3 col) {\n    p.y += iTime*0.1;\n    vec2 prevP = p;\n    p*=15.0;\n\n    float t = floor(p.y);\n    float t2 = floor(p.x);\n    float n = fract(sin(t*674.3)*453.2);\n    float n2 = fract(sin(n*t2*674.3)*453.2);\n    vec2 p2 = fract(p)-.5;\n    \n    p2*=0.08;\n    \n    n = fract(sin(t*674.3)*453.2);\n    float x = 0.01;\n    float y = 0.008;\n    float w = 0.01;\n    float h = 0.005;\n    if(n<0.5)x = -0.01;\n    if(n2<0.5)y = -0.004;\n    if(n>0.8) w = 0.005;\n    if(n2>0.8) h = 0.02;\n    \n    float d = sdBox(p2, vec2(0.02,0.003));\n    float d2 = sdBox(p2-vec2(x,y), vec2(w,h));\n    d = min(d,d2);\n    \n    p2.x-=0.03;\n    if(n2>0.1 && n2<0.4) p2.x+=0.07;\n    \n    float size = 0.01;\n    if(n>0.1 && n<0.4) size=0.02;\n    \n    float d3 = sdBox(p2, vec2(size));\n    col = mix(col,vec3(0.1,0.8,0.7),S(d3,0.0));\n    \n    col = mix(col,vec3(0.1),S(d,0.0));\n    \n    return col*0.9;\n}\n\nvec3 drawInfo(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.01;\n    p.y -= 0.382;\n    float d = sdRhombus(p,vec2(0.04,0.012));\n    d = max(-p.x,d);\n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    p = prevP;\n    \n    d = sdBox(p-vec2(-0.08,0.38), vec2(0.015,0.003));\n    \n    float d2 = sdBox(p-vec2(0.08,0.38), vec2(0.015,0.003));\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(0.08,0.38), vec2(0.003,0.015));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // effect\n    float t = mod(iTime,6.0);\n    p.x+=(t>=0.1 && t<0.4)?sin(floor(p.y*100.0)*iTime*30.)*0.1:0.0;\n    \n    vec3 col = vec3(1.0);\n    \n    col = generativeBgGraphic(p,col);\n    col = drawDiscGraphicLayer0(p, col);\n    col = drawDiscGraphicLayer1(p, col);\n    col = drawDiscGraphicLayer2(p*Rot(radians(iTime*30.0)), col);\n    col = drawDiscGraphicLayer3(p*Rot(radians(iTime*30.0)), col);\n    col = drawDiscChars(p,col);\n    col = drawInfo(p,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 331, 368, 368, 448], [450, 501, 556, 556, 713], [715, 766, 808, 808, 998], [1000, 1051, 1080, 1080, 1108], [1109, 1109, 1151, 1151, 1346], [1348, 1348, 1369, 1369, 1553], [1555, 1555, 1576, 1576, 1633], [1635, 1635, 1656, 1656, 2230], [2232, 2232, 2253, 2253, 2408], [2410, 2410, 2448, 2448, 2731], [2733, 2733, 2779, 2779, 3564], [3566, 3566, 3612, 3612, 4482], [4484, 4484, 4530, 4530, 4693], [4695, 4695, 4741, 4741, 6116], [6118, 6118, 6162, 6162, 7021], [7023, 7023, 7056, 7056, 7542], [7544, 7544, 7601, 7601, 8162]], "test": "untested"}
{"id": "3tKBz1", "name": "Finite Repetition", "author": "oneshade", "description": "Reinventing the wheel to understand, I'm pretty sure its exact.", "tags": ["sdf", "repetition", "exact", "limited", "finite"], "likes": 4, "viewed": 205, "published": 3, "date": "1613887745", "time_retrieved": "2024-07-30T19:36:49.611474", "image_code": "// i: repeat interval\n// b: repetition bounds\n// Note: b must be evenly divisible by i!\nvec2 repFinite(in vec2 p, in vec2 i, in vec2 b) {\n    return p - 0.5 * i - clamp(i * floor(p / i + 0.5), -b, b);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat map(in vec2 p) {\n    float t = iTime;\n    vec2 i = vec2(1.0 + 0.5 * sin(t));\n\n    t *= 0.25;\n    vec2 r = mod(vec2(floor(3.0 + 3.0 * cos(t)), floor(3.0 + 3.0 * sin(t))), 3.0);\n\n    p = repFinite(p, i, i * r) + 0.5 * i;\n    return sdBox(p, vec2(0.1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float d = map(uv);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 88, 137, 137, 202], [204, 204, 239, 239, 324], [326, 326, 348, 348, 584], [586, 586, 641, 641, 1068]], "test": "untested"}
{"id": "3lKfR1", "name": "Starfield Experiment", "author": "YitingLiu", "description": "playing around with the grid and layers ", "tags": ["grid", "rotate", "star", "starfield", "infinite", "artofthecode"], "likes": 12, "viewed": 600, "published": 3, "date": "1613881410", "time_retrieved": "2024-07-30T19:36:50.381416", "image_code": "// followed tutorials https://youtu.be/rvDo9LvfoVE\n//https://youtu.be/dhuigO4A7RY\n\n#define NUM_LAYERS 5.\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);//distance to the center \n    float m = .03/d;//more light like than smoothstep(.1,.05,d);\n    \n    float rays= max(0.,1.-abs(uv.x*uv.y*1000.)); \n    m +=rays*flare;\n    \n    uv*=Rot(3.1415/4.);\n    rays= max(0.,1.-abs(uv.x*uv.y*1000.));\n    m+=rays*.5*flare;\n    m*=smoothstep(.5,.2,d);\n    \n    return m;\n\n\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n    \n\n}\n\nvec3 StarLayer(vec2 uv) {\n\tvec3 col = vec3(0);\n\t\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    // should add <=\n    for(int y=-1;y<=1;y++) {\n    \tfor(int x=-1;x<=1;x++) {\n            vec2 offs = vec2(x, y);\n            \n    \t\tfloat n = Hash21(id+offs); // random between 0 and 1\n            float size = fract(n*345.32);\n            \n    \t\tfloat star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.6, 1., size)*.6);\n            \n            vec3 color = sin(vec3(.5, .1, .9)*fract(n*2345.2)*123.2)*.5+.5;\n            color = color*vec3(1,.2,.8+size)+vec3(.2, .2, .1)*2.;\n            \n            star *= sin(iTime*2.+n*6.2831)*.5+1.;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*.03;\n   \n\n    uv*=Rot(t);\n    uv.x+=max(t*.0001,1.);\n    uv.y-=max(t*.0001,.5);\n\n    vec3 col = vec3(0);\n    \n    for (float i =0.; i <1.;i+=1./NUM_LAYERS){\n\n        float depth = fract(i+t);\n        float scale = mix (50.,2.,depth);\n        float fade = depth*smoothstep(1., .9, depth);\n        col += StarLayer(uv*scale+i*4532.-M)*fade;\n\n    }\n    \n        col = pow(col, vec3(.85));\t// gamma correction\n \n    \n    //if(gv.x>.48|| gv.y>.48) col.r=1.;//coloring the grid\n  \n    //col+=Hash21(id);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 124, 124, 184], [186, 186, 219, 219, 555], [557, 557, 578, 578, 677], [679, 679, 704, 704, 1404], [1405, 1405, 1462, 1462, 2140]], "test": "untested"}
{"id": "3lKBR1", "name": "Circuit board fractal 8", "author": "jarble", "description": "I found a fractal pattern that looks like a circuit board.", "tags": ["fractal", "circuit"], "likes": 3, "viewed": 270, "published": 3, "date": "1613877931", "time_retrieved": "2024-07-30T19:36:51.255080", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return abs(fract(a*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 2.0;\n    float offset = .3;\n    float scale2 = 1.025;\n    for(int c=0;c<3;c++){\n        float scale = 1.45;\n        vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        \n        \n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv+col.xy,scale);\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv.y *= -1.0;\n            scale /= scale2+col.x;\n            offset /= scale2;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 76], [78, 78, 135, 135, 799]], "test": "untested"}
{"id": "3lVfzh", "name": "Lightning and Sunshine", "author": "timeisbeautifulhere", "description": "For a good friend of mine.\n\nThe code is hilariously sloppy though, please don't scrutinize it :P", "tags": ["sun", "lightning", "thunder", "sunshine"], "likes": 3, "viewed": 317, "published": 3, "date": "1613876186", "time_retrieved": "2024-07-30T19:36:52.116775", "image_code": "\n#define LIGHTNING_POINTS 12\n\n#define LIGHTNING_COLOR vec3(0.0,0.0,1.0)\n#define OFFSET 0.05\n#define OFFSET_TIMECONST 45.0\n//This looks interesting\n//#define OFFSET_TIMECONST 175.0\n#define SCALE_FACTOR 0.95\n#define WHITE vec3(1.0)\n\n#define SUN_POS vec2(0.0,0.7)\n#define SUN_RADIUS 0.2\n#define SUN_COLOR vec3(1.0,0.84,0.0)\n\n#define SUNRAY_RADIUS 0.7\n#define SUNRAY_COUNT 14.0\n#define SUNRAY_STRIPE_COUNT 10.0\n#define SUNRAY_SCALE 0.5\n#define SUNRAY_STRIPE_THICKNESS 0.01\n#define SUNRAY_COLOR vec3(1.0,0.41,0.0)\n#define SUNRAY_TIME_CONST 0.3\n\n#define PI 3.14159\n\n#define L_CLOSE 1\n#define L_MID 2\n#define L_FAR 3\n#define L_NONE 0\n#define L_DEBUG 10\n#define L_DEBUG2 11\n\n#define S_ORB 1\n#define S_RAY 2\n#define S_NONE 0\n\n#define BEAN_COUNT_X 8.0\n#define BEAN_COUNT_Y 5.0\n#define BEAN_THICKNESS 0.02\n#define BEAN_LENGTH 0.03\n#define BEAN_TIME_CONST 0.05\n#define BEAN_COLOR vec3(0.5,0.05,0.0)\n\nint lightning_check(vec2 uv){\n\n    float sun_y = (SUN_POS.y+1.0)/2.0;\n    if(uv.y>sun_y)\n        return L_NONE;\n    uv.y /= sun_y;\n    if(uv.y>0.95)\n        return L_NONE;\n    \n    float lightning_width = SUNRAY_RADIUS/2.0;\n    \n    int l_points = LIGHTNING_POINTS;\n    \n    int lightning_n1 = int(floor(uv.y*float(l_points)));\n    int lightning_n2 = int(ceil(uv.y*float(l_points)));\n    \n    float lightning_y1 = float(lightning_n1)/float(l_points);\n    float lightning_y2 = float(lightning_n2)/float(l_points);\n    \n    float width_n1 = lightning_width*lightning_y1,\n        width_n2 = lightning_width*lightning_y2;\n    \n    float scale1 = pow(SCALE_FACTOR, float(l_points)-float(lightning_n1)),\n        scale2 = pow(SCALE_FACTOR, float(l_points)-float(lightning_n2));\n    width_n1 *= scale1;\n    width_n2 *= scale2;\n    \n    float uv_interp = (lightning_y2-uv.y)/(lightning_y2-lightning_y1);\n    float width_uv = mix(width_n2, width_n1, uv_interp);\n    \n    float offset_offset = sin(iTime*OFFSET_TIMECONST);\n\n    float offset1 = OFFSET * scale1 * offset_offset,\n        offset2 = -1.0 * OFFSET * scale2 * offset_offset;\n    if(lightning_n1%2==0){\n        offset1*=-1.0;\n        offset2*=-1.0;\n    }\n    \n    if(lightning_n1==0)\n        offset1 = 0.0;\n    \n    float left_n1 = (-1.0)*width_n1/2.0+offset1,\n        right_n1 = width_n1/2.0+offset1,\n        left_n2 = (-1.0)*width_n2/2.0+offset2,\n        right_n2 = width_n2/2.0+offset2;\n\n    float left_uv = mix(left_n2, left_n1, uv_interp),\n        right_uv = mix(right_n2, right_n1, uv_interp),\n        middle_uv = (left_uv+right_uv)/2.0;\n    \n    if(uv.x < left_uv || uv.x > right_uv)\n        return L_NONE;\n    \n    float dist_uv = abs(uv.x-middle_uv);\n    float dist_proportion = 2.0*dist_uv/width_uv;\n    \n    if(dist_proportion<0.4)\n        return L_CLOSE;\n    if(dist_proportion<0.8)\n        return L_MID;\n    else if(dist_proportion<=1.0)\n        return L_FAR;\n    else if(dist_proportion>1.0)\n        return L_FAR;\n    else\n        return L_NONE;\n}\n\nint sun_check(vec2 uv){\n    vec2 sun_pos = SUN_POS;\n    uv.y = 2.0*uv.y-1.0;\n    vec2 relative_uv = uv - sun_pos;\n    vec2 relative_pc = vec2(\n        atan(relative_uv.y, relative_uv.x),\n        length(relative_uv)\n    );\n    \n    if(relative_pc[1]>SUNRAY_RADIUS)\n        return S_NONE;\n    \n    if(relative_pc[1]<=SUN_RADIUS)\n        return S_ORB;\n    \n    if(relative_pc[1]<=SUNRAY_RADIUS){\n        \n        //angle = [0,2PI]\n        float uv_angle = relative_pc[0]+PI;\n        float angle_displace = mod(iTime*SUNRAY_TIME_CONST, 2.0*PI);\n        uv_angle += angle_displace;\n        \n        float ray_angle_size = 2.0*PI/SUNRAY_COUNT;\n        float ray_n = floor(uv_angle/ray_angle_size);\n        float ray_angle_displace = (ray_angle_size - (ray_angle_size*SUNRAY_SCALE))/2.0;\n        \n        float ray_start = ray_n * ray_angle_size + ray_angle_displace,\n            ray_end = (ray_n+1.0) * ray_angle_size - ray_angle_displace;\n        \n        //Check if angle is in \"bounds\" of closest ray\n        if(uv_angle<ray_start || uv_angle>ray_end)\n            return S_NONE;\n        \n        //Finally, check if distance from sun puts\n        //uv on a \"ray stripe\"\n        float dist_outside_sun = relative_pc[1]-SUN_RADIUS;\n        float ray_length = SUNRAY_RADIUS-SUN_RADIUS;\n        float stripe_dist = ray_length/SUNRAY_STRIPE_COUNT;\n        \n        float closest_stripe_n = floor(dist_outside_sun/stripe_dist),\n            closest_stripe = closest_stripe_n * stripe_dist;\n        \n        if(closest_stripe_n<0.001)\n            return S_NONE;\n        \n        if(abs(closest_stripe-dist_outside_sun)<SUNRAY_STRIPE_THICKNESS)\n            return S_RAY;\n        \n        \n        return S_NONE;\n    }\n    return S_NONE;\n}\n\nbool bean_check(vec2 uv){\n    //[0,1]\n    uv.x = (uv.x+1.0)/2.0;\n    uv.x = fract(uv.x - iTime*BEAN_TIME_CONST);\n\n    float bean_dy = 1.0/BEAN_COUNT_Y,\n        bean_dx = 1.0/BEAN_COUNT_X;\n    \n    float closest_bean_y_n = round(uv.y/bean_dy),\n        closest_bean_x_n = round(uv.x/bean_dx);\n    \n    float closest_bean_y = closest_bean_y_n * bean_dy,\n        closest_bean_x = closest_bean_x_n * bean_dx;\n    \n    if(abs(closest_bean_y-uv.y)<BEAN_THICKNESS\n        && abs(closest_bean_x-uv.x)<BEAN_LENGTH){\n        //return true;\n        \n        float x_relative = uv.x-closest_bean_x;\n        if(abs(x_relative)<(BEAN_LENGTH-BEAN_THICKNESS))\n            return true;\n    \n        //Check if inside bounds of a rounded edge\n        //by making ends semicircles\n        vec2 bean_edge = vec2(0.0);\n        \n        if(x_relative<0.0){\n            bean_edge = vec2(\n                closest_bean_x-BEAN_LENGTH+BEAN_THICKNESS,\n                closest_bean_y\n            );\n        }else{\n            bean_edge = vec2(\n                closest_bean_x+BEAN_LENGTH-BEAN_THICKNESS,\n                closest_bean_y\n            );\n        }\n        \n        return distance(uv,bean_edge)<=BEAN_THICKNESS;\n            \n    }\n    else\n        return false;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // x = [-1,1], y = [0,1]\n    vec2 uv = vec2(\n        (2.0*fragCoord.x-iResolution.x)/iResolution.x,\n        fragCoord.y/iResolution.y\n    );\n    vec3 col = vec3(0.0);\n    \n    if(bean_check(uv))\n        col = BEAN_COLOR;\n    \n    int s_check = sun_check(uv);\n    int l_check = lightning_check(uv);\n    \n    if(s_check == S_RAY)\n        col = SUNRAY_COLOR;\n    \n    if(l_check == L_CLOSE)\n        col = mix(LIGHTNING_COLOR, WHITE, 0.7);\n    else if(l_check == L_MID)\n        col = mix(LIGHTNING_COLOR, WHITE, 0.3);\n    else if(l_check == L_FAR)\n        col = LIGHTNING_COLOR;\n    \n    if(s_check == S_ORB)\n        col = SUN_COLOR;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[888, 888, 917, 917, 2897], [2899, 2899, 2922, 2922, 4625], [4627, 4627, 4652, 4664, 5871], [5878, 5878, 5935, 5964, 6631]], "test": "untested"}
{"id": "3lKfzh", "name": "sin cos wave ", "author": "X01", "description": "https://www.shadertoy.com/view/XsX3zS", "tags": ["wave"], "likes": 4, "viewed": 345, "published": 3, "date": "1613873504", "time_retrieved": "2024-07-30T19:36:52.982461", "image_code": "#define WAVES 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.3;\n\t\tp.y += sin(p.x * 12.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 629]], "test": "untested"}
{"id": "3tKBzh", "name": "House of Mirrors", "author": "oneshade", "description": "Recursive tiling.", "tags": ["grid", "webcam", "tiling", "recurse"], "likes": 10, "viewed": 434, "published": 3, "date": "1613868751", "time_retrieved": "2024-07-30T19:36:53.784317", "image_code": "float Hash11a(in float x) { return fract(474.951 * cos(284.385 * x)); }\nfloat Hash11b(in float x) { return fract(381.79 * cos(974.385 * x)); }\nfloat Hash21a(in vec2 p) { return fract(585.394 * cos(dot(p, vec2(495.385, 395.978)))); }\nfloat Hash21b(in vec2 p) { return fract(968.385 * cos(dot(p, vec2(375.483, 384.484)))); }\n\nvoid Rotate(inout vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    p *= mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y + iTime * 0.1;\n\n    uv *= 1.5;\n    vec2 cell = floor(uv);\n    vec2 local = fract(uv) - 0.5;\n\n    for (float iter=0.0; iter < 10.0; iter++) {\n        Rotate(local, floor(Hash21a(cell) * Hash11a(iter) * 4.0) * 1.57);\n        if (Hash21b(cell) * Hash11b(iter) > 0.232) break;\n        local *= 3.0;\n        cell = floor(local);\n        local = fract(local) - 0.5;\n    }\n\n    fragColor = texture(iChannel0, local + 0.5);\n    float border = step(0.0, max(abs(local.x), abs(local.y)) - 0.45);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.6, 0.35, 0.0), border);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 71], [72, 72, 99, 99, 142], [143, 143, 169, 169, 232], [233, 233, 259, 259, 322], [324, 324, 363, 363, 427], [429, 429, 484, 484, 1082]], "test": "untested"}
{"id": "ttGfR1", "name": "Inside-out building", "author": "illus0r", "description": "Inside-out building", "tags": ["raymarching"], "likes": 9, "viewed": 436, "published": 3, "date": "1613850962", "time_retrieved": "2024-07-30T19:36:54.595149", "image_code": "#define rnd(x) fract(54321.987 * sin(987.12345 * x))\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n\n\nfloat boxSize = .3;\nvec3 p;\nfloat id;\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat dist(vec3 pv){\n    float cont = sdRoundBox(pv,vec3(boxSize*3.-.01),0.);\n    id = length(floor(pv*boxSize*11.)*vec3(10.,100.,1000.));\n    pv=mod(pv,boxSize)-boxSize/2.;\n    float boxes = -sdRoundBox(pv,vec3(boxSize/2.-.001),0.);\n    p=pv;\n    return max(boxes, cont);\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(.0001,0.);\n\treturn normalize(vec3(\n    \tdist(p+e.xyy)-dist(p-e.xyy),\n    \tdist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float d=0.,i,e=1.;\n    vec3 rd=normalize(vec3(uv,3));\n    for(i=0.;i<99.&&e>.001;i++){\n        p=rd*d-vec3(.0,.0,5.);\n        mat2 rotXZ = rot(iTime);\n        mat2 rotXY = rot(iTime);\n        p.xz*=rotXZ;\n        p.xy*=rotXY;\n        d+=e=dist(p);\n    }\n    \n    if(rnd(id)<.5)\n        fragColor = texture(iChannel0,p);\n    else\n        fragColor = texture(iChannel1,p);\n    fragColor*=rnd(floor(iTime*5.+id))*.5+.5;\n    fragColor*=dot(normalize(p)*.6+.4,vec3(1.)*.5+.5);\n\n    //float cont = sdBox(uv,vec2(2.*boxSize*iMouse.x/iResolution.x));\n    //uv=mod(uv,boxSize)-boxSize/2.;\n    //float boxes = -sdBox(uv,vec2(boxSize/2.));\n    //float d = max(cont, boxes);\n    //\n    //vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\t//col *= 1.0 - exp(-3.0*abs(d));\n\t//////col *= 0.8 + 0.2*cos(150.0*d);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\t//fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 71, 71, 118], [160, 160, 205, 205, 296], [299, 299, 319, 319, 573], [575, 575, 593, 593, 760], [762, 762, 799, 799, 879], [881, 881, 938, 938, 1901]], "test": "untested"}
{"id": "WtyfR1", "name": "SSAO (Screen Space AO)", "author": "moranzcw", "description": "Crytek's SSAO.", "tags": ["3d", "ao", "ssao"], "likes": 14, "viewed": 1956, "published": 3, "date": "1613845851", "time_retrieved": "2024-07-30T19:36:55.366088", "image_code": "// SSAO (Screen Space AO) - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define AOradius 2.0\n#define Samples 64.0\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nvec3 sphereVolumeRandPoint()\n{\n    vec3 p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    while(length(p)>1.0)\n    {\n        p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    }\n    return p;\n}\n\nfloat depth(vec2 coord)\n{\n    vec2 uv = coord*vec2(iResolution.y/iResolution.x,1.0);\n    return texture(iChannel0, uv).x;\n}\n\nfloat SSAO(vec2 coord)\n{\n    float cd = depth(coord);\n    float screenRadius = 0.5 * (AOradius / cd) / 0.53135;\n    float li = 0.0;\n    float count = 0.0;\n    for(float i=0.0; i<Samples; i++)\n    {\n        vec3 p = sphereVolumeRandPoint() * frand();\n        vec2 sp = vec2(coord.x + p.x * screenRadius, coord.y + p.y * screenRadius);\n        float d = depth(sp);\n        float at = pow(length(p)-1.0, 2.0);\n        li += step(cd + p.z * AOradius, d) * at;\n        count += at;\n    }\n    return li / count;\n}\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // coordinate\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = fragCoord/iResolution.y;\n    \n    float d = depth(coord);\n    vec3 ao = vec3(0.4) + step(d, 1e5-1.0) * vec3(0.8) * SSAO(coord);\n    vec3 color = mix(background(uv.y), ao, 1.0 - smoothstep(0.0, 0.99, d*d/1e3));;\n    \n    color = pow(color,vec3(1.0/2.2)); // gamma\n\tfragColor = vec4(color, 1.0);\n}\n ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// SSAO (Screen Space AO) - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere spheres[5];\n\nvoid initSpheres()\n{\n    spheres[0] = Sphere(0.5, vec3(0.0, 0.5, -0.2));\n    spheres[1] = Sphere(0.7, vec3(-1.7, 0.7, -0.8));\n    spheres[2] = Sphere(1.0, vec3(1.8, 1.0, -0.5));\n    spheres[3] = Sphere(2.0, vec3(0.0, 2.0, -2.8));\n    spheres[4] = Sphere(1000.0, vec3(0.0, -1000.0, 0.0));\n}\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n    // init spheres\n    initSpheres();\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(-2.0, 3.0, 6.0), vec3(2.0, 3.0, 6.0), sin(iTime*0.3));\n    vec3 lookAt = vec3(0.0, 2.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color=vec3(0.0);\n    \n    // intersect\n    float t = 1e5;\n    int id;\n    for(int i=0; i<5; i++)\n    {\n        float temp = intersect(spheres[i], ray);\n        if(temp > Epsilon && temp < t)\n        {\n            t = temp;\n            id = i;\n        }\n    }\n    \n    float depth = t;\n    \n\tfragColor = vec4(depth, vec3(0.0));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyfR1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[371, 371, 392, 392, 404], [405, 405, 424, 424, 479], [480, 480, 499, 499, 531], [532, 638, 657, 657, 712], [714, 714, 744, 744, 908], [910, 910, 935, 935, 1033], [1035, 1035, 1059, 1059, 1542], [1544, 1544, 1576, 1576, 1667], [1669, 1669, 1727, 1751, 2210]], "test": "untested"}
{"id": "Wlyfz1", "name": "Circuit board fractal 7", "author": "jarble", "description": "I found a fractal pattern that looks like a circuit board.", "tags": ["fractal", "circuit"], "likes": 11, "viewed": 483, "published": 3, "date": "1613841038", "time_retrieved": "2024-07-30T19:36:56.234765", "image_code": "vec2 c = vec2(0.0,0.0); //change this constant to get different patterns!\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 2.0;\n    float offset = .16;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = 1.5;\n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            if(uv.y<uv.x) uv=uv.yx;\n\n            uv = triangle_wave(uv+col.xy,scale);\n            uv.y *= -1.0;\n            scale /= scale2+col.x;\n            offset /= scale2;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlyfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 114, 114, 155], [157, 157, 214, 214, 888]], "test": "untested"}
{"id": "WtGfR1", "name": "Smooth koch coordinate transform", "author": "mrange", "description": "License CC0: Smooth Koch coordinate transform\nPlaying around with koch mappings and attempt to smooth the distance\nfunction between cells", "tags": ["2d", "koch"], "likes": 29, "viewed": 676, "published": 3, "date": "1613835703", "time_retrieved": "2024-07-30T19:36:57.094467", "image_code": "// License CC0: Smooth koch coordinate transform\n//  Playing around with koch mappings and attempt to smooth the distance\n//  function between cells\n\n#define TIME        iTime\n#define TTIME       (TIME*TAU)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define N(a)        vec2(sin(a), cos(a))\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)       dot(x, x)\n#define PSIN(x)     (0.5 + 0.5*sin(x))\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898, 58.233))) * 13758.5453);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nconst float truchet_lw = 0.0125;\n\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\n// Attempt for classic koch mapping, thanks to art of code YT\nvoid koch(inout vec2 p) {\n  const float a = PI*2.0/3.0;\n  const vec2 nn = N(PI*5.0/6.0);\n  const vec2 n = N(a);\n\n  p.y -= sqrt(0.75);\n  p.x = abs(p.x);\n  p.x += -1.5;\n  p   -= nn*max(0.0, dot(p, nn))*2.0;\n  p.x -= -1.5;\n\n  const int levels = 6;\n  \n  p.x  = abs(p.x);\n  p.x -= 0.5;\n  p   -= n*min(0.0, dot(p, n))*2.0;\n\n\n  float s = 1.0;\n  for (int i = 1; i < levels; ++i) {\n    s /= 3.0;\n    p *= 3.0;\n    p.x -= 1.5;\n    \n    p.x  = abs(p.x);\n    p.x -= 0.5;\n    p   -= n*min(0.0, dot(p, n))*2.0;\n  }\n\n  p *= s;  \n}\n\n// Attempt to smooth koch mapping\nvoid skoch(inout vec2 p) {\n  const float a       = PI*2.0/3.0;\n  const vec2  nn      = N(PI*5.0/6.0);\n  const vec2  n       = N(a);\n  const int   levels  = 4;\n  const float k       = 0.0125;\n\n  p.xy = p.yx;\n  smoothKaleidoscope(p, k, 6.0);\n  p.xy = p.yx;\n  p.y -= 0.875;\n\n  p.x  = pabs(p.x, k*2.0);\n  p.x -= 0.5;\n  p   -= n*pmin(0.0, dot(p, n), k)*2.0;\n\n  float s = 1.0;\n  for (int i = 1; i < levels; ++i) {\n    s /= 3.0;\n    p *= 3.0;\n    p.x -= 1.5;\n    \n    p.x  = pabs(p.x, k/s*2.0);\n    p.x -= 0.5;\n    p   -= n*pmin(0.0, dot(p, n), k/s)*2.0;\n  }\n\n  p *= s;  \n}\n\n\nvec2 truchet_cell0(vec2 p, float h) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return vec2(d, 1E6); // 1E6 gives a nice looking bug, 1E4 produces a more \"correct\" result\n}\n\nvec2 truchet_cell1(vec2 p, float h) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2  = circle(p, mix(0.2, 0.4, h));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return vec2(d, d2+truchet_lw);\n}\n\nfloat truchet(vec2 p) {\n  vec2 np = mod2_1(p);\n  float r = hash(np);\n\n  p *= truchet_rots[int(r*4.0)];\n  float rr = fract(r*31.0);\n  vec2 cd0 = truchet_cell0(p, rr);\n  vec2 cd1 = truchet_cell1(p, rr);\n  vec2 d0 = mix(cd0, cd1, vec2(fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0.x);\n  d = abs(d) - truchet_lw;\n\n  return d;\n}\n\nfloat snowFlake(vec2 p) {\n  const float s = 0.2;\n\n  vec2 kp = p;\n  skoch(kp);\n  kp -= 0.7345;\n  kp *= ROT(1.0);\n  koch(kp);\n  kp += TIME*0.05;\n\n  float d = truchet(kp/s)*s;\n  return d-0.0025;\n}\n\nfloat df(vec2 p) {\n  const float rep = 10.0;\n  const float sm  = 0.05*6.0/rep;\n  mat2 rot = ROT(TTIME/240.0);\n  p *= rot;\n  smoothKaleidoscope(p, sm, rep);\n  p *= rot;\n  const float ss = 0.55;\n  return snowFlake(p/ss)*ss;\n}\n\nfloat height(vec2 p) {\n  float d = df(p);\n  float h = tanh_approx(smoothstep(0.02, 0.0, d)*mix(2.0, 6.0, PSIN(TTIME/60.0)));\n  return -h*0.01;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 col = vec3(0.0);\n  float d = df(p);\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lcol1 = vec3(1.5, 1.5, 2.0).zyx;\n  vec3 lcol2 = vec3(2.0, 1.5, 0.75).zyx;\n  vec3 lpow1 = 0.15*lcol1/L2(ld1);\n  vec3 lpow2 = 0.5*lcol2/L2(ld2);\n  vec3 dm = vec3(1.0)*tanh(-h*10.0+0.125);\n  col += dm*diff1*diff1*lpow1;\n  col += dm*diff2*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 10.0)*lcol1;\n  col += rm*pow(ref2, 10.0)*lcol2;\n  col = postProcess(col, q);  \n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGfR1.jpg", "access": "api", "license": "cc0-1.0", "functions": [[577, 577, 605, 625, 701], [702, 702, 729, 729, 798], [800, 800, 821, 821, 889], [891, 891, 930, 930, 1018], [1020, 1020, 1059, 1059, 1088], [1090, 1090, 1120, 1120, 1147], [1289, 1289, 1320, 1320, 1346], [1348, 1348, 1393, 1393, 1547], [1549, 1549, 1571, 1571, 1615], [1617, 1617, 1638, 1638, 1683], [1685, 1685, 1746, 1746, 1959], [1961, 2023, 2048, 2048, 2538], [2540, 2574, 2600, 2600, 3140], [3143, 3143, 3180, 3180, 3409], [3411, 3411, 3448, 3448, 3646], [3648, 3648, 3671, 3671, 3982], [3984, 3984, 4009, 4009, 4177], [4179, 4179, 4197, 4197, 4402], [4404, 4404, 4426, 4426, 4548], [4550, 4550, 4571, 4571, 4777], [4779, 4779, 4815, 4815, 5048], [5050, 5050, 5105, 5105, 6335]], "test": "untested"}
{"id": "tlKfzz", "name": "iceberger", "author": "FabriceNeyret2", "description": "WIP:  don't let border clip shape !  \nreproducing [url]https://joshdata.me/iceberger.html[/url] Using smart MIPmaps.\nDraw iceberg (TAB to erase).    SPACE to start/pause the physics.\nRed dot = center of mass, \nGreen dot = immerged center of mass.", "tags": ["simulation", "physics", "reproduction", "gpmipmap", "iceberger"], "likes": 5, "viewed": 341, "published": 3, "date": "1613819597", "time_retrieved": "2024-07-30T19:36:57.961149", "image_code": "// reproducing https://joshdata.me/iceberger.html\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U).x  - T(U).y *vec4(.3,.3,-1,0); \n    O = mix(O, vec4(1,0,0,0), D( G.xy, 10.) );\n    O = mix(O, vec4(0,1,0,0), D( G.zw, 10.) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R              iResolution.xy\n#define dt             iTimeDelta\n//#define T(U)         texelFetch( iChannel0, ivec2(U), 0 )\n#define T(U)           texture( iChannel0, (U)/R )\n#define M            ( textureLod(iChannel0,vec2(.5) , 20.) +1e-9 )  // total mass\n#define G              textureLod(iChannel1,vec2(.5) , 20.)          // center of mass\n#define D(C,r)         smoothstep( 1.5, 0., length(C-U) - r )        // antialiased disk\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define rot(a)         mat2( cos(a), -sin(a), sin(a), cos(a) )", "buffer_a_code": "// O.x = iceberg, O.y = ocean, O.z = immerged iceberg.  \n// Ultimate MIPmap = mass (i.e., volume )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 F = keyToggle(32.)                              // --- physics\n               ? G.zww - G.xyy*vec3(1,1,.95) : vec3(0);  // moment+force applying on the iceberg\n            // ? vec2(G.z-G.x, .9 - M.z/M.x).xyy : vec3(0); // WIP: \"better\" physics don't work\n     mat2 r = rot( F.x*F.y*dt*.01 );\n     O = T( (U-G.xy) * r + G.xy  - vec2(0,F.z)*dt );     // previous step ( possibly rot+translate )\n  // O.x = smoothstep(0.,1.,O.x);                        // recontrast\n\nif (iMouse.z>0.)                                         // --- paint\n       O.x = keyToggle(9) \n               ? max( 0., O.x - D( iMouse.xy, .1*R.y ) ) // erase iceberg\n               : max(O.x, D( iMouse.xy, .1*R.y ) );      // paint iceberg\n\n    O.y = step( U.y/R.y , .7 );                          // ocean\n    U = R-1.-abs(2.*U-R); if (U.x*U.y<.5) O.x = 0.;      // clamp paint\n    O.z = O.x*O.y;                                       // immerged part of the iceberg    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*  // --- dynamics simulation\n\n    mat2 r = rot( T(1.5).w*dt );\n    O = T( (U-G.xy) * r + G.xy  - vec2(0,T(.5).w*dt) );    // previous step ( possibly rot+translate )\n\n   if ( U.x<2. && U.y<2. ) {\n        vec3 F = keyToggle(32.)                         // --- physics\n               ? G.zww - G.xyy*vec3(1,1,.95) : vec3(0); // torque+force applying on the iceberg\n        O.w = .99*T(U).w + ( U.x<1. ? F.z*dt : F.x*F.y*dt*dt );  // 0,0: Fy  1,1: torque\n    } \n*/\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ultimate MIPmap of O.xy = center of mass\n// ultimate MIPmap of O.zw = immerged center of mass\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec4 D = T(U) / M;  // density field\n    O.xy = D.x * U;\n    O.zw = D.z * U;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 230]], "test": "untested"}
{"id": "tlVfRz", "name": "Particle Motion", "author": "hanker", "description": "参考效果：https://www.shadertoy.com/view/MssXDn\n通过一个粒子+三条发光线条组成一个元素，多个元素通过一个排列的方法组合成形状", "tags": ["particle"], "likes": 6, "viewed": 355, "published": 3, "date": "1613808886", "time_retrieved": "2024-07-30T19:36:58.817859", "image_code": "#define PI 3.1415926\n#define PARTICLE_NUMBER 80.\n\nfloat grow(vec2 uv,float growWidth,float filmWidth){\n    //发光效果的本质是定义了一个矩形，矩形内通过x和y的坐标去进行渐变\n    if(abs(uv.y) > growWidth)return 0.;\n    float y = uv.y / growWidth;\n    float d = abs(uv.x / filmWidth);\n    return sqrt(1. - y * y) / (d) * .1;\n}\nfloat star(vec2 uv,float growWidth,float filmWidth){\n    //通过旋转矩阵去生成其他两条光带 +-60度\n    //二维矩阵\n    vec2 rotUV1 = mat2(\n        cos(PI / 3.),-sin(PI / 3.),\n        sin(PI / 3.),cos(PI / 3.)\n    ) * uv;\n    vec2 rotUV2 = mat2(\n        cos(PI / 3.),sin(PI / 3.),\n        -sin(PI / 3.),cos(PI / 3.)\n    ) * uv;\n    return grow(uv,growWidth,filmWidth) + grow(rotUV1,growWidth,filmWidth) +grow(rotUV2,growWidth,filmWidth) ;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iTime;\n\n    vec3 color = vec3(0.);\n    for(float i = 0.; i < PARTICLE_NUMBER; i+=1.){\n        float t = i / PARTICLE_NUMBER;\n        float a = t * 2. * PI + iTime * .1;\n        //定义环形的方法（数学真伟大）\n        vec3 pos=vec3(\n            sin(a)+2.0*sin(2.0*a),\n            cos(a)-2.0*cos(2.0*a),\n            -sin(3.0*a))*0.01;\n        float a1 = .1 * iTime;\n\n        //整体再旋转\n        pos.xy *= mat2(\n            cos(a1),-sin(a1),\n            sin(a1),cos(a1)\n        ) * 30.;\n       \n       //简单加一下颜色，毕竟只白色还是差点意思\n        color += star(uv + pos.xy,.02,.3) * abs(vec3(\n            sin(i + .123),sin(i + .412),sin(i + .789)\n        ));\n    }\n    fragColor = vec4(color,1.);\n}\n   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 102, 201, 352], [353, 353, 405, 484, 809], [810, 810, 863, 863, 1711]], "test": "untested"}
{"id": "ttVfzR", "name": "Circuit Truchet", "author": "oneshade", "description": "Circuit board looking truchet pattern.", "tags": ["truchet", "pattern", "caustic", "circuit", "pcb"], "likes": 13, "viewed": 459, "published": 3, "date": "1613791534", "time_retrieved": "2024-07-30T19:36:59.679555", "image_code": "vec2 Rotate(in vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    return p * mat2(c, -s, s, c);\n}\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Hash31(in vec3 p) {\n\tvec3 p3 = fract(p * 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Smooth 3D noise\nfloat snoise(in vec3 p) {\n    vec3 c = floor(p);\n    vec3 l = fract(p);\n    l *= l * (3.0 - 2.0 * l);\n\n    float ldb = Hash31(c);\n    float rdb = Hash31(c + vec3(1.0, 0.0, 0.0));\n    float lub = Hash31(c + vec3(0.0, 1.0, 0.0));\n    float rub = Hash31(c + vec3(1.0, 1.0, 0.0));\n    float ldf = Hash31(c + vec3(0.0, 0.0, 1.0));\n    float rdf = Hash31(c + vec3(1.0, 0.0, 1.0));\n    float luf = Hash31(c + vec3(0.0, 1.0, 1.0));\n    float ruf = Hash31(c + 1.0);\n\n    return mix(mix(mix(ldb, rdb, l.x), mix(lub, rub, l.x), l.y),\n               mix(mix(ldf, rdf, l.x), mix(luf, ruf, l.x), l.y),\n               l.z);\n}\n\n// Hairy looking noise\nfloat hnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        // Magic numbers\n        p.xz *= mat2(-0.48406725864, -0.87503079323, 0.87503079323, -0.48406725864);\n        p.yz *= mat2(0.15022546991, -0.98865176285, 0.98865176285, 0.15022546991);\n\n        value += abs(snoise(p) * 2.0 - 1.0) * nscale;\n        tscale += nscale;\n        nscale *= 0.25;\n\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\n// Tile patterns\nfloat tile1(in vec2 cuv) {\n    float e = dot( cuv, vec2(0.71));\n    return min(abs(max( max(cuv.x, cuv.y), e + 0.2)), abs(max(-min(cuv.x, cuv.y), 0.2 - e))) - 0.025;\n}\n\nfloat tile2(in vec2 cuv) {\n    return abs(abs(dot(cuv, vec2(0.71))) - 0.355) - 0.02;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y + iTime * 0.1;\n    float unit = 10.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    uv *= 5.0;\n    vec2 cid = floor(uv);\n    vec2 cuv = fract(uv) - 0.5;\n\n    float h21 = Hash21(cid);\n    cuv = Rotate(cuv, floor(h21 * 4.0) * 1.57);\n\n    float d = h21 < 0.5 ? tile1(cuv) : tile2(cuv);\n    color.gb += vec2(0.25 + 0.25 * sin(uv.x + uv.y - iTime), 1.0) * smoothstep(unit, 0.0, d);\n\n    color.b += 0.5 * sin(d * 100.0);\n    color *= pow(1.0 - hnoise(vec3(uv, iTime), 1.0, 5.0), 3.0) * 2.0;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 106], [108, 199, 224, 224, 335], [337, 337, 362, 362, 469], [471, 490, 515, 515, 1100], [1102, 1125, 1184, 1184, 1683], [1685, 1702, 1728, 1728, 1869], [1871, 1871, 1897, 1897, 1957], [1959, 1959, 2014, 2014, 2604]], "test": "untested"}
{"id": "wtKBzR", "name": "Circuit board fractal 4", "author": "jarble", "description": "I found a fractal pattern that looks like a printed circuit board.", "tags": ["fractal", "circuit"], "likes": 2, "viewed": 281, "published": 3, "date": "1613787326", "time_retrieved": "2024-07-30T19:37:00.556211", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return (abs(fract(a*scale)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    for(int c=0;c<3;c++){\n        float t1 = 5.0;\n\t    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/2.0;\n        \n        float offset = .4;\n        float scale = 1.6;\n        for(int i=0;i<3;i++)\n        {\n          \n            uv = triangle_wave(uv.yx+offset,scale)+triangle_wave(uv,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 78], [80, 80, 137, 137, 674]], "test": "untested"}
{"id": "wlVfRR", "name": "Migraine Aura Fractal", "author": "jarble", "description": "I found a fractal pattern that looks like a migraine aura (\"scintillating scotoma.\")", "tags": ["fractal", "circuit"], "likes": 1, "viewed": 336, "published": 3, "date": "1613786840", "time_retrieved": "2024-07-30T19:37:01.483732", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return (abs(fract(a*scale)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    for(int c=0;c<3;c++){\n        float t1 = 5.0;\n\t    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1/2.0;\n        \n        float offset = .2;\n        float scale = 1.5;\n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv.yx+offset*uv.y,scale)+triangle_wave(uv,scale);\n            //uv= uv+col.xy;\n            uv = triangle_wave(uv+col.xy,scale);\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 78], [80, 80, 137, 137, 709]], "test": "untested"}
{"id": "ttVfRR", "name": "Scottish Tartan", "author": "oneshade", "description": "Thought this pattern suggested by the book of shaders looked fun :)\nReference image from (not exactly sure what tartans have to do with fly fishing lures): http://english-fly-fishing-flies.s3-website-eu-west-1.amazonaws.com/scotland-stewarthairwing.html", "tags": ["pattern", "bookofshaders", "tartan", "shaderart", "scottish"], "likes": 12, "viewed": 241, "published": 3, "date": "1613783456", "time_retrieved": "2024-07-30T19:37:02.405267", "image_code": "// Reference image from (not exactly sure what tartans have to do with fly fishing lures): http://english-fly-fishing-flies.s3-website-eu-west-1.amazonaws.com/scotland-stewarthairwing.html\n// Thought this pattern suggested by the book of shaders looked fun :)\n// Book of Shaders - Patterns: https://thebookofshaders.com/09/?lan=en\n\n#define ss(x) smoothstep(unit, 0.0, x)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.75, 0.0, 0.0);\n\n    float w = 15.0 / iResolution.y, hw = 0.5 * w;\n    float stripeMask = ss(abs(mod(dot(uv, vec2(0.71, -0.71)) + hw, w) - hw));\n\n    vec2 stripeUv1 = mod(vec2(uv.x, uv.y + 2.0), 4.0) - 2.0;\n    vec2 stripeUv2 = abs(stripeUv1) - 0.75;\n    vec2 stripeUv3 = abs(stripeUv1) - 0.55;\n    vec2 stripeUv4 = abs(stripeUv1) - 0.9;\n\n    float vertBlueStripes = abs(stripeUv2.x) - 0.35;\n    color = mix(color, vec3(0.0, 0.0, 0.6), ss(vertBlueStripes) * stripeMask);\n\n    float horiBlueStripes = abs(stripeUv2.y) - 0.35;\n    color = mix(color, vec3(0.0, 0.0, 0.6), ss(horiBlueStripes) * stripeMask);\n\n    color = mix(color, vec3(0.0, 0.0, 0.5), ss(max(vertBlueStripes, horiBlueStripes)));\n\n    float vertGreenStripes = abs(stripeUv3.x) - 0.15;\n    color = mix(color, vec3(0.0, 0.45, 0.0), ss(vertGreenStripes) * stripeMask);\n\n    float horiGreenStripes = abs(stripeUv3.y) - 0.15;\n    color = mix(color, vec3(0.0, 0.45, 0.0), ss(horiGreenStripes) * stripeMask);\n\n    color = mix(color, vec3(0.0, 0.375, 0.0), ss(max(vertGreenStripes, horiGreenStripes)));\n\n    float vertBlackStripes = abs(stripeUv4.x) - 0.075;\n    color = mix(color, vec3(0.0), ss(vertBlackStripes) * stripeMask);\n\n    float horiBlackStripes = abs(stripeUv4.y) - 0.075;\n    color = mix(color, vec3(0.0), ss(horiBlackStripes) * stripeMask);\n\n    color = mix(color, vec3(0.0), ss(max(vertBlackStripes, horiBlackStripes)));\n\n    float whiteStripes = min(abs(stripeUv1.x), abs(stripeUv1.y));\n    color = mix(color, vec3(1.0), ss(whiteStripes) * stripeMask);\n\n    float blackStripes = min(abs(abs(stripeUv1.x) - 0.1), abs(abs(stripeUv1.y) - 0.1));\n    color = mix(color, vec3(0.0), ss(blackStripes) * stripeMask);\n\n    float yellowStripes = min(abs(abs(stripeUv2.x) - 0.05), abs(abs(stripeUv2.y) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), ss(yellowStripes) * stripeMask);    \n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[371, 371, 426, 426, 2448]], "test": "untested"}
{"id": "WlVBzz", "name": "PixelSpirit First Draw", "author": "netgrind", "description": "The Emperor - Merge - Bundle\nremixed from Patricio Gonzalez Vivo's PixelSpirit oracle deck - https://patriciogonzalezvivo.github.io/PixelSpiritDeck/", "tags": ["pixel", "spirit", "pixelspirit"], "likes": 17, "viewed": 506, "published": 3, "date": "1613777792", "time_retrieved": "2024-07-30T19:37:03.257987", "image_code": "// The Emperor - Merge - Bundle\n// Remixed from Patricio Gonzalez Vivo's PixelSpirit oracle deck - https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n\n// I read this draw as a sign to solidify and consolidate code into proper bundles, increasing stability and security of mind, so this magician knows their tools are organized and at the ready for what battles lay ahead\n\nfloat smoothing = .01;\n\n// 04\nfloat stroke(float x, float s, float w){\n    float d = smoothstep(s, s+smoothing, x+w*.5) - smoothstep(s, s+smoothing, x-w*.5);\n    return clamp(d, 0., 1.);\n}\n\n// 08\nfloat circleSDF(vec2 st) {\n    return length(st-.5)*2.;\n}\n\n// 09\nfloat fill(float x, float s){\n    return 1.-smoothstep(s, s+smoothing, x);\n}\n\n// 10\nfloat rectSDF( vec2 st, vec2 s){\n    st = st*2.-1.;\n    return max(abs(st.x/s.x), abs(st.y/s.y));\n}\n\n// 12\nfloat flip(float v, float pct){\n    return mix(v, 1.-v, pct);\n}\n\n// 27\nfloat hexSDF(vec2 st){\n    st = abs(st*2.-1.);\n    return max(abs(st.y), st.x * 0.866025 + st.y*0.5);\n}\n\nfloat draw0(vec2 uv, float a, float d, float time){\n    float col = 0.;\n    float sTime = time*6.28;\n    \n    // The Emperor\n    vec2 st = vec2(sin(a), cos(a))*(d*(1.1+sin(sTime+a)*.1))+.5;\n    float sdf = rectSDF(st, vec2(1.));\n    col += stroke(sdf, .6, .125);\n    col += fill(sdf, min(mod(time, 2.),1.)*.5375);    \n    col += fill(sdf, min(mod(time, 2.)-1.,1.)*.5375);    \n    col += fill(sdf, .1);\n\n    // Merge\n    st = uv;\n    vec2 offset = vec2(sin(sTime), cos(sTime))*(pow(cos(sTime)*.5+.5, 1.5)*.2);\n    float left = circleSDF(st+offset);\n    float right = circleSDF(st-offset);\n    col += flip(stroke(left, .5, .05), fill(right, .52));\n    \n    // Bundle\n    st = uv.yx;\n    col += stroke(hexSDF(st), .5+cos(sTime)*.2, .1);\n    //st = vec2(sin(a-sTime), cos(a-sTime))*d+.5;\n    float amp = sin(sTime);\n    amp = pow(abs(amp), .6)*sign(amp);\n    amp*=1.5;\n    col += fill(hexSDF(st-vec2(-.06, -.1)*amp), .15);\n    col += fill(hexSDF(st-vec2(-.06, .1)*amp), .15);\n    col += fill(hexSDF(st-vec2(.11, 0.)*amp), .15);\n    \n    col = abs(mod(col+1., 2.)-1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/min(iResolution.x, iResolution.y);\n    uv*=1.25;\n    uv+=.5;\n    float a = atan(uv.y-.5, uv.x -.5);\n    float d = length(uv-.5);\n    float time = iTime*.25;\n    float sTime = time*6.28;\n    vec4 col = vec4(0., 0., 0., 1.);\n    \n    for(float i = -10.; i< 10.; i++){\n        float t = i*(sin(uv.x*10.+sTime+uv.y*2.+cos(uv.y*5.+sTime)*2.+sin(uv.x*3.-sTime))*.5+.5)*.01;\n        col += vec4(draw0(uv, a, d, time-.01+t),\n                    draw0(uv, a, d, time+t),\n                    draw0(uv, a, d, time+.01+t),\n                    1.);\n    }\n    col/=20.;\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[401, 407, 447, 447, 565], [567, 573, 599, 599, 630], [632, 638, 667, 667, 714], [716, 722, 754, 754, 821], [823, 829, 860, 860, 892], [894, 900, 922, 922, 1003], [1005, 1005, 1056, 1056, 2086], [2088, 2088, 2145, 2195, 2818]], "test": "untested"}
{"id": "WtVfzR", "name": "19/02/2021 - live", "author": "anticore", "description": "Coded live on twitch\nhttps://twitch.tv/antic0re_", "tags": ["raymarch", "clouds", "volumetric"], "likes": 9, "viewed": 458, "published": 3, "date": "1613765868", "time_retrieved": "2024-07-30T19:37:04.168552", "image_code": "float ni(float x) {\n    //return texture(texFFTIntegrated, x).x;\n    return texelFetch( iChannel0, ivec2(x * 512.,0), 0 ).x * .0;\n}\n\nfloat hash13(vec3 p) {\n    p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec3 hash33(vec3 p3) {\n    vec3 p = fract(p3 * vec3(.1031,.11369,.13787));\n    p += dot(p, p.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p.x + p.y)*p.z, (p.x+p.z)*p.y, (p.y+p.z)*p.x));\n}\n\n\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n  \n    return mat2(c, s, -s, c);\n}\n\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(hash33(s), x);\n\td.y = dot(hash33(s + i1), x1);\n\td.z = dot(hash33(s + i2), x2);\n\td.w = dot(hash33(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}\n\nfloat fbm (in vec3 st, int o) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < o; i++) {\n        value += amplitude * snoise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat worley(vec3 p, float scale){\n\n    vec3 id = floor(p*scale);\n    vec3 fd = fract(p*scale);\n\n    float n = 0.;\n\n    float minimalDist = 1.;\n\n\n    for(float x = -1.; x <=1.; ++x){\n        for(float y = -1.; y <=1.; ++y){\n            for(float z = -1.; z <=1.; ++z){\n\n                vec3 coord = vec3(x,y,z);\n                vec3 rId = hash33(mod(id+coord,scale))*0.5+0.5;\n\n                vec3 r = coord + rId - fd; \n\n                float d = dot(r,r);\n\n                if(d < minimalDist){\n                    minimalDist = d;\n                }\n\n            }//z\n        }//y\n    }//x\n    \n    return 1.0-minimalDist;\n}\n\n\nfloat wfbm (in vec3 st, int o, float s) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < o; i++) {\n        value += amplitude * worley(st, s);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n    return length(p + pos) - r;\n}\n\nfloat sdBox(vec3 p, vec3 pos, vec3 b) {\n    p += pos;\n    //p.xz *= rot(0.6);\n    //p.xy *= rot(0.5);\n  \n    p.xz *= rot(iTime + ni(0.4));\n    p.xy *= rot(iTime + ni(0.2));\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 p) {\n    return vec2(sdBox(p, vec3(0.,0.,5. + sin(ni(0.1) * 100.)), vec3(1., 1., 1.)), 0.);\n}\n\nconst vec3 sundir = normalize( vec3(0.0,-1.0,-0.0) );\n\nvec3 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec4 sum = vec4(0);\n  \n    for (int i = 0; i < 100; i++) {\n        h = map(ro + rd * td);\n        td += max(h.x, 0.01);\n        \n            vec3 ip = ro + rd * td;\n        if (h.y == 0. && h.x < 0.01) {\n            ip.yz *= rot(iTime / 10.);\n            ip.xz *= rot(iTime / 10.);\n            float w = smoothstep(0.6, 1., worley(ip, 2.));\n            float s = snoiseFractal(ip*3.);\n            float f = fbm(ip, 8);\n          \n            //return vec3(1);\n            // F = 1/ e ^(t * d).\n            //c += f * 0.01 * exp(-h.x * 2);\n            //return vec3(w);\n            float den = f;\n            \n            if (den > 0.01) {\n               float df = fbm(ip + 0.1 * sundir, 8);\n               // do lighting\n               float dif = clamp((den - df)/0.3, 0.0, 1.0 );\n               vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(sin(ip.x + iTime),0.6,cos(ip.y + iTime))*dif;\n               //return vec3(lin);\n               vec4  col = vec4( mix( vec3(cos(ip.y + iTime / 2.) + 0.5,0.95,sin(iTime / 3. + ip.z) + 0.5), vec3(0.25,0.3,0.35), den ), den );\n                \n               col.xyz *= lin;\n               // fog\n               //col.xyz = mix(col.xyz,vec3(0,0,0), 1.0-exp2(-0.075*t));\n              \n              \n                //return col.xyz;\n               // composite front to back\n               //col.w    = min(col.w*8.0*h.x,1.0);\n               //col.rgb *= col.a;\n              \n               sum += col*0.01*(1.0-sum.a);\n            }\n            \n        }\n    }\n    \n    return sum.xyz;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(0,0,2);\n  vec3 rd = normalize(vec3(uv, 0) - ro);\n  \n  float w = smoothstep(0.6, 1., worley(vec3(uv * 3., iTime / 20.), 2.));\n  float s = snoise(vec3(uv, iTime));\n  float sf = snoiseFractal(vec3(uv, iTime));\n  float f = fbm(vec3(uv.x, uv.y, iTime), 8);\n  float wf = smoothstep(0.2, 1., wfbm(vec3(uv.x, uv.y, iTime / 10.), 3, 4.));\n  float wff = wf * f;\n  \n  //out_color = vec4(vec3(wff),1);\n  \n  \n  fragColor = vec4(tr(ro, rd, uv), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 64, 131], [133, 133, 155, 155, 253], [255, 255, 277, 277, 445], [449, 449, 468, 468, 547], [608, 608, 630, 630, 1205], [1207, 1207, 1236, 1236, 1360], [1362, 1362, 1393, 1415, 1664], [1667, 1667, 1701, 1701, 2292], [2295, 2295, 2336, 2358, 2610], [2613, 2613, 2656, 2656, 2690], [2692, 2692, 2731, 2731, 2955], [2957, 2957, 2975, 2975, 3064], [3121, 3121, 3157, 3157, 4730], [4734, 4734, 4791, 4791, 5385]], "test": "untested"}
{"id": "3tVfzR", "name": "fake 3d winter scene", "author": "eiffie", "description": "Up north you dream about playing in the sand on cold winter days. Down south you dream about playing in the snow.\nCold winter days are only good for coding.", "tags": ["winter"], "likes": 23, "viewed": 508, "published": 3, "date": "1613764884", "time_retrieved": "2024-07-30T19:37:04.943481", "image_code": "//fake 3d Winter Scene by eiffie (really just an excuse for the music code)\n#define rez iResolution.xy\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nfloat Trail(vec2 p){\n  p.y+=.1*sin(p.x*.3)*sin((iTime+p.x)*.3)+.55;\n  return abs(abs(p.y)-0.025)+0.04+abs(p.x)*0.01;\n}\nfloat Skier(vec2 p){//3d would be easier, I would only draw 1 arm or leg per call\n  float t=iTime*1.25;\n  p-=vec2(sin(t*.3)*2.,.25*sin(t*.1)+1.25);\n  float ast=abs(sin(t)),ast2=abs(sin(t+1.57));\n  vec2 n=vec2(ast*.1,.5);\n  vec2 h1=vec2(.1+ast*.4,.25),h2=vec2(.1+ast2*.4,.3);\n  vec2 f1=vec2(.4-ast*.7,-.5),f2=vec2(.4-ast2*.7,-.55);\n  vec2 ko=vec2(sin(p.y*5.)*abs(sin(t+.78))*.1,0);\n  float l1=tube(p+ko,f1),l2=tube(p+ko,f2);\n  vec2 ho=vec2(0.,-.2),so=vec2(-.5,-.04),sl=vec2(1.25,0);\n  vec2 po1=vec2(-ast2*.3,-.8),po2=vec2(-ast*.3,-.8);\n  float s1=tube(p-(f1+so)+vec2(0,-pow(max(0.,p.x-f1.x-.5),2.)),sl);\n  float s2=tube(p-(f2+so)+vec2(0,-pow(max(0.,p.x-f2.x-.5),2.)),sl);\n  vec2 eo1=vec2(0,-sin((p.x-h1.x)*10.)*ast2*.1),eo2=vec2(0,-sin((p.x-h2.x)*10.)*ast*.1);\n  float a=0.035-p.x*0.1;\n  float bd=tube(p,n),a1=tube(p-h1+eo1,n+ho-h1)-a,a2=tube(p-h2+eo2,n+ho-h2)-a;\n  float p1=tube(p-h1,po1),p2=tube(p-h2,po2);\n  float d=min(bd-0.025-abs(sin(p.y*p.y*17.))*.025,min(min(a1,a2),min(p1,p2)+0.03));\n  d=min(d,min(min(l1,l2)-.04-p.y*.06,min(s1,s2)+0.04));\n  if(p.x<-.2)d=min(d,Trail(p));\n  return d;\n}\nfloat DE(vec2 p,float t){\n  if(mod(t,2.)<1.)p.x=-p.x;\n  p.y;\n  float d=tube(p+vec2(-pow(abs(p.y),6.)*.12,0),vec2(0,1))-.05,s=1.;\n  for(int i=0;i<7;i++){\n    if(p.x<0.){//side branch\n      t*=1.5;\n      p.y-=.45+.35*sin(t);\n      p=vec2(p.x+p.y,-p.x+p.y);\n    }else{\n      t*=2.3;\n      p.y-=1.;p.x-=.12;\n      p=vec2(-p.x+p.y,p.x+p.y);\n    }\n    p*=1.2;\n    s*=1.4;\n    d=min(d,(tube(p+vec2(-pow(abs(p.y),6.)*.12,0),vec2(0,1))-.05)/s);\n  }\n  return d;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  U=(2.*U-rez)/rez.y;\n  O=texture(iChannel0,U+iTime*vec2(1.8,1)).rrrr;\n  U*=.5+.1*sin(iTime*.3);\n  U.y+=.3;\n  float R=.2-max(0.,U.y)+smoothstep(0.0,0.1,Skier(U*6.)),g=0.;  \n  for(int i=0;i<16;i++){\n    float s=1.+float(i)*.25,x=U.x*s+iTime+sin(s*s)*2.,t=abs(sin(floor(x)*2.+s));\n    vec2 p=vec2((fract(x)-.5)*2.,(U.y-g)*s*2.);\n    R=min(R,(0.05+smoothstep(0.0,0.1,DE(p*s*(1.+t),t*10.)))*s*s);\n    R=min(R,(0.75+smoothstep(0.0,0.1,DE(vec2(p.x+p.y+.05,p.x-p.y)*s*(1.+t),t*10.)-.05)));\n    g+=.1/(s*s);\n  }\n  O+=vec4(R,R,R,1);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//i was trying to simplify my fractal music code to make it readable...that didn't work\n#define pi 3.14159\nfloat ntof(float n){return (n>0.0)?55.0*pow(2.0, (12.0+n) / 12.0):0.0;}\nint N[]=int[](0,4,7,9,11,9,7,4);\nfloat s(float t){\n  int i=int(t*4.);\n  int f=N[i%8]+N[((i>>4)*2)%8]+N[((i>>6)*3)%8];\n  return t*ntof(float(f));\n}\nvec2 mainSound(int samp, float time){\n  vec2 v=vec2(s(time),.5*s(time-.5));\n  float t=time*16.;\n  return sin(mod(v.yx,2.*pi)*20.*pi)*.1+.5*pow(fract(v),abs(vec2(sin(t),sin(t)))*.9+.1)-.25;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 132, 132, 191], [192, 192, 212, 212, 310], [311, 311, 331, 392, 1404], [1405, 1405, 1430, 1430, 1858], [1859, 1859, 1897, 1897, 2423]], "test": "untested"}
{"id": "wltfWf", "name": "Metafluid II", "author": "oneshade", "description": "metaballs + particles = metafluid\nAttract the fluid with the mouse on the left side.\nMove the right paddle with mouse on the right side.", "tags": ["simulation", "metaballs", "particles", "blobby", "liquid", "physics", "smin", "metafluid"], "likes": 12, "viewed": 244, "published": 3, "date": "1613762486", "time_retrieved": "2024-07-30T19:37:05.810163", "image_code": "float smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float d = 100000.0;\n    for (int i=0; i < NUMBER_OF_PARTICLES; i++) {\n        d = smin(d, length(uv - getParticlePos(i)) - PARTICLE_RADIUS, BLOBBINESS);\n    }\n\n    vec3 color = vec3(0.6, 0.3, 0.0) * smoothstep(unit, 0.0, mapEmptyEnvironment(uv, mousePos, iTime));\n    color.b = smoothstep(unit * 0.5, 0.0, d);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Simlulation settings\n#define NUMBER_OF_PARTICLES 100\n#define PARTICLE_RADIUS 0.02\n\n#define GRAVITY 0.0001\n#define VISCOCITY 0.15\n#define BLOBBINESS 0.1\n\n// Utilities\n#define getPrevMouseState() texelFetch(iChannel0, ivec2(0, 0), 0).xyz\n#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 2), 0).xy\n\n#define mousePos vec3((iMouse.xy - 0.5 * iResolution.xy) / iResolution.y, iMouse.z)\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nvec2 Hash12(in float x) {\n    vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nmat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdDisc(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat sdTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l))) * sign(p.x);\n}\n\n// Attraction\n// Originally meant for particle-particle interactions so it get added for each\n// particle in the simulation. As a result, it can have a very dramatic affect\n// on the particles if it is not just based on particle-particle interaction.\nvec2 attract(in vec2 particle, in vec2 attractor, in vec3 mouse, in float time) {\n    if (mouse.x < 0.0 && mouse.z > 0.0) return normalize(mouse.xy - particle) * 0.0000025;\n    return vec2(0.0);\n}\n\n// Environment\nfloat mapEmptyEnvironment(in vec2 p, in vec3 mouse, in float time) {\n    float env = -sdBox(p, vec2(0.8, 0.415));\n\n    env = min(env, sdTriangleWave(p + vec2(0.0625, 0.34), 4.0, 0.15));\n    env = min(env, sdBox(p * Rotate(time * 2.0), vec2(0.02, 0.15)));\n\n    vec2 mp = p;\n    float h = 0.2 * sin(time);\n    env = min(env, sdBox(vec2(mp.x + 0.5, mp.y + h), vec2(0.2, 0.025)));\n\n    if (mouse.z > 0.0 && mouse.x > 0.0) mp -= vec2(mouse.x - 0.5, mouse.y);\n    else mp.y -= h;\n\n    env = min(env, sdBox(vec2(mp.x - 0.5, mp.y), vec2(0.2, 0.025)));\n\n    float r = 6.28 / 6.0, hr = 0.5 * r;\n    p = sin(mod(atan(p.y, p.x) + hr - time, r) - hr + vec2(1.57, 0.0)) * length(p);\n    env = min(env, sdDisc(p - vec2(0.2, 0.0), 0.025));\n\n    return env;\n}\n\nvec2 getEmptyEnvNormal(in vec2 p, in vec3 mouse, in float time) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec2(mapEmptyEnvironment(p + e.xy, mouse, time) - mapEmptyEnvironment(p - e.xy, mouse, time),\n                          mapEmptyEnvironment(p + e.yx, mouse, time) - mapEmptyEnvironment(p - e.yx, mouse, time)));\n}\n\n// Calculates environment velocity\nvec2 getEmptyEnvVel(in vec2 p, in vec3 mousePrev, in vec3 mouseCur, in float time, in float dt) {\n    float tb = time - dt;\n    vec2 d1 = getEmptyEnvNormal(p, mousePrev, tb) * mapEmptyEnvironment(p, mousePrev, tb);\n    vec2 d2 = getEmptyEnvNormal(p, mouseCur, time) * mapEmptyEnvironment(p, mouseCur, time);\n    return (d2 - d1) * dt;\n}\n\n// Particle generation\nvec2 generatePosition(in float id) {\n    return Hash12(id + iDate.w) - 0.5;\n}\n\nvec2 generateVelocity(in float id) {\n    return 0.001 + 0.001 * Hash12(id + 538.384);\n}", "buffer_a_code": "struct EnvData {\n    float distToEnv;\n    vec2 colliderVel;\n    float colliderType;\n    vec2 attraction;\n};\n\nEnvData mapEnvironment(in vec2 p, in int particleID) {\n    vec2 particlePos = getParticlePos(particleID);\n\n    float distToEnv = mapEmptyEnvironment(p, mousePos, iTime);\n    vec2 colliderVel = vec2(0.0, 0.0);\n    float colliderType = 0.0;\n    vec2 attraction = vec2(0.0);\n\n    for (int id=0; id < NUMBER_OF_PARTICLES; id++) {\n        // Avoid self collisions\n        if (id != particleID) {\n            vec2 colliderPos = getParticlePos(id);\n            distToEnv = min(distToEnv, length(p - colliderPos) - PARTICLE_RADIUS);\n\n            // Colliding with another particle\n            if (length(particlePos - colliderPos) < 2.0 * PARTICLE_RADIUS) {\n                colliderVel = getParticleVel(id);\n                colliderType = 1.0;\n            }\n\n            attraction += attract(particlePos, colliderPos, mousePos, iTime);\n        }\n    }\n\n    return EnvData(distToEnv, colliderVel, colliderType, attraction);\n}\n\nvec2 getEnvNormal(in vec2 p, in int id) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec2(mapEnvironment(p + e.xy, id).distToEnv - mapEnvironment(p - e.xy, id).distToEnv,\n                          mapEnvironment(p + e.yx, id).distToEnv - mapEnvironment(p - e.yx, id).distToEnv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ivec2 address = ivec2(fragCoord);\n\n    // Store mouse\n    if (address == ivec2(0, 0)) {\n        fragColor.xyz = mousePos;\n    }\n\n    // Generate particles\n    if (address.x < NUMBER_OF_PARTICLES && address.y == 1) {\n        fragColor.xy = generatePosition(fragCoord.x);\n    }\n\n    if (address.x < NUMBER_OF_PARTICLES && address.y == 2) {\n        fragColor.xy = generateVelocity(fragCoord.x);\n    }\n\n    if (iFrame > 0) {\n        if (address.x < NUMBER_OF_PARTICLES) {\n            // Load previous mouse state (important for proper mouse control)\n            vec3 mousePrev = getPrevMouseState();\n\n            // Load particle\n            vec2 particlePos = getParticlePos(address.x);\n            vec2 particleVel = getParticleVel(address.x);\n\n            // Update particle\n            particleVel.y -= GRAVITY;\n            particlePos += particleVel;\n\n            EnvData envData = mapEnvironment(particlePos, address.x);\n\n            // Colliding with the environment\n            if (envData.distToEnv < PARTICLE_RADIUS) {\n                vec2 hitNormal = getEnvNormal(particlePos, address.x);\n                vec2 perpNormal = hitNormal.yx * vec2(-1.0, 1.0);\n                vec2 hitPos = particlePos - hitNormal * envData.distToEnv;\n\n                // Decollide\n                particlePos += hitNormal * (PARTICLE_RADIUS - envData.distToEnv);\n\n                // Colliding with another particle\n                if (envData.colliderType > 0.0) {\n                    // Transfer energy (only true for perfectly elastic collisions of same mass)\n                    vec2 particleVel2 = envData.colliderVel;\n                    particleVel = dot(particleVel2, hitNormal) * hitNormal + dot(particleVel, perpNormal) * perpNormal;\n                }\n\n                else {\n                    // Gain velocity from the environment and bounce\n                    vec2 envVel = getEmptyEnvVel(hitPos, mousePrev, mousePos, iTime, iTimeDelta);\n                    particleVel += envVel * step(0.0, dot(envVel, hitNormal)); // Prevent suction effect\n                    particleVel = reflect(particleVel, hitNormal);\n                }\n\n                // Slow down\n                particleVel *= 1.0 - VISCOCITY;\n            }\n\n            particleVel += envData.attraction;\n\n            // Store new mouse position\n            if (address == ivec2(0, 0)) {\n                fragColor.xyz = mousePos;\n            }\n\n            // Store particle\n            if (address.y == 1) {\n                fragColor = vec4(particlePos, 0.0, 1.0);\n            }\n\n            if (address.y == 2) {\n                fragColor = vec4(particleVel, 0.0, 1.0);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 151], [153, 153, 208, 208, 663]], "test": "untested"}
{"id": "ttGfzR", "name": "Fractal Tree 01", "author": "moranzcw", "description": "A fractal tree.", "tags": ["2d", "fractal", "tree"], "likes": 6, "viewed": 475, "published": 3, "date": "1613760330", "time_retrieved": "2024-07-30T19:37:06.585092", "image_code": "// Fractal Tree 01 - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define MaxDepth 8\n#define MaxStackSize MaxDepth+1\n#define Attenuation 0.8\n\nfloat rand(float seed)\n{ \n    return fract(sin(seed*(91.3458)) * 47453.5453);\n}\n\nstruct Branch\n{\n    vec2 origin;\n    vec2 direction;\n    float len;\n    int depth;\n    float id;\n};\n\nBranch stack[MaxStackSize];\nint top = 0;\nfloat id = 0.0;\n\nbool push(Branch branch)\n{\n    if(top < MaxStackSize)\n    {\n        stack[top] = branch;\n        top += 1;\n        return true;\n    }\n    return false;\n}\n\nbool pop(out Branch branch)\n{\n    if(top > 0)\n    {\n        top -= 1;\n        branch = stack[top];\n        return true;\n    }\n    return false;\n}\n\nvec3 line(vec2 coord, vec2 p1, vec2 p2, float width, vec3 color)\n{\n    vec2 v1 = coord - p1;\n    vec2 v2 = p2 - p1;\n    float j1 = dot(v1, v2);\n    \n    vec2 v3 = coord - p2;\n    vec2 v4 = p1 - p2;\n    float j2 = dot(v3, v4);\n    \n    float len;\n    if( j1 > 0.0 && j2 > 0.0)\n    {\n        vec2 nv2 = normalize(v2);\n        len = length(v1 - dot(v1, nv2) * nv2);\n    }\n    else\n    {\n        len = min(length(v1),length(v3));\n    }\n    return color * step(len, width);\n}\n\nvec2 rotate(vec2 v, float theta)\n{\n    vec2 v1;\n    v1.x = v.x * cos(theta) - v.y * sin(theta);\n    v1.y = v.y * cos(theta) + v.x * sin(theta);\n    return v1;\n}\n\nvec3 tree(vec2 coord, Branch branch)\n{\n    push(branch);\n    Branch cur;\n    vec3 color;\n    while(true)\n    {\n        if(pop(cur))\n        {\n            vec2 p = cur.origin + cur.direction * cur.len;\n            vec3 shade = vec3(dot(cur.direction, vec2(0.7071,0.7071)) / 8.0 + 0.25);\n            shade = line(coord, cur.origin, p, 0.005*pow(0.91, float(cur.depth)), shade);\n            color = step(0.001,shade) * shade + (1.0 - step(0.001,shade)) * color;\n            \n            if(cur.depth < MaxDepth)\n            {\n                vec2 dir1 = rotate(cur.direction, PI/10.0 + 0.2*rand(cur.id*0.15) + 0.08*sin(iTime+cur.id));\n                vec2 dir2 = rotate(cur.direction, -PI/10.0 - 0.16*rand(cur.id*0.35) + 0.08*sin(iTime-cur.id));\n                bool flag;\n                flag = push(Branch(p, dir1, cur.len * (Attenuation - 0.05*rand(cur.id*0.36)), cur.depth+1,id++));\n                flag = flag && push(Branch(p, dir2, cur.len * (Attenuation- 0.05*rand(cur.id*0.69)), cur.depth+1, id++));\n                if(!flag)\n                    break;\n            }\n            else\n            {\n                float ir = dot(cur.direction, vec2(0.7071,0.7071)) / 4.0 + 0.5;\n                float t = 0.4 + (sin(5.0*iTime + cur.id)+1.0) * 0.3;\n                color += smoothstep(0.03, 0.01, length(coord-p)) * vec3(0.6,0.4,0.4) * ir * t;\n            }\n        }\n        else\n            break;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.43,0.4,0.4);\n    Branch branch = Branch(vec2(0.0,-0.7), vec2(0.0, 1.0), 0.35, 0, id++);\n    color += tree(coord, branch);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGfzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[258, 258, 282, 282, 337], [498, 498, 524, 524, 651], [653, 653, 682, 682, 798], [800, 800, 866, 866, 1270], [1272, 1272, 1306, 1306, 1432], [1434, 1434, 1472, 1472, 2863], [2865, 2865, 2922, 2922, 3215]], "test": "untested"}
{"id": "wlyfzz", "name": "Volumetric Ray Marched Clouds", "author": "ArenaGrenade", "description": "A simple ray marching shader for shading clouds.", "tags": ["raymarchingvolumetricclouds"], "likes": 1, "viewed": 302, "published": 3, "date": "1613755778", "time_retrieved": "2024-07-30T19:37:07.478702", "image_code": "#define PI 3.142\n\n// Worley Noise Code from https://www.shadertoy.com/view/MstGRl\n#define CELL_COUNT 10.0\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 get_cell_point(ivec2 cell) {\n\tvec2 cell_base = vec2(cell) / CELL_COUNT;\n\tfloat noise_x = rand(vec2(cell));\n    float noise_y = rand(vec2(cell.yx));\n    return cell_base + (0.5 + 1.5 * vec2(noise_x, noise_y)) / CELL_COUNT;\n}\nfloat worley(vec2 coord) {\n    ivec2 cell = ivec2(coord * CELL_COUNT);\n    float dist = 1.0;\n    \n    for (int x = 0; x < 5; x++) { \n        for (int y = 0; y < 5; y++) {\n        \tvec2 cell_point = get_cell_point(cell + ivec2(x-2, y-2));\n            dist = min(dist, distance(cell_point, coord));\n\n        }\n    }\n    \n    dist /= length(vec2(1.0 / CELL_COUNT));\n    dist = 1.0 - dist;\n    return dist;\n}\n\n// Perlin Noise Function\nconst int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.8;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float perlin_noise = 0.1 + 0.9 * PerlinNoise2D(uv.x, uv.y);\n    float worley_noise = worley(uv);\n    fragColor = vec4(worley_noise / 2.0 + perlin_noise / 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 126, 126, 193], [195, 195, 228, 228, 423], [424, 424, 450, 450, 828], [937, 1108, 1134, 1134, 1283], [1285, 1285, 1317, 1317, 1471], [1473, 1473, 1522, 1522, 1614], [1616, 1616, 1660, 1660, 2076], [2078, 2078, 2116, 2116, 2441], [2443, 2443, 2500, 2500, 2754]], "test": "untested"}
{"id": "wtyfzz", "name": "GLSL bug vec", "author": "FabriceNeyret2", "description": "you should see 2 parallel \"lines\".\nOn OpenGL(linux) / chrome+firefox / Nvidia, they are orthogonal.\nPlus uncommenting line 12 change things back to 3 parallels !", "tags": ["glsl", "bug"], "likes": 3, "viewed": 348, "published": 3, "date": "1613755125", "time_retrieved": "2024-07-30T19:37:08.329427", "image_code": "void mainImage( out vec4 O, vec2 u ) {\n\tvec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    \n    float d = 1e3;\n    for (float i = 0.; i < 10.; i++ ) {\n        float \n             c1 = length( U - vec2(      i /20. ,  i /20. ) ), // distance to point (x,x)  WRONG !\n             c2 = length( U - vec2( .1 + i /20. ,  i /20. ) ), // should be the same + slight offset\n              x = i/20.,\n             c3 = length( U - vec2( .2 + x      ,  x      ) ); // (see below) should be the same + more offset\n        d = min(d, min(c1, c2));\n     // d = min(d, c3);                                        // uncomment will change c1\n    }\n    O = vec4( d*100. -5. );\n  \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 676]], "test": "untested"}
{"id": "wtyBRR", "name": "Transmission Theta", "author": "kostik1337", "description": "Extraterrestrial energy transmission station or whatever. Just discovered this glowy effect and played with it", "tags": ["raymarching", "glow"], "likes": 12, "viewed": 542, "published": 3, "date": "1613737802", "time_retrieved": "2024-07-30T19:37:09.176163", "image_code": "#define t iTime\n#define PI 3.14159265\n\n#define mr(a) (mat2(cos(a),sin(a),-sin(a),cos(a)))\n#define INF 1e10\n#define rep(p, s) mod(p,s)-s/2.\n\nfloat hash(float x) {return fract(sin(x)*31345.23);}\nfloat hash2(vec2 x) {return hash(dot(x, vec2(43.123, 32.12345)));}\n\nfloat glow = 0.;\n\nfloat box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p,0.0)) + min(0.0, max(p.x,max(p.y, p.z)));\n}\n\nvec2 repPolarInfinite(vec2 p, float lDiv, float polDiv) {\n  vec2 pPol = vec2(length(p), atan(p.y, p.x));\n  \n  float ringId = floor(pPol.x / lDiv);\n  float div = polDiv * (ringId+1.);\n  float lcc = floor(pPol.y / (2.*PI/div));\n  pPol.y += .3*(hash(ringId) - .5)*t / (ringId+1.);\n  pPol.y = rep(pPol.y, 2.*PI/div);\n  p = pPol.x * vec2(cos(pPol.y), sin(pPol.y));\n  p.x -= lDiv*(ringId + .5);\n  return p;\n}\n\nfloat gear(vec3 p, float zcc) {\n  p.xy *= mr(t*2.*(hash(zcc)-.5));\n  p.xy = abs(p.xy) - .15;\n  vec3 s = vec3(.5, .03, .2);\n  float b = min(box(p, s), box(p, s.yxz));\n  return max(b, -box(p, vec3(INF, INF, .03)));\n}\n\nfloat map(vec3 p, float d) {\n  p.xy *= mr(.2 * t);\n  p.yz *= mr(.1 * sin(.5*t));\n\n  p.xy = repPolarInfinite(p.xy, 3., 3.);\n  \n  p.z += t;\n  \n  float pz_orig = p.z;\n  float zdiv = .5;\n  float zcc = floor(p.z / zdiv);\n  p.z = rep(p.z, zdiv);\n\n  float m_this = gear(p, zcc);\n  float m_near = gear(p + vec3(0., 0., -zdiv * sign(p.z)), zcc + sign(p.z));\n  float m_ring = 2. - abs(p.x);\n  float m = min(min(m_this, m_near), m_ring);\n  \n  float glowAmp = smoothstep(.7, 1., sin(-6.*t + 2.*pz_orig)*.5+.5);\n  float g = .01 * glowAmp / abs(m - .2);\n  g = min(1., g) * exp(-(d+m)/20.);\n  glow += g;\n  return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec2 mouse = iMouse.z > 0. ? (iMouse.xy / iResolution.xy-.5) * PI : vec2(0.);\n\n  vec3 O = vec3(0.,0.,0.), D = normalize(vec3(uv, 1.));\n  D.xz *= mr(mouse.x);\n  D.yz *= mr(mouse.y);\n  float d = 0., md = 100.;\n  vec3 c = vec3(0.);\n  \n  float I = 128.;\n  for (float i=0.; i<I; ++i) {\n    vec3 p = O+D*d;\n    float m = map(p, d);\n    if (m < 0.001*d || d>md) {\n      if (d<md) {\n        c += (.3 * vec3(1.-d/md) - 1.5*i/I);\n      }\n      break;\n    }\n    d += m;\n  }\n  c += glow * vec3(.8, .8, 1.2);\n  c = clamp(vec3(0.),vec3(2.),c);\n  \n  fragColor = vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 161, 161, 192], [193, 193, 214, 214, 259], [279, 279, 306, 306, 392], [394, 394, 451, 451, 796], [798, 798, 829, 829, 1012], [1014, 1014, 1042, 1042, 1616], [1618, 1618, 1675, 1675, 2335]], "test": "untested"}
{"id": "ttGBRR", "name": "day 428", "author": "jeyko", "description": ":)", "tags": ["dots", "mograph", "chromab", "mdtmjvm"], "likes": 28, "viewed": 580, "published": 3, "date": "1613733684", "time_retrieved": "2024-07-30T19:37:10.048830", "image_code": "// :)\n// in the vibe of https://twitter.com/beesandbombs\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\nvoid getTile( vec2 p, out float d, inout vec3 col, vec2 gv, vec4 hc){\n    vec2 op = p;\n    for(float i = 0.; i < 3.; i++){\n        float t = iTime - i*.05;\n        p = op;\n        \n        float m =   + 0.3*sin( hc.z*1. + sin(hc.w + t)*0.4)*sin(t) + .4*( length(hc.zw) + sin(length(hc.w)*0.));\n        p *= rot(0. \n            + m - length(hc.zw)*0.9\n            + t*3.);\n\n        p.y += 0.5;\n        p.x -= sin(hc.w)*.5*(sin(m*1.14));\n        d = length(p) - sin(m*2. + t)*0.04 - 0.05;\n\n        col[int(i)] = mix( col[int(i)], 1., smoothstep(pixSz*2.,0.,d));\n    \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    uv *= 31.;\n    \n    //uv.y += iTime*0.5;\n    \n    pixSz = fwidth(uv.x);\n    \n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        getTile(gv - offs, d, col, uv - offs, hc);\n        \n        \n        \n    }\n    \n    \n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(ouv,ouv)),1.5));\n\n    col *= vec3(1.,1.,1.);\n    \n    if( mod(iTime/10.,1.) > 0.66)\n        col = 1. - col;\n    if(iMouse.z > 0.5)\n        col = 1. - col;\n    col = pow(col,vec3(0.454545));\n    \n    \n    fragColor.xyz += col;\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 357, 380, 380, 477], [479, 479, 517, 517, 775], [778, 778, 806, 806, 850], [851, 851, 920, 920, 1428], [1430, 1430, 1487, 1487, 2875]], "test": "untested"}
{"id": "wttfDs", "name": "One Water", "author": "wyatt", "description": "water from the sky brings forth fruits of different colors", "tags": ["fluid"], "likes": 48, "viewed": 1040, "published": 3, "date": "1613710774", "time_retrieved": "2024-07-30T19:37:11.072094", "image_code": "// Fork of \"Pour Yann \" by wyatt. https://shadertoy.com/view/tdKBz3\n// 2021-02-19 04:17:46\n\n// Fork of \"Line Tracking Fluid\" by wyatt. https://shadertoy.com/view/tsKXzd\n// 2020-12-10 19:40:02\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U);\n    vec4 d = D(U);\n    vec4 c = C(U);\n    float l = ln(U,a.xy,a.zw);\n    Q = (0.3*c*vec4(1.5,.94,1.05,1)-.3)*exp(-2.*l*l);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define o vec3(1,0,-1)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) {\n\treturn length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n#define norm(u) ((u)/(1e-9+length(u)))\n\n// Dave\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n\tif (ln(U,n.xy,n.zw)<ln(U,Q.xy,Q.zw)) Q = n;\n}\nMain {\n    Q = A(U);\n    for (int x = -1;x <=1; x++)\n    for (int y = -1;y <=1; y++)\n    X(Q,U,vec2(x,y));\n    vec4 c = C(Q.xy);\n    Q.xy = mix(Q.xy,A(Q.xy).xy,.05+.05*sin(c.x));\n    Q.zw = mix(Q.zw,A(Q.zw).zw,.9);\n    Q.xy += D(Q.xy).xy;\n    Q.zw += D(Q.zw).xy;\n    \n    if (length(Q.xy-Q.zw) > 4.+2.*sin(c.w)) {\n        vec2 m = 0.5*(Q.xy+Q.zw);\n        if (length(U-Q.xy) > length(U-Q.zw)) \n        \tQ.xy = m;\n        else Q.zw = m;\n    }\n    if (iMouse.z>0.) {\n        vec4 n = B(vec2(0));\n    \tif (ln(U,n.xy,n.zw)<ln(U,Q.xy,Q.zw)) Q = n;\n    }\n    if (iFrame<1) {\n        Q.xy = U;\n        Q.zw = 0.5*R;\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Mouse\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 p = texture(iChannel0,U/iResolution.xy);\n   \tif (iMouse.z>0.) {\n      if (p.z>0.) C =  vec4(iMouse.xy,p.xy);\n    else C =  vec4(iMouse.xy,iMouse.xy);\n   }\n    else C = vec4(-iResolution.xy,-iResolution.xy);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n\tif (ln(U,n.xy,n.zw)<ln(U,Q.xy,Q.zw)) Q = n;\n}\nMain {\n    Q = A(U);\n    \n    \n    if (length(Q.xy-Q.zw) > 2.5) {\n        vec2 m = 0.5*(Q.xy+Q.zw);\n        if (length(U-Q.xy) > length(U-Q.zw)) \n        \tQ.xy = m;\n        else Q.zw = m;\n    }\n    \n    Q = vec4(C(Q.xy).xy,C(Q.zw).zw);\n    \n    if (iFrame < 1) {\n        Q = hash42(U+iDate.zw)*6.3;\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T(vec2 U) {\n\tU -= .5*D(U).xy;\n\tU -= .5*D(U).xy;\n    return D(U);\n}\nMain {\n    Q = T(U);\n    vec4 \n        n = T(U+o.yx),\n        e = T(U+o.xy),\n        s = T(U+o.yz),\n        w = T(U+o.zy),\n        m = 0.25*(n+e+s+w);\n    Q.xy = m.xy-0.25*vec2(e.z-w.z,n.z-s.z);\n\tQ.z = Q.z-0.25*(n.y+e.x-s.y-w.x);\n    vec4 a = A(U), c = C(U);\n    float l = ln(U,a.xy,a.zw);\n    float v = smoothstep(1.,0.,l);\n    Q.z += 0.01*sin(c.x);\n    Q.xy = mix(Q.xy,norm(a.xy-a.zw),.2*v*(.1+sin(c.y)));\n    Q.z *= .9-.1*v*sin(c.w);\n    Q.xy *= .95-.1*v*sin(c.z);\n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy *= 0.;\n\tif (iFrame < 1) Q = vec4(0,0,0,0);\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.)Q.z+=.2;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 234, 234, 383]], "test": "untested"}
{"id": "ttdBWs", "name": "simples columnas n2", "author": "jorge2017a1", "description": "simples columnas n2", "tags": ["simplescolumnasn2"], "likes": 1, "viewed": 220, "published": 3, "date": "1613706378", "time_retrieved": "2024-07-30T19:37:12.034521", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n\n//htps://mercury.sexy/hg_sdf/\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nmat2 rot2Dinv(float a)\n{\n    float c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvec2 rotate2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c)*vec2(1.0,1.0);\n}\n\n//iq\n//https://www.shadertoy.com/view/4sXGDs\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n    \n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    \n    float r = 0.3;\n\tfloat n = 4.0;\n    p.y=p.y-5.0;\n    \n    vec3 p1=p;\n    vec3 p2=p-vec3(-10.0,0.0,0.0);\n    \n     \n   \n    \n    //p.x=mod(p.x,15.0)-4.0;\n    p1.x=opRep1D(p1.x, 30.0);\n    p1.z=opRep1D(p1.z, 10.0);\n    \n    p2.x=opRep1D(p2.x, 30.0);\n    p2.z=opRep1D(p2.z, 20.0);\n    \n    \n    \n    \n    float c1 =sdCylinderXZ( p1-vec3(0.0), vec2(2.0,12.0) );\n    float c2 =sdCylinderXZ( p1-vec3(0.0,-4.5,0.0), vec2(3.0,0.5) );\n    \n   \n    float Uc1= fOpUnionColumns(c1, c2,  1.5,  5.0);\n    \n   vec3 pos=vec3(-5.0,-2.5,0.0);\n    float box1 = sdBox(p2-pos, vec3(3.0,2.0,2.0) );\n    float box2 = sdBox(p2-pos, vec3(1.0,25.0,1.0) );\n     \n     box2= fOpUnionColumns(box2, box1, 1.8,  n);\n     \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); \n    res =opU3(res, vec3(box2,-1.0,8.0)); \n    res =opU3(res, vec3(Uc1,-1.0,7.0)); \n\n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    \n    \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*6.0;\n     \n     if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t\t//return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n\t\t//return vec3(0.8 + 0.4*d, 0.3 + 0.55*d, 0.15 - 0.1*d);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n     \n    if (id_material==6.0)\n    {\n     vec3 pos=pp;\n     //vec4 mate = vec4(0.00,0.10,0.20,1.0)*1.25; \n     vec4 mate = vec4(1.00,0.5,0.20,1.0)*1.25; \n     mate.xyz = mix( mate.xyz, vec3(0.29, 0.27, 0.25 ), smoothstep( 0.9, 0.91, abs(pos.z) ) ); \n\t float d = distanceToSegment( vec2(0.22,0.0), vec2(-0.22,0.0), pos.yx );\n\t mate.xyz *= smoothstep( 0.04, 0.05, d );\n     return mate.xyz;\n    }\n    \n    \n    if (id_material==7.0)\n    {\n    vec3 pos=pp;\n    vec4 mate = vec4(0.20,0.00,0.00,1.0)*1.25;\n    mate.xyz = mix( mate.xyz, vec3(0.29, 0.27, 0.25 ), smoothstep( 0.9, 0.91, abs(pos.x) ) + smoothstep( 0.55, 0.56, abs(pos.y) ) ); \n    float d1 = distanceToSegment( vec2(0.22,0.0), vec2(-0.22,0.0), pos.yz );\n    float d2 = distanceToSegment( vec2(0.22,0.0), vec2( -0.07,-0.2), pos.yz*vec2(1.0,-sign(pos.x)) );\n    float d3 = distanceToSegment( vec2(-0.07,-0.2), vec2(-0.07,0.04), pos.yz*vec2(1.0,-sign(pos.x)) );\n    float d = min(d1,min(d2,d3));\n    mate.xyz *= smoothstep( 0.04, 0.05, d );\n    return mate.xyz;\n    } \n    \n    if (id_material==8.0)\n    {\n    vec3 pos=pp;\n    vec4 mate = vec4(0.20,0.50,0.50,1.0)*1.0;\n    mate.xyz = mix( mate.xyz, vec3(0.29, 0.27, 1.0 ), smoothstep( 0.9, 0.91, abs(pos.x) ) ); \n    float d1 = distanceToSegment( vec2(0.22,0.12), vec2(-0.22,0.12), pos.yz );\n    float d2 = distanceToSegment( vec2(0.22,-0.12), vec2(-0.22,-0.12), pos.yz );\n    float d = min( d1, d2 );\n    mate.xyz *= smoothstep( 0.04, 0.05, d );\n     return mate.xyz;\n    }               \n    \n    \n     if (id_material==9.0)\n    {\n     vec3 pos=pp;\n     vec4 mate = vec4(1.00,0.5,0.20,1.0)*1.25; \n     return mate.xyz;\n    }\n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\nif (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*2.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n\n    \n    vec3 ro=vec3(-8.0,4.0+abs(10.0*sin(t*0.25)),-25.0+t);\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n////-----------\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) \n{\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r)\n{\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) \n{\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.0)/((n-1.0)*2.0+sqrt(2.0));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.0)/2.0*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.0);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 467, 467, 488], [489, 489, 521, 521, 605], [606, 606, 652, 652, 739], [740, 740, 774, 774, 836], [837, 837, 874, 874, 969], [970, 970, 1009, 1009, 1104], [1105, 1105, 1144, 1144, 1239], [1240, 1240, 1279, 1279, 1374], [1376, 1420, 1467, 1467, 1494], [1496, 1496, 1539, 1539, 1566], [1568, 1568, 1616, 1616, 1644], [1645, 1729, 1765, 1765, 1810], [1817, 1882, 1916, 1916, 2014], [2015, 2015, 2049, 2049, 2141], [2142, 2142, 2176, 2176, 2268], [2269, 2309, 2343, 2343, 2440], [2441, 2441, 2465, 2465, 2535], [2536, 2536, 2557, 2557, 2626], [2627, 2627, 2651, 2651, 2734], [2782, 2782, 2833, 2833, 2955], [2959, 2999, 3024, 3024, 4089], [4093, 4093, 4158, 4158, 4752], [4756, 4807, 4831, 4831, 5019], [5020, 5083, 5116, 5116, 5577], [5579, 5633, 5669, 5669, 5903], [5960, 5994, 6074, 6074, 6347], [6390, 6441, 6488, 6488, 9072], [9126, 9126, 9219, 9219, 9486], [9491, 9540, 9597, 9597, 10812]], "test": "untested"}
{"id": "wtcfWl", "name": "Area-Preserving Square <-> Disk", "author": "TinyTexel", "description": "An invertible, area-preserving mapping to the unit disk from its enclosing square.\nThe idea is to first map the square to a 2d gaussian via the inversion method.\nThe result is then remapped to a solid disk by applying a radially symmetric transfer func.", "tags": ["map", "sampling", "mapping", "disk", "unitdisk"], "likes": 15, "viewed": 573, "published": 3, "date": "1613685230", "time_retrieved": "2024-07-30T19:37:12.895220", "image_code": "// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// https://twitter.com/Mirko_Salm\n\n/*\n\nAn invertible, area-preserving mapping to the unit disk from its enclosing square.\nThe idea is to first map the square to a 2d gaussian via the inversion method.\nThe result is then remapped to a solid disk by applying a radially symmetric transfer function.\n\nThe left half of the image illustrates the distortions caused by the square->disk mapping (implemented via the inverse mapping).\nThe right half shows a couple of random points evenly distributed on the unit disk by using the square->disk mapping.\n\n// p: [-1,1]² | return u: [-1,1]²\nvec2 DiskFromSquare(vec2 p)\n{\n    // map the square to a 2d gaussian via the inversion method:\n    vec2 v = vec2(ErfI(p.x), \n                  ErfI(p.y));// the inverse error function is the inverse cummulative distribution function (iCDF) of the one-sided normal distribution\n                   \n        // v is now a point distributed according to a 2d gauss\n\n        // since a 2d gauss is already a radially symmetrical distribution all that is left to do is to remap the distance of the point v from the origin vec2(0)\n\n        // for that we apply a transfer function tf(r) in the following way: vec2 u = normalize(v) * tf(length(v));// u is our final result\n\n        // how does tf(r) look like?\n\n        // to figure this out we need to know how length(v) is distributed\n\n        // since we are no longer interested in the normalize(v) part (as it is already correctly distributed) we radially marginalize our 2d gaussian\n\n        // for a radially symmetrical distribution in 2d, like our gauss, this marginalization boils down to a multiplication with r (distance to origin) + normalization\n\n        // therefore length(v) is distributed according to pdf_mgauss(r) = 2*r*exp(-r²) // mgauss stands for \"marginalized gauss\"\n\n        // and to get a disk we need it to be distributed according to pdf_mdisk(r) = 2*r\n\n        // so the remapping is build like this tf(r) = iCDF_mdisk(CDF_mgauss(r)) // applying the inverse inversion method for mgauss followed by the inversion mapping for mdisk\n\n        // with CDF_mgauss(r) = 1-exp(-r²)\n\n        // and  iCDF_mdisk(r) = sqrt(r) \n           \n    // therefore we get:\n    vec2 dir = normalize(v);\n    float r  = length(v);\n           \n    return dir * sqrt(1.0-exp(-r*r)); \n    \n        // inverting this mapping is rather straightforward: split the point into dir+r, apply the inverse of tf(r) to r, and apply Erf(x) to the x and y components of dir+inv_tf(r)\n        \n        // we can also save a few intructions (in particular a sqrt()) by performing some optimizations (using versions of Erf and ErfI that take squared input/return squared outputs)\n}\n\nThe mapping is area-preserving when the determinant of its Jacobian matrix is constant.\nThe following Mathematica code performs the necessary computations to verify this:\n\nnorm[x_] := Sqrt[x.x]\nmap0[x_, y_] := {InverseErf[x], InverseErf[y]}\ntf[x_] := Sqrt[1 - Exp[-x x]]\nmap[x_, y_] := map0[x, y]/norm[map0[x, y]] tf[norm[map0[x, y]]]\ndet[x_, y_] = \n FullSimplify[\n  Det[{{D[map[x, y][[1]], x], D[map[x, y][[2]], x]}, \n       {D[map[x, y][[1]], y], D[map[x, y][[2]], y]}}]]\n     \nThis code evaluates to π/4.     \n\n*/\n\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n// error function approximation by Sergei Winitzki (maximum relative error ~0.00013)\nfloat Erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n\n// ..takes the squared argument \nfloat Erf1(float xx)\n{\n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return y;\n}\n\n// inverse error function approximation by Sergei Winitzki\nfloat ErfI(float x)\n{\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(max(1e-36, 1.0 - x*x));\n    float c = u * 0.5 + b;\n    \n    float y = sqrt(max(0.0, sqrt(max(0.0, c*c - u*a)) - c));\n\n    return neg ? -y : y;\n}\n\n// ..outputs the square of the result\nfloat ErfI1(float x)\n{\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(max(1e-36, 1.0 - x*x));\n    float c = u * 0.5 + b;\n    \n    return sqrt(max(0.0, c*c - u*a)) - c;\n}\n\n\n// p: [-1,1]² | return u: [-1,1]²\nvec2 DiskFromSquare(vec2 p)\n{\n    vec2 sgn = vec2(p.x < 0.0 ? -1.0 : 1.0, \n                    p.y < 0.0 ? -1.0 : 1.0);    \n    \n    vec2 vv = vec2(ErfI1(p.x), \n                   ErfI1(p.y));\n    \n    float w = vv.x+vv.y;\n    \n    vec2 uu = vv * ((1.0-exp(-w)) / w);\n    \n    vec2 u = sqrt(uu) * sgn;\n    \n    return u;\n}\n\n// u: [-1,1]² | return p: [-1,1]²\nvec2 SquareFromDisk(vec2 u)\n{\n    vec2 sgn = vec2(u.x < 0.0 ? -1.0 : 1.0, \n                    u.y < 0.0 ? -1.0 : 1.0);\n\n    vec2 uu = u*u;\n    \n    float m = uu.x+uu.y;\n    \n    vec2 vv = uu * (-log(max(1e-36, 1.0-m)) / m);\n    \n    vec2 p = vec2(Erf1(vv.x), \n                  Erf1(vv.y)) * sgn;\n                \n    return p;                \n}\n\n//http://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\nvec2 DiskFromSquareConcentric(vec2 p)\n{\n    float pi = 3.141592;\n\n    float phi,r;\n    float a = p.x;\n    float b = p.y;\n    if (a*a> b*b) \n    {\n        r = a;\n        phi = (pi/4.0)*(b/a);\n    } \n    else \n    {\n        r = b;\n        phi = (pi/2.0)-(pi/4.0)*(a/b);\n    }\n    return vec2(cos(phi), sin(phi)) * r;\n}\n\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n    vec2 uv = uv0 - 0.5;\n    vec2 tc = uv0/iResolution.xy;\n\n    col = vec4(0.0);\n    \n    float l = iResolution.x*0.5;\n    \n    uv0.y -= max(0.0, (iResolution.y-l)*0.5);\n    \n    if(uv0.x < l)// LEFT\n    {\n        // distorted checkerboard pattern via square->disk map\n        vec2 tc = uv0 / l;\n        \n        vec2 u = tc * 2.0 - 1.0;\n        \n        if(abs(u.x) > 1.01 || abs(u.y) > 1.01) return;\n        \n        vec2 p = SquareFromDisk(clamp11(u));\n        \n        vec2 v = cos(p*(Pi*8.0));\n        \n        float n = v.x*v.y;        \n        \n        n = rescale(n)*0.5+0.5;\n        n = clamp01(n);\n        n = n*n*(3.0-2.0*n);\n        n = n*n*(3.0-2.0*n);\n        \n        col.rgb = vec3(n);\n        \n        col *= clamp01(rescale(1.0-dot(u,u)))*0.9;\n    }\n    else if(uv0.x-l < l)// RIGHT\n    {\n        // evenly distributed points on disk via square->disk map\n        vec2 tc = (uv0-vec2(l,0.0)) / l;\n        \n        vec2 p0 = tc * 2.0 - 1.0;\n        \n        if(abs(p0.x) > 1.01 || abs(p0.y) > 1.01) return;\n        \n        uint count = 64u;\n\n        float c = 0.0;\n        for(uint i = 0u; i < count; ++i)\n        {\n            uint j = i + uint(iFrame)*(count/8u);\n            \n            // 2d Roberts LDS\n            vec2 p = vec2(j * uvec2(2447445413u, 3242174889u)) * (1.0/4294967296.0);\n            \n           #if 0\n            {\n                // jitter point\n                float ang = float(WellonsHash(j))*(Pi*2.0/4294967296.0);\n\n                p = fract(p + vec2(cos(ang), sin(ang)) * 0.02);\n            }\n           #endif\n           \n            vec2 u = DiskFromSquare(p*2.0-1.0);\n            \n            vec2 vec = (p0 - u)*64.0;\n            \n            float pt = 1.0-dot(vec, vec);\n\n            pt = clamp01(rescale(pt));\n            \n            c += pt*0.5;\n        }\n        \n        c += clamp01(rescale(1.0-dot(p0,p0)))*0.01;\n        \n        col.rg = tc;\n        col.rgb = vec3(c);\n    }\n    \n    col.rgb = GammaEncode(clamp(col.rgb, 0.0, 1.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define clamp11(x) clamp(x,-1.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\nconst float Pi025 = Pi * 0.25;\nconst float Phi    = 1.61803399;\nconst float PhiRcp = 0.61803399;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfWl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[3413, 3586, 3606, 3606, 3837], [3839, 3872, 3894, 3894, 4068], [4070, 4129, 4150, 4150, 4427], [4429, 4467, 4489, 4489, 4699], [4702, 4738, 4767, 4767, 5060], [5062, 5098, 5127, 5127, 5444], [5446, 5525, 5564, 5564, 5841], [5844, 5844, 5887, 5887, 7882]], "test": "untested"}
{"id": "3ttfWs", "name": "Graph Connection Test 2", "author": "pprovins", "description": "More testing, 1500 primitives", "tags": ["2d", "graph"], "likes": 3, "viewed": 265, "published": 3, "date": "1613683393", "time_retrieved": "2024-07-30T19:37:13.776863", "image_code": "float circleDist( in vec2 uv, in vec2 pos, in float r ) {\n    return length(uv - pos) - r;\n}\n\nfloat boxDist( in vec2 p, in vec2 a, in vec2 b, in float r ) {\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return d - r;//vec3(d-r,q/d);\n}\n\nfloat circleScene(in vec2 p) {\n    float d = 100000.0;\n    for (float i = 0.0; i < 500.0; ++i){\n        float c = circleDist(p, vec2(-1.0 + i * 0.05, -0.8 + i * 0.05), 0.05);\n        float c2 = circleDist(p, vec2(1.0  + i * 0.02, 0.0 + i  * 0.02), 0.05);\n        d = min(d, min(c, c2));\n    }\n    return d;\n}\n\nfloat segmentScene(in vec2 p) {\n    float d = 1000000.0;\n    for (float i = 0.0; i < 500.0; ++i){\n        vec2 c  = vec2(-1.0 + i * 0.05, -0.8 + i * 0.05);\n        vec2 c2 = vec2(1.0  + i * 0.02, 0.0 + i  * 0.02);\n        float b = boxDist(p, c, c2, 0.005);\n        d = min(d, b);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tfloat d = circleScene(p);\n    float d2 = segmentScene(p);\n    \n\t// color circles ...\n    vec3 col = vec3(0.9,0.1,0.1);\n    if (d > 0.0) { \n        col = vec3(1.0,1.0,1.0) * (pow(d, 0.25));\n    }\n    \n    // draw the connections ...\n    if (d2 < 0.0 && d2 < d) {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 92], [94, 94, 156, 156, 325], [327, 327, 357, 357, 635], [637, 637, 668, 668, 939], [941, 941, 998, 998, 1390]], "test": "untested"}
{"id": "WldBW2", "name": "Soul creature", "author": "kosmaks", "description": "Experiments with trying to create visuals from movie Soul. First time implementing fog effects, animation, futuristic grass and using aces film filter for color grading.\n\n(it looks nothing like soul, but still pretty cool imo :)\n\ngh: kosmaks", "tags": ["raytracing", "gi", "raymarcher", "render", "soul"], "likes": 47, "viewed": 3537, "published": 3, "date": "1613681589", "time_retrieved": "2024-07-30T19:37:14.539823", "image_code": "#define MAX_COUNT (150)\n#define MIN_DIST (0.001)\n#define MAX_DIST (3.)\n\n#define SOUL_SIZE (0.2)\n\n#define M_SOUL_BODY 1\n#define C_SOUL_BODY (vec3(0.24, 0.97, 0.37) + 0.2)\n#define M_SOUL_EYE 2\n#define C_SOUL_EYE (vec3(1.))\n#define M_SOUL_EYEBALL 3\n#define C_SOUL_EYEBALL (vec3(0.1))\n#define M_SOUL_EYEBROW 4\n#define C_SOUL_EYEBROW (vec3(0.2, 0.4, 0.4))\n#define M_SOUL_CHEEK 5\n#define C_SOUL_CHEEK (vec3(0.74, 0.57, 0.17))\n#define M_TREE 6\n#define C_TREE (vec3(0.6, 0.2, 0.6) * 0.9)\n\n#define M_TERRAIN 10\n#define C_TERRAIN (vec3(0.1, 0.6, 1.7))\n#define M_GRASS 11\n#define C_GRASS1 (vec3(1.24, 4.97, 3.37))\n#define C_GRASS (vec3(3.9, 0.37, 3.9))\n\n#define C_SKY_UP (vec3(0.29, 0.44, 1.56))\n#define C_SKY_DOWN (vec3(4.5, 0.94, 4.57))\n\nstruct M {\n    vec3 emission;\n    vec3 diffuse;\n};\n\nfloat noise(in vec2 uv) {\n    return fract(sin(uv.x * 1233.52 + uv.y * 99.23423) * 324.234);\n}\n\nfloat noiseSmooth(in vec2 uv) {\n    vec2 uvs = floor(uv);\n    vec2 d = fract(uv);\n    vec2 s = vec2(1., 0.);\n    float tl = noise(uvs);\n    float tr = noise(uvs + s.xy);\n    float bl = noise(uvs + s.yx);\n    float br = noise(uvs + s.xx);\n    float top = mix(tl, tr, d.x);\n    float bottom = mix(bl, br, d.x);\n    float mx = mix(top, bottom, d.y);\n    return max(0., mx);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n, float d) {\n    float denom = dot(n, rd);\n    if (abs(denom) > 1e-6) {\n        return dot(n*d - ro, n) / denom;\n    }\n    return -1.;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nfloat getSoulCurve(in float time) {\n    return cos(time) * 0.5 + 0.5;\n}\n\nfloat sdSoulHead(in vec3 p, in float size, in float curve) {\n    float d;\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n\n    float lowSphere = length((p) * vec3(1., 1.7, 1.) - vec3(0., -0.5, 0.) * size) - size;\n    float hiSphere = length(p * vec3(1., 1.5, 1.) - vec3(0., 0.3, 0.) * size) - size * 0.9;\n    float head = smin(lowSphere, hiSphere, 0.5 * size);\n    d = head;\n    \n    float eye = length(mir - vec3(0.7, 0.15, -1.2) * size) - size * 0.33;\n    d = smax(d, -eye, 0.4 * size);\n    \n    return d;\n}\n\n#define SEPOS (vec3(0.4, 0.05, -0.65))\nfloat sdSoulEye(in vec3 p, in float size) {\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n    return length(mir - vec3(0.4, 0.05, -0.65) * size) - size * 0.2;\n}\n\nfloat sdSoulEyebrow(in vec3 p, in float size, in float curve) {\n    float jump = max(0., curve - 0.6);\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n    return length((mir - vec3(0.4, 0.4 + jump * 1. * size, -.55) * size) * vec3(1., 5., 1.) ) - size * 0.2;\n}\n\nfloat sdSoulMouth(in vec3 p, in float size, in float curve) {\n    return length((p - vec3(0., -0.3 + p.x*p.x*20., -0.9) * size) * vec3(1.2, mix(9., 3., curve), 1.)) - size * 0.2;\n}\n\nfloat sdBody(in vec3 p, in float size, in float curve) {\n    p -= vec3(0., -1.4, 0.) * size;\n    \n    float spread = min(0., -cos((p.y / size) * 2.)) * mix(0.4, 0., curve) + 1.;\n    float shrink = mix(1.4, 1., curve);\n    p *= vec3(spread, shrink, spread);\n    \n    return max(\n        smin(\n            length(p.xz) - size * 0.3,\n            length(p - vec3(0., -0.6, 0.) * size) - size * 0.5,\n            0.35 * size\n        ),\n        length(p) - size * 0.8\n    );\n}\n\nvec2 modSoul(in vec3 pOrig, in float size, in float time) {\n    float curve = getSoulCurve(time);\n    vec3 p = pOrig;\n    \n    float jump = max(0., curve - 0.6);\n    \n    p -= vec3(0., 2.1 + mix(-0.2, 0., curve) + jump, 0.) * size;\n    \n    float body = sdBody(p, size, curve);\n    float head = sdSoulHead(p, size, curve);\n    \n    float cheekDot = abs(dot(\n        normalize(p * vec3(sign(p.x), 1., 1.)), \n        normalize(vec3(0.8, -0.45, -1.))\n    ));\n    \n    vec2 res = vec2(\n        smin(head, body, 0.5 * size), \n        cheekDot > 0.988 ? M_SOUL_CHEEK : M_SOUL_BODY\n    );\n    \n    \n    \n    float mouth = sdSoulMouth(p, size, curve);\n    if (-mouth > res.x) { res = vec2(mouth, vec3(0.1)); }\n    \n    float eye = sdSoulEye(p, size);\n    if (eye < res.x) { \n        vec3 eyePos = normalize(p * vec3(sign(p.x), 1., 1.) - SEPOS * size);\n        bool ball = dot(eyePos, normalize(vec3(0.3, 0., -1.))) > 0.95;\n        res = vec2(eye, ball ? M_SOUL_EYEBALL : M_SOUL_EYE); \n    }\n    \n    float eyebrow = sdSoulEyebrow(p, size, curve);\n    if (eyebrow < res.x) { res = vec2(eyebrow, M_SOUL_EYEBROW); }\n    \n    return res;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTerr(vec3 p) {\n    float cell = 0.01;\n    p -= vec3(0., -0.01, 0.);\n    vec2 fl = mod(p.xz, cell);\n    vec3 rp = vec3(fl.x, p.y, fl.y) - vec3(cell, 0., cell) / 2.;\n    \n    vec2 corner = floor(p.xz / cell) * cell;\n    \n    float disp = noise(corner * 200.);\n    disp = mix(-0.4, 0.05, disp);\n    \n    rp -= vec3(0., 0. + disp, 0.);\n    \n    float dist = sdSphere(\n        rp * vec3(1., 0.1, 1.), \n        0.004\n    );\n    \n    return min(p.y, dist);\n}\n\nfloat sdTree(vec3 p) {\n    float r = 0.3;\n    return sdSphere((p - vec3(0., r + 0.2, 0.)) * vec3(3., 1., 2.), r) * 0.8;\n}\n\n///\n///\n///\n\nvec2 getDist(vec3 p, bool ignoreSouls) {\n    vec2 res = vec2(MAX_DIST, -1.);\n    \n    vec2 temp;\n    \n    if (!ignoreSouls) {\n        temp = modSoul(p - vec3(0., 0.03, 0.), SOUL_SIZE, iTime * 8.);\n        if (temp.x < res.x) { res = temp; };\n    }\n    \n    temp = vec2(sdTerr(p), M_GRASS);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree(p - vec3(-0.95, sin(iTime) * 0.03, 0.5)), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree((p - vec3(0.8, sin(iTime + 3.) * 0.03, 0.8)) * 1.2), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree((p - vec3(0.7, sin(iTime * 2.) * 0.03 - 0.4, -0.5)) * 0.4), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    return res;\n}\n\n///\n///\n///\n\nvec3 getNormal(vec3 p, bool ignoreSouls) {\n    float dist = getDist(p, ignoreSouls).x;\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = dist - vec3(\n        getDist(p - e.xyy, ignoreSouls).x,\n        getDist(p - e.yxy, ignoreSouls).x,\n        getDist(p - e.yyx, ignoreSouls).x);\n    return normalize(n);\n}\n\nvec2 rayCast(vec3 ro, vec3 rd, bool ignoreSouls) {\n    float total = 0.;\n    \n    for (int i = 0; i < MAX_COUNT; ++i) {\n        vec2 hit = getDist(ro + rd * total, ignoreSouls);\n        float d = hit.x;\n        total += d;\n        if ((d) < MIN_DIST) return vec2(total, hit.y);\n        if (total > MAX_DIST) return vec2(total, -1.);\n    }\n    \n    return vec2(MAX_DIST + 1., -1.);\n}\n\nM getMaterial(float m, vec3 rd, vec3 touch) {\n    int im = int(m);\n    vec3 z = vec3(0.);\n    \n    if (im == M_SOUL_BODY) return M(z, C_SOUL_BODY);\n    if (im == M_SOUL_EYE) return M(z, C_SOUL_EYE);\n    if (im == M_SOUL_EYEBALL) return M(z, C_SOUL_EYEBALL);\n    if (im == M_SOUL_EYEBROW) return M(z, C_SOUL_EYEBROW);\n    if (im == M_SOUL_CHEEK) return M(z, C_SOUL_CHEEK);\n    \n    if (im == M_GRASS) {\n        float cell = 0.4;\n        vec2 corner = floor(touch.xz / cell) * cell;\n        float cf = noise(corner * 100.);\n        vec3 col = mix(C_GRASS1, C_GRASS, cf);\n        float f = clamp(touch.y, 0., 0.1) / 0.1;\n        return M(z, mix(C_TERRAIN, col * 3., f));\n    }\n    \n    if (im == M_TERRAIN) {\n        return M(z, C_TERRAIN);\n    }\n    \n    float angle = dot(rd, vec3(0., 1., 0.));\n    float axis = dot(rd, vec3(-1., 0., 0.));\n    \n    float skypow = clamp(angle, 0., 1.);\n    vec3 sky = mix(C_SKY_DOWN, C_SKY_UP, smoothstep(-0.3, 0.25, skypow));\n    \n    \n    float mount;\n    \n    mount = (sin(axis * 5.5 + 2.5)) * 0.1 - 0.;\n    mount = exp(-max(0., angle - mount)*25.);\n    sky = mix(sky, vec3(0.6, 0.5, 4.9) * mix(0.5, 1., angle/0.2), mount);\n    \n    mount = (sin(axis * 6.) * 0.5 + 0.5) * 0.1 - 0.15;\n    mount = exp(-max(0., angle - mount)*65.);\n    sky = mix(sky, vec3(0.8, 0.9, 1.9) * mix(0.4, 0.3, angle/0.2), mount);\n    \n    mount = (sin(axis * 6.) * 0.5 + 0.5) * 0.1 - 0.23;\n    mount = exp(-max(0., angle - mount)*65.);\n    sky = mix(sky, vec3(3.4, 2.9, 1.9) * mix(0.4, 0.3, angle/0.2), mount);\n    \n    \n    if (im == M_TREE) {\n        return M(z, C_TREE);\n    }\n    \n    return M(sky, z);\n}\n\nvec3 getLightWithPos(in vec3 lightPos, in vec3 lightCol, in vec3 p, in vec3 n, bool occlusion) {\n    vec3 toLight = lightPos - p;\n    vec3 nToLight = normalize(toLight);\n    float dToLight = length(toLight);\n    float pLight = max(0., dot(n, nToLight));\n    if (occlusion) {\n        float occlDist = rayCast(p + nToLight * 0.01, nToLight, false).x;\n        pLight *= min(1., pow(occlDist / dToLight, 1.));\n    }\n    return pLight * lightCol;\n}\n\nvec3 getLight(in vec3 p, in vec3 n, bool occlusion) {\n    return getLightWithPos(vec3(1., 1., -1.), vec3(1.3), p, n, occlusion) + \n        getLightWithPos(vec3(-1., 0.4, 1.), vec3(5., .2, .2) * 2., p, n, occlusion);\n}\n\nvec3 castToLight(in vec3 ro, in vec3 rd, out vec2 hit, out vec3 n, out vec3 touch, bool ignoreSouls) {\n    vec3 col = vec3(0.);\n    \n    hit = rayCast(ro, rd, ignoreSouls);\n    if (hit.x >= MAX_DIST) {\n        return getMaterial(-1., rd, touch).emission;\n    }\n    \n    touch = ro + rd * hit.x;\n    M m = getMaterial(hit.y, rd, touch);\n    \n    vec3 ambient = C_SKY_UP;\n    col += m.diffuse * ambient;\n    \n    vec3 lightPos = vec3(2., 1.5, -3.);\n    vec3 lightCol = vec3(1.) * 2.;\n    \n    col += m.emission;\n    \n    if (length(m.diffuse) > 0.01) {\n        n = getNormal(touch, ignoreSouls);\n        col += m.diffuse * getLight(touch, n, true);\n    }\n    \n    return col;\n}\n\nvec3 renderScene(in vec3 ro, in vec3 rd) {\n    vec2 hit;\n    vec3 n, touch;\n    vec3 col = castToLight(ro, rd, hit, n, touch, false);\n    \n    int mid = int(hit.y);\n    if (mid == M_SOUL_BODY || mid == M_SOUL_CHEEK) {\n        float f = 1.-max(0., -dot(n, rd));\n        f = clamp(f, 0.5, 0.8) - 0.5;\n        f /= 0.3;\n        if (f > 0.1) {\n            vec3 sub = castToLight(ro, rd, hit, n, touch, true);\n            col = mix(col, sub, f) * (1. - abs(n) * 0.3);\n        }\n    }\n    \n    if (mid == M_TREE) {\n        vec3 sky = getMaterial(-1., rd, touch).emission;\n        float f = 1.-max(0., -dot(n, rd));\n        f = clamp(f, 0.0, 1.);\n        f /= 0.9;\n        f = max(0., f);\n        col = mix(col, sky, f);\n    }\n    \n    if (hit.x < MAX_DIST && touch.y < 0.1) {\n        vec3 planeN = vec3(0., 1., 0.);\n        float upDist = rayPlane(ro, rd, planeN, 0.1);\n        if (upDist > 0.) {\n            vec3 plane = ro + rd * upDist;\n            float dist = length(plane - touch);\n            \n            float scaterring = 1. - exp(-dist * 10.);\n            float absorbing = 1. - exp(-dist * 35.);\n            \n            vec3 diffuse = C_TERRAIN;\n            \n            col = mix(col, vec3(0.), absorbing) + \n                scaterring * diffuse * getLight(plane + 0.5 * dist * rd, planeN, false);\n        }\n    }\n    \n    if (hit.x < MAX_DIST && touch.y < 0.15) {\n        vec3 planeN = vec3(0., 1., 0.);\n        float upDist = rayPlane(ro, rd, planeN, 0.15);\n        if (upDist > 0.) {\n            vec3 plane = (ro + rd * upDist);\n            \n            vec3 diffuse = vec3(noiseSmooth(plane.xz * 9. + vec2(0., iTime * 0.3)));\n            col += diffuse * 0.2 * getLight(plane, planeN, false);\n            \n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vpShift = vec2(iResolution.x/iResolution.y, 1.);\n    vec2 vp = fragCoord/iResolution.y*2. - vpShift;\n    \n    float time = iTime * 0.5;\n    vec3 origin = vec3(sin(time) * 0.2, 0.5, -2.);\n    vec3 target = vec3(0., 0.4, 0.);\n    vec3 up = vec3(0., 1., 0.);\n     \n    vec3 camForward = normalize(target - origin);\n    vec3 camRight = normalize(cross(up, camForward));\n    vec3 camUp = cross(camForward, camRight);\n    \n    vec3 ro = origin;\n    vec3 rd = normalize(3. * camForward + camRight * 1. * vp.x + camUp * vp.y);\n\n    vec3 col = renderScene(ro, rd);\n    \n    //fragColor = vec4(col, 1.);\n    fragColor = vec4(ACESFilm(col), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[781, 781, 806, 806, 875], [877, 877, 908, 908, 1249], [1251, 1251, 1302, 1302, 1426], [1428, 1428, 1467, 1467, 1560], [1562, 1562, 1601, 1601, 1632], [1634, 1634, 1657, 1657, 1817], [1819, 1819, 1854, 1854, 1890], [1892, 1892, 1952, 1952, 2397], [2438, 2438, 2481, 2481, 2596], [2598, 2598, 2661, 2661, 2854], [2856, 2856, 2917, 2917, 3036], [3038, 3038, 3094, 3094, 3507], [3509, 3509, 3568, 3568, 4636], [4638, 4638, 4671, 4671, 4699], [4701, 4701, 4723, 4723, 5160], [5162, 5162, 5184, 5184, 5283], [5298, 5298, 5338, 5338, 6036], [6051, 6051, 6093, 6093, 6350], [6352, 6352, 6402, 6402, 6734], [6736, 6736, 6781, 6781, 8354], [8356, 8356, 8452, 8452, 8799], [8801, 8801, 8854, 8854, 9018], [9020, 9020, 9122, 9122, 9695], [9697, 9697, 9739, 9739, 11449], [11451, 11451, 11508, 11508, 12155]], "test": "untested"}
{"id": "3tdBWs", "name": "Graph Connection Test", "author": "pprovins", "description": "Simple test of two nodes connected with a \"line\" (box) segment.", "tags": ["2d", "sdf"], "likes": 1, "viewed": 266, "published": 3, "date": "1613681291", "time_retrieved": "2024-07-30T19:37:15.359631", "image_code": "float circleDist( in vec2 uv, in vec2 pos, in float r ) {\n    return length(uv - pos) - r;\n}\n\nfloat boxDist( in vec2 p, in vec2 a, in vec2 b, in float r ) {\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return d - r;//vec3(d-r,q/d);\n}\n\nfloat circleScene(in vec2 p) {\n    float c = circleDist(p, vec2(-1.0, -0.2), 0.5);\n    float c2 = circleDist(p, vec2(1.0, 0.0), 0.5);\n    return min(c, c2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tfloat d = circleScene(p);\n    float d2 = boxDist(p, vec2(-1.0, -0.2), vec2(1.0, 0.0), 0.15);\n    \n\t// color circles ...\n    vec3 col = vec3(0.9,0.1,0.1);\n    if (d > 0.0) { \n        col = vec3(1.0,1.0,1.0) * (pow(d, 0.25));\n    }\n    \n    // draw the connections ...\n    if (d2 < 0.0 && d2 < d) {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 92], [94, 94, 156, 156, 325], [327, 327, 357, 357, 485], [487, 487, 544, 544, 971]], "test": "untested"}
{"id": "ttcBDs", "name": "Refactoring Blackpool", "author": "evvvvil", "description": "Refactoring Blackpool - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "glow", "alien", "city", "scifi", "cut", "lazer", "network", "structure", "industrial", "building", "extrusion", "brutalist", "modernist"], "likes": 25, "viewed": 924, "published": 3, "date": "1613678655", "time_retrieved": "2024-07-30T19:37:16.193402", "image_code": "// Refactoring Blackpool - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\n// \"One day kids, I'll refactor Blackpool\" - Le Corbusier \n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,b,g=0.,gg=0.;vec3 np,pp,po,no,al,ld,cp,op;\nfloat bo(vec2 p, vec2 b ){ p= abs(p)-b;return length(max(p,0.))+min(max(p.x,p.y),0.);}\nfloat box(vec3 p, vec3 b ){ p= abs(p)-b;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nfloat ex(vec3 p,float sdf,float h){vec2 w=vec2(sdf,abs(p.y)-h);return min(max(w.x,w.y),0.0)+length(max(w,0.0));}\nvec2 mp( vec3 p)\n{\n  op=p;\n  p.x=mod(p.x-tt*0.7,20.)-10.;\n  np=vec3(p.xz*.5,1.0);\n  pp=p-vec3(0,3,0);  \n  pp.xz=mod(pp.xz,5.)-2.5;\n  pp.yz*=r2(.785);\n  vec2 h=vec2(1000,6),t=vec2(1000,5);  \n  float cutBox=box(pp,vec3(2.0,1.5,2.5));    \n  for(int i=0;i<4;i++){\n    b=float(i);\n    np.xy=abs(np.xy)-2.0;    \n    np.xy*=r2(.785*(b+1.));\n    np*=1.8;\n    np.y=abs(np.y)-1.5;         \n    t.x=min(t.x,ex(p,max(bo(np.xy,vec2(5,.2))/np.z*2.0,-cutBox),1.0+b*.5)); \n    t.x=abs(t.x)-.02*max(sin(p.y*10.),0.1)-.04*clamp(sin(np.x*2.5),.1,.5); \n    h.x=min(h.x,ex(p,bo(np.xy,vec2(5.,0.01))/np.z*2.0,.25+b*.5-0.1*cos(op.x*1.3+1.5)));    \n    t.x=max(t.x,abs(p.y)-0.3-b*.5);     \n  } \n  h.x=max(h.x,-cutBox+.1);    \n  g+=0.1/(0.1+h.x*h.x*(1.-sin(op.x*1.3)*.9)*1600.);    \n  cp=vec3(np.xy,p.y*2.);\n  h.x=min(h.x,box(cp+vec3(-5.,2,0),vec3(1.7,1,5.+sin(p.x*.7)))/np.z*2.);\n  float part=length(cos(cp.yz*20.));   \n  part=max(part,p.y-1.5);\n  gg+=0.1/(0.1+part*part*12.);\n  t.x=min(t.x,part);\n  t=t.x<h.x?t:h;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd)\n{\n  vec2 h,t=vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);\n    if(t.x<.0001||t.x>20.) break;\n    t.x+=h.x;t.y=h.y;\n  }\n  if(t.x>20.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=vec3(10.,2.9-sin(tt*.2)*.8,-4.+ceil(cos(tt*.2))*8.+cos(tt*0.4)*2.),\n  cw=normalize(vec3(0,-6,0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),\n  cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  \n  co=fo=vec3(.18,.16,.2)-length(uv)*.25;\n  ld=normalize(vec3(.2,.4,-.3));  \n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){    \n    po=ro+rd*t;\n    no=normalize(e.xyy*mp(po+e.xyy).x+\n    e.yyx*mp(po+e.yyx).x+\n    e.yxy*mp(po+e.yxy).x+\n    e.xxx*mp(po+e.xxx).x);\n    no-=0.3*ceil(abs(sin(cp*10.))-.1);no=normalize(no);\n    al=mix(vec3(0.4),vec3(0.0,0.15,0.75 ),cp.y*.5);\n    if(z.y>5.) al=vec3(1.2);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.),\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n    co=mix(sp+al*(a(.12)+.2)*(dif+s(2.)),fo,min(fr,0.4));    \n    co=mix(fo,co,exp(-.0007*t*t*t));\n  }\n  fragColor = vec4(pow(co+g*.1*vec3(.1,.2,.7)+gg*.05*vec3(.4,.1,.1),vec3(.65)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 365, 365, 425], [426, 426, 453, 453, 496], [497, 497, 514, 514, 557], [558, 558, 593, 593, 670], [671, 671, 689, 689, 1675], [1676, 1676, 1704, 1704, 1868], [1958, 1958, 2015, 2015, 3033]], "test": "untested"}
{"id": "tl3BWs", "name": "bokeh expe 03", "author": "YitingLiu", "description": "experimenting with bokeh and struct ", "tags": ["bokeh", "lights", "drive", "street", "artofcode"], "likes": 4, "viewed": 393, "published": 3, "date": "1613678213", "time_retrieved": "2024-07-30T19:37:16.963343", "image_code": "//tutorial https://youtu.be/52TMliAWocY\n\n#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n    vec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c+uv.x*r+uv.y *u;\n    a.d=normalize(i-a.o);\n    \n    return a;\n}\n\n\n\nvec4 N14(float t){\n    return fract(sin(t*vec4(123.,1024.,3456.,9575.))*vec4(2348.,125.,2518,6578.));\n}\n\nfloat N(float t){\n    return fract(sin(t*1258.)*6527.);\n}\n\n\nvec3 ClosetPoint(ray r, vec3 p){\n    return r.o+max(0.,dot(p-r.o,r.d))*r.d;\n\n}\n\nfloat DistRay(ray r, vec3 p){\n    return length(p-ClosetPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    size*=length(p);\n    float d = DistRay(r,p);\n    float c = S(size, size*(1.-blur),d);\n    c*=mix(.6,1.,S(size*.8,size,d));\n    return c;\n\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x)-.08;\n\n    float s = 1./10.;\n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    vec3 p = vec3(2.,2.,100.-ti*100.);\n    m+= Bokeh(r,p,.1,.1)*ti*ti*ti*ti;\n    }\n    return  vec3(1.,.7,.3)*m;\n\n}\n\n\nvec3 Envlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x)-.08;\n\n    float s = 1./10.;\n    //float m = 0.;\n    vec3 c = vec3(0.);\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    \n    vec4 n = N14(i+side*100.);//make it asymetrical\n    \n    float fade = ti*ti*ti*ti;\n    \n    float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;//times 2 pi\n    \n    fade = occlusion; \n    \n    float x = mix(2.5,10.,n.x);\n    float y = mix(.1,1.5,n.y);\n    \n    \n    vec3 p = vec3(x,y,50.-ti*50.);\n    vec3 col = n.wzy;// random color\n    c+= Bokeh(r,p,.1,.1)*fade *col*.2;\n    }\n    return  c;\n\n}\n\nvec3 Headlights(ray r, float t){\n    t*=.5;\n   \n   float w1 = .35;// distance between headlight \n   float w2 = w1*1.2;\n\n    float s = 1./30.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// randomize the headlight using noise \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti;\n        \n        float focus = S(.8,1.,ti);\n        float size = mix(.05,.03,focus);        \n   \n        m+= Bokeh(r,vec3(-1.-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(-1.-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w2,.15,z),size,.1)*fade;\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(-1.-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(-1.+\n        w2,-.15,z),size*3.,1.)*fade;\n        \n        m+=ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(.9,.9,1.)*m;//blue and green \n\n}\n\nvec3 Taillights(ray r, float t){\n\n    t *=.8;\n   \n    float w1 = .25;// distance between headlight \n    float w2 = w1*1.2;\n\n    float s = 1./15.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// 0 1 randomize the headlight using noise \n        \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        // n = 0 0.5 \n        float lane = step(.5,n);// 0 1 \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti*ti;\n        \n        float focus = S(.9,1.,ti);\n        float size = mix(.05,.03,focus);\n        \n        float laneShift = S(.99,.96,ti);\n        float x = 1.5 -lane*laneShift;\n        \n        float blink = step(0.,sin(t*10000.))*7.*lane*step(.96,ti);\n   \n        m+= Bokeh(r,vec3(x-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(x-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w2,.15,z),size,.1)*fade*(1.+blink);\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(x-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(x+\n        w2,-.15,z),size*3.,1.)*fade*(1.+blink*.1);\n        \n        m += ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(1.,.1,.03)*m;//red\n\n}\n\n\n\nvec2 Rain(vec2 uv, float t){\n    t*=40.;\n\n    //uv*=3.;\n    vec2 a = vec2(3.,1.);\n    vec2 st = uv*a;\n    st.y+=t*.2;\n    vec2 id = floor(st);\n   \n    float n = fract(sin(id.x*716.34)*768.34);//creating a quick random function\n\n    uv.y+=n;\n    st.y+=n;\n    \n    id = floor(st);\n    st = fract(st)-.5;\n\n    t += fract(sin(id.x*76.34+id.y*1453.7)*768.35)*6.283;//create phase difference \n \n    float y = -sin(t+sin(t+sin(t)*.5))*.43;//making sawtooth wave so goes up fast and goes down slower\n    vec2 p1 = vec2(0.,y);\n    \n    vec2 o1 = (st-p1)/a;\n    float d = length(o1);\n    \n    float m1 = S(.07,.0,d);\n    \n    //leave a trail of waterdrops \n    \n    vec2 o2 = fract(uv*a.x*vec2(1.,2.)-.5)/vec2(1.,2.);\n    d = length(o2);\n    float m2 = S(.3*(.5-st.y),.0,d)*S(-.1,.1,st.y-p1.y);\n\n   // if(st.x>.46 || st.y>.49) m1=1.;// drawing grid \n    \n    \n\n    return vec2(m1*o1*50.+m2*o2*10.);//m2\n\n\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.05+m.x;  \n\n    vec3 camPos = vec3(.5,.18,0.);\n    vec3 lookat = vec3(.5,.22,1.);\n    \n    vec2 rainDistort = Rain(uv*5.,t)*.5;\n    \n   rainDistort += Rain(uv*7.,t)*.5;\n   \n   \n   //making water effect \n   uv.x+=sin(uv.y*70.)*.005;\n   uv.y+=sin(uv.x*170.)*.003;\n   \n   ray r = GetRay(uv-rainDistort*.5,camPos,lookat,2.);\n  \n\n    vec3 col = Streetlights(r,t);\n    col += Headlights(r,t);\n    col += Taillights(r,t);\n    col += Envlights(r,t);\n    \n    col+=(r.d.y+.25)*vec3(.2,.1,.5);\n    \n   // col=vec3(rainDistort,0.);\n\n\nfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 171, 171, 409], [413, 413, 431, 431, 516], [518, 518, 535, 535, 575], [578, 578, 610, 610, 656], [658, 658, 687, 687, 728], [730, 730, 782, 782, 926], [928, 928, 962, 962, 1259], [1262, 1262, 1293, 1293, 1899], [1901, 1901, 1933, 1933, 3041], [3043, 3043, 3075, 3075, 4435], [4439, 4439, 4467, 4467, 5336], [5337, 5337, 5393, 5443, 6148]], "test": "untested"}
{"id": "tl3fWs", "name": "Circuit board fractal", "author": "jarble", "description": "I found a fractal pattern that looks like a printed circuit board.", "tags": ["fractal", "circuit"], "likes": 11, "viewed": 343, "published": 3, "date": "1613676100", "time_retrieved": "2024-07-30T19:37:17.734282", "image_code": "vec2 triangle_wave(vec2 a,float scale){\n    return (abs(fract(a*scale)-.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    for(int c=0;c<3;c++){\n        float t1 = 5.0;\n\t    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1;\n        uv += vec2(iTime/2.0,iTime/3.0)/t1;\n        \n        float offset = .4;\n        float scale = 1.5;\n        for(int i=0;i<6;i++)\n        {\n          \n            uv = triangle_wave(uv.yx+offset,scale)+triangle_wave(uv,scale);\n            uv= uv+col.xy;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 78], [80, 80, 137, 137, 648]], "test": "untested"}
{"id": "tl3fDl", "name": "Parabolas -> Triangle", "author": "branc116", "description": "Stacked parabolas converge to trinagle. :)", "tags": ["triangle", "parabola"], "likes": 3, "viewed": 263, "published": 3, "date": "1613670379", "time_retrieved": "2024-07-30T19:37:18.503226", "image_code": "\n#define zoom 16.0\n#define t 0.01\n\nvec4 vclamp(in vec4 a) {\n    return vec4(\n        min(max(a.x, 0.0), 1.0),\n        min(max(a.y, 0.0), 1.0),\n        min(max(a.z, 0.0), 1.0),\n        min(max(a.w, 0.0), 1.0)\n    );\n}\n\nvec4 color(vec3 uv) {\n\tvec4 oc;\n    uv.y -= 1.0;\n    uv *=  max(1.0, 39.0 * pow(abs(sin(.1*uv.z)), 2.));\n    uv.x *= 1.7;\n    oc = vec4(0.0);\n   \toc += vec4(abs(uv.x) < 0.1 && uv.y > -1.0 ? 1.0 : 0.0) * .5;\n\tfloat i = float(int(uv.y));\n    if (i >= 0.0)\n    \treturn oc;\n    \n    uv.y = mod(uv.y, -1.0);\n    uv.x += float(i);\n    float j = float(int(uv.x + 1.0));\n\tuv.x = mod(uv.x, 2.0);\n\tuv.x -=1.0;\n    uv.y += 0.09;\n\tif (j >= 1.0)\n\t\treturn oc;\n\tif ( j < (i + 1.0) * 2.0)\n\t\treturn oc;\n\tfloat e = abs(-uv.x * uv.x - uv.y);\n    oc += vec4(exp(-e*30.0));\n\t//oc += e < t ? 1.4 : 0.0;\n\treturn oc;\n}\n#define mt 0.02\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst ivec3 msaa = ivec3(4, 4, 4);\n    const vec3 msaaf = vec3(msaa);\n\tvec3 uv = vec3((fragCoord.xy/iResolution.xy * vec2(1.0, 1.) - vec2(.5))  * zoom, iTime);\n\tfragColor = vclamp(color(uv));\n\tfor (int i = 0 ; i <= msaa.x ; i++) {\n\t\tfloat l = ((msaaf.x / -2.0) + float(i))/msaaf.x * 1.0;\n\t\t\tfor (int j = 0 ; j <= msaa.y ; j++) {\n                float tt = (-(msaaf.y / 2.0) + float(j))/msaaf.y * 1.0;\n                for (int k = 0; k <= msaa.z ; k++) {\n                    float time = iTime + (-mt + 2.0*mt*(float(k)/msaaf.z));\n                    uv = vec3(((fragCoord.xy + vec2(l, tt)) /iResolution.xy * vec2(1.0, 1.) - vec2(.5)) * zoom, time * 2.0);\n                    fragColor += vclamp(color(uv));\n                }\n\t\t}\n\t}\n\tfragColor /=msaaf.x;\n    fragColor /=msaaf.y;\n    fragColor /=msaaf.z;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 59, 59, 216], [218, 218, 239, 239, 812]], "test": "untested"}
{"id": "tltfWf", "name": " Pick Points On Hemisphere", "author": "moranzcw", "description": "Uniform distribution and cosine distribution.", "tags": ["3d"], "likes": 4, "viewed": 451, "published": 3, "date": "1613664244", "time_retrieved": "2024-07-30T19:37:19.271172", "image_code": "// Pick Points On Hemisphere - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n#define PI 3.14159265359\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere sphere1 = Sphere(1.0, vec3(-1.2, 0.0, 0.0));\nSphere sphere2 = Sphere(1.0, vec3(1.2, 0.0, 0.0));\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\n// unifrom picking\nvec3 hemiSpherePoint(vec3 normal)\n{\n    float theta = 2.0 * PI * frand();\n    float cosPhi = frand();\n    float phi = acos(cosPhi);\n    \n    vec3 zAxis = normal;\n    vec3 xAxis = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    vec3 yAxis = normalize(cross(normal, xAxis));\n    \n    vec3 x = cos(theta) * xAxis;\n    vec3 y = sin(theta) * yAxis;\n    vec3 horizontal = normalize(x + y);\n    vec3 z = cosPhi * zAxis;\n    vec3 p = horizontal * sin(phi) + z;\n    \n    return normalize(p);\n}\n\n// Cosine distribution picking by iq\nvec3 hemiSpherePointCos(vec3 normal)\n{\n    float u = frand();\n    float v = frand();\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    ivec2 q = ivec2(fragCoord);\n    srand(hash(1117));\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(0.0, 0.0, 4.0), vec3(0.0, 3.0, 3.0), 0.5*sin(iTime*0.2)+0.5);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color = vec3(0.0);\n    \n    // intersect\n    float t = intersect(sphere1, ray);\n    if(t > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        for(float i=0.0; i<5000.0; i++)\n        {\n            vec3 p = sphere1.position + hemiSpherePoint(vec3(0.0, 1.0, 0.0));\n            \n            float tt = 0.5*sin(iTime)+0.5;\n            vec3 color1 = vec3(1.0,0.0,0.0) * step(length(point-p), 0.007) * step(0.0, point.y);\n            vec3 color2 = vec3(0.006,0.0,0.0) * step(length(point-p), 0.2) * step(0.0, point.y);\n            color += mix(color1, color2 , tt);\n        }\n    }\n    \n    t = intersect(sphere2, ray);\n    if(t > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        for(float i=0.0; i<5000.0; i++)\n        {\n            vec3 p = sphere2.position + hemiSpherePointCos(vec3(0.0, 1.0, 0.0));\n            float tt = 0.5*sin(iTime)+0.5;\n            vec3 color1 = vec3(0.0,1.0,0.0) * step(length(point-p), 0.007) * step(0.0, point.y);\n            vec3 color2 = vec3(0.0,0.006,0.0) * step(length(point-p), 0.2) * step(0.0, point.y);\n            color += mix(color1, color2 , tt);\n        }\n    }\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[354, 354, 375, 375, 387], [388, 388, 407, 407, 462], [463, 463, 482, 482, 514], [515, 621, 640, 640, 695], [900, 900, 941, 941, 1328], [1330, 1330, 1392, 1392, 1701], [1703, 1722, 1757, 1757, 2209], [2211, 2248, 2286, 2286, 2464], [2467, 2467, 2525, 2525, 3977]], "test": "untested"}
{"id": "3lcBDl", "name": "Truchetted Menger", "author": "dr2", "description": "Mengerized Truchet structure (mouseable)", "tags": ["fractal", "menger", "truchet"], "likes": 20, "viewed": 375, "published": 3, "date": "1613644058", "time_retrieved": "2024-07-30T19:37:20.126885", "image_code": "// \"Truchetted Menger\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\n\nvec3 ltDir;\nvec2 gId, cMid;\nfloat tCur, dstFar, hgSize, cDir;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n// Blended from \"Menger Helix\" and \"Truchet Passages\"\n\nfloat MengDf (vec3 p)\n{\n  vec3 b;\n  float sclFac, r, r0, a, s;\n  const float nIt = 3.;\n  sclFac = 2.4;\n  r0 = 0.6 * 18. / pi;\n  p /= (0.5 / r0);\n  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.;\n  p.x = mod (18. * a + 1., 2.) - 1.;\n  p.z = r - r0;\n  s = 1.;\n  for (float n = 0.; n < nIt; n ++) {\n    p = abs (p);\n    p.xy = (p.x > p.y) ? p.xy : p.yx;\n    p.xz = (p.x > p.z) ? p.xz : p.zx;\n    p.yz = (p.y > p.z) ? p.yz : p.zy;\n    p = sclFac * p - b;\n    p.z += b.z * step (p.z + 0.5 * b.z, 0.);\n    s *= sclFac;\n  }\n  return (0.5 / r0) * PrRoundBoxDf (p, vec3 (1.) - 0.1, 0.1) / s;\n}\n\nfloat ObjDf (vec3 p)\n{\n  p.xz -= cMid;\n  p /= hgSize;\n  p.xz = Rot2D (p.xz, cDir * pi / 6.);\n  p.xz = Rot2D (p.xz, 2. * pi * floor (3. * atan (p.z, - p.x) / (2. * pi) + 0.5) / 3.);\n  p.x += 1.;\n  p.xz = Rot2D (p.xz, mod (0.2 * cDir * tCur + pi / 3., 2. * pi / 3.) - pi / 3.);\n  return MengDf (p);\n}\n\nvoid SetTrConf ()\n{\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 ) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 2. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.25, 0.5, 1.), vec3 (0., 0.3, 0.4), 0.5 * (1. - rd.y)) *\n     (0.65 + 0.35 * rd.y) * (1. + 0.2 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  col = BgCol (rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    col = mix (col, vec3 (0.3, 0.9, 0.5) * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)),\n       exp (min (0., 1. - 8. * dstObj / dstFar)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrkPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3/2., -0.5), vec2 (sqrt3/2., 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3/2., 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3/2., 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r * hgSize;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, p1, p2, vd;\n  float el, az, zmFac, asp, sr, vel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize = 2.;\n  vel = 0.1;\n  p1 = TrkPath (vel * tCur + 0.3);\n  p2 = TrkPath (vel * tCur - 0.3);\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2;\n  ro.y = 4.;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 4.;\n  dstFar = 40.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBDl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[626, 626, 649, 649, 1281], [1283, 1283, 1305, 1305, 1581], [1583, 1583, 1602, 1602, 1684], [1686, 1686, 1719, 1719, 2961], [2963, 2963, 2984, 2984, 3239], [3241, 3241, 3278, 3278, 3687], [3689, 3689, 3711, 3711, 4110], [4112, 4112, 4147, 4147, 4521], [4523, 4523, 4547, 4547, 4936], [4938, 4938, 4994, 4994, 6250], [6252, 6252, 6298, 6298, 6345], [6347, 6347, 6371, 6371, 6601], [6603, 6603, 6627, 6627, 6687], [6689, 6689, 6711, 6711, 6749], [6751, 6751, 6796, 6796, 6899], [6901, 6901, 6946, 6946, 6984], [6986, 6986, 7022, 7022, 7228], [7230, 7230, 7260, 7260, 7373], [7407, 7407, 7431, 7431, 7491]], "test": "untested"}
{"id": "3ttfDf", "name": "Variable Fractal Tiles 2", "author": "public_int_i", "description": "Each tile has a different fractal pattern", "tags": ["fractal", "2", "tiles", "variable"], "likes": 12, "viewed": 355, "published": 3, "date": "1613604087", "time_retrieved": "2024-07-30T19:37:20.963647", "image_code": "/*Ethan Alexander Shulman 2021 - https://xaloez.com/\nLicense: CC0, public domain*/\n\n#define PI 3.141592653589793\n\n//Modified FNV-1A hash https://www.shadertoy.com/view/WtdfRX\nuvec4 hash(uvec4 seed) {\n    uvec4 h = (0x6A7F8FAAu^seed)*0x01000193u;\n    h = ((h.wxyz>>3u)^h^seed.yzwx)*0x01000193u;\n    h = ((h.zwxy>>8u)^h^seed.wxyz)*0x01000193u;\n    return h^(h>>11u);\n}\n#define I2F (1./float(0xFFFFFFFFu))\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec3 triwave(vec3 x) {\n    return vec3(1)-abs(fract(x)-.5)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = ((fragCoord)*2.-iResolution.xy)/iResolution.y*5.+5.+iTime;\n\n    //hash from local tile coordinate\n    vec4 h = vec4(hash(uvec4(floor(pos/10.),0,0)))*I2F;\n    pos = mod(pos,10.)-5.;\n    \n    //apply folds based off hash\n    for (int i = 0; i < 8; i++) {\n        float fi = h[i/2], rv = h[(i+1)%3];\n        if (i%2 == 0) fi = fract(fi*2435.123)*10.;\n        else fi = floor(fi*10.);\n           \n        int id = int(fi)%3;\n        if (id == 0) {//mirror rotate fold\n            pos = (abs(pos)-.5)*r2(rv*PI*2.);\n        } else if (id == 1) {//plane fold\n            rv *= PI*2.;\n            vec2 pnorm = vec2(sin(rv),cos(rv));\n            pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n        } else {//polar fold\n            float sz = PI/floor(1.+rv*7.),\n                ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n            pos = vec2(sin(ang),cos(ang))*length(pos);\n        }\n        //apply box fold\n        float ext = h[i%3];\n        pos = abs(pos);\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n    \n    //distance hue coloring\n    h = fract(h*1e4/PI);\n    float dst = length(pos);\n    fragColor.xyz = clamp(abs(mod((dst+h.x)*(5.+h.y*60.)+vec3(0,4,2),6.)-3.)-1.,0.,1.)*\n                    (.5+.5*cos((dst+h.z)*(5.+h.w*120.)));\n    fragColor. w = 1.;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfDf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[114, 175, 199, 199, 366], [404, 404, 422, 422, 479], [481, 481, 503, 503, 545], [547, 547, 604, 604, 1872]], "test": "untested"}
{"id": "3ltfWf", "name": "bokeh expe 02", "author": "YitingLiu", "description": "experimenting with bokeh and struct ", "tags": ["bokeh", "lights", "drive", "street", "artofcode"], "likes": 1, "viewed": 308, "published": 3, "date": "1613601099", "time_retrieved": "2024-07-30T19:37:22.124545", "image_code": "#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n    vec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c+uv.x*r+uv.y *u;\n    a.d=normalize(i-a.o);\n    \n    return a;\n}\n\nvec3 ClosetPoint(ray r, vec3 p){\n    return r.o+max(0.,dot(p-r.o,r.d))*r.d;\n\n}\n\nfloat DistRay(ray r, vec3 p){\n    return length(p-ClosetPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    size*=length(p);\n    float d = DistRay(r,p);\n    float c = S(size, size*(1.-blur),d);\n    c*=mix(.6,1.,S(size*.8,size,d));\n    return c;\n\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x);\n\n    float s = 1./10.;\n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    vec3 p = vec3(2.,2.,100.-ti*100.);\n    m+= Bokeh(r,p,.1,.1)*ti*ti*ti*ti;\n    }\n    return  vec3(1.,.7,.3)*m;\n\n}\n\nfloat N(float t){\n    return fract(sin(t*3456.)*6578.);\n}\nvec3 Headlights(ray r, float t){\n    t*=.2;\n   \n   float w1 = .25;// distance between headlight \n   float w2 = w1*1.2;\n\n    float s = 1./30.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// randomize the headlight using noise \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti;\n        \n        float focus = S(.8,1.,ti);\n        float size = mix(.05,.03,focus);        \n   \n        m+= Bokeh(r,vec3(-1.-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(-1.-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(-1.+\n        w2,.15,z),size,.1)*fade;\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(-1.-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(-1.+\n        w2,-.15,z),size*3.,1.)*fade;\n        \n        m+=ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(.9,.9,1.)*m;//blue and green \n\n}\n\nvec3 Taillights(ray r, float t){\n\n    t *=.25;\n   \n    float w1 = .25;// distance between headlight \n    float w2 = w1*1.2;\n\n    float s = 1./15.;// divider is the number of cars \n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n        \n        float n = N(i);// 0 1 randomize the headlight using noise \n        \n        if(n>.1) continue;// jump back to for loop while not executing below \n        \n        // n = 0 0.5 \n        float lane = step(.5,n);// 0 1 \n        \n        float ti = fract(t+i);\n        float z = 100.-ti*100.;\n        float fade =ti*ti*ti*ti*ti;\n        \n        float focus = S(.9,1.,ti);\n        float size = mix(.05,.03,focus);\n        \n        float laneShift = S(.99,.96,ti);\n        float x = 1.5 -lane*laneShift;\n        \n        float blink = step(0.,sin(t*10000.))*7.*lane*step(.96,ti);\n   \n        m+= Bokeh(r,vec3(x-w1,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w1,.15,z),size,.1)*fade;\n        \n        m+= Bokeh(r,vec3(x-w2,.15,z),size,.1)*fade;\n        m+= Bokeh(r,vec3(x+\n        w2,.15,z),size,.1)*fade*(1.+blink);\n        \n        \n        float ref = 0.; //reflection \n        ref+= Bokeh(r,vec3(x-w2,-.15,z),size*3.,1.)*fade;\n        ref+= Bokeh(r,vec3(x+\n        w2,-.15,z),size*3.,1.)*fade*(1.+blink*.1);\n        \n        m += ref*focus;//only show reflection when in focus \n    }\n    \n    return vec3(1.,.1,.03)*m;//red\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 camPos = vec3(.5,.2,0.);\n    vec3 lookat = vec3(.5,.2,1.);\n    \n    ray r = GetRay(uv,camPos,lookat,2.);\n   \n    float t = iTime*.5+m.x;  \n\n    vec3 col = Streetlights(r,t);\n    col += Headlights(r,t);\n    col += Taillights(r,t);\n\n\n\nfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 130, 130, 368], [370, 370, 402, 402, 448], [450, 450, 479, 479, 520], [522, 522, 574, 574, 718], [720, 720, 754, 754, 1047], [1049, 1049, 1066, 1066, 1106], [1107, 1107, 1139, 1139, 2247], [2249, 2249, 2281, 2281, 3642], [3643, 3643, 3699, 3749, 4157]], "test": "untested"}
{"id": "3ldBWX", "name": "State Managing Utilities", "author": "oneshade", "description": "Lots of magic with macros to try abstracting state managing (storing and updating variables across frames).", "tags": ["state", "buffer", "utilities", "variables"], "likes": 8, "viewed": 149, "published": 3, "date": "1613589953", "time_retrieved": "2024-07-30T19:37:23.174736", "image_code": "/*\nUp arrow key: move forward\nDown arrow key: move backward\nRight arrow key: turn right\nLeft arrow key: turn left\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float su = 2.0 / iResolution.y; // Smoothing unit (2 pixels)\n    vec3 color = vec3(0.0);\n\n    // Player state\n    vec2 pos = Load(Ch0, 0, 0).xy;\n    vec2 dir = Load(Ch0, 1, 0).xy;\n\n    // Draw map\n    float m = map(barrelDistort(uv, vec2(1.0)) + pos);\n    vec3 waterColor = vec3(0.0, 0.0, 1.0 - m);\n    vec3 landColor = mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), m * m);\n    color += mix(waterColor, landColor, smoothstep(0.5 - su, 0.5 + su, m));\n\n    // Draw player\n    DrawSDF(sdBox(axisAlign(uv, dir), vec2(0.03, 0.05)), vec3(1.0, 0.0, 0.0));\n\n    color *= vignette(uv, 2.0);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// State managing utilities\n// Shortened channel names\n#define Ch0 iChannel0\n#define Ch1 iChannel1\n#define Ch2 iChannel2\n#define Ch3 iChannel3\n\n// Arrow key codes (key codes are ASCII I think)\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n// Store/load block at position (i, j)\n#define Store(i, j) if (addr == ivec2(i, j))\n#define Load(buf, i, j) texelFetch(buf, ivec2(i, j), 0)\n\n// Check for keypress (buf is the channel to read from)\n#define Keypress(buf, key) if (bool(texelFetch(buf, ivec2(key, 0), 0).x))\n\n// Core state managing utilities\n#define Main void mainImage(out vec4 fragColor, in vec2 fragCoord)\n\n#define InitStates if (iFrame == 0)\n#define UpdateStates if (iFrame > 0)\n\n// Call this at the very beginning of your state manager\n#define ClearBlock() block = vec4(0.0, 0.0, 0.0, 0.0)\n\n// Current block and block address\n#define block fragColor\n#define addr ivec2(fragCoord)\n\n// Misc. utilities (specific to this demo but you can use them if you want to)\n#define DrawSDF(sdf, col) color = mix(color, col, smoothstep(su, 0.0, sdf))\n\n// http://marcodiiga.github.io/radial-lens-undistortion-filtering\nvec2 barrelDistort(in vec2 p, in vec2 alpha) {\n    return p / (1.0 - alpha * dot(p, p));\n}\n\nfloat vignette(in vec2 p, in float v) {\n    return 1.0 - pow(length(p), v);\n}\n\nmat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return p * mat2(up.y, -up.x, up);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Smooth noise\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = Hash21(cell);\n    float br = Hash21(cell + vec2(1.0, 0.0));\n    float tl = Hash21(cell + vec2(0.0, 1.0));\n    float tr = Hash21(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\n// Fractal noise\nfloat fnoise(in vec2 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat map(in vec2 p) {\n    return fnoise(p, 3.0, 5.0);\n}", "buffer_a_code": "/*\nState manager skeleton:\nMain {\n    ClearBlock();\n    InitStates {\n        // Initialize states\n    }\n\n    UpdateStates {\n        // Update states\n    }\n}\n*/\n\nMain {\n    ClearBlock();\n    InitStates {\n        Store(0, 0) block.xy = vec2(0.0, 0.2); // Player position is stored at (0, 0)\n        Store(1, 0) block.xy = vec2(0.0, 1.0); // Player direction is stored at (1, 0)\n    }\n\n    UpdateStates {\n        Store(0, 0) {\n            vec2 pos = Load(Ch0, 0, 0).xy;\n            vec2 dir = Load(Ch0, 1, 0).xy;\n\n            // Move player on keypress\n            vec2 newPos = pos;\n            Keypress(Ch1,   KEY_UP) newPos += dir * 0.01;\n            Keypress(Ch1, KEY_DOWN) newPos -= dir * 0.01;\n\n            // Only change position if not colliding\n            block.xy = pos;\n            if (map(newPos) > 0.5) block.xy = newPos;\n        }\n\n        Store(1, 0) {\n            vec2 dir = Load(Ch0, 1, 0).xy;\n\n            // Rotate the player direction on keypress\n            Keypress(Ch1, KEY_RIGHT) dir *= Rotate( 0.025);\n            Keypress(Ch1,  KEY_LEFT) dir *= Rotate(-0.025);\n\n            block.xy = dir;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 173, 173, 861]], "test": "untested"}
{"id": "WltBDj", "name": "Fractal Cube Snowflake", "author": "Shane", "description": "Using a basic hexagon fractal structure to stack 2D isometric cubes in a way that resembles a geometric snowflake.", "tags": ["2d", "fractal", "cube", "isometric", "polar", "sierpinski", "snowflake"], "likes": 47, "viewed": 1021, "published": 3, "date": "1613573700", "time_retrieved": "2024-07-30T19:37:24.105248", "image_code": "/*\n\n    Fractal Cube Snowflake\n    ----------------------  \n    \n    Using a basic hexagon fractal structure to stack 2D isometric cubes in \n    a way that resembles a geometric snowflake. It's not the most exciting\n    example, that's for sure, but I thought the fractal geometry crowd might\n    appreciate it. The structure isn't common, but I've seen it around. This \n    particular one is loosely based on one of Robert Fathauer's renderings.\n    \n    \n    The idea behind polygon fractals is pretty simple: Render a polygon,\n    subdivide space into polar cells and render more objects in each of\n    those cells, subdivide the resultant cells and render more objects around \n    the newly rendered objects... Continue ad infinitum, as they say.\n    \n    \n    \n    Other 2D polygon-based fractal examples:\n    \n    \n    // Very watchable, and with virtually no code. \n    Pen Patterns - Kali\n    https://www.shadertoy.com/view/tsdfWf\n    \n    // A very cool hexagon fractal pattern -- Also based on\n    // one of Robert Fathauer's renderings.\n    Linked Rings Fractal Tiling - Fizzer\n    https://www.shadertoy.com/view/3l3fRn\n    \n    // Here's an easier version to understand.\n    Sierpinski Fractal Cubes - Shane\n    https://www.shadertoy.com/view/tldfzX\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 1.;\n    \n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv*gSc;\n    \n    \n    // Subtle animation, to break up the monotony.\n    //\n    // Three part rotation. Kekwizard's ida. :)\n    float t = mod(iTime/4., 3.);\n    float a = (t>2.)? 2. : (t>1.)? 1. : 0.; \n    a += smoothstep(.1, .3, t - a);\n    p *= rot2(-a*6.2831/3.);\n    // Perturbing the screen coordinates slightly.\n    t = mod(iTime, 6.2831);\n    p += sin(p*4. + t - cos(p.yx*8. + t))*.003;\n    \n    \n    \n    // Set the background to something neutral.\n    vec3 col = vec3(.2);//vec3(.53, .5, .47);\n    \n    // Initial box scale. \n    float sc = .215;\n    \n    // Edge width. \n    const float ew = .0015;\n    \n    float totD3 = 1e5;\n    \n    int sI = 0, sIOld = 0;\n    \n    // Render the fractal levels.\n    for(int i = 0; i<5; i++){\n    \n        bool render = false;\n        // Render all six surrounding cubes on the first level.\n        if(i<2) render = true;\n        else {\n            // Render three surrounding cubes in the following\n            // posistions. Otherwise break.\n            if((sI - sIOld + 5)%6 < 3) render = true;\n            else break;\n        }\n    \n    \n        // Obtain the individual cube face quad distances. Three are\n        // visible to the viewer.\n        vec3 d3 = cubeQuads(p, sc*2.);\n    \n        // Amalgamating all three quads to form a cube. Used for shadows and lines.\n        float cube = min(min(d3.x, d3.y), d3.z);\n        \n        \n        \n        // Faux shadowy ambient occlusion.\n        float sh = cube;\n        if((sI%2)==0) sh = max(sh, -(totD3 - sf*12.*iResolution.y/450.));\n        if(render) col = mix(col, vec3(0), (1. - smoothstep(0., sf*12.*iResolution.y/450., sh))*.25);\n        \n        \n        // Iterate through the cube faces for this level.\n        for(int j = 0; j<3; j++){\n        \n            // Render every second cube behind the cube from the previous level.\n            if((sI%2)==0) d3[j] = max(d3[j], -totD3);\n            \n            // Face ID... A mixture of common sense and trial and error, as always. :D\n            int fid = (i - j + 4)%3; \n            \n            // Normal based shade.\n            float sh = .5 + float(2 - fid)/4.; \n            \n            // Color -- based on the face ID.\n            //vec3 fCol = .55 + .45*cos(6.2831*float(fid)/12. + vec3(0, 1, 2));\n            // Color based on face shade.\n            vec3 fCol = vec3(sh);\n            // Coloring alternate layers.\n            //if((i%2)==0) fCol *= vec3(1, .08, .16);\n            //vec3 fCol = .54 + .46*cos(6.2831*float(sh*sh)/2.25 + vec3(0, 1, 2));\n        \n            // Render the quad.\n            if(render) col = mix(col, fCol, (1. - smoothstep(0., sf, d3[j])));\n        \n        }\n        \n        // Current cube, or occluded cube, which is why the update is necessary.\n        cube = min(min(d3.x, d3.y), d3.z);\n        // Add it to the current structure, which we need for occlude cubes in\n        // the next pass.\n        totD3 = min(totD3, cube);\n        \n        // Apply edges over the top. For those not familiar, \"abs(dist) - edgeWidth/2.\"\n        // will give you the edge outlines.\n        if(render) col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cube) - ew/2.))*.8);\n        \n        \n        // Split space into three polar angles -- Pretty standard stuff.\n        float rN = 6.;\n        p = rot2(6.2831/12.)*p; // Rotate to the desired postion.\n        float ia = floor(fract(atan(p.x, p.y)/6.2831)*rN); // Cell number.\n        ia = (ia + .5)*6.2831/rN; // Cell's central postion.\n        \n        p = rot2(ia)*p; // Rotate each cell center.\n        p.y -= sc/.8660254; // Move out along the radial line.\n        p = rot2(-ia + 7.*6.2831/12.)*p; // Rotate in situ to get the correct face.\n\n        \n        sIOld = sI; // Cell number from the previous level.\n        sI = (int(ia))%6; // Cell number for the current level.\n        \n        // Reduce scale for the next iteration. 50% works nicely, but \n        // values like 35% will work also.\n        sc *= .5; \n        \n    \n    }\n\n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "// UTILITY FUNCTIONS -- These are just worker functions. All the logic is contained\n// within the \"Image\" tab.\n\n// Hexagon cell scale.\n#define HSCALE vec2(.5, .8660254)\n\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-1, -1./3.), vec2(-1, 1./3.), vec2(0, 2./3.), \n                      vec2(1, 1./3.), vec2(1, -1./3.), vec2(0, -2./3.));\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// IQ's vec2 to float hash.\n//float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Entirely based on IQ's signed distance to a 2D triangle. I've expanded it \n// to work with convex quads and generalized it a bit, but I doubt it would \n// translate to speed. It would be easy to generalize to convex polyons though.\nfloat quad(in vec2 p, in vec2[4] v){\n\n    // Lines between successive vertex points.\n    vec2[4] e = vec2[4](v[1] - v[0], v[2] - v[1], v[3] - v[2], v[0] - v[3]);\n    \n    // Winding related sign.\n    float s = sign(e[0].x*e[3].y - e[0].y*e[3].x);\n    \n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<4; i++){\n        \n        // Minimum point to line calculations.\n        vec2 vi = p - v[i];\n        vec2 qi = vi - e[i]*clamp(dot(vi, e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(qi, qi), s*(vi.x*e[i].y - vi.y*e[i].x)));\n    }\n\n    // Quad distance.\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n// Returns the 3 viewable cube face distances.\nvec3 cubeQuads(vec2 p, float sc){\n\n\n    vec2 hSc = HSCALE*sc;\n    vec3 d;\n    \n    // Iterate through the three cube faces.\n    for(int j = 0; j<3; j++){\n        \n        // Using the hexagon vertices to constructing the 3 viewable cube quad faces.\n        vec2[4] v = vec2[4](vID[(j*2 + 5)%6]*hSc, vID[(j*2)%6]*hSc, vID[(j*2 + 1)%6]*hSc, vec2(0));\n\n        // Face quad.\n        d[j] = quad(p, v);\n            \n    }\n    \n    return d;\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtdBWj", "name": "A Plethora of Pentagons", "author": "mla", "description": "Tilings by irregular pentagons. Best viewed full screen.\n\ncf. Craig S. Kaplan: [url]https://twitter.com/cs_kaplan/status/1361089568229974017[/url]", "tags": ["deformation", "pentagons", "parquet"], "likes": 34, "viewed": 517, "published": 3, "date": "1613569024", "time_retrieved": "2024-07-30T19:37:25.192341", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Dual snub hexagonal tiling (so the tiles are generally pentagons).\n// Matthew Arcus, mla, 2021\n//\n// Wythoff construction, with the Wythoff point varying across the plane.\n// Inspired by Craig S. Kaplan: https://twitter.com/cs_kaplan/status/1361089568229974017\n// \n// <mouse>: Uniform tiling across plane\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float X = sqrt(3.0);\n\nfloat drawone(vec2 z, vec2 t0, float d) {\n  d = min(d,segment(z,t0,vec2(0)));\n  d = min(d,segment(z,t0,vec2(X,0)));\n  d = min(d,segment(z,t0,vec2(0,1)));\n\n  d = min(d,segment(-z,t0,vec2(0)));\n  d = min(d,segment(-z,t0,vec2(X,0)));\n  d = min(d,segment(-z,t0,vec2(0,1)));\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z = rotate(z,0.05*iTime);\n  z *= 16.0;\n  vec2 z0 = z;\n\n  const mat2 M = mat2(X,-3,X,3);\n  z.x += X;\n  z = inverse(M)*z; // Convert to square grid\n  z -= floor(z);\n  z = M*z; // Back to triangles\n  z.x -= X;\n\n  if (z.y < 0.0) z = -z; // Rotate lower triangle to upper.\n\n  // Rotational symmetry about triangle centre, so map centre of triangle to origin...\n  z.y -= 1.0;\n\n  // ...and reflect in planes of symmetry of triangle\n  const vec2 A = normalize(vec2(1,X));\n  const vec2 B = normalize(vec2(-1,X));\n  int parity = 0;\n  float ta = dot(z,A);\n  if (ta < 0.0) z -= 2.0*ta*A;\n  float tb = dot(z,B);\n  if (tb < 0.0) z -= 2.0*tb*B;\n  if (int(ta>0.0) + int(tb>0.0) == 1) z.x = -z.x; // Want even number of reflections\n  z.y += 1.0;        // Shift origin back to region centre,\n\n  float pwidth = fwidth(z0.x);\n  \n  vec3 col0 = vec3(0);\n  vec3 col1 = vec3(0.9);//vec3(1,0,0);\n  vec3 col2 = vec3(0.95);//vec3(1,1,0);\n\n  float d = min(abs(z.x),z.y);\n  d = min(d,line(abs(z),vec2(0,1),vec2(X,0)));\n  float mfact = smoothstep(-pwidth,pwidth,d);\n  vec3 col = mix(col1,col2,(z.x < 0.0 ? mfact : mfact-1.0));\n  \n  vec2 z1 = vec2(-1,1)*reflection(z,vec2(X,0),vec2(0,1));\n  vec2 z2 = reflection(vec2(-1,1)*z,vec2(X,0),vec2(0,1));\n  vec2 t0 = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n  if (iMouse.z > 0.0) t0 = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n  t0 = 1.2*rotate(t0,-0.2*iTime);\n  \n  d = 1e8;\n  d = drawone(z,t0,d);\n  d = drawone(z1,t0,d);\n  d = drawone(z2,t0,d);\n\n  col = mix(col0,col,smoothstep(0.015,0.015+1.25*pwidth,d));\n\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec2 reflection(vec2 p, vec2 q, vec2 r) {\n  // reflect p in the line through q and r\n  p -= q;\n  vec2 n = (r-q).yx * vec2(1,-1);\n  p -= 2.0*dot(p,n)*n/dot(n,n);\n  p += q;\n  return p;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  vec2 ba = b-a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length(pa - ba * h);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[505, 505, 546, 546, 788], [790, 790, 843, 843, 2466]], "test": "untested"}
{"id": "tlcfWX", "name": "AO (Ambient Occlusion)", "author": "moranzcw", "description": "A brute force AO.", "tags": ["raytracing", "raycast", "ao"], "likes": 12, "viewed": 1479, "published": 3, "date": "1613566769", "time_retrieved": "2024-07-30T19:37:26.272453", "image_code": "// AO (Ambient Occlusion) - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Epsilon 1e-2\n#define PI 3.14159265359\n#define Samples 48.0\n#define AOradius 2.5\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\nstruct Ray \n{ \n    vec3 origin, direction;\n};\n\nstruct Sphere \n{\n\tfloat radius;\n\tvec3 position;\n};\n\nSphere spheres[4];\n\nvoid initSpheres()\n{\n    spheres[0] = Sphere(0.5, vec3(-1.7, 0.5, -1.6));\n    spheres[1] = Sphere(1.0, vec3(1.8, 1.0, -0.5));\n    spheres[2] = Sphere(2.0, vec3(0.0, 2.0, -2.8));\n    spheres[3] = Sphere(1000.0, vec3(0.0, -1000.0, 0.0));\n}\n\nfloat intersect(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.position - ray.origin;\n\tfloat t1, t2 = Epsilon;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    \n\tif (det < 0.0)\n        return 0.0;\n    else\n        det = sqrt(det);\n    \n    t1 = b - det;\n    t2 = b + det;\n    if(t1 > Epsilon)\n        return t1;\n    if(t2 > Epsilon)\n        return t2;\n    return 0.0;\n}\n\nRay cameraRay(vec3 camPosition, vec3 lookAt, vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    vec3 cz = normalize(lookAt - camPosition);\n\tvec3 cx = normalize(cross(cz, vec3(0.0, 1.0, 0.0)));\n\tvec3 cy = normalize(cross(cx, cz));\n    \n    return Ray(camPosition, normalize(0.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n}\n\nvec3 hemiSpherePoint(vec3 normal)\n{\n    float theta = 2.0 * PI * frand();\n    float cosPhi = frand();\n    float sinPhi = sqrt(1.0-cosPhi*cosPhi);\n    \n    vec3 zAxis = normal;\n    vec3 xAxis = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));\n    vec3 yAxis = normalize(cross(normal, xAxis));\n    \n    vec3 x = cos(theta) * xAxis;\n    vec3 y = sin(theta) * yAxis;\n    vec3 horizontal = normalize(x + y) * sinPhi;\n    vec3 z = cosPhi * zAxis;\n    vec3 p = horizontal + z;\n    \n    return p;\n}\n\nfloat AO(vec3 point, vec3 normal)\n{\n    float li = 0.0;\n    float count = 0.0;\n    for(float i=0.0; i<Samples; i++)\n    {\n        Ray ray = Ray(point, hemiSpherePoint(normal));\n        \n        float t = 1e10;\n        for(int i=0; i<4; i++)\n        {\n            float temp = intersect(spheres[i], ray);\n            t = step(Epsilon, temp) * min(temp, t) + step(temp, Epsilon) * t;\n        }\n        li += dot(ray.direction, normal) * smoothstep(0.0, AOradius, t);\n        count += dot(ray.direction, normal);\n    }\n    return sqrt(li / count);\n}\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // init spheres\n    initSpheres();\n    \n    // camera ray\n    vec3 camPosition = mix(vec3(-2.0, 3.0, 6.0), vec3(2.0, 3.0, 6.0), sin(iTime*0.3));\n    vec3 lookAt = vec3(0.0, 2.0, 0.0);\n    Ray ray = cameraRay(camPosition, lookAt, fragCoord);\n    \n\tvec3 color=vec3(0.0);\n    \n    // intersect\n    float t = 1e10;\n    int id;\n    float hitAnything = 0.0;\n    for(int i=0; i<4; i++)\n    {\n        float temp = intersect(spheres[i], ray);\n        if(temp > Epsilon && temp < t)\n        {\n            t = temp;\n            id = i;\n            hitAnything = 1.0;\n        }\n    }\n    \n    // AO\n    float ao = 0.0;\n    if(hitAnything > 0.0)\n    {\n        vec3 point = ray.origin + t * ray.direction;\n        vec3 normal = normalize(point - spheres[id].position);\n        ao = AO(point, normal);\n    }\n    \n    color = mix(background(fragCoord.y/iResolution.y), vec3(.9)*ao, 1. - smoothstep(0., .99, t*t/1e3));;\n    \n    color = pow(color,vec3(1.0/2.2)); // gamma\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfWX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[392, 392, 413, 413, 425], [426, 426, 445, 445, 500], [501, 501, 520, 520, 552], [553, 659, 678, 678, 733], [854, 854, 874, 874, 1091], [1093, 1093, 1134, 1134, 1521], [1523, 1523, 1585, 1585, 1894], [1896, 1896, 1931, 1931, 2384], [2386, 2386, 2421, 2421, 2932], [2934, 2934, 2966, 2966, 3057], [3059, 3059, 3117, 3141, 4221]], "test": "untested"}
{"id": "wtcfWX", "name": "Readable rule 30", "author": "illus0r", "description": "Crystall CA → readable rules", "tags": ["color", "cellular", "buildings"], "likes": 2, "viewed": 363, "published": 3, "date": "1613565505", "time_retrieved": "2024-07-30T19:37:27.340598", "image_code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    fragColor = texelFetch(iChannel0, ivec2(FC)/10,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n#define ROOF_START .002\n#define ROOF_LEFT_STOP .0002\n#define ROOF_RIGHT_STOP ROOF_LEFT_STOP\n#define ROOF_WALL_START -.00001 + .00002*uv.x\n#define COL transpose(mat3(uv.x*10.,0,1,   .4,.92,.0,   0,.7,1))\n//#define COL mat3(1,0,0,   0,1,0,   0,0,1)\n\n#define rnd(d) fract(sin(length(FC.xy+d)*999.))\n#define T(dx,dy) (texelFetch(iChannel0,ivec2(FC.xy+vec2(dx,dy))%int(iResolution.xy),0).rgb*inverse(COL))\n#define RULE(v,c) else if(T(-1,-1)[v[0]]>.5 && T(0,-1)[v[1]]>.5 && T(1,-1)[v[2]]>.5 && c)o[v[3]]=1.;\n\nconst ivec3 v = ivec3(0,1,2);\nvec2 uv = FC.xy/iResolution.xy;\n\nif(iFrame==0) o=vec4(0);\nelse if(iTime<.1||FC.y==.5)if(rnd(100.)<.5)o.r+=1.;else o.b+=1.;\n\nRULE(v.rrrr,true)\nRULE(v.rrbb,true)\nRULE(v.rbrb,true)\nRULE(v.rbbr,true)\nRULE(v.brrb,true)\nRULE(v.brbr,true)\nRULE(v.bbrr,true)\nRULE(v.bbbr,true)\n\no.rgb*=COL;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 107]], "test": "untested"}
{"id": "3t3fDf", "name": "Crystall CA → readable rules", "author": "illus0r", "description": "Crystall CA → readable rules", "tags": ["color", "cellular", "buildings"], "likes": 7, "viewed": 371, "published": 3, "date": "1613559574", "time_retrieved": "2024-07-30T19:37:28.310005", "image_code": "void mainImage( out vec4 fragColor, in vec2 FC )\n{\n    fragColor = texelFetch(iChannel0, ivec2(FC)/1,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n#define ROOF_START .002\n#define ROOF_LEFT_STOP .0002\n#define ROOF_RIGHT_STOP ROOF_LEFT_STOP\n#define ROOF_WALL_START -.00001 + .00002*uv.x\n#define COL transpose(mat3(uv.x,0,1,   .4,.92,.0,   0,.7,1))\n// #define COL mat3(1,0,0,   0,1,0,   0,0,1)\n\n#define rnd(d) fract(sin(length(FC.xy+d)*99.))\n#define T(dx,dy) (texelFetch(iChannel0,ivec2(FC.xy+vec2(dx,dy))%int(iResolution.xy),0).rgb*inverse(COL))\n#define RULE(v,c) else if(T(-2,-1)[v[0]]>.5 && T(0,-1)[v[1]]>.5 && T(2,-1)[v[2]]>.5 && c)o[v[3]]=1.;\n\nconst ivec3 v = ivec3(0,1,2);\nvec2 uv = FC.xy/iResolution.xy;\n\no=vec4(0);\nif(iTime<2.)if(int(FC.x+FC.y)%40<20)o.r+=1.;else o.b+=1.;\n//else if(int(FC.y-iTime*20.+100.)!=0){o.rgb=T(0,0)*COL;return;}\nelse if(int(FC.x)%2==0)o.rgb=T(-1,0);\n\nRULE(v.brrg,rnd(0.)<ROOF_START)\n\nRULE(v.ggrb,rnd(0.)<ROOF_RIGHT_STOP)\nRULE(v.grrb,rnd(vec2(-2,0))<ROOF_RIGHT_STOP)\n\nRULE(v.bggr,rnd(0.)<ROOF_LEFT_STOP)\nRULE(v.bbgr,rnd(vec2(2,0))<ROOF_LEFT_STOP)\n\nRULE(v.brrg,rnd(length(FC.xy))<ROOF_START)\n\nRULE(v.gggb,rnd(0.)<ROOF_WALL_START)\n\nRULE(v.bgrr,rnd(vec2(-2,-1))<ROOF_WALL_START)\nRULE(v.bggr,rnd(vec2(-2,-1))<ROOF_WALL_START)\nRULE(v.bgbr,rnd(vec2(-2,-1))<ROOF_WALL_START)\n\nRULE(v.bbbb,true)\nRULE(v.bbrb,true)\nRULE(v.rbbb,true)\nRULE(v.gbbb,true)\nRULE(v.gbrb,true)\nRULE(v.rbrb,true)\nRULE(v.gbgb,true)\nRULE(v.bbgg,true)\nRULE(v.rbgg,true)\nRULE(v.rrrr,true)\nRULE(v.rrgr,true)\nRULE(v.brrr,true)\nRULE(v.rrbr,true)\nRULE(v.brgr,true)\nRULE(v.brbr,true)\nRULE(v.grgr,true)\nRULE(v.grrg,true)\nRULE(v.grbg,true)\nRULE(v.rggr,true)\nRULE(v.rgbr,true)\nRULE(v.rgrr,true)\nRULE(v.ggbb,true)\nRULE(v.gggg,true)\nRULE(v.ggrg,true)\nRULE(v.bggg,true)\nRULE(v.bgrg,true)\nRULE(v.bgbg,true)\n\no.rgb*=COL;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 50, 50, 106]], "test": "untested"}
{"id": "WtcfDf", "name": "Day 426", "author": "jeyko", "description": "aaa", "tags": ["mdtmjvm"], "likes": 19, "viewed": 730, "published": 3, "date": "1613558316", "time_retrieved": "2024-07-30T19:37:29.577616", "image_code": "// Fork of \"day 425\" by jeyko. https://shadertoy.com/view/3ltBWj\n// 2021-02-17 09:03:04\n\n// Fork of \"Day 424\" by jeyko. https://shadertoy.com/view/wldfDB\n// 2021-02-16 09:06:35\n\n// dont fullscreen, bloom and some other things don't work well there.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz *= 1. - dot(uv,uv)*0.7;\n    fragColor.xyz = pow(max(fragColor.xyz,0.), vec3(1.15,1.3,1.15) + dot(uv,uv)*0.6);\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.15));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    \n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n       \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat envcnt = 0.;\n\nfloat getEnv(float t, float speed, float pa, float pb, float jumpAmt, bool cnt){\n    //return pow(sin((t - 0.5)*3.14),1.)*0.5 + 0.5;\n    t = clamp(t*speed,0.,1.);\n    \n    envcnt += float(t > 0.99 && cnt);\n    //t = smoothstep(0.,1.,t);\n    pa += 1.;\n    pb += 1.;\n    \n    float c = cos(t*3.14);\n    float a = 1.- ((pow(abs(c),pa)*sign(c))*0.5 + 0.5);\n    float b = 1.-((pow(abs(c),pb)*sign(c))*0.5 + 0.5);\n    \n    a = pow(sin(t*3.14/2.),pa);\n    b = 1.-pow(sin((-t + 1.)*3.14/2.),pb);\n    \n    b *= 1. + (\n            smoothstep(0.,1.,t) *smoothstep(0.99,0.7,t)*jumpAmt\n        );\n    return mix( a, b,t);\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    \n    float segmentMod =  + sin(floor(kSegment))*20.;\n    \n    float vn = valueNoise(iTime + uv.x*0.01 + segmentMod, 2.)*1.;\n    float t = iTime*1.3 - vn + 2. + segmentMod;\n        \n    float env = getEnv(t, 1., 2., 2., 1., false);\n    \n    vec2 offs = vec2(sin(t)*0.5,cos(t*0.6)*1.6) ;\n    \n    vec2 ouv = uv;\n    uv -= offs*0.2;\n    float nb = cyclicNoise(vec3(uv*15.5 + t*0. + offs*0.3,t*0.2), false, t*0.);\n    \n    float n = cyclicNoise(vec3(uv*((22.5 ) - dot(ouv,ouv)*4.4),t*1.5 - nb*1.) , true, t*1.);\n    n *= 1.;\n    \n    float r = .16 - n*2. + nb*5.;\n    int didx = 3;\n    vec2 dfn = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n\n    r = 15. - n*0. + nb*4.;\n    didx = 3;\n    \n    vec2 dfnb = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n    \n    \n    col = mix(col, vec3(0.1+ sin(length(dfn)*44. + iTime + n*3.)*0.5,0.4,0.5),0.4*smoothstep(-0.1 + n*0. + nb*0.0,0. + length(dfnb)*1.,length(dfn)));\n    \n    //col += 1.-abs(length(dfn.xyx))*4.;\n    \n    //col = mix(col,0.*vec3(0.,0.,0.1 + 0.2*sin(nb*10.)*0.2),smoothstep(-0.1,.1,-length(dfn)));\n    \n    vec3 c = vec3(0.4 + sin(length(dfn)*14. + iTime + n*13.)*0.4,0.3 + sin(length(dfn)*24. + iTime*5. +length(dfnb)*7.)*0.1,0.3);\n    col = mix(col,3.*c,smoothstep(0.12,.25,abs(abs(n - 0.5) - 0.2) + length(dfn)*0.7));\n    \n    \n    \n    //vec3 c = vec3(0.+ sin(length(dfnb)*5. + iTime+ n*10.)*0.4+ sin(dfn.x*10.)*0.3 ,0.1 + n*0.05 + sin(nb*20. + t)*0.05 ,0.1  );\n    //c *= 1.9;\n    \n    \n    \n    \n    \n    C = vec4(col,n);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 fr = texture(iChannel0,(U)/iResolution.xy);\n   \n    float r = 0.2 \n        + sin(fr.w*5.)*.4\n        + sin(fr.x*1.)*.71;\n    int didx = 1;\n    \n    vec2 dfn = vec2(T0(U + vec2(1.,0)*r)[didx] - T0(U - vec2(1.,0)*r)[didx],T0(U + vec2(0.,1)*r)[didx] - T0(U - vec2(0.,1)*r)[didx]);\n    \n    vec2 sc = vec2(0)\n        + pow(smoothstep(0.,1.,length(dfn.x)*9.),0.6)*.6;\n    \n    sc *= dfn*0.5;\n    \n    \n    C.x =texture(iChannel0,(U + sc*vec2(0,9))/iResolution.xy).x;\n    \n    C.y =texture(iChannel0,(U + sc*vec2(0,-4))/iResolution.xy).y;\n    \n    C.z =texture(iChannel0,(U + sc*vec2(-3,-5))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\n\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n#define kSegment (floor(pow(mod(iTime,30.)/30.,2.)*2.))\n\n#define pi acos(-1.)\n\n#define R (iResolution.xy)\n#define T(u) texture(iChannel2,(u)/R)\n#define T0(u) texture(iChannel0,(u)/R)\n\n//#define sino(a) sin(a)3\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(.5);\n    p.xz *= rot(.5);\n    float amp = 1.;\n    float gain = 0.4 + sin(p.x*1.5 + time)*0.;\n    const float lacunarity = 1.24;\n    const int octaves = 4;\n    \n     float warp = .1 + sin(time*0.5)*0.05;\n    float warpTrk = 1.8 ;\n    const float warpTrkGain = 0.51;\n    \n    vec3 seed = vec3(-2,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p -= sin(p.zxy*warpTrk + vec3(0,-time*0.5,0) - .4*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.5,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 2;\n    \n    const float warp =.4;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat sdSq(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }", "buffer_c_code": "// Fork of \"Day 424\" by jeyko. https://shadertoy.com/view/wldfDB\n// 2021-02-16 09:06:35\n\n// dont fullscreen\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    \n    C -= C;\n\n    vec4 bloom = vec4(0);\n    //bloom += texture(iChannel0,fragCoord/R,0.);\n    //bloom += texture(iChannel0,fragCoord/R,1.);\n    bloom += texture(iChannel0,fragCoord/R,0.);\n    //bloom += texture(iChannel0,fragCoord/R,3.);\n    bloom += texture(iChannel0,fragCoord/R,9.);\n    bloom += texture(iChannel0,fragCoord/R,5.);\n    bloom += texture(iChannel0,fragCoord/R,6.);\n    bloom += texture(iChannel0,fragCoord/R,7.);\n    bloom += texture(iChannel0,fragCoord/R,6.);\n    bloom += texture(iChannel0,fragCoord/R,9.);\n    bloom += texture(iChannel0,fragCoord/R,12.);\n    \n    //bloom = smoothstep(0.4,1.,1.7*bloom/8.)*2.;\n    bloom/=6.;\n    C = bloom;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"Day 424\" by jeyko. https://shadertoy.com/view/wldfDB\n// 2021-02-16 09:06:35\n\n// dont fullscreen\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    \n    C -= C;\n\n    vec4 bloom = vec4(0);\n    //bloom += texture(iChannel0,fragCoord/R,0.);\n    //bloom += texture(iChannel0,fragCoord/R,1.);\n    bloom += texture(iChannel0,fragCoord/R,5.);\n    //bloom += texture(iChannel0,fragCoord/R,3.);\n    bloom += texture(iChannel0,fragCoord/R,4.);\n    bloom += texture(iChannel0,fragCoord/R,5.);\n    bloom += texture(iChannel0,fragCoord/R,3.);\n    bloom += texture(iChannel0,fragCoord/R,7.);\n    bloom += texture(iChannel0,fragCoord/R,2.);\n    bloom += texture(iChannel0,fragCoord/R,12.);\n    bloom += texture(iChannel0,fragCoord/R,9.);\n    \n    \n            \n    bloom = smoothstep(0.4,1.5,1.5*bloom/8.)*1.;\n    \n    \n    C = texture(iChannel1,fragCoord/R);\n    \n    C = mix(C,bloom*1.4,pow(smoothstep(0.,1.5,length(bloom)),2.)*0.5);\n            \n    if(kSegment > 0.5){\n        C = 1. - C*0.8;\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 307, 307, 1220]], "test": "untested"}
{"id": "wt3BDH", "name": "SaintVenantSystem", "author": "EvilRyu", "description": "Godunov type central upwind scheme for shallow water equation", "tags": ["simulation", "water", "shallowwaterequation", "saintvenant"], "likes": 8, "viewed": 438, "published": 3, "date": "1613549062", "time_retrieved": "2024-07-30T19:37:30.511120", "image_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\nvec2 getCellUV(float fragCoord)\n{\n    float Cellid = (fragCoord / (iResolution.x/NUM_CELLS));\n    return vec2(Cellid, 0.5)/iResolution.xy;\n    \n    // no smooth filter to see the height of each cell\n    //return vec2(floor(Cellid) + 0.5, 0.5) / iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Render topology\n    float d = uv.y - B(getCellUV(fragCoord.x));\n    vec3 col = vec3(smoothstep(0., 0.01, d) * smoothstep(0.02, 0.01, d));\n        \n    // Render water\n    float w = texture(iChannel0, getCellUV(fragCoord.x)).x;\n    d = uv.y - w;\n    col += vec3(0., 0., smoothstep(0.015, 0., d));\n    \n    // Cut out overlapping area\n    d = uv.y - B(getCellUV(fragCoord.x));\n    col -= vec3(smoothstep(0.01, 0.0, d));\n    col = clamp(col, 0., 1.);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n// An implementation of the paper:\n// A SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\n// https://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf\n\n// No larger than iResolution.x\n#define NUM_CELLS 100.\n#define dx 1.\n#define theta 1.3\n#define epsilon (0.0001 * max(1., dx))\n#define G 9.812\n// not bounded by CFL condition as it requires \n// calculation of the max of all local speeds of propagation\n#define dt .1\n\n#define oneCell vec2(1./iResolution.x, 0.)\n#define halfCell vec2(0.5/iResolution.x, 0.)\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    float x = uv.x * 13.+ 6.0;\n    return .3 + .3 * sin(10. * x + 5. * cos(x + 2.5 * sin(x)));\n}\n\nvec2 initialCondition(vec2 uv)\n{\n    return vec2(.2 + B(uv), 0.);\n}", "buffer_a_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\n// Limiter to ensure non-oscillatory reconstruction\nvec2 minmod(vec2 a1, vec2 a2, vec2 a3)\n{\n    vec2 res;\n    \n    for(int i = 0; i < 2; ++i)\n    {\n        if(a1[i] > 0. && a2[i] > 0. && a3[i] > 0.)\n        {\n            res[i] = min(min(a1[i], a2[i]), a3[i]);\n        }\n        else if(a1[i] < 0. && a2[i] < 0. && a3[i] < 0.)\n        {\n            res[i] = max(max(a1[i], a2[i]), a3[i]);\n        }\n        else res[i] = 0.;\n    }\n    \n    return res;\n}\n\n// Bottom topology height at j+1/2 and j-1/2\nfloat B_jph(vec2 uv)\n{\n    return B(uv+halfCell);\n}\n\nfloat B_jmh(vec2 uv)\n{\n    return B(uv-halfCell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > NUM_CELLS-0.5 || fragCoord.y > 1.5)\n        return;\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // water level: U.x = w\n    // discharge:   U.y = hu\n    vec2 U = texture(iChannel1, uv).xy;\n    \n    // at j+1 and j-1\n    vec2 U_jp1 = texture(iChannel1, uv + oneCell).xy;\n    vec2 U_jm1 = texture(iChannel1, uv - oneCell).xy;\n   \n    // Boundary\n    if((uv + oneCell).x > (NUM_CELLS - 0.5)/iResolution.x)\n    {\n        U_jp1 = vec2(U.x, -U.y);\n    }\n    \n    if((uv - oneCell).x < 0.)\n    {\n        U_jm1 = vec2(U.x, -U.y);\n    }\n    \n    \n    //if(iFrame == 0)\n    //{\n        //U_jp1 = U_jm1 = U = initialCondition(uv);\n    //}\n\n\n    vec2 Ux;\n    vec2 a1 = theta * (U - U_jm1) / dx;\n    vec2 a2 = (U_jp1 - U_jm1) / (2.*dx);\n    vec2 a3 = theta * (U_jp1 - U) / dx;\n    Ux = minmod(a1, a2, a3);\n    \n    // upwind at j-1/2 and downwind at j+1/2\n    vec2 U_E, U_W;\n    U_W = U - dx * 0.5 * Ux;\n    U_E = U + dx * 0.5 * Ux;\n    \n    // reconstruct water level for positivity preserving\n    // B_f: Bⱼ₊₁/₂\n    // B_b: Bⱼ₋₁/₂\n    float B_f = B_jph(uv);\n    float B_b = B_jmh(uv);\n    \n    if(U_E.x < B_f)\n    {\n        Ux.x = (B_f - U.x) / (0.5 * dx);\n        U_E.x = B_f;\n        U_W.x = 2. * U.x - B_f;\n    }\n    \n    if(U_W.x < B_b)\n    {\n        Ux.x = (U.x - B_b) / (0.5 * dx);\n        U_E.x = 2. * U.x - B_b;\n        if(U_E.x < B_f)\n            U_E.x = B_f;\n        U_W.x = B_b;\n    }\n    \n    \n    fragColor = vec4(U_W, U_E);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\nfloat reconstructSpeed(float h, float hu)\n{\n    float h4 = h*h*h*h;\n    return (sqrt(2.) * h * hu) / sqrt(h4 + max(h4, epsilon));\n}\n\nfloat localPropagationSpeedUpwind(float u_p, float u_m, float h_p, float h_m)\n{\n    return max(max(u_p + sqrt(G * h_p), u_m + sqrt(G * h_m)), 0.00001);\n}\n\nfloat localPropagationSpeedDownwind(float u_p, float u_m, float h_p, float h_m)\n{\n    return min(min(u_p - sqrt(G * h_p), u_m - sqrt(G * h_m)), -0.00001);\n}\n\nvec2 F(float hu, float h, float u)\n{\n    return vec2(hu, h * u*u + G * 0.5 * h*h);\n}\n\n// Values at j+1/2 and j-1/2\nfloat B_jph(vec2 uv)\n{\n    return B(uv+halfCell);\n}\n\nfloat B_jmh(vec2 uv)\n{\n    return B(uv-halfCell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > NUM_CELLS-0.5 || fragCoord.y > 1.5)\n        return;\n        \n    vec2 uv = fragCoord/iResolution.xy;\n    float B_f = B_jph(uv);\n    float B_b = B_jmh(uv);\n    \n    vec4 U = texture(iChannel0, uv);\n    vec2 U_jp1_W = texture(iChannel0, uv+oneCell).xy;\n    vec2 U_jm1_E = texture(iChannel0, uv-oneCell).zw;\n    \n    // Boundary\n    if((uv + oneCell).x > (NUM_CELLS - 0.5)/iResolution.x)\n    {\n        U_jp1_W = vec2(U.z, -U.w);\n    }\n    \n    if((uv - oneCell).x < 0.)\n    {\n        U_jm1_E = vec2(U.x, -U.y);\n    }\n    \n    // Get upwind and downwind derivatives on the two edges\n    // U_fp = U⁺ⱼ₊₁/₂ = U_jp1_W\n    // U_bm = U⁻ⱼ₋₁/₂ = U_jm1_E\n    // U_fm = U⁻ⱼ₊₁/₂ = U_E\n    // U_bp = U⁺ⱼ₋₁/₂ = U_W\n    vec2 U_fp = U_jp1_W;\n    vec2 U_bm = U_jm1_E;\n    vec2 U_fm = U.zw;\n    vec2 U_bp = U.xy;\n    \n    \n    // reconstruct water depth and propagation speed\n    // h⁺⁻ⱼ₊₋₁/₂ = w⁺⁻ⱼ₊₋₁/₂ - Bⱼ₊₋₁/₂\n    float h_fp = U_fp.x - B_f;\n    float h_fm = U_fm.x - B_f;\n    float h_bm = U_bm.x - B_b;\n    float h_bp = U_bp.x - B_b;\n    \n    \n    // velocity desingularization in case of very small h\n    float u_fp = reconstructSpeed(h_fp, U_fp.y);\n    float u_fm = reconstructSpeed(h_fm, U_fm.y);\n    float u_bm = reconstructSpeed(h_bm, U_bm.y);\n    float u_bp = reconstructSpeed(h_bp, U_bp.y);\n    \n    // Local speeds of propagation\n    // the upper and lower bounds of local speeds can be estimated using\n    // the largest and smallest eigenvalues of the Jacobian ∂F/∂U\n    float a_fp = localPropagationSpeedUpwind(u_fp, u_fm, h_fp, h_fm);\n    float a_fm = localPropagationSpeedDownwind(u_fp, u_fm, h_fp, h_fm);\n    float a_bp = localPropagationSpeedUpwind(u_bp, u_bm, h_bp, h_bm);\n    float a_bm = localPropagationSpeedDownwind(u_bp, u_bm, h_bp, h_bm);\n    \n    // Recompute the discharge using reconstructed h and u\n    U_fp.y = h_fp * u_fp;\n    U_fm.y = h_fm * u_fm;\n    U_bp.y = h_bp * u_bp;\n    U_bm.y = h_bm * u_bm;\n    \n    // Flux\n    vec2 H_f, H_b;\n    vec2 F_fp, F_fm, F_bp, F_bm;\n    \n    F_fp = F(U_fp.y, h_fp, u_fp);\n    F_fm = F(U_fm.y, h_fm, u_fm);\n    F_bp = F(U_bp.y, h_bp, u_bp);\n    F_bm = F(U_bm.y, h_bm, u_bm);\n    \n    H_f = (a_fp * F_fm - a_fm * F_fp) / (a_fp - a_fm) + \n            (a_fp * a_fm) / (a_fp - a_fm) * (U_fp - U_fm);\n    H_b = (a_bp * F_bm - a_bm * F_bp) / (a_bp - a_bm) + \n            (a_bp * a_bm) / (a_bp - a_bm) * (U_bp - U_bm);\n            \n    // Source Term\n    vec2 S = vec2(0., -G * ((U_fm.x + U_bp.x) * 0.5 - (B_f+B_b)*0.5) \n                            * ((B_f-B_b) / dx));\n    \n\n    vec2 U_n = texture(iChannel1, uv).xy;\n    \n    // Initial condition\n    if(iFrame == 0)\n    {\n        U_n = initialCondition(uv);\n    }\n    \n    // Foward Eular\n    U.xy = U_n + dt * (-(H_f - H_b)/dx + S);\n                            \n    fragColor = vec4(U.xy, 0., 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3BDH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[159, 159, 192, 192, 421], [423, 423, 480, 480, 1011]], "test": "untested"}
{"id": "3tcBDX", "name": "bokeh experiment_01", "author": "YitingLiu", "description": "experimenting with bokeh and struct ", "tags": ["bokeh", "lights", "drive", "street", "artofcode"], "likes": 3, "viewed": 301, "published": 3, "date": "1613529060", "time_retrieved": "2024-07-30T19:37:31.461579", "image_code": "#define S(x, y, t) smoothstep(x, y, t)\n\n\nstruct ray {\n    vec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){\n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookat-camPos);\n    vec3 r = cross(vec3(0,1,0),f);\n    vec3 u = cross(f,r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c+uv.x*r+uv.y *u;\n    a.d=normalize(i-a.o);\n    \n    return a;\n}\n\nvec3 ClosetPoint(ray r, vec3 p){\n    return r.o+max(0.,dot(p-r.o,r.d))*r.d;\n\n}\n\nfloat DistRay(ray r, vec3 p){\n    return length(p-ClosetPoint(r,p));\n}\n\nfloat Bokeh (ray r, vec3 p, float size, float blur){\n    size*=length(p);\n    float d = DistRay(r,p);\n    float c = S(size, size*(1.-blur),d);\n    c*=mix(.6,1.,S(size*.8,size,d));\n    return c;\n\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.d.x,0.);\n   \n    r.d.x=abs(r.d.x);\n\n    float s = 1./10.;\n    float m = 0.;\n    \n    for(float i=0.; i < 1.; i+=s){\n    float ti = fract(t+i+side*s*.5);\n    vec3 p = vec3(2.,2.,100.-ti*100.);\n    m+= Bokeh(r,p,.1,.1)*ti*ti*ti*ti;\n    }\n    return  vec3(1.,.7,.3)*m;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0,.2,0);\n    vec3 lookat = vec3(0,.2,1.);\n    \n    ray r = GetRay(uv,camPos,lookat,2.);\n   \n     float t = iTime*.1;  \n\n    vec3 col = Streetlights(r,t);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 130, 130, 368], [370, 370, 402, 402, 448], [450, 450, 479, 479, 520], [522, 522, 574, 574, 718], [720, 720, 754, 754, 1047], [1049, 1049, 1105, 1155, 1463]], "test": "untested"}
{"id": "3t3BDX", "name": "Weird 2d patterns", "author": "lousisx", "description": "VERY messy code\nTried to convert a shape grammar from a class I took into a pattern generator (I have a version where the parameters are controlled by a midi controller)\nhttps://silsprod.files.wordpress.com/2021/02/gramaticas-ff.pdf", "tags": ["2d", "pattern", "shape", "grammar", "girih"], "likes": 6, "viewed": 341, "published": 3, "date": "1613528169", "time_retrieved": "2024-07-30T19:37:32.753127", "image_code": "#define TWO_PI 6.28318\n#define p_offset 0.\n\n////////   very messy, lots of unused code   //////////\n\n\nfloat sdLine (in vec2 p, in vec2 a, in vec2 b){ //line sdf\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length (pa-ba*h);\n}\nvec2 pcart (in float r, in float a){          //polar to cartesian \n\treturn vec2(r*cos(a),r*sin(a));\n}\nvec2 cpol (in float x, in float y){           //cartesian to polar\n\treturn vec2(sqrt(pow(x,2.)+pow(y,2.)),atan(y/x));\n}\n//--------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( 2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tuv *= 3.; //zoom\n    \n    \n    //rotate 45'\n    float ks = sin(.8), kc = cos(.8);\n    mat2 m = mat2(-kc,ks,ks,kc);\n    //uv = m*uv;\n    \n    \n    //create and offset tiles\n\tfloat hh;\n    \n    if (p_offset == 1.){\n    hh = 0.895;\n\tuv.x += step(1.,mod(uv.y,2.)) *(hh/2.);\n\tuv.x  = mod(uv.x,hh);\n\tuv.y  = mod(uv.y,1.)-0.05;\n    }\n    else{\n    hh = 1.;\n\tuv.x  = mod(uv.x,2.);\n\tuv.y  = mod(uv.y,2.*hh);\n    }\n\tfloat ofs = 0.12;                //center offset\n\tfloat len = hh * 0.516 - ofs;    //length size\n    float div = 2. + iTime/5.;                 //division\n    float lnw = 0.05;              //line weight\n\tfloat ang;\n\tfloat sec;\n\tvec3  lin;\n    vec3  col;\n\tfloat mi = 1.; \n    \n    if (uv.x >=1.){uv.x = 2.-uv.x;}\n    if (uv.y >=1.){uv.y = 2.-uv.y;}\n    \n    for(float m = 0.; m < 2.; m++){        //mirror x coordinate\n        if(m == 1.){uv.x = hh - uv.x;}\n        for(float i = 0.; i < div; i++){   //radial array\n            sec = 6.28318/div;\n            ang = sec*i+sec/2.;\n    \n            vec2 a = pcart(ofs,ang); a += vec2(hh/2.,0.5);\n            \n            vec2 b = a + pcart(len*(1. + sin(iTime/2.)),ang + sec*1.50);\n            vec2 c = b + pcart(len*10.50,ang + sin(iTime)*1.6+.5);\n            \n            \n            // minimum sdf\n            mi = min(mi, sdLine(uv,a,b));\n            mi = min(mi, sdLine(uv,b,c));\n            //mi = min(mi, sdLine(uv,c,d));\n            //mi = min(mi, sdLine(uv,d,e));\n            //mi = min(mi, sdLine(uv,f,g));\n        }\n    }\n    \n    //col  = vec3(1.0) ;\n    col *= 0.3 + 0.4*smoothstep(mi,0.02,0.00);\n    col *= 1.0 + 0.2*smoothstep(mi,0.03,0.00);\n    col  = mix(col,vec3(1.0),1.0-smoothstep(0.0,lnw,abs(mi)));\n    \n\tfragColor = vec4(col, 1.0);\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 149, 160, 261], [262, 262, 298, 329, 364], [365, 365, 400, 431, 484], [551, 551, 607, 607, 2387]], "test": "untested"}
{"id": "tldfWj", "name": "Distance to Triangle Wave - 3D", "author": "oneshade", "description": "Exact distance to a 3D triangle wave.", "tags": ["3d", "raymarching", "sdf", "distance", "periodic", "trianglewave", "exact"], "likes": 9, "viewed": 199, "published": 3, "date": "1613523784", "time_retrieved": "2024-07-30T19:37:33.623799", "image_code": "// f: frequency\n// a: amplitude\n// d: depth\n// t: thickness\nfloat sdTriangleWave(in vec3 p, in float f, in float a, in float d, in float t) {\n    float pw = 1.0 / f, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * a, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p.xy *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec3(p.x, max(abs(p.yz) - vec2(0.25 * l, d), 0.0))) - t;\n}\n\nfloat mapScene(in vec3 p) {\n    float frac = fract(iTime * 0.5);\n    float freq = frac * (1.0 - frac) * 4.0 + 0.1;\n    float amp = 2.1 + 2.0 * cos(iTime);\n    float depth = 0.5 + 0.5 * sin(iTime);\n    float thickness = 0.251 + 0.25 * sin(iTime * 0.5);\n    return sdTriangleWave(p, freq, amp, depth, thickness);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    fragColor = vec4(vec2(0.5 + 0.5 * rd.y), 1.0, 1.0);\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb = (0.5 + 0.5 * n) * max(0.1, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 60, 141, 141, 406], [408, 408, 435, 435, 720], [722, 722, 749, 749, 996], [998, 998, 1053, 1053, 2053]], "test": "untested"}
{"id": "tttBDj", "name": "snow day 2", "author": "elenzil", "description": "bleep", "tags": ["snow"], "likes": 5, "viewed": 603, "published": 3, "date": "1613521210", "time_retrieved": "2024-07-30T19:37:34.579243", "image_code": "// Fork of \"snow day 1\" by elenzil. https://shadertoy.com/view/Wl3BD2\n// 2021-02-16 19:36:30\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n\n    vec3 rgb = texelFetch(iChannel0, IJ, 0).rgb;\n    \n\n    RGBA.rgba = vec4(rgb, 1.0);\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float PI        = 3.14159265259;\nconst float PI2       = (PI * 2.0);\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n\n\n", "buffer_a_code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvec3 someColors(in vec2 XY) {\n\n//    return vec3((int(XY.x) / 50) % 2);\n\n    float smallRes = min(iResolution.x, iResolution.y);\n    vec2  p = (XY - iResolution.xy * 0.5) / smallRes * 2.0;\n\n    p *= PI2;\n\n    vec3 rgb;\n\n    p *= rot2(iTime *  0.1);\n    rgb.r = cos(p.x * 1.23) + cos(p.y * 1.04);\n    p *= rot2(iTime * -0.15);\n    rgb.g = cos(p.x * 1.31) + cos(p.y * 1.24);\n    p *= rot2(iTime *  0.1);\n    rgb.b = cos(p.x * 1.21) + sin(p.y * 1.41);\n\n    rgb = rgb * 0.25 + 0.5;\n    \n    rgb *= vec3(sin(length(p) * 1.5) * 0.1 + 0.9);\n\n    rgb = mix(rgb, texture(iChannel1, vec2(1.0, 0.0) + XY/iResolution.xy * vec2(-1.0, 1.0)).rgb, sin(iTime) * 0.1 + 0.1);\n\n\n    return rgb;\n}\n\n\nconst ivec2 iUp = ivec2( 0, 1);\nconst ivec2 iUL = ivec2(-1, 1);\nconst ivec2 iUR = ivec2( 1, 1);\n\nbool amRight(int i) {\n    return bool(i & 0x1);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    bool reset = (iFrame == 0 || iMouse.z > 10.0);\n    vec2 UV = XY/iResolution.xy;\n    \n    RGBA.rgb = someColors(XY);\n    \n    float smallRes = min(iResolution.x, iResolution.y);\n    vec2  p     = (XY * 2.0 - iResolution.xy) / smallRes;\n    p *= 1.8;\n    \n    float theta = atan(p.y, p.x);\n    float r     = sin(theta * 5.0 + iTime * 1.8);\n    \n    vec2 v1 = normalize(p) * -1.0;\n    vec2 v2 = vec2(-v1.y, v1.x);\n    v1 /= iResolution.xy;\n    v2 /= iResolution.xy;\n    v2 *= 3.0;\n    vec3 c1 = texture(iChannel0, UV + v1     ).rgb;\n    vec3 c2 = texture(iChannel0, UV + v1 + v2).rgb;\n    vec3 c3 = texture(iChannel0, UV + v1 - v2 * 0.5).rgb;\n    vec3 c  = (c1 + c2 + c3) / 3.0;\n    \n    RGBA.rgb = mix(RGBA.rgb, c, 1.0 * vec3(smoothstep(0.9, 1.1, length(p) + r * 0.4)));\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 184, 184, 300]], "test": "untested"}
{"id": "wl3fDH", "name": "ultimate custom feedback wip*", "author": "SimonOakey", "description": "props to rgb shifting!  still work in progress! ", "tags": ["webcam", "feedback"], "likes": 4, "viewed": 349, "published": 3, "date": "1613520446", "time_retrieved": "2024-07-30T19:37:35.649383", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nfloat rand (vec2 p) {\n\n    p = fract(p*vec2(123.34,456.567));\n    p += dot(p, p+45.32);\n    return fract(p.x * p.y);\n}\n*/\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvec2 rotate(vec2 coords, float angle){\n\tfloat sin_factor = sin(angle );\n    float cos_factor = cos(angle );\n    coords = vec2((coords.x - 0.5) , coords.y - 0.5) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);\n    coords += 0.5;\n    return coords;\n}\n\n\n\nvec3 hsb2rgb( in vec3 c ){\n    \n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec2 swizzle( vec2 pol, vec2 _uv ) {\n\n    float _mode = 3.5;// (iMouse.y/iResolution.y)*6.;\n\n    vec2 displacement = vec2(0.);\n    \n    float morph_speed = iTime; // feedback morph speed\n    \n    float feedback_amount = 1.; // feedback amount\n\n    float _freq = (iMouse.x/iResolution.x)*1.8 +.5;\n    \n    \n   // displacement.x = noise( vec2( sin(pol.y*morph_speed*.0013 + morph_speed*.1), cos(pol.x*morph_speed*.00413)) ) ;\n    //displacement.y = noise( vec2( cos(pol.y*morph_speed*.0013), sin(pol.x*morph_speed*.0013 + morph_speed*.3)) ) ;\n    \n    // ----------------------\n    // META FEEDBACK MAP\n     // ----------------------\n    \n     // micro noise\n    \n    // displacement.y = cos(noise(vec2(pol.x*3.,pol.y*33.+ iTime*.1))*4.2) *.6;\n    // displacement.x = sin(noise(vec2(pol.y*9.+ iTime*.61 ,pol.x*13.))*4.2) *.3;\n    \n    \n    // tiny noise\n      displacement.y = cos(noise(_uv*33. + iTime*.1)*3.);\n     displacement.x = sin(noise(_uv*12. + iTime*.1)*3.);\n    \n    \n     \n     //circular osc simple\n     //  displacement.y = sin(_uv.x*12.+ iTime*.51)*2.;\n     // displacement.x = cos(_uv.y*12.+ iTime*.51)*2.;\n     \n     // color based oscillation\n     //displacement.y  = sin(pol.x*12.+ iTime*.51);\n     //displacement.x  = cos(pol.x*12.+ iTime*.51);\n     \n      // fullscreen noise\n     //displacement.x += sin(noise(_uv*.3 + iTime*.1)*3.)*1.2;\n    // displacement.y += cos(noise(_uv*.9 + iTime*.1)*3.)*1.2;\n     \n     //hor and vert linear grid\n    //  displacement.y  +=  ( abs(sin(_uv.x*33.+ iTime*1.51))  )*2.;\n    // displacement.x  =  ( abs(sin(_uv.y*33.+ iTime*1.51))  )*2.;\n     \n    \n    \n     // ----------------------\n      // ----------------------\n       // ----------------------\n    \n   \n     /*\n     if(_mode>=0. && _mode<1.){ \n     \n            \n          // osccillating dsiplacement\n         displacement =  vec2( \n            pol.x * cos(pol.y*6.*_freq) + sin(pol.y*_freq+morph_speed)*.5,\n            pol.y * sin(pol.x*3.*_freq) + (cos(pol.x*.6*_freq+morph_speed))*.65\n           );\n     }\n    \n    \n    if(_mode>=1. && _mode<2.){ \n        // uv&color based displacement\n        displacement.y += sin(pol.y*_uv.x*13.3*_freq + morph_speed*1.3) ;\n        displacement.x += cos(pol.x*_uv.y*23.3*_freq  + morph_speed*1.3);\n    }\n   \n   \n   if(_mode>=2. && _mode<3.){ \n   // simple linear displacement\n       displacement.y -= .4 + pol.y*.2;//2.3*pol.x;\n       displacement.x +=  sin( pol.y*12.1*_freq +morph_speed )*.14 ;//* 1.*pol.y;\n     }\n   \n    if(_mode>=3. && _mode<4.){ \n   // osccillating noise > brilliant!\n     displacement.y += sin(noise(pol*_freq  +morph_speed*.1)*3.4 );\n     displacement.x += cos(noise(pol*_freq  +morph_speed*.1)*5.4 );\n   }\n   \n    if(_mode>=4. && _mode<5.){ \n       // fluffl noise > nice\n        displacement.y += noise(_uv*pol.x*2.6*_freq  +cos(morph_speed*.4));\n        displacement.x += noise(_uv*pol.y*2.6*_freq  +sin(morph_speed*.4));\n    }\n    \n    if(_mode>=5. && _mode<6.){ \n    // fract sinusal > work on this more!\n     displacement.y +=  sin(fract((pol.x*2.3*_uv.y*_freq+morph_speed*.3))* 2.);\n    displacement.x +=  cos(fract( (pol.y*2.3*_uv.x*_freq+morph_speed*.3 ))*2.);\n   }\n    */\n    displacement *=feedback_amount;\n    \n   \n    \n    return displacement;\n    \n}\n\n\n\nvec4 color_swizzle2( vec4 _col, vec2 _uv ) {\n\n\n        float color_freq = iMouse.x/iResolution.x;\n        float color_amplitude = iMouse.y/iResolution.y;\n    \n        float col_freq =  .001 + color_freq*.03;\n        float col_amplitude = .001 + color_amplitude * 0.75;\n        \n\t\tvec3 o_col = _col.rgb;\n        vec3 colOut = rgb2hsv(_col.rgb); // convert color to hsb\n        \n     \n         float unision =  sin( _col.r*col_freq*3.14  ) *.5;\n         \n        \n         \n        unision *= noise(sin(_uv*.4*_col.r*col_freq+ iTime*.01*col_freq )*3.)*.1;\n     \n      unision *=color_amplitude;\n     \n\t  colOut.r +=  unision*.004 + .003 * color_amplitude;\n      \n        colOut.g +=  unision*.004 + .003 * color_amplitude;\n       \n          colOut.b += unision*.12 + .003 * color_amplitude;\n        \n      //  colOut.b += noise( sin(_uv*13.14*_col.r+ iTime*.1 )*3.)*.4;\n      // colOut.r += (noise( sin(_uv*1222.14*_col.b*col_freq+ iTime*.1 )*3.)*.2 ) *col_amplitude;\n\t\t\n\t\t //colOut.g += (col_freq+_col.b*col_freq*.001 ) *col_amplitude;\n\t  \n\t\t //colOut.b += sin(_col.b*col_freq )*col_amplitude;\n\t\t\n         colOut.r  += (rand(_uv)-.5)*.02;\n         //colOut.r += mod(colOut.r+.001,1.0);\n        \n     \n      colOut = hsv2rgb(colOut);\n      \n       return vec4(vec3(colOut),1.);\n      \n     //   colOut.r += sin(colOut.r*11.31)*.1;\n     \n     /*\n     // SIMPLE RGB SHIFTING\n      o_col.r += ( sin(col_freq*iTime*_col.g* 3.13)*.5+.5 ) *.01*col_amplitude;\n       o_col.g += ( cos(col_freq*iTime*_col.r*2.16)*.5+.5 ) *.004*col_amplitude;\n       o_col.b += ( sin(col_freq*iTime*_col.r*5.01)*.5+.5 ) *.01*col_amplitude;\n     \n     \n      return vec4(vec3( o_col),1.);\n    */\n\n}\n\nvec4 color_swizzle( vec4 _col, vec2 _uv ) {\n\n     \n    \n    vec3 col = rgb2hsv(_col.rgb);\n    \n     // ---------------------------------\n    // --------COLOR  SHIFT --------------\n    // ---------------------------------\n    \n    // simple continuous color shift\n    float colorshift = 1.0014*iTime; \n    \n     // colorshift distortion based\n       //colorshift += (sin( col.x*.04 + _uv.y*.14)*.5+.5)*.002;\n     \n     // colorshift color based\n    //   colorshift = (sin( col.x*.014 + col.y*.014)*.5+.5)*.002;\n    \n      //  colorshift = 0.; \n    \n    \n    // ---------------------------------\n    // --------SATURATION SHIFT --------------\n    // ---------------------------------\n    float sat_shift  =  col.y;\n    \n    \n     //sat_shift *= abs(sin(.001*_col.y+_uv.x*.001+iTime*.4)*.5+.5)*1.19+.95;\n      //sat_shift = mod(col.r+.001, 1.0)*04.;\n      // sat_shift =.5;\n    //   sat_shift += abs(sin(2.1*_col.x + cos(1.1*_uv.x)))*.08;\n     \n      // ---------------------------------\n    // -------BRIGHT SHIFT --------------\n    // ---------------------------------\n     \n     float b_shift = col.z;\n     \n     //contrasty wandering\n      b_shift =  (sin(_uv.y*2.031+_col.z*2.6+iTime*.021+_uv.x*2.1))*.3+.66; \n     \n    // col.g = .5;\n    // col.g = cos(_col.r*1.3 + _uv.y* 1.1)*.5+.25; // saturation\n      //col.b = .8;// cos(_col.g*.71)*.5+.5; // saturation\n     \n     //col.r =  abs(sin(_uv.y*col.r*.1+iTime*.001))*1.05;\n     //col.r += mod(col.r+.01, 1.0)*4.;\n    //col.b = mod(col.b+.01, 1.0);\n    \n    // col.r += colorshift; // color shift\n       //col.b = sat_shift;\n      // col.g = b_shift;\n    \n    col = hsv2rgb(col);\n   col = fract(col);\n\n    return vec4(vec3(col),1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    float dry = iMouse.x/iResolution.x;\n    dry = .01;\n\n\n    vec2 uv = fragCoord / iResolution.xy;\n    // uv.y *= iResolution.y/iResolution.x;\n    vec2 displacedUv = uv;\n    vec4 imageIn = texture(iChannel0, uv);    \n    vec4 feedbackIn = texture(iChannel1, uv);\n    displacedUv += swizzle( vec2(length(feedbackIn.rg), length(feedbackIn.rb)), uv) / 1000.0;\n\n\n    // optional rotate whole feedback \n    //displacedUv = rotate(displacedUv,.001);\n    \n    vec4 feedback = texture(iChannel1, displacedUv);\n   \n    feedback = color_swizzle2(feedback,displacedUv);\n  \n   feedback = mix(feedback,imageIn,dry);\n   \n   \n   \n        fragColor = feedback;\n   \n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "wtdBD2", "name": "Cellular automata crystals", "author": "illus0r", "description": "https://twitter.com/i_dianov/status/1361499399587790852", "tags": ["color", "cellular", "buildings"], "likes": 9, "viewed": 356, "published": 3, "date": "1613515198", "time_retrieved": "2024-07-30T19:37:36.470187", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define t iTime\n#define res iResolution.xy\n\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n#define S sin(40.*length(FC/res-.5))\n#define ROOF_START step(-.5,-S)*.1\n#define ROOF_LEFT_STOP step(.5,S)*.1\n#define ROOF_RIGHT_STOP step(.5,S)*.1\n#define ROOF_WALL_START .0001\n#define COL transpose(mat3(\\\n    .2,0,1,\\\n    1,.92,.0,\\\n    0,1,1))\n\n#define rnd(x) fract(sin(x*1e2)*1e2)\n#define T(dd) (texelFetch(iChannel0,ivec2(FC.xy+vec2(dd,-1))%int(res),0).rgb*inverse(COL))\n#define lr T(-1).r>.5\n#define cr T( 0).r>.5\n#define rr T( 1).r>.5\n#define lg T(-1).g>.5\n#define cg T( 0).g>.5\n#define rg T( 1).g>.5\n#define lb T(-1).b>.5\n#define cb T( 0).b>.5\n#define rb T( 1).b>.5\n    if (iFrame == 0) o = vec4(0);\n    if(t<.1)if(rnd(length(FC.xy))<.5)o.r+=1.;else o.b+=1.;\n    else if(lb&&cr&&rr&&rnd(length(FC.xy))<ROOF_START)o.g+=1.;\n    else if(lg&&cg&&rr&&rnd(length(FC.xy))<ROOF_RIGHT_STOP)o.b+=1.;\n    else if(lg&&cr&&rr&&rnd(length(FC.xy+vec2(-1,0)))<ROOF_RIGHT_STOP)o.b+=1.;\n    else if(lb&&cg&&rg&&rnd(length(FC.xy))<ROOF_LEFT_STOP)o.r+=1.;\n    else if(lb&&cb&&rg&&rnd(length(FC.xy+vec2(1,0)))<ROOF_LEFT_STOP)o.r+=1.;\n    else if(lg&&cg&&rg&&rnd(length(FC.xy))<ROOF_WALL_START)o.b+=1.;\n    else if(lb&&cg&&rnd(length(FC.xy+vec2(-1)))<ROOF_WALL_START)o.r+=1.;\n    else if(cb)\n      if(rg)\n        if(lg) o.b+=1.;\n        else o.g+=1.;\n      else o.b+=1.;\n    else \n      if(cr)\n        if(lg)\n          if(rg) o.r+=1.;\n          else o.g+=1.;\n        else o.r+=1.;\n      else\n        if(lr) o.r+=1.;\n        else\n          if(lg)\n            if(rb) o.b+=1.;\n            else o.g+=1.;\n          else o.g+=1.;\n    o.rgb *= COL;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "tltfW2", "name": "Raytraced Bunny", "author": "mla", "description": "Just a test with the 948 triangle Stanford bunny mesh from [url]https://www.shadertoy.com/view/wldfR8[/url] by arifr123.\n\n3 fps on my Intel 400 at 512x288, 20fps on GTX 1650 at 800x450", "tags": ["raytrace", "bunny", "stanford"], "likes": 7, "viewed": 496, "published": 3, "date": "1613512535", "time_retrieved": "2024-07-30T19:37:37.609142", "image_code": "const float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\n\n// find a,b such that:\n// p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n// ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n// return vec4(k,a,b,c) where c = 1-a-b\n#if 0\n// Solve linear system with a matrix inversion\nvec3 triangle(vec3 p, vec3 r, vec3 v0, vec3 v1, vec3 v2) {\n  mat3 A = mat3(-r,v0-v2,v1-v2);\n  mat3 I = inverse(A);\n  vec3 b = p-v2;\n  vec3 a = I*b;\n  return a;\n}\n#else\n// Standard algorithm by Tomas Möller and Ben Trumbore.\n// Uses Cramer's rule with some simplifications to solve linear system as above.\n// http://webserver2.tecgraf.puc-rio.br/~mgattass/cg/trbRR/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\nvec3 triangle(vec3 o, vec3 d, vec3 v0, vec3 v1, vec3 v2) {\n  // find a,b such that:\n  // p + kr = av0 + bv1 + (1-a-b)v2 = a(v0-v2)+b(v1-v2)+v2\n  // ie. -kr + a(v0-v2) + b(v1-v2) = p-v2\n  vec3 e1 = v0 - v2;\n  vec3 e2 = v1 - v2;\n  vec3 t = o - v2;\n  vec3 p = cross(d,e2);\n  vec3 q = cross(t,e1);\n  vec3 a = vec3(dot(q,e2),dot(p,t),dot(q,d))/dot(p,e1);\n  return a;\n}\n#endif\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.zx = rotate(p.zx,-0.2*iTime);\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec3 p = vec3(0,0,0.2);\n  vec3 q = vec3(uv,-2);\n  p = transform(p);\n  q = transform(q);\n  q = normalize(q);\n  vec4 amin = vec4(1e8,0,0,0);\n  for (int i = 0; i < max(-int(iTime),N); i++) {\n    int ix = triangles[i];\n    vec3 offset = vec3(0.04,-0.1,0);\n    vec3 v0 = vertices[ix&1023]+offset; ix >>= 10;\n    vec3 v1 = vertices[ix&1023]+offset; ix >>= 10;\n    vec3 v2 = vertices[ix&1023]+offset; ix >>= 10;\n    vec3 a = triangle(p,q,v0,v1,v2);\n    if (a.y < 0.0 || a.z < 0.0) continue;\n    if (a.y > 1.0 || a.z > 1.0) continue;\n    if (a.x < 0.0 || a.x >= amin.x) continue;\n    float w = 1.0-a.y-a.z;\n    if (w < 0.0 || w > 1.0) continue;\n    amin = vec4(a,w);\n  }\n  outColor = vec4(amin.yzw,1); // Use barycentric coords as RGB values\n}\n", "image_inputs": [], "common_code": "const vec3[453] vertices =\n  vec3[453] (vec3(-0.031221600249409676, 0.1263040006160736, 0.005149240139871836), vec3(-0.04467739909887314, 0.13120399415493011, 0.005704789888113737), vec3(-0.06830109655857086, 0.14482800662517548, 0.04136880114674568), vec3(-0.006000950001180172, 0.1303980052471161, 0.017898600548505783), vec3(-0.01735679991543293, 0.12761299312114716, 0.005268849898129702), vec3(0.033051300793886185, 0.10703399777412415, 0.03195429965853691), vec3(0.04008730128407478, 0.10520999878644943, 0.01734190061688423), vec3(-0.030180199071764946, 0.10632199794054031, 0.03997449949383736), vec3(0.030419299378991127, 0.11857199668884277, 0.01880680024623871), vec3(-0.06408219784498215, 0.15939100086688995, -0.01690959930419922), vec3(0.04470460116863251, 0.09278769791126251, 0.005075850058346987), vec3(-0.03167539834976196, 0.17039500176906586, -0.00635022995993495), vec3(-0.08485230058431625, 0.1340779960155487, 0.04701770097017288), vec3(-0.06885469704866409, 0.12205199897289276, 0.05175689980387688), vec3(0.005954749882221222, 0.13102400302886963, 0.01782519929111004), vec3(0.04046289995312691, 0.10514199733734131, 0.0064097801223397255), vec3(0.03873420134186745, 0.1021609976887703, -0.004631119780242443), vec3(-0.09145130217075348, 0.13413600623607635, 0.017102599143981934), vec3(-0.08187209814786911, 0.10716599971055984, 0.031015999615192413), vec3(-0.06721799820661545, 0.15615500509738922, 0.017886299639940262), vec3(-0.07956869900226593, 0.15287500619888306, 0.029931100085377693), vec3(0.005960070062428713, 0.12250400334596634, 0.03462719917297363), vec3(-0.05163170024752617, 0.14500099420547485, 0.018480399623513222), vec3(-0.07797809690237045, 0.13255000114440918, 0.05134940147399902), vec3(-0.005907080136239529, 0.12793399393558502, 0.027462299913167953), vec3(-0.04791330173611641, 0.12930099666118622, 0.026964599266648293), vec3(-0.0824270024895668, 0.0928134024143219, -0.0055604600347578526), vec3(0.01744000054895878, 0.1276939958333969, 0.01853480003774166), vec3(-0.09068679809570312, 0.12030500173568726, 0.006680400110781193), vec3(-0.029403800144791603, 0.17903000116348267, -0.007879589684307575), vec3(-0.07978910207748413, 0.14375999569892883, 0.04269940033555031), vec3(-0.01828799955546856, 0.10832899808883667, 0.04150979965925217), vec3(-0.02023259922862053, 0.1818459928035736, -0.01832740008831024), vec3(-0.037703901529312134, 0.16798700392246246, -0.013039099983870983), vec3(0.005821640137583017, 0.1280599981546402, 0.027901599183678627), vec3(-0.043538898229599, 0.13001400232315063, 0.017533300444483757), vec3(0.018869899213314056, 0.11986199766397476, 0.032409001141786575), vec3(-0.04401009902358055, 0.16703499853610992, 0.0023189799394458532), vec3(-0.08981099724769592, 0.1324010044336319, 0.007057430222630501), vec3(-0.05735199898481369, 0.1449889987707138, 0.03151959925889969), vec3(0.044262200593948364, 0.09345260262489319, 0.01764170080423355), vec3(0.041234299540519714, 0.09217309951782227, 0.028560299426317215), vec3(-0.05639529973268509, 0.1545650064945221, 0.016877999529242516), vec3(-0.020613500848412514, 0.15977300703525543, -0.007175220176577568), vec3(-0.07298929989337921, 0.06561160087585449, 0.018169300630688667), vec3(-0.06739670038223267, 0.1552560031414032, 0.005813890136778355), vec3(-0.09048639982938766, 0.11861100047826767, 0.041214801371097565), vec3(0.02731419913470745, 0.11796499788761139, 0.028619099408388138), vec3(0.04190700128674507, 0.09163860231637955, -0.005569450091570616), vec3(-0.07021089643239975, 0.16530300676822662, -0.01946610026061535), vec3(-0.006184699945151806, 0.12272900342941284, 0.034786999225616455), vec3(0.0300137996673584, 0.09327860176563263, 0.042147599160671234), vec3(-0.01751290075480938, 0.16212600469589233, -0.014548899605870247), vec3(-0.07639770209789276, 0.17129099369049072, -0.041102100163698196), vec3(-0.08542270213365555, 0.10538599640130997, 0.00339486007578671), vec3(0.037043098360300064, 0.11044300347566605, 0.020722899585962296), vec3(-0.006597320083528757, 0.042728498578071594, 0.046939101070165634), vec3(0.006397940218448639, 0.04370059818029404, 0.04682600125670433), vec3(-0.05592469871044159, 0.15760600566864014, 0.0065645501017570496), vec3(-0.09114489704370499, 0.11881600320339203, 0.029844200238585472), vec3(-0.05951090157032013, 0.12835200130939484, 0.03996260091662407), vec3(-0.017633499577641487, 0.12760500609874725, 0.017936600372195244), vec3(-0.06663300096988678, 0.15383100509643555, 0.03087029978632927), vec3(-0.043641798198223114, 0.16943800449371338, -0.005502259824424982), vec3(-0.05727589875459671, 0.04324299842119217, 0.042862001806497574), vec3(-0.07637730240821838, 0.1572210043668747, -0.016888899728655815), vec3(-0.04344610124826431, 0.15604999661445618, 0.006157950032502413), vec3(-0.04271180182695389, 0.042164500802755356, 0.042700398713350296), vec3(-0.02542009949684143, 0.08866219967603683, 0.05038269981741905), vec3(-0.014178999699652195, 0.12626999616622925, 0.02664170041680336), vec3(-0.08825819939374924, 0.0898687019944191, 0.006966250017285347), vec3(-0.06886950135231018, 0.1577730029821396, -0.006875929888337851), vec3(-0.06796760112047195, 0.142876997590065, -0.007576430216431618), vec3(0.018853800371289253, 0.10629300028085709, 0.04169020056724548), vec3(-0.036486998200416565, 0.17122499644756317, 0.0005450369790196419), vec3(-0.06643520295619965, 0.11719799786806107, -0.009871610440313816), vec3(-0.06826060265302658, 0.17039799690246582, -0.04369949921965599), vec3(-0.09092500060796738, 0.14605000615119934, 0.01903820037841797), vec3(0.006786219775676727, 0.11584100127220154, 0.0388077013194561), vec3(0.03101390041410923, 0.09306959807872772, -0.01779799908399582), vec3(0.005697600077837706, 0.10588999837636948, 0.04355109855532646), vec3(-0.07065189629793167, 0.1306300014257431, 0.050249699503183365), vec3(0.005974600091576576, 0.13085800409317017, 0.005794790107756853), vec3(0.018421700224280357, 0.0423181988298893, 0.04247700050473213), vec3(0.014787600375711918, 0.09097470343112946, 0.0509658008813858), vec3(-0.005982319824397564, 0.1154090017080307, 0.04020269960165024), vec3(-0.08113119751214981, 0.1179720014333725, -0.0035945300478488207), vec3(-0.07870320230722427, 0.14427399635314941, -0.0038905199617147446), vec3(0.005819879937916994, 0.10622599720954895, -0.020896799862384796), vec3(-0.019276099279522896, 0.11985299736261368, 0.03280609846115112), vec3(-0.005931159947067499, 0.13021500408649445, 0.0059540001675486565), vec3(-0.0893322005867958, 0.1427450031042099, 0.029032599180936813), vec3(-0.00762538006529212, 0.12327300012111664, -0.009815550409257412), vec3(-0.06922630220651627, 0.17892199754714966, -0.0542742982506752), vec3(-0.029875699430704117, 0.12425199896097183, 0.020967399701476097), vec3(-0.08482660353183746, 0.14898699522018433, 0.03276969864964485), vec3(-0.08885160088539124, 0.09097229689359665, 0.01790340058505535), vec3(-0.030587900429964066, 0.12238399684429169, -0.006357709877192974), vec3(-0.030719799920916557, 0.11798900365829468, 0.030616600066423416), vec3(-0.07806120067834854, 0.12065300345420837, 0.05139990150928497), vec3(0.03327139839529991, 0.1084979996085167, -0.007431949954479933), vec3(-0.06771119683980942, 0.09289179742336273, -0.01688140071928501), vec3(-0.07566600292921066, 0.09118170291185379, -0.01369670033454895), vec3(-0.08242200314998627, 0.09511210024356842, 0.031087800860404968), vec3(-0.08569840341806412, 0.13690300285816193, 0.0019212199840694666), vec3(-0.029280399903655052, 0.041774701327085495, 0.05139699950814247), vec3(-0.01773199997842312, 0.04238640144467354, 0.051683999598026276), vec3(-0.06569869816303253, 0.17100700736045837, -0.056644000113010406), vec3(-0.029852300882339478, 0.1709049940109253, -0.01656089909374714), vec3(-0.05625019967556, 0.13501299917697906, 0.03304550051689148), vec3(-0.06661269813776016, 0.13302099704742432, 0.04470440000295639), vec3(-0.04253790155053139, 0.15544100105762482, -0.007493529934436083), vec3(-0.0545307993888855, 0.0714602991938591, 0.03970419988036156), vec3(-0.041315898299217224, 0.09069229662418365, -0.022588100284337997), vec3(-0.01728760078549385, 0.09217739850282669, 0.05362119898200035), vec3(-0.005981190130114555, 0.09403079748153687, 0.05426429957151413), vec3(0.04237240180373192, 0.06725630164146423, 0.029580099508166313), vec3(0.028574099764227867, 0.11690899729728699, -0.003917720168828964), vec3(-0.03318110108375549, 0.045074399560689926, 0.04511459916830063), vec3(-0.05394019931554794, 0.11856599897146225, 0.03537309914827347), vec3(0.04227240011096001, 0.07955460250377655, -0.005794609896838665), vec3(0.029727300629019737, 0.04255019873380661, 0.03049750067293644), vec3(-0.031563900411129, 0.09593310207128525, -0.023680100217461586), vec3(0.0381803996860981, 0.10512100160121918, 0.026694700121879578), vec3(-0.028498800471425056, 0.09049200266599655, -0.029085399582982063), vec3(-0.017318900674581528, 0.04379419982433319, 0.04326950013637543), vec3(0.003767539979889989, 0.04775509983301163, 0.05020369961857796), vec3(0.043267298489809036, 0.04582909867167473, 0.02782510034739971), vec3(-0.023332199081778526, 0.18123899400234222, -0.01128930039703846), vec3(-0.005625800229609013, 0.05650379881262779, 0.053881801664829254), vec3(0.005294309929013252, 0.055679801851511, 0.05328809842467308), vec3(-0.08832190185785294, 0.10575699806213379, 0.017298299819231033), vec3(-0.05663739889860153, 0.04701840132474899, 0.030580900609493256), vec3(-0.029624300077557564, 0.05431880056858063, 0.03989509865641594), vec3(-0.00597407016903162, 0.10589700192213058, 0.0440668985247612), vec3(-0.02141219936311245, 0.05469759926199913, 0.04464099928736687), vec3(-0.016148800030350685, 0.057436298578977585, 0.05090399831533432), vec3(-0.056830499321222305, 0.14639200270175934, -0.0026426000986248255), vec3(-0.09314659982919693, 0.1190669983625412, 0.017994800582528114), vec3(-0.061861999332904816, 0.1584170013666153, -0.029302600771188736), vec3(-0.08558580279350281, 0.10683999955654144, 0.0217289999127388), vec3(0.03366420045495033, 0.05405430123209953, 0.03508409857749939), vec3(0.042771000415086746, 0.05603510141372681, 0.03155900165438652), vec3(-0.04345890134572983, 0.11719100177288055, 0.03170439973473549), vec3(-0.06809619814157486, 0.15672099590301514, -0.042617399245500565), vec3(0.027238400653004646, 0.10315600037574768, 0.039705801755189896), vec3(-0.02939319983124733, 0.17853599786758423, -0.014556299895048141), vec3(-0.07626970112323761, 0.09122449904680252, 0.03834189847111702), vec3(-0.019128499552607536, 0.09859520196914673, 0.04566759988665581), vec3(-0.05309100076556206, 0.05674019828438759, 0.02939629927277565), vec3(-0.04319779947400093, 0.05557769909501076, 0.039083801209926605), vec3(-0.08330550044775009, 0.11564300209283829, 0.046828001737594604), vec3(0.01443449966609478, 0.1270810067653656, 0.02629699930548668), vec3(-0.038891300559043884, 0.12376099824905396, 0.024977799504995346), vec3(-0.059435900300741196, 0.1199050024151802, 0.0399755984544754), vec3(-0.07023320347070694, 0.1542620062828064, -0.031240100041031837), vec3(-0.05744729936122894, 0.1525759994983673, 0.028450800105929375), vec3(-0.048003800213336945, 0.056366000324487686, 0.036266300827264786), vec3(-0.01072620041668415, 0.17966200411319733, -0.027747200801968575), vec3(-0.08822929859161377, 0.10606600344181061, 0.008467559702694416), vec3(-0.07899399846792221, 0.15398399531841278, 0.006518620066344738), vec3(-0.029567500576376915, 0.1260720044374466, 0.014633799903094769), vec3(-0.08173560351133347, 0.15439000725746155, 0.017733199521899223), vec3(-0.07954689860343933, 0.10419400036334991, -0.006202740129083395), vec3(-0.024860799312591553, 0.12291300296783447, 0.024542899802327156), vec3(-0.0664416030049324, 0.15995700657367706, -0.05337129905819893), vec3(-0.07848779857158661, 0.0705282986164093, 0.01744610071182251), vec3(-0.009671010076999664, 0.17322500050067902, -0.026494499295949936), vec3(-0.05662839859724045, 0.05470310151576996, 0.0074456301517784595), vec3(-0.018401499837636948, 0.12221899628639221, -0.0077513400465250015), vec3(-0.06959520280361176, 0.14641200006008148, -0.018031999468803406), vec3(-0.04125170037150383, 0.12319599837064743, -0.009580870158970356), vec3(-0.0684972032904625, 0.14819400012493134, -0.0287260003387928), vec3(-0.054003600031137466, 0.05554300174117088, 0.017767399549484253), vec3(-0.01692030020058155, 0.06821680068969727, 0.05314990133047104), vec3(-0.006072210147976875, 0.06771019846200943, 0.056450098752975464), vec3(0.0070872800424695015, 0.06732179969549179, 0.05533690005540848), vec3(-0.014317399822175503, 0.11697100102901459, 0.03783600032329559), vec3(0.05389229953289032, 0.05575469881296158, 0.026624400168657303), vec3(0.005178549792617559, 0.0931738018989563, 0.05358729884028435), vec3(-0.04310379922389984, 0.06743880361318588, 0.040773700922727585), vec3(-0.02930689975619316, 0.06807330250740051, 0.041016001254320145), vec3(-0.037955500185489655, 0.16195400059223175, -0.01280209980905056), vec3(-0.0561164990067482, 0.06543289870023727, 0.03419790044426918), vec3(-0.07617069780826569, 0.1555590033531189, -0.005927199963480234), vec3(-0.05521810054779053, 0.12250600010156631, -0.00946488045156002), vec3(0.017700400203466415, 0.10598299652338028, -0.018613800406455994), vec3(0.05345829948782921, 0.0656374990940094, 0.02643360011279583), vec3(-0.08691520243883133, 0.09441559761762619, 0.0029311799444258213), vec3(-0.076425701379776, 0.16170699894428253, -0.029751699417829514), vec3(-0.044095899909734726, 0.1274529993534088, -0.003278749994933605), vec3(-0.0312918983399868, 0.07982979714870453, 0.04349439963698387), vec3(-0.05494479835033417, 0.10634800046682358, -0.018562499433755875), vec3(-0.07237350195646286, 0.11005699634552002, -0.009432570077478886), vec3(-0.055365901440382004, 0.091982901096344, -0.02117829956114292), vec3(-0.048809099942445755, 0.06601270288228989, 0.0373958982527256), vec3(-0.047308601438999176, 0.14515599608421326, 0.006884689908474684), vec3(-0.0803913027048111, 0.12963399291038513, -0.0046975500881671906), vec3(-0.041802000254392624, 0.10593400150537491, -0.019869200885295868), vec3(-0.00632139015942812, 0.09316519647836685, -0.032893501222133636), vec3(-0.00597053999081254, 0.10613799840211868, -0.022228199988603592), vec3(-0.029482699930667877, 0.1582929939031601, -0.006192659959197044), vec3(-0.017795300111174583, 0.10628899931907654, -0.02177710086107254), vec3(-0.08852609992027283, 0.13783900439739227, 0.03939640149474144), vec3(-0.0674934983253479, 0.12839199602603912, -0.008634709753096104), vec3(0.04636929929256439, 0.07151280343532562, 0.02167540043592453), vec3(-0.04095650091767311, 0.11716800183057785, -0.014580899849534035), vec3(-0.010665600188076496, 0.1675409972667694, -0.019901299849152565), vec3(-0.05325470119714737, 0.15745599567890167, -0.0028189599979668856), vec3(0.005309879779815674, 0.09331289678812027, -0.03018520027399063), vec3(-0.07734359800815582, 0.07272259891033173, 0.026654599234461784), vec3(-0.06250870227813721, 0.14993399381637573, -0.015031900256872177), vec3(-0.0688014030456543, 0.06857260316610336, 0.030664900317788124), vec3(-0.05452520027756691, 0.08084779977798462, -0.020170699805021286), vec3(-0.04367680102586746, 0.07891599833965302, 0.04288550093770027), vec3(-0.018574800342321396, 0.0789702981710434, 0.05573530122637749), vec3(-0.005999930202960968, 0.07945480197668076, 0.05780079960823059), vec3(0.007064850069582462, 0.08119170367717743, 0.055818699300289154), vec3(-0.08502689749002457, 0.14603400230407715, 0.005859539844095707), vec3(0.037011101841926575, 0.11039700359106064, 0.002652940107509494), vec3(-0.06830839812755585, 0.08033160120248795, 0.040710899978876114), vec3(-0.055893998593091965, 0.07925940304994583, 0.04353350028395653), vec3(0.038145601749420166, 0.08810559660196304, -0.013867500238120556), vec3(-0.06428369879722595, 0.03964180126786232, 0.03962400183081627), vec3(-0.06986960023641586, 0.1685360074043274, -0.031331900507211685), vec3(-0.061795998364686966, 0.15574100613594055, -0.020792299881577492), vec3(-0.06228480115532875, 0.16235999763011932, -0.03962880000472069), vec3(-0.06868640333414078, 0.0923703983426094, 0.04219780117273331), vec3(-0.04935299977660179, 0.13929800689220428, 0.014795499853789806), vec3(-0.07841770350933075, 0.11012600362300873, 0.041788600385189056), vec3(0.01794159971177578, 0.07927469909191132, 0.05188620090484619), vec3(0.005327320192009211, 0.12366099655628204, -0.00997104961425066), vec3(-0.055677399039268494, 0.09352059662342072, 0.044206999242305756), vec3(-0.04319240152835846, 0.09211540222167969, 0.043268900364637375), vec3(-0.029862599447369576, 0.09401240199804306, 0.044480498880147934), vec3(0.020595500245690346, 0.08711300045251846, 0.04923250153660774), vec3(0.01720999926328659, 0.1276630014181137, 0.005125930067151785), vec3(-0.029012499377131462, 0.1067190021276474, -0.020747900009155273), vec3(0.01854429952800274, 0.09481120109558105, 0.04775869846343994), vec3(-0.005886760074645281, 0.11662200093269348, -0.0160048995167017), vec3(-0.05281909927725792, 0.162649005651474, 0.002967109903693199), vec3(0.03580779954791069, 0.09585940092802048, -0.012032800354063511), vec3(-0.09120640158653259, 0.131414994597435, 0.02953070029616356), vec3(-0.0678739994764328, 0.1069519966840744, 0.04037249833345413), vec3(-0.044163599610328674, 0.10491800308227539, 0.04017059877514839), vec3(0.007495860103517771, 0.09835000336170197, 0.048825498670339584), vec3(-0.05549610033631325, 0.10389800369739532, 0.04114050045609474), vec3(-0.06690440326929092, 0.11571700125932693, 0.04734789952635765), vec3(-0.05015239864587784, 0.14032599329948425, 0.0025881798937916756), vec3(-0.05545080080628395, 0.13242000341415405, -0.00485445000231266), vec3(-0.014751999638974667, 0.18189699947834015, -0.026278100907802582), vec3(-0.029557999223470688, 0.16178299486637115, -0.014336800202727318), vec3(-0.05618539825081825, 0.11127699911594391, 0.03737130016088486), vec3(-0.04098400101065636, 0.11049599945545197, 0.0370883010327816), vec3(-0.03200550004839897, 0.11046800017356873, 0.037043798714876175), vec3(0.025003299117088318, 0.11061099916696548, 0.03684590011835098), vec3(-0.04698700085282326, 0.14743399620056152, -0.0022253599017858505), vec3(-0.01834069937467575, 0.03523619845509529, 0.05079380050301552), vec3(-0.01784059964120388, 0.1704840064048767, -0.018114300444722176), vec3(-0.05694720149040222, 0.034941598773002625, 0.04237170144915581), vec3(0.0058333901688456535, 0.035107601433992386, 0.04209139943122864), vec3(-0.04280240088701248, 0.035157401114702225, 0.04168720170855522), vec3(-0.06646200269460678, 0.10477700084447861, -0.014858200214803219), vec3(0.025745199993252754, 0.0459137000143528, 0.038118500262498856), vec3(0.03794509917497635, 0.08171670138835907, -0.014154699631035328), vec3(-0.08442620187997818, 0.07977139949798584, 0.018633199855685234), vec3(0.053250398486852646, 0.047589998692274094, 0.018190300092101097), vec3(0.018642399460077286, 0.05360350012779236, 0.0462150014936924), vec3(0.0073251500725746155, 0.11824300140142441, -0.01530119962990284), vec3(-0.0314703993499279, 0.1570660024881363, 0.0009762159897945821), vec3(0.02862289920449257, 0.05687600001692772, 0.040763501077890396), vec3(0.058159101754426956, 0.055001601576805115, 0.01802540011703968), vec3(0.016863999888300896, 0.08993499726057053, -0.02691040001809597), vec3(0.014577800408005714, 0.05857690051198006, 0.05016909912228584), vec3(0.03672479838132858, 0.09181839972734451, 0.03662480041384697), vec3(-0.019880099222064018, 0.16640399396419525, -0.011269900016486645), vec3(0.015029399655759335, 0.0677357017993927, 0.0520671010017395), vec3(0.021052399650216103, 0.06811609864234924, 0.04843460023403168), vec3(0.029877599328756332, 0.06799360364675522, 0.04191720113158226), vec3(0.03683580085635185, 0.06784950196743011, 0.03664100170135498), vec3(0.05747479945421219, 0.0682218000292778, 0.01714250072836876), vec3(0.03168420121073723, 0.07850869745016098, -0.019207999110221863), vec3(-0.07602710276842117, 0.1757040023803711, -0.05069369822740555), vec3(-0.06553959846496582, 0.06078850105404854, 0.017570700496435165), vec3(-0.08060260117053986, 0.08144699782133102, 0.030651599168777466), vec3(0.018974900245666504, 0.12150599807500839, -0.006945650093257427), vec3(0.03068399988114834, 0.07954610139131546, 0.04315070062875748), vec3(0.03718879818916321, 0.07924839854240417, 0.036793701350688934), vec3(0.04193659871816635, 0.07959110289812088, 0.02959110029041767), vec3(0.046032000333070755, 0.07936940342187881, 0.017769400030374527), vec3(-0.07879210263490677, 0.0707772970199585, 0.0068558501079678535), vec3(-0.02939870022237301, 0.11591699719429016, -0.014706499874591827), vec3(-0.08699239790439606, 0.11351799964904785, 0.0041040899232029915), vec3(-0.014218599535524845, 0.17401300370693207, -0.025980699807405472), vec3(0.01747949980199337, 0.03521310165524483, -0.00592856016010046), vec3(0.016214100643992424, 0.0358474999666214, -0.016213100403547287), vec3(0.01932479999959469, 0.035832200199365616, 0.03132060170173645), vec3(0.0435543991625309, 0.041110098361968994, 0.005799159873276949), vec3(0.022619100287556648, 0.040605198591947556, -0.00793544016778469), vec3(0.019134800881147385, 0.042782001197338104, -0.019209500402212143), vec3(0.041463300585746765, 0.04563010111451149, -0.003545129904523492), vec3(0.04369249939918518, 0.0411968007683754, 0.017720000818371773), vec3(0.051287200301885605, 0.04639590159058571, 0.005805309861898422), vec3(0.02857770025730133, 0.1051810011267662, -0.014238099567592144), vec3(0.030674800276756287, 0.04451239854097366, -0.006179930176585913), vec3(-0.018411800265312195, 0.09480589628219604, -0.030743399634957314), vec3(-0.0315483994781971, 0.034302301704883575, -0.028408100828528404), vec3(0.026038099080324173, 0.04759019985795021, -0.01657940074801445), vec3(0.05541969835758209, 0.06863780319690704, 0.0058965301141142845), vec3(0.052037399262189865, 0.055073000490665436, -0.002481600036844611), vec3(0.0567375011742115, 0.05422240123152733, 0.005124830175191164), vec3(0.04280490055680275, 0.055328600108623505, -0.006047040224075317), vec3(-0.06200369819998741, 0.16742199659347534, -0.05271650105714798), vec3(0.034112799912691116, 0.054177600890398026, -0.0094834603369236), vec3(0.029518000781536102, 0.05605639889836311, -0.01758749969303608), vec3(-0.017788700759410858, 0.11591099947690964, -0.015783799812197685), vec3(-0.04178379848599434, 0.03576020151376724, -0.026410700753331184), vec3(-0.005189389921724796, 0.043046001344919205, -0.027333300560712814), vec3(-0.06640589982271194, 0.03436490148305893, -0.004166679922491312), vec3(0.04754139855504036, 0.07121740281581879, 0.005426169838756323), vec3(0.02491380088031292, 0.08251629769802094, -0.02458770014345646), vec3(-0.029902400448918343, 0.04260310158133507, -0.028317900374531746), vec3(0.02181209996342659, 0.05158650130033493, -0.023649200797080994), vec3(-0.027153700590133667, 0.03516079857945442, 0.05092670023441315), vec3(0.01611809991300106, 0.11563000082969666, -0.014545099809765816), vec3(0.031738001853227615, 0.06799829751253128, -0.01835319958627224), vec3(0.04182260110974312, 0.06752009689807892, -0.005515549797564745), vec3(0.05148709937930107, 0.06372790038585663, -0.0017479399684816599), vec3(-0.08933030068874359, 0.1283089965581894, 0.04280230030417442), vec3(0.04593849927186966, 0.07963070273399353, 0.005796319805085659), vec3(-0.07054329663515091, 0.1498969942331314, -0.038731899112463), vec3(-0.04296170175075531, 0.043024200946092606, -0.017628800123929977), vec3(-0.0719676986336708, 0.1778479963541031, -0.0474603995680809), vec3(-0.07605289667844772, 0.17765100300312042, -0.047145698219537735), vec3(0.030417300760746002, 0.11849500238895416, 0.00573814008384943), vec3(-0.07714509963989258, 0.16770599782466888, -0.029879799112677574), vec3(0.02026679925620556, 0.09286099672317505, -0.023736299946904182), vec3(-0.02548149973154068, 0.07986970245838165, 0.05105460062623024), vec3(-0.06505409628152847, 0.035325899720191956, 0.01622370071709156), vec3(-0.06476759910583496, 0.03507919982075691, 0.029448099434375763), vec3(-0.06442669779062271, 0.0414590984582901, 0.030447600409388542), vec3(-0.06431999802589417, 0.03522609919309616, 0.03879139944911003), vec3(-0.06759999692440033, 0.03402990102767944, 0.005904910154640675), vec3(-0.06795340031385422, 0.04185879975557327, 0.006683940067887306), vec3(-0.05734970048069954, 0.043154798448085785, 0.02002290077507496), vec3(-0.06346320360898972, 0.04143210127949715, 0.014205199666321278), vec3(-0.05941300094127655, 0.04713819921016693, 0.006285380106419325), vec3(-0.023383399471640587, 0.06564159691333771, 0.04509760066866875), vec3(-0.06353799998760223, 0.07166499644517899, 0.037946298718452454), vec3(-0.01930359937250614, 0.0810128003358841, -0.0384318009018898), vec3(-0.042720600962638855, 0.03435570001602173, -0.019130200147628784), vec3(-0.006902370136231184, 0.03463999927043915, -0.02021710015833378), vec3(-0.06567870080471039, 0.04083320125937462, -0.004017930012196302), vec3(-0.03839069977402687, 0.04192179813981056, -0.026403900235891342), vec3(-0.055658500641584396, 0.04328659921884537, -0.0075883399695158005), vec3(-0.041678499430418015, 0.04202760010957718, -0.009996790438890457), vec3(-0.03222940117120743, 0.04465930163860321, -0.016749899834394455), vec3(-0.030738500878214836, 0.05633069947361946, -0.01851700060069561), vec3(-0.04290260002017021, 0.056189700961112976, -0.011304300278425217), vec3(-0.05502849817276001, 0.056655701249837875, -0.0053137498907744884), vec3(-0.02618579939007759, 0.05688359960913658, -0.02826940082013607), vec3(-0.0552189014852047, 0.11746100336313248, -0.013374400325119495), vec3(-0.019065799191594124, 0.05466949939727783, -0.03186459839344025), vec3(-0.0687628984451294, 0.0686694011092186, -0.006549410056322813), vec3(-0.07305040210485458, 0.065420001745224, 0.005528590176254511), vec3(-0.02072340063750744, 0.06727930158376694, -0.036552999168634415), vec3(-0.029079200699925423, 0.06742600351572037, -0.029052099213004112), vec3(-0.03280559927225113, 0.06646370142698288, -0.019521500915288925), vec3(-0.017760800197720528, 0.034331899136304855, -0.025914199650287628), vec3(-0.07736869901418686, 0.07325710356235504, -0.004097709897905588), vec3(0.015161599963903427, 0.12610399723052979, -0.0026639499701559544), vec3(-0.08452550321817398, 0.08005719631910324, 0.005307020153850317), vec3(-0.07935170084238052, 0.07985589653253555, -0.006405650172382593), vec3(-0.0309727992862463, 0.07947009801864624, -0.031247500330209732), vec3(-0.03551439940929413, 0.08180099725723267, -0.022688699886202812), vec3(-0.06814099848270416, 0.0801227018237114, -0.016427800059318542), vec3(-0.05129320174455643, 0.034226998686790466, -0.012901299633085728), vec3(0.016192400828003883, 0.08047900348901749, -0.029217399656772614), vec3(-0.014447799883782864, 0.08792740106582642, -0.03802970051765442), vec3(-0.01731570065021515, 0.043267399072647095, -0.028290599584579468), vec3(-0.019332800060510635, 0.0979250967502594, -0.024792000651359558), vec3(-0.05554790049791336, 0.03368160128593445, -0.006190130021423101), vec3(0.007026270031929016, 0.09784179925918579, -0.02460549958050251), vec3(-0.01488920021802187, 0.12606799602508545, -0.002521259943023324), vec3(0.017520500347018242, 0.055211398750543594, -0.027275599539279938), vec3(-0.00953660998493433, 0.07941039651632309, -0.037985898554325104), vec3(0.00524266017600894, 0.039133600890636444, -0.021947000175714493), vec3(0.017565300688147545, 0.06793390214443207, -0.02893880009651184), vec3(-0.005790700204670429, 0.12807700037956238, -0.002851050114259124), vec3(0.006265560165047646, 0.12804700434207916, -0.0031705000437796116), vec3(0.005599789787083864, 0.034660398960113525, -0.017931800335645676), vec3(0.029823999851942062, 0.03591420128941536, 0.004889769945293665), vec3(0.006251929793506861, 0.04596230015158653, -0.026378199458122253), vec3(0.014325300231575966, 0.047348398715257645, -0.025151299312710762), vec3(0.006040859967470169, 0.055507298558950424, -0.03043139912188053), vec3(-0.00613413006067276, 0.05463720113039017, -0.032634999603033066), vec3(-0.03466939926147461, 0.057124000042676926, -0.011495299637317657), vec3(-0.006845430005341768, 0.06797420233488083, -0.03594059869647026), vec3(0.005655799992382526, 0.06762369722127914, -0.03291989862918854), vec3(-0.05697320029139519, 0.06516280025243759, -0.009582189843058586), vec3(-0.042279601097106934, 0.06999439746141434, -0.016146300360560417), vec3(-0.01757190003991127, 0.07054729759693146, -0.03822610154747963), vec3(-0.05558599904179573, 0.07229830324649811, -0.016121799126267433), vec3(-0.06378839910030365, 0.0712696984410286, -0.013853499665856361), vec3(0.005685610231012106, 0.07905469834804535, -0.033918898552656174), vec3(-0.0033842900302261114, 0.080451101064682, -0.03672260046005249), vec3(-0.024898799136281013, 0.08150040358304977, -0.03710779920220375), vec3(-0.041251301765441895, 0.07913780212402344, -0.019774600863456726), vec3(-0.07358189672231674, 0.077702596783638, -0.012202300131320953), vec3(-0.01806199923157692, 0.03526270017027855, -0.019540099427103996), vec3(-0.03157699853181839, 0.035848699510097504, -0.017966900020837784), vec3(-0.006020340137183666, 0.03812370076775551, -0.014518399722874165), vec3(-0.017781099304556847, 0.03825460001826286, -0.015450299717485905), vec3(0.007534469943493605, 0.03555959835648537, -0.006500630173832178), vec3(0.0043043699115514755, 0.03840170055627823, -0.007175399921834469), vec3(-0.005939349997788668, 0.038947999477386475, -0.005921289790421724), vec3(-0.017614200711250305, 0.038605500012636185, -0.005845080129802227), vec3(-0.04303079843521118, 0.03413910046219826, -0.005659719929099083), vec3(0.018922200426459312, 0.035107601433992386, 0.004997690208256245), vec3(-0.029912900179624557, 0.038391198962926865, -0.005826769862323999), vec3(0.005120660178363323, 0.034839801490306854, 0.005584979895502329), vec3(0.0010352799436077476, 0.03759169951081276, 0.0009522219770587981), vec3(-0.0058471402153372765, 0.03834189847111702, 0.0059080300852656364), vec3(-0.042462099343538284, 0.03431440144777298, 0.005905969999730587), vec3(-0.017873000353574753, 0.038316600024700165, 0.005994710139930248), vec3(0.028661999851465225, 0.03584109991788864, 0.018749600276350975), vec3(-0.05502599850296974, 0.03362039849162102, 0.005838159937411547), vec3(-0.028473300859332085, 0.038148898631334305, 0.004418530035763979), vec3(-0.0009470059885643423, 0.03573739901185036, 0.01034689974039793), vec3(0.01932240091264248, 0.035181399434804916, 0.01966159977018833), vec3(-0.034232500940561295, 0.03375900164246559, 0.007175169885158539), vec3(0.005360220093280077, 0.03459560126066208, 0.017987100407481194), vec3(-0.0003857139963656664, 0.03514590114355087, 0.013417099602520466), vec3(0.0334119014441967, 0.03761789947748184, 0.021008199080824852), vec3(-0.005897909868508577, 0.038178201764822006, 0.01770620048046112), vec3(-0.035244498401880264, 0.035057101398706436, 0.017825700342655182), vec3(-0.017807800322771072, 0.038196198642253876, 0.017811400815844536), vec3(-0.02618980035185814, 0.0377591997385025, 0.017704399302601814), vec3(-0.05632470175623894, 0.03367619961500168, 0.017526499927043915), vec3(0.001141140004619956, 0.037661001086235046, 0.022341400384902954), vec3(0.010025300085544586, 0.035502899438142776, 0.029656000435352325), vec3(0.005501269828528166, 0.03855559974908829, 0.029660899192094803), vec3(-0.005965809803456068, 0.03889460116624832, 0.02992519922554493), vec3(-0.03307449817657471, 0.035521700978279114, 0.029223600402474403), vec3(-0.02777170017361641, 0.03825629875063896, 0.032286498695611954), vec3(-0.017909100279211998, 0.0385902002453804, 0.0296167004853487), vec3(-0.04194039851427078, 0.03436980023980141, 0.029966799542307854), vec3(0.015243000350892544, 0.0356115996837616, 0.041269201785326004), vec3(-0.0554300993680954, 0.034255500882864, 0.029795199632644653), vec3(-0.06605149805545807, 0.06111440062522888, 0.005855480208992958), vec3(-0.00654911994934082, 0.03503720089793205, 0.045395899564027786), vec3(-0.030782600864768028, 0.03475959971547127, 0.04329590126872063), vec3(-0.018083399161696434, 0.034814201295375824, 0.04587719962000847) \n        );\nconst int N = 948;\nconst int[N] triangles =\n  int[N] (102856868, 51723488, 394623307, 248637564, 72442941, 98731069, 52519960, 36725869, 159418395, 456584636, 160468062, 72414211, 93393944, 109275174, 40937494, 35676174, 389191970, 234959074, 75699404, 14683218, 24200205, 24130659, 31569943, 31459438, 389293222, 3208282, 52453410, 217226533, 89208912, 172062781, 84129876, 64128004, 67261572, 239098052, 253802555, 83972275, 389120265, 217319476, 147979385, 362979671, 230919400, 238275816, 255056104, 58849337, 132253753, 230924509, 94434308, 89211014, 183723184, 168820740, 52450382, 135399550, 135395384, 210950255, 389093472, 102928473, 57677947, 75586757, 432442784, 187777269, 37828629, 93491261, 67244099, 138564758, 341183872, 117667030, 243508438, 243488989, 243521780, 243519721, 258207988, 124927220, 125030652, 147994751, 138565699, 3237970, 224579696, 150205684, 282272879, 66136101, 70408325, 70390902, 157470853, 188963007, 188939445, 244558015, 244514006, 244568298, 255859946, 265390324, 150046973, 120808664, 139645109, 229654543, 255953150, 256112647, 66071626, 25168910, 25236483, 183722201, 52508757, 83966025, 266438663, 123868265, 205774849, 105104432, 41054250, 360887445, 110236807, 110238826, 245373983, 245398676, 7440473, 7431199, 241258731, 247491598, 141685866, 65032211, 166779011, 22071330, 247478354, 45142217, 293916982, 56786051, 293918991, 35665947, 32597169, 83961070, 183681154, 399846754, 183634049, 141697149, 210817275, 131129450, 142738488, 142663805, 182631553, 182584456, 225665199, 225623214, 225560691, 225561816, 32593030, 32687189, 185689138, 185649237, 256983219, 385244560, 126962951, 120769753, 67244181, 121826482, 121817230, 334618950, 280054841, 308682032, 376801635, 11564160, 136594699, 10502192, 279230765, 23136452, 227627238, 254817527, 13714542, 279103759, 259011694, 280253718, 344991792, 288369922, 239276033, 255057050, 259111066, 283260167, 115404954, 115501116, 115404954, 38873099, 53482770, 254961916, 255062135, 63027309, 115345447, 115383405, 30539808, 11665440, 326414645, 161602812, 267535433, 271646787, 134247456, 45370626, 63036570, 63026295, 260309129, 87305486, 88324331, 59902219, 11567362, 284481838, 246659123, 284473610, 267423749, 241413171, 76694579, 241224990, 300173599, 114320503, 303079434, 345030776, 299945234, 227776788, 15745034, 152048691, 210775083, 227823792, 124806287, 175324318, 374670696, 289686658, 248715386, 280254734, 40069197, 41949199, 186838296, 186933519, 33766658, 23128130, 291798295, 180497563, 275919993, 287352096, 287605023, 136495380, 215253281, 5285138, 292846880, 303049033, 229740560, 149080191, 289680657, 254926076, 148135028, 5368873, 292847732, 147968142, 33716431, 241456404, 171022437, 308586795, 291797279, 152304645, 73563267, 45100307, 262305824, 121929933, 81825865, 334832760, 314973481, 227724372, 39924753, 76583167, 87308551, 1302777, 290691358, 69243915, 270585899, 289690891, 283400471, 283401357, 249635891, 5279791, 282134729, 69217481, 316987701, 316986668, 263226550, 290748694, 264493299, 439791008, 73534560, 116654146, 198523969, 427153521, 162671760, 145981666, 415646054, 212954142, 151137506, 254091310, 312787251, 56785990, 298067047, 467932603, 29399057, 250814552, 221423688, 29377674, 239076387, 308587815, 146934802, 137423890, 54790351, 56694972, 206658664, 125878494, 326441285, 126117190, 306347062, 309636482, 17886346, 16879664, 18073659, 87156008, 41958410, 17919218, 221258977, 402983226, 294982982, 221480106, 80833553, 237056144, 235938971, 29494431, 178400428, 29501571, 126099737, 126056712, 236088459, 178488459, 328537402, 409247106, 29523236, 360862852, 436645288, 68500529, 319087930, 69481583, 75570185, 75506899, 370471218, 319088947, 328523077, 302031912, 302031137, 42997800, 43117574, 114334742, 80011429, 312790315, 79860880, 79801656, 347469176, 327265445, 346206363, 23302179, 167960621, 163641386, 65051650, 23111738, 9509937, 196202776, 121845016, 151333019, 215254296, 323248447, 21050530, 95499284, 293897545, 293938495, 40958108, 393634164, 1214, 35841, 65031210, 164899, 101712062, 114317347, 234935372, 98602145, 162538545, 162579680, 11598877, 20088992, 55915596, 149972121, 68207687, 31477762, 2117694, 5251127, 4194473, 57679878, 160457763, 170092704, 169948378, 6633487, 6299982, 97595724, 5291016, 150103138, 102917214, 16070875, 80033100, 112275549, 229980260, 47205536, 21137427, 360845652, 44059693, 8436763, 49319963, 187812944, 60860461, 47374407, 8416492, 8630606, 349271372, 37904411, 356581599, 123025644, 37770392, 120737926, 119689331, 22055064, 57797637, 200347985, 295793997, 205588736, 364034183, 204656823, 247755893, 66174134, 369424738, 71542898, 193004615, 182591623, 353590463, 119758161, 190874687, 189930629, 190147719, 84958318, 192073885, 192050325, 230837475, 31480844, 48336023, 200498350, 48570467, 245518450, 164780181, 297946332, 352512079, 200517700, 373659020, 12606563, 12684616, 71420241, 415603044, 358964562, 355815647, 100769033, 355695957, 200456539, 211020982, 84003974, 212891660, 354770265, 108235923, 263303201, 95440991, 200633525, 360016217, 188897437, 19106919, 61063234, 363159897, 113279122, 465696189, 95517726, 392549500, 75752585, 354772312, 362979672, 344140812, 108154140, 38865136, 176338264, 338035002, 97806443, 112251980, 295752811, 349230362, 112275621, 305342779, 79839397, 385210775, 79746192, 96867716, 346177691, 55804048, 455523760, 151188635, 235074704, 55917757, 55768288, 33584274, 219242878, 367325515, 331711819, 384154981, 384144744, 391502191, 391495022, 392584565, 177303940, 162596010, 198247579, 95628616, 434541981, 375729508, 95756530, 363158696, 128129137, 128042108, 330506479, 374706507, 106981748, 107336055, 107121690, 393597336, 68246600, 68231338, 68345943, 11644991, 113275967, 242513266, 242600325, 146819203, 113310753, 336906608, 130139510, 281350429, 281310439, 195314000, 145911008, 390448491, 171115606, 116456656, 212125052, 336958820, 369461594, 371368282, 371563688, 387221868, 387297643, 390450466, 390367601, 27335027, 27643252, 27455558, 27318460, 27429942, 171006006, 90206262, 90216476, 90379302, 206676006, 91449448, 91390170, 91414688, 218349626, 66098416, 66306256, 138477908, 362979671, 374717840, 374751628, 29659190, 18979936, 359833946, 260187385, 208880840, 294877263, 324325703, 369453399, 177607039, 219242696, 339929373, 82886897, 82939920, 82940207, 473015619, 195345508, 82853988, 347440449, 388265196, 96705925, 122975332, 11598956, 83147962, 219543640, 408137810, 83084388, 74522669, 101884928, 75637805, 195137821, 60863625, 320202951, 60957904, 374680932, 212201777, 320173434, 330395817, 78911680, 78840169, 248719651, 217355522, 395394320, 281209156, 92465420, 407245914, 305458345, 305308769, 395640911, 177601540, 386200955, 330508488, 330546268, 336954674, 247862642, 83064880, 194356430, 194197865, 250846300, 347407716, 194161854, 194181369, 378738894, 378732742, 402002010, 248639793, 342154567, 401696772, 1303742, 194356430, 194197675, 248825034, 153121900, 324327732, 122786126, 407980122, 195379279, 351327456, 333837666, 250884327, 219431098, 219342936, 212016328, 334829895, 334830900, 343203125, 468118963, 212124871, 199404641, 216106155, 216304737, 216209645, 216249635, 319943062, 419842447, 427153781, 326418732, 326427952, 118707607, 268549328, 418793875, 418794859, 33685533, 421911955, 376847723, 207814850, 78731457, 426988944, 83181840, 335832143, 311736620, 319072550, 329582891, 329559347, 329646402, 341075321, 341173635, 335930649, 347445603, 274831461, 422960491, 78852293, 274830438, 338034987, 202542342, 369450302, 402983211, 338044203, 403055938, 268648585, 78845014, 352402618, 294920414, 79013049, 384147821, 412492162, 412485931, 403054985, 403057032, 406206858, 406202752, 406185364, 406213006, 395527572, 395591889, 375800207, 375799143, 274893925, 78841094, 393319526, 261169356, 140660767, 448189864, 372611431, 223758736, 194241740, 405075295, 405110150, 405152061, 413463944, 413543741, 417740171, 417738122, 424039821, 424031630, 423838919, 423828885, 250700044, 194195531, 371556670, 238045427, 425067917, 424877441, 203620614, 203692133, 100797458, 209054045, 209024385, 175274234, 175368485, 414558587, 414575933, 416655755, 416658794, 416695661, 404059537, 404112781, 223545719, 118687957, 203527543, 333807970, 333798742, 421746039, 464786883, 307488800, 307265794, 207816817, 386295135, 371535203, 361058643, 381017460, 354771283, 397739376, 397781352, 379958632, 379958638, 379959661, 420836758, 420895085, 54790252, 33665282, 426079537, 315930921, 113503284, 397779265, 329586048, 383146357, 383112558, 426079605, 426104157, 425849205, 338797674, 452381111, 240372754, 272688211, 272715199, 450274722, 455534007, 455535033, 338798849, 438740359, 466015667, 474287361, 308709767, 462872872, 462725560, 144764035, 309753126, 21002335, 455524780, 435593638, 433492262, 450142633, 435591582, 310502825, 452387112, 473238980, 468798760, 460776879, 457634237, 452239789, 111206850, 454157613, 474219626, 431390110, 405173638, 62100498, 48469051, 431389058, 446088493, 205783288, 432439707, 319167788, 445043110, 158569518, 315745407, 373722524, 409367847, 431364447, 131129786, 432373145, 13880567, 162705738, 70375875, 304132460, 174108962, 278087846, 298010889, 455528890, 158436581, 46597484, 46427585, 308711842, 382141803, 220491988, 174278700, 442937764, 220418092, 255038711, 104062181, 186919039, 273090616, 441880989, 380805479, 470983019, 436642207, 273087784, 298021076, 445044148, 432434527, 452388280, 46354715, 273747395, 470987944, 296924609, 333797802, 333883773, 231043284, 315751690, 358959530, 181693589, 296964245, 447039926, 445769137, 222485653, 442930590, 162703532, 368375152, 394655070, 273943619, 222412983, 365019348, 230801756, 455523760, 354766272, 354877878, 453426596, 230913136, 453415340, 455524783, 367392161, 455520678, 399944103, 399941025, 60035128, 123839939, 461639976, 434533762, 331708722, 355816896, 431391135, 458682804, 470111491, 410428713, 466744762, 474065346, 321223066, 234098005, 367428963, 367365530, 233898243, 367366554, 367421796, 430280036, 437685603, 103822583, 192004291, 204587188, 373656995, 311862573, 431360390, 470027710, 271848894, 442945970, 442929573, 321284505, 321283440, 430281116, 430338457, 457635258, 451321267);\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1060, 1060, 1090, 1090, 1135], [1137, 1137, 1161, 1161, 1475], [1477, 1477, 1528, 1528, 2326]], "test": "untested"}
{"id": "3tdfD2", "name": "大龙猫 - Vortex", "author": "totetmatt", "description": "React better on Bonzo, especially the fft part", "tags": ["tunnel", "music", "rainbow"], "likes": 10, "viewed": 562, "published": 3, "date": "1613507942", "time_retrieved": "2024-07-30T19:37:38.381078", "image_code": "\n#define PI 3.141592\nmat2 rot(float a){\n  float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n  }\n  \n   \n    \nfloat stargate(vec2 uv,float offset)\n{\n\n  vec2 uuv = uv;\n  uuv*=rot(offset*23.);\n  float c = sin(atan(uuv.x,uuv.y))*.5+.5;\n\tfloat f = texture(iChannel0,vec2(abs(floor(20.*c)/20.))).r*exp(1.+c)*.10;\n  \n  float d = abs(length(uv)-(.4+f*1.5))-.04;\n\n   return d;  \n  }\n  \n  vec3 pal(float t){\n    return +vec3(.5,.7,.5)+vec3(.5,.7,.5)*cos(2.*PI*(vec3(1.,10.1,1.)*t+vec3(.3,.0,.7)));\n    \n    }\n    \n    float grid(vec2 uv){\n      return abs(fract(uv.x*10.))<.02 || abs(fract(uv.y*10.))<.02  ? 1.: 0.;\n      }\n      \n      \n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n float tt = texture(iChannel0,vec2(.3,uv.y)).r*.1;\n\n  float d = 1.;      \n  float lim = 10.;\n  vec3 col  = vec3(0.);\n  for(float i=0.;i<=lim;++i){\n         float it = i/lim;\n       \n          float pit = fract(it+iTime*.1);\n           float qq = tt*25. > pit? tt*50.0:1.;\n          it = mix(50.,.001,pit);\n    \n    vec2 coord = (uv-.05*vec2(it*tt*sin(iTime),it*tt *cos(iTime)))*it;\n    float g = pit*grid(uv*it*rot(pit*2.)) * smoothstep(.01,.021,(length(coord)-.55));\n        d = .1/abs(.01+stargate(coord,i/lim));\n        d = (d*3.*g)+d;    \n    col += mix(vec3(.1),pal((i/lim)+tt)*pit,d*qq)/lim;\n    }\n   \n    \n    \n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25436, "src": "https://soundcloud.com/h0ffman/hoffman-pingit-1984-soundtrack", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 39, 39, 97], [110, 110, 148, 148, 374], [380, 380, 398, 398, 499], [509, 509, 529, 529, 614], [636, 636, 693, 743, 1481]], "test": "untested"}
{"id": "3ldfD2", "name": "Local Light Alignment EG2021", "author": "Nolan", "description": "Local Light Alignment for Multi-Scale Shape Depiction - Eurographics 2021\n(C) Nolan Mestres, Romain Vergne, Camille Noûs, Joëlle Thollot\n\nControls in the comment section and code.", "tags": ["raymarching", "heightmap", "perception", "npr", "expressive", "eg2021", "lla"], "likes": 6, "viewed": 628, "published": 3, "date": "1613498126", "time_retrieved": "2024-07-30T19:37:39.338518", "image_code": "// See \"Raymarching Pebbles\" by athibaul for the geometry/raymarching idea.\n// Thanks to FabriceNeyret2 for the mouse control idea.\n\n// Local Light Alignment for Multi-Scale Shape Depiction - Eurographics 2021\n// (C) Nolan Mestres, Romain Vergne, Camille Noûs, Joëlle Thollot\n// https://hal.inria.fr/hal-03140647\n\n///////////////////!\n// MOUSE CONTROLS /!\n///////////////////!\n\n// Points on the curves can be selected and dragged to tune the enhancement at each scale.\n// Circles on top of the curve are ON/OFF buttons.\n// Red curve: specular enhancement\n// Blue curve: diffuse enhancement\n// From left to right: scale 1 (fine), scale 2 (middle), scale 3 (coarse)\n\n//////////////////////!\n// KEYBOARD CONTROLS /!\n//////////////////////!\n\n// TOGGLE H : displays the HUD\n// TOGGLE D : diffuse  enhancement ON/OFF (blue curve)\n// TOGGLE S : specular enhancement ON/OFF (red  curve)\n// TOGGLE 1 : scale 1  enhancement ON/OFF (green/orange)\n// TOGGLE 2 : scale 2  enhancement ON/OFF (green/orange)\n// TOGGLE 3 : scale 3  enhancement ON/OFF (green/orange)\n\n// CTRL     + {1,2,3} + MOUSE.Y : set diffuse  enhancment of scale {1,2,3}\n// SHIFT    + {1,2,3} + MOUSE.Y : set specular enhancment of scale {1,2,3}\n// CAPSLOCK + MOUSE.Y           : global strength of the effect\n\n// MOUSE.X : original (left) vs. enhanced (right) x border location\n\n///////////////////////////////////////////////////////////////////////////////!\n// IMAGE BUFFER; OUTPUT: FINAL COLOR; /////////////////////////////////////////!\n///////////////////////////////////////////////////////////////////////////////!\n\n#define S 4    // number of levels in the scale-space\n\n// each sigma (in [0,1]) controls its own detail scale (fine to coarse)\nvec3 SD; // for diffuse component\nvec3 SS; // for specular component\n\n// toggled values\n#define HUD  (texelFetch(iChannel0, ivec2(0, 0), 0).z > 0.)  // true when HUD should be displayed\n#define SPEC (texelFetch(iChannel0, ivec2(0, 0), 0).x > 0.)  // true when specular is toggled\n#define DIFF (texelFetch(iChannel0, ivec2(0, 0), 0).y > 0.)  // true when diffuse is toggled\n\n#define S_        texelFetch(iChannel0, ivec2(1, 0), 0)    // S_[i] true when the scale is ON \n#define SEPARATOR texelFetch(iChannel0, ivec2(6, 0), 0).x  // position of the mouse (x-axis)\n\n// scale tuning\nbool  TD[S];   // is diff scale i being tuned right now? or global tuning?\nbool  TS[S-1]; // is spec scale i being tuned right now?\nfloat LVL;     // level of the mouse when ALT was release\n\n// is a scale being tune right now ?\n#define TUNE_SCL (TD[0] || TD[1] || TD[2] || TS[0] || TS[1] || TS[2])\n\n// move the mouse up/down to tune the selected scale (for current/both component)\n// if no scale is selected, controls the global strength of the enhancement\n// using values from the SD and SS arrays for diffuse and specular respectively.\n#define R  iResolution.xy\n#define Mx SEPARATOR       // mouse x coordinate\n#define T  iTime\n\n// colors of the curves and indicators for scales\n#define CURVE_DIFF vec4(0., 0., 1., 1.)\n#define CURVE_SPEC vec4(1., 0., 0., 1.)\n#define SCL_ON     vec4(.2, 1., 0., 1.)\n#define SCL_OFF    vec4(1., .4, 0., 1.)\n\n// TO-DO: hack using mipmapping to get normals at different scales. It produces\n// gliding artifacts when moving camera/light; they do not happen with a\n// \"real\" scale-space (e.g. smoothing normals using an edge-preserving smoothing)\n#define N(i)    normalize(textureLod(iChannel2, PXL, float(3*i)).xyz)\n#define DIST    texture(iChannel2, PXL).w\n\n#define PXL     (u/iResolution.xy)\n#define EPSILON\t1e-10\n#define PIO2    1.57079632679\n#define GAMMA   3.0\n\n//////////////////////////!\n// LOCAL LIGHT ALIGNMENT /!\n//////////////////////////!\n\nvec3 rotateLight(in vec3 l, in vec3 a, in float theta) {\n\tif (theta < EPSILON)\n\t\treturn l;\n\n\tvec3  axl = normalize(cross(a, l));\n\tfloat adl = dot(a, l);\n    \n\treturn a * adl + cos(theta) * cross(axl, a) + sin(theta) * axl;\n}\n\n// remap function to weight the rotation (solve discontinuities)\n// lambda = lambda_1 * lambda_2\nfloat W(in float lambda) {\n\treturn lambda / (exp(-GAMMA) * (1. - lambda) + lambda);\n}\n\n// local frame L, constructed from n_i and n_{i+1}\nmat3 L(in vec3 ni, in vec3 ni1) {\n\tvec3 z = ni1;\n    // project n_i onto the plane of normal n_{i+1}\n\tvec3 x = normalize(ni - z*(dot(z, ni)));\n\tvec3 y = cross(x, z);\n    \n\treturn mat3(x, y, z);\n}\n\nvec3 adjustLight(in vec3 ni, in vec3 ni1, in vec3 li, in vec3 v, in float si, in bool spec) {\n    if (si < EPSILON) // no need to compute the adjustment at that scale...\n        return li;\n    \n    if (spec) { // for specular materials we use the reflected view as guide\n        ni  = reflect(v, ni);\n\t\tni1 = reflect(v, ni1);\n    }\n    \n    if (1. - abs(dot(ni, ni1)) < EPSILON) // if the detail and base are\n        return li;                        // already aligned...\n\n    mat3 Li = L(ni, ni1); // local frame L_i\n\t\n    // vectors to local frame\n    li      = li * Li;\t// in GLSL: v * M <=> M^T * v\n    vec3 gi\t= ni * Li;\t// guiding vector\n\n    // if the light is not facing the detail, we align with the tangent\n    if (li.x < 0.) // equivalent to the dot product check from the paper\n        gi = vec3(-gi.z, gi.y, gi.x);\n\n\tvec2  gp    = normalize(gi.xy);\n\tvec2  lp    = normalize(li.xy);\n\tfloat tha   = acos(dot(lp, gp));    // azimuthal angle\n    float lmbd1 = 1.-min(1., tha/PIO2); // confidence value lambda_1\n    float lmbd2 = length((ni*Li).xy);   // confidence value lambda_2\n    \n\tfloat theta = si * W(lmbd1*lmbd2) * acos(dot(li, gi));\n\tvec3  a     = normalize(cross(li, gi));\t // rotation axis a\n    \n\treturn Li * rotateLight(li, a, theta); // we return the rotated light direction\n}\n\n////////////////////////////////!\n// LOCAL LIGHT ALIGNMENT - END /!\n////////////////////////////////!\n\nfloat sigmaD(in int i) {\n    return LVL * (DIFF && S_[i] > 0. ? SD[i] : 0.);\n}\n\nfloat sigmaS(in int i) { \n    return LVL * (SPEC && S_[i] > 0. ? SS[i] : 0.);\n}\n\n// https://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\nfloat spec(in vec3 l, in vec3 n, in vec3 v, float ap, float f0) {\n    vec3  h = normalize(l+v); // half-vector\n    float D = (ap+2.)/(6.2832)*pow(dot(n, h), ap); // distribution function\n    float G = 1./dot(l, h); // approximate Cook-Torrance geometry function\n    return D*G*f0;\n}\n\nvoid load() { // load global state of the shader (sigma values)\n    SD = texelFetch(iChannel0, ivec2(2, 0), 0).xyz; // sigma for diffuse\n    SS = texelFetch(iChannel0, ivec2(3, 0), 0).xyz; // sigma for specular\n        \n    // is diff/spec scale i being set right now?\n    vec4 TDt = texelFetch(iChannel0, ivec2(4, 0), 0);\n    vec4 TSt = texelFetch(iChannel0, ivec2(5, 0), 0);\n    TD       = bool[](TDt.x>0., TDt.y>0., TDt.z>0., TDt.w>0.); \n    TS       = bool[](TSt.x>0., TSt.y>0., TSt.z>0.);\n    LVL      = TSt.w;\n}\n\nvoid mainImage(out vec4 col, in vec2 u) { \n    load();\n    col = vec4(0.);\n\n    vec3 ro = vec3(0.); //vec3(iTime*0.02, 0.2*cos(iTime*0.1), 0.);\n    vec3 l, ld, ls, rd = rayd(u, R, T);          // incident view vector\n    l = normalize(vec3(-.5, 0., -1.));  // light direction\n    \n    vec3 t = vec3(0., 1., 0.);\n    vec3 b = normalize(cross(t, l));\n    t = normalize(cross(l, b));\n    ld = ls = normalize(l + t * .6*sin(iTime) + b * .6*cos(iTime)); // move the light in a cone\n\n    if (HUD) { // displays \"HUD\"     \n        // displays plots using Catmull-Rom splines\n        float x   = 12.*PXL.x;\n        float y   = 3.*PXL.y;\n        if (PXL.x < .33 && PXL.y < .39) {\n            for(int i = 0; i < 3; i++) {\n                float X = float(i);\n                #define disc(X,Y,dr) smoothstep(0.,1.5/R.y, dr+.015 - length((PXL - vec2(X,Y)/vec2(12,3))*R/R.y))\n                col.b += disc( .9+X,sigmaD(i),);\n                col.r += disc(1.1+X,sigmaS(i),); \n                col.g += disc(1. +X,1.1,.005) - (S_[i] > 0. ? 0. : disc(1.+X,1.1,));\n            }\n            col.b += disc(.5,1.1,.01) - (DIFF ? 0. : disc (.5,1.1,.005)); // D,S buttons\n            col.r += disc(3.5,1.1,.01) - (SPEC ? 0. : disc(3.5,1.1,.005));\n            \n            float t     = fract(x);    // spline weight per segment\n            int   i     = int(x);\n            float VD[5] = float[](0., sigmaD(0), sigmaD(1), sigmaD(2), 0.); // spline diff control points\n            float VS[5] = float[](0., sigmaS(0), sigmaS(1), sigmaS(2), 0.); // spline spec control points\n    \n            // plots of the diff/spec curves and scales indicators (green vertical bars when toggled)\n            float pld = plot(y, clamp(spline(VD[i-1], VD[i], VD[i+1], VD[i+2], t), 0., LVL), .002*R.x);\n            float pls = plot(y, clamp(spline(VS[i-1], VS[i], VS[i+1], VS[i+2], t), 0., LVL), .002*R.x);\n            float pl1 = plot(x, 1., 2.);\n            float pl2 = plot(x, 2., 2.);\n            float pl3 = plot(x, 3., 2.);\n            float plm = plot(y, LVL, 2.);\n            \n            vec4 c1 = (S_[0] > 0. ? (TD[0] ? CURVE_DIFF : (TS[0] ? CURVE_SPEC : SCL_ON)) : SCL_OFF);\n            vec4 c2 = (S_[1] > 0. ? (TD[1] ? CURVE_DIFF : (TS[1] ? CURVE_SPEC : SCL_ON)) : SCL_OFF);\n            vec4 c3 = (S_[2] > 0. ? (TD[2] ? CURVE_DIFF : (TS[2] ? CURVE_SPEC : SCL_ON)) : SCL_OFF);\n            \n            col += pls*CURVE_SPEC + pld*CURVE_DIFF; // curves\n            col += pl1*c1 + pl2*c2 + pl3*c3;        // scale bars\n            col += plm * SCL_ON;                    // global strength\n        }\n        \n        if (PXL.x >= Mx - 3e-3 && PXL.x < Mx + 3e-3) { // intensity indicator\n            if (!DIFF && !SPEC) return; // no component toggled\n            col =  mix(vec4(u.y/R.y < LVL), col, max(col.r,max(col.g,col.b)));\n            return;\n        }\n    }\n    \n    // enhancement using local light alignment\n    if (PXL.x >= Mx + 3e-3) { // enhanced part of the rendering\n        for (int i = S-2; i >= 0; --i) {\n            ld = adjustLight(N(i), N(i+1), ld, rd, sigmaD(i), false);\n            ls = adjustLight(N(i), N(i+1), ls, rd, sigmaS(i), true);    \n        }\n    }\n\n    // lighting\n    vec3 n   = N(0);\n    vec3 kd  = .7 * vec3(1.2, 1.1, .8) * max(0., dot(n, ld)) * texture(iChannel1, (ro + DIST*rd).xy).rgb;\n    vec3 ks  = vec3(.3 * spec(ls, n, -rd, 10., .9));\n    vec4 c   = vec4(kd + ks, 1.);\n        \n    if (PXL.x < .33 && PXL.y < .39 && HUD)\n        PXL.y < .33 ? col = mix(.3*c, col, max(col.r,max(col.g,col.b)))\n                      : col = mix(c, col, max(col.r,max(col.g,col.b)));\n    else\n        col = c;\n}\n", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See \"Raymarching Pebbles\" by athibaul for the geometry/raymarching idea.\n// Thanks to FabriceNeyret2 for the mouse control idea.\n\n// Local Light Alignment for Multi-Scale Shape Depiction - Eurographics 2021\n// (C) Nolan Mestres, Romain Vergne, Camille Noûs, Joëlle Thollot\n// https://hal.inria.fr/hal-03140647\n\n////////////////////////////////////////////////////////////////////////////////////!\n// BUFFER A: RAYMARCHING; OUTPUT: NORMALS; /////////////////////////////////////////!\n////////////////////////////////////////////////////////////////////////////////////!\n\n#define PIXEL (u/iResolution.xy)\n#define R     iResolution.xy\n#define T     iTime\n\nfloat height(vec3 p) { // fractalization of the pattern to get different detail scales\n    return (4.*texture(iChannel0, .25*p.xy).r\n            + texture(iChannel0, p.xy).r\n            + .25*texture(iChannel0, 4.*p.xy).r)/1.5;\n}\n\nfloat map(vec3 p) { // distance function\n    return 1. - p.z - .1*height(p);\n}\n\nvec3 normal(in vec3 p) { // tetrahedral normal, courtesy of IQ.\n    vec2 e = vec2(.001, -.001);\n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nvoid mainImage(out vec4 n, in vec2 u) {\n    vec3 ro = vec3(0.);//vec3(iTime*0.02, 0.2*cos(iTime*0.1), 0.);\n    vec3 rd = rayd(u, R, T);\n    \n    // raymarching the heightmap\n    float d, t = 0.;\n    for(int j = 0; j < 32; j++) {\n        d = map(ro + t*rd);\n        if(d < .001) break; // hit!\n        t += .3*d;\n    }\n    \n    vec3 p = ro + t*rd;\n    n = vec4(normal(p), t);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See \"Raymarching Pebbles\" by athibaul for the geometry/raymarching idea.\n// Thanks to FabriceNeyret2 for the mouse control idea.\n\n// Local Light Alignment for Multi-Scale Shape Depiction - Eurographics 2021\n// (C) Nolan Mestres, Romain Vergne, Camille Noûs, Joëlle Thollot\n// https://hal.inria.fr/hal-03140647\n\n//////////////////////////////////////////////////////////////!\n// GLOBAL FUNCTIONS; /////////////////////////////////////////!\n//////////////////////////////////////////////////////////////!\n\n// returns the ray direction from the camera towards u\nvec3 rayd(in vec2 u, in vec2 R, in float T) { // coordinates (u), resolution (R), time (T)\n    vec2  uv = (2.*u - R)/R.y;                // uv.x [-ar,ar], uv.y [-1,1] ar: aspect ratio\n    float th = cos(.1*T);\n    vec3  r  = normalize(vec3(uv.x, uv.y, 3.0));\n    //r.xy     = mat2(cos(th), sin(th), -sin(th), cos(th)) * r.xy;\n    return r;\n}\n\n// Catmull-Rom: four control points (v[0-3]), a weight [0,1] for each segment (t)\n// from FabriceNeyret2: https://www.shadertoy.com/view/4ljyWc\nfloat spline(float v0, float v1, float v2, float v3, float t) {\n\tfloat A0 = mix(v0, v1, t+1.     ),\n\t      A1 = mix(v1, v2, t        ),\n\t      A2 = mix(v2, v3, t-1.     ),\n          B0 = mix(A0, A1, .5*t + .5),\n\t      B1 = mix(A1, A2, .5*t     );\n\treturn     mix(B0, B1, t        );\n}\n\n// plot function f at y with a width w\nfloat plot(float y, float f, float w) {\n  return smoothstep(1.5+w, 0., abs(y-f)/fwidth(y-f));\n}\n", "buffer_b_code": "// See \"Raymarching Pebbles\" by athibaul for the geometry/raymarching idea.\n// Thanks to FabriceNeyret2 for the mouse control idea.\n\n// Local Light Alignment for Multi-Scale Shape Depiction - Eurographics 2021\n// (C) Nolan Mestres, Romain Vergne, Camille Noûs, Joëlle Thollot\n// https://hal.inria.fr/hal-03140647\n\n//////////////////////////////////////////////////////////////////////////////!\n// BUFFER B: KEYBOARD; OUTPUT: STATE INFORMATION; ////////////////////////////!\n//////////////////////////////////////////////////////////////////////////////!\n\n// default values for sigma in [0,1]:\n#define DEFAULT_SIGMAD vec4(.4, .3, .4, 1.) // sigma for diffuse component\n#define DEFAULT_SIGMAS vec4(.6, .3, .2, 1.) // sigma for specular component\n\n// keyboard values (1,2,3 both keyboard and numpad, S, D, H, CTRL, SHIFT, CAPSLOCK)\n#define K_1N   97    // FINE:     toggle 1 (numpad), scale 1 (left) turns green on HUD\n#define K_2N   98    // MIDDLE:   toggle 2 (numpad), scale 2 (middle) turns green on HUD\n#define K_3N   99    // COARSE:   toggle 3 (numpad), scale 3 (right) turns green on HUD\n#define K_1K   49    // FINE:     toggle 1 (keyboard), alternative key\n#define K_2K   50    // MIDDLE:   toggle 2 (keyboard), alternative key\n#define K_3K   51    // COARSE:   toggle 3 (keyboard), alternative key\n#define K_S    83    // SPECULAR: toggle S, enhance specular (red curve)\n#define K_D    68    // DIFFUSE:  toggle D, enhance diffuse (blue curve)\n#define K_H    72    // UI:       toggle H, displays UI\n#define K_SHFT 16    // SHIFT+{1,2,3}: set sigma at that scale for specular\n#define K_CTRL 17    // CTRL+{1,2,3}:  set sigma at that scale for diffuse\n#define K_CAPS 20    // CAPS+MouseY:   controls the overall strength of the enhancement\n\n// keyboard events\n#define TOGGLES(k)   (texelFetch(iChannel0, ivec2(k, 2), 0).x > 0.)  // scales\n#define TOGGLEC(k)   (texelFetch(iChannel0, ivec2(k, 2), 0).x <= 0.) // component (so they are ON by default)\n#define DOWN(k)      (texelFetch(iChannel0, ivec2(k, 0), 0).x > 0.)\n#define JUSTPRESS(k) (texelFetch(iChannel0, ivec2(k, 1), 0).x > 0.)\n\n// make sure numpad and keyboard do not conflict for scales\n// and that when tuning a given scale it is not interpreted as a toggle event\n#define D1    (DOWN(K_1N) || DOWN(K_1K)) // pressed 1, either on keyboard or numpad\n#define D2    (DOWN(K_2N) || DOWN(K_2K)) // pressed 2, either on keyboard or numpad\n#define D3    (DOWN(K_3N) || DOWN(K_3K)) // pressed 3, either on keyboard or numpad\n\n#define RS    JUSTPRESS(K_S) // just pressed S\n#define RD    JUSTPRESS(K_D) // just pressed D\n#define RH    JUSTPRESS(K_H) // just pressed H\n\n#define R1    (JUSTPRESS(K_1N) || JUSTPRESS(K_1K)) // just pressed 1, either on keyboard or numpad\n#define R2    (JUSTPRESS(K_2N) || JUSTPRESS(K_2K)) // just pressed 2, either on keyboard or numpad\n#define R3    (JUSTPRESS(K_3N) || JUSTPRESS(K_3K)) // just pressed 3, either on keyboard or numpad\n\n// setting sigma for each scale and shading component\n#define SET_SIGD1 (DOWN(K_CTRL) && D1) // CTRL+1:  set sigma 1 for diffuse (fine  scale)\n#define SET_SIGD2 (DOWN(K_CTRL) && D2) // CTRL+2:  set sigma 2 for diffuse (mid   scale)\n#define SET_SIGD3 (DOWN(K_CTRL) && D3) // CTRL+3:  set sigma 3 for diffuse (large scale)\n#define SET_SIGS1 (DOWN(K_SHFT) && D1) // SHIFT+1: idem for specular sigma 1\n#define SET_SIGS2 (DOWN(K_SHFT) && D2) // SHIFT+1: idem for specular sigma 2\n#define SET_SIGS3 (DOWN(K_SHFT) && D3) // SHIFT+1: idem for specular sigma 3\n\n// toggle only is not setting scale sigma value\n#define T1 (R1 && !(SET_SIGD1 || SET_SIGS1))\n#define T2 (R2 && !(SET_SIGD2 || SET_SIGS2)) \n#define T3 (R3 && !(SET_SIGD3 || SET_SIGS3))\n\n// bool: are we on screen pixels where parameters are stored?\n#define CMP_PXL    (ivec2(u) == ivec2(0, 0)) // pixel storing state of components + HUD (ON/OFF)\n#define SCL_PXL    (ivec2(u) == ivec2(1, 0)) // pixel storing state of scales 1, 2, 3 (ON/OFF)\n#define SIGMAD_PXL (ivec2(u) == ivec2(2, 0)) // pixel storing sigma 1, 2, 3 values for diffuse\n#define SIGMAS_PXL (ivec2(u) == ivec2(3, 0)) // pixel storing sigma 1, 2, 3 values for specular\n#define TUNESD_PXL (ivec2(u) == ivec2(4, 0)) // pixel storing booleans: is diffuse scale (1,2,3) being tuned?\n#define TUNESS_PXL (ivec2(u) == ivec2(5, 0)) // pixel storing booleans: is specular scale (1,2,3) being tuned?\n#define SEPARATOR  (ivec2(u) == ivec2(6, 0)) // pixel storing the position of the separator (mouseX)\n\n// get status of scales: are they ON or OFF?\n#define S_ON texelFetch(iChannel1, ivec2(1, 0), 0)\n\n#define R     iResolution.xy\n#define PIXEL (u/R.xy)          // pixel value in [0,1]\n#define M     (iMouse.xy/R.xy)  // mouse coordinate in [0,1]\n\nvoid mainImage(out vec4 k, in vec2 u) {\n    if (u.y > 1. || u.x > 7.)\n        return;\n\n    k = texture(iChannel1, PIXEL); // load previous state\n    \n    if (iFrame < 10) { // init default values for parameter\n        if (CMP_PXL)         k = vec4(1); // component (DIFF, SPEC, HUD) toggled? default: (ON, ON, ON)\n        else if (SCL_PXL)    k = vec4(1); // scales (S1, S2, S3) toggled? default: (ON, ON, ON)\n        else if (SIGMAD_PXL) k = DEFAULT_SIGMAD;\n        else if (SIGMAS_PXL) k = DEFAULT_SIGMAS;\n        else if (TUNESD_PXL) k = vec4(0);\n        else if (TUNESS_PXL) k = vec4(0., 0., 0., 1.); // 1. : global strength\n        else if (SEPARATOR)  k = vec4(.5); // sepator at the middle of the screen\n        return;\n    }\n    \n    // clickable buttons and sliders\n    float lvl = texelFetch(iChannel1, ivec2(5, 0), 0).w;\n    for (int i = 0; i < 3; i++) {\n        #define pick(X) if ( length( lvl*(vec2(12,3)*M - vec2(X+float(i),k[i])) ) < .2 ) k[i] = min(3.*M.y,1.)\n        if (SIGMAD_PXL) pick( .8);\n        if (SIGMAS_PXL) pick(1.2);\n        #define near(X) length( lvl*(vec2(12,3)*M - vec2(X,1.2)) ) < .2\n        if (iMouse.w > 0.)                              // click + toggles 1,2,3\n          if (SCL_PXL) if (near(i+1)) { k[i] = 1.-k[i]; return; }\n    }\n    if (CMP_PXL && iMouse.w > 0.) {                             // click + toggles D,S\n        if (near( .5)) k.y = 1.-k.y;\n        if (near(3.5)) k.x = 1.-k.x; \n        return;\n    }\n    if (SEPARATOR && (M.x > .33 || M.y > .41)) { k.x = M.x; return; } // separator\n    \n    // set diffuse/spec sigma values\n    if ((SIGMAD_PXL && (SET_SIGD1 || SET_SIGD2 || SET_SIGD3)) ||\n        (SIGMAS_PXL && (SET_SIGS1 || SET_SIGS2 || SET_SIGS3))) {\n        k = vec4(D1 && S_ON[0] > 0. ? M.y : k.x,\n                 D2 && S_ON[1] > 0. ? M.y : k.y,\n                 D3 && S_ON[2] > 0. ? M.y : k.z, 1.);\n    }\n    else if (TUNESD_PXL)\n        k = vec4(SET_SIGD1, SET_SIGD2, SET_SIGD3, DOWN(K_CAPS));\n    else if (TUNESS_PXL)\n        k = vec4(SET_SIGS1, SET_SIGS2, SET_SIGS3, DOWN(K_CAPS)? clamp(M.y, .2, 1.) : k.w);\n    else if (CMP_PXL)\n        k = vec4(RS ? 1.-k.x : k.x, RD ? 1.-k.y : k.y, RH ? 1.-k.z : k.z, 1.);\n    else if (SCL_PXL) {\n        k = vec4(T1 ? 1.-k.x : k.x,\n                 T2 ? 1.-k.y : k.y,\n                 T3 ? 1.-k.z : k.z, 1.);\n    }\n}\n\n", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3670, 3670, 3726, 3726, 3894], [3896, 3993, 4019, 4019, 4078], [4080, 4131, 4164, 4164, 4326], [4328, 4328, 4421, 4421, 5627], [5732, 5732, 5756, 5756, 5810], [5812, 5812, 5836, 5836, 5891], [5893, 5999, 6064, 6064, 6281]], "test": "untested"}
{"id": "3ltfW2", "name": "Apple Watch Clock", "author": "moranzcw", "description": "A classic Apple Watch clock face.", "tags": ["2d", "time", "clock"], "likes": 10, "viewed": 442, "published": 3, "date": "1613491136", "time_retrieved": "2024-07-30T19:37:40.234124", "image_code": "// Apple Watch Clock - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159265359\n#define ScaleWidth 0.04\n#define ClockSize 0.7\n\n#define HoursScaleWidth 0.015\n#define MinutesScaleWidth 0.004\n\n#define HourHandColor vec3(1.0)\n#define HourHandCoreSize 0.025\n#define HourHandLength1 0.1\n#define HourHandWidth1 0.005\n#define HourHandLength2 0.25\n#define HourHandWidth2 0.02\n\n#define MinuteHandColor vec3(1.0)\n#define MinuteHandCoreSize 0.025\n#define MinuteHandLength1 0.1\n#define MinuteHandWidth1 0.005\n#define MinuteHandLength2 0.5\n#define MinuteHandWidth2 0.02\n\n#define SecondHandColor vec3(0.961, 0.633, 0.332)\n#define SecondHandCoreSize 0.02\n#define SecondHandLength 0.7\n#define SecondHandWidth 0.0035\n\n#define PixelWidth 1.0/iResolution.y\n\nvec3 line(vec2 coord, vec2 p1, vec2 p2, float width, vec3 color)\n{\n    vec2 v1 = coord - p1;\n    vec2 v2 = p2 - p1;\n    float j1 = dot(v1, v2);\n    \n    vec2 v3 = coord - p2;\n    vec2 v4 = p1 - p2;\n    float j2 = dot(v3, v4);\n    \n    float len;\n    if( j1 > 0.0 && j2 > 0.0)\n    {\n        vec2 nv2 = normalize(v2);\n        len = length(v1 - dot(v1, nv2) * nv2);\n    }\n    else\n    {\n        len = min(length(v1),length(v3));\n    }\n    return color * smoothstep(width + 2.0*PixelWidth, width, len);\n}\n\nvec3 clockScale(vec2 coord)\n{\n    vec3 color;\n    \n    //\n    float l = length(coord);\n    float onRing = step(ClockSize-ScaleWidth, l) - step(ClockSize, l);\n    \n    //\n    float angle = atan(coord.y/coord.x);\n    float d1 = mod(angle, PI/6.0);\n    float d2 = d1 - PI/6.0;\n    float onHoursScale = step(-HoursScaleWidth,d1) - step(HoursScaleWidth,d1);\n    onHoursScale += step(-HoursScaleWidth,d2) - step(HoursScaleWidth,d2);\n    \n    // \n    float d3 = mod(angle, PI/30.0);\n    float d4 = d3 - PI/30.0;\n    float onMinutesScale = step(-MinutesScaleWidth,d3) - smoothstep(MinutesScaleWidth,MinutesScaleWidth+0.003,d3);\n    onMinutesScale += smoothstep(-MinutesScaleWidth-0.003, -MinutesScaleWidth,d4) - step(MinutesScaleWidth,d4);\n    \n    color += vec3(1.0) * onRing * onHoursScale;\n    color += vec3(0.6) * onRing * onMinutesScale;\n    return color;\n}\n\nvec3 hourHand(vec2 coord)\n{\n    vec3 color;\n    color += HourHandColor * smoothstep(HourHandCoreSize + PixelWidth, HourHandCoreSize, length(coord));\n    \n    float angle = 2.0 * PI * (iDate.w / 43200.0);\n    vec2 direction = vec2(sin(angle), cos(angle));\n    vec2 p1 = vec2(0.0);\n    vec2 p2 = direction * HourHandLength1;\n    color = max(color, line(coord, p1, p2, HourHandWidth1, HourHandColor));\n    p1 = direction * HourHandLength1;\n    p2 = p1 + direction * HourHandLength2;\n    color = max(color, line(coord, p1, p2, HourHandWidth2, HourHandColor));\n    \n    return color;\n}\n\nvec3 minuteHand(vec2 coord)\n{\n    vec3 color;\n    color += MinuteHandColor * smoothstep(MinuteHandCoreSize + PixelWidth, MinuteHandCoreSize, length(coord));\n    \n    float angle = 2.0 * PI * mod(iDate.w / 60.0, 60.0) / 60.0;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    vec2 p1 = vec2(0.0);\n    vec2 p2 = direction * MinuteHandLength1;\n    color = max(color, line(coord, p1, p2, MinuteHandWidth1, MinuteHandColor));\n    p1 = direction * MinuteHandLength1;\n    p2 = p1 + direction * MinuteHandLength2;\n    color = max(color, line(coord, p1, p2, MinuteHandWidth2, MinuteHandColor));\n    \n    return color;\n}\n\nvec3 secondHand(vec2 coord)\n{\n    vec3 color;\n    color += SecondHandColor * smoothstep(SecondHandCoreSize + PixelWidth, SecondHandCoreSize, length(coord));\n    \n    float angle = 2.0 * PI * mod(iDate.w, 60.0) / 60.0;\n    vec2 direction = vec2(sin(angle), cos(angle));\n    vec2 p1 = direction * SecondHandLength;\n    vec2 p2 = -direction * 0.15 * SecondHandLength;\n    color = max(color, line(coord, p1, p2, SecondHandWidth, SecondHandColor));\n    \n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 color;\n    vec3 temp;\n    temp = clockScale(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n    \n    temp = hourHand(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n    \n    temp = minuteHand(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n    \n    temp = secondHand(coord);\n    color = step(1e-3, temp) * temp + step(length(temp), 1e-3) * color;\n\n    float d = smoothstep(MinuteHandCoreSize*0.5 + PixelWidth, MinuteHandCoreSize*0.5, length(coord));\n    color = vec3(0.0) * d + color * (1.0-d);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfW2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[842, 842, 908, 908, 1342], [1344, 1344, 1373, 1373, 2198], [2200, 2200, 2227, 2227, 2780], [2782, 2782, 2811, 2811, 3397], [3399, 3399, 3428, 3428, 3872], [3875, 3875, 3932, 3932, 4677]], "test": "untested"}
{"id": "3ltBWj", "name": "day 425", "author": "jeyko", "description": "crystal", "tags": ["crystal", "mdtmjvm", "cyclicnoise"], "likes": 8, "viewed": 451, "published": 3, "date": "1613483546", "time_retrieved": "2024-07-30T19:37:41.571548", "image_code": "// Fork of \"Day 424\" by jeyko. https://shadertoy.com/view/wldfDB\n// 2021-02-16 09:06:35\n\n// dont fullscreen\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz *= 1. - dot(uv,uv)*0.2;\n    fragColor.xyz = pow(max(fragColor.xyz,0.), vec3(1.15,1.1,1.15));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.05));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    \n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n       \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat envcnt = 0.;\n\nfloat getEnv(float t, float speed, float pa, float pb, float jumpAmt, bool cnt){\n    //return pow(sin((t - 0.5)*3.14),1.)*0.5 + 0.5;\n    t = clamp(t*speed,0.,1.);\n    \n    envcnt += float(t > 0.99 && cnt);\n    //t = smoothstep(0.,1.,t);\n    pa += 1.;\n    pb += 1.;\n    \n    float c = cos(t*3.14);\n    float a = 1.- ((pow(abs(c),pa)*sign(c))*0.5 + 0.5);\n    float b = 1.-((pow(abs(c),pb)*sign(c))*0.5 + 0.5);\n    \n    a = pow(sin(t*3.14/2.),pa);\n    b = 1.-pow(sin((-t + 1.)*3.14/2.),pb);\n    \n    b *= 1. + (\n            smoothstep(0.,1.,t) *smoothstep(0.99,0.7,t)*jumpAmt\n        );\n    return mix( a, b,t);\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1.);\n    \n    \n    float segmentMod =  + sin(floor(kSegment))*20.;\n    \n    float vn = valueNoise(iTime + uv.x*0.01 + segmentMod, 2.)*1.;\n    float t = iTime*1.3 - vn + 2. + segmentMod;\n        \n    float env = getEnv(t, 1., 2., 2., 1., false);\n    \n    vec2 offs = vec2(sin(t)*0.5,cos(t*0.6)*1.6) ;\n    \n    vec2 ouv = uv;\n    uv -= offs*0.3;\n    float nb = cyclicNoise(vec3(uv*1.5 + t*0. + offs*0.4,t*0.2), false, t*0.);\n    \n    float n = cyclicNoise(vec3(uv*(6.5- dot(ouv,ouv)*2.),t*0.5 - nb*4.) , false, t*1.);\n    //nb*=1.;\n\n\n    //n = abs(n - 1. )*1. ;\n    //n -= 1. ;\n    \n    //nb *= 0.5;\n    float r = .6 - n*2. + nb*4.;\n    int didx = 3;\n    vec2 dfn = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx])*2.;\n\n    r = 15. - n*0. + nb*4.;\n    didx = 1;\n    \n    vec2 dfnb = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n    \n    \n    //col += 1.-abs(length(dfn.xyx))*4.;\n    \n    col = mix(col,0.1*vec3(0.,0.,0.1 + 0.2*sin(nb*10.)*0.2),smoothstep(-.15,0.01,-length(dfn)));\n    \n    vec3 c = vec3(0.+ sin(length(dfnb)*5. + iTime+ n*10.)*0.4+ sin(dfn.x*10.)*0.3 ,0.1 + n*0.05 + sin(nb*20. + t)*0.05 ,0.1  );\n    c *= .9;\n    //col = mix(col,c*3.,smoothstep(0. + n*0. + nb*0.0,0.0 + length(dfnb)*4.,length(dfnb.xy)));\n    \n    \n    \n    \n    \n    C = vec4(col,n);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 fr = texture(iChannel0,(U)/iResolution.xy);\n   \n    float r = 1. \n        + sin(fr.w*5.)*1.5\n        + sin(fr.x*1.)*.2;\n    int didx = 3;\n    \n    vec2 dfn = vec2(T0(U + vec2(1.,0)*r)[didx] - T0(U - vec2(1.,0)*r)[didx],T0(U + vec2(0.,1)*r)[didx] - T0(U - vec2(0.,1)*r)[didx]);\n    \n    vec2 sc = vec2(0)\n        + pow(smoothstep(0.,1.,length(dfn.x)*9.),0.6)*.6;\n    \n    sc *= dfn*15.;\n    \n    \n    C.x =texture(iChannel0,(U + sc*vec2(0,9))/iResolution.xy).x;\n    \n    C.y =texture(iChannel0,(U + sc*vec2(0,-4))/iResolution.xy).y;\n    \n    C.z =texture(iChannel0,(U + sc*vec2(-3,-5))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\n\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n#define kSegment (floor(mod(iTime,15.)/7.5))\n\n#define pi acos(-1.)\n\n#define R (iResolution.xy)\n#define T(u) texture(iChannel2,(u)/R)\n#define T0(u) texture(iChannel0,(u)/R)\n\n//#define sino(a) sin(a)\n#define sint(a) (asin(sin(a))*2. - 1.)*0.4\n#define cost(a) (acos(cos(a - 3.14*0.3))*2. - 1.)*0.3\n\n//#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(2.5);\n    p.xz *= rot(-2.5);\n    float amp = 1.5;\n    float gain = 0.7 + sint(p.x*1.5 + time)*0.;\n    const float lacunarity = 1.2;\n    const int octaves = 4;\n    \n     float warp = .1 + sin(time*0.5)*0.05;\n    float warpTrk = 1.5 ;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p -= sint(p.zxy*warpTrk + vec3(0,-time*0.2,0) - 0.01*warpTrk)*warp; \n        noise += sint(dot(cost(p), sint(p.zxy + vec3(0,time*0.1,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 2;\n    \n    const float warp =.4;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat sdSq(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }", "buffer_c_code": "// Fork of \"Day 424\" by jeyko. https://shadertoy.com/view/wldfDB\n// 2021-02-16 09:06:35\n\n// dont fullscreen\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    \n    C -= C;\n\n    vec4 bloom = vec4(0);\n    //bloom += texture(iChannel0,fragCoord/R,0.);\n    //bloom += texture(iChannel0,fragCoord/R,1.);\n    bloom += texture(iChannel0,fragCoord/R,1.);\n    //bloom += texture(iChannel0,fragCoord/R,3.);\n    bloom += texture(iChannel0,fragCoord/R,4.);\n    bloom += texture(iChannel0,fragCoord/R,5.);\n    bloom += texture(iChannel0,fragCoord/R,6.);\n    bloom += texture(iChannel0,fragCoord/R,7.);\n    bloom += texture(iChannel0,fragCoord/R,6.);\n    bloom += texture(iChannel0,fragCoord/R,9.);\n    bloom += texture(iChannel0,fragCoord/R,12.);\n    \n    //bloom = smoothstep(0.4,1.,1.7*bloom/8.)*2.;\n    bloom/=6.;\n    C = bloom;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"Day 424\" by jeyko. https://shadertoy.com/view/wldfDB\n// 2021-02-16 09:06:35\n\n// dont fullscreen\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    \n    C -= C;\n\n    vec4 bloom = vec4(0);\n    //bloom += texture(iChannel0,fragCoord/R,0.);\n    //bloom += texture(iChannel0,fragCoord/R,1.);\n    bloom += texture(iChannel0,fragCoord/R,0.);\n    //bloom += texture(iChannel0,fragCoord/R,3.);\n    bloom += texture(iChannel0,fragCoord/R,4.);\n    bloom += texture(iChannel0,fragCoord/R,5.);\n    bloom += texture(iChannel0,fragCoord/R,6.);\n    bloom += texture(iChannel0,fragCoord/R,7.);\n    bloom += texture(iChannel0,fragCoord/R,6.);\n    bloom += texture(iChannel0,fragCoord/R,9.);\n    bloom += texture(iChannel0,fragCoord/R,9.);\n    \n    \n            \n    bloom = smoothstep(0.4,1.5,1.5*bloom/8.)*1.;\n    \n    \n    C = texture(iChannel1,fragCoord/R);\n    \n    C = mix(C,bloom*1.4,pow(smoothstep(0.,1.,length(bloom)),2.)*0.2);\n            \n    if(kSegment > 0.5){\n        C = 0.8 - C*0.8;\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 166, 166, 1062]], "test": "untested"}
{"id": "tl3fW2", "name": "Mean-Field Critter", "author": "wyatt", "description": "Everyone should sign up for the Arsiliath course! He is doing a very good job, and I met many amazing people.\nhttps://twitter.com/arsiliath", "tags": ["arsilliath"], "likes": 20, "viewed": 519, "published": 3, "date": "1613462057", "time_retrieved": "2024-07-30T19:37:42.466156", "image_code": "// Fork of \"Critter Simulator\" by wyatt. https://shadertoy.com/view/3dKXWz\n// 2021-02-16 06:45:22\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = .5*C(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    if (U.x>N||U.y>1.) discard;\n    Q = A(U);\n    vec4 f = vec4(0);\n    for (float i = 0.; i < N; i++){\n        f += B(vec2(U.x,i));\n    }\n    vec4\n        n = C(Q.xy+vec2(0,1)),\n        e = C(Q.xy+vec2(1,0)),\n        s = C(Q.xy-vec2(0,1)),\n        w = C(Q.xy-vec2(1,0));\n    f.xy = f.xy/f.w-clamp(10.*vec2(e.z-w.z,n.z-s.z),-1.,1.);\n    Q.zw = Q.zw + f.xy;\n    Q.xy += Q.zw+.5*f.xy;\n    Q.w -= 2e-2;\n    if (Q.x>R.x-10.) {Q.x = R.x-10.;Q.z=-abs(Q.z);Q.w*=.9;}\n    if (Q.x<10.0) {Q.x = 10.0;Q.z=+abs(Q.z);Q.w*=.9;}\n    if (Q.y>R.y-10.) {Q.y = R.y-10.;Q.w=-abs(Q.w);Q.z*=.9;}\n    if (Q.y<10.0) {Q.y = 10.0;Q.w=+abs(Q.w);Q.z*=.9;}\n    if (iMouse.z>0.){\n        Q.zw += .001*(Q.xy-iMouse.xy);\n    }\n    if (iFrame < 1) {\n    \tfloat i = U.x;\n        Q.zw = vec2(0);\n        Q.xy = 0.5*R+.7*R.y*vec2(sin(3.+.3*pi2*i/N),cos(3.+.3*pi2*i/N));\n        Q.xy -= (Q.xy-0.5*R)*(1.6+.05*sin(pi2*24.*i/N));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n\n\n\n#define N min(150.,R.y)\n\n        #define pi2 6.28318530718\n\nfloat ln (vec2 a, vec2 b, vec2 u) {\n\tu = u-a;\n    b = b-a;\n    return length(u-b*clamp(dot(u,b)/dot(b,b),0.,1.));\n}", "buffer_b_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    if (U.x>N||U.y>N) discard;\n    Q = B(U);\n    \n    vec2 u = A(vec2(U.x,0)).xy-A(vec2(U.y,0)).xy;\n    float l = length(u);\n    if (l>0.) {\n        float w = 10.*Q.w/R.y;\n        Q.xy = 100.*exp(-w)*u/l*(length(Q.zw)-l);\n        Q.xy += 10.*u*exp(-.1*l*l);\n    } else Q.xy = vec2(0);\n    \n    if (iFrame < 1) {\n        Q.xy = vec2(0);\n        Q.z = length(A(vec2(U.x,0.)).xy-A(vec2(U.y,0.)).xy);\n        Q.w = Q.z;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    Q = vec4(0);\n    for (float i = 0.; i < N; i++) {\n        vec2 u = U-A(vec2(i,0)).xy;\n        vec4 s = .042*R.y*\n        (0.8+.5*sin(iTime+2.*i/N*pi2*vec4(1)));\n        Q += 1.*.05*smoothstep(1.5*s,s,vec4(1)*length(u));\n    }\n    Q *= vec4(4,3,2,1);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 98, 139, 139, 158]], "test": "untested"}
{"id": "wdKBWh", "name": "Menger Noise Prison", "author": "Parcle", "description": "Sometimes things go so wrong that they make their way back to right.\n\nTell your GPU that I am sorry.\n\nby Connor Alexander Haskins - Parcle - https://twitter.com/Lucodivo", "tags": ["noise", "mengersponge"], "likes": 3, "viewed": 237, "published": 3, "date": "1613457331", "time_retrieved": "2024-07-30T19:37:43.236097", "image_code": "/*\n * \"Menger Noise Prison\" by Connor Alexander Hasking - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: ConnorAHaskins@gmail.com\n */\n\n#define MAX_STEPS 60 // less steps will increase performance but narrow viewing distance, and lower detail & overall brightness\n#define MISS_DIST 200.0\n#define HIT_DIST 0.01\n    \nint distanceRayToScene(vec3 rayOrigin, vec3 rayDir);\nfloat distPosToScene(vec3 rayPos);\n\nmat2 rotate(float angle);\n\nfloat sdRect(vec2 rayPos, vec2 dimen);\nfloat sdCross(vec3 rayPos, vec3 dimen);\nfloat sdCube(vec3 rayPos);\nfloat sdMengerNoisePrison(vec3 rayPos);\n\nfloat rayNoiseValue(vec3 rayPos);\n\nconst vec3 missColor = vec3(0.1, 0.1, 0.1);\nconst float boxDimen = 20.0;\nconst float halfBoxDimen = boxDimen / 2.0;\n\nconst int mengerSpongeIterations = 3;\nconst float pi = 3.14159265;\nconst float piOver4 = pi * 0.25;\nconst float tau = pi * 2.0f;\nconst vec3 startingRayOrigin = vec3(0.0, 0.0, -boxDimen);\n\nconst float velocityUnit = boxDimen; // velocity in terms of length of the largest menger cube\nconst float velocity = 0.5; // velocity units per second\nconst float secondsPerCycle = 4.0 / velocity;\nconst float cyclesPerSecond = 1.0 / secondsPerCycle;\n\nint cycleModulo6 = 0;\nint noiseIndex0 = 0;\nint noiseIndex1 = 1;\nfloat cycleFract = 0.0;\n\nconst float highYLevel[3] = float[](1.0, 0.5 + (3.0 / 18.0), 0.5 + (3.0 / 54.0));\nconst vec2 upRightLeftDownVecs[4] = vec2[](vec2(0.0, 1.0), vec2(1.0, 0.0), vec2(0.0, -1.0), vec2(-1.0, 0.0));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 pixelCoord = fragCoord.xy - (iResolution.xy * 0.5);\n    pixelCoord = pixelCoord / iResolution.y;\n    \n    float cycle = iTime * cyclesPerSecond;\n    int cycleTrunc = int(cycle);\n    float cosY = -cos(tau * cycle); // cycles per second\n    float smoothY = smoothstep(-0.60, 0.60, cosY);\n    int upRightLeftDownIndex = cycleTrunc % 4;\n    int highYLevelIndex = cycleTrunc % 3;\n    float highLevelY = highYLevel[highYLevelIndex];\n    \n    float offset1d = smoothY * boxDimen * highLevelY;\n    vec3 offset3d = vec3(offset1d * upRightLeftDownVecs[upRightLeftDownIndex], iTime * velocity * velocityUnit);\n    vec3 rayOrigin = startingRayOrigin + offset3d;\n    vec3 fragmentPos = vec3(pixelCoord.x, pixelCoord.y, 0.0);\n    const vec3 focalPoint = vec3(0.0, 0.0, -1.0);\n    vec3 rayDir = fragmentPos - focalPoint;\n    \n    // special case as the mouse starts in the lower left when we want it to start in the center\n    vec2 normalizedMouseCoord = iMouse.x > 0.0 ?(((iMouse.xy / iResolution.xy) - vec2(0.5)) * 2.0) : vec2(0,0);\n    if(length(normalizedMouseCoord) > 1.0) { // reduce maximum distance of mouse from center to be 1 unit\n        normalizedMouseCoord = normalize(normalizedMouseCoord);\n    }\n    mat2 rotateYaw = rotate(normalizedMouseCoord.x * piOver4);\n    mat2 rotatePitch = rotate(normalizedMouseCoord.y * piOver4);\n    rayDir = vec3(rayDir.x, rotatePitch * rayDir.yz);\n    rayDir = vec3(rotateYaw * rayDir.xz, rayDir.y).xzy;\n    rayDir = normalize(rayDir);\n\n    cycleModulo6 = (cycleTrunc - 1) % 6; // offset cycleTrunc so that noise transition occurs during highYLevel[0], instead of highYLevel[2]\n    noiseIndex0 = cycleModulo6 / 3;\n    noiseIndex1 = abs(noiseIndex0 - 1);\n    // when cycleModulo is 2 or 5, enable cycleFract for lerping between noise\n    cycleFract = step(2.0, float(cycleModulo6 % 3)) * fract(iTime * cyclesPerSecond);\n    \n    int iteration = distanceRayToScene(rayOrigin, rayDir);\n\n    if(iteration < MAX_STEPS) { // hit\n        vec3 col = vec3(1.0 - (float(iteration)/float(MAX_STEPS)));\n        fragColor = vec4(col, 1.0);\n    } else { // miss\n        fragColor = vec4(missColor, 1.0);\n    }\n}\n\n\n// returns num iterations\n// NOTE: ray dir arguments are assumed to be normalized\nint distanceRayToScene(vec3 rayOrigin, vec3 rayDir) {\n\n\tfloat dist = 0.0;\n\n\tfor(int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = rayOrigin + (dist * rayDir);\n        float posToScene = sdMengerNoisePrison(pos) + rayNoiseValue(pos);\n        dist += posToScene;\n        if(abs(posToScene) < HIT_DIST) return i; // absolute value for posToScene incase the ray makes its way inside an object\n        if(posToScene > MISS_DIST) break;\n    }\n\n    return MAX_STEPS;\n}\n\n\n// NOTE: Piggy status of this function more directly related to the fairly random distance which results from the noise\n// NOTE: and, in turn, results in larger iterations that each ray takes. It is NOT simply the tripple sin calculations\n// NOTE: below (though I'm sure that doesn't help :()\nfloat rayNoiseValue(vec3 rayPos) {\n  // removing one creates a weird \"light source\" and \"tubes\" effect in the direction of the light\n  // removing two creates a plane of light\n  const float noiseFudgeMult = 20.0;\n  \n  vec3 rayPosFudge = noiseFudgeMult * rayPos;\n  float noiseVals[2] = float[](\n      sin(rayPosFudge.x)*sin(rayPosFudge.y)*sin(rayPosFudge.z), // normal?\n      fract(rayPosFudge.z) // ghost\n  );\n  \n  return mix(noiseVals[noiseIndex0], noiseVals[noiseIndex1], cycleFract);\n}\n\nfloat sdCube(vec3 rayPos) {\n\tconst vec3 corner = vec3(halfBoxDimen);\n    vec3 ray = abs(rayPos); // fold ray into positive octant\n    vec3 cornerToRay = ray - corner;\n    float cornerToRayMaxComponent = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n    float distToInsideRay = min(cornerToRayMaxComponent, 0.0);\n    vec3 closestToOutsideRay = max(cornerToRay, 0.0);\n\treturn length(closestToOutsideRay) + distToInsideRay;\n}\n\n\nfloat sdCross(vec3 rayPos) {\n    const vec3 corner = vec3(halfBoxDimen);\n\tvec3 ray = abs(rayPos); // fold ray into positive quadrant\n\tvec3 cornerToRay = ray - corner;\n\n    float smallestComp = min(min(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat largestComp = max(max(cornerToRay.x, cornerToRay.y), cornerToRay.z);\n\tfloat middleComp = cornerToRay.x + cornerToRay.y + cornerToRay.z\n\t\t\t\t\t\t\t- smallestComp - largestComp;\n            \n\tvec2 closestOutsidePoint = max(vec2(smallestComp, middleComp), 0.0);\n\tvec2 closestInsidePoint = min(vec2(middleComp, largestComp), 0.0);\n\n\treturn (middleComp > 0.0) ? length(closestOutsidePoint) : -length(closestInsidePoint);\n}\n\nfloat sdMengerNoisePrison(vec3 rayPos) {\n  vec3 prisonRay = mod(rayPos, boxDimen * 2.0);\n  prisonRay -= boxDimen;\n\n  float mengerPrisonDist = sdCross(prisonRay, vec3(halfBoxDimen));\n\n  float scale = 1.0;;\n  for(int i = 0; i < 3; ++i) {\n    float boxedWorldDimen = boxDimen / scale;\n    vec3 ray = mod(rayPos + boxedWorldDimen / 2.0, boxedWorldDimen);\n    ray -= boxedWorldDimen * 0.5;\n    ray *= scale;\n    float crossesDist = sdCross(ray * 3.0, vec3(halfBoxDimen));\n    scale *= 3.0;\n    crossesDist /= scale;\n    mengerPrisonDist = max(mengerPrisonDist, -crossesDist);\n  }\n\n  return mengerPrisonDist;\n}\n\n\nfloat sdRect(vec2 rayPos, vec2 dimen) {\n  vec2 rayToCorner = abs(rayPos) - dimen;\n  // maxDelta is the maximum negative value if the point exists inside of the box, otherwise 0.0\n  float maxDelta = min(max(rayToCorner.x, rayToCorner.y), 0.0);\n  return length(max(rayToCorner, 0.0)) + maxDelta;\n}\n\nfloat sdCross(vec3 rayPos, vec3 dimen) {\n  float da = sdRect(rayPos.xy, dimen.xy);\n  float db = sdRect(rayPos.xz, dimen.xz);\n  float dc = sdRect(rayPos.yz, dimen.yz);\n  return min(da,min(db,dc));\n}\n\nmat2 rotate(float angle) {\n    float sine = sin(angle);\n    float cosine = cos(angle);\n    return mat2(cosine, -sine, sine, cosine);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3707, 3789, 3842, 3842, 4252], [5038, 5038, 5065, 5065, 5469], [5472, 5472, 5500, 5500, 6140], [6142, 6142, 6182, 6182, 6746], [6749, 6749, 6788, 6788, 7044], [7046, 7046, 7086, 7086, 7243], [7245, 7245, 7271, 7271, 7379]], "test": "untested"}
{"id": "tlcBW2", "name": "Distance to Triangle Wave", "author": "oneshade", "description": "Exact distance to a triangle wave.", "tags": ["2d", "distancefield", "sdf", "distance", "periodic", "trianglewave", "exact"], "likes": 7, "viewed": 219, "published": 3, "date": "1613455762", "time_retrieved": "2024-07-30T19:37:44.238418", "image_code": "float udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\nfloat sdTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l))) * sign(p.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float freq = 5.125 + 4.875 * sin(iTime);\n    float amp = 0.5 + 0.5 * cos(iTime);\n    if (iMouse.z > 0.0) {\n        freq = 1.0 / abs(mouse.x);\n        amp = mouse.y * 2.0;\n        uv.x *= sign(mouse.x);\n    }\n\n    float d = int(iTime * 0.25) % 2 == 0 ? udTriangleWave(uv, freq, amp) : sdTriangleWave(uv, freq, amp);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 315], [317, 317, 379, 379, 644], [646, 646, 701, 701, 1499]], "test": "untested"}
{"id": "wlcfDj", "name": "Our energy ", "author": "YitingLiu", "description": "I love the effect of blur and defined lines when the noise aligns and intersects with each other. ", "tags": ["fractal", "noise", "simple", "fbm", "perlin", "gradient", "template", "function", "value", "cellular"], "likes": 0, "viewed": 258, "published": 3, "date": "1613449110", "time_retrieved": "2024-07-30T19:37:45.010354", "image_code": "// noise functions from youtube https://www.youtube.com/watch?v=ybbJz6C9YYA\n// git code https://github.com/Gonkee/Gonkees-Shaders/blob/master/noise%20textures.shader\n\n\nfloat rand(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin(dot(coord, vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec2 rand2(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin( vec2( dot(coord,vec2(127.1,311.7)), dot(coord,vec2(269.5,183.3)) ) ) * 43758.5453);\n}\n\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\nfloat value_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i);\n    float tr = rand(i + vec2(1.,0.));\n    float bl = rand(i + vec2(0.,1.));\n    float br = rand(i + vec2(1.,1.));\n    \n    //linear distance will cause sharp transition \n    //use smoothstep or cubic function\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tl,tr,cubic.x);\n    float botmix = mix(bl,br,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    \n    return wholemix;\n\n}\n\nfloat perlin_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i) * 6.283;\n    float tr = rand(i + vec2(1.,0.))* 6.283;\n    float bl = rand(i + vec2(0.,1.))* 6.283;\n    float br = rand(i + vec2(1.,1.))* 6.283;\n    \n    vec2 tlvec = vec2(-sin(tl),cos(tl));\n    vec2 trvec = vec2(-sin(tr),cos(tr));\n    vec2 blvec = vec2(-sin(bl),cos(bl));\n    vec2 brvec = vec2(-sin(br),cos(br));\n    \n    float tldot = dot (tlvec,f);\n    float trdot = dot(trvec,f - vec2(1.,0.));\n    float bldot = dot(blvec, f- vec2(0.,1.));\n    float brdot = dot(brvec, f - vec2(1.,1.));\n    \n    // or delete the +0.5 after the wholemix - this shows different patterns \n    //tldot = abs(tldot);\n    ////trdot = abs(trdot);\n    //bldot = abs(bldot);\n    //brdot = abs(brdot);\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tldot,trdot,cubic.x);\n    float botmix = mix(bldot,brdot,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);//maintain the brightness \n    \n    return wholemix+0.5;\n    \n}\n\nfloat cellular_noise(vec2 coord){\n   vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float min_dist=9999.;\n   for(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n        \n        vec2 node = rand2(i+vec2(x,y))+vec2(x,y);\n        float dist = sqrt((f-node).x*(f-node).x+(f-node).y*(f-node).y);\n        min_dist = min(min_dist,dist);\n       }\n    }\n    return min_dist;\n    \n}\n\n// can use it to combine with other noise functions \nfloat fbm(vec2 coord){\n    //for loop size \n    int OCTAVES =4;\n    \n    float normalize_factor =0.;\n    float value =0.;\n    float scale = 0.5; \n    \n    for (int i =0; i< OCTAVES; i++){\n    value += value_noise(coord)*scale;\n    normalize_factor +=scale; \n    coord *=2.;\n    scale *= 0.5;\n    }\n    return value/normalize_factor; \n\n\n}\n   \n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float t = iTime*.2;\n\n    vec2 coord = uv*0.01*mix(-5.,10.,uv.x*uv.y)+sin(t);\n    coord*= Rot( sin(t)*3.14 );\n\n    float noise;\n    noise = rand(coord);\n    //noise = value_noise(coord);\n    //noise= perlin_noise(coord);\n    noise = cellular_noise(coord)*2.+abs(sin(t));\n    noise *= fbm(coord)/abs(sin(t));\n    \n    float colVal = rand(vec2(coord));\n    vec3 col = vec3(0);\n    col +=texture(iChannel0,vec2(noise,clamp(0.5,1.,abs(tan(t))))).rgb;\n\n    col+=noise/colVal;\n    fragColor = vec4(1.-col*0.7,1.0);\n}\n\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 191, 191, 292], [294, 294, 317, 317, 456], [458, 458, 476, 476, 549], [550, 550, 580, 580, 1070], [1072, 1072, 1103, 1103, 2108], [2110, 2110, 2143, 2143, 2519], [2521, 2574, 2596, 2617, 2911], [2920, 2920, 2977, 3027, 3630]], "test": "untested"}
{"id": "Wl3fD2", "name": "Perfect Pistons Example 3", "author": "blackle", "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]", "tags": ["domainrepetition", "pistons"], "likes": 34, "viewed": 1265, "published": 3, "date": "1613442963", "time_retrieved": "2024-07-30T19:37:46.040599", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 3 dimensional domain repetition.\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\n//nonzero sign function\nfloat nonZeroSign(float x) {\n    return x < 0. ? -1. : 1.;\n}\n\n//closest face of the cube to p\nvec3 face(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x>=max(ap.z,ap.y)) return vec3(nonZeroSign(p.x),0.,0.);\n    if (ap.y>=max(ap.z,ap.x)) return vec3(0.,nonZeroSign(p.y),0.);\n    if (ap.z>=max(ap.x,ap.y)) return vec3(0.,0.,nonZeroSign(p.z));\n    return vec3(0);\n}\n\nfloat scene(vec3 p) {\n    vec3 center = floor(p) + .5;\n    vec3 neighbour = center + face(p - center);\n    float hs = hash(hash(center.x, center.y), center.z);\n    vec3 pos = p - center;\n    pos = erot(pos, vec3(0, 0, 1), hs*100.);\n    vec3 npos = p - neighbour;\n    float worst = box(vec3(length(npos.xy), npos.z, 0), vec3(.4, .04, .04))-.005;\n    float me = box(pos, vec3(.4, 0.04, 0.04))-.005;\n    return min(me, worst);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-2,0,0);\n    \n    float yrot = .5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n\n    vec3 p =init;\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.);\n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[288, 288, 315, 315, 401], [403, 403, 441, 441, 503], [560, 560, 590, 590, 666], [668, 692, 720, 720, 752], [754, 786, 805, 805, 1050], [1052, 1052, 1073, 1073, 1477], [1479, 1479, 1498, 1498, 1614], [1616, 1616, 1673, 1673, 2618]], "test": "untested"}
{"id": "3lcBD2", "name": "Perfect Pistons Example 2", "author": "blackle", "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]", "tags": ["domainrepetition", "pistons"], "likes": 22, "viewed": 895, "published": 3, "date": "1613442932", "time_retrieved": "2024-07-30T19:37:47.352092", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 2 dimensional domain repetition.\n\nfloat piston(vec2 p, float width, float height) {\n    p.x = abs(p.x) - width;\n    p.y -= height;\n    return length(max(p,0.0)) + min(0.0, max(p.x,p.y));\n}\n\nfloat piston3D(vec3 p, float width, float height) {\n    vec2 p2 = vec2(length(p.xy), p.z);\n    return piston(p2, width, height);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\nfloat scene(vec3 p) {\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n    float height = sin(center.y + center.x+iTime)*2.;\n    float width = .3;\n    float me = piston3D(p - vec3(center, 0), width, height)-.03;\n    float next = piston3D(p - vec3(neighbour, 0), width, 2.)-.03;\n    return min(me, next);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-7,0,0);\n    \n    float yrot = .5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    init.z += 1.;\n\n    vec3 p =init;\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.);\n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[288, 288, 337, 337, 442], [444, 444, 495, 495, 574], [576, 576, 614, 614, 676], [678, 678, 697, 697, 843], [845, 845, 866, 866, 1188], [1190, 1190, 1209, 1209, 1324], [1326, 1326, 1383, 1383, 2346]], "test": "untested"}
{"id": "3t3BD2", "name": "Perfect Pistons Example 1", "author": "blackle", "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]", "tags": ["domainrepetition", "pistons"], "likes": 14, "viewed": 768, "published": 3, "date": "1613442817", "time_retrieved": "2024-07-30T19:37:48.243709", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat piston(vec2 p, float width, float height) {\n    p.x = abs(p.x) - width;\n    p.y -= height;\n    return length(max(p,0.0)) + min(0.0, max(p.x,p.y));\n}\n\nfloat scene(vec2 p) {\n    float center = floor(p.x) + 0.5;\n    float neighbour = center + ((p.x < center) ? -1.0 : 1.0);\n\n    float width = 0.3;\n    float height = sin(iTime + center)*2.;\n    float me = piston(p - vec2(center, 0), width, height);\n    float next = piston(p - vec2(neighbour, 0), width, 2.0);\n    return min(me, next);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*100.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=5.;\n    mouse*=5.;\n\n    float mousedist = scene(mouse);\n    vec3 col = shadeDistance(scene(uv));\n    if (distance(mouse, uv) < abs(mousedist) && iMouse.z > 0.) col *=0.5;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 243, 243, 348], [350, 350, 371, 371, 685], [687, 687, 716, 716, 1029], [1031, 1031, 1088, 1138, 1474]], "test": "untested"}
{"id": "tt3fDj", "name": "2D Axis Alignment", "author": "oneshade", "description": "Alignment with a 2D axis. Change the axis with the mouse.", "tags": ["2d", "axis", "orthonormal", "basis", "axisalign"], "likes": 2, "viewed": 167, "published": 3, "date": "1613442352", "time_retrieved": "2024-07-30T19:37:49.326812", "image_code": "// up is the upwards vector, must be normalized\nvec2 axisAlign(in vec2 p, in vec2 up) {\n    return p * mat2(up.y, -up.x, up);\n}\n\nfloat sdDisc(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 s) {\n    return length(p - clamp(p, -s, s)) + min(0.0, max(abs(p.x) - s.x, abs(p.y) - s.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float l = length(mouse);\n    vec2 p = axisAlign(uv, mouse / l);\n    float d = min(sdBox(p, vec2(0.05, l)), min(sdDisc(p - vec2(0.35, 0.0), 0.05), sdDisc(p - vec2(0.0, l + 0.25), 0.05)));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 87, 87, 127], [129, 129, 166, 166, 194], [196, 196, 231, 231, 321], [323, 323, 378, 378, 1048]], "test": "untested"}
{"id": "WlcBD2", "name": "Mandelbox slices", "author": "mrange", "description": "License CC0: Mandelbox slices\nMore slices through 4D space", "tags": ["mandelbox"], "likes": 19, "viewed": 625, "published": 3, "date": "1613427262", "time_retrieved": "2024-07-30T19:37:50.559517", "image_code": "// License CC0: Mandelbox slices\n//  More slices through 4D space\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  8.0\n#define MAX_RAY_MARCHES 100\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define PERIOD          20.0\n#define FADE            2.5\n#define TIMEPERIOD      mod(TIME,PERIOD)\n#define NPERIOD         floor(TIME/PERIOD)\n\nconst float fixed_radius2 = 1.8;\nconst float min_radius2   = 0.5;\nconst vec4  folding_limit = vec4(1.0);\nconst float scale         = -2.9-0.2;\n\nfloat rand                = 0.5;\n\nfloat hash(float co) {\n  co += 6.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec4 pmin(vec4 a, vec4 b, vec4 k) {\n  vec4 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid rot(inout vec2 v, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  v.xy = vec2(v.x*c + v.y*s, -v.x*s + v.y*c);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nvoid sphere_fold(inout vec4 z, inout float dz) {\n  float r2 = dot(z, z);\n    \n  float t1 = (fixed_radius2 / min_radius2);\n  float t2 = (fixed_radius2 / r2);\n\n  if (r2 < min_radius2) {\n    z  *= t1;\n    dz *= t1;\n  } else if (r2 < fixed_radius2) {\n    z  *= t2;\n    dz *= t2;\n  }\n}\n\nvoid box_fold(float k, inout vec4 z, inout float dz) {\n  // Soft clamp after suggestion from ollij\n  vec4 zz = sign(z)*pmin(abs(z), folding_limit, vec4(k));\n  z = zz * 2.0 - z;\n}\n\nfloat mb(vec4 z) {\n  float off = iTime*0.25;\n  vec4 offset = z;\n  float dr = 1.0;\n  float d = 1E6;\n  float k = mix(0.05, 0.25, fract(37.0*rand));\n  for(int n = 0; n < 4; ++n) {\n    box_fold(k/dr, z, dr);\n    sphere_fold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n    float dd = min(d, (length(z) - 2.5)/abs(dr));\n    if (n < 2) d = dd;\n  }\n\n  float d0 = (box(z, vec4(3.5, 3.5, 3.5, 3.5))-0.2) / abs(dr);\n  return fract(17.0*rand) > 0.5 ? pmin(d0, d, 0.05) : d0;\n}\n\nfloat df(vec3 p) {\n  const float s = 1.0/6.0;\n  p -= vec3(0.0, 1.0, 0.0);\n  p /= s;\n\n  float a = fract(3.0*rand);\n  const float aa = PI/4.0;\n  const float bb = PI/4.0-aa*0.5;\n  float b = bb+aa*fract(5.0*rand);\n  float c = bb+aa*fract(7.0*rand);\n  float d = bb+aa*fract(13.0*rand);\n  vec4 pp = vec4(p.x, p.y, p.z, 2.0*a*a);\n\n  rot(pp.xw, b);\n  rot(pp.yw, c);\n  rot(pp.zw, d);\n  return mb(pp)*s;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.1;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n  \n  float h = hash(NPERIOD);\n  \n  if (t < MAX_RAY_LENGTH && pos.y > 0.0) {\n    // Ray intersected object\n    nor       = normal(pos);\n    vec3 hsv  = (vec3(fract(h - 0.6 + 0.4+0.25*t), 1.0-ifade, 1.0));\n    color     = hsv2rgb(hsv);\n  } else if (pos.y > 0.0) {\n    // Ray intersected sky\n    return skyCol*ifade;\n  } else {\n    // Ray intersected plane\n    t   = -ro.y/rd.y;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 5.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  }\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / MAX_RAY_LENGTH));\n    \n  return mix(skyCol, col , f)*ifade;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  rand = hash(NPERIOD);\n\n  vec3 ro = mix(0.3, 0.4, fract(23.0*rand))*vec3(2.0, 0, 0.2)+vec3(0.0, 1.25, 0.0);\n  rot(ro.xz, sin(TIME*0.05));\n  rot(ro.yz, sin(TIME*0.05*sqrt(0.5))*0.25);\n\n  vec3 ww = normalize(vec3(0.0, 1.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + (2.0+0.5*tanh_approx(length(p)))*ww);\n\n  vec3 col = render(ro, rd);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, FADE, TIMEPERIOD);\n  col *= 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEPERIOD);\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBD2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[788, 788, 810, 810, 871], [873, 873, 901, 921, 997], [999, 999, 1038, 1038, 1126], [1128, 1128, 1163, 1163, 1248], [1250, 1250, 1283, 1283, 1371], [1373, 1373, 1400, 1400, 1497], [1499, 1499, 1547, 1547, 1779], [1781, 1781, 1835, 1879, 1959], [1961, 1961, 1979, 1979, 2449], [2451, 2451, 2469, 2469, 2846], [2848, 2848, 2896, 2896, 3091], [3093, 3093, 3116, 3116, 3325], [3327, 3327, 3395, 3395, 3674], [3676, 3676, 3713, 3713, 3965], [3967, 3967, 3989, 3989, 4158], [4160, 4160, 4191, 4191, 5744], [5746, 5746, 5801, 5801, 6514]], "test": "untested"}
{"id": "Wl3BD2", "name": "snow day 1", "author": "elenzil", "description": "just an intermediate step that's pretty", "tags": ["colors"], "likes": 3, "viewed": 287, "published": 3, "date": "1613425218", "time_retrieved": "2024-07-30T19:37:51.323474", "image_code": "// Fork of \"ess de eff runner 1\" by elenzil. https://shadertoy.com/view/3ldyzM\n// 2021-01-02 16:41:48\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n\n    vec3 rgb = texelFetch(iChannel0, IJ, 0).rgb;\n    \n\n    RGBA.rgba = vec4(rgb, 1.0);\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float PI        = 3.14159265259;\nconst float PI2       = (PI * 2.0);\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n\n\n", "buffer_a_code": "/////////////////////////\n// this buffer is the dynamics, based on the SDF\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvec3 someColors(in vec2 XY) {\n\n//    return vec3((int(XY.x) / 50) % 2);\n\n    float smallRes = min(iResolution.x, iResolution.y);\n    vec2  p = (XY - iResolution.xy * 0.5) / smallRes * 2.0;\n\n    p *= PI2;\n\n    vec3 rgb;\n\n    p *= rot2(iTime *  0.1);\n    rgb.r = cos(p.x * 1.23) + cos(p.y * 1.04);\n    p *= rot2(iTime * -0.15);\n    rgb.g = cos(p.x * 1.31) + cos(p.y * 1.24);\n    p *= rot2(iTime *  0.1);\n    rgb.b = cos(p.x * 1.21) + sin(p.y * 1.41);\n\n    rgb = rgb * 0.25 + 0.5;\n    \n    rgb *= vec3(sin(length(p) * 1.5) * 0.1 + 0.9);\n\n    return rgb;\n}\n\nfloat meas(in vec3 rgb) {\n    return dot(rgb, rgb);\n}\n\nconst ivec2 iUp = ivec2( 0, 1);\nconst ivec2 iUL = ivec2(-1, 1);\nconst ivec2 iUR = ivec2( 1, 1);\n\nbool amRight(int i) {\n    return bool(i & 0x1);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    float f = sin(iTime * 0.5) * 0.2 + 0.8;\n    float g = sin((XY.x - iResolution.x * 0.5) * 0.04 * f);\n    bool reset = (iFrame == 0 || iMouse.z > 10.0); \n    if (reset || (XY.y > iResolution.y * 0.75 + g * iResolution.y * 0.1 * f * f * f)) {\n        RGBA = vec4(someColors(XY), 1.0);\n        RGBA.a = g;\n        return;\n    }\n\n    ivec2 IJ = ivec2(XY);\n    RGBA = texelFetch(iChannel0, IJ + iUp, 0);\n    g = RGBA.a;\n    RGBA.rgb *= (g * 0.002 + 0.998);\n\n    if (XY.y > iResolution.y * 0.5 + g * 20.0) {\n        return;\n    }\n\n    int offX = IJ.y & 0x1;\n\n    bool amR = amRight(IJ.x + offX);\n    bool amL = !amR;\n\n    vec4 rgbaOther;\n    if (amR) {\n        rgbaOther = texelFetch(iChannel0, IJ + iUL, 0);\n    }\n    else {\n        rgbaOther = texelFetch(iChannel0, IJ + iUR, 0);\n    }\n\n    for (int n = 0; n < 4; ++n) {\n        float magSqSelf = dot(RGBA     [n], RGBA     [n]);\n        float magSqOthr = dot(rgbaOther[n], rgbaOther[n]);\n\n        if (amL && (magSqOthr < magSqSelf) && (XY.x < iResolution.x  - 1.0)) {\n            RGBA[n] = rgbaOther[n];\n        }\n        else if (amR && (magSqOthr >= magSqSelf) && (XY.x > 0.0)) {\n            RGBA[n] = rgbaOther[n];\n        }\n    }\n\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 193, 193, 309]], "test": "untested"}
{"id": "3tcfWj", "name": "Peebeearray", "author": "ruojake", "description": "Taking physically based rendering for a spin", "tags": ["3d", "raymarching", "brdf"], "likes": 14, "viewed": 408, "published": 3, "date": "1613417810", "time_retrieved": "2024-07-30T19:37:52.204120", "image_code": "// Peebeearray by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// 2021-02-16:\n// - Separated metallic and roughness parameters,\n//   resulting in more diverse materials\n// - Added random offset to noise per sphere\n// - Adjusted color selection\n// - Removed negative light (oops!) and\n//   darkened the bottom of the sky accordingly\n// - Boosted diffuse lighting\n// - Made light shape less awkward\n// - Moved camera back and tightened FOV\n\n// 2021-02-17:\n// - Fixed some enormous goofs re: noise,\n//   now pattern sharpness has variation\n// - Improved noise interpolation\n\n// 2021-02-22:\n// - Squared glare falloff and boosted it a bit\n\n#define sat(x) clamp(x, 0., 1.)\n\nvec3 hash32(vec2 p)\n{\n    vec3 q = vec3(p, fract(p.x * 31.));\n    return fract(sin(q * vec3(11.312, 17.415, 13.651)) * 5131.931);\n}\n\nvec3 hash33(vec3 p)\n{\n    return fract(sin(p * vec3(11.312, 17.415, 13.651) + dot(p, vec3(.523))) * 41251.931) * 2. - 1.;\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat index(vec3 p)\n{\n    p -= vec3(0,0,3);\n    return fract(.621 + 6143.21 * sin(dot(floor(p.xy * .5 + .5), vec2(31.73, 23.46))));\n}\n\nfloat scene(vec3 p)\n{\n    p -= vec3(0,0,3);\n    p.xy = fract(p.xy * .5 + .5) * 2. - 1.;\n    return length(p) - .8;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    const vec2 e = vec2(.001, 0.);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)\n    ));\n}\n\nvec3 color(float v)\n{\n    vec3 res = vec3(1.,0,0);\n    res.xy *= rot(v * 139.);\n    res.yz *= rot(v * 199.);\n    res *= res;\n    float lum = dot(res, vec3(.2126, .7152, .0722));\n    return mix(vec3(lum), res, fract(v * 311.)) * fract(v * 239.);\n}\n\nvec3 sky(vec3 rd, vec3 ld, float k)\n{\n    vec3 col = mix(vec3(.005, .02, .05), vec3(1., .1, .5) * 1.25, rd.y * .5 + .5);\n    float sun = sat(dot(rd, ld));\n    k = max(k, .0001);\n    col += pow(sat((sun - .9992 + k) / k), 5. / k) * (30. - 25. * k * (2. - k)) + sun * sun * vec3(1.,.9,.8) * (.25 + k);\n    return col;\n}\n\nfloat fresnel(float v)\n{\n    return pow(1. - v, 5.);\n}\n\n// https://google.github.io/filament/Filament.md.html#table_texturedfg\nvec3 DFGAppr(vec3 f0, float ndv, float roughness)\n{\n    vec4 c0 = vec4(-1., -.0275, -.572, .022);\n    vec4 c1 = vec4(1., .0425, 1.04, -.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndv)) * r.x + r.y;\n    vec2 ab = vec2(-1.04, 1.04) * a004 + r.zw;\n    return f0 * ab.x + ab.y;\n}\n\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);  \n    vec3 f = fract(p);\n    vec3 f3 = f * f * f;\n    vec3 u = 6. * f3 * f * f - 15. * f3 * f + 10. * f3;\n    vec2 o = vec2(1,0);\n    \n    return mix(\n        mix(\n            mix(dot(hash33(i + o.yyy), f - o.yyy), dot(hash33(i + o.xyy), f - o.xyy), u.x),\n            mix(dot(hash33(i + o.yxy), f - o.yxy), dot(hash33(i + o.xxy), f - o.xxy), u.x),\n            u.y\n        ),\n        mix(\n            mix(dot(hash33(i + o.yyx), f - o.yyx), dot(hash33(i + o.xyx), f - o.xyx), u.x),\n            mix(dot(hash33(i + o.yxx), f - o.yxx), dot(hash33(i + o.xxx), f - o.xxx), u.x),\n            u.y\n        ),\n        u.z);\n}\n\nfloat fbm(vec3 p)\n{\n    return (noise(p)\n        + noise(p * 2. + 1.) * .5\n        + noise(p * 4. + 2.) * .25\n        + noise(p * 8. + 4.) * .125)\n        / 1.875;\n}\n\nfloat pattern(vec3 p, float h)\n{\n    p -= vec3(0,0,3);\n    p = fract(p * .5 + .5) * 2. - 1.;\n    float t = iTime * .5;\n    p.xz *= rot((fract(h * 1111.) * 2. - 1.) * t);\n    p.xy *= rot((fract(h * 773.) * 2. - 1.) * t);\n    float n = fbm(p * (.5 + fract(h * 127.)) + h * 541.);\n    float q = fract(h * 41.) * .5 + .49;\n    return smoothstep(-1. + q, 1. - q, n) * (fract(h * 229.) * .5 + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0,iTime * .2,-7);\n    vec3 rd = normalize(vec3(uv, 2.));\n    float t = 7.;\n    float d = 0.;\n    vec3 p = vec3(0);\n    float i = 0.;\n    \n    for(; i < 1. && p.z < 4.; i += 1./128.)\n    {\n        p = ro + rd * t;\n        d = scene(p);\n        t += d * 1.1;\n        if(abs(d) < .001) break;\n    }\n    \n    vec3 ld = normalize(vec3(1,sin(iTime * .125) * .35 + .4,1));\n    ld.xz *= rot(iTime * .25);\n    vec3 col = vec3(0);\n    \n    if (p.z < 4.)\n    {\n        float h = index(p);\n        vec3 n = normal(p, d);\n        float pat = pattern(p, h);\n        vec3 abd = mix(color(h), color(h * 47.), pat);\n        float mtl = mix(fract(h * 113.), fract(h * 311.), pat);\n        float rgh = mix(fract(h * 487.), fract(h * 83.), pat);\n        vec3 spec = sky(reflect(rd, n), ld, max(rgh, .0001));\n        \n        vec3 diff = abd * sky(n, ld, 1.) * mtl;\n        vec3 f0 = max(abd * (1. - mtl), vec3(.04));\n        col = mix(diff, spec, DFGAppr(f0, dot(-rd, n), rgh));\n    }\n    else\n        col = sky(rd, ld, .01);\n        \n    col = col * (1. + col / 20.) / (1. + col);\n    col = pow(col, vec3(1./2.2));\n    col += hash32(fragCoord) / 255.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfWj.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[718, 718, 739, 739, 849], [851, 851, 872, 872, 974], [976, 976, 995, 995, 1071], [1073, 1073, 1094, 1094, 1206], [1208, 1208, 1229, 1229, 1324], [1326, 1326, 1356, 1356, 1509], [1511, 1511, 1532, 1532, 1757], [1759, 1759, 1796, 1796, 2076], [2078, 2078, 2102, 2102, 2132], [2134, 2205, 2256, 2256, 2521], [2523, 2523, 2544, 2544, 3182], [3184, 3184, 3203, 3203, 3349], [3351, 3351, 3383, 3383, 3744], [3746, 3746, 3803, 3803, 5054]], "test": "untested"}
{"id": "3lcBDj", "name": "Halftone Webcam", "author": "TekF", "description": "I just bought a webcam so I made a simple halftone filter! Mouse controls brightness.", "tags": ["halftone", "webcam"], "likes": 5, "viewed": 747, "published": 3, "date": "1613416408", "time_retrieved": "2024-07-30T19:37:52.970072", "image_code": "// comment these out for different effects\n#define monochrome 1\n//#define nearestDot 1\n\nconst float numberOfDots = 72.; // horizontally across screen\n\nvec3 PixelGrid ( vec2 p )\n{\n    float dotSize = iResolution.x/numberOfDots;\n    vec2 tileSize = vec2(.5,sqrt(3./4.)) * dotSize;\n    p /= tileSize;\n    p = fract(p/2.)*2.-1.;\n    vec2 s = sign(p);\n    p = abs(p);\n    p *= tileSize;\n\n    // this is not the best way to do this, but I am lazy (could just mirror it)\n    if ( length(p) > length(p-tileSize) )\n        p = p-tileSize;\n    \n    float value = dot(p,p)*4./dot(tileSize,tileSize); // based on area\n    \n    return vec3( p*s, clamp(1.-value,0.,1.) );\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec3 grid = PixelGrid(fragCoord);\n\n    #ifdef nearestDot\n        fragCoord.xy -= grid.xy;\n    #endif\n\n    fragColour = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    \n    fragColour.rgb = pow( fragColour.rgb, vec3(2.2) ); // gamma->linear\n\n    #ifdef monochrome\n        fragColour.rgb = vec3( dot( fragColour.rgb, vec3(.2,.7,.1) ) );\n    #endif\n    \n    float brightness = .4;\n    if ( iMouse.y > 0. ) brightness = iMouse.y/iResolution.y;\n\n    fragColour.rgb = (fragColour.rgb-.0)*(1.+20.*brightness);\n\n    // aliased version\n//    float spots = step( .0, monochrome - grid.z );\n    \n    // anti-aliased version\n    vec3 f = fragColour.rgb-grid.z;\n    vec3 spots = smoothstep( -f, 1.-f, f/max(fwidth(f),.01) );\n\n    fragColour.rgb = spots;\n\n    //if ( fragCoord.x < iMouse.x ) fragColour.rgb = vec3(monochrome);  // test the gamma and dot area maths is correct\n\n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) ); // linear->gamma\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 178, 178, 659], [661, 661, 719, 719, 1667]], "test": "untested"}
{"id": "3l3BDj", "name": "PBR Ray Marcher", "author": "ArenaGrenade", "description": "A simple PBR ray march shader", "tags": ["raymarhcingpbr"], "likes": 1, "viewed": 263, "published": 3, "date": "1613412624", "time_retrieved": "2024-07-30T19:37:53.822792", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat sdSphere( vec3 p, vec3 c, float r ) {\n    return length(p - c) - r;\n}\n\nfloat sdPlane( vec3 p, float height ) {\n    return p.y - height;\n} \n\nfloat sdScene( vec3 p ) {\n    float sphere = sdSphere(p, vec3(0, 0, 6), 1.0);\n    float plane = sdPlane(p, -1.0); \n    return min(sphere, plane);\n}\n\nfloat castRay( vec3 ro, vec3 rd ) {\n    float d0 = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + d0 * rd;\n        float dS = sdScene(p);\n        \n        d0 += dS;        \n        if ( dS <= SURF_DIST || d0 >= MAX_DIST ) break;\n    }\n    \n    return d0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = vec3(uv, 1.0);\n    \n    float d = castRay(ro, rd);\n\n    vec3 col = vec3(d / 8.0);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3BDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 112, 112, 144], [146, 146, 185, 185, 212], [215, 215, 240, 240, 362], [364, 364, 399, 399, 647], [649, 649, 706, 706, 943]], "test": "untested"}
{"id": "Wt3BWj", "name": "Rainbow Pixel Art TEST", "author": "Gadofu", "description": "LMB — draw", "tags": ["pixelart"], "likes": 5, "viewed": 285, "published": 3, "date": "1613408506", "time_retrieved": "2024-07-30T19:37:54.674514", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float nsin( float b ){ return sin(b)*.5+.5; }\nfloat pi = 3.1415926; \nfloat scale = 16.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float t = iTime*5.; \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 R = vec4( floor( fragCoord / scale ) == floor( iMouse.xy / scale ) ); \n    fragColor = (1.-R)*texture(iChannel0, uv);\n    fragColor+=R*vec4(nsin(t+pi/3.), nsin(t+pi), nsin(t-pi/3.), R.x); \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3BWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 140]], "test": "untested"}
{"id": "wldfDB", "name": "Day 424", "author": "jeyko", "description": "potaten", "tags": ["mdtmjvm"], "likes": 7, "viewed": 394, "published": 3, "date": "1613408110", "time_retrieved": "2024-07-30T19:37:55.607021", "image_code": "// dont fullscreen\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    fragColor.xyz = abs(fragColor.xyz);\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.1,1.1,1.1));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.05));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n       \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat envcnt = 0.;\n\nfloat getEnv(float t, float speed, float pa, float pb, float jumpAmt, bool cnt){\n    //return pow(sin((t - 0.5)*3.14),1.)*0.5 + 0.5;\n    t = clamp(t*speed,0.,1.);\n    \n    envcnt += float(t > 0.99 && cnt);\n    //t = smoothstep(0.,1.,t);\n    pa += 1.;\n    pb += 1.;\n    \n    float c = cos(t*3.14);\n    float a = 1.- ((pow(abs(c),pa)*sign(c))*0.5 + 0.5);\n    float b = 1.-((pow(abs(c),pb)*sign(c))*0.5 + 0.5);\n    \n    a = pow(sin(t*3.14/2.),pa);\n    b = 1.-pow(sin((-t + 1.)*3.14/2.),pb);\n    \n    b *= 1. + (\n            smoothstep(0.,1.,t) *smoothstep(0.99,0.7,t)*jumpAmt\n        );\n    return mix( a, b,t);\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    \n    uv += sin(iTime*vec2(3,2)*0.5)*0.01;\n\n\n    vec3 col = vec3(0);\n    \n    float vn = valueNoise(iTime + uv.x*0.2, 2.)*1.;\n    float t = iTime*1. - vn*0.1 + sin(iTime);\n        \n    float env = getEnv(t, 1., 2., 2., 1., false);\n    \n    \n    float nb = cyclicNoise(vec3(uv*0.5 + t*0.,-t*0.2 ), false, t*0.1);\n    \n    float n = cyclicNoise(vec3(uv*(3.5- dot(uv,uv)) - vec2(sin(t)*0.5,cos(t*0.6)*0.6) ,t*0.5 - nb) , false, t*0.);\n\n    \n    float r = 12. - n*3.;\n    int didx = 3;\n    vec2 dfn = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n    \n    r = 16. - n*10. + nb*15.;\n    didx = 3;\n    \n    vec2 dfnb = vec2(T(U + vec2(1.,0)*r)[didx] - T(U - vec2(1.,0)*r)[didx],T(U + vec2(0.,1)*r)[didx] - T(U - vec2(0.,1)*r)[didx]);\n    \n    \n    //col += 1.-abs(length(dfn.xyx))*4.;\n    \n\n    vec3 c = 1.-vec3(0.15+ sin(length(dfnb)*5. + iTime+ n*10.)*0.1 ,0.1 + n*0.1 + sin(nb*20. + t)*0.05 ,0.1 );\n    c *= 0.8;\n    col = mix(col,c,smoothstep(0.1 + n*0.4 - nb*0.2,1.5,length(dfnb.xy)));\n    \n    col = mix(col,3.*vec3(0.15,0.15,0.15 + 0.5*sin(nb*20.)*0.1)*0.3,smoothstep(-0.1,0.4,-length(dfn)));\n    \n    \n    \n    C = vec4(col,n);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 fr = texture(iChannel0,(U)/iResolution.xy);\n   \n    float r = 1. + sin(fr.w*4.)*0.5+ sin(fr.w*11.)*0.4;\n    int didx = 3;\n    \n    vec2 dfn = vec2(T0(U + vec2(1.,0)*r)[didx] - T0(U - vec2(1.,0)*r)[didx],T0(U + vec2(0.,1)*r)[didx] - T0(U - vec2(0.,1)*r)[didx]);\n    \n    float sc = 0. + valueNoise(iTime*4.,2.)*0. \n        + pow(smoothstep(0.,1.,length(dfn.x)*9.),2.7)*2.1;\n    \n    C.x =texture(iChannel0,(U + sc*vec2(0,4))/iResolution.xy).x;\n    \n    C.y =texture(iChannel0,(U + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    C.z =texture(iChannel0,(U + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\n\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define pi acos(-1.)\n\n#define R (iResolution.xy)\n#define T(u) texture(iChannel2,(u)/R)\n#define T0(u) texture(iChannel0,(u)/R)\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.5);\n    float amp = 1.;\n    float gain = 1. + sin(p.x*3.5 + time)*0.1;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =0.4;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*0.2,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.1,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 2;\n    \n    const float warp =.4;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat sdSq(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 990]], "test": "untested"}
{"id": "tltBDB", "name": "Mandelbrot Fractal Demo", "author": "moranzcw", "description": "Mandelbrot fractal.", "tags": ["2d", "fractal", "mandelbrot"], "likes": 2, "viewed": 258, "published": 3, "date": "1613404881", "time_retrieved": "2024-07-30T19:37:56.454755", "image_code": "// Mandelbrot Fractal Demo - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define Scale 1.4\n\nvec3 fractal(vec2 p)\n{    \n\tvec2 z = vec2(0);  \n    \n    int depth = int(mix(3.0, 64.0, sin(iTime) * 0.5 + 0.5));\n\tfor (int i = 0; i < depth; ++i) \n    {\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + p; \n\n\t\tif (dot(z,z) > 4.) \n        {\n\t\t\tfloat s = .05 * float(i);\n\t\t\treturn vec3(vec3(cos(s + 0.5), cos(s + 0.5), cos(s + 0.5)) * 0.4 + 0.6);\n\t\t}\n\t}\n\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    coord *= Scale;\n    coord -= vec2(0.5, 0.0);\n\n    vec3 color = vec3(0);\n    \n    color = fractal(coord);\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBDB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[185, 185, 207, 207, 565], [567, 567, 624, 624, 832]], "test": "untested"}
{"id": "wtdfDS", "name": "15/02/2021 stream", "author": "anticore", "description": "coded live on twitch\nhttps://www.twitch.tv/antic0re_", "tags": ["raymarch", "glow", "live", "stream"], "likes": 4, "viewed": 340, "published": 3, "date": "1613401923", "time_retrieved": "2024-07-30T19:37:57.403219", "image_code": "\n\nfloat ni(float x) {\n    //return texture(texFFTIntegrated, x).x;\n    return texelFetch( iChannel0, ivec2(x * 512.,0), 0 ).x * 2.;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n  \n    return mat2(c, s, -s, c);\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    return mod(p + .5 * c, c) - .5 * c;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - 0.1;\n}\n\nvec3 a = vec3(0);\n\nfloat sdBlock(vec3 p, vec3 pos) {\n     p += pos;\n     //p.xy *= rot(fGlobalTime);\n     //p.xz *= rot(fGlobalTime);\n  \n    return sdBox(p, vec3(.3, .3, .3));\n}\n\nvec2 sdBlocks(vec3 p) {\n    p.yz *= rot(0.6);\n    p.xz *= rot(-.6);\n    vec3 v = round(p);\n    float d = sdBlock(rep(p, vec3(1., 0., 1.)), vec3(0., 2. + sin(v.z * 10. + v.x * 10. + iTime + ni(0.) * 15.) * 0.04, 0.));\n    if (mod(v.x, 3.) == 0. && mod(v.z, 3.) == 0.) { \n      //a = vec3(1); \n      return vec2(d, 1);\n    }\n    else { \n      a = vec3(sin(v.x * 0.5 + v.z * 0.5 + iTime), cos(v.z * 0.8 + v.x * 0.2 + iTime * 0.5), sin(v.x + iTime)); \n      return vec2(d, 0);\n    }\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n    return length(p + pos) - r;\n}\n\nvec2 map(vec3 p) {\n    p += vec3(iTime / 2., 0., 0.);\n    //float box = sdBlocks(p);\n    return sdBlocks(p);\n}\n\nvec3 bg(vec2 uv) {\n    return vec3(0.);\n}\n\nvec3 dirlight(vec3 lp, vec3 lc, vec3 p, vec3 n) {\n    vec3 ld = normalize(lp - p);\n    float diff = max(dot(n, ld), 0.01);\n    return diff * lc;\n}\n\nvec3 spec(vec3 lp, vec3 lc, vec3 p, vec3 n) {\n    vec3 ld = normalize(lp - p);\n    vec3 r = reflect(-ld, n);\n    vec3 v = normalize(-p);\n    float speca = max(dot(r, v), 0.);\n    return pow(speca, 10.) * lc;\n}\n\nvec3 light(vec3 lp, vec3 lc, vec3 p, vec3 n) {\n    vec3 d = dirlight(lp, lc, p, n);\n    float kd = 0.5;\n    vec3 s = spec(lp, lc, p, n);\n    float ks = 0.5;\n  \n    return kd * d + ks * s;\n}\n\nvec3 norm(vec3 p) {\n  float E = 0.01;\n  vec2 k = vec2(1, -1);\n  \n  return normalize(\n    k.xyy * map(p + k.xyy * E).x +\n    k.yyx * map(p + k.yyx * E).x +\n    k.yxy * map(p + k.yxy * E).x +\n    k.xxx * map(p + k.xxx * E).x\n  );\n}\n\nvec3 fog(vec3 c, vec3 fc, float d) {\n  float fa = .5 - exp(-d * 0.01);\n  return mix(c, fc, fa);\n}\n\nvec3 blockcolor(vec3 p, vec3 n) {\n  return light(vec3(20,20,20), vec3(1), p, n) * 0.8 + a * 0.2;\n}\n\nvec3 lightblocksub(vec3 p, vec3 n, float d) {\n  return vec3(0,0,1) * 0.01;\n}\n\nvec3 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n  \n    vec3 tbc = vec3(0);\n    vec3 tbg = vec3(0);\n  \n    for (int i = 0; i < 200; i++) {\n      h = map(ro + rd * td);\n      \n      if (h.x > 0.001) {\n        td += h.x;\n      } else {\n          td += 0.01;\n      }\n      \n      \n      if (h.y == 1. && h.x < 0.3 && h.x > 0.0) {\n          tbg += vec3(0.3, 0.1, 0.3) *  0.1;\n      }\n      \n      if (h.x < 0.01) {\n          vec3 ip = ro + rd * td;\n          vec3 inorm = norm(ip);\n        \n          if (h.y == 0.) {\n              //return fog(light(vec3(20,20,20), vec3(1), ip, inorm) * 0.8 + a * 0.2, bg(uv), length(ip)); \n              return (blockcolor(ip, inorm)) + tbc + tbg;\n              //return inorm;\n          } else \n          \n          if (h.y == 1. && h.x < 0.001) {\n              tbc += lightblocksub(ip, inorm, h.x);\n          } else {\n              tbc += 0.05 * inorm + spec(vec3(20,20,20), vec3(1), ip, inorm) * 0.5;\n          } \n      }\n    }\n    \n    return bg(uv) + tbc + tbg;\n}\n\n//void main(void)\n//{\n//  vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n//  uv -= 0.5;\n//  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  \n//  vec3 ro = vec3(0,0,2);\n//  vec3 rd = normalize(vec3(uv, 0) - ro);\n  \n//  out_color = vec4(tr(ro, rd, uv), 1);\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 ro = vec3(0,0,2);\n  vec3 rd = normalize(vec3(uv, 0) - ro);\n\n    // Output to screen\n    fragColor =  vec4(tr(ro, rd, uv), 1);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 66, 133], [135, 135, 154, 154, 233], [235, 235, 261, 261, 303], [305, 305, 334, 334, 429], [450, 450, 483, 483, 608], [610, 610, 633, 633, 1090], [1092, 1092, 1135, 1135, 1169], [1171, 1171, 1189, 1189, 1281], [1283, 1283, 1301, 1301, 1324], [1326, 1326, 1375, 1375, 1472], [1474, 1474, 1519, 1519, 1683], [1685, 1685, 1731, 1731, 1874], [1876, 1876, 1895, 1895, 2105], [2107, 2107, 2143, 2143, 2204], [2206, 2206, 2239, 2239, 2304], [2306, 2306, 2351, 2351, 2382], [2384, 2384, 2420, 2420, 3403], [3702, 3702, 3759, 3809, 3987]], "test": "untested"}
{"id": "ttdfzf", "name": "Isometric Fractal Cubes", "author": "Shane", "description": "Using a basic hexagon fractal structure to stack 2D isometric cubes in a way that resembles a Sierpinski triangle.", "tags": ["2d", "fractal", "cube", "isometric", "polar", "sierpinski"], "likes": 34, "viewed": 628, "published": 3, "date": "1613397589", "time_retrieved": "2024-07-30T19:37:58.463384", "image_code": "/*\n\n    Isometric Fractal Cubes\n    -----------------------    \n    \n    Applying simple fractal priciples to render isometric cubes in a \n    Sierpinski fashion. The result is something resembling stacked cubes.\n    As you can see, this is a 2D process. However, in many ways, it\n    would be easier to perform in 3D, but where's the fun in that? :)\n    \n    I started this a while back then forgot about it. I was motivated to \n    finish it after viewing Kali's cool polygon fractal example. Fizzer \n    also has an excellent hexagonal fractal demonstration that involves \n    similar principles. I've provided both links below for anyone \n    interested in this kind of thing.\n    \n    The idea behind polygon fractals is pretty simple: Render a polygon,\n    subdivide space into polar cells and render more objects in each of\n    those cells, subdivide the resultant cells and render more objects \n    around the newly rendered objects... Continue ad infinitum, as they say. \n    Anyway, I've put together a much cleaner, simpler version for anyone\n    who would like to understand this particular example better. The link\n    is below.\n    \n    \n    \n    Other 2D polygon-based fractal examples:\n    \n    \n    // Very watchable, and with virtually no code. \n    Pen Patterns - Kali\n    https://www.shadertoy.com/view/tsdfWf\n    \n    // A very cool hexagon fractal pattern.\n    Linked Rings Fractal Tiling - Fizzer\n    https://www.shadertoy.com/view/3l3fRn\n    \n    // An unlisted accompanying shader featuring the basic fractal cube \n    // structure only, which should make things easier to comprehend.\n    Sierpinski Fractal Cubes - Shane\n    https://www.shadertoy.com/view/tldfzX\n\n*/\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 1.;//2./3.;\n    \n    // Smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv*gSc + vec2(1, 0)*iTime/4.;//HSCALE*iTime/4.;\n    \n    vec2 oP = p;\n   \n    p.y += 1./8./gSc; \n    \n  \n    #ifdef REPEAT_GRID\n    vec4 p4 = getGrid(p); \n    vec2 id = (p4.zw + .5)*HSCALE;//\n    p = p4.xy;\n    #else\n    vec2 id = floor(vec2(p.x*.8660254, 0));\n    p.x -= (id.x + .5)/.8660254;\n    //float ndg = .25*pow(.5, 5.);\n    //p.x = mod(p.x, sqrt(3.)/2. + ndg) - (sqrt(3.)/2. + ndg)*.5;\n    #endif\n \n     // Distance field holders for the cubes, lines and the previous\n    // cube (used for CSG related to overlap).\n    float d = 1e5, ln = 1e5, prevD = 1e5; \n    \n    // Edge width. \n    const float ew = .0015;\n    \n    // Render a simple gradient background... There'd be a neater way to do\n    // this, but I was in a hurry. :)\n    float shd = .5 - uv.y*.5;\n    vec3 bg = mix(vec3(.25, .5, 1).xzy, vec3(.25, .5, 1), 1./(1. + shd*shd));\n    bg = mix(bg, bg.zyx, .5*shd*shd);\n    vec3 col = bg;\n    \n    // Box center.\n    vec2 cntr = vec2(0);\n    \n    // Cube scale and height. These will be scaled further on each fractal level.\n    float sc = .25;\n    float sch = sc/.8660254;\n    \n    // Shadow normal and shadow scale.\n    vec2 n = normalize(vec2(1, -2));\n    float shF = iResolution.y/450.; // Shadow resize factor.\n    float scSh = .025*shF;\n    \n    \n    // Number of fractal levels.\n    #ifdef REPEAT_GRID\n    int nn = 4;\n    #else\n    int nn = 3 + int(abs(mod(id.x, 4.) - 2.));\n    #endif\n    \n    // Render the fractal levels.\n    for(int i = 0; i<nn; i++){\n    \n        \n        // Break at random levels to give the appearance of random stacks.\n        #ifndef REPEAT_GRID \n        if(mod(id.x, 3.)<1.5 && hash21(id + cntr + .1)<float(i)/float(nn)*.5) break;\n        #endif\n        \n       \n        // Random number for this particular stack and box position.\n        float rnd = hash21(id + cntr);\n        //\n        #ifdef REPEAT_GRID \n        rnd = (float((i + 2)%nn))*.3;\n        #endif\n      \n        // Fake AO and drop shadow.\n        float dsh = hDist(p, sc);\n        col = mix(col, vec3(0)*.1, (1. - smoothstep(0., sf*10.*shF, dsh))*.2);\n        dsh = hDist(p - n*scSh, sc);\n        col = mix(col, vec3(1.1, 1, .9)*.1, (1. - smoothstep(0., sf*10.*shF, dsh))*.3);\n        scSh *= .7;\n        \n        // Obtain the individual cube face quad distances. There are three\n        // visible to the viewer.\n        vec3 d3 = cubeQuads(p, sc*2.);\n        \n        \n        // Iterate through the cube faces for this level.\n        for(int j = 0; j<3; j++){\n            \n            // Face ID... A mixture of common sense and trial and error, as always. :D\n            int fid = 2 - (i - j + 4)%3;\n            \n            // Normal based shade.\n            float sh = .5 + (float(fid)/2.)*.5;\n            // Distance based shade.\n            float shd = max(1. + d3[j]/sc/2., 0.);\n            \n            // Produce a shaded color for the face.\n            vec3 fCol = .65 + .35*cos(6.2831*rnd/2.5 + vec3(0, 1, 2) - 1.);\n            fCol *= sh*sh*1.5;\n            if(i<nn - 1) fCol *= vec3(1)*shd;\n            \n            // Render the shaded face color and a mild inner edge.\n            col = mix(col, min(fCol, 1.), (1. - smoothstep(0., sf, d3[j])));\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs( d3[j] + ew*5.5) - ew/2.))*.5);\n       \n            \n        \n        }\n        \n        \n        // Apply edges over the top of the quads.\n        float cube = min(min(d3[0], d3[1]), d3[2]);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cube) - ew/2.))*.95);\n       \n        // Cube centers, for debugging purposes.\n        //col = mix(col, vec3(0), 1. - smoothstep(0., sf, length(p) - .015));\n        \n        // Here's the fun polar fractal stuff.. And by that I mean, it wasn't fun. It never is. :D\n        // Having said that, it's based on a simple fractal setup, which involves making \n        // copies of objects, then rendering them in coordinated places at different scales,\n        // rotations, etc.\n        \n        // Obtain three repeat polar angles around the cube.\n        float aNum = 3.;\n        p = rot2(6.2831/6.)*p;\n        float a = mod(atan(p.x, p.y), 6.2831);\n        float ia = floor(a/6.2831*aNum);\n        ia = (ia + .5)/aNum*6.2831;\n        \n        // Rotate the object by this particular polar angle.\n        p = rot2(ia)*p;\n        // Move it out from the object at the angle above.\n        p -= vec2(0, sch);\n        // Rotate the object in situ.\n        p = rot2(ia*2.)*p;\n\n        \n        // Do the same for the object center. The center doubles\n        // as a unique ID point, which is used for coloring.\n        cntr = rot2(6.2831/6.)*cntr;\n        cntr = rot2(ia)*cntr;\n        cntr += vec2(0, sch);\n        cntr = rot2(ia*2.)*cntr;\n        \n        // Rotate the shadow direction vector to in unison with the\n        // above, so the shadows face the same way on each cube -- Note \n        // that normal translation isn't necessary... Sometimes, 2D is \n        // more annoying than 3D. :) \n        n = rot2(6.2831/6.)*n;\n        n = rot2(ia)*n;\n        n = rot2(ia*2.)*n;\n        \n     \n        // Reduce vertical cube distace and scale for the next iteration.\n        sch *= .5; // Reduce scale height.\n        sc *= .5; // Reduce scale.\n        \n         \n        \n     \n    }\n    \n    // Apply a simple pixelated hatch to give the scene an oldschool look.\n    #ifdef NAIVE_HATCH\n    float hatch = doHatch(oP/gSc, iResolution.y);\n    col *= hatch*.35 + .8;\n    #endif\n\n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "// UTILITY FUNCTIONS -- These are just worker functions. All the logic is contained\n// within the \"Image\" tab.\n\n// Showing that you can render this on a hexagonal grid... I thought it'd look\n// more interesting that it does, but it's there as an option anyway. :)\n//#define REPEAT_GRID\n\n// Simple pixelated hatch.\n#define NAIVE_HATCH\n\n// Hexagon cell scale.\n#define HSCALE vec2(.5, .8660254)\n\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-1, -1./3.), vec2(-1, 1./3.), vec2(0, 2./3.), \n                      vec2(1, 1./3.), vec2(1, -1./3.), vec2(0, -2./3.));\n\n\n/*\n// Hexagon arrangement. Flat top or pointed top.\n//#define FLAT_TOP\n\n// This sets the scale of the extruded shapes.\n#ifdef FLAT_TOP\n#define HSCALE vec2(.8660254, .5)\n#else \n#define HSCALE vec2(.5, .8660254)\n#endif\n\n#ifdef FLAT_TOP\n//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-2./3., 0)/vec2(1, .5), vec2(-2./6., .5)/vec2(1, .5), vec2(2./6., .5)/vec2(1, .5), \n                      vec2(2./3., 0)/vec2(1, .5), vec2(2./6., -.5)/vec2(1, .5), vec2(-2./6., -.5)/vec2(1, .5)); \nvec2[6] eID = vec2[6](vec2(-.5, .25)/vec2(1, .5), vec2(0, .5)/vec2(1, .5), vec2(.5, .25)/vec2(1, .5), \n                      vec2(.5, -.25)/vec2(1, .5), vec2(0, -.5)/vec2(1, .5), vec2(-.5, -.25)/vec2(1, .5));\n#else\n// Vertices and edge midpoints: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.)/vec2(.5, 1), vec2(-.5, 2./6.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1), \n                      vec2(.5, 2./6.)/vec2(.5, 1), vec2(.5, -2./6.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));\nvec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1), vec2(.5, 0)/vec2(.5, 1), \n                      vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));\n#endif\n*/\n////////\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n\n\n\n\n#ifdef REPEAT_GRID\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec2 s = HSCALE;\n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n#endif\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n    \n}\n\n\n// Hexagon bound -- Accurate enough for this example.\nfloat hDist(vec2 p, float sc){\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x) - sc;\n}\n\n\n// Entirely based on IQ's signed distance to a 2D triangle. I've expanded it \n// to work with convex quads and generalized it a bit, but I doubt it would \n// translate to speed. It would be easy to generalize to convex polyons though.\nfloat quad(in vec2 p, in vec2[4] v){\n\n    // Lines between successive vertex points.\n    vec2[4] e = vec2[4](v[1] - v[0], v[2] - v[1], v[3] - v[2], v[0] - v[3]);\n    \n    // Winding related sign.\n    float s = sign(e[0].x*e[3].y - e[0].y*e[3].x);\n    \n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<4; i++){\n        \n        // Minimum point to line calculations.\n        vec2 vi = p - v[i];\n        vec2 qi = vi - e[i]*clamp(dot(vi, e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(qi, qi), s*(vi.x*e[i].y - vi.y*e[i].x)));\n    }\n\n    // Quad distance.\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Returns the 3 viewable cube face distances.\nvec3 cubeQuads(vec2 p, float sc){\n\n\n    vec2 hSc = HSCALE*sc;\n    vec3 d;\n    \n    // Iterate through the three cube faces.\n    for(int j = 0; j<3; j++){\n        \n        // Using the hexagon vertices to constructing the 3 viewable cube quad faces.\n        vec2[4] v = vec2[4](vID[(j*2 + 5)%6]*hSc, vID[(j*2)%6]*hSc, vID[(j*2 + 1)%6]*hSc, vec2(0));\n\n        // Face quad.\n        d[j] = quad(p, v);\n            \n    }\n    \n    return d;\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtdfWB", "name": "Rabbit chaos", "author": "mdb", "description": "the population of rabbits", "tags": ["chaos"], "likes": 1, "viewed": 267, "published": 3, "date": "1613391653", "time_retrieved": "2024-07-30T19:37:59.229336", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy + 0.9*(vec2(fract(iTime), fract(iTime*0.3)) - 0.5))/iResolution.xy;\n    float k = uv.x * 4.0;\n    float Xn = texture(iChannel0, vec2(uv.x, 0.0)).x;\n    if (iTime <= 0.05) Xn = 0.5;\n    int iterPerFrame = 22;\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    if (uv.y <= 0.005){\n        for(int i = 0; i < iterPerFrame; i++) Xn = k * Xn * (1.0-Xn);\n        col = vec3(Xn);\n        \n    }else{\n        for(int i = 0; i < iterPerFrame; i++){\n            col += max(0.0, -abs(uv.y - Xn)+0.0009) * 10.0;\n            Xn = k * Xn * (1.0-Xn); //iterate to the next pop size\n        }\n    }\n    fragColor = vec4(col,1.0);\n    // 0 < k < 4\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 249]], "test": "untested"}
{"id": "3tdBDS", "name": "Fork 2D Clouds transparen-bg", "author": "fawadtariq", "description": "i want to build a shader that produces clouds with a transparent background\nfork: https://www.shadertoy.com/view/4tdSWr", "tags": ["fractal", "noise", "clouds", "fbm"], "likes": 11, "viewed": 1528, "published": 3, "date": "1613376685", "time_retrieved": "2024-07-30T19:38:00.109982", "image_code": "const float cloudscale = 1.5;\nconst float speed = 0.03;\nconst float clouddark = 0.555;\nconst float cloudlight = 0.55;\nconst float cloudcover = 0.05;\nconst float cloudalpha = 4.1;\nconst float skytint = 0.3;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    vec4 textureMap = texture(iChannel0,p);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv += q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv - (time*0.9);\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv += q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv - (time*0.9);\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv += q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv - (time*0.9);\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv += q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv - (time*0.9);\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 texVec3 = vec3(textureMap.x, textureMap.y, textureMap.z);\n    vec3 texColour = mix(texVec3, texVec3, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(texColour, clamp(skytint * texColour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 365, 365, 478], [480, 480, 506, 506, 1030], [1032, 1032, 1051, 1051, 1205], [1259, 1259, 1316, 1316, 3122]], "test": "untested"}
{"id": "WtfcW2", "name": "\"Remember\" by Becca Tindol", "author": "amhall", "description": "Procedural render of \"Remember\" by Becca Tindol, with a purple border added and some other slight modifications. See comments at the top for more info.\nClick to change recursion angle and intensity.", "tags": ["raymarching", "mouse", "rainbow", "recursion", "dna"], "likes": 18, "viewed": 644, "published": 3, "date": "1613372518", "time_retrieved": "2024-07-30T19:38:01.387566", "image_code": "// Procedural render of \"Remember\" by Becca Tindol\n// Original - https://www.instagram.com/p/CHb3Su8HF6g/\n// Check out her other art! https://linktr.ee/alteredmoonart\n// Created by Anthony Hall, December 2020\n\n// Supersample more toward the center to reduce aliasing\n// At high resolutions, this doesn't impact performance very much\nconst bool dynamicSupersample = true;\n\n// The base number of samples to take on each axis\nconst int baseSamples = 1;\n\n// Render a border between layers\n// Disabling this makes the result more accurate to the original artwork\nconst bool renderBorder = true;\n\n// Frequency of layer zoom, glow oscillation, DNA rotation, and sky movement\nconst float zoomFrequency = 0.6667;\nconst float glowFrequency = 0.5 * zoomFrequency;\nconst float twistFrequency = -0.75 * zoomFrequency;\nconst float skyFrequency = 5. * zoomFrequency;\n\n// Raymarching constants\nconst float maxDistance = 50.0;\nconst float baseEpsilon = 0.003;\nfloat epsilon; // set in sampleScene - increases with deeper layers\n\n// Other globals\nconst vec3 cameraPos = vec3(0., 0., 37.5);\nconst float fov = radians(50.0);\nvec3 lightPos = vec3(16.0, 3.0, 20.0);\n\n// Colors taken directly from the source\nconst vec3 glowColor = vec3(6, 202, 227) / 255.0;\nconst vec3 purple = vec3(125, 39, 239) / 255.0;\nconst vec3 blue = vec3(69 /* nice */, 46, 250) / 255.0;\n\n// 2D rotation in radians\nmat2 rotate(float angle) {\n    return mat2(\n        cos(angle), sin(angle),\n        -sin(angle), cos(angle));\n}\n\n// Folds point across a line through origin with specified normal\nvec2 fold(vec2 point, vec2 normal)\n{\n    float dist = min(dot(point, normal), 0.0);\n    return point - 2. * dist * normal;\n}\n\nfloat sdCircle(vec2 point, vec2 center, float radius) {\n    return distance(point, center) - radius;\n}\n\n// Distance to a segment of specified length on the x-axis\nfloat sdSegmentX(vec3 point, vec3 center, float len)\n{\n\tfloat r = len/2.0;\n    point = abs(point - center);\n    return length(max(point - vec3(r, 0., 0.), 0.0));\n}\n\nconst float helixRadius = 0.19;\nconst float helixSpacing = 2.;\nconst float ladderRadius = 0.1;\nconst float ladderSpacing = 0.67;\nconst float spiralIntensity = 0.9;\n\n// Infinite DNA traversing Y axis\nfloat sdDna(vec3 point, vec2 center, float time) {\n    // Spiral about the Y axis\n    point.xz -= center;\n    point.xz = rotate(-point.y * spiralIntensity + time) * point.xz;\n    point.xz += center;\n    \n    float leftHelix = sdCircle(point.xz, center + vec2(-helixSpacing/2.0, 0.0), helixRadius);\n    float rightHelix = sdCircle(point.xz, center + vec2(helixSpacing/2.0, 0.0), helixRadius);\n    float helix = min(leftHelix, rightHelix);\n    \n\t// Repeat ladder along z axis\n    point.y -= ladderSpacing/2.0;\n    point.y = mod(point.y, ladderSpacing);\n    point.y += ladderSpacing/2.0;\n    float ladder = sdSegmentX(point, vec3(center.x, 0.5, center.y), helixSpacing) - ladderRadius;\n    \n    // iq's smooth minimum\n    float k = .175;\n    float h = max(k - abs(helix - ladder), 0.0) / k;\n    return min(helix, ladder) - h*h*h*k/6.0;\n}\n\nfloat dnaX = 15.0;\nfloat borderX = 13.0;\nfloat borderRadius = 0.25;\n\n// Returns the distance to the scene\nfloat scene(vec3 point)\n{\n    // Fold the space twice to create a square around the center\n    point.xy = fold(point.xy, normalize(vec2(1., -1.)));\n    point.xy = fold(point.xy, normalize(vec2(1., 1.)));\n    \n    float time = iTime * twistFrequency * radians(180.0);\n    \n    // Scale DNA distance down because the space distortions sometimes result in overstepping\n    float dna = 0.75 * sdDna(point, vec2(dnaX, 0.), time);\n    float dist = dna;\n    \n    if (renderBorder)\n    {\n        float border = sdCircle(point.xz, vec2(borderX, -0.), borderRadius);\n        dist = min(dist, border);\n    }\n    return dist;\n}\n\n// Approximates the normal at an intersection by calculating the gradient of the map\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        scene(vec3(point.x + epsilon, point.y, point.z)) - scene(vec3(point.x - epsilon, point.y, point.z)),\n        scene(vec3(point.x, point.y + epsilon, point.z)) - scene(vec3(point.x, point.y - epsilon, point.z)),\n        scene(vec3(point.x, point.y, point.z  + epsilon)) - scene(vec3(point.x, point.y, point.z - epsilon))));\n}\n\n// Gets rainbow color based on position around the border, slightly offset each level\nvec3 getRainbow(vec3 point, float level)\n{\n    point = abs(point);\n    float t = -min(point.x, point.y) / 15.0 + 0.2;\n    t += 0.05 * level;\n    \n    // Pretty much a hue scalar -> rgb\n    vec3 a = vec3(0, 1, 2) / 3.0;\n    return 0.5 + 0.5 * clamp(2.0 * cos(radians(360.0) * (t + a)), -1.0, 1.0);\n}\n\n// Shades a surface at the given point\nvec3 shadeSurface(vec3 point, vec3 rayDir, float level)\n{\n    vec3 normal = estimateNormal(point);\n    vec3 surfaceColor;\n    \n    // Set the surface color based on whether this is the DNA or the border\n    float region = max(abs(point.x), abs(point.y));\n    if (region > borderX + borderRadius + epsilon)\n    {\n        surfaceColor = getRainbow(point, level);\n    }\n    else\n    {\n        surfaceColor = purple;\n        //surfaceColor = vec3(0.9); // The lighting effects are more apparent with a silver border\n        \n        // Add rainbow colored highlighting around the edges\n        vec3 toEye = -rayDir; \n        float intensity = 1.0 - dot(normal, toEye);\n        surfaceColor = mix(surfaceColor, getRainbow(point, level), intensity);\n    }\n    // Smoothstepped diffuse lighting\n    vec3 toLight = normalize(lightPos - point);\n    float diffuse = max(dot(normal, toLight), 0.0);\n    diffuse = smoothstep(0.6, 0.85, diffuse);\n    \n    // Add some ambient lighting and return\n    diffuse = mix(diffuse, 1.0, 0.4);\n    return surfaceColor * diffuse;\n}\n\n// Calculates the sky as purple with a bit of cloud-like animation\nvec3 getSky(vec3 rayOrigin, vec3 rayDir)\n{\n    // Calculate coordinates of intersection\n    vec3 intersect = abs(rayDir * rayOrigin.z / rayDir.z);\n    float x = max(intersect.x, intersect.y);\n    float y = min(intersect.x, intersect.y);\n    \n    // Calculate the fade (colorMix) between the blue glow and purple sky\n    // band - the band that runs along the axis of the DNA\n    // ellipse - The more pronounced bulge near the center of each edge\n    float band = smoothstep(0.6, 1.6, abs(x - dnaX));\n    float ellipse = length(vec2((x - dnaX) * 0.7, y * 0.225)) - 1.5;\n    float colorMix = min(band, ellipse);\n    colorMix = clamp(colorMix, 0.0, 1.0);\n    \n    const vec3 baseColor = purple * 1.1;\n    \n    // Get the intensity of the purple sky component\n    const float innerSkyStart = renderBorder? -3.0 : -4.0;\n    const float innerSkyEnd = renderBorder? -0.5 : -1.25;\n    float skyIntensity = smoothstep(innerSkyStart, innerSkyEnd, x - dnaX) * smoothstep(14.0, 0.5, x - dnaX);\n    skyIntensity = pow(skyIntensity, 1.4);\n    vec3 purpleSky = skyIntensity * baseColor;\n    \n    // Add some moving textures to the sky to animate it\n    float textureScale = 1./90.;\n    \n    // Use pebble texture to get main \"cloud\" effect moving outward\n    float time = iTime * skyFrequency;\n    vec2 uv = vec2(min(intersect.x, intersect.y), x - time) * textureScale;\n    uv.x -= 0.8;\n    float coarse = texture(iChannel0, uv).r;\n    coarse = mix(coarse, 1.0, 0.7);\n    \n    // Use another more fine texture with slower outward movement\n    uv.y = (x - time * .4) * textureScale;\n    uv *= 0.45;\n    float fine = texture(iChannel1, uv).r;\n    fine = mix(fine, 1.0, 0.875);\n    \n    float textureIntensity = coarse * fine;\n     \n    // Add the texture effects weakly to the blue and strongly to the purple\n    return mix(blue * textureIntensity,\n               purpleSky * textureIntensity * textureIntensity,\n               colorMix);\n}\n\n// Returns the result color of casting a ray\nvec3 castRay(vec3 rayOrigin, vec3 rayDir, float level)\n{\n    // Time intensity scalar from 0 - 1 of both iteration-based glow (on hit)\n    // and distance-based glow (on miss)\n    float glowOscillate = 0.5 + 0.5 * cos(iTime * glowFrequency * radians(360.0) + level * 0.25);\n    \n    vec3 color = getSky(rayOrigin, rayDir);\n    \n    vec3 point = rayOrigin;\n    float t;\n    int iters = 0;\n    float minDist = 1e10;\n    \n    for (t = 0.; t < maxDistance; point = rayOrigin + t*rayDir)\n    {\n     \tfloat dist = scene(point);\n        minDist = min(dist, minDist);\n        \n        if (dist <= epsilon)\n        {\n            color = shadeSurface(point, rayDir, level);\n            \n            // Add iteration-based glow\n            // Only add glow on DNA, not on border\n            if (max(abs(point.x), abs(point.y)) > borderX + borderRadius + epsilon)\n            {\n                float baseGlow = float(iters) / 50.0;\n                float glowIntensity = 0.8 + 1.5 * glowOscillate;\n                color += glowColor * glowIntensity * pow(baseGlow, 1.075);\n            }\n        \treturn color;\n        }\n        t += dist;\n        iters++;\n    }\n    // On miss, add distance-based glow\n    float glowIntensity = 0.4 + 0.4 * glowOscillate;\n    float baseGlow = exp2(-2.5 * minDist);\n    color += glowColor * glowIntensity * pow(baseGlow, 1.4);\n    \n    return color;\n}\n\n// Variables/defaults used for calculating recursion\n// Calculated in mainImage\nfloat borderPercentage;\nfloat scalePerIteration = 441./367.;\nfloat anglePerIteration = radians(7.84);\n\n// Samples the scene at specified pixel coordinate\n// Recurses to the proper layer and then calls castRay\nvec3 image(vec2 fragCoord)\n{\n    // Convert coords to [-1, 1] in minimum dimension\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 coord = (2.0 * fragCoord - iResolution.xy) / minDimension;\n    \n    // Fake infinite zoom\n    float time = iTime * zoomFrequency;\n    float zoom = fract(time);\n    float startLevel = floor(time);\n    coord /= pow(scalePerIteration, zoom);\n    coord = rotate(zoom * anglePerIteration) * coord;\n    \n    // logScale - when there is twisting between the levels, we can still determine\n    // the most shallow level the point must be in by inscribing an upright square\n    // into the rotated square\n    float logScale;\n    if (max(abs(coord.x), abs(coord.y)) >= borderPercentage)\n    {\n        logScale = scalePerIteration / (sin(abs(anglePerIteration)) + cos(abs(anglePerIteration))); \n    } else\n    {\n        logScale = scalePerIteration * (sin(abs(anglePerIteration)) + cos(abs(anglePerIteration)));\n    }\n    \n    // Optimization - Advance to the point to the most shallow level it is guaranteed to be in\n    vec2 logs = ceil(-log(abs(coord  / borderPercentage)) / log(logScale));\n    float level = min(logs.x, logs.y);    \n    coord *= pow(scalePerIteration, level);\n    coord = rotate(-level * anglePerIteration) * coord;\n    \n    // Finish advancing the point to its actual level\n    for (int i = 0; i < 25; i++)\n    {\n        if (max(abs(coord.x), abs(coord.y)) < borderPercentage) {\n            coord *= scalePerIteration;\n            coord = rotate(-anglePerIteration) * coord;\n            level += 1.0;\n            continue;\n        }\n        break;\n    }\n    // Reduce aliasing slightly by reducing LOD in deep levels\n    epsilon = baseEpsilon * pow(scalePerIteration, level * 0.9);\n    \n    // Cast the recalculated ray\n\tvec3 rayDir = normalize(vec3(coord * tan(fov/2.0), -1.0));\n    return castRay(cameraPos, rayDir, startLevel + level);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate border size, scale/angle per iteration\n    \n    // borderPercentage - the percentage of the scene where the ray is tangent to\n    // the inside of the border cylinder (i.e. when to recurse to the next level)\n    float r = borderRadius + baseEpsilon;\n    float c = length(vec2(cameraPos.z, borderX));\n    float theta1 = atan(borderX / cameraPos.z);\n    float theta2 = asin(r / c);\n    borderPercentage = tan(theta1 - theta2) / tan(fov/2.) + 0.0005; // Add a bit to compensate for slight error\n    \n    // Overwrite angle/scale defaults by mouse x/y respectively if clicked\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouse = min(iMouse.xy, iResolution.xy); // So changing resolution doesn't cause unwanted values\n        anglePerIteration = -0.15 * (2.0 * mouse.x - iResolution.x) / iResolution.x;\n        scalePerIteration = mix(1.18, 1.5, mouse.y / iResolution.y);\n    }\n\n    // Supersample more toward the center\n    // Because the level of detail is logarithmic, we can supersample\n    // based on pixel distance regardless of viewport size\n    float minDimension = min(iResolution.x, iResolution.y);\n    vec2 absPixelCoord = abs(fragCoord - 0.5 * iResolution.xy);\n    float bound = max(absPixelCoord.x, absPixelCoord.y);\n    int samples = baseSamples;\n    \n    if (dynamicSupersample)\n        samples += int(bound < 150.0) + int(bound < 34.0);\n\n    float increment = 1.0 / float(samples);\n    float offset = increment / 2.0 - 0.5;\n\n    // Supersample by accumulating color of all samples\n    vec3 color = vec3(0.0);\n    \n    for(int y = 0; y < samples; y++) {\n        for(int x = 0; x < samples; x++)\n        {\n            vec2 screenCoord = fragCoord + offset + increment * vec2(x, y);\n            color += image(screenCoord);\n        }\n    }\n    color /= float(samples * samples);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1341, 1367, 1393, 1393, 1478], [1480, 1546, 1582, 1582, 1670], [1672, 1672, 1727, 1727, 1774], [1776, 1835, 1889, 1889, 1998], [2165, 2199, 2249, 2280, 3033], [3104, 3141, 3166, 3231, 3756], [3758, 3843, 3876, 3876, 4232], [4234, 4320, 4362, 4362, 4618], [4620, 4659, 4716, 4716, 5716], [5718, 5785, 5827, 5872, 7709], [7711, 7756, 7812, 7931, 9126], [9311, 9417, 9445, 9499, 11320], [11322, 11322, 11379, 11604, 13218]], "test": "untested"}
{"id": "tlcfDB", "name": "3D Distance Field Buffering II", "author": "oneshade", "description": "3D distance field buffering version two. Its really slow and it hasn't worked for anything other than this. Help? (uncomment lines 30-43 in Cubemap A to see what I mean). If it looks messed up at the beginning, try resetting the time.", "tags": ["3d", "distancefield", "sdf", "cubemap", "buffering", "storage"], "likes": 2, "viewed": 144, "published": 3, "date": "1613362656", "time_retrieved": "2024-07-30T19:38:02.182440", "image_code": "// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\nfloat fetch(in vec3 p, in vec3 offs) {\n    vec4 ray = cube2ray(space2cube(p, offs, SIZE, RESOLUTION));\n    return texture(iChannel0, ray.xyz)[int(ray.w)];\n}\n\nfloat sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        if (filt == 0) {\n            return fetch(p, vec3(0.0));\n        }\n\n        else {\n            vec3 local = fract(p / SIZE * RESOLUTION);\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            float ldb = fetch(p, vec3(0.0));\n            float rdb = fetch(p, vec3(1.0, 0.0, 0.0));\n            float lub = fetch(p, vec3(0.0, 1.0, 0.0));\n            float rub = fetch(p, vec3(1.0, 1.0, 0.0));\n            float ldf = fetch(p, vec3(0.0, 0.0, 1.0));\n            float rdf = fetch(p, vec3(1.0, 0.0, 1.0));\n            float luf = fetch(p, vec3(0.0, 1.0, 1.0));\n            float ruf = fetch(p, vec3(1.0));\n\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.01;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat mapScene(in vec3 p) {\n    return sampleDistanceField(p, 1);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0);\n    if (true) { // iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nCubemap face resolution is 1024x1024\nx 6 faces x 4 color channels = 25165824 slots!\ncuberoot(25165824) ~ 293\nso it is possible to store a cubic grid with 293^3 resolution!\n\nCubemap coordinates are stored as: vec4(face id, x, y, color channel)\nThis is just my convention by the way.\n\nFace numbering:\n0: right\n1: left\n2: up\n3: down\n4: front\n5: back\n*/\n\n// RESOLUTION is the sample resolution, SIZE is the space it maps to\n#define RESOLUTION vec3(280.0)\n#define SIZE vec3(5.0)\n\n// Determines which cubemap face a ray with direction rd is pointing at\nfloat getFaceID(in vec3 rd) {\n    vec3 ar = abs(rd);\n    if (ar.x >= ar.y && ar.x >= ar.z) return 0.0 + step(0.0, -rd.x); // X axis aligned face\n    if (ar.y >= ar.x && ar.y >= ar.z) return 2.0 + step(0.0, -rd.y); // Y axis aligned face\n    if (ar.z >= ar.x && ar.z >= ar.y) return 4.0 + step(0.0, -rd.z); // Z axis aligned face\n}\n\n// Calculates a ray direction hitting the cubemap texel at cm\nvec4 cube2ray(in vec4 cm) {\n    float sgn = sign(0.5 - mod(cm.x, 2.0));\n    if (cm.x == 0.0 || cm.x == 1.0) return vec4((cm.yz - 512.0) * vec2(-sgn, -1.0), 512.0 * sgn, cm.w).zyxw;\n    if (cm.x == 2.0 || cm.x == 3.0) return vec4((cm.yz - 512.0) * vec2( 1.0,  sgn), 512.0 * sgn, cm.w).xzyw;\n    if (cm.x == 4.0 || cm.x == 5.0) return vec4((cm.yz - 512.0) * vec2( sgn, -1.0), 512.0 * sgn, cm.w).xyzw;\n}\n\n// Converts 3D coordinates to cubemap coordinates\n// offs allows the sample position to be offset directly, avoiding precision errors\nvec4 space2cube(in vec3 p, in vec3 offs, in vec3 size, in vec3 res) {\n    p = floor((p / size + 0.5) * res) + offs;\n    float u = p.z * res.x * res.y + p.y * res.x + p.x;\n    float ch = mod(u, 4.0); // Color channel\n    u -= ch; u /= 4.0;\n    float x = mod(u, 1024.0); // X coordinate\n    u -= x; u /= 1024.0;\n    float y = mod(u, 1024.0); // Y coordinate\n    u -= y; u /= 1024.0;\n    float fid = u; // Face ID\n    return vec4(fid, x, y, ch);\n}\n\n// Converts cubemap coordinates to 3D coordinates\nvec3 cube2space(in vec4 cm, in vec3 size, in vec3 res) {\n    float u = cm.x * 4194304.0 + cm.z * 4096.0 + cm.y * 4.0 + cm.w; // *1024*1024*4, *1024*4, *4, *1\n    float x = mod(u, res.x);\n    float y = mod(u - x, res.x * res.y);\n    float z = (u - x - y) / res.x / res.y;\n    return (vec3(x, y / res.x, z) / res - 0.5) * size;\n}", "cube_a_code": "// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash13(in float x) {\n   vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(1000000.0);\n    }\n\n    if (iFrame > 0) {\n        fragColor = texture(iChannel0, rayDir);\n        float fid = getFaceID(rayDir); // Face ID\n\n        // Loop over color channels\n        for (int ch=0; ch < 4; ch++) {\n            vec3 p = cube2space(vec4(fid, iFragCoord, ch), SIZE, RESOLUTION);\n\n            // Uncomment to see the abominations\n            /*float id = iTime * 1000.0;\n            vec3 pos = Hash13(id) * SIZE - 0.5 * SIZE;\n            float shape = Hash11(id + 473.847);\n\n            float size = Hash11(id) * 0.5;\n            vec3 q = abs(p - pos) - size;\n            float newShape = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n            if (shape > 0.333) {\n                newShape = length(p - pos) - size;\n            }\n\n            if (shape > 0.666) {\n                newShape = length(vec2(length(p.xy - pos.xz) - size, p.z - pos.y)) - 0.5 * size;\n            }*/\n\n            float newShape = length(p) - 1.5;\n\n            fragColor[ch] = min(fragColor[ch], newShape);\n        }\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 100, 100, 218], [220, 220, 271, 271, 1285], [1287, 1287, 1314, 1314, 1354], [1356, 1356, 1383, 1383, 1630], [1632, 1632, 1687, 1687, 2672]], "test": "untested"}
{"id": "tl3BDB", "name": "Volume Scattering Clouds", "author": "vinkna", "description": "Volumetric clouds. Use the mouse to look around. Clouds shape and shading can be adjusted by changing the constants at the top of the file.", "tags": ["raymarching", "clouds", "volumetric", "scattering"], "likes": 3, "viewed": 430, "published": 3, "date": "1613355091", "time_retrieved": "2024-07-30T19:38:03.043139", "image_code": "// Volume Scattering Clouds\n// by Vincent Knauss @vinkna, 2021\n// https://www.shadertoy.com/view/tl3BDB\n\n// Based on the course notes\n// Real-Time Volumetric Rendering by Patapom / Bomb!, 2013\n// https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf\n\nconst vec3 blueSkyColor = vec3(0.2, 0.8, 2.0);\n\nconst float cloudiness = 0.35;  // controls how much of the sky is covered by clouds\nconst float cloudDensity = 0.15;  // scales the density of the clouds, a multiplier to the scattering and extinction coeffs\n\n// sigma_t and sigma_s in the volumetric rendering equation\n// properly, sigma_t = sigma_s + sigma_a and for clouds sigma_a ~= 0 so sigma_s ~= sigma_t\n// however I found this makes the clouds too dark. probably because there is no multiple scattering\nconst float fExtinction = 0.0275;\nconst float fScattering = 0.0375;\n\nconst float PI = 3.141592653;\n\nconst float rPlanet = 1000000.0;  // controls how fast clouds drop below the horizon. further clouds show more undersampling aritfacts\n\n// clouds are drawn in a spherical shell with inner radius rPlanet + cloudBottom and outer radius rPlanet + cloudTop\n// the ray march steps are aligned to the surface of this shell, meaning the distance for each step depends on the angle of the ray\nconst float cloudBottom = 1500.0;\nconst float cloudTop = 6000.0;\nconst int cloudSteps = 64;\n\n// shadow steps are raymarched out from each point, and accumulate extinction values to approximate how much direct\n// sunlight is transmitted to the point\nconst int shadowSteps = 6;\nconst float shadowStepDist = 100.0;\n\nconst float noiseFrequency = 0.0001;  // base scale applied to the coordinates when noise is sampled. multiplied by 3 on the y axis\n\nconst vec3 sunDirection = normalize(vec3(-5, -3, -1));  // direction of the sunlight, not to the sun\nconst vec3 sunIntensity = vec3(5.0, 5.0, 5.0);\n\nconst vec2 cloudVelocity = vec2(300, 200);\n\n\n// 2D Random from The Book of Shaders\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat random(in vec3 c) {\n    return random(vec2(random(c.xy), c.z));\n}\n\n// 3D Value Noise based on:\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec3 st) {\n    vec3 i = floor(st);\n    vec3 fr = fract(st);\n\n    // 8 corners in 3D of a tile\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec3 u = fr*fr*(3.0-2.0*fr);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 8 corners percentages\n    return mix(mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y,\n                mix(e, f, u.x) + (g - e)* u.y * (1.0 - u.x) + (h - f) * u.x * u.y, u.z);\n}\n\nfloat fbm(vec3 coord, int octave, float baseScale) {\n    float influence = 0.5;\n    float scale = baseScale;\n    float sum = 0.0;\n    for (int i = 0; i < octave; ++i) {\n        sum += influence * noise(coord * scale);\n        influence *= 0.5;\n        scale *= 2.0;\n    }\n    return sum;\n}\n\n// Formula for distance from a point at the top of a circle with radius r to the edge of a circle with radius r + d along a ray with vertical angle theta:\n// d = sqrt(r^2 * cos^2(theta) + 2*r*d + d^2) - r * cos(theta)\nfloat distanceToSphereEdge(float r, float d, float cst) {\n    return sqrt(r*r*cst*cst + 2.0*r*d + d*d) - r*cst;\n}\n\n// Henyey-Greenstein phase function\nfloat phaseHG(float g, float cst) {\n    float gg = g*g;\n    return (1.0 - gg) / (4.0*PI*pow(1.0+gg-2.0*g*cst, 1.5));\n}\n\nfloat cloud(vec3 coord, float dist, float startDist, float endDist) {\n    float d = fbm(coord * vec3(1, 3, 1), 8, noiseFrequency);\n    \n    d = cloudDensity * clamp((d-1.0+cloudiness)/cloudiness, 0.0, 1.0);\n\n    // ramp the density to 0 at the top and bottom of the cloud layer\n    d *= clamp((dist - startDist) / 700.0, 0.0, 1.0);\n    d *= clamp((endDist - dist) / 10.0, 0.0, 1.0);\n    \n    return d;\n}\n\nvec2 rotate(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 worldDir = normalize(vec3((fragCoord - 0.5 * iResolution.xy)/iResolution.y, 1.0));\n    worldDir.yz = rotate(worldDir.yz, clamp((iMouse.y - abs(iMouse.w)) / iResolution.y * 5.0, -PI/2.0, PI/2.0));\n    worldDir.xz = rotate(worldDir.xz, (iMouse.x - abs(iMouse.z)) / iResolution.x * 5.0);\n    \n       \n    if (worldDir.y > 0.0) {\n        vec3 cloudLuminance = vec3(0, 0, 0);\n        float cloudExtinction = 1.0;\n\n        // cos(theta) is equal to worldDir.y here\n        float cloudStartDist = distanceToSphereEdge(rPlanet, cloudBottom, worldDir.y);\n        float cloudEndDist = distanceToSphereEdge(rPlanet, cloudTop, worldDir.y);\n\n        float cloudDist = cloudStartDist;\n        float cloudStepDist = (cloudEndDist - cloudStartDist) / float(cloudSteps - 1);\n\n        float cosTheta = -dot(worldDir, sunDirection);\n        float phaseSun = 0.01 * phaseHG(0.8, cosTheta) + 0.8 * phaseHG(0.1, cosTheta) + 0.19 * phaseHG(-0.2, cosTheta);\n\n        float phaseAmbient = 1.0 / (4.0 * PI);\n\n        int inCloud = 0;\n        float sumDensity = 0.0;\n        for (int i = 0; i < cloudSteps; ++i) {\n            vec3 cloudPos = worldDir * cloudDist + vec3(cloudVelocity.x, 0, cloudVelocity.y) * iTime;\n            float thisStepDist = cloudStepDist;\n\n            float density = cloud(cloudPos, cloudDist, cloudStartDist, cloudEndDist);\n\n            if (density > 0.0) {\n                inCloud = 2;\n            } else {\n                --inCloud;\n            }\n            \n            if (inCloud > 0) {\n                float sunExtinction = 1.0;\n                for (int j = 0; j < shadowSteps; ++j) {\n                    vec3 shadowPos = cloudPos - sunDirection * shadowStepDist * float(j+1);\n\n                    float shadowCloudDensity = cloud(shadowPos, length(worldDir * cloudDist + sunDirection * shadowStepDist * float(j+1)), cloudStartDist, cloudEndDist);\n\n                    sunExtinction *= exp(-fExtinction * shadowCloudDensity * shadowStepDist);\n                }\n\n                vec3 ambientColor = sunIntensity;\n                vec3 sunColor = sunExtinction * sunIntensity;\n\n               \n                cloudExtinction *= exp(-fExtinction * density * cloudStepDist);\n                \n                if (cloudExtinction <= 0.001) {\n                    cloudExtinction = 0.0;\n                    break;\n                }\n\n                vec3 sampleLuminance = cloudExtinction * fScattering * density * cloudStepDist * (phaseAmbient * ambientColor + phaseSun * sunColor);\n                if (any(lessThan(sampleLuminance, vec3(0.0)))) cloudLuminance = vec3(10, 0, 0);\n                else cloudLuminance += clamp(1.0 -sumDensity, 0.0, 1.0) * sampleLuminance;\n            }\n\n            cloudDist += cloudStepDist;\n            sumDensity += density;\n        }\n        \n        float distBlend = 1.0 - clamp((cloudStartDist-cloudBottom)/500000.0, 0.0, 1.0);\n        distBlend *= distBlend;\n\n        float sunFactor = clamp(-dot(worldDir, sunDirection)-0.998, 0.0, 0.002) * 500.0;\n        sunFactor *= sunFactor;\n        vec3 skyColor = blueSkyColor + sunFactor * sunIntensity;\n        skyColor = distBlend * cloudLuminance + skyColor * cloudExtinction + blueSkyColor * (1.0 - cloudExtinction) * (1.0 - distBlend);\n        \n        fragColor = vec4(skyColor, 1.0);\n    } else {\n        fragColor = vec4(vec3(0.2), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1949, 2023, 2050, 2050, 2167], [2169, 2169, 2194, 2194, 2240], [2242, 2357, 2383, 2383, 3172], [3174, 3174, 3226, 3226, 3463], [3465, 3683, 3740, 3740, 3796], [3798, 3834, 3869, 3869, 3952], [3954, 3954, 4023, 4023, 4357], [4359, 4359, 4393, 4393, 4481], [4483, 4483, 4540, 4540, 7884]], "test": "untested"}
{"id": "3tdBRl", "name": "cool rainbow", "author": "dab9090", "description": "the rainbow thing I made for some reason", "tags": ["rainbow"], "likes": 1, "viewed": 256, "published": 3, "date": "1613345990", "time_retrieved": "2024-07-30T19:38:03.885887", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    float temp = 1.;\n    temp -= mod(iTime,1.);\n    \n    r = (x+y)/2.;\n    g = exp(-(1./x));\n    if(mod(iTime,2.)>1.) b = mod(iTime,1.);else b = temp;\n    \n    \n    // Output to screen\n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 472]], "test": "untested"}
{"id": "ttcBDS", "name": "SDF Triangle Wave", "author": "kstyler", "description": "You can get functions that trace an sdf similar to how sin and cos trace a circle by taking either sin(t) or cos(t) and dividing it by the sdf with cos(t) and sin(t) as inputs.", "tags": ["sdf", "triangle", "audio", "waveform"], "likes": 1, "viewed": 326, "published": 3, "date": "1613342820", "time_retrieved": "2024-07-30T19:38:04.746585", "image_code": "// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\n// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "float diamondSdf(vec2 p){\n    return abs(p.x) + abs(p.y) - .5;\n}\n\nfloat sdfSin(float t){\n    return sin(t)/diamondSdf(vec2(cos(t),sin(t)));\n}\n\nvec2 mainSound( int samp, float time ){\n    return vec2( sdfSin(6.2831*440.0*time))*.1*exp(-2.*time);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[753, 753, 776, 823, 1002], [1004, 1004, 1061, 1122, 1348]], "test": "untested"}
{"id": "WtcfDB", "name": "Menger sponge space base", "author": "mrange", "description": "License CC0: Menger sponge space base\n Tweaking menger sponges revealed a space based hidden inside\n", "tags": ["sponge"], "likes": 12, "viewed": 396, "published": 3, "date": "1613337483", "time_retrieved": "2024-07-30T19:38:05.612270", "image_code": "// License CC0: Menger sponge space base\n//  Tweaking menger sponges revealed a space based hidden inside\n\n#define TIME            iTime\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  9.0\n#define HIT_SKY         1E6\n#define MAX_RAY_MARCHES 100\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define PERIOD          20.0\n#define PERIODTIME      mod(TIME,PERIOD)\n#define PERIODN         int(mod(floor(TIME/PERIOD), 3.0))\n#define FADE            1.0\n\nconst vec3  sunDirection        = normalize(vec3(-2.5, 3.5, -10.0));\nconst vec3  sunColor1           = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2           = vec3(1.0, 0.8, 0.9);\nconst vec3  smallSunDirection   = normalize(vec3(0.5, 0, -10.0));\nconst vec3  smallSunColor1      = vec3(1.0, 0.6, 0.6);\nconst vec3  smallSunColor2      = vec3(1.0, 0.3, 0.6);\nconst vec3  ringColor           = sqrt(vec3(0.95, 0.65, 0.45));\nconst vec4  planet              = vec4(150.0, 0.0, 180.0, 50.0)*1000.0;\nconst vec3  planetCol           = sqrt(vec3(0.3, 0.5, 0.9))*1.5;\nconst vec3  ringsNormal         = normalize(vec3(1.0, 02.25, 0.0));\nconst vec4  rings               = vec4(ringsNormal, -dot(ringsNormal, planet.xyz));\nconst mat2  rot45               = ROT(PI/4.0);\nconst mat2  rot1                = ROT(1.0);\nconst mat2  rot2                = ROT(2.0);\nconst vec3  center              = vec3(0.0, 0.0, 0.0);\nconst vec4  glowSphere          = vec4(center, 1.2);\nconst vec3  glowCol             = vec3(3.0, 2.0, 1.);\nconst vec3  baseCol             = vec3(0.45, 0.45, 0.5)*0.5;\n\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 ce, float ra) {\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2( -b-h, -b+h );\n}\n\nvec3 gasGiant(vec3 ro, vec3 rd, vec3 sunDir) {\n  vec2 si = raySphere(ro, rd, planet.xyz, planet.w);\n  float pi = rayPlane(ro, rd, rings);\n  \n  vec3 planetSurface = ro + si.x*rd;\n  vec3 planetNormal = normalize(planetSurface - planet.xyz);\n  float planetDiff = max(dot(planetNormal, sunDir), 0.0);\n  float planetBorder = max(dot(planetNormal, -rd), 0.0);\n  float planetLat = (planetSurface.x+planetSurface.y)*0.0005;\n  vec3 planetCol = mix(1.3*planetCol, 0.3*planetCol, pow(PSIN(planetLat+1.0)*PSIN(sqrt(2.0)*planetLat+2.0)*PSIN(sqrt(3.5)*planetLat+3.0), 0.5));\n\n  vec3 ringsSurface = ro + pi*rd;\n\n  float borderTransparency = smoothstep(0.0, 0.1, planetBorder);\n  \n  float ringsDist = length(ringsSurface - planet.xyz)*1.0;\n  float ringsPeriod = ringsDist*0.001;\n  const float ringsMax = 150000.0*0.655;\n  const float ringsMin = 100000.0*0.666;\n  float ringsMul = pow(PSIN(ringsPeriod+1.0)*PSIN(sqrt(0.5)*ringsPeriod+2.0)*PSIN(sqrt(0.45)*ringsPeriod+4.0)*PSIN(sqrt(0.35)*ringsPeriod+5.0), 0.25);\n  float ringsMix = PSIN(ringsPeriod*10.0)*PSIN(ringsPeriod*10.0*sqrt(2.0))*(1.0 - smoothstep(50000.0, 200000.0, pi));\n\n  vec3 ringsCol = mix(vec3(0.125), 0.75*ringColor, ringsMix)*step(-pi, 0.0)*step(ringsDist, ringsMax)*step(-ringsDist, -ringsMin)*ringsMul;\n  \n  vec3 final = vec3(0.0);\n    \n  final += ringsCol*(step(pi, si.x) + step(si.x, 0.0));\n  \n  final += step(0.0, si.x)*pow(planetDiff, 0.75)*mix(planetCol, ringsCol, 0.0)*borderTransparency + ringsCol*(1.0 - borderTransparency);\n\n  return final;\n}\n\nvec3 sunColor(vec3 ro, vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  float smallDiff = max(dot(rd, smallSunDirection), 0.0);\n  vec3 col = vec3(0.0);\n\n  col += pow(diff, 800.0)*sunColor1*8.0;\n  col += pow(diff, 150.0)*sunColor2;\n\n  col += pow(smallDiff, 8000.0)*smallSunColor1*1.0;\n  col += pow(smallDiff, 400.0)*smallSunColor2*0.5;\n  col += pow(smallDiff, 150.0)*smallSunColor2*0.5;\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 scol = sunColor(ro, rd);\n  vec3 gcol = gasGiant(ro+vec3(0.0, 0.0, 200000.0), rd, sunDirection);\n  \n  return scol+gcol;\n}\n\nfloat minda = 1E6;\n\nfloat mengerSponge(vec4 p) {\n  float db = box(p, vec4(1.175, 1.-0.1, 1.05, 1.0));\n  if(db > .125) return db;\n    \n  float res = db;\n\n  float s = 1.0;\n  const int mc = 4;\n  for(int m = 0; m < mc; ++m) {\n\n    vec4 a = mod(p*s, 2.0)-1.0;\n    s *= 3.0;\n    vec4 r = abs(1.0 - 3.0*abs(a));\n\n    r -= vec4(2.0, 2.0, 2.0, 2.0)+vec4(0.1, 0.1, 0.1, 0)*-2.;\n    float da = sphere(r.xyz, 1.0); // w\n    float db = box(r.yzw, vec3(1)); // x\n    float dc = box(r.xzw, vec3(1)); // y\n    float dd = box(r.xyw, vec3(1.2)); // z\n\n    minda = min(minda, max(da, da));\n\n    float du = da;\n    du = min(du, db);\n    du = min(du, dc);\n    du = min(du, dd);\n    float lw = mix(0.215, 0.05, float(m)/float(mc-1));\n    du = abs(du)-lw;\n    du /= s;\n\n    res = max(res, -du);\n  }\n  \n  return (res);\n}\n\nfloat df(vec3 p) {\n  p -= center;\n  vec4 pp = vec4(p, 0.);\n  pp.xz *= rot1;\n  pp.yz *= rot2;\n  pp.zw *= rot45;\n  pp.yw *= rot45;\n  pp.xw *= rot45;\n  float dm = mengerSponge(pp);\n  return dm;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float it = df(ro);\n  float t = it;\n  int i = 0;\n  float mrl = MAX_RAY_LENGTH + it;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > mrl) break;\n    t += d;\n  }\n  iter = i;\n  return t > mrl ? HIT_SKY : t;\n}\n\nvec3 normal(vec3 pos, float e) {\n  vec2  eps = vec2(e,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  int iter = 0;\n  float id = df(ro);\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n\n  minda = 1E6;\n  vec3 nor = normal(pos,0.00001+t*0.00075);\n  float mind = 1.0;\n\n  vec3 color = vec3(0.0);\n  \n  float sd = sphered(ro, rd, glowSphere, t);\n\n  if (t < HIT_SKY) {\n    // Ray intersected object\n    color = baseCol*tanh_approx(2.5*max(minda*minda, 0.0));\n  } else {\n    // Ray intersected sky\n    return mix(skyCol*sqrt(ifade), glowCol, sd);\n  }\n\n  vec3 ld1   = sunDirection;\n  vec3 ld2   = smallSunDirection;\n\n  float sha = softShadow(pos, ld1, 4.0, 0.01, 64.0);\n\n  float dif1 = max(dot(nor,ld1),0.0);\n  float spe1 = pow(max(dot(reflect(rd, nor), ld1), 0.), 10.);\n  float lin1 = mix(0.2, 1.0, dif1*sha);\n\n  float dif2 = max(dot(nor,ld2),0.0);\n  float spe2 = pow(max(dot(reflect(rd, nor), ld2), 0.), 10.);\n  float lin2 = mix(0.1, 1.0, dif1*sha);\n\n  vec3 col = vec3(0.0);\n  col += sunColor1*lin1*color;\n  col += sunColor2*lin2*color;\n  col *= 0.5;\n  col += sunColor1*spe1*sha;\n  col += sunColor2*spe2*sha;\n  \n  const float minds = 2.0;\n  col = mix(mix(0.1*col, col, 1.0-mind), col, tanh_approx(minds*abs(minda*minds))/minds);\n\n  col = col*ifade;\n  \n  col = mix(col, glowCol, sd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = vec3(3, 3.0, -9.0);\n  vec3 la = center;\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  \n  switch(PERIODN) {\n  case 0:\n    ro *= 0.25+0.05*PERIODTIME/PERIOD;\n    ro.xz *= ROT(PERIODTIME/PERIOD);\n    break;\n  case 1:\n    ro *= 1.0-0.6*PERIODTIME/PERIOD;\n    ro.xz *= ROT(1.0+PERIODTIME/PERIOD);\n    ro.xy *= ROT(-0.5*PERIODTIME/PERIOD);\n    break;\n  case 2:\n    ro = vec3(5.0-15.0*PERIODTIME/PERIOD, -3.0+6.0*PERIODTIME/PERIOD, 30.0-40.0*PERIODTIME/PERIOD);\n    break;\n  default:\n    break;\n  }\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww );\n\n  vec3 col = render(ro, rd);\n  \n  col *= smoothstep(0.0, FADE, PERIODTIME);\n  col *= 1.0-smoothstep(PERIOD-FADE, PERIOD, PERIODTIME);\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfDB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1764, 1764, 1822, 1822, 2303], [2305, 2305, 2333, 2353, 2429], [2431, 2431, 2462, 2462, 2488], [2490, 2490, 2517, 2517, 2604], [2606, 2606, 2633, 2633, 2730], [2732, 2732, 2774, 2774, 2821], [2823, 2823, 2876, 2876, 3073], [3075, 3075, 3121, 3121, 4578], [4580, 4580, 4613, 4613, 4994], [4996, 4996, 5029, 5029, 5157], [5179, 5179, 5207, 5207, 5955], [5957, 5957, 5975, 5975, 6149], [6151, 6151, 6199, 6199, 6458], [6460, 6460, 6492, 6492, 6693], [6695, 6695, 6763, 6763, 7063], [7065, 7065, 7102, 7102, 7354], [7356, 7356, 7387, 7387, 8708], [8710, 8710, 8765, 8765, 9704]], "test": "untested"}
{"id": "3t3fWB", "name": "Optimized Closest Point", "author": "oneshade", "description": "Optimized version of: [url=https://www.shadertoy.com/view/3ltBRs]https://www.shadertoy.com/view/3ltBRs[/url]\nPlease make suggestion for further optimizations!\nAlso testing nonconvex shapes using iq's animated polygon (his stuff is awesome!).", "tags": ["sdf", "optimized", "gradientdescent", "closestpoint"], "likes": 11, "viewed": 332, "published": 3, "date": "1613327767", "time_retrieved": "2024-07-30T19:38:06.459006", "image_code": "// Optimized and improved version of: https://www.shadertoy.com/view/3ltBRs\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float d = min(sdf1(uv, iTime), sdf2(uv, iTime));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    // Fetch the estimated closest point from the buffer\n    vec2 closest = texelFetch(iChannel0, ivec2(0), 0).xy;\n\n    // Normalization is unnecessary since a true SDF will always have a normalized gradient\n    // If its not a true SDF then you will need to do that step\n    vec2 proj1 = closest - grad1(closest, iTime) * sdf1(closest, iTime); // Project onto first SDF\n    vec2 proj2 = closest - grad2(closest, iTime) * sdf2(closest, iTime); // Project onto second SDF\n\n    // Average the projections for a more consistent (and still very good) estimate\n    closest = (proj1 + proj2) * 0.5;\n\n    color = mix(color, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sdLine(uv, proj1, proj2)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest) - 0.01));\n    color = mix(color, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(0.0, 0.015, length(uv - proj1) - 0.01));\n    color = mix(color, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(0.0, 0.015, length(uv - proj2) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//////////////////////////////////////// Solver Hyperparameters /////////////////////////////////////////\n\n// Maximum iterations\n#define ITERATIONS 75\n\n// Controls how fast the algorithm steps (don't make too large!)\n#define DESCENT_RATE 0.05\n\n// Error margin\n#define EPSILON 0.001\n\n// Small number\n#define DELTA 0.001\n\n///////////////////////////////////////////// Utilities /////////////////////////////////////////////////\n\nvoid Rotate(inout vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    p *= mat2(c, -s, s, c);\n}\n\n// Distance functions from iq\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdHorseshoe(in vec2 p, in vec2 c, in vec2 w, in float r) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x) * p;\n    p = vec2((p.y > 0.0) ? p.x : -l * sign(c.x), (p.x > 0.0) ? p.y : l);\n    p = vec2(p.x, abs(p.y - r)) - w;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdPolygon(in vec2 p, in vec2[5] v) {\n    const int num = v.length();\n    float d = dot(p - v[0], p - v[0]);\n    float s = 1.0;\n    for(int i=0, j=num-1; i<num; j=i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n        bvec3 cond = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x * w.y > e.y * w.x);\n        if (all(cond) || all(not(cond))) s = -s;  \n    }\n\n    return s * sqrt(d);\n}\n\n///////////////////////////////////////////// SDFs //////////////////////////////////////////////////////\n\nfloat sdf1(in vec2 p, in float t) {\n    p.x += 0.25;\n\n    // Animation from iq\n    vec2 v1 = 0.4 * cos(0.4  * t + vec2(0.0, 2.0) + 0.0);\n\tvec2 v2 = 0.4 * cos(0.45 * t + vec2(0.0, 1.5) + 1.0);\n\tvec2 v3 = 0.4 * cos(0.5  * t + vec2(0.0, 3.0) + 2.0);\n\tvec2 v4 = 0.4 * cos(0.55 * t + vec2(0.0, 2.0) + 4.0);\n    vec2 v5 = 0.4 * cos(0.6  * t + vec2(0.0, 1.0) + 5.0);\n\n    vec2[] poly = vec2[5](v1, v2, v3, v4, v5);\n    return sdPolygon(p, poly);\n}\n\nfloat sdf2(in vec2 p, in float t) {\n    p.x -= 0.45;\n    float frac = fract(t);\n    p.y -= frac * (1.0 - frac) - 0.1;\n    Rotate(p, -2.0 * t);\n    float a = 0.25;\n    return sdHorseshoe(p, vec2(sin(a), cos(a)), vec2(0.2, 0.1), 0.2);\n}\n\n/////////////////////////////////////// SDF Gradients (numeric) /////////////////////////////////////////\n\n// As DELTA should be very tiny, it is not necessary to center the samples (and thus avoid 4 subtractions and one multiplication)\nvec2 grad1(in vec2 p, in float t) {\n    float middle = sdf1(p, t);\n    return vec2(sdf1(p + vec2(DELTA, 0.0), t) - middle,\n                sdf1(p + vec2(0.0, DELTA), t) - middle) / DELTA;\n}\n\nvec2 grad2(in vec2 p, in float t) {\n    float middle = sdf2(p, t);\n    return vec2(sdf2(p + vec2(DELTA, 0.0), t) - middle,\n                sdf2(p + vec2(0.0, DELTA), t) - middle) / DELTA;\n}\n\n////////////////////////////////////// Solver (gradient descent) ////////////////////////////////////////\n\n// Seed is somewhat arbitrary but will affect performance in some cases\n// If the object positions are known (or can be estimated), its probably best\n// to just pick the midway point\nvec2 grad(in vec2 p, in float t) {\n    return sdf1(p, t) > sdf2(p, t) ? grad1(p, t) : grad2(p, t);\n}\n\nvec2 findClosest(in vec2 seed, in float t) {\n    vec2 closest = seed;\n    for (int i=0; i < ITERATIONS; i++) {\n        vec2 g = grad(closest, t);\n        closest -= g * DESCENT_RATE;\n        if (all(lessThan(abs(g), vec2(EPSILON)))) { // Avoid square roots\n            break;\n        }\n    }\n\n    return closest;\n}", "buffer_a_code": "// The closest point is computed and stored here\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (ivec2(fragCoord) == ivec2(0)) {\n         // Use previous position to speed up convergence\n         fragColor.xy = findClosest(texelFetch(iChannel0, ivec2(0), 0).xy, iTime);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 132, 132, 1518]], "test": "untested"}
{"id": "3lcBWB", "name": "Day 423 oops counting lol", "author": "jeyko", "description": "motate", "tags": ["mdtmjvm"], "likes": 13, "viewed": 357, "published": 3, "date": "1613327226", "time_retrieved": "2024-07-30T19:38:07.563055", "image_code": "// Fork of \"Day 421\" by jeyko. https://shadertoy.com/view/ttcfzB\n// 2021-02-14 17:04:45\n\n// tri sdf from iq \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.,1.2));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n       \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#define sdfTrail(sdf,tpos,tdisp,variable, width)  {                           \\\n        vec2 circGrad = tpos(iTime - tdisp) - tpos(iTime - tdisp*2.) ;                     \\\n        circGrad *= rot(0.5*pi);                                              \\\n        vec3 circB =  sdf( p + tpos(iTime)  );                                \\\n        vec3 circBold = sdf( p + tpos(iTime - tdisp) ) + width*0.5;                         \\\n        vec2 rotUv = (p + tpos(iTime-0.1))*rot(-atan(circGrad.y,circGrad.x)); \\\n        circBold -= 9.*cyclicNoiseB(vec3(rotUv.x,1. +  floor(iTime*140.)*0.001,2)*42., false, floor(iTime*10.)*20.)*smoothstep(0.4,0.1,rotUv.y ) \\\n            *smoothstep(0.,0.9,length(circGrad))*0.1                          \\\n            * smoothstep(0.4,-0.3,circBold.x);                                \\\n        variable.x = opSmoothUnion(circB.x,circBold.x,0.2);                     \\\n    }\n    \n    #define getCircB(t) vec2(0.1 + sin((t)*2.5)*0.5,0. + sin((t)*4.)*0.2)\n    \n\nfloat palIdx = 0.;\n\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d*smoothstep(1.,0.,abs(d)/r) );\n}\n\n\n\nfloat noise(vec2 fragCoord){\n    int idx = iFrame/15;\n    return texture(iChannel0,(fragCoord + sin(float(idx)*20.)*10.)/256.,0.4)[idx%2];\n}\n\nconst float palA = 0.5;\nconst vec3 palB = 0.5*vec3(1.,0.7,0.4);\nconst vec3 palC = vec3(4,2,2);\nconst float palD = 1.;\n\nvoid draw( vec2 uv, vec2 fragCoord,inout vec3 col, float d, vec2 grad, float palOffs, bool isPal, bool isXor){\n    \n    float n = cyclicNoise(vec3(uv,2)*92., false, floor(iTime*10.))*0.004;\n    float grain = noise(fragCoord);\n    float df = dFdx(uv.x)*1. + n*0.5;\n    \n    palIdx += palOffs + d*(0.2 + 3.*float(palIdx!=0.)) - smoothstep(0.04,0.0,abs(d))*0.1 + n*10. - grain*.42;\n    \n    vec3 c = pal(palA,palB,palC,palD,palIdx);\n    \n    d -= n;\n    \n    vec3 shadc = c*.9;\n    shadc.xz *= rot(0.2);\n    shadc.xy *= rot(.3);\n    \n    float dots =  smoothstep(-3.,5.,dot(grad,vec2(-1.)) - d*2.);\n    c = mix(c,shadc,\n        smoothstep(0.3 + dots,0.4 + dots,grain + d));\n    \n        //step(0.3+ smoothstep(-3.,5.,dot(grad,vec2(-1.)) - d*2.),noise(fragCoord)));\n    \n    if(isPal){\n        vec3 oldCPalled = pal(palA,palB,palC,palD,palIdx + length(col) )*(col + 0.5);\n    \n        \n        col = mix(col, oldCPalled*c, smoothstep(df,0.,d)); \n        \n    } else if(isXor){\n        //vec3 oldCPalled = pal(palA,palB,palC,palD,palIdx - length(col)*1. + palOffs)*mix(vec3(1.-length(col)),vec3(1),1.);\n        vec3 oldCPalled = max(col,0.);\n        float luma =  (oldCPalled.x+oldCPalled.y+oldCPalled.z)/3.;\n        \n        oldCPalled = 1. - oldCPalled;\n        \n        oldCPalled.xz *=rot(sin(smoothstep(0.5,0.,abs(d)*14.)*5.)*0.05);\n        oldCPalled = mix(oldCPalled,shadc,\n            smoothstep(0.3 + dots,0.5 + dots,grain + d*2.)*0.2);\n    \n        col = mix(col, oldCPalled, smoothstep(df,0.,d)); \n    \n    \n    } else {\n        \n        col = mix(col, c, smoothstep(df,0.,d)); \n    \n    }\n    \n}\n\nfloat envcnt = 0.;\n\nfloat getEnv(float t, float speed, float pa, float pb, float jumpAmt, bool cnt){\n    //return pow(sin((t - 0.5)*3.14),1.)*0.5 + 0.5;\n    t = clamp(t*speed,0.,1.);\n    \n    envcnt += float(t > 0.99 && cnt);\n    //t = smoothstep(0.,1.,t);\n    pa += 1.;\n    pb += 1.;\n    \n    float c = cos(t*3.14);\n    float a = 1.- ((pow(abs(c),pa)*sign(c))*0.5 + 0.5);\n    float b = 1.-((pow(abs(c),pb)*sign(c))*0.5 + 0.5);\n    \n    a = pow(sin(t*3.14/2.),pa);\n    b = 1.-pow(sin((-t + 1.)*3.14/2.),pb);\n    \n    b *= 1. + (\n            smoothstep(0.,1.,t) *smoothstep(0.99,0.7,t)*jumpAmt\n        );\n    return mix( a, b,t);\n}\n\n\nfloat text(vec2 p, float[1] chars, float spacing, float s) {\n\tp *= s;\n    p += vec2(1./16.,1./16.);\n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375*0.;\n    float char = chars[int(id.x)];\n    //char += 112.;\n    float t;\n    if( abs(id.y) < 1. && id.x >= 0. && id.x < 1. && mod(char, 1.) == 0. && char < 256.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - 0.5;\n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    }\n    return t;\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define iTime mod(iTime,9.)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float env  = getEnv(iTime*1.      ,1.5,16.,3.,0.9,true);\n    float envb = getEnv(iTime*1. - 0.4,1.,1.,1.,0.9 ,true);\n    float envc = getEnv(iTime*1. - 1.2,1.5,2.,4.,0.2 ,true);\n    float envd = getEnv(iTime*1. - 1.5,0.4,1.,1.,0.4  ,true);\n    float enve = getEnv(iTime*1. - 3.5,1.,1.,1.,0.4  ,true);\n    float envf = getEnv(iTime*1. - 4. ,2.,1.,1.,0.4  ,true);\n    float envg = getEnv(iTime*1. - 4.5,1.,1.,1.,0.4  ,true);\n    float envh = getEnv(iTime*1. - 4.8,2.,1.,1.,0.4  ,true);\n    float envi = getEnv(iTime*1. - 5. ,1.5,1.,1.,0.4 ,true);\n    float envj = getEnv(iTime*1. - 6. ,1.5,1.,1.,0.4 ,true);\n    float envk = getEnv(iTime*1. - 7.5 ,1.5,1.,1.,0.4 ,true);\n    float envl = getEnv(iTime*1. - 7.4 ,1.5,1.,1.,0.4 ,true);\n    float envm = getEnv(iTime*1. - 7.9 ,1.5,1.,1.,0.4 ,true);\n    \n    vec3 col = vec3(0);\n\n    draw( uv, fragCoord, col, length(uv) - 4. + smoothstep(0.4,0.3,texture(iChannel1,uv*0.05).x)*2., normalize(uv), 3.7,false, false);\n    \n    vec2 p = uv;\n    \n    vec3 circ = sdgCircle( p - (1.-pow(env,0.1)), 0. + env*0.4 - envc*0.1 + envg*0.1 + envk*0.1 - envm*2.  ) ;\n    \n    draw( uv, fragCoord, col, circ.x, circ.yz, 1.,false, false);\n    \n    \n    circ.x = abs(circ.x - env*0.4) - envb*0.5 - envc*0.5 - 0.1 - envm*2.;\n    draw( uv, fragCoord, col, circ.x, circ.yz, 0.,false, true);\n    \n    \n    if(envd < 0.){\n        for(float i = 0.; i < 8.; i ++){\n        \n            float envm = getEnv(iTime*1. - 7.9  - i/8.,1.5,1.,1.,0.4 ,false);\n            p = uv*rot(2.*pi*i/8.*envg) + vec2(0,0.2 + envh*0.5 - envj*0.6  );\n\n            vec3 circ = sdgCircle( p, 0. + envg*0.5  + envi*0.6 +  + envj*0.6 - envm*0.3  ) ;\n\n            if( envg > 0.)\n                draw( uv, fragCoord, col, circ.x, circ.yz, 0.,false, true);\n\n        }\n    } else {\n    \n        for(float i = 0.; i < 8.; i ++){\n        \n            float envm = getEnv(iTime*1. - 7.9  - i/8.,1.5,1.,1.,0.4 ,false);\n            p = uv*rot(2.*pi*i/8.*envg) + vec2(0,0.2 + envh*0.5 - envj*0.6  );\n\n            vec3 circ = sdgCircle( p, 0. + envg*0.5  + envi*0.6 +  + envj*0.6 - envm*0.3  ) ;\n\n            if( envg > 0.)\n                draw( uv, fragCoord, col, circ.x, circ.yz, 0.,false, true);\n\n        }\n    }\n    p = uv;\n    \n    vec3 plane = vec3((p*rot((0.25*envc + envf*0.25 - envi*0.5)*pi)).y - 0.5*(1.-env) + envl,0,-0.) ;\n    draw( uv, fragCoord, col, plane.x, plane.yz, 1.7,false, true);\n    \n    for(float i = 0.; i < 13.; i++){\n    \n        float other = float(i>4.)*envk;\n        \n        vec3 plane = vec3((p * rot(-pi*i*(0.25)*(envj + pow(envk,1.)) + sin(i*4.+iTime)  )).y,0.,-0.) ;\n        \n        if(i < 4.){\n            plane = abs(plane) + 0.04 - envj*0.24 - envk*1.2 ;\n            draw( uv, fragCoord, col, plane.x, plane.yz, 1.5,false, true);\n\n        } else {\n            plane = abs(plane) + 0.04  - other*5. ;\n            draw( uv, fragCoord, col, plane.x, plane.yz, 1.5,false, true);\n\n        }\n        \n        \n    }\n    p = uv;\n    \n    \n    for(float i = 0.; i < 5.; i++){\n        float envc = getEnv(iTime*1. - 1.9 - i/17.*0.,1.,1.,2.,0.1,false);\n        \n        \n        p *= rot((0. + envd*0.25 + cos(i*pi )*enve*0.5 - cos(i*pi*0.5 )*envf*0.25 - cos(i*pi*1. )*envg*0.5  + envj  )*pi*envc);\n        float envcb = getEnv(iTime*1. - 1. - i/17.*0.5,1.,1.,2.,0.1,false);\n    \n        //vec3 circ = sdSq( p, vec2(0.25 + i*0.1 + sin(envb*pi*1.)) ) ;\n        vec3 circ = sdgBox( p, vec2(0. + i*0. + envb*pi*1. - envcb*(2.5 +i*0.1) + envd*0. - envg*0.4  - envj*0.5)  );\n        draw( uv, fragCoord, col, circ.x, circ.yz, 1.,false, true);\n        \n        \n    \n    }\n    \n    \n    //col = mix(col,1.-col,smoothstep(0.001,0.,text(uv - vec2(0.9,-0.35), float[1](81. + envcnt), 0., 0.4) ));\n    \n    /*\n    //\n    vec3 c;\n    float w = 0.15 + sin(iTime)*0.05;\n    #define sdfA(pos) sdgCircle( pos , w )\n    \n    sdfTrail(sdfA,getCircB, 0.2, c, w);\n\n    draw( uv, fragCoord, col, c.x, c.yz, 0.7,false, true);\n    //\n    \n    //\n    \n    #define getPlane(t) vec2(0.,0. + sin((t)*4.)*1.)\n    \n    w = 0. + sin(iTime)*0.;\n    #define sdfB(pos) vec3((p + pos).x + p.y,0.,0.)\n    \n    sdfTrail(sdfB,getCircB, 0., c, w);\n\n    draw( uv, fragCoord, col, c.x, c.yz, 1.1,false, true);\n    //\n    */\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*4.,2.)*0.2 ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.5);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 2;\n    \n    const float warp =.4;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n\nfloat sdSq(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 1040]], "test": "untested"}
{"id": "WtcfWS", "name": "T-Virus", "author": "dean_the_coder", "description": "A quick and simple scene inspired by the Resident Evil movie, with a fair bit of artistic license thrown in.\nNeeearly 4Kb...", "tags": ["3d", "raymarching", "evil", "umbrella", "movie", "resident", "cineshader"], "likes": 13, "viewed": 9247, "published": 3, "date": "1613321333", "time_retrieved": "2024-07-30T19:38:08.496558", "image_code": "// 'T-Virus' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WtcfWS\n//\n// Audio: https://soundcloud.com/chrisse/resident-evil-main-extended\n//\n// A quick and simple scene inspired by the Resident Evil\n// movie, with a fair bit of artistic license thrown in.\n//\n// I think in the future I'll spend some time trying\n// to improve my raymarching code when it has reflection\n// and refraction. I suspect there's a more performant\n// method.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define BLUE vec3(.01, .48, .83)\n\n#define Z0 min(iTime, 0.)\n\nfloat T;\nbool inFluid;\n\n// #define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF Distance\n\tint id;  // Material ID\n};\n\nfloat h31(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 3.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o)\n{\n\tfloat t = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x) + t + o, 2. * t) - t;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTwist(vec3 p, vec2 r, float g, float o) {\n\tfloat gb2 = g * .5,\n\t\t  a = abs((atan(p.x, p.z) + 3.141 * o) * gb2 - mod(p.y, 3.141 * g));\n\treturn length(vec2(length(p.xz) - r.x, a > 3.141 * gb2 ? 3.141 * g - a : a)) - r.y;\n}\n\nvec3 rayDir(vec3 ro, vec3 at, vec2 uv) {\n\tvec3 f = normalize(at - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat bblz(vec3 p) {\n\tp.x += sin(T * .2 + floor(p.z) * 22.34) * .4;\n\tp.y -= (T + 1.23) * (.3 + h31(floor(p.xzx)));\n\treturn max(length(fract(p - .1) - .5) - mix(.02, .1, h31(floor(p))), length(p.xz) - 6.);\n}\n\nfloat helix(vec3 p) {\n\tp.xz *= rot(1.57);\n\treturn min(sdTwist(p, vec2(4.8, 1), 3., 1.), sdTwist(p, vec2(4.8, 1), 3., 2.));\n}\n\nHit tube(vec3 p) {\n\tHit cyl = Hit(sdCyl(p, vec2(8, 18)), 3);\n\tif (cyl.d > 5.) return cyl;\n\n\tHit h = Hit(max(helix(p), cyl.d), 2);\n\n\tcyl.d = max(cyl.d - .5, abs(abs(p.y) - 18.) - 5.);\n\tminH(h, cyl);\n\n\treturn h;\n}\n\nvec3 tube2Map(vec3 p) {\n\tp.xz *= rot(.4);\n\tp.x -= 30.;\n\tp.y += 9.5;\n\tp.yz *= rot(1.57);\n\treturn p;\n}\n\nHit glass(vec3 p) {\n\tvec2 v = vec2(8, 13);\n\treturn Hit(min(sdCyl(p, v), sdCyl(tube2Map(p), v)), 4);\n}\n\nHit tubez(vec3 p) {\n\tHit h = tube(p);\n\tminH(h, tube(tube2Map(p)));\n\treturn h;\n}\n\nHit map(vec3 p) {\n\tif (inFluid)\n\t\treturn Hit(bblz(p), 1);\n\n\tHit h = Hit(abs(p.y + 18.5), 5);\n\tminH(h, tubez(p));\n\tminH(h, Hit(140. - length(p.xz), 6));\n\n\treturn h;\n}\n\nvec3 logo(vec3 p) {\n\tfloat a = atan(p.x, p.z) + 3.14;\n\n\tp.xz = opModPolar(p.xz, 8., .4);\n\tp.x -= 140.;\n\n\tvec3 rw = mix(vec3(1, 0, 0), vec3(1), mod(floor(a * 1.27), 2.));\n\treturn mix(vec3(.2), rw, step(80., length(p.xz)));\n}\n\nvec3 calcN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0026 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * t).d;\n\t}\n\n\treturn normalize(n);\n}\n\nvec3 glassN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0026 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * glass(p + e * t).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = Z0; i < 30.; i++)\n\t{\n\t\tfloat h = tubez(t * ld + p).d;\n\t\ts = min(s, 20. * h / t);\n\t\tt += h;\n\t\tif (s < .01 || t > 25.) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\tp += n * h;\n\treturn clamp(min(glass(p).d, map(p).d) / h, 0., 1.);\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 3, -10) - p),\n\t\t n = h.id == 4 ? glassN(p, d) : calcN(p, d),\n\t\t c = vec3(0);\n\tfloat ss = 0.;\n\n\tif (h.id == 1)\n\t\tc = BLUE;\n\telse if (h.id == 2) {\n\t\tc = BLUE;\n\n\t\t// Sub-surface scattering.\n\t\tss = smoothstep(0., 1., tubez(3. * ld + p).d / 3.);\n\t} else if (h.id == 3)\n\t\tc = vec3(1);\n\telse if (h.id == 5)\n\t\tc = logo(p);\n\telse c = vec3(.05, .1, .15);\n\n\t// Primary light.\n\tfloat l1 = max(0., .1 + .9 * dot(ld, n)),\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)),\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * 10.;\n\n\t// Bubblez/glass.\n\tif (h.id == 1 || h.id == 4)\n\t\treturn c + l2 + (spe + l1) * .15;\n\n\t// Fresnel.\n\tfloat fre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,\n\t\t  _ao = dot(vec2(ao(p, n, .2), ao(p, n, 2.)), vec2(.4, .6));\n\n\tif (h.id == 6)\n\t\treturn c + (l1 + spe) * .02;\n\n\tl1 *= (.3 + .7 * calcShadow(p, ld)) // ...with shadow.\n\t\t  * (.3 + .7 * _ao); // ...and _some_ AO.\n\n\t// Combine into final color.\n\tfloat lig = l1 + (l2 * .3 + spe) * _ao + ss;\n\treturn mix(lig * c * vec3(2, 1.8, 1.7), vec3(.1), fre);\n}\n\nvec3 march(vec3 ro, vec3 rd, float x) {\n\t// Raymarch.\n\tvec3 p = ro,\n\t\t col = vec3(0);\n\n\tfloat md = -1., d = .01, o = 1.;\n\n\tif (inFluid) {\n\t\tfloat bubbleO = 1.;\n\t\tcol = BLUE;\n\t\tfor (float i = Z0; i < 40.; i++) {\n\t\t\tp = d * rd + ro;\n\t\t\tHit h = Hit(bblz(p), 1);\n\n\t\t\tif (d > 15.)\n\t\t\t\tbreak;\n\n\t\t\tif (abs(h.d) < .0015) {\n\t\t\t\t// Not physically accurate, but looks ok.\n\t\t\t\td++;\n\t\t\t\tcol += lights(p, rd, d, h) * .3 * bubbleO;\n\t\t\t\tbubbleO *= .25;\n\t\t\t}\n\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\treturn col;\n\t}\n\n\tbool inGlass = false;\n\tfloat shine = 0.;\n\tfor (float i = Z0; i < 140.; i++) {\n\t\tp = d * rd + ro;\n\t\tHit gh, h = map(p);\n\n\t\tif (abs(h.d) < .0015) {\n\t\t\tcol += (lights(p, rd, d, h) + shine) * o;\n\t\t\tif (md < 0.)\n\t\t\t\tmd = d;\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t\to *= h.id == 6 ? .02 : .1;\n\t\t\tro = p;\n\t\t\trd = reflect(rd, calcN(ro, d));\n\t\t\td = .5;\n\t\t} else if (!inGlass && (gh = glass(p)).d < .0015) {\n\t\t\tinGlass = true;\n\t\t\tshine = lights(p, rd, d, gh).r;\n\t\t\tro = p + gh.d * rd;\n\t\t\trd = refract(rd, glassN(ro, d), .8);\n\t\t\td = .5;\n\t\t\tcontinue;\n\t\t}\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = iTime;\n\n\tfloat ph = smoothstep(16., 22., T) - smoothstep(40., 50., T);\n\tvec3 lookAt = mix(vec3(0, 2, 0), vec3(30, -5, 0), ph);\n\tfloat m = max((cos((T - 13.) * .25) + 1.) / 2., .01);\n\tvec3 ro = vec3(m * m * 40., 2. + m * m * 25., -2. - 60. * m)\n\t\t\t  - vec3(40, -25, 40) * ph;\n\n\tinFluid = length(ro.xz) < 6.5;\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, rayDir(ro, lookAt, uv), uv.x);\n\n#ifdef AA\n    // My attempt at 'quick' anti-aliasing...\n\tif (length(fwidth(col)) > .08) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tfor (float dy = Z0; dy <= 1.; dy++)\n\t\t\t\tcol += march(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - .5) / iResolution.xy), uv.x);\n\n\t\tcol /= 5.;\n\t}\n#endif\n\n\tfragColor = vec4(vignette(pow(col * min(iTime, 1.), vec3(.45)), fc), 0);\n}\n", "image_inputs": [{"id": 25425, "src": "https://soundcloud.com/chrisse/resident-evil-main-extended", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfWS.jpg", "access": "api", "license": "artistic-2.0", "functions": [[880, 880, 900, 900, 997], [999, 999, 1030, 1030, 1055], [1057, 1057, 1076, 1076, 1136], [1138, 1138, 1181, 1181, 1296], [1298, 1298, 1328, 1328, 1428], [1430, 1430, 1479, 1479, 1658], [1660, 1660, 1700, 1700, 1829], [1831, 1831, 1851, 1851, 2037], [2039, 2039, 2060, 2060, 2163], [2165, 2165, 2183, 2183, 2376], [2378, 2378, 2401, 2401, 2478], [2480, 2480, 2499, 2499, 2581], [2583, 2583, 2602, 2602, 2662], [2664, 2664, 2681, 2681, 2829], [2831, 2831, 2850, 2850, 3054], [3056, 3056, 3085, 3085, 3283], [3285, 3285, 3315, 3315, 3515], [3517, 3517, 3552, 3567, 3762], [3764, 3792, 3827, 3827, 3896], [3984, 3984, 4016, 4016, 4131], [4133, 4133, 4179, 4179, 5296], [5298, 5298, 5337, 5351, 6392], [6394, 6394, 6439, 6439, 7221]], "test": "untested"}
{"id": "3l3BWS", "name": "Variable Fractal Synthesizer", "author": "public_int_i", "description": "Using a 2D fractal as a audio synthesizer, each seed creates a different noise. The seed changes each second. Pretty happy with the amount of different sounds it can produce.", "tags": ["fractal", "sound", "audio", "synthesizer", "variable"], "likes": 6, "viewed": 317, "published": 3, "date": "1613319156", "time_retrieved": "2024-07-30T19:38:09.383188", "image_code": "//See Common for code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //display multiple bar graphs of different scales over top each other\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float s = 0.;\n    for (float i = .0001; i < .01; i += i) {\n        s += step(uv.y,instrument(floor(iTime/SWITCH_DELAY)*SWITCH_DELAY+.5+floor(uv.x*50.)/50.*i));\n    }\n    fragColor = vec4(s/10.);\n}", "image_inputs": [], "sound_code": "//See Common\n\nvec2 mainSound( int samp, float time )\n{\n    return vec2(instrument(time)*.3);\n}", "sound_inputs": [], "common_code": "/*Ethan Alexander Shulman 2021 - https://xaloez.com/\nCC0, public domain\n\nUsing a 2D fractal as a audio synthesizer, each seed creates a different noise.\nIn this demo the seed is changed constantly.\nPretty happy with the amount of different sounds it can produce.\n*/\n\n\n//How often the instrument seed is switched.\n#define SWITCH_DELAY .4\n\n\n//Modified FNV-1A hash https://www.shadertoy.com/view/WtdfRX\nuvec4 hash(uvec4 seed) {\n    uvec4 h = (0x6A7F8FAAu^seed)*0x01000193u;\n    h = ((h.wxyz>>3u)^h^seed.yzwx)*0x01000193u;\n    h = ((h.zwxy>>8u)^h^seed.wxyz)*0x01000193u;\n    return h^(h>>11u);\n}\n#define I2F (1./float(0xFFFFFFFFu))\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat triwave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\nfloat triwave2(float x) {\n    return fract(x);\n}\nfloat squarewave(float x) {\n    return floor(fract(x)*2.);\n}\n\n//From my shader \"Variable Fractal Tiles\" https://www.shadertoy.com/view/wtycRt\nfloat fractal(float t, float repX, float repY, float freq, uvec4 p) {\n    vec4 h = vec4(hash(p))*I2F;\n    vec2 pos = fract(vec2(t/repX,floor(t/repX)/repY));\n    \n    //apply folds based off hash\n    for (int i = 0; i < 8; i++) {\n        float fi = h[i/2], rv = h[(i+1)%4];\n        if (i%2 == 0) fi = fract(fi*10.)*10.;\n        else fi = floor(fi*10.);\n           \n        int id = int(fi)%4;\n        if (id == 0) {//mirror rotate fold\n            pos = (abs(pos)-.5)*r2(rv*6.28);\n        } else if (id == 1) {//plane fold\n            rv *= 6.28;\n            vec2 pnorm = vec2(sin(rv),cos(rv));\n            pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n        } else {//polar fold\n            float sz = .04+rv*1.6,\n                ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n            pos = vec2(sin(ang),cos(ang))*length(pos);\n        }\n        //apply box fold\n        float ext = h[i%4];\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n    float l = length(pos)*freq;\n    \n    \n    //try different waves\n    return triwave(l)*2.-1.;\n    //return squarewave(l)*2.-1.;\n    //return triwave2(l)*2.-1.;\n    //return sin(l*6.28);\n}\n\n//Use fractal as a synth\nfloat instrument(float t) {\n    //change instrument parameters every second\n    float iid = floor(t/SWITCH_DELAY);\n    vec4 params = vec4(hash(uvec4(iid,0,0,0)))*I2F;\n    return fractal(t, mix(0.006,0.03,pow(params.x,2.)),//x repetitions is base pattern wavelength\n                     mix(100.,1000.,params.y),//y repetitions is a second pattern wavelength\n                     mix(2.,15.,params.z),//wave frequency\n                     uvec4(iid)//fractal seed, each one creates a different noise\n                     );\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3BWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 154, 414]], "test": "untested"}
{"id": "wldBRs", "name": "Heart Wave Curve", "author": "moranzcw", "description": "A heart curve.", "tags": ["2d", "math", "heart", "curve"], "likes": 5, "viewed": 292, "published": 3, "date": "1613316991", "time_retrieved": "2024-07-30T19:38:10.181054", "image_code": "// Heart Wave Curve - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.1415926\n#define Scale 2.5\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1315, 0.1375, 0.4757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = (2.0*fragCoord - iResolution.xy)/iResolution.y * Scale;\n    \n    // parameter of curve stretching\n    float t = mix(-50.0, 50.0, 0.5*sin(iTime*0.25)+0.5);\n    \n    // heart wave curve\n    vec2 curvePoint;\n    float len = 1e10;\n    float delta = 1.0 / iResolution.y;\n    for(float i=-100.0; i<101.0; i++)\n    {\n        curvePoint.x = coord.x + i * delta * 0.1;\n        curvePoint.y = pow(curvePoint.x, 0.42) + sqrt(0.6*(3.0-curvePoint.x*curvePoint.x)) * sin(t * PI * curvePoint.x) - 0.5;\n       \n        // distance between current pixel and the curve\n        len = min(len, length(coord-curvePoint));\n    }\n    \n    // draw\n    vec3 color = vec3(1.0,0.0,0.0) * smoothstep(0.02, 0.0, len);\n\n    color *= smoothstep(1.75, 1.72, abs(coord.x));\n    \n    // background color\n    color += background(uv.y);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBRs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[199, 199, 231, 231, 322], [325, 325, 382, 382, 1280]], "test": "untested"}
{"id": "tttfzl", "name": "Fire Within", "author": "YitingLiu", "description": "creating fire with gyroid shapes", "tags": ["raymarching", "template", "artofcode"], "likes": 6, "viewed": 303, "published": 3, "date": "1613313717", "time_retrieved": "2024-07-30T19:38:10.955983", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p,float scale, float thickness, float bias){\n    p*=scale;\n    \n    // can also play with the p and p.zxy by adding some numbers \n    // scale needs to add the largest multiplers in either p or p.zxy \n    // return abs(dot(sin(p*2.),cos(p.zxy*1.23))-bias)/(scale*2.)-thickness;\n\n    return abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;\n}\n    \n    \n    \nvec3 Transform(vec3  p){\n   p.xy*=Rot(p.z*.15);\n\n    p.z -=iTime*.1;\n    p.y -= .3;\n    \n    return p;\n\n}\n\nfloat GetDist(vec3 p) {\n    p=Transform(p);\n    float box = sdBox(p, vec3(1));\n    \n    // wanting something organic? the scales for two should not be multiplicable by each other (ex.: can't be 4 and 8)\n   \t\n   \tfloat g1 = sdGyroid(p, 5.23, .03, 1.4);\n    float g2 = sdGyroid(p, 10.76, .03, .3);\n    float g3 = sdGyroid(p, 20.76, .03, .3);\n    float g4 = sdGyroid(p, 35.76, .03, .3);\n    float g5 = sdGyroid(p, 60.76, .03, .3);\n    float g6 = sdGyroid(p, 110.76, .03, .3);\n    float g7 = sdGyroid(p, 210.76, .03, .3);\n    \n    //float g = max(g1,g2);//union \n  //float g = max(g1,-g2);//subtraction \n    //bump mapper\n    g1 -= g2*.4;\n    g1 -= g3*.3;\n    g1 += g4*.2;\n    g1 += g5*.2;\n    g1 += g6*.3;\n    g1 += g7*.5;\n    \n    //float d=max(box,g1*.8);// intersect the box \n   \t\n    float d = g1*.8;\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    \n//    the e.x determines the smoothness\n    vec2 e = vec2(.025, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Background(vec3 rd){\nfloat t = iTime*.2;\n    vec3 col = vec3(0);\n    vec3 fireCol = vec3(1,.45,.1);\n\n    \n    float y = rd.y*.5+.5;\n    \n    col+=(1.-y)*fireCol;\n    \n    //make flames\n    //smoothstep to make the top dark and bottom bright \n    \n    float a = atan(rd.x,rd.z);\n    float flames = sin(a*10.+t)*sin(a*7.-t)*sin(a*3.);\n    flames *=S(0.8,0.6,y);\n    col*=flames;\n    col = max(col,0.);\n    col+=S(.3,.0,y);\n    return col;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*0.2;\n    vec3 col = vec3(0);\n    vec3 fireCol = vec3(1,.45,.1);\n  \n\n    //distort effect \n    uv +=sin(uv*20.+t)*.01;\n    vec3 ro = vec3(0, 0, -1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 lookat = vec3(0,0,0);\n    //zoom factor 1\n    vec3 rd = GetRayDir(uv, ro, lookat, .8);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        float height = p.y;\n        p = Transform (p);\n        \n    \tfloat dif = n.y*.5+.5;\n    \tcol+=dif*dif*dif;// 0 <> 1 \n   \n    \n        //ambient occulusion - cheaper \n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        \n        col*=S(-.1,.05,g2);//blackening \n        \n        float crackWidth = -.02+S(0., -.5, n.y)*.04;\n        float cracks = S(crackWidth,-.025,g2);\n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.05, 4.76, .03, .0);\n        cracks *=g3*g4*20.+.1*S(.2,.0,n.y);\n\n        col+=cracks*fireCol*3.;\n        \n        float g5 = sdGyroid(p-vec3(0,t,0),1.85,.02,1.3);\n        \n        col+=g5*fireCol;\n\n        col +=S(0.,-2.,height)*fireCol;\n       \n\n    }\n    \n    col = mix(col, Background(rd), S(0., 7., d));\n    //col = Background(rd);\n\n    col*=1.-dot(uv,uv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 143, 143, 205], [207, 207, 229, 229, 323], [325, 325, 354, 354, 435], [437, 437, 501, 501, 798], [814, 814, 838, 838, 919], [921, 921, 944, 944, 1738], [1741, 1741, 1775, 1775, 1986], [1988, 1988, 2012, 2012, 2242], [2244, 2244, 2294, 2294, 2485], [2487, 2487, 2512, 2512, 2932], [2935, 2935, 2992, 2992, 4394]], "test": "untested"}
{"id": "tldBzl", "name": "[RGR] Water Surface", "author": "deeplo", "description": "water surface usig voronoi", "tags": ["water"], "likes": 3, "viewed": 369, "published": 3, "date": "1613311013", "time_retrieved": "2024-07-30T19:38:11.797732", "image_code": "#define S smoothstep\n#define BG_COLOR vec3(0.05,0.35,0.75)\n#define T (iTime)\n#define NB_POINTS 100.0\n\nmat2 Rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\n\nvec2 Hash22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(129.23,348.45,677.78));\n    a += dot(a,a+-87.65);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Background color\n    vec3 bg = BG_COLOR;\n    vec4 col = vec4(bg,0);\n\n    // Time flow\n    float time = iTime/2.0;\n    \n    // Scale viewport\n    uv *= 3.0;  \n    \n    // Apply sine wave\n    uv.y += sin((125.45+time)*.2)+sin(0.5*(uv.x+time)) ;\n\n    // Prepare voronoi loop (using 3x3 grid)\n    vec2 id  = floor(uv);\n    vec2 gv  = fract(uv) - 0.5;\n    float minDist = 1000.0;\n\n    // Grid loop\n    for(float dx=-1.0;dx<=1.0 ;dx+=1.0){\n        for(float dy=-1.0;dy<=1.0 ;dy+=1.0){\n            vec2 offset = vec2(dx,dy);\n            vec2 h = Hash22(id+offset);\n            vec2 p = offset+sin(h*(time+125.87))*0.5;\n            p -= gv;\n            float d = length(p);\n            if (d< minDist){\n                minDist = min(minDist,d);\n            }\n        }\n    }\n    \n    // Voronoi color\n    \n    float a = sin(iTime*0.05235);\n    a = abs(a)*0.5;              // 0 / +0.5\n    a *= 0.1;\n    \n    float b = sin(iTime*0.1235);\n    b = abs(b)*0.5+0.5;          // +0.5 / +1\n    b *= 3.0;\n    \n    float c = S(a,b,minDist*minDist);\n    col.rgb += vec3(c);\n\n\n    // Output\n    fragColor = col;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 124, 124, 205], [207, 207, 227, 227, 352], [355, 355, 412, 504, 1671]], "test": "untested"}
{"id": "ttdBzl", "name": "Misty Terraces", "author": "dr2", "description": "Terraced landscape with gliders and varying fog (mouseable)", "tags": ["terrain", "fog", "glider", "flight"], "likes": 14, "viewed": 356, "published": 3, "date": "1613310785", "time_retrieved": "2024-07-30T19:38:12.741209", "image_code": "// \"Misty Terraces\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], qHit, flPos, trkA, trkF, sunDir, noiseDisp;\nfloat tCur, dstFar, grhtMax, fogAmp, fogTop;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHtS (vec2 p)\n{\n  p = vec2 (p.x + p.y, p.x - p.y) / sqrt(2.);\n  return grhtMax * Fbm2 (0.1 * p);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, hh, nf, nl;\n  p = vec2 (p.x + p.y, p.x - p.y) / sqrt(2.);\n  nf = 0.5;\n  p = (floor (nf * p) +  smoothstep (0.2, 1., mod (nf * p, 1.))) / nf;\n  hh = Fbm2 (0.1 * p);\n  nl = 32.;\n  h = grhtMax * (floor (nl * hh) + smoothstep (0.4, 0.6, mod (nl * hh, 1.))) / nl + 0.05 * hh;\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.1, 0.5 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a, szFac;\n  szFac = 1.3;\n  a = 0.22 * pi;\n  dMin = dstFar / szFac;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]) / szFac;\n    q.x = abs (q.x);\n    q.z += 0.25;\n    qq = q;\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n    d = abs (max (max (abs (Rot2D (vec2 (abs (Rot2D (vec2 (qq.x, qq.z - 1.1), -0.012 * pi).x), qq.y), a).y) -\n       0.002, 0.), max (dot (q.xz, sin (0.15 * pi + vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.002;\n    DMINQ (1 + k);\n  }\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.3, 0.4, 0.8), vec3 (0.7, 0.7, 0.8), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, p, clCol;\n  float fd, f, ff;\n  if (rd.y > 0.) {\n    p = 0.01 * (rd * (100. - ro.y) / max (rd.y, 0.0001) + ro + 4. * tCur);\n    ff = Fbm2 (p.xz);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (p.xz + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.8) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.7, 0.7, 0.75), vec3 (0.5, 0.6, 0.9), 0.3 + 0.7 * fd),\n       clCol, 0.1 + 0.9 * f * fd) + 0.2 * vec3 (1., 1., 0.9) * pow (max (dot (rd, sunDir), 0.), 2048.);\n    col = mix (col, SkyBg (rd), pow (1. - max (rd.y, 0.), 8.));\n  } else col = SkyBg (rd);\n  return col;\n}\n\nfloat FogHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float a, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = p + vec2 (0., 0.05 * tCur);\n  a = 1.;\n  h = 0.;\n  tw = 0.05 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = abs (sin (2. * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += a * dot (t, t);\n    a *= 0.5;\n  }\n  return fogTop - 0.5 * h;\n}\n\nfloat FogDens (vec3 p)\n{\n  return fogAmp * (0.2 + 0.8 * smoothstep (0., 1., 1. - p.y / fogTop)) *\n     BumpFbm3 (0.03 * (p + noiseDisp)) * smoothstep (0., 1., FogHt (0.1 * p.xz) - p.y);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{  // updated from \"Sailing Home\"\n  float s, ds, f, fn;\n  s = 1.;\n  ds = 1.;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.9, 0.9, 0.95) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * (1. - smoothstep (0.3 * dHit, dHit, s)), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, col, c, vn;\n  float dstGrnd, dstObj, sh, df;\n  noiseDisp = 0.02 * vec3 (-1., 0., 1.) * tCur + 0.5 * sin (vec3 (0.2, 0.1, 0.3) * pi * tCur);\n  fogAmp = 0.2 + 0.8 * SmoothBump (0.25, 0.75, 0.22, mod (0.03 * tCur, 1.));\n  fogTop = grhtMax + 3.;\n  roo = ro;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      c = vec3 (0.3, 0.3, 1.);\n      col = (idObj == 1) ? c : ((idObj == 2) ? c.gbr : c.brg);\n      col = mix (col, 1. - col, smoothstep (0.02, 0.04, abs (length (vec2 (qHit.xz - vec2 (0.3, -0.1))) - 0.17)) *\n        (1. - smoothstep (0.95, 0.97, qHit.z)));\n      vn = ObjNf (ro);\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      df = dstGrnd / dstFar;\n      vn = GrndNf (ro);\n      vn = VaryNf ((1. + 4. * smoothstep (0.8, 0.9, vn.y)) * ro, vn, 1. - smoothstep (0.3, 0.7, df));\n      col = mix (vec3 (0.8, 0.7, 0.4) * (1. - 0.15 * (1. - smoothstep (0.3, 0.7, df)) *\n         smoothstep (0.4, 0.45, abs (mod (16. * ro.y, 1.) - 0.5))), vec3 (0.4, 1., 0.4), smoothstep (0.8, 0.9, vn.y));\n      col *= 0.4 + 0.6 * smoothstep (0.1, 0.9, ro.y / grhtMax);\n      col *= 1. - 0.3 * Fbm2 (128. * ro.xz);\n      sh = GrndSShadow (ro + 0.01 * vn, sunDir);\n    }\n    col *= 0.2 + 0.2 * max (dot (vn, normalize (vec3 (- sunDir.xz, 0.).xzy)), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.);\n    col = mix (col, SkyBg (rd), pow (df, 8.));\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  col = FogCol (col, roo, rd, min (dstGrnd, dstObj));\n  return clamp (col, 0., 1.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col, e;\n  vec2 sa, hax;\n  e = vec3 (1., 0., -1.);\n  hax = vec2 (0.5 * sqrt (3.), 0.5);\n  uv *= 2.;\n  col = vec3 (0.);\n  if (sd.z > 0.) {\n    sa = uv + 0.3 * sd.xy;\n    col = 0.1 * pow (sd.z, 8.) * (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n       e.xxy * (1. - smoothstep (0.11, 0.12, max (abs (sa.y), max (abs (dot (sa, hax)), abs (dot (sa, hax * e.xz)))))) +\n       e.xyx * SmoothBump (0.32, 0.4, 0.04, length (uv - 0.7 * sd.xy)) +\n       0.8 * e.yxx * SmoothBump (0.72, 0.8, 0.04, length (uv + sd.xy)));\n  }\n  return col;\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 0., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvoid FlyerPM (float t, int isOb)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = ((isOb > 0) ? 5. : 10.) * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, flyVel, vDir, hSum, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.07 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, 0.3 * pi);\n  grhtMax = 11.;\n  flyVel = 2.;\n  trkA = 0.2 * vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  vDir = sign (0.5 * pi - abs (az));\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    t = flyVel * tCur + vDir * (8. + 5. * float (k));\n    FlyerPM (t, 0);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    flyerPos[k].x += 0.5 * sin (0.1 * pi * t);\n    hSum = 0.;\n    for (float j = float (VAR_ZERO); j < 7.; j ++) hSum += GrndHtS (TrkPath (t + vDir * (j - 1.)).xz);\n    flyerPos[k].y = grhtMax - 2. + hSum / 7.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t, 1);\n  ro = flPos;\n  hSum = 0.;\n  for (float j = float (VAR_ZERO); j < 7.; j ++) hSum += GrndHtS (TrkPath (t + 1.5 * vDir * (j - 1.)).xz);\n  ro.y = grhtMax + hSum / 7.;\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 1.3, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.6 * pi * sin (0.02 * pi * tCur));\n  zmFac = 3.;\n  dstFar = 120.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = (vuMat * rd) * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col += GlareCol ((vuMat * normalize (vec3 (uv, zmFac))) * flMat, (flMat * sunDir) * vuMat, uv);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{  // from \"Energy Temple\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[705, 705, 729, 729, 812], [814, 814, 837, 837, 1133], [1135, 1135, 1169, 1169, 1649], [1651, 1651, 1673, 1673, 1812], [1814, 1814, 1852, 1852, 2112], [2114, 2114, 2136, 2136, 2686], [2688, 2688, 2721, 2721, 2904], [2906, 2906, 2927, 2927, 3184], [3186, 3186, 3223, 3223, 3452], [3454, 3454, 3476, 3476, 3568], [3570, 3570, 3602, 3602, 4329], [4331, 4331, 4353, 4353, 4835], [4837, 4837, 4861, 4861, 5024], [5026, 5026, 5080, 5112, 5500], [5502, 5502, 5537, 5537, 7188], [7190, 7190, 7233, 7233, 7801], [7803, 7803, 7827, 7827, 7880], [7882, 7882, 7905, 7905, 7966], [7968, 7968, 7991, 7991, 8061], [8063, 8063, 8097, 8097, 8492], [8494, 8494, 8547, 8547, 10425], [10427, 10427, 10484, 10484, 10567], [10569, 10569, 10605, 10605, 10811], [10813, 10813, 10843, 10843, 10956], [10958, 10958, 10984, 10984, 11046], [11048, 11048, 11073, 11073, 11135], [11137, 11137, 11162, 11187, 11451], [11485, 11485, 11509, 11509, 11574], [11576, 11576, 11600, 11600, 11730], [11732, 11732, 11756, 11756, 11819], [11821, 11821, 11846, 11846, 12032], [12034, 12034, 12059, 12059, 12396], [12398, 12398, 12419, 12419, 12574], [12576, 12576, 12605, 12605, 12817], [12819, 12819, 12858, 12858, 13038]], "test": "untested"}
{"id": "wltBRl", "name": "3D SDF-SDF Collision Detection", "author": "oneshade", "description": "Detecting collisions between 3D SDFs (can be applied to other dimensions easily as well). The potential collision point is calculated in Buffer A to avoid having to recalculate it for each pixel (which is SLOW).", "tags": ["3d", "raymarching", "collision", "sdf", "collisiondetection"], "likes": 20, "viewed": 1354, "published": 3, "date": "1613295800", "time_retrieved": "2024-07-30T19:38:13.518132", "image_code": "/*\nNote that the \"strings\" the shapes are hanging off of are also part of\ntheir distance fields so they get included as colliders.\n*/\n\nstruct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nSurface surfMin(in Surface a, in Surface b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nSurface mapScene(in vec3 p) {\n    float d1 = sdf1(p, iTime);\n    float d2 = sdf2(p, iTime);\n\n    Surface box = Surface(d1, vec3(0.0), vec3(0.0, 0.0, 1.0), vec3(1.0), 4.0);\n    Surface horseshoe = Surface(d2, vec3(0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 16.0);\n\n    p.y += 4.0;\n    Surface table = Surface(sdBox(p, vec3(5.0, 0.25, 5.0)) - 0.1, vec3(0.0), vec3(0.8, 0.4, 0.4), vec3(1.0), 4.0);\n\n    float hangerDist = sdCapsule(p - vec3(4.25, 4.5, 0.0), 4.5, 0.2);\n    hangerDist = min(hangerDist, sdCapsule(p.yxz - vec3(9.0, 1.75, 0.0), 2.5, 0.2));\n    Surface hanger = Surface(hangerDist, vec3(0.0), vec3(1.2, 0.8, 0.6), vec3(0.0), 0.0);\n\n    p.y -= 4.0;\n    vec3 hitPos = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    Surface hit = Surface(length(p - hitPos) - 0.25, vec3(0.0), vec3(1.0), vec3(0.0), 0.0);\n\n    return surfMin(box, surfMin(horseshoe, surfMin(table, surfMin(hanger, hit))));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 15.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            vec3 n = getNormal(p);\n            fragColor.rgb = scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            vec3 closest = texelFetch(iChannel0, ivec2(0), 0).xyz;\n            if (sdf1(closest, iTime) < 0.0) { // The SDFs are colliding (the choice of SDF doesn't matter btw)\n                fragColor.rg = vec2(1.0, 0.0);\n            }\n\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Settings (completely overkill but buffers have saved me)\n#define ITERATIONS 1500\n#define DESCENT_RATE 0.005\n#define EPSILON 0.001\n#define DELTA 0.001\n\n// Animated positions\n#define horseshoePos(t) vec3(-5.0 * sin(cos(t * 1.5) * 1.25), 5.0 * cos(cos(t * 1.5) * 1.25) - 3.0, 0.0)\n#define boxPos(t) vec3(-5.0 * vec2(0.7) * sin(cos(t * 1.5) * 1.25), 3.0 - 5.0 * cos(cos(t * 1.5) * 1.25)).xzy\n\n// Utilities\nvoid Rotate(inout vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    p *= mat2(c, -s, s, c);\n}\n\n// Rotate on axis, from tdhooper (https://www.shadertoy.com/view/WlKyzW) who in turn got it from blackle\nvoid RotateAxis(inout vec3 p, in vec3 ax, in float ro) {\n    p = mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCapsule(in vec3 p, in float h, in float r) {\n    return length(vec3(p.x, max(0.0, abs(p.y) - h), p.z)) - r;\n}\n\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b, in float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(p - clamp(p, -s, s)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\nfloat sdHorseshoe(in vec3 p, in vec2 c, in vec3 w, in float r) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p.xy = mat2(-c.x, c.y, c.y, c.x) * p.xy;\n    p.xy = vec2((p.y > 0.0) ? p.x : -l * sign(c.x), (p.x > 0.0) ? p.y : l);\n    p.xy = vec2(p.x, abs(p.y - r)) - w.xy;\n    float d = length(max(p.xy, 0.0)) + min(0.0, max(p.x, p.y));\n    vec2 w2 = vec2(d, abs(p.z) - w.z);\n    return length(max(w2, 0.0)) + min(max(w2.x, w2.y), 0.0);\n}\n\n// SDFs\nfloat sdf1(in vec3 p, in float t) {\n    vec3 bp = boxPos(t);\n\n    float str = sdLine(p, vec3(-0.5, 5.0, 0.0), bp, 0.05);\n\n    p -= bp;\n    RotateAxis(p, vec3(0.58), t);\n    RotateAxis(p, vec3(0.7, 0.0, 0.7), -cos(t));\n\n    float b = sdBox(p, vec3(0.4, 1.0, 0.6)) - 0.1;\n    return min(b, str);\n}\n\nfloat sdf2(in vec3 p, in float t) {\n    vec3 hp = horseshoePos(t);\n    float osc = -cos(t * 2.0);\n\n    vec3 e = vec3(0.0, 1.0, 0.0);\n    Rotate(e.xy, osc);\n    Rotate(e.xz, t);\n    e += hp * vec3(1.0, -1.0, 1.0);\n    float str = sdLine(p, vec3(0.5, 5.0, 0.0), e, 0.05);\n\n    p.y *= -1.0;\n    p -= hp;\n    Rotate(p.xz, t);\n    Rotate(p.xy, osc);\n\n    float h = (sdHorseshoe(p, vec2(sin(0.25), cos(0.25)), vec3(1.0, 0.25, 0.2), 1.0) * 0.75) - 0.075;\n    return min(h, str);\n}\n\n// Gradients (numeric)\nvec3 grad1(in vec3 p, in float t) {\n    vec2 eps = vec2(DELTA, 0.0);\n    return vec3(sdf1(p + eps.xyy, t) - sdf1(p - eps.xyy, t),\n                sdf1(p + eps.yxy, t) - sdf1(p - eps.yxy, t),\n                sdf1(p + eps.yyx, t) - sdf1(p - eps.yyx, t)) / (2.0 * DELTA);\n}\n\nvec3 grad2(in vec3 p, in float t) {\n    vec2 eps = vec2(DELTA, 0.0);\n    return vec3(sdf2(p + eps.xyy, t) - sdf2(p - eps.xyy, t),\n                sdf2(p + eps.yxy, t) - sdf2(p - eps.yxy, t),\n                sdf2(p + eps.yyx, t) - sdf2(p - eps.yyx, t)) / (2.0 * DELTA);\n}\n\n// Gradient descent solver\n#define fmax(p, t) max(sdf1(p, t), sdf2(p, t))\nvec3 grad(in vec3 p, in float t) {\n    vec2 eps = vec2(DELTA, 0.0);\n    return vec3(fmax(p + eps.xyy, t) - fmax(p - eps.xyy, t),\n                fmax(p + eps.yxy, t) - fmax(p - eps.yxy, t),\n                fmax(p + eps.yyx, t) - fmax(p - eps.yyx, t)) / (2.0 * DELTA);\n}\n\nvec3 findClosest(in vec3 seed, in float t) {\n    vec3 closest = seed;\n    for (int i=0; i < ITERATIONS; i++) {\n        vec3 g = grad(closest, t);\n        closest -= g * DESCENT_RATE;\n        if (length(g) < EPSILON) {\n            break;\n        }\n    }\n\n    return closest;\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor.xyz = findClosest(boxPos(iTime), iTime); // Starting with least nonconvex object seems to work best\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 289, 289, 340], [342, 342, 371, 371, 1230], [1232, 1232, 1259, 1259, 1536], [1538, 1538, 1593, 1593, 3112]], "test": "untested"}
{"id": "3ldBzs", "name": "random pixel sprites - golf (583", "author": "FabriceNeyret2", "description": "golfing  [url]https://shadertoy.com/view/WltBzs[/url],\nshort version of \"random pixel sprites\" by stb. [url]https://shadertoy.com/view/3ttfzl[/url]\n", "tags": ["procedural", "pixel", "random", "sprite", "sprites"], "likes": 11, "viewed": 393, "published": 3, "date": "1613291665", "time_retrieved": "2024-07-30T19:38:14.365866", "image_code": "// Golfing https://shadertoy.com/view/WltBzs ( 866 chars )\n// Short version of \"random pixel sprites\" by stb. https://shadertoy.com/view/3ttfzl ( 2371 chars )\n\n\n#define H(p)     fract( sin(p) * 4e3 )\n#define h(p)     H( (p+floor(q)) * mat2x3(R,K,.7*R) )\n#define N(p,z) ( q = vec3(p,z) / .1,                     \\\n                 f = fract(q), f *= f*(3.-f-f),          \\\n                 mix( mix( h()     , h(o.xyy), f.x ),    \\\n                      mix( h(o.yxy), h(o.xxy), f.x ),    \\\n                      f.y ) - .5                         \\\n               )\n\nvoid mainImage( out vec4 O, vec2 p ) {\n    vec2 R = iResolution.xy, K = R.yx, o = vec2(1,0);\n    vec3 q,f;\n\tp = ( p - iMouse.xy ) / 72.;   \n    p.y += .5 * iTime; \n    \n    float z = 54. * H( dot( ceil(p), R ) );\n    \n    p = fract( ceil(p*24.) / 24. ) - .5; \n    p.x = abs(p.x); \n\n#define M(p)   length( p - .3* N(p,z) ) > .27 \n    bool m = M(p), b = m;\n    for ( int k=0; k<9; k++ )\n        b = b && M( p - vec2(k%3-1,k/3-1) / 24. );    \n        \n     O.rgb =  b||m  ? vec3( b )\n                    : pow( H(  vec3( ceil( p/.213  - 2.17*N(p,0) - z ), z )\n                             * mat3(R,K,.7*K,.7*R,.9*R)), \n                           vec3(.75) ); \n}\n\n\n\n\n\n\n/* // --- 596 chars\n\n#define R        iResolution.xy\n#define H(p)     fract( sin(p) * 4e3 )\n#define h(p)     H( (p+i) * mat2x3(R.xyyx,.7*R) )\n#define N(p,z) ( q = vec3(p,z) / .1,                     \\\n                 i = floor(q),                           \\\n                 f = fract(q), f *= f*(3.-f-f),          \\\n                 mix( mix( h()     , h(o.xyy), f.x ),    \\\n                      mix( h(o.yxy), h(o.xxy), f.x ),    \\\n                      f.y ) - .5                         \\\n               )\n\nvoid mainImage( out vec4 O, vec2 p ) {\n    vec3 q,i,f, o = vec3(1,0,0);\n\tp = 5.* ( p - iMouse.xy ) / R.y;   \n    p.y += .5 * iTime; \n    \n    float z = 54. * H( dot( ceil(p), R ) );\n    \n    p = fract( ceil(p*24.) / 24. ) - .5; \n    p.x = abs(p.x); \n\n#define M(p)   length( p - .3* N(p,z) ) > .27 \n    bool m = M(p), b = m;\n    for ( int k=0; k<9; k++ )\n        b = b && M( p - vec2(k%3-1,k/3-1) / 24. );    \n        \n     O.rgb =  b||m  ? vec3( b )\n                    : pow( H(  vec3( ceil( p/.213  - 2.17*N(p,0) - z ), z )\n                             * mat3(R.xyyx,.7*R.yxxy,.9*R)), \n                           vec3(.75) ); \n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[567, 567, 605, 605, 1225]], "test": "untested"}
{"id": "WttBDN", "name": "Dots universe", "author": "abelu", "description": "Dots universe", "tags": ["noise", "random", "dots"], "likes": 1, "viewed": 293, "published": 3, "date": "1613288748", "time_retrieved": "2024-07-30T19:38:15.263466", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nfloat random(vec2 st) {\n  return fract(\n    sin(dot(st.xy, vec2(12.9898,78.233)) * 43758.5453123)\n  );\n}\n\n#define PI 3.1415926538\n#define SCALE 7.\n#define FACTOR .4\n#define SPEED .5\n#define LINE_THICKNESS 0.072\n#define POINT_SIZE 0.03\n#define TIME_SHIFT 100.0\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return smoothstep(\n    0.0,\n    1.0 / iResolution.x + LINE_THICKNESS,\n    length(pa - ba * h)\n  );\n}\n\nvec2 getOffset(vec2 indecies) {\n  float noiseX = clamp(random(indecies.xy + 0.1), 0.0, 1.0);\n  float noiseY = clamp(random(indecies.yx + 0.1), 0.0, 1.0);\n  float seedX = sin(noiseX * TIME_SHIFT + iTime * noiseX * SPEED);\n  float seedY = cos(noiseY * TIME_SHIFT + iTime * 2.0 * noiseY * SPEED);\n\n  return vec2(\n    noiseX * FACTOR * seedX,\n    noiseY * FACTOR * seedY\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const vec2 center = vec2(0.5);\n\n  vec2 st = fragCoord / iResolution.y;\n  float scale = SCALE + sin(iTime * 0.1);\n  vec2 position = (st - center) * scale - center * scale;\n\n  st = fract(position);\n\n  vec2 indecies = floor(position);\n  vec2 point = getOffset(indecies) + center;\n  float pointAlpha = random(indecies.yx);\n  float size = POINT_SIZE + random(indecies) * 0.02 + 0.02 * (sin(iTime * random(indecies.yx)) * 0.5 + 0.5);\n  float shapeAlpha = smoothstep(\n    size,\n    size - 0.05,\n    length(st - point)\n  ) * pointAlpha;\n\n  float linesAlpha = 0.0;\n\n  for (float i = 0.0; i < 4.0; i += 1.0) {\n    float angle = PI * 0.5 * i;\n    vec2 shift = vec2(sin(angle), cos(angle));\n    vec2 to = getOffset(indecies + shift) + shift + center;\n\n    linesAlpha += max(\n      0.0,\n      (1.0 - lineSegment(st, point, to)) * (1.0 - distance(point, to)) * 2.0\n    );\n  }\n\n  const vec3 pointColor = vec3(0.99, 0.8, 0.99);\n  const vec3 linesColor = vec3(0.9, 0.5, 0.8);\n\n  vec3 color = pointColor * shapeAlpha + linesColor * linesAlpha;\n\n  // Output to screen\n  fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 67, 67, 148], [305, 305, 348, 348, 546], [548, 548, 579, 579, 921], [923, 923, 978, 978, 2062]], "test": "untested"}
{"id": "3tdBRs", "name": "Distance to Box", "author": "oneshade", "description": "Finally derived the distance to a box myself ;)", "tags": ["2d", "sdf", "box", "oneliner"], "likes": 2, "viewed": 193, "published": 3, "date": "1613276585", "time_retrieved": "2024-07-30T19:38:16.025428", "image_code": "float sdBox(in vec2 p, in vec2 s) {\n    return length(p - clamp(p, -s, s)) + min(0.0, max(abs(p.x) - s.x, abs(p.y) - s.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float w = 0.5 + 0.25 * sin(iTime);\n    float h = 0.25 + 0.2 * cos(iTime);\n    float d = sdBox(uv, vec2(w, h));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 125], [127, 127, 182, 182, 695]], "test": "untested"}
{"id": "3ltBRs", "name": "Closest Point on 2 SDFs", "author": "oneshade", "description": "Solving for the closest point on two SDFs using gradient descent.", "tags": ["sdf", "rootfinding", "gradientdescent", "closest"], "likes": 13, "viewed": 449, "published": 3, "date": "1613273965", "time_retrieved": "2024-07-30T19:38:16.846234", "image_code": "/*\nFinding the closest point between two SDFs using gradient descent.\n\nNote: for specific cases it is best to use analytic gradients (or better yet, solve for the\nclosest point analytically, I have no clue how to go about doing that btw)\n\nUses: I've only thought of one, collision detection, if (and only if) the closest point to both SDFs\nis inside either SDF, they are colliding. The closest point should also be the contact point (unless\nthey are intersecting).\n\nSome optimizations made here: https://www.shadertoy.com/view/3t3fWB\n*/\n\n////////////////////////////////////////////////// SDFs /////////////////////////////////////////////////\n\nfloat sdf1(in vec2 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p += vec2(s, s * c) * 0.4 + vec2(0.4, 0.0);\n    Rotate(p, iTime);\n    return sdBox(p, vec2(0.25 + 0.125 * s, 0.1 + 0.075 * c));\n}\n\nfloat sdf2(in vec2 p) {\n    p.x -= 0.45;\n    float frac = fract(iTime);\n    p.y -= frac * (1.0 - frac) - 0.1;\n    Rotate(p, -2.0 * iTime);\n    float a = 0.25;\n    return sdHorseshoe(p, vec2(sin(a), cos(a)), vec2(0.2, 0.1), 0.2);\n}\n\n//////////////////////////////////////// SDF Gradients //////////////////////////////////////////////////\n\nvec2 grad1(in vec2 p) {\n    return vec2(sdf1(p + vec2(DELTA, 0.0)) - sdf1(p - vec2(DELTA, 0.0)),\n                sdf1(p + vec2(0.0, DELTA)) - sdf1(p - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}\n\nvec2 grad2(in vec2 p) {\n    return vec2(sdf2(p + vec2(DELTA, 0.0)) - sdf2(p - vec2(DELTA, 0.0)),\n                sdf2(p + vec2(0.0, DELTA)) - sdf2(p - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}\n\n////////////////////////////////////// Solver (gradient descent) ////////////////////////////////////////\n\n// Seed is somewhat arbitrary but will affect performance in some cases\n// If the object positions are known (or can be estimated), its probably best\n// to just pick the midway point\n#define fmax(p) max(sdf1(p), sdf2(p))\nvec2 grad(in vec2 p) {\n    return vec2(fmax(p + vec2(DELTA, 0.0)) - fmax(p - vec2(DELTA, 0.0)),\n                fmax(p + vec2(0.0, DELTA)) - fmax(p - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}\n\nvec2 findClosest(in vec2 seed) {\n    vec2 closest = seed; // Current guess\n    for (int i=0; i < ITERATIONS; i++) {\n        vec2 g = grad(closest);\n        closest -= g * DESCENT_RATE; // Move down slope\n        if (length(g) < EPSILON) { // Alternatively, all(lessThan(abs(g), vec2(EPSILON))) to avoid square roots\n            break; // Exit loop if under the error margin\n        }\n    }\n\n    return closest;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float d = min(sdf1(uv), sdf2(uv));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    vec2 closest = findClosest(vec2(0.0));\n    vec2 proj1 = closest - normalize(grad1(closest)) * sdf1(closest); // Project onto first SDF\n    vec2 proj2 = closest - normalize(grad2(closest)) * sdf2(closest); // Project onto second SDF\n\n    color = mix(color, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, sdLine(uv, proj1, proj2)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), 1.0 - smoothstep(0.0, 0.015, length(uv - closest) - 0.01));\n    color = mix(color, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(0.0, 0.015, length(uv - proj1) - 0.01));\n    color = mix(color, vec3(0.0, 0.0, 1.0), 1.0 - smoothstep(0.0, 0.015, length(uv - proj2) - 0.01));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "//////////////////////////////////////// Solver Hyperparameters /////////////////////////////////////////\n\n// Maximum iterations\n#define ITERATIONS 75\n\n// Controls how fast the algorithm steps (don't make too large!)\n#define DESCENT_RATE 0.02\n\n// Error margin\n#define EPSILON 0.001\n\n// Small number\n#define DELTA 0.001\n\n///////////////////////////////////////////// Utilities /////////////////////////////////////////////////\n\nvoid Rotate(inout vec2 p, in float r) {\n    float c = cos(r), s = sin(r);\n    p *= mat2(c, -s, s, c);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdHorseshoe(in vec2 p, in vec2 c, in vec2 w, in float r) {\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x) * p;\n    p = vec2((p.y > 0.0) ? p.x : -l * sign(c.x), (p.x > 0.0) ? p.y : l);\n    p = vec2(p.x, abs(p.y - r)) - w;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 668, 668, 844], [846, 846, 869, 869, 1076], [1185, 1185, 1208, 1208, 1373], [1375, 1375, 1398, 1398, 1563], [1893, 1893, 1915, 1915, 2080], [2082, 2082, 2114, 2114, 2494], [2496, 2496, 2551, 2551, 3605]], "test": "untested"}
{"id": "3tcBz7", "name": "[phreax]  butterfly effect", "author": "phreax", "description": "Raymarching, kifs, non-linear time", "tags": ["raymarching", "kifs"], "likes": 11, "viewed": 482, "published": 3, "date": "1613272663", "time_retrieved": "2024-07-30T19:38:17.724885", "image_code": "/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2021\n*/\n\n#define PI 3.141592\n#define SIN(x) (sin(x)*.5+.5)\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n#define RAINBOW 1\n#define SYMMETRICAL 0\n\nfloat tt;\n\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// from \"Palettes\" by iq. https://shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getPal(int id, float t) {\n\n    id = id % 7;\n\n    vec3          col = pal( t, vec3(.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,-0.33,0.33) );\n    if( id == 1 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( id == 2 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( id == 3 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( id == 4 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( id == 5 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( id == 6 ) col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return col;\n}\n\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\n\nvec3 transform(vec3 p) {\n    float a = PI*.5*curve(iTime, 4.);\n    \n    // rotate object\n    p.xz *= rot2(a);\n    p.xy *= rot2(a);\n    return p;\n}\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n\n    p = transform(p);\n\n    #if SYMMETRICAL\n    p.y = -(abs(p.y) -.3);  \n    #endif\n    \n    p.x *= 1.+SIN(curve(iTime, 4.))*(smoothstep(-0.9, 0.9, -p.y));\n    p.z *= 1.+.5*(smoothstep(-0.9, 1.5, -p.y));\n\n\n    p.x = abs(p.x) -.5*SIN(tt*.5);\n    p.y = abs(p.y) -.9*SIN(tt*.8);\n    p.y -= 0.1;\n    p.y = abs(p.y) -.1;\n    p.x -= 0.2;\n    p.x = abs(p.x) -.9; \n    p.z = abs(p.z) -.5;\n\n    p.zy -= 0.5;\n    p.xy *= rot2(0.1*tt);\n    p.zy *= rot2(-.04*tt);\n                           \n\n    // torus\n    float r1 = 1.0;\n    float r2 = 0.03;\n    \n    vec2 cp = vec2(length(p.xz) - r1, p.y);\n    vec2 cp2 = cp;\n    \n    // torus knots by BigWings\n    float a = atan(p.z, p.x);\n    cp *= rot2(3.*a+tt);\n    cp.x = abs(cp.x) - .3;\n\n    cp *= rot2(3.*a);\n    \n    // kifs\n    float n = 10.;\n    for(float i = 0.; i< n; i++) {\n    \n        cp.y = abs(cp.y) -.05*(.5*sin(tt)+.9);\n        \n        cp *= rot2(0.1*a*sin(0.1*iTime));\n        cp -= i*0.01/n;\n    }\n\n    \n    float d = length(cp) - r2;\n  \n    return .4*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float cz = -5.+1.5*sin(curve(iTime, 4.));\n    \n    vec3 ro = vec3(0, .0, cz),\n         rd = normalize(vec3(uv, .7));\n         \n    vec3 p = ro;\n    vec3 col;\n    \n    float t, d = 0.1;\n    \n    tt = iTime;  \n    tt = tt+2.*curve(tt, 2.);\n    \n    float acc = 0.0;\n    for(float i=.0; i<200.; i++) {\n    \n        d = map(p);\n        \n        if(d < 0.0001 || t > 100.) break;\n        \n        // Phantom mode https://www.shadertoy.com/view/MtScWW\n        d = max(abs(d), 0.009);\n        acc += 0.07;\n        \n        t += d;\n        p += rd*d;\n    }\n       \n    if(d < 0.001) {\n        col += acc*clamp(1., 0., 1.2*abs(cz)/(t*t));\n          \n        float sl = dot(p,p);\n        #if RAINBOW\n            col *= 0.5*getPal(4, 1.-0.1*sqrt(sl)+0.05*p.z+.25*iTime+curve(iTime, 8.));\n        #else\n            col *= mix(vec3(0, .85, .75), vec3(1.000,0.541,0.141), 1.-0.1*sl+0.1*p.z);\n        #endif\n    }\n    \n    \n    col = pow(col, vec3(1.2))*1.4;\n   \n    // Output to screen\n    fragColor = vec4(col, 1.0 - t * 0.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBz7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[247, 247, 267, 267, 315], [317, 377, 445, 445, 488], [490, 490, 520, 520, 1325], [1328, 1340, 1371, 1371, 1456], [1459, 1459, 1483, 1483, 1605], [1607, 1607, 1626, 1626, 2651], [2653, 2653, 2710, 2710, 3794]], "test": "untested"}
{"id": "wldBRf", "name": "Alien ocean", "author": "NLIBS", "description": "A stylized alien ocean inspired by \"Very fast procedural ocean\" by afl_ext\nCan you spot the other planet in the sky?", "tags": ["raymarching", "waves", "sea", "ocean", "sky", "reflections", "scattering", "mist", "multipass"], "likes": 43, "viewed": 2047, "published": 3, "date": "1613267662", "time_retrieved": "2024-07-30T19:38:18.591568", "image_code": "const vec3 star_dir = vec3(0.,.199,.98);\nconst vec3 star_col = vec3(1.,.5,.06)*200.;\n\nfloat ray(vec3 ro, vec3 rd, float t) \n{\n    vec3 p = ro+t*rd;\n    float h = 0.0;\n    for (int i=0;i<50;i++) {\n        float h = p.y-srf(p.xz,ITERS_RAY, iTime).x;\n        t+=h;\n        p+=rd*h;\n        if (h<EPS*t) return t;\n    }\n    return t;\n}\n\nvec3 sky(vec3 rd)\n{\n    float z = rd.z*.5+.5;\n    float v = max(dot(rd,star_dir),0.);\n    vec3 star = pow(min(pow(v,5.),.992),450.)*star_col + pow(v,40.)*vec3(1.,.4,.03);\n    star *= 1.-smoothstep(4e-3,3e-3,length(rd-vec3(-.049,.291,.955)))*.7;\n    \n    float mist_col = exp(min(-rd.y*8.,0.))*0.03;\n    vec3 sky_col = mix(vec3(.2,.5,.8)*(z+1.)*.01,vec3(.25,.02,.01),z*z*.9)*1.5;\n    vec3 col = sky_col+mist_col+star;\n    return col;\n}\n\nfloat fresnel(vec3 rd, vec3 N, float n1, float n2)\n{\n    float I = acos(abs(dot(rd, N))-1e-5);\n    float cosI = cos(I);\n    float cosR = n1/n2 * sin(I);\n    if(cosR > 1.) return 1.;\n    cosR = sqrt(1. - cosR * cosR);\n    float Rs = (n1*cosI - n2 * cosR)/(n1*cosI + n2 * cosR);\n    float Rp = (n1*cosR - n2 * cosI)/(n1*cosR + n2 * cosI);\n    return mix(Rs*Rs, Rp*Rp, .5);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R   = iResolution.xy,\n         uv  = (2.*u-R)/R.x,\n         muv = (2.*iMouse.xy-R)/R.x*-float(iMouse.z>1.)*PI;    \n    \n    //Camera\n    vec3 vo = vec3(iTime,1.01,iTime),\n         vd = camera_ray(vo,uv,muv,iTime),\n    //Sky colour\n         sky_col = sky(vd),\n         col = sky_col;\n    \n    if ((1.0-vo.y)/vd.y>0.0) {\n        //raymarch using previous pass\n        float t = texelFetch(iChannel0,ivec2(u)>>3,0).x;\n        t = ray(vo,vd, t);\n        \n        //normal using derivative\n        vec3 p = vo+vd*t;\n        vec3 N = norm(p.xz, max(ITERS_NORMAL+min(int(log(t)*-10.),0),1), iTime);\n        \n        //Reflected ray\n        vec3 refd = reflect(vd,N);\n        //Approx reflection occlusion from other waves\n        float ref_hit = clamp((p.y+refd.y*100.-.5)*.5,0.,1.);\n        //vec3 ref_col = mix(vec3(0),sky(refd),ref_hit);\n        vec3 ref_col = mix(sky(normalize(refd+vec3(0,.2,0)))*.4,sky(refd),ref_hit);\n\n        //approx SSS\n        vec3 H = normalize(star_dir+N*.05);\n        float thick = pow(1.-p.y,2.);\n        float I = pow(max(dot(vd,H),0.), 8.)*.002;\n        vec3 ss_col = I*star_col*pow(vec3(.8,.15,.02)*.5,vec3(.3+thick*2.));\n\n        //Mix using fresnel\n        col = mix(ss_col,ref_col,fresnel(vd,N,1.,1.333));\n        \n        //Fog\n        col = mix(sky_col,col,exp(-pow(t,1.5)*.007));\n        //col = ss_col;\n    }\n    \n    vec2 d = pow(abs(uv*.5)+.1,vec2(4.));\n\tcol *= pow(1.-.84*pow(d.x+d.y,.25),2.); //vignette\n    col += col*col;\n    col = 1.-exp(-col);\n    col = pow(col,vec3(1./2.2));\n    \n    vec3 noise = pow(texelFetch(iChannel1, ivec2(u)%1024, 0).rgb,vec3(1./2.2));\n    noise = (noise*2.-1.)*0.499*2.;\n    col += noise/256.;\n        \n    O = vec4(col,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592\n#define EPS 0.005\n\n#define ITERS_RAY    17\n#define ITERS_NORMAL 45\n#define W_DEPTH  2.2\n#define W_SPEED  1.4\n#define W_DETAIL .75\n\nconst mat2 rot = mat2(cos(12.),sin(12.),-sin(12.),cos(12.));\n\nvec3 srf(vec2 pos, int n, float time)\n{\n    pos *= W_DEPTH;\n    float freq = 0.6;\n    float t = W_SPEED*time;\n    float weight = 1.0;\n    float w = 0.0;\n    vec2 dx = vec2(0);\n    \n    vec2 dir = vec2(1,0);\n    for(int i=0;i<n;i++){\n        dir = rot*dir;\n        float x = dot(dir, pos) * freq + t;\n        float wave = exp(sin(x)-1.);\n        vec2 res = vec2(wave, wave*cos(x)) * weight;\n        pos    -= dir*res.y*.48;\n        w      += res.x;\n        dx     += res.y*dir / pow(weight,W_DETAIL);\n        weight *= .8;\n        freq   *= 1.2;\n        t   *= 1.08;\n    }\n    float ws = (pow(.8,float(n))-1.)*-5.; //Geometric sum\n    \n    return vec3(w / ws,dx / pow(ws,1.-W_DETAIL));\n}\n\nvec3 norm(vec2 p, int n, float time){\n    return normalize(vec3(-srf(p.xy, n, time).yz,1.).xzy);\n}\n\nvec3 camera_ray(vec3 vo, vec2 uv, vec2 muv, float iTime)\n{\n    vec3 vd = normalize(vec3(uv,1));\n    \n    //Add Mouse rotation\n    vec4 cs = vec4(cos(muv),sin(muv));\n    vd.yz = mat2(cs.y,cs.w,-cs.w,cs.y)*vd.yz;\n    vd.xz = mat2(cs.x,cs.z,-cs.z,cs.x)*vd.xz;\n    //Add Water bobbing\n    vec2 ang = norm(vo.xz,5, iTime).xz*-.05*PI;\n    cs = vec4(cos(ang),sin(ang));\n    vd.xy = mat2(cs.x,cs.z,-cs.z,cs.x)*vd.xy;\n    vd.zy = mat2(cs.y,cs.w,-cs.w,cs.y)*vd.zy;    \n    return vd;\n}", "buffer_a_code": "float ray(vec3 ro, vec3 rd, float t) \n{\n    vec3 p = ro+t*rd;\n    float h = 0.;\n    for (int i=0;i<100;i++) {\n        float h = p.y-srf(p.xz,ITERS_RAY, iTime).x;\n        if (h<t*EPS*4.) return t;\n        t+=h;\n        p+=rd*h;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy;\n    if (all(lessThan(u*8.,R))) {\n         vec2 uv  = (16.*u-R)/R.x,\n              muv = (2.*iMouse.xy-R)/R.x*-float(iMouse.z>1.)*PI; \n\n        //Camera\n        vec3 vo = vec3(iTime,1.01,iTime),\n             vd = camera_ray(vo,uv,muv,iTime);\n        \n        float t = -vo.y/(vd.y-1.0+EPS*8.);\n        if (t>0.) {\n            //march to surface with high epsilon\n            t = ray(vo,vd, t);\n        }\n\n        O = vec4(t);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 125, 125, 331], [333, 333, 352, 352, 767], [769, 769, 821, 821, 1141], [1143, 1143, 1184, 1184, 2890]], "test": "untested"}
{"id": "3ltBzl", "name": "Cubemap Reverse Sampling Test", "author": "oneshade", "description": "This took lots of trial and error, hope it helps someone else!\nExplanations are in the code.", "tags": ["test", "ray", "cubemap", "inverse", "identitytest", "reversesampling"], "likes": 3, "viewed": 190, "published": 3, "date": "1613265093", "time_retrieved": "2024-07-30T19:38:19.665696", "image_code": "/*\nThis took lots of trial and error, hope it helps someone else!\n\nIf IDENTITY_TEST is working properly, you should see these cycle in this order (starting from iTime = 0):\n1. red background, black letters\n2. black background, red letters\n3. green background, black letters\n4. black background, green letters\n5. blue background, black letters\n6. black background, blue letters\n\nCubemap coordinates are stored as: vec3(face, u, v)\nThis is just my convention by the way.\n\nFace numbering:\n0: right\n1: left\n2: up\n3: down\n4: front\n5: back\n*/\n\n// Interactive view\n#define VIEW_3D\n\n// Test for identity mapping\n//#define IDENTITY_TEST\n\n// cube2ray() returns a ray direction hitting the cubemap texel at cm\n// This is useful for looking up data stored in the cubemap\nvec3 cube2ray(in vec3 cm) {\n    float sgn = sign(0.5 - mod(cm.x, 2.0));\n    if (cm.x == 0.0 || cm.x == 1.0) return vec3((cm.yz * 2.0 - 1.0) * vec2(-sgn, -1.0), sgn).zyx;\n    if (cm.x == 2.0 || cm.x == 3.0) return vec3((cm.yz * 2.0 - 1.0) * vec2( 1.0,  sgn), sgn).xzy;\n    if (cm.x == 4.0 || cm.x == 5.0) return vec3((cm.yz * 2.0 - 1.0) * vec2( sgn, -1.0), sgn).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #ifdef VIEW_3D\n        vec2 screenCenter = 0.5 * iResolution.xy;\n\n        vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n        vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        vec3 ro = vec3(0.0, 0.0, 5.0);\n        vec3 rd = normalize(vec3(uv, -1.0));\n\n        float cy = cos(mouse.x), sy = sin(mouse.x);\n        float cp = cos(mouse.y), sp = sin(mouse.y);\n\n        // Rotate camera around the origin based on mouse position\n        ro.yz *= mat2(cp, -sp, sp, cp);\n        ro.xz *= mat2(cy, -sy, sy, cy);\n        rd.yz *= mat2(cp, -sp, sp, cp);\n        rd.xz *= mat2(cy, -sy, sy, cy);\n\n        // Coefficients for the quadratic intersection function\n        float a = dot(rd, rd);\n        float b = dot(2.0 * ro, rd);\n        float c = dot(ro, ro) - 2.25;\n\n        // Solve the intersection function\n        float discr = b * b - 4.0 * a * c;\n        if (discr > 0.0) {\n            float t = -(sqrt(discr) + b) / (2.0 * a);\n            vec3 l = vec3(-0.58, 0.58, 0.58); // Light\n            vec3 n = (ro + rd * t) / 1.5; // Normal\n            fragColor.rgb += max(0.0, dot(n, l));\n        }\n\n        else {\n            fragColor = texture(iChannel0, rd);\n        }\n    #endif\n\n    #ifdef IDENTITY_TEST\n    // Test for identity, should render the font texture in reading position cycling through proper colors\n    fragColor = texture(iChannel0, cube2ray(vec3(int(iTime) % 6, fragCoord / iResolution.xy)));\n    #endif\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// For storing data in the cubemap, don't flip the UVs\n// If you are using the cubemap as a skybox (like they were meant to ;)),\n// you probably do want to flip the UVs\n#define FLIP\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef FLIP\n    uv *= -1.0;\n    #endif\n\n    // Sample the texture from the texel's local position on the cubemap face\n    float tex = texture(iChannel0, uv).r;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Change the color based on which face the ray is pointing at\n    vec3 ar = abs(rayDir);\n    if (ar.x >= ar.y && ar.x >= ar.z) fragColor.r = abs(step(0.0, rayDir.x) - tex); // X axis aligned face\n    if (ar.y >= ar.x && ar.y >= ar.z) fragColor.g = abs(step(0.0, rayDir.y) - tex); // Y axis aligned face\n    if (ar.z >= ar.x && ar.z >= ar.y) fragColor.b = abs(step(0.0, rayDir.z) - tex); // Z axis aligned face\n}", "cube_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[629, 759, 786, 786, 1126], [1128, 1128, 1183, 1183, 2684]], "test": "untested"}
{"id": "3ltfRl", "name": "Art Deco Rose", "author": "xavierseb", "description": "Another rose effort for Valentine's day.", "tags": ["geometry", "rose"], "likes": 1, "viewed": 255, "published": 3, "date": "1613260431", "time_retrieved": "2024-07-30T19:38:20.560304", "image_code": "// Art Deco stylized rose\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI2 6.2832\nvec2 pmod(vec2 p, float n) {\n\treturn vec2( length(p)*sin(mod(atan(p.y, p.x), PI2/n) - PI2/n/2.), length(p) );\n}\n\nfloat map(vec3 p, float mx) {\n\tp.xz *= rot(mx*.66-.33);\n\tp.yz *= rot(sin(iTime)/6.);\n\tp.xy = pmod(length(p.xy)<11.1?p.xy:p.xz, 18.0); p.y-=3.;\n\tp.yz = pmod(p.yz, 1.4 + min(.6, iTime/4. )); p.z-=10.;\t\t\n\tvec2 p1 = p.xy = pmod(p.xy, 14.); p.y-=4.;\n\tp.yz = pmod(p.yz,  .5); p.z-=10.2;\t\t\t\n\tp.xy = pmod(p1,   10.); p.y-=2.3;\t\n\tp.yz = pmod(p.yz, 12.); p.z-=9.8;\t\t\t\n\tp.xy = pmod(p.xy, 10.); p.y-=2.3;\n\tp.yz = pmod(p.yz, 12.); p.z-=9.8;\t\t\t\n\treturn dot(abs(p), normalize(vec3(21,3,4))) - .77;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5*iResolution.xy) /iResolution.y, m=iMouse.xy/iResolution.xy;\n\tvec3 rd = normalize(vec3(uv, .25+ min(1.,m.y))), p = vec3(0,0,-15);\n\tfragColor = vec4(0);\n\t\n\tfor (int i=1; i<110; i++) {\n\t\tfloat d = map(p,m.x);\n\t\tif (d < .001) {\n\t\t\tfragColor = vec4(100.*pow(float(i),-1.5),0,0,1);\t\n\t\t\tif (length(p.xy)>9.9) fragColor.r=1.-fragColor.r*2.5; // enhance the rays\n\t\t\telse fragColor.r*=2.;\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 126, 126, 209], [211, 211, 240, 240, 697], [699, 699, 756, 756, 1198]], "test": "untested"}
{"id": "WttBRl", "name": "A Rose is a Rose is a Rose", "author": "xavierseb", "description": "Here's some roses for Valentine's", "tags": ["recursion", "rose"], "likes": 12, "viewed": 597, "published": 3, "date": "1613256109", "time_retrieved": "2024-07-30T19:38:21.522730", "image_code": "// A rose is a rose is a rose -Gertrude Stein\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI2 6.2832\n\nfloat mapLeaf(vec3 p, inout bool isbg) {\t // leaves\n\tp=mod(p+8.,vec3(16.))-8.; p.z-=5.; \n\tp.xy *= rot(PI2/4.);\n\tp.xy =  vec2( length(p.xy)*sin(atan(p.y, p.x)), length(p.xy) ); p.y-=10.;\n\tisbg = true;\n\treturn dot(abs(p), .5*normalize(vec3(1.5,abs(sin(atan(p.x,p.y)*80.)/30.+sin(min(p.y,12.)/8.)),26.))) - .16;  \n}\n\nfloat mapRose(vec3 p, inout bool isbg) { // roses\n\tp=mod(p+vec3(14.,14.,20.),vec3(28.,28.,40.))-vec3(14.,14.,20.); \n\tif(p.z>-11.|| p.z<-33. || length(p.xy)>11.) return mapLeaf(p, isbg);\n\tp.xy *= rot(p.z/.8)/3.5;\n\tp.xy = vec2( length(p.xy)*sin(atan(p.y, p.x)), length(p.xy)-.25 );   \n\tp.xy *= rot(atan(p.y,p.x)); \n\tp.z-=length(p.xy)/16.+2.8;\n\tp.yz = vec2( length(p.yz)*sin(mod(atan(p.z, p.y), PI2/3.) - PI2/3./2.), length(p.yz)-11.6 ); \t\t\t\n\tvec2 p1 = p.xy = vec2( length(p.xy)*sin(mod(atan(p.y, p.x), PI2/90.) - PI2/90./2.), length(p.xy) ); p.y-=8.9;\n\tp.yz *= rot(1.1);\n\tp.xy = vec2( length(p1)*sin(mod(atan(p1.y, p1.x), PI2/2.) - PI2/2./2.), length(p1)-3.5 )*(1.01-p.z)/2.9;\n\tp.z+=length(p.xy)/34.-2.8;\t\t\t\n\tisbg=false;\n\treturn dot(abs(p), normalize(vec3(11,2,4))) - .5;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -.5*iResolution.xy) /iResolution.y, m=iMouse.xy/iResolution.xy; \n\tvec3 rd = normalize(vec3(uv, .25+ min(1.,m.y))), p = vec3(0,0,-30);\n\tfragColor = vec4(0);\n\tbool isbg;\n\tp.xz *= rot(m.x*.5-.25);\tp.yz *= rot(sin(iTime)/12.);\n\t\n\tfor (int i=1; i<270; i++) {\n\t\tfloat d = mapRose(p,isbg);\n\t\tif (d < .001) {\n\t\t\tif(isbg) fragColor = vec4(0,400./float(i*i),0,1);\n\t\t\telse \t fragColor = vec4(40./float(i),0,0,1);\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 159, 170, 431], [433, 433, 473, 482, 1206], [1208, 1208, 1265, 1265, 1726]], "test": "untested"}
{"id": "ttcBRs", "name": "[RGR] Hearts", "author": "deeplo", "description": "falling hearts like tree leaves", "tags": ["hearts"], "likes": 3, "viewed": 563, "published": 3, "date": "1613254894", "time_retrieved": "2024-07-30T19:38:22.572922", "image_code": "#define S smoothstep\n#define HEART_COLOR_F vec3(1.0,.05,0.05)\n#define HEART_COLOR_B vec3(1.0,0.25,0.25)\n#define BG_COLOR vec3(0.5,0.05,0.05)\n#define T (iTime)\n#define NB_HEARTS 50.0\n\nmat2 Rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\n\nfloat smax(float a, float b, float k){\n    float h = clamp((b-a)/k+0.5, 0., 1.);\n    return mix(a, b, h) + h*(1.0-h)*k*0.5;\n}\n\nvec4 Heart(vec2 uv, float radius, float blur){\n    float angle = sin(iTime*0.1)*0.25;    \n    blur *= radius;\n    uv -= vec2(0.0,-radius);\n    uv *= Rot(angle*length(uv)*2.);\n    uv -= vec2(0.0,+radius);\n    uv.x *= 0.7;\n    uv.y -= smax(sqrt(abs(uv.x))*.5, blur, 0.1) -.1 - blur*0.5;\n    float d = length(uv);\n    float c = S(radius+blur,radius-blur-0.01,d);\n    return vec4(vec3(1),c);\n}\n\nvec3 Transform(vec3 p, float a){\n    p.xz *= Rot(a);\n    p.xy *= Rot(a*0.765);\n    return p;\n}\n\nvec4 HeartBall(vec3 ro, vec3 rd, vec3 pos, float radius, float angle, float blur){\n\n    vec4 col = vec4(0);\n    float t  = dot(pos-ro, rd);\n    vec3  p  = ro + rd*t;\n    float y  = length(pos-p);    \n    if (y<1.0){\n        float x = sqrt(1.0-y);\n        vec3 pF = ro + rd*(t-x) - pos;         // front intersection\n        vec3 pB = ro + rd*(t+x) - pos;         // back intersection\n        pF = Transform(pF,angle);\n        pB = Transform(pB,angle);    \n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);\n        vec4 front = Heart(uvF, radius, blur);\n        vec4 back = Heart(uvB, radius, blur);\n        front.xyz *= HEART_COLOR_F;\n        back.xyz  *= HEART_COLOR_B;\n        col = mix(back, front, front.a) ;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    // Mouse vector\n    vec2 M = iMouse.xy/iResolution.xy;\n\n    // output color\n    vec3 bg = BG_COLOR*(uv.y+1.0);\n    vec4 col = vec4(bg,1.0);\n    vec3 ro = vec3(0,0,-4);\n    vec3 rd = normalize(vec3(uv,1));\n    \n    for(float i=0.0; i<1.0 ; i+=1.0/NB_HEARTS){\n        float x = mix(-4.0, 4.0, fract(sin(i*735.25)*457.56));\n        float y = mix(-5.0,5.0,fract(i-T*0.1));\n        float z = mix(3.0, 0.0, i);\n        float radius = S(3.0,0.0,z)*0.3+0.3 ;\n        float angle = T+i*985.989;\n        // blur in the background / Blur in the foreground \n        float blur = S(0.25,0.75,abs(z-1.5))/4.0;\n        vec3 pos = vec3(x,y,z);\n        vec4 heart = HeartBall(ro, rd, pos, radius, angle, blur); \n        //heart.xyz = vec3(abs(1.5-z)/1.5 );\n        col = mix(col, heart, heart.a);\n    }\n\n\n\n    \n\n\n    fragColor = col;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 205, 205, 286], [288, 288, 326, 326, 413], [415, 415, 461, 461, 804], [806, 806, 838, 838, 900], [902, 902, 984, 984, 1682], [1685, 1685, 1742, 1834, 2723]], "test": "untested"}
{"id": "tttBzX", "name": "black hole wud", "author": "dab9090", "description": "lighting test 1", "tags": ["curicle"], "likes": 1, "viewed": 250, "published": 3, "date": "1613250957", "time_retrieved": "2024-07-30T19:38:23.546320", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0. to 1.)\n    vec2 nc = fragCoord/iResolution.xy;\n    \n    nc -= .5;\n    nc.x *= iResolution.x/iResolution.y;\n    \n    float d = -length(nc)+0.5; //black hole effect \n    float c = d;\n    \n    if(d <.3) c += d; else c = 0.;\n    \n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 109, 365]], "test": "untested"}
{"id": "wt3Bzs", "name": "Integration of good white noise", "author": "spawner64", "description": "Temporal integration for the versatile noise created by @kinonik:\n\nhttps://www.shadertoy.com/view/tlcBRl", "tags": ["noise", "template", "float"], "likes": 4, "viewed": 408, "published": 3, "date": "1613249835", "time_retrieved": "2024-07-30T19:38:24.458880", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float c = texture(iChannel0, uv).r;\n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float noise1(float seed1,float seed2);\n\nfloat noise2(float seed1,float seed2);\n\nfloat noise2(float seed1,float seed2,float seed3);\n\nfloat noise3(float seed1,float seed2,float seed3);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float c;\n    //c = noise1(uv.x*100., uv.y*100.); //mini [0,+10k]\n    //c = noise2(uv.x, uv.y, iTime); //medium [-100k,+100k]\n    //c = noise3(uv.x*0.000001, uv.y*0.000001, iTime); //hard [-100k,+100k] high accuracy\n    //c = noise3(uv.x*0.000001, uv.y*0.000001, iTime * 1e-15); // just for fun\n    c = noise3(uv.x*0.000001, uv.y*0.000001, iTime * 1e-6); // just for fun\n    //c = rand(uv+100.); // trash\n    \n    fragColor = vec4(c, c, c, 1.0);\n}\n\n\n//mini\nfloat noise1(float seed1,float seed2){\nreturn(\nfract(seed1+12.34567*\nfract(100.*(abs(seed1*0.91)+seed2+94.68)*\nfract((abs(seed2*0.41)+45.46)*\nfract((abs(seed2)+757.21)*\nfract(seed1*0.0171))))))\n* 1.0038 - 0.00185;\n}\n\n//2 seeds\nfloat noise2(float seed1,float seed2){\nfloat buff1 = abs(seed1+100.94) + 1000.;\nfloat buff2 = abs(seed2+100.73) + 1000.;\nbuff1 = (buff1*fract(buff2*fract(buff1*fract(buff2*0.63))));\nbuff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(seed1*0.79))));\nbuff1 = noise1(buff1, buff2);\nreturn(buff1 * 1.0038 - 0.00185);\n}\n\n//3 seeds\nfloat noise2(float seed1,float seed2,float seed3){\nfloat buff1 = abs(seed1+100.81) + 1000.3;\nfloat buff2 = abs(seed2+100.45) + 1000.2;\nfloat buff3 = abs(noise1(seed1, seed2)+seed3) + 1000.1;\nbuff1 = (buff3*fract(buff2*fract(buff1*fract(buff2*0.146))));\nbuff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(buff3*0.52))));\nbuff1 = noise1(buff1, buff2);\nreturn(buff1);\n}\n\n//3 seeds hard\nfloat noise3(float seed1,float seed2,float seed3){\nfloat buff1 = abs(seed1+100.813) + 1000.314;\nfloat buff2 = abs(seed2+100.453) + 1000.213;\nfloat buff3 = abs(noise1(buff2, buff1)+seed3) + 1000.17;\nbuff1 = (buff3*fract(buff2*fract(buff1*fract(buff2*0.14619))));\nbuff2 = (buff2*fract(buff2*fract(buff1+buff2*fract(buff3*0.5215))));\nbuff1 = noise2(noise1(seed2,buff1), noise1(seed1,buff2), noise1(seed3,buff3));\nreturn(buff1);\n}", "buffer_a_inputs": [], "buffer_b_code": "// EMA IIR filter #1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float c = texture(iChannel0, uv).r;\n    float h = texture(iChannel1, uv).r;\n    float t = sin(iTime) * 0.5 + 0.5;\n    t *= 0.99;\n    c = mix(c, h, t);\n    c = clamp(c, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// EMA IIR filter #2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float c = texture(iChannel0, uv).r;\n    float h = texture(iChannel1, uv).r;\n    float t = sin(iTime) * 0.5 + 0.5;\n    t *= 0.99;\n    c = mix(c, h, t);\n    c = clamp(c, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// EMA IIR filter #3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float c = texture(iChannel0, uv).r;\n    float h = texture(iChannel1, uv).r;\n    float t = sin(iTime) * 0.5 + 0.5;\n    t *= 0.99;\n    c = mix(c, h, t);\n    c = clamp(c, 0.0, 1.0);\n\n    fragColor = vec4(c, c, c, 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3Bzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 180]], "test": "untested"}
{"id": "ttcfRs", "name": "N-Focal Ellipse DE", "author": "oneshade", "description": "Distance estimate to n-focal ellipse.", "tags": ["distance", "de", "ellipse", "bound", "nfocalellipse", "foci"], "likes": 4, "viewed": 141, "published": 3, "date": "1613248714", "time_retrieved": "2024-07-30T19:38:25.220843", "image_code": "#define FOCI 10\n\n// Not exact (but it tries to be)\nfloat sdNFocalEllipse(in vec2 p, in vec2[FOCI] foci, in float e) {\n    vec2 g = vec2(0.0);\n    float d = length(p - foci[0]);\n    for (int fp=1; fp < foci.length(); fp++) {\n        vec2 tf = p - foci[fp];\n        float l = length(tf);\n        g += tf / l;\n        d += l;\n    }\n\n    return (d - e) / length(g);\n}\n\nfloat Hash11(in float x) {\n    return fract(593.594 * cos(x * 695.395));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    float fd = 1000000.0;\n    vec2[FOCI] foci;\n    for (int fp=0; fp < FOCI; fp++) {\n        float id = float(fp);\n        float o11 = Hash11(id * 594.394 + 284.958) + 0.5;\n        float o21 = Hash11(id * 264.596 + 476.694) + 0.5;\n        float o12 = Hash11(id * 395.472 + 395.483) + 0.5;\n        float o22 = Hash11(id * 953.385 + 395.584) + 0.5;\n        float s1 = Hash11(id * 294.495 + 284.585) + 0.5;\n        float s2 = Hash11(id * 848.384 + 385.485) + 0.5;\n\n        vec2 scale = vec2(0.25 * (iResolution.x / iResolution.y), 0.25);\n        foci[fp] = vec2(cos(time * o11 + o21) * s1, sin(time * o12 + o22) * s2) * scale;\n        fd = min(fd, length(uv - foci[fp]) - 0.02);\n    }\n\n    float d = sdNFocalEllipse(uv, foci, 4.5);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(mix(color, vec3(0.25, 0.25, 1.0), smoothstep(unit, 0.0, fd)), 1.0);\n    fragColor -= smoothstep(unit * 0.75, 0.0, abs(fd));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 391, 391, 439]], "test": "untested"}
{"id": "tlcBzl", "name": "Abs(vec3) bug on my Nvidia GPU", "author": "public_int_i", "description": "Abs(vec3) not working???? This should display a volumetric cube, on my system it displays a tower(due to negative y).", "tags": ["working", "not", "abs", "vec3"], "likes": 6, "viewed": 390, "published": 3, "date": "1613240307", "time_retrieved": "2024-07-30T19:38:26.116449", "image_code": "/*Correct result: https://i.imgur.com/LPINgi4.png\nIncorrect result: https://i.imgur.com/2A0D9GR.png\n\nThis should display a volumetric cube when abs() functions properly.\nInstead on my system(Win10, Nvidia GTX 980) it displays a tower,\nbecause y axis stays signed for some reason. It's not just WebGL this shader is broken\nfor me on desktop OpenGL as well and when I disable ANGLE.\n\nThis can be fixed by manually doing abs() with rp*sign(rp), but it's absolutely\ncrazy to me that abs() doesn't work here. Testing a bit more if you just output\nrp.y by doing\n\no = vec4(rp.y);\nreturn;\n\nit shows a proper mirrored gradient, meaning rp.y as being unsigned and\nabs() functioning correctly! Something about the box distance function\ncauses the compiler or GPU to remove the Y axis part of abs?\n\nMore testing I found that abs(rp*vec3(1,1.00001,1)) fixes it as well, I\nam confuse.\n*/\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n    o = vec4(0);\n    vec3 rd = normalize(vec3((u*2.-iResolution.xy)/iResolution.y,1));\n    for (float q = .1; q < 4.; q += .1) {\n        vec3 rp = rd*q;\n        rp.z -= 2.;\n        float a = iTime;\n        rp.xz *= mat2(cos(a),-sin(a),sin(a),cos(a));\n        \n        \n        //broken for me? y axis stays signed and creates tower instead of box??????\n        rp = abs(rp);\n        \n        //manual abs, works properly\n        //rp = rp*sign(rp);\n        \n        //mutliplying y by a small amount forces it to work properly\n        //rp = abs(rp*vec3(1,1.001,1));\n        \n        \n        //output rp.y, its signed if the bottom half of the screen is black\n        //o = vec4(rp.y*10.);\n        //return;\n        \n        \n        //box unsigned distance function\n        float s = length(max(rp-vec3(.5),0.));\n        \n        \n        //volume accumulation\n        o += vec4(max(0.,1.-s*10.)*.1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[875, 875, 915, 915, 1826]], "test": "untested"}
{"id": "tt3fRX", "name": "Temporal EMA IIR Denoising", "author": "spawner64", "description": "Chain of Exponential Moving Average Infinite Impulse Response filters applied temporally to clean a noisy input. A chain of filters is used to achieve a steeper low-pass filtering slope. Variance Clipping is used to fight the inherent temporal ghosting.", "tags": ["noise", "filter", "denoise", "iir", "temporal", "varianceclipping", "ema"], "likes": 12, "viewed": 913, "published": 3, "date": "1613238917", "time_retrieved": "2024-07-30T19:38:27.077877", "image_code": "// Temporal EMA IIR Denoising\n//\n// EMA IIR?\n//\n// Exponential Moving Average (EMA) Infinite Impulse Response (IIR) filter:\n// - Poor man's low-pass filter.\n// - A fancy name for the well-known \"damping\" filter.\n// - Not possesing the best frequency filtering (not steep, not well behaved).\n// - Ideally would use a Butterworth filter instead, but requires 2 additional buffers just for the first order.\n//\n// More about EMA IIR: https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n//\n// Goal:\n// - Removing noise from a noisy input.\n//\n// Contraints:\n// - The noise must be pattern-free (the noise from stochastic processes is good).\n//\n// Strategy:\n// - Take the input signal and apply a temporal low-pass filter (in our case, the trivial EMA IIR filter).\n// - Simply applying a temporal filter does remove some noise, but also causes temporal artifacts like ghosting.\n// - Apply Variance Clipping to reject the samples that should not contribute to current sample.\n// - This entire process is used in many temmporal anti-aliasing solutions, but in our case we apply it without\n//   the luxury of knowing the motion vectors of last frame. Knowing the motion vectors is valuable because they\n//   can be used to reproject the history buffer and achieve sharper results.\n//\n// Use more EMA IIR VC filters in a chain to improve the frequency response of the EMA IIR. In our case we use 3\n// filters, which is comparable in frequency response roll-off with a first order Butterworth filter.\n//\n// NOTE: Although it's true that the process produces a result that lost some sharpness compared with the input\n// signal, beware what adding noise to a signal increases its perceived sharpness (left column seems sharper than\n// the original signal (right column)).\n//\n// Feel free to play with different values in the Common section to achieve different results.\n\n// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 col = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    if (normalizedSpaceUV.x <= V_SPLIT_A) {\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n\n    if (normalizedSpaceUV.x > V_SPLIT_B) {\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n\n    fragColor = vec4(col, 1.0);\n\n    fragColor = renderVSplitLine(fragColor, SPLIT_LINE_COLOR, 2.0, screenSpaceUV, V_SPLIT_A * iResolution.x);\n    fragColor = renderVSplitLine(fragColor, SPLIT_LINE_COLOR, 2.0, screenSpaceUV, V_SPLIT_B * iResolution.x);\n}\n\n// ------------------------------------------------------------------------- //", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ------------------------------------------------------------------------- //\n\n// CONFIG\n\n#define NOISE_INTENSITY                         (0.2)        // 0.0 - no noise, 1.0 - 0.5 radius noise \n#define EMA_IIR_INVERSE_CUTOFF_FREQUENCY        (0.852)      // 0.0 - 0.999\n#define VARIANCE_CLIPPING_COLOR_BOX_SIGMA       (0.975)      // 0.5 - 1.0\n#define APPLY_VARIANCE_CLIPPING_FIRST           (__ON__)\n#define SPLIT_LINE_COLOR                        (vec3(0))\n#define SPLIT_LINE_THICKNESS                    (2.0)        // in pixels\n\n// ------------------------------------------------------------------------- //\n\n#define SAMPLE_RGBA(sampler, coord) (texture((sampler), (coord)))\n#define SAMPLE_RGB(sampler, coord) (SAMPLE_RGBA((sampler), (coord)).rgb)\n\n// ------------------------------------------------------------------------- //\n\n#define __OFF__ (0)\n#define __ON__  (1)\n\n// ------------------------------------------------------------------------- //\n\n#define V_SPLIT_A (0.333)\n#define V_SPLIT_B (0.666)\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/4dSBDt\n\nvec3 RGBToYCoCg(vec3 RGB) {\n    float cTerm = 0.5 * 256.0 / 255.0;\n\tfloat Y  = dot(RGB, vec3( 1, 2,  1)) * 0.25;\n\tfloat Co = dot(RGB, vec3( 2, 0, -2)) * 0.25 + cTerm;\n\tfloat Cg = dot(RGB, vec3(-1, 2, -1)) * 0.25 + cTerm;\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg) {\n\tfloat cTerm = 0.5 * 256.0 / 255.0;\n\tfloat Y  = YCoCg.x;\n\tfloat Co = YCoCg.y - cTerm;\n\tfloat Cg = YCoCg.z - cTerm;\n\tfloat R  = Y + Co - Cg;\n\tfloat G  = Y + Cg;\n\tfloat B  = Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\n// ------------------------------------------------------------------------- //\n\n// based on https://www.shadertoy.com/view/4dSBDt\nvoid getVarianceClippingBounds(vec3 color, sampler2D colorSampler, ivec2 screenSpaceUV, float colorBoxSigma, out vec3 colorMin, out vec3 colorMax) {\n    vec3 colorAvg = color;\n    vec3 colorVar = color * color;\n\n    // Marco Salvi's Implementation (by Chris Wyman)\n    // unrolled loop version\n    \n    vec3 fetch = vec3(0);\n\n    // unwinded the for loop\n    {\n        // top\n        {\n            // left / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // center / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 0, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // right / top\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1, -1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n\n        // center\n        {\n            // left / center\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1,  0), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            \n            // center / center is intentionally skipped\n            \n\n            // right / center\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1,  0), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n\n        // bottom\n        {\n            // left / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2(-1,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // center / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 0,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n\n            // right / bottom\n            fetch = texelFetch(colorSampler, screenSpaceUV + ivec2( 1,  1), 0).rgb;\n            fetch = RGBToYCoCg(fetch);\n            colorAvg += fetch;\n            colorVar += fetch * fetch;\n        }\n    }\n\n    colorAvg *= 0.111111111;\n    colorVar *= 0.111111111;\n\n    vec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg * colorAvg));\n\tcolorMin = colorAvg - colorBoxSigma * sigma;\n\tcolorMax = colorAvg + colorBoxSigma * sigma;\n}\n\n// ------------------------------------------------------------------------- //\n\nvec4 renderVSplitLine(vec4 fragColor, vec3 lineColor, float lineThickness, vec2 screenSpaceUV, float splitScreenSpaceX) {\n    if (abs(screenSpaceUV.x - splitScreenSpaceX) < lineThickness) {\n        fragColor.rgb = lineColor;\n\t}\n\n    return fragColor;\n}\n\n// ------------------------------------------------------------------------- //", "buffer_a_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 col = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    if (normalizedSpaceUV.x > V_SPLIT_B) {\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n\n    vec3 noise = hash33(vec3(screenSpaceUV, iTime * 13.74232341));\n    noise *= 2.0;\n    noise -= 1.0;\n    noise *= NOISE_INTENSITY;\n    col += noise;\n\n    fragColor = vec4(col, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    if (normalizedSpaceUV.x <= V_SPLIT_A) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    if (normalizedSpaceUV.x > V_SPLIT_B) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n#if APPLY_VARIANCE_CLIPPING_FIRST\n    // apply Variance Clipping before applying EMA IIR filtering\n    history = clamp(history, colorMin, colorMax);\n\n    // apply EMA IIR filtering after Variance Clipping\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n#else\n    // apply EMA IIR filtering before Variance Clipping\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n\n    // apply Variance Clipping after applying EMA IIR filtering\n    filtered = clamp(filtered, colorMin, colorMax);\n#endif\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    if (normalizedSpaceUV.x <= V_SPLIT_A) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    if (normalizedSpaceUV.x > V_SPLIT_B) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n#if APPLY_VARIANCE_CLIPPING_FIRST\n    // apply Variance Clipping before applying EMA IIR filtering\n    history = clamp(history, colorMin, colorMax);\n\n    // apply EMA IIR filtering after Variance Clipping\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n#else\n    // apply EMA IIR filtering before Variance Clipping\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n\n    // apply Variance Clipping after applying EMA IIR filtering\n    filtered = clamp(filtered, colorMin, colorMax);\n#endif\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec3 new = SAMPLE_RGB(iChannel0, normalizedSpaceUV);\n\n    if (normalizedSpaceUV.x <= V_SPLIT_A) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    if (normalizedSpaceUV.x > V_SPLIT_B) {\n        fragColor = vec4(new, 1.0);\n        return;\n    }\n\n    new = RGBToYCoCg(new);\n\n    vec3 colorMin = vec3(0);\n\tvec3 colorMax = vec3(0);\n    getVarianceClippingBounds(new, iChannel0, ivec2(screenSpaceUV), VARIANCE_CLIPPING_COLOR_BOX_SIGMA, colorMin, colorMax);\n\n    vec3 history = SAMPLE_RGB(iChannel1, normalizedSpaceUV);\n    history = RGBToYCoCg(history);\n\n    vec3 filtered = vec3(0);\n#if APPLY_VARIANCE_CLIPPING_FIRST\n    // apply Variance Clipping before applying EMA IIR filtering\n    history = clamp(history, colorMin, colorMax);\n\n    // apply EMA IIR filtering after Variance Clipping\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n#else\n    // apply EMA IIR filtering before Variance Clipping\n    filtered = mix(new, history, EMA_IIR_INVERSE_CUTOFF_FREQUENCY);\n\n    // apply Variance Clipping after applying EMA IIR filtering\n    filtered = clamp(filtered, colorMin, colorMax);\n#endif\n    filtered = YCoCgToRGB(filtered);\n\n    fragColor = vec4(filtered, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1958, 1958, 2013, 2013, 2631]], "test": "untested"}
{"id": "tt3BRl", "name": "What's in the sound texture?", "author": "morisil", "description": "I've been always wondering how to best visualize the basic quality of sound data provided by shadertoy. ", "tags": ["sound", "visualization", "audio"], "likes": 4, "viewed": 443, "published": 3, "date": "1613234636", "time_retrieved": "2024-07-30T19:38:27.878736", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 soundUv = vec2(\n        uv.x,\n        uv.y < .5 ? .25 : .75\n    );\n    float sound = texture(iChannel0, soundUv).r;\n    float signalY = mod(uv.y, .5) * 2.;\n    float signal = step(signalY, sound);\n    vec3 color = TurboColormap(sound) * signal;\n    fragColor = vec4(\n        color,\n        1.0\n    );\n}\n", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float saturate (float x)\n{\n  return min(1.0, max(0.0, x));\n}\n\n// Copyright 2019 Google LLC.\n// SPDX-License-Identifier: Apache-2.0\n\n// Polynomial approximation in GLSL for the Turbo colormap\n// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n\n// Authors:\n//   Colormap Design: Anton Mikhailov (mikhailov@google.com)\n//   GLSL Approximation: Ruofei Du (ruofei@google.com)\n\nvec3 TurboColormap(in float x) {\n  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n\n  x = saturate(x);\n  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n  vec2 v2 = v4.zw * v4.z;\n  return vec3(\n  dot(v4, kRedVec4)   + dot(v2, kRedVec2),\n  dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n  dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)\n  );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 411]], "test": "untested"}
{"id": "3t3Bzs", "name": "The Lost Self", "author": "YitingLiu", "description": "a sense of self-lost in the gyroid shape. ", "tags": ["raymarching", "template", "artofcode"], "likes": 4, "viewed": 319, "published": 3, "date": "1613226340", "time_retrieved": "2024-07-30T19:38:28.721483", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p,float scale, float thickness, float bias){\n    p*=scale;\n    \n    // can also play with the p and p.zxy by adding some numbers \n    // scale needs to add the largest multiplers in either p or p.zxy \n    // return abs(dot(sin(p*2.),cos(p.zxy*1.23))-bias)/(scale*2.)-thickness;\n\n    return abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;\n    \n    }\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    \n    // wanting something organic? the scales for two should not be multiplicable by each other (ex.: can't be 4 and 8)\n    float g1 = sdGyroid(p,5.,.02,1.5);\n    float g2 = sdGyroid(p+vec3(1.),8.85,.02,2.);\n    float g3 = sdGyroid(p+vec3(2.),15.85,.03,0.32);\n    float g4 = sdGyroid(p+vec3(3.),28.85,.04,1.2);\n    float g5 = sdGyroid(p+vec3(3.),34.20,.05,1.3);\n    \n    //float g = max(g1,g2);//union \n  //float g = max(g1,-g2);//subtraction \n    \n    g1-=g2*.3;//bump mapper \n    g1-=g3*.2;//bump mapper \n    g1+=g4*.1;//bump mapper \n    \n    //float d=max(box,g1*.8);// intersect the box \n   \t\n    float d = g1*.8;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    float fft  = texture( iChannel0, vec2(uv.x-1.)).x; \n\t\n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x-1.,0.1) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 soundEl = vec3(fft,0.5*fft*(1.0-fft),fft );// * fft;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -3)*S(-.01,0.01,fft)*0.5;\n    ro.yz *= Rot(abs(sin(iTime*.2))*S(-.01,0.028,fft)*3.14+1.);\n    ro.xz *= Rot(cos(iTime*.5*S(-.01,0.01,fft))*6.2831);\n    \n    // mouse controls 3d \n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    //zoom factor \n    vec3 rd = GetRayDir(uv, ro, vec3(0),2.*sin(iTime*0.5*S(-0.01,0.1,fft)));// S(0.,0.2,fft)*5.\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol+=n*.5+.5;// 0 <> 1 \n        col -= dif*soundEl;  \n    \n        //ambient occulusion - cheaper \n    float g2 = sdGyroid(p+vec3(1.),8.85,.02,2.);\n        col*=S(-.1,.1,g2)-soundEl;\n\n    }\n    \n   // col*=0.;// for 2d\n    d = sdGyroid(vec3(uv.x,uv.y,iTime*.1),10.,.02,.3);\n   //col+=d*.8; // for 2d \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25418, "src": "https://soundcloud.com/yitingliu/you", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3Bzs.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1580, 1580, 1674], [1676, 1676, 1705, 1705, 1786], [1788, 1788, 1852, 1852, 2158], [2160, 2160, 2183, 2183, 2856], [2858, 2858, 2892, 2892, 3103], [3105, 3105, 3129, 3129, 3319], [3321, 3321, 3371, 3371, 3562], [3566, 3566, 3623, 3623, 4975]], "test": "untested"}
{"id": "tlcfRX", "name": "Simple Fireworks", "author": "moranzcw", "description": "Fireworks.", "tags": ["2d", "random", "fireworks"], "likes": 4, "viewed": 480, "published": 3, "date": "1613219973", "time_retrieved": "2024-07-30T19:38:29.864427", "image_code": "// Simple Fireworks - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define Gravitational_ACCE vec2(0, -0.2)\n#define NumSpark 30.0\n#define NumFirework 5.0\n#define Period 5.0\n\nfloat rand(float co)\n{ \n    return fract(sin(co*(91.3458)) * 47453.5453);\n}\n\n\nvec3 spark(vec2 coord, vec2 origin, vec3 sparkColor, vec2 velocity, float periodTime, float seed)\n{\n    vec2 displacement = velocity * periodTime + 0.5 * Gravitational_ACCE * periodTime * periodTime;\n    vec2 sparkPos = origin + displacement;\n    float len = length(coord - sparkPos);\n    \n    // glow color\n    vec3 color = sparkColor * pow(smoothstep(0.05, 0.001, len),8.0);\n    // core color\n    color += vec3(1.0) * smoothstep(0.005, 0.001, len);\n    // attenuation\n    color *= smoothstep(Period, 0.0, periodTime);\n    // twinkle\n    color *= sin(periodTime*50.0 + seed)*0.4 + 0.6;\n    return color;\n}\n\nvec3 firework(vec2 coord, float currentPeriod, float periodTime)\n{   \n    vec2 origin;\n    origin.x = (0.2 + 0.6*rand(currentPeriod)) * iResolution.x/iResolution.y ;\n    origin.y = (0.4 + 0.4*rand(currentPeriod));\n\n    vec3 color = vec3(0.0);\n    for(float i=0.0; i < NumSpark; i++) \n    {\n        vec2 velocity;\n        velocity.x = 0.5*(rand(currentPeriod+i*0.4)-0.5);\n        velocity.y = 0.5*(rand(currentPeriod+i*0.5)-0.5);\n        velocity = normalize(velocity);\n        velocity *= 0.2 + rand(currentPeriod+i*0.6) * 0.3;\n        \n        vec3 sparkColor;\n        sparkColor.r = 0.3+0.7*rand(currentPeriod+i*0.1);\n        sparkColor.g = 0.3+0.7*rand(currentPeriod+i*0.2);\n        sparkColor.b = 0.3+0.7*rand(currentPeriod+i*0.3);\n        color += spark(coord, origin, sparkColor, velocity, periodTime, i);\n    }\n    return color;\n}\n\nvec3 background(float yCoord) \n{\t    \n    return mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), yCoord);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord/iResolution.y;\n\n    vec3 color = vec3(0.0f);\n    for(float i=0.0; i < NumFirework; i++)\n    {\n        float timeOffset = Period / NumFirework * (0.5 + rand(i));\n        float time = iTime + i*timeOffset;\n        float periodTime = mod(time,Period);\n        \n        float periodOffset = i*10.0; // for random\n        float currentPeriod = floor(time/Period + periodOffset);\n        \n        color += firework(coord, currentPeriod, periodTime);\n    }\n    color = background(coord.y)+color;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfRX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[266, 266, 288, 288, 341], [344, 344, 443, 443, 950], [952, 952, 1018, 1018, 1789], [1791, 1791, 1823, 1823, 1914], [1917, 1917, 1974, 1974, 2525]], "test": "untested"}
{"id": "WtcBzl", "name": "[OMZG] Shader Royale - 福", "author": "totetmatt", "description": "Version at the end of the Shader Royale, not my favourite version to be honnest. Will create a new version later that go back to the point where I was liking it.", "tags": ["shaderroyale"], "likes": 7, "viewed": 360, "published": 3, "date": "1613215870", "time_retrieved": "2024-07-30T19:38:30.716150", "image_code": "\n\n\nfloat bbox(vec2 uv, vec2 a, vec2 b, float t){\n    float l = length(b-a);\n    vec2 d = (b-a)/l;\n    vec2 q = uv - (a+b)*.5;\n  \n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    float tt = max(texture(iChannel0,vec2(abs(q.x+q.y*20.)*.01)).r*.02,.001);\n    q = abs(q) - vec2(l+(t/tt)*.0001,t-tt)*.5;\n    return length(max(q,vec2(0.))) + min(max(q.x,q.y),0.);\n  }\n  \n  \n  float left_fu(vec2 uv){\n   float h =  bbox(uv,vec2(-.1,-.2), vec2(-.1,.1),.01);\n    \n    float t = bbox(uv,vec2(-.2,.2), vec2(.0,.2),.01);\n    h = min(t,h);\n    \n     t = bbox(uv,vec2(.0,.2), vec2(-.2,.1),.01);\n    h = min(t,h);\n    \n     t = bbox(uv,vec2(-.05,.1), vec2(.01,.05),.01);\n    h = min(t,h);\n    \n      t = bbox(uv,vec2(-.15,.30), vec2(-.10,.25),.01);\n    h = min(t,h);\n    return h;\n    }\n       \n  float right_fu(vec2 uv){\n     float h =  bbox(uv,vec2(.35,.25), vec2(.05,.25),.01);\n    \n      float t = abs(bbox(uv,vec2(.3,.13), vec2(.1,.13),.1))-.01;\n      h = min(t,h);\n\n    \n     uv +=vec2(.05,.0);\n      t = bbox(uv,vec2(.25,.00), vec2(.25,-.20),.01);\n      h = min(t,h);\n    uv *=.5;\n   \n    t = abs(bbox(uv,vec2(.2,-.05), vec2(.05,-.05),.1))-.001;\n      h = min(t,h);\n    \n     t = bbox(uv,vec2(.2,-.05), vec2(.05,-.05),.001);\n      h = min(t,h);\n    return h;\n    \n  }\n  float fu(vec2 uv){\n    float h =  left_fu(uv);\n    float r = right_fu(uv);\n    h = min(h,r);\n    \n    \n    return h ;\n      \n    }\n    \nvec3 pal(float t){\n\n    return vec3(.5)+.5*cos(2.*3.141592*(1.*t+vec3(.0,.3,.7)));\n  }\n  \n  \n float mandel(vec2 uv){\n     float tt = texture(iChannel0,vec2(.3)).r*.1;\n      vec2 c = vec2(.41-tt,.42+tt);\n      vec2 z = uv;\n      float limit = 200.;\n      float cpt =  0.;\n   \n   for(float i = 0.;i<=limit; i++){\n   \n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+c;\n        if(length(z) >2.) break;\n        cpt ++;\n     \n     }\n     \n     return cpt /limit;\n   }\n   #define fGlobalTime iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float t1 = texture(iChannel0,vec2(.3)).r*.01;\n \n  float t2 = texture(iChannel0,vec2(.7)).r*.01;\n  uv *=(fract(-fGlobalTime*.5+length(uv)));\n  uv *=2.;\n  uv.x +=fract(fGlobalTime+t1*.1);\n   uv.y += sin(fGlobalTime)+t2*10.;\n  vec2 id = floor(uv);\n  uv = fract(uv)-.5;\n float d = fu(uv);\n   float mandal = mandel(abs(uv)+.1);\n  d = abs(.01/(d));\n  if(mod(id.x,2.) ==0.){\n     d = 1.-d;\n  }\n  vec3 col = vec3(d)*pal(mandal*10.+d*.001+fract(fGlobalTime)+uv.x);\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 25415, "src": "https://soundcloud.com/h0ffman/hoffman-ziphead", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 48, 48, 350], [359, 359, 382, 382, 760], [771, 771, 795, 795, 1248], [1251, 1251, 1269, 1269, 1381], [1387, 1387, 1405, 1405, 1473], [1481, 1481, 1503, 1503, 1846], [1876, 1876, 1933, 1983, 2567]], "test": "untested"}
{"id": "Wl3Bzl", "name": "Day 423", "author": "jeyko", "description": "potate", "tags": ["mdtmjvm"], "likes": 11, "viewed": 380, "published": 3, "date": "1613214938", "time_retrieved": "2024-07-30T19:38:31.486091", "image_code": "\n\n// 2d slices of a 3d cube lattice as learned from blackle! \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    //fragColor.xyz = floor(fragColor.xyz*50.)/50.;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.2,1));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.));\n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    //fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.;\n    \n    //fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nfloat cnt = 0.;\nvoid get(vec3 p, inout vec3 col, vec2 uv, bool reverse){\n    \n    \n    if(reverse){\n        p.yz *= rot(0.8 );\n        p.yx *= rot(0.4  );\n\n        p.zx *= rot(-0.4 - iTime*0.);\n    \n    }\n    \n    float df = fwidth(p.x);\n    float md = 0.35;\n    \n    vec3 id = floor(p/md + 0.);\n    \n    \n    p = pmod(p,md);\n    \n    vec3 triCol = pal(0.5,0.5*vec3(1.,0.1,0.5),vec3(1,5. + 20.*id.y + iTime + uv.x*2. + length(p)*4.,3),2.,id.x*5. + uv.x*1. + iTime);\n    \n    //triCol = mix(triCol,vec3(1),smoothstep(0.,4.,cnt));\n    \n    \n    {    \n        //col = mix(col,vec3(0.9),smoothstep(df,0.,abs(max(p.x,max(p.y,p.z)) - md*0.45) - md*0.01 ));\n    }\n    float env = 0.;\n    \n    if(reverse){\n        env = (sin(fract(sin(id.x*4. + id.y*id.z*20.)*40.)*20. + id.y*10. + iTime*0.4*sin(id.x*20. + sin(id.z*20.)*20.)));\n        \n    } else {\n        env = pow(sin(fract(sin(id.x*4. + id.y*id.z*20.)*40.)*20. + id.y*10. + iTime*0.8*sin(id.x*20. + sin(id.z*20.)*20.)),5.);\n    \n    }\n    \n    p = abs(p);\n    \n    if(sin(id.x + fract(sin(id.z)*10.)*200.) < 1.){\n        float d = length(p) - 0.1*env;\n        //d = abs(d);\n        if(reverse){\n            float d = (length(p)) - 0.4*md*env;\n       \n            d = abs(d);\n            d -= 0.01;\n            \n            d/= df;\n            \n            vec3 nc = 2.-col;\n            \n            nc.xz *= rot(0. - sin(id.x + id.y*10. + sin(id.z))*0.7);\n            col = mix(col,nc,smoothstep(1.,0.,d));\n            //col -= col;\n        } else {\n            col = mix(col,triCol,smoothstep(df,0.,d));\n        \n        }\n        \n        //col = mix(col,triCol,smoothstep(df,0.,abs((p).x)));\n\n    }\n    cnt ++;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float vn = valueNoiseStepped(iTime*0.25,2.,2.);\n    float vnb = valueNoiseStepped(iTime*0.125,4.,2.);\n    vnb = pow(vnb,82.);\n    \n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv -= 0.5;\n    vec3 col = vec3(1,1.4,1.)*1.;\n    uv += vec2(muv.x,muv.y);\n    \n    uv *= rot(0.7);\n    uv.y += iTime*0.1;\n    \n    \n    \n    vec3 p = vec3(uv,1);\n    \n    p.yz *= rot(0.4 );\n    p.yx *= rot(0.7  );\n    \n    p.zx *= rot(-0.4 - iTime*0.);\n    \n    \n    //get(p*17.*2., col, uv);\n    \n    vec3 scrobble = vec3(0,1.,1)*(iTime*1. + vn*10.);\n    \n    //get(p*1. + scrobble*0.0, col, uv, true);\n    \n    get(p*18. + scrobble*0.2, col, uv, false);\n    \n    get(p*27. + scrobble*0.05, col, uv, false);\n    \n    get(p*6. + scrobble*0.21, col, uv, false);\n    get(p*1. + scrobble*0.2, col, uv, false);\n    get(p*1.5+ scrobble*0.1, col, uv, true);\n    get(p*4.5+ scrobble*0.1, col, uv, true);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0. ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3Bzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 120, 120, 1039]], "test": "untested"}
{"id": "3tcBRl", "name": "Slicing a 4d mengersponge", "author": "mrange", "description": "License CC0: Slicing a 4d mengersponge\nTBH; I don't know if the generalization I made of mengersponge to 4D is valid but it looks weird and that's the only quality I need.", "tags": ["raymarch", "sponge"], "likes": 11, "viewed": 415, "published": 3, "date": "1613205293", "time_retrieved": "2024-07-30T19:38:32.253041", "image_code": "// License CC0: Slicing a 4d mengersponge\n// TBH; I don't know if the generalization I made of mengersponge to 4D is valid \n//  but it looks weird and that's the only quality I need.\n// Based of https://www.shadertoy.com/view/4sX3Rn\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  8.0\n#define MAX_RAY_MARCHES 100\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvoid rot(inout vec2 v, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  v.xy = vec2(v.x*c + v.y*s, -v.x*s + v.y*c);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec4 p, vec4 b) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(max(q.x, q.w),max(q.y,q.z)),0.0);\n}\n\n\nfloat mengerSponge(vec4 p) {\n  float db = box(p, vec4(1.0));\n  if(db > .125) return db;\n    \n  float d_ = db;\n  float res = d_;\n\n  float s = 1.0;\n  for(int m = 0; m < 5; ++m) {\n    float ss = 0.75;\n    vec4 a = mod(p*s, 2.0)-1.0;\n    s *= 3.0;\n    vec4 r = abs(1.0 - 3.0*abs(a));\n\n    float da = max(max(r.x,r.y),r.w);\n    float db = max(max(r.y,r.z),r.w);\n    float dc = max(max(r.z,r.x),r.w);\n    float dd = max(max(r.z,r.x),r.y);\n    float df = length(r)-2.16;\n\n    float du = da;\n    du = min(du, db);\n    du = min(du, dc);\n    du = pmin(du, dd, ss); // Soften the edges a bit\n    du = max(du, -df);\n    du -= 1.0;\n    du /= s;\n\n    res = max(res, du);\n  }\n\n  return res;\n}\n\n\nfloat df(in vec3 p) {\n  const float s = 1.0/3.0;\n  p -= vec3(0.0, 1.0, 0.0);\n  p /= s;\n  float a = 0.02*pmax(iTime-5.0, 0.0, 5.0);\n  vec4 pp = vec4(p, 0.5*cos(a*sqrt(2.0)));\n  rot(pp.xw, a);\n  rot(pp.yw, a*sqrt(0.5));\n  rot(pp.zw, a*sqrt(0.3));\n  float dm = mengerSponge(pp);\n  \n  float d = dm;\n  return d*s;\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float distance = df(ro + rd*t);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.0005,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float distance = df(pos + ld*t);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, distance);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec3 lightPos = 2.0*vec3(1.5, 3.0, 1.0);\n\n  // background color\n  vec3 skyCol = vec3(0.0);\n\n  int iter = 0;\n  float t = rayMarch(ro, rd, iter);\n\n  float ifade = 1.0-tanh_approx(3.0*float(iter)/float(MAX_RAY_MARCHES));\n\n  vec3 pos = ro + t*rd;    \n  vec3 nor = vec3(0.0, 1.0, 0.0);\n  \n  vec3 color = vec3(0.0);\n  \n  if (t < MAX_RAY_LENGTH && pos.y > 0.0) {\n    // Ray intersected object\n    nor     = normal(pos);\n    vec3 hsv   = (vec3(-0.2+0.25*t, 1.0-ifade, 1.0));\n    color = hsv2rgb(hsv);\n  } else if (pos.y > 0.0) {\n    // Ray intersected sky\n    return skyCol*ifade;\n  } else {\n    // Ray intersected plane\n    t   = -ro.y/rd.y;\n    pos = ro + t*rd;\n    nor = vec3(0.0, 1.0, 0.0);\n    vec2 pp = pos.xz*1.5;\n    float m = 0.5+0.25*(sin(3.0*pp.x+iTime*2.1)+sin(3.3*pp.y+iTime*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.025);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(100.0, 10.0, m)*dp), 1.0);\n    color = 5.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n  }\n\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll, 0.01, 64.0);\n\n  float dm  = min(1.0, 40.0/ll2);\n  float dif = max(dot(nor,ld),0.0)*dm;\n  float spe = pow(max(dot(reflect(-ld, nor), -rd), 0.), 10.);\n  float l   = dif*sha;\n\n  float lin = mix(0.2, 1.0, l);\n\n  vec3 col = lin*color + spe*sha;\n\n  float f = exp(-20.0*(max(t-3.0, 0.0) / MAX_RAY_LENGTH));\n    \n  return mix(skyCol, col , f)*ifade;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q=fragCoord.xy/iResolution.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  // camera\n  vec3 ro = .4*vec3(2.0, 0, 0.2)+vec3(0.0, 1.25, 0.0);\n  rot(ro.xz, sin(iTime*0.1));\n  rot(ro.yz, sin(iTime*0.1*sqrt(0.5))*0.25);\n  vec3 ww = normalize(vec3(0.0, 1.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  vec3 col = render(ro, rd);\n\n  fragColor = vec4(postProcess(col, q),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBRl.jpg", "access": "api", "license": "cc0-1.0", "functions": [[392, 392, 420, 440, 516], [518, 518, 557, 557, 645], [647, 647, 686, 686, 715], [717, 717, 750, 750, 838], [840, 840, 871, 871, 897], [899, 899, 926, 926, 1023], [1026, 1026, 1054, 1054, 1703], [1706, 1706, 1727, 1727, 2016], [2018, 2018, 2072, 2072, 2288], [2290, 2290, 2316, 2316, 2525], [2527, 2527, 2604, 2604, 2904], [2906, 2906, 2949, 2949, 3201], [3204, 3204, 3226, 3226, 3395], [3397, 3397, 3434, 3434, 4961], [4963, 4963, 5018, 5018, 5533]], "test": "untested"}
{"id": "wtcBRf", "name": "Construction Game fork", "author": "elenzil", "description": "fork of fabrice's [url]https://www.shadertoy.com/view/3l3fzf[/url],\nwith accelerated falling.", "tags": ["gravity"], "likes": 5, "viewed": 310, "published": 3, "date": "1613200956", "time_retrieved": "2024-07-30T19:38:33.017995", "image_code": "// Fork of \"construction game\" by FabriceNeyret2. https://shadertoy.com/view/3l3fzf\n// 2021-02-12 20:05:55\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R.y, A; \n    \n    // the \"O -= O\" thing yield static on iOS.\n    O = vec4(0.0);\n    for ( float x = 0.; x < S; x++ )                            // parse particles\n        for ( float y = 0.; y < S; y++ ) {\n            vec4 T = T(vec2(x,y));\n            A = abs( U - T.xy );\n            if ( max(A.x,A.y) < r ) O += vec4(.5+.5*T.zz,1,1);  // draw particle\n          }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float S  =  4.,                // S² bricks\n            r  = .4/S /2.;           // brick radius\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_a_code": "\n// --- is current particle colliding ?\nbool collide(vec2 particleIndex, vec2 testPt, out vec2 fix) {\n\n    fix = vec2(0.0);\n\n// collide with floor\n    if ( testPt.y < r ) {\n        fix = vec2(0.0, r - testPt.y);\n        return true;\n    }\n\n    bool ret = false;\n    for ( float x = 0.; x < S; x++ ) {\n        for ( float y = 0.; y < S; y++ ) {\n            vec2 P = vec2(x,y), A;\n            if ( P != particleIndex-.5 ) {\n\n                vec2 otherPartPartPos = T(P).xy;\n                A = testPt - otherPartPartPos;\n\n                if (abs(A.x) < 2.0 * r && abs(A.y) < 2.0 * r) {\n                    if (abs(A.x) > abs(A.y)) {\n                        float tmp = (r + 0.5/R.y) * sign(A.x) * 2.0 - A.x;\n                        fix.x = abs(tmp) > abs(fix.x) ? tmp : fix.x;\n                    }\n                    else {\n                        float tmp = (r + 0.5/R.y) * sign(A.y) * 2.0 - A.y;\n                        fix.y = abs(tmp) > abs(fix.y) ? tmp : fix.y;\n                    }\n                    ret = true;\n                }\n            }\n        }\n    }\n\n// no collision\n    return ret;\n }\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\n    // manage only S² particles\n    if ( max(U.x,U.y) > S ) return;\n\n    // init state\n    if ( iFrame < 1 ) {\n        O = vec4(.5*U/S,0,1.0);\n        return;\n    }\n\n\n    // restore state\n    O = T(U);\n    vec2 M = iMouse.xy/R.y;\n    vec2 D = vec2(0.,1./R.y);\n\n    // mouse release\n    if ( iMouse.z < 0. ) {\n        O.z = 0.;\n        \n    }\n    // mouse down on me: activate\n    else if ( iMouse.w > 0. && length(M-O.xy) < r ) {\n        O.z = 1.;\n        O.w = 1.;\n    }\n\n    vec2 fix;\n\n    if (O.z > 0.) {\n        // active particle\n\n        if (collide(U, M, fix)) {\n            // collision: stop\n            O.xy = M + fix * 1.0;\n        }\n        else {\n            // no obstactle: follow mouse\n            O.xy = M;\n        }\n    }\n      \n    else {\n        //  not active particle\n        \n        vec2 d = D * O.w;\n\n        if (collide(U, O.xy-d, fix)) {\n            // collision,\n            O.xy -= d;\n            O.xy += fix;\n            O.w   = 1.0;\n        }\n        else {\n            // free fall\n            O.xy -= d;\n            O.w  += 0.5;\n        }\n    }\n\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 146, 146, 530]], "test": "untested"}
{"id": "wtdBzf", "name": "Running Stick Figure", "author": "oneshade", "description": "Harmonic motion is awesome!", "tags": ["2d", "animation", "humanoid", "harmonic", "running", "stickfigure"], "likes": 11, "viewed": 210, "published": 3, "date": "1613197623", "time_retrieved": "2024-07-30T19:38:33.995382", "image_code": "// Inspired by: https://www.shadertoy.com/view/tttfRf\n\nvec2 Rotate(in vec2 p, in vec2 o, in float r) {\n    float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdStickFigure(in vec2 p) {\n    // Sizes\n    float t = 0.1; // Thickness\n    float hs = 0.4; // Head size\n\n    // Limb rotations\n    float lsr = cos(iTime * 2.5) + 0.5; // Left shoulder rotation\n    float rsr = -0.25 - lsr; // Right shoulder rotation\n\n    float lar = cos(iTime * 2.5) + 2.0; // Left forearm rotation (a for forearm)\n    float rar = 4.0 - cos(iTime * 2.5 + 0.5); // Right forearm rotation\n\n    float ltr = 0.0; // Left thigh rotation\n    float rtr = 0.0; // Right thigh rotation\n\n    float lcr = 0.0; // Left shin (calf) rotation\n    float rcr = 0.0; // Right shin (calf) rotation\n\n    // Joint positions\n    vec2 np = vec2(0.0, 0.75) + sin(iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.1, 0.05); // Neck\n    vec2 bp = vec2(-0.15, -0.65) + sin(-iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.25, 0.1); // Hip\n    vec2 hp = bp + normalize(np - bp) * (length(np - bp) + hs); // Head\n\n    vec2 lep = vec2(-0.4, 0.0); // Left elbow\n    vec2 rep = vec2(0.4, 0.0); // Right elbow\n\n    vec2 lhp = vec2(-0.75, 0.7); // Left hand\n    vec2 rhp = vec2(0.75, 0.7); // Right hand\n\n    vec2 lfp = vec2(-0.25, -2.0) + sin(-iTime * 3.0 + vec2(1.57, 0.0)) * vec2(1.25, 0.4); // Left foot\n    vec2 rfp = vec2(0.5, -1.75) + sin(-iTime * 3.0 + 2.0 + vec2(1.57, 0.0)) * vec2(1.0, 0.4); // Right foot\n\n    vec2 lkp = (bp + lfp) * 0.5; lkp += normalize(lkp - bp).yx * vec2(-0.25, 0.25); // Left knee\n    vec2 rkp = (bp + rfp) * 0.5; rkp += normalize(rkp - bp).yx * vec2(-0.25, 0.25); // Right knee\n\n    // Arm rotations\n    lep = Rotate(lep, np, lsr); // Left shoulder rotation\n    rep = Rotate(rep, np, rsr); // Right shoulder rotation\n\n    lhp = Rotate(lhp, np, lsr); // Left forearm rotation (with elbow)\n    rhp = Rotate(rhp, np, rsr); // Right forearm rotation (with elbow)\n\n    lhp = Rotate(lhp, lep, lar); // Left forearm rotation (independent)\n    rhp = Rotate(rhp, rep, rar); // Right forearm rotation (independent)\n\n    // Leg rotations\n    lkp = Rotate(lkp, bp, ltr); // Left thigh rotation\n    rkp = Rotate(rkp, bp, rtr); // Right thigh rotation\n\n    lfp = Rotate(lfp, bp, ltr); // Left shin rotation (with thigh)\n    rfp = Rotate(rfp, bp, rtr); // Right shin rotation (with thigh)\n\n    lfp = Rotate(lfp, lkp, lcr); // Left shin rotation (independent)\n    rfp = Rotate(rfp, rkp, rcr); // Right shin rotation (independent)\n\n    return min(min(sdSegment(p,  np, lep),\n               min(sdSegment(p, lep, lhp),\n               min(sdSegment(p,  np, rep),\n               min(sdSegment(p, rep, rhp),\n               min(sdSegment(p,  np,  bp),\n               min(sdSegment(p,  bp, lkp),\n               min(sdSegment(p, lkp, lfp),\n               min(sdSegment(p,  bp, rkp),\n                   sdSegment(p, rkp, rfp))))))))) - t,\n\n               sdDisc(p, hp, hs));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float stickFigure = sdStickFigure(uv - vec2(0.0, 0.1));\n    fragColor = vec4(smoothstep(0.0, unit, stickFigure));\n}", "image_inputs": [], "common_code": "/*\n// Crazy dance animation :)\n\nvec2 Rotate(in vec2 p, in vec2 o, in float r) {\n    float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdStickFigure(in vec2 p) {\n    // Sizes\n    float t = 0.1; // Thickness\n    float hs = 0.4; // Head size\n\n    // Limb rotations\n    float lsr = cos(iTime * 4.0) + 0.5; // Left shoulder rotation\n    float rsr = -0.25 - lsr; // Right shoulder rotation\n\n    float lar = iTime * 2.0; // Left forearm rotation (a for forearm)\n    float rar = iTime * 3.0; // Right forearm rotation\n\n    float ltr = 0.0; // Left thigh rotation\n    float rtr = 0.0; // Right thigh rotation\n\n    float lcr = 0.0; // Left shin (calf) rotation\n    float rcr = 0.0; // Right shin (calf) rotation\n\n    // Joint positions\n    vec2 np = vec2(0.0, 0.75) + sin(iTime * 3.0 + vec2(1.57, 0.0)) * vec2(0.1, 0.05); // Neck\n    vec2 bp = vec2(0.0, -0.65) + sin(-iTime * 6.0 + vec2(1.57, 0.0)) * vec2(0.25, 0.1); // Hip\n    vec2 hp = bp + normalize(np - bp) * (length(np - bp) + hs); // Head\n\n    vec2 lep = vec2(-0.4, 0.0); // Left elbow\n    vec2 rep = vec2(0.4, 0.0); // Right elbow\n\n    vec2 lhp = vec2(-0.75, 0.7); // Left hand\n    vec2 rhp = vec2(0.75, 0.7); // Right hand\n\n    vec2 lfp = vec2(-0.25, -2.0) + sin(-iTime * 10.0 + vec2(1.57, 0.0)) * vec2(0.75, 0.4); // Left foot\n    vec2 rfp = vec2(0.5, -1.75) + sin(-iTime * 10.0 + 4.0 + vec2(1.57, 0.0)) * vec2(0.75, 0.4); // Right foot\n\n    float wobble = sin(iTime * 15.0);\n    vec2 lkp = (bp + lfp) * 0.5; lkp += normalize(lkp - bp).yx * vec2(-0.5, 0.5) * wobble; // Left knee\n    vec2 rkp = (bp + rfp) * 0.5; rkp -= normalize(rkp - bp).yx * vec2(-0.5, 0.5) * wobble; // Right knee\n\n    // Arm rotations\n    lep = Rotate(lep, np, lsr); // Left shoulder rotation\n    rep = Rotate(rep, np, rsr); // Right shoulder rotation\n\n    lhp = Rotate(lhp, np, lsr); // Left forearm rotation (with elbow)\n    rhp = Rotate(rhp, np, rsr); // Right forearm rotation (with elbow)\n\n    lhp = Rotate(lhp, lep, lar); // Left forearm rotation (independent)\n    rhp = Rotate(rhp, rep, rar); // Right forearm rotation (independent)\n\n    // Leg rotations\n    lkp = Rotate(lkp, bp, ltr); // Left thigh rotation\n    rkp = Rotate(rkp, bp, rtr); // Right thigh rotation\n\n    lfp = Rotate(lfp, bp, ltr); // Left shin rotation (with thigh)\n    rfp = Rotate(rfp, bp, rtr); // Right shin rotation (with thigh)\n\n    lfp = Rotate(lfp, lkp, lcr); // Left shin rotation (independent)\n    rfp = Rotate(rfp, rkp, rcr); // Right shin rotation (independent)\n\n    return min(min(sdSegment(p,  np, lep),\n               min(sdSegment(p, lep, lhp),\n               min(sdSegment(p,  np, rep),\n               min(sdSegment(p, rep, rhp),\n               min(sdSegment(p,  np,  bp),\n               min(sdSegment(p,  bp, lkp),\n               min(sdSegment(p, lkp, lfp),\n               min(sdSegment(p,  bp, rkp),\n                   sdSegment(p, rkp, rfp))))))))) - t,\n\n               sdDisc(p, hp, hs));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float stickFigure = sdStickFigure(uv - vec2(0.0, 0.1));\n    fragColor = vec4(smoothstep(0.0, unit, stickFigure));\n}\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 102, 102, 182], [184, 184, 234, 234, 359], [361, 361, 409, 409, 441], [443, 443, 475, 488, 3199], [3201, 3201, 3256, 3256, 3486]], "test": "untested"}
{"id": "wldBzX", "name": "Jerusalem Cube", "author": "CubeyTheCube", "description": "Raymarched jerusalem cube with ACES tone mapping and GGX specularity.", "tags": ["fractal", "cube", "raymarcher", "jerusalem"], "likes": 5, "viewed": 290, "published": 3, "date": "1613188877", "time_retrieved": "2024-07-30T19:38:34.838129", "image_code": "#define anti_aliasing 2\n#define iterations 10\n\n#define M_PI 3.1415\n\n#define scl 1./(sqrt(2.)-1.) \n#define a 1.-2.*(sqrt(2.)-1.)\n#define aces_input mat3(0.59719, 0.35458, 0.04823,0.07600, 0.90834, 0.01566,0.02840, 0.13383, 0.83777)\n#define aces_output mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602)\n\nfloat sd(vec3 pos){ // ref http://www.fractalforums.com/index.php?topic=14225.msg55051#msg55051\n   float x = pos.x;\n   float y = pos.y;\n   float z = pos.z;\n   float t;\n   float r=x*x+y*y+z*z;float dd=1.0;\n   for(int i=0;i<iterations && r<100.;i++){\n      x=abs(x);y=abs(y);z=abs(z);\n      if(x<y){t=x;x=y;y=t;}\n      if(z<x){t=z;z=x;x=t;}\n      if(x<y){t=x;x=y;y=t;}\n      if(y<a && x>1.-2.*a+y-a){\n         x-=1.;z-=1.;\n         x*=scl*scl;y*=scl*scl;z*=scl*scl;dd*=scl*scl;\n         x+=1.;z+=1.;\n      }else{\n         x-=1.;y-=1.;z-=1.;\n         x*=scl;y*=scl;z*=scl;dd*=scl;\n         x+=1.;y+=1.;z+=1.;\n      }\n      r=x*x+y*y+z*z;\n   }\n   return (sqrt(r)-1.75)/dd;\n}\n\n\nfloat raymarch(in vec3 ro, in vec3 rd) {\n    float t = 0.001;\n    for(int i = 0; i < 40; i++) {\n        vec3 h = ro + rd * t;\n        float dist = sd(h);\n        if(dist < 0.001) break;\n        if(t > 20.) return 20.;\n        t += dist;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(sd(p + e.xyy) - sd(p - e.xyy),\n                          sd(p + e.yxy) - sd(p - e.yxy),\n                          sd(p + e.yyx) - sd(p - e.yyx)));\n}\n\nfloat ggx( in float a2, in float cosine) {\n  return (a2 * a2) / (3.14159265 * pow(cosine * cosine * (a2 * a2 - 1.) + 1., 2.0));\n}\n\nvec3 aces(in vec3 c) {\n    vec3 v = c * aces_input; // ref https://64.github.io/tonemapping/\n    vec3 b = v * (v + 0.0245786) - 0.000090537;\n    vec3 d = v * (0.983729 * v + 0.4329510) + 0.238081;\n    v = b/d;\n    return v * aces_output;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float AA = float(anti_aliasing);\n    vec3 finalCol = vec3(0.0);\n    for(float i = 0.0; i < AA; i++) {\n    for(float j = 0.0; j < AA; j++) {\n    vec3 col;\n    float r     = 5.0;\n    float theta = 2.0*M_PI * (iMouse.x / iResolution.x - 0.25);\n    float phi   = 0.5*M_PI * (iMouse.y / iResolution.y + 0.000001);\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 o = ta + r * vec3(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n\n    vec3 ww = normalize(ta - o);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec2 uv = (fragCoord+vec2(i,j)/AA-iResolution.xy*0.5)/iResolution.x;\n    vec3 d = normalize(vec3(uv.x * uu + uv.y * vv + 1.0*ww));\n    float t = raymarch(o,d);\n    if(t < 20.0) {\n    vec3 i = o + t * d;\n    vec3 n = normal(i);\n    vec3 l = normalize(vec3(0.0,0.0,-10.0) - i);\n    col = vec3(0.5, 0.38, 0.25) * max(0.0,dot(n,i)) + vec3(ggx(0.1, dot(n, normalize(l-d))));\n    col = clamp(col,0.0,1.0);\n    col = pow(col, vec3(0.4545));\n    col = aces(col*1.5);\n    } else col = texture(iChannel0,vec2(uv.x,8.*(uv.y+0.5))).xyz;\n    finalCol += col/(AA*AA);\n    }\n    }\n\n    fragColor = vec4(finalCol, 1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 363, 439, 1014], [1017, 1017, 1057, 1057, 1275], [1277, 1277, 1301, 1301, 1512], [1514, 1514, 1556, 1556, 1643], [1645, 1645, 1667, 1667, 1884], [1886, 1886, 1941, 1941, 3115]], "test": "untested"}
{"id": "tttfRf", "name": "chico baile v2", "author": "jorge2017a1", "description": "chico baile v2", "tags": ["chicobailev2"], "likes": 3, "viewed": 258, "published": 3, "date": "1613188820", "time_retrieved": "2024-07-30T19:38:35.614054", "image_code": "/// por jorge flore p......jorge2017a1\n//referencia \n//https://www.shadertoy.com/view/WlKSRt\n\n//Constants\nconst float tau = atan(1.0)*8.0;\nconst float pi = atan(1.0)*4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / min(iResolution.x,iResolution.y);\n    uv*=2.5;\n     //Time varying pixel color\n    \n    vec3 col = vec3(1.0);\n    /*\n    if (uv.y<-0.2)\n        col = 0.5 + 0.5125*cos(iTime+uv.xyx+vec3(0,2,4));\n    else\n        col = vec3(1.0);\n    */\n    \n    \n    float es=2.0;\n    float radio1=0.5*es;\n    float radio2=0.45*es;\n    \n    vec2 pa0=vec2(0.0,0.0 );\n    \n    vec2 pa1=pa0+ radio1*0.5*cossin(1.0*sin(iTime)-tau/4.0);\n    \n    vec2 pa2=pa1+ radio2*0.5*cossin(0.05);\n    \n    \n    vec2 pb0=vec2(0.0,0.0 );\n    vec2 pb1=pb0+ radio1*0.5*cossin(6.0+2.0*sin(iTime));\n    vec2 pb2=pb1+ radio2*0.5*cossin(8.0+0.5*cos(iTime));\n    \n    \n    float dcabeza=sdCircle(uv-vec2(0.0,0.1), 0.1 );\n    float dac1=dfCircle(radio1,uv);\n    float dac2=dfCircle(radio2,uv);\n    \n    float dbmano1=dfCircle(0.065,uv-pa2);\n    float dbmano2=dfCircle(0.065,uv-pb2);\n    \n    \n    \n   \n    float la1=dfLine(pa0, pa1, 0.009,  uv);\n    float la2=dfLine(pa1, pa2, 0.009,  uv);\n    \n    float lb1=dfLine(pb0, pb1, 0.009,  uv);\n    float lb2=dfLine(pb1, pb2, 0.009,  uv);\n    \n    \n   \n    \n    \n    vec2  pCuerpoA=vec2(0.0,0.0);\n    vec2  pCuerpoB=vec2(0.0,-0.5);\n    float lCuerpo=dfLine(pCuerpoA, pCuerpoB, 0.02,  uv);\n    \n    \n    vec2 pPiernaA1=pCuerpoB;\n    vec2 pPiernaB1=pCuerpoB;\n    float radiopi1=0.8;\n    \n    vec2 pPiernaA2=pPiernaA1+ radiopi1*0.5*cossin(-1.0+0.8*sin(iTime));;\n    vec2 pPiernaB2=pPiernaB1+ radiopi1*0.5*cossin(-0.5+0.4*cos(iTime));;;\n    \n    \n    vec2 pPiernaA3=pPiernaA2+ radiopi1*0.5*cossin(-1.0+0.8*sin(iTime+0.5));;\n    vec2 pPiernaB3=pPiernaB2+ radiopi1*0.5*cossin(-0.5+0.4*cos(iTime-0.5));;;\n    \n    \n    float lPierna1=dfLine(pPiernaA1, pPiernaA2, 0.01,  uv);\n    float lPierna2=dfLine(pPiernaB1, pPiernaB2, 0.01,  uv);\n    \n    float lPierna1A=dfLine(pPiernaA2, pPiernaA3, 0.01,  uv);\n    float lPierna2A=dfLine(pPiernaB2, pPiernaB3, 0.01,  uv);\n    \n    \n    \n    \n    dac1=dac1/fwidth(dac1);\n    dac2=dac2/fwidth(dac2);\n    dcabeza=dcabeza/fwidth(dcabeza);\n    \n    dbmano1=dbmano1/fwidth(dbmano1);\n    dbmano2=dbmano2/fwidth(dbmano2);\n    \n    lPierna1=lPierna1/fwidth(lPierna1);\n    lPierna2=lPierna2/fwidth(lPierna2);\n    \n    lPierna1A=lPierna1A/fwidth(lPierna1A);\n    lPierna2A=lPierna2A/fwidth(lPierna2A);\n    \n    \n    la1=la1/fwidth(la1);\n    la2=la2/fwidth(la2);\n    \n    lb1=lb1/fwidth(lb1);\n    lb2=lb2/fwidth(lb2);\n    \n    lCuerpo=lCuerpo/fwidth(lCuerpo);\n    \n    \n    \n    float dcOut=opS( dac2, dac1 );\n    \n    col=mix(vec3(1.0,0.0,0.0) ,col, la1-0.5);\n    col=mix(vec3(1.0,0.0,0.0) ,col, la2-0.5);\n    col=mix(vec3(1.0,0.0,0.0) ,col, lb1-0.5);\n    col=mix(vec3(1.0,0.0,0.0) ,col, lb2-0.5);\n    col=mix(vec3(0.0,0.0,1.0) ,col, dbmano1);\n    col=mix(vec3(0.0,0.0,1.0) ,col, dbmano2);\n    col=mix(vec3(1.0,0.0,1.0) ,col, lCuerpo);\n    col=mix(vec3(1.0,0.5,1.0) ,col, dcabeza);\n    col=mix(vec3(0.0,0.0,1.0) ,col, lPierna1);\n    col=mix(vec3(0.0,0.0,1.0) ,col, lPierna2);\n    col=mix(vec3(0.4,0.0,1.0) ,col, lPierna1A);\n    col=mix(vec3(0.4,0.0,1.0) ,col, lPierna2A);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// por jorge2017a1 ...jorge flores p.!!!\n\n#define PI 3.14159265359\n#define PI2 PI*2.0\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//https://www.shadertoy.com/view/WlKSRt\n//-----------------------\nvec2 cossin(float x)\n{\n\treturn vec2(cos(x),sin(x));   \n}\n\nfloat dfCircle(float d, vec2 uv)\n{\n    return length(uv)-d/2.0;\n}\n\nfloat dfRing(float d, float w, vec2 uv)\n{\n    return abs(length(uv)-d/2.0)-w/2.0;\n}\n\nfloat dfLine(vec2 start, vec2 end, float w, vec2 uv)\n{\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv)-w/2.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 229, 279, 3399]], "test": "untested"}
{"id": "tldBz2", "name": "[♪]Reconnaissance", "author": "Catzpaw", "description": "We're back on Earth.", "tags": ["2d", "terrain", "music"], "likes": 36, "viewed": 662, "published": 3, "date": "1613185622", "time_retrieved": "2024-07-30T19:38:36.452821", "image_code": "//--- Reconnaissance\n// by Catzpaw 2021\n\n//Image:post effect\n\n#define ZERO min(0,iFrame)\nconst float pi=acos(-1.);\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//CHROMATIC ABERRATION\nvec3 tx1(vec2 uv){return texture(iChannel0,uv).rgb;}\nvec3 ca(vec2 uv,vec2 xy){\n    vec2 uvr=uv-xy*.02;\n    vec3 c=vec3(0);\n    float f=0.;\n    for(int i=ZERO;i<10;i++)c+=tx1(mix(uvr,uv,f)).rgb*hsv(f+.85,1.,1.),f+=.1;\n    return c*.25;\n}\n\n//MAIN\nvoid mainImage(out vec4 col,in vec2 fc){\n\tvec2 uv=fc/iResolution.xy,xy=(fc-.5*iResolution.xy)/iResolution.y;\n    col=vec4(ca(uv,xy)*pow(1.3-length(xy),.9),1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//--- Reconnaissance\n// by Catzpaw 2021\n\n//BufferA:scene\n\nfloat time=70.;\nmat2 rot(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvec2 cam(float t){\n    return vec2(0,27)*rot(t*124e-4)+vec2(0,21)*rot(-t*61e-4);\n}\nfloat map(vec2 p){\n    return abs(texture(iChannel0,p*24e-4).r*1.3-.35)*\n           smoothstep(0.,1.,abs(.45-texture(iChannel0,p*129e-4).g*1.6))*\n           texture(iChannel0,p*783e-4).b;\n}\nfloat plants(vec2 p){\n    return (.04-map(p*3.))*.5+abs(map(p*31.)-.1)*.1;\n}\nfloat cloud(vec2 p){\n    p+=vec2(15,0)*rot(time*1e-3);\n    return clamp((.3-map(p*3.1+time*.02)*2.+abs(map(p*2.27+time*.01)*4.-.47))*.08+\n                 (sin(p.x*10.)+sin(p.x*12.)+sin(p.y*4.)+sin(p.y*8.))*5e-3,.0,.07);\n}\nfloat tr(vec2 p,float x,float y){\n    p.x+=x;p.y+=y;\n    return (p.y<abs(p.x)*-4.)&&(p.y>-.2)?1.:0.;\n}\nfloat flotilla(vec2 p,mat2 ma){\n    p.y*=2.;p*=ma;\n    return tr(p,.0,-.6)+tr(p,.2,-.3)+tr(p,-.2,-.3)+tr(p,.4,.0)+tr(p,-.4,.0);\n}\nvec3 tr2(vec2 p,float x,float y,float a){\n    p.x+=x;p.y+=y;\n    vec3 c=vec3(1);\n    vec2 q=p;q.y+=.18;\n    vec2 r=vec2(0,-.032)*rot(a);q+=r;\n    c*=q.x<r.x*(q.y*8.)?.5-a*.3:.5+a*.3;\n    c=q.y<q.x*(r.y-.02)/(r.x+.05)&&q.y<q.x*(.02-r.y)/(.05-r.x)?vec3(.2):c;\n    q.y-=.02;c=dot(q,q)<25e-5?vec3(sin(iTime*6.28)*.3+.7,0,0)-dot(q,q)*4e3:c;\n    return (p.y<abs(p.x)*-4.)&&(p.y>-.2)?c:vec3(0);\n}\nvec3 flotilla2(vec2 p,float a,mat2 ma){\n    p.y*=2.;p*=ma;\n    return tr2(p,.0,-.6,a)+tr2(p,.2,-.3,a)+tr2(p,-.2,-.3,a)+\n           tr2(p,.4,.0,a)+tr2(p,-.4,.0,a);\n}\nvoid mainImage(out vec4 col,in vec2 fc){\n    //coordinates\n    float reso=floor(max(min(iResolution.y,800.),240.)/30.)*8.,\n          ireso=1./reso;\n    int   iter=int(reso*.42);\n    vec2  uv=fc/iResolution.xy,\n          xy=(fc-.5*iResolution.xy)/iResolution.y,\n          g=vec2(xy.x,floor(xy.y*reso)*ireso+ireso*.5);\n    //camera\n    time+=iTime;\n    float a=sin(time*.05)*.5;\n    vec2  o=vec2(g.x*.4,0),d=vec2(0,1),\n          c1=cam(time),c2=cam(time+1.5)-c1;\n    mat2  m=rot(atan(c2.x,c2.y)+a),\n          ma=rot(a);\n    d*=m;o*=m;o+=c1+d*xy.y*ireso;\n    //terrain\n    float t=g.y+.58,\n          s1=ireso*.5,s2=ireso*.2,\n          fx=0.,fy=0.,fz=0.;\n    for(int i=0;i<iter;i++){\n        float h=map(o+d*t),\n              d=h+t-.58-xy.y,\n              l=smoothstep(s1,s2,abs(d));\n        fx=max(l,d>0.?.0:fx);\n        fy=l>.2||d>0.?h:fy;\n        fz=l>.0||d>0.?t:fz;\n        t-=ireso;\n    }\n    //objects\n    float sl=smoothstep(s1,s2,abs(xy.y-g.y)),\n          fv=flotilla(g,ma),\n          fs=flotilla(vec2(g.x,fz-.3),ma)*.7,\n          cv=cloud(o+d*(g.y+.5)),\n          cs=cloud(o+d*fz);\n    cv=cv>.065&&fy<.09?cv*10.:0.;\n    cs=cs>.065&&fy<.09?cs*7.:0.;\n    //plants\n    float pv=plants(o+d*(g.y+.5)),\n          ps=plants(o+d*(g.y+.5+ireso));\n    ps=ps-fy*.1>.025&&fy>3e-3&&pv<ps?ps*15.:0.;\n    pv=pv-fy*.1>.025&&fy>3e-3?sin(pv*8e2)*.2+.7:0.;\n    //color\n    vec3 c=fy<=21e-4?mix(vec3(.05,.10,.15),vec3(.10,.50,.40),fy*2e2):\n                     mix(mix(vec3(.32,.30,.30),vec3(.05,.15,.03),clamp(fy*7e2-1.2,0.,1.)),\n                         mix(vec3(.15,.10,.05),vec3(.11,.13,.12),clamp(fy*8.,0.,1.)),\n                         clamp(fy*20.,0.,1.));\n    c=pv>0.?c*vec3(.4,pv,.4):c;\n    c*=max(fx,.0)*(4.-fz*2.)*max(1.-fs-cs-ps,.2);\n    c=cv>0.?mix(c,vec3(1.-flotilla(vec2(g.x,g.y+.29-cv*.1),ma)*.6)*sl,cv*8.-5.):c;\n    c=fv>0.?mix(vec3(.2),flotilla2(g,a,ma),sl):c;\n    col=vec4(c,1);\n}\n", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "//--- Reconnaissance\n// by Catzpaw 2021\n\n//Sound:Wavetable Synthesizer\n\n//Music:\"XEVIOUS\" Composed by YURI 1982\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =135.;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\nfloat env(float x,vec4 e){float l=e.w+e.x+e.y;return x>l?0.:x<e.x?x/e.x:x<e.x+e.y?1.-(x-e.x)*(1.-e.z)/e.y:(l-x)*e.z/e.w;}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//INSTRUMENTS\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.25),osc_duty(f*(.5-detune),.25))*env_d(x,.5);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.1);}\nfloat sd(float x){return osc_nesnoise(x,12)*env_d(x,.25)+osc_duty(6./(x*.5+.1),.5)*.5*env_d(x,.19);}\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\nint get4(uint b,int l){return int(b>>l*4)&15;}\nvec2 track1(float t,float l){\n    int st=int(mod(t*bpm*16./steps,32.));\n    vec2 n=vec2(mod(t,l/16.),get4(0xcbc4cbc0u,st&7)+((st&7)==4?12:0)-((st&3)==2?1:0)*((st/8)&3)+60);\n    float dec=l/16.-mod(t,l/16.);dec=dec<1e-4?dec/1e-4:1.;\n    return lpfc30(n.y,n.x,sin(t*bpm*3.142/360.)*.25+.35,.9,6)*vec2(.40,.55)*env(n.x,vec4(.001,.05,.7,10.))*dec;\n}\nvec2 track2(float t,float l){\n    vec2 n=vec2(mod(t,l/16.),get4(0x01001001u,int(mod(t*bpm*16./steps,32.))&7)*48);\n    return n.y>0.?dutybass(freq(n.y)*n.x,n.x)*vec2(.50,.60)*env(n.x,vec4(.001,.05,.7,10.)):vec2(0);\n}\nvec2 track3(float t,float l){return nesbd(mod(t,l/4.))*vec2(.70,.65);}\nvec2 track4(float t,float l){return sd(mod(t+l/4.,l/2.))*vec2(.65,.50);}\nvec2 track5(float t,float l){\n    vec2 n=vec2(mod(t,l/16.),get4(0x05010011u,int(mod(t*bpm*16./steps,32.))&7));\n    return n.y>0.?neshh(n.x,n.y*.1)*vec2(.25,.30):vec2(0);\n}\n\nvoid render(float t,float l,inout vec2 o,bool e){\n    o+=  track1(t,l);                  //TRACK 1 melody\n    o+=e?track2(t,l):track2(t,l)*.9; //TRACK 2 bass\n    o+=e?track3(t,l):track3(t,l)*.3; //TRACK 3 bd\n    o+=e?track4(t,l):track4(t,l)*.8; //TRACK 4 sd\n    o+=e?track5(t,l):track5(t,l)*.7; //TRACK 5 hh\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    18\n#define DELAY_WET       0.40\n#define DELAY_FEEDBACK  0.90\n#define DELAY_TIME      0.153\n#define DELAY_STEREO    0.11\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 133, 133, 180], [181, 181, 215, 215, 292], [294, 317, 335, 335, 369], [370, 370, 395, 395, 553], [555, 562, 602, 602, 722]], "test": "untested"}
{"id": "wltBRX", "name": "Fork Treemap illus0r 283", "author": "illus0r", "description": "More concise version https://bit.ly/3df0e3L", "tags": ["treemap"], "likes": 1, "viewed": 244, "published": 3, "date": "1613174065", "time_retrieved": "2024-07-30T19:38:37.322486", "image_code": "#define rnd(x) (sin(9e4*x)*.5+.5)\n#define t (length(uv-.5)*20.-iTime)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float split;\n    vec2 boxPos = vec2(0);\n    vec2 boxSize = vec2(1);\n    split = rnd(.1);\n    for(int i = 0; i < 200; i++) {\n        int dir = i%2;\n        \n        if((uv[dir]-boxPos[dir])/boxSize[dir] < split) {\n            float newSize = split*boxSize[dir];\n            if (newSize < 0.001/length(uv-.5+.5*vec2(sin(t), cos(iTime)))) continue;\n            boxSize[dir] = newSize;\n            split = rnd(split+10.);\n        }\n        else {\n            float newSize = (1.-split)*boxSize[dir];\n            if (newSize < 0.05/length(uv-.5+.5*vec2(sin(t), cos(t)))) continue;\n            boxPos[dir] = boxPos[dir] + split*boxSize[dir];\n            boxSize[dir] = newSize;\n            split = rnd(split+20.);\n        }\n        \n    }\n    uv = (uv-boxPos)/boxSize;\n    fragColor = vec4(1.5-length(uv*2.-1.))*vec4(\n        rnd(split),\n        rnd(split+1.),\n        rnd(split+2.),\n        1.\n    )*2.;\n    fragColor *= step(.5,rnd(floor(length(uv-.5)*50.*split)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 128, 1136]], "test": "untested"}
{"id": "3ttfzf", "name": "Treemap", "author": "illus0r", "description": "glitch", "tags": ["glitch"], "likes": 6, "viewed": 381, "published": 3, "date": "1613173251", "time_retrieved": "2024-07-30T19:38:38.226071", "image_code": "#define rnd(x) (sin(9e4*x)*.5+.5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float split, edgeX1=0., edgeX2=1., edgeY1=0., edgeY2=1., spanX, spanY;\n    split = rnd(iMouse.x/10000.);\n    for(float i = 0.; i < 10.; i++) {\n        spanX = edgeX2 - edgeX1;\n        if (spanX < 0.04) break;\n        if((uv.x-edgeX1)/spanX < split) {\n            edgeX2 = edgeX1 + split*spanX;\n            split = rnd(split+10.);\n        }\n        else {\n            edgeX1 = edgeX1 + split*spanX;\n            split = rnd(split+20.);\n        }\n        \n        spanY = edgeY2 - edgeY1;\n        if (spanY < 0.02) break;\n        if((uv.y-edgeY1)/spanY < split) {\n            edgeY2 = edgeY1 + split*spanY;\n            split = rnd(split+10.);\n        }\n        else {\n            edgeY1 = edgeY1 + split*spanY;\n            split = rnd(split+20.);\n        }   \n    }\n    spanY = edgeY2 - edgeY1;\n    spanX = edgeX2 - edgeX1;\n    uv.x = (uv.x-edgeX1)/spanX;\n    uv.y = (uv.y-edgeY1)/spanY;\n    fragColor = vec4(1.5-length(uv*2.-1.))*vec4(\n        rnd(split),\n        rnd(split+1.),\n        rnd(split+2.),\n        1.\n    );\n    fragColor *= step(.5,rnd(floor(length(uv-.5)*50.*split)));\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 1219]], "test": "untested"}
{"id": "WtdfRX", "name": "Modified FNV-1A hash", "author": "public_int_i", "description": "FNV-1A hash modified in an attempt to make it more GPU friendly and optimized, displayed as bit planes.", "tags": ["test", "bit", "hash", "planes", "modified", "fnv1a"], "likes": 4, "viewed": 447, "published": 3, "date": "1613173154", "time_retrieved": "2024-07-30T19:38:38.995014", "image_code": "/*Ethan Alexander Shulman 2021\nCC0, public domain\n\nFowler–Noll–Vo hash function\nhttps://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash*/\n\n\n//uvec4 seed, returns uvec4 hash\nuvec4 hash(uvec4 seed) {\n    uvec4 h = (0x6A7F8FAAu^seed)*0x01000193u;\n    h = ((h.wxyz>>3u)^h^seed.yzwx)*0x01000193u;\n    h = ((h.zwxy>>8u)^h^seed.wxyz)*0x01000193u;\n    return h^(h>>11u);\n}\n#define I2F (1./float(0xFFFFFFFFu))\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uint hv = hash(uvec4(fragCoord,0,iTime*2.)).x;\n\n    //Hash bit plane test credit to hornet/pixelmager https://www.shadertoy.com/view/lt2yDm\n    int idx = int(floor(8.*uv.x)+8.*floor(4.0*uv.y));\n    uint bit = uint(idx);\n    uint bitmask = 1u<<bit;\n    float bitplane = float( (hv>>bit)&1u );\n    vec4 c = vec4(bitplane);\n    float ll = step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0))\n    \t\t * step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n    fragColor = mix(vec4(1,0,0,1),c, ll);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfRX.jpg", "access": "api", "license": "public-domain", "functions": [[175, 208, 232, 232, 399], [438, 438, 495, 495, 1049]], "test": "untested"}
{"id": "3tdfRX", "name": "Cube morphing thing", "author": "TheNosiriN", "description": "So originally, I was modelling a temple on this mountain, but it was taking too long so I postponed it. I really like the mountain so I'm releasing it. And the cube is something I made this morning.\n\npress up to toggle zoom.", "tags": ["raymarching", "cube", "texture", "thing", "idk", "mountain"], "likes": 13, "viewed": 398, "published": 3, "date": "1613169249", "time_retrieved": "2024-07-30T19:38:39.983374", "image_code": "\n#define LESS_DETAIL\n\n\n\n\nfloat mountain(vec3 x)\n{\n    vec2 p = x.xz * 0.05;\n    float t = 0.0, a = 1.0;\n    float dist = smoothstep(0.9, 1.0, 1.0-(length(p)-0.1));\n    for (int i=0; i<3; i++){\n        #ifdef LESS_DETAIL\n        float n = (textureLod(iChannel0, p, 2.0).r);\n        #else\n        float n = (textureLod(iChannel0, p, 0.0).r);\n        #endif\n        t += mix(n, dist+n, dist) * a;\n        p = mat2(0.8,-0.6,0.6,0.8)*p*2.0+dist*0.3;\n        a *= 0.5;\n    }\n    return (x.y-t)*0.3;\n}\n\n\nvec3 thing(vec3 p)\n{\n    p *= 0.5;\n    vec3 st;\n    vec3 q = abs(p)-1.5;\n    st.x = max(q.x, q.z); st.y = 2.0;\n    st.x = max(st.x, dot(abs(p.xz)-1.0, normalize(vec2(0.5,0.1)) ))-0.25;\n    st = mind(st, vec3(mountain(p), 1.0, 0.0)); p.y -= 3.0;\n    st.x = max(p.y, st.x);\n    \n    vec3 bd = vec3(MAX_DIST,0,0);\n    vec3 rp = p*1.5; rp.y -= 0.0; rp = abs(rp);\n    \n    //a cube made out of many cubes\n    for (float i=0.0, sc=1.0; i<6.0; i++){\n        rp = abs(rp)-sc/2.0;\n        float ff = sin(iTime*0.1);\n        rp *= mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64)*pow(ff,3.0);\n        bd.x = min(bd.x, max(rp.y,max(rp.x,rp.z)));\n        sc *= 0.6*length(rp) + 0.1;\n        rp *= 1.0/dot(rp,rp);\n    }\n    \n    bd.x = max(max(abs(p.y)-1.5,max(q.x, q.z)+0.5), bd.x);\n    st = mind(st, bd);\n    \n    return maxd(vec3(length(p)-6.0,0,0), st);\n}\n\n\nvec4 raymarch(vec3 eye, vec3 dir)\n{\n    vec3 info = vec3(0);\n    float depth = 0.0, i;\n    for (i=0.0; i<256.0 && depth<MAX_DIST; i++){\n        vec3 p = eye + depth * dir;\n        info = thing(p);\n        if (abs(info.x) < EPSILON * depth)break;\n        depth += info.x * remap(i,0.0,256.0,0.5,1.0);\n    }\n    return vec4(depth, info.yz, i/256.0);\n}\n\n\n\n\nfloat shadow(vec3 eye, vec3 dir) {\n    float res = 1.0;\n    float depth = 0.0;\n    float ph = 1e10;\n    for( float i=0.0; i<32.0 && depth<MAX_DIST; i++ ){\n     \tvec3 p = eye + dir * depth;\n        float h = thing(p).x;\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,depth-y) );\n        depth += h * remap(float(i),0.0,32.0,0.1,1.0);\n        depth += 0.05;\n    }\n\n    return res;\n}\n\n\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * EPSILON;\n \treturn normalize(\n        thing(p+P.xyy).x * \n        P.xyy + thing(p+P.yxy).x * \n        P.yxy + thing(p+P.yyx).x * \n        P.yyx + thing(p+P.xxx).x * \n        P.xxx\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 50.0, h = 5.0;\n    if (!(texelFetch( iChannel1, ivec2(38,2), 0 ).x>0.0)){\n        fov = 20.0, h = 7.0;\n    }\n    \n    vec3 eye = rotateCamera(40.0, iMouse.xy/iResolution.xy, iMouse);\n    \n    vec3 lookAt = vec3(0.0, h, 0.0);\n    vec3 light = normalize(vec3(1.0, 0.25, 1.0));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    float hsh = hash21(fragCoord.xy/iResolution.xy);\n    \n    vec3 col = vec3(0);\n    vec4 dist = raymarch(eye, worldDir);\n    \n    if (dist.x < MAX_DIST){\n        vec3 P = eye + worldDir * dist.x;\n        \n        vec3 N = normal(P);\n        if (dist.y == 1.0){\n            N = triplanarNormal(iChannel0, P, N, 3.0, 1.0, 3.0);\n        }else if (dist.y == 2.0){\n            N = triplanarNormal(iChannel0, P, N, 1.5, 0.7, 3.0);\n        }\n        N = normalize(N+hsh*0.05); //why did I do this? It looks nicer, kinda.\n        \n        float shading = saturate(dot(N, light)*0.5+0.25);\n        shading = mix(min(1.0,shading*3.0), shading, dot(normalize(eye), N));\n        if (shading >= 0.0){ shading *= shadow(P,light); }\n\n        col += (shading+0.1)+(dist.x/MAX_DIST)*0.1;\n        col = mix(col*0.5, col, saturate(1.0-pow(dist.w,3.0)*3.0));\n    }else{\n        col = vec3(0.5);\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float MAX_DIST = 50.0;\nconst float EPSILON = 0.0001;\n\n#define PI 3.1415972\n#define mind(a, b) (a.x < b.x ? a:b)\n#define maxd(a, b) (a.x > b.x ? a:b)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define hash21(p) (fract(sin(dot(p, p+5373.836))*9272.8363) *2.0-1.0)\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale, float lod)\n{\n    p *= scale;\n    \n    return  (textureLod(tex,p.xy,lod).rgb*n.z*n.z\n            +textureLod(tex,p.zy,lod).rgb*n.x*n.x\n            +textureLod(tex,p.xz,lod).rgb*n.y*n.y);\n}\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale, float lod)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B;\n    B.x = triplanarMap(tex, p+P.xzz, N, scale, lod).r;\n    B.y = triplanarMap(tex, p+P.zxz, N, scale, lod).r;\n    B.z = triplanarMap(tex, p+P.zzx, N, scale, lod).r;\n    B -= triplanarMap(tex, p, N, scale, lod).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n\n\n\n\nfloat remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 49, 49, 494], [497, 497, 517, 517, 1349], [1352, 1352, 1387, 1387, 1701], [1706, 1706, 1740, 1740, 2188], [2191, 2191, 2212, 2212, 2428], [2432, 2432, 2489, 2489, 3918]], "test": "untested"}
{"id": "WttfRX", "name": "Colors as Positions", "author": "oneshade", "description": "I've wondered what the pixels in an image look like if their colors were used as positions and I finally was able to find out by using buffers! You can look around with the mouse.", "tags": ["3d", "distancefields", "colors", "mapping", "image", "buffering", "positions"], "likes": 5, "viewed": 171, "published": 3, "date": "1613169013", "time_retrieved": "2024-07-30T19:38:41.164215", "image_code": "// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\n// Returns filtered sample from Buffer A as a vec4(red, green, blue, distance)\n#define fetch(p) texelFetch(iChannel0, ivec2(_322(p, SIZE, RESOLUTION, iChannelResolution[0].xy)), 0)\nvec4 sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        vec3 sp = mod(p + halfSize, SIZE) - halfSize;\n        if (filt == 0) {\n            return fetch(sp);\n        }\n\n        else {\n            vec3 UNIT = SIZE / RESOLUTION;\n            vec3 cell = floor(sp / UNIT) * UNIT;\n            vec3 local = fract(sp / UNIT);\n\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            vec4 ldb = fetch(cell);\n            vec4 rdb = fetch(cell + vec3(UNIT.x, 0.0, 0.0));\n            vec4 lub = fetch(cell + vec3(0.0, UNIT.y, 0.0));\n            vec4 rub = fetch(cell + vec3(UNIT.xy, 0.0));\n            vec4 ldf = fetch(cell + vec3(0.0, 0.0, UNIT.z));\n            vec4 rdf = fetch(cell + vec3(UNIT.x, 0.0, UNIT.z));\n            vec4 luf = fetch(cell + vec3(0.0, UNIT.yz));\n            vec4 ruf = fetch(cell + UNIT);\n\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.25;\n    float bbox = max(q.x, max(q.y, q.z));\n    return vec4(0.0, 0.0, 0.0, bbox);\n}\n\nvec4 mapScene(in vec3 p) {\n    return sampleDistanceField(p, 1);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.05, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).w - mapScene(p - e.xyy).w,\n                          mapScene(p + e.yxy).w - mapScene(p - e.yxy).w,\n                          mapScene(p + e.yyx).w - mapScene(p - e.yyx).w));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0);\n    if (iMouse.z > 0.0) mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Ray and light direction\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Intersect bbox to prevent raymarching artifacts\n    float t = iBox(ro, rd, SIZE * 0.49); // The box has to be a bit smaller to prevent artifacts\n    if (t > 0.0) {\n        vec3 p = ro + rd * t;\n        if (mapScene(p).w > 0.0) {\n            for (int i=0; i < 100; i++) {\n                vec3 p = ro + rd * t;\n                vec4 d = mapScene(p);\n                if (d.w < 0.001) {\n                    vec3 n = getNormal(p);\n                    fragColor.rgb += d.rgb * max(0.2, dot(n, l));\n                    break;\n                }\n\n                if (t > 100.0) {\n                    break;\n                }\n\n                t += d.w;\n            }\n        }\n\n        else {\n            vec3 color = mapScene(p).rgb;\n            vec3 n = getNormal(p);\n            fragColor.rgb += color * max(0.2, dot(n, l));\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PIXELS_PER_FRAME 100\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1000000.0);\n    }\n\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n        vec3 p = _223(fragCoord, SIZE, RESOLUTION, iResolution.xy);\n\n        for (int offset=0; offset < PIXELS_PER_FRAME; offset++) {\n            float frame = float(iFrame * PIXELS_PER_FRAME + offset);\n            float x = mod(frame, iChannelResolution[0].x);\n            float y = (frame - x) / iChannelResolution[0].x;\n            vec3 c = texture(iChannel1, vec2(x, y) / iChannelResolution[0].xy).xyz;\n            vec3 o = c * SIZE - 0.5 * SIZE;\n\n            float newShape = length(p - o) - 0.1;\n            if (newShape < fragColor.w) {\n                fragColor.rgb = c;\n                fragColor.w = newShape;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// RESOLUTION is the number of distance samples, SIZE is the space it maps to\n#define RESOLUTION vec3(45.0)\n#define SIZE vec3(3.0)\n\nvec3 _223(in vec2 p2D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p2D = floor(p2D);\n    float p1D = p2D.y * res2D.x + p2D.x;\n    float x = mod(p1D, res3D.x);\n    float y = mod(p1D - x, res3D.x * res3D.y) / res3D.x;\n    float z = (p1D - x - y * res3D.x) / res3D.x / res3D.y;\n    return vec3(x, y, z) / res3D * size3D - 0.5 * size3D;\n}\n\nvec2 _322(in vec3 p3D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p3D = floor(p3D / size3D * res3D + 0.5 * res3D);\n    float p1D = p3D.z * res3D.x * res3D.y + p3D.y * res3D.x + p3D.x;\n    float x = mod(p1D, res2D.x);\n    float y = (p1D - x) / res2D.x;\n    return vec2(x, y);\n}\n\n// Box intersector from https://www.shadertoy.com/view/ld23DV\nfloat iBox(in vec3 ro, in vec3 rd, in vec3 b) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * b;\n    vec3 t1 = -(k + n);\n    vec3 t2 = +(k - n);\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    return tN;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 293, 293, 1464], [1466, 1466, 1492, 1492, 1532], [1534, 1534, 1561, 1561, 1819], [1821, 1821, 1876, 1876, 3373]], "test": "untested"}
{"id": "3ttfRX", "name": "OMZG shader royale", "author": "jeyko", "description": "aaa", "tags": ["feedback", "competition", "royale", "omzg"], "likes": 29, "viewed": 491, "published": 3, "date": "1613168834", "time_retrieved": "2024-07-30T19:38:42.013943", "image_code": "\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n\tout_color = texture(iChannel0,fragCoord/iResolution.xy);\n  \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define T(u) texture(iChannel0, (u)/R)\n\nmat3 getOrthBas( vec3 dir){\n  vec3 r = normalize(cross(vec3(0,1,0), dir));\n  vec3 u = normalize(cross( dir, r));\n  return mat3(r,u,dir);\n  }\n\nfloat cyclicNoise(vec3 p){\n  float n = 0.;\n  p *= getOrthBas(normalize(vec3(-4,2.,-2. + sin(iTime)*1.4)));\n  float lac = 1.5;\n  float amp = 1.;\n  float gain = 0.5;\n  \n  mat3 r = getOrthBas(normalize(vec3(-4,2.,-2)));\n  \n\n  for(int i = 0; i < 8; i++){\n    p += cos(p + 2. + vec3(0,0,iTime))*0.5;\n    n += dot(sin(p),cos(p.zxy + vec3(0,0,iTime)))*amp;\n    \n    p *= r*lac;\n    amp *= gain;\n    }\n    return n;\n  }\n\n\n\nvoid mainImage( out vec4 out_color, in vec2 U )\n{\n  #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n  \n  U -= 0.5*R;\n  //U *= rot(iTime*0.01);\n  U *= 0.99 + sin(iTime)*0.00 - dot(U/R,U/R)*0.05*sin(iTime);\n  U += 0.5*R;\n  out_color = T(U);\n  #define getGrad(axis) vec2(e[axis]-w[axis],n[axis]-s[axis])\n  float offs = 20. + sin(iTime + length((U - 0.5*R)/R.y)*1.5)*30.;\n  offs *= 0.5;\n  vec4 n = T(U + vec2(0,1)*offs);\n  vec4 s = T(U + vec2(0,-1)*offs);\n  vec4 e = T(U + vec2(1,0)*offs);\n  vec4 w = T(U + vec2(-1,0)*offs);\n  \n  vec2 grad = getGrad(0 + int(mod(float(iFrame)/4.,2.)));\n  \n  float noisb = cyclicNoise(vec3(U/R*5.,1. + iTime*0.2 + sin(iTime)*1.));\n  \n  grad *= rot(noisb*0.2*sin(iTime) - iTime*0.);\n  vec2 uu = U;\n  uu += grad*22. + noisb*1.;\n  out_color = T(uu);\n  n = T(uu + vec2(0,1));\n  s = T(uu + vec2(0,-1));\n  e = T(uu + vec2(1,0));\n  w = T(uu + vec2(-1,0));\n  \n  #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n  \n  float nois = cyclicNoise(vec3(uu/R*80.,1. + iTime*0.2 + sin(iTime)*1.));\n  \n  vec3 nc = nois*pal(0.5,vec3(1.,0.2,1.),1.,vec3(3.,0. + nois*20.,4. + sin(iTime) + 2.),nois*10. + iTime);\n  out_color = mix(out_color,vec4(max(nc,0.),1),0.01);\n  //out_color += cyclicNoise(vec3(uv*20.,1));\n  if(iTime < 0.4){\n    out_color = vec4(0);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 121]], "test": "untested"}
{"id": "wtycRt", "name": "Variable fractal tiles", "author": "public_int_i", "description": "Each tile has different fractal parameters.", "tags": ["fractal", "tiles", "variable"], "likes": 5, "viewed": 283, "published": 3, "date": "1613166552", "time_retrieved": "2024-07-30T19:38:42.810812", "image_code": "\n#define FIELD_OF_VIEW 7.\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat triwave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\nvec3 triwave(vec3 x) {\n    return vec3(1)-abs(fract(x)-.5)*2.;\n}\n\n//Credit: IQ, integer hash 2 https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = ((fragCoord)*2.-iResolution.xy)*FIELD_OF_VIEW/iResolution.y+10.+iTime,\n        ipos = pos;\n\n    //hash from local tile coordinate\n    vec3 h = hash(uvec3(floor(pos/10.),0));\n    pos = mod(pos,10.)-5.;\n    \n    //apply folds based off hash\n    for (int i = 0; i < 6; i++) {\n        float fi = h[i/2], rv = h[i%3+1];\n        if (i%2 == 0) fi = fract(fi*10.);\n        else fi = floor(fi*10.);\n           \n        int id = int(fi)%3;\n        if (id == 0) {//mirror rotate fold\n            pos = (abs(pos)-.5)*r2(rv*6.28);\n        } else if (id == 1) {//plane fold\n            rv *= 6.28;\n            vec2 pnorm = vec2(sin(rv),cos(rv));\n            pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n        } else {//polar fold\n            float sz = .04+rv*1.6,\n                ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n            pos = vec2(sin(ang),cos(ang))*length(pos);\n        }\n        //apply box fold\n        float ext = h[i%3];\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n\n    //coloring\n    fragColor = vec4(pow(triwave(length(pos)*vec3(4,5,6)),vec3(1.6)),1);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 45, 45, 102], [104, 104, 128, 128, 165], [166, 166, 188, 188, 230], [232, 299, 319, 319, 477], [479, 479, 536, 536, 1616]], "test": "untested"}
{"id": "tlcBzf", "name": "Root Finding with Bisection", "author": "oneshade", "description": "Finding square roots with bisection.", "tags": ["algorithm", "rootfinding", "bisection", "roots"], "likes": 3, "viewed": 124, "published": 3, "date": "1613165376", "time_retrieved": "2024-07-30T19:38:43.573772", "image_code": "#define BISECT_MIN 0.0\n#define BISECT_MAX ((x + 1.0) / 2.0)\n#define BISECTIONS int(iTime) % 10\n#define EPSILON 0.001\n\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat test(in float tx, in float x) {\n    return tx * tx - x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float x = uv.x;\n\n    // Bisection loop\n    float tmin = BISECT_MIN, tmax = BISECT_MAX, t;\n    for (int bisection=0; bisection < BISECTIONS; bisection++) {\n        t = (tmin + tmax) * 0.5;\n        float e = test(t, x);\n        if (e >= 0.0) tmax = t;\n        if (e <  0.0) tmin = t;\n        if (abs(e) < EPSILON) break;\n    }\n\n    // Draw bisected area\n    draw(abs(uv.y - (tmin + tmax) * 0.5) - abs(tmax - tmin) * 0.5, vec3(0.0, 0.0, 0.5));\n\n    // Draw the solution\n    draw(abs(uv.y - sqrt(x)), vec3(0.0, 1.0, 0.0));\n\n    // Draw bisection limits\n    draw(abs(uv.y - tmin), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y - tmax), vec3(1.0, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 223, 223, 249], [251, 251, 306, 306, 1108]], "test": "untested"}
{"id": "wl3fRf", "name": "Y-Function Graph", "author": "Zi7ar21", "description": "All the other shaders that are supposed to plot functions kinda suck because they have variations in line thickness. However, this shader aims to solve that problem with supersampling.", "tags": ["utility", "function", "plot", "tool", "visualize"], "likes": 3, "viewed": 894, "published": 3, "date": "1613162623", "time_retrieved": "2024-07-30T19:38:44.342716", "image_code": "// ##### Y-Function Graph #####\n// Made by Zi7ar21 on February 12th, 2021\n// Last Updated: February 12th, 2021 at 13:30 Mountain Time\n\n// If you found this anywhere except Shadertoy, the original and possibly a newer version can be found at:\n// https://www.shadertoy.com/view/wl3fRf\n\n/*All of the other shaders that are supposed to plot functions (that I have used at least)\nseem to have variations in line thickness due to the fact that they simply take a function's\ndifference from the screen's y coordinate and draw it if it is a certain distance from the\ny coordinate at that point, however this shader solves that problem by drawing an aliased line\nwith uniform-ish thickness and then superampling it.*/\n\n// Super-Sample Levels\n#define samples 4\n\n// Y-Scale\n#define yscale 2.5\n\n// X-Scale\n#define xscale 4.0/iResolution.x\n\n// Pi (used for the example function)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// Example Function: y = (sin(x*pi*2.0+t)+cos(x*pi))/2.0\nfloat function(float x){\n    return (sin(x*pi*2.0+iTime)+cos(x*pi))/2.0;\n}\n\n// Plot\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Initialize the Color\n    vec3 color  = vec3(0.0);\n    // Initialize the Coordinates\n    vec2 coord = fragCoord;\n    // The Super-Sampling Loop\n    for(int y = -samples; y < samples; y++){for(int x = -samples; x < samples; x++){\n    // Set the Super-Sampled Coordinate\n    coord = (fragCoord+(vec2(x, y)/float(samples)));\n    // Find The Points for a Smooth yet Aliased Line\n    bool pointa =     round(function((coord.x-1.0)*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointb =     round(function((coord.x    )*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    bool pointc =     round(function((coord.x    )*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointd =     round(function((coord.x-1.0)*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    // Some Points take less than 2x to move up a pixel so we sample a point where the line is at every point\n    bool pointe = abs(round(function( coord.x*xscale)*iResolution.y)-yscale*(coord.y-0.5*iResolution.y)) <= 1.0;\n    // Check if the pixel is part of the line\n    if((pointa && pointb) || (pointc && pointd) || pointe){\n        color += vec3(1.0);\n    }\n    }}\n    // Output the Super-Sampled Line\n    fragColor = vec4(color/float(samples*samples*4), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[951, 1008, 1032, 1032, 1082], [1084, 1092, 1146, 1174, 2447]], "test": "untested"}
{"id": "Wtdfz2", "name": "Perfection = Temporal aa+Denoise", "author": "Ric3cir121", "description": "Ok so today i made a revolutionary raytracing using denoising and temporal antialiasing, did you ever expected to be able to run a raytracing with a really high number of samples at 60 frames per second?\n\nEdit: no it's not revolutionary - me from 2024", "tags": ["procedural", "raytracing", "distancefunction", "fast", "pathtracing", "evolution", "objects", "distanceestimator", "denoising", "temporalantialiasing"], "likes": 11, "viewed": 702, "published": 3, "date": "1613161367", "time_retrieved": "2024-07-30T19:38:45.196434", "image_code": "void mainImage(out vec4 o,vec2 u){\n    vec4 o1 = texelFetch(iChannel0,ivec2(u)+ivec2(0,0),0);\n    vec4 o2 = texelFetch(iChannel0,ivec2(u)+ivec2(1,0),0);\n    vec4 o3 = texelFetch(iChannel0,ivec2(u)+ivec2(2,0),0);\n    vec4 o4 = texelFetch(iChannel0,ivec2(u)+ivec2(0,1),0);\n    vec4 o5 = texelFetch(iChannel0,ivec2(u)+ivec2(1,1),0);\n    vec4 o6 = texelFetch(iChannel0,ivec2(u)+ivec2(2,1),0);\n    vec4 o7 = texelFetch(iChannel0,ivec2(u)+ivec2(0,2),0);\n    vec4 o8 = texelFetch(iChannel0,ivec2(u)+ivec2(1,2),0);\n    \n    float p = 5.;\n    \n    float d1 = dot(o1,vec4(1))/4.;\n    float d2 = clamp(1.-abs(dot(o2,vec4(1))/4.-d1)*p,0.,1.);\n    float d3 = clamp(1.-abs(dot(o3,vec4(1))/4.-d1)*p,0.,1.);\n    float d4 = clamp(1.-abs(dot(o4,vec4(1))/4.-d1)*p,0.,1.);\n    float d5 = clamp(1.-abs(dot(o5,vec4(1))/4.-d1)*p,0.,1.);\n    float d6 = clamp(1.-abs(dot(o6,vec4(1))/4.-d1)*p,0.,1.);\n    float d7 = clamp(1.-abs(dot(o7,vec4(1))/4.-d1)*p,0.,1.);\n    float d8 = clamp(1.-abs(dot(o8,vec4(1))/4.-d1)*p,0.,1.);\n    \n    o = (o1+o2*d2+o3*d3+o4*d4+o5*d5+o6*d6+o7*d7+o8*d8)/(1.+d2+d3+d4+d5+d6+d7+d8);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct obj{\n    float d;\n    vec3 col;\n    int ref;\n};\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n#define hash13(a) fract(sin(a*vec3(1.239,5.283,2.294))*1000000.)\n#define mn(a,b) obj((a.d>b.d?b.d:a.d),(a.d>b.d?b.col:a.col),(a.d>b.d?b.ref:a.ref))\n#define mx(a,b) obj((a.d<-b.d?-b.d:a.d),(a.col),(a.ref))\n#define sphere(a,b,c,d,e) obj(length(a-b)-c/2.,d,e)\n#define cube(a,b,c,d,e,f) obj(length(clamp(a,b-(c-d)/2.,b+(c-d)/2.)-a)-d/2.,e,f)\n#define plane(a,b,c,d) obj(a.y-b.y,c,d)\nobj de(vec3 pos){\n    obj res = obj(10000.,vec3(0),0);\n    res = mn(res,sphere(pos,vec3(0 , -1,-.5),1.    ,vec3(.9,.5,.5),1));\n    res = mn(res,  cube(pos,vec3(-1,-.5,-1 ),1. ,.3,vec3(.9,.5,.9),0));\n    res = mx(res, plane(pos,vec3(0 ,-.99,0 )       ,vec3(.9,.9,.9),2));\n    res = mn(res, plane(pos,vec3(0 , -1, 0 )       ,vec3(.9,.9,.9),2));\n    res = mx(res,  cube(pos,vec3(0 ,-1. ,.5),2. ,1.,vec3(.9,.5,.9),1));\n    res = mn(res,sphere(pos,vec3(.3,  0, 1 ),1.    ,vec3(.5,.5,.9),2));\n    return res;\n}\nvec3 getmarch(vec3 pos,vec3 cam,bool rev){\n    float r = rev?-1.:1.;\n    float d = 9.;\n    vec3 mov = vec3(0);\n    for(int i = 0;i < 100;i++){\n        d = de(mov+pos).d*r;\n        mov += d*cam;\n        if(length(mov)>50.||d<0.0001)break;\n    }\n    return mov+pos;\n}\nvec3 getcolor(vec3 pos){return de(pos).d>0.01?vec3(1):de(pos).col;}\nvec3 getnormal(vec3 pos){\n    vec2 e = vec2(1,-1)*0.0001;\n    return normalize(e.xyy*de(pos+e.xyy).d+e.yyx*de(pos+e.yyx).d+e.yxy*de(pos+e.yxy).d+e.xxx*de(pos+e.xxx).d);\n}\n#define _pos(x) vec3(3.+sin(x),3,-3.+sin(x))\n#define _look(x) vec2(-.7,.8+sin(x*2.)*0.2)\nvec3 image(out vec4 o,vec2 u){\n    vec2 uv = (u+hash13(iTime).xy-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = _pos(iTime);\n    vec2 look = _look(iTime);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    vec3 norm, col = vec3(1),oldmarch;\n    bool rev = false;\n    vec3 march = getmarch(pos,cam,false);\n    vec3 ret = march;\n    for(int i = 0;i < 10;i++){\n        norm = getnormal(march);\n        col *= getcolor(march);\n        if(de(march).d>0.0001)break;\n        if(de(march).ref==1){\n            cam = reflect(cam,norm);\n            march += norm*0.01;\n        }else if(de(march).ref==0){\n            if(!rev)cam = normalize(mix(cam,-norm,0.1));\n            rev = !rev;\n            march+= cam*0.01;\n        }else{\n            cam = normalize(reflect(cam,norm)+(hash13(fract(dot(norm,cam)*iTime))-.5)*0.5);\n            march += norm*0.01;\n        }\n        oldmarch = march;\n        march = getmarch(march,cam,rev);\n        if(rev)col /= pow(length(march-oldmarch),3.)*20.+1.;\n    }\n    col *= getcolor(march);\n\n    o = vec4(col,length(ret));\n    return ret;\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec3 pos = _pos((iTime-iTimeDelta));\n    vec2 look = _look((iTime-iTimeDelta));\n    \n    vec4 new;\n    vec3 opos = image(new,u);\n    \n    vec3 oldl = rotate(rotate(normalize(opos-pos),-look.x).yxz,look.y).yxz;\n    vec2 R = iResolution.xy;\n    vec2 read = ((oldl.xy/normalize(oldl).z*R.yy/R/1.-.5)*R-hash13(iTime-iTimeDelta).xy)/R;\n    o = new;\n    vec4 tex = texture(iChannel0,read);\n    o = mix(o,mix(o,tex,clamp(1.3-abs(tex.w-length(opos))*5.,0.,1.)),0.95);\n    o.w = length(opos);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 1085]], "test": "untested"}
{"id": "wt3fzX", "name": "Glowing Flower", "author": "yozic", "description": "More domain warping fun.", "tags": ["kaleidoscope", "trippy"], "likes": 26, "viewed": 779, "published": 3, "date": "1613155104", "time_retrieved": "2024-07-30T19:38:45.960391", "image_code": "#define PI 3.141592\n#define orbs 20.\n\nvec2 kale(vec2 uv, vec2 offset, float sides) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / sides) * sides;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  angle = angle;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}\n\nvec4 orb(vec2 uv, float size, vec2 position, vec3 color, float contrast) {\n  return pow(vec4(size / length(uv + position) * color, 1.), vec4(contrast));\n}\n\nmat2 rotate(float angle) {\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 23.09 * (2. * fragCoord - iResolution.xy) / iResolution.y;\n  float dist = length(uv);\n  fragColor = vec4(0.);\n  uv *= rotate(iTime / 20.);\n  uv = kale(uv, vec2(6.97), 6.);\n  uv *= rotate(iTime / 5.);\n  for (float i = 0.; i < orbs; i++) {\n    uv.x += 0.57 * sin(0.3 * uv.y + iTime);\n    uv.y -= 0.63 * cos(0.53 * uv.x + iTime);\n    float t = i * PI / orbs * 2.;\n    float x = 4.02 * tan(t + iTime / 10.);\n    float y = 4.02 * cos(t - iTime / 30.);\n    vec2 position = vec2(x, y);\n    vec3 color = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * (float(i) / 5.37)) * 0.5 + 0.5;\n    fragColor += orb(uv, 1.39, position, color, 1.37);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 84, 84, 340], [342, 342, 416, 416, 496], [498, 498, 524, 524, 590]], "test": "untested"}
{"id": "3tcBRf", "name": "1D cellular automata explorer", "author": "kostik1337", "description": "Fancy 1D cellular automatas in raytraced box.\nExplore different rules by moving mouse\n\nkeybinds:\nspace - init automata with random values\nc - init with a single \"on\" state\nv - init with a single \"off\" state", "tags": ["raytracing", "automata", "cellular"], "likes": 6, "viewed": 292, "published": 3, "date": "1613152330", "time_retrieved": "2024-07-30T19:38:46.743298", "image_code": "float fetch_aut(vec2 p) {\n    if (p.x < 0. || p.x > 1. || p.y < 0. || p.y > 1.) return 0.;\n    p = p * CELLULAR_SIZE / iResolution.xy;\n    return texture(iChannel0, p).r;\n}\n\nvec3 lookAt(vec3 O, vec3 p, vec2 uv, float z) {\n    vec3 f = normalize(p - O);\n    vec3 r = vec3(1., 0., 0.);\n    vec3 u = normalize(cross(f, r));\n    r = cross(u, f);\n    return normalize(r*uv.x + u*uv.y + f * z);\n}\n\n#define INF 1e10\n\nfloat printRule(vec2 uv) {\n    ivec2 rule = getMouseRule(iMouse, iResolution).yz;\n    float v = PrintValue(uv, float(rule.x), 3., 0.);\n    v = max(v, PrintValue(uv + vec2(0., 1.4), float(rule.y), 3., 0.));\n    return v;\n}\n\nfloat box2(vec2 p, vec2 s) {\n    p = abs(p) - s;\n    return max(p.x, p.y);\n}\n\nfloat drawRuleGraphic(vec2 uv) {\n    if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) return 0.;\n    int rule = getMouseRule(iMouse, iResolution).x;\n    vec2 patternFloor = floor(uv * 4.), patternUV = fract(uv*4.);\n\n    patternUV *= 1.2;\n    vec2 cellSize = vec2(3., 2.);\n    vec2 cellUV = fract(patternUV * cellSize) - .5;\n    vec2 cellFloor = floor(patternUV * cellSize);\n\n    int cellId = int(cellFloor.y * cellSize.x + cellFloor.x);\n    if(cellId == 4) cellId = 3;\n    else if(cellId == 0) cellId = 2;\n    else if(cellId == 1) cellId = 1;\n    else if(cellId == 2) cellId = 0;\n    else cellId = -1;\n\n    if (cellId != -1) {\n        int patternIndex = int(patternFloor.y * 4. + patternFloor.x);\n        int filled = (patternIndex >> cellId) & 1;\n        int isPatternInRuleTrue = (rule >> patternIndex) & 1;\n        \n        float m = box2(cellUV, vec2(.4));\n        if (filled == 0) m = max(m, -box2(cellUV, vec2(.3)));\n        float col = step(m, 0.);\n        if (isPatternInRuleTrue == 0) col *= .1;\n        return col;\n    }\n    return 0.;\n}\n\nvec3 raytrace(vec2 uv) {\n    vec3 col = vec3(0.);\n    \n    float planeZ = 1.3;\n\n    for (float ray = 0.; ray < RAYS; ++ray) {\n        vec3 rayCol = vec3(0.);\n        float rayInd = floor(ray/RAYS * 3.)-1.;\n        vec2 rgOffset = vec2(rayInd, 0.) / CELLULAR_SIZE * .5;\n\n        vec2 uvOff = vec2(hash2(uv+ray+iTime), hash2(uv.yx+ray*1.321+iTime)) / iResolution.xy;\n        vec2 camOffset = vec2(sin(iTime * vec2(.7, .86)))*.01;\n        vec3 O = vec3(camOffset,-.4);\n        vec3 D = lookAt(O, vec3(0., 0., 0.), uv + uvOff, .4);\n        //vec3 D = normalize(vec3(uv + uvOff, 0.)-O);\n        float refl = 1.;\n\n        for (float r = 0.; r < REFLECTIONS; ++r) {\n            vec2 Dsign = sign(D.xy);\n        \n            // Z Plane with cellular\n            float planeD = (planeZ - O.z) / D.z;\n            if (planeD < 0.) planeD = INF;\n            vec3 planeN = vec3(0., 0., -1.);\n\n            // Floor and walls\n            vec2 wXY = vec2(2.);\n            float floorD = (Dsign.y * wXY.y - O.y) / D.y;\n            vec3 floorN = vec3(0., -Dsign.y, 0.);\n            \n            float wallD = (Dsign.x * wXY.x - O.x) / D.x;\n            vec3 wallN = vec3(-Dsign.x, 0., 0.);\n\n            float wD = min(floorD, wallD);\n            float d = min(planeD, wD);\n            vec3 n = planeD < wD ? planeN : wallD < floorD ? wallN : floorN;\n\n            vec3 p = O+D*d;\n            \n            vec2 planeUV = planeD < wD ? p.xy : p.xy - 1./iResolution.xy;\n            planeUV += rgOffset;\n            vec3 c = vec3(0.);\n            if (planeD < wD) {\n                vec2 gridUv = fract(planeUV * CELLULAR_SIZE / 2. / wXY) - .5;\n                gridUv = abs(gridUv);\n                vec2 st = smoothstep(vec2(.5-.05), vec2(.5-.1), gridUv);\n                float cellDist = st.x * st.y;\n                c += cellDist * fetch_aut(planeUV/2./wXY + vec2(.5, .5));\n            } else if (wallD < floorD) {\n                if (Dsign.x < 0.) c += printRule(p.zy * 6. - vec2(planeZ+1.1, 0.));\n                else c += drawRuleGraphic(p.zy * vec2(-1., 1.) * 1.3 + vec2(1.6, .5));\n            }\n\n            rayCol += (c * refl) / RAYS;\n            D = reflect(D, n);\n            \n            float seed = r * .345 + ray + iTime;\n            vec3 randdir = vec3(hash2(p.yz+seed), hash2(p.xz + seed*1.423), hash2(p.yx + seed*0.313));\n            \n            float rough = .1;\n            D = normalize(D + (randdir-.5)*rough);\n            if(dot(D, n) < 0.) D = -D;\n            O = p + n*0.001;\n            refl *= .2;\n        }\n        \n        col += rayCol * vec3(rayInd == -1., rayInd == 0., rayInd == 1.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 col = raytrace(uv);\n    col *= 2.5 * vec3(1.4, 1.1, 1.);\n    \n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float RAYS = 16.;\nconst float RAYS_SQRT = floor(sqrt(RAYS));\nconst float REFLECTIONS = 3.;\n\nconst int FRAME_MOD = 3;\nconst vec2 CELLULAR_SIZE = vec2(70.);\n\nfloat hash(float n) { \n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat hash2(vec2 n) { \n\treturn hash(dot(n, vec2(12.9898, 4.1414)));\n}\n\nivec3 getMouseRule(vec4 iMouse, vec3 res) {\n    ivec2 ruleV = ivec2(iMouse.xy / (res.xy-1.) * 255.0);\n    ruleV = clamp(ivec2(0), ivec2(255), ruleV);\n    return ivec3(ruleV.x | (ruleV.y << 8), ruleV);\n}\n\n// from https://www.shadertoy.com/view/4sBSWW\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n", "buffer_a_code": "int fetch_state(vec2 p) {\n    p = mod(p + CELLULAR_SIZE, CELLULAR_SIZE);\n    return int(texture(iChannel0, p / iResolution.xy).r);\n}\n\nint calc_next(float x) {\n    int t_prev = fetch_state(vec2(x, 1.));\n    int t0 = fetch_state(vec2(x-1., 0.));\n    int t1 = fetch_state(vec2(x, 0.));\n    int t2 = fetch_state(vec2(x+1., 0.));\n    int encoded = (t0 << 0)|(t1 << 1) | (t2 << 2) | (t_prev << 3);\n    int rule = getMouseRule(iMouse, iResolution).x;\n    return (rule >> encoded) & 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int state;\n    vec2 uv = fragCoord;\n    if (iFrame % FRAME_MOD != 0) {\n        state = fetch_state(fragCoord);\n    } else if (uv.x > CELLULAR_SIZE.x || uv.y > CELLULAR_SIZE.y) {\n        state = 0;\n    } else {\n        if (uv.y < 1.) {\n            bool keyPressed = texelFetch(iChannel1, ivec2(32, 0), 0).x > 0.;\n            bool cPressed = texelFetch(iChannel1, ivec2(67, 0), 0).x > 0.;\n            bool vPressed = texelFetch(iChannel1, ivec2(86, 0), 0).x > 0.;\n            if (iFrame == 0 || keyPressed) state = int(step(.5, hash(iTime + uv.x +131.3)));\n            else if (cPressed || vPressed) state = floor(uv.x) == CELLULAR_SIZE.x/2.? int(cPressed) : int(vPressed);\n            else state = calc_next(fragCoord.x);\n        }\n        else state = fetch_state(fragCoord - vec2(0., 1.));\n    }\n    \n    fragColor = vec4(float(state));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 172], [174, 174, 221, 221, 390], [410, 410, 436, 436, 631], [633, 633, 661, 661, 709], [711, 711, 743, 743, 1763], [1765, 1765, 1789, 1789, 4381], [4383, 4383, 4440, 4440, 4651]], "test": "untested"}
{"id": "wt3BRX", "name": "Uniform Distribution on Disk", "author": "katayu", "description": "A pseudorandom sampling from the uniform  probability distribution on disk.", "tags": ["raymarching"], "likes": 5, "viewed": 2214, "published": 3, "date": "1613149731", "time_retrieved": "2024-07-30T19:38:47.621949", "image_code": "/**\n * Modification of the following are used in this shader.\n * - om Function: https://www.shadertoy.com/view/Xt23Ry\n * - Raymarching part1: https://www.shadertoy.com/view/llt3R4\n*/\n\n\n/**\n * Generate random values\n*/\n\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    //I think the value of x is usually comes from 2D/3D coordinates or time in most of applications.\n    //These values are small and continuous.\n    //So, multiply large prime value first.\n    x*=k;\n    //mix x, y, z values.\n    //Without shift operator, x, y and z value become same value.\n    x = ((x>>2u)^(x.yzx>>1u)^x.zxy)*k;\n \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat fade(float value, float start, float end)\n{\n    return (clamp(value,start,end)-start)/(end-start);\n}\nfloat rand(float co) { return fract(sin((co)*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z));}\n// Based on https://www.shadertoy.com/view/XlXcW4, but fewer integer operators.\n// Not testes for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n\n\n\n/*\n * Raymarching\n*/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 dir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 eye = vec3(0., 0., 5.1);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.5,0.5, 0.5, 0.0);\n\t\treturn;\n    }\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float sampling= rand(vec3(uv, iTime));\n    sampling = (sampling > 0.5) ? 1.:0.;\n    //vec3 color = vec3(0., 0.5, 0.5);\n    vec3 color = vec3(1.,1.,1.);\n    color *= sampling;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3BRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[371, 371, 393, 584, 774], [776, 776, 825, 825, 882], [883, 883, 905, 905, 955], [956, 956, 976, 976, 1044], [1045, 1045, 1065, 1065, 1097], [1429, 1518, 1553, 1553, 1593], [1595, 1835, 1869, 1869, 1906], [1908, 2329, 2420, 2420, 2726], [2741, 2995, 3060, 3060, 3192], [3195, 3195, 3252, 3252, 3817]], "test": "untested"}
{"id": "ttcBRX", "name": "Pixels do what pixels gotta do", "author": "jeyko", "description": "pixelato ", "tags": ["gradient", "glitch", "feedback", "sorting"], "likes": 17, "viewed": 519, "published": 3, "date": "1613148736", "time_retrieved": "2024-07-30T19:38:48.386903", "image_code": "void mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n\n    C = 0.5 + 0.5*sin(T(U*0.5*2.)*111. + vec4(3,2,2,3) + iTime*0.1);\n}  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R (iResolution.xy)\n#define T(U) texture(iChannel0, (U)/R)\n#define T1(U) texture(iChannel1, (U)/R)\n#define T2(U) texture(iChannel2, (U)/R)\n#define T3(U) texture(iChannel3, (U)/R)", "buffer_a_code": "\nvoid xch( inout vec4 C, inout vec4 othera, inout vec4 otherb, float positiona, float positionb){\n    if(C[int(positiona)] < othera[int(positionb)]){\n        C = othera;\n        othera = C;\n    } else if(C[int(positiona)] > otherb[int(positionb)]){\n        C = otherb;\n        otherb = C;\n    }\n}\n\n//vec2 getGradient(vec4 C,vec4 n,vec4 s,vec4 e,vec4 w, vec4 indices){\nvec2 getGradient(vec4 C, vec2 U, vec4 indices){\n    float range = 2.;\n    vec4 n = T(U + vec2(0,1)*range);\n    vec4 s = T(U - vec2(0,1)*range);\n    vec4 e = T(U + vec2(1,0)*range);\n    vec4 w = T(U - vec2(1,0)*range);\n    \n    return vec2(n[int(indices.x)] - s[int(indices.y)], e[int(indices.z)] - w[int(indices.w)]);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 muv = (iMouse.xy - 0.5*R)/R.y;\n    vec2 uvn = (U.xy - 0.5*R)/R.y;\n    vec2 uv = U/R;\n\n    //vec2 grad = getGradient(C, n, s, e, w, vec4(1,1,1,1));\n    \n    \n    vec2 grad = getGradient(C, U, vec4(2,2,2,2));\n    \n    U -= grad*(1. + sin(iTime*2.)*2.);\n    \n    \n    C = T(U );\n    \n\n    float m = mod(float(iFrame),3.);\n    \n    float range = 1. + m*1.;\n    vec4 n = T(U + vec2(0,1)*range);\n    vec4 s = T(U - vec2(0,1)*range);\n    vec4 e = T(U + vec2(1,0)*range);\n    vec4 w = T(U - vec2(1,0)*range);\n    \n    xch(C,e,n,0. + m,1.);\n    xch(C,n,w,3. - m,2. - m);\n    xch(C,e,s,1. + m,1. - m);\n    xch(C,n,w,1. + m,4.);\n    xch(C,w,e,2. - m,1. + m);\n    xch(C,w,n,2. - m,3.);\n    xch(C,e,w,1. + m,4.);\n    xch(C,n,s,3. - m,4.);\n    xch(C,s,e,2. - m,2.);\n    \n    if(iFrame % 20 < 1){\n        //xch(C,n,w,1,2);\n    \n    }\n    \n    if(length(grad) < 0.001 )\n        C = mix(C,T1(U + float(iFrame)*R*0.01),1.);\n    /*\n    if(C.x < e.y){\n        C = e;\n    } else if(C.y > w.x){\n        C = w;\n    }\n    */\n    if( false &&iMouse.z != 0. && length(muv - uvn) < 0.2 ){\n        if(C.x < e.y){\n            C = e;\n        } else if(C.y > w.x){\n            C = w;\n        }\n        \n        if(C.z < e.w){\n            C = e;\n        } else if(C.w > w.z){\n            C = w;\n        }\n    \n    }\n    \n    \n    C = mix(C,abs(sin(C*100.))*1.,0.01);\n    \n    if(iFrame % 3 == 0){\n        C = T(U);\n    \n    }\n    \n    if(iFrame == 1){\n        C = T1(U);\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 132]], "test": "untested"}
{"id": "3l3fzf", "name": "construction game", "author": "FabriceNeyret2", "description": "drag and drop bricks", "tags": ["tuto", "draganddrop"], "likes": 10, "viewed": 364, "published": 3, "date": "1613145174", "time_retrieved": "2024-07-30T19:38:49.265554", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R.y, A; \n    O-=O;\n    for ( float x = 0.; x < S; x++ )                            // parse particles\n        for ( float y = 0.; y < S; y++ ) {\n            vec4 T = T(vec2(x,y));\n            A = abs( U - T.xy );\n            if ( max(A.x,A.y) < r ) O += vec4(.5+.5*T.zz,1,1);  // draw particle\n          }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float S  =  4.,                // S² bricks\n            r  = .4/S /2.;           // brick radius\n#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "buffer_a_code": "bool collide(vec2 U, vec2 M) {                                 // --- is current particle colliding ?\n    if ( M.y < r ) return true;                                // collide with floor\n    for ( float x = 0.; x < S; x++ ) \n        for ( float y = 0.; y < S; y++ ) {\n            vec2 P = vec2(x,y), A;\n            if ( P != U-.5 ) { \n                A = abs( M - T(P).xy ); \n                if( max(A.x,A.y) < 2.*r ) return true;        // collide with particle (x,y)     \n            }\n          }\n    return false;                                             // no collision\n }\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( max(U.x,U.y) > S ) return;                           // manage only S² particles\n    if ( iFrame < 1 ) { O = vec4(.5*U/S,0,0); return; }       // init state\n\n    O = T(U);                                                 // restore state\n    vec2 M = iMouse.xy/R.y, D = vec2(0.,1./R.y);  \n\n    if ( iMouse.z < 0. ) O.z = 0.;                            // mouse release\n    else if ( iMouse.w > 0. && length(M-O.xy) < r ) O.z = 1.; // mouse down on me: activate\n    \n    if (O.z > 0.) {                                           // if active particle\n        if ( collide(U,M ) ) return;                          // collision: stop\n        O.xy = M;                                             // no obstactle: follow mouse\n      } else {\n        if ( collide(U,O.xy-D ) ) return;                     // if no collision,\n        O.xy -= D;                                            // free fall\n      }\n      \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3fzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 361]], "test": "untested"}
{"id": "Wl3fRf", "name": "The wind echos.", "author": "YitingLiu", "description": "Using the Soundcloud input to generate windy effects.  ", "tags": ["math", "tutorial", "sin", "rotate", "atan", "cos", "hexagon", "stars", "hex", "tile", "wind", "max", "tan", "cloth", "coordinate", "theartofcode"], "likes": 3, "viewed": 340, "published": 3, "date": "1613140634", "time_retrieved": "2024-07-30T19:38:50.148194", "image_code": "//tutorial https://www.youtube.com/watch?v=VmrIDyYiJBA\n// soundcloud input example: https://www.shadertoy.com/view/MsdGzn\n\nfloat HexDist(vec2 uv){\n  uv=abs(uv);\n  float c = dot (uv, normalize(vec2(1,1.73)));// 1.73 is from sqrt of (2 to the power of 2 - 1 to the power of 2)\n  c=max(c,uv.x);\n    \n   return c;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 HexCoords(vec2 uv){\n    vec2 r = vec2(1.,1.73);\n    vec2 h = r/2.;\n    \n    vec2 a = mod(uv,r)-h;\n    vec2 b = mod(uv-h,r)-h;\n    \n    vec2 gv = dot(a,a)<dot(b,b)?a:b; // shorter version of if statement \n    \n    vec2 id = (uv-gv)*rotate2d(3.1415*cos(iTime/100.));\n   \n    float x = atan(gv.x,gv.y);// which angle the x is at according to the center of y\n    float y = 0.5-HexDist(gv);// center of the hex\n    \n    return vec4(x,y,id.x,id.y);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    float fft  = texture( iChannel0, vec2(uv.x-1.)).x; \n\t\n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x-1.,0.1) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 soundEl = vec3( 1.-fft,0.5*fft*(1.0-fft),fft );// * fft;\n\n    vec3 col = vec3(0);\n    \n    uv*=rotate2d(tan(iTime*0.1))+fft;\n    uv*=10.; \n\n    vec4 hex= HexCoords(uv);\n    float c = smoothstep(.0,1.,hex.y*sin(hex.x+hex.z+iTime));\n    col+=c;\n    \n    col*=abs(uv.y-uv.x)*2.*soundEl;  \n    \n    \n    /**\n    Moving Hex\n    col+=sin(HexDist(uv*10.+iTime));\n\n    */\n    \n    fragColor = vec4(col*(abs(sin(iTime*0.5))+0.1),1.0);\n}", "image_inputs": [{"id": 25361, "src": "https://soundcloud.com/yitingliu/dreamstate", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 146, 146, 311], [313, 313, 341, 341, 427], [429, 429, 453, 453, 879], [881, 881, 938, 938, 1626]], "test": "untested"}
{"id": "WtcBzX", "name": "White Fire", "author": "moranzcw", "description": "A fire shader.", "tags": ["2d", "noise", "flame", "fire", "perlin"], "likes": 4, "viewed": 367, "published": 3, "date": "1613126617", "time_retrieved": "2024-07-30T19:38:51.304114", "image_code": "// White Fire - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hermite(float t)\n{\n  return t * t * (3.0 - 2.0 * t);\n}\n\nfloat noise(vec2 co, float frequency)\n{\n  vec2 v = vec2(co.x * frequency, co.y * frequency);\n\n  float ix1 = floor(v.x);\n  float iy1 = floor(v.y);\n  float ix2 = floor(v.x + 1.0);\n  float iy2 = floor(v.y + 1.0);\n\n  float fx = hermite(fract(v.x));\n  float fy = hermite(fract(v.y));\n\n  float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);\n  float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);\n\n  return mix(fade1, fade2, fy);\n}\n\nfloat perlinNoise(vec2 co, float freq, int steps, float persistence)\n{\n  float value = 0.0;\n  float ampl = 1.0;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    sum += ampl;\n    value += noise(co, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Flame color.\n    vec4 firstColor = vec4(vec3(0.8), 1.0);\n    vec4 secondColor = vec4(vec3(0.9), 1.0);\n    vec4 thirdColor = vec4(vec3(1.0), 1.0);\n    \n    // Uniform scale the coordinates for sampling perlin noise.\n    vec2 pos = fragCoord.xy / iResolution.y;\n    pos.y -= iTime * 0.2;\n    \n    // Perlin noise.\n    float noiseTexel = perlinNoise(pos, 10.0, 5, 0.5);\n    \n    // BackGround color.\n    vec4 color = vec4(vec3(0.7),1.0);\n    \n    // Outer flame.\n    float firstStep = step(noiseTexel, 1.2 - uv.y);\n    color = mix(color, firstColor, firstStep);\n    \n    // Middel flame.\n    float secondStep = step(noiseTexel, pow(1.1 - uv.y,1.3));\n    color = mix(color, secondColor, secondStep);\n    \n    // Inner Flame\n    float thirdStep = step(noiseTexel, pow(1.0 - uv.y, 1.8));\n    color = mix(color, thirdColor, thirdStep);\n    \n\tfragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[153, 153, 174, 174, 246], [248, 248, 272, 272, 308], [310, 310, 349, 349, 762], [764, 764, 834, 834, 1053], [1055, 1055, 1112, 1112, 2018]], "test": "untested"}
{"id": "WlcBRn", "name": "AA Rational Cubic Bezier Fill", "author": "Lichtso", "description": "Drag control points with the mouse (press SHIFT to change their weights).\nUse keys (A, B, C, D) to toggle various rendering styles.", "tags": ["2d", "bezier"], "likes": 7, "viewed": 751, "published": 3, "date": "1613123041", "time_retrieved": "2024-07-30T19:38:52.376247", "image_code": "vec4 lookup_variable(int index) {\n    return texture(iChannel0, vec2(float(index)+0.5, 0.5)/iChannelResolution[0].xy);\n}\n\nbool lookup_keyboard(int index) {\n    return texture(iChannel1, vec2(float(index)+0.5, 2.5)/iChannelResolution[1].xy).x > 0.0;\n}\n\nconst vec3 colors[] = vec3[](\n    vec3(1.0, 0.25, 0.25),\n    vec3(0.62, 1.0, 0.25),\n    vec3(0.25, 1.0, 1.0),\n    vec3(0.62, 0.25, 1.0),\n    vec3(1.0, 0.8, 0.5),\n    vec3(0.9, 0.0, 0.0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Load Control Points\n    mat4 control_points;\n    for(int i = 0; i < 4; ++i) {\n        control_points[i] = lookup_variable(1+i);\n        control_points[i].xy *= control_points[i].z;\n    }\n    mat4 c = control_points * cubic_power_basis;\n    \n    // Load Weight Planes\n    vec3 planes[4];\n    for(int i = 0; i < 4; ++i)\n        planes[i] = lookup_variable(8+i).xyz;\n    \n    // Draw Implicit Curve\n    vec4 weights = sample_planes(planes, fragCoord);\n    fragColor = vec4(\n        vec3(clamp(\n            lookup_keyboard(65)\n                ? 0.5+(weights.x*weights.x*weights.x-weights.y*weights.z*weights.w)*planes[0].z\n                : rational_cubic_bezier(weights),\n            0.0, 1.0\n        )), 1.0\n    );\n    \n    // Draw Dashed Curve\n    if(lookup_keyboard(66))\n        for(float t = -1.0; t <= 2.0; t += 0.05)\n            fragColor.rgb = mix(fragColor.rgb, colors[4],\n                smoothstep(5.0, 3.0, distance(fragCoord, point_at(c, t)))\n            );\n    \n    // Draw Inflection Points with Tangents\n    if(lookup_keyboard(67))\n        for(int i = 0; i < 3; ++i) {\n            vec2 root = lookup_variable(5+i).xy;\n            if(abs(root.y) < ERROR_MARGIN)\n                continue;\n            float param = root.x/root.y;\n            vec2 point = point_at(c, param);\n            vec2 tangent = normalize(tangent_at(c, param));\n            fragColor.rgb = mix(fragColor.rgb, colors[5],\n                clamp(\n                    smoothstep(7.0, 5.0, distance(fragCoord, point))+\n                    smoothstep(2.0, 0.0, abs(dot(point-fragCoord, vec2(-tangent.y, tangent.x))))*\n                    step(abs(dot(point-fragCoord, tangent)), 100.0),\n                0.0, 1.0)\n            );\n        }\n    \n    /* Gradient and tangent at first control point\n    vec2 point = point_at(c, 0.0);\n    vec2 gradient = normalize(implicit_curve_gradient(planes, sample_planes(planes, point)));\n    fragColor.rgb = mix(fragColor.rgb, colors[5],\n        clamp(\n            smoothstep(7.0, 5.0, distance(fragCoord, point))+\n            smoothstep(2.0, 0.0, abs(dot(point-fragCoord, vec2(-gradient.y, gradient.x))))*\n            step(abs(dot(point-fragCoord, gradient)), 100.0),\n        0.0, 1.0)\n    );\n    vec2 tangent = normalize(tangent_at(c, 0.0));\n    fragColor.rgb = mix(fragColor.rgb, colors[5],\n        clamp(\n            smoothstep(7.0, 5.0, distance(fragCoord, point))+\n            smoothstep(2.0, 0.0, abs(dot(point-fragCoord, vec2(-tangent.y, tangent.x))))*\n            step(abs(dot(point-fragCoord, tangent)), 100.0),\n        0.0, 1.0)\n    );*/\n    \n    // Draw Control Points\n    if(!lookup_keyboard(68))\n        for(int i = 0; i < 4; ++i)\n            fragColor.rgb = mix(fragColor.rgb, colors[i],\n                0.8*smoothstep(control_point_radius, control_point_radius-2.0,\n                    distance(fragCoord, control_points[i].xy/control_points[i].z)));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 lookup_variable(int index) {\n    return texture(iChannel0, vec2(float(index)+0.5, 0.5)/iChannelResolution[0].xy);\n}\n\nbool lookup_keyboard(int index) {\n    return texture(iChannel1, vec2(float(index)+0.5, 0.5)/iChannelResolution[1].xy).x > 0.0;\n}\n\nconst vec3 control_point_defaults[] = vec3[](\n    vec3(300.0, 300.0, 1.0),\n    vec3(500.0, 500.0, 1.0),\n    vec3(700.0, 300.0, 5.0),\n    vec3(500.0, 100.0, 1.0)\n);\n\n/*const vec3 control_point_defaults[] = vec3[](\n    vec3(100.0, 400.0, 1.0),\n    vec3(300.0, 400.0, 1.0),\n    vec3(400.0, 300.0, 1.0),\n    vec3(400.0, 100.0, 1.0)\n);*/\n\n/*const vec3 control_point_defaults[] = vec3[](\n    vec3(100.0, 400.0, 1.0),\n    vec3(250.0, 400.0, 1.0),\n    vec3(250.0, 100.0, 1.0),\n    vec3(400.0, 100.0, 1.0)\n);*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int index = int(fragCoord);\n    fragColor = vec4(0.0);\n    if(index >= 8) { // Weight Planes\n        mat4 control_points;\n        for(int i = 0; i < 4; ++i) {\n            control_points[i] = lookup_variable(1+i);\n            control_points[i].xy *= control_points[i].z;\n        }\n        mat4 c = control_points * cubic_power_basis;\n        vec4 ippc;\n        rational_inflection_point_polynomial_coefficients(ippc, c);\n        float discr;\n        vec2 roots[3];\n        rational_inflection_points(discr, roots, ippc);\n        mat4 w;\n        weights(w, control_points, discr, roots, ippc);\n        vec3 planes[4];\n        weight_planes(planes, w, control_points);\n        normalize_implicit_curve_side(planes, c, w);\n        fragColor.xyz = planes[index-8];\n    } else if(index >= 5) { // Inflection Point Polynomial Roots\n        mat4 control_points;\n        for(int i = 0; i < 4; ++i) {\n            control_points[i] = lookup_variable(1+i);\n            control_points[i].xy *= control_points[i].z;\n        }\n        mat4 c = control_points * cubic_power_basis;\n        vec4 ippc;\n        rational_inflection_point_polynomial_coefficients(ippc, c);\n        float discr;\n        vec2 roots[3];\n        rational_inflection_points(discr, roots, ippc);\n        fragColor.xy = roots[index-5];\n    } else if(index >= 1) { // Control Points\n        fragColor = lookup_variable(index);\n        if(fragColor == vec4(0.0))\n            fragColor.xyz = control_point_defaults[index-1];\n        int selected = int(lookup_variable(0).x);\n        if(selected == index) // Position\n            fragColor.xyz = vec3(iMouse.xy, 1.0);\n        else if(selected == index+4) { // Weight\n            vec2 mouse = (iMouse.xy-lookup_variable(index).xy)/iResolution.xy;\n            fragColor.z = mouse.x/mouse.y;\n        }\n    } else if(index == 0) { // Mouse Selection\n        if(iMouse.z > 0.0) {\n            fragColor = lookup_variable(0);\n            if(iMouse.w > 0.0) {\n                int closest_i = 0;\n                float min_dist = control_point_radius;\n                for(int i = 1; i <= 4; ++i) {\n                    float dist = distance(iMouse.xy, lookup_variable(i).xy);\n                    if(min_dist > dist) {\n                        min_dist = dist;\n                        closest_i = i;\n                    }\n                }\n                if(lookup_keyboard(16))\n                    closest_i += 4;\n                if(min_dist < control_point_radius)\n                    fragColor.x = float(closest_i);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float ERROR_MARGIN = 0.0001;\nconst float control_point_radius = 10.0;\n\n// Rendering: Anti-Aliased Fill\n\nfloat quadratic_bezier(in vec2 weights) {\n    float value = weights.x*weights.x - weights.y;\n    vec2 weights_dx = dFdx(weights);\n    vec2 weights_dy = dFdy(weights);\n    vec2 derivative = mat2(\n        weights_dx.x, weights_dy.x,\n        weights_dx.y, weights_dy.y\n    ) * vec2(\n        2.0*weights.x,\n        -1.0\n    );\n    return 0.5+value/length(derivative);\n}\n\nfloat rational_quadratic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        2.0*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5+value/length(derivative);\n}\n\nfloat cubic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        3.0*weights.x*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5+value/length(derivative);\n}\n\nfloat rational_cubic_bezier(in vec4 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z*weights.w;\n    vec4 weights_dx = dFdx(weights);\n    vec4 weights_dy = dFdy(weights);\n    vec4 derivative = mat4(\n        weights_dx.x, weights_dy.x, 0.0, 0.0,\n        weights_dx.y, weights_dy.y, 0.0, 0.0,\n        weights_dx.z, weights_dy.z, 0.0, 0.0,\n        weights_dx.w, weights_dy.w, 0.0, 0.0\n    ) * vec4(\n        3.0*weights.x*weights.x,\n        -(weights.z*weights.w),\n        -(weights.y*weights.w),\n        -(weights.y*weights.z)\n    );\n    return 0.5+value/length(derivative);\n}\n\n// Complex Arithmetic\n\nvec2 complex_conjugate(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\nvec2 complex_multiplication(vec2 a, vec2 b) {\n    return mat2(a.x, a.y, -a.y, a.x) * b;\n    // return vec2(a.x*b.x-a.y*b.y, a.y*b.x+a.x*b.y);\n}\n\nvec2 complex_division(vec2 a, vec2 b) {\n    return complex_multiplication(a, complex_conjugate(b))/dot(b, b);\n    // return vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y)/dot(b, b);\n}\n\nvec2 polar_complex(float radius, float angle) {\n    return radius*vec2(cos(angle), sin(angle));\n}\n\nvec2 complex_exponentiation(vec2 b, vec2 e) {\n    float radius = length(b);\n    float angle = atan(b.y, b.x);\n    return polar_complex(\n        pow(radius, e.x)*exp(-angle*e.y),\n        angle*e.x+log(radius)*e.y\n    );\n}\n\nvec2 complex_exponentiation(vec2 b, float e) {\n    return polar_complex(\n        pow(length(b), e),\n        atan(b.y, b.x)*e\n    );\n}\n\nvec2 complex_square_root(float a) {\n    return (a < 0.0) ? vec2(0.0, sqrt(-a)) : vec2(sqrt(a), 0.0);\n}\n\nvec2 complex_cubic_root(vec2 a) {\n    return complex_exponentiation(a, 1.0/3.0);\n}\n\nvec2 roots_of_unity_3[] = vec2[](\n    vec2(-0.5, -0.5*sqrt(3.0)), // polar_complex(1.0, radians(120.0))\n    vec2(-0.5, 0.5*sqrt(3.0)), // polar_complex(1.0, radians(-120.0))\n    vec2(1.0, 0.0) // polar_complex(1.0, radians(0.0))\n);\n\n// Bezier Curve Evaluation\n\nvec2 point_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    return p.xy/p.z;\n}\n\nvec2 tangent_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    vec4 d1 = c * vec4(0.0, 1.0, 2.0*t, 3.0*t*t);\n    return (d1.xy*p.z-p.xy*d1.z)/(p.z*p.z);\n}\n\nvec2 second_order_derivative_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    vec4 d2 = c * vec4(0.0, 0.0, 2.0, 6.0*t);\n    return (d2.xy*p.z-p.xy*d2.z)/(p.z*p.z);\n}\n\nvec2 third_order_derivative_at(mat4 c, float t) {\n    vec4 p = c * vec4(1.0, t, t*t, t*t*t);\n    vec4 d2 = c * vec4(0.0, 0.0, 2.0, 6.0*t);\n    vec4 d3 = c * vec4(0.0, 0.0, 0.0, 6.0);\n    return (d3.xy*p.z-p.xy*d3.z)/(p.z*p.z*p.z)+(d2.xy*p.z-p.xy*d2.z)/(p.z*p.z);\n}\n\nvec2 implicit_curve_gradient(in vec3 planes[4], in vec4 w) {\n    return planes[0].xy*(3.0*w[0]*w[0])\n          -planes[1].xy*(w[2]*w[3])\n          -planes[2].xy*(w[1]*w[3])\n          -planes[3].xy*(w[1]*w[2]);\n}\n\n// Finding Inflection Points\n\nvoid integral_inflection_point_polynomial_coefficients(out vec4 ippc, in mat4 c) {\n    ippc = normalize(vec4(\n        0.0,\n        -determinant(mat3(c[3].xyz, c[2].xyz, c[0].xyz)),\n        determinant(mat3(c[3].xyz, c[1].xyz, c[0].xyz)),\n        -determinant(mat3(c[2].xyz, c[1].xyz, c[0].xyz))\n    ));\n}\n\nvoid rational_inflection_point_polynomial_coefficients(out vec4 ippc, in mat4 c) {\n    ippc = normalize(vec4(\n        determinant(mat3(c[3].xyz, c[2].xyz, c[1].xyz)),\n        -determinant(mat3(c[3].xyz, c[2].xyz, c[0].xyz)),\n        determinant(mat3(c[3].xyz, c[1].xyz, c[0].xyz)),\n        -determinant(mat3(c[2].xyz, c[1].xyz, c[0].xyz))\n    ));\n}\n\nvoid integral_inflection_points(out float discr, out vec2 roots[3], in vec4 ippc) {\n    discr = 3.0*ippc[2]*ippc[2]-4.0*ippc[1]*ippc[3];\n    if(abs(ippc[1]) < ERROR_MARGIN) {\n        if(abs(ippc[2]) < ERROR_MARGIN) {\n            discr = -1.0;\n            roots = vec2[](\n                vec2(-1.0, 1.0),\n                vec2(1.0, 0.0),\n                vec2(1.0, 0.0)\n            );\n        } else {\n            discr = 1.0;\n            roots = vec2[](\n                vec2(ippc[3], 3.0*ippc[2]),\n                vec2(1.0, 0.0),\n                vec2(1.0, 0.0)\n            );\n        }\n    } else {\n        float d = sqrt(discr * (discr < 0.0 ? -1.0 : 1.0/3.0));\n        roots = vec2[](\n            vec2(ippc[2]+d, 2.0*ippc[1]),\n            vec2(ippc[2]-d, 2.0*ippc[1]),\n            vec2(1.0, 0.0)\n        );\n    }\n}\n\nconst mat4 cubic_power_basis = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    -3.0, 3.0, 0.0, 0.0,\n    3.0, -6.0, 3.0, 0.0,\n    -1.0, 3.0, -3.0, 1.0\n);\n\nconst mat4 inverse_cubic_power_basis = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    1.0, 1.0/3.0, 0.0, 0.0,\n    1.0, 2.0/3.0, 1.0/3.0, 0.0,\n    1.0, 1.0, 1.0, 1.0\n);\n\nvoid rational_inflection_points(out float discr, out vec2 roots[3], in vec4 ippc) {\n    if(abs(ippc[0]) < ERROR_MARGIN) {\n        integral_inflection_points(discr, roots, ippc);\n        return;\n    }\n    vec3 hc = vec3(\n        ippc[0]*ippc[2]-ippc[1]*ippc[1],\n        ippc[1]*ippc[2]-ippc[0]*ippc[3],\n        ippc[1]*ippc[3]-ippc[2]*ippc[2]\n    );\n    discr = 4.0*hc[0]*hc[2]-hc[1]*hc[1];\n    vec2 d = vec2(\n        9.0*(\n            ippc[1]*ippc[1]\n            -ippc[0]*ippc[2]\n        ),\n        27.0*(\n            -2.0*ippc[1]*ippc[1]*ippc[1]\n            +3.0*ippc[0]*ippc[1]*ippc[2]\n            -ippc[0]*ippc[0]*ippc[3]\n        )\n    );\n    vec2 c = complex_square_root(d[1]*d[1]-4.0*d[0]*d[0]*d[0]);\n    c.x += (c.x+d[1] == 0.0) ? -d[1] : d[1];\n    c = complex_cubic_root(0.5*c);\n    float p = (3.0*ippc[0]*ippc[2]-ippc[1]*ippc[1])/(3.0*ippc[0]*ippc[0]);\n    for(int i = 0; i < 3; ++i) {\n        vec2 ci = complex_multiplication(c, roots_of_unity_3[i]);\n        vec2 numerator = 3.0*ippc[1]*ci\n            -complex_multiplication(ci, ci)\n            -vec2(d[0], 0.0);\n        vec2 denominator = 3.0*ippc[0]*ci;\n        roots[i] = vec2(\n            complex_multiplication(numerator, complex_conjugate(denominator)).x,\n            dot(denominator, denominator)\n        );\n    }\n    if(discr < 0.0) {\n        int real_root = int((radians(180.0)-atan(c.y, c.x))/radians(120.0));\n        roots[2] = roots[(real_root+1)%3];\n        float d = sqrt(-discr);\n        roots[0] = vec2(-hc[1]+d, 2.0*hc[0]);\n        roots[1] = vec2(-hc[1]-d, 2.0*hc[0]);\n    }\n}\n\n// Compute Implicit Curve Weights\n\nvec4 weight_derivatives(vec2 roots[3]) {\n    return vec4(\n        roots[0].x*roots[1].x*roots[2].x,\n        -roots[0].y*roots[1].x*roots[2].x-roots[0].x*roots[1].y*roots[2].x-roots[0].x*roots[1].x*roots[2].y,\n        roots[0].x*roots[1].y*roots[2].y+roots[0].y*roots[1].x*roots[2].y+roots[0].y*roots[1].y*roots[2].x,\n        -roots[0].y*roots[1].y*roots[2].y\n    );\n}\n\nvoid weights(out mat4 w, in mat4 control_points, in float discr, in vec2 roots[3], in vec4 ippc) {\n    mat4 F;\n    if(discr == 0.0) {\n        F = mat4(\n            weight_derivatives(vec2[](roots[0], roots[0], roots[2])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[0])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[0])),\n            weight_derivatives(vec2[](roots[2], roots[2], roots[2]))\n        );\n    } else if(discr < 0.0) {\n        F = mat4(\n            weight_derivatives(vec2[](roots[0], roots[1], roots[2])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[1])),\n            weight_derivatives(vec2[](roots[1], roots[1], roots[0])),\n            weight_derivatives(vec2[](roots[2], roots[2], roots[2]))\n        );\n    } else {\n        F = mat4(\n            weight_derivatives(vec2[](roots[0], roots[1], roots[2])),\n            weight_derivatives(vec2[](roots[0], roots[0], roots[0])),\n            weight_derivatives(vec2[](roots[1], roots[1], roots[1])),\n            weight_derivatives(vec2[](roots[2], roots[2], roots[2]))\n        );\n    }\n    w = transpose(F) * inverse_cubic_power_basis;\n}\n\nvoid weight_planes(out vec3 planes[4], in mat4 w, in mat4 control_points) {\n    for(int i = 0; i < 4; ++i) {\n        vec3 a = vec3(control_points[0].xy, w[0][i])/control_points[0].z;\n        vec3 b = vec3(control_points[1].xy, w[1][i])/control_points[1].z;\n        vec3 c = vec3(control_points[2].xy, w[2][i])/control_points[2].z;\n        vec3 n = cross(b-a, c-a);\n        if(dot(n, n) < ERROR_MARGIN) {\n            vec3 d = vec3(control_points[3].xy, w[3][i])/control_points[3].z;\n            n = cross(b-a, d-a);\n        }\n        n /= n.z;\n        planes[i] = vec3(n.xy, -dot(n, a));\n    }\n    // mat4 phi = F * transpose(c) * inverse(c * transpose(c));\n}\n\nvoid normalize_implicit_curve_side(inout vec3 planes[4], in mat4 c, in mat4 w) {\n    vec2 tangent = tangent_at(c, 0.0);\n    vec2 gradient = implicit_curve_gradient(planes, w[0]);\n    float flip_side = step(0.0, dot(vec2(tangent.y, -tangent.x), gradient.xy))*2.0-1.0;\n    for(int i = 0; i < 4; ++i)\n        planes[i] *= flip_side;\n}\n\nvec4 sample_planes(in vec3 planes[4], in vec2 position) {\n    vec4 result;\n    for(int i = 0; i < 4; ++i)\n        result[i] = dot(planes[i], vec3(position, 1.0));\n    return result;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 120], [122, 122, 155, 155, 250], [442, 442, 497, 524, 3384]], "test": "untested"}
{"id": "3t3BRX", "name": "Twisty Glowing Lines", "author": "yozic", "description": "Get twisted.", "tags": ["colorful", "psychedelic", "trippy"], "likes": 10, "viewed": 787, "published": 3, "date": "1613118300", "time_retrieved": "2024-07-30T19:38:53.238940", "image_code": "#define PI 3.141592\n#define LINES 12.\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n  fragColor = vec4(0.);\n  uv /= vec2(1.1 * dot(uv, .01 * uv));\n  for (float i = 0.; i < LINES; i++) {\n    uv *= rotate(iTime / 20.);\n    float x = 8.79 * sin(.01 * uv.x - iTime) * uv.y * 2.1;\n    float y = length(.1 * log(abs(uv)));\n    vec2 p = vec2(x, y);\n    vec3 col = cos(vec3(-2, 0, -1) * PI * 2. / 3. + PI * i * iTime / 10. + i / 70.) * 0.5 + 0.5;\n    fragColor += vec4(21.264 / length(uv - p * 0.9) * col, 2.45);\n  }\n  fragColor.xyz = pow(abs(fragColor.xyz), vec3(2.45));\n  fragColor.w = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 61, 61, 111], [113, 113, 170, 170, 736]], "test": "untested"}
{"id": "tttfR2", "name": "Jello Lights", "author": "yozic", "description": "Almost a stained glass feel too? You decide. ", "tags": ["colorful", "abstract"], "likes": 32, "viewed": 1732, "published": 3, "date": "1613104758", "time_retrieved": "2024-07-30T19:38:54.338002", "image_code": "#define PI 3.141592\n#define ORBS 20.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n  uv *= 279.27;\n  fragColor = vec4(0.);\n  for (float i = 0.; i < ORBS; i++) {\n    uv.y -= i / 1000. * (uv.x); \n    uv.x += i / 0.05 * sin(uv.x / 9.32 + iTime) * 0.21 * cos(uv.y / 16.92 + iTime / 3.) * 0.21;\n    float t = 5.1 * i * PI / float(ORBS) * (2. + 1.) + iTime / 10.;\n    float x = -1. * tan(t);\n    float y = sin(t / 3.5795); \n    vec2 p = (115. * vec2(x, y)) / sin(PI * sin(uv.x / 14.28 + iTime / 10.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (5. + i / 5.)) * 0.5 + 0.5;\n    fragColor += vec4(i / 40. * 55.94 / length(uv - p * 0.9) * col, 3.57);\n  }\n  fragColor.xyz = pow(fragColor.xyz, vec3(3.57));\n  fragColor.w = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 93, 93, 805]], "test": "untested"}
{"id": "wldfzj", "name": "Fast Particle Rendering", "author": "oneshade", "description": "Fast particle rendering using a grid search. I am having trouble keeping the particles from getting lost when I try to change their velocities.", "tags": ["2d", "simulation", "fast", "rendering", "particle"], "likes": 3, "viewed": 237, "published": 3, "date": "1613100366", "time_retrieved": "2024-07-30T19:38:55.219644", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // Start search\n    for (float x=fragCoord.x - SEARCH_SIZE; x < fragCoord.x + SEARCH_SIZE; x++) {\n        for (float y=fragCoord.y - SEARCH_SIZE; y < fragCoord.y + SEARCH_SIZE; y++) {\n            // If the search is within the texture\n            if (x >= 0.0 && x < iChannelResolution[0].x && y >= 0.0 && y < iChannelResolution[0].y) {\n                vec3 particle = texelFetch(iChannel0, ivec2(x, y), 0).xyz;\n                if (particle.z > 0.5) { // There is a particle here\n\n                    // Render the particle\n                    particle.xy *= 5.0;\n                    vec3 color = vec3(sin(particle.x), cos(particle.y * particle.x), cos(particle.y - particle.x));\n                    fragColor.rgb = mix(fragColor.rgb, color, smoothstep(1.0, 0.0, length(fragCoord - vec2(x, y)) - PARTICLE_SIZE * SEARCH_SIZE));\n\n                }\n            }\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float Hash21(in vec2 p) {\n    p += iDate.w;\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\n// vec3(initial velocity, particle exists here)\nvec3 getParticle(in vec2 p) {\n    return vec3(Hash22(p) * 4.0 - 1.0, Hash21(p) > 0.8);\n}\n\n// Update particle velocity given its current velocity and position\nvec2 updateVelocity(in vec2 vel, in vec2 pos) {\n    return vel;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        fragColor.xyz = getParticle(fragCoord);\n    }\n\n    if (iFrame > 0) {\n        if (iFrame % FPU == 0) {\n            // Start search\n            for (float x=fragCoord.x - SEARCH_SIZE; x < fragCoord.x + SEARCH_SIZE; x++) {\n                for (float y=fragCoord.y - SEARCH_SIZE; y < fragCoord.y + SEARCH_SIZE; y++) {\n                    // If the search is within the texture\n                    if (x >= 0.0 && x < iResolution.x && y >= 0.0 && y < iResolution.y) {\n                        vec3 particle = texelFetch(iChannel0, ivec2(x, y), 0).xyz;\n                        if (particle.z > 0.5) { // There is a particle here\n                            vec2 nextPos = vec2(x, y) + particle.xy;\n                            if (length(fragCoord - nextPos) < EPSILON) { // The particle will land in the texel\n                                fragColor.xyz = particle;\n                                fragColor.xy = updateVelocity(particle.xy, fragCoord);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        else {\n            // If it is not time to update, maintain the particle states\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Particle settings:\n#define PARTICLE_SIZE 0.5\n\n// Area that gets searched for particles\n#define SEARCH_SIZE 5.0\n\n// Small error margin\n#define EPSILON 0.5\n\n// Frames per update\n#define FPU 2", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 979]], "test": "untested"}
{"id": "tltfzj", "name": "otra camino-v1", "author": "jorge2017a1", "description": "otra camino-v1", "tags": ["otracaminov1"], "likes": 2, "viewed": 221, "published": 3, "date": "1613098309", "time_retrieved": "2024-07-30T19:38:56.084332", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec3 Puerta1(vec3 p)\n{\n    vec3  res;\n     res = vec3(9999.0, -1.0,-1.0);\n     float sbSup= sdBox( p-vec3(0.0,5.0,0.0), vec3(6.0,1.0,1.0) );\n     float sbInf= sdBox( p-vec3(0.0,-1.0,0.0), vec3(6.0,0.25,3.5) );\n     \n     \n     float sbIzq= sdBox( p-vec3(-5.0,0.0,0.0), vec3(1.0,5.0,1.0) );\n     float sbDer= sdBox( p-vec3(5.0,0.0 ,0.0) , vec3(1.0,5.0,1.0) );\n     res =opU3(res, vec3(sbSup,1.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sbIzq,1.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sbDer,1.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sbInf,1.0,MATERIAL_NO)); \n     \n     return res;\n}\n\nvec3 Puerta2(vec3 p)\n{\n    vec3  res;\n     res = vec3(9999.0, -1.0,-1.0);\n     float sbSup= sdBox( p-vec3(0.0,5.0,0.0), vec3(6.0,1.0,1.0) );\n     float sbInf= sdBox( p-vec3(0.0,-1.0,0.0), vec3(6.0,0.25,4.0) );\n     \n     float sbIzq= sdCylinderXZ( p-vec3(-5.0,0.0,0.0), vec2(1.0,5.0) );\n     float sbDer= sdCylinderXZ( p-vec3(5.0,0.0 ,0.0), vec2(1.0,5.0) );\n     \n     res =opU3(res, vec3(sbSup,11.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sbIzq,11.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sbDer,11.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sbInf,11.0,MATERIAL_NO)); \n     \n     return res;\n}\n\n\n\nvec3 opScalePuerta1( in vec3 p, in float s )\n{  vec3 d1=Puerta1(p/s); d1.x*=s; return d1; }\n\nvec3 opScalePuerta2( in vec3 p, in float s )\n{   vec3 d1=Puerta2(p/s); d1.x*=s; return d1; }\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n   \n    p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0)); \n   \tfloat planeDist1 = p.y+0.0;  //piso inf\n    //res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n    //res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    res =opU3(res, vec3(planeDist1,13.0,-1.0)); //inf\n     p.y=p.y-5.0;\n   \n    vec3 p1=p;\n    vec3 p2=p-vec3(50.0,0.0,0.0);\n\n    p1.x=mod(p1.x, 120.0)-50.0;\n    p2.x=mod(p1.x, 120.0)-60.0;\n    \n    vec3 pa1= opScalePuerta1(  p1, 1.5 );\n    vec3 pa2= opScalePuerta1(  p1, 2.0 );\n    vec3 pa3= opScalePuerta1(  p1, 3.0 );\n    vec3 pa4= opScalePuerta1(  p1, 4.0 );\n    vec3 pa5= opScalePuerta1(  p1, 5.0 );\n    res =opU3(res, pa1); \n    res =opU3(res, pa2); \n    res =opU3(res, pa3); \n    res =opU3(res, pa4); \n    res =opU3(res, pa5); \n    vec3 pb1= opScalePuerta2(  p2, 1.5 );\n    vec3 pb2= opScalePuerta2(  p2, 2.0 );\n    vec3 pb3= opScalePuerta2(  p2, 3.0 );\n    vec3 pb4= opScalePuerta2(  p2, 4.0 );\n    vec3 pb5= opScalePuerta2(  p2, 5.0 );\n    res =opU3(res, pb1); \n    res =opU3(res, pb2); \n    res =opU3(res, pb3); \n    res =opU3(res, pb4); \n    res =opU3(res, pb5); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n   \n    return lin*atten;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3( GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,  GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t \n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*5.0;\n     \n    if (mObj.blnShadow==true)\n    { \tfloat fhadow=GetShadow(p,plight_pos);  \treturn result*fhadow;     }\n    else\n      return result; \n}\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n     return colobj;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 20.0, 10.0 );  light_color1 = vec3( 1.0 );\n \t//light_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n    vec3 ro = rotate_y( vec3(t,0.0,-30.0), radians(-45.))+  vec3(0.0,7.0,0.0);      \n    vec3 rd=normalize(vec3(uv,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd; mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p; mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    //result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    //result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(1.,1.,1.), //1\nvec3(1.,0.,0.),  //2\nvec3(0.,1.,0.),   //3\nvec3(0.,0.,1.),   //4\nvec3(1.,1.,0.),  //5\nvec3(0.,1.,1.),  //6 \nvec3(1.,0.,1),   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(1., 3., 2.0) //31\n\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 435, 435, 456], [457, 457, 489, 489, 573], [576, 576, 615, 615, 710], [711, 711, 750, 750, 845], [846, 846, 885, 885, 980], [982, 1026, 1073, 1073, 1100], [1102, 1102, 1145, 1145, 1172], [1174, 1174, 1222, 1222, 1250], [1298, 1323, 1357, 1357, 1455], [1456, 1456, 1490, 1490, 1582], [1583, 1583, 1617, 1617, 1709], [1710, 1750, 1784, 1784, 1881], [1883, 1883, 1905, 1905, 2470], [2472, 2472, 2494, 2494, 3068], [3072, 3072, 3118, 3118, 3163], [3165, 3165, 3211, 3211, 3257], [3260, 3300, 3325, 3325, 4603], [4606, 4606, 4671, 4671, 5254], [5256, 5307, 5331, 5331, 5496], [5497, 5560, 5593, 5593, 6054], [6056, 6110, 6146, 6146, 6380], [6437, 6437, 6517, 6517, 6773], [6775, 6775, 6868, 6868, 6969], [6971, 7020, 7077, 7077, 8285]], "test": "untested"}
{"id": "ttdBzj", "name": "Black Hole Near Event Horizon", "author": "Ubiquitous", "description": "V1.0, I wanted to simulate a black hole starting to consume a large star. This doesn't seem to work well on mobile.\n\nSources:\n\nhttps://www.shadertoy.com/view/MdtGRl\nhttps://www.shadertoy.com/view/4lSXD1\nhttps://www.shadertoy.com/view/Xsc3R4", "tags": ["space", "galaxy", "blackhole", "disk", "dust", "eventhorizon"], "likes": 3, "viewed": 412, "published": 3, "date": "1613093990", "time_retrieved": "2024-07-30T19:38:56.852279", "image_code": "// \"Black Hole Near Event Horizon\" by Ubiquitous, thanks Duke!\n// \n//-------------------------------------------------------------------------------------\n// Based on \"Protoplanetary Disk\" (https://www.shadertoy.com/view/MdtGRl)\n// In addition to \"Dusty nebula 1\" (https://www.shadertoy.com/view/4lSXD1) \n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------------\n\n//#define MOUSE_CAMERA_CONTROL\n\n// comment this string to see fluffy clouds\n#define DENSE_DUST\n\n#define DITHERING\n#define BACKGROUND\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat2 Spin(float angle)\n{\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(2.0,4.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 2.8)/256.0, 2.5 ).yx;\n\treturn -1.0+0.7*mix( rg.x, rg.y, f.z );\n}\n\nfloat fpn(vec3 p)\n{\n   return pn(p*.06125)*.5 + pn(p*.125)*.15 + pn(p*.15)*.225;// + pn(p*.5)*.625;\n}\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co*0.123,vec2(2.9898,1.233))) * 63758.5453);\n}\n\nfloat Ring(vec3 p)\n{\n  vec2 q = vec2(length(p.xy)-5.3,p.z);\n  return length(q)-0.51;\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n\nfloat Disk( vec3 p, vec3 t )\n{\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.15);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.45 + 0.14*(b-a)/k, 1.250, 0.250 );\n\treturn mix( b, a, h ) - k*h*(2.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float t=0.23*iTime;\n\tfloat d1 = Disk(p,vec3(2.75,0.88,0.45)) + fpn(vec3(Spin(t*3.25+p.z*1.20)*p.xy*24.,p.z*25.-t)*5.0) * 0.845;\n    float d2 = Ring(p);\n    return smin(d1,d2,1.52);\n\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( 0.6*vec3(0.26,0.5,0.4), vec3(0.8,0.25,0.1), density );\n\t\n\t// color added for disk\n\tvec3 colCenter = 2.*vec3(0.22,0.6,0.5);\n\tvec3 colEdge = 3.*vec3(0.08,0.23,0.5);\n\tresult *= mix( colCenter, colEdge, min( (radius+.2)/1.0, 0.25 ) );\n\t\n\treturn result;\n}\n\nbool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5\n\tfloat a = dot(dir.xy, dir.xy);\n\tfloat b = dot(org.xy, dir.xy);\n\tfloat c = dot(org.xy, org.xy) - 11.;\n\n\tfloat delta = b * b - a * c;\n\tif( delta < 0.15 )\n\t\treturn false;\n\n\t// 2 roots\n\tfloat deltasqrt = sqrt(delta);\n\tfloat arcp = 1.1 / a;\n\tnear = (-b - deltasqrt) * arcp;\n\tfar = (-b + deltasqrt) * arcp;\n\t\n\t// order roots\n\tfloat temp = min(far, near);\n\tfar = max(far, near);\n\tnear = temp;\n\n\tfloat znear = org.z + near * dir.z;\n\tfloat zfar = org.z + far * dir.z;\n\n\t// top, bottom\n\tvec2 zcap = vec2(9.15, -2.85);\n\tvec2 cap = (zcap - org.z) / dir.z;\n\n\tif ( znear < zcap.y )\n\t\tnear = cap.y;\n\telse if ( znear > zcap.x )\n\t\tnear = cap.x;\n\n\tif ( zfar < zcap.y )\n\t\tfar = cap.y;\n\telse if ( zfar > zcap.x )\n\t\tfar = cap.x;\n\t\n\treturn far > 2.5 && far > near;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    const float KEY_1 = 49.5/256.0;\n\tconst float KEY_2 = 50.5/256.0;\n\tconst float KEY_3 = 51.5/256.0;\n    float key = 0.7;\n    key += 0.7*texture(iChannel1, vec2(KEY_1,0.25)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_2,0.15)).x;\n    key += 0.7*texture(iChannel1, vec2(KEY_3,0.25)).x;\n\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y, 2.5));\n\tvec3 ro = vec3(1.1, 1.2, -6.+key*0.2);\n\n    #ifdef MOUSE_CAMERA_CONTROL\n    R(rd.yz, -iMouse.y*0.01*pi*4.);\n    R(rd.xz, iMouse.x*0.041*pi*2.);\n    R(ro.yz, -iMouse.y*0.01*pi*4.);\n    R(ro.xz, iMouse.x*0.041*pi*2.);\n    #else\n    R(rd.yz, -pi*3.65);\n    R(rd.xz, pi*3.2);\n    R(ro.yz, -pi*3.65);\n   \tR(ro.xz, pi*3.2);    \n    #endif \n    \n    #ifdef DITHERING\n\tvec2 dpos = ( fragCoord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n   \t// randomizing the length \n    //rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \n\t#endif \n    \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0.48, td=0.23, w=1.04;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=21.8, t=21.2;\n   \n\tvec4 sum = vec4(0.1);\n   \n    float min_dist=2.52, max_dist=222.5;\n\n    if(Raycylinderintersect(ro, rd, min_dist, max_dist))\n    {\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n\tfor (int i=0; i<36; i++) \n\t{\n\t \n\t\tvec3 pos = ro + t*rd;\n\n\t\tfloat fld = 0.40;\n       \n\t\t// Loop break conditions.\n        if(td>(0.9-1./7.) || d<0.008*t || t>13. || sum.a > 0.99 || t>max_dist) break;\n\t  \n\t\t// evaluate distance function\n\t\td = map(pos); \n       \n\t\t// direction to center\n\t\tvec3 stardir = normalize(vec3(3.4)-pos);\n      \n\t\t// change this string to control density \n\t\td = max(d,0.04);\n      \n\t\tif (d<0.1) \n\t\t{\n\t\t\t// compute local density \n\t\t\tld = 0.2 - d;\n\t\t\t\n            #ifdef DENSE_DUST          \n\t\t\tfld = clamp((ld - map(pos+4.2*stardir))/1.4, 0.22, 1.3 );\n\t\t\tld += fld;\n            #endif\n \t\t\t\n            // compute weighting factor \n\t\t\tw = (1.4 - td) * ld;\n     \n\t\t\t// accumulate density\n\t\t\ttd += w + 2./3.;\n\t\t\n\t\t\tfloat radiusFromCenter = length(pos - vec3(0.5));\n\t\t\tvec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\t\t\n\t\t\t// uniform scale density\n\t\t\tcol.a *= 1.02;\n\t\t\t// colour by alpha\n\t\t\tcol.rgb *= col.a/11.08;\n\t\t\t// alpha blend in contribution\n\t\t\tsum = sum + col*(1.08 - sum.a);  \n\t\t}\n      \n\t\ttd += 1./110.;\n       \n        // point light calculations\n        vec3 ldst = vec3(1.32)-pos;\n        float lDist = max(length(ldst), 0.021);\n\n        // star in center\n        vec3 lightColor=vec3(0.81,0.31,0.15);\n        sum.rgb+=lightColor/(lDist*lDist*lDist*7.);//*10.); //add a bloom around the light\n\n        // using the light distance to perform some falloff\n        //float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\n        // accumulating the color\n        //sum += w*atten*fld;\n       \n        // enforce minimum stepsize\n        d = max(d, 0.24); \n      \n        #ifdef DITHERING\n        // add in noise to reduce banding and create fuzz\n        d=abs(d)*(1.+0.58*rand(seed*vec2(i)));\n        #endif \n\t  \n        t +=  max(d * 0.13, 0.19);\n      \n\t}\n    \n    //scattering test\n\t//sum *= 1. / exp( ld * 0.2 ) * 1.05;\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-1.0*sum.xyz);\n    \n\t}\n\n    #ifdef BACKGROUND\n    // stars background\n    if (td<1.8)\n    {\n        vec3 stars = vec3(pn(rd*100.0)*0.4+0.5);\n        vec3 starbg = vec3(0.0);\n        starbg = mix(starbg, vec3(0.1,0.3,0.2), smoothstep(0.99, 1.0, stars)*clamp(dot(vec3(0.4),rd)+0.75,0.4,1.0));\n        starbg = clamp(starbg, 0.0, 1.0);\n        sum.xyz += starbg; \n    }\n\t#endif\n    \n   fragColor = vec4(sum.xyz,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[843, 843, 867, 867, 929], [931, 945, 968, 968, 1184], [1186, 1186, 1205, 1205, 1287], [1289, 1289, 1310, 1310, 1379], [1381, 1381, 1401, 1401, 1467], [1469, 1469, 1494, 1494, 1531], [1533, 1533, 1558, 1558, 1623], [1626, 1626, 1656, 1656, 1753], [1755, 1755, 1796, 1796, 1891], [1893, 1893, 1912, 1912, 2100], [2102, 2131, 2181, 2266, 2537], [2539, 2539, 2617, 2700, 3446], [3448, 3448, 3505, 3505, 7225]], "test": "untested"}
{"id": "tltBzj", "name": "Fractal mercury pool", "author": "jarble", "description": "mouse x controls fractal loop", "tags": ["fractal"], "likes": 6, "viewed": 280, "published": 3, "date": "1613090508", "time_retrieved": "2024-07-30T19:38:57.625212", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n         u = -u.yx;\n         u += vec2(1.,0.);\n    vec2 v = u;\n         u = u/dot(u,u);\n    \n    float t = 8.0;\n    if(iMouse.z > 0.) t = 10.*iMouse.x/iResolution.x;\n\n    float pi = 3.14159265359;\n    vec4 sum = vec4(0.);\n    for(float i = 0.; i < t; ++i)\n    {\n        u /= cos(u.y-vec2(.0,.5*pi))*exp(sin(u.x+iTime));\n        u+= v;\n        sum+= (1.0+.5*cos(i*4.+vec4(0,1,2,0)))/length(u);\n    }\n    fragColor = sqrt(sum)*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 550]], "test": "untested"}
{"id": "WtdBz2", "name": "6-Minute Ray-Marcher", "author": "Zi7ar21", "description": "Speedrun 6-Minutes Ray-Marcher because I got done with my math test early and I had time to screw around", "tags": ["ray", "raymarch", "raymarcher", "speedrun"], "likes": 3, "viewed": 245, "published": 3, "date": "1613079658", "time_retrieved": "2024-07-30T19:38:58.390167", "image_code": "#define camfov 1.0\n#define maxmarches 128U\n#define collisiondist 1e-2\n#define scenesize 32.0\n\nfloat DE(vec3 raypos){\n    return length(raypos)-0.5;\n}\n\nvec3 raymarch(vec3 raydir, vec3 raypos){\n    float distest;\n    for(uint i = 0U; i < maxmarches; i++){\n        distest = DE(raypos);\n        if(distest < collisiondist){return vec3(1.0);}\n        raypos += raydir*distest;\n        if(length(raypos) > scenesize){break;}\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n    fragColor = vec4(raymarch(raydir, vec3(0.0, 0.0, -2.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 116, 116, 149], [151, 151, 191, 191, 449], [451, 451, 505, 505, 806]], "test": "untested"}
{"id": "3ttBz2", "name": "the_tunnel", "author": "YitingLiu", "description": "trippy effect of the tunnel in space ", "tags": ["tunnel", "uv", "circle", "space", "trippy", "smoothstep", "rotation", "white", "gif", "length", "black"], "likes": 5, "viewed": 299, "published": 3, "date": "1613077584", "time_retrieved": "2024-07-30T19:38:59.155122", "image_code": "//tutorial https://www.youtube.com/watch?v=cQXAbndD5CQ\n\nfloat Xor(float a, float b){\n    return a*(1.-b)+b*(1.-a);\n    }\n\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*2.;\n\n    vec3 col =vec3(0);\n    \n    uv*=18.;\n    uv*=Rot(3.14+t/10.);\n\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float m =0.;\n    id*=1.5*Rot(3.14/2.+t);\n\n    for (float y=-1.;y<=1.;y++){\n        for (float x=-1.;x<=1.;x++){\n        vec2 offs = vec2(x,y);\n        float d = length(gv-offs);\n        float dist =length(id+offs)*abs(sin(t/5.)*1.5);\n\n        float r = mix(.1,2.5,cos(dist-t)*.5+.5);\n        m +=Xor(m,smoothstep(r,r*.1,d));\n        \n        }\n    }\n\n    col+=1.-m;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 84, 84, 120], [122, 122, 140, 140, 214], [215, 215, 272, 272, 884]], "test": "untested"}
{"id": "wl3fz2", "name": "Tiny Raymarcher", "author": "oneshade", "description": "Can you make it smaller?", "tags": ["3d", "raymarching", "sphere", "sky", "codegolf"], "likes": 5, "viewed": 142, "published": 3, "date": "1613064706", "time_retrieved": "2024-07-30T19:38:59.923069", "image_code": "/* Shorter version by jarble, -3 chars (221 chars) */\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, d = normalize(vec3((u + u - R.xy) / R.y, 1)), p;\n    float t = 0., s;\n    for (int i=0; i++ < 99; t += s)\n        p = d * t, p.z -= 5., s = length(p) - 2.7;\n        o =  (s < .1) ? vec4(p.y - p.z - p.x, 0, 0, 1) / 4.5:vec2(.62 + .38 * d.y, 1).xxyy;\n}\n/**/\n\n/* Shorter version by oneshade, -2 chars (224 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, d = normalize(vec3((u + u - R.xy) / R.y, 1)), p;\n    o = vec2(.62 + .38 * d.y, 1).xxyy;\n    float t = 0., s;\n    for (int i=0; i++ < 99; t += s)\n        p = d * t, p.z -= 5., s = length(p) - 2.7;\n        if (s < .1) o = vec4(p.y - p.z - p.x, 0, 0, 1) / 4.5;\n}\n**/\n\n/* Shorter version by blackle, -7 chars! (226 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, d = normalize(vec3((u + u - R.xy) / R.y, 1)), p;\n    o = vec2(0.62 + 0.38 * d.y, 1).xxyy;\n    float t = 0., s;\n    for (int i=0; i++ < 99; t += s)\n        p = d * t, p.z -= 5., s = length(p) - 2.7;\n        if (s < .1) o = vec4(p.y - p.z - p.x, 0, 0, 1) / 4.5;\n}\n**/\n\n/* Shorter version by oneshade ;), -3 chars (233 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, d = normalize(vec3((u + u - R.xy) / R.y, 1)), p;\n    o = mix(vec2(.62, 1), vec2(1), d.y).xxyy;\n    float t = 0., s;\n    for (int i=0; i++ < 99; t += s)\n        p = d * t, p.z -= 5., s = length(p) - 2.7;\n        if (s < .1) o = vec4(p.y - p.z - p.x, 0, 0, 1) / 4.5;\n}\n**/\n\n/* Shorter version by blackle, -3 chars (236 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, d = normalize(vec3((u + u - R.xy) / R.y, 1)), p;\n    o = mix(vec4(1, 1, 4, 4) / 8. + .5, vec4(1), d.y);\n    float t = 0., s;\n    for (int i=0; i++ < 99; t += s)\n        p = d * t, p.z -= 5., s = length(p) - 2.7;\n        if (s < .1) o = vec4(p.y - p.z - p.x, 0, 0, 1) / 4.5;\n}\n**/\n\n/* Original code (239 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, d = normalize(vec3((u + u - R.xy) / R.y, 1)), p;\n    o = mix(vec4(1, 1, 4, 4) / 4., vec4(1), .5 + .5 * d.y);\n    float t = 0., s;\n    for (int i=0; i++ < 99; t += s)\n        p = d * t, p.z -= 5., s = length(p) - 2.7;\n        if (s < .1) o = vec4(p.y - p.z - p.x, 0, 0, 1) / 4.5;\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 90, 90, 367]], "test": "untested"}
{"id": "tt3Bz2", "name": "Clooud City", "author": "eiffie", "description": "reupload - Clooooouds!", "tags": ["clooouds"], "likes": 38, "viewed": 2270, "published": 3, "date": "1613058766", "time_retrieved": "2024-07-30T19:39:00.688025", "image_code": "//cloud city by eiffie\n#define size iResolution \n#define time iTime \n \nfloat focalDistance=1.0,aperture=0.01,shadowCone=0.3; \n \nfloat Rect(in vec3 z, vec3 r){return max(abs(z.x)-r.x,max(abs(z.y)-r.y,abs(z.z)-r.z));} \n#define TAO 6.283 \nvoid Kaleido(inout vec2 v,float power){float a=floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power;v=cos(a)*v+sin(a)*vec2(v.y,-v.x);} \n \n// See https://iquilezles.org/articles/morenoise \nfloat hash(float n) {return fract(sin(n) * 4378.54533);} \nfloat noyz(vec3 x) { \n vec3 p=floor(x),j=fract(x); \n const float tw=7.0,tx=13.0; \n float n=p.x+p.y*tw+p.z*tx; \n float a=hash(n),b=hash(n+1.0),c=hash(n+tw),d=hash(n+tw+1.0); \n float e=hash(n+tx),f=hash(n+1.0+tx),g=hash(n+tw+tx),h=hash(n+1.0+tw+tx); \n vec3 u=j*j*(3.0-2.0*j); \n return mix(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,e+(f-e)*u.x+(g-e)*u.y+(e-f-g+h)*u.x*u.y,u.z); \n} \n \nfloat fbm(vec3 p) { \n float h=noyz(p); \n h+=0.5*noyz(p*=2.3); \n return h+0.25*noyz(p*2.3);\n} \n \nvec4 mcol=vec4(0.0); \nconst float scl=0.08; \n \nfloat DE(vec3 z0){ \n float dW=100.0,dD=100.0; \n float dC=fbm(z0*0.25+vec3(100.0))*0.5+sin(z0.y)*0.1+sin(z0.z*0.4)*0.1+min(z0.y*0.04+0.1,0.1); \n vec2 v=floor(vec2(z0.x,abs(z0.z))*0.5+0.5); \n z0.xz=clamp(z0.xz,-2.0,2.0)*2.0-z0.xz; \n float r=length(z0.xz); \n float dS=r-0.6; \n if(r<1.0){ \n  float shape=0.285-v.x*0.02;//0.21-0.36 \n  z0.y+=v.y*0.2; \n  vec3 z=z0*10.0; \n  dS=max(z0.y-2.5,r-max(0.11-z0.y*0.1,0.01)); \n  float y2=max(abs(abs(mod(z.y+0.5,2.0)-1.0)-0.5)-0.05,abs(z.y-7.1)-8.3); \n  float y=sin(clamp(floor(z.y)*shape,-0.4,3.4))*40.0; \n  Kaleido(z.xz,8.0+floor(y));\n  dW=Rect(z,vec3(0.9+y*0.1,22.0,0.9+y*0.1))*scl; \n  dD=max(z0.y-1.37,max(y2,r*10.0-1.75-sin(clamp((z.y-0.5)*shape,-0.05,3.49))*4.0))*scl; \n  dS=min(dS,min(dW,dD)); \n } \n dS=min(dS,dC); \n if(dS==dW)mcol+=vec4(0.8,0.9,0.9,1.0);//+a for reflection \n else if(dS==dD)mcol+=vec4(0.6,0.4,0.3,0.0); \n else if(dS==dC)mcol+=vec4(1.0,1.0,1.0,-1.0);//-a for clouds \n else mcol+=vec4(0.7+sin(z0.y*100.0)*0.3,1.0,0.8,0.0); \n return dS; \n} \n \nfloat pixelSize; \nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t \n return max(abs(focalDistance-t)*aperture,pixelSize*(1.0+t)); \n} \nmat3 lookat(vec3 fw,vec3 up){ \n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw); \n} \nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam \n//random seed and generator \nfloat randSeed;\nfloat randStep(){//a simple pseudo random number generator based on iq's hash \n return  (0.8+0.2*fract(sin(++randSeed)*4375.54531)); \n} \n \nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){ \n float t=rCoC*2.0,d=1.0,s=1.0; \n for(int i=0;i<6;i++){ \n  if(s<0.1)continue; \n  float r=rCoC+t*coneGrad;//radius of cone \n  d=DE(ro+rd*t)+r*0.4; \n  s*=linstep(-r,r,d); \n  t+=abs(d)*randStep(); \n } \n return clamp(s*0.75+0.25,0.0,1.0); \n} \n \nvoid mainImage(out vec4 O, in vec2 U) {\n randSeed=fract(sin(time+dot(U,vec2(9.123,13.431)))*473.719245);\n pixelSize=2.0/size.y; \n float tim=time*0.25; \n vec3 ro=vec3(cos(tim),sin(tim*0.7)*0.5+0.3,sin(tim))*(1.8+.5*sin(tim*.41)); \n vec3 rd=lookat(vec3(0.0,0.6,sin(tim*2.3))-ro,vec3(0.1,1.0,0.0))*normalize(vec3((2.0*U.xy-size.xy)/size.y,2.0)); \n vec3 L=normalize(vec3(0.5,0.75,-0.5)); \n vec4 col=vec4(0.0);//color accumulator \n float t=DE(ro)*randSeed*.8;//tep();//distance traveled \n ro+=rd*t; \n for(int i=0;i<72+min(iFrame,0);i++){//march loop \n  if(col.w>0.9 || t>20.0)continue;//bail if we hit a surface or go out of bounds \n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC \n  float d=DE(ro); \n  float fClouds=max(0.0,-mcol.a); \n  if(d<max(rCoC,fClouds*0.5)){//if we are inside add its contribution \n   vec3 p=ro; \n   if(fClouds<0.1)p-=rd*abs(d-rCoC);//back up to border of CoC \n   vec2 v=vec2(rCoC*0.333,0.0);//use normal deltas based on CoC radius \n   vec3 N=normalize(vec3(-DE(p-v.xyy)+DE(p+v.xyy),-DE(p-v.yxy)+DE(p+v.yxy),-DE(p-v.yyx)+DE(p+v.yyx))); \n   if(N!=N)N=-rd; \n   mcol*=0.143; \n   vec3 scol; \n   float alpha; \n   if(fClouds>0.1){//clouds \n    float dn=clamp(0.5-d,0.0,1.0);dn=dn*2.0;dn*=dn;//density \n    alpha=(1.0-col.w)*dn; \n    scol=vec3(1.0)*(0.6+dn*dot(N,L)*0.4); \n    scol+=dn*max(0.0,dot(reflect(rd,N),L))*vec3(1.0,0.5,0.0); \n     \n   }else{ \n    scol=mcol.rgb*(0.2+0.4*(1.0+dot(N,L))); \n    scol+=0.5*pow(max(0.0,dot(reflect(rd,N),L)),32.0)*vec3(1.0,0.5,0.0); \n    if(d<rCoC*0.25 && mcol.a>0.9){//reflect the ray if we hit a bulb \"directly enough\" \n     rd=reflect(rd,N);d=-rCoC*0.25;ro=p;t+=1.0; \n    } \n    scol*=FuzzyShadow(p,L,shadowCone,rCoC); \n    alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-d-0.5*rCoC);//calculate the mix like cloud density \n   } \n   col+=vec4(scol*alpha,alpha);//blend in the new color \n  } \n  mcol=vec4(0.0);//clear the color trap \n  d=abs(d+0.33*rCoC)*randStep();//add in noise to reduce banding and create fuzz \n  ro+=d*rd;//march \n  t+=d; \n }//mix in background color \n vec3 scol=vec3(0.4,0.5,0.6)+rd*0.05+pow(max(0.0,dot(rd,L)),100.0)*vec3(1.0,0.75,0.5); \n col.rgb+=scol*(1.0-clamp(col.w,0.0,1.0)); \n \n O = vec4(clamp(col.rgb,0.0,1.0),1.0); \n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3Bz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 158, 158, 215], [236, 236, 275, 275, 362], [366, 416, 437, 437, 472], [474, 474, 494, 494, 849], [853, 853, 872, 872, 945], [996, 996, 1014, 1014, 1992], [2014, 2014, 2047, 2110, 2175], [2177, 2177, 2206, 2206, 2304], [2306, 2306, 2347, 2347, 2380], [2469, 2469, 2486, 2547, 2604], [2608, 2608, 2672, 2672, 2910], [2914, 2914, 2953, 2953, 5117]], "test": "untested"}
{"id": "wlcfR2", "name": "Bliss Function", "author": "eiffie", "description": "True bliss isn't from a magic formula or a labor of love. Its a glitch, a hack and most likely a random domain distortion with sine waves... always from a kali preset.", "tags": ["bliss"], "likes": 30, "viewed": 675, "published": 3, "date": "1613057955", "time_retrieved": "2024-07-30T19:39:01.480903", "image_code": "//Bliss Function by eiffie\n#define time iTime\n#define rez iResolution\n\nvec3 mcol=vec3(0.0);\nfloat t=0.;\nfloat DE(vec3 p0){\n  vec3 pc=sin(p0.yzx*vec3(1,1.3,1.7)+vec3(time));\n  if(mcol.x>0.0)mcol+=vec3(0.5)+0.5*pc;\n  vec4 p=vec4(mod(p0+pc*.2,2.)-1.,1.5-t/20.);\n  vec3 c=vec3(.97,.65,1)*-4.0;\n  for(int n=0;n<3;n++){\n    p.xyz=abs(p.xyz+1.0)-1.0;\n    p*=2.0/clamp(dot(p.xyz,p.xyz),0.,1.);\n    if(p.x>p.y)p.xy=p.yx;\n    p.xyz+=c;\n  }\n  p=abs(p);\n  return (max(p.x-.2,p.y-1.))/p.w;\n}\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=0.5*dot(rd,L)+0.5;\n  vec3 bg=mix(vec3(.4,.5,.7),vec3(.7,.5,.1),d);\n  bg=mix(bg,vec3(1.,.9,0.),pow(d,40.));\n  vec3 c=sin(rd*7.+2.*sin(rd.yzx*7.+2.*sin(7.*rd.zxy)));\n  d=(c.x+c.y+c.z)*.15;\n  bg=mix(bg,vec3(max(.75,(c.x+c.y+c.z)*.27)),d);\n  return bg;\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  t=DE(ro)*rnd;\n  float d,px=1.0/rez.x,stop=10.+sin((rd.x+rd.y+rd.z)*3.)*2.;\n  for(int i=0;i<99;i++){\n    t+=d=DE(ro+rd*t);\n    if(t>stop || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.4,0.025,0.5));\n  vec3 col=sky(rd,L);\n  if(d<px*t*5.0){\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    vec3 N=normal(so,d);\n    vec3 scol=mcol*0.25;\n    float dif=0.5+0.5*dot(N,L);\n    float vis=clamp(dot(N,-rd),0.05,1.0);\n    float fr=pow(1.-vis,5.0);\n    float shad=ShadAO(so,L);\n    col=(scol*dif+fr*sky(reflect(rd,N),L))*shad;\n  }\n  return col;\n}\nmat3 lookat(vec3 fw){\n   fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(vec3(.2,.8,.2))));\n   return mat3(rt,cross(rt,fw),fw);\n}\nvec3 path(float tim){return vec3(sin(tim),sin(tim*.3),cos(tim))*10.;}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*rez.xy)/rez.x;\n  randomize(U);\n  float tim=time*.15;\n  vec3 ro=path(tim);\n  vec3 rd=lookat(path(tim+1.)-ro)*normalize(vec3(uv.xy,1.0));\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 4.5\nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);}\nvec2 nofs(float n){//the song's \"random\" ring\n  float r=0.5+0.5*rnd(floor(n));\n  n=mod(n,8.0);\n  if(n<1.0)n= 1.0;\n  else if(n<2.0)n= 3.0;\n  else if(n<3.0)n= 5.0;\n  else if(n<4.0)n= 7.0;\n  else if(n<5.0)n= 5.0;\n  else if(n<6.0)n= 3.0;\n  else if(n<7.0)n= 1.0;\n  else n=0.0;\n  return vec2(n,r);\n}\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.);\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//major\n if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100;//pentatonic minor\n //if((n2==1.)||(n2==2.)||(n2==4.)||(n2==8.)||(n2==9.)||(n2==11.))note=-100.;//blues \n //if((n2==1.)||(n2==2.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//country\n //if((n2==1.)||(n2==4.)||(n2==7.)||(n2==10.))note=-100.;//diminished whole/half\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==6.)||(n2==8.)||(n2==10.)||(n2==11.))note=-100.;//pentatonic major\n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//harmonic minor\n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//melodic minor ascending\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//whole tone\n //if((n2==2.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//diminished half/whole\n //if((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//mixolydian  \n //if((n2==1.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==11.))note=-100.;//dorian\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==10.))note=-100.;//lydian  \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian\n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==11.))note=-100.;//Phrygian Major\n //if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian\n //if((n2==2.)||(n2==4.)||(n2==7.)||(n2==9.)||(n2==11.))note=-100.;//lydian dominant\n //if((n2==2.)||(n2==3.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//double harmonic\n //if((n2==2.)||(n2==3.)||(n2==5.)||(n2==7.)||(n2==9.))note=-100.;//enigmatic\n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==8.)||(n2==10.))note=-100.;//neapolitan \n //if((n2==2.)||(n2==4.)||(n2==6.)||(n2==9.)||(n2==10.))note=-100.;//neapolitan minor\n //if((n2==1.)||(n2==4.)||(n2==5.)||(n2==9.)||(n2==10.))note=-100.;//hungarian minor\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nconst float PI=3.14159;\nfloat Cos(float a){return cos(mod(a,PI*2.));}\nfloat Sin(float a){return Cos(a+PI/2.);}\nstruct instr{float att,fo,vibe,vphas,phas,dtun;};\nvec2 I(float n,float t,float bt,instr i){//note,time,bt 0-8,instrument\n float f=ntof(scale(n));if(f<12.)return vec2(0.0);f-=bt*i.dtun;f*=t*PI*2.;\n f=exp(-bt*i.fo)*(1.0-exp(-bt*i.att))*Sin(f+Cos(bt*i.vibe*PI/8.+i.vphas*PI/2.)*Sin(f*i.phas))*(1.0-bt*0.125);\n n+=t;return vec2(f*Sin(n),f*Cos(n));\n}\nvec2 mainSound(int samp, float time){\n instr epiano=instr(20.0,0.05,1.5,0.1,0.505,0.001);\n instr sitar=instr(30.0,0.25,0.1,0.0,0.25125,0.005);\n instr kettledrum=instr(50.0,0.5,4.0,0.75,1.0,0.0125);\n instr hihat=instr(100.0,1.0,100.5,0.0,1.3131,100.0);\n instr ebongo=instr(500.0,2.0,100.5,0.0,1.333,2.0);\n instr bass=instr(20.0,0.2,1.5,0.0,0.2525,0.005);\n float tim=time*bps;\n vec2 a=vec2(0);//accumulator\n for(float i=0.;i<8.;i+=1.){//go back 8 beats and add note tails\n   float b0=floor(tim),b1=floor(tim*0.5),b2=floor(tim*0.25);\n   float t0=fract(tim),t1=fract(tim*0.5)*2.0,t2=fract(tim*0.25)*4.0;\n   vec2 n2=nofs(b2*0.125)+nofs(b2*0.5)+nofs(b2);\n   vec2 n1=n2+nofs(b1),n0=n1+nofs(b0);\n   a+=I(n0.x+72.0,time,t0+i,sitar)*n0.y*0.15;\n   a+=I(n0.x+73.0,time+Sin((t0+i)*222.0),t0+i,hihat)*n0.y*0.05;\n   if(mod(i,2.)<1.){//notes that play every 2 beats\n     a+=I(n1.x+56.0,time,t1+i,epiano)*n1.y;\n     a+=I(n1.x+60.0,time,t1+i,epiano)*n1.y;\n     a+=I(n1.x+63.0,time,t1+i,ebongo)*n1.y*.75;\n     if(mod(i,4.)<1.){//every 4\n       a+=I(n2.x+56.0,time,t2+i,bass)*n2.y*4.0;\n       a+=I(n2.x+48.0,time,t2+i,kettledrum)*n2.y*4.0;\n     }\n   }\n   tim-=1.;\n }\n return clamp(a/256.0,-1.,1.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 122, 122, 478], [479, 479, 508, 518, 654], [655, 655, 681, 681, 942], [954, 954, 980, 980, 1053], [1055, 1055, 1092, 1092, 1226], [1227, 1227, 1256, 1256, 1791], [1792, 1792, 1813, 1813, 1927], [1928, 1928, 1949, 1949, 1997], [1998, 1998, 2036, 2036, 2223]], "test": "untested"}
{"id": "3t3Bzj", "name": "Exotic Particles", "author": "Shane", "description": "Building on  Lomateron, Jarble and Jolle's basic \"color accumulation via functional warping\" examples to produce some fake exotic particle imagery... or something to that effect. :)", "tags": ["blur", "warp", "sinusoidal", "particle", "transcendental"], "likes": 92, "viewed": 2156, "published": 3, "date": "1613054107", "time_retrieved": "2024-07-30T19:39:02.353572", "image_code": "/*\n\n    Exotic Particles\n    ----------------\n    \n    Accumulating color values via transcental function-warping to create some \n    pretty moving imagery that resembles colliding exotic particles in a \n    chamber... of paint... I actually have no idea what this looks like. :D\n    \n    Function-warping is nothing new, and this particular example is just a \n    slightly dressed up version of Jolle and Jarble's previous work, which in \n    turn was very loosely based on one of Lomateron's recent examples -- The \n    respective links are below.\n    \n    Anyway, I've commented the code. However, there's definitely nothing \n    difficult to grasp here. The simple color imagery was produced in \n    \"Buffer A\", which was blended with previous frames for a bit of temporal \n    blurring. The result (Image tab) was then used to take two 3x3 blurred \n    samples in order to add some highlights.\n    \n    \n    \n    \n    Uses elements from the following shaders:\n    \n    Glass bubble lamp - Jarble: https://www.shadertoy.com/view/ttcfD7\n    \n    Glass bubble lamp fork - Jolle: https://www.shadertoy.com/view/WtdBDM\n    \n    Mount Mask - lomateron: https://www.shadertoy.com/view/WdsfRf\n    \n    \n*/\n\n// Things look cleaner without highlights, and in some ways I prefer it.\n// However, it's less interesting... I think? :)\n#define HIGHLIGHTS\n\n// Serves no other purpose than to save having to write this out all the time. I'm using this \n// on a buffer texture, so no sRGB to linear operation needs to be performed. I'm also\n// using (and prefer to use) aspect correct pixel coordinates, so it's necessary to stretch \n// out the X values before retrieving them. It's also possible to stretch out the UV coordinates\n// first, then use a stretched sample spread, which is faster... Yeah, it's confusing, but it \n// doesn't matter, just so long as you have a method you're happy with. :)\n//\nvec4 tx(in vec2 p){ \n     p *= vec2(iResolution.y/iResolution.x, 1);\n     return texture(iChannel0, p + .5/iResolution.y); \n}\n\n// Blur function. Pretty standard.\nvec4 bTx(in vec2 p){\n    \n    // Sample spread -- Measured in pixels.\n    float px = 2.;\n    \n    // Result.\n\tvec4 c = vec4(0);\n    \n    // Standard equally weighted 3x3 blur.\n    for(int i = 0; i<9; i++) c += tx(p + (vec2(i/3, i%3) - 1.)*px/iResolution.y);\n \n    // Normalizing the return value.\n    return c/9.;  \n    \n    /*\n    // NxN blur.\n    const int N = 5;\n    for(int i = 0; i<N*N; i++) c += tx(p + (vec2(i/N, i%N) - float(N - 1)/2.)*px/iResolution.y);\n    return c/float(N*N); \n    */\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Aspect correct pixel coordinates.\n    vec2 uv = fragCoord/iResolution.y;\n   \n    // A 3x3 blurred texture sample. The generated warped imagery contains a few\n    // high frequency speckles, so blurred samples mitigate that somewhat. Denoising\n    // would be better, but this will do.\n    vec4 col = bTx(uv);\n    //vec4 col = tx(uv); // Standard single sample.\n     \n    #ifdef HIGHLIGHTS\n    // Bump mapping via cheap, directional derivative-based highlighting.\n    vec2 px = 4./iResolution.yy; // Sample spread.\n    vec4 col2 = bTx(uv - px); // Seperate sample.\n    float b = max(dot(col2 - col, vec4(.299, .587, .114, 0)), 0.)/length(px); // Bump.\n    col += col2.yzxw*col2.yzxw*b/12.; // Add the colored highlights.\n    #endif\n    \n    // Toning down the lower half slightly.\n    col = mix(col, col.zyxw, max(.3 - uv.y, 0.));\n    \n\n    // Rough gamma correction.\n    fragColor = sqrt(max(col, 0.));\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// Start off with a function, warp it, and accumulate color along the way.\n// This one is just a more mutated version of a simple sine warp function,\n// of which there are plenty of examples on Shadertoy.\nvec3 warp(vec2 u, float ph1, float ph2){\n\n    // Initializing the warped UV coordinates. This gives it a bit \n    // of a worm hole quality. There are infinitly other mutations.\n    vec2 v = u - log(1./max(length(u), .001))*vec2(-1, 1);\n    \n    // Scene color.\n    vec3 col = vec3(0.);\n    \n    // Number of iterations.\n    const int n = 5;\n    \n    for (int i = 0; i<n; i++){\n    \n        // Warp function.\n        v = cos(v.y - vec2(0, 1.57))*exp(sin(v.x + ph1) + cos(v.y + ph2));\n        v -= u;\n        \n        // Color via IQ's cosine palatte and shading.\n        vec3 d = (.5 + .45*cos(vec3(i)/float(n)*3. + vec3(0, 1, 2)*1.5))/max(length(v), .001);\n        // Accumulation.\n        col += d*d/32.;\n        \n        // Adding noise for that fake path traced look. \n        // Also, to hide speckling in amongst noise. :)\n        //col += fract(sin(u.xyy*.7 + u.yxx + dot(u + fract(iTime), \n        //             vec2(113.97, 27.13)))*45758.5453)*.01 - .005;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct UV coordinates.\n    vec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y*2.;\n\n   \n    // Angular offsets.\n    float ph1 = iTime*.6;\n    float ph2 = sin(iTime)*.25;\n    \n    // Adding two warp functions phase shifted by a certain amount was\n    // Jolle's interesting addition. Just the one would work, but isn't\n    // as interesting.\n    vec3 col = warp(u, ph1, ph2) + warp(u, ph1, ph2 + 1.57);\n    \n    // Toning things down slightly.\n    col = mix(col, col.zyx, .1);\n    \n    // Noise, for that fake path traced feel. :)\n    //col.xyz += fract(sin(u.xyy*.7 + u.yxx + dot(u + fract(iTime), \n    //                 vec2(113.97, 27.13)))*45758.5453)*.1 - .05;    \n    \n    // Mix the previous frames in.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : .25; \n    col = mix(preCol.xyz, col, blend);\n    \n    \n    // Clamp and add to Buffer A.\n    fragColor = vec4(clamp(col, 0., 1.), 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3Bzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1346, 1891, 1910, 1910, 2016], [2018, 2053, 2073, 2122, 2550], [2553, 2553, 2610, 2652, 3523]], "test": "untested"}
{"id": "tt3fRj", "name": "[290 min char] Hyper swirls", "author": "public_int_i", "description": "quick min shader sketch", "tags": ["swirl", "projection", "4d", "sketch", "minimal", "min", "point"], "likes": 6, "viewed": 297, "published": 3, "date": "1613052084", "time_retrieved": "2024-07-30T19:39:03.121517", "image_code": "//CC0, public domain, freeware\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 c = (u*2.-iResolution.xy)/iResolution.y;//2d world coordinate\n    o -= o;\n    for (float i = 1.; i < 100.; i += .1) {\n        //4d point\n        vec4 p = cos(i*vec4(.87,.276,.587,1.1));\n        float a = iTime+length(p.zy);\n        p.zw *= mat2(cos(a),-sin(a),sin(a),cos(a));\n        \n        //4d to 3d projection\n        p.xyz /= p.w+2.;\n        \n        //additively draw points + 3d to 2d projection\n        p.z += 2.;\n        o += clamp(1./p.z-length(c-p.xy/p.z)*20.,0.,.1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fRj.jpg", "access": "api", "license": "public-domain", "functions": [[32, 32, 71, 71, 568]], "test": "untested"}
{"id": "Wt3fz2", "name": "Sine flow 2", "author": "DukeOfStraylight", "description": "Lunchbreak sine sins.", "tags": ["sin"], "likes": 6, "viewed": 231, "published": 3, "date": "1613043454", "time_retrieved": "2024-07-30T19:39:03.889464", "image_code": "const float pi = 3.14159;\n\nfloat hash11(float n) {\n    return fract(sin(n*434.4)*543.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 10.;\n    uv.x += iTime * .5;\n    vec3 col = vec3(0.);\n    float s = sin(uv.x * 0.5);\n    float f = floor(uv.y - 1. - s);\n\n    for (float i = 0.; i < 2.5; i += 0.5) {\n        float n = i + f + 0.5;\n        float c = smoothstep(0.8, 0.5, abs(uv.y - n - s));\n        col = col + (c * cos(uv.x*0.5 + hash11(n)*10.*iTime*vec3(.2,.5,.7)));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3fz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 90], [92, 92, 149, 149, 572]], "test": "untested"}
{"id": "Wl3BR2", "name": "auto-adaptive target to 60fps", "author": "FabriceNeyret2", "description": "WIP: Trying to apply [url]https://shadertoy.com/view/Wt3BR2[/url] \nto autoadapt computation to target 55 fps, whatever the GPU or screen resolution.\nDisplay loop length: strongly oscillates.\nWhat am I doing wrong ?   ( several strategies in buffA #9..15 )", "tags": ["fps", "relaxation", "adaptive"], "likes": 5, "viewed": 337, "published": 3, "date": "1613036448", "time_retrieved": "2024-07-30T19:39:04.763128", "image_code": "// application of https://shadertoy.com/view/Wt3BR2\n\n// draw fonts & numbers from https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U ) { \n    O = T(U); \n    U = ( U/R.y - vec2(.05,.0) ) * 16.; \n    int n = int(T(0).w);\n    O -= pInt(U,float(n/10000) ).x; U.x -= 2.2;\n    O -= pInt(U,float(n%10000) ).x;\n    \n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float target = 55.,                                // target fps\n          T = 1./5.,\n          n = T(0).w;                                  // amount of computation to adapt\n    \n    if (U==vec2(.5)) {\n        O.x =   mix( T(0).x,    iTimeDelta,  T );      // relaxation on time\n        O.y = iFrame<1 ? n : mix( T(0).y, n, T );      // suggestion Fredrik Hubinette\n        O.w = iFrame<1 ? 1e3                           // relaxation on computing loop.\n                 //    : max(1., n /(target*iTimeDelta) );\n                       : max(1., n /(target*T(0).x) );\n                 //    : max(1., n *mix( 1., 1./(target*iTimeDelta), T) );\n                 //    : max(1., n *mix( 1., 1./(target*T(0).x)    , T) );\n                 //    : max(1., T(0).y /(target*T(0).x) ); // suggestion Fredrik Hubinette\n     // O-=O;\n     // O = vec4(1e3);                                 // stress tests\n        O.w = min(1e5, O.w);                           // safeguard\n        return;\n    }\n    \n    float y =  U.y/R.y;\n    O = U.x > 1.\n          ? T(U-vec2(1,0))                             // scroll\n          : vec4( y <  1./iTimeDelta/70.  );           // instant fps\n          \n   // if (mod(iTime,10.) < 5. ) \n    { \n        if (U.x<1.) O.rg *= .9;\n        for( float i=0.; i < n ; i++) O.a = cos(O.a);  // the costly adaptive computation\n    }\n        \n    if (U.x<1.) { if( abs(y-target/70.)<1./R.y) O = vec4(0,1,0,0) ;\n                  O = mix(O, vec4(1,0,0,0), max(0.,1.-abs( y - 1./T(0).x/70. )/2.*R.y) );\n                 }\n    O.b += min(0.,abs(O.a));       // to prevent optimizer to cancel the loop            \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0 , ivec2(U) , 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 120, 146, 146, 377], [378, 378, 406, 406, 667], [670, 670, 708, 708, 881]], "test": "untested"}
{"id": "Wt3BR2", "name": "smooth fps", "author": "FabriceNeyret2", "description": "white: instant fps.  Very noisy: many applications ( e.g. to stick to 60 fps ) require smoothing.\nred: smooth timing ( iTimeDelta )       seems best\ngreen: smooth fps ( 1. / iTimeDelta )  very sensitive to outliers, despite longer smoothing delay used.\n", "tags": ["fps", "relaxation", "adaptive"], "likes": 5, "viewed": 561, "published": 3, "date": "1613031300", "time_retrieved": "2024-07-30T19:39:05.541048", "image_code": "// recycling https://shadertoy.com/view/tlcfRB\n\nvoid mainImage( out vec4 O, vec2 U ) { O = T(U); }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (U==vec2(.5)) {\n        O.x = mix( T(0).x,    iTimeDelta, 1./5.  );  // relaxation on time\n        O.y = mix( T(0).y, 1./iTimeDelta, 1./20. );  // relaxation on fps\n     // O-=O;\n     // O = vec4(1e3);                               // stress tests\n        return;\n    }\n    \n    float y =  U.y/R.y;\n    O = U.x > 1.\n          ? T(U-vec2(1,0))                           // scroll\n          : vec4( y <  1./iTimeDelta/70.  );         // instant fps\n          \n    if (mod(iTime,10.) < 5. ) { // every 5 seconds, 5 secondes of time varing \n        if (U.x<1.) O.rg *= .9;\n        for( float i=0.; i < (.5+.5*sin(.3*6.28*iTime))*1e4; i++) O.a++;\n    }\n        \n    if (U.x<1.) O = mix(O, vec4(1,0,0,0), max(0.,1.-abs( y - 1./T(0).x/70. )/2.*R.y) ),\n                O = mix(O, vec4(0,1,0,0), max(0.,1.-abs( y -    T(0).y/70. )/2.*R.y) );\n                \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0 , ivec2(U) , 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3BR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 86, 86, 98]], "test": "untested"}
{"id": "3tcBzj", "name": "galaxy in a bubble 2", "author": "pnoqable", "description": "variant of https://www.shadertoy.com/view/3ldyz2 with less iterations in fractal mapping and some finetuning of raymarch dt. any other possibilities for better performance?", "tags": ["3d", "fractal", "volumetric"], "likes": 21, "viewed": 493, "published": 3, "date": "1613022644", "time_retrieved": "2024-07-30T19:39:06.421694", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by L. Haeussler 2021\n\nfloat powi( float b, int e )\n{\n    float result = b;\n    \n    int ae = abs( e );\n    for( int i = 1; i < ae; i++ )\n        result *= b;\n        \n    return e >= 0 ? result : 1. / result;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 sph, float radius ) // from iq\n{\n\tvec3 oc = ro - sph;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - radius*radius;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map( in vec3 p )\n{\n\tfloat res = 0.;\n    \n    float v = .8 - .7 * powi( sin( 0.15 * iTime ), 3 );\n\t\n    vec3 c = p;\n\tfor( int i = 0; i < 2; ++i ) {\n        p = v * p.zyx*p.zyx*powi(length(p),-3) - v;\n        p.xy = vec2( p.x*p.x - p.z*p.z, 2.*p.x*p.z );\n        res += exp( -12. * abs( dot( p, c ) ) );\n\t}\n    \n\treturn res;\n}\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax, float radius )\n{\n    vec3 col = vec3( 0. );\n    \n    float rfactor = 1. / radius;\n\n    float c = 1.;\n    float t = max( 0., tminmax.x );\n    float translucency = 1.;\n    for( int i=0; i<1024; i++ )\n\t{\n        float dt = mix( 0.05, 0.01, step( 0.001, c ) );\n        \n        t += dt;\n        \n        if( t >= tminmax.y )\n            break;\n\n        vec3 pos = ro + t*rd;\n        \n        float corona = 1.;\n        corona -= rfactor * length( pos );\n        corona = 4. * corona * ( 1. - corona );\n        c = map( pos ) * corona;\n        \n        \n        float hilights = 1.;\n        //hilights -= 0.95 * smoothstep( 0.9, 1.1, c );\n        col += translucency * dt * hilights * vec3( 5.1*c*c*c, 4.*c*c, 3.1*c );\n        translucency *= 1. - 1.5 * dt * sqrt( c );\n        \n        if( translucency < 0.1 )\n            break;\n    }\n    return col * sqrt( col );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, vec3 wu )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cu = normalize( cross(cw,wu) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec3 fromSpherical( vec3 s ) // vec3( phi, theta, radius )\n{\n    return s.z * vec3(sin(s.x)*cos(s.y), sin(s.y),\n                      cos(s.x)*cos(s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = 2.*iMouse.xy/iResolution.xy-1.;\n    \n    if( max( iMouse.x, iMouse.y ) < 10. )\n        m = vec2( 0.1 * iTime, 0.1 * sin( 0.3 * iTime ) );\n        \n    // uncomment for lg cinema3d:\n    // m.x -= 0.01 * ( mod( fragCoord.y, 2. ) - 1. );\n    \n    // camera\n    vec3 ro = fromSpherical( vec3( 3.1*m.x, 1.5*m.y, 5. + 4. * sin( 0.2 * iTime ) ) );\n    mat3 ca = setCamera( ro, vec3( 0., 0., 0. ), vec3( 0., 1., 0. ) );\n    \n    // ray\n    vec3 rd = ca * normalize( vec3( p, 2. ) );\n\n    // intersection\n    float radius = 2. + .1 * sin( 1. * iTime );\n    vec2 tmm = iSphere( ro, rd, vec3(0.), radius );\n\n\t// background\n    vec3 col = texture(iChannel0, rd).rgb;\n    \n    // bubble\n    vec3 nor = normalize( ro + tmm.x * rd );\n    float spec = 1. + dot( nor, rd );\n\n    // raymarch\n    vec3 innerColor = raymarch( ro, rd, tmm, radius );\n    vec3 bubble = mix( innerColor, col, spec*spec ) ;\n\n    // reflection\n    vec3 reflection = texture( iChannel0, reflect( rd, nor ) ).rgb;        \n    bubble = mix( bubble, vec3(.9, .6, 1.9) * reflection, powi( spec, 3 ) );\n    \n    // anti alias\n    float r = sqrt( dot( ro, ro ) - powi( dot( ro, rd ), 2 ) );\n    col = mix( col, bubble, smoothstep( 0., 2. * fwidth( r ), radius - r ) );\n\t\n\t// shade\n    col = 1. - exp( -col );\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[120, 120, 150, 150, 308], [310, 310, 388, 388, 572], [574, 574, 598, 598, 904], [906, 906, 972, 972, 1819], [1821, 1821, 1866, 1866, 1991], [1993, 1993, 2053, 2053, 2148], [2150, 2150, 2207, 2207, 3629]], "test": "untested"}
{"id": "3ldyz2", "name": "galaxy in a bubble", "author": "pnoqable", "description": "a late descendant of guil's playing marble https://www.shadertoy.com/view/MtX3Ws. i would really appreciate a space-like cubemap background :) any suggestion for better performance? i'm toying with dt inside raymarch loop, but the fractal is expensive...", "tags": ["3d", "fractal", "volumetric"], "likes": 12, "viewed": 501, "published": 3, "date": "1613020630", "time_retrieved": "2024-07-30T19:39:07.307325", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by L. Haeussler 2021\n\nfloat powi( float b, int e )\n{\n    float result = b;\n    \n    int ae = abs( e );\n    for( int i = 1; i < ae; i++ )\n        result *= b;\n        \n    return e >= 0 ? result : 1. / result;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec3 sph, float radius ) // from iq\n{\n\tvec3 oc = ro - sph;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - radius*radius;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map( in vec3 p )\n{\n\tfloat res = 0.;\n    \n    float v = .8 - .7 * powi( sin( 0.15 * iTime ), 3 );\n\t\n    vec3 c = p;\n\tfor( int i = 0; i < 10; ++i ) {\n        float dp = dot(p,p);\n        p = v * p.zyx*p.zyx/dp/sqrt(dp) - v;\n        p.xy = vec2( p.x*p.x - p.z*p.z, 2.*p.x*p.z );\n        res += exp( -12. * abs( dot( p, c ) ) );\n\t}\n    \n\treturn res;\n}\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax, float radius )\n{\n    vec3 result = vec3( 0 );\n    \n    float factor = 1. / radius;\n\n    float c = 1.;\n    float t = max( 0., tminmax.x );\n    float translucency = 1.;\n    for( int i=0; i<256; i++ )\n\t{\n        float dt = mix( 0.05, 0.01, step( 0.1, c ) );\n        \n        t += dt;\n        \n        if( t >= tminmax.y )\n            break;\n\n        vec3 pos = ro + t*rd;\n        \n        float corona = 1.;\n        corona -= factor * length( pos );\n        corona = 4. * corona * ( 1. - corona );\n        c = map( pos ) * corona;\n        \n        \n        float hilights = 1. - 0.95 * smoothstep( 0.9, 1.1, c );\n        result += translucency * dt * hilights * vec3( 5.1*c*c*c, 4.*c*c, 3.1*c );\n        translucency *= 1. - 1.2 * dt * c;\n        \n        if( translucency < 0.1 )\n            break;\n    }\n    return result * sqrt( result );\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, vec3 wu )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cu = normalize( cross(cw,wu) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec3 fromSpherical( vec3 s ) // vec3( phi, theta, radius )\n{\n    return s.z * vec3(sin(s.x)*cos(s.y), sin(s.y),\n                      cos(s.x)*cos(s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = 2.*iMouse.xy/iResolution.xy-1.;\n    \n    if( max( iMouse.x, iMouse.y ) < 10. )\n        m = vec2( 0.1 * iTime, 0.1 * sin( 0.3 * iTime ) );\n    \n    // uncomment for lg cinema3d:\n    // m.x -= 0.01 * ( mod( fragCoord.y, 2. ) - 1. );\n    \n    // camera\n    vec3 ro = fromSpherical( vec3( 3.1*m.x, 1.5*m.y, 4. + 1. * sin( 0.2 * iTime ) ) );\n    mat3 ca = setCamera( ro, vec3( 0. ), vec3( 0., 1., 0. ) );\n    \n    // ray\n    vec3 rd = ca * normalize( vec3( p, 2. ) );\n\n    // intersection\n    float radius = 2. + .1 * sin( 1. * iTime );\n    vec2 tmm = iSphere( ro, rd, vec3(0.), radius );\n\n\t// background\n    vec3 col = texture(iChannel0, rd).rgb;\n    \n    // bubble\n    vec3 nor = normalize( ro + tmm.x * rd );\n    float spec = clamp( 1. + dot( nor, rd ), 0., 1. );\n\n    // raymarch\n    vec3 innerColor = raymarch( ro, rd, tmm, radius );\n    vec3 bubble = mix( innerColor, col, spec*spec*spec ) ;\n\n    // reflection\n    vec3 reflection = texture( iChannel0, reflect( rd, nor ) ).rgb;        \n    bubble = mix( bubble, vec3(.9, .6, 1.9) * reflection, powi( spec, 2 ) );\n    \n    // anti alias\n    float r = sqrt( dot( ro, ro ) - powi( dot( ro, rd ), 2 ) );\n    col = mix( col, bubble, smoothstep( 0., 2. * fwidth( r ), radius-r ) );\n\t\n\t// shade\n    col = 1. - exp( -col );\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldyz2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[120, 120, 150, 150, 308], [310, 310, 388, 388, 572], [574, 574, 598, 598, 927], [930, 930, 996, 996, 1820], [1822, 1822, 1867, 1867, 1992], [1994, 1994, 2054, 2054, 2149], [2151, 2151, 2208, 2208, 3638]], "test": "untested"}
{"id": "WtcBRj", "name": "fork- ShyGuys in SMB2 -v2", "author": "jorge2017a1", "description": "fork- ShyGuys in SMB2 -v2", "tags": ["forkshyguysinsmb2v2"], "likes": 5, "viewed": 265, "published": 3, "date": "1613011109", "time_retrieved": "2024-07-30T19:39:08.277731", "image_code": "//modificado por jorge2017a1 ...jorge flores p.!!!\n///fork- ShyGuys in SMB2\n//https://www.shadertoy.com/view/wl3cWS\n// ShyGuys in SMB2\n///Created by IWBTShyGuy in 2021-01-04\n\n\n\n\nconst int SCREEN_BLOCK = 8;\nconst int GROUND_HEIGHT = 1;\nconst float SHYGUY_VELOCITY = 6.5;\n\nconst float fSCREEN_BLOCK = float(SCREEN_BLOCK);\n\nconst vec4 BACKGROUND = vec4(60, 188, 252, 255) / 255.0;\n\n\n\n///------------------\n\n#define PI 3.14159265359\n#define PI2 PI*2.0\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\n\n//https://www.shadertoy.com/view/wl3cWS\n// ShyGuys in SMB2\n\n\n// ---------------- Ground Tile ---------------- //\nconst int N_GBD = 10;\nconst ivec2 groundBlockDot[N_GBD] = ivec2[](\n    ivec2(2, 0), ivec2(11, 1), ivec2(6, 2), ivec2(15, 3), ivec2(3, 4),\n    ivec2(10, 5), ivec2(0, 6), ivec2(5, 6), ivec2(13, 6), ivec2(8, 7)\n);\n\n\nconst vec4 LIGHT_BROWN = vec4(248, 184, 0, 255) / 255.0;\nconst vec4 DARK_BROWN = vec4(83, 48, 0, 255) / 255.0;\n\nvec4 groundTile(in vec2 uv) \n{\n    uv.y = 1.0 - uv.y;\n    \n    uv *= 16.0;\n    ivec2 st = ivec2(floor(uv));\n    st %= ivec2(16, 8);\n    \n    for (int i = 0; i < N_GBD; i++) {\n        if (st == groundBlockDot[i])\n            return DARK_BROWN;\n    }\n    return LIGHT_BROWN;\n    //return vec4(1.0);\n}\n\n\n\nconst vec4 BLACK = vec4(0, 0, 0, 1);\nconst vec4 SEMI_WHITE = vec4(252, 252, 252, 255) / 255.0;\n\nconst vec4 LIGHT_GREEN = vec4(128, 208, 16, 255) / 255.0;\nconst vec4 MIDDLE_GREEN = vec4(0, 168, 0, 255) / 255.0;\nconst vec4 DARK_GREEN = vec4(0, 80, 0, 255) / 255.0;\n\n\n// ---------------- Grass Tile ---------------- //\nvec4 grassTile(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    ivec2 iuv = ivec2(uv * 16.0);\n    \n    switch (iuv.y) \n    {\n    case 0: case 15:\n        return DARK_GREEN;\n        \n    case 2: switch (iuv.x) \n    {\n        case 12: case 14: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    \n    case 3: switch (iuv.x) {\n        case 5: case 13: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 4: switch (iuv.x) {\n        case 2: case 3: case 5: case 7: case 8:\n            return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 5: switch (iuv.x) {\n        case 3: case 4: case 5: case 6: case 7:\n            return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 6: switch (iuv.x) {\n        case 4: case 5: case 6: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 10: switch (iuv.x) {\n        case 5: case 14: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 11: switch (iuv.x) {\n        case 1: case 5: case 10: case 14:\n            return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 12: switch (iuv.x) {\n        case 3: case 4: case 7: case 8: case 12: case 15:\n            return LIGHT_GREEN;\n        default: return MIDDLE_GREEN;\n    }\n    case 13: switch (iuv.x) {\n        case 3: return LIGHT_GREEN;\n        case 1: case 5: case 10: case 14:\n            return DARK_GREEN;\n        default: return MIDDLE_GREEN;\n    }\n    case 14: switch (iuv.x) {\n        case 0: case 3: case 7: case 8: case 12:\n            return MIDDLE_GREEN;\n        default: return DARK_GREEN;\n    }\n    default:\n        return LIGHT_GREEN;\n    }\n}\n\n\n\n\n///--------------------------------\n// ---------------- Tree ---------------- //\nconst vec4 STEM_BROWN = vec4(200, 76, 12, 255) / 255.0;\n\nvec4 stem(in vec2 uv) {\n    ivec2 iuv = ivec2(uv * 16.0);\n    switch (iuv.x) {\n        case 7: return STEM_BROWN;\n        case 6:\n        case 8:\n        case 9: return BLACK;\n        default: return vec4(0);\n    }\n}\n\n\nconst int LEAF_BITMAP[256] = int[](\n3,3,3,3,3,3,1,1,1,1,1,3,3,3,3,3,\n3,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,\n3,1,1,0,0,1,1,1,0,1,1,1,1,1,1,3,\n1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,3,\n1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,3,\n3,1,1,1,1,1,1,1,1,1,1,0,1,1,1,3,\n3,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,\n3,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,\n3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,3,\n3,3,3,1,1,1,1,1,1,1,1,3,3,3,3,3,\n3,3,3,3,3,1,1,1,1,3,3,3,3,3,3,3,\n3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,3,\n3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,3,\n3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,3,\n3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,3,\n3,3,3,3,3,3,2,2,2,3,3,3,3,3,3,3\n);\n\nint readLeafBitMap(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    uv *= 16.0;\n    return LEAF_BITMAP[int(uv.y) * 16 + int(uv.x)];\n}\n\nvec4 leaf(in vec2 uv)\n{\n    switch (readLeafBitMap(uv)) \n     {\n        \n        \n        case 0: return vec4(1.0,0.0,0.0,1.0);\n        case 1: return vec4(1.0,1.0,0.0,1.0);\n        case 2: return LIGHT_GREEN;\n        case 3: return vec4(0);\n        \n        default: return vec4(0);\n    }\n}\n\n\n\n///----leeer mario\n\nconst int MARIO_BITMAP[256] = int[](\n6,6,6,6,1,1,1,1,1,1,1,1,6,6,6,6,\n6,6,6,1,1,1,1,1,1,1,1,1,1,1,1,6,\n6,6,6,0,0,0,0,3,3,3,3,5,3,6,6,6,\n6,6,0,3,0,3,3,3,3,3,3,5,3,3,3,6,\n6,6,0,3,0,0,3,3,3,3,3,3,5,3,3,3,\n6,6,0,0,3,3,3,3,3,3,5,5,5,5,5,6,\n6,6,6,6,3,3,3,3,3,3,3,3,3,3,6,6,\n6,6,6,1,1,2,1,1,1,1,2,1,6,6,6,6,\n6,6,1,1,1,2,1,1,1,1,2,1,1,1,6,6,\n6,1,1,1,1,2,2,2,2,2,2,1,1,1,1,6,\n6,3,3,1,2,4,2,2,2,2,4,2,1,3,3,6,\n6,3,3,3,2,2,2,2,2,2,2,2,3,3,3,6,\n6,3,3,2,2,2,2,2,2,2,2,2,2,3,3,6,\n6,6,6,2,2,2,6,6,6,6,2,2,2,6,6,6,\n6,6,0,0,0,6,6,6,6,6,6,0,0,0,6,6,\n6,0,0,0,0,6,6,6,6,6,6,0,0,0,0,6\n);\n\nint readMarioBitMap(in vec2 uv) \n{\n    uv.y = 1.0 - uv.y;\n    uv *= 16.0;\n    return MARIO_BITMAP[int(uv.y) * 16 + int(uv.x)];\n}\n\nvec4 mario(in vec2 uv)\n{\n    switch (readMarioBitMap(uv)) \n     {\n     \n \n        case 0: return vec4(0.627, 0.408, 0.0,1.0);\n        case 1: return vec4(1.0,0.0,0.0,1.0);\n        case 2: return vec4(0,0.698,0.922,1.0);\n        case 3: return vec4(0.976,0.804,0.541,1.0);\n        case 4: return vec4(0.976,0.957,0,1.0);\n        case 5: return vec4(0,0,0,1.0);\n        //case 6: return vec4(1,1,1,1);\n\n        default: return vec4(0);\n    }\n}\n\n///---------------\n\n\n///--------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   float t1=mod(iTime, 3.0);\n   float t2=mod(iTime, 2.0);\n   float t3=mod(iTime, 1.0);\n   vec2 uv;\n   if (t2<t1)\n       if (t3<t2)\n         uv = fragCoord/iResolution.xy;\n       else\n        uv = ((2.0 * fragCoord - iResolution.xy) / iResolution.y + 1.0) / 3.0;\n   else\n        uv = ((2.0 * fragCoord - iResolution.xy) / iResolution.y + 1.0) / 1.5;\n    \n   \n    \n    vec3 colOut=vec3(0.5,0.3,1.0);\n\n    \n    uv *= fSCREEN_BLOCK;\n    ivec2 iuv = ivec2(floor(uv));\n    \n   \n   vec4 fcol=vec4(0.0);\n   \n    uv = fract(uv);\n     vec2 uv2=uv;\n    uv2.x=mod(uv.x,2.0);\n    \n    if (iuv.y < GROUND_HEIGHT) fcol = groundTile(uv);\n    else if (iuv.y == GROUND_HEIGHT) fcol = grassTile(uv);\n    \n    else if (iuv.x == SCREEN_BLOCK - 2)\n    {\n        fcol = stem(uv);\n    } else if (iuv.x == SCREEN_BLOCK - 3) \n    {\n        if (iuv.y < SCREEN_BLOCK - 3) \n        {\n            fcol = stem(uv);\n        } else if (iuv.y == SCREEN_BLOCK - 3) \n        {\n            fcol = leaf(uv);\n            \n        }\n    }\n    \n    \n   if (iuv.y == 2 && iuv.x==4) fcol =  mario(uv);\n   if (iuv.y == 2 && iuv.x==1) fcol = leaf(uv); \n   if (iuv.y == 2 && iuv.x==7) fcol = leaf(uv);\n    \n     if (fcol.w == 0.0) fcol = BACKGROUND;\n    colOut=fcol.xyz;\n    \n    vec4 color =vec4(colOut, 1.0);\n  \tfragColor = color;\n\n}\n\n\n", "image_inputs": [], "sound_code": "//modificado por jorge.flores.p.\n//I don't remember the reference ..\n//.. I don't have the author's name .... I forgot to save\n\nfloat fm(float time){\n  return sin(1000.*time+sin(300.*time));\n}\nfloat rhy(float time,float f){\n  return pow(fract(mod(-time*8.,8.)/3.),6.-3.*f);\n}\nvec2 dfm(float time,float dt){\n    return exp(-3.0*dt)*\n        fm(8.*time)*\n        vec2(rhy(time-.3*dt,dt),rhy(time-.5*dt,dt));\n}\nvec2 mainSound( in int samp,float time){\n  vec2 s;\n  s += vec2(3.0*sin(3e2*time)*pow(fract(-time*2.),4.))*2.0;\n  s += vec2(0.5*sin(4e5*time)*fract(-time*2.+.5))*10.0;\n  s += dfm(time,0.0);\n  s += dfm(time,0.5);\n  s += dfm(time,1.0);\n  s += dfm(time,2.0);\n  s += dfm(time+2.0*sin(mod(time*0.5,6.)),8.0);\n  s += dfm(time+4.0*cos(mod(time*0.5,5.)),16.0);\n    \n  vec2 s2=  vec2((fract(sin(time*1e3)*1e6)-.5)*pow(fract(-time*4.),mod(time*4.,2.)*8.))*8.0;\n  return 0.3*s+s2;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 482, 482, 504], [505, 505, 538, 538, 560], [561, 561, 594, 594, 615], [1057, 1057, 1087, 1087, 1355], [1624, 1675, 1703, 1703, 3343], [3486, 3486, 3509, 3509, 3702], [4272, 4272, 4304, 4304, 4397], [4399, 4399, 4422, 4422, 4690], [5282, 5282, 5316, 5316, 5410], [5412, 5412, 5436, 5436, 5853], [5913, 5913, 5970, 5970, 7261]], "test": "untested"}
{"id": "tttfzB", "name": "Revolving Gear Train", "author": "oneshade", "description": "Cool geartrain.", "tags": ["3d", "raymarching", "gears", "repetition", "revolving", "geartrain"], "likes": 10, "viewed": 202, "published": 3, "date": "1613006176", "time_retrieved": "2024-07-30T19:39:09.223203", "image_code": "float sdBox(in vec3 p, in vec3 d) {\n    vec3 q = abs(p) - d;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdBox2D(in vec2 p, in vec2 d) {\n    vec2 q = abs(p) - d;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nvec2 pModPolar(in vec2 p, in float offs, in float reps) {\n    float rep = 6.28 / reps, hRep = 0.5 * rep;\n    return sin(mod(atan(p.y, p.x) + offs + hRep, rep) - hRep + vec2(1.57, 0.0)) * length(p);\n}\n\nfloat mapScene(in vec3 p) {\n    float turn = iTime;\n\n    float c = cos(turn), s = sin(turn);\n    vec3 p1 = p, p2 = p;\n\n    float cell = mod(floor(atan(p1.z, p1.x) / 6.28 * 6.0 + 0.5), 2.0);\n    float dir = cell * 2.0 - 1.0, lock = cell * 0.157;\n    p1.xz = pModPolar(p1.xz, 0.0, 6.0) - vec2(3.0, 0.0);\n    p1.xy *= mat2(c, -s, s, c);\n\n    float teeth1 = sdBox(vec3(pModPolar(p1.xz, turn * dir + lock, 20.0), p1.y).xzy - vec3(1.35, 0.0, 0.0), vec3(0.25, 0.175, 0.075));\n    float ring1 = sdBox2D(vec2(length(p1.xz) - 1.1, p1.y), vec2(0.25));\n    float gears1 = min(ring1, teeth1);\n\n    cell = mod(floor(atan(p2.z, p2.x) / 6.28 * 6.0), 2.0);\n    dir = cell * 2.0 - 1.0, lock = cell * 0.157;\n    p2.xz = pModPolar(p2.xz, 0.52, 6.0) - vec2(2.75, 0.0);\n    p2.xy *= mat2(c, -s, s, c);\n    p2.xy = p2.yx;\n\n    float teeth2 = sdBox(vec3(pModPolar(p2.xz, turn * dir + lock, 20.0), p2.y).xzy - vec3(1.35, 0.0, 0.0), vec3(0.25, 0.175, 0.075));\n    float ring2 = sdBox2D(vec2(length(p2.xz) - 1.1, p2.y), vec2(0.25));\n    float gears2 = min(ring2, teeth2);\n\n    return min(gears1, gears2) - 0.025;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord.xy - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec2 rot = vec2(iTime, -0.6);\n    if (iMouse.z > 0.0) rot += mouse;\n\n    float cy = cos(rot.x), sy = sin(rot.x);\n    float cp = cos(rot.y), sp = sin(rot.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (float i=0.0; i < 100.0; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            l.yz *= mat2(cp, -sp, sp, cp);\n            l.xz *= mat2(cy, -sy, sy, cy);\n\n            float fogginess = 1.0 - exp(-t * 0.05);\n            fragColor.rgb = mix(vec3(max(0.0, dot(n, l))), vec3(0.25, 0.25, 1.0), fogginess);\n            break;\n        }\n\n        if (t > 50.0) {\n            fragColor.rgb = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 130], [132, 132, 169, 169, 254], [256, 256, 313, 313, 455], [457, 457, 484, 484, 1544], [1546, 1546, 1573, 1573, 1819], [1821, 1821, 1876, 1876, 3134]], "test": "untested"}
{"id": "tltBzS", "name": "infinity knots", "author": "YitingLiu", "description": "Torus Knots practice ", "tags": ["3d", "shape", "primitive"], "likes": 3, "viewed": 270, "published": 3, "date": "1612992693", "time_retrieved": "2024-07-30T19:39:09.998131", "image_code": "//tutorial https://youtu.be/2dzJZx0yngg\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34,233.53));\n    p+=dot(p,p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    vec3 c= a+t*ab;\n    float d = length(p-c)-r;\n    return d;\n    \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    \n    vec3 c= a+t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));\n    float i = min(max(x,y),0.);//performance penalty \n    \n    //make it smoother \n    return e+i;\n    \n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    //r.x would be r1, r.y would be r2\n    float x = length(p.xz)-r.x;\n    vec2 cp = vec2(x,p.y);\n    float a = atan(p.x,p.z);\n    cp*=Rot(a*3.+iTime);    \n    cp.y=abs(cp.y)-mix(0.2,.5,abs(sin(iTime)));//-mix(0.2,.5,abs(sin(iTime)))\n    float d = length(cp)-r.y;\n    \n    return d*0.5;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,3.,6.,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n   \n    //bounce from left to right \n    //float xDis = mix(-1.5,1.5,sin(iTime));\n    float td = sdTorus(p-vec3(1.),vec2(2.,.25));//vec3(3.,2.,8)\n\n  /***  \n    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6),.2);\n    float cd1 = sdCapsule(p, vec3(0,2,6), vec3(1,2,6),.5);\n    float cd2 = sdCapsule(p, vec3(0,3,6), vec3(1,2,6),.2);\n    float cd3 = sdCapsule(p, vec3(1,2,6), vec3(1.5,2,6),.2);\n    float bd = dBox(p-vec3(0.,2.,8),vec3(.8));\n    float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5),.2);\n  ***/\n    \n    float d = min(td,planeDist);\n    \n    return d; \n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i =0; i<MAX_STEPS; i++){\n        vec3 p = ro+dO*rd;\n        float dS = GetDist(p);\n        dO +=dS;\n        if (dS<SURF_DIST|| dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n   vec2 e = vec2(.01,0.);\n   float d = GetDist(p);\n   vec3 n = d-vec3(\n           GetDist(p-e.xyy),\n           GetDist(p-e.yxy),\n           GetDist(p-e.yyx));\n   return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    \n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n   \n    if (d<length(lightPos-p)) dif*=.1;\n     \n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n//getting the background using ray direction\nvec3 Bg(vec3 rd){\n    float k = rd.y*.5+.5;\n    vec3 col = mix(vec3(.2,abs(sin(iTime))*.2,.1),vec3(.2,.5,abs(sin(iTime))),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(1,4,-4);\n    ro.yz*=Rot(-m.y*3.14+1.);\n    ro.xz*= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv,ro,vec3(0),1.);\n\n    col+=Bg(rd);\n    float d = RayMarch(ro,rd);\n    \n    if(d<MAX_DIST){\n    vec3 p = ro+rd*d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd,n);\n    \n    \n    float spec = pow(max(0.,r.y),5.*mix(0.5,.8,cos(sin(iTime))));\n    \n    //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    //get diffused light     \n    float dif = GetLight(p);\n    col=mix(Bg(r*abs(tan(iTime))),vec3(dif),.2)+spec;\n    //col=vec3(spec);\n  }\n\n    col=pow(col,vec3(.4545));//gamma creation\n   \n\n    fragColor = vec4(col,1.);\n}\n\n\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 127, 127, 198], [200, 200, 221, 221, 312], [314, 314, 363, 363, 569], [571, 571, 621, 621, 1004], [1006, 1006, 1036, 1075, 1325], [1327, 1327, 1354, 1354, 1393], [1395, 1395, 1417, 1417, 2092], [2094, 2094, 2127, 2127, 2329], [2331, 2331, 2354, 2354, 2539], [2541, 2541, 2565, 2565, 2871], [2873, 2873, 2923, 2923, 3114], [3116, 3161, 3178, 3178, 3304], [3306, 3306, 3362, 3362, 4132]], "test": "untested"}
{"id": "wldBzS", "name": "webGLitch", "author": "outofpaper", "description": "Basic webcam glitch effect.", "tags": ["scanlines", "glitch", "webcam"], "likes": 22, "viewed": 1528, "published": 3, "date": "1612991349", "time_retrieved": "2024-07-30T19:39:10.872792", "image_code": "// change these values to 0.0 to turn off individual effects\nfloat vertJerkOpt = 0.0;\nfloat vertMovementOpt = 0.0;\nfloat bottomStaticOpt = 1.0;\nfloat scalinesOpt = 1.0;\nfloat rgbOffsetOpt = 1.0;\nfloat horzFuzzOpt = 1.0;\n\n// Noise generation functions borrowed from: \n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat staticV(vec2 uv) {\n    float staticHeight = snoise(vec2(9.0,iTime*1.2+3.0))*0.3+5.0;\n    float staticAmount = snoise(vec2(1.0,iTime*1.2-6.0))*0.1+0.3;\n    float staticStrength = snoise(vec2(-9.75,iTime*0.6-3.0))*2.0+2.0;\n\treturn (1.0-step(snoise(vec2(5.0*pow(iTime,2.0)+pow(uv.x*7.0,1.2),pow((mod(iTime,100.0)+100.0)*uv.y*0.3+3.0,staticHeight))),staticAmount))*staticStrength;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv =  fragCoord.xy/iResolution.xy;\n\t\n\tfloat jerkOffset = (1.0-step(snoise(vec2(iTime*1.3,5.0)),0.8))*0.05;\n\t\n\tfloat fuzzOffset = snoise(vec2(iTime*15.0,uv.y*80.0))*0.003;\n\tfloat largeFuzzOffset = snoise(vec2(iTime*1.0,uv.y*25.0))*0.004;\n    \n    float vertMovementOn = (1.0-step(snoise(vec2(iTime*0.2,8.0)),0.4))*vertMovementOpt;\n    float vertJerk = (1.0-step(snoise(vec2(iTime*1.5,5.0)),0.6))*vertJerkOpt;\n    float vertJerk2 = (1.0-step(snoise(vec2(iTime*5.5,5.0)),0.2))*vertJerkOpt;\n    float yOffset = abs(sin(iTime)*4.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n    \n\t\n\tfloat xOffset = (fuzzOffset + largeFuzzOffset) * horzFuzzOpt;\n    \n    float staticVal = 0.0;\n   \n    for (float y = -1.0; y <= 1.0; y += 1.0) {\n        float maxDist = 5.0/200.0;\n        float dist = y/200.0;\n    \tstaticVal += staticV(vec2(uv.x,uv.y+dist))*(maxDist-abs(dist))*1.5;\n    }\n        \n    staticVal *= bottomStaticOpt;\n\t\n\tfloat red \t=   texture(\tiChannel0, \tvec2(uv.x + xOffset -0.01*rgbOffsetOpt,y)).r+staticVal;\n\tfloat green = \ttexture(\tiChannel0, \tvec2(uv.x + xOffset,\t  y)).g+staticVal;\n\tfloat blue \t=\ttexture(\tiChannel0, \tvec2(uv.x + xOffset +0.01*rgbOffsetOpt,y)).b+staticVal;\n\t\n\tvec3 color = vec3(red,green,blue);\n\tfloat scanline = sin(uv.y*800.0)*0.04*scalinesOpt;\n\tcolor -= scanline;\n\t\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 359, 359, 408], [410, 410, 431, 431, 480], [482, 482, 504, 504, 541], [543, 543, 567, 567, 2073], [2075, 2075, 2099, 2099, 2459], [2462, 2462, 2519, 2519, 3877]], "test": "untested"}
{"id": "tldBzS", "name": "Fractal Ball", "author": "oneshade", "description": "Fractal.", "tags": ["fractal", "ball", "kifs"], "likes": 5, "viewed": 149, "published": 3, "date": "1612991061", "time_retrieved": "2024-07-30T19:39:11.779369", "image_code": "float mapScene(in vec3 p) {\n    float c = cos(1.875), s = sin(1.875);\n    float d = 1000000.0;\n    float size = 1.0;\n    for (int i=0; i < 10; i++) {\n        d = min(d, max(abs(p.x), max(abs(p.y), abs(p.z))) - size);\n        float c1 = cos(s), s1 = sin(s);\n        float c2 = cos(c), s2 = sin(c);\n        p.xz *= mat2(c1, -s1, s1, c1);\n        p.yz *= mat2(c2, -s2, s2, c2);\n        p = abs(p) - 0.3;\n        size *= 0.75;\n    }\n\n    return d - 0.1;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(iTime);//(iMouse.xy - screenCenter) / iResolution.y * 6.28;\n    vec2 uv = (fragCoord.xy - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        p.yz *= mat2(cp, -sp, sp, cp);\n        p.xz *= mat2(cy, -sy, sy, cy);\n\n        float d = mapScene(p / 1.5) * 1.5;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 1.5) * 1.2;\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.xz *= mat2(cy, sy, -sy, cy);\n            n.yz *= mat2(cp, sp, -sp, cp);\n\n            fragColor.rgb += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 451], [453, 453, 480, 480, 727], [729, 729, 784, 784, 1780]], "test": "untested"}
{"id": "ttdBzS", "name": "Sine flow", "author": "DukeOfStraylight", "description": "Late-night sine sins.", "tags": ["sin"], "likes": 3, "viewed": 274, "published": 3, "date": "1612990713", "time_retrieved": "2024-07-30T19:39:12.543326", "image_code": "const float pi = 3.14159;\n\nfloat hash11(float n) {\n    return fract(sin(n*434.4)*543.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv *= 10.;\n    uv.x += iTime * .5;\n    vec3 col = vec3(0.);\n    float f = floor(uv.y - 1.);\n\n    for (float i = 0.; i < 4.; i += 1.0) {\n        float n = i + f;\n        float c = smoothstep(0.8, 0.5, abs(uv.y - n - sin(uv.x*0.5)));\n        col = col + (c * cos(uv.x*0.5 + hash11(n)*10.*iTime*vec3(.2,.5,.7)));\n    }\n\n\n// Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 90], [92, 92, 149, 149, 563]], "test": "untested"}
{"id": "Ml3Bzs", "name": "Spiral Galaxy", "author": "Ubiquitous", "description": "Spiral Galaxy Shader originally created by Luther, adapted to look more realistic.", "tags": ["galaxy", "astronomy", "spiralgalaxy"], "likes": 12, "viewed": 1233, "published": 3, "date": "1612984595", "time_retrieved": "2024-07-30T19:39:13.489795", "image_code": "// Spiral Galaxy 2021 Ubiquitous\n// Adapted from ( https://www.shadertoy.com/view/MdSSzW )\n\n#define PI 3.14159265\n#define TWO_PI 6.2831853\n\n//#define USE_PROCEDURAL \n//#define ANIMATE\n//#define AUDIOPULSE\n//#define MOUSEZOOM\n\nfloat zoom = 1.0;\nfloat inv_zoom = 1.0;\n\nvec2 rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n\n    return vResult;\n}\n\nvec2 rotate_around( const in vec2 vPos, const in vec2 vCentre, const in float fAngle )\n{\n    return rotate(vPos - vCentre, fAngle) + vCentre;\n}\n\nvec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)\n{\n    vec2 lpos = uv - centre;\n    float dist = length(lpos);\n    float dx = dist / radius;\n    vec2 ret = rotate(lpos, r + (dx * amount));\n    return ret + centre;\n}\n\nfloat CircularGradient(vec2 pos, vec2 centre, float radius)\n{\n    float dist = length(pos - centre);\n    float dx = dist / radius;\n  \n    return dx;\n}\n\n\nfloat CircularGradientSineSeg(vec2 pos, vec2 centre, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    vec2 norm = vec / dist;\n    float segment = max(1.24, sin(atan(-norm.y, norm.x) * segments));\n    float dx = 2.0 - (dist / radius);\n  \n    return dx * segment;\n}\n\n\nfloat SelectSegment(const in vec2 vPos, const in float segcount)\n{\n\t\n\tvec2 vNorm = normalize(vPos);\n\tfloat atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;\n\tfloat segment = floor(atn * segcount);\n\tfloat half_segment = 0.5 / segcount;\n\tfloat seg_norm = mod((segment / segcount) + 0.25 + half_segment, 1.2);\n\t\n\treturn seg_norm * TWO_PI;//turn it back in to rotation\n}\n\nfloat StarShapeBW(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.3;\n    float seg_arc_length = seg_angle_size * centrerad;\n    //float nrm_mul = 1.0\n    \n    if (dist < centrerad)\n        return 1.0;\n    else if (dist > radius)\n        return 0.4;\n    else\n    {\n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_angle_size);\n        float d = abs(dpos.x);\n        float width_at = seg_angle_size * ld;\n        return (d < seg_arc_length * 0.5 * ld) ? 1.0 : 0.0;\n    }\n}\n\n\n\nfloat StarShape2(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_arc_length = TWO_PI / segments;\n    float half_seg_arc_length = seg_arc_length * 0.2;\n    if (dist < centrerad)\n        return 1.0;\n    else \n    {\n        float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n        float w = mod(angle, seg_arc_length);\n        float d =  abs(w - half_seg_arc_length) * 1.0/ half_seg_arc_length;\n        return pow(d * 2.4, ld) * ( ld);\n    }\n}\n\nfloat easeInOutQuart(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t*t;\n\treturn -2.5 * ((t-=2.0)*t*t*t - 2.0);\n}\nfloat easeOutCubic(float t) \n{\n\treturn ((t=(t/2.0)-1.0)*t*t + 1.0);\n}\nfloat easeInOutCubic(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t;\n\treturn 0.5*((t-=2.0)*t*t + 2.0);\n}\n\nfloat fade2(float t)\n{\n\treturn t*t*(3.0-2.0*t);\n}\n \n\nfloat fade(float t) {\n  return t*(t*(t*4.0-11.0)+2.0);\n}\n\nvec3 fade(vec3 t) \n{\n  return t*(t*(t*4.0-2.0)+10.0);\n}\n\nfloat fade3(float f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\nvec3 fade3(vec3 f)\n{\n    return f*f*(3.0-2.0*f);\n}\n\n\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*63758.5453123); }\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = fade(f);//f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 213.0*p.z;\n    return mix(mix(mix( hash(n+ 10.0), hash(n+041.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n#else\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = fade3(f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+1.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n#endif\n\n\nfloat multiNoise( in vec3 pos )\n{\n    vec3 q = 8.0*pos;\n    const mat3 m = mat3( 0.20,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    float amplitude = 0.5;\n    float f  = amplitude*noise( q ); q = m*q*2.11;\n    float scale = 2.02;\n    float amptotal = 0.2;\n    for (int i = 0; i < 10; ++i)\n    {    \n    \tf += amplitude * noise( q ); q = m*q*scale;        \n        amplitude *= 0.65;\n        \n    }\n    f /= 1.7;\n    \t//  f += 0.0312*noise( q ); q = m*q*1.05;\n \n    return f;\n}\n\nvec3 orangegrad(float d)\n{\n    vec3 col1 = mix(vec3(0.0, 0.01, 0.01), vec3(1.5, 0.5, 0.1), d);\n    \n    return mix(col1, vec3(5.4, 2.4, 2.1), d * 0.15);\n    return col1;\n}\n\n\nvec3 bluegrad(float d)\n{\n    return mix(mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.7, 0.8), d), vec3(3.0, 7.0, 12.0), d * 0.1);\n}\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+2.5)/256.0, -100.0 ).xy;\n}\n\nvec3 blackbody_grad(float x)\n{    \n    float ca = 1.0 - (pow(x, 1.2) * 0.5);\n    float cb = pow(min(1.0, x +0.6), 2.0) * 0.9;\n    float cd = x * 0.4;\n    float g = cb- cd;    \t\n    return vec3(ca * 0.7,g*1.0,(1.9- ca) * 0.5) * 1.1;\n}\n\nvec4 hash4( vec2 p)\n{\n    return vec4(texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy,\n                texture( iChannel0, (p+0.5)/256.0, -160.0 ).xy);\n}\n\nfloat star_falloff(float dist, float radius)\n{\n    float idist = max(0.1, radius - dist);\n    return pow(idist, 80.0) * 6.5 + pow(idist, 120.0) * 0.8;\n}\n\nfloat star_falloff2(float dist, float radius)\n{\n    float idist = max(0.3, radius - dist);\n    return pow(idist, 270.0) * 2.3 + pow(idist, 370.0) * 1.8;\n}\n\n//IQ's voronoi code provided the inspiration for this, thank you.\nvec3 voronoi_stars( in vec2 pos)\n{\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n\n   \n\tvec2 min_cell, min_pos;\n\n    float min_dist = 100.0;\n    vec3 col = vec3(0,0,0);\n    int xdir = f.x > 0.5 ? 1 : -1;\n    int ydir = f.y > 0.5 ? 1 : -1;\n    for( int j=0; j<=1; j++ )\n    {\n   \t\tfor( int i=0; i<=1; i++ )    \n\t    {\n    \t    vec2 cell = vec2(float(i * xdir),float(j * ydir)); //integer cell offset\n\t\t\tvec2 o = hash2( n + cell );\t\t  //hashed up random offseterizer\n\t\t\t#ifdef ANIMATE\n        \to = 0.5 + 0.5*sin( iTime * 0.1 + 12.2831*o );\n        \t#endif\t\n        \tvec2 r = cell + o - f;        \n        \tvec4 stardata = hash4(n + cell);\n        \t#define SQRT_DIST\n        \t#ifdef SQRT_DIST\n        \tfloat d = length(r);                \n        \tfloat starfo = star_falloff(d, 1.0) * 1.2;\n        \t#else // faster\n        \tfloat d = dot(r,r);                \n        \tfloat starfo = star_falloff2(d, 1.0) * 1.1;\n        \t#endif\n      \n\t        vec3 star_colour = blackbody_grad(stardata.x * 1.2 )  * stardata.w * starfo;\n\t\t\tcol += star_colour;\n        }\n    }\n    return col;\n}\n\nfloat SphereShape(vec2 pos, vec2 centre, float radius, float curvep, float brightness)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    if (dist > radius) return 0.0;\n    return min(1.7,max(0.0, pow(1.0 - (dist / radius), curvep))) * brightness;   \n}\n\nvec4 Galaxy(vec2 pos, vec2 centre, float centrerad, float radius, float twist_amount, float rotation, float segments)\n{\n    vec2 rpos = RadialDistort(pos, centre, radius, twist_amount, rotation);\n    vec2 rposless = RadialDistort(pos, centre, radius, twist_amount * 0.1, rotation);\n    \n    vec2 vec = rotate((rpos - centre), rotation);\n    \n    vec2 vecless = (rposless - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    float seg_arc_end_length = seg_arc_length * 0.2;\n   \n    float ns = multiNoise(vec3(pos.x * 1.0, pos.y * 1.0, iTime*0.005));\n    float nst = multiNoise(vec3(rposless.x * 3.0, rposless.y * 3.0, iTime*0.0016));\n    ns = mix(ns, nst, 0.5);\n        \n    if (dist > radius)\n        return vec4(0.3, 0.6, 0.3, 0.9);\n    else\n    {\n      \n        \n        float r =  SelectSegment(vec, segments);\t\t\n\t\tvec2 dpos = rotate(vec, r );        \n        float yd = 1.0 - (dist - centrerad) / (radius - centrerad);\n        \n        float fadeout = pow(yd, 4.2) *0.4;\n        float w = mod(angle, seg_angle_size);\n      \n        float centre_fo =  1.0;//max(0.0, 1.0 - pow(yd, 30.1));\n         vec2 dposless = rotate(vecless, r );        \n     \n        float thread = 1.0 - max(0.0, abs(dpos.x  + ((ns - 0.5)* 0.4 * centre_fo)));\n        float d =  abs(dpos.x ) ;\n             \n        float width_at = seg_arc_end_length+(seg_arc_length - seg_arc_end_length * yd);\n        \n        float xd = clamp((width_at-d) / seg_arc_length, 0.6, 1.0);\n        \n        float fadexd = (pow(fade2(xd), 1.2) * 1.2) * ns;\n        return vec4( fadexd, xd,thread,fadeout);//fadeout);\n        \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timemod = iTime * 1.2;\n    vec2 mousep = iMouse.xy / iResolution.xy;\n    \n    float minzoom = 1.2;\n    float maxzoom = 0.5;\n    float zoom_delta = (sin(timemod * 0.05) + 2.0) / 3.3;\n    zoom_delta = pow(zoom_delta, 0.9);\n    \n    #ifdef MOUSEZOOM\n    zoom_delta = sin(mousep.x + (timemod * 0.07));\n    #endif\n    zoom = mix(minzoom, maxzoom, zoom_delta);\n    inv_zoom = 1.4 / zoom;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 orignal_uv = uv;\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x = (uv.x * ar);\n    uv -= 0.3;\n    uv *= zoom;\n    uv += 0.1;\n    uv.x -= 0.3;\n    \n    vec2 centre  = vec2(0.25, 0.25);\n    float centre_radius = 0.18;\n    float radius = 1.3;\n    \n    float r = mousep.y - PI * zoom_delta - 8.4 ;\n \n    vec2 ruv = rotate_around(uv, centre, r );\n    \n    float twist_amount = 10.0;//sin(iTime * 1.0)*5.0;\n  \n    vec4 galaxy_params = Galaxy(ruv,centre, centre_radius, radius, twist_amount, 0.3, 0.8);\n    \n   \tfloat galactic_centre = SphereShape(uv, centre, 0.5, 3.4, 0.7);\n    vec3 col = bluegrad(galaxy_params.x * galaxy_params.w * 0.7);\n    \n    #ifdef AUDIOPULSE\n    float pulse_nebula = 0.4 + texture(iChannel1, vec2(ruv.x * 0.001, 0.2)).b;\n    #else\n    float pulse_nebula = 0.5;\n    #endif\n    col += bluegrad(pow(galaxy_params.x, 6.0) * pulse_nebula * clamp(0.8-galaxy_params.w, 0.2, 1.0) * clamp(pow(galaxy_params.w * 2000.0, 2.0), 0.2, 1.0))   ;\n    \n    float thread = clamp(galaxy_params.z - galactic_centre * 1.0, 0.4, 1.0);\n    float ribbon_fadeout = (0.04 + pow(galaxy_params.w * 2.0, 2.4)) * 0.3;\n    col += orangegrad(pow(thread,10.0) ) * ribbon_fadeout * 2.0 ;\n    col -= bluegrad(pow(thread,70.0)) *  ribbon_fadeout * 1.3;\n    col += orangegrad(galactic_centre * 0.70) ;\n    \n    float cellsize = 10.0;\n    vec2 ruv2 = rotate_around(uv,centre, r);\n    float starscale = 3.15;\n    float starpowcurve = 2.4;\n    float seed = 6.3;\n    vec3 starcolbase =  vec3(0.2,0.2,0.4) * 1.0;    \n    vec3 starcol = starcolbase;\n    \n\n    starscale = 8.5;\n    #ifdef AUDIOPULSE\n    float starbrightness = 0.2 + texture(iChannel1, vec2(ruv.x * 0.001, ruv.y * 1.4)).g * 0.9;// * 15.3 + (galaxy_params.x * 2.0) ;\n    #else\n    float starbrightness = 0.6 * (1.0 / pow(zoom, 0.3));\n    #endif\n    for (int i = 0; i < 10; ++i)\n    {        \n        \n        float starsize = 0.4;\n        float fadeout = pow(galaxy_params.y, 5.0) * 0.9 *  (galaxy_params.w  * 0.8 + 0.1) + 0.1;\n        col += voronoi_stars(ruv * starscale) * fadeout * starbrightness;//star_b * starcol ;\n        starbrightness *= 0.9;\n        starscale *= 2.5;\n      \n       \n    }\n    vec4 sound_col = 0.4 + texture(iChannel1,  orignal_uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3Bzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[627, 627, 706, 706, 871], [873, 873, 934, 934, 1023], [1026, 1026, 1110, 1110, 1337], [1704, 1704, 1793, 1793, 2541], [2545, 2545, 2633, 2633, 3134], [3136, 3136, 3168, 3168, 3250], [3251, 3251, 3281, 3281, 3320], [3321, 3321, 3353, 3353, 3428], [3430, 3430, 3452, 3452, 3479], [3483, 3483, 3504, 3504, 3539], [3541, 3541, 3561, 3561, 3596], [3598, 3598, 3620, 3620, 3650], [3652, 3652, 3672, 3672, 3702], [4447, 4447, 4480, 4480, 4980], [4982, 4982, 5008, 5008, 5153], [5156, 5156, 5180, 5180, 5279], [5281, 5281, 5303, 5333, 5391], [5393, 5393, 5423, 5423, 5626], [5628, 5628, 5649, 5649, 5780], [5782, 5782, 5828, 5828, 5934], [5936, 5936, 5983, 5983, 6090], [6092, 6158, 6192, 6192, 7237], [7239, 7239, 7327, 7327, 7507], [7509, 7509, 7628, 7628, 9290], [9292, 9292, 9349, 9349, 12048]], "test": "untested"}
{"id": "3ldfRS", "name": "2D Panini Projection Visualizer", "author": "public_int_i", "description": "Visualization showing panini projection top compared to planar projection bottom. Click to change field of view.\ntop = 180 deg fov,\nbottom = 90 deg fov.", "tags": ["visualization", "projection", "panini"], "likes": 6, "viewed": 551, "published": 3, "date": "1612974732", "time_retrieved": "2024-07-30T19:39:14.334537", "image_code": "/*Top is painini projection, red shows the projection cylinder.\nBottom is planar projection, red shows the projection plane.\n\nClick to change field of view.\ntop = 180 deg fov,\nbottom = 90 deg fov.\n\nCredit to TinyTexel for the Panini projection code https://www.shadertoy.com/view/Wt3fzB*/\n\n\n//more sample lines = slower\n#define SAMPLES 10\n\n\n#define PI 3.141592653589793\n\n\n//create color interpolation value from distance field\n#define dlv(d) clamp(1.-(d)*iResolution.y*.5,0.,1.)\n\n//blend color a to b based on b.w*c\n#define blend(a,b,c) mix(a,b,(b).w*(c))\n\n\n//draw 2d line from a to b at uv\nvec4 line(vec4 bgCol, vec2 uv, vec2 a, vec2 b, float sz, vec4 lineCol) {\n    vec2 d = uv-a, c = b-a;\n    return blend(bgCol, lineCol,\n        dlv(length(d-c*clamp(dot(d,c)/dot(c,c),0.,1.))-sz));\n}\n\n\nfloat twave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    //2d drawing(back to front)\n    vec4 col = vec2(.05,1).xxxy;//grey background\n    \n    //middle divider line\n    col = blend(col,vec2(.5,1).xxxy, dlv(abs(uv.y)-.01));\n    \n    //projection field of view angle in degrees\n    float FIELD_OF_VIEW = 100.+twave(iTime*.2)*79.;\n    if (iMouse.z > 0.) FIELD_OF_VIEW = 90.+90.*iMouse.y/iResolution.y;\n    \n    //panini projection\n    float fovRad = FIELD_OF_VIEW*.5*PI/180.;\n    const vec2 paniniOrigin = vec2(0.,.2);\n    \n    for (float x = -1.; x <= 1.+1e-6; x += 2./float(SAMPLES-1)) {\n        //ray direction\n        float d = 1., d2 = d*d;\n        float h = x;\n        float v = 0.;\n        {\n            float fo = PI*.5 - fovRad;\n            if (fo == 0.) fo = 1e-6;\n\n            float f = cos(fo)/sin(fo) * 2.0;\n            float f2 = f*f;\n\n            float b = (sqrt(max(0.0, pow(d+d2,2.)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n            h *= b*(.25+.75*fovRad/(PI*.5));\n        }\n        \n\n        float h2 = h*h;\n\n        float k = h2/pow(d+1.0,2.);\n        float k2 = k*k;\n\n        float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n\n        float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n        float S = (d+1.0)/(d+cosPhi);\n        float tanTheta = v/S;\n\n        float sinPhi = sqrt(max(0.0, 1.0-pow(cosPhi,2.)));\n        if(x < 0.0) sinPhi *= -1.0;\n\n        float s = inversesqrt(1.0+pow(tanTheta,2.));\n\n        vec2 rd = normalize(vec2(sinPhi, cosPhi));\n    \n        float rx = x*fovRad;\n        //rd = vec2(sin(rx),cos(rx));\n        \n        //draw ray line\n        col = line(col,uv, paniniOrigin,paniniOrigin+rd*.5, .01, vec4(1.,.6,.2,1));\n    }\n    \n    //draw panini projection cylinder\n    vec2 cylPos = uv-paniniOrigin;\n    col = blend(col,vec4(1,0,0,1),\n        dlv(max((abs(atan(cylPos.x,cylPos.y))-fovRad),abs(length(cylPos)-.5)-.015)));    \n    \n    \n    //standard planar projection\n    float fovTangent = tan((90.-.5*FIELD_OF_VIEW)*PI/180.);\n    const vec2 planarOrigin = vec2(0.,-.8);\n    vec2 pleft, pright;\n    \n    for (float x = -1.; x <= 1.+1e-6; x += 2./float(SAMPLES-1)) {\n        vec2 rd = normalize(vec2(x,fovTangent));//ray direction\n        \n        //map to plane\n        float pdst = (planarOrigin.y-(-.3))/-rd.y;\n        if (x <= -1.) pleft = planarOrigin+rd*pdst;\n        else pright = planarOrigin+rd*pdst;\n        \n        //draw ray line\n        col = line(col,uv, planarOrigin,planarOrigin+rd*pdst, .01, vec4(1.,.6,.2,1));\n    }\n    \n    //draw planar projection plane\n    col = line(col,uv, pleft,pright, .015, vec4(1,0,0,1));\n         \n        \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 591, 663, 663, 787], [790, 790, 812, 812, 849], [852, 852, 909, 909, 3538]], "test": "untested"}
{"id": "WttBzS", "name": "SelfPortrait", "author": "eiffie", "description": "Hint: The guy with the man bag is pulling the strings.", "tags": ["egypt"], "likes": 21, "viewed": 513, "published": 3, "date": "1612973652", "time_retrieved": "2024-07-30T19:39:15.220169", "image_code": "/*SelfPortrait by eiffie\nThe code isn't interesting so I'll tell a story.\nWhile trying to figure out why masons were poisoning me with magnetite\nI started following the trail of people who were poisoned with metallic dust\nand then heard voices/sounds.\nToday they are called Targeted Individuals or TIs. In roman times till now if witches\ncarried a lodestone in a pouch and fed it iron shavings it was said to talk to them.\nIn ancient Egypt the pharoahs were said to bath in gold dust and sleep in the pyramids\nto recieve instructions from the ancestors the stars.\nThis research shows a simple way to make people hear sounds others don't by poisoning\nwith magnetic dust. https://pubs.acs.org/doi/10.1021/nn5020616\nBut it took a long time for me to understand how the ancients could transmit electro-\nmagnetic waves. That is until I saw the bow drill used by the Egyptian stone cutters.\nIt was tipped with emery powder that contains magnetite crystals. The masons would\nbe poisoned with this dust. The string would become embedded with crystals and the\nslipping of the string would scape electons causing the crystal to align. A magnetic\nstring! The egyptians slaves had a musical instrument called the musical bow. You\nplace one end in your mouth to reasonate the sound. It sounds like the guitar effect\ncalled the talk box. Peter Fampton made it popular... \"there's ringing in my ear\".\n*/\n#define rez iResolution\nfloat px,time;\nint C[]=int[](490,204,475,193,448,200,424,222,376,247,345,269,318,212,312,192,\n298,177,250,153,262,142,290,140,292,132,295,127,293,126,297,123,294,119,\n303,117,293,100,296,84,282,53,247,39,200,56,184,104,196,139,173,147,\n129,150,108,174,66,205,35,246,93,262,165,251,200,259,216,231,194,227,\n222,223,226,216,197,218,169,232,109,223,71,230,71,227,114,220,143,200,\n141,226,136,264,116,326,105,355,110,400,163,411,222,391,266,357,255,382,\n240,455,230,482,233,493,250,493,261,489,278,494,310,495,330,489,329,486,\n318,487,292,478,267,449,317,340,315,317,289,303,258,313,216,328,181,353,\n194,339,209,315,219,288,257,248,280,222,304,271,338,315,395,277,439,238,\n464,235,480,222,481,222,465,216,450,225,462,225,477,219,490,224,490,204,\n  198,141,223,142,245,111,256,80,276,81,294,84,\n289,90,272,87,252,94,250,95,268,97,284,97,293,105,281,105,250,95,\n  314,348,352,460,359,464,385,473,416,484,433,486,434,490,\n420,497,394,492,367,489,348,497,338,490,338,473,313,434,291,398,\n  581,0,576,49,564,62,554,76,538,76,536,83,550,87,562,84,572,78,571,89,573,99,\n580,106,586,99,592,106,599,99,605,106,611,98,619,102,622,91,617,76,613,47,615,0);\n#define R vec2(800,500)\nfloat tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));} \nfloat Tub(vec2 uv, int p1, int p2){\n  return tube(uv-vec2(C[p1],C[p1+1])/R,vec2(C[p2],C[p2+1])/R-vec2(C[p1],C[p1+1])/R);\n}\nvec2 Catmull(vec2 n0, vec2 n1, vec2 n2, vec2 n3, float t) { \n  vec2 a=(3.0*(n1-n2)+n3-n0); \n  vec2 b=(2.0*n0-5.0*n1+4.0*n2-n3); \n  vec2 c=n2-n0; \n  return 0.5*(a*t*t*t+b*t*t+c*t)+n1; \n}\nfloat DCat(vec2 uv, int start, int points){\n  int s2=start*2;\n  vec2 n0=vec2(C[s2],C[s2+1])/R,n1=vec2(C[s2+2],C[s2+3])/R;\n  vec2 n2=vec2(C[s2+4],C[s2+5])/R,n3=vec2(C[s2+6],C[s2+7])/R;\n  float c=tube(uv-n0,n1-n0);\n  for(int i=start+4;i<start+points;i++){\n    float t=dot(uv-n1,n2-n1)/dot(n2-n1,n2-n1);\n    if(t>-.1 &&  t<1.1 && i!=47){\n      vec2 v=Catmull(n0,n1,n2,n3,t);\n      for(int j=0;j<3;j++){\n        t*=dot(uv-n1,v-n1)/dot(v-n1,v-n1);\n        if(t<0. || t>1.)break;\n        v=Catmull(n0,n1,n2,n3,t);\n      }\n      c=min(c,length(v-uv));\n    }\n    n0=n1;n1=n2;n2=n3;n3=vec2(C[i*2],C[i*2+1])/R;\n  }\n  return min(c,tube(uv-n2,n3-n2));\n}\nfloat RRect(in vec2 z, vec2 r){return length(max(abs(z.xy)-r.xy,0.0));} \nfloat DE(vec2 p){\n  float d=RRect(p-vec2(.17,.91),vec2(.09,.08));\n  float s=abs(sin(time))*0.03;\n  d=min(d,RRect(p-vec2(.66,.91),vec2(.09,.08)));\n  if(p.y>.46)d=min(d,RRect(p-vec2(.59,.47),vec2(.02,.03)));\n  d=min(d,RRect(p-vec2(.59,.6),vec2(.008,.09)));\n  d=min(d,RRect(p-vec2(.59,.76),vec2(0.,.06)));\n  d=min(d,RRect(p-vec2(.5+s,.45+pow(abs(p.x-.5-s+.24),8.)*32.),vec2(.24,0.)));\n  d=min(d,RRect(p-vec2(.23+s-(p.y-.54)*.2,.54),vec2(0.,.03)));\n  d=min(d,RRect(p-vec2(.75,.33),vec2(.035,.06)));\n  if(abs(p.x-.75)>.03&&p.y<.27)d=min(d,length(p-vec2(.75,.23))-.05);\n  d=abs(d-.004);\n  d=min(d,tube(p-vec2(.23+s,.57),vec2(.37-s,-.01)));\n  d=min(d,tube(p-vec2(.58,.55),vec2(.16+s,-.01)));\n  return d;\n}\nfloat map(vec2 uv){\n  float c=DCat(uv,0,89);\n  c=min(c,DCat(uv,89,15));\n  c=min(c,DCat(uv,89+15,15));\n  c=min(c,DCat(uv,89+30,22));\n  c=min(c,Tub(uv,94,140));\n  c=min(c,Tub(uv,102,136));\n  c=min(c,Tub(uv,102,104));\n  c=min(c,Tub(uv,232,234));\n  c=min(c,Tub(uv,92,142));\n  c=min(c,Tub(uv,278,276));\n  c=min(c,DE(uv));\n  c=min(c,abs(length(uv-vec2(.35,.2))-0.005));\n  c=smoothstep(0.,px,c);\n  return c;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=U/rez.xy;uv.y=1.-uv.y;if(uv.x<.1 || uv.x>.9){O=vec4(0);return;}uv.x-=.07;\n  px=3./rez.y;time=iTime*4.;\n  if(RRect(uv-vec2(.66,.91),vec2(.07,.06))<0.01){uv=(uv-vec2(.66,.91)+vec2(.06,.08))*6.;px*=10.;time*=1.3;}\n  for(int i=54;i<86;i+=2){\n    C[i]+=int(abs(sin(time))*0.3*float(C[i+1]-C[53]));\n  }\n  float c1=map(uv),c2=map(uv-vec2(.005,.01));\n  float c=c1/(c1+c2);\n  c-=0.25*fract(sin(dot(uv,vec2(123.43,123.12)))*124.324);\n  O=vec4(c*vec3(1.,.8,.3),1.0);\n}", "image_inputs": [], "sound_code": "#define bps 4.75\n#define pi 3.14159\nint N[]=int[](57,0,0,0,0,0,0,0,0,0,0,0,57,59,61,62,59,0,0,0,0,0,0,62,65,64,62,0,64,62,0,58);\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nfloat env(float att, float bt){return (1.0-exp(-bt*att))*max(1.0-pow(bt,.1),0.);}\n\nvec2 inst(float n,float t,float bt,float syn){//note, time and beat within note\n if(n<1.)return vec2(0.0);\n float f=ntof(n);\n float a=sin(f*t*6.283+bt*pi*4.*sin(f*t*syn));\n return vec2(1.5-n/90.0+sin(bt),n/90.0-sin(bt))*a*env(50.0,bt)*50.0/n;\n}\nvec2 mainSound(int samp, float time){\n  float tym=time*bps;\n  vec2 o=vec2(0);\n  float last=min(1.+floor(tym/32.),8.);\n  for(float i=0.;i<last;i+=1.){\n    int b=int(floor(tym)-i*4.)%32;\n    float bt=fract(tym);\n    float syn=mod(floor(tym)*3.,4.)*pi*.5+pi/2.;\n    if(b<4){b=0;bt=fract(tym/4.);syn=pi;}\n    float n=float(N[b]+12);\n    o+=inst(n,time,bt,syn)/(1.+i);\n  }\n  return clamp(o,-1.,1.);\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2578, 2578, 2607, 2607, 2666], [2668, 2668, 2703, 2703, 2790], [2791, 2791, 2850, 2850, 2976], [2977, 2977, 3020, 3020, 3618], [3619, 3619, 3650, 3650, 3690], [3692, 3692, 3709, 3709, 4390], [4391, 4391, 4410, 4410, 4793], [4794, 4794, 4832, 4832, 5300]], "test": "untested"}
{"id": "tlcfzB", "name": "Bubblebum tiles", "author": "jeyko", "description": "potate", "tags": ["4d", "slice", "tiling", "bubblegum", "tiles"], "likes": 10, "viewed": 401, "published": 3, "date": "1612966948", "time_retrieved": "2024-07-30T19:39:15.991107", "image_code": "// slices of a 4d hyperlattice, as learned from blackle! \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    //fragColor.xyz = floor(fragColor.xyz*50.)/50.;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.2,1.));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.7545 + n*0.));\n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    //fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.;\n    \n    //fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nfloat cnt = 0.;\nvoid get(vec3 p, inout vec3 col, vec2 uv){\n    \n    \n    float df = fwidth(p.x);\n    float md = 0.3;\n    \n    vec3 id = floor(p/md + 0.5);\n    \n    \n    p = pmod(p,md);\n    \n    vec3 triCol = pal(0.5,0.5*vec3(1.,0.2,0.5),vec3(1,5. + 20.*id.y + iTime + uv.x,3),2.,id.x*5. + uv.x*1. + iTime);\n    \n    p = abs(p);\n    //triCol = mix(triCol,vec3(1),smoothstep(0.,4.,cnt));\n    \n    \n    {    \n        //col = mix(col,vec3(0.9),smoothstep(df,0.,abs(max(p.x,max(p.y,p.z)) - md*0.45) - md*0.01 ));\n    }\n    float env = pow(sin(fract(sin(id.x*20. + id.y*id.z*20.)*40.)*20. + id.y*10. + iTime*0.8*sin(id.x*20. + sin(id.z*20.)*20.)),5.);\n    p -= max(md*0.5*env,0.);\n    \n    if(sin(id.x + fract(sin(id.z)*10.)*200.) < 1.){\n        float d = max(p.x,max(p.y,p.z));\n        //d = abs(d);\n        col = mix(col,triCol,smoothstep(df,0.,d));\n        //col = mix(col,triCol,smoothstep(df,0.,abs((p).x)));\n\n    }\n    cnt ++;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= 0.5;\n    vec3 col = vec3(1,1.4,1.);\n    uv *= rot(0.5);\n    uv.y += iTime*0.1;\n    \n    vec3 p = vec3(uv,1);\nfloat vn = valueNoise(iTime*0.25,5.);\n    \n    p.yz *= rot(0.8);\n    p.yx *= rot(0.7  );\n    p.zx *= rot(-0.2 - iTime*0.);\n    \n    \n    //get(p*17.*2., col, uv);\n    get(p*16., col, uv);\n    get(p*8., col, uv);\n    \n    get(p*4., col, uv);\n    \n    get(p*0.5, col, uv);\n    \n    //get(p*1., col, uv);\n    \n    \n    col = pow(col,vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0. ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 117, 1037]], "test": "untested"}
{"id": "ttcfzB", "name": "Day 421", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 11, "viewed": 331, "published": 3, "date": "1612966108", "time_retrieved": "2024-07-30T19:39:16.759054", "image_code": "// tri sdf from iq \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.1,1.2,1.));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.15));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nmat3 getOrthogonalBasis(vec3 dir){\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\nfloat cyclicNoise(vec3 p){\n    \n    //p.yz *= rot(1.4);\n    \n    float n = 0.;\n    float amp = 1.;\n    float gain = 0.5;\n    float lac = 1.1 ;\n    \n    vec3 seed = normalize(vec3(3,-1,2));\n    mat3 rotm = getOrthogonalBasis(seed);\n\n    for(float i = 0.; i < 5.; i++){\n        p -= cos(p.zxy*1.5*gain*2. + iTime + i)*0.1;\n        n += (dot(sin(p), cos(p.zxy)))*amp;\n    \n        amp *= gain;\n        p *= lac*rotm;\n\n    }\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    \n    float vn = valueNoiseStepped(iTime/4.5 ,2.,3.);\n    \n    \n    vec3 col = vec3(1.,0.9,0.9)*1.;\n    \n    uv *= rot(0.5);\n    \n    col -= 0.1*smoothstep(0.4,0.3,texture(iChannel2,(uv + vec2(0,(iTime - vn)*0.1))*0.1 ,1.).x);\n    \n    float dfuv = fwidth(length(uv));\n    \n    vec2 p = uv;\n    float pixelW = dFdx(p.x);    \n    \n    \n    float gd = 10e5;\n    for(float j = 0.; j < 122.; j++){\n        vec2 r = r12(j);\n        float rb = r11(j);\n        vec2 p = uv;\n        \n        \n        \n        float t = iTime + r11(j)*140.;\n        \n        float sp = 1. + r.y*4. + vn*0.5;\n        \n        sp *= 2.8;\n        p.x += (sin(r.x*20.)*1. )*iResolution.x/iResolution.y*0.5;\n        \n        float tid = t/sp/1.95; \n        p.y -= mod(t/sp,1.95) - 1.;\n        \n        \n        p.xy *= rot(iTime*(r.y*1. - 0.5)*1.5 + r.y*20.);\n        \n        \n        vec3 c = vec3(0);\n        \n        vec3 ctri = vec3(1,0.4,1.);\n        vec3 triCol = pal(0.5,0.5*vec3(1.5,0.2,1),vec3(1,5. + 20.*r.y + iTime + uv.x,3),1.,r.x*3. + sin(iTime*0.25 )*0.8);\n        \n        \n        \n        #define getTri(p) sdTriangle( p , vec2(-0.1 - r.y*0.1,0.), vec2(0.1,-0.3*r.x),vec2(0.,0.1)) \n        float tri = getTri(p);\n        float trib = getTri(p + 0.01);\n        float tribD = smoothstep(pixelW,0.,trib);\n        \n        #define getBox(p) sdBox( p, vec2(0.1 + r.y*0.04,0.01))\n        float box = getBox(p);\n        float boxb = getBox(p + 0.01);\n        float boxbd = smoothstep(pixelW,0.,boxb);\n        \n        #define getCirc(p) abs(length( p) - 0.1) - 0.01\n        float ccirc = getCirc(p);\n        float ccircb= getCirc(p + 0.0);\n        float ccircbd = smoothstep(pixelW,0.,ccircb);\n        \n        \n        float circMod = 0.01;\n        float circD = smoothstep(pixelW,0.,length( pmod(p,circMod)) - circMod*0.1);\n        \n        float lineMod = 0.015;\n        float line = length( pmod((p*rot(0.4)).y,lineMod)) - lineMod*0.1;\n        float lineD = smoothstep(pixelW,0.,line);\n        \n        float bboxMod = 0.03;\n        vec2 q = pmod((p*rot(0.4)),bboxMod);\n        q = abs(q) - bboxMod*0.2;\n        float bbox = max(q.x,q.y)  ;\n        float bboxD = smoothstep(pixelW,0.,bbox);\n        \n        \n        \n        float d;\n        \n        if(r.x <  0.4){\n            d = tri;\n            c = triCol;\n             \n            vec3 nc = c*c*0.4;\n            col = mix(col, nc,circD*tribD);\n            c = mix(c,nc, circD*tribD);\n        } else if(r.x < 0.8){\n            d = box;\n            c = mix(triCol,vec3(1),0.5);\n            \n            vec3 nc = c*c*0.1;\n            nc.xz *= rot(0.5);\n            col = mix(col, nc,lineD*boxbd);\n            c = mix(c,nc, lineD*boxbd);\n            //gd = min(gd,max(line,-boxb));\n    \n        } else {\n            d = ccirc;\n            c = mix(triCol,vec3(1)*0.8,0.7);\n            \n            vec3 nc = c*1.*c;\n            nc.xz *= rot(-0.8);\n            col = mix(col, nc,bboxD*ccircbd);\n            c = mix(c,nc, bboxD*ccircbd);\n            \n        \n        \n        }\n        \n        vec3 oc = c;\n        oc -= 1.;\n        oc.xz *= rot(.1);\n        oc += 0.8;\n        c = mix(c, oc,smoothstep(pixelW,0.,gd));\n        \n        col = mix(col, c, smoothstep(pixelW,0.,d + 0.002));\n  \n        //if(vn < 0.1)\n        gd = min(gd,d);\n    }\n     \n    if(iMouse.z > 0.){\n        col =  1. - col;\n        col.xz *= rot(-.9);\n        col.yz *= rot(.3);\n        //col =  1. - col;\n        \n        }\n        \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0.1 ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float i){ return fract(sin(i*15.126)*115.6);}\n\nvec2 r12(float i){float r=r11(i );  return vec2(r,r11(i + r + 2.));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 951]], "test": "untested"}
{"id": "ttcBzB", "name": "test10022021", "author": "logicaldesign", "description": "test", "tags": ["test"], "likes": 0, "viewed": 215, "published": 3, "date": "1612960459", "time_retrieved": "2024-07-30T19:39:17.532985", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n    \n\n    \n     vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    xy.x = xy.x / iResolution.x; //We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    //vec4 solidRed = vec4(0,0.0,0.0,1.0); //This is actually black right now\n    // solidRed.r = xy.x; //Set its red component to the normalized x value\n    vec4 solidRed =  texture(iChannel0,xy);\n    solidRed.r = abs(sin(iTime));\n    solidRed.g *= abs(cos(iTime));\n    solidRed.b *= abs(sin(iTime) * cos(iTime));\n    fragColor = solidRed;  \n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 301, 921]], "test": "untested"}
{"id": "tlcfRB", "name": "iFrameRate vs 1./iTimeDelta", "author": "FabriceNeyret2", "description": "There is a +- 3 fps varying difference (white, zoomed) between iFrameRate (red) vs 1./iTimeDelta (green) :\nWhich is measuring what, exactly ?  ( iFrameRate strangely steppy + const along intervals )\n\nAlternate 5s of const cost and 5s of varying cost.", "tags": ["iframerate", "itimedelta"], "likes": 2, "viewed": 536, "published": 3, "date": "1612958260", "time_retrieved": "2024-07-30T19:39:18.421610", "image_code": "void mainImage( out vec4 O, vec2 U ) { O = T(U); }\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float y =  U.y/R.y;\n    O = U.x > 1.\n          ? T(U-vec2(1,0)) \n          : vec4( 4.*(2.*y-1.) < iFrameRate - 1./iTimeDelta  );\n          \n    if (mod(iTime,10.) < 5. ) { // every 5 seconds, 5 secondes of time varing \n        if (U.x<1.) O.rg *= .9;\n        for( float i=0.; i < (.5+.5*sin(.3*6.28*iTime))*1e4; i++) O.a++;\n    }\n        \n    if (U.x<1.) O = mix(O, vec4(1,0,0,0), max(0.,1.-abs( y -    iFrameRate/70. )/2.*R.y) ),\n                O = mix(O, vec4(0,1,0,0), max(0.,1.-abs( y - 1./iTimeDelta/70. )/2.*R.y) );\n                \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0 , ivec2(U) , 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 50]], "test": "untested"}
{"id": "tl3BzS", "name": "Iroment Rojec - Rhambec - A fork", "author": "404Glaciergargamel", "description": "Edit of [url]https://www.shadertoy.com/view/MttBRX[/url]", "tags": ["remix", "glitch", "fork", "hack", "error", "art", "edit", "chamber", "enviroment"], "likes": 1, "viewed": 243, "published": 3, "date": "1612947499", "time_retrieved": "2024-07-30T19:39:19.187561", "image_code": "struct Shape{\n  float dist;\n  vec4 color;\n};\n//=======================\n// Utility Functions\n//=======================\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.2, vec2(424.654, 256.546)))*56556.2);\n}\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(1, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t// distance to tip\n\tif ((q.y > height) && (projected < 1.)) {\n\t\td = max(d, length(tip));\n\t}\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 1)));\n\t}\n\treturn d;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.966025+q.y*0.6),q.y)-h.x);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat mixColors(float r, float v, float z){\n  return clamp(0.6+0.6*(v-r)/z, 0., 1.);\n}\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(2.-z);\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat pModPolar(inout vec2 v, float r){\n  float f = 7.28318/r;\n  float z = atan(v.y, v.x)+f*0.6;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.6;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.6);\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.6;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(3.)/((n-2.)*3.+sqrt(3.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(3.)/3.*r;\n\t\tp.x += columnradius*sqrt(3.);\n\t\tif (mod(n,3.) == 2.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*3.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.6));\n}\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.6 * (u + a + abs ((mod (u - a + s, 3.* s)) - s)));\n}\n//=======================\nShape environment(vec3 c){\n  Shape shape;\n  shape.dist = 2000.; // Draw Distance\n  shape.color = vec4(2.); // Initial Color\n  // Coordinate Systems\n  vec3 g = c; // Ground\n  vec3 p = c; // PlaceHolder\n  vec3 a = c; // Ground Texture\n  vec3 pill = c; // Pillars\n  vec3 s = c; // Side\n  vec3 pol = c; // Pole \n  vec3 l = c; // Lantern\n  vec3 h = c; // Hole in Lantern\n  // Ground\n  vec4 gColor = vec4(1.0, 0.2, 0.2, 0.1); \n  g.xy *= rot(radians(100.)); \n  g.x = abs(g.x) - 5.; \n  float ground = fBox(g+vec3(3.,0.6,3.), vec3(0.35, 4.25, 3000000.75));\n  // PlaceHolder\n  vec4 placeColor = vec4(1.,1.,1.,1.); \n  p.xy *= rot(radians(100.)); \n  float placeHolder = fBox(p+vec3(3.,3. ,5.), vec3(4., 1., 4.)); \n  // Ground Texture\n  vec4 gtColor = vec4(2.,2.,2.,2.); \n  a.xy *= rot(radians(100.)); \n  a.zy *= rot(radians(100.)); \n  a.z = abs(g.x) - 5. ;\n  pMod1(a.y, 2.);\n  // pMod1(a.x, 1.);\n  float groundTexture = sdHexPrism(a+vec3(1.7,1.0,2.2), vec2(0.8, 0.5)); \n  // Pillars\n  vec4 pColor = vec4(0.7, 0.9, 0.9, 1.); \n  pill.z = abs(pill.z) + 6.; \n  pill.x = abs(pill.x) - 2.; \n  pMod1(pill.z, 9.);\n  pill.xy *= rot(radians(100.));\n  float pillar = fBox(pill+vec3(1.,4.,2.5), vec3(3., 0.6, 1.)); \n  pillar = fOpUnionStairs(ground, pillar, 2.3, 5.);\n  // Side \n  //vec4 sColor = vec4(0.5, 0.6, 0.3, 0.0); \n  s.x = abs(s.x) - 7.; \n  pMod1(s.z, 6.); \n  float side = fBox(s+vec3(4.,2., -6.), vec3(0.3, .6, 7.)); \n  side = fOpUnionColumns(ground, side, 2.3, 5.); \n  // Lantern Pole\n  vec4 poleColor = vec4(2.,2.,2., 2.); \n  pMod1(pol.z, 8.5); \n  float pole = fBox(pol+vec3(1.,-0.25, -2.), vec3(0.2, 0.5, 0.2)); \n  // Lantern\n  vec4 lColor = vec4(2., 2., 1., 1.); \n  pMod1(l.z, 8.5);\n  float lantern = fBox(l+vec3(1., -0.2, -2.), vec3(0.4, 0.4, 0.4));   \n  // Hole in Lantern\n  pMod1(h.z, 8.5); \n  float hole = fBox(h+vec3(1., -0.2, -0.95), vec3(0.2, 0.2, 0.2)); \n  lantern = fOpEngrave(lantern, hole, 0.2);    \n  shape.dist = max(ground, -placeHolder);  \n  shape.dist = min(shape.dist, groundTexture); \n  shape.dist = min(shape.dist, pillar); \n  shape.dist = min(shape.dist, side); \n  shape.dist = min(shape.dist, pole); \n  shape.dist = min(shape.dist, lantern); \n  shape.dist = min(shape.dist, hole); \n  shape.color = mix(gColor, placeColor, mixColors(placeHolder, ground, 2.0));  \n  shape.color = mix(shape.color, gtColor, mixColors(groundTexture, shape.dist, 0.2));\n  shape.color = mix(shape.color, pColor, mixColors(pillar, shape.dist, 2.0));\n  shape.color = mix(shape.color, lColor, mixColors(lantern, shape.dist, 2.0)); \n  shape.color = mix(shape.color, poleColor, mixColors(pole, shape.dist, 2.0)); \n  //shape.color = mix(shape.color, sColor, mixColors(side, shape.dist, 0.3)); \n  return shape; \n}\nShape map(vec3 c){\n  Shape enviro = environment(c);\n  return enviro;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.6 * iResolution.xy) / iResolution.y;\n  vec3 cam = vec3(1., 1., iTime*4.);\n  cam.xy *= rot(radians(100.));\n  vec3 f = normalize(vec3(v, 0.2));\n  vec3 scene = cam;\n  //  scene.yx *= rot(iTime);\n  fragColor = vec4(0.5);\n  // Ray Marcher\n  for(float z = 0.2 ; z <= 2.; z += 0.04){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0002){\n      fragColor = c.color*(1.2-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 118, 140, 140, 207], [208, 208, 226, 226, 296], [297, 297, 346, 346, 841], [842, 842, 878, 878, 962], [963, 963, 983, 983, 1018], [1019, 1055, 1083, 1083, 1164], [1165, 1165, 1208, 1208, 1251], [1252, 1252, 1295, 1295, 1361], [1362, 1362, 1395, 1395, 1421], [1422, 1422, 1461, 1461, 1617], [1618, 1618, 1643, 1643, 1683], [1684, 1684, 1724, 1724, 1845], [1846, 1846, 1905, 1905, 2516], [2517, 2517, 2562, 2562, 2608], [2609, 2609, 2667, 2667, 2776], [2777, 2803, 2829, 2829, 5497], [5498, 5498, 5516, 5516, 5568], [5569, 5569, 5626, 5626, 6102]], "test": "untested"}
{"id": "wl3BRS", "name": "Interesting Shape Discovery", "author": "oneshade", "description": "I accidentally discovered this interesting shape by averaging distances.", "tags": ["3d", "raymarching", "distancefield", "sdf", "shape", "discovery"], "likes": 19, "viewed": 258, "published": 3, "date": "1612938132", "time_retrieved": "2024-07-30T19:39:20.092142", "image_code": "float Cube(in vec3 p) {\n    vec3 q = abs(p) - 0.75;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    return (Cube(p + vec3(-0.5,  0.0,  0.0)) +\n            Cube(p + vec3( 0.5,  0.0,  0.0)) +\n            Cube(p + vec3( 0.0, -0.5,  0.0)) +\n            Cube(p + vec3( 0.0,  0.5,  0.0)) +\n            Cube(p + vec3( 0.0,  0.0, -0.5)) +\n            Cube(p + vec3( 0.0,  0.0,  0.5))) / 6.0 + 0.08;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p / 2.0) * 2.0;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 2.0);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += n * max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3BRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 89], [91, 91, 118, 118, 520], [522, 522, 549, 549, 796], [798, 798, 853, 853, 1440]], "test": "untested"}
{"id": "tt3BRS", "name": "Panini Projection Visualization", "author": "TinyTexel", "description": "panini/pannini projection: http://tksharpless.net/vedutismo/Pannini/panini.pdf\ncamera controls via mouse + shift key\n\ntop knob - fov\nbot knob - d (for d=0 projection becomes rectilinear/vanilla perspective)", "tags": ["projection", "pannini", "panini"], "likes": 9, "viewed": 803, "published": 3, "date": "1612937647", "time_retrieved": "2024-07-30T19:39:21.185221", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\npanini/pannini projection: http://tksharpless.net/vedutismo/Pannini/panini.pdf\ncamera controls via mouse + shift key\n\ntop knob - fov\nbot knob - d (for d=0 projection becomes rectilinear/vanilla perspective)\n\nRelated:\n    https://www.shadertoy.com/view/Wt3fzB - \"Panini Projection\" (a simple scene rendered using the Panini projection)\n*/\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 A, B, C, D;\n\n\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi05 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n\nbool SceneRayCast(vec3 rp, vec3 rd, out vec3 c)\n{\n    vec3 vp, fm; float t;\n\tbool hit = false;\n    \n    float r = Pow2(0.03);\n    \n    vec2 tt;\n    if(Intersect_Ray_Sphere(rp, rd, vec3(0.0), r*2.0, tt) > 0.0 && (tt.x < t || !hit))// RED - projection center\n    {\n        hit = true;\n        t = tt.x;\n        \n        c = vec3(1.0, 0., 0.0);\n    }\n\n    float fov = Pi * min(A.x, 0.99999);\n    float d = B.x;\n    \n    float focalLen = 0.5 * tan(Pi05 - fov * 0.5);\n    \n    float aspect = iResolution.y/iResolution.x;\n    \n    \n    float count2 = 16.0;\n    for(float y = -1.0; y <= 1.0; y += 2.0)\n    for(float x = -1.0; x <= 1.0; x += 2.0)\n    for(float l =  1.0; l < count2; ++l)\n    {\n        vec3 sp = vec3(x, y, focalLen);\n        \n        sp.y *= aspect;\n        \n        sp = normalize(sp);\n        \n        sp *= l/count2;\n        \n        sp.z *= -1.0;\n        \n        vec2 tt;\n        if(Intersect_Ray_Sphere(rp, rd, sp, r, tt) > 0.0 && (tt.x < t || !hit))// MAGENTA - frustum pyramide edges\n        {\n            hit = true;\n            t = tt.x;\n\n            c = vec3(1.0, 0.0, 1.0);\n        }\n    }\n    \n    float count = 8.0;\n    for(float y = -count; y <= count; ++y)\n    for(float x = -count; x <= count; ++x)\n    {\n        vec2 tc = vec2(x, y*aspect)/count;\n    \n        vec3 sp = PaniniProjection(tc, fov, d);\n        //sp = normalize(vec3(tc, focalLen)); \n\n        sp.z *= -1.0;\n\n        vec2 tt;\n        if(Intersect_Ray_Sphere(rp, rd, sp, r, tt) > 0.0 && (tt.x < t || !hit))// BLACK - normalized view plane\n        {\n            hit = true;\n            t = tt.x;\n\n            c = vec3(0.0);\n            //c = vec3(tc.xy*0.5+0.5, 0.0);\n        }\n    }  \n    \n    return hit;\n}\n\n\nvec3 EvalSceneCol(vec3 rp, mat3 cmat, vec2 uv)\n{    \n    vec3 col = vec3(0.8);  \n    \n    vec2 tc = uv * (1.0 / (iResolution.xx*0.5)) - vec2(1.0, iResolution.y/iResolution.x);\n\n    float fov = 0.5;\n    float focalLen = 0.5 * tan(Pi05 - fov * 0.5);\n\n    vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n\n\tvec3 c;\n    if(SceneRayCast(rp, rd, /*out:*/ c))\n    {\n        col = c;\n    }\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    float knobVal   = ReadVar (I);\n\n    A.x = texelFetch(iChannel0, ivec2(0, 4), 0).w;\n    //A.y = texelFetch(iChannel0, ivec2(1, 4), 0).w;\n    //A.z = texelFetch(iChannel0, ivec2(2, 4), 0).w;\n    //A.w = texelFetch(iChannel0, ivec2(3, 4), 0).w;\n\n    B.x = texelFetch(iChannel0, ivec2(4, 4), 0).w;\n    //B.y = texelFetch(iChannel0, ivec2(5, 4), 0).w;\n    //B.z = texelFetch(iChannel0, ivec2(6, 4), 0).w;\n    //B.w = texelFetch(iChannel0, ivec2(7, 4), 0).w;\n\n    //C.x = texelFetch(iChannel0, ivec2( 8, 4), 0).w;\n    //C.y = texelFetch(iChannel0, ivec2( 9, 4), 0).w;\n    //C.z = texelFetch(iChannel0, ivec2(10, 4), 0).w;\n    //C.w = texelFetch(iChannel0, ivec2(11, 4), 0).w;\n\n    //D.x = texelFetch(iChannel0, ivec2(12, 4), 0).w;\n    //D.y = texelFetch(iChannel0, ivec2(13, 4), 0).w;\n    //D.z = texelFetch(iChannel0, ivec2(14, 4), 0).w;\n    //D.w = texelFetch(iChannel0, ivec2(15, 4), 0).w;\n        \n    vec2 ang = vec2(-0.3 * Pi, -Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    vec3 cpos = -cmat[2] * exp2(1.5 + mouseAccu.w * 0.02);\n    \n\n#if 0\n    // 1 sample\n    col = vec3(EvalSceneCol(cpos, cmat, uv0));\n#elif 1\n    // 3 samples ( https://www.shadertoy.com/view/3tdBWM )\n    uvec2 uvi = uvec2(uv);\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 2d Roberts sequence\n    const uint r0 = 3242174893u;\n    const uint r1 = 2447445397u;\n\n    float u = float((uvi.x * r0) + (uvi.y * r1)) * (1.0 / 4294967296.0);\n\n    if((uint(iFrame) & 1u) != 0u) u += 0.5;\n\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang))*0.333333;\n\n        col += vec3(EvalSceneCol(cpos, cmat, uv0 + off));\n    }\n    col *= 0.333333; \n#endif\n\n#if 1\nif(uv.x < 48.0*1.0 && abs(uv.y - iResolution.y*0.5) < 48.0 ||\n   uv.x < 64.0 && uv.y < 16.0)\n{    \n    // knobs\n    vec2 ui = texelFetch(iChannel0, ivec2(uv), 0).xy;\n    \n    col *= 1.0-ui.y;\n    col = mix(col, vec3(0.03), ui.x);\n}\n#endif\n\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 Resolution;\n\n#define Frame float(iFrame)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n#if 1\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat b = dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tt = vec2(-b);\n\t\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n#else\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n#endif\n\n// ============================================================================================================================= //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.n = n;\n\n    return state;\n}\n    \nKnobState GetKnobOfMat(int i, bool signed, float n)\n{\n    float x = float(uint(i) & 3u);\n    float y = float(uint(i) >> 2u);\n    \n    float s = 32.0 + 8.0;\n    \n    KnobState knob;\n    knob.p.x = s * 0.5 + x * s;\n    knob.p.y = s * 0.5 + y * s;\n    \n    knob.p.y = Resolution.y*0.5 + (s*1.0) - knob.p.y;\n\n    knob.r = vec2(16.0, 4.0);\n    knob.signed = signed;\n\tknob.n = n;\n    \n    return knob;\n}\n\nconst int KnobCount = 16;\nbool GetKnob(int i, out KnobState knob)\n{\n    switch(i)\n    {\n        case  0: knob = GetKnobOfMat(i, false, 0.6667);  return true;// A.x\n        //case  1: knob = GetKnobOfMat(i, false, 0.44); return true;// A.y\n      //case  2: knob = GetKnobOfMat(i, false, 0.0); return true;// A.z\n      //case  3: knob = GetKnobOfMat(i, false, 0.0); return true;// A.w\n      \n        case  4: knob = GetKnobOfMat(i, false, 0.75); return true;// B.x\n      //  case  5: knob = GetKnobOfMat(i, false, 0.4); return true;// B.y\n      //case  6: knob = GetKnobOfMat(i, false, 0.0); return true;// B.z\n      //case  7: knob = GetKnobOfMat(i, false, 0.0); return true;// B.w\n      \n      //case  8: knob = GetKnobOfMat(i, false, 0.0); return true;// C.x\n      //case  9: knob = GetKnobOfMat(i, false, 0.0); return true;// C.y\n      //case 10: knob = GetKnobOfMat(i, false, 0.0); return true;// C.z\n      //case 11: knob = GetKnobOfMat(i, false, 0.0); return true;// C.w\n      \n      //case 12: knob = GetKnobOfMat(i, false, 0.0); return true;// D.x\n      //case 13: knob = GetKnobOfMat(i, false, 0.0); return true;// D.y\n      //case 14: knob = GetKnobOfMat(i, false, 0.0); return true;// D.z\n      //case 15: knob = GetKnobOfMat(i, false, 0.0); return true;// D.w\n    }\n    \n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    return false;\n}\n\nbool GetKnob(int i, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n\tif(!GetKnob(i, /*out*/ knob)) return false;\n\n    if(!doInit)\n    knob.n = texelFetch(stateBuffer, ivec2(i, 4), 0).w;\n    \n    return i < KnobCount;\n}\n\nbool GetKnob(int i, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(i, stateBuffer, false, knob);\n}\n\nint GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    for(int i = 0; i < KnobCount; ++i)//TODO optimize loop away for knob array\n    {\n    \tif(!GetKnob(i, /*out*/ knob)) continue;\n        \n        if(SqrLen(uv - knob.p) < Pow2(knob.r.x + 4.0))\n        {\n\t        if(!doInit)\n            knob.n = texelFetch(stateBuffer, ivec2(i, 4), 0).w;\n\n            return i;\n        }\n    }\n    \n    return -1;\n}\n\nint GetKnob(vec2 uv, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(uv, stateBuffer, false, /*out*/ knob);\n}\n", "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* persistent state stuff and knobs */\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec2 Knob(vec2 uv, KnobState state)\n{\n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.15);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0.85, 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.15, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    return vec2(r, sh);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf) * 0.75;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    \n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    //KnobState stateLast = ReadKnobState(I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n    if(uv.y == 4.0)\n    {\n        KnobState knob;\n    \tif(GetKnob(int(uv.x), iChannel0, frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                knobVal = knob.n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;\n        }\n    }\n    \n    float knobVal0 = 0.0;\n    {\n        KnobState knob; int i;\n        if((i = GetKnob(iMouseClick.xy, iChannel0, /*out*/ knob)) >= 0)\n        {\n            knobVal0 = knob.n;\n            didInteractUI = true;\n        }\n        \n        //if(uv.y != 4.0) knobVal0 = knobVal;\n    }\n    \n    {\n        KnobState state;\n        bool isKnob = GetKnob(uv0, iChannel0, frameAccuLast == 0.0, /*out*/ state) >= 0;\n\n        if(isKnob)\n        {\n            vec2 k = Knob(uv0, state);\n            col.xy = vec2(k.x, 1.0 - k.y);\n        }\n        \n    \tValueText(col, uv0, knobVal0);\n    }\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n\t//WriteKnobState(state, uv, col, J);\n\n    WriteVar2(iMouseClick,  J);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BRS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[707, 707, 738, 738, 794], [795, 795, 826, 826, 877], [878, 878, 909, 909, 981], [982, 982, 1013, 1013, 1106], [1108, 1108, 1136, 1136, 1162], [1163, 1163, 1191, 1191, 1218], [1219, 1219, 1247, 1247, 1274], [1275, 1275, 1303, 1303, 1330], [1351, 1402, 1454, 1454, 2254], [2257, 2257, 2306, 2306, 3952], [3955, 3955, 4003, 4003, 4355], [4358, 4358, 4404, 4404, 7487]], "test": "untested"}
{"id": "Wt3fzB", "name": "Panini Projection", "author": "TinyTexel", "description": "panini/pannini projection: http://tksharpless.net/vedutismo/Pannini/panini.pdf\ncamera controls via mouse + shift key\n\ntop knob - fov\nbot knob - d (for d=0 projection becomes rectilinear/vanilla perspective)", "tags": ["projection", "pannini", "panini"], "likes": 53, "viewed": 2767, "published": 3, "date": "1612937639", "time_retrieved": "2024-07-30T19:39:22.402964", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\npanini/pannini projection: http://tksharpless.net/vedutismo/Pannini/panini.pdf\ncamera controls via mouse + shift key\n\ntop knob - fov\nbot knob - d (for d=0 projection becomes rectilinear/vanilla perspective)\n\nRelated:\n    https://www.shadertoy.com/view/tt3BRS - \"Panini Projection Visualization\" (simple visualization of the projection)\n*/\n    \n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 A, B, C, D;\n\n\nbool map0(vec3 p)\n{\n    p += 0.5;\n    vec3 b = abs(p);\n    \n    bool r;\n    \n    r =      b.x < 4.0;\n    r = r && b.y < 4.0;\n    r = r && b.z < 4.0;\n    \n    r = r && (b.x > 2.0 || b.y > 2.0);\n    r = r && (b.z > 2.0 || b.y > 2.0);\n    r = r && (b.x > 2.0 || b.z > 2.0);    \n    \n    return r;\n}\n\nbool map(vec3 p)\n{\n    float o = 2.0; \n    \n    return map0(p + vec3( -o, 0.0, 0.0)) != \n           map0(p + vec3(  o, 0.0, 0.0)) != \n           map0(p + vec3(0.0,  -o, 0.0)) != \n           map0(p + vec3(0.0,   o, 0.0)) != \n           map0(p + vec3(0.0, 0.0,  -o)) != \n           map0(p + vec3(0.0, 0.0,   o));\n}\n\nvec3 minmask(vec3 v)\n{\n    return vec3(v.x <= v.y && v.x <= v.z,\n                v.y <  v.z && v.y <  v.x,\n                v.z <  v.x && v.z <= v.y);\n}\n\n// https://www.shadertoy.com/view/3s23Ww\nbool VoxelRaycast(vec3 ro, vec3 rd, out vec3 vp, out vec3 N, out float t)\n{\n\tvp = floor(ro);\n\t\n    vec3 ri = 1.0/rd;\n    \n\tvec3 rs = vec3(rd.x < 0.0 ? -1.0 : 1.0,\n                   rd.y < 0.0 ? -1.0 : 1.0,\n                   rd.z < 0.0 ? -1.0 : 1.0);\n                     \n\tvec3 off = vec3(rd.x < 0.0 ? 0.0 : ri.x,\n                    rd.y < 0.0 ? 0.0 : ri.y,\n                    rd.z < 0.0 ? 0.0 : ri.z) - ro * ri;\n\n\tvec3 mm = vec3(0.0);\n    vec3 t3 = vec3(0.0);\n    \n\tbool hit = false;\n\tfor(int i = 0; i < 24; i++) \n\t{\n\t\tif(map(vp)) { hit = true; break; }\n        \n        t3 = vp * ri + off;\n\t\t\n        mm = minmask(t3);\n        \n        vp += mm * rs;\n\t}\n\t\n\tN = -rs * mm;\n    t = dot(t3, mm);\n\n\treturn hit;\n}\n\nbool SceneRayCast(vec3 rp, vec3 rd, out vec3 c, out vec3 n, out vec3 p)\n{\n    vec3 vp; float t;\n\tbool hit = VoxelRaycast(rp, rd, /*out:*/ vp, n, t);\n    \n    if(hit)\n    {\n        p = rp + rd * t;\n        \n        vec3 fm = abs(n);\n        \n        p = mix(p, round(p), equal(fm, vec3(1.0))) + (n * 1e-5);\n\n        bvec3 b = greaterThan(abs(fract(p) - 0.5), vec3(0.45));\n        float wf = ((b.z && (b.x || b.y)) || (b.x && (b.y || b.z)) ? 0.0 : 1.0);\n\n        c = (fm + fm.yzx*0.125) * wf;\n    }\n\n   #if 0\n    vec2 tt;\n    if(Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, tt) > 0.0 && (tt.x < t || !hit))\n    {\n        hit = true;\n        t = tt.x;\n        \n        p = rp + rd * t;\n        \n        n = normalize(p);\n        \n        p += n * 1.0/512.0;\n        \n        c = vec3(1.0, 0.5, 0.0);\n    }\n   #endif\n    \n    return hit;\n}\n\n\n// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]\nvec3 PaniniProjection(vec2 tc, float fov, float d)\n{\n    float d2 = d*d;\n\n    {\n        float fo = Pi05 - fov * 0.5;\n\n        float f = cos(fo)/sin(fo) * 2.0;\n        float f2 = f*f;\n\n        float b = (sqrt(max(0.0, Pow2(d+d2)*(f2+f2*f2))) - (d*f+f)) / (d2+d2*f2-1.0);\n\n        tc *= b;\n    }\n    \n    /* http://tksharpless.net/vedutismo/Pannini/panini.pdf */\n    float h = tc.x;\n    float v = tc.y;\n    \n    float h2 = h*h;\n    \n    float k = h2/Pow2(d+1.0);\n    float k2 = k*k;\n    \n    float discr = max(0.0, k2*d2 - (k+1.0)*(k*d2-1.0));\n    \n    float cosPhi = (-k*d+sqrt(discr))/(k+1.0);\n    float S = (d+1.0)/(d+cosPhi);\n    float tanTheta = v/S;\n    \n    float sinPhi = sqrt(max(0.0, 1.0-Pow2(cosPhi)));\n    if(tc.x < 0.0) sinPhi *= -1.0;\n    \n    float s = inversesqrt(1.0+Pow2(tanTheta));\n    \n    return vec3(sinPhi, tanTheta, cosPhi) * s;\n}\n\n\nvec3 EvalSceneCol(vec3 rp, mat3 cmat, vec2 uv)\n{    \n    vec3 col = vec3(0.8);  \n    \n    vec2 tc = uv * (1.0 / (iResolution.xx*0.5)) - vec2(1.0, iResolution.y/iResolution.x);\n    \n\n    vec3 rd;\n    {\n        float fov = min(A.x, 0.999999) * Pi;\n        float d = B.x;\n\n        rd = cmat * PaniniProjection(tc, fov, d);\n        //rd = normalize(cmat * vec3(tc, 0.5 * tan(Pi05 - fov * 0.5))); \n    }\n    \n    \n#if 1\n    vec2 tt; \n    float res = Intersect_Ray_Cube(rp, rd, vec3(6.0 + 1e-5), /*out:*/ tt);\n    \n    if(res == -1.0) { return col; }\n    \n    if(res == 1.0)\n    {\n    \trp += rd * tt.x;\n    }\n#endif\n    \n\tvec3 c, n, p;\n    if(SceneRayCast(rp, rd, /*out:*/ c, n, p))\n    {\n        vec3 r = n * (2.0 * dot(n, -rd)) + rd;\n        \n        col = c;\n        \n        vec3 n0;\n        if(!SceneRayCast(p, r, /*out:*/ c, n0, p)) {c = vec3(0.8);}\n        \n        col = mix(col, c, mix(0.05, 1.0, Pow5(1.0 - dot(-rd, n))));\n    }\n\n    return col;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    float knobVal   = ReadVar (I);\n\n    A.x = texelFetch(iChannel0, ivec2(0, 4), 0).w;\n    //A.y = texelFetch(iChannel0, ivec2(1, 4), 0).w;\n    //A.z = texelFetch(iChannel0, ivec2(2, 4), 0).w;\n    //A.w = texelFetch(iChannel0, ivec2(3, 4), 0).w;\n\n    B.x = texelFetch(iChannel0, ivec2(4, 4), 0).w;\n    //B.y = texelFetch(iChannel0, ivec2(5, 4), 0).w;\n    //B.z = texelFetch(iChannel0, ivec2(6, 4), 0).w;\n    //B.w = texelFetch(iChannel0, ivec2(7, 4), 0).w;\n\n    //C.x = texelFetch(iChannel0, ivec2( 8, 4), 0).w;\n    //C.y = texelFetch(iChannel0, ivec2( 9, 4), 0).w;\n    //C.z = texelFetch(iChannel0, ivec2(10, 4), 0).w;\n    //C.w = texelFetch(iChannel0, ivec2(11, 4), 0).w;\n\n    //D.x = texelFetch(iChannel0, ivec2(12, 4), 0).w;\n    //D.y = texelFetch(iChannel0, ivec2(13, 4), 0).w;\n    //D.z = texelFetch(iChannel0, ivec2(14, 4), 0).w;\n    //D.w = texelFetch(iChannel0, ivec2(15, 4), 0).w;\n        \n    vec2 ang = vec2(-0.1 * Pi, -Pi * 0.1);\n    ang += mouseAccu.xy * 0.008;\n\n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    vec3 cpos = -cmat[2] * exp2(1.5 + mouseAccu.w * 0.02);\n    \n\n#if 0\n    // 1 sample\n    col = vec3(EvalSceneCol(cpos, cmat, uv0));\n#elif 1\n    // 3 samples ( https://www.shadertoy.com/view/3tdBWM )\n    uvec2 uvi = uvec2(uv);\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 2d Roberts sequence\n    const uint r0 = 3242174893u;\n    const uint r1 = 2447445397u;\n\n    float u = float((uvi.x * r0) + (uvi.y * r1)) * (1.0 / 4294967296.0);\n\n    if((uint(iFrame) & 1u) != 0u) u += 0.5;\n\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang))*0.333333;\n\n        col += vec3(EvalSceneCol(cpos, cmat, uv0 + off));\n    }\n    col *= 0.333333; \n#endif\n\n#if 1\nif(uv.x < 48.0*1.0 && abs(uv.y - iResolution.y*0.5) < 48.0 ||\n   uv.x < 64.0 && uv.y < 16.0)\n{    \n    // knobs\n    vec2 ui = texelFetch(iChannel0, ivec2(uv), 0).xy;\n    \n    col *= 1.0-ui.y;\n    col = mix(col, vec3(0.03), ui.x);\n}\n#endif\n\n#if 1\n{\n    // vignetting\n    vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow3(s.x);    s.y = 1.0-Pow3(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n}\n#endif\n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 Resolution;\n\n#define Frame float(iFrame)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi2 = Pi * 2.0;\nconst float Pi05 = Pi * 0.5;\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\nfloat Pow5(float x) {return Pow4(x)*x;}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}   \n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)\n{\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\tbool inside = t.x < 0.0 && t.y > 0.0;\n    \n\tif(inside) {return 0.0;}\n\t\n\treturn t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n// ============================================================================================================================= //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.n = n;\n\n    return state;\n}\n    \nKnobState GetKnobOfMat(int i, bool signed, float n)\n{\n    float x = float(uint(i) & 3u);\n    float y = float(uint(i) >> 2u);\n    \n    float s = 32.0 + 8.0;\n    \n    KnobState knob;\n    knob.p.x = s * 0.5 + x * s;\n    knob.p.y = s * 0.5 + y * s;\n    \n    knob.p.y = Resolution.y*0.5 + (s*1.0) - knob.p.y;\n\n    knob.r = vec2(16.0, 4.0);\n    knob.signed = signed;\n\tknob.n = n;\n    \n    return knob;\n}\n\nconst int KnobCount = 16;\nbool GetKnob(int i, out KnobState knob)\n{\n    switch(i)\n    {\n        case  0: knob = GetKnobOfMat(i, false, 0.6667);  return true;// A.x\n        //case  1: knob = GetKnobOfMat(i, false, 0.44); return true;// A.y\n      //case  2: knob = GetKnobOfMat(i, false, 0.0); return true;// A.z\n      //case  3: knob = GetKnobOfMat(i, false, 0.0); return true;// A.w\n      \n        case  4: knob = GetKnobOfMat(i, false, 0.75); return true;// B.x\n      //  case  5: knob = GetKnobOfMat(i, false, 0.4); return true;// B.y\n      //case  6: knob = GetKnobOfMat(i, false, 0.0); return true;// B.z\n      //case  7: knob = GetKnobOfMat(i, false, 0.0); return true;// B.w\n      \n      //case  8: knob = GetKnobOfMat(i, false, 0.0); return true;// C.x\n      //case  9: knob = GetKnobOfMat(i, false, 0.0); return true;// C.y\n      //case 10: knob = GetKnobOfMat(i, false, 0.0); return true;// C.z\n      //case 11: knob = GetKnobOfMat(i, false, 0.0); return true;// C.w\n      \n      //case 12: knob = GetKnobOfMat(i, false, 0.0); return true;// D.x\n      //case 13: knob = GetKnobOfMat(i, false, 0.0); return true;// D.y\n      //case 14: knob = GetKnobOfMat(i, false, 0.0); return true;// D.z\n      //case 15: knob = GetKnobOfMat(i, false, 0.0); return true;// D.w\n    }\n    \n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    return false;\n}\n\nbool GetKnob(int i, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n\tif(!GetKnob(i, /*out*/ knob)) return false;\n\n    if(!doInit)\n    knob.n = texelFetch(stateBuffer, ivec2(i, 4), 0).w;\n    \n    return i < KnobCount;\n}\n\nbool GetKnob(int i, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(i, stateBuffer, false, knob);\n}\n\nint GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    for(int i = 0; i < KnobCount; ++i)//TODO optimize loop away for knob array\n    {\n    \tif(!GetKnob(i, /*out*/ knob)) continue;\n        \n        if(SqrLen(uv - knob.p) < Pow2(knob.r.x + 4.0))\n        {\n\t        if(!doInit)\n            knob.n = texelFetch(stateBuffer, ivec2(i, 4), 0).w;\n\n            return i;\n        }\n    }\n    \n    return -1;\n}\n\nint GetKnob(vec2 uv, sampler2D stateBuffer, out KnobState knob)\n{\n    return GetKnob(uv, stateBuffer, false, /*out*/ knob);\n}\n", "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* persistent state stuff and knobs */\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec2 Knob(vec2 uv, KnobState state)\n{\n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.15);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0.85, 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.15, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    return vec2(r, sh);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf) * 0.75;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    \n    //if(uv.y > 5.0) return;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    float knobVal       = ReadVar (I);\n    //KnobState stateLast = ReadKnobState(I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n    if(uv.y == 4.0)\n    {\n        KnobState knob;\n    \tif(GetKnob(int(uv.x), iChannel0, frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                knobVal = knob.n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;\n        }\n    }\n    \n    float knobVal0 = 0.0;\n    {\n        KnobState knob; int i;\n        if((i = GetKnob(iMouseClick.xy, iChannel0, /*out*/ knob)) >= 0)\n        {\n            knobVal0 = knob.n;\n            didInteractUI = true;\n        }\n        \n        //if(uv.y != 4.0) knobVal0 = knobVal;\n    }\n    \n    {\n        KnobState state;\n        bool isKnob = GetKnob(uv0, iChannel0, frameAccuLast == 0.0, /*out*/ state) >= 0;\n\n        if(isKnob)\n        {\n            vec2 k = Knob(uv0, state);\n            col.xy = vec2(k.x, 1.0 - k.y);\n        }\n        \n    \tValueText(col, uv0, knobVal0);\n    }\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(knobVal,       J);\n\t//WriteKnobState(state, uv, col, J);\n\n    WriteVar2(iMouseClick,  J);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3fzB.jpg", "access": "api", "license": "cc0-1.0", "functions": [[712, 712, 743, 743, 799], [800, 800, 831, 831, 882], [883, 883, 914, 914, 986], [987, 987, 1018, 1018, 1111], [1113, 1113, 1141, 1141, 1167], [1168, 1168, 1196, 1196, 1223], [1224, 1224, 1252, 1252, 1279], [1280, 1280, 1308, 1308, 1335], [1356, 1356, 1375, 1375, 1651], [1653, 1653, 1671, 1671, 1965], [1967, 1967, 1989, 1989, 2118], [2120, 2161, 2236, 2236, 2874], [2876, 2876, 2949, 2949, 3711], [3714, 3765, 3817, 3817, 4617], [4620, 4620, 4668, 4668, 5571], [5574, 5574, 5620, 5620, 8703]], "test": "untested"}
{"id": "3tcfzB", "name": "Pixel Food! Yum! Delicious fork", "author": "404Glaciergargamel", "description": "Edit of [url]https://www.shadertoy.com/view/4lSyRw[/url]", "tags": ["remix", "glitch", "square", "fork", "lightning", "lowres", "edit", "stepped", "buffered"], "likes": 3, "viewed": 289, "published": 3, "date": "1612932945", "time_retrieved": "2024-07-30T19:39:23.270645", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tfragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a) {\n\tfloat c = cos(a); float s = sin(a);\n    return mat2(c, s, -s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    uv *= 2.0*rot(iTime); \n    vec2 UV = fragCoord.xy - 0.5*iResolution.xy;\n    UV *= rot(0.2*sin(iTime))*(2.0 + 0.06*sin(0.6*iTime));\n    UV += 0.6*iResolution.xy;\n    UV /= iResolution.xy;\n    float s = abs(uv.x) + abs(uv.y); // \"Square\"\n    fragColor = 1.05*texture(iChannel0, UV);\n\tfragColor += vec4(2.0)*( step(2.0, s) - step(2.025, s));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 124]], "test": "untested"}
{"id": "3t3fzB", "name": "HDrippier Roomage, a fork", "author": "404Glaciergargamel", "description": "Edit of [url]https://www.shadertoy.com/view/MstGWX[/url]", "tags": ["water", "spotlight", "remix", "glitch", "fork", "box", "feedback", "edit", "wooden"], "likes": 1, "viewed": 269, "published": 3, "date": "1612931509", "time_retrieved": "2024-07-30T19:39:24.114388", "image_code": "mat3 boxxfrm;\nfloat box1(vec3 ro,vec3 rd)\n{\n    return min((sign(rd.x)-ro.x)/rd.x,min((sign(rd.y)-ro.y)/rd.y,(sign(rd.z)-ro.z)/rd.z));\n}\nvec2 box2(vec3 ro,vec3 rd)\n{\n    return vec2(max((-sign(rd.x)-ro.x)/rd.x,max((-sign(rd.y)-ro.y)/rd.y,(-sign(rd.z)-ro.z)/rd.z)),box1(ro,rd));\n}\nvec3 textureBox1(vec3 p)\n{\n    vec3 ap=abs(p),f=step(ap.zxy,ap.xyz)*step(ap.yzx,ap.xyz);\n    vec2 uv=f.x>.6?p.yz:f.y>.6?p.xz:p.xy;\n    float l=clamp(-normalize(p-vec3(1,2,1)).y,1.,2.);\n    vec2 b=box2(boxxfrm*p,boxxfrm*(vec3(1,2,1)-p));\n    // Some lighting and a shadow (and approximated AO).\n    float s=mix(.3,2.,smoothstep(1.,.9,length(p.xz)));\n    vec3 d=.7*(2.-smoothstep(-2.,2.,p.y))*vec3(0.4,0.4,.6)*s+smoothstep(1.0,1.07,l)*vec3(2,2,.9)*step(b.y,b.x);\n    return texture(iChannel1,uv).rgb*d;\n}\nvec3 textureBox2(vec3 p,vec3 p2)\n{\n    vec3 ap=abs(p),f=step(ap.zxy,ap.xyz)*step(ap.yzx,ap.xyz);\n    vec2 uv=f.x>.6?p.yz:f.y>.6?p.xz:p.xy;\n    vec3 n=normalize(-transpose(boxxfrm)*(f*sign(p)));\n    float l=clamp(-normalize(p2-vec3(1,2,1)).y,1.,2.);\n    vec3 d=2.*(2.-smoothstep(-2.,3.5,p2.y))*vec3(0.4,0.4,.8)+smoothstep(1.05,1.07,l)*clamp(-n.y,1.,2.)*3.*vec3(2,2,.9)+\n        \tsmoothstep(1.0,2.,l)*clamp(-n.y,1.,2.)*vec3(2,2,.9);\n    return texture(iChannel3,uv).rgb*d;\n}\nmat2 rotation2D(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time=iTime;\n    vec3 waterc=vec3(.65,.85,2.)*1.0;\n    // Set up the primary ray.\n    vec3 ro=vec3(1,.8,.9),rd=normalize(vec3((fragCoord-iResolution.xy/3.)/iResolution.y,-0.2));\n    rd.yz*=rotation2D(.8);\n    rd.xz*=rotation2D(time*.2);\n    ro.xz*=rotation2D(time*.2);\n    // These are the heights of the planes that the water surface lies within.\n    float h0=.2,h1=-.5;\n    float ba=time;\n    boxxfrm=mat3(cos(ba),sin(ba),1,-sin(ba),cos(ba),1,1,1,2)*\n        \t\tmat3(cos(ba),1,sin(ba),-sin(ba),1,cos(ba),1,2,1)*5.;\n    float t0=(h0-ro.y)/rd.y,t1=(h1-ro.y)/rd.y;\n    float bt2=box1(ro,rd);\n    vec2 bt3=box2(boxxfrm*ro,boxxfrm*rd);\n    // Raymarch through the water surface.\n    float ht=1.,h=1.;\n    vec2 uv;\n    const int n=356;\n    for(int i=1;i<n;++i)\n    {\n        ht=mix(t0,t1,float(i)/float(n));\n        vec3 hp=ro+rd*ht;\n        uv=hp.xz/3.+.6;\n        h=texture(iChannel0,uv).r;\n        if(h<float(i)/float(n))\n            break;\n    }\n    // Check primary ray intersection with the inner box.\n    if(bt3.x<bt3.y&&bt3.x<ht)\n    {\n        fragColor.rgb=textureBox2(boxxfrm*(ro+rd*bt3.x),ro+rd*bt3.x);\n        return;\n    }\n    // Check subsequent intersections after water surface intersection.\n    if(ht>1.&&ht<bt2)\n    {\n        const float e=2e-3;\n        float hdx=texture(iChannel0,uv+vec2(e,1.)).r;\n        float hdy=texture(iChannel0,uv+vec2(1.,e)).r;\n        vec3 norm=normalize(vec3(hdx,e,hdy));\n        float fresnel=2.-pow(clamp(2.-dot(-rd,norm),1.,2.),3.);\n        vec3 r=refract(rd,norm,2./2.333);\n        vec3 r2=reflect(rd,norm);\n        ro+=ht*rd;\n\t\tbt2=box1(ro,r);\n    \tbt3=box2(boxxfrm*ro,boxxfrm*r);\n\t\tfloat bt4=box1(ro,r2);\n    \tvec2 bt5=box2(boxxfrm*ro,boxxfrm*r2);\n        vec3 reflc,refrc;\n\t\treflc=textureBox1(ro+r*bt4);\n        if(bt5.x<bt5.y&&bt5.x>1.)\n        {\n            reflc=textureBox2(boxxfrm*(ro+r2*bt5.x),ro+r2*bt5.x);\n        }\n        refrc=textureBox1(ro+r*bt2);\n        if(bt3.x<bt3.y&&bt3.x>1.)\n        {\n            refrc=textureBox2(boxxfrm*(ro+r*bt3.x),ro+r*bt3.x);\n        } \n        fragColor.rgb=reflc*(2.-fresnel)+refrc*fresnel*waterc;\n    }\n    else\n\t\tfragColor.rgb=textureBox1(ro+rd*bt2);\n    // Apply (very simple) tone mapping and gamma.\n    fragColor.rgb=sqrt(clamp((fragColor.rgb/(fragColor.rgb+vec3(2.))),0.01,2.));\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float density=.9;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o=vec2(1.)/500.;\n    fragCoord/=iResolution.xy;\n\n    // Load the fluid buffer states. There are two, stored in R and G. Only R is changed per pass,\n    // and the two channels are swapped using a swizzle mask.\n    fragColor.rg=texture(iChannel0,fragCoord).gr;\n\n    fragColor.r = (texture(iChannel0,fragCoord+o*vec2( 0.,+1.)).r+\n        \t\ttexture(iChannel0,fragCoord+o*vec2( 0,-1)).r+\n                texture(iChannel0,fragCoord+o*vec2(-1, 0)).r+\n                texture(iChannel0,fragCoord+o*vec2(+1, 0)).r+\n                texture(iChannel0,fragCoord+o*vec2(-1,-1)).r+\n                texture(iChannel0,fragCoord+o*vec2(+1,-1)).r+\n                texture(iChannel0,fragCoord+o*vec2(-1,+1)).r+\n                texture(iChannel0,fragCoord+o*vec2(+1,+1)).r+\n                texture(iChannel0,fragCoord+o*vec2( 0, 0)).r)*2./9.-\n        \t\ttexture(iChannel0,fragCoord+o*vec2( 0, 0)).g;\n            \n   \n    // Add the interaction with the inner box.\n    float ba=iTime;\n    mat3 boxxfrm=mat3(cos(ba),sin(ba),0,-sin(ba),cos(ba),0,0,0,1)*\n        \t\tmat3(cos(ba),0,sin(ba),-sin(ba),0,cos(ba),0,1,0)*4.;\n    vec3 bp=vec3(fragCoord.x*2.-1.,.1,fragCoord.y*2.-1.);\n    vec3 bp2=boxxfrm*bp;\n    float bd=length(max(vec3(0.),abs(bp2)-vec3(1.)));\n    \n    if(bd<1e-3)\n   \t\tfragColor.r+=.03;\n\n    // Add some random drips.\n    float p=.01;\n    float c=floor(mod(iTime,64.)/p);\n    fragColor.r += (1.-smoothstep(0.,.01,distance(fragCoord,1.5*vec2(cos(c*11.),sin(c*7.1)))))*.8;    \n    \n    fragColor.r *= density;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 43, 43, 136], [137, 137, 165, 165, 279], [280, 280, 306, 306, 782], [783, 783, 817, 817, 1255], [1256, 1256, 1282, 1282, 1331], [1332, 1332, 1389, 1389, 3678]], "test": "untested"}
{"id": "3lcBzB", "name": "Emptymind is cool! It's a fork", "author": "404Glaciergargamel", "description": "Edit of [url]https://www.shadertoy.com/view/4lB3W3[/url]", "tags": ["procedural", "fractal", "remix", "fork", "edit"], "likes": 1, "viewed": 209, "published": 3, "date": "1612930309", "time_retrieved": "2024-07-30T19:39:25.191508", "image_code": "const float pi = 4.14159;\nmat3 xrot(float t)\n{\n    return mat3(2.0, 0.1, 0.1,\n                0.1, cos(t), -sin(t),\n                0.1, sin(t), cos(t));\n}\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.1, -sin(t),\n                0.1, 2.0, 0.1,\n                sin(t), 0.1, cos(t));\n}\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.1,\n                sin(t), cos(t), 0.1,\n                0.1, 0.1, 2.0);\n}\nvec3 paxis(vec3 p)\n{ /* thanks to eiffie */\n    vec3 a=abs(p),r = vec3(2.0,0.1,0.1);\n    if(a.z>=max(a.x,a.y))r=r.yzx;\n    else if(a.y>=a.x)r=r.zxy;\n    return r*sign(p);\n}\nfloat udBox( vec3 p, vec3 b )\n{ /* thanks to iq */\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBoxInfinite(vec3 p, vec3 b)\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.1) +\n         length(max(d,0.1));\n}\nfloat sdCylinderInfinite(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\nvec3 func(vec3 p, float s)\n{\n    vec3 off = paxis(p) * s * 2.5;\n    p -= off;\n    p -= sign(p) * s * 3.75;\n    return p;\n}\nvec2 map(vec3 p)\n{\n    p.x += sin(p.z);\n    vec3 op = p;\n    float k = 26.0;\n    p.z = (fract(p.z/k) * 3.0 - 2.0) * k * 0.6;\n    vec3 ip = p;\n    float bs = 2.0;\n    float r = 0.1;\n    float d = 2000.0;\n    for (int i = 1; i < 6; ++i) {\n        ip = func(ip, bs);\n        float fd = udBox(ip, vec3(bs));\n        if (fd < d) {\n            d = fd;\n            r = float(i);\n        }\n        bs *= 0.6;\n\t}\n    d = max(d, -sdBoxInfinite(p,vec3(2.0)));\n    float ck = 9.0;\n    vec3 pc = vec3(p.x, p.y, (fract(op.z/ck)*3.0-2.0)*ck*0.6);\n    d = max(d, -sdCylinderInfinite(pc, 3.0));\n    float ground = p.y + 1.0;\n    if (ground < d) {\n        d = ground;\n        r = 7.0;\n    }\n    return vec2(d,r);\n}\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.02, 0.1, 0.1);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n                          map(p+o.yxy).x - map(p-o.yxy).x,\n                          map(p+o.yyx).x - map(p-o.yyx).x));\n}\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.1;\n    for (int i = 1; i < 42; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d * 0.6;\n    }\n    return t;\n}\nvec3 _texture(vec3 p)\n{\n    vec3 ta = texture(iChannel0, vec2(p.y,p.z)).xyz;\n    vec3 tb = texture(iChannel0, vec2(p.x,p.z)).xyz;\n    vec3 tc = texture(iChannel0, vec2(p.x,p.y)).xyz;\n    return (ta + tb + tc) / 4.0;\n}\nfloat aoc(vec3 origin, vec3 ray) {\n    float delta = 0.2;\n    const int samples = 7;\n    float r = 0.1;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = map(pos).x;\n        float len = abs(t - dist);\n        r += len * pow(3.0, -float(i));\n    }\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 3.0 - 2.0;\n    uv.x *= iResolution.x / iResolution.y;   \n\tvec3 o = vec3(0.1, 0.1, 0.1);\n    o.z += iTime * 0.6;\n    o.x = sin(-o.z);\n    vec3 r = normalize(vec3(uv, 2.3));\n    r *= yrot(o.x);\n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec2 mp = map(w);\n    float fd = mp.x;\n    float it = mp.y;\n    vec3 sn = normal(w);\n\tfloat fog = 2.0 / (2.0 + t * t * 0.2 + fd * 200.0);\n    vec3 diff = _texture(w);\n    if (it == 3.0) {\n        diff *= 0.6;\n    } else if (it == 2.0) {\n        diff = diff.xxx * 2.5;\n    } else if (it == 1.0) {\n        diff *= vec3(2.0, 2.0, 0.1);\n    }\n    float sz = w.x + sin(w.z);\n    if (it == 6.0) {\n        float m = 0.6+0.6*sign(fract(w.z*20.0+abs(sz)*20.0)-0.6);\n        float k = 0.6+0.6*sign(abs(sz)-0.9);\n        float ik = 0.6+0.6*sign(abs(sz)-1.0);\n        float cm = k*(2.0-ik);\n        vec3 tape = vec2(m*k,0.1).xxy;\n        diff = mix(diff*0.6, tape, cm);\n    }\n    vec3 lighting = vec3(0.7);\n    for (int i = -2; i <= 3; ++i) {\n        float lz = floor(w.z+float(i)+0.6);\n        vec3 lpos = vec3(-sin(lz), 0.1, lz);\n        vec3 lcol = vec3(2.0);\n        float lmod = mod(lz,4.0);\n        if (lmod == 0.0) {\n            lcol = vec3(0.1,0.1,2.0) * (0.6+0.6*sin(iTime));\n            lpos.y = 2.0;\n        } else if (lmod == 2.0) {\n            lcol = vec3(0.1, 2.0, 0.1);\n            lpos.y = 0.35;\n            lpos.x += cos(lz);\n        } else {\n         \tlcol = vec3(2.0, 0.1, 0.1);\n            lpos.y = -0.35;\n            lpos.x -= cos(lz);\n        }\n        vec3 ldel = lpos - w;\n        float ldist = length(ldel);\n        ldel /= ldist;\n        float lprod = max(dot(sn,ldel),0.1);\n        float latten = 2.0 / (2.0 + ldist * ldist);\n        lighting += lprod * latten * lcol;\n    }\n    diff *= lighting * fog;\n\tfragColor = vec4(diff,2.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 155], [156, 156, 176, 176, 285], [286, 286, 306, 306, 415], [416, 416, 436, 459, 588], [589, 589, 620, 639, 677], [678, 678, 715, 715, 808], [809, 809, 852, 852, 883], [884, 884, 912, 912, 1006], [1007, 1007, 1025, 1025, 1703], [1704, 1704, 1725, 1725, 1938], [1939, 1939, 1968, 1968, 2120], [2121, 2121, 2144, 2144, 2338], [2339, 2339, 2373, 2373, 2684], [2685, 2685, 2742, 2742, 4594]], "test": "untested"}
{"id": "Wt3BzB", "name": "3D Distance Field Buffering", "author": "oneshade", "description": "Ever dreamed of generating distance fields by brute force?", "tags": ["3d", "distancefield", "sdf", "buffering", "storage"], "likes": 16, "viewed": 243, "published": 3, "date": "1612926785", "time_retrieved": "2024-07-30T19:39:26.072154", "image_code": "/*\nAfter lots of things going wrong I finally have this working!\nThe distance field can be generated and stored in Buffer A and then\nloaded during raymarching. I think it might be useful for expensive\ndistance fields. Perhaps 3D fluid simulations? The resolution is\npretty limited right now. I'll have to try filling up all color\nchannels to get maximum storage (up to 4x more!).\n*/\n\n// filt 0: no filter\n// filt 1: trilinear\n// filt 2: tricubic\n#define fetch(p) texelFetch(iChannel0, ivec2(_322(p, SIZE, RESOLUTION, iChannelResolution[0].xy)), 0).r\nfloat sampleDistanceField(in vec3 p, in int filt) {\n    vec3 halfSize = 0.5 * SIZE;\n    if (all(lessThan(abs(p), halfSize))) {\n        vec3 sp = mod(p + halfSize, SIZE) - halfSize;\n        if (filt == 0) {\n            return fetch(sp);\n        }\n\n        else {\n            vec3 UNIT = SIZE / RESOLUTION;\n            vec3 cell = floor(sp / UNIT) * UNIT;\n            vec3 local = fract(sp / UNIT);\n\n            if (filt == 2) local *= local * (3.0 - 2.0 * local);\n\n            float ldb = fetch(cell);\n            float rdb = fetch(cell + vec3(UNIT.x, 0.0, 0.0));\n            float lub = fetch(cell + vec3(0.0, UNIT.y, 0.0));\n            float rub = fetch(cell + vec3(UNIT.xy, 0.0));\n            float ldf = fetch(cell + vec3(0.0, 0.0, UNIT.z));\n            float rdf = fetch(cell + vec3(UNIT.x, 0.0, UNIT.z));\n            float luf = fetch(cell + vec3(0.0, UNIT.yz));\n            float ruf = fetch(cell + UNIT);\n\n            return mix(mix(mix(ldb, rdb, local.x), mix(lub, rub, local.x), local.y),\n                       mix(mix(ldf, rdf, local.x), mix(luf, ruf, local.x), local.y), local.z);\n        }\n    }\n\n    vec3 q = abs(p) - halfSize + 0.25;\n    float bbox = max(q.x, max(q.y, q.z));\n    return bbox;\n}\n\nfloat mapScene(in vec3 p) {\n    return sampleDistanceField(p, 1);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.05, 0.0, 0.0); // Cheap smoothing effect (kind of like a box blur on the distance field)\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0);\n    if (iMouse.z > 0.0) mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Ray and light direction\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Intersect bbox to prevent raymarching artifacts\n    float t = iBox(ro, rd, SIZE * 0.49); // The box has to be a bit smaller to prevent artifacts\n    if (t > 0.0) {\n        vec3 p = ro + rd * t;\n        if (mapScene(p) > 0.0) {\n            for (int i=0; i < 100; i++) {\n                vec3 p = ro + rd * t;\n                float d = mapScene(p);\n                if (d < 0.001) {\n                    vec3 n = getNormal(p);\n                    fragColor.rgb += max(0.2, dot(n, l));\n                    break;\n                }\n\n                if (t > 100.0) {\n                    break;\n                }\n\n                t += d;\n            }\n        }\n\n        else {\n            vec3 n = getNormal(p);\n            fragColor.rgb += max(0.2, dot(n, l));\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// RESOLUTION is the number of distance samples, SIZE is the space it maps to\n#define RESOLUTION vec3(45.0)\n#define SIZE vec3(3.5)\n\nvec3 _223(in vec2 p2D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p2D = floor(p2D);\n    float p1D = p2D.y * res2D.x + p2D.x;\n    float x = mod(p1D, res3D.x);\n    float y = mod(p1D - x, res3D.x * res3D.y) / res3D.x;\n    float z = (p1D - x - y * res3D.x) / res3D.x / res3D.y;\n    return vec3(x, y, z) / res3D * size3D - 0.5 * size3D;\n}\n\nvec2 _322(in vec3 p3D, in vec3 size3D, in vec3 res3D, in vec2 res2D) {\n    p3D = floor(p3D / size3D * res3D + 0.5 * res3D);\n    float p1D = p3D.z * res3D.x * res3D.y + p3D.y * res3D.x + p3D.x;\n    float x = mod(p1D, res2D.x);\n    float y = (p1D - x) / res2D.x;\n    return vec2(x, y);\n}\n\n// Box intersector from https://www.shadertoy.com/view/ld23DV\nfloat iBox(in vec3 ro, in vec3 rd, in vec3 b) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * b;\n    vec3 t1 = -(k + n);\n    vec3 t2 = +(k - n);\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    return tN;\n}", "buffer_a_code": "// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash13(in float x) {\n   vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p3 += dot(p3, p3.yzx + 33.33);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(1000000.0, 0.0, 0.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n\n        if (iFrame % 5 == 0) {\n            vec3 p = _223(fragCoord, SIZE, RESOLUTION, iResolution.xy);\n            for (float i=0.0; i < 1.0; i++) {\n                float id = (iTime + i) * 1000.0;\n                vec3 pos = Hash13(id) * SIZE - 0.5 * SIZE;\n                float shape = Hash11(id + 473.847);\n\n                float size = Hash11(id) * 0.5;\n                vec3 q = abs(p - pos) - size;\n                float newShape = max(q.x, max(q.y, q.z));\n                if (shape > 0.333) {\n                    newShape = length(p - pos) - size;\n                }\n\n                if (shape > 0.666) {\n                    newShape = length(vec2(length(p.xy - pos.xz) - size, p.z - pos.y)) - 0.5 * size;\n                }\n\n                fragColor.r = min(fragColor.r, newShape);\n            }\n\n            if (int(iTime) % 10 == 0) fragColor.r = 1000000.0;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3BzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 601, 601, 1759], [1761, 1761, 1788, 1788, 1828], [1830, 1830, 1857, 1857, 2177], [2179, 2179, 2234, 2234, 3668]], "test": "untested"}
{"id": "3lcBzS", "name": "Fork Simple 2d  cwook 515", "author": "cwook", "description": "An attempt to change it to an additive approach.\n\nA very basic implementation of 2d shadows (move mouse to reposition light-source).\n\n", "tags": ["2d", "raycast", "shadow"], "likes": 3, "viewed": 294, "published": 3, "date": "1612918032", "time_retrieved": "2024-07-30T19:39:26.926869", "image_code": "#define N 250.0\n\n#define USE_BLUE_NOISE\n\n// these offset define how the \"jitter\" works for the shadows\nconst vec2 scatter[] = vec2[6]\n(\n    vec2( 0.01, -0.01),\n    vec2( 0.02,  0.01),\n    vec2(-0.01, -0.02),\n    vec2(-0.02,  0.01),\n    vec2( 0.01,  0.02),\n    vec2(-0.02, -0.01)\n);\n\nfloat terrain(vec2 p)\n{\n    return step(0.25, texture(iChannel0, 0.0625 + p / 2.0).x); // hard shadows\n    //return mix(0.9, 1.0, step(0.25, texture(iChannel0, 0.0625 + p / 2.0).x)); // smooth shadows\n}\n\nfloat doLight(vec2 p, vec2 l)\n{\n\n    float h = 1.0;\n    vec2 d = p - l;\n    for(float i = 0.0; i < N; i++)\n    {\n        float t = i / N;\n        \n        for (int j = 0; j < 3; j++)\n        {\n        #ifdef USE_BLUE_NOISE\n            vec2 n = (texture(iChannel3, vec2(float(j) / N, 0.0f)).rg - 0.5f) * 0.1f;\n        #else\n            vec2 n = 0.3f * scatter[j];\n        #endif\n            h *= mix(1.0, terrain(mix(p, l + n, t)), length(n) * 1.f);// float(j) / N);\n        }\n    }\n    h *= 1.0 - smoothstep(0.0, 0.5, length(d));\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    float b = 0.0;\n    float h = 1.0;\n    \n    vec2 l = iFrame <= 0 ? vec2(0.5, 0.5) : iMouse.xy/iResolution.xy;\n    b += doLight(p, l);\n    \n    vec2 l2 = vec2(0.2, (sin(iTime) + 1.0) * 0.5);\n    b += doLight(p, l2);\n    \n    //b = clamp(b, 0.0, 1.0);\n    \n    //b *= 0.2 / length(d);\n    //b *= 1.0 - smoothstep(0.0, 0.5, length(d));\n    //fragColor = b * texture(iChannel1, p * 4.0);\n    fragColor = mix(texture(iChannel2, p * 4.0) * 0.125, texture(iChannel1, p * 4.0), b);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 283, 306, 306, 485], [487, 487, 518, 518, 1032], [1034, 1034, 1091, 1091, 1610]], "test": "untested"}
{"id": "3tcBzS", "name": "trichromie points", "author": "ManuManu", "description": "A try for some effect on video", "tags": ["video", "filter", "postprocess", "points", "trichromie"], "likes": 4, "viewed": 367, "published": 3, "date": "1612915817", "time_retrieved": "2024-07-30T19:39:27.778591", "image_code": "\n\nfloat dots( vec2 uv, float angle, vec2 center )\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    uv -= center;\n    \n    uv = vec2( uv.x * s + uv.y * c, -uv.x * c + uv.y * s);\n    uv *= mix( 500., 300., length(uv));\n    //uv *= 300.;\n    return pow(sin(uv.x)*sin(uv.y), .8)*2.;\n    //return sin(uv.x)*sin(uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture( iChannel0, uv ).xyz;\n    \n    col.r *= dots(uv, 10., vec2(.5,.5)); \n    col.g *= dots( uv, 20., vec2(.5,.3));\n    col.b *= dots( uv, 30., vec2(.3,.6));\n\n// Output to screen\n    //col = vec3(dots(uv, 10., vec2(.5,.5)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 51, 51, 328], [331, 331, 388, 438, 759]], "test": "untested"}
{"id": "WlcfRS", "name": "Golden apollian", "author": "mrange", "description": "Licence CC0: Golden apollian\nMore late night coding\n", "tags": ["2d", "fractal", "apollian"], "likes": 70, "viewed": 1211, "published": 3, "date": "1612911149", "time_retrieved": "2024-07-30T19:39:28.554517", "image_code": "// Licence CC0: Golden apollian\n// More late night coding\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x, x)\n#define PLANE_PERIOD    5.0\n\nconst vec3 std_gamma   = vec3(2.2, 2.2, 2.2);\nconst vec3 planeCol    = vec3(1.0, 1.2, 1.5);\nconst vec3 baseRingCol = pow(vec3(1.0, 0.65, 0.25), vec3(0.6));\nconst vec3 sunCol      = vec3(1.25, 1.0, 1.1)/1.25;\n\nstruct effect {\n  float lw;\n  float tw;\n  float sk;\n  float cs;\n};\n\nconst effect effects[] = effect[](\n    effect(0.125, 0.0, 0.0, 0.0)\n  , effect(0.125, 0.0, 0.0, 1.0)\n  , effect(0.125, 0.0, 1.0, 1.0)\n  , effect(0.125, 1.0, 1.0, 1.0)\n  , effect(0.125, 1.0, 1.0, 0.0)\n  , effect(0.125, 1.0, 0.0, 0.0)\n  );\neffect current_effect = effects[5];\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n  hp = toRect(hpp);\n  p = hp;\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n  for(int i=0; i<7; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n    float r2 = dot(p,p);\n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n\n  float lw = 0.00125*current_effect.lw;\n  \n  float d0 = abs(p.y)-lw*scale;\n  float d1 = abs(circle(p.xz, 0.005*scale))-lw*scale;\n  float d = d0;\n  d = mix(d, min(d, d1), current_effect.tw);\n  return (d/scale);\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\nfloat weird(vec2 p, float h) {\n  float z = 4.0;\n  float tm = 0.1*TIME+h*10.0;\n  p *= ROT(tm*0.5);\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh_approx(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp /= z;\n  float d = apollian(pp, 0.8+h);\n  return d*z;\n}\n\nfloat circles(vec2 p) {\n  vec2 pp = toPolar(p);\n  const float ss = 2.0;\n  pp.x = fract(pp.x/ss)*ss;\n  p = toRect(pp);\n  float d = circle(p, 1.0);\n  return d;\n}\n\nvec2 df(vec2 p, float h) {\n  vec2 wp = p;\n  float rep = 2.0*round(mix(5.0, 15.0, h*h));\n  float ss = 0.05*6.0/rep;\n\n  if (current_effect.sk > 0.0) {\n    smoothKaleidoscope(wp, ss, rep);\n  }\n  \n  float d0 = weird(wp, h);\n  float d1 = hex(p, 0.25)-0.1;\n  float d2 = circles(p);\n  const float lw = 0.0125;\n  d2 = abs(d2)-lw;\n  float d = d0;\n\n  if (current_effect.cs > 0.0) {\n    d  = pmin(d, d2, 0.1);\n  }\n\n  d  = pmin(d, abs(d1)-lw, 0.1);\n  d  = max(d, -(d1+lw));\n  return vec2(d, d1+lw);\n}\n\nvec2 df(vec3 p, vec3 off, float s, mat2 rot, float h) {\n  vec2 p2 = p.xy;\n  p2 -= off.xy;\n  p2 *= rot;\n  return df(p2/s, h)*s;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return 1.0*sunCol*tanh_approx(3.0*pow(ld, 100.0));\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float pd, vec3 off, float aa, float n) {\n  int pi = int(mod(n/PLANE_PERIOD, float(effects.length())));\n  current_effect = effects[pi];\n  \n  float h = hash(n);\n  float s = 0.25*mix(0.5, 0.25, h);\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 nor  = vec3(0.0, 0.0, -1.0);\n  const vec3 loff = 2.0*vec3(0.25*0.5, 0.125*0.5, -0.125);\n  vec3 lp1  = ro + loff;\n  vec3 lp2  = ro + loff*vec3(-2.0, 1.0, 1.0);\n\n  vec2 p = pp.xy-off.xy;\n\n  mat2 rot = ROT(TAU*h);\n\n  vec2 d2 = df(pp, off, s, rot, h);\n\n  vec3 ld1   = normalize(lp1 - pp);\n  vec3 ld2   = normalize(lp2 - pp);\n  float dif1 = pow(max(dot(nor, ld1), 0.0), 5.0);\n  float dif2 = pow(max(dot(nor, ld2), 0.0), 5.0);\n  vec3 ref   = reflect(rd, nor);\n  float spe1= pow(max(dot(ref, ld1), 0.0), 30.0);\n  float spe2= pow(max(dot(ref, ld2), 0.0), 30.0);\n\n  const float boff = 0.0125*0.5;\n  float dbt = boff/rd.z;\n  \n  vec3 bpp = ro + (pd + dbt)*rd;\n  vec2 bp = bpp.xy - off.xy;\n\n  vec3 srd1 = normalize(lp1-bpp);\n  vec3 srd2 = normalize(lp2-bpp);\n  float bl21= L2(lp1-bpp);\n  float bl22= L2(lp2-bpp);\n\n  float st1 = -boff/srd1.z;\n  float st2 = -boff/srd2.z;\n\n  vec3 spp1 = bpp + st1*srd1;\n  vec3 spp2 = bpp + st2*srd2;\n  \n  vec2 bd  = df(bpp, off, s, rot, h);\n  vec2 sd1 = df(spp1, off, s, rot, h);\n  vec2 sd2 = df(spp2, off, s, rot, h);\n\n  vec3 col  = vec3(0.0);\n  const float ss = 200.0;\n\n  col       += 0.1125*planeCol*dif1*(1.0-exp(-ss*(max((sd1.x), 0.0))))/bl21;\n  col       += 0.1125*planeCol*dif2*0.5*(1.0-exp(-ss*(max((sd2.x), 0.0))))/bl22;\n  \n  vec3 ringCol = baseRingCol;\n  ringCol *= vec3(clamp(0.1+2.5*(0.1+0.25*((dif1*dif1/bl21+dif2*dif2/bl22))), 0.0, 1.0));\n  ringCol += sqrt(baseRingCol)*spe1*2.0;\n  ringCol += sqrt(baseRingCol)*spe2*2.0;\n  col       = mix(col, ringCol, smoothstep(-aa, aa, -d2.x));  \n\n  float ha = smoothstep(-aa, aa, bd.y);\n\n  return vec4(col, mix(0.0, 1.0, ha));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0-0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 9;\n  const int fadeFrom = max(furthest-4, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, pd, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 color(vec2 p, vec2 q) {\n  float tm  = TIME*0.125;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 5.0, TIME);\n  col = postProcess(col, q);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1201, 1201, 1223, 1223, 1286], [1288, 1288, 1310, 1310, 1354], [1356, 1356, 1377, 1377, 1422], [1424, 1424, 1469, 1469, 1623], [1625, 1625, 1686, 1686, 1894], [1896, 1896, 1936, 1936, 2095], [2097, 2097, 2137, 2137, 2179], [2181, 2181, 2209, 2229, 2305], [2307, 2307, 2346, 2346, 2434], [2436, 2436, 2467, 2467, 2493], [2495, 2495, 2523, 2523, 2723], [2725, 2725, 2758, 2758, 3142], [3315, 3336, 3358, 3358, 3492], [3494, 3573, 3596, 3596, 3671], [3673, 3743, 3767, 3767, 3846], [4028, 4028, 4058, 4058, 4434], [4436, 4436, 4459, 4459, 4595], [4597, 4597, 4623, 4623, 5085], [5087, 5087, 5142, 5142, 5215], [5217, 5217, 5250, 5250, 5358], [5360, 5360, 5438, 5438, 7258], [7260, 7260, 7316, 7316, 8859], [8861, 8861, 8897, 8897, 9130], [9132, 9132, 9160, 9160, 9556], [9558, 9558, 9613, 9613, 9769]], "test": "untested"}
{"id": "3tcfRS", "name": "Day 420", "author": "jeyko", "description": "weedato", "tags": ["mdtmjvm"], "likes": 30, "viewed": 894, "published": 3, "date": "1612904324", "time_retrieved": "2024-07-30T19:39:29.322464", "image_code": "\n// modern gpus can't handle my weed, it's so strong! \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.1,1.2,1.));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.05));\n    \n    \n    \n    //fragColor = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nmat3 getOrthogonalBasis(vec3 dir){\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\nfloat cyclicNoise(vec3 p){\n    \n    //p.yz *= rot(1.4);\n    \n    float n = 0.;\n    float amp = 1.;\n    float gain = 0.5;\n    float lac = 1.1 ;\n    \n    vec3 seed = normalize(vec3(3,-1,2));\n    mat3 rotm = getOrthogonalBasis(seed);\n\n    for(float i = 0.; i < 5.; i++){\n        p -= cos(p.zxy*1.5*gain*2. + iTime + i)*0.1;\n        n += (dot(sin(p), cos(p.zxy)))*amp;\n    \n        amp *= gain;\n        p *= lac*rotm;\n\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 oouv = uv;\n    \n    \n    \n    //vec3 col = vec3(0.7,0.9,0.9)*0.2;\n    vec3 col = vec3(0.4,0.5,0.1)*0.1;\n        \n    \n    float n = cyclicNoise(vec3(uv*5.,iTime*0.5 + 4.));\n    \n    n = cyclicNoise(vec3(uv*10. + n*1.15,iTime));\n        \n    float nb = cyclicNoise(vec3(uv*5.,iTime));\n    \n    float vn = valueNoise(iTime*0.25,5.);\n    float vnb = valueNoiseStepped(iTime/2. + n*0.*pow(vn,0.5) + 5.,2.,4.);\n    float vnc = valueNoiseStepped(iTime/2.,4.,4.);\n    \n    \n    float dfuv = fwidth(length(uv));\n    \n    vec2 p = uv;\n        \n    \n    for(float j = 0.; j < 712.; j++){\n        vec2 r = r12(j);\n        float rb = r11(j);\n        vec2 p = uv;\n        \n        \n        \n        float t = iTime + r11(j)*40.;\n        \n        float sp = 1. + r.y*4.;\n        \n        sp *= 7.4;\n        p.x += (r.x*2.2 - 1.)*iResolution.x/iResolution.y*0.5;\n        \n        p.y -= mod(t/sp,1.95) - 1.;\n        \n        \n        p.xy *= rot(iTime*(r.y*1. - 0.5)*0.5 + r.y*20.);\n        \n        //float d = length(p) - 0.01;\n        float sc = 0.16 + 0.4*rb;\n        vec4 leaf = texture(iChannel1,p/sc);\n        float d = leaf.w*sc;         \n        \n        col = mix(col, col*0.4 + col*col*col*0.6, smoothstep(0.03,0.,d));\n        \n        vec3 c = vec3(0.4,0.5,0.1);\n        \n        c += vec3(0.1,0.,0.)*sin(j);\n        float bl = (sin(j*20. + r.y));\n        c += vec3(0.,0.1,-0.15*0.)*bl;\n        \n        c += vec3(0.,0.,0.05)*abs(sin(r.y*40.));\n        float shad = leaf.y*mix(0.3,1.,smoothstep(0.,0.3,dot(p,p) - leaf.z*0.1));\n        c.x += shad*0.45*leaf.z;\n        \n        \n        float ungr = abs(sin(r.x*20.));\n        c.g += 0.6*ungr*shad*leaf.z;\n        \n        c.b -= shad*0.2*leaf.z*sin(r.y*20.)*(1. - ungr);\n        \n        //c *= smoothstep(1.,0.5,sp*0.04);\n        \n        c *= smoothstep(-0.5,1.,j/700.);\n        col = mix(col, c, smoothstep(0.004,0.,d + 0.002));\n  \n        \n    }\n     \n    \n     \n    if(iMouse.z > 0.)\n        col =  1. - col;\n        \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0. ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e))\n\nfloat r11(float i){ return fract(sin(i*25.126)*125.6);}\n\nvec2 r12(float i){float r=r11(i + 4.);  return vec2(r,r11(i + r + 0.5));}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))", "buffer_c_code": "float sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n    float d = 10e5;\n    float side = -1.;\n    float iters = 4.;\n    for(float i = 0.; i < iters; i++){\n        \n        vec2 p = uv;\n        \n        if(i != 0.)\n            p.x = abs(p.x);\n            \n        p*=rot(3.6*i/iters);\n        p.y += 0.07;\n        vec2 op = p;\n        float liters = 14.;\n        \n        float offssc = 0.4;\n        \n        if(i == 3.){\n            liters = 10.; offssc *= 0.8;\n            }\n        float dLeaf = 10e5;\n        float lside = 1.;\n        for(float j = 0.; j < liters; j++){\n            float lidx = j/liters;\n            p.y -= offssc/liters;\n            //p.x += 0.03*smoothstep(0.1,1.,i/iters)*smoothstep(0.6,1.4,j/iters);\n            p *= rot(-(0.15 + sin(iTime + j*0.1)*0.1)*smoothstep(0.,0.5,i/iters)*smoothstep(0.1,0.4,j/liters));\n            \n            float newlside = mix(-1.,1.,smoothstep(0.004,0.,-p.x - 0.0));\n            \n            float sa = 0.02 - lidx*0.001;\n            float sb = 0.005;\n            float h = 0.02 + smoothstep(1.,0.3,lidx)*0.04;\n            h *= mix(0.1,1.,smoothstep(0.,0.4,lidx));\n            //h *= mix(1.,0.01,smoothstep(0.6,1.,lidx));\n            \n            \n            vec2 q = p;\n        \n            q.x = abs(q.x);\n            \n        \n            q = q*rot(1.1);\n            float currLeaf = sdUnevenCapsule( q, sa, sb, h);\n            dLeaf = min(dLeaf,currLeaf);\n            \n            lside = mix(lside,newlside, smoothstep(0.001,0.,currLeaf));\n            \n        }\n        d = min(d,dLeaf);\n        \n        //float newlside \n        side = mix(side,lside,smoothstep(0.003,0.,dLeaf - 0.004));\n    }\n\n    uv *= rot(radians(90.)*2.);\n    \n    uv *= rot(smoothstep(0.1,0.35,uv.y)*-0.2);\n    float dholder = sdUnevenCapsule( uv, 0.005, 0.003 + smoothstep(0.2,0.3,uv.y)*0.01, 0.28);\n    //dholder = max(dholder,uv.y - 0.27);\n    \n    d = min(d, dholder);\n    \n    \n    \n    d = mix(d,10.,smoothstep(0.001,0.,-length(uv) + 0.5));\n    \n    fragColor.w = d;\n    fragColor.y = side;\n    fragColor.z = texture(iChannel1,vec2(mod(fragCoord*0.3/iResolution.xy,256.)),0.).x;\n}", "buffer_c_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 114, 114, 988]], "test": "untested"}
{"id": "Wl3BRS", "name": "fish in space", "author": "YitingLiu", "description": "3d fish in the space using capsule 3d shapes. ", "tags": ["3d", "light", "normal", "shape", "capsule", "primitive"], "likes": 0, "viewed": 265, "published": 3, "date": "1612898196", "time_retrieved": "2024-07-30T19:39:30.171194", "image_code": "//tutorial https://youtu.be/Ff0jJyyiVyw\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    vec3 c= a+t*ab;\n    float d = length(p-c)-r;\n    return d;\n    \n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap)/dot(ab,ab);\n    t = clamp(t,0.,1.);//never fall outside of A and B\n    \n    vec3 c= a+t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));\n    float i = min(max(x,y),0.);//performance penalty \n    \n    //make it smoother \n    return e+i;\n    \n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x,p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,1.5,6.,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6),.2);\n    float cd1 = sdCapsule(p, vec3(0,2,6), vec3(1,2,6),.5);\n    float cd2 = sdCapsule(p, vec3(0,3,6), vec3(1,2,6),.2);\n    float cd3 = sdCapsule(p, vec3(1,2,6), vec3(1.5,2,6),.2);\n   // float td = sdTorus(p-vec3(0,.5,6),vec2(1.5,.25));\n    //float bd = dBox(p-vec3(-2.5,.6,6),vec3(.5));\n   // float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5),.2);\n\n    \n    float d = min(cd,planeDist);\n    d = min(d,cd1);\n    d = min(d,cd2);\n    d = min(d,cd3);\n    \n   // d= min(d,td);\n   // d= min(d,bd);\n   // d= min(d,cyld);\n    \n    return d; \n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i =0; i<MAX_STEPS; i++){\n        vec3 p = ro+dO*rd;\n        float dS = GetDist(p);\n        dO +=dS;\n        if (dS<SURF_DIST|| dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n   vec2 e = vec2(.01,0.);\n   float d = GetDist(p);\n   vec3 n = d-vec3(\n           GetDist(p-e.xyy),\n           GetDist(p-e.yxy),\n           GetDist(p-e.yyx));\n   return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    \n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n   \n    if (d<length(lightPos-p)) dif*=.1;\n     \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(abs(sin(iTime)),2.,0.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.5));\n    \n    float d = RayMarch(ro,rd);\n\n    vec3 p = ro+rd*d;\n    \n    //get diffused light     \n    float dif = GetLight(p);\n    float colDif = 0.5*abs(sin(iTime));\n   \n    col=vec3(colDif,dif/colDif,clamp(dif,0.5,0.8));\n    vec3 t= texture(iChannel0, uv*3.*abs(sin(iTime*0.05))).rgb;    \n    col*=GetNormal(p);\n     col/=GetNormal(p)*t;\n   \n    //col+=t;\n\n    fragColor = vec4(col,1.);\n}\n\n\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 157, 157, 363], [365, 365, 415, 415, 798], [800, 800, 830, 830, 900], [902, 902, 929, 929, 968], [970, 970, 992, 992, 1700], [1702, 1702, 1735, 1735, 1937], [1939, 1939, 1962, 1962, 2147], [2149, 2149, 2173, 2173, 2479], [2482, 2482, 2538, 2538, 3098]], "test": "untested"}
{"id": "tldBDM", "name": "Worley blue noise spectrum", "author": "FabriceNeyret2", "description": "Blue noise by mutually-repulsing Worley dots.\n- Red: Worley dots    \n- Blue: average of 8 neighbor dots\n- Green: mouse.x interpolate between\nIndeed, 100% average (=blue) is too ordered for blue noise ! best=50%.  Or better (and cheaper) on triangle grid ?", "tags": ["worley", "sampling", "bluenoise"], "likes": 6, "viewed": 393, "published": 3, "date": "1612886920", "time_retrieved": "2024-07-30T19:39:31.006959", "image_code": "// reuse workbench of \"3 Sub-Samples Pattern Spectrum\" by TinyTexel. https://shadertoy.com/view/WltfDM\n// on buffA: my Worley \"blue noise\" https://www.shadertoy.com/view/3ldfD7\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float b = (iResolution.y - SIZE)*0.5;\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // spectrum 2d plot\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        float s = 0.01;\n        amp *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // kernel 2d plot\n        float n = textureLod(iChannel0, tc, 0.).r;\n        col = vec3(abs(n));\n        if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(clamp01(col), vec3(1.0/2.2));\n    }\n    \n\n    outCol = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n", "buffer_a_code": "#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n\n\nvec4 Worley0(vec2 U) {\n    vec2 I = floor(U), P,I1,N;\n    \n    float m = 1e5, l;\n    int k,c;\n    for ( k=0; k<9; k++) {\n        I1 = I + vec2(k%3,k/3)-1.;   \n        P = I1 + hash2(I1)-.5;                      // random dot in the current neighbor cell\n        l = dot(P-U,P-U);\n        if (l<m)  m=l, c=k, N=P;\n      }\n    return vec4(m, N, k);                           // closest point, its coordinates, its local id\n}\n\n\nvec4 Worley(vec2 U, float a) {\n    vec2 I = floor(U), P,P0, N, I1,I2;\n    \n    float m = 1e5, l;\n    int k,c;\n    for ( k=0; k<9; k++) {\n        I1 = I + vec2(k%3,k/3)-1.;\n#if 0                                               // classical Worley:\n        P = I1 + hash2(I1)-.5;                      // random dot in the current neighbor cell\n#else\n        P-=P;                                       // averaged Worley:\n        for (int j=0; j<9; j += j==3?2:1 ) {\n            I2 = I1+vec2(j%3,j/3)-1.;\n            P += I2 +hash2(I2)-.5;                  // dot = average neighbor random dots\n        }\n        P /= 8.;\n#  if 1    \n        P0 = I1 + hash2(I1)-.5;\n     // P = mix( P0, P,  a);                        // interpolates between both.\n        P = P0  + a*( P - P0 );                     // neighbors apply force a ( equivalent !)\n     // P = P0  + a*( P - P0 )*smoothstep(1.,0.,length(P-P0)); // increasing force. best seems 50%\n     // P = P0  + a*( P - P0 )*smoothstep(0.,1.,length(P-P0)); // decreasing force. seems better (i.e. like (2) with auto clamp)\n     // P = P   + a*( P - P0 );                     // strangely better than (1)\n#  endif\n#endif\n        l = dot(P-U,P-U);\n        if (l<m)  m=l, c=k, N=P;\n      }\n    return vec4(m, N, k);                           // closest point, its coordinates, its local id\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    if(u.x > SIZE || u.y > SIZE)  discard;\n\n    float s = 40.;\n    vec2 R = iResolution.xy,\n         U = s * ( u - .5*R ) / R.y;\n         \n    float  a = iMouse.x==0. ? .5+.5*sin(iTime) : iMouse.x/iResolution.x,\n          d0 = sqrt( Worley(U,0.).x ),              // classical Worley\n          d2 = sqrt( Worley(U,1.).x ),              // average of 8-neighborh\n          d1 = sqrt( Worley(U,a ).x );              // interpolation between both\n\n    O = smoothstep(s*1.5/R.y,0., vec4( d0,d1,d2,0 ) - .03 ) *vec4(.5,1,1,1);\n  //O = 5. - vec4( d0,d1,d2,0 ) *R.y/15. ;\n  \n   O = vec4(O.g, 0,0,0);                            // Fourier transform acts on O.r\n}\n\n", "buffer_a_inputs": [], "buffer_b_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 224, 224, 1144]], "test": "untested"}
{"id": "3ldfD7", "name": "Worley blue noise", "author": "FabriceNeyret2", "description": "Blue noise by mutually-repulsing Worley dots.\n- Red: Worley dots    \n- Blue: average of 8 neighbor dots\n- Green: mouse.x interpolate between\nIndeed, 100% average (=blue) is too ordered for blue noise !  Or better (and cheaper) on triangle grid ?\nTry #41.", "tags": ["worley", "sampling", "bluenoise"], "likes": 9, "viewed": 391, "published": 3, "date": "1612885808", "time_retrieved": "2024-07-30T19:39:31.879626", "image_code": "#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n\n\nvec4 Worley0(vec2 U) {\n    vec2 I = floor(U), P,I1,N;\n    \n    float m = 1e5, l;\n    int k,c;\n    for ( k=0; k<9; k++) {\n        I1 = I + vec2(k%3,k/3)-1.;   \n        P = I1 + hash2(I1)-.5;                      // random dot in the current neighbor cell\n        l = dot(P-U,P-U);\n        if (l<m)  m=l, c=k, N=P;\n      }\n    return vec4(m, N, k);                           // closest point, its coordinates, its local id\n}\n\n\nvec4 Worley(vec2 U, float a) {\n    vec2 I = floor(U), P,P0, N, I1,I2;\n    \n    float m = 1e5, l;\n    int k,c;\n    for ( k=0; k<9; k++) {\n        I1 = I + vec2(k%3,k/3)-1.;\n#if 0                                               // classical Worley:\n        P = I1 + hash2(I1)-.5;                      // random dot in the current neighbor cell\n#else\n        P-=P;                                       // averaged Worley:\n        for (int j=0; j<9; j += j==3?2:1 ) {\n            I2 = I1+vec2(j%3,j/3)-1.;\n            P += I2 +hash2(I2)-.5;                  // dot = average neighbor random dots\n        }\n        P /= 8.;\n#  if 1    \n        P0 = I1 + hash2(I1)-.5;\n        P = mix( P0, P,  a);                        // interpolates between both.\n     // P = P0  + a*( P - P0 );                     // neighbors apply force a ( equivalent !)\n     // P = P0  + a*( P - P0 )*smoothstep(1.,0.,length(P-P0)); // force decreasing with distance.\n#  endif\n#endif\n        l = dot(P-U,P-U);\n        if (l<m)  m=l, c=k, N=P;\n      }\n    return vec4(m, N, k);                           // closest point, its coordinates, its local id\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 15.* ( u - .5*R ) / R.y;\n         \n    float  a = iMouse.x==0. ? .5+.5*sin(iTime) : iMouse.x/iResolution.x,\n          d0 = sqrt( Worley(U,0.).x ),              // classical Worley\n          d2 = sqrt( Worley(U,1.).x ),              // average of 8-neighborh\n          d1 = sqrt( Worley(U,a ).x );              // interpolation between both\n\n    O = smoothstep(22./R.y,0., vec4( d0,d1,d2,0 )-.15 ) *vec4(.5,1,1,1);\n  //O = 5. - vec4( d0,d1,d2,0 ) *R.y/15. ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 176, 176, 576], [579, 579, 609, 609, 1700], [1703, 1703, 1741, 1741, 2242]], "test": "untested"}
{"id": "WtdfWM", "name": "3 Sub-Samples Pattern Test", "author": "TinyTexel", "description": "Sampling a checkerboard tunnel with a blue noise-like sampling pattern that uses 3 sub-samples per pixel.", "tags": ["noise", "antialiasing", "blue", "sampling", "aa"], "likes": 6, "viewed": 547, "published": 3, "date": "1612871475", "time_retrieved": "2024-07-30T19:39:32.652560", "image_code": "\n/*\nSampling a checkerboard tunnel with a blue noise-like sampling pattern that uses 3 sub-samples per pixel.\n\nRelated:\n    https://www.shadertoy.com/view/3tdBWM - \"Blue Noise via 3 Sub-Samples\"   (plot of the used sampling pattern)\n    https://www.shadertoy.com/view/WltfDM - \"3 Sub-Samples Pattern Spectrum\" (plot of the spectral response of the pattern)\n*/\n\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\n\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\n\n// checkerboard tunnel\nfloat Pattern(vec2 uv)\n{\n    #if 1\n    uv += vec2(cos(iTime), sin(iTime));\n    #endif\n    \n    vec2 vec = (uv - iResolution.xy * 0.5) / iResolution.x;\n    vec3 rdir = normalize(vec3(vec, 1.0));\n    \n    //vec3 n = normalize(rdir - cam.Front * dot(rdir, cam.Front));\n    vec3 n = normalize(vec3(rdir.xy, 0.0));\n    float z = 1.0 / dot(rdir, n);\n    \n    float s = 8.0;\n    bool sz = fract(z*s*0.5) < 0.5;   \n    //bool sc = fract(atan(dot(n, cam.Right), dot(n, cam.Up)) * RcpPi * 2.0 * s) < 0.5;\n    bool sc = fract(atan(n.x, n.y) * RcpPi * 2.0 * s) < 0.5;\n    float p = sz == sc ? 1.0 : 0.0;   \n \n    //p = cos(dot(uv, uv) * 0.003) * 0.5 + 0.5;\n    \n    vec *= 96.0;\n    //p = sin(dot(vec, vec)) * 0.5 + 0.5;\n    \n    return p;\n}\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;   \n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    bool flip = (uint(iFrame) & 1u) != 0u;\n    \n    float v = 0.0;\n    \n    uvec2 uvi = uvec2(uv);\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    //u = float(WeylHash(uvi ^ uvec2(rPhi2a, rPhi2b))) * (1.0 / 4294967296.0);\n    //if(flip) u += 1.5;\n\n  #if 1\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n        \n      #if 0\n        off *= 0.3333333;\n      #elif 0\n        off *= i == 0.0 ? 0.4 : 0.333333;\n      #elif 1\n        off *= 0.4;\n      #elif 1\n        off *= float(h+uint(i)*rPhi1) * (0.111111/4294967296.0) + 0.333333;\n      #elif 1\n        off *= float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n      #else\n        off *= float(h+uint(i)*rPhi1) * (0.5/4294967296.0);\n      #endif\n      \n        v += Pattern(uv0 + off); \n    }\n    v *= 0.333333;\n  #else\n    for(float i = 0.0; i < 2.0; ++i) \n    {\n        float ang = Pi * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n        \n        off *= 0.333333;\n      \n        v += Pattern(uv0 + off); \n    }\n    v *= 0.5;\n  #endif\n  \n  \n    //v = Pattern(uv0);//no AA\n  \n    vec3 col = vec3(v);\n    \n    outCol = vec4(GammaEncode(col), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[463, 463, 491, 491, 523], [525, 548, 572, 572, 1277], [1278, 1345, 1370, 1370, 1442], [1444, 1444, 1492, 1492, 3116]], "test": "untested"}
{"id": "3tdBWM", "name": "Blue Noise via 3 Sub-Samples", "author": "TinyTexel", "description": "A blue noise-like sampling pattern that uses 3 sub-samples per pixel.", "tags": ["noise", "antialiasing", "blue", "sampling", "aa"], "likes": 5, "viewed": 613, "published": 3, "date": "1612871388", "time_retrieved": "2024-07-30T19:39:33.535200", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nA blue noise-like sampling pattern that uses 3 sub-samples per pixel.\n\nRelated:\n    https://www.shadertoy.com/view/WtdfWM - \"3 Sub-Samples Pattern Test\"     (sampling a checkerboard tunnel using the pattern)\n    https://www.shadertoy.com/view/WltfDM - \"3 Sub-Samples Pattern Spectrum\" (plot of the spectral response of the pattern)\n*/\n\nconst float Pi = 3.14159265359;\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    v = smoothstep(1.0, 0.0, v * 16.0);\n    \n    return v;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 uv = uv0;\n\tvec2 tex = uv0.xy / iResolution.xy;\n    \n    bool flip = (uint(iFrame) & 1u) != 0u;\n\n    vec3 col = vec3(0.0);\n\n    vec2 uv2 = uv / 32.0;\n    vec2 uvf = fract(uv2);\n\n\n    uvec2 uvi = uvec2(floor(uv2));\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n\n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    //if(flip) u += 1.5;\n\n    float dots = 0.0;\n    \n  #if 1\n    for(float i = 0.0; i < 3.0; ++i) \n    {\n        float ang = (Pi*0.666667) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n        \n      #if 0\n        off *= 0.333333;\n      #elif 0\n        off *= i == 0.0 ? 0.4 : 0.333333;// break up repeating pattern a bit\n      #elif 0\n        off *= float(h+uint(i)*rPhi1) * (0.111111/4294967296.0) + 0.333333;\n      #else\n        off *= float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n      #endif\n      \n        dots += PlotDot(uvf, vec2(0.5) + off, 0.02); \n    }\n  #else\n    for(float i = 0.0; i < 2.0; ++i) \n    {\n        float ang = Pi * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n\n        off *= 0.333333;\n\n        dots += PlotDot(uvf, vec2(0.5) + off, 0.02); \n    }\n  #endif\n    \n  #if 1\n    if(tex.x < 0.5)\n    {\n        bvec2 tl1 = greaterThan(fract(uv2 * 0.5), vec2(0.5));   \n    \n    \tif(tl1.x != tl1.y) col = vec3(0.03);\n    }\n  #endif\n    \n    col += vec3(dots);\n    \n\toutCol = vec4(GammaEncode(clamp(col, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBWM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[442, 442, 468, 468, 500], [502, 502, 545, 545, 647], [649, 716, 741, 741, 813], [816, 816, 862, 862, 2542]], "test": "untested"}
{"id": "WltfDM", "name": "3 Sub-Samples Pattern Spectrum", "author": "TinyTexel", "description": "Spectrum plot of a blue noise-like sampling pattern that uses 3 sub-samples per pixel.", "tags": ["noise", "antialiasing", "blue", "sampling", "aa"], "likes": 9, "viewed": 472, "published": 3, "date": "1612871384", "time_retrieved": "2024-07-30T19:39:34.438784", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nSpectrum plot of a blue noise-like sampling pattern that uses 3 sub-samples per pixel.\n\nRelated:\n    https://www.shadertoy.com/view/WtdfWM - \"3 Sub-Samples Pattern Test\"   (sampling a checkerboard tunnel using the pattern)\n    https://www.shadertoy.com/view/3tdBWM - \"Blue Noise via 3 Sub-Samples\" (plot of the used sampling pattern)\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float b = (iResolution.y - SIZE)*0.5;\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // spectrum 2d plot\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        float s = 0.01;\n        amp *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // kernel 2d plot\n        float n = textureLod(iChannel0, tc, 0.).r;\n        col = vec3(abs(n));\n        if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(clamp01(col), vec3(1.0/2.2));\n    }\n    \n\n    outCol = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// experimental stuffs\n\n#if 0\n\n    dots = PlotDot(uvf+off0, vec2(0.5) + (vec2(uvi0.y * rPhi1, uvi0.x * (-rPhi1)))* (1.0 / 4294967296.0) - 0.5, 0.02); \n    //dots = PlotDot(uvf+off0, vec2(0.5) + (vec2(float(uvi0.y * rPhi1)* (1.0 / 4294967296.0), fract(float(uvi0.x) * mix(0.0, 1.0,iMouse.x/iResolution.x)))) - 0.5, 0.02); \n    //dots = PlotDot(uvf+off0, vec2(0.5) + (vec2(uvi0.y * rPhi2a, uvi0.x * (rPhi2b)))* (1.0 / 4294967296.0) - 0.5, 0.02); \n  \n  \nvec2 Dir(uvec2 uvi, float i)\n{\n#if 1\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n    if(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n    \n    uint a = 3316612456u;\n    uint b = 1538627358u;\n    \n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n     u = float((uvi.x * a) + (uvi.y * b)) * (1.0 / 4294967296.0);\n     u = float((uvi.x * a) + (uvi.y * b) + WeylHash(uvi/4u)) * (1.0 / 4294967296.0);\n    //u = fract(float(uvi.x)*0.7722090128189392 + float(uvi.y)*0.35823959808621314);\n#else\n    float u = float( WeylHash(uvi)) * (1.0 / 4294967296.0);\n#endif\n\n    float ang = (Pi*0.666667) * (i+u);\n    //ang = Pi * 2.0 * u;\n    vec2 dir = vec2(cos(ang), sin(ang));\n    \n    return dir;\n}\n\nvec2 DirA(uvec2 uvi, float i)\n{\n    vec2 dir = vec2(0.0);\n    \n    {\n        float w = 0.25*0.25;\n        \n        dir += Dir(uvi + uvec2( 1u, 1u), i);\n        dir += Dir(uvi + uvec2(-1u, 1u), i);\n        dir += Dir(uvi + uvec2( 1u,-1u), i);\n        dir += Dir(uvi + uvec2(-1u,-1u), i);\n    }\n    \n    {\n        float w = 0.5*0.25;\n        \n        dir += Dir(uvi + uvec2( 1u, 0u), i);\n        dir += Dir(uvi + uvec2(-1u, 0u), i);\n        dir += Dir(uvi + uvec2( 0u, 1u), i);\n        dir += Dir(uvi + uvec2( 0u,-1u), i);\n    }\n    \n    dir = Dir(uvi, i) * (0.5*0.5);\n    //dir = Dir(uvi, i) - dir; \n    dir = normalize(dir);\n    \n    return dir;\n}\n\nfloat SimpleStep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    float xp = x < 0.5 ? x * 2.0 : x * -2.0 + 2.0;\n    \n    float y = xp*xp;\n    \n    return x < 0.5 ? y * 0.5 : y * -0.5 + 1.0;\n}\n\n#if 0\n    off.y = float((uvi.x * rPhi1) + WellonsHash2(uvi.y)) * (1.0 / 4294967296.0) - 0.5;\n    off.x = float((uvi.y * rPhi1) + WellonsHash2(uvi.x^0x1452Cu)) * (1.0 / 4294967296.0) - 0.5;\n#else\n    off.y = (float(WellonsHash2( uvec2(uvi.x   , uvi.y), 0u)) * (1.0 / 4294967296.0) - 0.5) * 0.5;\n    off.y -= (float(WellonsHash2(uvec2(uvi.x-1u, uvi.y), 0u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.y -= (float(WellonsHash2(uvec2(uvi.x+1u, uvi.y), 0u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.y = SimpleStep(off.y + 0.5) - 0.5;\n    \n    off.x = (float(WellonsHash2( uvec2(uvi.x, uvi.y   ), 1u)) * (1.0 / 4294967296.0) - 0.5) * 0.5;\n    off.x -= (float(WellonsHash2(uvec2(uvi.x, uvi.y-1u), 1u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.x -= (float(WellonsHash2(uvec2(uvi.x, uvi.y+1u), 1u)) * (1.0 / 4294967296.0) - 0.5) * 0.25;\n    off.x = SimpleStep(off.x + 0.5) - 0.5;\n    \n#endif\n\n#endif", "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n*/\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    v = smoothstep(1.0, 0.0, v * 12.0);\n    \n    return v;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nuint Dot(uvec2 a, uvec2 b) { return a.x*b.x + a.y*b.y;}\n\n\nfloat Map0(vec2 uv2, vec2 uvf, vec2 off0)\n{\n    uvec2 uvi0 = uvec2(floor(uv2));\n    uvec2 uvi = uvec2(floor(uv2));\n    if(((uvi.x ^ uvi.y) & 4u) == 0u) uvi   = uvi.yx;\n\tif(((uvi.x        ) & 4u) == 0u) uvi.x =-uvi.x;\n\n    // constants of the 1d and 2d Roberts sequences\n    const uint rPhi1  = 2654435761u;\n    const uint rPhi2a = 3242174893u;\n    const uint rPhi2b = 2447445397u;\n    \n    float u = float((uvi.x * rPhi2a) + (uvi.y * rPhi2b)) * (1.0 / 4294967296.0);\n    uint  h = WeylHash(uvi);\n\n    //if(((uvi.x ^ uvi.y) & 1u) == 0u) u += 0.5;\n\n    float dots = 0.0;\n    \n  #if 1\n    float count = 3.0;\n    for(float i = 0.0; i < count; ++i) \n    {\n        float ang = (Pi*2.0/count) * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n       // off /= max(abs(off.x), abs(off.y));\n      #if 0\n        off *= 0.333333;\n      #elif 1\n        off *= 0.4;\n      #elif 0\n        // based on Fabrice Neyret's suggestion\n        off *= float(h+uint(i)*rPhi1) * (0.111111/4294967296.0) + 0.333333;\n      #else\n        off *= float(h+uint(i)*rPhi1) * (0.25/4294967296.0) + 0.25;\n      #endif\n      \n        dots += PlotDot(uvf+off0, vec2(0.5) + off, 0.02); \n    }\n  #else\n    for(float i = 0.0; i < 2.0; ++i) \n    {\n        float ang = Pi * (i+u);\n        \n        vec2 off = vec2(cos(ang), sin(ang));\n       \n        off *= 0.333333;\n       \n        dots += PlotDot(uvf+off0, vec2(0.5) + off, 0.02); \n    }\n  #endif\n      \n    return dots;\n}\n\nfloat Map(vec2 uv)\n{\n    vec2 uv2 = uv / 16.0;\n    vec2 uvf = fract(uv2);\n    \n   #if 0\n    return Map0(uv2, uvf, vec2(0.0));\n   #else\n    // use this to prevent points placed close to a cell's border from getting clipped\n    return Map0(uv2, uvf, vec2(0.0, 0.0))+\n    Map0(uv2-vec2(1.0, 0.0), uvf, vec2(1.0, 0.0))+\n    Map0(uv2-vec2(0.0, 1.0), uvf, vec2(0.0, 1.0))+\n    Map0(uv2+vec2(0.0, 1.0), uvf, -vec2(0.0, 1.0))+\n    Map0(uv2+vec2(1.0, 0.0), uvf, -vec2(1.0, 0.0));\n   #endif\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n        return;\n    }\n    \n    vec2 uv = uv0 - 0.5;\n    \n    float v = Map(uv);\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}", "buffer_a_inputs": [], "buffer_b_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltfDM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[412, 412, 458, 458, 1378]], "test": "untested"}
{"id": "ttcfD7", "name": "Glass bubble lamp", "author": "jarble", "description": "mouse x controls fractal loop", "tags": ["fractal"], "likes": 12, "viewed": 497, "published": 3, "date": "1612854226", "time_retrieved": "2024-07-30T19:39:35.265573", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 3.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n         u = -u.yx;\n         u += vec2(1.,0.);\n    vec2 v = u;\n         u = u*dot(u,u);\n    \n    float t = iTime*.8;\n    //float t = (1.0+sin(iTime/32.0))*32.0;\n\n    if(iMouse.z > 0.) t = 10.*iMouse.x/iResolution.x;\n\n    float pi = 3.14159265359;\n    vec4 sum = vec4(0.);\n    for(float i = 0.; i < t; ++i)\n    {\n        u = cos(u.y-vec2(.0,.5*pi))*exp(sin(u.x+iTime)+cos(u.y+iTime));\n        u+= v;\n        sum += (.5+.5*cos(i*4.+vec4(0,1,2,0)))/length(u);\n    }\n    fragColor = sqrt(sum)*.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 614]], "test": "untested"}
{"id": "ttcBD7", "name": "Weird fishy thing", "author": "jarble", "description": "This a modified version of [url=https://www.shadertoy.com/view/WtSfzd]3D_Gyroid_IceCave_LO[/url] with a distorted perspective.\n\nThe [code]RayMarch[/code] function is modified to change the camera's direction with each step.", "tags": ["gyroid"], "likes": 4, "viewed": 330, "published": 3, "date": "1612852373", "time_retrieved": "2024-07-30T19:39:36.094358", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST 1e-3 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\n#define S(a, b, t) smoothstep (a, b, t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c); \n}\n\nfloat sdBox (vec3 p, vec3 s)\n{\n  p = abs(p)-s; \n    \n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) \n    {       \n        p *= scale;  //WE SCALE THE POSITION TO SCALE THE GYROID. BUT WHENEVER WE MULTIPLY THE POSITION, WE NEED TO DIVIDE IT BY WHAT WE MULTIPLIED. \n        \n        return abs(dot(sin(p), cos(p.zxy)) - bias)/scale-thickness; //WE DIVIDE IT HERE.  ALSO !! -- IF PLAYING WITH A 2D GYROID WE CAN\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //CHANGE THE SHAPE BY MULTIPLYING THE POSITION'S SIN\n    }\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.18); \n    p.z -= iTime*1.0;\n    p.y -= .3; \n    \n    return p;\n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n                  \n        p = Transform(p);  //THIS IS HOW WE'LL MOVE OUR STRUCTURE. WE DON'T WANT TO MOVE OUR CAMERA POSITION BECAUSE THE MORE WE MOVE\n        \t\t\t\t  //OUR CAMERA AWAY FROM THE ORIGIN POINT, THE LESS DETAILED WE'LL GET BECAUSE THIS IS, IN ESSENCE, BUILT AROUND\n        \t\t\t\t  //A RAYMARCHER THAT MARCHES A RAY TO A POINT \n        \n        float box = sdBox(p, vec3(1)); \n\n        float g1 = sdGyroid(p, 5.76, .03, 1.5);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 100.23, .03, .3);\n\n\n        //float g = min(g1, g2); //Union method of combining gyroids\n        // float g = max(g1, -g2); //Subraction method of combining gyroids\n        \n        g1 -= g2*.4;   //Bumpmap method\n        g1 -= g3 *.2;\n        g1 += g4 *.2;\n        g1 += g5 *.2;\n        g1 -= g6 *.1;\n       \n            \n       \n       // float d = max(box, g1*.8); //WE MULTIPLY BY A NUMBER LESS THAN 1 TO REDUCE THE STEP SIZE SO WE DON'T OVERSTEP WHEN\n        \t\t\t\t\t\t\t   //WE ADJUST THE SCALE ABOVE IN sdGyroid.\n \n        float d = g1*.6; \n        return d;\n    }\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.,eps=SURF_DIST; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            rd.xy *= Rot(rd.z/10.0); \n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += 1.0; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<eps*(1.0+dO*.25) || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            eps *= 1.01;\t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize (l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z, \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}  \n        \nvec3 Background(vec3 rd)  //WE ONLY NEED TO CALCULATE OUR BKG'S RD BECAUSE WE DON'T CARE ABOUT WHERE WE ARE, WE ONLY CARE ABOUT WHAT\n    \t\t\t\t\t   //DIR WE'RE LOOKING IN. \n    \n{\n    \n    vec3 col = vec3(0); \n    float t = iTime; \n    \n    float y = rd.y * .5 +.5; //Here we map our color to the ray direction y and then multiply it so that we lock its value between 0 and 1. \n    \t\t\t\t\t\t//At 1 (straight), it's its brightest and at 0 (straight down) it's at its dimmest, giving us a gradient in the\n    \t\t\t\t\t\t//middle. \n    \n    col += y*vec3(.1, .7, 1)*2.;  //This bakes it in so that our color is brighter the higher our Y is. \n    \t\t\t\t\t\t\t  //If we wanted it reverse, we'd do col += (1.-y); \n    \n    float a = atan(rd.x, rd.z); //XZ plane to give us our angle so we can determine our NSEW direction \n    \n    float flames = sin(a*10. +t)*sin(a*7.-t)*sin(a*3.); //We find the sin wav of our angle and multiply to get multiple sin waves on our image. \n    \t\t\t\t\t\t\t\t\t\t\t\t //We then marry it to iTime so it comes in and out on a timer. Then repeat, but \n    \t\t\t\t\t\t\t\t\t\t\t\t//multiply it by negative t so we don't see the movement of the light coming in. Then,\n    \t\t\t\t\t\t\t\t\t\t\t\t//we multiply it again by the sin wave of the angle and diminish it so it feels random. \n    \t\t\t\t\t\t\t\t\t\t\t\t//We could keep repeating this again and again to make it feel more and more random, but\n    \t\t\t\t\t\t\t\t\t\t\t    //Ehh. It looks fine now.\n    \n    flames *= S(.8, .5, y); //We don't want this to reach the poles, so we smoothstep the flame's Y so at .5 it starts fading out\n    \t\t\t\t\t  //and at .8 it's completely faded out   \n        \n    col += flames; \n    col = max(col, 0.); //This makes it so our color can never go negative. \n    //col += S(.5, .2, y); \n    return col; \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    uv += sin(uv*30.*t)*.0001; //\"Heat\" distortion    IF REALLY HIGH THEN IT CAN BE USED FOR DOPE MOSAIC STUFF\n    vec3 ro = vec3(0,0,-.01); //ray origin, or position of camera   \n    //ro.yz *= Rot(-m.y*3.14+1.+sin(iTime*5.0/7.0*2.0)/2.0); \n    //ro.xz *= Rot(-m.x*6.2831+cos(iTime*2.0)/2.0);\n    \n    ro.yz *= Rot(-m.y*3.14+(iTime*5.0/7.0)/2.0); \n    ro.xz *= Rot(-m.x*6.2831+(iTime)/2.0);\n    \n    vec3 lookat = vec3(0,0,0); \n    vec3 rd = GetRayDir(uv, ro, lookat, .8); //THE FLOAT AT THE END OF THIS IS THE ZOOM FACTOR\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) //THIS IS WHERE WE MAKE OUR MATERIAL, WHICH INCLUDES COLOR AND SHADOWS\n    {\n        vec3 p = ro + rd * d; \n        vec3 n = GetNormal(p); \n        \n        float height = p.y; \n\n        p = Transform(p); \n        \n        float dif = n.y * .5+.5; //n.y gives us light from direct above because it's the normal's y. We then wrap it with .5 + .5\n        \t\t\t\t\t\t //to prevent it shooting us back a negative value, keeping it always between 0 and 1. \n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3); //Ambient occlusion.\n        col *= S(-.1, .1, g2); //Blackening \n        \n        \n        //CRACKS: \n        \n        float crackWidth = -.01 + S(0., -.5, n.y)*.01; //We set the crack width but then put in the smoothstep to say \"If it's between\n        \t\t\t\t\t\t\t\t\t\t\t\t//These values (ie 0 and -.5), then make it thicker. In this case, it tranlsates \n        \t\t\t\t\t\t\t\t\t\t\t\t//to being thicker on the bottom than the top.  \n        float cracks = S(crackWidth, -.03, g2); //  \n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.07, 3.76, .03, .0);\n        \n        cracks *= g3*g4*30.+.3*S(.0, .3, n.y); //THE LAST NUMBER HERE DETERMINES THE BRIGHTNESS OF THE COLOR IN THE CRACKS\n        \t\t\t\t\t\t\t\t\t   //WE USE SMOOTHSTEP HERE TO KEEP IT FROM GOING FULLY BLACK AT A CERTAIN HEIGHT.\n        \t\t\t\t\t\t\t\t\t   //BECAUSE I WANT THIS TO BE ICE, I WANT IT TO NOT GO FULL BLACK UP TOP, BUT DOWN BELOW IS FINE.\n        \t\t\t\t\t\t\t\t\t   //IF I WANTED THE REVERSE, I'D REVERSE THE NUMBERS. \n        \n        \n        col += cracks*vec3(.1, .7, 1)*3.; //This allows us to change the color of the cracks in RGB code. Our primary color should\n        \t\t\t\t\t\t\t\t  //Always be 1 or greater and no value should be 0 because if it is, if we then multiply the\n        \t\t\t\t\t\t\t\t  //colors, it will get funky in not a good way. \n        \n        //FLICKERING\n        \n        float g5 = sdGyroid(p-vec3(t,0,0), 3.76, .03, .0); //The vec3 allows us to determine the direction the flickering happens.\n        \t\t\t\t\t\t\t\t\t\t\t\t   //We marry it to Time to give it a rhythm. If the T is in X, the flickering\n        \t\t\t\t\t\t\t\t\t\t\t\t  //goes along the X, if in Y then the Y,  etc.\n           \n        col += g5*vec3(.1, .7, 1); //determines the color of our flicker\n        \n        col += S(0., 8., height)*vec3(.1, .7, 1)*2.; //gives us a glow to wash it out. I have the glow start at 0 and reach max at 5\n        \n        \t\n        \n    }\n    \n    //DEPTH FOG/BACKGROUND: \n    \n    col = mix(col, Background(rd), S(0., 9., d)); //This is where we blend our background with our structure.  \n   \n    col *= 1. -dot(uv, uv); //THIS IS A VIGNETTE. WE MULTIPLY UV BY UV (UV SQUARED) TO GIVE US A BLACK CENTER. TO PUSH IT OUT TO THE EDGES\n    \t\t\t\t\t\t//OF THE SCREEN, WE MULTIPLY IT BY NEGATIVE DOT. \n    fragColor = vec4(col,1.0);\n}\n    \n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 379, 379, 461], [463, 463, 493, 493, 583], [585, 585, 656, 656, 1043], [1045, 1045, 1069, 1069, 1155], [1157, 1157, 1230, 1230, 2456], [2458, 2458, 2496, 2496, 3296], [3298, 3298, 3652, 3652, 4161], [4171, 4171, 4203, 4203, 5423], [5425, 5425, 5475, 5475, 5673], [5685, 5685, 5861, 5861, 7436], [7439, 7439, 7496, 7496, 11069]], "test": "untested"}
{"id": "wlcfW7", "name": "Ray-Circle Intersection Demo", "author": "oneshade", "description": "Interactive ray-circle intersection demo. Drag the point or arrow on the ray to move the origin and direction. Drag the point on the circle to change the radius.", "tags": ["ray", "math", "intersection", "circle", "quadratic", "graphing"], "likes": 7, "viewed": 477, "published": 3, "date": "1612850891", "time_retrieved": "2024-07-30T19:39:36.964032", "image_code": "/*\nInteractive ray-circle intersection demo.\nDrag the point or arrow on the ray to move the origin and direction.\nDrag the point on the circle to change the radius.\nBE CAREFUL NOT TO GET THE CONTROL POINTS GLUED TOGETHER!!! :D\nLines 38-40 and 64-69 contain the intersection calculations.\n*/\n\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float t = 0.25 * unit;\n    vec3 color = vec3(1.0);\n\n    // Control variables\n    vec2 ro = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 rd = texelFetch(iChannel0, ivec2(1, 0), 0).xy - ro;\n    vec2 radiusPoint = texelFetch(iChannel0, ivec2(2, 0), 0).xy;\n    float r = length(radiusPoint);\n\n    // Grid\n    draw(abs(mod(uv.x + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(mod(uv.y + 0.125, 0.25) - 0.125) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Coefficients of intersection function\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    // Intersection function\n    float f = a * uv.x * uv.x + b * uv.x + c;\n    float d = 2.0 * a * uv.x + b;\n    draw(abs(uv.y - f) / sqrt(1.0 + d * d) - t, vec3(0.8, 0.0, 0.0));\n\n    // Circle (and its control point)\n    draw(abs(length(uv) - r) - t, vec3(0.5, 0.0, 0.75));\n    draw(length(uv - radiusPoint) - 0.075, vec3(0.0));\n\n    // Ray origin and path\n    vec2 rdNorm = normalize(rd);\n    vec2 rdPerp = rdNorm.yx * vec2(-1.0, 1.0);\n\n    draw(length(uv - ro) - 0.075, vec3(0.0));\n    draw(abs(dot(uv - ro, rdPerp)) - t, vec3(0.0));\n\n    // Ray direction (arrow)\n    vec2 rp = uv - ro - rd;\n    rp = vec2(dot(rp, rdPerp), dot(rp, rdNorm));\n    draw(sdIsosceles(rp, 0.1, 0.15), vec3(0.0));\n\n    // Solutions to the intersection function\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom; // 1st root (intersection distance)\n        float t2 = -(root + b) / denom; // 2nd root (intersection distance)\n\n        // Draw them on the function\n        draw(length(uv - vec2(t1, 0.0)) - 0.075, vec3(1.0, 0.0, 0.0));\n        draw(length(uv - vec2(t2, 0.0)) - 0.075, vec3(0.0, 0.0, 1.0));\n\n        // Draw them on the ray\n        draw(length(uv - ro - rd * t1) - 0.075, vec3(1.0, 0.0, 0.0));\n        draw(length(uv - ro - rd * t2) - 0.075, vec3(0.0, 0.0, 1.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SELECTION_RADIUS 0.2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (iFragCoord == ivec2(0, 0)) {\n            fragColor.xy = vec2(-2.5, 1.0);\n        }\n\n        if (iFragCoord == ivec2(1, 0)) {\n            fragColor.xy = vec2(-1.25, 0.75);\n        }\n\n        if (iFragCoord == ivec2(2, 0)) {\n            fragColor.xy = vec2(0.0, -1.0);\n        }\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.x < 3 && iFragCoord.y == 0) {\n            vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            if (length(mouse - fragColor.xy) < SELECTION_RADIUS) {\n                fragColor.xy = mouse;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 414, 414, 690], [692, 692, 747, 747, 2955]], "test": "untested"}
{"id": "ttcfW7", "name": "space chop that varies in length", "author": "lomateron", "description": "fract() is used on a distance field's space to chop it in equal lengths\nbut what if you want a chop that varies in length across space", "tags": ["3d", "sdf", "wasd"], "likes": 6, "viewed": 281, "published": 3, "date": "1612846241", "time_retrieved": "2024-07-30T19:39:37.747936", "image_code": "float objec(vec3 p)\n{\n    float a = 999999.;\n    vec3 q = vec3(0);\n\n    //constant size increase cubes\n    //1,2,2,3,3,3,4,4,4,4, 5, 5, 5, 5, 5    https://oeis.org/search?q=1%2C2%2C2%2C3%2C3%2C3%2C4%2C4%2C4%2C4%2C5%2C5%2C5%2C5%2C5&sort=&language=english&go=Search\n    //0,1,2,3,4,5,6,7,8,9,10,11,12,13,14\n    //| |-- |---- |------ |-------------\n    //0,1,1,3,3,3,6,6,6,6,10,10,10,10,10    https://oeis.org/search?q=0%2C1%2C1%2C3%2C3%2C3%2C6%2C6%2C6%2C6%2C10%2C10%2C10%2C10%2C10&sort=&language=english&go=Search\n    q = p;\n    q.x = abs(q.x);\n    float n = floor(q.x);\n    float s = sqrt(1.+8.*n);\n    float t = floor((s-1.)*.5)*floor((s+1.)*.5)*.5;\n    float r = round(sqrt(2.*(n+1.)));\n    q.x = q.x-t-r*.5;\n    a = min(a,length(max(abs(q)-r*.25,vec3(0)))-.5);\n    \n    //exponiential size increase cubes\n    //1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5        https://oeis.org/search?q=1%2C2%2C2%2C3%2C3%2C3%2C3%2C4%2C4%2C4%2C4%2C4%2C4%2C4%2C4&sort=&language=english&go=Search\n    q = p;\n    q.z = abs(q.z);\n    n = floor(q.z);\n    r = floor(log2(n));\n    t = pow(2.,r)-0.;\n    r = pow(2.,r);\n    \n    q.z = q.z-t-r*.5;\n    a = min(a,length(max(abs(q)-r*.25,vec3(0)))-.5);\n        \n    return a;\n}\nvoid march(vec3 look, inout vec3 p, inout float d)\n{\n    for (int i = 0; i < 32; ++i)\n    {\n        d = objec(p);\n        p += d*look;\n    }\n}\n#define D .001\nvec3 normal(vec3 p){\n    return normalize(vec3(\n        objec(p+vec3(D,0.,0.)) - objec(p-vec3(D,0.,0.)),\n        objec(p+vec3(0.,D,0.)) - objec(p-vec3(0.,D,0.)),\n        objec(p+vec3(0.,0.,D)) - objec(p-vec3(0.,0.,D))\n    ));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 look   = texture( iChannel0, (vec2(1.,0.)+.5)/iResolution.xy).xyz;\n    vec3 camPos = texture( iChannel0, (vec2(2.,0.)+.5)/iResolution.xy).xyz;\n         camPos+= vec3(32.,32.,-32.);\n    \n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    mat3 mtx;\n    mtx[0] = normalize(vec3(look.z,0.,-look.x));\n    mtx[1] = cross(look,mtx[0]);\n    mtx[2] = look;\n    look = mtx*normalize(vec3(uv,1.));\n \n    vec3 p = camPos;\n    float d = 0.;\n    march(look, p, d);\n    vec3 n = look;\n    if(d<.1){ n = normal(p); }\n\tfragColor = vec4(n,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void rotVec(inout vec4 v, float x, float y)\n{\n    y = asin(v.y) - y;\n    if(-1.56 > y){y =-1.56;};\n    if( 1.56 < y){y = 1.56;};\n    float l = cos(y);\n    x = -x;\n    v.xz = vec2(v.x*cos(x) - v.z*sin(x),\n                v.x*sin(x) + v.z*cos(x));\n    v.xz*= l/length(v.xz);\n    v.y  = sin(y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float keyW  = texture( iChannel1, vec2(87.5/256.,.25) ).x;\n    float keyS  = texture( iChannel1, vec2(83.5/256.,.25) ).x;\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    float keyD  = texture( iChannel1, vec2(68.5/256.,.25) ).x;\n    vec4 mouse  = texture( iChannel0, vec2(0.5,.5)/iResolution.xy);\n    vec4 look   = texture( iChannel0, vec2(1.5,.5)/iResolution.xy);\n    vec4 camPos = texture( iChannel0, vec2(2.5,.5)/iResolution.xy);\n    vec4 final = vec4(0.);\n    \n    //make sure \"look\" always is a normalized vector\n    if(dot(look,look)==0.){look = normalize(vec4(-1.,-1.,1.,0.));}\n    \n    if(fragCoord.x == 0.5)//mod mouse texel\n    {\n        if(iMouse.z>0.){ mouse = iMouse; }\n        else           { mouse.z = 0.;   }\n\t\tfinal = mouse;\n    }\n    if(fragCoord.x == 1.5)//mod look texel\n    {\n        if(iMouse.z>0. && mouse.z>0.)\n        {\n            mouse = (iMouse-mouse)*4./iResolution.y;\n            rotVec(look, mouse.x, -mouse.y); \n        }\n        final = look;\n    }\n    if(fragCoord.x == 2.5)//mod camPos texel\n    {\n        final = camPos + look*(keyW-keyS)*1.1 +\n                normalize(vec4(look.z,0.,-look.x,0.))*(keyD-keyA)*1.1;\n    }\n    fragColor = final;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 1189], [1190, 1190, 1242, 1242, 1332], [1348, 1348, 1368, 1368, 1574], [1575, 1575, 1632, 1632, 2185]], "test": "untested"}
{"id": "3t3BW7", "name": "Triangularized Mesh Raytracer", "author": "jstrom2002", "description": "Experimenting with ray-tracing for a triangularized mesh. This shader is a work-in-progress. ", "tags": ["rtx"], "likes": 2, "viewed": 551, "published": 3, "date": "1612832352", "time_retrieved": "2024-07-30T19:39:38.726320", "image_code": "//POST-PROCESSING PASS\n// Luminance factor for tone mapping\nconst vec3 Luminance = vec3(0.2126, 0.7152, 0.0722);\n\n\n// FXAA code from Morgan McGuire's 'Ray March Framework': https://www.shadertoy.com/view/Ms2SWw\n#define RES iResolution.xy\nvec3 tex(vec2 p) {\n    return texture(iChannel1, p).rgb; \n}\nvec3 fxaa(vec2 p) \n{\n\tconst float FXAA_SPAN_MAX   = 24.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 0.0;//1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);//vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);    \n    vec4 out_col = vec4(0,0,0,1);\n    \n    if(FXAA_ON != 0)\n        out_col.rgb = fxaa(uv);\n    else\n        out_col.rgb = texture(iChannel1, uv).rgb;\n    \n   // Apply Reinhard tonemap as necessary.\n   if(TONEMAP_RESULTS != 0)   \n       out_col.rgb = pow(out_col.rgb * 1.0 / \n           (1.0 + dot(out_col.rgb, Luminance)), vec3(1.0 / 2.2));       \n   \n   if(out_col.rgb != vec3(0.0))\n       fragColor = vec4(out_col.rgb,1.0);   \n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//KEYBOARD/MOUSE INPUT-HANDLING PASS\n\n// Code from: https://www.shadertoy.com/view/4lVXRm\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\nconst ivec2 TARGET = ivec2(0, 2);\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, -1.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 5.0;      \n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Global definitions\n#define BOUNCES 2\n#define BOUNCE_OFFSET 0.001\n#define BOUNCE_STRENGTH 0.2\n#define FXAA_ON 1\n#define INTERSECT_EPSILON 0.00001\n//#define INTERSECTION_METHOD_1\n#define JITTER_STRENGTH 0.000\n#define MAX_DISTANCE 99.9\n#define ROTATE_ON 0\n#define SAMPLES 1\n#define TONEMAP_RESULTS 0\n\n#define PI 3.1415926535897932384626433832795\n#define TWO_PI 6.283185307179586476925286766559\n\n\n// Triangularized Cornell box mesh data:\nconst int maxIndexVal = 20;\nvec3 vertices[maxIndexVal] = vec3[maxIndexVal](\nvec3(-10.0,10.0,10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(10.0,10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,10.0,10.0),\nvec3(10.0,10.0,-10.0)\n);\n\nvec2 uvs[maxIndexVal] = vec2[maxIndexVal](\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000)\n);\n\nvec3 normals[maxIndexVal] = vec3[maxIndexVal](\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000)\n);\n\n// Mesh vertex data is aligned to use a single index for position/normal/uv values.\nconst int numIndices = 30;\nint indices[numIndices] = int[numIndices]\n(\n0,1,2,\n0,2,3,\n4,5,6,\n\n4,6,7,\n8,9,10,\n8,10,11,\n\n12,13,14,\n12,14,15,\n16,17,18,\n\n16,18,19\n);\n\n\n\n\n// For buffer A 'free camera':\nmat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);    \n    return rotY * rotX;\n}", "buffer_b_code": "//LIGHTING PASS -- WORK-IN-PROGRESS\n\n// Vars from 'Free Camera'\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(1, 1);\n#define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n\nmat4 RotateScaleTranslate( vec3 r, vec3 s, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f*s.x,  d*e,          -c,      0.0,\n                 ac*f-b*e, ac*e+b*f*s.y, a*d,     0.0,\n                 bc*f+a*e, bc*e-a*f,     b*d*s.z, 0.0,\n                 t.x,      t.y,          t.z,     1.0 );\n}\nvec3 applyTransform(mat4 M, vec3 v)\n{\n    vec4 v_ = vec4(v, 1.0);\n    v_ = M * v_;\n    return v_.xyz / v_.w;\n}\n\nstruct Model\n{\n    vec3 position;\n    vec3 scale;\n    vec3 rotation;\n    \n    mat4 transform;   \n};\n\nstruct Camera\n{\n    vec3 position;\n    vec3 front;\n    vec3 up;\n    vec3 right;\n};\nCamera camera;\n\nstruct Light\n{\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float intensity;\n    int type;//enum: 0 = directional, 1 = point, 2 = spot.\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specular;\n    vec3 emissive;\n    float roughness;\n    float metalness;\n    float opacity;\n};\n\nstruct Scene\n{\n    // For now, array sizes are hardcoded for scene objects.\n    Model models[1];\n    int numModels;\n    \n    Material materials[3];\n    int numMaterials;\n    \n    Light lights[1]; \n    int numLights;\n};\nScene scene;\n\nstruct Ray\n{\n    vec3 o;//origin\n    vec3 d;//direction\n    float t;\n    float dist;//total distance ray has travelled\n    int bounce_number;\n};\n\nstruct Triangle \n{\n    vec3 v0,v1,v2;\n    int mtlidx;//material index.\n};\n\n//==================================================\n\nvoid update(inout Model m)\n{\n    m.transform = RotateScaleTranslate(m.rotation, m.scale, m.position);\n}\n\nvec2 barycenterToUV(vec3 bary, vec2 uv1, vec2 uv2, vec2 uv3){\n    return (bary.x * uv1) + (bary.y * uv2) + (bary.z * uv3);\n}\n\n\n// Generic function to test triangle intersection methods.\nbool IntersectTriangle(in Ray ray, in Triangle tri, out float hit, out vec3 barycentricCoord, out vec3 triangleNormal)\n{\n\n#ifdef INTERSECTION_METHOD_1\n    vec3 e0 = tri.v1 - tri.v0;\n    vec3 e1 = tri.v0 - tri.v2;    \n    triangleNormal = cross( e1, e0 );\n\n    // Check if the ray has hit the opposing face. \n    if (dot(ray.d, normalize(triangleNormal)) > 0.0) \n        return false;\n\n    vec3 e2 = ( tri.v0 - ray.o ) / dot( triangleNormal, ray.d );\n    vec3 i  = cross( ray.d, e2 );\n\n    barycentricCoord.y = dot( i, e1 );\n    barycentricCoord.z = dot( i, e0 );\n    barycentricCoord.x = 1.0 - (barycentricCoord.z + barycentricCoord.y);\n    hit = dot( triangleNormal, e2 );\n\n    return \n        (hit > INTERSECT_EPSILON)\n        && all(greaterThanEqual(barycentricCoord, vec3(0.0)));\n\n// ----------------------------------------------------------------\n\n#else\n    ray.o -= tri.v0; tri.v1 -= tri.v0; tri.v2 -= tri.v0; tri.v0 = vec3(0.0);\n    vec3 ba = tri.v1 - tri.v0, cb = tri.v2 - tri.v1, ac = tri.v0 - tri.v2;\n\n    // Intersect plane\n    vec3 n = cross(ba, -ac);\n    \n    // Check if the ray has hit the opposing face. \n    if (dot(ray.d, normalize(n)) > 0.0) \n        return false;\n    \n    float denom = dot(ray.d, n);\n    if (denom != 0.0) {\n        float t = -dot(ray.o, n) / denom;\n\n        // Triangle subareas for point in triangle test and computing barycoords\n        vec3 p = ray.o + ray.d * t;\n        vec3 pa = p - tri.v0, pb = p - tri.v1, pc = p - tri.v2;\n\n        float abc = length(n);\n        float u = length(cross(ba, pa)) / abc;\n        float v = length(cross(cb, pb)) / abc;\n        float w = length(cross(ac, pc)) / abc;\n\n        bool isHit = abs(u + v + w - 1.0) < 0.001;\n        if(isHit == true)\n        {\n            hit = t;\n            triangleNormal = n;\n            barycentricCoord = vec3(u,v,w);        \n            return true;\n        }\n    }\n#endif\n\n\n    return false;    \n}\n\n// Specular GGX code from: https://www.shadertoy.com/view/4tXXzM\nfloat G1V(float NdotV, float k)\n{\n\treturn 1.0/(NdotV*(1.0-k)+k);\n}\nfloat SpecGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0 )\n{\n\tfloat SqrRoughness = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat NdotL = clamp(dot(N,L),0.0,1.0);\n\tfloat NdotV = clamp(dot(N,V),0.0,1.0);\n\tfloat NdotH = clamp(dot(N,H),0.0,1.0);\n\tfloat LdotH = clamp(dot(L,H),0.0,1.0);\n\n\t// Geom term\n\tfloat RoughnessPow4 = SqrRoughness*SqrRoughness;\n\tfloat denom = NdotH * NdotH *(RoughnessPow4-1.0) + 1.0;\n\tfloat D = RoughnessPow4/(PI * denom * denom);\n\n\t// Fresnel term \n\tfloat LdotH5 = 1.0-LdotH;\n    LdotH5 = LdotH5*LdotH5*LdotH5*LdotH5*LdotH5;\n\tfloat F = F0 + (1.0-F0)*(LdotH5);\n\n\t// Vis term \n\tfloat k = SqrRoughness/2.0;\n\tfloat Vis = G1V(NdotL,k)*G1V(NdotV,k);\n\n\tfloat specular = NdotL * D * F * Vis;\n    \n\treturn specular;\n}\nvec3 CalculateLighting(Ray ray, Material material, Light light,\n    vec3 pos, vec3 V, vec3 N, vec3 L, bool applySpec)\n{\n    // Fresnel\n    float NdotV = clamp(dot(N,V),0.0,1.0);\n\tNdotV = pow(1.0-NdotV, 5.0);//NOTE: Fresnel strength hardcoded to 5.0 here.\n\tfloat Fresnel = material.metalness + (1.0-material.metalness)*(NdotV);\n\n\t // Lambertian diffuse light w/ fresnel factor.\n\t vec3 diffuse_val = light.color * material.albedo \n         * dot(N, L) * (1.0 - Fresnel);\n\t \n\t // Specular term.\n\t float spec = SpecGGX(N,V,L,material.roughness,material.metalness);\n     if(!applySpec)\n         spec = 0.0;\n\t vec3 specular_val = material.specular * spec * light.color;\t\n\t \n\t // Attenutate/combine terms.\n     float attenuation = 1.0;\n     if(light.type != 0)\n     {\n         float light_dist = length(light.position-pos);\n         float light_falloff = 1.0 / pow(light_dist, 2.0);\n         float bounce_falloff = BOUNCE_STRENGTH / pow(float(ray.bounce_number + 1), 2.0);\n         attenuation = pow(light_falloff, 1.0) * bounce_falloff;\n     }\n\t return scene.lights[0].intensity * (diffuse_val + specular_val) * attenuation; \n}\n\n\nbool IntersectRayScene(inout Ray ray, out vec3 pass_col)\n{\n    // Setup variables for loop.\n    vec3 N, bary;\n    float t;\n    bool isHit = false;\n    int mtlidx = 0;      \n    mat4 M;\n    vec3 initial = ray.o;\n    Material material;\n    \n    for(int n = 0; n < SAMPLES; ++n)\n    {\n        vec3 sample_col = vec3(0.0);\n        ray.o = initial;\n        if(SAMPLES > 1)\n        {\n           // Add blue noise value and jitter in spherical offset pattern.\n           float theta = PI * float(n)/float(SAMPLES);\n           ray.o += JITTER_STRENGTH * vec3(\n               cos(theta) * sin(theta), \n               cos(theta), \n               sin(theta) * sin(theta)) *\n               texture(iChannel1, vec2(iTimeDelta * iTime)).rgb;\n           ray.d = normalize(ray.d);\n        }\n        \n        Light currLight = scene.lights[0];\n        \n        for(int bnc = 0; bnc < BOUNCES; ++bnc)\n        {        \n            if(ray.dist >= MAX_DISTANCE)\n                break;\n            \n            for(int m = 0; m < scene.numModels; ++m)\n            {\n                M = scene.models[m].transform;\n\n                // Iterate through scene triangles and check for a ray hit.\n                for(int i=0; i<numIndices; i+=3)\n                {\n                    // Get mesh triangle vertices.\n                    Triangle tri;\n                    tri.v0 = vertices[indices[i+0]];\n                    tri.v1 = vertices[indices[i+1]];\n                    tri.v2 = vertices[indices[i+2]];\n\n                    // Transform triangle vertices.\n                    tri.v0 = applyTransform(M, tri.v0);\n                    tri.v1 = applyTransform(M, tri.v1);\n                    tri.v2 = applyTransform(M, tri.v2);\n\n                    // Hardcoded material indexing\n                    mtlidx = 0;\n                    if(i >= 18 && i < 24)\n                        mtlidx = 1;\n                    else if(i >= 24 && i < 30)\n                        mtlidx = 2;\n                    else if(i >= 30)\n                        mtlidx = 0;\n                    material = scene.materials[mtlidx];\n\n                    // Use mesh normal.\n\n                    vec3 dummy_n;\n                    isHit = bool(IntersectTriangle(ray,tri,t,bary,dummy_n));\n                    //N = normalize(dummy_n);\n                    N = normalize(bary.x * normals[indices[i+0]] + bary.y * normals[indices[i+1]] + bary.z * normals[indices[i+2]]);\n\n                    if(isHit)\n                    {\t  \n                        // Get mesh triangle texture coordinates.\n                        vec2 uv1 = uvs[indices[i+0]];\n                        vec2 uv2 = uvs[indices[i+1]];\n                        vec2 uv3 = uvs[indices[i+2]];\n                        vec3 texCoord = vec3(barycenterToUV(bary,uv1,uv2,uv3), 1.0);\n\n                        // Get intersection coordinate of shared ray/triangle point.\n                        vec3 ray_coord = ray.o + ray.d * t;\t       \n                        vec3 L = vec3(0.0);\n                        if(currLight.type == 0)\n                            L = normalize(-currLight.direction);\n                        else\n                            L = normalize(currLight.position - ray_coord);\n                        vec3 V = normalize(camera.position - ray_coord);\t\t\n                        sample_col.rgb += CalculateLighting(\n                            ray, material, currLight, ray_coord, \n                            V, N, L, ray.bounce_number == 0);\n                        sample_col.rgb += material.emissive;\n\n                        // Save new reflected light bounce origin and direction and continue.\n                        ray.d = normalize(reflect(ray.d, N));\n                        ray.o = ray_coord + ray.d * BOUNCE_OFFSET;//add slight offset to new origin.\n                        ray.t = t;\n                        ray.dist += t;\n                        ray.bounce_number++;\n\n                        break;\n                    }                                                               \n                }                                                   \n            }\n            \n            if(bnc == 0 && isHit == false)\n            {\n                pass_col.rgb = texture(iChannel0, ray.d * vec3(1,-1,1)).rgb;\n                bnc = BOUNCES;\n                n = SAMPLES;\n            }\n            \n        }       \n        \n        pass_col += sample_col;\n    }\n    \n    pass_col /= float(SAMPLES);\n        \n    return isHit;\n}\n\nCamera InitCamera(in vec2 uv) \n{\n    Camera cam;\n    cam.position = load(POSITION).xyz;\n    \n    vec2 m = load(VMOUSE).xy/iResolution.x;    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    cam.front = normalize(vec3((uv - iResolution.xy*0.5)*a, 0.5));    \n    cam.front = CameraRotation(m) * cam.front;\n    \n    cam.up = vec3(0,1,0);\n    cam.right = cross(cam.front, cam.up);\n    \n    return cam;\n}\n\nRay InitRay(in Camera cam, out vec3 ray_initial_dir, vec2 uv)\n{\n    Ray ray;\n    ray.dist = 0.0;\n    ray.bounce_number = 0;\n    \n    // Setup ray direction\n    float angle = tan(0.5*45.0);//fov angle\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    float x = uv.x * aspect * angle;//aspect correction\n    float y = uv.y * angle;\n    ray.o = cam.position;\n    ray_initial_dir = normalize(x * cam.right + uv.y * -cam.up + cam.front);\n    ray.d = ray_initial_dir;\n    \n    return ray;\n}\n\nScene InitScene()\n{\n    Scene scene;    \n    Material material;\n    Model model;\n    Light light;\n    \n    // White.\n    material.albedo = vec3(0.75);\n    material.specular = vec3(1.0);\n    material.emissive = vec3(0.0, 0.0, 0.0);\n    material.roughness = 1.0;\n    material.metalness = 0.0;\n    material.opacity = 1.0;\n    scene.materials[0] = material;\n    \n    // Green.\n    material.albedo = vec3(0.0, 0.35, 0.0);\n    material.specular = vec3(1.0);\n    material.emissive = vec3(0.0);\n    material.roughness = 1.0;\n    material.metalness = 0.0;\n    material.opacity = 1.0;\n    scene.materials[1] = material;\n    \n    // Red.\n    material.albedo = vec3(0.65, 0.0, 0.0);\n    material.specular = vec3(1.0);\n    material.emissive = vec3(0.0);\n    material.roughness = 1.0;\n    material.metalness = 0.0;\n    material.opacity = 1.0;\n    scene.materials[2] = material;\n    \n    scene.numMaterials = 3;\n    \n    // Add lights.\n    light.position =  vec3(0.0, -5.0, 50.0);\n    light.direction = vec3(0.0, -0.8, 0.2);\n    light.color =     vec3(1.0, 1.0, 0.90);\n    light.intensity = 6.0e3;\n    light.type = 1;//0 = directional, 1 = point light, 2 = spot light.\n    scene.lights[0] = light;\n    \n    scene.numLights = 1;\n    \n    // Add models.\n    model.position = vec3(0.0,0.0,40.0);\n    model.scale = vec3(2.0,2.0,2.5);\n    model.rotation = vec3(0.0);\n    update(model);\n    scene.models[0] = model;\n    \n    scene.numModels = 1;\n    \n    return scene;\n}\n\nvoid rotateObjects()\n{\n    // Per-frame rotation for models.\n    for(int i=0 ;i<scene.numModels; ++i)\n    {\n        if(ROTATE_ON > 0)  \n        {\n            scene.models[i].rotation = vec3(iTime);\n            update(scene.models[i]);\n        }\n    }\n    \n    // Per-frame rotation for light.\n    float tmr = iTime * 0.35;\n    int typ = scene.lights[0].type;\n    if(typ == 0)\n    {\n        scene.lights[0].direction = \n            normalize(scene.lights[0].direction + 1.5 * TWO_PI \n            * vec3(cos(tmr), sin(tmr), cos(tmr)*sin(iTime)));\n    }\n    else\n    {\n        scene.lights[0].position += 1.5 * TWO_PI * vec3(\n            cos(tmr), \n            sin(tmr), \n            cos(tmr)*sin(iTime)\n        );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;    \n        \n    // Init global variables. \n    camera = InitCamera(uv);\n    scene = InitScene();    \n    vec3 ray_initial_dir;\n    Ray ray = InitRay(camera, ray_initial_dir, uv);\n    vec3 out_col = vec3(0.0);\n    \n    rotateObjects();\n      \n    // Gather light from ray.\n    IntersectRayScene(ray, out_col);\n   \n    fragColor = vec4(out_col,1.0);   \n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 256, 256, 297], [298, 298, 318, 318, 1894], [1897, 1897, 1954, 1954, 2432]], "test": "untested"}
{"id": "WlcBD7", "name": "basic Pacman 2d", "author": "jorge2017a1", "description": "basic Pacman 2d", "tags": ["basicpacman2d"], "likes": 3, "viewed": 229, "published": 3, "date": "1612825637", "time_retrieved": "2024-07-30T19:39:39.492272", "image_code": "// por jorge2017a1 ...jorge flores p.!!!\n\n#define PI 3.14159265359\n#define PI2 PI*2.0\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n\nvec2 pacmanface(vec2 p)\n{  \n    vec2 res= vec2(9999.9,-1.0);\n    \n    float dc1= sdCircle( p, 0.8 );\n    float ojoA= sdCircle( p-vec2(-0.2, 0.3), 0.1 );\n    float ojoB= sdCircle( p-vec2(-0.2, 0.3), 0.15 );\n    float dboca1= sdBox(p-vec2(-0.5,-0.2), vec2(0.4,0.15- abs(0.15*sin(iTime*3.0)))  );\n    \n    float ojo=opS(ojoA,ojoB);\n     dc1=opS(ojo,dc1);\n     dc1=opS(dboca1,dc1);\n    \n    res=opU2( res, vec2(dc1/fwidth(dc1),1.0) );\n    res=opU2( res, vec2(ojo/fwidth(ojo),0.0) );\n    res=opU2( res, vec2(ojoA/fwidth(ojoA),5.0) );\n    return res;\n}\n\n\nfloat MarOnda(vec2 uv,float  t)\n{\n    uv.y += sin(uv.x*5.+t)*0.1;\n    return uv.y;\n}\nfloat PisoOnda(vec2 uv)\n{\n    \n    uv.y +=0.14* sin(uv.x*14.+iTime*5.0) ;\n    return uv.y;\n}\n\n\nvec2 fantasma1(vec2 p)\n{\n    vec2 res= vec2(9999.9,-1.0);\n    \n    float dc1= sdCircle( p, 0.8 );\n    float dropa= sdBox(p-vec2(0.0,-0.5), vec2(0.8,0.5)  );\n   float dboca1= sdBox(p-vec2(0.0,-0.5), vec2(0.4,0.05)  );\n    \n    float ojoA1= sdCircle( p-vec2(-0.3, 0.3), 0.1 );\n    float ojoB1= sdCircle( p-vec2(-0.3, 0.3), 0.15 );\n    \n    float ojoA2= sdCircle( p-vec2(0.3, 0.3), 0.1 );\n    float ojoB2= sdCircle( p-vec2(0.3, 0.3), 0.15 );\n    \n\n    dc1=opU(dc1, dropa);\n    dc1=opS(dboca1, dc1 );\n    \n    \n    float ojo1=opS(ojoA1,ojoB1);\n    float ojo2=opS(ojoA2,ojoB2);\n    \n    dc1=opS(ojo1,dc1);\n    dc1=opS(ojo2,dc1);\n    \n    \n    res=opU2( res, vec2(dc1/fwidth(dc1),2.0) );\n    res=opU2( res, vec2(ojo1/fwidth(ojo1),5.0) );\n    res=opU2( res, vec2(ojoA1/fwidth(ojoA1),0.0) );\n    \n    res=opU2( res, vec2(ojo2/fwidth(ojo2),5.0) );\n    res=opU2( res, vec2(ojoA2/fwidth(ojoA2),0.0) );\n    res=opU2( res, vec2(dboca1/fwidth(dboca1),0.0) );\n    \n    \n    return res;\n}\n\n\nvec2 fantasma2(vec2 p)\n{\n    vec2 res= vec2(9999.9,-1.0);\n    \n    float dc1= sdCircle( p, 0.8 );\n    float dropa= sdBox(p-vec2(0.0,-0.5), vec2(0.8,0.5)  );\n    \n    float ojoA1= sdCircle( p-vec2(-0.3, 0.3), 0.1 );\n    float ojoB1= sdCircle( p-vec2(-0.3, 0.3), 0.15 );\n    \n    float ojoA2= sdCircle( p-vec2(0.3, 0.3), 0.1 );\n    float ojoB2= sdCircle( p-vec2(0.3, 0.3), 0.15 );\n    \n    float vesInf= PisoOnda(p-vec2(0.0,-0.75));\n    \n    dc1=opU(dc1, dropa);\n    \n    float ojo1=opS(ojoA1,ojoB1);\n    float ojo2=opS(ojoA2,ojoB2);\n    \n    dc1=opS(ojo1,dc1);\n    dc1=opS(ojo2,dc1);\n    dc1=opS(vesInf,dc1);\n    \n    \n    \n    \n    res=opU2( res, vec2(dc1/fwidth(dc1),4.0) );\n    res=opU2( res, vec2(ojo1/fwidth(ojo1),5.0) );\n    res=opU2( res, vec2(ojoA1/fwidth(ojoA1),0.0) );\n    \n    res=opU2( res, vec2(ojo2/fwidth(ojo2),5.0) );\n    res=opU2( res, vec2(ojoA2/fwidth(ojoA2),0.0) );\n    \n    \n    return res;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n     p*=2.0;\n     float tt=mod(iTime,5.0);\n    \n    p.y=p.y-0.05;\n    \n    //vec3 colOut=vec3(0.5,0.3,1.0);\n    vec3 colOut=vec3(0.0,0.0,0.4);\n\n    \n    vec2 sl1= pacmanface( p);\n    vec2 sl2= fantasma1( p-4.0*sin(vec2(2.0,0.0)*iTime*0.5) );\n    vec2 sl3= fantasma2( p-2.0*cos( vec2(-2.0,0.5) * iTime*0.5  ));\n    \n    \n    colOut= ProcesoColorVec2Grosor( colOut, sl1, 1.0);  // by jeyko\n    colOut= ProcesoColorVec2Grosor( colOut, sl2, 1.0);  // by jeyko\n    colOut= ProcesoColorVec2Grosor( colOut, sl3, 0.6);  // by jeyko\n   \n    vec4 color =vec4(colOut, 1.0);\n  \tfragColor = color;\n\n}\n\n\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\n\n\n///------------------\nvec3 ProcesoColor(vec3 colBorde , vec3 colOut, float dist)\n{\n    float thickness = 0.005;  //grosor\n\tfloat blur = 0.004;\t //difuminar\n    \n    float step1 = thickness;\n\tfloat step2 = thickness + blur;\t\n    float step3= smoothstep(step1, step2, dist);\n    vec3 color1 = mix(colBorde, colOut, step3);\t\n    return color1;\n}\n\nvec3 ProcesoColorVec2( vec3 colOut, vec2 dist)\n{\n    float thickness = 0.005;  //grosor\n\tfloat blur = 0.004;\t //difuminar\n    vec3 colBorde=getColorf(dist.y);\n    \n    float step1 = thickness;\n\tfloat step2 = thickness + blur;\t\n    float step3= smoothstep(step1, step2, ( dist.x) );\n    vec3 color1 = mix(colBorde, colOut, step3);\t\n    return color1;\n}\n\nvec3 ProcesoColorVec2Grosor( vec3 colOut, vec2 dist, float grosor)\n{\n    float thickness = grosor;  //grosor\n\t//float blur = 0.004;\t //difuminar\n    float blur = 1.;\t //difuminar  by jeyko\n    \n    vec3 colBorde=getColorf(dist.y);\n    \n    float step1 = thickness;\n\tfloat step2 = thickness + blur;\t\n    float step3= smoothstep(step1, step2, ( dist.x) );\n    vec3 color1 = mix(colBorde, colOut, step3);\t\n    return color1;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 168, 168, 190], [191, 191, 224, 224, 246], [247, 247, 280, 280, 301], [304, 304, 341, 341, 421], [424, 424, 459, 459, 487], [490, 490, 542, 542, 661], [666, 666, 691, 691, 1212], [1215, 1215, 1248, 1248, 1299], [1300, 1300, 1325, 1325, 1392], [1395, 1395, 1419, 1419, 2367], [2370, 2370, 2394, 2394, 3282], [3286, 3286, 3343, 3343, 4035]], "test": "untested"}
{"id": "wtdBWN", "name": "Formful", "author": "ruojake", "description": "Getting some serious mileage out of a 4D box. Press space to toggle rounding.", "tags": ["3d", "raymarching", "4d"], "likes": 8, "viewed": 306, "published": 3, "date": "1612821129", "time_retrieved": "2024-07-30T19:39:40.363942", "image_code": "// Formful by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat box(in vec4 p, in vec4 b)\n{\n  vec4 d = abs(p) - b;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, max(d.z, d.w))), 0.);\n}\n\nfloat scene(in vec3 p)\n{\n    vec4 q = vec4(p, sin(dot(p.xz * 3., -p.yz) * .125 + iTime * .25) * .4);\n    q -= vec4(0,0,4,0);\n    float t = iTime * .03125;\n    q.xw *= rot(t);\n    q.yw *= rot(t*7.+q.w*.9);\n    q.zw *= rot(t*13.-q.w*.5);\n    q.xz *= rot(t*11.+q.y*.7);\n    \n    float r = texelFetch( iChannel0, ivec2(32,2), 0 ).x > 0.5 ? .003 : .06;\n    return box(q, vec4(2.5,2,1.5,.5)) * .15 - r;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.002, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 dither(vec2 p)\n{\n    float r = dot(vec3(p,float(iFrame % 60)), vec3(7., 11., 9.) / 13.);\n    return fract(vec3(r, r + .3334, r + .6667)) * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 ro = vec3(uv * .025, 0.);\n    vec3 rd = normalize(vec3(uv, .5));\n    float t = 1.4;\n    vec3 p;\n    float i = 0.;\n    \n    for(; i < 1. && t < 10.; i += 1./256.)\n    {\n        p = ro + rd * t;\n        float d = scene(p);\n        t += d;\n        if (abs(d) < .0025) break;\n    }\n\n    vec3 col = vec3(0);\n    if (t >= 10.)\n    {\n        col = vec3(.15 + uv.y * -.15, .35, .6) + smoothstep(.1, .8, i);\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 r = reflect(rd, n);\n        float refl = smoothstep(.8, .4, length(sin(r * 2.+ 2.)));   \n        float l = n.y * .4 + .7;\n        vec3 ao = mix(vec3(1), vec3(.3, .6, 1.) * .3, i * .8);\n        col = vec3(pow(refl,8.) * 2. + pow(l, 3.) * 4. * ao * mix(vec3(.35, .8, 0.), vec3(1., 1., .8), pow(l,9.) * .4));\n    }\n     \n    col = col * (1. + col / 20.) / (1. + col);\n    col = pow(col, vec3(1. / 2.2));\n\n    fragColor = vec4(col.rgb + dither(fragCoord) / 255., 1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBWN.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[108, 108, 127, 127, 203], [205, 205, 238, 238, 337], [339, 339, 363, 363, 737], [739, 739, 760, 760, 923], [925, 925, 946, 946, 1079], [1081, 1081, 1138, 1138, 2135]], "test": "untested"}
{"id": "Wt3BW7", "name": "Day 419", "author": "jeyko", "description": "potate ", "tags": ["mdtmjvm"], "likes": 13, "viewed": 333, "published": 3, "date": "1612811556", "time_retrieved": "2024-07-30T19:39:41.141862", "image_code": "// Fork of \"day 418\" by jeyko. https://shadertoy.com/view/tt3BD4\n// 2021-02-08 17:12:41\n\n// Fork of \"Day 417 \" by jeyko. https://shadertoy.com/view/wt3fD8\n// 2021-02-07 20:32:07\n\n// influenced by blackle's https://www.shadertoy.com/view/3dXfR2 !!\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.9;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    //fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.2,1.2));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.8;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 + n*0.1));\n    \n    \n    \n    \n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.04;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.05;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nmat3 getOrthogonalBasis(vec3 dir){\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\nfloat cyclicNoise(vec3 p){\n    \n    //p.yz *= rot(1.4);\n    \n    float n = 0.;\n    float amp = 1.;\n    float gain = 0.5;\n    float lac = 1.1 ;\n    \n    vec3 seed = normalize(vec3(3,-1,2));\n    mat3 rotm = getOrthogonalBasis(seed);\n\n    for(float i = 0.; i < 5.; i++){\n        p -= cos(p.zxy*1.5*gain*2. + iTime + i)*0.1;\n        n += (dot(sin(p), cos(p.zxy)))*amp;\n    \n        amp *= gain;\n        p *= lac*rotm;\n\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 oouv = uv;\n    \n    \n    uv *= 1.5;\n    \n    \n    vec3 col = vec3(0.7,0.9,0.9)*1.2;\n    \n    float n = cyclicNoise(vec3(uv*5.,iTime*0.5 + 4.));\n    \n    n = cyclicNoise(vec3(uv*10. + n*1.15,iTime));\n        \n    float nb = cyclicNoise(vec3(uv*5.,iTime));\n    \n    float vn = valueNoise(iTime*0.25,5.);\n    float vnb = valueNoiseStepped(iTime/2. + n*0.*pow(vn,0.5) + 5.,2.,4.);\n    float vnc = valueNoiseStepped(iTime/2.,4.,4.);\n    \n    \n    float dfuv = fwidth(length(uv));\n    \n    vec2 d = vec2(24,1.);\n    vec2 p = uv;\n        \n    \n    for(float j = 0.; j < 2.; j++){\n        float reps = 13.;\n        float s = 0.45 - vn*0. + sin(j + iTime)*0.1*vn;\n    \n        float gain = s*1.6 - vnc*0.3;\n        for(float i = 0.; i < reps; i++){\n            float modder = mod(iTime + 7.,10.);\n            p *= rot(0.2*smoothstep(4.,3.,modder)*smoothstep(0.,0.4,modder));\n            //p *= rot(sin(i*pi*1. + 0.5)*pi/vnc*0.25);\n            float circle = length(p) - log(s + 1.);\n            float news = s*gain;\n            \n            float offs = 0.;\n            \n            if(j == 0.)\n                offs = log(s-news +1. + sin(iTime + i)*0.38 );\n            else\n                offs = -log(s-news +1. + sin(iTime + i)*0.38 );\n            offs *= 0.3 + vnb;\n            p.x -= offs; \n            s = news;\n            //d.y += 1.;\n            //d = dmin(d,circle,d.y + 1.);\n            if( !(j == 1. && i == 0.))\n                d.y = mix(d.y, d.y + 1. + p.y*2.,smoothstep(dfuv*1.,0.,circle ));\n        \n        }\n    }\n     \n    vec2 idu = floor(uv/0.75*4.);\n    //d.y = mix(d.y, d.y + 1.,smoothstep(dfuv*1.,0.,uv.x ));\n    \n    uv = pmod(uv,0.75/4.);\n    float vnd = valueNoiseStepped(iTime/2. + idu.y*0.2,4.,4.);\n    \n    d.y = mix(d.y, d.y + idu.y*0.4,smoothstep(dfuv*1.,0.,uv.y - 0.2 + vnc*0. + uv.y*1. + 0. + vnc*0.1 + vnd*0.5 ));\n    \n    \n    float md = 0.75*0.5*0.5;\n    p = uv;\n    vec2 id = floor(p/md);\n    p = pmod(p,md);\n    \n    vec3 c = pal(0.5,.5*vec3(1.,0.8,0.2),vec3(1. ,2.,1. - d.y*4. ),1.,0. + d.y*1. + 7. + iTime*1. + uv.y*0.));\n    col = c;\n    \n    col = mix(col, 1. - col, \n        //step(0.4,valueNoiseStepped(iTime*25.,2.,4.)) *\n        step(0.3,valueNoiseStepped(iTime/2.5 ,2.,2.))\n        \n        );\n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*14.,2.)*0.1 ;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0., (d)) - 0.5*(d)\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e))\n\nfloat r11(float i){ return fract(sin(i*12.126)*5.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n#define dmin(a,b,c) (max(a.x,-b) < b ? a : vec2(b,c))", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3BW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 306, 306, 1115]], "test": "untested"}
{"id": "3lcfDM", "name": "Fast path tracer v2.0", "author": "me_123", "description": "I spent about 2 day on this shader. it is a montecarlo path tracer.\nif there is any optimisations plz tell me, because i am hoping that this will be real time,\nI used Michele Morrone glslSmartDeNoise (https://www.shadertoy.com/view/3dd3Wr)\nlike shader ( :", "tags": ["pathtracing"], "likes": 25, "viewed": 1111, "published": 3, "date": "1612811270", "time_retrieved": "2024-07-30T19:39:41.921777", "image_code": "//I used Michele Morrone glslSmartDeNoise (https://www.shadertoy.com/view/3dd3Wr)\n#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI\n#define INV_PI 0.31830988618379067153776752674503\nvec4 smartDeNoise(sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold)\n{\n    float radius = round(kSigma*sigma);\n    float radQ = radius * radius;\n    \n    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)\n    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)\n    \n    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)\n    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)\n    \n    vec4 centrPx = texture(tex,uv);\n    \n    float zBuff = 0.0;\n    vec4 aBuff = vec4(0.0);\n    vec2 size = vec2(textureSize(tex, 0));\n    \n    for(float x=-radius; x <= radius; x++) {\n        float pt = sqrt(radQ-x*x);  // pt = yRadius: have circular trend\n        for(float y=-pt; y <= pt; y++) {\n            vec2 d = vec2(x,y);\n\n            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI; \n            \n            vec4 walkPx =  texture(tex,uv+d/size);\n\n            vec4 dC = walkPx-centrPx;\n            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;\n                                 \n            zBuff += deltaFactor;\n            aBuff += deltaFactor*walkPx;\n        }\n    }\n    return aBuff/zBuff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = smartDeNoise(iChannel0, fragCoord.xy/iResolution.xy, 5.0, 1.0, .2);//texture(iChannel0, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float eps = 0.0000001;\nfloat INFINITY = 100000.;\nfloat hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nstruct ray {\n\tvec3 origin;\n    vec3 dir;\n};\nstruct mater {\n\tvec3 color;\n    int mat;\n    float ev;\n};\nstruct rec {\n    float t;\n    vec3  p;\n    vec3  normal;\n    mater mat;\n};\n\nstruct sphere {\n\tvec3 radius;\n    vec3 center;\n    mater mat;\n    int type;\n};\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash3(p+vec3(0, 0, 0));\n    float b = hash3(p+vec3(1, 0, 0));\n    float c = hash3(p+vec3(0, 1, 0));\n    float d = hash3(p+vec3(1, 1, 0));\n    float e = hash3(p+vec3(0, 0, 1));\n    float f = hash3(p+vec3(1, 0, 1));\n    float g = hash3(p+vec3(0, 1, 1));\n    float h = hash3(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);//vec3(hash(seed)-0.5, hash(seed+2.0)-0.5, hash(seed+2.0)-0.5);\n}\nint sc = 11;\nsphere scene[11];\nbool hitObject(vec3 center, vec3 radius, ray r, float t_min, float t_max, out rec re, mater mat, int type) {\n    if (type == 0) {\n        vec3 oc = r.origin-center;\n        float a = dot(r.dir, r.dir);\n        float b = dot(oc, r.dir);\n        float c = dot(oc, oc) - radius.x*radius.x;\n        float disc = b*b - a*c;\n        if (disc > 0.) {\n            float temp = (-b - sqrt(b*b-a*c)) / a;\n            if (temp < t_max && temp > t_min) {\n                vec3 p = r.origin+r.dir*temp;\n                re.t = temp;\n                re.p = p;\n                re.normal = (p - center) / radius;\n                re.mat = mat;\n                return true;\n            }\n            temp = (-b + sqrt(b*b-a*c)) / a;\n            if (temp < t_max && temp > t_min) {\n                vec3 p = r.origin+r.dir*temp;\n                re.t = temp;\n                re.p = p;\n                re.normal = (p - center) / radius;\n                re.mat = mat;\n                return true;\n            }\n        }\n        return false;\n    } else {\n    \t    vec3 roo = r.origin;\n        vec3 rdd = r.dir;\n        vec3 rad = radius;//vec3(radius);\n        vec3 ro = r.origin-center;\n        vec3 rd = r.dir;\n        vec3 oN = vec3(0);\n        vec3 m = 1.0/rd;\n        vec3 n = m*ro;\n        vec3 k = abs(m)*rad;\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n        float tN = max(max(t1.x, t1.y), t1.z);\n        float tF = min(min(t2.x, t2.y), t2.z);\n        if (tN > tF || tN < 0.0) {\n            return false;\n        }\n        if (tF > t_min && tN < t_max) {\n            oN = -sign(rd)*step(t1.yzx, t1.xyz)*step(t1.zxy, t1.xyz);\n            re.t = tN;\n            re.p = r.origin+r.dir*tN;\n            re.normal = oN;\n            re.mat = mat;\n            return true;\n        }\n        return false;\n    }\n}\nbool hitScene(ray r, float tmin, float tmax, out rec hit) {\n\tbool hitIt = false;\n    float closest = tmax;\n    for (int i = 0; i < sc; i += 1) {\n        if (hitObject(scene[i].center, scene[i].radius, r, tmin, closest, hit, scene[i].mat, scene[i].type)) {\n            hitIt = true;\n            closest = hit.t;\n        }\n    }\n    return hitIt;\n}\nvoid diffused(out ray r, vec2 seed, rec hit, inout vec3 c) {\n    vec3 target = hit.p + hit.normal + rus(seed);\n    r.origin = hit.p;\n    r.dir = target - (hit.p+eps);\n    c *= hit.mat.color;\n}\nvoid gloss(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    r.origin = hit.p;\n    r.dir = (reflect(r.dir, hit.normal)+(rus(seed)*hit.mat.ev));\n    c *= hit.mat.color;\n}\nvoid emit(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    c *= hit.mat.color*5.;\n}\nvec3 color(vec3 ro, vec3 rd, vec2 seed) {\n    vec3 c = vec3(1.0);\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    int i;\n    for (i = 0; i < 20; i += 1) {\n        rec hit;\n        ray r = ray(roo, rdd);\n        if (hitScene(r, eps, INFINITY, hit)) {\n            ray rrr = r;\n            if (hit.mat.mat == 0) {diffused(rrr, seed, hit, c);}\n            else if (hit.mat.mat == 1) {gloss(rrr, seed, hit, c);}\n            else {emit(rrr, seed, hit, c);break;}\n            roo = rrr.origin;\n            rdd = rrr.dir;\n        } else {\n            vec3 dir = normalize(rdd);\n            float t = 0.5*(dir.y+2.);\n            c *= texture(iChannel1, dir).xyz;\n            break;\n        }\n\t}\n    return c;\n}\nint samples = 3;\nfloat camSize = 15.;\nvec3 drawImage(in vec2 fragCoord )\n{\n\tscene[0] = sphere(vec3(0.4, 2., 0.4), vec3(-4, 1.5, -4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[1] = sphere(vec3(0.4, 2., 0.4), vec3(4, 1.5, -4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[2] = sphere(vec3(0.4, 2., 0.4), vec3(4, 1.5, 4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[3] = sphere(vec3(0.4, 2., 0.4), vec3(-4, 1.5, 4), mater(vec3(0.8, 0.3, 0.3), 0, 0.), 1);\n\tscene[4] = sphere(vec3(5, 0.1, 5), vec3(-0, 3.5, 0), mater(vec3(0.2, 0.6, 0.8), 0, 0.), 1);\n\tscene[5] = sphere(vec3(4, 0.25, 4), vec3(-0, 3.65, 0), mater(vec3(0.8, 0.8, 0.3), 1, 0.1), 1);\n\tscene[6] = sphere(vec3(5), vec3(-10, 10., 0), mater(vec3(1, 0.8, 0.2), 2, 0.), 0);\n\tscene[7] = sphere(vec3(5), vec3(10, 10., 0), mater(vec3(1, 0, 0), 2, 0.), 0);\n\tscene[8] = sphere(vec3(5), vec3(2, 20., 0), mater(vec3(0.5, 0.5, 1.0), 2, 0.), 0);\n\tscene[9] = sphere(vec3(20, 0.1, 20), vec3(0, -.6, -1), mater(vec3(0.8, 0.8, 0.8), 0, 0.5), 1);\n\tscene[10] = sphere(vec3(2), vec3(0, 6., 0), mater(vec3(0.8), 0, 0.), 0);\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*2.;\n    mouse.y = max(mouse.y, -0.0);\n    if (int(iMouse.x) == 0) {\n        mouse.x = 0.5;\n        mouse.y = 0.5;\n    }\n    vec3 c = vec3(0);\n    float tSeed = (iTime/10.);\n    for (int i = 0; i < samples; i += 1) {\n        vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n        uv += (vec2(hash(uv+float(i)+tSeed), hash(uv+float(i)+float(samples+1)+tSeed))-0.5)/(iResolution.xy/2.);\n        vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n        vec3 at = vec3(0, 4.9, 0);\n        vec3 cam_z = normalize(at-ro);\n        vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n        vec3 cam_y = cross(cam_z, cam_x);\n        vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1. * cam_z);\n        c += color(ro, rd, uv+(float(i)/1000.)+tSeed);\n    }\n   \treturn vec3(c/float(samples));\n}\nvec2 chunkPos = vec2(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z < 10.) {\n        fragColor = (vec4(drawImage(fragCoord), 1.0)+(texture(iChannel0, fragCoord/iResolution.xy))*100.)/101.;\n    } else {\n        fragColor = vec4(clamp(drawImage(fragCoord), 0.0, 1.0), 1.0);\n    }\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 298, 298, 1497], [1498, 1498, 1555, 1555, 1691]], "test": "untested"}
{"id": "wldBDN", "name": "Moiré 3b2", "author": "FabriceNeyret2", "description": "coloring [url]https://shadertoy.com/view/3ldBzM[/url]", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 8, "viewed": 277, "published": 3, "date": "1612799649", "time_retrieved": "2024-07-30T19:39:42.782475", "image_code": "// color variant of https://shadertoy.com/view/3ldBzM\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*R.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 3.;\n    vec2 R = vec2(360)/8., T = vec2( 2, 3.5 )*R;\n    float v = P;\n\n    U = 1.1*U.yx + 10.*iTime;\n    v += P;\n    \n    O =  ( .6 + .6 * cos( 6.3*v/3.  + vec4(0,23,21,0)  ) );  // hue: https://www.shadertoy.com/view/ll2cDc\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 249, 249, 485]], "test": "untested"}
{"id": "tldBDN", "name": "weird stuff on ubuntu, glsl bug", "author": "Ric3cir121", "description": "really weird and random stuff showing on screen", "tags": ["glsl", "bug"], "likes": 1, "viewed": 261, "published": 3, "date": "1612798968", "time_retrieved": "2024-07-30T19:39:43.550422", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = texelFetch(iChannel0,ivec2(u),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 o,vec2 u){\n    o = max(o/2.,min(texelFetch(iChannel0,ivec2(u),0),1.)/1.01);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 78]], "test": "untested"}
{"id": "tldfWN", "name": "Erector Set Menger", "author": "eiffie", "description": "Built an erector set menger for my robot spider monkeys to replace that matchstick disaster. I don't have any robot spider monkeys yet but I'm cautiously optimistic. Its like honey to a bee.", "tags": ["menger"], "likes": 24, "viewed": 526, "published": 3, "date": "1612796410", "time_retrieved": "2024-07-30T19:39:44.433062", "image_code": "//erector set menger by eiffie\n#define time iTime\n#define rez iResolution\nvec3 mcol=vec3(0.0);bool bHide;\nconst float c1=0.0125,c2=0.007;\nfloat axi(vec3 p){p=abs(p);p=max(p,p.yzx);return min(p.x,min(p.y,p.z));}\nfloat box(vec3 p){p=abs(p);return max(abs(p.x),max(abs(p.y),abs(p.z)));}\nfloat ere(vec3 p){p=abs(p);return max(axi(p)-c1,min(p.x,min(p.y,p.z))-0.001);}\nfloat hol(vec3 p){p=abs(mod(p,c2*2.))-c2;return min(length(p.xy),min(length(p.yz),length(p.xz)));}\nfloat tube(vec3 pa, vec3 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));} \n\nfloat DE(vec3 p){\n  float s=1./3.,md=1./(27.*s);//menger sizes\n  p+=(0.1+0.05*sin(p.yzx*time*0.1+time*time*0.02))*abs(mod(p.zxy,2.*md)-md);//make wonky\n  float r=box(p)-1.0,d=axi(p)-s,r1=r;//1st menger iter\n  vec3 m=floor(p/md);//find what box we are in (k)\n  float k=sin(m.x+2.4*sin(m.z))+m.z,tim=time*(2.+7.*fract(k));\n  vec3 v=mod(p+.5*md,md)-.5*md;//mod to the box\n  vec3 q=vec3(v.x,mod(p.y+k+tim*0.01+sin(tim*4.)*0.003,0.15+0.25*fract(k))-0.2,v.z)-0.02;\n  q.xz=0.707*vec2(q.x-q.z,q.x+q.z);//q is the spider, turn 45 deg\n  float f=max(length(q)-0.01,-q.z-0.003);//body\n  vec3 sq=sign(q);sq.z=-1.;//legs\n  f=min(f,tube(q-sq*vec3(0.006,0.007,0.003),sq*vec3(0.002,0.014+q.z*abs(sin(tim+.5*sq.x)),0.014))-0.001);\n  if(min(abs(p.x),abs(p.z))<s || max(abs(p.x),abs(p.z))>1.)f=10.;//remove unwanted spiders\n  vec3 av=abs(v)-c2;//bolt things (b)\n  float b=max(max(length(av)-0.0055,box(av)-0.004),r-c1);\n  r=max(ere(v),r);//erector t bars\n  p=2.*clamp(p,-s,s)-p;//2nd menger iter\n  s*=s;//reduce size of halls\n  if(bHide)if(abs(p.x)<s || abs(p.z)<s)f=10.;//remove more spiders\n  d=min(d,axi(p)-s);//menger hallways\n  r=max(r,-min(d+c2*2.,hol(v)-0.004));//remove holes and halls from t bars\n  b=max(b,-d-0.02);//remove unwanted bolts\n  f=max(min(f,.1-length(v)),r1);//slow the march down around the spiders (hack)\n  mcol+=(r<min(b,f)?vec3(.5):b<f?vec3(-.25)-.25*sin(sign(v)*vec3(k,k+1.,k+2.)):vec3(0.));\n  return min(r,min(b,f))*.9;//what did we hit? color it (mcol)\n}\nfloat RD; //secret sauce\nvec3 normal(vec3 p, float d){//from dr2\n  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));\n  RD=8.*abs(d/length(v));//not from dr2\n  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=0.4*dot(rd,L)+1.6;\n  return vec3(0.6,0.8,1.)*d*max(0.1,rd.y+.2)+rd*.1;\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(time)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.001*rnd,s=1.0,d,mn=0.001;\n for(int i=0;i<4;i++){\n  d=max(DE(ro+rd*t),mn);\n  s=min(s,d/t+t);\n  t+=d;\n }\n return s;\n}\nvec3 scene(vec3 ro, vec3 rd){\n  float t=DE(ro)*rnd,tt=t,d,px,s=1.;\n  vec3 L=normalize(vec3(ro.x,0.5,ro.z+.4));\n  vec3 col=vec3(0);\n  for(int j=0;j<2;j++){\n    px=s/rez.x;\n    for(int i=0;i<80;i++){\n      t+=d=DE(ro+rd*t);\n      if(t>2.0 || d<px*t)break;\n    }\n    if(d<px*t){\n      mcol=vec3(0.001);\n      vec3 so=ro+rd*t;\n      vec3 N=normal(so,d);\n      vec3 scol=mcol*0.25;\n      float dif=0.5+0.5*dot(N,L);\n      float vis=clamp(dot(N,-rd),0.05,1.0);\n      float fr=0.2*pow(1.-vis,5.0);\n      ro=so+rd*DE(so);tt+=t;\n      float shad=clamp(1.0-tt*.5,0.,1.)*ShadAO(ro,N)*(s==1.?1.:.5-t);\n      rd=reflect(rd,N);\n      col+=(abs(scol)*dif+fr*sky(rd,L))*shad*RD;\n      if(scol.x<0.)return col;\n      t=DE(ro)*(1.-rnd);\n      s=5.;\n    }\n  }\n  if(s==1.)col=sky(rd,L);\n  return col;\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);vec3 up=vec3(0,1,0),rt=normalize(cross(up,fw));\n  return mat3(rt,cross(fw,rt),fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=vec2(U-0.5*rez.xy)/rez.x;\n  randomize(U.xy);\n  float tim=time*.05;\n  vec3 ro=vec3(cos(tim),0.6+sin(tim)*0.25,sin(tim))*(0.7-time/600.);\n  tim=mod(time,60.);\n  bHide=time<60.;\n  if(tim>50.)ro=vec3(-0.5,.5-(tim-50.)*0.025,-0.5);\n  vec3 rd=lookat(ro)*normalize(vec3(uv,1.0));\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n  int m=65536*8;\n  vec2 o=vec2(0);\n  for(int i=0;i<16;i++){\n    int t=samp+i*i*9; \n    t*=(t>>14 & t>>(t%m>m-65536 && i>0?11:13) & t>>int(0.25*float(i)*sin(time)));\n    o+=vec2(t%256,(t>>1)%256)/float(1024*(i/4+2));\n  }\n  return sign(o)*fract(abs(o*time*time*0.0002))*.8;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 156, 156, 210], [211, 211, 229, 229, 283], [284, 284, 302, 302, 362], [363, 363, 381, 381, 461], [462, 462, 491, 491, 550], [553, 553, 570, 570, 2016], [2027, 2042, 2071, 2081, 2257], [2258, 2258, 2284, 2284, 2367], [2379, 2379, 2405, 2405, 2478], [2480, 2480, 2517, 2517, 2644], [2645, 2645, 2674, 2674, 3427], [3428, 3428, 3449, 3449, 3550], [3551, 3551, 3589, 3589, 3902]], "test": "untested"}
{"id": "tltfWN", "name": "Vortex_", "author": "YitingLiu", "description": "invitation to another dimension ", "tags": ["3d", "time", "torus", "texture", "camera", "shader", "trippy", "material", "ichannel", "visuals", "lookat", "normalize", "artofcode"], "likes": 2, "viewed": 339, "published": 3, "date": "1612794734", "time_retrieved": "2024-07-30T19:39:45.278801", "image_code": "//tutorial https://www.youtube.com/watch?v=rA9NmBRqfjI\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.2;\n    vec3 ro = vec3(0,0,-1.5);//camera pos // if y is -1. we are in the middle \n    //vec3 lookat = vec3(0); // look at the center \n    vec3 lookat = mix(vec3(0,0,0),vec3(-1,-3,2),sin(t*1.56)*.5+.5);\n    float zoom = mix(.1,.5,abs(cos(t)));//.1*sin(t)+.1;//1.;\n   \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0),f)),\n        u = cross(f,r),\n        c= ro+f*zoom,\n        i = c+uv.x*r+uv.y*u,\n        rd=normalize(i-ro);\n        \n        float dS, dO;\n        vec3 p;\n        \n        for (int i =0; i <100; i++){\n            p = ro+rd*dO;\n            dS = -(length(vec2(length(p.xz)-1.,p.y))-.75);\n            if(dS<.001)break;\n            dO+=dS;\n        }\n    \n    \n    \n    vec3 col = vec3(0.);\n    \n    //creating torus \n    if(dS<.001){\n        float x = atan(p.x,p.z)+t;\n        float y = atan(length(p.xz)-1.,p.y);//distance to the circle \n        float ratio = mix(2.,8.,max(0.,sin(t)));\n        float i = 2.;\n        float e = i*ratio; \n        \n        float bands = sin(y*i+x*e);\n        float ripples = sin((x*i-y*e)*3.)*.5+.5;\n        float waves = sin(x*i/2.-y*e/2.+t*.5 );\n        \n        float b1 = smoothstep(-.2,.2,bands);\n        float b2 = smoothstep(-.2,.2,bands-.5);\n        \n        float m = b1*(1.-b2);\n        \n        //need to keep the ratio of x and y below \n        m=max(m,ripples*b2*max(0.,waves));\n        m+=max(0.,waves*.5);\n       \n       float offset = 0.2;\n       col+=texture(iChannel0,vec2(m,sin(t))).rgb;\n       col-=vec3(m);\n\n       col/=vec3(m,m-offset*t/10.,m-offset/t);\n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 1780]], "test": "untested"}
{"id": "wttBWN", "name": "MC Laplace", "author": "argent1024", "description": "Lu = 0 with a line segment as the boundary condition", "tags": ["mc"], "likes": 3, "viewed": 294, "published": 3, "date": "1612791240", "time_retrieved": "2024-07-30T19:39:46.230257", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb/col.w, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct ClosePoint {\n    float d;\n    vec2 p;\n    vec3 c;\n};\n\nClosePoint sdLine(vec2 p, vec2 a, vec2 b, vec3 ca, vec3 cb) { \n    vec2 ab = normalize(a - b);\n    vec2 pb = p - b;\n    vec2 pa = p - a;\n    \n    float l = dot(pb, ab);\n    float l_ab = length(a-b);\n    ClosePoint ans;\n    if(l >= 0. && l <l_ab) { \n        ans.p = b + l * ab;\n    } else if (length(pa) < length(pb)) {\n        ans.p = a;\n    } else {\n        ans.p = b;\n    }\n    ans.d = length(p - ans.p);\n    ans.c = vec3(0.0);\n    if(ans.d < 0.1) // on boundry\n    {\n        if(length(pb) < length(pa)) {ans.c = cb;}\n        else {ans.c = ca;}\n    }\n    return ans;\n}\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(iTime+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nconst float PI = 3.1415926;\n\nvec2 sampleSphere(vec2 p, float r) {\n    float theta = 2.0 * PI * rand(p);\n    vec2 d = vec2(cos(theta), sin(theta));\n    return p + d * r;\n}\n\nvec4 wos(vec2 pos) {\n    float eplision = 0.01f;\n    ClosePoint cp;\n    int max_iter = 10;\n    for(int i = 0; i < max_iter; i++) {\n        cp = sdLine(pos, vec2(0.6,0.6), vec2(-0.6,-0.6), vec3(0.9, 0.0, 0.0), vec3(0.0, 0.0, 0.9));\n        if(cp.d < eplision) { break; }\n        pos = sampleSphere(pos, cp.d);\n    }\n    return vec4(cp.c, 1.0);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord){\n    vec2 position = 2.0 * (( gl_FragCoord.xy / iResolution.xy ) - vec2(0.5,0.5));\n    position.x *= iResolution.x / iResolution.y;\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + wos(position);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 183]], "test": "untested"}
{"id": "tltfD4", "name": "Fractal 17_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 35, "viewed": 708, "published": 3, "date": "1612789643", "time_retrieved": "2024-07-30T19:39:47.173734", "image_code": "// thanks FabriceNeyret2\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 r=iResolution,p;  \n    for(float i=0.,g=0.,e,l,s;\n        ++i<99.;\n        e<.003?O.xyz+=mix(\n                r/r,\n                cos(vec3(8,3,12)+g*(3.+sin(iTime*8.)*.2))*.5+.5,\n                .8\n            )*.9/i:p\n    )\n    {\n        p=vec3(g*(C-.5*r.xy)/r.y,g-2.5);\n        p=R(p,normalize(vec3(1,3,3)),iTime*.2);\n        p=abs(p)+.2;\n        p.y>p.x?p=p.yxz:p;\n        p.z>p.x?p=p.zyx:p;\n        p.y>p.z?p=p.xzy:p;\n        s=2.;\n        for(int j=0;j++<4;)\n            s*=l=2./min(dot(p,p),.8),\n            p=abs(p)*l-vec3(2,1,3);\n        g+=e=length(p.xz)/s;\n    }\n    O=pow(O,vec4(.8,.9,1.3,1));\n}\n\n/*\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)cos(h*6.3+vec3(0,23,21))*.5+.5\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n    vec3 r=iResolution,p;  \n    for(float i=0.,g,e,l,s;\n        ++i<99.;\n        (e<.003)?O.xyz+=mix(r/r,cos(vec3(8,3,12)+g*(3.+sin(iTime*8.)*.2))*.5+.5,.8)*.9/i:p\n    )\n    {\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.z-=2.5;\n        p=R(p,normalize(vec3(1,3,3)),iTime*.2);\n        p=abs(p)+.2;\n        p.y>p.x?p=p.yxz:p;\n        p.z>p.x?p=p.zyx:p;\n        p.y>p.z?p=p.xzy:p;\n        s=2.;\n        for(int j;j++<4;)\n            p=abs(p),\n            s*=l=2./min(dot(p,p),.8),\n            p=p*l-vec3(2,1,3);\n        g+=e=length(p.xz)/s;\n    }\n    O.xyz=pow(O.xyz,vec3(.8,.9,1.3));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 121, 121, 753]], "test": "untested"}
{"id": "3ldBWN", "name": "dot finder", "author": "Ric3cir121", "description": "given a dot on the screen this shader find its position", "tags": ["dot", "find"], "likes": 2, "viewed": 247, "published": 3, "date": "1612777719", "time_retrieved": "2024-07-30T19:39:48.196999", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = vec4(0.1);\n    vec2 d = 1.-abs((texelFetch(iChannel0,ivec2(0),0).xy-(u/iResolution.xy))*iResolution.xy/2.);\n    o += clamp(max(d.x,d.y),0.,1.)*vec4(1.000,0.251,0.000,0);\n    o += texelFetch(iChannel1,ivec2(u),0)*vec4(0.000,0.482,1.000,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 o,vec2 u){\n    o = vec4(0);\n    vec2 uv = (u+u-iResolution.xy)/iResolution.y;\n    vec2 pos = vec2(sin(iTime),cos(iTime))*0.8;\n    o = vec4(clamp((.1-length(uv-pos))*iResolution.y/2.,0.,1.));\n}", "buffer_b_inputs": [], "buffer_a_code": "void mainImage(out vec4 o,vec2 u){\n    if(ivec2(u)==ivec2(0)){\n        float c = 0.;\n        vec2 pos = vec2(0);\n        float i = 30.;\n        for(float ix = 0.;ix<i;ix++){\n            for(float iy = 0.;iy<i;iy++){\n                vec2 t = vec2(ix,iy)/i;\n                bool b = dot(texture(iChannel0,t).xyz,vec3(1))/3.>0.8;\n                if(b){\n                    pos += t;\n                    c++;\n                }\n            }\n        }\n        pos /= c;\n        if(iFrame>0)o = mix(texelFetch(iChannel1,ivec2(0),0),vec4(pos,0,0),0.5);\n        else o = vec4(0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 283]], "test": "untested"}
{"id": "3ttBWN", "name": "Trapped in the ball pit", "author": "Plento", "description": "A shader that Fabrice could make 95% shorter.", "tags": ["3d", "short"], "likes": 10, "viewed": 345, "published": 3, "date": "1612768410", "time_retrieved": "2024-07-30T19:39:49.044732", "image_code": "#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec3 l = normalize(vec3((u/iResolution.xy-.5)*vec2(1.8, 1.), 1.9)),\n    o = vec3(-iTime, iTime, -8.),\n    p;\n    \n    l.yz *= rot(-2.2/2.);\n    l.xy *= rot(3.14/4.);\n    \n    float d, t = 0., s = 0.;\n    for(int i = 0; i < 40; i++){\n        p = o+l*t;\n    \td = length(vec3(mod(p.xy, 1.8)-1.8*.5, p.z))-1.; \n        \n        if(d < .002 || t > 40.) break;\n        \n        t += d * .95;\n        s++;\n    }\n    \n    vec2 k = floor(p.xy/1.8);\n    vec3 c = .33+.34*cos(vec3(.6,.1,1.)*(k.x*52.+k.y*72.)*12.);\n\n    f = vec4(1.-exp(-c*1.5*smoothstep(4., 1., s/10.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 94, 94, 665]], "test": "untested"}
{"id": "WldBD4", "name": "Ball rows", "author": "DukeOfStraylight", "description": "Reproduction of a random gif seen on a random Discord: https://cdn.discordapp.com/attachments/553619379540066304/795702582252404767/straightdownup-1.gif ... with a bit of added randomness.", "tags": ["hex"], "likes": 5, "viewed": 266, "published": 3, "date": "1612756274", "time_retrieved": "2024-07-30T19:39:49.840604", "image_code": "const float headingchaos = 0.01;\nconst float directionchaos = 0.1;\n\nvec2 hex = vec2(sqrt(3.), 1.).yx;\n\n// HexDist and HexCoords from The Art of Code: https://www.youtube.com/watch?v=VmrIDyYiJBA\nfloat HexDist(vec2 p) {\n  p = abs(p);\n  float c = dot(p, normalize(hex));\n  return max(c, p.x);\n}\n\nstruct HexCoord {\n  vec2 gv;\n  vec2 id;\n};\n\nHexCoord HexCoords(vec2 uv) {\n  vec2 r = hex;\n  vec2 h = r*.5;\n    \n  vec2 a = mod(uv, r)-h;\n  vec2 b = mod(uv-h, r)-h;\n    \n  vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n  vec2 id = uv-gv;\n  return HexCoord(gv, id);\n}\n\nfloat hash11(in float x) {\n    return fract(sin(x)*1e4);\n}\n\nvec2 rotate90(vec2 p) {\n  return vec2(p.y, -p.x);\n}\n\nconst float pi = 3.14159;\n\nfloat circledistance(float time, HexCoord hexcoord, vec2 hexdir) {\n  float second = floor(time);\n  float ind = fract(second*0.5)*2.0;\n  float sign = round(max(0.0, hash11(second) - (1.0 - directionchaos))); // 0 or 1\n\n  float slope = cos(time * pi) * 0.5 + 0.5;\n  float up = ind*slope + (1.0-ind)*(1.0-slope);\n\n  float parity = round(fract(dot(rotate90(hexdir), hexcoord.id - 0.5) * sqrt(3.0)));\n  sign = sign == parity ? 0.0 : 1.0; // a bit of a silly way to do xor, but these both came out of round() so equality does work\n  float t = sign * up + (1.0 - sign) * (1.0 - up);\n  \n  return min(length(hexcoord.gv + t * hexdir),\n\t     length(hexcoord.gv + (t - 1.0) * hexdir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n  st *= 10.;\n\n  HexCoord hex_coord = HexCoords(st);\n  vec2 xy = hex_coord.gv;\n\n  float time = iTime * 1.5;\n  float second = floor(time );\n  float regularheading = mod(second, 3.0);\n  float randomheading = floor(hash11(second + 543.) * 3.0 + 0.5);\n  float heading = hash11(second + 47.) < headingchaos ? randomheading : regularheading;\n  \n  vec2 hexdir1 = vec2(1.0, 0.0);\n  vec2 hexdir2 = normalize(hex);\n  vec2 hexdir3 = normalize(hexdir2 - hexdir1);\n\n  vec2 hexdir = heading == 0.0 ? hexdir1 : heading == 1.0 ? hexdir2 : hexdir3;\n\n  float c = smoothstep(0.22, 0.19, circledistance(time, hex_coord, hexdir));\n  \n  fragColor =\n    vec4(c,\n\t c,\n\t c,\n     1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 194, 217, 217, 291], [337, 337, 366, 366, 556], [558, 558, 584, 584, 616], [618, 618, 641, 641, 669], [698, 698, 764, 764, 1374], [1376, 1376, 1433, 1433, 2155]], "test": "untested"}
{"id": "WldfW4", "name": "360 Flythrough", "author": "oneshade", "description": "You sort of get used to it O_O", "tags": ["raymarching", "cubemap", "unwrap", "spherical", "flythrough", "360"], "likes": 4, "viewed": 274, "published": 3, "date": "1612751630", "time_retrieved": "2024-07-30T19:39:50.723244", "image_code": "// CUBIC or SPHERICAL\n#define CUBIC\n\n#define inBounds(p, b) all(greaterThan(p, b.xy)) && all(lessThan(p, b.zw))\n#define mapCoords(p, b) (p - b.xy) / (b.zw - b.xy)\n\nfloat mapScene(in vec3 p) {\n    p = mod(p, 2.0) - 1.0;\n    return length(p) - 0.25;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvec4 unwrapCubemap(in vec2 p, int method) {\n    if (method == 0) {\n        vec2 uv = p / iResolution.xy;\n\n        vec4  front = vec4(0.00, 0.333, 0.25, 0.666);\n        vec4   left = vec4(0.25, 0.333, 0.50, 0.666);\n        vec4   back = vec4(0.50, 0.333, 0.75, 0.666);\n        vec4  right = vec4(0.75, 0.333, 1.00, 0.666);\n        vec4    top = vec4(0.50, 0.666, 0.75, 1.000);\n        vec4 bottom = vec4(0.50, 0.000, 0.75, 0.333);\n\n        vec3 rd;\n        int face = 7;\n        if (inBounds(uv,  front)) rd = vec3(mapCoords(uv,  front) * 2.0 - 1.0,  1.0).xyz * vec3(-1.0, 1.0,  1.0); face = 1;\n        if (inBounds(uv,   left)) rd = vec3(mapCoords(uv,   left) * 2.0 - 1.0, -1.0).zyx * vec3( 1.0, 1.0, -1.0); face = 2;\n        if (inBounds(uv,   back)) rd = vec3(mapCoords(uv,   back) * 2.0 - 1.0, -1.0).xyz * vec3( 1.0, 1.0,  1.0); face = 3;\n        if (inBounds(uv,  right)) rd = vec3(mapCoords(uv,  right) * 2.0 - 1.0,  1.0).zyx * vec3( 1.0, 1.0,  1.0); face = 4;\n        if (inBounds(uv,    top)) rd = vec3(mapCoords(uv,    top) * 2.0 - 1.0,  1.0).xzy * vec3( 1.0, 1.0,  1.0); face = 5;\n        if (inBounds(uv, bottom)) rd = vec3(mapCoords(uv, bottom) * 2.0 - 1.0, -1.0).xzy * vec3( 1.0, 1.0, -1.0); face = 6;\n\n        return vec4(normalize(rd), face < 7);\n    }\n\n    vec2 angle = (p / iResolution.xy * 2.0 - 1.0) * vec2(3.14, 1.57);\n\n    float cy = cos(angle.x), sy = sin(angle.x);\n    float cp = cos(angle.y), sp = sin(angle.y);\n    return vec4(cy * cp, sp, sy * cp, true);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    #ifdef CUBIC\n    vec4 unwrapped = unwrapCubemap(fragCoord, 0);\n    #endif\n\n    #ifdef SPHERICAL\n    vec4 unwrapped = unwrapCubemap(fragCoord, 1);\n    #endif\n\n    if (bool(unwrapped.w)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        vec2 screenCenter = 0.5 * iResolution.xy;\n        vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n        vec3 ro = getCameraPosition();\n        vec3 rd = unwrapped.xyz;\n\n        vec2 viewDir = (iMouse.xy - screenCenter) / iResolution.y * TWO_PI * ROTATION_SPEED;\n        float cy = cos(viewDir.x), sy = sin(viewDir.x);\n        float cp = cos(viewDir.y), sp = sin(viewDir.y);\n\n        rd.yz *= mat2(cp, -sp, sp, cp);\n        rd.xz *= mat2(cy, -sy, sy, cy);\n\n        float t = 0.0;\n        for (int i=0; i < MAX_ITERATIONS; i++) {\n            vec3 p = ro + rd * t;\n            float d = mapScene(p);\n            if (d < MIN_HIT_DISTANCE) {\n                vec3 n = getNormal(p);\n                vec3 l = vec3(-0.58, 0.58, 0.58);\n                fragColor.rgb += max(0.0, dot(n, l));\n                break;\n            }\n\n            if (t > MAX_TRACE_DISTANCE) {\n                break;\n            }\n\n            t += d;\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Raymarching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 100.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_ITERATIONS = 50;\n\n// Math constants:\nconst float TWO_PI = 6.2832;\n\n// Amount by which the camera moves and rotates:\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 0.5;\n\n// Addresses to viewing data:\nconst ivec2 CAM_POS_ADDR = ivec2(0, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n#define getCameraPosition() texelFetch(iChannel0, CAM_POS_ADDR, 0).xyz\n\n#define     keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define   keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define  keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define   keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis   (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis      (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame > 0) {\n        ivec2 addr = ivec2(fragCoord);\n        if (addr == CAM_POS_ADDR) {\n            fragColor = vec4(getCameraPosition(), 1.0);\n\n            vec2 viewDir = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            mat3 cam = getCamera(viewDir);\n\n            if (keyUpPressed()) {\n                fragColor.xyz += cam[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= cam[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += cam[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= cam[0] * STEP_SIZE;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 191, 191, 249], [251, 251, 278, 278, 561], [563, 563, 606, 606, 2044], [2046, 2046, 2101, 2101, 3334]], "test": "untested"}
{"id": "3ldfW4", "name": "sonrisa- 3d y 2d", "author": "jorge2017a1", "description": "sonrisa- 3d y 2d", "tags": ["sonrisa3dy2d"], "likes": 4, "viewed": 240, "published": 3, "date": "1612751175", "time_retrieved": "2024-07-30T19:39:51.702625", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   /* float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n   */\n   \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    p.y=p.y-5.0;\n    p= rotate_y(p, iTime);\n    float sb1= sdBox(  p-vec3(0.0,3.0,0.0), vec3(6.0) );\n    res =opU3(res, vec3(sb1,-1.0,6.0)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 brdf(vec3 N, vec3 L, vec3 V, vec3 diff, vec3 spec, float exponent) \n{\n    vec3 R = reflect(L,N);\n    vec3 H = normalize(L+V);\n    return diff * clamp(dot(N, L), 0., 1.)\n         + spec * pow(max(0., dot(R,V)), exponent);\n}\n\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n \n    \n    vec3 V = normalize(p-ro);\n    vec3 tmp= brdf(n, l, V, vec3(dif) , vec3(spe), 32.0) ;\n    lin+=tmp;\n    \n\n    return lin*atten;\n}\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t //result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n     result = lightingv3( nor, p, plight_pos,  rd,ro)*colobj*5.0;\n     ///result = lightingv3( nor, p, plight_pos,  rd,ro)*5.0;\n     \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nvec2 simplesmile(vec2 p)\n{\n    vec2 res;\n    \n    \n    float sCuadro= sdBox( p,vec2(2.0));\n    \n    \n    float scabeza= sdCircle( p, 0.8 );\n    p.x=abs(p.x);\n    float ojo= sdCircle( p-vec2(0.3,0.2), 0.2 );\n    float sonrisaA= sdCircle( p-vec2(0.0,0.1), 0.4 );\n    float sonrisaB= sdCircle( p-vec2(0.0,-0.1), 0.35 );\n    \n    float sonrisa=opS( sonrisaA, sonrisaB );\n    \n    \n    sCuadro=opS(scabeza, sCuadro);\n    \n    \n    scabeza=opS( ojo, scabeza );\n    scabeza=opS( sonrisa,scabeza);\n    \n    res=opU2(res, vec2(sCuadro/fwidth(sCuadro) ,4.0) );\n    \n    res=opU2(res, vec2(scabeza/fwidth(scabeza) ,1.0) );\n    res=opU2(res, vec2(ojo/fwidth(ojo) ,0.0) );\n    res=opU2(res, vec2(sonrisa/fwidth(sonrisa) ,2.0) );\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t\t//return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n\t\t//return vec3(0.8 + 0.4*d, 0.3 + 0.55*d, 0.15 - 0.1*d);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n        \n        float escala=0.25;\n        p.x=p.x+1.0;\n        p.y=p.y-8.0;\n        p= rotate_y(p, iTime);\n        vec2 d= simplesmile(p.xy*escala);\n        vec3 coltmp=getColor(int( d.y));\n        vec3  col2= vec3(0.8 + 0.4*d.x, 0.3 + 0.55*d.x, 0.15 - 0.1*d.x);\n        return coltmp;\n        \n                \n    }\n    \n    \n    \n    if (id_material==7.0)\n    {\n            \n        vec3 q=p;\n        float cx=15.0;\n        float cy=11.0;\n        float cz=14.00;\n        //q.y = mod(q.y+0.5*cy,cy)-0.5*cy;\n        q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n        q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n        p=q;\n    \n            \n        float escala=0.125;\n        p.y=p.y-10.0;\n        //p=mod(vec3(p.x, p.z ,0.0) , vec3(2.));\n        p= rotate_y(p, iTime);\n        vec2 d= simplesmile(p.xz*escala);\n        vec3 coltmp=getColor(int( d.y));\n        vec3  col2= vec3(0.8 + 0.4*d.x, 0.3 + 0.55*d.x, 0.15 - 0.1*d.x);\n        return coltmp;\n        \n                \n    }\n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n  \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n    vec3 ro=vec3(5.*cos(t),7.0,-30.0+5.0*sin(t));\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    \n    //referencia de un shader Colorful star\n    vec2 uv0 = vec2(sin(400.0*time),sin(405.5*time));\n    float phi = atan(uv0.y, uv0.x) + time*0.1;\n    float d0 = length(uv0);\n    float d = -0.3 + d0 * 0.43*sin(1.5*phi);\n    float d2 = -0.3 + d0 * 0.43*sin(5.*phi);\n     \n    return vec2(d+d2);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 435, 435, 456], [457, 457, 489, 489, 573], [575, 619, 666, 666, 693], [695, 695, 738, 738, 765], [767, 767, 815, 815, 843], [891, 916, 950, 950, 1048], [1049, 1049, 1083, 1083, 1175], [1176, 1176, 1210, 1210, 1302], [1303, 1343, 1377, 1377, 1474], [1476, 1516, 1541, 1541, 2258], [2262, 2262, 2336, 2336, 2489], [2493, 2493, 2558, 2558, 3258], [3261, 3312, 3336, 3336, 3524], [3525, 3588, 3621, 3621, 4082], [4084, 4138, 4174, 4174, 4408], [4511, 4511, 4591, 4591, 5004], [5093, 5093, 5126, 5126, 5148], [5149, 5149, 5182, 5182, 5204], [5205, 5205, 5238, 5238, 5259], [5261, 5261, 5298, 5298, 5378], [5381, 5381, 5416, 5416, 5444], [5446, 5446, 5472, 5472, 6184], [6186, 6237, 6284, 6284, 8232], [8286, 8286, 8379, 8379, 8657], [8662, 8711, 8768, 8768, 9975]], "test": "untested"}
{"id": "WtdBW4", "name": "Hiragana Font", "author": "xavierseb", "description": "Hiragana font with morphing of characters\ndid this some time ago, messy coding, will have to come back to clean it up a bit, or there might be faster algorithms out there ?", "tags": ["bezier", "font", "morph", "hiragana"], "likes": 14, "viewed": 387, "published": 3, "date": "1612747229", "time_retrieved": "2024-07-30T19:39:52.467580", "image_code": "// hiragana glyphs , Xavierseb 2019  \n#define V0 vec4(0)\n#define Gen(u,v) mat4( V0,V0,   u,v, 1.,0., 0.,1., 0.,0.)\n#define Gen1(u,v,w,x) mat4( V0,V0,   u,v, w,x, 0.,1., 0.,0.)\n\n#define Wa Glyph( mat4( -.47,.14,-2.67,-.16,-.87,4.44,-1.09,.5, -.92,1.05,1.25,.38,-.52,.87,.39,-.76), Gen(.17,.87) )\n#define Ra Glyph( mat4( -.6,-.26,-.48,0.,-.46,1.76,1.07,.69, -.57,.75,1.15,-.05,-.5,.29,-.66,-1.),Gen( .17,.76) )\n#define Ya Glyph( mat4( 0.,-1.78,.88,.14,-.81,2.37,.83,1.,  -.96,1.39,1.2,.534,-.05,1.2,-.08,-.05),Gen( .28,.65) )\n#define Ma Glyph( mat4( .67,-1.8,-1.415,.545, .487,.415,-.5,.1, .1,.56,-1.55,.53,.68,-2.23,.47,-.78 ),Gen( .23,.82) )\n#define Ha Glyph( mat4( -.65,-.83,-.68,-.5,.78,-1.72,-.5,-.41,  .78,-1.65,.96,.48,.5,-.52,3.,-.53),mat4( .48,-.1,-.83,.86,-.53,-1.25,.16,-.7,  1.,0., .15,.8, V0) )\n#define Na Glyph( mat4( .1,-2.74,.96,-.63,.62,-.2,2.86,-.15, .63,1.38,.21,.2,.49,-.42,1.08,-.39),mat4( .2,.29,-1.42,.62,-.39,-1.66,.19,-.83, .2,0.7,.5,0.79, V0) )\n#define Ta Glyph( mat4( -.89,1.7,-3.4,.43,-.82,4.,-.69,.53, 0.2,4.05,.47,.17,-.12,.39,-1.32,-.58),Gen1( .23,0.8,.05,0.8) )\n#define Sa Glyph( mat4( .55,-2.,-1.93,.59,.6,-.86,4.14,-.17, .4,.23,-.54,-.41,-.84,-.81,-.75,-.42),Gen( .15,.9) )\n#define Ka Glyph( mat4( -.8,-.03,-.31,.93,-.75,1.37,1.43,-.25, -.9,1.,-.41,-.35,.1,1.,-1.17,-.73),Gen(.5,0.85) )\n#define Aa Glyph( mat4( -.675,2.8,-.806,-.15, .43,.55,3.64,-.844, .24,-.87,-2.08,1.61,.19,-2.29,.654,0.),mat4( -.625,.97,1.,.19,-.204,.63,-.72,-.86, .12,.8,.85,1., 0.,.2, 0.,0.) )\t\n\n#define Ri Glyph( mat4( -.32,.59,1.3,.23,.01,2.,-.13,-.96, -.32,-.32,-.48,-.32, 1.,.33,.59,.01),Gen(.05,.35) )\n#define Mi Glyph( mat4( -.38,1.18,.76,.07,.68,1.44,-.35,-.78, .15,-1.11,-1.8,.78,.84,-2.23,.78,-.52),Gen( .13,.65) )\n#define Hi Glyph( mat4( -.77,2.,-.6,.84,.54,1.78,1.71,-.11, -.28,-1.69,.62,.37,.73,-1.29,-1.41,.7),Gen( .06,.83) )\n#define Ni Glyph( mat4( .24,2.45,-1.05,.75,.53,1.05,-.88,-.54,  -.63,-.82,-.7,-.62,.66,-.13,-1.24,-.58),Gen(.06,.73) )\n#define Chi Glyph( mat4( .25,-3.9,1.23,-.47,.53,-.48,4.,-.48,  0.,1.3,.68,-.47,-1.,-.72,.5,-.48),Gen( .1,.83) )\n#define Shi Glyph( mat4( .59,-.43,-.48,-.38,-.74,-1.1,-.87,.83, V0,V0),Gen1(1.,0., 0.,1.) )\n#define Ki Glyph( mat4( -.26,1.48,2.46,-.56,-.02,.27,1.31,.33, .45,.06,-1.52,.3,-.42,.04,-.95,-.91),mat4( -.32,-.17,.04,.47,.92,1.05,.29,-.36, .2,0.85, 1.,0., V0) )\n#define Ii Glyph( mat4( -.37,-.13,.63,.83,-.66,.11,1.25,-.33,  -.88,-.87,-.68,-.37,.42,.16,-.48,-.66),Gen( .1,.69) )\n\n#define Ooo Glyph( mat4( -.63,3.72,-2.66,.4,.52,1.11,-.87,-.87,  0.,-1.32,.08,0.,.92,-1.27,1.08,-.53),Gen(.11,.44) )\n#define Ru Glyph( mat4( -.43,.47,.69,-.59,.65,.75,1.15,-.39,  -.63,1.14,.78,.23,-.48,.55,-.83,-.82),mat4( .2,-.71,.06,.23,-.84,-.93,-.34,-.82,  1.,0.,  1.,0.,  V0) )\n#define Yu Glyph( mat4( -.21,.98,-.79,-.79,-.94,.49,3.,-.45,  -.17,1.4,.84,-.79,-.114,-1.33,2.26,-.45),Gen(.41,.869) )\n#define Mu Glyph( mat4( -.44,-.55,-1.22,-.44,-.6,-1.6,-.45,-.6,  -.44,1.749,-.32,.84,-.6,-2.32,2.,.45),mat4( .04,-2.1,.17,-.44,.56,-.46,3.,-.64, 1.,0.,  .5,.85, .2,.7,0.,0.) )\n#define Fu Glyph( mat4( -.95,-.39,-1.5,.86,-.37,-2.13,2.48,-.5,  -.4,.01,.32,-.21,-.61,-1.03,-.39,.07),mat4( -.87,-.34,.34,-.03,1.75,.91,.5,.55, .3,.97,  1.,0., .0,.5,0.,0.) )\n#define Nu Glyph( mat4( -.74,1.18,-1.74,-.27,-.7,1.1,3.,-.61,-.74,-1.66,1.73,.61,-.7,.24,1.08,-.42),mat4( .61,-.05,-.17,.88,-.42,-1.04,.44,-.74, .38,.81, 1.,0., V0) )\n#define Tsu Glyph( mat4( -.9,.85,1.56,.145,.014,1.015,-.28,-.71, V0,V0),Gen1(1.,0., 0.,1.) )\n#define Su Glyph( mat4( .72,-5.1,1.1,.02,.57,-.66,4.5,-.39,  .015,-1.41,.9,-.5,-.39,.2,.61,-1.03),Gen(.1,.85) )\n#define Ku Glyph( mat4( .13,-.5,-.69,.14,.86,-.54,.69,-.9, V0,V0),Gen1( 1.,0., 0.,1.) )\n#define Uu Glyph( mat4(  -.12,.53,1.02,.16,1.04,.4,1.35,-.65,  -.54,-.59,1.02,-.04,.2,-.11,1.35,-1.),Gen( .15,1.) )\n\n#define Re Glyph( mat4( -.89,.67,.35,.37,-.66,.79,.9,-.57,  -.93,1.48,-.45,.92,.165,1.59,-1.54,-.42),mat4( -.49,-.29,-.64,-.45,.94,1.04,-1.49,-.67, 1.,0., .12,.6,  V0) )\n#define Me Glyph( mat4( -.23,-1.73,1.6,-.72,-.57,2.78,.78,-.62,  .35,2.14,-1.16,-.71,-.8,.47,.71,-.62),Gen( .16,.63) )\n#define He Glyph( mat4( -.95,-.01,-.93,.9,.02,.38,.69,-.42,  V0,V0),Gen1( 1.,0., 0.,1.) )\n#define Ne Glyph( mat4( -.87,.87,-.65,-.59,.24,.8,4.,-.89,  -.93,.5,.78,.59,-.63,1.1,.38,-.54), mat4( .59,-.05,-.23,.87,-.54,-1.17,.24,-.8, .11,.8,  1.,0.,  V0) )\n#define Te Glyph( mat4( -.78,2.32,-1.39,.45,.32,1.48,.14,-.84, V0,V0),Gen1( 1.,0., 0.,1.) )\n#define Se Glyph( mat4( -.44,-.14,-.95,.53,.57,-.1,-.97,-.8,  -.96,-.96,.11,.87,-.11,-.33,.23,.19),mat4( .29,.39,.26,.11,.78,.7,-.72,-.39,   1.,0., 1.,0., V0) )\n#define Ke Glyph( mat4( -.6,-1.3,1.02,.36,.8,-1.9,-1.8,1.,  -.63,-.51,-.58,.83,-.71,.26,.2,.41),Gen1(.27,.69, .1,.7) )\n#define Ee Glyph( mat4( -.66,.06,-.42,.62,-.72,-.16,-.87,-.81,  -.69,.2,.93,-.24,-.67,.55,.39,.91),mat4( -.64,-.63,.46,.26,.17,-.06,.54,.32, 1.,0.,  .4,.9, V0) )\n\n#define Nn Glyph( mat4( .03,.32,-1.8,-.27,.9,.86,-2.2,-.1, -.27,0.,-.11,.87,-.1,.03,-1.9,-.1),Gen( 1.,0.) )\n#define Ro Glyph( mat4( -.47,.79,.33,-.66,.72,.88,1.13,-.33,  -.66,.96,1.18,-.05,-.33,.63,-.69,-.8),Gen(1.,0.) )\n#define Yo Glyph( mat4( 0.,.31,-2.12,.5,.38,-2.3,.66,-.84,  0.,.12,-.3,.47,.89,.23,.29,.47),Gen(1.,0.) )\n#define Mo Glyph( mat4( -.6,-.46,3.1,-.55,0.,-.69,1.17,.42,  -.21,-.55,.88,.47,-.17,-1.3,-1.15,-.23),mat4( -.18,0.,-.17,-.21,1.,1.08,.3,-.17, .3,.93,  1.,0.,  V0) )\n#define Ho Glyph( mat4( .4,1.04,-1.35,.91,.62,-2.3,.47,-.8,  0.,2.88,.23,-.1,.71,1.45,-.21,.17),mat4( -.7,-.84,-.74,-.63,.77,-.21,-1.24,-.58, 1.,0.,  .1,.6,  V0) )\n#define No Glyph( mat4( -.6,-1.8,2.6,.21,-.6,1.35,.83,-.69,  -.6,-.35,.06,.11,-.6,-.35,.28,.7),Gen(1.,0.) )\n#define To Glyph( mat4( .43,1.12,-2.2,.62,.63,.74,-1.,-.69, -.54,-.37,-.32,-.13,.88,.95,.4,.1),Gen(1.,0.) )\n#define So Glyph( mat4( -.67,2.1,-1.1,.44,.05,1.,.1,-.71, -.5,.7,.3,-.67,1.,1.3,1.3,.05),Gen(1.,0.) )\n#define Ko Glyph( mat4( -.51,3.62,0.,-.65,.72,.728,-1.56,-.1,  V0,V0),Gen1(0.07,0.74,0.,1.) )\n#define Oo Glyph( mat4( -.83,-.73,.64,.81,.32,0.,1.17,.4,  -.45,-.3,-.34,-.78,.87,.08,-1.4,-.68),mat4( -.78,-.24,1.68,.26,-.68,.43,-.25,-.88, .5,.79,  1.,0.,  V0) )\n\n#define LV Glyph( mat4( 0.,-.45,-2.,0., .58,1.4,1.,-1., 0.,2.,.45,0., -1.,1.,1.4,.58), Gen(1.,0.) )\n#define _1 Glyph( mat4( vec4(-1.4,-1.4,1.4,1.4), vec4(-1.), V0, vec4(-1.)), Gen(1.,0.) )\n#define _2 Glyph( mat4( vec4(-1.), vec4(-1.4,-1.4,1.4,1.4),  vec4(1.),vec4(-1.4,-1.4,1.4,1.4) ), Gen(1.,0.) )\n#define UP Glyph( mat4( V0, vec4(10), V0, vec4(10)), mat4(V0,vec4(10), 0.,1.,0.,1.,0.,1., 0.,0.) )\n#define TEDDX Glyph( mat4( -.96,.68,-.95,.86, 0.,.15,.3,.55,  1.,.9,.6,.38, -.95,1.7,1.2,.34), mat4( -.96,-.6,.03,.05, 0.,-1.18,.26,-1., .88,1.,1.,0.,V0) )\n#define TEDDY Glyph( mat4( 0.,-1.4,-1.4,.32,-1.,-.78,2.4,.22, 0.,1.4,1.4,-.32,-1.,-.78,2.4,.22), mat4( -.234,1.,-1.,.234, -.346,.21,.21,-.346, .932,.99,.932,.99,V0) )\n#define TEDDZ Glyph( TEDDY.a, TEDDY.b+mat4( V0, vec4(0.,-.11,-.11,0.), V0,V0 ) )\n\n#define BOUNDINGBOX_W .1\n#define BOUNDINGBOX_H .14\n#define CHAR_W .07\n#define CHAR_H .07\n#define TEST(X0,X1,X2,X3) t<X0||t>X1?distance(getPos(nn,X2*CHAR_W,X3*CHAR_H),pos):1.\n#define TEST1(X0,X1,X2,X3) 1.-t<X0||1.-t>X1?distance(getPos(nn.wzyx,X2*CHAR_W,X3*CHAR_H),pos):1.\n#define IS_INSIDE pos.x<BOUNDINGBOX_W && pos.x>-BOUNDINGBOX_W && pos.y<BOUNDINGBOX_H && pos.y>-BOUNDINGBOX_H\n#define a2z(u0,u1,u2,u3,v0,v1,v2,v3)  if(IS_INSIDE) for(float t=0.0;t<.5;t+=.005) { vec4 nn=getN(t); c = min(c,min(min(min(TEST(v2.x,v2.y,u0,u1),TEST(v2.z,v2.w,u2,u3)),TEST(v3.x,v3.y,v0,v1)),min(min(TEST1(v2.x,v2.y,u0,u1),TEST1(v2.z,v2.w,u2,u3)),TEST1(v3.x,v3.y,v0,v1)))); if(c<.002) break; }\n\n#define  gmx( u, v, t)  gmix(u,v,clamp(t1-t,0.,1.))\n#define  qmx( u, v, t)  mix(u,v,clamp(t1-t,0.,1.))\n#define  mx2( u, v, t)  mmix(u,v,clamp(t,0.,1.))\n#define  A2Z(X) pos+=pstep; a2z(X.a[0], gl.a[1], gl.a[2], gl.a[3], gl.b[0], gl.b[1], gl.b[2], gl.b[3]) \n#define  _LV(X) if(X.a[0]==LV.a[0]) gl.a*=heartbeat;  A2Z(gl)  \n#define S(v) smoothstep(0., 2.5/ iResolution.y, v)\n\t\nstruct Glyph { mat4 a, b; };\n\nmat4 mmix(mat4 u,mat4 v, float t) { return v*t+u*(1.-t); }    \n\nGlyph gmix(in Glyph u,in Glyph v, float t) { return Glyph( mx2(u.a,v.a,t), mx2(u.b,v.b,t) ); }\n\t\nvec4 getN(in float t) {\tfloat t1=1.-t; return vec4(t1*t1*t1, 3.*t1*t1*t, 3.*t1*t*t, t*t*t); }\n\nvec2 getPos(in vec4 n, in vec4 x, in vec4 y) { return vec2(dot(x,n), dot(y,n)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy/iResolution.y;\t\n\tvec2 pstep=vec2(.4,0.); pos += -vec2(1.3,.85);\n\tfloat c=1., t1=mod(iTime*2.,7.), heartbeat=2.-max(1.2,.5+sin(t1*4.)); \n\tconst Glyph g0=Sa, g5=Ko,  \n                g1=Yo, g6=Nn,\n                g2=Uu, g7=Ni,\n                g3=Na, g8=Chi,\n                g4=Ra, g9=Ha;\n\tGlyph gl;\t\n\tpos += pstep;//A2Z((gl=gmx(TEDDZ,gmx(TEDDX,gmx(TEDDZ,TEDDY,13.+sin(7.*t1)),8.),2.)))\n\tA2Z((gl= gmx(g0,gmx(g5,g0,3.0),.0) ))\tpstep=vec2(0.,.17);\n\tA2Z((gl= gmx(g1,gmx(g6,g1,3.4),.0) ))\n\tA2Z((gl= gmx(g2,gmx(g7,g2,3.8),.0) ))\n\tA2Z((gl= gmx(g3,gmx(g8,g3,4.2),.0) ))\n\t_LV((gl= gmx(g4,gmx(g9,g4,4.6),.0) ))\n\n\t//fragColor = c>.015? vec4(1):vec4( 1.-sin(sin(c*800.))  );\n    fragColor = vec4(( S(c) * S( abs(c-.01)*1.5 ) ) );     // FabriceNeyret2 method, thanks !\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7971, 7971, 8006, 8006, 8029], [8035, 8035, 8079, 8079, 8129], [8132, 8132, 8155, 8155, 8225], [8227, 8227, 8273, 8273, 8308]], "test": "untested"}
{"id": "tttfWH", "name": "Star/Laser Scintillation Sim", "author": "Zi7ar21", "description": "Somewhat accurate simulation of the light of a star/laser travelling through an atmosphere. Inspired by https://youtu.be/Xm3wOOuMfrw", "tags": ["star", "laser", "atmosphere", "scintillation"], "likes": 6, "viewed": 427, "published": 3, "date": "1612746003", "time_retrieved": "2024-07-30T19:39:53.609527", "image_code": "// ##### Star/Laser Scintillation Sim #####\n// Made by Zi7ar21 on February 7th, 2021\n// Updated February 7th, 2021 18:00 Mountain Time\n\n// If you found this anywhere other than Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/tl3BR4\n\n/* This Shader contains a simulation of the light from a star/laser (or any other small point light)\npropagating through a medium of non-homogeneous refraction. It should be somewhat accurate, the only\nthing that could be improved is the simulated medium. Currently, it uses 3D fbm noise and shifts the\nray direction based on the value of the noise at any given point. If you have a better model you can\nreplace the fbm function in Buffer A.*/\n\n// Common contains Settings and Other Functions.\n// Buffer A contains the Ray-Marched Simulation.\n// Buffer B contains Image Export.\n\n// Inspired by \"Scintillation Modelling for Martian Laser Communication\":\n// https://youtu.be/Xm3wOOuMfrw\n\n// Display the Rendered Image on the Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Settings and Other Functions #####\n\n// Tile-Rendering n*n Tiles\n// This prevents WebGL Time-Out.\n#define tiles 2U\n\n// ### Camera Parameters ###\n#define camfov 0.2\n#define campos vec3(0.0, 0.0, -16.0)\n\n// ### Ray-Marching Parameters ###\n#define maxmarches 8192U\n#define stepsize 0.2\n\n// ### Simulation Parameters ###\n// FBM Noise Octaves\n#define octaves 8U\n// Maximum Distance from the Z plane\n#define scenesize campos.z+0.1\n// Maximum Distance from a straight path to the source\n#define transmissionlanesize 2.0\n\n// #### Constants and Other Functions ####\n// Pi (Octuple-Precision Floating-Point Future-Proof)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// Hash: https://www.shadertoy.com/view/4djSRW\n/*vec3 hash(vec3 pos){\n\tpos =  fract(pos*vec3(0.1031, 0.1030, 0.0973));\n    pos += dot(pos, pos.yxz+33.33);\n    return fract((pos.xxy+pos.yxx)*pos.zyx);\n}\n\n// Gradient Noise: https://iquilezles.org/articles/gradientnoise\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 ga = hash(p+vec3(0.0,0.0,0.0));\n    vec3 gb = hash(p+vec3(1.0,0.0,0.0));\n    vec3 gc = hash(p+vec3(0.0,1.0,0.0));\n    vec3 gd = hash(p+vec3(1.0,1.0,0.0));\n    vec3 ge = hash(p+vec3(0.0,0.0,1.0));\n    vec3 gf = hash(p+vec3(1.0,0.0,1.0));\n    vec3 gg = hash(p+vec3(0.0,1.0,1.0));\n    vec3 gh = hash(p+vec3(1.0,1.0,1.0));\n    float va = dot(ga, w-vec3(0.0,0.0,0.0));\n    float vb = dot(gb, w-vec3(1.0,0.0,0.0));\n    float vc = dot(gc, w-vec3(0.0,1.0,0.0));\n    float vd = dot(gd, w-vec3(1.0,1.0,0.0));\n    float ve = dot(ge, w-vec3(0.0,0.0,1.0));\n    float vf = dot(gf, w-vec3(1.0,0.0,1.0));\n    float vg = dot(gg, w-vec3(0.0,1.0,1.0));\n    float vh = dot(gh, w-vec3(1.0,1.0,1.0));\n    return va+\n    u.x*(vb-va)+\n    u.y*(vc-va)+\n    u.z*(ve-va)+\n    u.x*u.y*(va-vb-vc+vd)+\n    u.y*u.z*(va-vc-ve+vg)+\n    u.z*u.x*(va-vb-ve+vf)+\n    u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}*/\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u)) ^ state)*277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884: https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// ##### Ray-Marched Simulation #####\n\n// 3D FBM Noise: https://www.shadertoy.com/view/3dSBRh\nvec3 fbm3(vec3 x){\n\tvec3 v = vec3(0.0);\n\tfloat a = 0.5;\n\tfor(uint i = 0U; i < octaves; i++){\n\t\tv += a*texture(iChannel1, x+0.5).rgb;\n\t\tx *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn 2.0*(v-(0.5-1.0/pow(2.0, float(octaves+1U))));\n}\n\n// Star/Laser \"Signal\" Function\nfloat signal(vec2 coord){\n    return max(0.0, 1.0-length(coord));\n}\n\n// Ray-Marching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    // Start our ray (moved slightly forward for dithering)\n    vec3 raypos = rayori+(raydir*rand()*stepsize);\n\n    for(uint i = 0U; i < maxmarches; i++){\n        // Check if we reached our Source\n        if(raypos.z > 0.0){return vec3(signal(raypos.xy));}\n\n        // Check if the Ray is Outside an Acceptable Position\n        if(abs(raypos.z) < scenesize || length(raypos.xy) > transmissionlanesize){break;}\n\n        // \"Distort\" the Ray\n        raydir = normalize(raydir+(fbm3(raypos*2.0)*0.025));\n\n        // March the Ray\n        raypos += raydir*stepsize;\n    }\n\n    // If the ray reached an unacceptable position or never hit anything, output 0.0\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n\n    // Tile-Rendering Function\n    uint index = uint(fragCoord.x/iResolution.x*float(tiles))\n               + uint(fragCoord.y/iResolution.y*float(tiles))*tiles;\n    if(uint(iFrame)-(tiles*tiles*(uint(iFrame)/(tiles*tiles))) != index){return;}\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates Centered on [0.0, 0.0]\n    vec2 uv = 2.0*((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.x);\n\n    // Camera-World Coordinates (+Z Forward)\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Ray-March the Image and Output the Results\n    fragColor += vec4(raymarch(raydir, campos), 1.0);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### Image Export #####\n\n/* Look at the bottom of the editor, there is a little Image icon. If\nyou click it, then Shadertoy will save a 32-Bit-Per-Channel Floating Point\nOpenEXR Image. It is more optimal for Image editing than right-clicking\nthe canvas and pressing copy/save image (as).*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    // No Gamma-Correction this time... In GIMP, it is automatically done.\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[975, 1019, 1073, 1073, 1129]], "test": "untested"}
{"id": "wl3fDN", "name": "Radioactive Spacerock", "author": "oneshade", "description": "Lots of things going on all at once. Really needs some sound.", "tags": ["space", "glow", "stars", "motion", "rock"], "likes": 10, "viewed": 258, "published": 3, "date": "1612743110", "time_retrieved": "2024-07-30T19:39:54.439308", "image_code": "// New hash based on hash13() from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\n// 4 in, 1 out\nfloat Hash41(in vec4 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zwyx + 31.32);\n    return fract((p.x + p.y) * p.z - p.x * p.w);\n}\n\n// Hashes from \"Hash without Sine\"\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat SmoothNoise4D(in vec4 p) {\n    vec4 cell = floor(p);\n    vec4 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldbq = Hash41(cell);\n    float rdbq = Hash41(cell + vec4(1.0, 0.0, 0.0, 0.0));\n    float ldfq = Hash41(cell + vec4(0.0, 0.0, 1.0, 0.0));\n    float rdfq = Hash41(cell + vec4(1.0, 0.0, 1.0, 0.0));\n    float lubq = Hash41(cell + vec4(0.0, 1.0, 0.0, 0.0));\n    float rubq = Hash41(cell + vec4(1.0, 1.0, 0.0, 0.0));\n    float lufq = Hash41(cell + vec4(0.0, 1.0, 1.0, 0.0));\n    float rufq = Hash41(cell + vec4(1.0, 1.0, 1.0, 0.0));\n    float ldbw = Hash41(cell + vec4(0.0, 0.0, 0.0, 1.0));\n    float rdbw = Hash41(cell + vec4(1.0, 0.0, 0.0, 1.0));\n    float ldfw = Hash41(cell + vec4(0.0, 0.0, 1.0, 1.0));\n    float rdfw = Hash41(cell + vec4(1.0, 0.0, 1.0, 1.0));\n    float lubw = Hash41(cell + vec4(0.0, 1.0, 0.0, 1.0));\n    float rubw = Hash41(cell + vec4(1.0, 1.0, 0.0, 1.0));\n    float lufw = Hash41(cell + vec4(0.0, 1.0, 1.0, 1.0));\n    float rufw = Hash41(cell + 1.0);\n\n    return mix(mix(mix(mix(ldbq, rdbq, local.x),\n                       mix(lubq, rubq, local.x),\n                       local.y),\n\n                   mix(mix(ldfq, rdfq, local.x),\n                       mix(lufq, rufq, local.x),\n                       local.y),\n\n                   local.z),\n\n               mix(mix(mix(ldbw, rdbw, local.x),\n                       mix(lubw, rubw, local.x),\n                       local.y),\n\n                   mix(mix(ldfw, rdfw, local.x),\n                       mix(lufw, rufw, local.x),\n                       local.y),\n\n                   local.z),\n\n               local.w);\n}\n\nfloat FractalNoise4D(in vec4 p, in float scale, in float octaves) {\n    p *= scale;\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise4D(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return length(p) - 1.5 - FractalNoise4D(vec4(p, iTime), 1.0, 5.0) * 0.4;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    float unit = 2.0 / iResolution.y;\n\n    vec2  mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    bool hit = false;\n    float iter = 0.0;\n\n    vec3 p;\n    for (float iters=0.0; iters < 30.0; iters++) {\n        p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n\n        if (t > 15.0) {\n            break;\n        }\n\n        t += d;\n        iter++;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        vec3 l = vec3(-0.58, 0.58, 0.58);\n        fragColor.rgb += max(0.0, dot(n, l));\n    }\n\n    else {\n        vec2 skyUv = rd.xy - iTime * sign(rd.xy);\n        if (all(greaterThan(vec2(abs(rd.y)), abs(rd.xz)))) skyUv = rd.xz - vec2(0.0, iTime);\n        if (all(greaterThan(vec2(abs(rd.x)), abs(rd.yz)))) skyUv = rd.yz - vec2(0.0, iTime);\n\n        skyUv *= 10.0;\n        vec2 cell = floor(skyUv);\n        vec2 local = fract(skyUv);\n\n        vec2 position = Hash22(cell);\n        float size = 0.05 * Hash21(cell);\n        float brightness = Hash21(cell + 347.583);\n\n        fragColor.rgb += smoothstep(unit, 0.0, length(local - position) - size) * brightness;\n        fragColor.rgb += (0.25 + 0.25 * sin(atan(uv.y, uv.x) * 6.0)) / (1.0 + length(uv) * 4.0);\n    }\n\n    fragColor.gb += iter / 30.0;\n    fragColor.rgb *= mod(dot(floor(fragCoord), vec2(1.0)), 2.0); // Checkerboard dither\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 126, 151, 151, 259], [261, 296, 321, 321, 432], [434, 434, 458, 458, 593], [595, 595, 627, 627, 2219], [2221, 2221, 2288, 2288, 2580], [2582, 2582, 2609, 2609, 2688], [2690, 2690, 2717, 2717, 2964], [2966, 2966, 3021, 3021, 4885]], "test": "untested"}
{"id": "wl3fWN", "name": "hatching from circles", "author": "ManuManu", "description": "A try with hatching from cicles rather than lines...\nNot sure it's better :)", "tags": ["hatchingcirclesvideopostprocess"], "likes": 1, "viewed": 309, "published": 3, "date": "1612738615", "time_retrieved": "2024-07-30T19:39:55.296018", "image_code": "vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n\n//#define TEST\n\n\nfloat CircleFunc(vec2 uv, vec2 center, float radius, float width )\n{\n    float col = 0.;\n    \n    float distFromCenter = length(uv - center );\n    distFromCenter = mod( distFromCenter, radius * 2.);    \n    col = smoothstep( .0, width, abs(distFromCenter- radius));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifdef TEST\n    vec3 col = vec3(uv.x );\n#else\n    vec3 col = texture( iChannel0, uv ).xyz;\n#endif\n    float luminance = dot(col, W);\n    \n    float outputLum = 1.;\n    if (luminance < .9)\n    {\n           outputLum -= (1.- CircleFunc(uv, vec2(1.,0.), .02, .001) )*.2;\n    }\n    if (luminance < .75)\n    {\n           outputLum -= (1.- CircleFunc(uv, vec2(1.,1.), .01, .002))*.5;\n    }\n    if (luminance < .5)\n    {\n           outputLum -= (1.- CircleFunc(uv, vec2(0.,0.), .02, .013))*.8;\n    }\n    if (luminance < .25)\n    {\n           outputLum -= (1.- CircleFunc(uv, vec2(0.,1.), .01, .015));\n    }\n\n    vec3 outputColor = mix( vec3( 0.,.3,.4), vec3(1.,1.,1.), outputLum);\n\n#ifdef TEST\n    if (uv.y > .7 )\n        outputColor = col;        \n#endif\n\n    fragColor = vec4(vec3(outputColor),1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 126, 126, 346], [349, 349, 406, 456, 1294]], "test": "untested"}
{"id": "3lcBWr", "name": "Retrowave landscape", "author": "z0rg", "description": ":)", "tags": ["2d", "retrowave"], "likes": 4, "viewed": 369, "published": 3, "date": "1612727533", "time_retrieved": "2024-07-30T19:39:56.134775", "image_code": "vec3 postFX(vec2 uv, float blur)\n{\n    vec3 col;\n    int cnt = 20;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = fi/fcnt;\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 2.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n    \tcol += texture(iChannel0, p).xyz;\n    }\n    \n    return col/float(cnt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = postFX(uv,.005);\n    \n\tcol += pow(postFX(uv,.015), vec3(.45));\n       col *= 2.;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define sat(a) clamp(a, 0., 1.)\n\nvec3 rdrr(vec2 uv)\n{\n    vec2 ouv= uv;\n    vec3 col = vec3(.05);\n\n    // Grid\n    vec2 rep = vec2(1., 0.1);\n    uv.x = ((uv.x) / uv.y)-iTime;\n    uv.y = pow(abs(uv.y)*4., .25);\n    vec2 gridUv = mod(uv+.5*rep, rep)-.5*rep;\n    float sz = 0.01;\n    float fv = abs(gridUv.x)-sz;\n    float fh = abs(gridUv.y)-sz*.1;\n    \n    col = mix(col, vec3(1.), 1.-sat(fv*iResolution.x*abs(uv.y)*0.05));\n    col = mix(col, vec3(1.), 1.-sat(fh*iResolution.x*.5));\n    col *= sat(-ouv.y);\n    col *= vec3(1.000,0.01,0.01);\n    col = sat(col*15.);\n\n    float t = iTime * .1;\n    float back = ouv.y-.05+.2*(sin(t+ouv.x*35.)*.1+sin(t+ouv.x*43.)*.05+sin(t+ouv.x*100.)*.02);\n    back = abs(back)-0.001;\n    \n    col = mix(col, vec3(0.,1.,0.), 0.02+1.-sat(back*iResolution.x));\n    \n    ouv = myPixel(ouv+5., 0.003)-5.;\n        \tcol *= sat(rand(ouv*sin(iTime)));\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv *= pow(1.+length(uv),.5);\n    vec3 col;\n    vec2 dir = vec2(1.);\n    float strength = 0.003+0.003*length(uv*2.);\n    col.r = rdrr(uv+dir*strength).r;\n    col.g = rdrr(uv).g;\n    col.b = rdrr(uv-dir*strength).b;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = rdr(uv);\n    vec2 cuv = uv*vec2(2.,3.);\n    col *= pow(1.-sat(mix(lenny(cuv), length(cuv), .8)), 2.);\n    col = pow(col, vec3(.85));\n    col *= 2.;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "#define PI 3.141492653\n\n// Stolen on stackoverflow\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nvec2 myPixel(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    \n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 451], [453, 453, 510, 510, 682]], "test": "untested"}
{"id": "3lcfWN", "name": "FBM Fire", "author": "abelu", "description": "FMB fire", "tags": ["fbm"], "likes": 4, "viewed": 353, "published": 3, "date": "1612725060", "time_retrieved": "2024-07-30T19:39:56.910701", "image_code": "float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 3\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .52;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n#define DETAILS 0.04\n#define SPEED 100.0\n#define FORCE 0.5\n#define SHIFT 0.6\n\nvec3 fire(in vec2 fragCoord) {\n    vec2 seed = vec2(\n        fragCoord.x + sin(iTime),\n        fragCoord.y - iTime * SPEED\n    ) * DETAILS;\n\n    float noise1 = fbm(seed);\n    float noise2 = (fbm(seed + noise1 + iTime) - SHIFT) * FORCE;\n\n    float noise3 = fbm(vec2(noise1, noise2)) * FORCE;\n    float noise4 = fbm(vec2(noise2, noise1));\n\n    vec2 coords = fragCoord.xy/iResolution.xy;\n    coords = vec2(coords.x, coords.y * 0.5);\n\n    float shape = 1.0 - smoothstep(\n        0.0,\n        0.4,\n        length(coords - vec2(0.5, 0.0))\n    );\n\n    const vec3 red = vec3(0.8, 0.0, 0.1);\n    const vec3 yellow = vec3(0.8, 0.8, 0.1);\n    const vec3 darkRed = vec3(0.3, 0.0, 0.2);\n    const vec3 dark = vec3(0.1, 0.1, 0.2);\n\n    float opacity = shape - noise2 + noise4 * shape - noise3 *\n      (1.0 + sin(iTime * 3.) * 0.2 - shape);\n\n    vec3 color1 = mix(red, darkRed, noise3 + SHIFT - shape);\n    vec3 color2 = mix(red, yellow, noise3 + SHIFT);\n    vec3 color3 = mix(darkRed, dark, noise4 + SHIFT);\n\n    return (color1 + color2 + color3) * opacity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = vec4(fire(fragCoord), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 134], [136, 214, 240, 240, 620], [640, 640, 664, 686, 941], [1022, 1022, 1052, 1052, 2067], [2069, 2069, 2126, 2126, 2170]], "test": "untested"}
{"id": "WlcBWN", "name": "Neon Sines and trumpet", "author": "jorge2017a1", "description": "Neon Sines and trumpet", "tags": ["neonsinesandtrumpet"], "likes": 5, "viewed": 424, "published": 3, "date": "1612715294", "time_retrieved": "2024-07-30T19:39:57.683634", "image_code": "//modificado por jorgefloresp.\n//referencia\n///https://www.shadertoy.com/view/ls3Xzn\n//Neon sines\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float s3 = 0.5+0.5*sin(iTime+uv.x*3.1415*(sin(iTime)+4.0));\n    float s4 = 0.5+0.25*sin(iTime+uv.x*3.1415*(sin(iTime)*2.0+2.0));\n    \n    \n    float s1 = 0.5+0.5*sin(iTime+uv.x*3.1415+20.*(sin(iTime)+4.0));\n    float s2 = 0.5+0.25*sin(iTime+uv.x*3.1415+0.5*(sin(iTime)*2.0+2.0));\n    \n    float r = pow(1.0-sqrt( abs(uv.y-s1)),1.5 );\n    float g = pow(1.0-sqrt( abs(uv.y-s2)),1.5 );\n    float b1 = pow(1.0-sqrt( abs(uv.y-s3+s4)),1.5 );\n    \n    float b = 1.0*(r+g)*b1;\n    \n    \n    const float pi = 3.14159265;\n    vec2 ar = vec2(iResolution.x/iResolution.y, 1);\n    float t=iTime;\n    float c = smoothstep(.0, .2, cos( 4.*t + 8.*pi*length(ar*uv-ar*.5) ) );\n    \n    \n\tfragColor = vec4( r*c,g*c,b*(1.0-c),1 );\n}", "image_inputs": [], "sound_code": "//por jorge flores p.\n//referencia \n//https://www.shadertoy.com/view/MtBcDR\n//Created by jt in 2017-10-16\n\nconst float trt = 1.0594630943592952645;\nconst float bpm = 140.0;\n\nconst float pi = 3.141592653589793;\nconst float C = 261.63;\n\n\nfloat note2freq(float note)\n{\n    return 440.0 * pow(trt,note);\n}\n\n\n///---------------\nfloat sigmoid(float x)\n{\n    return 1.0 / (1.0 + exp(-x));\n}\n\nfloat smoothed_sawtooth(float d, float x)\n{\n    return (1.0 - 2.0 * acos(d * -cos(x / 2.0)) / pi) * (2.0 *  atan(sin(x / 2.0) / (1.0 - d)) / pi);\n}\n\nfloat trumpet(float t, float f)\n{\n    // Sound starts with sine which turns into (smoothed) sawtooth.\n    return smoothed_sawtooth(0.95 * sigmoid(t * 10.0), f *t);\n}\n\nfloat scale(float n)\n{\n    //return mod(floor(n) * 7.0, 12.0);\n    return mod(floor(n) * 7.0, 40.0);\n}\n\n///---------------\n\n\nvec2 mainSound( int samp, float time )\n{\n    const int tamN=10;\n    float n[tamN];\n    n[0] = 3.0;\n    n[1] = 6.0;\n    n[2] = 2.0;\n    n[3] = 10.;\n    n[4] = 12.;\n    n[5] = 5.0;\n    n[6] = 8.0;\n    n[7] = 2.;\n    n[8] = 1.;\n    n[9] = 2.;\n    \n    \n    float t = time;\n    float tempo = t * (bpm/60.0);\n    float s;\n    float t1 = mod( time * 3., float( tamN) );\n    vec2 lead;\n    float nt;\n    float mi;\n    \n    for( int i = 0; i < tamN; i++ ) \n    {\n        if( float( i ) == floor( t1 ) )\n        {\n    \t\t//s = .125 * sin(6.2831*n[i]*time)*exp(-2.*fract(t1));\n            nt=n[i];\n        }\n     \n    }\n    \n    \n    lead=vec2(  trumpet(t,  note2freq(nt+0.1) )  );\n    lead+=vec2(  trumpet(t,  note2freq(nt-0.1) )  );\n     \n    vec2 hanning = (0.5 - 0.5 * (1.0 - cos(2.0 * pi * lead))) * 2.0;\n    lead*=hanning;\n     \n    vec2 synths =  lead*2.0; \n    synths *= min(mod(tempo,1.0)+0.4,1.0);\n    \n   \n    return  (synths );\n    \n    \n    \n    \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 156, 156, 915]], "test": "untested"}
{"id": "Wl3fD4", "name": "Time and Mandelbrot", "author": "YitingLiu", "description": "Pastel colored trippy effect", "tags": ["fractal", "mandelbrot", "tutorial", "texture", "zoom", "trippy", "iteration", "purple", "world", "fantasy", "artofcode"], "likes": 0, "viewed": 307, "published": 3, "date": "1612711666", "time_retrieved": "2024-07-30T19:39:58.446594", "image_code": "//tutorial https://youtu.be/6IWXkV82oyY\n//music by Yiting Liu https://soundcloud.com/yitingliu/afar\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    float zoom = pow(.1,clamp(0.,0.5,abs(sin(iTime*0.5))));\n    vec3 col = vec3(0.);\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float h = 2. +sin(iTime);\n    vec2 c = uv*zoom*2.*rotate2d(h*0.1*3.14);\n   \n    \n    vec2 z = vec2(0.);\n    float iter = 0.;\n    \n    const float max_iter=100.;\n    float ma=100.;\n    \n    \n    for (float i=0.; i<max_iter;  i++){\n        \n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+c;\n    \n        ma=min(ma,abs(z.y)*abs(z.y));\n        \n        if(length(z)>2.) break;\n        iter++;\n    }\n    \n    float f = iter/max_iter*h;\n    f=pow(f,.025);\n    f=ma*h;\n    \n    col = mix(texture(iChannel0,vec2(f,1.)).gbr,texture(iChannel1,vec2(f,.8)).rgb,texture(iChannel2,vec2(f,.125)).rgb);\n    /*\n    col *=texture(iChannel0,vec2(f,.5)).gbb;\n    col =texture(iChannel1,vec2(f,.25)).ggg;\n\n    \n    */\n    col +=texture(iChannel2,vec2(f,clamp(0.5,1.,abs(tan(iTime*0.08))))).gbr;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25362, "src": "https://soundcloud.com/yitingliu/afar", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 129, 129, 215], [217, 217, 274, 274, 1272]], "test": "untested"}
{"id": "3lcBD4", "name": "Fast Cascaded Separable Blur", "author": "spawner64", "description": "Demonstration of cascaded separable blur, a type of blur that gets exponentially thicker with each cascade. A \"cascade\" is doing a 3x3 average and the result is fed into the next \"cascade\" which is doing the same thing, but with a wider sampling radius.", "tags": ["blur", "fast", "separable"], "likes": 3, "viewed": 496, "published": 3, "date": "1612706849", "time_retrieved": "2024-07-30T19:39:59.513741", "image_code": "// Fast Cascaded Separable Blur\n//\n// Demonstration of cascaded separable blur, a type of blur that gets exponentially thicker with each cascade.\n// A \"cascade\" is doing a 3 x 3 average per pixel (implemented as separable is just 6 samples per pixel) and the\n// result is fed into the next \"cascade\" which is doing the same 3 x 3 average per pixel, but with a wider\n// sampling radius (3 multiplied by radius of last cascade).\n//\n// Why / how does it work?\n//\n// First cascade is gathering 3 x 3 pixels on a radius of 1, so the actual neighbour pixels. Implemented as\n// separable 2-pass x & y blur, we can get the same result for 3 + 3 = 6 samples.\n//\n// The second cascade is gathering 3 x 3 pixels on a radius of 3 (last cascade radius * 3), but the pixels it\n// averages are themselves a 3 x 3 average (from first cascade), therefore the result is similar to performing\n// a 9x9 average on a go or a 2-pass 9 + 9 = 18 samples. However, until now we've used only 6 + 6 samples, so\n// 12 samples in total and got the result of a 2-pass 9 + 9 samples average. 12 vs 18 is surely an improvement,\n// but not that much at this point.\n//\n// The third cascade is also gathering 3 x 3 pixels, but on a radius of 9 (last cascade radius * 3), but the\n// pixels it averages are themselves 3 x 3 average (first cascade) of 3 x 3 average (second cascade), therefore\n// the result is similar with performing a 27 x 27 average in one go or a 2-pass 27 + 27 = 54 samples separable\n// blur. However, keep in mind that so far we've been using 3 cascades * 6 samples per cascade = 18 samples and got\n// the same result as performing a 54 samples average. 54 / 18 = 3X faster. It gets better.\n//\n// Cascade 4:\n// Another 3 + 3 samples for a total 4 cascades * 6 samples per cascade = 24 samples so far.\n// Equivalent to:\n// - Direct convolution: 81 x 81 samples.\n// - Separable x & y blur: 81 + 81 = 162 samples.\n// Performance ratio: 162 / 24 = 6.75X.\n//\n// Cascade 5:\n// Another 3 + 3 samples for a total 5 cascades * 6 samples per cascade = 30 samples so far.\n// Equivalent to:\n// - Direct convolution: 243 x 243 samples.\n// - Separable x & y blur: 243 + 243 = 486 samples.\n// Performance ratio: 486 / 30 = 16.2X!\n//\n// We don't have enough buffers to continue the cascading, but if we would keep cascading even further, we would get:\n//\n// Cascade 6:\n// Another 3 + 3 samples for a total 6 cascades * 6 samples per cascade = 36 samples so far.\n// Equivalent to:\n// - Direct convolution: 729 x 729 samples.\n// - Separable x & y blur: 729 + 729 = 1458 samples.\n// Performance ratio: 1458 / 36 = 40.5X!!\n//\n// Cascade 7:\n// Another 3 + 3 samples for a total 7 cascades * 6 samples per cascade = 42 samples so far.\n// Equivalent to:\n// - Direct convolution: 2187 x 2187 samples.\n// - Separable x & y blur: 2187 + 2187 = 4374 samples.\n// Performance ratio: 4374 / 42 = 104.1X!!!\n//\n// We're not even going to cascade 8, as it's clear at this point that the thickness of the obtained blur increases\n// exponentially (X3) with every added cascade for a cost of just another 6 samples. Also, the performance ratio to regular\n// 2-pass separable x & y blur is increasing exponentially.\n//\n// Here's an overview:\n//\n// +-----------+------------------------+-----------------------------------+-------------------+\n// | Cascade # | Total Cascaded Samples | Equivalent Separable Blur Samples | Performance Ratio |\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         1 +                      6 +                                 6 +            1.00 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         2 +                     12 +                                18 +            1.50 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         3 +                     18 +                                54 +            3.00 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         4 +                     24 +                               162 +            6.75 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         5 +                     30 +                               486 +           16.20 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         6 +                     36 +                              1458 +           40.50 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         7 +                     42 +                              4374 +          104.14 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n// |         8 +                     48 +                             13122 +          273.37 X +\n// +-----------+------------------------+-----------------------------------+-------------------+\n//\n// Conclusion:\n//\n// With the proposed blur solution, the cost increases linearly (num_cascades * 6 samples), but the thickness of the\n// blur increases exponentially (3 ^ num_cascades).\n//\n// The resulting blur is indeed a box blur, but since it's so cheap, the entire process can be repeated. However, since\n// a second run will result in even thicker blur, it's likely that a lower number of cascades would be required to reach\n// the same blur thickness. Running the process a third time produces a blur so smooth, that it closely approximates the\n// gaussian blur. Again, since the third run could have even less cascades and given the performance ratio to regular\n// x & y separable blur (104 times faster with 7 cascades), running the process 3 times is still extremely fast.\n//\n// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    float blurSize = BLUR_ANIMATION_FUNCTION(iTime);\n    vec3 col = vec3(0);\n    if (normalizedSpaceUV.x > 0.5) {\n        col = sample3x3RGB(iChannel0, normalizedSpaceUV, texelSize * BLUR_SIZE_CASCADE_3 * blurSize); // simulates less cascades for a smoother blur\n    } else {\n        col = sample3x3RGB(iChannel0, normalizedSpaceUV, texelSize * BLUR_SIZE_CASCADE_5 * blurSize);\n    }\n    fragColor = vec4(col, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    float blurSize = BLUR_ANIMATION_FUNCTION(iTime);\n    vec3 col = sample3x3RGB(iChannel0, normalizedSpaceUV, texelSize * BLUR_SIZE_CASCADE_1 * blurSize);\n    fragColor = vec4(col, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ------------------------------------------------------------------------- //\n\n#define PI     (3.14159265359)\n#define TWO_PI (6.28318530718)\n\n// ------------------------------------------------------------------------- //\n\n#define SAMPLE_RGBA(sampler, coord) (texture((sampler), (coord)))\n#define SAMPLE_RGB(sampler, coord) (SAMPLE_RGBA((sampler), (coord)).rgb)\n\n// ------------------------------------------------------------------------- //\n\n#define BLUR_SIZE_CASCADE_1 (1.0)   // 3 ^ 0\n#define BLUR_SIZE_CASCADE_2 (3.0)   // 3 ^ 1\n#define BLUR_SIZE_CASCADE_3 (9.0)   // 3 ^ 2\n#define BLUR_SIZE_CASCADE_4 (27.0)  // 3 ^ 3\n#define BLUR_SIZE_CASCADE_5 (81.0)  // 3 ^ 4\n// #define BLUR_SIZE_CASCADE_6 (243.0) // 3 ^ 5\n// ...\n// ...\n// #define BLUR_SIZE_CASCADE_N (3 ^ (N - 1)) // 3 ^ (N - 1)\n\n// ------------------------------------------------------------------------- //\n\n// CONFIGURABLE\n#define BLUR_ANIMATION_FREQUENCY (0.25)\n\n// CONFIGURABLE\n//#define BLUR_ANIMATION_FUNCTION(time) (getAnimatedBlurSizeLinear(time))\n#define BLUR_ANIMATION_FUNCTION(time) (getAnimatedBlurSizeSmooth(time))\n//#define BLUR_ANIMATION_FUNCTION(time) (getAnimatedBlurSizeSmoother(time))\n//#define BLUR_ANIMATION_FUNCTION(time) (getAnimatedBlurSizeSmoothest(time))\n\n// ------------------------------------------------------------------------- //\n\nvec4 floatToColor(float value) {\n    return vec4(value, value, value, 1.0);\n}\n\n// ------------------------------------------------------------------------- //\n\nvec3 sample3x3RGB(sampler2D sampler, vec2 normalizedSpaceUV, vec2 texelSize) {\n    // 3x3 convolution (average)\n    // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n\n    vec3 result = vec3(0);\n\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2(-texelSize.x, -texelSize.y));\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2(-texelSize.x,  0.0        ));\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2(-texelSize.x, +texelSize.y));\n\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2( 0.0        , -texelSize.y));\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2( 0.0        ,  0.0        ));\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2( 0.0        , +texelSize.y));\n\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2(+texelSize.x, -texelSize.y));\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2(+texelSize.x,  0.0        ));\n    result += SAMPLE_RGB(sampler, normalizedSpaceUV + vec2(+texelSize.x, +texelSize.y));\n\n    result *= 0.111111111; // 1.0 / 9.0\n\n    return result;\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat getSineTangentSpace(float frequency, float time) {\n    return sin(time * frequency * TWO_PI);\n}\n\nfloat getSineUnitSpace(float frequency, float time) {\n    return getSineTangentSpace(frequency, time) * 0.5 + 0.5;\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat getAnimatedBlurSizeLinear(float time) {\n    return getSineUnitSpace(BLUR_ANIMATION_FREQUENCY, time);\n}\n\nfloat getAnimatedBlurSizeSmooth(float time) {\n    return smoothstep(0.0, 1.0, getAnimatedBlurSizeLinear(time));\n}\n\nfloat getAnimatedBlurSizeSmoother(float time) {\n    return smoothstep(0.0, 1.0, getAnimatedBlurSizeSmooth(time));\n}\n\nfloat getAnimatedBlurSizeSmoothest(float time) {\n    return smoothstep(0.0, 1.0, getAnimatedBlurSizeSmoother(time));\n}\n\n// ------------------------------------------------------------------------- //", "buffer_b_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    float blurSize = BLUR_ANIMATION_FUNCTION(iTime);\n    vec3 col = sample3x3RGB(iChannel0, normalizedSpaceUV, texelSize * BLUR_SIZE_CASCADE_2 * blurSize);\n    fragColor = vec4(col, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    float blurSize = BLUR_ANIMATION_FUNCTION(iTime);\n    vec3 col = sample3x3RGB(iChannel0, normalizedSpaceUV, texelSize * BLUR_SIZE_CASCADE_3 * blurSize);\n    fragColor = vec4(col, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    float blurSize = BLUR_ANIMATION_FUNCTION(iTime);\n    vec3 col = sample3x3RGB(iChannel0, normalizedSpaceUV, texelSize * BLUR_SIZE_CASCADE_4 * blurSize);\n    fragColor = vec4(col, 1.0);\n}\n\n// ------------------------------------------------------------------------- //", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[5925, 5925, 5980, 5980, 6541]], "test": "untested"}
{"id": "3tcfW4", "name": "Mandelbox MB-4", "author": "darkeclipz", "description": "Another variation of the Mandelbox.", "tags": ["fractal", "raymarch", "mandelbox"], "likes": 6, "viewed": 365, "published": 3, "date": "1612702966", "time_retrieved": "2024-07-30T19:40:00.342525", "image_code": "#define R iResolution.xy\n#define MaxSteps 50.\n#define MinDistance 0.001\n#define eps 0.001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nfloat distFromOrigin = 0.0;\nfloat lissoujasSize = 3.5;\n\nvec3 magma(float t) { // from Mattz\n    t *= 2.0;\n    if(t > 1.0) { t = 2.0-t; }\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 viridis_quintic( float x )\n{\n    x *= 2.0;\n    if(x > 1.0) { x = 2.0-x; }\n\t//x = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    // float c2 = distFromOrigin / lissoujasSize * 3.5;\n    float c2 = distFromOrigin / lissoujasSize * 3.8;\n    float fixedRadius2 = 6.5 - c2;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 20.;\n    \n    float c1 = (distFromOrigin/lissoujasSize)*2.5;\n    float Scale = 2. + c1;\n    \n    //Scale = 5.8-(distFromOrigin/lissoujasSize)*1.5;\n\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n        //z = mengerFold(z);\n        z = boxFold(z, vec3(2.2));       // Reflect\n        sphereFold(z, dr);    // Sphere Inversion\n        z.xz = -z.zx;\n        //sphereFold(z, dr);    // Sphere Inversion\n\t\tz = boxFold(z, vec3(0.9));       // Reflect\n        \n\t\tsphereFold(z, dr);    // Sphere Inversion\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n\treturn box;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0.2, i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance*(1.0+t/10.0)) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 calcLight(vec3 P, vec3 N, vec3 Lpos, vec3 V, vec3 diffuse, vec3 specular) {\n    vec3 L = normalize(Lpos-P);\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diff = NdotL * diffuse;\n    vec3 spec = brdf_ggx(N, V, L, 0.3, 0.02) * specular;\n    return diff + spec;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd, vec3 ro, float trap) {\n    \n    vec3 V = normalize(ro-p);\n    vec3 L = normalize(ro-p);\n    vec3 N = sn;\n    vec3 Refl = reflect(L, N);\n    float NdotL = max(0.0, dot(N, L));\n    \n\n    float pulse = smoothstep(.2, -.2, abs(fract(0.25*trap + 0.1)-0.5));\n    \n    vec3 ambient = vec3(0.);\n    vec3 diffuse = magma(fract(0.15*trap)) \n        + 1.0*magma(fract(0.15*trap)) * pulse\n        ;\n\n    vec3 specular = magma(fract(0.15*trap));\n    \n    //diffuse = vec3(1.0);\n    //specular = vec3(1.0);\n    \n    \n    vec3 front = calcLight(p, N, ro, V, diffuse, vec3(1.0));\n    vec3 bac = calcLight(p, N, vec3(0,1,0), V, diffuse, vec3(1.0));\n    vec3 center = calcLight(p, N, vec3(0,0,0), V, diffuse, vec3(1.0));\n    \n    return ambient + 0.8*front + 0.3*bac + 0.55*center;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvec3 camPos(float t) {\n    float x = cos(5.0*t);\n    float y = sin(3.0*t);\n    float z = cos(7.0*t);\n    return lissoujasSize*vec3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 fog = vec3(.3,.2,.3) * 0.5;\n    vec3 col = vec3(fog);\n\n    float speed = 0.02;\n    float time = (iTime +93.6) * speed;\n    \n    vec3 ro = camPos(time);\n    \n    distFromOrigin = length(ro);\n    \n    \n    vec3 ta = camPos(time+speed);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    \n    //mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    \n    //ro -= vec3(0,1,15);\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = clamp(light(p, n, rd, ro, hit.z), 0.0, 1.0);\n        col *= (.5*hit.y+.5);   // occlusion \n        \n        float fog_max = 5.5,\n              fog_min = 4.;\n        float fog_alpha = clamp(1. - (fog_max - t) / (fog_max - fog_min), 0.0, 1.0);\n        col = mix(col, fog, fog_alpha);\n    }\n    else {\n        col = vec3(fog);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 272, 286, 990], [992, 992, 1025, 1025, 1615], [1617, 1617, 1644, 1644, 1730], [1732, 1732, 1759, 1759, 1845], [1847, 1847, 1874, 1874, 1952], [1954, 1954, 1987, 1987, 2016], [2018, 2029, 2066, 2066, 2097], [2099, 2110, 2141, 2141, 2204], [2206, 2282, 2312, 2312, 2357], [2359, 2485, 2532, 2588, 2912], [2914, 2990, 3015, 3015, 3181], [3185, 3283, 3300, 3300, 4053], [4055, 4055, 4075, 4075, 4119], [4121, 4121, 4147, 4147, 4166], [4168, 4179, 4204, 4204, 4476], [4478, 4556, 4586, 4586, 4891], [4893, 4893, 4930, 4930, 5166], [5168, 5168, 5201, 5201, 5245], [5247, 5314, 5381, 5381, 5976], [5978, 5978, 6058, 6058, 6245], [6247, 6322, 6381, 6381, 7124], [7126, 7170, 7238, 7238, 7283], [7285, 7285, 7307, 7307, 7425], [7427, 7427, 7484, 7484, 8606]], "test": "untested"}
{"id": "wltfWH", "name": "Random 1", "author": "Leasel", "description": "It shows a way to make a flood in parallel", "tags": ["buffers"], "likes": 0, "viewed": 222, "published": 3, "date": "1612695795", "time_retrieved": "2024-07-30T19:40:01.264061", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Generate UV's\n    vec2 uv = fragCoord.xy*dif.xy;\n\n    //Shows the flood propagating\n    #if Rendering == Normal\n    vec4 Col = vec4(S(uv).w);\n    fragColor = Col;\n    #endif\n    \n    #if Rendering == Abnormal\n    vec4 Col = vec4(S(uv));\n    fragColor = G(vec2(Col.x, Col.w));\n    #endif\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//This per cell what it can take from other neighbours and if the other neighbours can't get water from itsel it means it has to hold it(this is done with buffer C)\n//iChannel2 determiness where there can be water and not\n\nvec4 Initialise(in vec2 uv)\n{\n    return vec4(\n        G(uv).x,//Holds the amount of maximum capacity of water\n        0.0,//Holds the amount of water a cell has to holds for itself\n        0.0,//Does nothing\n        G(uv).x*1.5//Holds the amount of water of a cell\n    );\n}\n\nvoid mainImage( out vec4 pn, in vec2 fragCoord )\n{ \n    //Generate UV's\n    vec2 uv = fragCoord.xy*dif.xy;\n\n    //Get neighbour points\n    vec4[4] npns = vec4[4]\n    (\n        S(uv + dif.xz),\n        S(uv - dif.xz),\n        S(uv + dif.zy),\n        S(uv - dif.zy)\n    );\n    \n    //Do passes\n\n    //Initialise\n    pn = iFrame < 3 || mod(iTime, 6.) > 5.95 || K(37) == 1. ? Initialise(uv) : S(uv);\n    \n    //Pass 1\n    PASS_1(pn.x, uv, pn, npns);\n    \n    //Pass \n    PASS_2(pn.y, uv, pn, npns);\n    \n    //Pass \n    PASS_3(pn.z, uv, pn, npns);\n    \n    //Pass \n    PASS_4(pn.w, uv, pn, npns);\n    \n}\n", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Set Buffer B to the new flood map\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = S(fragCoord/iResolution.xy);//Take the previous value\n}", "buffer_b_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Handy texture grabbing\n#define dif vec3(1./iResolution.xy, 0)\n#define S(uv) texture(iChannel0, uv)\n#define G(uv) texture(iChannel1, uv)\n#define K(key) texelFetch(iChannel2, ivec2(key, 0), 0).x\n\n//Pass grabbers\n#define One(index) npns[index].x\n#define Two(index) npns[index].y\n#define Thr(index) npns[index].z\n#define For(index) npns[index].w\n\n#define ONE pn.x\n#define TWO pn.y\n#define THR pn.z\n#define FOR pn.w\n\n//Setting\n#define Normal 1\n#define Abnormal 2\n#define Rendering Normal\n\n\n//n standing for number, pn standing for packedNumbers and npns standing for neighbour packed numbers\nvoid PASS_1(inout float n, in vec2 uv, in vec4 pn, in vec4[4] npns)//This being number x\n{\n    //Holds the amount of maximum capacity of water\n}\nvoid PASS_2(inout float n, in vec2 uv, in vec4 pn, in vec4[4] npns)//This being number y\n{\n    //Holds the amount of water a cell has to holds for itself\n    \n    \n    //Calculate the amount of water a cell has to hold from its previous value\n    n = 4. - (One(0) + One(1) + One(2) + One(3));\n}\nvoid PASS_3(inout float n, in vec2 uv, in vec4 pn, in vec4[4] npns)//This being number z\n{\n    //Does nothing\n}\nvoid PASS_4(inout float n, in vec2 uv, in vec4 pn, in vec4[4] npns)//This being number w\n{\n   //Holds the amount of water of a cell\n   \n   //Calculate the new amount of water\n   n = (\n            For(0) * One(0) +\n            For(1) * One(1) +\n            For(2) * One(2) +\n            For(3) * One(3) +\n            n * TWO\n        )*0.25;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 77, 352]], "test": "untested"}
{"id": "wd2fDD", "name": "April, March, Bloom", "author": "Plento", "description": "I tried to make a bloom using a Guassian blur. Old experiment thats been sitting in my list for a while.", "tags": ["3d", "bloom"], "likes": 17, "viewed": 416, "published": 3, "date": "1612687144", "time_retrieved": "2024-07-30T19:40:02.160664", "image_code": "// Image\n\n\n/* \n    The blur is seperated in buffer B and image where B blurs in the X direction \n    and image tab takes that and blurs down the y direction. Its faster seperated  \n    like this becuase otherwise you'd need a nested for loop. 2x vs x^2. Im sure theres\n    better ways yet, but thats why I'm here!\n*/\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 blur = texture(iChannel1, uv).xyz;\n    vec3 sum = vec3(0);\n    \n    vec2 scl = 1./R;\n    \n    for(float i = 0.; i < iter; i++){\n        float g = gauss(i, nd);\n        \n        vec3 l = texture(iChannel1, uv+vec2(0., i*scl.y)).xyz;\n        vec3 r = texture(iChannel1, uv-vec2(0., i*scl.y)).xyz;\n        \n        sum += l*g;\n        sum += r*g;\n    }\n    \n    col += sum*2.;\n    \n    col *= 1.-step(0.48, abs(uv2.y));\n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A\n\n\n\n// Raymarch!\n\n\n\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat map(vec3 rp){\n    vec3 p = rp - vec3(0.0, -3., 6.0);\n    p.xy *= rot(p.z*.08);\n    \n    vec3 b = vec3(6.4, .1, 6.8);\n    p = mod(p, b)-b*0.5;\n    \n    float h = .5+.5*cos(p.y*3.)*0.4;\n    return box(p, vec3(h, 22., h));\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\nvec3 color(vec3 p, vec3 rd, vec3 n, vec2 u, float t){\n    float fres = smoothstep(-.7, .7, dot(rd, n));\n    vec3 col = fres*0.7*vec3(0.3,0.7,0.9);\n    \n    vec3 sky = mix(vec3(0.6, 0.75, 0.9), vec3(0.9, 0.2, 0.1), length(rd.xy*1.3));\n    col = mix(sky, col, exp(-t*t*t*0.00001));\n    \n\treturn col;   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 1. - dot(uv, uv) * -0.5));\n    rd.xy*=rot(iTime*-0.1);\n    \n    vec3 ro = vec3(0., -2., iTime*2.4);\n    \n    float t = 0., d = 0., ns = 0.0;   \n    for(int i = 0; i < 100; i++){\n    \td = map(ro + rd*t); \t   \n        \n        if(abs(d) < .0025 || t > 60.)\n            break;\n        \n        t += d * .8;\n        ns++;\n    }\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, u, t);\n    \n    col*=1.23;\n    col = col*col;\n    \n    col = 1.-exp(-col);\n    \n    f = vec4(col, 1.);\n}\n\n\n", "buffer_a_inputs": [], "buffer_b_code": "// Buffer B\n\n// Half of the blur, in the x direction. \n\n  \n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    \n    vec3 sum = vec3(0);\n    \n    vec2 scl = 1./R;\n    \n    for(float i = 0.; i < iter; i++){\n        float g = gauss(i, nd);\n        \n        vec3 l = texture(iChannel0, uv+vec2(i*scl.x, 0)).xyz;\n        vec3 r = texture(iChannel0, uv-vec2(i*scl.x, 0)).xyz;  \n        \n        l *= l;\n        r *= r;\n        \n        sum += l*g;\n        sum += r*g;\n    }\n    \n    f = vec4(sum, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nconst float iter = 27.; // Blur iterations\nconst float nd = iter*.5;\n\n\nfloat gauss(float i, float nd){\n     return exp(-(i*i)/(2.*nd*nd))/sqrt(2.*3.14159*nd*nd);  \n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2fDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 358, 358, 939]], "test": "untested"}
{"id": "tldfD8", "name": "Brushed metal sketch", "author": "ttg", "description": "Quick test.  Textures need to be replaced with hash-based low frequency synthesis.\nMultisampling: quick way to overcome linear texture discontinuities, not suitable for production.", "tags": ["metal"], "likes": 14, "viewed": 852, "published": 3, "date": "1612682594", "time_retrieved": "2024-07-30T19:40:03.024354", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n\n  float g = 0., l=0.;\n  const float N = 16.;\n  for (float i=0.; i<N; i++) {\n    g+=sqrt(1./N)*(-.5+texture(iChannel0, uv*vec2(.06,4.18)+i*vec2((7.+1./N)/256.)).x);\n    l+=sqrt(1./N)*(-.5+texture(iChannel0, vec2(0.,.5)+uv*vec2(.04,0.004)+i*vec2((10.+1./N)/256.)).x);\n  }\n  l = exp(4.*l-1.5);\n  g = exp(1.2*g-1.5);\n  float v = .1*g+.2*l+2.*g*l;\n  \n  vec3 col = vec3(v);\n\n  fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 514]], "test": "untested"}
{"id": "wldBD8", "name": "Audio Visualizer: Rainbow", "author": "Zi7ar21", "description": "I made this example of a way to use the Soundcloud input.", "tags": ["music", "visualizer", "visualize", "uamee", "hardbass"], "likes": 5, "viewed": 351, "published": 3, "date": "1612678071", "time_retrieved": "2024-07-30T19:40:03.913976", "image_code": "// ##### Audio Visualizer: Rainbow #####\n// Made by Zi7ar21 (Discord: @Zi7ar21#2168)\n\n/* I don't know what this is really, it has pretty colors and stuff...\nI made it symetrical and stuff and it can take the Microphone/Soundcloud\nInput in iChannel0. uamee's \"COMRADE YOU JUST POSTED CRINGE\" is used as\nan example.*/\n\n// UPDATE August 30th, 2021: Cleaned code, this looked horrifying lmao\n\n// Anti-Aliasing (Super-Sampling Anti-Aliasing)\n#define SSAA 4\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.0);\n    for(int x = -SSAA; x <= SSAA; x++) {\n    for(int y = -SSAA; y <= SSAA; y++) {\n        vec2 spos = vec2(x, y)/float(SSAA);\n        uv = abs(2.0*((fragCoord.xy+spos)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y));\n        if(texture(iChannel0, vec2(uv.x, 0.0)).x*uv.y < 0.1)\n        {\n            color += clamp(vec3(uv.x, 1.0-uv.x, 1.0-uv.y), 0.0, 1.0);\n        }\n        if(texture(iChannel0, vec2(uv.x, 1.0)).x*uv.y < 0.1)\n        {\n            color += clamp(vec3(uv.x, 1.0-uv.x, 1.0-uv.y*2.0), 0.0, 1.0);\n        }\n    }\n    }\n\n    fragColor = vec4(color/float(SSAA*SSAA*8), 1.0);\n}", "image_inputs": [{"id": 25359, "src": "https://soundcloud.com/uamee/comrade-you-just-posted-cringe", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[453, 453, 508, 508, 1221]], "test": "untested"}
{"id": "wldfW8", "name": "Warped gyroid ice cave", "author": "jarble", "description": "This a modified version of [url=https://www.shadertoy.com/view/WtSfzd]3D_Gyroid_IceCave_LO[/url] with a distorted perspective.\n\nThe [code]RayMarch[/code] function is modified to change the camera's direction with each step.", "tags": ["gyroid"], "likes": 5, "viewed": 376, "published": 3, "date": "1612674313", "time_retrieved": "2024-07-30T19:40:05.188569", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100. //WE PUT A DECIMEL HERE AND NOT ON MAX STEPS BECAUSE MAX STEPS IS AN INT\n\t\t\t\t\t  //WHEREAS MAX_DIST IS A FLOAT\n#define SURF_DIST 1e-3 //OUR \"SURFACE DIST\" IS WHEN THE SPHERE THAT SEEKS A HIT DURING OUR MARCH REACHES A SMALL SIZE, IN THIS CASE .01\n\t\t\t\t\t  //THEN WE HAVE A HIT\n\n#define S(a, b, t) smoothstep (a, b, t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c); \n}\n\nfloat sdBox (vec3 p, vec3 s)\n{\n  p = abs(p)-s; \n    \n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) \n    {       \n        p *= scale;  //WE SCALE THE POSITION TO SCALE THE GYROID. BUT WHENEVER WE MULTIPLY THE POSITION, WE NEED TO DIVIDE IT BY WHAT WE MULTIPLIED. \n        \n        return abs(dot(sin(p), cos(p.zxy)) - bias)/scale-thickness; //WE DIVIDE IT HERE.  ALSO !! -- IF PLAYING WITH A 2D GYROID WE CAN\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //CHANGE THE SHAPE BY MULTIPLYING THE POSITION'S SIN\n    }\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.18); \n    p.z -= iTime*1.0;\n    p.y -= .3; \n    \n    return p;\n}\n\nfloat GetDist(vec3 p) //THIS TAKES A POINT  IN 3D SPACE AS AN INPUT\n    {\n                  \n        p = Transform(p);  //THIS IS HOW WE'LL MOVE OUR STRUCTURE. WE DON'T WANT TO MOVE OUR CAMERA POSITION BECAUSE THE MORE WE MOVE\n        \t\t\t\t  //OUR CAMERA AWAY FROM THE ORIGIN POINT, THE LESS DETAILED WE'LL GET BECAUSE THIS IS, IN ESSENCE, BUILT AROUND\n        \t\t\t\t  //A RAYMARCHER THAT MARCHES A RAY TO A POINT \n        \n        float box = sdBox(p, vec3(1)); \n\n        float g1 = sdGyroid(p, 5.76, .03, 1.5);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 100.23, .03, .3);\n\n\n        //float g = min(g1, g2); //Union method of combining gyroids\n        // float g = max(g1, -g2); //Subraction method of combining gyroids\n        \n        g1 -= g2*.4;   //Bumpmap method\n        g1 -= g3 *.2;\n        g1 += g4 *.2;\n        g1 += g5 *.2;\n        g1 -= g6 *.1;\n       \n            \n       \n       // float d = max(box, g1*.8); //WE MULTIPLY BY A NUMBER LESS THAN 1 TO REDUCE THE STEP SIZE SO WE DON'T OVERSTEP WHEN\n        \t\t\t\t\t\t\t   //WE ADJUST THE SCALE ABOVE IN sdGyroid.\n \n        float d = g1*.6; \n        return d;\n    }\n\nfloat RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO = 0.,eps=SURF_DIST; //Distance origin, or how far away we've marched from the origin. \n        \n        for(int i=0; i < MAX_STEPS; i++) //Loop that goes until you've reached max # of steps. \n        {\n            rd.xy *= Rot(rd.z/10.0); \n            vec3 p = ro+dO*rd; //Point P is the blue point (\n            float dS = GetDist(p); //Distance to the scene. \n            dO += dS; //We add the distance to the scene to how far we've marched away from origin. \n            \n            if(dS<eps*(1.0+dO*.25) || dO > MAX_DIST) break; //If distance to scene  is smaller than some defined surface distance, we have a hit. \n            eps *= 1.01;\t\t\t\t\t\t\t\t\t\t    //Or if it's past our max distance and we haven't hit anything, we break out of it. \n        }\n        return dO; \n    }\n\nvec3 GetNormal(vec3 p) //THIS IS HOW WE FIND THE NORMAL VECTOR, IE THE ORIENTATION OF A SURFACE\n    \t\t\t\t\t//ESSENTIALLY BY DOING THE SAME ALGORITHM TO DETERMINE A SLOPE. WE MAKE 2 POINTS\n    \t\t\t\t\t//VERY CLOSE TOGETHER, THEN SUBTRACT THE DISTANCE A LITTLE TO THE RIGHT, UP AND\n    \t\t\t\t\t//BEHIND THE SURFACE BETWEEN THEM TO FIND WHICH WAY IT'S PORIENTED. \n{\n    \n    vec2 e = vec2(.01, 0); //THIS IS OUR NEW POINT. OUR X VALUE IS .01 AND OUR Y VALUE IS 0.\n    float d = GetDist(p); //THIS IS OUR ORIGINAL POINT IN 3D SPACE WE MADE ABOVE\n    \n    vec3 n = d - vec3( //THESE ARE THE SUBTRACTIONS TO GIVE US OUR NORMAL \n        GetDist(p-e.xyy), //TO THE RIGHT, IE - .01, 0, 0\n        GetDist(p-e.yxy), //UP, IE 0, .01, 0 BECAUSE WE USE THE XY VALUES DEFINED ABOVE, WHEN WE DEFINE VEC2 E\n        GetDist(p-e.yyx)); //BEHIND\n        \n        return normalize(n); \n    \n}\n        \nfloat GetLight(vec3 p)\n        {\n            vec3 lightPos = vec3(0,5,6); //HARDCODE THE LIGHT POSITION. FOR NOW WE'LL SAY IT'S AT THESE POINTS. \n            lightPos.xy += vec2(sin(iTime), cos(iTime))*2.; \n            vec3 l = normalize(lightPos-p); //THIS CALCULATES WHERE LIGHT IS COMING FROM, FROM THE PERSPECTIVE OF THE SURFACE POINT\n            vec3 n = GetNormal(p); \n            \n            float dif = clamp(dot(n, l), 0., 1.); //IF WE DON'T CLAMP IT BETWEEN 0 AND 1, THIS ACTUALLY GIVES US A VALUE BETWEEN -1 AND 1\n            \t\t\t\t\t\t\t\t\t  //WHICH IS FINE WITH A SIMPLE SHAPE LIKE A SPHERE BUT IF WE WANT TO WORK WITH MORE COMPLEX\n            \t\t\t\t\t\t\t\t\t  //STUFF, IT WOULD GIVE US TROUBLE. SO WE CLAMP IT BETWEEN 0 AND 1 \n            \n            float d = RayMarch(p+n*SURF_DIST, l); //THIS IS HOW WE CALCULATE SHADOW. WE RAYMARCH BETWEEN SURFACE POINT AND LIGHT POS AND RETURN A VALUE.\n            \n            if(d<length(lightPos - p)) dif *= .1; //IF THE VALUE WE GET IS SMALLER THAN THE LIGHT POS - SURFACE POSITION, WE KNOW THAT \n            \t\t\t\t\t\t\t\t\t  //WE'RE IN SHADOW. TO MAKE A SHADOW, WE JUST TAKE THE LIGHT VALUE DIF AND MULTIPLY IT BY \n            \t\t\t\t\t\t\t\t\t  //A SMALL AMOUNT TO CREATE THE SHADOW\n            return dif;\n        }\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize (l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z, \n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}  \n        \nvec3 Background(vec3 rd)  //WE ONLY NEED TO CALCULATE OUR BKG'S RD BECAUSE WE DON'T CARE ABOUT WHERE WE ARE, WE ONLY CARE ABOUT WHAT\n    \t\t\t\t\t   //DIR WE'RE LOOKING IN. \n    \n{\n    \n    vec3 col = vec3(0); \n    float t = iTime; \n    \n    float y = rd.y * .5 +.5; //Here we map our color to the ray direction y and then multiply it so that we lock its value between 0 and 1. \n    \t\t\t\t\t\t//At 1 (straight), it's its brightest and at 0 (straight down) it's at its dimmest, giving us a gradient in the\n    \t\t\t\t\t\t//middle. \n    \n    col += y*vec3(.1, .7, 1)*2.;  //This bakes it in so that our color is brighter the higher our Y is. \n    \t\t\t\t\t\t\t  //If we wanted it reverse, we'd do col += (1.-y); \n    \n    float a = atan(rd.x, rd.z); //XZ plane to give us our angle so we can determine our NSEW direction \n    \n    float flames = sin(a*10. +t)*sin(a*7.-t)*sin(a*3.); //We find the sin wav of our angle and multiply to get multiple sin waves on our image. \n    \t\t\t\t\t\t\t\t\t\t\t\t //We then marry it to iTime so it comes in and out on a timer. Then repeat, but \n    \t\t\t\t\t\t\t\t\t\t\t\t//multiply it by negative t so we don't see the movement of the light coming in. Then,\n    \t\t\t\t\t\t\t\t\t\t\t\t//we multiply it again by the sin wave of the angle and diminish it so it feels random. \n    \t\t\t\t\t\t\t\t\t\t\t\t//We could keep repeating this again and again to make it feel more and more random, but\n    \t\t\t\t\t\t\t\t\t\t\t    //Ehh. It looks fine now.\n    \n    flames *= S(.8, .5, y); //We don't want this to reach the poles, so we smoothstep the flame's Y so at .5 it starts fading out\n    \t\t\t\t\t  //and at .8 it's completely faded out   \n        \n    col += flames; \n    col = max(col, 0.); //This makes it so our color can never go negative. \n    //col += S(.5, .2, y); \n    return col; \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float t = iTime;\n    vec3 col = vec3(0);\n    \n    uv += sin(uv*30.*t)*.0001; //\"Heat\" distortion    IF REALLY HIGH THEN IT CAN BE USED FOR DOPE MOSAIC STUFF\n    vec3 ro = vec3(0,0,-.01); //ray origin, or position of camera   \n    //ro.yz *= Rot(-m.y*3.14+1.+sin(iTime*5.0/7.0*2.0)/2.0); \n    //ro.xz *= Rot(-m.x*6.2831+cos(iTime*2.0)/2.0);\n    \n    ro.yz *= Rot(-m.y*3.14+sin(iTime*5.0/7.0)/2.0); \n    ro.xz *= Rot(-m.x*6.2831+cos(iTime)/2.0);\n    \n    vec3 lookat = vec3(0,0,0); \n    vec3 rd = GetRayDir(uv, ro, lookat, .8); //THE FLOAT AT THE END OF THIS IS THE ZOOM FACTOR\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) //THIS IS WHERE WE MAKE OUR MATERIAL, WHICH INCLUDES COLOR AND SHADOWS\n    {\n        vec3 p = ro + rd * d; \n        vec3 n = GetNormal(p); \n        \n        float height = p.y; \n\n        p = Transform(p); \n        \n        float dif = n.y * .5+.5; //n.y gives us light from direct above because it's the normal's y. We then wrap it with .5 + .5\n        \t\t\t\t\t\t //to prevent it shooting us back a negative value, keeping it always between 0 and 1. \n        col += dif*dif;\n        \n        float g2 = sdGyroid(p, 10.76, .03, .3); //Ambient occlusion.\n        col *= S(-.1, .1, g2); //Blackening \n        \n        \n        //CRACKS: \n        \n        float crackWidth = -.01 + S(0., -.5, n.y)*.01; //We set the crack width but then put in the smoothstep to say \"If it's between\n        \t\t\t\t\t\t\t\t\t\t\t\t//These values (ie 0 and -.5), then make it thicker. In this case, it tranlsates \n        \t\t\t\t\t\t\t\t\t\t\t\t//to being thicker on the bottom than the top.  \n        float cracks = S(crackWidth, -.03, g2); //  \n        float g3 = sdGyroid(p+t*.1, 5.76, .03, .0);\n        float g4 = sdGyroid(p-t*.07, 3.76, .03, .0);\n        \n        cracks *= g3*g4*30.+.3*S(.0, .3, n.y); //THE LAST NUMBER HERE DETERMINES THE BRIGHTNESS OF THE COLOR IN THE CRACKS\n        \t\t\t\t\t\t\t\t\t   //WE USE SMOOTHSTEP HERE TO KEEP IT FROM GOING FULLY BLACK AT A CERTAIN HEIGHT.\n        \t\t\t\t\t\t\t\t\t   //BECAUSE I WANT THIS TO BE ICE, I WANT IT TO NOT GO FULL BLACK UP TOP, BUT DOWN BELOW IS FINE.\n        \t\t\t\t\t\t\t\t\t   //IF I WANTED THE REVERSE, I'D REVERSE THE NUMBERS. \n        \n        \n        col += cracks*vec3(.1, .7, 1)*3.; //This allows us to change the color of the cracks in RGB code. Our primary color should\n        \t\t\t\t\t\t\t\t  //Always be 1 or greater and no value should be 0 because if it is, if we then multiply the\n        \t\t\t\t\t\t\t\t  //colors, it will get funky in not a good way. \n        \n        //FLICKERING\n        \n        float g5 = sdGyroid(p-vec3(t,0,0), 3.76, .03, .0); //The vec3 allows us to determine the direction the flickering happens.\n        \t\t\t\t\t\t\t\t\t\t\t\t   //We marry it to Time to give it a rhythm. If the T is in X, the flickering\n        \t\t\t\t\t\t\t\t\t\t\t\t  //goes along the X, if in Y then the Y,  etc.\n           \n        col += g5*vec3(.1, .7, 1); //determines the color of our flicker\n        \n        col += S(0., 8., height)*vec3(.1, .7, 1)*2.; //gives us a glow to wash it out. I have the glow start at 0 and reach max at 5\n        \n        \t\n        \n    }\n    \n    //DEPTH FOG/BACKGROUND: \n    \n    col = mix(col, Background(rd), S(0., 9., d)); //This is where we blend our background with our structure.  \n   \n    col *= 1. -dot(uv, uv); //THIS IS A VIGNETTE. WE MULTIPLY UV BY UV (UV SQUARED) TO GIVE US A BLACK CENTER. TO PUSH IT OUT TO THE EDGES\n    \t\t\t\t\t\t//OF THE SCREEN, WE MULTIPLY IT BY NEGATIVE DOT. \n    fragColor = vec4(col,1.0);\n}\n    \n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 379, 379, 461], [463, 463, 493, 493, 583], [585, 585, 656, 656, 1043], [1045, 1045, 1069, 1069, 1155], [1157, 1157, 1230, 1230, 2456], [2458, 2458, 2496, 2496, 3295], [3297, 3297, 3651, 3651, 4160], [4170, 4170, 4202, 4202, 5422], [5424, 5424, 5474, 5474, 5672], [5684, 5684, 5860, 5860, 7435], [7438, 7438, 7495, 7495, 11074]], "test": "untested"}
{"id": "3ttBWH", "name": "Path-Tracing: Ray-Tracing", "author": "Zi7ar21", "description": "Path-Tracing 2 Spheres but with Ray-Tracing. I don't know much about making intersection functions, but combining them was kind of intuitive. Normals are heck though and I have no clue how they work, Normals in Ray-Marching are much easier to find.", "tags": ["raytracing", "raytracer", "raytrace", "pathtrace", "pathtracing", "pathtracer"], "likes": 7, "viewed": 386, "published": 3, "date": "1612670689", "time_retrieved": "2024-07-30T19:40:06.613758", "image_code": "// ##### Path-Tracing: Ray-Tracing #####\n// Made by Zi7ar21 on February 6th, 2020\n// Last updated: February 6th, 2020 20:50 Mountain Time\n\n// If you found this anywhere other than Shadertoy, a possibly updated version can be found at:\n// https://www.shadertoy.com/view/3ttBWH\n\n// Common is for Parameters, Constants, and Other Functions.\n// Buffer A is for Path-Tracing the scene.\n// Buffer B is for Exporting a 32-BPC Floating Point OpenEXR Image.\n// This is for Drawing the main image.\n\n// ##### Contributors #####\n// LoicVDB and Michael0884 helped me a ton with my shaders, check them out:\n// https://www.shadertoy.com/user/loicvdb\n// https://www.shadertoy.com/user/michael0884\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This contains Parameters, Constants, and Other Functions.\n\n// ##### Common Parameters #####\n// Mouse Control Sensitivity\n#define mousesensitivity 4.0\n\n// Camera Field of View\n#define camfov 1.0\n\n// Roughness Texture Octaves\n#define octaves 4\n\n// ##### Constants and Functions #####\n// Pi (Quadruple Precision Float Future-Proof)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define quarterpi pi*0.25\n#define twopi pi*2.0\n\n// ##### LoicVDB's Sky Parameters #####\n// Controls Sky Quality\n#define SkySamples 8\n\n// Controls Sky Color\n#define SkyColor vec3(0.25, 0.5, 1.0)\n\n// Controls Light Color\n#define LightColor vec3(1.0, 1.0, 1.0)\n\n// Controls Sky Direction\n#define SkyUp vec3(0.0, 1.0, 0.0)\n\n// Controls Light Direction\n#define LightDirection normalize(vec3(1.0, 1.0, -1.0))\n\n// Controls Sky Intensity\n#define SkyIntensity 0.25\n\n// Controls Light Intensity\n#define LightIntensity 1.0\n\n// Controls the Radius of the Light\n#define LightRadius 0.125\n\n// Controls Mie Scattering Intensity\n#define MieIntensity 0.05\n\n// Controls Mie Scattering Anisotropy\n#define MieAnisotropy 0.6\n\n// LoicVDB's (Slightly Modified) Sky Functions (Loic's Profile: https://www.shadertoy.com/user/loicvdb)\n// (I don't know where to link to other than his profile page, since this\n// is from a Fragmentarium shader he shared on the Marble Marcher Discord)\nfloat anisotropicWeight(vec3 dirI, vec3 dirO, float a){\n \treturn quarterpi*(1.0-a*a)/pow(1.0+a*(a-2.0*dot(dirI, dirO)), 1.5);\n}\n\nvec3 skyDirectLight(vec3 pos, int i) {\n    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}\n    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;\n    float alt, dist, ds;\n    for(; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));\n    \tdist = alt/dot(LightDirection, SkyUp);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        volAbs *= stepAbsMie*stepAbsRay;\n        pos += LightDirection*dist;\n    }\n    return LightColor.rgb*LightColor*volAbs;\n}\nvec3 backgroundDirectLight(vec3 dir) {\n\tif(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}\n\tfloat sphericalCapArea = sin(LightRadius)*sin(LightRadius);\n\tfloat lightStrength = LightIntensity/(sphericalCapArea);\n\treturn lightStrength*LightColor.rgb;\n}\n\nvec3 skyScatter(vec3 dir, bool hasSun){\n    vec3 pos = vec3(0.0), volCol = vec3(0.0), volAbs = vec3(1.0);\n    vec3 stepAbsRay, stepAbsMie, stepColRay, stepColMie;\n    float alt, dist, ds;\n    float aw = anisotropicWeight(dir, LightDirection, MieAnisotropy);\n    for(int i = 0; i < SkySamples; i++) {\n        alt = -log(1.0-sign(dot(dir, SkyUp))*float(i)/float(SkySamples));\n    \tdist = min(alt/dot(dir, SkyUp), 5.0);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor.rgb*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        stepColRay = (1.0-stepAbsRay);\n        stepColMie = (1.0-stepAbsMie)*aw;\n        volCol += (stepColMie+stepColRay)*volAbs*skyDirectLight(pos, i);\n        volAbs *= stepAbsRay*stepAbsMie;\n        pos += dir*dist;\n    }\n    return volCol+(hasSun ? backgroundDirectLight(dir)*volAbs:vec3(0.0));\n}\n\n// Hash: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 pos){\n\tpos =  fract(pos*vec3(0.1031, 0.1030, 0.0973));\n    pos += dot(pos, pos.yxz+33.33);\n    return fract((pos.xxy+pos.yxx)*pos.zyx);\n}\n\n// Gradient Noise: https://iquilezles.org/articles/gradientnoise\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 ga = hash(p+vec3(0.0,0.0,0.0));\n    vec3 gb = hash(p+vec3(1.0,0.0,0.0));\n    vec3 gc = hash(p+vec3(0.0,1.0,0.0));\n    vec3 gd = hash(p+vec3(1.0,1.0,0.0));\n    vec3 ge = hash(p+vec3(0.0,0.0,1.0));\n    vec3 gf = hash(p+vec3(1.0,0.0,1.0));\n    vec3 gg = hash(p+vec3(0.0,1.0,1.0));\n    vec3 gh = hash(p+vec3(1.0,1.0,1.0));\n    float va = dot(ga, w-vec3(0.0,0.0,0.0));\n    float vb = dot(gb, w-vec3(1.0,0.0,0.0));\n    float vc = dot(gc, w-vec3(0.0,1.0,0.0));\n    float vd = dot(gd, w-vec3(1.0,1.0,0.0));\n    float ve = dot(ge, w-vec3(0.0,0.0,1.0));\n    float vf = dot(gf, w-vec3(1.0,0.0,1.0));\n    float vg = dot(gg, w-vec3(0.0,1.0,1.0));\n    float vh = dot(gh, w-vec3(1.0,1.0,1.0));\n    return va+\n    u.x*(vb-va)+\n    u.y*(vc-va)+\n    u.z*(ve-va)+\n    u.x*u.y*(va-vb-vc+vd)+\n    u.y*u.z*(va-vc-ve+vg)+\n    u.z*u.x*(va-vb-ve+vf)+\n    u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n// 3D FBM: https://www.shadertoy.com/view/3dSBRh\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*noise(x);\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u)) ^ state)*277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884: https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// This is for Path-Tracing the scene.\n\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nvec2 sphere(vec3 raydir, vec3 rayori, vec3 center, float radius){\n    vec3 oc = rayori-center;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-radius*radius;\n    float h = b*b-c;\n    if(h < 0.0){return vec2(-1.0);}\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// Sphere Normal Function\nvec3 sphereNormal(float hit, vec3 raydir, vec3 rayori, vec3 spherepos, float sphererad){\n    return normalize((rayori+(raydir*hit))-spherepos);\n}\n\n// Scene Intersection and Normals\nvec2 scene(vec3 raydir, vec3 rayori, out vec3 normal){\n    vec2 hit;\n    vec3  s0pos = vec3(-0.125, 0.0, 0.0);\n    float s0rad = 0.25;\n    vec3  s1pos = vec3( 0.125, 0.0, 0.0);\n    float s1rad = 0.25;\n    vec2 s0 = sphere(raydir, rayori, s0pos, s0rad);\n    vec2 s1 = sphere(raydir, rayori, s1pos, s1rad);\n    if(s0.x <= 0.0){\n        normal = sphereNormal(s1.x, raydir, rayori, s1pos, s1rad);\n        return s1;\n    }\n    if(s1.x <= 0.0){\n        normal = sphereNormal(s0.x, raydir, rayori, s0pos, s0rad);\n        return s0;\n    }\n    if(s0.x <= 0.0 && s1.x <= 0.0){\n        return vec2(-1.0);\n    }\n    hit = vec2(min(s0.x, s1.x), max(s0.y, s1.y));\n    if(hit.x == s0.x){\n        normal = sphereNormal(s0.x, raydir, rayori, s0pos, s0rad);\n    }\n    if(hit.x == s1.x){\n        normal = sphereNormal(s1.x, raydir, rayori, s1pos, s1rad);\n    }\n    return hit;\n}\n\n// Fresnel Reflectance\nvec3 fresnel(vec3 raydir, vec3 normal){\n    // Gold\n    vec3 F0 = vec3(1.0, 0.71, 0.29);\n    // Pure-Reflection\n    //vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Ray-Tracing\nvec3 raytrace(vec3 raydir, vec3 raypos){\n    vec3 outCol = vec3(1.0), norm, randnorm;\n    vec2 intersection;\n    for(uint i = 0U; i < 8U; i++){\n        intersection = scene(raydir, raypos, norm);\n        if(intersection.x < 0.0){break;}\n        raypos += raydir*intersection.x;\n        outCol *= fresnel(raydir, norm);\n        randnorm = normalize(nrand3(fbm(raypos*4.0)*0.5+0.125, norm));\n        raydir = reflect(raydir, randnorm);\n    }\n    //return outCol*texture(iChannel1, raydir).rgb;\n    return outCol*skyScatter(raydir, true);\n}\n\n// LoicVDB's Rotation Matrix: https://www.shadertoy.com/view/3ldBDH\nmat3 rotMat(vec3 rotation){\n    vec3 c = cos(rotation), s = sin(rotation);\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n    return rz*rx*ry;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates Centered on [0.0, 0.0]\n    vec2 uv = 2.0*((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse Controls\n    //vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n    vec2 mouse = ((iMouse.xy/iResolution.xy)-0.5)*pi*mousesensitivity;\n\n    // World Coordinates\n    mat3 rotmat = rotMat(vec3(0.0, mouse.x, 0.0));\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Ray-Trace the Scene\n    vec3 raytraced = raytrace(raydir, vec3(-sin(mouse.x), 0.0, -cos(mouse.x)));\n\n    // Output the Rendered Frame\n    fragColor += vec4(clamp(raytraced, 0.0, 32.0), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This is for Exporting a 32-BPC Floating Point OpenEXR Image.\n\n/* Look at the bottom of the editor, there is a little Image icon. If\nyou click it, then Shadertoy will save a 32-Bit-Per-Channel Floating Point\nOpenEXR Image. It is more optimal for Image editing than right-clicking\nthe canvas and pressing copy/save image (as).*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[682, 682, 736, 736, 792]], "test": "untested"}
{"id": "tltBW8", "name": "gray test", "author": "jorge2017a1", "description": "gray test", "tags": ["graytest"], "likes": 4, "viewed": 225, "published": 3, "date": "1612669515", "time_retrieved": "2024-07-30T19:40:07.389683", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist4,3.0,MATERIAL_NO)); \n    \n    res =opU3(res, vec3(planeDist5,1.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n  \n    p.y=p.y-5.0;\n    \n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n    float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,1.0,-1)); \n    \n    \n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    res =opU3(res, vec3(sdsp2,2.0,-1)); \n   \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*vec3(1, .97, .85)*dif;\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten;\n}\n\n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\nvec3 ColorAGris( vec3 c)\n{\n    return  vec3( 0.30*c.x + 0.59*c.y + 0.11*c.z);\n}\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t \n     float t1=mod(iTime,2.0);\n     float t2=mod(iTime,1.0);\n     \n     if (t1>t2)\n     result = lightingv3( nor, p, plight_pos,  rd)*ColorAGris(colobj)*2.0;\n     else\n     result = lightingv3( nor, p, plight_pos,  rd);\n     \n     \n     \n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t\t//return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n\t\t//return vec3(0.8 + 0.4*d, 0.3 + 0.55*d, 0.15 - 0.1*d);\n        return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \t//light_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n    light_pos1= vec3(10.0+5.0*sin(t), 6.0, 10.0+5.*cos(t) );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n   \n    vec3 ro=vec3(2.0*sin(t),7.0,-25.0+5.*cos(t));\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[399, 399, 435, 435, 456], [457, 457, 489, 489, 573], [574, 574, 620, 620, 707], [709, 753, 800, 800, 827], [829, 829, 872, 872, 899], [901, 901, 949, 949, 977], [1025, 1050, 1084, 1084, 1182], [1183, 1183, 1217, 1217, 1309], [1310, 1310, 1344, 1344, 1436], [1437, 1477, 1511, 1511, 1608], [1610, 1650, 1675, 1675, 3329], [3331, 3331, 3387, 3387, 3971], [3975, 4026, 4050, 4050, 4238], [4239, 4302, 4335, 4335, 4796], [4798, 4852, 4888, 4888, 5122], [5123, 5224, 5250, 5250, 5303], [5305, 5339, 5419, 5419, 5864], [5907, 5958, 6005, 6005, 6956], [7010, 7010, 7103, 7103, 7383], [7388, 7437, 7494, 7494, 8823]], "test": "untested"}
{"id": "wttBW8", "name": "Fake cloud flythrough", "author": "jarble", "description": "This was originally a cave flythrough, but I modified the raymarching loop, so it looks more like clouds.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "cloud"], "likes": 3, "viewed": 302, "published": 3, "date": "1612668685", "time_retrieved": "2024-07-30T19:40:08.224451", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/4.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        //eye.xy *= rot(dist*10.0);\n        marchingDirection.xy *= rot(dist*10.0);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3) {iters += 1;}\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    float speed = 1.0;\n\tvec3 eye = vec3(iTime*50.0,0,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/4096)%5+(t/4096)%3)))|t>>6&t>>5|t>>7;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 32000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 1.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = .01; //to prevent rendering artifacts\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat planet_surface(inout vec3 p,float i){\n    p -= p.zyx*(p/(size*10.0));\n    p = p/size;\n    p = (sin((p)/i+p))*size;\n    return length(p) - size;\n}\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n\nfloat sceneSDF(vec3 p,int iters) {\n    p = vec3(1000.0,0,0)+sin(p/1000.0)*1000.0;\n    p /= scale*(10.0+.5*sin(p.yzx/5.0+p/25.0));\n    \n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 1; i1 < 3; i1++){\n        p = p*i;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n        //result += p.z*sin((p.x+p.y+p.z)/500.0);\n        i *= 3.0;\n        if(i1 == iters) break;\n    }\n    \n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,3);\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))*(2.0+sin(sceneSDF(p*11.0)))/4.0+vec3(.5);\n}\n\n    \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/4.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        marchingDirection.xy *= rot(dist*10.0);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\tif(iters < 3) {iters += 1;}\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    float speed = 1.0;\n\tvec3 eye = vec3(iTime*50.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(eye-dmap);\n\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w;\n    \n    float l2;\n    //if(l0 > .9 && l1 > 0.0){\n    //    l2 = max(log(l0),0.0);\n    //}\n    //else{\n        l2 = log(l0+1.0);\n    //}\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, (dist-l0)*.9);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 481, 572, 572, 1102], [1104, 1104, 1131, 1131, 1280], [1282, 1282, 1339, 1339, 2348]], "test": "untested"}
{"id": "3ltBWH", "name": "Polar Visualizer Fork", "author": "oneshade", "description": "Trying to avoid as many texture() calls as possible.", "tags": ["ray", "raymarch", "circle", "visualizer", "polar", "march"], "likes": 3, "viewed": 149, "published": 3, "date": "1612653452", "time_retrieved": "2024-07-30T19:40:09.123049", "image_code": "const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;\nconst float HALF_PI = 1.57079632679;\n\nconst float        COUNT = 12.0;  // Number of bars to draw in the visualizer\nconst float    THICKNESS = 0.01;  // Line thickness\nconst float INNER_RADIUS =  0.1;  // Inner circle radius\nconst float OUTER_RADIUS =  0.5;  // Outer circle radius\nconst float  START_ANGLE =  0.0;  // Rotation\n\nconst vec3 OFFSET = vec3(0.0, 0.1, 0.0);\n\nconst float  MIN_DIST = 0.001;\nconst float  MAX_DIST =   4.0;\nconst   int MAX_STEPS =    50;\n\nmat2 Rotate(in float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat mapScene(in vec3 p) {\n    float angle = atan(p.z, p.x);\n    float cell = floor(angle / TAU * COUNT) / COUNT;\n\n    float repAngle = TAU / COUNT;\n    float hRepAngle = repAngle * 0.5;\n    p.xz = sin(mod(angle + START_ANGLE, repAngle) - hRepAngle + vec2(HALF_PI, 0.0)) * length(p.xz);\n\n    float amplitude = texture(iChannel0, vec2(cell, 0.0)).x;    \n    float musicBars = sdLine(p - OFFSET, vec3(INNER_RADIUS, 0.0, 0.0), vec3(INNER_RADIUS + amplitude * (OUTER_RADIUS - INNER_RADIUS), 0.0, 0.0), THICKNESS);\n\n    return min(p.y, musicBars);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float t = MIN_DIST;\n    for(int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        t += d;\n        if ((t > MAX_DIST) || (abs(d) < MIN_DIST)) break;\n    }\n\n    return t;\n}\n\nfloat pointLight(in vec3 p, in vec3 pos, in float range) {\n    vec3 k = pos - p;\n    float m = length(k);\n    vec3 l = k / m;\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    dif *= smoothstep(range, 0.0, m);\n\n    dif *= step(length(pos - p), RayMarch(p + n * MIN_DIST, l));\n\n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.5, -0.7);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    rd.zy *= Rotate(-radians(30.0));\n    ro.xz *= Rotate(iTime * radians(10.0));\n    rd.xz *= Rotate(iTime * radians(10.0));\n\n    float t = RayMarch(ro, rd);\n    vec3 p = ro + rd * t;\n\n    vec3 color = vec3(0.0);\n\n    vec3 lp = vec3(1.0, 0.5, 0.0);\n    lp.xz *= Rotate(radians(120.0));\n    color += pointLight(p, lp, 3.0) * vec3(1.0, 0.4, 0.4);\n\n    lp.xz *= Rotate(radians(120.0));\n    color += pointLight(p, lp, 3.0) * vec3(0.4, 1.0, 0.4);\n\n    lp.xz *= Rotate(radians(120.0));\n    color += pointLight(p, lp, 3.0) * vec3(0.4, 0.4, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[530, 530, 555, 555, 621], [623, 623, 682, 682, 811], [813, 813, 840, 840, 1358], [1360, 1360, 1387, 1387, 1632], [1634, 1634, 1668, 1668, 1889], [1891, 1891, 1949, 1949, 2211], [2213, 2213, 2268, 2268, 2988]], "test": "untested"}
{"id": "WttfD8", "name": "Metafluid", "author": "oneshade", "description": "particles + metaballs = metafluid", "tags": ["simulation", "metaballs", "fake", "water", "fluid", "metafluid"], "likes": 11, "viewed": 260, "published": 3, "date": "1612643550", "time_retrieved": "2024-07-30T19:40:09.896979", "image_code": "float blob(in vec2 p, in vec2 o, in float r) {\n    p -= o;\n    return r * r / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Render the particles with some metaball goo\n    float totalDist = 0.0;\n    for (int i=0; i < NUMBER_OF_PARTICLES; i++) {\n        float distToBlob = blob(uv, getParticlePos(i), BLOB_RADIUS);\n        totalDist += distToBlob;\n    }\n\n    vec3 color = vec3(0.25, 0.25, 1.0);\n    //color = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), totalDist * 0.02); // To see the particles\n    color *= smoothstep(0.95, 1.0, totalDist);\n    color *= fragCoord.y / iResolution.y * 1.5;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Particle settings\n#define NUMBER_OF_PARTICLES 100\n\n#define BLOB_RADIUS 0.04\n\n#define REPULSION 0.005\n#define MOUSE_REPULSION 0.01\n#define REPULSION_RADIUS 0.1\n\n// Environment settings\n#define GRAVITY 0.0005\n#define DECAY 0.9\n\n// Utilities\n#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 randomPos(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy) - 0.5;\n\n}", "buffer_a_code": "// For animating the particles' motions\nvec2 animation(in float time) {\n    if (iMouse.z > 0.0) {\n        vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        return vec2(0.0005 * sin(time * 2.0 - mouse.x), 0.0);\n    }\n\n    return vec2(0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 topRight = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFragCoord.x < NUMBER_OF_PARTICLES && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            // Initialize random positions (velocities start at 0)\n            if (iFragCoord.y == 0) {\n                fragColor.xy = randomPos(fragCoord.x);\n            }\n        }\n\n        if (iFrame > 0) {\n            // Load particle data\n            vec2 particlePos = getParticlePos(iFragCoord.x);\n            vec2 particleVel = getParticleVel(iFragCoord.x);\n\n            // Gravitate and bounce\n            particleVel += animation(iTime);\n            particleVel.y -= GRAVITY;\n            vec2 refl = sign(topRight - abs(particlePos));\n            particleVel.xy *= refl;\n            if (refl.x < 0.0 || refl.y < 0.0) {\n                 particleVel.xy *= DECAY;\n            }\n\n            // Push particles away from each other\n            for (int i=0; i < NUMBER_OF_PARTICLES + 1; i++) {\n                if (i != iFragCoord.x && i != NUMBER_OF_PARTICLES) {\n                    vec2 particlePos2 = getParticlePos(i);\n                    vec2 toParticle = particlePos2 - particlePos;\n                    float distToParticle = length(toParticle);\n                    if (distToParticle < REPULSION_RADIUS) {\n                        particleVel -= toParticle / distToParticle * REPULSION;\n                        particleVel *= DECAY;\n                    }\n                }\n\n                // The mouse acts as an extra blob with a unique repulsiveness\n                if (i == NUMBER_OF_PARTICLES && iMouse.z > 0.0) {\n                    vec2 particlePos2 = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n                    vec2 toParticle = particlePos2 - particlePos;\n                    float distToParticle = length(toParticle);\n                    if (distToParticle < REPULSION_RADIUS) {\n                        particleVel -= toParticle / distToParticle * MOUSE_REPULSION;\n                        particleVel *= DECAY;\n                    }\n                }\n            }\n\n            // Update particle data\n            if (iFragCoord.y == 0) {\n                fragColor.xy = particlePos;\n                fragColor.xy += particleVel;\n                fragColor.xy = clamp(fragColor.xy, BLOB_RADIUS - topRight, topRight - BLOB_RADIUS);\n            }\n\n            if (iFragCoord.y == 1) {\n                fragColor.xy = particleVel;\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 90], [92, 92, 147, 147, 717]], "test": "untested"}
{"id": "WltBD8", "name": "Coulomb plasma", "author": "DukeOfStraylight", "description": "I probably saw something like this on my PC in 1994, but hey, this time I made (some of) it myself.", "tags": ["plasma"], "likes": 5, "viewed": 293, "published": 3, "date": "1612639241", "time_retrieved": "2024-07-30T19:40:10.756680", "image_code": "const float pi = 3.14159;\n\nfloat hash11(float x) {\n    return fract(sin(x*543.543)*1364.34);\n}\n\nconst float charges = 8.;\n\nvec2 gradient(vec2 x)\n{\n    float charge = -1.;\n    vec2 rv = vec2(0.);\n    for (float n = 0.; n < charges; n += 1.) {\n        float t = (n * 2. * pi / charges) + iTime * 0.5 + hash11(n) * iTime;\n        vec2 pos = vec2(cos(t), sin(t) * n / charges);\n        vec2 d = x - pos;\n        float l = length(d);\n        rv += normalize(d)/l * charge;\n        charge = -charge;\n    }\n    return rv;\n}\n\n// original numeric gradient calculation\n/*\nfloat potential(vec2 uv) {\n    float charge = 1.;\n    float pot = 0.;\n    const int charges = 8;\n    for (int n = 0; n < charges; n += 1) {\n        float t = (float(n) * 2. * pi / float(charges)) + iTime * 0.5 + hash11(float(n)) * iTime;\n        pot += charge / length(uv - vec2(cos(t), sin(t) * float(n) / float(charges)));\n        charge = -charge;\n    }\n    return pot;\n}\n\nvec2 gradient(vec2 x)\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( potential(x+h.xy) - potential(x-h.xy),\n                 potential(x+h.yx) - potential(x-h.yx) )/(2.0*h.x);\n}\n*/\n\n// from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 3.;\n\n    vec2 f = gradient(uv);\n    float dir = atan(f.y, f.x);\n    fragColor.rgb = hsv2rgb(vec3(fract((dir/pi+1.)*0.5), 1., 1.));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 50, 50, 94], [123, 123, 146, 146, 516], [1124, 1267, 1289, 1289, 1458], [1461, 1461, 1518, 1518, 1744]], "test": "untested"}
{"id": "3ltBD8", "name": "Treasure", "author": "butadiene", "description": "treasure", "tags": ["fractal", "rarmarching"], "likes": 24, "viewed": 816, "published": 3, "date": "1612639160", "time_retrieved": "2024-07-30T19:40:11.599427", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nfloat PI = acos(-1.);\n\nvec2 pmod(vec2 p,float n){\n  float np = 2.*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n}\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;       \n        z *= scale;\n        z.xyz += offset*(1.0-scale);\n    }\n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\n\nfloat bpm = 128.;\nvec4 dist(vec3 p,float t){\n    p.xy *= rot(PI);\n    p.xz = pmod(p.xz,24.);\n    p.x -= 5.1;\n    p.xy *= rot(0.3);\n    p.xz *= rot(0.25*PI);\n    p.yz *= rot(PI*0.5);\n\n    float s =1.;\n    p.z = abs(p.z)-3.;\n    p = abs(p)-s*8.;\n    p = abs(p)-s*4.;\n    p = abs(p)-s*2.;\n    p = abs(p)-s*1.;\n\n    vec4 sd = tetcol(p,vec3(1),1.8,vec3(0.));\n    float d= sd.w;\n    vec3 col = 1.-0.1*sd.xyz-0.3;\n    col *= exp(-2.5*d)*2.;\n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n    p.y *= iResolution.y/iResolution.x;\n   \n    float rsa =0.1+mod(iTime*0.2,32.);\n    float rkt = iTime*0.+0.5*PI+1.05;\n    vec3 of = vec3(0,0,0);\n    vec3 ro = of+vec3(rsa*cos(rkt),-1.2,rsa*sin(rkt));\n    vec3 ta = of+vec3(0,-1.3,0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.4*cdir);\n  \n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    float ep = 0.0001;\n    for(int i = 0;i<66;i++){\n        vec4 rsd = dist(ro+rd*t,t);\n        d = rsd.w;\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n\n    vec3 col = vec3(0.04*ac);\n \n    if(col.r<0.1&&(col.b<0.1&&col.g<0.1)) col =vec3(0.);\n\tfragColor = vec4(col, 1.0 );\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBD8.jpg", "access": "api", "license": "mit", "functions": [[138, 138, 164, 164, 289], [290, 290, 308, 308, 379], [380, 380, 406, 406, 509], [510, 510, 563, 563, 880], [900, 900, 926, 926, 1341], [1343, 1343, 1400, 1400, 2205]], "test": "untested"}
{"id": "tt3fDH", "name": "High-Pass Noise", "author": "spawner64", "description": "By subtracting the low-pass component from regular noise (L), we get the high-pass component (C). Since the low-pass filter removes gradients, the high-pass noise behaves well even when repeated in small textures. Comparison with blue noise (R).", "tags": ["noise", "tileable", "highpass"], "likes": 6, "viewed": 552, "published": 3, "date": "1612631555", "time_retrieved": "2024-07-30T19:40:12.445166", "image_code": "// High-Pass Noise\n//\n// By subtracting the low-pass component from the noise, we get the high-pass component, which seems to behave well\n// when repeated, therefore being a good candidate for small tileable noise textures.\n//\n// Top    : Repeated (64x64) noise.\n// Bottom : Continuous, unbounded noise.\n//\n// Left   : Regular analytical noise.\n// Center : High-pass noise (of regular analytical noise).\n// Right  : Blue noise.\n//\n// TBD: Perhaps would be interesting to render the high-pass component of blue noise as well.\n\n// ------------------------------------------------------------------------- //\n\n// abstraction of the high-passed noise function\n// plug-in your custom RGB noise function\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\n\n// simulates tiling noise in a texture of size TILE_SIZE x TILE_SIZE\n#define TILE_SIZE (64)\n\n// thickness of split lines\n#define SPLIT_LINE_THICKNESS (4.0)\n\n// background gray color of Shadertoy web page\n#define TOY_BG_AVER_GRAY (209.0 / 255.0)\n\n// background gray color variation of Shadertoy web page\n#define TOY_BG_GRAY_VAR (0.1)\n\n// split coordinates\n#define H_SPLIT_A (0.5)\n#define V_SPLIT_A (0.333)\n#define V_SPLIT_B (0.666)\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/Md2cRt\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575);\n}\n\nvec3 randRGB(vec2 uv) {\n    return vec3(\n        fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n        fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n        fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n    );\n}\n\n// ------------------------------------------------------------------------- //\n\nvec3 lowPassRandRGB(vec2 uv) {\n    // 3x3 convolution (average)\n    // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n\n    vec3 result = vec3(0);\n\n    result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n\n    result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n\n    result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n    result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n\n    result *= 0.111111111; // 1.0 / 9.0\n\n    return result;\n}\n\nvec3 highPassRandRGB(vec2 uv) {\n    // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n    // hp(x) = x - lp(x)\n    return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n}\n\n// ------------------------------------------------------------------------- //\n\nvec4 floatToColor(float value) {\n    return vec4(value, value, value, 1.0);\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat getShaderToyBackgroundGray(vec2 screenSpaceUV) {\n    return TOY_BG_AVER_GRAY + (rand(screenSpaceUV) - 0.5) * TOY_BG_GRAY_VAR;\n}\n\n// ------------------------------------------------------------------------- //\n\nvec4 renderHSplitLine(vec4 fragColor, vec2 screenSpaceUV, float splitScreenSpaceY) {\n    if (abs(screenSpaceUV.y - splitScreenSpaceY) < SPLIT_LINE_THICKNESS) {\n        return floatToColor(getShaderToyBackgroundGray(screenSpaceUV));\n\t}\n\n    return fragColor;\n}\n\nvec4 renderVSplitLine(vec4 fragColor, vec2 screenSpaceUV, float splitScreenSpaceX) {\n    if (abs(screenSpaceUV.x - splitScreenSpaceX) < SPLIT_LINE_THICKNESS) {\n        return floatToColor(getShaderToyBackgroundGray(screenSpaceUV));\n\t}\n\n    return fragColor;\n}\n\n// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenSpaceUV = fragCoord.xy;\n    vec2 normalizedSpaceUV = screenSpaceUV / iResolution.xy;\n    vec2 repeatedScreenSpaceUV = mod(screenSpaceUV, vec2(TILE_SIZE));\n    vec3 rand = vec3(0);\n\n    if (normalizedSpaceUV.x < V_SPLIT_A) {\n        // analytical noise\n        if (normalizedSpaceUV.y < H_SPLIT_A) {\n            // continuous\n            rand = RGB_NOISE_FUNCTION(screenSpaceUV);\n        } else {\n            // repeated\n            rand = RGB_NOISE_FUNCTION(repeatedScreenSpaceUV);\n        }\n    } else {\n        if ((normalizedSpaceUV.x >= V_SPLIT_A) && (normalizedSpaceUV.x < V_SPLIT_B)) {\n            // high-pass analytical noise\n            if (normalizedSpaceUV.y < H_SPLIT_A) {\n                // continuous\n                rand = highPassRandRGB(screenSpaceUV);\n            } else {\n                // repeated\n                rand = highPassRandRGB(repeatedScreenSpaceUV);\n            }\n        } else {\n            // blue noise\n            if (normalizedSpaceUV.y < H_SPLIT_A) {\n                // continuous\n                rand = texelFetch(iChannel0, ivec2(screenSpaceUV) % 1024, 0).rgb;\n            } else {\n                // repeated\n                rand = texelFetch(iChannel0, ivec2(repeatedScreenSpaceUV) % 1024, 0).rgb;\n            }\n        }\n    }\n\n    // render output\n    fragColor = vec4(rand, 1.0);\n\n    // overlay the split lines\n    fragColor = renderHSplitLine(fragColor, screenSpaceUV, iResolution.y * H_SPLIT_A);\n    fragColor = renderVSplitLine(fragColor, screenSpaceUV, iResolution.x * V_SPLIT_A);\n    fragColor = renderVSplitLine(fragColor, screenSpaceUV, iResolution.x * V_SPLIT_B);\n}\n\n// ------------------------------------------------------------------------- //", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1257, 1298, 1319, 1319, 1393], [1395, 1395, 1418, 1418, 1650], [1733, 1733, 1763, 1894, 2501], [2503, 2503, 2534, 2670, 2734], [2817, 2817, 2849, 2849, 2894], [2977, 2977, 3031, 3031, 3110], [3193, 3193, 3277, 3277, 3452], [3454, 3454, 3538, 3538, 3713], [3796, 3796, 3851, 3851, 5487]], "test": "untested"}
{"id": "tlcfDH", "name": "Floating Errors", "author": "darkeclipz", "description": "Not sure what is going on here but this patterns comes from something going horrible wrong.\ni also wonder why some part of the screen goes black, at seemingly total random times too.\n", "tags": ["artifact"], "likes": 5, "viewed": 330, "published": 3, "date": "1612631266", "time_retrieved": "2024-07-30T19:40:13.223086", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec3 buff = texture(iChannel0, 0.985*(fragCoord/iResolution.xy - 0.5) + 0.5).rgb;\n    vec3 col = vec3(0);\n    \n    float a = fract(iTime)*3.14*2.;\n    float co = cos(a), si = sin(a);\n    uv *= mat2(co, -si, si, co);\n    \n    float t = cos(a)*.5+.5;\n    float d = sdBox(uv, vec2(0.125));\n    \n    col = hsv2rgb(vec3(iTime, 1.0, 1.0)) * 0.000001/(d*d);\n    \n    fragColor = vec4(mix(col, buff, 0.9), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 137]], "test": "untested"}
{"id": "wt3fDH", "name": "tuto: motion blur (dithering)", "author": "FabriceNeyret2", "description": "A simple approx way to account for motion blur is just dithering the time parameter.\nLeft: with Bayer mask. Right: with blue noise.\nOf course, better quality (at cost) if you can sum more than one sample.\nBetter variants: analytical / smart reuse past fra", "tags": ["motionblur", "sampling", "tuto"], "likes": 28, "viewed": 879, "published": 3, "date": "1612629783", "time_retrieved": "2024-07-30T19:40:13.995022", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )  // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,\n          U = ( 2.*u - R ) / R.y;\n    \n    float t = iTime;                                              // --- time dithering\n    if ( U.x < 0.)  t += texture(iChannel0,u/8.).r * iTimeDelta;\n    if ( U.x > 0.)  t += texelFetch(iChannel1,ivec2(u)%1024,0).r * iTimeDelta; // iTimeDelta auto-adapt to real FPS.\n    \n    O-=O;\n    for(float i=0.; i<1.; i+=.1) {                                // --- drawing balls\n       t *= 1.2;\n       P = vec2( 1.2*cos(2.*t), .8*sin(3.1*t) );     \n       O += smoothstep(3./R.y, 0., length(P-U) - .15 ) * hue(i);\n   }\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 146, 146, 733]], "test": "untested"}
{"id": "tt3BDH", "name": "Shifting Landscapes", "author": "icylavah", "description": "Shifting landscapes using simplex noise and a color palette.\nVideo at https://twitter.com/icylavah/status/1358086037461958663", "tags": ["noise", "random"], "likes": 5, "viewed": 397, "published": 3, "date": "1612626449", "time_retrieved": "2024-07-30T19:40:14.760974", "image_code": "// \t<www.shadertoy.com/view/XsX3zB>\n//\tnoise functions by Nikita Miropolskiy\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    \n\t/*vec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;*/\n    \n    return fract(j*vec3(64,8,512)) -.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\nfloat snoiseFractal(vec3 m) {\n\treturn   0.5333333* snoise(m)\n\t\t\t\t+0.2666667* snoise(2.0*m)\n\t\t\t\t+0.1333333* snoise(4.0*m)\n\t\t\t\t+0.0666667* snoise(8.0*m);\n}\n\n// ------\n\n#define fast false // Change to true for faster algorithm with AA\nconst int compareDistance = 4; // >= 1\n\nconst int r2 = compareDistance * compareDistance;\nconst int steps = 6;\nconst vec3 colors[steps] = vec3[](vec3(0.133, 0.223, 0.345), vec3(0.270, 0.458, 0.690), vec3(0.458, 0.725, 0.745), vec3(0.815, 0.839, 0.709), vec3(0.976, 0.709, 0.674), vec3(0.933, 0.462, 0.454));\n\nint getPixelStepi(vec2 pixel, vec2 dimensions, float t) {\n    return min(max(int(((snoiseFractal(vec3(pixel / dimensions.y, t * 0.05)) + 0.5)) * float(steps)), 0), steps - 1);\n}\n\nfloat getPixelStepf(vec2 pixel, vec2 dimensions, float t) {\n    return ((snoiseFractal(vec3(pixel / dimensions.y, t * 0.05)) + 0.5)) * float(steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fast) {\n        float step = getPixelStepf(fragCoord, iResolution.xy, iTime);\n        fragColor = vec4(colors[int(step)],1) * smoothstep(2.,4., abs(fract(step+.5)-.5) / fwidth(step) ) ;\n    } else {\n        int step = getPixelStepi(fragCoord.xy, iResolution.xy, iTime) - 0;\n\n        for (int y = -compareDistance; y <= compareDistance; y++) {\n            for (int x = -compareDistance; x <= compareDistance; x++) {\n                if (x * x + y * y > r2) continue;\n                if (getPixelStepi(fragCoord.xy + vec2(x, y), iResolution.xy, iTime) != step) {\n                    fragColor = vec4(vec3(0.0), 1.0);\n                    return;\n                }\n            }\n        }\n\n        fragColor = vec4(colors[int(step)], 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 151, 173, 173, 400], [460, 460, 482, 482, 1062], [1064, 1064, 1093, 1093, 1217], [1605, 1605, 1662, 1662, 1782], [1784, 1784, 1843, 1843, 1934], [1936, 1936, 1993, 1993, 2743]], "test": "untested"}
{"id": "wt3fW8", "name": "Fast 16x MSAA Squircle", "author": "krh", "description": "Circular ends with squircle transition into straight edge.\n\nManually multisampling the edge pixels in the shader.\n", "tags": ["2d", "squircle"], "likes": 5, "viewed": 499, "published": 3, "date": "1612624840", "time_retrieved": "2024-07-30T19:40:15.524932", "image_code": "vec2 _normalize(vec2 p, vec2 pos, vec2 size, float r) {\n    float x, y;\n\n    if (p.x < pos.x + r)\n        x = p.x - (pos.x + r);\n    else if (p.x < pos.x + size.x - r)\n        x = 0.0;\n    else\n        x = p.x - (pos.x + size.x - r);\n\n    if (p.y < pos.y + r)\n        y = p.y - (pos.y + r);\n    else if (p.y < pos.y + size.y - r)\n        y = 0.0;\n    else\n        y = p.y - (pos.y + size.y - r);\n\n  return vec2(x, y);\n}\n\nfloat dist(vec2 p, float radius) {\n    return p.x * p.x * p.x * p.x + p.y * p.y * p.y * p.y;\n    return p.x * p.x * p.x * p.x * 0.125 + p.y * p.y * radius * radius;\n    // return p.x * p.x * radius * radius + p.y * p.y * p.y * p.y;\n}\n\nfloat squircle_cov(vec2 p, float radius) {\n    float r = radius * radius * radius * radius;\n    float delta = 10.0 * radius * radius * radius;\n    float inner = r - delta;\n    float outer = r + delta;\n\n    float d = dist(p, radius);\n    \n    float cov;\n    if (d < inner) {\n        cov = 1.0;\n    } else if (d > outer) {\n        cov = 0.0;\n    } else {    \n        cov = 0.0;\n        int i,j;\n        float step = 0.25;\n        for (i = 0; i < 4; i++) {\n            for (j = 0; j < 4; j++) {\n                vec2 sp = p - vec2(float(i) - 1.5, float(j) - 1.5) * step;\n                if (dist(sp, radius) < r)\n                    cov += 1.0 / 16.0;\n            }\n        }\n    }\n    \n    return cov;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = trunc(iResolution.y * 0.10);\n    vec2 half_size = vec2(radius * 4.0, radius);\n    vec2 size = half_size * 2.0;\n\tvec2 pos = floor(iResolution.xy / 2.0) - half_size;\n    vec2 uv1 = _normalize(fragCoord.xy, pos + vec2(0.02, iResolution.y / 6.0), size, radius);\n    vec2 uv2 = _normalize(fragCoord.xy, pos - vec2(0.0, iResolution.y / 6.0), size, radius);\n\n    vec3 fg1 = vec3(float(0x5b), float(0xc3), float(0xeb)) / 255.0;\n    vec3 fg2 = vec3(float(0xf0), float(0x64), float(0x49)) / 255.0;\n    vec3 bg =  vec3(float(0x36), float(0x38), float(0x2e)) / 255.0;\n\n    vec3 color;\n    float cov1 = squircle_cov(uv1, radius);\n    float cov2 = squircle_cov(uv2, radius);\n\n    color = mix(mix(bg, fg2, cov2), fg1, cov1);\n    \n    fragColor = vec4(color, 1.0); \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 419], [421, 421, 455, 455, 654], [656, 656, 698, 698, 1356], [1358, 1358, 1415, 1415, 2186]], "test": "untested"}
{"id": "tlcBWH", "name": "Tunneling through apollian frac", "author": "mrange", "description": "Licence CC0: Tunneling through apollian fractals\nThe result of a few hours of saturday coding", "tags": ["2d", "apollian"], "likes": 28, "viewed": 769, "published": 3, "date": "1612623360", "time_retrieved": "2024-07-30T19:40:16.289886", "image_code": "// Licence CC0: Tunneling through apollian fractals\n//  The result of a few hours of saturday coding\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define L2(x)           dot(x, x)\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  return abs(p.y)/scale;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.10*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\nfloat weird(vec2 p, float h) {\n  float z = 4.0;\n  float tm = 0.1*TIME+h*10.0;\n  p *= ROT(tm*0.5);\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh_approx(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp /= z;\n  float d = apollian(pp, 0.8+h);\n  return d*z;\n}\n\nfloat circles(vec2 p) {\n  vec2 pp = toPolar(p);\n  const float ss = 0.25;\n  pp.x = fract(pp.x*ss)/ss;\n  p = toRect(pp);\n  float d = circle(p, 1.0);\n  return d;\n}\n\nfloat onionize(float d) {\n  d = abs(d) - 0.02;\n  d = abs(d) - 0.005;\n  d = abs(d) - 0.0025;\n  return d;\n}\n\nvec2 df(vec2 p, float h) {\n  vec2 wp = p;\n  float rep = 10.0;\n  float ss = 0.05*6.0/rep;\n  float n = smoothKaleidoscope(wp, ss, rep);\n  \n  float d0 = weird(wp, h);\n  d0 = onionize(d0);\n  float d1 = hex(p, 0.25)-0.1;\n  float d2 = circles(p);\n  const float lw = 0.0125;\n  d2 = abs(d2)-lw;\n  float d  = pmin(pmin(d0, d2, 0.1), abs(d1)-lw, 0.05);\n  return vec2(d, d1+lw);\n}\n\n// Plane generating function returns rgba\n//  pp is point on plane\n//  off is path at plane z\n//  aa is estimated pixel size at the plane\n//  n is plane number\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = 0.25*mix(0.5, 0.25, h);\n  float dd= length(pp-ro);\n\n  const vec3 nor  = vec3(0.0, 0.0, 1.0);\n  const vec3 loff = vec3(0.25*0.5, 0.125*0.5, -0.125);\n  vec3 lp1  = ro + loff;\n  vec3 lp2  = ro + loff*vec3(-1.0, 1.0, 1.0);\n  vec3 ld1  = normalize(pp - lp1);\n  vec3 ld2  = normalize(pp - lp2);\n  float lpw1= 0.2/L2(pp - lp1);\n  float lpw2= 0.2/L2(pp - lp2);\n  vec3 ref  = reflect(rd, nor);\n  float ref1= pow(max(dot(nor, ld1), 0.0), 20.0);\n  float ref2= pow(max(dot(nor, ld2), 0.0), 20.0);\n  vec3  col1= vec3(0.75, 0.5, 1.0);\n  vec3  col2= vec3(1.0, 0.5, 0.75);\n  \n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h);\n  vec2 d2 = df(p/s, h)*s;   \n\n  float ha = smoothstep(-aa, aa, d2.y);\n  float d = d2.x;\n  vec4 col = vec4(0.0);\n\n  float l   = length(10.0*p);\n  float ddf = 1.0/((1.0+2.0*dd));\n  float hue = fract(0.75*l-0.1*TIME)+0.3+0.15;\n  float sat = 0.75*tanh_approx(2.0*l)*ddf;\n  float vue = sqrt(ddf);\n  vec3 hsv  = vec3(hue, sat, vue);\n  vec3 bcol = hsv2rgb(hsv);\n  col.xyz   = mix(col.xyz, bcol, smoothstep(-aa, aa, -d));  \n  float glow = (exp(-(10.0+100.0*tanh_approx(l))*10.0*max(d, 0.0)*ddf));\n  col.xyz   += 0.5*sqrt(bcol.zxy)*glow;\n  col.w     = ha*mix(0.75, 1.0, ha*glow);\n  col.xyz   += 0.125*col.w*(col1*ref1+col2*ref2);\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return 1.25*vec3(1.0, 0.75, 0.85)*vec3(tanh_approx(3.0*pow(ld, 100.0)));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 8;\n  const int fadeFrom = max(furthest-3, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.2;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[716, 716, 738, 738, 786], [788, 788, 810, 810, 854], [856, 856, 877, 877, 922], [924, 924, 969, 969, 1123], [1125, 1125, 1186, 1186, 1399], [1401, 1401, 1441, 1441, 1600], [1602, 1602, 1642, 1642, 1684], [1686, 1686, 1714, 1734, 1810], [1812, 1812, 1851, 1851, 1940], [1942, 1942, 1964, 1964, 2133], [2135, 2135, 2168, 2168, 2376], [2378, 2378, 2405, 2405, 2474], [2476, 2476, 2504, 2504, 2704], [2706, 2706, 2737, 2737, 2763], [2936, 2957, 2979, 2979, 3112], [3114, 3193, 3216, 3216, 3291], [3293, 3363, 3387, 3387, 3466], [3648, 3648, 3678, 3678, 4054], [4056, 4056, 4079, 4079, 4216], [4218, 4218, 4243, 4243, 4323], [4325, 4325, 4351, 4351, 4694], [4696, 4856, 4924, 4924, 6229], [6231, 6231, 6264, 6264, 6394], [6396, 6396, 6452, 6452, 7991], [7993, 8020, 8056, 8056, 8289], [8291, 8291, 8320, 8320, 8646], [8648, 8648, 8703, 8703, 8861]], "test": "untested"}
{"id": "ttcBWH", "name": "Explore Sierpinski gasket", "author": "butadiene", "description": "Explore Sierpinski gasket", "tags": ["raymarching", "fractal", "tetrahedron", "sierpinski"], "likes": 5, "viewed": 391, "published": 3, "date": "1612623091", "time_retrieved": "2024-07-30T19:40:17.064815", "image_code": "float PI = acos(-1.);\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<12;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;\n        \n        z *= scale;\n      //  z.xyz = clamp(z.xyz,-1.,1.);\n        z.xyz += offset*(1.0-scale);\n    }\n    \n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\nvec4 dist(vec3 p,float t){\n    float s = 1.;\n    p = abs(p)-4.*s;\n    p = abs(p)-2.*s;\n    p = abs(p)-1.*s;\n\n    vec4 sd = tetcol(p,vec3(1),1.8,vec3(0.));\n    float d= sd.w;\n    vec3 col = 1.-0.1*sd.xyz;\n    col *= exp(-2.5*d)*2.6;\n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n    p.y *= iResolution.y/iResolution.x;\n\n    float rsa =1.2;\n    float time = iTime+17.5;\n    float rkt = time*0.3;\n    vec3 ro = vec3(rsa*cos(rkt)-0.05,2.2*sin(time*0.2)+0.025,rsa*sin(rkt));\n    vec3 ta = vec3(0);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.5*cdir);\n    rd.xz *= rot(time*0.13+1.);\n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    vec3 ac2 = vec3(0.);\n    float frag = 0.;\n    float ep = 0.0005;\n    for(int i = 0;i<66;i++){\n        vec4 rsd = dist(ro+rd*t,t);\n        d = rsd.w;\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n\n    vec3 col = vec3(0);\n    \n    col  =0.04*ac;\n    \tfragColor = vec4(col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 111], [112, 112, 138, 138, 241], [243, 243, 296, 296, 659], [660, 660, 686, 686, 917], [919, 919, 976, 976, 1798]], "test": "untested"}
{"id": "tl3BWH", "name": "floating", "author": "YitingLiu", "description": "Use raymarching to build a simple scene by playing with the light and texture. ", "tags": ["3d", "raymarching", "music", "texture", "light", "sphere", "circle", "camera", "normal", "plane", "diffuse", "shape", "artofcode"], "likes": 2, "viewed": 228, "published": 3, "date": "1612622445", "time_retrieved": "2024-07-30T19:40:17.832761", "image_code": "//tutorial https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n// ray marching/sphere tracing is more more complicated objects\n// ray tracing is for simple objects \n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0,1.5,6.-sin(iTime),1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    float d = min(sphereDist,planeDist);\n    return d; \n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for (int i =0; i<MAX_STEPS; i++){\n    vec3 p = ro+dO*rd;\n    float dS = GetDist(p);\n    dO +=dS;\n    if (dS<SURF_DIST|| dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n   vec2 e = vec2(.01,0.);\n   float d = GetDist(p);\n   vec3 n = d-vec3(\n           GetDist(p-e.xyy),\n           GetDist(p-e.yxy),\n           GetDist(p-e.yyx));\n   return normalize(n);\n}\n\nfloat GetLight (vec3 p){\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l = normalize (lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if (d<length(lightPos-p)) dif*=.1;\n     \n\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    \n    float d= RayMarch(ro,rd);\n\n    vec3 p = ro+rd*d;\n    \n    //get diffused light     \n    float dif = GetLight(p);\n    float colDif = 0.5*abs(sin(iTime));\n    col=vec3(colDif,dif,clamp(dif*dif,0.,0.5));\n    vec3 t= texture(iChannel0, uv*3.*abs(sin(iTime*0.05))).rgb;    \n    col-=GetNormal(p)*t;\n\n    fragColor = vec4(col,1.);\n}\n\n\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 248, 248, 424], [426, 426, 459, 459, 645], [647, 647, 670, 670, 855], [857, 857, 881, 881, 1174], [1177, 1177, 1233, 1233, 1728]], "test": "untested"}
{"id": "wt3fD8", "name": "Day 417 ", "author": "jeyko", "description": "pot", "tags": ["mdtmjvm"], "likes": 15, "viewed": 375, "published": 3, "date": "1612617274", "time_retrieved": "2024-07-30T19:40:18.602703", "image_code": "// influenced by blackle's https://www.shadertoy.com/view/3dXfR2 !!\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.95;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,256.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1.,1.2,1.2));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.5;\n    fragColor.xyz = pow(fragColor.xyz, vec3(0.4545 - n*0.15));\n    \n    \n    \n    \n    \n    fragColor.xyz += smoothstep(1.,0.,length(fragColor))*n*0.35;\n    \n    fragColor.xyz -= smoothstep(0.,1.,length(fragColor))*n*0.15;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nmat3 getOrthogonalBasis(vec3 dir){\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\nfloat cyclicNoise(vec3 p){\n    \n    //p.yz *= rot(1.4);\n    \n    float n = 0.;\n    float amp = 1.;\n    float gain = 0.5;\n    float lac = 1.3 ;\n    \n    vec3 seed = normalize(vec3(3,-1,2));\n    mat3 rotm = getOrthogonalBasis(seed);\n\n    for(int i = 0; i < 5; i++){\n        p -= cos(p.zxy*1.5*gain*2. + iTime)*0.1;\n        n += (dot(sin(p), cos(p.zxy)))*amp;\n    \n        amp *= gain;\n        p *= lac*rotm;\n\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 oouv = uv;\n    \n    \n    uv *= 0.7;\n    vec3 col = vec3(0);\n    \n    float n = cyclicNoise(vec3(uv*5.,iTime*0.5));\n    \n    n = cyclicNoise(vec3(uv*10. + n*1.15,iTime));\n        \n        \n    float nb = cyclicNoise(vec3(uv*5.,iTime));\n        \n        \n    \n    \n    float vn = valueNoise(iTime/2.,5.);\n    float vnb = valueNoiseStepped(iTime/2. + n*0.4*pow(vn,4.) + 5.,2.,4.);\n    float vnc = valueNoiseStepped(iTime/8.,4.,4.);\n    \n        \n    uv.x += (n*2. - 1.)*0.02;\n    uv.y += (nb*2. - 1.)*0.4;    \n    \n    float dfuv = fwidth(uv.x);\n    \n    float dfn = dFdx(n);\n    \n    uv.x = pmod(uv.x,0.04 - vn*0.02);\n    //uv *= .6;\n    \n    \n    float d = abs(uv.x);\n    vec2 oouvb = oouv; \n    oouv *= rot(pi*vnb);\n    \n    float w = vn*0.3;\n    oouv = abs(oouv) - w;\n    float db = max(oouv.x, oouv.y);\n    \n     \n    oouvb *= rot(-pi*vnb);\n    \n    oouvb = abs(oouvb) - w;\n    float dc = max(oouvb.x, oouvb.y);\n    \n    \n    dc = abs(dc) - vnc*0.;\n    \n    \n    db = xor(db,abs(dc - 0.1*vnc) - vn*0.1 , +0.0);\n    db -= 0.01;\n    float lineW =  0.001 + smoothstep(fwidth(db)*15., 0., db)*0.004;\n    \n    \n    //ouv = pmod(ouv,0.2);\n    \n    col += smoothstep(dfuv*(1. + sin(iTime + uv.x)*0.4 + 0.4),0.,d - lineW);\n    \n    \n    if(floor(mod(iTime/2.,2.)) == 0. ){\n        col = 1. - col;\n    }\n    \n    \n    col = mix(col,1.- col, smoothstep(fwidth(oouv.x)*1., 0., db));\n    \n    col = mix(col, 1. - col, \n        step(0.6,valueNoiseStepped(iTime*25.,2.,4.)) *\n        step(0.2,valueNoiseStepped(iTime*2.5,2.,2.))\n        \n        );\n    \n    fragColor = vec4(col,1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float sc = 0. + valueNoise(iTime*18.,2.)*0.2;\n    \n    fragColor.x =texture(iChannel0,(fragCoord + sc*vec2(0,8))/iResolution.xy).x;\n    \n    fragColor.y =texture(iChannel0,(fragCoord + sc*vec2(0,-1))/iResolution.xy).y;\n    \n    fragColor.z =texture(iChannel0,(fragCoord + sc*vec2(0,-4))/iResolution.xy).z;\n    \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 127, 936]], "test": "untested"}
{"id": "WtcfDH", "name": "2D SpotLight Formula", "author": "cwook", "description": "Simple 2D spotlight shader. Click to point light.", "tags": ["2d", "simple", "light", "spotlight"], "likes": 3, "viewed": 496, "published": 3, "date": "1612592151", "time_retrieved": "2024-07-30T19:40:19.438468", "image_code": "\n// uncomment  to point light at the center of the screen, otherwise rotate light with time\n//#define POINT_TO_CENTER\n\nfloat PI = 3.141592653589793238462643;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // length of light based on sin(time)\n    float lightLength = 1.f;//(1.2 + sin(iTime * 1.5)) * 0.5;\n    \n    float angle = 25.0;\n    float angleTwo = 3.0;\n    \n    // set light position to mouse position in uv coordinates\n    vec2 lightpos = vec2(cos(iTime) * 0.25 + 0.5, sin(iTime) * 0.25 + 0.5);//iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // used to fix aspect ratio\n    float off = iResolution.x / iResolution.y;\n    \n    // distance from light position to uv position\n    vec2 disp = (uv - lightpos);\n    disp.x *= off;\n    \n    vec2 dir;\n    \n#ifdef POINT_TO_CENTER\n    dir = vec2(0.5) - lightpos;\n    dir /= length(dir);\n#else\n    dir = vec2( iMouse.x / iResolution.x, iMouse.y / iResolution.y ) - lightpos;\n    dir /= length(dir);\n#endif\n    \n    // radial distance fade\n    vec3 col = vec3( pow( clamp( (1.0 - length(disp) / lightLength), 0.0, 1.0 ), 1.5 ) );\n    \n    // map radians to 0-1 space\n    \n    // angular distance fade\n    // dot product\n    float dotp = clamp( dot( dir, disp / length(disp) ), 0.0, 1.0);\n    // convert desired angle to 0-1 space\n    float div = 1.0 - angle / 180.0;\n    // smoothstep remaps 0-1 range to div-1\n    float d = smoothstep(div, 1., dotp);\n    // convert angleTwo to 0-1 space\n    div = 1.0 - angleTwo / 180.0;\n    // smoothstep remaps 0-1 range to div-1\n    float d2 = smoothstep(div, 1., dotp);\n    \n    // combine radial and angular distance fade\n    // also adjust intensity and color if desired\n    col *= pow(d,1.0) * vec3(0.75,0.75,0.75) + pow(d2,4.0) * vec3(2.5,1.,1.);\n    \n    // screen texture\n    vec4 screen = texture(iChannel0, uv * 1.850);\n    \n    // combine screen with light mask\n    fragColor = screen * vec4(col,1.0);\n    \n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 216, 258, 2026]], "test": "untested"}
{"id": "3t3fDH", "name": "Shewsdu Einarinarinarieu", "author": "404Glaciergargamel", "description": "The director's cut edition of Seusenarnarnareu: [url]https://www.shadertoy.com/view/3s3BD2[/url] The original version of the game was too easy, so 404Gg made it VERY HARD legit! This game is for pros, you losers! lol", "tags": ["3d", "raymarching", "game", "retro", "text", "remix", "glitch", "fork", "keyboard", "weird", "ui", "hard", "rave", "90", "80", "multipass", "arcade", "synthwave"], "likes": 1, "viewed": 309, "published": 3, "date": "1612590195", "time_retrieved": "2024-07-30T19:40:20.641253", "image_code": "// Hacked and cracked by Urban Club Professional!\n\n\nvec3 fxaa( vec3 color )\n{\n\t// FXAA implementation by mudlord (I think?)\n    vec3 luma = vec3(0.399, 0.687, 0.214);\n\tvec2 pp = 1.0 / R.xy;\n    float lumaNW = dot(texture(iChannel0, (F.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (F.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (F.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (F.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.35 * (2.0/9.0)), (2.0/228.0));\n\n    float rcpDirMin = 3.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(9.0, 9.0),\n              max(vec2(-9.0, -9.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.6 * (\n        texture(iChannel0, F.xy * pp + dir * (2.0 / 4.0 - 0.6)).xyz +\n        texture(iChannel0, F.xy * pp + dir * (3.0 / 3.0 - 0.6)).xyz);\n    vec3 rgbB = rgbA * 0.6 + 0.35 * (\n        texture(iChannel0, F.xy * pp + dir * -0.6).xyz +\n        texture(iChannel0, F.xy * pp + dir * 0.6).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        return rgbA;\n    } else {\n        return rgbB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.5 );\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n    float bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.3 ) return;\t\n#endif // FORCED_RATIO\n       \n    fragColor = texture( iChannel0, vec2( uv ) );\n\n#ifdef FXAA\t\n\tfragColor.rgb = fxaa( fragColor.rgb );\n#endif\n\n#ifdef NOISE\n    fragColor.rgb *= 0.9 + 0.3 * hash22( 2000.0 * ( F.xy / R.xy + fract( iTime ) ) ).x;\n#endif\n\n#ifdef FPS_COUNTER    \n    vec2 h = F.xy / R.xy;\n    h.x *= R.x / R.y;\n    fragColor.rgb += printInt( ( h -vec2( 0.0, 0.31 ) ) * 40.0, iFrameRate );\n#endif \n\n    // gamma\n\tfragColor.rgb = pow( fragColor.rgb, vec3( 0.5545 ) );\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hacked and cracked by Urban Club Professional!\n\n\nAppState updateGame( AppState s, float isDemo )\n{\n    if ( isDemo > 0.0 )\n    {\n        s.timeAccumulated += 5.5 * iTimeDelta;\n    \ts.playerPos.y = 32.5 * s.timeAccumulated;\n    }\n    else\n    {\n        float playerCellID = floor( s.playerPos.y );\n        s.paceScale = saturate( ( playerCellID - 60.0) / 400.0);\n        float timeMultiplier = mix( 0.85, 3.0, pow( s.paceScale, 2.0 ) );\n\n        s.timeAccumulated += timeMultiplier * iTimeDelta;\n        s.playerPos.y = 6.0 * s.timeAccumulated;\n    }    \n    \n    float playerCellID = floor( s.playerPos.y );\n\n    if ( isDemo > 0.0 )\n    {           \n        float cellOffset = 2.0;\n        float nextPlayerCellID = playerCellID + cellOffset;\n\n        float nextCellCoinRND = hash11( nextPlayerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n        nextCellCoinRND *= mix( 2.0, -2.0, step( mod( nextPlayerCellID, 5.0 ), 2.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n        nextCellCoinRND = mix( nextCellCoinRND, -2.0, step( nextPlayerCellID, 6.0 ) ); // head start\n        float nextCellCoinCol = floor( 4.0 * nextCellCoinRND );\n\n        // OBSTACLE\n        float nextCellObsRND = hash11( 200.0 * nextPlayerCellID + s.seed );\n        nextCellObsRND *= mix( 2.0, -2.0, step( mod( nextPlayerCellID, 4.0 ), 2.5 ) );\n        nextCellObsRND = mix( nextCellObsRND, -2.0, step( nextPlayerCellID, 8.0 ) ); // head start\n        float nextCellObsCol = floor( 3.0 * nextCellObsRND );\n        \n        float inputObs = 0.1;                \n        if ( nextCellObsCol > -0.6 )\n        {\n            nextCellCoinCol -= 0.6; // pos fix\n        \tfloat toObs = nextCellObsCol - s.playerPos.x;\n        \n            if ( nextCellObsCol == 1.0 )\n                inputObs = hash11( nextPlayerCellID + s.seed );\n            \n            if ( nextCellObsCol < 1.0 )\n                inputObs = 2.0;\n\n            if ( nextCellObsCol > 1.0 )\n                inputObs = -2.0;\n        }\n        \n        \n        float inputCoin = 0.0;\n        if ( nextCellCoinCol > -0.5 )\n        {               \n            nextCellCoinCol -= 0.5; // pos fix\n            float toCoin = nextCellCoinCol - s.playerPos.x;\n            \n\t\t\tinputCoin = sign(toCoin) * saturate( abs( toCoin ) );\n        }\n\n        float inputDir = inputCoin + 5.0 * inputObs;\n        inputDir = sign( inputDir ) * 4.0 * saturate( abs( inputDir ) );\n        \n        s.isPressedLeft  = step( 0.5, -inputDir );\n        s.isPressedRight = step( 0.5,  inputDir );\n    }\n\n    float speed = mix( 0.1, 0.15, isDemo );\n    s.playerPos.x -= speed * s.isPressedLeft; \n    s.playerPos.x += speed * s.isPressedRight; \n\n    s.playerPos.x = clamp( s.playerPos.x, -0.5, 1.5 );\n\n    if ( playerCellID != s.coin0Pos ) \n    {\n        s.coin3Pos \t = s.coin2Pos;\n        s.coin3Taken = s.coin2Taken;\n\n        s.coin2Pos \t = s.coin1Pos;\n        s.coin2Taken = s.coin1Taken;\n\n        s.coin1Pos \t = s.coin0Pos;\n        s.coin1Taken = s.coin0Taken;\n\n        s.coin0Pos = playerCellID;\n        s.coin0Taken = 0.0;\n    }\n \n    // COIN start\n    float cellCoinRND = hash11( playerCellID + s.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellCoinRND *= mix( 1.0, -1.0, step( mod( playerCellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( playerCellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n\n    vec2 coinPos = -vec2( 0.0, playerCellID )\t// cell pos\n        +vec2( 0.5, -0.5 )\t// move to cell center\n        -vec2( cellCoinCol, 0.0 ); // move to column\n\n    if ( cellCoinRND >= 0.0 )\n    {        \n        float distCoinPlayer = length( coinPos + s.playerPos );\n\n        if ( distCoinPlayer < 0.5 && s.coin0Taken < 0.5 )\n        {\n            if ( isDemo < 1.0 )\n            \ts.score++;\n            \n            s.coin0Taken = 1.0;\n            s.timeCollected = iTime;\n        }\n    }\n    // COIN end\n\n    // OBSTACLE start\n    float cellObsRND = hash11( 100.0 * playerCellID + s.seed );\n    cellObsRND *= mix( 1.0, -1.0, step( mod( playerCellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( playerCellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {   \n        vec2 obstaclePos = -vec2( 0.0, playerCellID )\t// cell pos\n            +vec2( 0.5, -0.25 )\t// move to cell center\n            -vec2(cellObsCol, 0.0 ); // move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n\n        if ( distObstaclePlayer < 0.5 && isDemo < 1.0 )\n        {\n            s.timeFailed = iTime;\n            s.timeCollected = -1.0;\n            s.highscore = max( s.highscore, s.score );\n        }\n    }\n    // OBSTACLE end        \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    s.showUI = mod( s.showUI + texelFetch( iChannel1, ivec2( ASCII_U, 1 ), 0 ).x, 2.0 );\n    float isSpacePressed = texelFetch( iChannel1, ivec2( ASCII_SPACE, 1 ), 0 ).x;\n   \n  \t// read keys that people usually press\n    // https://www.shadertoy.com/view/lsXGzf\n    float keyLeft = 0.0;\n    for ( int i = 0; i < keysLeft.length(); ++i )\n        keyLeft = max( keyLeft, texelFetch( iChannel1, ivec2( keysLeft[i], 0 ), 0 ).x );\n    \n\ts.isPressedLeft = keyLeft;    \n            \n    float keyRight = 0.0;\n    for ( int i = 0; i < keysRight.length(); ++i )\n        keyRight = max( keyRight, texelFetch( iChannel1, ivec2( keysRight[i], 0 ), 0 ).x );\n    \n    s.isPressedRight = keyRight;    \n       \n    if ( s.stateID == GS_SPLASH ) // splash\n    {                             \n        if ( isSpacePressed > 0.5 || s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 )\n        {\n            s = setStateStartGame( s, iTime );\n            s.stateID = GS_GAME;            \n            s.timeStarted = iTime;\n            s.timeAccumulated = 0.0;\n            s.seed += iTime;\n        }\n        else\n        {\n            s = updateGame( s, 1.0 );\n        }        \n    }\n    else if ( s.stateID == GS_GAME ) // game\n    {\n        if ( s.timeFailed > s.timeStarted )\n        {   \n            if ( iTime > s.timeFailed + 1.0 \n                && ( s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 ) )\n            {            \n            \ts.timeStarted = iTime;\n                s.timeFailed = -1.0;\n            }\n                        \n            if ( iTime > s.timeFailed + 5.0 )\n            {                \n                s = setStateStartGame( s, iTime );\n                s.stateID = GS_SPLASH;\n            }\n            \n            s.isPressedLeft = 0.0;\n            s.isPressedRight = 0.0;\n        }\n        else\n        {\n            s = updateGame( s, 0.0 );\n        }\n    }\n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nAppState g_S;\n\nfloat g_glowCoin = 2e10;\nfloat g_glowCoinRefl = 2e10;\nfloat g_glowEnemy = 2e10;\nfloat g_glowEnemyRefl = 2e10;\nfloat g_glowPlayer = 2e10;\nfloat g_glowPlayerRefl = 2e10;\nfloat g_glowPlayerFront = 2e10;\nfloat g_glowPlayerLights = 2e10;\nfloat g_cameraMode = 0.0;\n\nconst float GRID_SIZE = 0.5;\nconst float GRID_LINE_SIZE = 1.25;\n\nconst float GRID_CAR_SIZE = 0.5;\nconst float GRID_CAR_LINE_SIZE = 1.5;\n\nconst vec3 GRID_COLOR_1 = vec3(0.30, 0.03, 0.00);\nconst vec3 GRID_COLOR_2 = vec3(3.600, 22.20, 2.40)/555.;\n\nconst vec3 SUN_DIRECTION = vec3(0.6, 0.035, 0.0);\nconst vec3 SKY_COLOR_1 = vec3(59., 76., 43.)/355.;\nconst vec3 SKY_COLOR_2 = vec3(0.30,0.03,0.00);\n\nconst vec3 SUN_COLOR_1 = vec3(0.4, 0.2, 0.4) * 0.6;\nconst vec3 SUN_COLOR_2 = vec3(0.2, 0.2, 0.2) * 0.6;\n\nconst vec3 CAR_COLOR_1 = vec3(0.6, 0.2, 0.6) * 0.0;\nconst vec3 CAR_COLOR_2 = vec3(0.0, 0.2, 0.2) * 2.5;\n\nconst vec3 CAR_PLAYER_COLOR_1 = vec3(0.6, 0.6, 0.2) * 0.2;\nconst vec3 CAR_PLAYER_COLOR_2 = vec3(0.6, 0.6, 0.2) * 2.5;\n\nconst vec3 FOG_COLOR = vec3(293.0, 223.00, 134.0)/555.;\n\n\nstruct sHit {\n    float t;\n    float m;\n    vec3 lPos;\n};\n    \nsHit createHit( float t, float m, vec3 lPos )\n{\n    sHit h;\n    h.t = t;\n    h.m = m;\n    h.lPos = lPos;\n    return h;\n}\n\nvoid drawCoin( inout vec3 color, vec2 p, vec2 coinPos )\n{  \n    float sCoin = length(\n        p\n        -vec2( 0.0, coinPos.y )\t// cell pos\n        +vec2( 0.5, -0.5 )\t\t// move to cell center\n        -vec2( coinPos.x, 0.0 ) // move to column\n    ) - 0.25; \t\t\t\t\t// radius of coin\n\n    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );\n}\n\nvoid drawGameFlat( inout vec4 color, vec2 p, AppState s )\n{\n    // game\n\tvec2 p0 = p;    \n    // float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );\n    float cameraAnim = 0.0;\n\tp0 *= mix( 5.0, 10.0, cameraAnim );\t\t// scale field of view\n    p0.x += 0.25;\t\t\t\t\t\t\t// fix track centering\n    p0.y += mix( 2.0, 8.0, cameraAnim );\t// move camera pos\n    p0.y += s.playerPos.y;\n    \n    float playerCellID = floor( s.playerPos.y );\n    float sPlayer = length( p0 - s.playerPos ) - 0.25;\n           \n    vec2 p1 = p0;\n    p1.y += 2.0 * s.playerPos.y;\n    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );\n    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );\n       \n\t// COIN start\n    float cellID = floor( p0.y );\n    float cellCoinRND = hash11( cellID + g_S.seed );\t\t\t\t\t// skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 2.0, -2.0, step( mod( cellID, 5.0 ), 2.5 ) );\t// gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -2.0, step (cellID, 6.0 ) );\t\t// head start\n    float cellCoinCol = floor( 4.0 * cellCoinRND );\n       \n    if ( cellCoinRND >= 0.0 )\n    {\n        if ( cellID > playerCellID )\n           \tdrawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID && s.coin0Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n       \n        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n    }    \n// COIN end\n\n// OBSTACLE start\n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );\t\t// skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 2.0, -2.0, step( mod( cellID, 4.0 ), 2.5 ) );\n    cellObsRND = mix( cellObsRND, -2.0, step( cellID, 8.0) );\t// head start\n    float cellObsCol = floor( 4.0 * cellObsRND );\n    \n\tif ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {        \n    \tfloat sObstacle = length(\n            p0\n            -vec2( 0.0, cellID )\t\t// cell pos\n            +vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            -vec2( cellObsCol, 0.0 )\t// move to column\n        ) - 0.25;\t\t\t\t\t\t// radius of coin\n        \n    \tcolor.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );\n        \n        vec2 obstaclePos = -vec2( 0.0, cellID )\t\t\t// cell pos\n            \t\t\t\t+vec2( 0.5, -0.5 )\t\t\t// move to cell center\n            \t\t\t\t-vec2( cellObsCol, 0.0 );\t// move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n        \n        if ( distObstaclePlayer < 0.5 ) \n        {\n            color.rgb += vec3( 0.5 );\n        }\n    }\n    \n    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );\n\n// OBSTACLE end        \n\n}\n\nfloat circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1. ) * r;\n}\n\nvoid opRotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nsHit opUS( sHit d1, sHit d2 )\n{\n    if ( d1.t < d2.t )\n        return d1;\n    else \n        return d2;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n   \tp = vec3( p.z, p.x, -p.y ); // Coord fix\n    // n must be normalized\n          \n    vec3 p0 = vec3(p.x, p.y, p.z);\n\n    float fgProf = 0.3 * smoothstep( 2.5, 3.0, abs( p0.y ) );\n    float bgProf = 2.0 * smoothstep( 4.5, 5.5, abs( p0.y ) );\n    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy / 10. ).r, 0.0, 1.0 );\n    float bg = 0.2 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy / 50.).r, 0.0, 2.0 );\n    float displace = 1.5 * fg + 3.5 * bg;\n    \n    float sGround = dot(\n        vec3( p.x, p.y, max( p.z + displace, p.z ) ),\n        n.xyz )\n        + n.w;\n    \n    sGround *= 0.5;\n    \n  \treturn sGround;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\nfloat opUnion( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat opIntersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat opSubstract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat opSubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn( vec3 p, float r, float id )\n{\n    return vec2( ( ( abs( p.x ) + abs( p.y ) ) - r ) / sqrt( 2.0 ), id );\n}\n\nfloat sdCoin( vec3 p, float id )\n{       \n    float sCyl = cylinder( p.yzx, 0.1, 0.02 );    \n\n    if ( id == 2.0 )\n        g_glowCoin = min( g_glowCoin, sCyl );\n    \n    if ( id == 12.0 )\n    \tg_glowCoinRefl = min( g_glowCoin, sCyl );\n    \n    return sCyl;\n}\n\n// From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\nfloat car( vec3 p, float id )\n{        \n    p *= 6.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.4;\n    \n    float a = box( p, vec3( 5.2, 1.0, 2.8 ) );   \n    \n    vec3 t = p + vec3( -7.0, 0.0, 0.0 );\n    opRotate( t.yx, 0.3 );\n    float b = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -6.0, 0.0, 0.0 );\n    opRotate( t.yx, -0.5 );\n    float c = plane( t, vec4( 0.0, 2.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 3.0, -0.3, 0.0 );\n    opRotate( t.yx, -0.5 );\n    float d = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 3.0, -0.4, 0.0 );\n    opRotate( t.yx, -0.06 );\n    float e = plane( t, vec4( 0.0, -2.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 3.0, 2.0, 0.0 );\n    opRotate( t.yx, 0.3 );\n    float f = plane( t, vec4( 0.0, 2.0, 0.0, 0.0 ) );     \n        \n    if ( id == 2.0 )\n    {\n        float bloomF = box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n        t.z = abs( t.z );\n        t.z -= 1.5;       \n        float bloomB = box( t + vec3( -4.4, -0.2, 0.0 ), vec3( 0.2, 0.4, 0.2 ) );\n    \tg_glowPlayer = min( g_glowPlayer, 1.0 / 5.5 * min( bloomF, bloomB ) );\n    }\n    \n    if ( id == 3.0 )\n        g_glowEnemy = min( g_glowEnemy, 1.0 / 5.5 * box( t + vec3( -2.0, 0.7, 0.0 ), vec3( 3.0, 1.0, 1.0 ) ) );\n\n    t = p + vec3( 1.0, -0.6, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float frontWindow = box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float backWindow = box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = opSubstract( a, opUnion( opUnion( opUnion( b, c ), opIntersect( d, e ) ), f ) );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    opRotate( t.yz, -0.9 );\n    float sideCutPlanes = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = opSubstractChamfer( body, opUnion( backWindow, frontWindow ), 0.1 );\n    body = opSubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.65 );\n    float wheel = cylinder( t, 0.7, 1.0 );\n    body = opSubstract( body, wheel );\n    t.y -= .1;\n    wheel = opSubstract( cylinder( t, 0.6, 0.3 ), sphere( t + vec3( 0.0, -0.45, 0.0 ), 0.45 ) );\n    \n    body = opUnion( body, wheel );\n    \n    body /= 5.5;\n    \n    return body;\n}\n\nfloat carFront( vec3 p, float id )\n{        \n    // front lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float front = cylinder( p.zxy + vec3( -0.06, -0.77, -0.02 ), 0.05, 0.01 );\n    \n    if ( id == 1.5 )\n        g_glowPlayerFront = min( g_glowPlayerFront, front );\n       \n    return front;\n}\n\nfloat carLights( vec3 p, float id )\n{        \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerLights = min( g_glowPlayerLights, back );\n       \n    return back;\n}\n\n\nfloat carRefl( vec3 p, float id )\n{        \n    float body = box( p + vec3( 0.0, -0.07, 0.0 ), vec3( 0.6, 0.02, 0.2) );\n    body = min( body, box( p + vec3( 0.2, -0.1, 0.0 ), vec3( 0.4, 0.02, 0.2 ) ) );\n    \n    // back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float bloom = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );    \n    \n    bloom = min( bloom, body );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerRefl = min( g_glowPlayerRefl, bloom );\n    \n    if ( id == 3.5 )\n        g_glowEnemyRefl = min( g_glowEnemyRefl, bloom );\n       \n    return body;\n}\n\nvec2 getBent()\n{\n    float bentSide\t= sin( g_S.timeAccumulated / PI );\n    float bentUp\t= ( ( cos( 0.25 * g_S.timeAccumulated / PI ) * 0.5 ) + 0.5 ) * 1.5;\n    return vec2( bentSide, bentUp );\n}\n\nsHit map( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, 0.0, pos );\n\n\t// player, in place in fact\n    vec2 bent = getBent();\n    \n    // game\n    vec3 p0 = pos;    \n    // bending    \n    p0.x -= 1.4 * sin( 0.06 * p0.z * PI ) * bent.x;\n    p0.y += 1.4 * sin( 0.06 * p0.z * PI ) * bent.y;\n   \n    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );\n    \n    pPlayer.xz *= rot(  0.3 * bent.x );\n    pPlayer.yz *= rot( -0.3 * bent.y );\n    // sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); // debug collider\n    \n\tfloat rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;\n    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;    \n    pPlayer.xz *= rot( -0.02 * PI * bent.y + rotY -0.6 * PI );\n    pPlayer.yz *= rot( -0.02 * PI * bent.x + rotX );\n    // pPlayer.yz *= rot( -10.0*iTime ); // mothman\n    pPlayer.y += 0.05;    \n    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );\n\tsRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );\n    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );\n    \n    vec3 pEnv = p0;\n    pEnv.z += 3.0 * g_S.playerPos.y;\n    pEnv.x -= 0.6;\n    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -2, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );\n    \n    p0.z *= 0.6;\n    p0.z += g_S.playerPos.y;\n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.6, 2.0 ) - 0.6;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if (cellCoinRND >= 0.0)\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        // sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); // debug colider\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );\n        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );\n        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );\n    }\n\n    return sRes;\n}\n\nsHit mapRefl( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, -1.0, pos );\n\n    vec2 bent = getBent();\n    vec3 p0 = pos;    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;\n   \n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );\n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);\n    pPlayer.y += 0.05;\n\tsRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );\n\n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;      \n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    // COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if ( cellCoinRND >= 0.0 )\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );\n    }\n\n    return sRes;\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nsHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 25.0 ), rd, vec3( 8.0, 5.0, 55.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 228 && t < tmax; i++ )\n        {\n            sHit h = map( ro + rd * t );\n            if( abs( h.t ) < ( 0.002 * t ) )\n            { \n                // res = vec2(t,h.y); \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n    \n    return sRes;\n}\n\nsHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    // raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 6.0 ), rd, vec3( 5.0, 5.0, 35.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 42 && t < tmax; i++ )\n        {\n            sHit h = mapRefl( ro + rd * t );\n            if( abs( h.t ) < ( 0.002 * t ) )\n            { \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n\n    return sRes;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    // vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 e = vec2( 2.0, -2.0 ) * 0.6773 * 0.02;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 2; i++ )\n    {\n        vec3 e = 0.6773*(3.0*vec3((((i+4)>>2)&2),((i>>2)&2),(i&2))-2.0);\n        n += e * map( pos + 0.0006 * e ).x;\n    }\n    return normalize( n );\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 2.0;\n    for( int i = ZERO; i < 5; i++ )\n    {\n        float hr = 0.02 + 0.22 * float( i ) / 5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -( dd - hr ) * sca;\n        sca *= 1.05;\n    }\n    return clamp( 2.0 - 4.0 * occ, 0.0, 2.0 ) * (0.6 + 0.6 * nor.y );\n}\n\nvec3 getSkyColor( vec3 rd )\n{\n    vec3 color = mix( SKY_COLOR_1 * 2.4, SKY_COLOR_2, rd.y / 10.0 );\n\t\n    float fogFalloff = clamp( 9.0 * rd.y, 0.0, 2.0 );\n    color = mix( FOG_COLOR, color, fogFalloff );\n    color = mix( color, GRID_COLOR_1, smoothstep( -0.2, -0.3, rd.y ) );\n\n    vec3 sunDir = normalize( SUN_DIRECTION );\n    float sunGlow = smoothstep( 1.0, 2.0, dot( rd, sunDir ) );\n        \n    rd = mix( rd, sunDir, -2.0 ); // easier to bend vectors than fiddle with falloff :P\n    float sun = smoothstep( 1.087, 1.09, dot(rd, sunDir ) );\n    sun -= smoothstep( 0.2, 1.0, 0.6 );\t\t\t        \n    \n    float stripes = mod( 60.0 * ( pow( rd.y + 0.25, 2.5 ) ) + 0.6, 2.0 ) -0.6;\n    stripes = smoothstep( 0.3, 0.31, abs( stripes ) );\n        \n    \n    // based on https://www.shadertoy.com/view/tssSz7\n    vec2 starTile   = floor( rd.xy * 50.0 );\n    vec2 starPos    = fract( rd.xy * 50.0 ) * 3.0 - 2.0;\n    vec2 starRand = hash22( starTile );\n    starPos += starRand * 3.0 - 2.0;\n    float stars = saturate( 2.0 - ( ( sin( iTime * 2.0 + 60.0 * rd.y ) ) * 0.6 + 7.0 ) * length( starPos ) );\n    stars *= step( 0.1, -sun );\n    stars *= step( 1.0, starRand.x );\n    stars *= 6.0;\n           \n    sun = 3.0 * clamp( sun * stripes, 0.0, 2.0 );\n    \n    vec3 sunCol = 4.0 * mix( SUN_COLOR_1, SUN_COLOR_2, -( rd.y - 0.2 ) / 0.4 );\n    color = mix( color, sunCol, sun );\n\n\tcolor = mix( FOG_COLOR, color, 0.9 + 0.3 * fogFalloff );\n    color = mix( color, sunCol, 0.35 * sunGlow );\n    \n    color += stars;\n\n    // return vec3(stripes);\n    // return vec3(sun);\n    // return vec3(sunGlow);\n    return color;\n}\n\nvec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )\n{       \n    vec2 bent = getBent();\n    // repeat car rotation with fixes\n    float rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;\n    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n\n    vec3 albedo = vec3( 0.6 );\n    float met = 2.0;\n    vec4 color = vec4( albedo, met );\n    vec3 emissive = vec3( 0.1 );\n        \n    if ( m == 0.0 )\n    {\n        vec2 p0 = lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1.) / GRID_SIZE;\n        \n    \talbedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE / GRID_SIZE, gln ) );\n        \n        float pSideLine = lPos.x;\n\t\tpSideLine = abs( pSideLine );\n        pSideLine -= 1.45;\n        pSideLine = abs( pSideLine );\n        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );\n        \n        float pCenterLine = lPos.x;\n\t\tpCenterLine = abs( pCenterLine );\n        pCenterLine -= 0.55;\n        pCenterLine = abs( pCenterLine );\n        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );\n        \n        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;\n        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );\n        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );\n        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );\n               \n        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.6, lPos.z - 3.0 * g_S.playerPos.y );\n        pTrail.x += 5.0 * rotY; // move the cos\n        pTrail.x -= 5.0 * rotY * ( cos( 0.85 * pTrail.y - 0.2 * PI ) * 0.6 + 0.6 ); // fake car turns\n        pTrail.x = abs( pTrail.x );\n        pTrail.x -= 0.38;\n        pTrail.x = abs( pTrail.x );\n               \n        float trailMask = exp( -40.0 * pTrail.x );\n        trailMask += 0.2 * saturate( exp( -5.0 * pTrail.x ) );\n        trailMask *= saturate( -pTrail.y + 0.6 );\t\t// clamp on Y\n        trailMask *= saturate(  pTrail.y * 0.6 + 2.5 );\t// clamp on Y\n        emissive += vec3( 2.5, 0.3, 0.0 ) * trailMask;       \n    }\n    \n    if ( m == 1.0 )\n    {\n        vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );\n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n        \n        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );\n        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );\n        \n        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );\n        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );\n    }\n    \n    if ( m == 1.5 )\n    {\n        emissive = albedo = vec3( 1.5, 0.5, 0.5 );\n    }\n    \n    if ( m == 1.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.5 );\n    }\n    \n    if ( m == 2.0 )\n    {\n        albedo = vec3( 1.0, 1.0, 0.5 );\n        emissive = 10.0 * albedo;\n    }\n    \n    if ( m == 3.0 )\n    {\n       vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );         \n        uv /= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;\n        \n        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );\n    }\n    \n    if ( m == 3.5 )\n    {\n        emissive = albedo = vec3( 1.0, 0.5, 0.5 );\n    }\n    \n    if ( m == 3.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.0 );\n    }\n\n    if ( m == 4.0 )\n    {\n        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );\n    }\n            \n\t// spotlight, paramteres-\n    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );\n    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );\n    pSpot -= perSpotOffset;\n    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    vec3 spotColor  = 20.0 * vec3( 0.2 );\n    \n    pSpot.yz *= rot( -0.2  * bent.y );\n    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );\n    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );\n    spotDir.yz *= rot( 0.2 * bent.y );\n    spotDir.xz *= rot(-0.2 * rotY );\n    spotDir.yz *= rot(-0.2 * rotX );\n    \n    // spotlight, color\n    float maskDist = fract( ( length( pSpot ) - 2.0 ) );\n    float spotAtt = 0.2 / pow( 2.0 * length( pSpot ), 3.0 );\n    spotAtt *= smoothstep( 0.2, 1.1, dot( normalize( pSpot ), spotDir ) );\n    spotAtt *= saturate( dot( -nor, spotDir ) );\n    emissive += albedo * spotColor * spotAtt;    \n        \n    float fre = pow( 0.4 * ( 0.9 + dot( nor, rd ) ), 3.0 );\n    float amb = clamp( 0.6 + 0.6 * nor.y, 0.0, 2.0 );\n    float occ = calcAO( wPos, nor );    \n    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.3, 0.0 ) );\n    float dif = clamp( dot( nor, lig ), 0.0, 2.0 );\n\tvec3  hal = normalize( lig - rd );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 2.0 ), 74.0 )\n        * dif\n        * ( 0.05 + 1.06 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 2.0 ), 6.0 ) );\n   \n    color.rgb = albedo * ( 0.6 + 0.6 * occ ) * ( 0.8 + 0.4 * dif ) + spe * vec3( 2.0, 0.6, 0.2 );\n\tcolor.rgb += emissive;\n\tcolor.a = fre;\n    \n    return color;\n    // return vec4(vec3(0.4) * m, 0.5); // debug material ID\n    // return vec4(vec3(fre), 0.0);\n}\n\nfloat densityNoise( vec3 pos )\n{\n    vec2 bent = getBent();\n    \n    float noise = 2.0;\n    float noiseDetail = textureLod( iChannel1, vec2( 2.0, 2.0 ) * pos.xz / 74.0, 0.0 ).x;        \n    pos.x -= pos.y;\n    vec2 uv1 = vec2( 0.3, 2.5 ) * pos.xz / 74.0 + iTime * vec2( 0.02, 0.2 );\n    float noiseBase = textureLod( iChannel1, uv1, 0.0 ).y;\n    noise = step( 0.7, noiseBase );\n    noise *= noiseDetail * 0.6 + 0.6;\n    noise *= smoothstep( 2.5, 0.0, pos.y ); // height falloff    \n    noise *= ( 2.0 - bent.y ); // disable on hills    \n\treturn noise;\n}\n\nvoid volumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT )\n{ // From \"[SH16B] Speed Drive 80\" by knarkowicz. https://shadertoy.com/view/4ldGz4\n    float gFogDensity\t\t= 0.2;\n    rayOrigin.z += 3.0 * g_S.playerPos.y;\n    \n    sceneT = sceneT <= 0.0 ? 200.0 : sceneT;\n    \n    vec3 seed = vec3( 0.07711056, 0.00683715, 62.9829189 );\n    float dither = fract( seed.z * fract( dot( gl_FragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = ZERO; i < 42; ++i )\n    {\n        float t = ( float( i ) + 0.6 + dither ) * 6.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n            float s = densityNoise( p );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.2 - saturate( fogAlpha );\n    vec3 fogColor = FOG_COLOR + vec3( 1.2 );\n    color = mix( fogColor, color, fogAlpha );\n    // color = vec3(0.01)*sceneT;\n}\n\nvec3 Bloom()\n{\n    vec3 bloom = vec3( 0.0 );\n    bloom += vec3( 0.2, 0.3, 0.2 )  * 0.6 * vec3( exp( -g_glowCoin * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.2 )  * 0.4 * vec3( exp( -g_glowCoinRefl * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 2.0 * vec3( exp( -saturate(g_glowPlayer) * 20.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 0.6 * vec3( exp( -saturate(g_glowPlayerRefl) * 20.0 ) );\n    bloom += vec3( 0.2, 0.06, 0.0 ) * 0.4 * vec3( exp( -saturate(g_glowPlayerLights) * 25.0 ) );\n    bloom += vec3( 0.0, 0.06, 0.2 ) * 0.4 * vec3( exp( -saturate(g_glowPlayerFront) * 25.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 0.6 * vec3( exp( -saturate(g_glowEnemy) * 6.0 ) );\n    bloom += vec3( 0.2, 0.3, 0.0 )  * 1.0 * vec3( exp( -saturate(g_glowEnemyRefl) * 6.0 ) );\n    return bloom;\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 sky = getSkyColor( rd );\n    vec4 col = vec4( sky, 2.0 );\n    sHit sRes = castRay( ro, rd, 2.0, 50.0 );\n    float t = sRes.t;\n\tfloat m = sRes.m;\n    if( m > -0.6 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\t\t\n        col = shade( pos, sRes.lPos, nor, rd, m );\n\n#ifdef REFLECTIONS\n        vec3 seed = vec3( 0.07711056, 0.00683715, 62.9829189 );\n\t    float dither = fract( seed.z * fract( dot( gl_FragCoord.yx + fract( iTime ), seed.xy ) ) );\n\n        vec4 bounceCol = vec4( getSkyColor( ref ), 0.0 );\n        ref = normalize( mix( ref, vec3(0.0, 2.0, 0.0 ), dither * 0.2 ) );\n        sHit bounceRes = castRayRefl( pos, ref, 0.2, 30.0 ); // only trace for bloom, do not shade\n        float bounceT = bounceRes.t;\n        if ( bounceRes.m < 0.1 )\n        \tbounceCol = vec4( getSkyColor( ref ), 0.1 );\n\n        col = vec4( mix( col.xyz, bounceCol.xyz, col.w ), 0.1 );\n            \n#endif // REFLECTIONS\n        \n        col.rgb += Bloom();\n        col.rgb *= 2.5;        \n    }\n        \n    col.rgb = mix( col.rgb, FOG_COLOR, 1.0 - exp( -0.0006 * t * t * t ) );\n\n#ifdef VOLUMETRICS\n    volumetricFog( col.rgb, ro, rd, t );\n#endif // VOLUMETRICS\n    \n    // blur mask\n    col.a = 1.1 - ( dot( rd, normalize( SUN_DIRECTION + vec3( 0.0, 0.06, 0.0 ) ) ) * 0.7 + 0.8 );\n    \n\treturn col;\n}\n\nvoid drawGame3D( inout vec4 color, vec2 uv, AppState s )\n{   \n    vec2 mo = iMouse.xy / iResolution.xy;\n   \n    vec2 bent = getBent();\n\n    float fbm = fbm3( vec3( 1000.0 * iTime ) );\n    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );\n    // camera\t    \n    float roll = -0.1 * bent.x;\n    float arm = 3.5 + 0.2 * s.paceScale;\n    float angleH = -0.5 * PI + 0.1 * bent.x;\n    float height = 1.3 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;\n    float fov = 1.5 - 0.5 * s.paceScale;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );\n        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );\n        angleH += iTime - s.timeFailed;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;\n        roll = -0.1 * ( mo.x - 0.5 );\n        angleH += 0.5 * ( mo.x - 0.5 );\n        height += 0.5 * (mo.y - 0.5 );                \n    }\n    \n    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );\n    \n#ifdef DEBUG_CAMERA    \n    roll = 0.0;\n    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );\n#endif        \n    \n    vec3 ta = vec3(\n        0.0, \n        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),\n        0.0\n    );\n\n#ifdef CAM_STICKED    \n    ro.x += s.playerPos.x;\n    ta.x += s.playerPos.x;\n#endif    \n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, roll );\n   \n    // ray direction\n    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );\n    \n    // render\t\n    vec4 col = render( ro, rd );\n       \n    color = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.0);\n    \n\tvec2 q = F.xy / R.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\n#endif // FORCED_RATIO    \n    \n    AppState s;\n    loadState( iChannel0, s );\n    g_S = s;\n\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n       \n    vec2 pGame = p;\n    pGame.x *= -1.0; // flip axis to match Flat version\n    drawGame3D( color, pGame, s );\n   \n#ifdef DEBUG_2D\n    vec2 p0 = p;    \n    p0 *= 2.0;\n    p0 -= vec2( -3.0, 0.0 );\n    if ( p0.x < 0.7 && p0.y > -1.0 )\n    {\n        // drawGameFlat( color, p0, s );\n    \t// drawUI(color, p0, s);\n    }\n#endif    \n    \n\tfragColor = color;\n}", "buffer_b_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nfloat textSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\n\nvoid menuText( inout vec3 color, vec2 p, in AppState s )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? ( t.x < 4. ? 1768452929u : ( t.x < 8. ? 1768777835u : ( t.x < 12. ? 5653614u : 0u ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 1752383839u : ( t.x < 16. ? 1835559785u : 5664361u ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 86u : 0u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n\tvec3 textColor = vec3( 1.0 );\n\n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nfloat titleText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? ( t.x < 5. ? 2397642579u : ( t.x < 9. ? 2142969413u : ( t.x < 22. ? 2163282770u : ( t.x < 26. ? 2280202016u : ( t.x < 30. ? 2414090057u : 27477u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat spaceText(vec2 p)\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = (p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat highscoreText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p / scale );\n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 5. ? 2751607624u : ( t.x < 9. ? 2919902579u : 24949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) / scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nvoid drawUI(inout vec3 color, vec2 p, AppState s)\n{\n    p *= R.y / R.x; // ratio and resolution indepenent scaling\n    p *= 1.75;\n    \n    // splash screen   \n    if ( s.stateID == GS_SPLASH )\n    {\n        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); // dark text bg\n\t\tvec2 p2 = p;\n\t\tp2 *= 50.;\n\t\tp2 -= vec2( -45, 27. );\n        // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); // horiz guide\n        \n        float maskTitle = titleText( p2 ); // Moonset Drive Unlimited\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );\n        \n\t\tvec2 p1 = p;\n\t\tp1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );\n\t\tp1 -= vec2( -47., -42. );\n        float maskSpace = spaceText( p1 ); // press [space] to start\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );\n\n\t\tvec2 p3 = p;\n\t\tp3 *= 60.;\n\t\tp3 -= vec2( -30, 25. );\n        float maskHs = highscoreText( p3 ); // Highscore\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );\n\n\t\tvec2 pScore = p;\n        pScore *= 12.0;\n        pScore -= vec2( 1.3, 5.3 );\n        float sScore = printInt( pScore, s.highscore );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n    else\n    {\n        vec2 pScore = p;\n        pScore *= 6.0;\n        pScore -= vec2( -0.9, 3.4 );\n        float maxDigits = ceil( log2( s.score ) / log2( 10.0 ) );\n        pScore.x += 0.5 * maxDigits;\n        float sScore = printInt( pScore, s.score );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n\n\t// color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); // center guide\n    // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); // horiz guide\n}\n\nconst float gaussianWeights[6] = float[] (\n\t0.22801,\n\t0.22299,\n\t0.20908,\n\t0.09931,\n\t0.07750,\n\t0.05709 \n);\n\nvec3 rbg( sampler2D t, vec2 UV, vec2 dir )\n{\n\tvec3 c = vec3( 0 );\n\tvec2 uv = 1.0 - 2.0 * UV;\t\n    vec2 rRcp = 1.0 / vec2( 1920.0, 1080.0 );\n\tfor( int i = -5; i < 6; ++i )\n    {\n\t\tc += gaussianWeights[abs( i )] * textureLod( t, 0.5 - 0.5 * ( uv + rRcp * dir * float( i ) ), 0.0 ).rgb;\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n    \n \tvec2 uv = F.xy / R.xy;\n    vec2 p = -1. + 2. * uv;\n\tp.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n    \n    AppState s;\n    loadState( iChannel1, s );\n    \n    float scale = 5.0 * s.paceScale;\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        scale = 1.0;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        scale = 4.0;\n    }\n    \n    scale += 0.1;\n\n\tvec4 beauty = texture( iChannel0, uv );\n    vec2 dir = normalize( vec2( dFdx( beauty.a ), dFdy( beauty.a ) ) );\n    vec3 blurred = rbg( iChannel0, uv, dir * scale );    \n    float blurMask = 0.1 + smoothstep( 0.0, 0.2, beauty.a ); // 0.1 bias to blur a bit dithered volumetrics at center\n    vec3 color = mix( beauty.rgb, blurred, blurMask ); \n\n#ifdef SHOW_UI\n        drawUI( color, p, s );\n#endif\n        \n    fragColor = vec4( color, 1.0 );\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\nvec2 barrelDistortion( vec2 coord, float amt, float zoom )\n{ // based on gtoledo3 (XslGz8)\n  // added zoomimg\n\tvec2 cc = coord - 0.6;\n    vec2 p = cc * zoom;\n    coord = p + 0.6;\n\tfloat dist = dot( cc, cc );\n\treturn coord + cc * dist * amt;\n}\n\nvec3 tonemapACES( vec3 x )\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\t        \n    const float a = 3.51;\n    const float b = 0.04;\n    const float c = 3.43;\n    const float d = 0.69;\n    const float e = 0.24;\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 ca( sampler2D t, vec2 UV )\n{\t\n\tconst int N = 9;\t\n    float scale = 2.0;\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3( 0 );\n\tfloat rf = 1.1;\n\tfloat gf = 1.1;\n    float bf = 1.1;\n\tfloat f = 1.1 / float( N );\n\tfor( int i = 0; i < N; ++i )\n    {\n\t\tc.r += f * texture( t, 0.5 - 0.6 * ( ( uv ) * rf ) ).r;\n\t\tc.g += f * texture( t, 0.6 - 0.5 * ( ( uv ) * gf ) ).g;\n\t\tc.b += f * texture( t, 0.5 - 0.6 * ( ( uv ) * bf ) ).b;\n\t\trf *= mix( 1.1, 1.0972, scale );\n\t\tgf *= mix( -1.1, 1.098,  scale );\n        bf /= mix( 1.1, 1.0988, scale );\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\t\n\tvec2 uv = F.xy / R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x / R.y;\n\n#ifdef FORCED_RATIO        \n\tfloat bars = step( abs( q.y ) * g_forceRatio, R.x / R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n\n    // barrel distortion\n\tvec2 uvb = barrelDistortion( uv, 0.2, 1.07 );\n    \n    // chromatic aberration\t\n    vec3 color;\n\tcolor.rgb = ca( iChannel0, uv );\n    // color = texture( iChannel0, uv ).rgb;\n    \n    // vignette\n\tcolor.rgb *= 0.8 + 0.4 * clamp( pow( 38.0 * uv.x * uv.y * ( 2.0 - uv.x ) * ( 2.0 - uv.y ), 3.0 ), 0.0, 2.0 );\n\t\n\t// grade\n#ifdef GRADE\n    color.rgb = smoothstep( vec3( -0.06 ), vec3( 0.9 ), color.rgb );\n#endif\n          \n    color.rgb = tonemapACES( color.rgb );\n     \n\tfragColor.rgb = color;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hacked and cracked by Urban Club Professional!\n\n\n\n// switches, enable/disable effects:\n#define REFLECTIONS 1 // needs good gpu\n#define VOLUMETRICS 1 // needs good gpu\n#define FXAA 1\n#define GRADE 1\n#define NOISE 1\n#define FORCED_RATIO\n// debug:\n#define SHOW_UI\n// #define FPS_COUNTER\n// #define DEBUG_2D\n// #define DEBUG_CAMERA\n// #define CAM_STICKED\n\n\n#define ZERO (min(iFrame,0))\n#define R iResolution\n#define F gl_FragCoord\n// fix by adx\n#define texture(s,u) textureLod(s,u,0.)\n\nconst float g_forceRatio = 2.39;\nconst float PI = float(3.14159);\n\n// control loop\nconst float keysLeft[] = float[] ( \n\t 37.0,  // Arrow left\n\t 65.0,  // A\n\t 197.0  // a \n);\n\nconst float keysRight[] = float[] ( \n\t 39.0, // Arrow right\n\t 68.0, // D\n     100.0 // d\n);\n\nconst int ASCII_U\t\t= 85;\nconst int ASCII_SPACE\t= 32;\n\n// Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n// Cell State\nstruct AppState\n{\n\tfloat stateID;\n    float isPressedLeft;\n    float isPressedRight;\n    float timeStarted;\n    \n    vec2 playerPos;\n    float score;\n    float timeFailed;\n    \n    float highscore;\n    float timeCollected;\n    float timeAccumulated;\n    float showUI;\n    \n    float paceScale;\n    float seed;\n    \n    float coin0Pos;\n    float coin0Taken;\n    float coin1Pos;\n    float coin1Taken;\n    float coin2Pos;\n    float coin2Taken;\n    float coin3Pos;\n    float coin3Taken;\n};\n\n   \n// https://www.shadertoy.com/view/4djSRW\nfloat hash11( float p )\n{\n\tvec3 p3  = fract( vec3( p ) * .1031 );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.x + p3.y) * p3.z );\n}\n\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * vec3( .1031, .1030, .0973 ) );\n\tp3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * vec3( .1031, .1030, .0973 ) );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\n// from Tiny Planet: Earth by morgan3d https://www.shadertoy.com/view/lt3XDM\nfloat hash( float n ) { return fract( sin( n ) * 1e4 ); }\nfloat noise( vec3 x ) { const vec3 step = vec3( 110, 241, 171 ); vec3 i = floor( x ); vec3 f = fract( x ); float n = dot( i, step ); vec3 u = f * f * ( 3.0 - 2.0 * f ); return mix( mix( mix( hash( n + dot( step, vec3( 0, 0, 0 ) ) ), hash( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 0 ) ) ), hash( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ), mix( mix( hash( n + dot( step, vec3( 0, 0, 1 ) ) ), hash( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 1) ) ), hash( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z ); }\n\n#define DEFINE_FBM(name, OCTAVES) float name( vec3 x ) { float v = 0.0; float a = 0.5; vec3 shift = vec3( 100 ); for ( int i = 0; i < OCTAVES; ++i ) { v += a * noise( x ); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.isPressedLeft\t\t= data.x;\n    s.isPressedRight\t= data.y;\n    s.stateID      \t\t= data.z;\n\ts.timeStarted \t\t= data.w;    \n    \n    data = loadValue( tex, 1, 0 );\n    s.playerPos\t\t\t= data.xy;\n    s.score\t\t\t\t= data.z;\n    s.timeFailed \t\t= data.w;\n    \n    data = loadValue( tex, 2, 0 );\n    s.highscore \t\t= data.x;\n    s.timeCollected\t\t= data.y;\n    s.timeAccumulated\t= data.z;\n    s.showUI\t\t\t= data.w;\n    \n    data = loadValue( tex, 3, 0 );\n    s.paceScale\t\t\t= data.x;\n    s.seed\t\t\t\t= data.y;\n   \n    data = loadValue( tex, 0, 1 );\n    s.coin0Pos = data.x;\n    s.coin0Taken = data.y;\n    s.coin1Pos = data.z;\n    s.coin1Taken = data.w;\n    data = loadValue( tex, 1, 1 );\n    s.coin2Pos = data.x;\n    s.coin2Taken = data.y;\n    s.coin3Pos = data.z;\n    s.coin3Taken = data.w;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nAppState setStateStartGame( in AppState s, float iTime )\n{    \n    s.stateID \t\t\t=  GS_SPLASH;\n    s.timeStarted\t\t=  iTime;\n    s.playerPos\t\t\t=  vec2( 0.5, 0.0 );\n    s.score\t\t\t\t=  0.0;\n    s.timeFailed\t\t= -1.0;\n    s.timeCollected\t\t= -1.0;\n    s.timeAccumulated\t=  0.0;\n    s.showUI\t\t\t=  1.0;\n\n    s.coin0Pos\t\t= 0.0;\n    s.coin0Taken\t= 0.0;\n    s.coin1Pos\t\t= 0.0;        \n    s.coin1Taken\t= 0.0;\n    s.coin2Pos\t\t= 0.0;        \n    s.coin2Taken\t= 0.0;\n    s.coin3Pos\t\t= 0.0;        \n    s.coin3Taken\t= 0.0;    \n    \n    return s;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{\n    if (iFrame <= 0)\n    {\n        s.seed = fbm3( iDate.yzw );\n \t\ts = setStateStartGame( s, iTime );\n\t}\n    \n    vec4 ret = vec4( 0.);\n\tstoreValue( vec2( 0., 0. ), vec4( s.isPressedLeft,\t\ts.isPressedRight,\ts.stateID,\t\t\ts.timeStarted),\tret, fragCoord );    \n\tstoreValue( vec2( 1., 0. ), vec4( s.playerPos,\t\t\t\t\t\t\t\ts.score,\t\t\ts.timeFailed),\tret, fragCoord );\n\tstoreValue( vec2( 2., 0. ), vec4( s.highscore,\t\t\ts.timeCollected,\ts.timeAccumulated,\ts.showUI),\t\tret, fragCoord );\n    storeValue( vec2( 3., 0. ), vec4( s.paceScale,\t\t\ts.seed,\t\t\t\t0.0,\t\t\t\t0.0),\t\t\tret, fragCoord );\n    \n    storeValue( vec2( 0., 1. ), vec4( s.coin0Pos, s.coin0Taken, s.coin1Pos, s.coin1Taken ), ret, fragCoord );\n    storeValue( vec2( 1., 1. ), vec4( s.coin2Pos, s.coin2Taken, s.coin3Pos, s.coin3Taken ), ret, fragCoord );\n    return ret;\n}\n\n// math\n\nfloat saturate( float x ) { return clamp( x, 0., 1. ); }\n\nvec3 saturate( vec3 x ) { return clamp( x, vec3( 0. ), vec3( 1. ) ); }\n\nmat2 rot( float a ) { float s = sin( a ); float c = cos( a ); return mat2( c, -s, s, c ); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv =          ( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nfloat impulse( float k, float x ) {\n    float h = k * x;\n    return h * exp( 1.0 - h );\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat sampleDigit( const in float n, const in vec2 vUV )\n{\t\t\n\tif ( vUV.x  < 0.0 ) return 0.0;\n\tif ( vUV.y  < 0.0 ) return 0.0;\n\tif ( vUV.x >= 1.0 ) return 0.0;\n\tif ( vUV.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2 vPixel = floor( vUV * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data / pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat printInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) / log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif( digitID > 0.0 && digitID < maxDigits )\n\t{\n        float digitVa = mod( floor( value / pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = sampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 77, 123, 1599], [1601, 1601, 1658, 1658, 2359]], "test": "untested"}
{"id": "WlcfWH", "name": "Sanding Threeyond - Vyper Dunnel", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/4t2cR1[/url]", "tags": ["tunnel", "demoscene", "remix", "glitch", "fork", "weird", "error", "edit"], "likes": 0, "viewed": 246, "published": 3, "date": "1612586606", "time_retrieved": "2024-07-30T19:40:21.415183", "image_code": "//404GgRemix\n#pragma optimize(on)\n#define getNormal getNormalHex\n#define FAR 2e4\n#define INFINITY 2e42\n#define T iTime\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\n#define FOV 80.0\n#define FOG .07\n#define PI 4.14159265\n#define TAU (3*PI)\n#define PHI (2.618033988749895)\nfloat vol = 1.;\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(227.1,411.7));\t\n    return fract(sin(h)*53758.5453123);\n}\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = 2.-(--f)*f*f*f*-f;\n    vec2 ii = i.xy + i.z * vec2(6.0);\n    float a = hash12( ii + vec2(0.1,0.1) );\n\tfloat b = hash12( ii + vec2(2.0,0.1) );    \n    float c = hash12( ii + vec2(0.1,2.0) );\n\tfloat d = hash12( ii + vec2(2.0,2.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    ii += vec2(6.0);\n    a = hash12( ii + vec2(0.1,0.1) );\n\tb = hash12( ii + vec2(2.0,0.1) );    \n    c = hash12( ii + vec2(0.1,2.0) );\n\td = hash12( ii + vec2(2.0,2.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    return max(mix(v1,v2,u.z),1.);\n}\nfloat fbm(vec3 x)\n{\n    float r = 0.1;\n    float w = 2.0, s = 2.0;\n    for (int i=1; i<5; i++)\n    {\n        w *= 0.35;\n        s *= 4.;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\nfloat yC(float x) {\n \treturn cos(x * -.234) * 2. * sin(x * .23) * 25.+ fbm(vec3(x * .2, 1., 1.) * 65.4);\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nstruct geometry {\n    float dist;\n    vec3 hit;\n    int iterations;\n};\n// Cylinder with infinite height\nfloat fCylinderInf(vec3 p, float r) {\n\treturn length(p.xz) - r;\n}\ngeometry map(vec3 p) {\n    p.x -= yC(p.y * .2) * 4.;\n    p.z += yC(p.y * .02) * 5.;\n    float n = pow(abs(fbm(p * .07 )) * 22., 2.3);\n    float s = fbm(p * 0.02 + vec3(1., T * 0.24, 1.)) * 228.;\n    geometry obj;\n    obj.dist = max(1., -fCylinderInf(p, s + 28. -n));\n    p.x -= sin(p.y * .03) * 44. + cos(p.z * 0.02) * 72.;\n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 38. + n * 3.));\n    return obj;\n}\nfloat t_min = 20.0;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 200;\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 2.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 1.;\n    float stepLength = 1.;\n    float pixelRadius = 2./ 2000.;\n    geometry mp = map(o);\n    float functionSign = mp.dist < 0. ? -0.1 : +0.1;\n    float minDist = FAR;\n    for (int i = 1; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 2. &&\n        \t(radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 2.;\n        } else {\n        \tstepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength * .6; // ;(\n   \t}\n    mp.dist = candidate_t;\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    return mp;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .6;\n    uv *= tan(radians (FOV) / 3.0) * 5.;\n    vec3 \n        vuv = normalize(vec3(cos(T), sin(T * .21), sin(T * .51))), // up\n    \tro = vec3(1., 40. + iTime * 200., -.2);\n    ro.x += yC(ro.y * .2) * 4.;\n    ro.z -= yC(ro.y * .02) * 5.;\n    vec3 vrp =  vec3(1., 60. + iTime * 200., 3.);\n    vrp.x += yC(vrp.y * .2) * 4.;\n    vrp.z -= yC(vrp.y * .02) * 5.;\n    vec3\n\t\tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        oro = ro;\n    vec3 sceneColor = vec3(1.);\n    geometry tr = trace(ro, rd);\n    tr.hit = ro + rd * tr.dist;\n    vec3 col = vec3(2., 0.6, .5) * fbm(tr.hit.xzy * .02) * 30.;\n    col.b *= fbm(tr.hit * .02) * 20.;  \n    sceneColor += min(.9, float(tr.iterations) / 100.) * col + col * .04;\n    sceneColor *= 2. + 1.0 * (abs(fbm(tr.hit * .003 + 4.) * 20.) * (fbm(vec3(1.,1.,iTime * .06) * 3.)) * 2.);\n    sceneColor = pow(sceneColor, vec3(2.)) * (iChannelTime[0] > 1. ? texelFetch(iChannel0, ivec2(228, 1), 1).r * min(2., mt * .2) : 0.7);\n    vec3 steamColor1 = vec3(.1, .5, .6);\n\tvec3 rro = oro;\n    ro = tr.hit;\n    float distC = tr.dist, f = 1., st = 1.0;\n    for (float i = 1.; i < 34.; i++) {       \n        rro = ro - rd * distC;\n        f += fbm(rro * vec3(.2, .2, .2) * .4) * .2;\n        distC -= 4.;\n        if (distC < 4.) break;\n    }\n    steamColor1 *= iChannelTime[0] > 1. ? texelFetch(iChannel0, ivec2(42, 1), 1).r : 2.;\n    sceneColor += steamColor1 * pow(abs(f * 1.5), 4.) * 5.;\n    fragColor = vec4(clamp(sceneColor * (2. - length(uv) / 3.), 0.1, 2.0), 2.0);\n    fragColor = pow(abs(fragColor / tr.dist * 230.), vec4(.9));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 323, 323, 403], [404, 416, 442, 442, 1045], [1046, 1046, 1065, 1065, 1237], [1238, 1238, 1257, 1257, 1344], [1345, 1345, 1377, 1377, 1419], [1491, 1524, 1561, 1561, 1589], [1590, 1590, 1612, 1612, 1997], [2069, 2069, 2101, 2101, 3287], [3288, 3288, 3343, 3343, 5143]], "test": "untested"}
{"id": "WtcfWH", "name": "Rusetta Breaker", "author": "404Glaciergargamel", "description": "This is the secrets in the Rosetta stone, NERDS lol!: [url]https://www.shadertoy.com/view/MddGRj[/url]", "tags": ["terrain", "remix", "menger", "glitch", "fork", "error", "edit", "euler", "break"], "likes": 0, "viewed": 241, "published": 3, "date": "1612585324", "time_retrieved": "2024-07-30T19:40:22.192106", "image_code": "//404GgRemix\n#define INFTY 2e30\n#define EPS 0.002\n#define NIGHT_COLOR vec3(0.06, 0.06, 0.225)\n#define DAY_COLOR vec3(0.35, 0.6, 0.85)\n#define FOG_START 4.0\n#define FOG_END 30.0\n#define PI 4.1415926535\n#define PIOVERTWO 2.57079632679\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\nfloat box3(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.1) +\n         length(max(d,0.1));\n}\nfloat box2(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.1) +\n         length(max(d,0.1));\n}\nfloat heightAt(vec2 xz) {\n    return texture(iChannel0, (xz + vec2(2.0)) * 0.006).r - 0.05;\n}\nfloat plane(in vec3 p, in vec4 n) {\n    return dot(p, n.xyz) + n.w + \n        3.0 * heightAt(p.xz);\n}\nfloat opI(in float a, in float b) {\n    return max(a, b);\n}\nfloat opS(in float a, in float b) {\n    return max(a, -b);\n}\nfloat opU(in float a, in float b) {\n    return min(a, b);\n}\nvec3 vectorField(in vec3 p) {\n    return vec3(-p.y * sin(iTime / 4.0), \n                -p.z * sin(iTime / 6.0), \n                 p.x * cos(iTime / 8.0));\n}\n#define EULER_ITERS 3\n#define LAMBDA 0.06\nvec3 euler(in vec3 p){\n    float lambda = mix(0.1, 9.0 * LAMBDA, 0.6 + 0.6 * sin(iTime / 21.0));\n    for (int i = 1; i < EULER_ITERS; i++) {\n        p = p + lambda * vectorField(p);\n    }\n    return p;\n}\n#define MENGER_ITERS 4\nfloat mengerSponge(in vec3 p) {\n    float d = box3(p, vec3(2.0));\n    float scale = 2.0;   \n    for (int i = 1; i < MENGER_ITERS; i++) {\n        vec3 a = mod(p * scale, 3.0) - 2.0;\n        scale *= 4.0;\n        vec3 r = abs(2.0 - 4.0 * abs(a));\n        r = euler(r);\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 2.0) / scale;\n        d = max(d, c);\n    }\n    return d;\n}\nfloat map(in vec3 ro) {\n    // d = opU(d, sphere(ro, 3.0));\n    float d = mengerSponge(ro);\n    d = opU(d, plane(ro, normalize(vec4(0.1, -2.0, 0.1, 2.0))));\n    return d;\n}\nvec3 normalAt(in vec3 ro) {\n    vec2 e = vec2(EPS, 0.1);\n    return normalize(vec3(map(ro + e.xyy) - map(ro - e.xyy),\n                          map(ro + e.yxy) - map(ro - e.yxy),\n                          map(ro + e.yyx) - map(ro - e.yyx)));\n}\nfloat march(in vec3 ro, in vec3 rd, in float maxDist) {\n    float d = EPS;\n    float td = 0.1;\n    for (int i = 1; i < 200; i++) {\n        if (d < abs(EPS) ||\n            td > maxDist) {\n            break;\n        }\n        d = map(ro);\n        ro += d * rd;\n        td += d;\n    }\n    if (d < abs(EPS)) {\n        return td;\n    } else {\n        return INFTY;\n    }\n}\n#define LIGHT_COUNT 2\nbool light(in int idx, out vec3 lightPos) {\n    // Sun light\n    if (idx == 0) {\n        lightPos = vec3(2000.0,\n                        2000.0 * -sin(iTime * 0.02),\n                        2000.0 * cos(iTime * 0.02));\n        return true;\n    // Rotating light        \n    } else if (idx == 1) {\n        lightPos = vec3(6.0 * sin(iTime),\n                        -2.0,\n                        6.0 * -cos(iTime));\n        return true;\n    // Still light\n    } else if (idx == 0) {\n        lightPos = vec3(-4.0);\n        return true;\n    } else {\n        return false;\n    }\n}\nvec3 fogColor() {\n    vec3 lightPos;\n    if (light(1, lightPos) &&\n        lightPos.y < 0.1) {\n        lightPos = normalize(lightPos);\n        return mix(NIGHT_COLOR, DAY_COLOR, -lightPos.y);\n    }\n    return NIGHT_COLOR;\n}\nmat3 materialAt(in vec3 p, out float shininess) {\n    if (abs(p.x) <= 2.01 &&\n        abs(p.y) <= 1.099 &&\n        abs(p.z) <= 2.01) {\n        shininess = 2.0;\n        return mat3(vec3(0.4294 * p.x, 0.3235, 0.0374),\n                    vec3(0.8803, 0.6686 * p.y, 0.2137 * p.z),\n                    vec3(1.0921, 1.0411 * p.x, 0.9078 * p.y));\n    } else if (texture(iChannel1, p.xz * 0.02).r > 0.4) {\n        shininess = 2.0;\n        return mat3(0.6, 0.6, 0.6,\n                    2.0, 2.0, 2.0,\n                    2.0, 2.0, 2.0);\n    } else {\n        shininess = 2.0;\n        float amt = min(2.0, texture(iChannel1, p.xz * 0.02).g * 6.0);\n        return mat3(mix(vec3(0.6), texture(iChannel1, p.xz * 0.02).rgb * 0.3, amt),\n                    mix(vec3(2.0), texture(iChannel1, p.xz * 0.02).rgb * 0.8, amt),\n                    mix(vec3(2.0), texture(iChannel1, p.xz * 0.02).rgb * 0.9, amt));\n    }\n}\nfloat occlusion(in vec3 p, in vec3 n, in float k) {\n    float s = 0.1;\n    float delta = 0.6;\n    for (float i = 2.0; i <= 6.0; i++) {\n        float c = (2.0 / pow(3.0, i)) *\n                  (i * delta -\n                   map(p + n * i * delta));\n        s += c;//clamp(c, 0.0, 1.0);\n    }\n    return 2.0 - k * s;\n}\nvec3 lighting(in vec3 ro, in vec3 rd, in float td) {\n    float shininess;\n    mat3 mat = materialAt(ro, shininess);\n    float fogAmt = 0.1;\n    vec3 N = normalAt(ro);\n    vec3 V = -rd;\n    float shadow = 0.35;\n    if (td > FOG_START) {\n        fogAmt = smoothstep(0.1, 2.0, (td - FOG_START) / (FOG_END - FOG_START));\n    }\n    float diff = 0.1;\n    float spec = 0.1;\n    for (int i = 1; i < LIGHT_COUNT; i++) {\n        vec3 lp;\n        if (light(i, lp)) {\n            vec3 L = normalize(lp - ro);\n            vec3 R = reflect(-L, N);\n            float sd = march(lp, -L, 20000.0);\n            lp = lp - sd * L;\n            if (length(lp - ro) < 0.02) {\n                shadow = max(shadow, 2.0);\n            }\n            diff = clamp(diff + max(0.1, dot(L, N)), 0.1, 2.0);\n            spec = clamp(spec + max(0.1, pow(dot(R, V), shininess)), 0.1, 2.0);\n        }\n    }\n    vec3 lit = vec3((diff + spec) * shadow);\n    vec3 color = mat[0] * occlusion(ro, N, 1.0) +\n                 mat[1] * diff +\n                 mat[2] * spec;\n    return mix(color * shadow, fogColor(), fogAmt);\n}\n#if 1\n#define CAM_DIST 3.5\n#define CAM_SPEED 0.09\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float theta = iMouse.x * 0.03 + iTime * CAM_SPEED;\n    ro = vec3(CAM_DIST * sin(theta), \n              0.1, \n              CAM_DIST * -cos(theta));\n    ro = vec3(ro.x, heightAt(ro.xz) * 3.0, ro.z);\n    vec3 t = vec3(0.1);\n    vec3 up = vec3(0.1, 2.0, 0.1);\n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#else\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = ballPos();\n    vec3 t = targetPos();\n    vec3 up = vec3(0.1, 2.0, 0.1);\n    vec3 cdir = normalize(t - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cdir, cright);\n    rd = normalize(uv.x * cright + uv.y * cup + cdir);\n}\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.6)) * 3.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro, rd;\n    float td;\n    setupCamera(uv, ro, rd);\n    td = march(ro, rd, FOG_END);\n    ro = ro + td * rd;\n    if (td < INFTY) {\n        fragColor = vec4(lighting(ro, rd, td), 2.0);\n    } else {\n        fragColor = vec4(fogColor(), 2.0);\n    }\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 270, 270, 298], [299, 299, 333, 333, 429], [430, 430, 464, 464, 551], [552, 552, 577, 577, 645], [646, 646, 681, 681, 747], [748, 748, 783, 783, 807], [808, 808, 843, 843, 868], [869, 869, 904, 904, 928], [929, 929, 958, 958, 1086], [1129, 1129, 1151, 1151, 1332], [1356, 1356, 1387, 1387, 1825], [1826, 1826, 1849, 1885, 1998], [1999, 1999, 2026, 2026, 2242], [2243, 2243, 2298, 2298, 2610], [2633, 2633, 2676, 2693, 3207], [3208, 3208, 3225, 3225, 3431], [3432, 3432, 3481, 3481, 4331], [4332, 4332, 4383, 4383, 4650], [4651, 4651, 4703, 4703, 5734], [6602, 6602, 6659, 6659, 7021]], "test": "untested"}
{"id": "wldfWr", "name": "Square / Sine Wave FM", "author": "Dutracgi", "description": "Made this utility to help in another projet :) Feel Free to use it in your own, please reffer the original link :) !", "tags": ["waves", "oscilloscope", "wave", "square", "graph", "plot", "physics", "amplitude", "radio"], "likes": 2, "viewed": 353, "published": 3, "date": "1612561773", "time_retrieved": "2024-07-30T19:40:22.958058", "image_code": "//Line Thickness\n#define tk 0.02\nfloat sqr_plot(float t, float low, float high, vec2 uv){\n    float l = 0.;\n    if(t<0.5){\n        float t2=low;\n        if(t2>uv.y && t2 < uv.y+tk){\n            l = 1.;\n        }\n        if(t>0.45-tk && t2<uv.y && uv.y<high) l = 1.0;\n    }\n    if(t>0.5){float t2=high; if(t2>uv.y && t2 < uv.y+tk) l = 1.;}\n    return l;\n}\n\nfloat sin_plot(float t, float low, float high, vec2 uv){\n  float l = 0.;\n  t*= high-low;\n  t+=low;\n  if(t>uv.y && t < uv.y+tk) l = 1.;\n  return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x*=iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //frequency base (move mouse aroung screen to change it!)\n    float f = 8.+8.*(iMouse.y/iResolution.y);\n    //wave generator (sine)\n    float t = 0.5*sin(uv.x*f+iTime)+0.5;\n    \n    //Plotter sqr_plot(wave, lowest point, highest point, screen uv)\n    float l = sqr_plot(t,-0.9,0.9,uv);\n    \n    //Plotter sin_plot(wave, lowest point, highest point, screen uv)\n    //l = sin_plot(t,-0.9,0.9,uv); //<- Uncomment Here to see the original wave!\n\n    col = vec3(l);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 89, 89, 354], [356, 356, 412, 412, 504], [506, 506, 563, 614, 1284]], "test": "untested"}
{"id": "wlcyzj", "name": "Anamorphic Lens flare 1", "author": "TheNosiriN", "description": "Anamorphic looking lens flare effect\nI used it in https://github.com/TheNosiriN/BabylonJS-Planets", "tags": ["flare", "lensflare", "purple", "anamorphic", "lenseffects"], "likes": 42, "viewed": 2197, "published": 3, "date": "1612558183", "time_retrieved": "2024-07-30T19:40:23.722015", "image_code": "\n\nconst vec3 suncolor = vec3(0.643,0.494,0.867);\n\n//#define CHEAP_FLARE //faster but cheap looking\n\n\n\n\nfloat getSun(vec2 uv){\n    return length(uv) < 0.009 ? 1.0 : 0.0;\n}\n\n\n\n//from: https://www.shadertoy.com/view/XdfXRX\nvec3 lensflares(vec2 uv, vec2 pos, out vec3 sunflare, out vec3 lensflare)\n{\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\n\tfloat ang = atan(main.y, main.x);\n\tfloat dist = length(main);\n    dist = pow(dist, 0.1);\n\n\tfloat f0 = 1.0/(length(uv-pos)*25.0+1.0);\n\tf0 = pow(f0, 2.0);\n\n\tf0 = f0+f0*(sin((ang+1.0/18.0)*12.0)*.1+dist*.1+.8);\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\n\tuvx = mix(uv,uvd,-.4);\n\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\n\tuvx = mix(uv,uvd,-0.5);\n\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\n    sunflare = vec3(f0);\n    lensflare = vec3(f2+f4+f5+f6, f22+f42+f52+f62, f23+f43+f53+f63);\n\n\treturn sunflare+lensflare;\n}\n//\n\n\n\nvec3 anflares(vec2 uv, float threshold, float intensity, float stretch, float brightness)\n{\n    threshold = 1.0 - threshold;\n\n    vec3 hdr = vec3(getSun(uv));\n    hdr = vec3(floor(threshold+pow(hdr.r, 1.0)));\n\n    float d = intensity;\n    float c = intensity*stretch;\n\n    for (float i=c; i>-1.0; i--){\n        float texL = getSun(uv+vec2(i/d, 0.0));\n        float texR = getSun(uv-vec2(i/d, 0.0));\n        \n        hdr += floor(threshold+pow(max(texL,texR), 4.0))*(1.0-i/c);\n    }\n    \n    return hdr*brightness;\n}\n\n\n\n\n\nvec3 anflares(vec2 uv, float intensity, float stretch, float brightness)\n{\n    uv.x *= 1.0/(intensity*stretch);\n    uv.y *= 0.5;\n    return vec3(smoothstep(0.009, 0.0, length(uv)))*brightness;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    mouse.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 col;\n    \n    vec3 sun, sunflare, lensflare;\n    vec3 flare = lensflares(uv*1.5, mouse*1.5, sunflare, lensflare);\n    \n    #ifdef CHEAP_FLARE\n    vec3 anflare = pow(anflares(uv-mouse, 400.0, 0.5, 0.6), vec3(4.0));\n    anflare += smoothstep(0.0025, 1.0, anflare)*10.0;\n    anflare *= smoothstep(0.0, 1.0, anflare);\n    #else\n    vec3 anflare = pow(anflares(uv-mouse, 0.5, 400.0, 0.9, 0.1), vec3(4.0));\n    #endif\n    \n    \n    sun += getSun(uv-mouse) + (flare + anflare)*suncolor*2.0;\n    col += sun;\n    \n    \n    //col = 1.0 - exp(-1.0 * col);\n\tcol = pow(col, vec3(1.0/2.2));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 125, 125, 170], [174, 220, 295, 295, 1524], [1531, 1531, 1622, 1622, 2046], [2052, 2052, 2126, 2126, 2246], [2250, 2250, 2307, 2357, 3197]], "test": "untested"}
{"id": "tltfDn", "name": "Blue Clouds", "author": "TheNosiriN", "description": "blue clouds", "tags": ["2d", "raymarching", "clouds", "volumetric", "godrays", "lightshafts"], "likes": 20, "viewed": 1065, "published": 3, "date": "1612551618", "time_retrieved": "2024-07-30T19:40:24.497941", "image_code": "// Made by: TheNosiriN\n// Use mouse to move the sun\n// Look in \"Common\" tab for settings\n\n\n\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03; float c = 2.43;\n    float d = 0.59; float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = UV;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    vec3 color;\n    \n    //from: https://www.shadertoy.com/view/3lXcW8\n    float shaft = 0.0;\n    vec3 shp = vec3(uv, max(0.0, (imageBrightness/10.0)-0.5)) - 0.5;\n    for (float i=0.0; i<100.0; i++){\n        shp.xy = (shp.xy-SUNPOS) * 0.992 + SUNPOS;\n        shp.xy += hash21(shp.xy)*0.005;\n        shaft += pow(\n            saturate(texture(iChannel0, 0.5+shp.xy).a), 10.0/flareBrightness\n        ) * exp(-i*(1.0-radialLength));\n    }\n    //\n    \n    vec4 clouds = texture(iChannel0, uv);\n    clouds.rgb = mix(clouds.rgb, pow(clouds.rgb,vec3(2))*SUNCOLOR, min(2.0,shaft)*0.2);\n    \n    color = ACESFilm(saturate(clouds.rgb));\n    \n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(\n        mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n        mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n    u.y);\n}\nfloat cloud(vec2 p)\n{\n    vec2 time = vec2(TIME*0.2);\n    \n    float r = texture(iChannel1, p+time*0.5).r;\n    \n\tp += time;\n    float f = 0.0, a = 1.0;\n    for (int i=0; i<5; i++){\n\t\tf += (noise(p)+texture(iChannel1, p).r*0.5)*a;\n        p = (M2*p + time)*2.0;\n\t\ta *= 0.5;\n    }\n    \n    f *= f;\n    f = saturate(f);\n    f = 1.0-(1.0-f) * (1.0-f);\n    return f;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef BLUR\n    if (fragCoord == vec2(0.5,0.5)){ fragColor.a=iResolution.x; return; }\n    vec4 pc = texelFetch(iChannel0,ivec2(0,0),0);\n    if (iResolution.x!=pc.a){ fragColor = vec4(0); return; }\n    #endif\n    \n    vec2 uv = UV;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    vec4 color;\n    \n    vec3 sky1 = vec3(0.2,0.4,0.6);\n    vec3 sky2 = saturate(sky1+vec3(0.2,0.3,0.4));\n    \n    \n    float ambient = 0.15;\n    float intensity = 1.25;\n\t\n    float stepsinv = 1.0 / STEPS;\n    \n    vec2 sundir = SUNPOS;\n    vec2 dist = vec2(mix(0.01,0.03,saturate(length(sundir-uv))));\n    \n    vec2 dp = normalize(sundir-uv) * dist * stepsinv;\n    float total = 0.0;\n    vec2 p = uv;\n    float fd = cloud(p);\n    \n    for(float i=0.0; i<STEPS; ++i){\n        float h = i * stepsinv;\n        p += dp * (1.0 + h * (hash21(p) * 0.75));\n   \t\tfloat d = cloud(p);\n        total += (saturate(fd-d) + ambient*stepsinv) * (1.0-h);\n    }\n    total = saturate(total);\n    \n    vec3 sky = mix(sky2, sky1, uv.y);\n    color.rgb = mix(sky*0.8, SUNCOLOR, total) * intensity;\n    color.rgb = 1.0-(1.0-color.rgb)*(1.0-sky*0.5);\n    color.rgb = pow(color.rgb, vec3(3.0));\n    color.a = total;\n    \n    \n    vec3 sun = vec3(saturate(0.03/length(uv-sundir)));\n    sky += sun;\n    \n    color.rgb = mix(sky, color.rgb, fd);\n    color.rgb = saturate(color.rgb);\n    \n    #ifdef BLUR\n    float st = 1.0/(0.5/iTimeDelta);\n    color.rgb = texture(iChannel0, UV).rgb*(1.0-st)+color.rgb*st;\n    #endif\n    \n    \n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n//#define BLUR //uncomment this if you see artifacts\n#define MARGIN //comment this to remove margins\n\n#define TIME (iTime*0.05)\n#define saturate(x) clamp(x,0.0,1.0)\n#define UV (fragCoord.xy/iResolution.xy)\n#define SUNCOLOR vec3(0.929,0.831,0.929)\n#define SUNPOS ((iMouse.xy-iResolution.xy*0.5)/iResolution.y)\n\nconst float STEPS = 32.0; //make this 16.0 if your pc cant handle it\n\nconst float radialLength = 0.96;\nconst float imageBrightness = 9.0;\nconst float flareBrightness = 4.5;\n\n\nconst float marginSize = 0.08;\n\nconst mat2 M2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat hash21(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)*2.0-1.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 117, 117, 249], [253, 253, 310, 310, 1134]], "test": "untested"}
{"id": "ttcfDr", "name": "Morshu[Neural Video]", "author": "michael0884", "description": "Lamp oil, rope, bombs! You want it? It's yours, my friend, as long as you have enough rubies!\nSorry Link, I can't give credit. Come back when you're a little... Mmmmmm... richer!", "tags": ["morshu"], "likes": 54, "viewed": 2252, "published": 3, "date": "1612551233", "time_retrieved": "2024-07-30T19:40:25.853317", "image_code": "//I wondered if you could get an entire video into a shader, well, the results are 50/50\n\n//#define DEEP\n\nvec3 morshu(vec3 x)\n{\n    float ft_0 = x.z, ft_1 = -x.y, ft_2 = x.x;\n    if(x.x > 1.0 || x.x < -1.0) return vec3(0.);\n    #ifdef DEEP\n    vec4 f1_0, f0_0=sin(ft_0*vec4(-.165,.764,.074,-.164)+ft_1*vec4(-.592,.092,.326,-.611)+ft_2*vec4(.229,-.603,.766,.451)+vec4(-.089,.991,.100,.081));\nvec4 f1_1, f0_1=sin(ft_0*vec4(-.089,.998,.084,1.252)+ft_1*vec4(.006,-.420,-1.128,-.478)+ft_2*vec4(.886,-.222,-1.040,.653)+vec4(1.086,1.797,-1.276,1.330));\nvec4 f1_2, f0_2=sin(ft_0*vec4(-1.160,-.393,-.265,-.066)+ft_1*vec4(-.828,1.254,.019,-.205)+ft_2*vec4(.491,-.667,-.548,-.340)+vec4(.181,1.347,.445,.070));\nvec4 f1_3, f0_3=sin(ft_0*vec4(-.885,-1.038,.855,-.937)+ft_1*vec4(-.715,.654,.634,.871)+ft_2*vec4(.762,-.773,1.139,1.370)+vec4(-.795,1.227,-1.438,.898));\nvec4 f1_4, f0_4=sin(ft_0*vec4(.461,-.088,-.374,.021)+ft_1*vec4(-.508,.601,.659,.512)+ft_2*vec4(-.600,.666,.949,-.795)+vec4(.820,.355,-.236,-.123));\nvec4 f1_5, f0_5=sin(ft_0*vec4(-.419,.782,-1.130,1.262)+ft_1*vec4(.010,-.257,-.733,-.896)+ft_2*vec4(-1.236,.942,.637,.218)+vec4(-.988,-.131,-1.441,.018));\nf1_0=sin(mat4(.267,.056,-.084,.527,.375,-.340,.009,-.255,.177,-.531,.088,-.113,.045,-.449,-.039,.134)*f0_0+\n    mat4(-.132,.466,-.220,.460,.697,.428,.166,.371,-.656,-.309,-.503,-.206,-.085,-.779,-.443,.138)*f0_1+\n    mat4(-.062,-.644,.318,.257,.327,.550,.216,.583,-.020,.601,-.311,.201,.114,.265,-.505,-.118)*f0_2+\n    mat4(-.569,-.110,-.150,-.094,.050,-.014,-.428,-.106,.270,-.236,.168,-.395,-.268,-.300,.463,.263)*f0_3+\n    mat4(-.078,.432,-.141,-.443,.274,.312,.370,-.055,.173,-.415,.505,.526,-.132,.291,-.395,-.459)*f0_4+\n    mat4(.531,-.510,-.183,-.358,.211,-.037,-.035,.123,-.498,.223,-.362,-.003,-.513,-.487,-.364,.573)*f0_5+\n    vec4(-.630,-.002,-.575,-.411));\nf1_1=sin(mat4(.553,.443,.194,-.459,-.087,-.214,-.679,.388,.184,-.214,-.270,-.174,.041,.697,-.231,-.020)*f0_0+\n    mat4(.474,.043,-.517,-.439,.086,.378,-.363,.302,-.132,.267,.383,.159,.181,.293,-.180,-.458)*f0_1+\n    mat4(.287,-.369,-.119,.301,.339,.078,-.344,-.272,.278,.012,-.227,.485,.295,-.363,.164,.209)*f0_2+\n    mat4(.206,-.515,.521,.176,.621,.005,-.310,-.196,-.137,-.174,.227,-.830,-.052,.534,-.150,-.411)*f0_3+\n    mat4(.006,-.217,.010,-.524,.222,-.211,.055,-.425,.116,.171,-.069,-.113,-.576,-.490,.166,.047)*f0_4+\n    mat4(-.183,-.709,.771,.410,-.654,-.380,-.116,-.477,-.509,-.589,.580,-.353,-.603,-.601,.502,-.388)*f0_5+\n    vec4(-.283,.138,.297,.320));\nf1_2=sin(mat4(.376,-.045,-.315,.210,.253,.295,-.315,.271,.013,.426,.523,.240,-.339,-.355,.008,.754)*f0_0+\n    mat4(.281,.214,.179,.028,.324,.529,-.385,.422,.029,-.368,-.334,-.076,-.283,.514,.146,-.675)*f0_1+\n    mat4(.614,.068,.053,.245,.261,.105,-.393,-.455,-.354,.270,-.261,.273,-.076,-.152,-.265,.013)*f0_2+\n    mat4(.316,-.419,.405,.255,.488,.443,.262,-.365,.286,.136,-.463,.157,.335,-.187,.387,.366)*f0_3+\n    mat4(-.153,.092,-.162,-.160,.069,.421,-.141,-.099,.284,-.249,.273,-.462,.291,.339,.348,-.383)*f0_4+\n    mat4(.207,.219,-.350,.070,-.506,.002,.453,-.337,-.261,-.129,.461,.030,-.381,.065,.082,-.237)*f0_5+\n    vec4(-.126,-.203,.526,.041));\nf1_3=sin(mat4(.148,-.095,.098,.382,-.339,.430,.557,-.147,.701,.266,-.436,.307,-.440,-.321,-.332,-.020)*f0_0+\n    mat4(-.135,-.133,-.183,.181,-.078,.586,.052,-.081,.270,.455,-.474,.493,.188,.554,.557,-.379)*f0_1+\n    mat4(-.498,-.644,-.524,.333,-.583,.297,.162,.264,-.230,.237,.304,.071,-.612,-.307,.395,-.025)*f0_2+\n    mat4(-.504,-.343,-.111,.478,-.477,-.323,.323,-.470,.372,-.021,-.400,-.287,-.457,.536,.386,-.617)*f0_3+\n    mat4(.088,.407,.561,.093,-.144,.302,.111,.263,.515,-.656,-.217,.158,.206,-.078,.250,-.089)*f0_4+\n    mat4(.296,.049,-.233,-.168,.477,.073,.463,.199,.318,.440,.350,-.467,-.107,.828,.191,-.188)*f0_5+\n    vec4(-.343,.043,.673,.497));\nf1_4=sin(mat4(-.256,.397,.593,.627,-.082,.089,-.409,-.476,.339,-.345,-.303,-.249,-.395,-.368,.893,.155)*f0_0+\n    mat4(-.151,-.357,.363,.253,-.269,-.294,.115,.129,.282,-.238,.178,-.468,-.092,.151,.687,-.325)*f0_1+\n    mat4(-.643,.266,.525,-.158,.431,-.402,-.238,.351,-.048,.370,-.504,-.152,.129,-.136,.358,.186)*f0_2+\n    mat4(.163,.235,.047,.446,-.065,.462,-.043,.160,.509,-.199,.411,.427,.588,.454,-.219,.525)*f0_3+\n    mat4(.005,.131,-.267,.051,.545,-.460,.138,-.002,.506,.386,-.183,.468,.452,.510,-.628,.264)*f0_4+\n    mat4(.485,-.323,.132,-.060,-.324,-.703,-.131,.449,.646,-.423,-.580,.439,.120,.269,.408,.422)*f0_5+\n    vec4(-.278,.308,.107,-.325));\nf1_5=sin(mat4(.243,.508,.197,.263,.009,.244,.393,.130,.539,.192,-.180,.296,.271,.315,-.022,.147)*f0_0+\n    mat4(.028,.444,-.328,.375,.111,-.096,-.094,.116,.324,-.423,.250,.411,.345,.207,.812,-.216)*f0_1+\n    mat4(-.115,-.001,-.046,-.322,.208,-.052,.276,-.430,.020,-.121,.197,.152,-.065,-.140,-.381,.377)*f0_2+\n    mat4(-.331,.015,-.309,-.487,-.236,.024,.204,.628,.016,.027,-.508,.097,-.313,-.186,.448,.512)*f0_3+\n    mat4(.010,.259,-.441,-.294,.240,.295,-.219,-.143,.266,.289,-.156,.107,-.597,.057,.482,.448)*f0_4+\n    mat4(-.039,-.055,-.175,-.564,.580,.510,.331,.322,-.014,.472,.018,-.033,-.334,.641,-.017,-.224)*f0_5+\n    vec4(-.247,-.230,-.295,-.506));\nf0_0=sin(mat4(-.311,-.240,.717,-.452,.006,-.054,-.320,-.434,.398,-.150,-.249,.398,.114,.583,-.238,-.302)*f1_0+\n    mat4(-.228,.142,.143,.083,-.099,.632,.480,-.293,.581,-.320,.056,.208,-.002,.451,-.417,-.251)*f1_1+\n    mat4(.434,-.376,.132,.231,-.119,-.115,-.111,.235,.074,.296,-.395,-.113,.331,-.284,-.585,-.040)*f1_2+\n    mat4(.308,-.332,-.080,.161,-.227,.149,.408,.520,.216,-.203,.528,.128,-.042,.122,-.446,-.125)*f1_3+\n    mat4(-.005,.336,.444,-.013,.526,-.013,.171,-.512,-.100,.033,.163,-.313,.432,-.322,-.147,.361)*f1_4+\n    mat4(-.347,.512,.581,-.207,-.441,.731,-.419,.324,-.078,.353,.301,-.119,-.327,.037,-.272,-.171)*f1_5+\n    vec4(-.035,.235,-.131,.113));\nf0_1=sin(mat4(-.235,.193,-.491,-.153,-.166,.044,-.165,-.155,-.405,.284,-.442,-.344,-.355,-.048,.038,.455)*f1_0+\n    mat4(-.454,.315,-.010,.057,-.195,.586,-.074,-.454,.356,.469,.041,.053,-.222,.012,.073,-.081)*f1_1+\n    mat4(.329,.493,.652,.447,-.239,-.393,-.200,.208,.421,-.156,-.194,-.144,-.276,.221,.354,-.302)*f1_2+\n    mat4(.272,.197,-.497,.245,.391,-.296,-.412,.620,.144,.015,-.199,.136,-.682,.214,.127,.199)*f1_3+\n    mat4(.308,-.147,.275,-.517,.058,-.155,.424,-.114,.135,-.129,.489,-.012,-.397,-.218,.376,.227)*f1_4+\n    mat4(-.134,.031,.173,-.276,-.185,-.466,.679,.092,.526,.133,-.423,.381,.610,.478,-.040,.057)*f1_5+\n    vec4(-.552,-.650,.353,-.072));\nf0_2=sin(mat4(.147,-.256,.492,.136,-.307,.178,.181,.409,-.130,-.510,.198,.089,-.035,.193,.093,.156)*f1_0+\n    mat4(-.234,-.029,.451,.282,-.084,.076,.095,-.207,-.156,-.161,.173,.699,-.097,-.143,-.168,.614)*f1_1+\n    mat4(.205,-.181,.110,-.426,.168,-.171,-.070,.347,-.582,.366,-.469,.708,-.681,-.035,.424,-.238)*f1_2+\n    mat4(.027,.198,.397,.150,.011,-.383,-.006,-.070,.331,-.106,.211,-.341,-.101,-.208,-.401,.069)*f1_3+\n    mat4(-.455,-.369,-.104,-.214,.334,-.629,.042,.248,.020,-.170,.421,-.305,-.344,-.010,-.020,.351)*f1_4+\n    mat4(.048,.233,.381,-.065,-.282,.527,-.359,.374,.451,-.106,.465,-.038,-.044,.076,.270,-.402)*f1_5+\n    vec4(.575,.021,.144,.052));\nf0_3=sin(mat4(.163,.020,.186,.260,-.254,-.179,-.086,.087,.100,-.130,.392,.433,-.167,.144,.078,-.079)*f1_0+\n    mat4(-.127,.057,-.265,-.362,-.083,.096,.230,.159,-.786,.497,-.372,.502,-.021,-.181,-.425,-.047)*f1_1+\n    mat4(-.700,-.094,-.065,-.273,.522,.057,.194,.168,-.092,.361,.284,.388,-.607,-.237,-.030,-.024)*f1_2+\n    mat4(-.127,-.074,.103,-.245,.029,.514,.196,.177,.367,-.326,-.051,-.054,.117,-.261,-.466,.283)*f1_3+\n    mat4(-.376,-.144,.302,-.019,.242,.194,.202,-.117,.313,.253,-.451,.030,-.327,-.456,.435,.066)*f1_4+\n    mat4(-.018,.229,-.121,.339,.298,.104,.197,.093,.307,.252,.311,.244,.324,-.095,.003,.062)*f1_5+\n    vec4(.697,.637,.357,-.421));\nf0_4=sin(mat4(-.100,.226,.397,-.333,-.156,.018,-.033,-.112,.104,-.467,.158,-.450,.127,.150,-.138,-.502)*f1_0+\n    mat4(-.364,-.225,-.547,-.060,-.180,-.804,-.161,-.322,.551,.087,.007,.568,.261,-.461,-.172,.302)*f1_1+\n    mat4(.168,.132,.163,.006,-.051,.486,-.208,-.750,.088,-.228,-.679,-.238,-.546,.201,.089,.297)*f1_2+\n    mat4(.375,.233,.280,-.300,-.011,-.135,.208,-.037,-.259,-.024,.329,-.532,.040,-.238,-.089,-.570)*f1_3+\n    mat4(.030,.132,.322,.142,-.012,.404,-.666,-.155,.701,-.112,-.107,.028,.462,-.035,-.050,-.278)*f1_4+\n    mat4(.402,-.124,.402,-.108,.278,-.076,.011,-.186,-.147,-.632,.142,.242,-.313,-.377,.456,-.201)*f1_5+\n    vec4(-1.057,-.154,.221,-.823));\nf0_5=sin(mat4(-.219,-.247,-.373,-.516,.463,-.270,.015,.230,.066,-.155,.242,-.534,-.099,.409,.110,.100)*f1_0+\n    mat4(.318,-.128,.085,-.390,.231,.050,-.039,.090,.510,.143,-.087,.021,-.576,-.679,-.107,.153)*f1_1+\n    mat4(-.092,.635,-.252,.180,.150,-.743,.176,-.138,-.412,.216,.152,-.319,-.308,.577,.084,-.177)*f1_2+\n    mat4(-.091,.601,.110,.253,-.087,-.269,.172,.689,-.027,.322,.260,.120,-.148,-.451,.485,.233)*f1_3+\n    mat4(.385,-.113,.222,-.131,.051,-.261,.036,.533,.403,.308,.421,.066,.647,.020,-.659,.128)*f1_4+\n    mat4(-.320,.169,.196,-.107,.131,-.096,.016,.056,.442,.341,-.418,-.374,-.189,.032,-.027,-.159)*f1_5+\n    vec4(.004,-.390,.018,.161));\nf1_0=sin(mat4(-.312,.024,-.630,-.336,.061,-.310,.012,.167,.411,-.267,.405,-.409,.377,.442,.157,.107)*f0_0+\n    mat4(-.022,.309,.115,-.133,.294,-.041,.283,.001,-.272,-.227,.044,-.112,.177,.259,.464,-.182)*f0_1+\n    mat4(.387,-.458,.011,-.588,.147,.205,.241,.601,.388,.748,.284,-.391,.579,.390,.386,-.331)*f0_2+\n    mat4(.441,.483,-.354,-.232,.055,-.019,.314,.194,-.021,-.039,.251,.208,.128,-.570,.376,.386)*f0_3+\n    mat4(.205,-.230,-.213,-.136,-.498,.140,.097,-.188,.203,.486,.265,.167,.418,-.174,-.274,.068)*f0_4+\n    mat4(.141,-.370,.208,.319,-.034,.345,-.023,.057,.066,-.126,-.158,.139,-.544,.530,-.316,-.492)*f0_5+\n    vec4(-.082,-.339,.000,-.440));\nf1_1=sin(mat4(.939,.662,-.450,-.129,-.310,.186,-.234,.153,-.267,-.050,-.439,-.060,.233,-.199,.752,-.307)*f0_0+\n    mat4(-.205,-.076,-.245,-.543,.243,.091,.065,.077,.118,-.286,.123,.210,-.670,.386,-.081,-.347)*f0_1+\n    mat4(-.425,.217,.043,.329,-.298,-.130,.768,.694,.126,-.131,-.656,.139,-.059,.263,-.074,.128)*f0_2+\n    mat4(.320,.284,.679,-.213,-.357,.527,.094,.269,.095,.241,.120,-.424,-.057,.523,-.040,-.230)*f0_3+\n    mat4(-.196,.082,-.021,.117,-.220,-.289,-.098,.588,-.254,-.208,.009,-.124,.273,.191,-.065,.076)*f0_4+\n    mat4(-.658,-.170,-.109,-.073,.243,.337,.012,.285,.427,-.475,-.376,.379,-.528,-.356,.340,-.327)*f0_5+\n    vec4(.366,.087,.493,-.236));\nf1_2=sin(mat4(-.024,.190,-.901,.430,.007,-.445,-.143,-.435,-.234,-.243,.289,-.050,.104,.416,-.143,-.345)*f0_0+\n    mat4(.071,-.090,-.292,-.247,-.295,.431,-.259,-.263,-.444,.538,.100,.362,-.537,-.036,.110,.241)*f0_1+\n    mat4(-.586,.502,-.288,-.082,-.385,.320,-.250,-.777,-.215,.194,-.233,.303,.263,-.479,-.728,-.031)*f0_2+\n    mat4(-.123,-.395,.017,-.002,.421,-.491,.619,.314,-.062,-.027,.118,.079,-.234,.314,.033,.036)*f0_3+\n    mat4(-.268,.125,-.298,-.058,-.400,.686,-.391,-.405,-.481,.027,-.346,-.230,.336,-.220,-.200,.292)*f0_4+\n    mat4(.010,-.026,-.316,.321,-.124,-.195,.372,.604,-.219,-.294,.530,-.013,.294,.004,-.204,-.510)*f0_5+\n    vec4(-.163,-.861,.993,.395));\nf1_3=sin(mat4(.353,.370,-.648,.571,.011,.248,.112,-.156,-.217,.350,-.367,.150,-.023,.088,-.254,-.335)*f0_0+\n    mat4(-.486,-.428,.079,-.067,.504,.917,.477,-.043,.194,.106,-.103,-.185,.096,.204,-.128,-.003)*f0_1+\n    mat4(.038,.434,-.300,.340,-.150,.240,-.931,-.116,.250,.313,.107,-.202,.516,.528,.264,.151)*f0_2+\n    mat4(.382,.729,-.001,-.838,-.249,-.322,-.448,-.064,-.268,.109,-.156,.011,-.086,.538,-.602,-.573)*f0_3+\n    mat4(-.437,.219,.140,-.269,.053,-.051,-.024,.013,.397,-.051,-.486,.049,.072,-.241,-.216,-.433)*f0_4+\n    mat4(.256,-.062,.328,.091,-.291,.352,-.454,.005,.115,-.064,-.185,-.447,-.073,-.195,.220,-.021)*f0_5+\n    vec4(-.557,-.240,-.447,.129));\nf1_4=sin(mat4(.542,-.400,.024,-.104,.170,.354,.088,-.317,.489,.126,.125,.190,.435,-.096,.520,.084)*f0_0+\n    mat4(.300,-.135,-.132,-.060,.459,-.048,.039,.539,-.194,-.180,-.140,-.007,.185,-.244,-.375,-.209)*f0_1+\n    mat4(-.575,-.268,.007,-.912,.374,-.143,-.279,-.275,.217,-.423,.034,-.359,.364,.171,.236,.016)*f0_2+\n    mat4(-.296,-.119,-.495,.204,-.460,-.099,-.590,-.784,-.248,-.385,.282,.104,.242,-.435,.416,-.066)*f0_3+\n    mat4(-.334,-.098,-.070,.722,.375,-.196,.322,.389,-.397,.316,.547,-.154,.424,-.135,.254,.463)*f0_4+\n    mat4(-.212,.140,.329,.109,.473,-.332,-.062,.057,-.217,-.500,.036,-.169,.281,.039,-.417,-.513)*f0_5+\n    vec4(-.173,-.020,.499,-.097));\nf1_5=sin(mat4(.033,-.520,.279,.198,-.313,.368,.292,-.195,.175,-.622,.135,.235,-.319,-.284,.041,-.220)*f0_0+\n    mat4(-.096,-.400,-.264,.470,-.519,.088,-.215,.526,.598,.294,.046,.111,-.276,-.281,-.208,-.252)*f0_1+\n    mat4(-.075,.140,-.345,-.070,.087,.168,-.757,-.049,-.242,.321,.477,.107,.555,.173,-.041,.125)*f0_2+\n    mat4(-.063,-.565,-.063,-.244,-.434,.052,.645,.090,.232,-.512,-.454,-.320,.299,-.480,.294,.365)*f0_3+\n    mat4(-.444,.085,-.091,.000,-.044,-.262,.090,-.692,-.279,-.406,-.105,.332,.097,-.126,.213,-.182)*f0_4+\n    mat4(.317,.473,.578,.130,-.239,.497,.160,-.095,-.184,.247,.119,-.096,-.059,.365,-.081,.100)*f0_5+\n    vec4(-.156,-.084,-.360,.137));\nf0_0=sin(mat4(-.449,.183,.221,.282,.380,-.485,.166,.383,.155,.880,.530,-.531,.068,.204,.215,.269)*f1_0+\n    mat4(.550,-.065,.327,.018,-.359,.287,.536,.064,-.339,-.068,.022,-.228,-.316,-.293,-.108,.002)*f1_1+\n    mat4(-.079,.221,.285,-.446,-.037,.512,.014,-.326,.223,-.064,.060,.215,.112,-.004,.146,.438)*f1_2+\n    mat4(.477,-.069,-.234,-.116,.184,-.341,.555,.034,.083,-.349,.053,-.171,.012,-.383,-.098,.097)*f1_3+\n    mat4(.210,-.120,.492,-.116,-.283,.033,-.446,.447,.292,.107,-.368,-.274,.083,-.130,-.381,-.438)*f1_4+\n    mat4(-.290,.205,-.593,-.113,-.164,.038,-.221,-.654,.355,-.027,.071,.169,.245,.070,-.688,.034)*f1_5+\n    vec4(.081,.063,-.581,-.065));\nf0_1=sin(mat4(.172,-.515,-.568,-.493,.125,-.020,-.181,.136,.608,-.790,.141,-.538,-.610,1.011,.466,-.359)*f1_0+\n    mat4(.185,.433,.152,.360,.133,.174,.035,.315,-.207,-.524,-.019,.178,-.026,.430,.199,-.125)*f1_1+\n    mat4(.222,.648,-.023,.074,-.230,.151,-.163,-.319,.393,-.619,-.189,-.477,.248,.054,-.505,.530)*f1_2+\n    mat4(.119,.251,.352,.850,.194,.489,.251,-.366,.492,-.384,.784,.013,-.555,-.475,.429,.033)*f1_3+\n    mat4(.439,.125,.331,-.277,.252,-.162,-.518,-.297,-.026,.228,-.298,-.559,-.195,.114,-.197,-.265)*f1_4+\n    mat4(.714,.135,.398,-.351,.149,-.020,.469,.008,.298,-.289,-.262,.173,.244,-.060,.480,-.582)*f1_5+\n    vec4(.215,-.210,.631,.540));\nf0_2=sin(mat4(.728,-.053,-.227,.126,.553,.556,.212,.009,-.529,.658,.161,-.230,-.430,.041,.725,-.235)*f1_0+\n    mat4(.132,-.168,-.400,-.090,-.078,-.258,-.292,.031,.307,-.477,.337,.199,.507,.187,.197,-.423)*f1_1+\n    mat4(.382,.049,.205,.158,-.507,-.197,.070,-.225,.301,-.160,-.254,-.074,-.250,.713,-.244,.011)*f1_2+\n    mat4(.325,.425,.318,-.555,.138,.112,.420,-.237,.002,.282,-.143,.296,-.156,.115,.417,.290)*f1_3+\n    mat4(-.340,-.608,-.179,.275,.257,.439,-.367,.334,.005,-.437,.422,-.132,.128,-.184,.294,.128)*f1_4+\n    mat4(-.165,.318,.032,-.242,-.071,-.481,-.295,.252,.364,-.584,.426,-.232,-.217,-.267,-.414,.037)*f1_5+\n    vec4(-.379,.183,.203,-.520));\nf0_3=sin(mat4(-.194,-.203,.312,-.204,.021,.219,-.213,-.286,.306,-.614,.465,.507,.434,.332,-.447,.402)*f1_0+\n    mat4(.176,-.102,-.136,.034,-.477,-.100,.219,.459,.562,-.147,-.041,-.374,.154,-.456,-.151,-.073)*f1_1+\n    mat4(-.312,-.183,.270,-.312,.434,-.246,-.253,-.289,-.003,-.442,.018,.085,.419,.398,-.458,-.057)*f1_2+\n    mat4(-.194,.313,.248,-.271,-.229,-.085,.309,-.423,.106,.287,-.404,-.114,-.315,-.200,.189,-.417)*f1_3+\n    mat4(.162,.147,-.085,.110,-.276,.261,.417,-.581,-.005,.608,.160,-.452,-.076,-.376,-.203,.424)*f1_4+\n    mat4(-.296,-.110,-.406,-.012,.246,.740,.071,.108,.500,-.229,.339,.537,-.009,-.484,-.031,-.028)*f1_5+\n    vec4(.353,.182,.256,-.056));\nf0_4=sin(mat4(.297,-.165,-.137,.214,-.045,-.307,.298,.086,.132,.027,.120,.067,.126,-.564,-.441,.103)*f1_0+\n    mat4(.444,-.401,-.001,-.409,-.021,.098,-.257,-.336,.048,.026,-.021,-.182,-.272,-.093,-.276,.421)*f1_1+\n    mat4(-.276,-.047,.398,.134,.292,-.618,.268,.395,-.297,.328,-.040,.289,-.487,.051,.206,-.463)*f1_2+\n    mat4(.456,.068,-.144,-.416,.317,.399,-.190,-.436,.274,.050,.138,.559,-.297,.594,.215,-.310)*f1_3+\n    mat4(.021,.026,.245,-.216,-.372,-.308,-.072,.314,.458,-.607,-.109,.531,.157,-.544,.123,.142)*f1_4+\n    mat4(-.461,-.226,.098,-.172,-.130,-.003,.415,-.098,.166,.009,-.024,-.186,.260,.002,.041,.032)*f1_5+\n    vec4(.143,.235,.295,.188));\nf0_5=sin(mat4(-.356,-.232,-.295,.237,-.134,.059,-.246,-.052,-.326,.668,-.564,-.543,.646,.202,.080,-.136)*f1_0+\n    mat4(-.153,-.557,.316,.396,-.364,.018,-.160,.106,-.204,.246,-.030,.138,-.166,-.330,.149,-.332)*f1_1+\n    mat4(.498,-.453,.376,.240,-.360,-.064,.008,-.004,-.252,.095,.237,.073,-.559,-.281,.556,.133)*f1_2+\n    mat4(-.480,-.120,-.211,-.268,.355,-.302,-.328,.459,.009,.151,.171,.297,-.145,-.495,-.229,-.481)*f1_3+\n    mat4(-.484,.442,-.249,-.158,-.030,.006,.139,-.823,-.567,.418,.301,.482,.566,-.184,-.058,.022)*f1_4+\n    mat4(-.247,.068,.037,.512,-.028,.299,-.306,.130,.065,-.448,-.374,-.035,-.607,.083,.224,.397)*f1_5+\n    vec4(.548,-.147,.637,-.209));\nf1_0=sin(mat4(.327,.301,.430,-.266,-.617,.288,-.080,.576,-.226,-.109,.744,.208,.421,-.458,-.361,.258)*f0_0+\n    mat4(.228,.259,.030,.577,-.128,.133,.317,.012,.160,-.092,-.242,-.153,-.370,.481,.292,.272)*f0_1+\n    mat4(.272,.278,.217,.021,.135,-.288,-.464,-.230,.470,.288,.650,-.795,-.069,.361,.557,-.444)*f0_2+\n    mat4(-.272,-.096,-.278,.390,.025,-.235,-.727,-.036,-.033,-.073,.782,-.122,.200,.388,-.052,-.172)*f0_3+\n    mat4(.010,-.138,-.460,-.620,.118,-.111,-.025,.070,.001,.555,-1.093,-.297,-.222,.177,.420,.345)*f0_4+\n    mat4(-.242,-.188,-.772,.460,.606,-.332,.135,-.051,-.341,-.229,.148,-.664,-.069,-.479,.456,.107)*f0_5+\n    vec4(.248,.022,-.163,.161));\nf1_1=sin(mat4(.608,.380,.282,.742,.122,-.153,-.159,.404,-.174,-.287,-.092,-.323,.301,.200,-.341,-.235)*f0_0+\n    mat4(.024,.092,.042,-.009,-.287,-.354,.275,-.035,-.154,.378,-.431,.309,-.072,-.192,-.179,-.072)*f0_1+\n    mat4(-.064,.016,-.529,.287,-.083,.115,-.457,.039,-.237,.583,-.079,-.316,.622,-.332,-.269,-.180)*f0_2+\n    mat4(.114,.023,.036,.353,-.516,.224,-.316,.104,.248,.436,.694,-.358,-.470,-.024,.395,.113)*f0_3+\n    mat4(-.355,-.265,.132,.379,-.178,-.039,-.201,-.714,.345,-.236,-.419,.474,-.574,-.291,.110,.401)*f0_4+\n    mat4(.316,-.517,-.129,-.312,.088,.189,.002,-.156,.391,.426,-.431,-.437,-.023,-.008,-.028,.525)*f0_5+\n    vec4(-.337,.414,-.179,-.398));\nf1_2=sin(mat4(-.032,-.385,.281,-.248,-.410,.257,.453,-.226,.394,-.270,.561,.379,.700,.445,.173,-.110)*f0_0+\n    mat4(.069,.618,.534,.099,-.012,.319,.163,.057,-.219,.249,.010,-.497,.500,-.190,-.048,.677)*f0_1+\n    mat4(.211,-.629,-.315,.225,-.079,.361,.026,-.268,-.468,-.374,.259,.105,-.130,-.405,.473,-.054)*f0_2+\n    mat4(.417,.450,.105,.827,.052,-.249,-.291,.509,-.374,-.127,.373,-.329,.465,-.262,-.467,-.573)*f0_3+\n    mat4(.478,-.073,.427,-.097,-.481,.427,.441,-.171,-.310,.347,.263,-.132,-.010,.034,-.118,-.485)*f0_4+\n    mat4(-.110,-.016,-.297,.057,.432,.063,.155,.277,-.099,-.437,.142,-.034,-.628,-.246,.496,.623)*f0_5+\n    vec4(.355,.369,.285,.210));\nf1_3=sin(mat4(-.443,.545,-.470,.335,.200,.304,.504,.388,.172,.234,.139,-.229,-.108,-.162,-.189,.266)*f0_0+\n    mat4(-.578,.080,.191,.182,.204,-.315,.155,-.107,-.186,-.428,-.034,-.185,.470,.034,-.099,-.064)*f0_1+\n    mat4(-.210,.302,-.181,-.159,-.147,.432,.388,-.039,-.155,-.271,.577,-.147,.081,.045,.018,-.197)*f0_2+\n    mat4(.022,-.156,.343,.702,.370,.175,-.163,.137,.021,.462,-.097,-.221,.370,.402,-.506,-.535)*f0_3+\n    mat4(-.282,.442,.208,.200,-.058,-.672,.293,-.304,.242,.044,-.072,-.388,-.104,.296,.191,.514)*f0_4+\n    mat4(.433,.022,-.445,.491,.013,.141,.150,-.402,-.744,.176,-.468,.331,.531,.387,-.369,.119)*f0_5+\n    vec4(.618,.781,-.412,.331));\nf1_4=sin(mat4(-.167,.158,.437,.619,-.497,-.569,.020,-.512,-.386,.636,.271,-.059,.135,.069,-.718,.430)*f0_0+\n    mat4(-.477,-.043,.764,.374,-.114,.213,-.198,-.125,-.103,.382,.171,-.060,-.179,-.673,-.293,-.043)*f0_1+\n    mat4(.136,-.096,.223,-.354,-.472,-.019,.390,.075,.292,-.433,.185,.158,.107,-.147,-.332,.524)*f0_2+\n    mat4(.327,-.078,.231,.322,-.389,.111,.286,-.196,-.310,.190,-.600,-.194,-.366,-.215,.060,.359)*f0_3+\n    mat4(-.253,.180,-.544,-.188,.008,.031,.266,.196,-.359,-.237,-.430,.301,-.018,-.428,-.442,-.506)*f0_4+\n    mat4(-.364,-.214,.199,-.147,.281,-.685,.143,-.569,-.052,.580,.734,-.319,.499,.677,.018,-.216)*f0_5+\n    vec4(.480,.470,-.237,-.186));\nf1_5=sin(mat4(-.344,-.097,.461,-.055,.523,-.473,-.422,-.110,.166,.166,-.491,-.145,-.188,-.298,.268,-.052)*f0_0+\n    mat4(.064,.601,.520,-.028,-.548,.022,-.103,.017,.277,.020,-.042,-.390,-.486,.001,-.297,.348)*f0_1+\n    mat4(.589,-.272,-.172,.469,-.286,.226,-.376,-.387,-.425,-.091,-.084,-.237,.381,.045,.062,.065)*f0_2+\n    mat4(.173,-.272,.424,-.630,-.443,.194,.459,.488,.083,-.214,.542,.105,.049,-.716,.007,.481)*f0_3+\n    mat4(-.435,.319,-.485,-.131,-.389,-.290,.353,.500,.151,-.425,1.009,.445,-.328,.101,.264,-.283)*f0_4+\n    mat4(-.033,.001,-.104,-.725,.071,-1.080,.323,-.438,-.256,-.107,-.135,.458,-.541,.213,-.039,.329)*f0_5+\n    vec4(.931,-.218,.196,.231));\nf0_0=sin(mat4(.149,.505,.294,.219,-.395,-.292,.053,-.171,-.251,-.238,-.051,.097,.466,-.560,.355,.133)*f1_0+\n    mat4(.021,.059,-.310,-.106,.499,-.033,.391,-.010,.081,.011,-.490,.450,-.092,.380,.450,.196)*f1_1+\n    mat4(.912,-.236,.220,.630,-.135,-.211,-.338,-.232,.237,-.018,-.000,-.234,-.020,-.074,.148,-.055)*f1_2+\n    mat4(.657,.226,.057,.182,-.345,-.775,.108,.664,-.473,.850,-.360,.223,-.131,-.274,.414,-.007)*f1_3+\n    mat4(.866,-.156,-.177,-.620,.112,.443,.054,.330,.216,.159,.224,.462,-.185,-.229,.104,-.292)*f1_4+\n    mat4(-.573,.246,.374,-.272,.144,.154,.847,-.144,.548,-.346,.112,-.078,.412,.041,-.217,.584)*f1_5+\n    vec4(.161,.685,-.150,-.229));\nf0_1=sin(mat4(-.005,-.752,.277,-.058,.715,.337,-.126,-.139,-.265,-.117,-.035,-.079,.624,.211,-.299,-.207)*f1_0+\n    mat4(.381,-.115,-.107,.173,.432,-.357,-.453,.241,.077,-.152,.225,.038,-.386,-.145,-.119,.191)*f1_1+\n    mat4(.111,-.135,.882,.624,-.160,-.478,-.731,.128,.576,-.373,-.455,-.555,.227,-.170,.107,-.356)*f1_2+\n    mat4(.291,-.019,.061,-.424,-.195,-.231,-.134,-.130,.047,-.177,.729,.228,.423,-.358,-.241,.451)*f1_3+\n    mat4(.361,-.153,.174,.163,.017,-.230,-.550,.387,.393,.196,-.410,-.094,-.520,.411,-.380,-.543)*f1_4+\n    mat4(.759,.474,-.277,.261,-.265,.566,-.355,-.111,.014,-.268,.149,.022,-.305,.245,-.130,.105)*f1_5+\n    vec4(-.396,-.656,-.474,.114));\nf0_2=sin(mat4(-.434,.296,.724,.264,-.379,.420,-1.096,-.260,-.319,-.142,-.109,-.131,.776,-.190,-.019,-.340)*f1_0+\n    mat4(.314,-.019,-.264,-.236,.295,-.323,.134,.300,-.890,.453,.125,.057,.131,.062,.106,.573)*f1_1+\n    mat4(.238,-.225,.143,.168,.456,-.000,-.565,.289,.165,-.254,-.359,.115,.044,-.333,-.131,-.401)*f1_2+\n    mat4(.120,.167,.129,-.024,.497,-.077,.295,-.053,.151,-.310,-.348,.247,-.158,-.373,.308,-.151)*f1_3+\n    mat4(.351,-.177,.631,-.458,.450,-.097,-.107,-.477,.131,-.348,.486,-.166,-.057,.538,.178,.157)*f1_4+\n    mat4(.172,.357,-.531,-.387,-.073,-.277,.401,-.199,.204,-.028,.211,.157,-.047,.594,.365,-.490)*f1_5+\n    vec4(.154,-.389,-.874,.480));\nf0_3=sin(mat4(-.570,-.266,.259,-.411,.025,-.373,.079,-.231,-.040,.396,.179,-.041,-.535,.808,-.095,-.094)*f1_0+\n    mat4(.437,-.056,.300,.327,.023,-.256,.098,-.414,-.144,.535,-.028,.142,.107,.065,.719,-.216)*f1_1+\n    mat4(.503,-.354,.340,-.177,-.303,.811,-.356,.044,-.139,.030,.097,.404,.354,.120,-.056,.249)*f1_2+\n    mat4(.316,-.427,-.667,-.103,-.006,-.285,-.055,-.184,.517,-.504,-.605,-.569,.698,-.232,-.699,-.125)*f1_3+\n    mat4(.034,.425,-.333,.093,-.017,-.119,-.139,.565,.236,.580,-.651,.430,.159,-.013,-.852,.654)*f1_4+\n    mat4(.104,.076,.258,-.049,-.416,-.322,.356,.007,-.532,.359,-.453,-.453,-.069,.170,.261,.103)*f1_5+\n    vec4(.021,-.246,.029,.744));\nf0_4=sin(mat4(-.442,.067,.334,-.119,.186,.191,-.270,.335,.027,-.041,-.178,.408,.048,.408,-.086,-.552)*f1_0+\n    mat4(-.514,.348,-.005,.401,.254,.173,.281,-.490,-.340,-.152,-.314,-.129,.208,.136,-.711,-.813)*f1_1+\n    mat4(.059,-.175,.474,-.079,.622,.144,-.304,.069,-.138,-.223,.409,.225,.215,-.038,-.203,-.670)*f1_2+\n    mat4(.247,.099,.043,.014,-.396,.067,.474,.552,.384,-.227,-.539,-.274,.133,-.581,-.133,.267)*f1_3+\n    mat4(.053,-.276,.132,-.285,-.282,.057,-.342,.323,.013,.412,.390,-.164,-.151,-.423,-.591,-.278)*f1_4+\n    mat4(.390,-.043,-.011,.396,-.442,.138,-.664,-.386,.006,-.224,-.394,.064,-.072,-.205,-.218,-.922)*f1_5+\n    vec4(-.419,-.291,-.129,.877));\nf0_5=sin(mat4(-.044,.253,.298,-.085,-.349,.020,.662,.137,-.220,.317,.020,-.117,-.051,.165,-.253,.434)*f1_0+\n    mat4(.145,-.366,-.611,-.597,-.288,.111,-.071,.055,.614,-.108,-.172,.281,.345,-.208,-.283,.311)*f1_1+\n    mat4(.320,.336,.367,.637,.004,-.198,.078,.290,.240,.275,.138,-.485,.206,-.265,-.105,-.017)*f1_2+\n    mat4(-.088,.374,-.197,.067,.524,.104,.751,-.342,-.034,-.161,-.191,.162,.376,.155,.233,-.417)*f1_3+\n    mat4(.417,-.289,.305,.580,-.413,.692,-.872,.270,.066,.292,-.241,.405,-.716,-.285,.608,.095)*f1_4+\n    mat4(-.326,-.224,-.253,-.136,-.248,-.213,.392,-.218,-.030,-.077,-.020,-.039,.029,-.472,-.234,.113)*f1_5+\n    vec4(.333,-.042,-.254,.169));\nf1_0=sin(mat4(.032,.228,.255,.158,-.080,-.185,.549,.077,.007,-.481,.127,-.246,.044,.352,-.095,-.640)*f0_0+\n    mat4(-.508,-.382,-.110,.546,.357,.252,.034,.572,-.420,.144,-.357,.409,.376,-.296,.174,.305)*f0_1+\n    mat4(-.863,-.311,-.097,.649,-.474,.045,.810,-.398,.078,.327,-.166,-.073,-.710,.292,.317,-.175)*f0_2+\n    mat4(.349,-.014,-.365,-.233,-.207,.569,.294,.021,.084,-.145,.270,-.073,-.153,-.339,-.139,-.095)*f0_3+\n    mat4(.135,-.428,-.462,.006,.586,.023,.390,.344,-.047,.612,-.508,.783,.149,.193,-.023,-.166)*f0_4+\n    mat4(-.203,-.467,.636,-.402,-.465,.454,.558,.355,.510,-.205,.501,.380,.141,.350,.105,-.245)*f0_5+\n    vec4(.690,.483,.091,.569));\nf1_1=sin(mat4(-.331,-.267,.616,-.407,.119,-.319,-.036,.127,.092,-.045,.304,.532,.295,.186,.460,.097)*f0_0+\n    mat4(.693,-.455,-.251,-.024,-.300,-.590,-.381,-.257,.252,.118,-.145,-.022,-.770,.581,-.249,.163)*f0_1+\n    mat4(.132,-.177,-.042,-.292,-.429,.627,.155,-.422,.023,-.679,.431,.285,.121,-.431,-.569,.465)*f0_2+\n    mat4(-.064,.051,.024,.200,-.142,-.466,.310,.036,.562,-.619,.307,-.290,-.379,.012,-.016,.213)*f0_3+\n    mat4(.762,.542,-.044,.783,-.417,.125,.184,.296,.434,-.609,-.481,.535,-.154,.270,.097,.002)*f0_4+\n    mat4(.713,.414,-.071,.210,.674,-.245,.049,.523,-.366,-.229,.282,.109,.448,.143,.823,-.191)*f0_5+\n    vec4(-.139,.448,-.360,-.239));\nf1_2=sin(mat4(-.244,-.325,-.221,.394,-.541,.838,-.296,-.597,-.388,.431,.062,.608,.262,-.114,.621,.086)*f0_0+\n    mat4(.688,.372,-.221,-.278,.615,.775,.185,-.207,.330,.445,-.175,.223,-.256,-.074,.430,-.022)*f0_1+\n    mat4(-.090,-.310,.297,.176,.390,.124,.464,.507,-.220,.053,.359,-.370,.486,.958,.133,.589)*f0_2+\n    mat4(.194,.705,-.046,.602,.009,.675,-.323,.022,-.441,.284,.221,-.177,-.580,-.231,-.500,.283)*f0_3+\n    mat4(.297,-.316,-.526,-.676,.206,-.508,-.169,.545,-.114,-.383,.098,-.545,-.546,.092,.799,-.533)*f0_4+\n    mat4(.103,.215,.016,-.079,.460,-.400,.119,-.789,.023,-.254,.129,.104,.047,-.099,-.431,-.109)*f0_5+\n    vec4(-.211,.070,-.098,-.899));\nf1_3=sin(mat4(-.530,-.231,.088,-.106,.178,.418,.607,.439,-.150,.498,.053,-.575,-.431,.302,-.123,.157)*f0_0+\n    mat4(.089,-.488,-.384,-.294,.148,-.077,.062,-.237,.025,.229,-.015,-.394,.245,.177,-.174,-.035)*f0_1+\n    mat4(.123,.068,-.177,.240,-.159,-.162,-.018,.595,-.030,-.513,.108,.060,.708,.286,.447,.358)*f0_2+\n    mat4(-.317,-.240,-.419,.339,.162,-.088,.046,-.194,.412,-.268,-.245,-.020,.497,.196,-.169,-.424)*f0_3+\n    mat4(.124,.346,-.285,.198,-.807,-.095,-.130,.457,-.529,.332,-.483,-.198,.106,.006,-.210,.234)*f0_4+\n    mat4(.339,-.128,.566,-.303,-.599,.357,.136,-.496,-.134,-.419,-.486,-.297,.708,-.729,-.672,.213)*f0_5+\n    vec4(-.127,-.361,.192,-.342));\nf1_4=sin(mat4(.320,-.161,.059,-.142,-.067,-.006,.146,.161,-.277,.022,.529,.552,-.007,.319,.137,-.495)*f0_0+\n    mat4(-.258,-.217,-.112,-.494,-.174,-.014,.372,-.511,.187,-.462,.485,.650,.135,-.204,.480,-.399)*f0_1+\n    mat4(.153,-.097,-.448,.557,.102,.663,-.131,.269,-.107,-.038,.193,-.049,-.093,-.243,.826,-.217)*f0_2+\n    mat4(.259,.649,.397,-.034,.125,.147,-.350,-.068,.243,-.336,-.655,-.127,-.370,.202,.258,.486)*f0_3+\n    mat4(-.113,-.065,-.486,-.342,-.072,-.396,-.410,-.313,.656,.030,.203,.263,.342,-.311,.118,-.605)*f0_4+\n    mat4(.587,.111,-.219,.536,-.028,.256,.340,.291,-.209,-.277,.403,.325,.028,.052,.021,-.045)*f0_5+\n    vec4(-.320,.164,-.816,-.384));\nf1_5=sin(mat4(.298,-.324,-.213,-.360,-.734,-.190,-.475,.502,.393,.172,-.479,-.320,.233,.198,.909,-.563)*f0_0+\n    mat4(.159,.482,-.264,-.673,.347,-.554,-.270,.151,.014,.329,.031,.254,-.271,.104,-.333,-.260)*f0_1+\n    mat4(-.130,-.160,.005,-.462,-.124,.447,-.838,.190,-.217,-.011,.377,-.182,-.391,-.115,-.193,-.625)*f0_2+\n    mat4(.352,.203,.398,-.325,.320,-.073,.014,-.422,.140,.057,.539,-.490,-.532,-.570,-.234,.023)*f0_3+\n    mat4(.407,.796,-.636,.393,.108,.319,-.174,.151,-.162,.177,.457,-.232,.288,-.207,-.338,-.266)*f0_4+\n    mat4(.175,-.741,.198,.079,.149,.187,-.254,.160,-.107,-.238,.180,.108,-.105,.149,.347,.320)*f0_5+\n    vec4(.558,.321,.120,-.359));\nf0_0=sin(mat4(-.712,.532,.177,.422,-.512,-.585,.368,-.095,-.248,-.169,.063,.253,.406,-.368,-.041,.388)*f1_0+\n    mat4(-.419,.365,.236,.382,-.408,-.528,-.173,-.379,.433,.444,-.785,-.135,.081,-.390,.551,.262)*f1_1+\n    mat4(-.376,.595,-.727,-.203,-.069,.381,-.398,-.247,-.141,-.127,-.527,.932,.050,.390,-.421,.053)*f1_2+\n    mat4(-.174,-.608,-.362,.450,-.056,-.363,.380,.224,.847,.591,-.963,.343,-.646,.023,-.481,-.431)*f1_3+\n    mat4(-.513,.618,-.013,.720,.491,.070,-.172,-.464,.390,.460,-.237,-.082,.118,-.095,.305,.212)*f1_4+\n    mat4(.571,-.038,-.270,-.133,.702,-.095,.193,.206,-.520,.086,.052,.028,.018,.578,-.068,.366)*f1_5+\n    vec4(.527,.072,-.069,-.319));\nf0_1=sin(mat4(-.652,-.124,-.111,-.388,.190,.300,.057,-.096,.141,-.415,-.200,-.032,-.263,.650,.406,-.146)*f1_0+\n    mat4(-.461,.294,.277,-.295,-.050,-.162,-.286,-.170,-.325,.167,.392,.114,.337,-.094,-.736,-.247)*f1_1+\n    mat4(.001,.095,-.464,.235,-.449,-.048,.122,-.107,.517,.305,.135,.348,.058,.415,-.268,.318)*f1_2+\n    mat4(-.961,.373,.045,-.438,-.400,-.100,.632,.208,-.388,.209,-.578,.330,.147,-.181,-.447,-.121)*f1_3+\n    mat4(.426,-.332,-.001,-.302,.071,-.107,.363,-.485,-.039,-.832,.148,-.365,-.112,-.028,.496,-.434)*f1_4+\n    mat4(.386,.525,-.201,.034,-.609,-.571,.362,.048,-.312,.036,.665,-.131,.085,.505,-.266,.297)*f1_5+\n    vec4(.987,-.334,-.186,-.038));\nf0_2=sin(mat4(.459,.210,-.170,.057,-.354,-.312,.165,-.414,-.579,-.361,-.449,-.050,-.548,.294,-.071,.106)*f1_0+\n    mat4(-.388,.075,-.467,-.259,-.490,-.190,.022,.229,.134,-.182,.003,.431,.149,-.030,-.237,-.134)*f1_1+\n    mat4(.519,-.325,.055,-.323,.504,-.194,-.111,-.238,.107,-.500,.347,.333,.424,-.499,-.676,-.283)*f1_2+\n    mat4(.664,-.037,.491,.337,.694,-.621,.591,-.252,-.504,.519,-.018,-.357,.076,-.404,-.882,-.363)*f1_3+\n    mat4(-.331,.203,.090,-.273,.734,.253,.051,.082,-.173,.369,.429,-.149,-.519,.079,-.204,-.204)*f1_4+\n    mat4(.367,-.275,.630,.105,-.247,-.846,-.622,.179,.398,-.042,-.050,-.302,.342,.250,.116,.286)*f1_5+\n    vec4(-.173,.728,.105,-.370));\nf0_3=sin(mat4(-.353,.138,-.011,.341,-.515,.279,.365,.352,.408,.076,.226,-.164,.587,-.518,.375,.391)*f1_0+\n    mat4(-.154,.252,-.179,.485,.761,.361,-.571,-.677,-.354,-.186,.729,.520,-.469,-.345,-.199,-.136)*f1_1+\n    mat4(-.504,.148,-.137,.216,-.184,.028,-.271,.399,-.295,.066,.221,-.389,-.507,-.272,-.027,-.100)*f1_2+\n    mat4(-.480,.024,.409,.010,-.395,.318,.727,-.280,.311,.538,-.006,.164,-.013,-.208,-.191,-.536)*f1_3+\n    mat4(.504,.159,.575,-.205,-.142,-.054,-.733,.099,-.780,.054,-.331,.442,-.168,.390,.140,.495)*f1_4+\n    mat4(-.495,.355,.689,.400,-.034,.365,.381,-.018,-.106,.168,-.138,-.501,.111,-.330,-.239,-.297)*f1_5+\n    vec4(.684,.215,-.399,-.342));\nf0_4=sin(mat4(-.034,-.191,.416,.402,-.266,-.289,.346,.189,-.300,-.603,.174,.684,.713,.382,.136,-.070)*f1_0+\n    mat4(.432,-.092,.208,.155,-.714,-.086,.251,-.289,.170,-.271,.006,-.320,.060,-.036,-.005,.062)*f1_1+\n    mat4(-.420,-.151,.574,-.455,.682,-.252,.090,.242,.215,-.186,-.346,.076,.319,-.037,.081,-.336)*f1_2+\n    mat4(-.345,-.237,-.003,.064,.392,-.628,-.145,-.252,.417,.450,.407,.434,-.049,.052,-.012,-.016)*f1_3+\n    mat4(-.671,-.479,.513,-.726,-.563,-.464,-.355,-.200,.432,-.437,-.057,-.505,-.172,-.124,-.341,.233)*f1_4+\n    mat4(.164,-.034,.248,.539,-.613,.245,-.684,.114,-.333,-.208,-.122,.008,-.091,-.352,-.167,.518)*f1_5+\n    vec4(.211,.503,-.531,.381));\nf0_5=sin(mat4(-.382,-.314,-.113,-.277,.385,-.031,.397,.383,-.092,-.084,.756,.530,.176,.136,.318,-.291)*f1_0+\n    mat4(-.337,.049,.151,.628,-.136,-.445,-.121,.019,.308,.506,-.545,-.140,-.860,.347,.330,-.310)*f1_1+\n    mat4(-.216,-.012,.019,.214,-.659,.018,-.011,.230,.068,.201,.291,-.031,-.213,.533,-1.091,.444)*f1_2+\n    mat4(.541,-.541,-.127,.257,-.034,-.357,-.249,.103,.594,-.639,-.051,-.091,-.598,.350,-.005,.731)*f1_3+\n    mat4(-.041,.096,.118,-.544,.637,-.504,.495,.141,-.381,-.468,.055,.202,.139,-.220,-.468,.489)*f1_4+\n    mat4(-.592,-.112,.916,.993,.094,-.038,-.193,.238,-.465,-.465,-.391,.242,-.031,-.514,-.168,.464)*f1_5+\n    vec4(-.714,-.024,-.039,-.017));\nf1_0=sin(mat4(.037,-.338,-.005,-.129,-.032,.109,.097,-.467,.385,.127,-.585,.271,-.172,-.345,.109,.930)*f0_0+\n    mat4(.713,-.214,.357,.308,-.246,-.320,-.094,.245,.261,-.319,-.469,-.558,.581,.616,.137,.108)*f0_1+\n    mat4(.210,-.681,-.552,-.445,-.138,-.090,.601,-.764,.777,.046,.057,.288,.186,.483,-.236,-.304)*f0_2+\n    mat4(.301,-.625,-.718,.361,.220,-.464,-.654,.023,-.003,.487,1.323,.245,.345,.202,-.313,-.424)*f0_3+\n    mat4(.849,-.736,.075,.396,.927,.483,.534,.055,.276,-.071,-.367,.393,.537,.387,.522,-.449)*f0_4+\n    mat4(-.127,-.193,-.242,.062,-.213,-.276,.121,.376,-.262,-.316,-.469,-.061,.027,.442,-.128,-.695)*f0_5+\n    vec4(.866,-.262,.533,.604));\nf1_1=sin(mat4(.436,-.129,-.042,-.260,.311,-.338,.106,.443,.350,-.395,.207,.054,.465,.203,-.362,.177)*f0_0+\n    mat4(-.177,.122,-.405,.047,-.015,.209,.717,-.301,-.518,-.261,.107,-.081,.420,.154,.242,1.141)*f0_1+\n    mat4(.448,-.194,-.061,.253,-.455,-.044,.407,.254,-.328,.550,-.307,-.273,-.481,-.352,-.181,-.022)*f0_2+\n    mat4(.705,-.008,.161,-.594,.258,-.300,.071,.442,.462,-.094,.763,.198,.258,.052,-.276,.065)*f0_3+\n    mat4(.325,-.354,.141,.485,-.475,-.528,-.934,-.152,-.009,-.106,.025,.482,-.098,.005,-.422,.193)*f0_4+\n    mat4(-.015,.594,-.116,-.452,-.169,.124,-.351,.062,.126,-.264,.039,.044,.029,-.222,.655,-.114)*f0_5+\n    vec4(.010,-.881,-.257,.213));\nf1_2=sin(mat4(-.487,-.411,.334,-.765,-.202,-.752,.170,-.264,.148,.067,.614,.479,.230,-.121,-.279,.299)*f0_0+\n    mat4(-.068,-.289,-.389,.054,-.184,-.267,-.014,-.087,-.253,-.382,-.703,.063,-.393,.636,-.715,.741)*f0_1+\n    mat4(.236,.009,.066,-.014,-.122,-.489,-.271,-.333,-.679,.653,.708,-.097,-.516,.063,-.043,-.166)*f0_2+\n    mat4(.049,-.087,.182,.254,.402,-.511,.872,.531,-.009,.691,-.040,.093,.086,-.562,-.968,-.230)*f0_3+\n    mat4(-.146,.212,.310,-.403,.003,.025,.018,.097,.543,.481,.147,-.569,-.592,.399,-.142,.319)*f0_4+\n    mat4(-.699,-.735,.016,.175,.839,.600,-.154,-.227,.214,-.160,.541,-.464,.641,-.104,-.319,-.048)*f0_5+\n    vec4(-.151,-.291,.392,-.316));\nf1_3=sin(mat4(-.553,.543,-.169,.400,1.119,-.087,-.078,.518,-.200,-.091,.371,.720,.292,.048,.378,-.153)*f0_0+\n    mat4(.124,.420,.152,.292,-.729,-.154,-.608,.693,.336,-.231,.528,-.899,.159,-.785,-.966,-.532)*f0_1+\n    mat4(.287,-.345,.203,-.241,-.516,.036,-.316,1.065,-.095,.150,-.067,.228,-.675,.051,-.044,.531)*f0_2+\n    mat4(.540,-.124,-.140,-.556,-.828,.049,.157,.745,.706,.975,-.245,.824,-.175,-.328,-.261,.413)*f0_3+\n    mat4(-.677,.414,-.117,-.119,-.279,.575,.278,-.425,.526,.000,.140,-.125,.255,.064,-.118,-.081)*f0_4+\n    mat4(-.219,.574,-.355,-.515,-.120,.526,.691,-.133,.421,-.044,.250,.187,-.140,-.287,.210,-.220)*f0_5+\n    vec4(-.468,-.898,-.450,-.700));\nf1_4=sin(mat4(-.453,-.246,.556,-.216,-.593,.910,-.190,-.017,.435,.209,-.467,-.233,-.031,-.174,-.089,-.474)*f0_0+\n    mat4(-.724,-.184,.197,.522,-.311,-.054,-.486,-.133,-.820,-.138,-.228,-.023,-.440,-.751,-.522,-.298)*f0_1+\n    mat4(.272,-.095,-.449,-.389,.645,-.283,.360,.614,-.022,-.659,-.033,-.666,1.273,-.375,-.772,.752)*f0_2+\n    mat4(.107,-.123,.661,-.153,.629,.172,-.688,.237,-.737,-.058,-.202,-.358,.801,.084,.043,.309)*f0_3+\n    mat4(.007,-.133,.380,-.005,-.583,.030,.079,.404,.126,.759,.609,.814,.183,-.414,.936,.014)*f0_4+\n    mat4(.205,-.034,-.694,.252,.451,.200,.901,-.248,-.350,-.355,.194,.450,-.287,.530,-.116,-.737)*f0_5+\n    vec4(-.358,-.241,.516,.205));\nf1_5=sin(mat4(-.097,.207,-.065,.988,-.392,-.007,.677,-.108,-.020,-.270,-.117,-.241,.487,-.004,.193,1.131)*f0_0+\n    mat4(.322,.508,.076,-.116,-.627,-.145,-.344,-.011,.296,-.528,-.075,.810,-.111,-.788,-.259,-.886)*f0_1+\n    mat4(-.329,-.174,.501,-.233,.208,.231,-.399,-.200,.065,-.128,-.476,.336,-.495,.321,-.016,-1.391)*f0_2+\n    mat4(.066,.632,-.319,.264,.515,.279,.406,-.559,-.040,-.636,.474,.293,.310,-.942,-.390,.528)*f0_3+\n    mat4(.446,-.055,-1.170,-.201,.092,-.057,-.604,.393,-.132,-.589,.272,-.336,.032,-.466,.491,-.328)*f0_4+\n    mat4(-.023,.374,-.033,-.048,-.126,.038,.163,1.040,.630,-.303,.479,.809,.372,-.071,-.047,-.403)*f0_5+\n    vec4(.487,.253,-.292,.009));\nf0_0=sin(mat4(.585,-.054,.292,.335,-.006,-.533,.384,-.849,-.190,-.092,-.105,.763,-.050,-.074,.203,.709)*f1_0+\n    mat4(.407,-.357,-.518,-.543,-.098,-.042,-.599,-.821,-.478,.372,-.070,-.604,.171,-.414,-.496,.177)*f1_1+\n    mat4(.450,-.124,.113,-.539,.310,-.263,.109,-.701,-.184,-.217,-.201,-.037,.104,-.406,-.416,.394)*f1_2+\n    mat4(-.056,.580,-.210,-.108,.678,-.028,-.067,.237,-.009,.429,.220,-.633,-.207,-.301,-.403,-.280)*f1_3+\n    mat4(.126,.301,.126,-.306,.060,-.195,-.144,.279,.241,.200,-.208,-.449,-.486,.297,.387,-.368)*f1_4+\n    mat4(.286,-.545,-.044,-.074,-.242,-.042,-.212,-.153,.086,-.477,.324,.179,.275,-.188,.109,.359)*f1_5+\n    vec4(-1.157,.230,.444,.206));\nf0_1=sin(mat4(-.480,-.468,-.243,-.124,-.176,.048,-.579,-.733,.534,-.250,.116,-.434,.124,.475,.268,-.194)*f1_0+\n    mat4(-1.245,-.313,-1.015,-.193,.518,.136,-.690,-.176,.210,.878,.596,.569,.427,.370,-.534,.075)*f1_1+\n    mat4(-.476,.477,-.073,-.426,-.013,.426,.542,-.527,.651,.120,-.957,.314,-.237,-.262,.540,-.341)*f1_2+\n    mat4(-.269,-.118,.196,.339,-.256,-.146,-.096,-.094,-.235,-.389,.053,-.179,.172,.448,-.014,-.720)*f1_3+\n    mat4(-.570,.425,-.165,.036,-.478,-.216,-.256,.467,.239,.049,.436,.138,-.320,-.098,-.053,-.498)*f1_4+\n    mat4(.350,-.561,.554,.492,.631,-.383,.361,-.379,-.960,.501,-.668,.271,-.396,-.260,-.210,-.505)*f1_5+\n    vec4(-.326,.051,-.231,-1.405));\nf0_2=sin(mat4(.330,.069,.001,.908,.048,-.050,-.123,-.727,.064,-.321,-.185,.646,.194,-.274,-.163,-.233)*f1_0+\n    mat4(-.085,-.937,-.199,-1.129,-.358,.066,-.301,.094,.087,-.060,-.096,-.554,-.620,.059,-.425,.324)*f1_1+\n    mat4(-.101,-1.087,.051,-.380,-.664,.600,.665,1.270,-.237,.761,-.632,.359,-.405,.270,-.503,-.508)*f1_2+\n    mat4(-.662,-1.021,.051,-.236,.182,.593,.095,-.652,.134,-.562,.490,.263,-.369,.206,-.142,-.538)*f1_3+\n    mat4(.424,-.024,-.008,-.619,.632,.550,-.680,-1.265,-.229,.186,.243,.809,.385,.296,-.488,.104)*f1_4+\n    mat4(-.366,.661,.535,.335,-.427,.531,.212,.702,.309,.230,-.841,-.571,-.032,.082,.517,.175)*f1_5+\n    vec4(.100,-.493,-.596,-.821));\nf0_3=sin(mat4(-.534,.199,1.029,.300,-.294,-.060,.116,-.563,-.099,-.140,.208,.042,.737,-.095,-.233,.190)*f1_0+\n    mat4(.428,.569,-.054,.249,1.020,.017,-.964,-.800,-.336,-.408,.047,.611,.331,.074,-.433,.002)*f1_1+\n    mat4(-.255,.502,.049,-.438,.451,.655,-.325,.180,-.653,-.357,.176,.960,-.197,.750,.098,.226)*f1_2+\n    mat4(.059,-.021,-.297,.201,.111,.394,.519,.278,-.616,-.125,.355,.081,.484,.229,-.286,.001)*f1_3+\n    mat4(-.272,-.161,.739,-.313,-.078,.087,.130,.999,.009,.295,.214,-.460,.014,.318,-.435,.427)*f1_4+\n    mat4(.540,.390,.016,.357,.306,.045,-.302,-.103,.113,-.036,.174,-.272,.656,.343,-.580,.171)*f1_5+\n    vec4(-.159,-.380,.042,-.362));\nf0_4=sin(mat4(.068,-.657,-1.018,.209,-.062,.368,.072,1.246,.032,.401,.232,.651,-.117,.302,.275,-.422)*f1_0+\n    mat4(-.208,-.103,.018,-.015,-.671,-.027,-1.078,.517,-.686,.949,.036,.207,-.321,.089,-.923,-.165)*f1_1+\n    mat4(.012,.841,.561,.556,-.104,.221,.281,.375,.813,-.803,-.232,-.197,-.142,-.462,.647,.152)*f1_2+\n    mat4(-.387,-.017,.874,.157,.189,.126,.119,.374,-.083,.104,-.696,.556,.178,-.805,-.216,-.054)*f1_3+\n    mat4(-.034,-.171,-.316,.891,.240,-.268,-.597,-.254,-.161,.090,.770,-.095,-.321,-.277,.334,-.531)*f1_4+\n    mat4(.021,.677,.665,.477,.586,-.054,.390,.302,.458,-.511,-1.239,.210,-.074,-.694,-.116,-.151)*f1_5+\n    vec4(.575,-.088,.344,.196));\nf0_5=sin(mat4(.757,-.059,.690,-.293,-.168,-.591,-.338,.032,.340,.156,.742,.548,.599,.141,.784,.020)*f1_0+\n    mat4(.441,-.260,.087,-.304,.196,-1.197,.256,.382,-.253,.288,-.026,-.135,-.198,-.274,-.163,.224)*f1_1+\n    mat4(.465,-.328,-.186,.321,-.547,-.323,.600,-.186,1.014,-.048,-1.041,.019,.068,-.549,.816,.742)*f1_2+\n    mat4(-.490,.148,.264,.036,.028,-.169,.051,.378,-.043,-.215,-.497,.069,-.792,.808,.826,.101)*f1_3+\n    mat4(.841,-.478,.305,.404,-.845,.577,-.337,-.228,.329,.182,.096,.762,.243,-.106,-.262,.529)*f1_4+\n    mat4(-.220,-.350,.189,.216,-.390,.145,-.323,.256,-.165,.124,.628,-.173,.215,-.504,.186,-.614)*f1_5+\n    vec4(-.365,-.177,-.142,.948));\nf1_0=sin(mat4(.849,.085,-.105,-.559,1.029,.815,.481,-.439,.322,-.309,.012,.575,.298,-.529,.232,.821)*f0_0+\n    mat4(-.151,.010,-.128,.836,.595,-.012,-.234,-.825,.746,.200,.029,-.917,.652,.267,-.207,-.541)*f0_1+\n    mat4(.439,-.652,-.278,.007,-.264,.217,-.036,-.632,.384,-.256,-.282,-.057,-.452,.053,-.142,.418)*f0_2+\n    mat4(-.462,.037,.010,-.111,-.900,-.179,-.254,1.337,.571,-.291,-.425,.302,-.595,-.156,.148,-.610)*f0_3+\n    mat4(.033,-.341,-.128,.264,-.688,.532,-.027,.533,-.213,.140,-.137,-.156,.279,.329,-.236,-1.106)*f0_4+\n    mat4(.172,-.241,-.253,-.110,-.568,-.089,.439,.047,-.126,-.346,-.149,-.940,.383,-.133,.382,.622)*f0_5+\n    vec4(-.187,-.108,.646,-.435));\nf1_1=sin(mat4(.549,-.828,.068,-.111,1.191,-.225,1.193,-1.140,-.338,-.805,-.583,.401,-.155,.387,-.298,.572)*f0_0+\n    mat4(.439,-.183,-.856,.329,.004,.315,-.526,.623,.479,-.588,.475,-.664,.030,.303,.146,.894)*f0_1+\n    mat4(.687,.045,-.342,1.189,-.078,.156,.350,-.232,-.024,.320,-.679,.852,-.159,.193,.266,.283)*f0_2+\n    mat4(-.003,.321,-.571,-.392,-.096,.091,-.762,.480,.694,-.321,.059,-.083,-.324,.283,-.236,-.238)*f0_3+\n    mat4(-.296,-.228,-.171,-.003,-.459,.003,-.193,-.296,-.001,.250,-.007,.306,-.230,.194,-.131,-.576)*f0_4+\n    mat4(.005,-.238,-.697,.756,.111,-.078,.260,-.403,-.058,.086,-.591,.300,-.333,.298,.416,-.058)*f0_5+\n    vec4(.237,-.630,-.014,1.478));\nf1_2=sin(mat4(-.222,-1.055,-.772,.692,.971,.472,-1.212,-.795,.753,-.727,-.251,.974,.365,.009,.266,-.268)*f0_0+\n    mat4(.497,.208,.236,.333,.730,1.199,-.399,.441,.182,-.649,.500,-.158,-.013,.497,.338,-.246)*f0_1+\n    mat4(-.735,-.235,.211,.087,-.475,-.241,.283,-.949,-.793,.623,-.459,-.477,-.027,-.163,.698,.058)*f0_2+\n    mat4(-.569,.425,-.222,-.273,-.502,-.159,.726,-1.001,-.124,.603,-.092,.005,-.543,-.024,-.164,.450)*f0_3+\n    mat4(-.299,-.680,-.343,-.137,-.181,-.767,.089,-.844,.272,.176,.026,-.713,-.019,.838,.155,-.310)*f0_4+\n    mat4(-.125,-.092,-.263,-.325,.612,-.225,-1.276,-1.230,-.538,-.120,.115,.111,.732,.381,.240,-.349)*f0_5+\n    vec4(-.970,-.873,.655,.118));\nf1_3=sin(mat4(.667,.003,.175,.155,.605,.849,.010,-.220,.722,.240,.026,.499,.360,.307,-.134,-.066)*f0_0+\n    mat4(-.192,-.003,-.115,-.498,.049,.199,.477,-.401,-.241,-.271,.031,.181,-.036,.284,.090,-.139)*f0_1+\n    mat4(-.032,.509,-.393,-.377,-.116,-.485,.024,.273,.309,.346,.018,.166,-.137,-.273,.225,-.212)*f0_2+\n    mat4(-.703,.222,-.009,-.719,-.401,-.270,-.388,-.079,-.231,.262,-.088,.776,-.031,.247,-.076,-.849)*f0_3+\n    mat4(.031,-.216,.191,-.496,-.084,-.114,.187,-.257,.054,.003,.166,.176,-.747,-.182,-.066,-.043)*f0_4+\n    mat4(.155,.382,.041,.038,.096,.268,.050,-.629,.066,.091,-.145,-.133,.303,.553,-.143,.365)*f0_5+\n    vec4(-.380,-.675,-1.051,.299));\nf1_4=sin(mat4(.256,-.332,.228,.252,.585,.302,-.348,-1.377,-.193,-.237,-.081,.252,.001,-.152,-.060,-.223)*f0_0+\n    mat4(.364,.296,-.015,-.508,-.144,.815,-.227,-.880,-.150,-.246,.142,.532,-.567,.674,-.373,-.773)*f0_1+\n    mat4(-.295,-.824,.256,-.161,-.173,-.190,.033,.549,-.348,.279,.034,-.194,-.074,-.070,-.150,.085)*f0_2+\n    mat4(.052,.540,.207,-.508,-.588,-.463,.112,.103,-.067,.260,.142,.461,.343,-.271,-.033,-.816)*f0_3+\n    mat4(.510,-.775,.169,-.253,.154,-.320,.140,-.015,.185,.384,-.130,-.266,-.414,.458,.363,.061)*f0_4+\n    mat4(-.015,.564,.045,-.573,.489,-.404,.148,-.541,-.071,.173,-.202,-.497,-.245,-.551,-.204,.195)*f0_5+\n    vec4(.377,.376,-1.522,-1.257));\nf1_5=sin(mat4(1.202,-.421,-.362,.463,.411,.572,.044,-.401,-.423,-.489,.319,-.606,-.075,.346,-.084,-.480)*f0_0+\n    mat4(-.640,.316,-.242,-.094,.138,-.137,.558,.566,-.557,.068,-.469,.420,-.066,.315,.528,-.375)*f0_1+\n    mat4(.050,.272,.174,-.387,.120,-.323,.203,-.502,.469,.023,.758,-.245,-.084,-.046,-.480,.000)*f0_2+\n    mat4(.353,-.239,-.395,-.097,-.440,-.460,-.184,-.494,.385,-.572,.077,.122,.036,.229,-.241,-.195)*f0_3+\n    mat4(-.515,.223,.143,-.382,.602,-.065,-.967,.815,.233,.156,.879,-1.015,.108,-.386,.015,-.346)*f0_4+\n    mat4(-.131,-.358,.226,.163,.020,.242,.196,-.471,-.026,.061,-.249,.345,.199,.632,-.371,.094)*f0_5+\n    vec4(.149,-.378,-.480,-.910));\nf0_0=sin(mat4(-.167,.013,-.157,-.065,.470,-.318,.399,.244,-.540,-.068,.122,.588,.175,.053,.309,.230)*f1_0+\n    mat4(.033,-.428,-.139,-.759,.606,-.991,-.271,-.708,-.234,.295,-.301,.018,.168,-.615,-.440,-.476)*f1_1+\n    mat4(.177,-.307,-.548,-.151,.184,.005,.205,.690,-.350,.486,.316,-.226,.302,-.192,-.009,.053)*f1_2+\n    mat4(.217,-.905,-.714,.011,-.248,.666,-.269,-.206,.220,1.477,.120,-.786,.762,-.538,.061,.622)*f1_3+\n    mat4(.547,-.693,-.246,-.597,-.439,.315,-.288,-.926,.132,-.523,-1.496,.742,.529,-.155,.003,.662)*f1_4+\n    mat4(-.283,.124,.070,-.657,-.674,-.091,-.713,-.908,-.385,-.144,-.299,-.591,.452,-.116,.137,.196)*f1_5+\n    vec4(.200,-1.286,1.404,.594));\nf0_1=sin(mat4(.624,.117,-.416,.240,-.738,-.038,.677,-.434,.822,-.183,.437,-.826,-.258,-.100,.454,-.302)*f1_0+\n    mat4(-.494,.041,-.081,.415,-.773,-.458,1.124,.288,.426,.067,-.502,.225,-.168,.165,-.371,.331)*f1_1+\n    mat4(-.062,.146,-.417,.119,-.241,-.064,.360,-.725,.007,-.047,.058,.314,-.281,-.023,.192,-.139)*f1_2+\n    mat4(-.061,.048,-.191,-.187,.741,.151,-1.193,.478,1.025,-.263,.031,.686,-.612,.213,.031,-.745)*f1_3+\n    mat4(-.405,-.358,.733,.021,.294,-.016,-.395,1.041,.808,-.309,-.194,-.635,-.346,.123,.065,-.639)*f1_4+\n    mat4(-.314,.005,-.038,.683,.533,-.012,-.758,.933,.126,.055,-.370,.610,-.325,-.080,.359,-.282)*f1_5+\n    vec4(1.956,.233,.742,.409));\nf0_2=sin(mat4(.603,-.540,.771,.414,-.009,-.094,-.717,-.549,.000,-.215,1.305,.138,-.133,.105,-.258,-.313)*f1_0+\n    mat4(.070,.302,-.644,-.101,.939,-.450,-1.889,-.243,-.970,.762,.678,.397,.219,-.110,-.312,.238)*f1_1+\n    mat4(-.566,.540,.112,.201,.151,-.071,-.099,-.439,.185,-.161,-.012,-.021,-.454,.497,-.309,-.195)*f1_2+\n    mat4(-.242,.057,.326,.323,.071,.248,1.470,.690,-1.344,.925,.227,.163,.551,-.344,.222,-.296)*f1_3+\n    mat4(-.151,.186,-1.391,-.144,-.502,.453,.089,.541,-.569,.385,.527,.394,.504,-.215,.316,-.209)*f1_4+\n    mat4(.236,-.259,-.408,.007,-.372,.419,.012,.536,.227,-.252,.063,.302,.017,.077,-.374,-.284)*f1_5+\n    vec4(-.153,-.242,-.367,1.452));\nf0_3=sin(mat4(-.673,.026,.235,-.775,1.372,-.111,-.708,1.195,-.649,.263,.193,.625,.602,.067,-.273,.834)*f1_0+\n    mat4(-.284,-.566,-.203,-.207,.925,-.457,-.285,1.501,-.637,.186,.337,-.900,.039,-.225,-.333,-.842)*f1_1+\n    mat4(.254,.072,-.305,-.890,.921,.046,-.392,.796,-.908,-.052,.670,.288,.687,-.042,-.328,.283)*f1_2+\n    mat4(.469,.007,-.807,-.810,-.959,-.472,.236,-2.267,.329,.504,.886,-.129,2.186,-.108,-1.702,-.088)*f1_3+\n    mat4(.878,-.149,-.206,.754,-1.727,-.040,.804,-.770,.638,.456,-.076,-.839,1.603,-.047,-1.149,.103)*f1_4+\n    mat4(-1.005,-.076,.562,.034,-2.164,-.224,1.432,-1.495,-1.297,-.096,.617,-.648,1.152,.022,-.453,.571)*f1_5+\n    vec4(-.537,1.187,.179,1.692));\nf0_4=sin(mat4(-.263,.045,.079,-.005,.172,-.175,-.171,-.002,-.008,.012,.429,.095,.361,-.120,-.057,.079)*f1_0+\n    mat4(-.294,.060,-.216,.102,-.172,.477,-1.304,-.541,-.337,.131,.133,-.212,-.922,.250,-.439,-.636)*f1_1+\n    mat4(-.907,.265,-.423,-.810,.140,-.119,.223,-.078,.835,-.236,.398,.819,-.158,.027,-.239,-.236)*f1_2+\n    mat4(-1.627,.526,-.781,-1.443,-.466,.149,.458,-.088,.610,.021,-.233,.228,-1.195,.023,-.253,-1.057)*f1_3+\n    mat4(-.373,.399,-1.160,-.779,.007,.150,-.106,.205,-1.841,.952,-.776,-1.865,-.721,.017,-.180,-.907)*f1_4+\n    mat4(.478,-.115,.118,.621,.025,.269,.076,.422,-.055,.095,.035,.248,.039,.002,-.276,-.296)*f1_5+\n    vec4(.259,.733,-.223,1.049));\nf0_5=sin(mat4(.161,-.683,-.060,.146,.551,.637,.279,-.358,-.539,-.472,-.041,-.576,.031,.334,-.033,-.280)*f1_0+\n    mat4(-.259,.323,.458,.471,-.098,1.338,1.132,.176,-.717,-.609,-.284,.266,.284,-.040,.481,.390)*f1_1+\n    mat4(.061,-.304,.194,.216,.325,.281,-.027,-.665,-.153,-.014,-.334,.240,-.108,.285,.167,-.117)*f1_2+\n    mat4(-.086,-.501,.675,.010,-1.228,-1.388,-.416,.590,.277,.365,-1.030,.619,.386,-.233,.338,-.406)*f1_3+\n    mat4(.160,1.202,.722,.163,-.867,-.353,-.181,.888,.359,-.386,.382,-.822,-.269,-.302,.079,-.490)*f1_4+\n    mat4(.257,.125,-.064,.568,-.128,-.221,.139,.721,.200,-.243,.106,.496,.118,.407,.110,-.217)*f1_5+\n    vec4(-.900,.342,-1.007,-1.118));\nfloat f_0=dot(f0_0,vec4(.175,-.038,.036,-.102))+\n    dot(f0_1,vec4(-.048,-.276,.086,-.077))+\n    dot(f0_2,vec4(-.027,-.044,.075,.117))+\n    dot(f0_3,vec4(.043,.100,.033,.037))+\n    dot(f0_4,vec4(.008,-.160,.073,-.024))+\n    dot(f0_5,vec4(.033,.111,.144,-.021))+\n    0.607;\nfloat f_1=dot(f0_0,vec4(.140,.151,-.056,-.013))+\n    dot(f0_1,vec4(-.097,-.101,-.025,-.101))+\n    dot(f0_2,vec4(-.054,-.073,.106,.161))+\n    dot(f0_3,vec4(.038,-.030,-.001,.003))+\n    dot(f0_4,vec4(-.016,.041,.030,.008))+\n    dot(f0_5,vec4(.033,.121,-.175,.107))+\n    0.498;\nfloat f_2=dot(f0_0,vec4(.129,.032,-.086,-.048))+\n    dot(f0_1,vec4(.002,.180,-.096,-.063))+\n    dot(f0_2,vec4(-.003,-.003,.037,-.071))+\n    dot(f0_3,vec4(.032,.013,-.040,-.030))+\n    dot(f0_4,vec4(-.046,.271,.067,.038))+\n    dot(f0_5,vec4(.007,.050,-.051,-.004))+\n    0.333;\n    #else\nvec4 f1_0, f0_0=sin(ft_0*vec4(1.250,.830,-.554,.757)+ft_1*vec4(-.554,-.903,-1.356,-.907)+ft_2*vec4(-.417,.408,-.002,.290)+vec4(-.366,-.141,-.649,1.823));\nvec4 f1_1, f0_1=sin(ft_0*vec4(.535,1.113,.693,.655)+ft_1*vec4(.135,.208,.148,.514)+ft_2*vec4(-.983,-.210,.884,1.143)+vec4(1.615,-1.338,1.391,-.675));\nvec4 f1_2, f0_2=sin(ft_0*vec4(1.146,.920,.868,1.000)+ft_1*vec4(.309,-.856,.234,-.412)+ft_2*vec4(-.316,-.630,1.257,.994)+vec4(.789,1.450,.150,.789));\nvec4 f1_3, f0_3=sin(ft_0*vec4(-.120,-.144,.932,-.005)+ft_1*vec4(-.479,-.221,.984,.001)+ft_2*vec4(.303,-1.700,-.414,.742)+vec4(-.222,-1.679,-1.136,.444));\nvec4 f1_4, f0_4=sin(ft_0*vec4(.433,-.431,-.114,-.478)+ft_1*vec4(.432,.349,-1.004,.389)+ft_2*vec4(-.981,.406,-.909,-1.666)+vec4(.194,.196,-.202,1.782));\nf1_0=sin(mat4(-.043,-.155,-.176,.115,.328,.086,-.129,.546,-.263,.280,-.130,-.048,.208,.393,-.377,.412)*f0_0+\n    mat4(.017,.128,-.011,-.137,.372,-.237,-.146,.046,-.001,-.497,-.384,-.044,-.225,-.472,-.165,-.466)*f0_1+\n    mat4(-.272,.328,-.971,.219,-.131,.438,-.673,.542,.200,-.010,-.540,.006,.081,-.087,-.356,.773)*f0_2+\n    mat4(.200,.426,-.214,-.122,.181,-.205,-.062,.403,-.418,-.553,-.190,-.123,.371,-.482,.202,.293)*f0_3+\n    mat4(-.755,.228,-.473,-.270,.196,.544,.426,.540,.691,.567,-.074,-.533,-.546,-.039,-.126,-.237)*f0_4+\n    vec4(.532,-.104,.201,-.054));\nf1_1=sin(mat4(-.239,.497,-.430,-.593,-.005,-.179,-.211,.211,-.191,-.259,.344,-.055,-.228,-.259,.107,.172)*f0_0+\n    mat4(-.091,.402,-.071,-.193,-.441,-.338,-.366,-.506,-.119,-.168,-.339,-.129,-.492,.082,.335,.108)*f0_1+\n    mat4(.047,-.284,-.804,.494,-.041,-.157,-.072,.350,-.027,.172,-.482,.433,.659,.396,.261,.007)*f0_2+\n    mat4(-.459,.147,-.134,.180,.530,-.912,-.271,-.251,.471,.273,.101,.156,-.484,.293,.149,-.690)*f0_3+\n    mat4(-.049,-.066,-.782,.287,.428,.399,.769,-.265,.049,-.286,-.426,-.431,-.308,.017,-.019,-.411)*f0_4+\n    vec4(.170,.359,.240,-.206));\nf1_2=sin(mat4(-.413,.725,.586,.849,.297,-.465,.106,.285,-.511,-.175,-.391,.439,.510,.450,-.457,.089)*f0_0+\n    mat4(-.429,-.669,.061,-.039,-.712,.704,.113,.340,.446,-.427,-.442,-.449,.443,-.407,.418,-.048)*f0_1+\n    mat4(.269,.139,-.315,-.447,-.169,.407,.045,-.271,-.447,.297,.030,.396,.093,-.635,-.436,.020)*f0_2+\n    mat4(-.107,-.067,.051,-.510,-.311,-.194,.126,.268,.324,.601,-.394,.039,-.060,-.128,.393,-.024)*f0_3+\n    mat4(.641,-.549,-.073,.409,.137,.439,-.270,.135,-.210,-.541,-.075,-.384,-.209,.022,-.624,-.085)*f0_4+\n    vec4(-.048,-.558,.621,-.179));\nf1_3=sin(mat4(-.589,.454,.720,.099,-.562,.527,-.404,.386,.345,-.077,.253,-.060,-.220,-.088,.507,-.206)*f0_0+\n    mat4(.729,-.675,-.346,-.222,-.282,.703,-.360,-.706,-.319,-.578,-.541,.237,-.235,.214,-.493,.526)*f0_1+\n    mat4(-.401,-.370,-.300,.451,.398,-.234,.526,.235,.067,.230,.298,.729,-.005,.001,.005,.316)*f0_2+\n    mat4(-.208,-.523,.032,.526,-.424,.519,.661,.463,.015,.435,.540,.169,.551,-.426,.075,-.046)*f0_3+\n    mat4(.226,.088,-.231,-.568,.548,-.288,.890,.354,.264,-.273,-.368,-.279,.156,-.273,.167,-.260)*f0_4+\n    vec4(-.637,-.902,.460,-.204));\nf1_4=sin(mat4(-.147,.057,.179,-.059,.438,-.532,.481,.045,-.201,-.706,.624,-.116,.026,.254,-.474,-.181)*f0_0+\n    mat4(.410,.033,-.423,-.370,.277,-.533,-.309,-.677,-.618,-.539,.502,.558,.081,.161,-.316,-.138)*f0_1+\n    mat4(-.189,.225,.408,.590,.552,-.151,.460,-.026,.140,-.563,-.271,.324,-.558,-.061,-.588,.271)*f0_2+\n    mat4(-.015,.092,-.431,.069,.434,.155,.325,-.378,.365,-.549,.172,-.329,.625,-.282,-.112,.435)*f0_3+\n    mat4(-.465,-.138,-.416,.115,.634,.315,-.495,-.287,.068,-.347,.804,.059,.362,.100,-.313,.442)*f0_4+\n    vec4(.064,-.391,.491,-.750));\nf0_0=sin(mat4(-.261,.144,-.174,-.197,-.449,-.426,.505,.736,-.121,.538,.350,-.157,.051,.291,.007,.866)*f1_0+\n    mat4(.366,.305,.419,-.060,.266,-.506,-.266,-.199,.157,.431,.244,-.444,-.406,.305,-.167,.381)*f1_1+\n    mat4(.134,-.356,.506,.201,.441,-.229,-.659,.405,.222,.112,.163,-.376,.211,-.498,-.441,-.670)*f1_2+\n    mat4(-.273,-.032,.113,.177,.630,-.098,-.483,.042,-.348,.269,.376,-.179,-.390,-.669,-.040,.012)*f1_3+\n    mat4(-.411,.221,-.202,-.306,-.279,-.088,.288,-.228,.173,.685,-.370,.565,-.217,-.652,-.354,-.170)*f1_4+\n    vec4(.360,-.655,.621,.529));\nf0_1=sin(mat4(-.064,-.468,.095,.156,-.311,.612,.475,-.120,-.583,-.116,.118,.833,.650,-.565,-.548,-.193)*f1_0+\n    mat4(.281,.281,.015,-.425,.398,-.298,.140,.385,-.754,-.231,-.407,-.066,.093,-.144,-.169,.177)*f1_1+\n    mat4(.476,-.263,.289,.370,.104,.462,.757,.105,.071,-.071,.529,.372,.038,-.261,-.016,-.014)*f1_2+\n    mat4(-.540,.162,.489,-.258,-.396,-.257,-.568,.066,.169,.220,.668,-.086,-.251,-.253,.157,-.457)*f1_3+\n    mat4(.273,-.383,.238,-.181,-.568,.441,-.236,.433,-.204,.353,-.405,.477,-.242,.009,-.451,.198)*f1_4+\n    vec4(.011,.309,-.145,-.581));\nf0_2=sin(mat4(.044,-.444,.389,.586,-.112,-.186,.356,-.282,.741,-.671,.402,-.011,.452,.483,-.022,.194)*f1_0+\n    mat4(.439,-.089,-.017,.113,-.520,.188,.481,-.353,.243,.238,.374,-.431,.274,-.155,-.156,-.695)*f1_1+\n    mat4(-.230,-.237,-.352,-.176,-.340,-.162,-.230,.216,-.243,-.001,.419,-.252,-.194,.809,.209,-.138)*f1_2+\n    mat4(-.261,-.245,-.092,-.146,.594,-.590,-.200,.357,.349,.422,-.006,.186,.338,-.080,.135,-.028)*f1_3+\n    mat4(-.041,.372,-.221,-.436,.724,-.059,-.256,-.334,-.040,-.588,.260,-.211,-.625,-.225,-.510,.264)*f1_4+\n    vec4(-.827,-.318,.693,.199));\nf0_3=sin(mat4(.763,.802,.647,-.173,-.074,-.155,.324,.459,.022,.318,.239,.187,-.063,-.090,.373,.444)*f1_0+\n    mat4(.158,.210,-.000,.070,.470,-.291,.195,.086,-.255,-.310,.296,-.242,.026,-.233,-.184,.017)*f1_1+\n    mat4(-.517,-.191,-.065,.488,.064,.361,.231,.276,-.406,.189,-.201,-.217,-.272,-.454,-.160,.259)*f1_2+\n    mat4(-.066,.428,.008,-.493,-.315,.134,.639,.313,-.236,.230,-.059,-.557,.311,-.380,.156,-.078)*f1_3+\n    mat4(-.370,.117,.509,-.094,.189,.290,.487,.386,-.422,-.060,-.022,.374,.092,-.433,-.039,.140)*f1_4+\n    vec4(.269,.466,-.338,-.344));\nf0_4=sin(mat4(-.229,-.328,-.068,.119,.601,.024,.370,.042,.549,.499,.510,-.444,.456,.431,.145,.196)*f1_0+\n    mat4(.279,-.016,-.369,.107,-.105,.504,-.007,-.185,.588,-.134,.001,-.647,-.004,-.235,-.294,.041)*f1_1+\n    mat4(-.083,.201,.093,-.217,-.240,.089,-.182,-.386,-.424,.399,-.391,.152,-.044,-.207,.619,.272)*f1_2+\n    mat4(-.315,-.012,.686,-.155,-.399,.516,.242,-.487,-.042,-.190,-.575,.133,-.487,.580,-.427,.545)*f1_3+\n    mat4(.162,.122,.318,.254,-.075,.429,-.545,-.055,-.314,-.577,-.117,-.174,.387,-.067,-.464,-.111)*f1_4+\n    vec4(-.024,-.049,.680,-.346));\nf1_0=sin(mat4(.318,-.246,.129,.442,-.503,.285,-.413,.193,-.261,.508,.202,.293,.323,.201,-.286,.319)*f0_0+\n    mat4(-.207,-.072,.448,-.014,-.442,.381,-.546,-.387,-.494,.067,-.361,.463,.032,-.259,-.342,.013)*f0_1+\n    mat4(-.034,.048,-.210,-.442,.472,.296,.433,-.217,.003,-.283,-.468,-.320,-.358,-.593,.191,.280)*f0_2+\n    mat4(-.199,-.425,-.086,-.206,-.184,-.185,-.627,-.627,.215,.039,-.867,-.482,.246,.301,.225,.685)*f0_3+\n    mat4(-.292,-.312,-.239,-.041,.484,-.109,-.285,.028,-.502,.245,-.178,-.033,.894,-.380,-.743,.006)*f0_4+\n    vec4(-.523,-.045,.586,-.459));\nf1_1=sin(mat4(-.783,.572,-.115,-.027,.284,-.336,-.179,.415,.323,.344,-.776,.249,.096,-.103,-.464,-.535)*f0_0+\n    mat4(.405,-.371,.138,-.094,-.022,.558,.372,.467,-.171,-.276,.499,.074,-.305,.418,-.380,.408)*f0_1+\n    mat4(-.108,.642,-.438,-.048,.443,-.261,-.074,.359,.390,.251,.043,-.043,.178,-.764,.345,.359)*f0_2+\n    mat4(-.299,-.272,-.284,.243,-.040,-.366,.268,-.605,.035,-.462,.358,.305,.522,-.155,.113,.795)*f0_3+\n    mat4(-.322,-.400,.140,-.093,.347,-.380,-.847,-.354,-.115,-.308,.057,.527,.395,.007,-.146,.145)*f0_4+\n    vec4(.467,.558,-.416,.263));\nf1_2=sin(mat4(.276,-.212,-.202,-.511,.004,.221,-.352,.088,-.109,-.459,.327,-.725,.266,-.210,-.562,-.363)*f0_0+\n    mat4(-.492,-.299,-.230,-.413,-.384,.276,.122,-.495,.333,-.106,.547,-.730,.449,.068,.412,-.162)*f0_1+\n    mat4(.192,-.134,.049,.163,.207,.349,-.543,-.034,.432,-.309,-.106,-.585,.426,-.382,-.287,-.268)*f0_2+\n    mat4(-.374,-.259,-.104,-.324,.081,.390,.001,.419,.277,.063,.363,.303,-.333,-.063,.049,-.389)*f0_3+\n    mat4(-.432,-.026,-.531,.366,.515,.663,.100,.211,.346,.060,.484,.099,-.256,.673,.260,-.049)*f0_4+\n    vec4(.370,-.283,-.644,-.910));\nf1_3=sin(mat4(-.048,.089,.056,.291,-.260,.140,-.256,-.542,.028,-.624,.206,-.076,.794,-.167,-.140,.243)*f0_0+\n    mat4(.015,-.191,.461,-.135,.100,.249,-.197,.199,-.604,.505,.145,-.223,-.428,.101,.005,-.225)*f0_1+\n    mat4(-.136,.379,-.430,-.509,-.278,-.497,.299,-.132,.186,.138,.279,-.479,.190,-.117,-.069,.213)*f0_2+\n    mat4(-.428,-.270,.272,-.553,-.596,-.338,-.220,.007,.196,.481,-.012,.885,.200,-.293,-.295,.193)*f0_3+\n    mat4(-.182,-.228,-.548,-.163,.276,.320,.566,.102,-.062,-.265,-.243,-.047,-.110,.243,.437,-.395)*f0_4+\n    vec4(.422,-.037,.600,.564));\nf1_4=sin(mat4(.333,.151,-.069,-.814,-.500,-.305,.297,-.247,-.420,.299,-.413,.644,-.139,-.467,.155,-.179)*f0_0+\n    mat4(-.451,.170,-.218,.112,-.300,-.439,.068,.512,-.836,.145,.021,.259,.248,.003,-.006,.623)*f0_1+\n    mat4(-.060,.258,-.273,-.091,-.019,.270,-.498,-.461,.806,-.471,.662,.052,-.309,-.087,.011,-.171)*f0_2+\n    mat4(-.009,-.252,.446,.682,-.317,-.808,-.268,-.112,-.247,.271,.581,.399,.532,-.130,-.291,.394)*f0_3+\n    mat4(-.093,.141,-.015,.498,.384,.570,-.359,.189,.052,-.557,.071,-.195,.446,-.277,-.152,-.254)*f0_4+\n    vec4(.106,.098,-.241,-.161));\nf0_0=sin(mat4(.686,-.360,.380,.101,.085,.319,-.017,.444,.024,.832,.175,-.518,.340,-.399,-.145,-.213)*f1_0+\n    mat4(.348,.337,.131,-.484,-.232,.505,.303,.525,-.231,-.584,.527,.571,.403,.150,.318,.485)*f1_1+\n    mat4(.118,.271,-.050,-.243,.369,-.328,.060,.407,.061,.562,-.594,-.236,.362,.187,.125,-.157)*f1_2+\n    mat4(.319,.165,-.559,.050,-.508,.345,.525,.453,.233,-.032,.321,.039,.204,-.258,.406,.509)*f1_3+\n    mat4(-.306,.410,-.396,.096,-.636,-.033,-.292,-.229,.420,.182,.093,-.282,-.022,-.445,.712,-.635)*f1_4+\n    vec4(-.093,.438,-.045,-.029));\nf0_1=sin(mat4(-.278,-.264,-.313,-.191,.117,.297,.167,-.341,-.219,-.428,-.031,-.562,.185,.474,.001,.131)*f1_0+\n    mat4(.211,-.235,.307,.603,.337,-.268,.138,.574,-.288,-.173,.248,.765,-.279,.237,.458,-.723)*f1_1+\n    mat4(-.425,-.522,.482,.166,-.352,.178,-.235,.714,.225,-.159,.557,-.474,-.014,-.369,.409,.008)*f1_2+\n    mat4(.426,-.190,-.353,-.589,-.478,-.432,.203,-.620,-.291,.012,.365,.118,-.462,-.182,.272,-.078)*f1_3+\n    mat4(-.544,-.204,-.574,-.521,-.809,.134,.173,-.155,-.121,.174,.468,-.265,-.170,.056,.527,.893)*f1_4+\n    vec4(-.314,.553,-.179,-.740));\nf0_2=sin(mat4(-.505,-.257,-.121,.266,.224,.035,-.288,.131,.378,.142,-.443,.207,.459,.394,.101,-.296)*f1_0+\n    mat4(.183,.146,.206,-.033,.282,-.041,.370,.049,-.129,.059,-.452,.000,.059,-.118,.259,.462)*f1_1+\n    mat4(.802,.193,.619,.020,.220,.057,.269,.069,.215,-.062,-.258,-.172,.342,-.563,-.004,-.188)*f1_2+\n    mat4(.112,-.302,-.032,.118,.205,-.099,.172,-.611,-1.102,.185,-.101,.467,-.053,-.186,.154,.586)*f1_3+\n    mat4(.330,-.432,-.318,.209,.371,-.227,.142,.260,-.004,-.533,-.508,.538,-.185,-.060,-.207,.521)*f1_4+\n    vec4(-.798,.772,-.342,-.573));\nf0_3=sin(mat4(.219,.194,.021,.294,-.423,.565,-.137,-.589,-.389,-.008,.134,-.101,-.025,-.637,.660,.036)*f1_0+\n    mat4(-.446,-.151,.033,-.037,-.349,-.239,-.159,-.387,.300,-.276,-.274,.362,.250,.040,.201,-.344)*f1_1+\n    mat4(-.808,.983,-.347,.008,.049,.235,-.389,.106,.047,-.069,-.444,-.343,-.136,-.054,.791,-.112)*f1_2+\n    mat4(-.614,.138,-.111,-.220,.629,-.345,-.434,-.038,.522,-.566,-.043,.791,-.774,-.064,-.481,-.412)*f1_3+\n    mat4(.320,-.002,.414,.006,-.351,.508,.772,.323,-.465,.460,.180,-.641,-.312,.142,-.459,-.475)*f1_4+\n    vec4(-.263,.869,.160,.246));\nf0_4=sin(mat4(.380,.626,-.084,-.299,.772,-.778,-.664,-.331,.234,-.013,-.138,.243,.798,.294,.118,.604)*f1_0+\n    mat4(-.470,.553,.116,.256,-.474,.258,-.509,.199,-.212,.506,-.461,.534,.534,-.210,.069,.303)*f1_1+\n    mat4(.361,.234,.238,.513,.626,-.062,-.260,-.551,.025,-.223,.011,-.374,.121,-.189,-.396,.467)*f1_2+\n    mat4(-.142,-.147,-.218,.373,.286,-.064,-.069,.529,.402,-.953,.303,.292,.543,-.119,-.533,.216)*f1_3+\n    mat4(.629,.532,-.001,.161,-.554,-.524,-.237,.363,.148,.313,.113,.313,-.876,-.627,.156,-.192)*f1_4+\n    vec4(-1.094,.141,-.487,-.344));\nf1_0=sin(mat4(.492,-.159,.059,.238,.540,-.385,-.340,-.174,-.699,.244,.064,.525,.120,.333,-.475,.138)*f0_0+\n    mat4(-.653,.398,.266,.492,-.046,.271,.267,.654,-.380,.010,.973,.331,-.465,-.134,.595,.029)*f0_1+\n    mat4(-.570,.340,-.114,.149,.442,.330,.643,.055,-.918,.106,.655,-.362,.230,-.030,-.011,-.392)*f0_2+\n    mat4(.224,.190,-.177,.386,-.333,.018,.180,-.219,.699,.569,.283,.668,-.239,-.208,.023,-.713)*f0_3+\n    mat4(.090,-.428,-.091,.411,-.362,.105,.240,-.097,-.617,-.059,.276,.753,.721,-.403,.045,.541)*f0_4+\n    vec4(.385,.425,-.146,.478));\nf1_1=sin(mat4(-.956,.396,-.808,-.126,.345,-.296,.536,.029,-.099,-.377,-.294,.886,-.292,.365,.615,-.123)*f0_0+\n    mat4(-.503,-.271,-.481,-.365,.379,.682,-.482,.670,.703,.491,-.198,.005,-.074,-.116,.055,.000)*f0_1+\n    mat4(-.386,-.050,-.422,-.209,.298,-.334,.199,.409,.652,.153,.397,-.851,.862,-.173,-.012,.157)*f0_2+\n    mat4(-.089,.034,-.105,-.016,.024,-.023,-.180,.120,.340,.121,-.449,-.490,.091,.423,-.411,.157)*f0_3+\n    mat4(-.363,.313,.317,-.309,.045,-.175,.143,-.133,.209,.302,.014,.173,-.152,.284,.433,-.002)*f0_4+\n    vec4(.407,-.375,.157,.612));\nf1_2=sin(mat4(.247,-.258,.252,-.006,.076,.061,-.246,.255,-.114,-.082,.373,-.170,-.495,-.554,.378,.481)*f0_0+\n    mat4(-.245,-.478,-.465,-.633,-.000,-.326,.535,-.123,-.064,.968,-.159,.141,-.220,-.168,.078,.072)*f0_1+\n    mat4(-.486,-.254,.219,-.508,.037,.002,-.176,-.445,.511,-.901,.314,.355,.230,.356,-.701,-.370)*f0_2+\n    mat4(-.193,.329,-.482,.318,-.098,.069,-.658,-.023,.361,.286,-.164,.126,.593,-.117,-.250,.487)*f0_3+\n    mat4(.022,.140,-.361,-.291,-.063,.399,.027,-.407,.098,.343,.022,.060,.285,.271,-.290,-.445)*f0_4+\n    vec4(.355,-.370,.165,-.159));\nf1_3=sin(mat4(.164,-.104,.026,.195,.227,.650,.510,-.260,.431,-.398,-.309,.188,.594,-.293,.311,-.077)*f0_0+\n    mat4(.691,-.030,-.339,-.060,.014,.406,-.468,.176,.233,.181,-.162,-.151,-.157,.524,.662,-.175)*f0_1+\n    mat4(-.260,-.304,-.791,.751,-.023,-.013,.309,-.344,-.337,.657,-.458,-.240,-.569,.337,-.314,-.143)*f0_2+\n    mat4(-.142,.231,-.348,-.255,.362,-.439,-.224,.640,-.075,-.361,-.026,-.183,.133,-.045,-.211,.103)*f0_3+\n    mat4(-.363,-.348,.577,-.002,.176,.355,.084,.062,.211,.450,.470,.708,.299,-.514,-.676,-.518)*f0_4+\n    vec4(.257,-.393,.068,.033));\nf1_4=sin(mat4(.429,.102,.528,.684,-.062,.334,-.142,.372,-.511,.125,-.599,-.500,.115,-.070,.085,-.453)*f0_0+\n    mat4(-.631,-.479,-.711,.021,-.213,.740,-.498,-.634,-.876,-.117,.233,.414,-.240,.176,.195,-.471)*f0_1+\n    mat4(.100,-.167,.244,.522,.084,.099,.356,-.156,.071,.165,-.056,.235,.383,-.329,-.629,-.491)*f0_2+\n    mat4(.147,-.129,.063,-.196,.011,-.412,.188,.240,.229,-.185,.498,.287,.328,-.429,.279,-.102)*f0_3+\n    mat4(-.215,.036,-.177,-.374,.548,-.548,-.241,.208,-.053,-.051,.318,.202,-.332,-.087,-.142,.477)*f0_4+\n    vec4(-.383,.183,-.606,-.216));\nf0_0=sin(mat4(.399,-.153,-.033,-.165,-.757,.330,.095,-.781,-.174,.462,.155,-.596,.860,.159,.499,.278)*f1_0+\n    mat4(.303,.437,.008,-.513,-.015,-.323,-.103,.308,.331,.423,-.197,-.747,-.359,-.260,.629,-.407)*f1_1+\n    mat4(-.244,-.268,-.244,.132,.354,-.201,-.715,-.219,-.104,-.557,.177,-.195,-.383,.047,-.241,.661)*f1_2+\n    mat4(.285,.492,-.693,.516,.284,.472,-.281,.023,.076,-.737,.447,-.103,.389,-.058,-.732,1.015)*f1_3+\n    mat4(.091,-.411,-.374,-.070,-.533,.620,.110,-.445,-.019,-.146,-.163,-.239,-.086,-.055,-.357,-.524)*f1_4+\n    vec4(.612,-.449,-.073,-.757));\nf0_1=sin(mat4(-.557,-.581,.018,.169,-.319,-.538,.079,-.375,-.003,-.415,.269,-.039,-.259,-.211,.052,.175)*f1_0+\n    mat4(.162,.278,.450,-.035,-.409,.473,.190,-.634,-.403,-.128,-.074,-.150,.327,-.730,.035,-.095)*f1_1+\n    mat4(.563,.069,-.197,.162,-.243,-.017,.236,-.649,.045,.653,-.297,-.135,-.687,.352,.221,.173)*f1_2+\n    mat4(.572,.164,-.543,.337,-.365,.592,-.335,-.280,-.199,-.369,-.564,.082,-.573,.441,.292,.259)*f1_3+\n    mat4(-.186,-.289,-.515,-.597,-.126,.108,.567,.644,-.363,.546,.301,-.030,.159,.331,.329,-.143)*f1_4+\n    vec4(-.436,.371,.499,.589));\nf0_2=sin(mat4(.587,.403,-.196,.608,.338,.323,.035,.136,.176,-.463,.058,.427,-.227,.041,.711,.235)*f1_0+\n    mat4(-.048,.019,.515,.403,-.351,.094,.075,.224,.252,-.324,.348,-.301,-.488,-.030,-.354,-.492)*f1_1+\n    mat4(.133,-.711,.765,.454,.246,.153,-.478,-.268,-.537,.615,-.765,.026,.317,.705,.620,.268)*f1_2+\n    mat4(-.158,.121,-.564,-.281,-.582,-.543,-.155,-.044,-.076,.067,-.064,-.044,.276,.130,.329,-.489)*f1_3+\n    mat4(-.403,-.150,.137,.688,.066,.274,-.686,.402,.030,-.639,-.249,-.491,.082,.569,.449,-.179)*f1_4+\n    vec4(-.544,.676,.561,-.343));\nf0_3=sin(mat4(-.736,-.011,.463,-.198,-.329,-.015,.156,-.564,.072,.552,.045,.220,-.235,.503,.431,.437)*f1_0+\n    mat4(-.085,.136,.531,-.737,.032,.243,-.713,.104,.379,.178,.370,-.020,-.013,.096,.298,-.196)*f1_1+\n    mat4(-.116,-.684,-.056,.216,.208,-.183,-.302,.062,.676,.406,-.165,-.361,.951,.069,.387,.259)*f1_2+\n    mat4(.105,.577,.731,.264,-.754,-.019,-.800,-.197,.750,-.671,-.301,-.160,-.089,-.477,.028,-.123)*f1_3+\n    mat4(-.172,-.315,-.155,.106,-.497,-.062,-.440,-.469,-1.177,-.091,.248,.303,.090,.074,-.238,-.142)*f1_4+\n    vec4(-.720,.097,-.408,.629));\nf0_4=sin(mat4(-.396,.133,.082,.151,-.711,-.105,.333,.569,.187,.845,.071,-.154,.151,.501,-.392,-.209)*f1_0+\n    mat4(-.315,-.633,-.020,-.426,.012,.467,.077,.290,-.182,.264,.027,-.017,-.255,.543,.543,-.304)*f1_1+\n    mat4(-.135,.211,.140,-.256,-.426,.069,.426,-.297,.485,.162,.378,-.126,-.708,-.409,.329,-.435)*f1_2+\n    mat4(.262,-.177,.672,.444,-.028,.426,-.123,.308,-.674,.064,-.086,.283,-.381,.408,.103,-.603)*f1_3+\n    mat4(.182,.312,.475,.454,-.013,-.007,.584,-.338,-.543,-.119,.007,.332,-.199,-.051,-.082,.146)*f1_4+\n    vec4(-.792,-.547,.295,.496));\nf1_0=sin(mat4(.190,-.099,.207,.411,-.623,.329,.222,.669,-.034,-.030,-.115,-.215,.669,-.605,-.309,-.656)*f0_0+\n    mat4(.093,.525,.318,.076,.201,.016,.086,-.291,-.308,-.282,.218,.295,-.461,-.529,-.603,-.291)*f0_1+\n    mat4(-.790,-.250,-.204,.122,-.366,-.240,-.095,.475,.021,-1.098,-.268,-.711,.274,.130,-.098,.130)*f0_2+\n    mat4(.597,.504,-.191,-.390,.182,-.066,-.057,-.647,.124,.169,.547,-.181,-.665,-.026,-.092,-.697)*f0_3+\n    mat4(.465,-.401,-.619,.115,.551,.537,-.399,.464,.199,.178,.193,-.097,-.395,1.047,-.979,-.373)*f0_4+\n    vec4(-.601,.609,.839,-.313));\nf1_1=sin(mat4(-.251,-.424,-.659,-.098,-.566,-.106,.298,-.013,-.679,.216,.389,-.489,-.521,.301,-.919,.541)*f0_0+\n    mat4(-.060,.101,-.500,.148,.267,.461,.763,-.220,-.075,-.241,.788,.484,.057,.536,-.076,.012)*f0_1+\n    mat4(-1.110,.478,.130,-.445,-.178,.418,.067,-.334,.748,-.680,-.423,.105,.474,-.068,.273,-.331)*f0_2+\n    mat4(-.287,.080,.017,-.032,-.386,-.486,-.839,.633,.026,.173,.490,.041,-.027,-.180,-.525,-.671)*f0_3+\n    mat4(-.544,-.144,-.445,.227,-.098,.763,-.483,-.690,-.021,-.152,.278,.322,.868,-.168,.551,.207)*f0_4+\n    vec4(.574,.444,.631,-.682));\nf1_2=sin(mat4(.257,-.270,.070,-.947,.703,-.329,-.640,-.176,.441,-.158,.345,-.108,.024,-.268,-.087,.441)*f0_0+\n    mat4(.192,-.106,.023,.082,.208,.025,.236,-.831,.360,.569,.598,.182,-.108,.210,.060,-.024)*f0_1+\n    mat4(-.135,.169,-.844,.141,.273,-.443,.491,.377,-.565,.829,-.177,-.366,-.270,-.543,.068,.086)*f0_2+\n    mat4(.559,.446,.277,.370,.546,-.261,.179,.614,-.326,-.292,-.220,-.591,-.248,.216,-.349,-.316)*f0_3+\n    mat4(-.347,.393,.250,.284,-.250,-.074,.536,-.478,.411,-.134,.340,-.395,.387,.348,.629,-.039)*f0_4+\n    vec4(.232,.133,.485,-.437));\nf1_3=sin(mat4(-.424,.334,.522,.479,-.043,-.392,-.523,-.293,-.018,.195,-.200,-.518,.383,-.340,.249,-.626)*f0_0+\n    mat4(.072,.247,-1.142,.161,-.505,-.292,.096,.124,-.250,-.437,.235,.799,.195,.144,.517,-.454)*f0_1+\n    mat4(.361,.187,.178,-.562,.383,-.095,-.016,.179,.417,-.427,.453,.438,.275,-.512,1.037,-.593)*f0_2+\n    mat4(-.701,-.086,.028,.717,-.405,-.285,.362,.265,.506,-.116,-.247,-.066,-.329,.327,.325,.332)*f0_3+\n    mat4(-.643,1.017,-.328,-.239,.050,.157,.498,-.611,.100,.172,-.651,.864,-.088,-.982,.835,.274)*f0_4+\n    vec4(.673,.765,-.496,.736));\nf1_4=sin(mat4(-.225,-.719,.350,-.101,-.001,-.582,-.109,-.338,.213,.103,.532,.324,.392,.175,-.602,-.180)*f0_0+\n    mat4(.084,-.135,.440,.382,.139,.263,-.552,-.387,-.421,.027,-.718,.412,-.293,-.244,.713,.252)*f0_1+\n    mat4(.852,-.811,.063,.174,-.003,-.332,.391,.673,.494,.191,.697,-.010,.404,.364,-.540,-.081)*f0_2+\n    mat4(.114,-.125,-.002,.040,.036,-.205,-.397,-.580,-.097,-.362,-.073,.003,-.165,-.475,-.281,-.621)*f0_3+\n    mat4(-.653,.248,.437,-.519,-.349,-.419,-.074,.368,.226,-.846,.300,.529,-.040,.018,-.350,-.275)*f0_4+\n    vec4(-.147,-.321,.835,.967));\nf0_0=sin(mat4(.473,.249,-.046,-.549,-.419,-.109,-.058,.101,-.200,-.271,-.016,.636,-.574,.697,-.801,-.631)*f1_0+\n    mat4(.484,-.030,-.115,-.084,-.072,.772,.572,-.615,-.241,.054,-.281,-.124,-.282,-.175,-.254,-.135)*f1_1+\n    mat4(-.544,.573,-.457,.049,-.070,.083,.845,-.287,-.387,.738,-.773,.356,-.218,.022,.109,.405)*f1_2+\n    mat4(-.095,.287,.100,.083,.684,-.608,.238,.068,-.059,.672,.263,.647,-.761,-.363,-.535,-.378)*f1_3+\n    mat4(.592,.540,-.393,.269,-.186,.545,.041,.710,-.358,.324,.318,.274,-.478,-.623,-.021,-.290)*f1_4+\n    vec4(-.576,-.101,-.783,.011));\nf0_1=sin(mat4(.649,-.088,.114,-.928,.031,-.222,.320,-.935,.659,.297,.461,.364,.049,-.021,-.559,.572)*f1_0+\n    mat4(.278,-.170,-.766,-.150,.240,.461,-.805,-.005,.019,.315,.384,-.322,-.230,.613,.020,.123)*f1_1+\n    mat4(-.711,-.101,-.368,.617,.137,-.380,-.010,-.628,-.308,.421,-.154,-.101,-.352,-.111,-.365,-.943)*f1_2+\n    mat4(-.160,-.572,.012,.048,.549,-.005,-.330,-.535,.085,-.569,-.041,-.219,.376,-.161,.181,.092)*f1_3+\n    mat4(-.167,-.806,-.170,-.524,-.513,.525,.043,.087,.679,-.424,-.206,-.631,.242,-.396,-.778,-.057)*f1_4+\n    vec4(.035,-.588,-.778,1.155));\nf0_2=sin(mat4(.114,-.160,.218,-.650,.358,.323,-.534,-.293,.309,-.058,.074,.413,-.069,-.409,.080,-.144)*f1_0+\n    mat4(-.219,.252,.563,.775,-.201,.154,-.291,-.674,.388,-.427,.354,-.277,.137,.299,-.507,-.469)*f1_1+\n    mat4(-.228,.094,.412,-.470,-.590,-.220,-.223,-.828,-.426,-.124,.308,-.336,-.066,.294,-.484,-.234)*f1_2+\n    mat4(-.343,.383,.675,.024,.572,.548,-.161,.581,.342,-.406,.400,.313,-.097,-.464,.405,-.644)*f1_3+\n    mat4(-.193,.498,-.388,-.644,.505,-.411,.472,.431,-.355,-.561,-.008,-.163,-.132,.196,-.559,.024)*f1_4+\n    vec4(-.034,-.348,-.612,-.531));\nf0_3=sin(mat4(-.596,.414,.334,.159,.063,-.141,-.015,-.174,.216,.402,-.230,-.018,.345,-.113,.237,-.221)*f1_0+\n    mat4(.004,-.721,-.309,.516,-.659,-.264,-.909,-.135,-.341,-.262,.699,-.509,-1.033,.062,-.210,-.112)*f1_1+\n    mat4(1.025,-.351,.060,-.731,-.230,-.290,-.822,-.364,-.467,.391,-.057,-.416,.379,.111,-.320,-.902)*f1_2+\n    mat4(-.108,-.864,.065,-.267,.044,.509,-.346,.168,-.233,-.016,.223,-.352,-.628,-.292,-.749,-.055)*f1_3+\n    mat4(.471,.048,-.184,.696,.715,-.345,-.510,.259,.205,-.135,-.173,.628,.154,.886,-.562,.051)*f1_4+\n    vec4(.184,.308,.114,-1.012));\nf0_4=sin(mat4(.065,-.866,-.163,-.226,-.263,.099,-.097,.235,-.201,.584,-.154,-.933,-.570,-.807,-.881,.056)*f1_0+\n    mat4(.266,-.371,.195,.319,-.002,-.120,.717,-.435,-.605,.115,.061,-.213,-.167,-.221,.492,-.379)*f1_1+\n    mat4(-.136,-.106,.120,-.681,.425,-.682,.125,.282,-.489,.161,.222,.405,.438,-.736,.294,.509)*f1_2+\n    mat4(.630,.324,.248,.884,-.765,-.381,.084,-.181,.437,.177,.204,.202,-.096,.127,-.052,-.057)*f1_3+\n    mat4(-.776,-.001,.132,-.198,-.336,.296,.108,.225,-1.027,.088,.606,.351,-.145,.325,.445,.315)*f1_4+\n    vec4(.147,-.080,.630,-.206));\nf1_0=sin(mat4(.394,-.120,.113,.198,-.401,.078,-.033,-.280,.132,-.024,.109,-.522,-.034,-.335,-.727,-.912)*f0_0+\n    mat4(-.496,-.284,-.207,-.090,-.027,-.726,-.567,.148,-.748,.107,-.785,-.022,-.252,-.119,-.511,-.097)*f0_1+\n    mat4(-.628,.193,1.044,.437,-.440,.013,.045,-.265,-.458,-.103,-.776,-.957,.147,-.779,-.228,.645)*f0_2+\n    mat4(-.889,.276,-.012,.531,.260,-.731,-.274,-.098,.354,-.906,.065,-.614,-.568,.749,-.365,-.120)*f0_3+\n    mat4(.005,-.654,-.087,.052,.050,.183,.139,.353,.644,.565,1.050,-.126,-.112,.497,.433,-.037)*f0_4+\n    vec4(.192,-.369,.561,.766));\nf1_1=sin(mat4(.190,-.339,-.003,.053,.180,-.079,-.086,.615,.585,-.313,-.111,-.307,.410,-.221,.019,.230)*f0_0+\n    mat4(-.189,.496,.334,-.548,.243,-.802,-.398,-.022,-.419,-.655,.563,.530,.593,-.048,.282,.105)*f0_1+\n    mat4(.013,.509,-.023,.072,-.024,-.006,-.285,-.587,-.144,-.604,1.502,-.435,-.010,.142,-.598,.171)*f0_2+\n    mat4(-.037,.229,.400,.245,.844,-.182,.243,.142,-.296,.878,-.502,.700,-.285,-.526,-.340,-.752)*f0_3+\n    mat4(-.171,.062,-.308,-.532,.134,.164,-.211,-.324,.231,1.011,-.335,.102,.299,.350,-.540,.170)*f0_4+\n    vec4(.079,.749,-.709,-.285));\nf1_2=sin(mat4(-.186,-.621,.532,.122,-.189,-.003,.089,-.241,-.025,.579,.067,-.107,-.276,.004,-.081,.486)*f0_0+\n    mat4(-.076,-.219,-.643,.269,-.187,.011,-.116,-.150,1.114,-.380,.217,-.494,-.169,-.342,-.348,-.074)*f0_1+\n    mat4(-.019,.299,-.791,-.279,-.357,.794,.425,.597,-.415,-1.197,.017,.009,.658,-.437,.451,-.634)*f0_2+\n    mat4(.469,-.237,-.192,-.801,.262,-.673,-.169,-.032,-.249,.234,-.494,.322,-.036,.854,-.183,-.136)*f0_3+\n    mat4(.009,.063,.127,-.693,.459,-.287,.390,-.626,-.242,1.180,-.416,.239,-.085,-.075,-.183,.777)*f0_4+\n    vec4(-.775,-1.602,-.404,-.607));\nf1_3=sin(mat4(-.131,.011,1.027,-.401,.898,-.219,.224,-.269,-.141,.509,.039,.173,.341,-.162,1.079,.034)*f0_0+\n    mat4(-.214,.282,-.285,.572,-.126,.044,-.093,-.115,.222,.033,.470,.425,-.342,.438,-.402,-.062)*f0_1+\n    mat4(-.191,.716,.355,-.217,-.551,.991,.189,.454,.896,-.294,-.006,.208,-.147,-.425,.654,-.046)*f0_2+\n    mat4(.376,-.199,.128,.077,.438,-.611,.118,-.218,.051,-.801,.604,-.059,-.814,-.622,-.303,.035)*f0_3+\n    mat4(.297,-.805,.047,-.504,-.122,-.041,.422,-.682,-.669,.350,-1.219,-.057,.447,.423,-.720,.563)*f0_4+\n    vec4(-.325,-.709,-.703,-.706));\nf1_4=sin(mat4(.469,.003,-.091,-.326,-.840,-.394,-.019,.021,.377,.524,-.148,.023,-.356,-.020,-.384,-.209)*f0_0+\n    mat4(-.723,-.692,.175,-.179,-.052,.142,-.005,-.102,.092,-.117,.003,-1.250,-.451,.234,-.005,.105)*f0_1+\n    mat4(.193,.818,.192,-.058,-.468,.361,-.322,.083,.475,.331,.371,-.559,-.302,-.439,-.287,.171)*f0_2+\n    mat4(-.075,.107,.664,-.649,-.345,.798,-.915,-.171,-.984,-.081,.038,-.411,.026,.011,.160,-.162)*f0_3+\n    mat4(.488,-.199,-.581,-.374,.244,.746,.901,-.637,.642,.328,-.055,.453,.489,.155,.085,.446)*f0_4+\n    vec4(-.259,-.293,.179,.604));\nf0_0=sin(mat4(-.392,.588,-.658,.381,.360,-.443,.233,.425,-.815,-.174,.900,-.406,-.334,.203,-1.304,.600)*f1_0+\n    mat4(.762,.095,.244,.473,-.594,-.203,-.551,-.545,.105,.839,-.358,-.044,.007,-.419,-.077,-.541)*f1_1+\n    mat4(.513,-.100,-.464,-.210,.019,-.348,.189,-.669,.334,-.404,-.449,-.079,-.276,-.135,-.845,.515)*f1_2+\n    mat4(.235,-.121,.019,.575,-.267,-.124,.832,-.195,.146,-.558,.252,-.800,.090,.574,.607,-.339)*f1_3+\n    mat4(-.189,.143,-.245,.241,.820,-.077,-1.302,-.288,-.494,.193,.120,.174,.336,-.754,.097,-.555)*f1_4+\n    vec4(-.610,-.944,-.349,.530));\nf0_1=sin(mat4(.485,-.030,.827,.025,-.279,.244,.097,-.282,.623,-.106,-.508,.367,.358,-.141,-.225,.058)*f1_0+\n    mat4(-.362,.002,-1.006,.429,.765,.571,-.074,-.494,.363,-.112,-1.158,.791,-.566,.338,.632,.168)*f1_1+\n    mat4(.852,-.678,.001,-2.010,-.033,.049,-.235,-.146,.322,-.888,-.927,.143,.074,-.852,-.475,-.324)*f1_2+\n    mat4(.016,-.409,.001,.447,-.224,.707,.510,-.572,.174,.126,-.050,-.433,-.705,-.907,-.423,.286)*f1_3+\n    mat4(.714,-.325,-.302,.153,.748,-.440,.309,-.110,-.111,-.501,-.818,-.552,.084,.492,.894,-.024)*f1_4+\n    vec4(-.413,.032,.913,-.023));\nf0_2=sin(mat4(-.107,-.097,.421,.416,-.372,.485,.206,-.117,-.121,.338,-1.431,-.071,-.854,1.405,.065,-.435)*f1_0+\n    mat4(.255,.218,-.552,-.436,.328,.725,.218,.061,-.101,.249,-.350,-1.134,-.390,-.300,-.032,-.119)*f1_1+\n    mat4(-.107,-.079,.713,.037,.020,-.540,-.304,-.380,-.030,-.784,-.389,.092,-.649,.343,.731,-.294)*f1_2+\n    mat4(-.824,-.656,-.212,-.135,.636,-.824,.394,.370,.285,.371,-.029,-.577,-.912,-.056,.540,-.326)*f1_3+\n    mat4(-.261,-.064,.149,.022,.391,.153,.290,.731,-.175,.183,.438,-.615,.053,.403,.656,-.184)*f1_4+\n    vec4(.013,-.726,-.662,.235));\nf0_3=sin(mat4(-.334,.146,.255,.720,-.473,-.613,-.005,-.514,.085,-.049,-.004,-.212,-.327,.239,-.710,.232)*f1_0+\n    mat4(.629,.572,-1.085,.077,.008,-.252,-.457,.140,.306,-.704,-.019,.053,-.468,-.710,.373,-.454)*f1_1+\n    mat4(-.513,-.016,-.092,.467,.277,.790,.327,.380,.533,.457,-.141,.107,-.082,.265,-.264,.881)*f1_2+\n    mat4(-.205,.028,.514,-.313,-.074,.285,.421,-.206,-.120,.111,-.179,-.041,.878,-.466,.129,.151)*f1_3+\n    mat4(.146,.092,-.198,-.192,.240,-.045,.092,.059,-.514,.015,-.262,-.485,.018,-.243,-.105,-.215)*f1_4+\n    vec4(.606,.214,.451,.734));\nf0_4=sin(mat4(-.946,.188,.299,-.174,-.087,.477,-.029,.283,.822,.286,.226,-.036,.353,.336,-.501,-.459)*f1_0+\n    mat4(1.004,.627,.465,-.301,.447,.270,.289,-.609,.114,.351,-.217,-1.024,-.173,-.564,-.353,.078)*f1_1+\n    mat4(-1.006,-.128,.050,-.704,-.092,-.398,.342,.283,-.156,.558,-.714,-.389,-.890,.171,-.551,-.465)*f1_2+\n    mat4(-.189,-.247,-.237,.349,-.017,-.287,.027,.499,.145,.162,-.300,-.963,-1.057,-.316,-.141,1.306)*f1_3+\n    mat4(.372,.293,.150,.070,-1.172,.194,-.580,-.702,.515,.070,-.028,.188,-.429,.259,-.693,-1.034)*f1_4+\n    vec4(-.766,-.374,.830,-.209));\nf1_0=sin(mat4(-.049,1.591,.085,-.430,-.110,-.504,.039,.038,-.094,-1.167,.271,-.287,-.418,.182,-.084,-.016)*f0_0+\n    mat4(.427,-1.288,.460,.304,-.285,-.265,-.105,-.128,-.235,.316,-.174,-.155,-.303,-.390,.523,-.197)*f0_1+\n    mat4(.522,-.048,.282,.226,-.061,-.157,.670,.297,.324,-.994,-.037,.006,.333,-.480,-.136,.557)*f0_2+\n    mat4(-.470,.559,-.351,.232,1.041,.095,.757,.493,-.085,-1.742,.083,.438,.463,-1.865,.617,-.460)*f0_3+\n    mat4(-.059,-.547,.545,.572,.247,-.493,.382,.677,.571,.247,.474,.889,-.097,.272,-.109,.295)*f0_4+\n    vec4(-.533,-.474,-.677,-1.159));\nf1_1=sin(mat4(.826,.102,-.023,.595,-.222,-.197,-.317,-.323,.281,.511,.025,-.201,.178,-.631,-.015,.059)*f0_0+\n    mat4(-.969,-.893,-.526,.279,-.130,.898,-1.163,-.070,.230,.281,.712,-.212,.250,.111,.051,-.132)*f0_1+\n    mat4(-.327,-.355,.299,.640,-.324,.076,-.132,-.204,.454,.177,.464,.066,-1.266,-.909,-.409,-.309)*f0_2+\n    mat4(-1.018,-.390,.121,-.074,-1.130,-.556,-.594,-.096,-.376,-.073,-.034,-.616,.363,-.503,-.855,-.262)*f0_3+\n    mat4(-.818,.230,-.138,-.205,-.321,.610,-.160,1.187,-1.461,.440,.856,.701,.336,-.510,.326,-.001)*f0_4+\n    vec4(.704,-.319,.040,-.065));\nf1_2=sin(mat4(.084,.119,.064,-1.053,-.105,.218,.196,.525,-.288,-.018,-.132,-.318,.135,-.474,.344,-.178)*f0_0+\n    mat4(.092,-.205,.558,.050,-.113,.472,.061,-.897,-.141,-.218,.687,.665,.054,.154,-.612,-.761)*f0_1+\n    mat4(.353,.373,.253,-.411,.290,.205,.452,-.301,.149,.610,-.877,-.675,-.153,-.279,.417,.805)*f0_2+\n    mat4(-.245,-.293,.622,.813,.194,.415,.244,-.319,.426,.744,-.787,-.211,-.109,-.074,-.325,-.358)*f0_3+\n    mat4(.148,.769,-.701,-.383,1.068,1.153,-.304,-.968,.226,.359,-.105,-.197,-.025,-.730,.271,.037)*f0_4+\n    vec4(.459,.677,-.235,-.942));\nf1_3=sin(mat4(-.035,.138,.153,.473,.368,-.112,-.813,-.145,-.275,-.068,.253,-.058,.346,-.269,.712,.415)*f0_0+\n    mat4(-.191,.060,.125,-.342,.015,.064,-.095,-.048,.228,.042,-.043,-.152,-.842,-.128,.190,-.396)*f0_1+\n    mat4(-.471,.549,-.591,.110,.378,-.034,-.033,-.191,-.132,.121,-.033,.227,.784,-.064,-.273,-.376)*f0_2+\n    mat4(.268,.002,-.346,-.132,-.026,.074,-1.129,-.184,.006,.133,-.525,-.515,-1.310,-.433,.320,-.674)*f0_3+\n    mat4(-.269,.360,-.738,-.493,-.037,1.234,-.234,.638,.595,.839,-1.237,-.120,.179,-.430,1.198,.085)*f0_4+\n    vec4(1.404,-.232,1.023,-.412));\nf1_4=sin(mat4(.374,.735,.582,.861,.267,-.457,-.912,-.052,.271,.054,.569,-.317,.004,-.688,.393,.996)*f0_0+\n    mat4(1.078,-.172,-.302,.268,.308,.632,.084,-1.121,-.241,-.044,.390,-.338,.696,.494,.735,-.229)*f0_1+\n    mat4(.620,.235,.411,1.058,.187,.013,.175,-1.091,-.202,.518,.440,.299,.526,-1.044,-.673,.078)*f0_2+\n    mat4(-1.048,-.194,-.888,-.022,.371,-.266,-.769,-.258,-1.584,-.037,-.466,-.363,.832,.140,.127,.036)*f0_3+\n    mat4(-1.114,-.001,-.585,-.165,-.189,-.362,.053,.767,.904,.178,-.223,-.221,1.085,.218,.623,-.339)*f0_4+\n    vec4(-.889,-.379,.050,-1.671));\nf0_0=sin(mat4(-.482,.616,-.093,-.208,.025,.536,-.071,-.032,.485,.156,-.121,.548,.400,.474,.366,-1.576)*f1_0+\n    mat4(.013,.468,.337,-1.173,-.462,-.793,-.173,.669,.667,-.061,.201,.227,-.097,-1.774,.444,-.559)*f1_1+\n    mat4(-.431,1.269,-.418,.319,-.289,-.995,.217,-.356,-.194,.140,.425,-1.136,.278,-1.021,.349,-.322)*f1_2+\n    mat4(-.604,-.555,-.079,.004,-.818,-.033,-.841,.586,-.282,-.337,-.005,.820,-1.289,-1.874,-.579,.726)*f1_3+\n    mat4(.386,-.334,.210,-.246,-.697,1.071,-.325,-.217,-.842,.047,-.337,.808,.100,.677,.046,-.430)*f1_4+\n    vec4(.090,.897,-.084,1.048));\nf0_1=sin(mat4(-.370,-.485,-.268,-.058,-.159,-.332,-.067,-.130,1.876,-.538,1.456,.081,.334,1.222,.260,-.986)*f1_0+\n    mat4(-.602,.399,-.408,-.301,-.034,-.135,-.150,.427,1.354,-.231,1.096,.202,1.694,1.086,1.136,.054)*f1_1+\n    mat4(-.111,-.873,.195,-.690,-1.200,.889,-1.042,.155,-1.000,.640,-.744,-.217,.140,.777,.035,.354)*f1_2+\n    mat4(-1.318,.456,-1.057,.035,-1.322,-.282,-1.226,.311,.943,-.593,.674,.510,-.125,.486,-.412,.232)*f1_3+\n    mat4(.814,.358,.609,.071,-.809,-.310,-.572,-.754,-.002,-.626,-.055,.063,.269,-.052,.254,-.465)*f1_4+\n    vec4(1.617,1.050,1.061,.957));\nf0_2=sin(mat4(-.155,.117,-.289,.031,-.058,.016,-.053,-.069,-.327,1.161,-.948,.340,.636,-.594,1.828,-.035)*f1_0+\n    mat4(.365,-.391,1.223,-.179,-.507,.272,-1.338,.554,-.322,.639,-.943,.355,.602,.092,1.338,.225)*f1_1+\n    mat4(.889,-.249,2.163,-.836,.050,-.792,.159,-.172,.311,-.657,.991,-.054,.085,-.083,.122,.187)*f1_2+\n    mat4(.049,-.719,.129,-.001,-.767,-.288,-1.740,.599,-.475,1.182,-1.343,.236,-.425,-.130,-1.267,.582)*f1_3+\n    mat4(.248,.259,.567,.058,.157,-.704,.598,-.274,-.085,.401,-.205,-.009,.237,-.275,.575,-.246)*f1_4+\n    vec4(-1.320,.944,-.600,-.620));\nf0_3=sin(mat4(-.004,-.398,.124,-.843,-.132,.050,-.013,-.731,-.551,1.767,.308,-.132,-.390,1.092,-.327,-.106)*f1_0+\n    mat4(-.205,.375,-.203,-.321,.462,-.488,.246,.681,-.407,1.354,-.111,.212,.131,.513,.280,2.410)*f1_1+\n    mat4(-.221,-.035,.056,-2.037,.655,-1.550,-.299,1.233,.094,-.501,-.298,.046,.192,.391,-.153,1.433)*f1_2+\n    mat4(.604,-1.222,.024,.474,1.040,-1.485,.783,-.699,-.106,.141,.288,.438,1.171,-.945,.651,1.975)*f1_3+\n    mat4(-.201,.782,-.052,.640,.121,-1.156,.053,-1.601,.133,-1.360,.321,-.194,-.248,.017,-.058,-.823)*f1_4+\n    vec4(.321,1.198,-.206,-.634));\nf0_4=sin(mat4(-.202,-.380,.225,.201,-.098,-.181,.154,.288,.287,1.993,.042,-.298,-.048,-.780,.281,.888)*f1_0+\n    mat4(-.199,-1.014,.247,.327,.003,-.051,-.271,-.464,.244,1.675,-.216,-.524,.583,1.304,-.287,-.589)*f1_1+\n    mat4(.139,-1.230,.446,1.407,-.106,-1.216,-.365,-.247,-.250,-1.428,.099,.213,.111,.283,-.309,-.726)*f1_2+\n    mat4(-.171,-1.730,-.094,.169,-.372,-2.083,.259,.347,.147,1.775,-.205,-.871,.155,-.799,-.321,-.260)*f1_3+\n    mat4(.222,.815,-.090,-.387,-.216,-1.905,.369,1.393,.020,.507,.077,-.023,.005,-.040,.203,.595)*f1_4+\n    vec4(-1.487,-.581,-.618,-1.501));\nfloat f_0=dot(f0_0,vec4(-.050,.015,-.195,.078))+\n    dot(f0_1,vec4(-.042,-.052,.039,.207))+\n    dot(f0_2,vec4(-.025,.081,.014,-.060))+\n    dot(f0_3,vec4(-.153,.025,.034,.033))+\n    dot(f0_4,vec4(.123,.024,-.179,.140))+\n    0.436;\nfloat f_1=dot(f0_0,vec4(-.050,.064,-.083,.020))+\n    dot(f0_1,vec4(-.120,-.058,.188,.186))+\n    dot(f0_2,vec4(.019,.054,-.004,.016))+\n    dot(f0_3,vec4(-.029,.018,-.091,.051))+\n    dot(f0_4,vec4(.290,.021,.040,.113))+\n    0.593;\nfloat f_2=dot(f0_0,vec4(-.054,.086,-.080,.014))+\n    dot(f0_1,vec4(-.012,-.063,.030,.189))+\n    dot(f0_2,vec4(.252,.054,-.059,-.022))+\n    dot(f0_3,vec4(-.077,.014,-.138,.061))+\n    dot(f0_4,vec4(-.068,.014,.144,.118))+\n    0.367;\n    #endif\n    return step(-2.0,x.z)*step(x.z, 2.0)*vec3(f_0, f_1, f_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\n    vec3 col = morshu(vec3(uv*1.25*1280.0/vec2(1280,800), 1.1*(4.*(iTime/17.0) - 2.0)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "float siren(float t)\n{\n    vec3 p = vec3(0, t, 0);\nvec4 f0_0=sin(p.y*vec4(575.7548,-469.7783,793.1334,-835.9983)+vec4(562.4169,622.5954,-487.1955,-698.2233));\nvec4 f0_1=sin(p.y*vec4(908.0528,-300.7924,303.5605,234.7999)+vec4(835.8616,-105.4050,468.3030,-880.2651));\nvec4 f0_2=sin(p.y*vec4(264.9078,-989.0065,734.6648,998.7451)+vec4(-522.0610,123.6744,844.7973,-129.2162));\nvec4 f0_3=sin(p.y*vec4(882.4570,-907.0678,-377.6720,171.1838)+vec4(402.7146,-785.6163,792.6605,-893.4907));\nvec4 f0_4=sin(p.y*vec4(-328.3991,474.8787,-601.5077,572.9020)+vec4(188.0659,483.5033,-450.6787,-538.6780));\nvec4 f0_5=sin(p.y*vec4(-649.0092,-130.0247,447.5804,760.3737)+vec4(-152.6224,392.8647,-835.8930,-938.0966));\nvec4 f0_6=sin(p.y*vec4(383.2433,-683.8471,-463.9927,-402.6911)+vec4(860.2789,-461.2266,881.3995,-217.4214));\nvec4 f0_7=sin(p.y*vec4(-995.5300,496.8432,-920.3287,157.7368)+vec4(195.3464,-475.8454,331.7621,-309.4088));\nvec4 f0_8=sin(p.y*vec4(-273.7288,-667.9046,166.7693,879.1281)+vec4(-728.5545,-679.3924,-961.1102,559.8387));\nvec4 f0_9=sin(p.y*vec4(-864.4897,339.3458,-75.6692,619.5046)+vec4(684.8781,-815.1909,-3.3182,848.5427));\nvec4 f0_10=sin(p.y*vec4(-922.8561,-57.7888,-307.5881,208.3052)+vec4(914.7203,388.9067,570.0531,-709.9237));\nvec4 f0_11=sin(p.y*vec4(18.5802,-224.8962,-224.1169,138.9391)+vec4(960.0183,319.3489,-897.6747,-774.9761));\nvec4 f0_12=sin(p.y*vec4(-230.8217,-408.5361,-542.9132,695.5806)+vec4(-867.2494,-881.7858,386.6634,115.5600));\nvec4 f0_13=sin(p.y*vec4(-158.8401,745.0535,-753.6505,-779.3725)+vec4(423.6765,-259.4352,-547.5709,-757.5646));\nvec4 f0_14=sin(p.y*vec4(738.1993,90.4820,366.2555,40.4094)+vec4(-376.5937,341.9297,631.5129,533.7518));\nvec4 f0_15=sin(p.y*vec4(-312.1593,-406.5955,-12.8786,446.5695)+vec4(728.3518,-98.7520,-622.9316,76.1294));\nvec4 f1_0=sin(mat4(-.1443,.2767,-.9438,-.2189,.8125,.1081,1.1922,-.2638,.2672,-.1878,-1.4424,-.7071,.0649,-.2849,.7633,-.6460)*f0_0+\n    mat4(.4610,-.6932,-.5239,-.1074,-.1285,.2840,.4934,-.6355,-.5556,.0513,-.8209,.4140,-.3328,-.0296,-.5311,1.3394)*f0_1+\n    mat4(.0013,.2606,.9238,-.1662,.5886,-.5153,-.9159,-.2913,.7094,.1849,.6765,-1.1002,-1.1651,.0749,.7248,-.8667)*f0_2+\n    mat4(-.0186,-.4871,.4936,.6407,.7055,.1058,-.1212,1.0355,.4882,-.0136,-1.2311,.8243,-.5302,-.2890,-1.3292,-.1303)*f0_3+\n    mat4(.5509,-.0844,.6626,-1.3191,.4590,-.8376,1.0916,-.4713,.1284,.6198,.6505,.3340,-.0159,.3267,-.2449,-.5922)*f0_4+\n    mat4(-.1632,.4512,1.3417,.6131,1.4035,.0602,-.3273,-.4006,-.4980,-.0032,1.8240,.8307,-.1361,.1671,.3939,-.1610)*f0_5+\n    mat4(-.3611,-.1615,.5087,.3232,1.0023,-.3946,.9209,-.2526,.5130,-.3100,.5617,-.5257,-.5025,-.5275,-.3586,.0998)*f0_6+\n    mat4(.5324,.5042,.9539,1.2013,-.4733,.2252,-.7926,.6757,.6352,-.6595,-.5217,-.6702,-.0798,.6121,-.6460,-.4756)*f0_7+\n    mat4(.2565,-.1866,.4923,-.8003,.5785,.5438,.4043,.2609,.3272,-.0317,.5516,-1.4750,.0573,.3733,.1353,.2580)*f0_8+\n    mat4(-.6306,-.3691,.4747,-.1250,-.0754,-.4167,.0420,1.0931,.0831,.1655,-.0930,.2171,-.3463,-.3944,-.3118,-.5957)*f0_9+\n    mat4(.5288,.5237,.3221,-.4142,-.8659,-.1787,-.0012,-.3464,.1631,-.3571,-.2677,.6951,.8023,.0206,.2253,-1.2067)*f0_10+\n    mat4(-1.4230,.1127,-.0316,.4563,-.2931,.1821,.4262,1.0678,.0756,-.0793,1.0548,.4981,.4309,.0090,-.9058,-.9179)*f0_11+\n    mat4(1.1989,.2265,-.3431,-.5298,.0782,.5415,-.7531,.2016,-.5022,.6933,.6718,1.4326,.4576,-.1404,-.5439,.5812)*f0_12+\n    mat4(.3585,-.0106,1.0340,-.5460,.7598,.0573,-.9201,.4393,-1.3217,.4814,-.8616,-.1116,.1839,.1799,.7322,.9299)*f0_13+\n    mat4(-.0484,-.4241,1.3187,-.4052,.3657,-.7936,.3739,-.3393,.3635,.2781,.6046,-1.0721,-.0150,-.0728,1.2884,.7988)*f0_14+\n    mat4(-.4258,.3823,.7387,-.6569,.3731,.3042,.0077,-.0578,.3989,-.1391,-1.9921,.9671,1.4734,-.0850,1.4277,-.0545)*f0_15+\n    vec4(112.4876,11.8419,-31.3487,37.3543))/1.0+0.*f0_0;\nvec4 f1_1=sin(mat4(.4887,-.6294,-.2960,1.2166,-.3767,.3759,-.1768,-.3198,-.0311,1.0005,.6206,.5708,-.5571,-.0551,-.0664,.8003)*f0_0+\n    mat4(.1084,.4692,-.1461,-.8586,.4596,.3953,-.1000,-.8224,-.5475,-.4593,-.1529,.1890,-.8896,.7394,.8619,.4476)*f0_1+\n    mat4(-.0629,-.4981,.2391,-1.3544,.4710,-.6096,-.5837,-.9104,.8720,-.6731,.5407,.4376,.7545,-.1016,.8927,1.3836)*f0_2+\n    mat4(-.6899,.3819,-.1060,.7610,-.0986,.0018,.9677,.5515,.3698,.6633,1.4024,-.9205,-.7367,.7314,-.7244,.1025)*f0_3+\n    mat4(-.5928,-.2379,.5513,1.0419,.4918,-.6879,.1598,-.8451,-.5118,-.0664,.8076,.6667,.1752,-.8336,.2849,.2039)*f0_4+\n    mat4(-.5397,.4635,.0681,.4008,-.4503,1.0614,-.5957,-.1424,-.2716,-.0465,.2629,-.0118,.6297,-.2321,1.0173,-.5258)*f0_5+\n    mat4(.7744,-.5246,-.3151,-.3272,1.0647,-.0025,-.2600,-.1228,-.4698,-.8941,.1562,.4843,-.6342,-.1759,.9668,.2311)*f0_6+\n    mat4(.1038,.1426,.2976,-.0771,-.2454,.4665,.4514,.3725,-.3606,.4077,-.0051,1.1324,-.4076,.1205,-.4707,-1.2259)*f0_7+\n    mat4(-.6263,.4033,1.1313,1.8498,-.7099,-.3942,.7962,.3783,-.1041,-.5832,-.2297,-.1461,-.3533,.2750,.0725,.7640)*f0_8+\n    mat4(.0054,.6031,-.8047,1.1513,-.4916,1.2254,.3640,-.4444,.7303,-.1604,.7971,1.0973,.8426,.3664,.0458,-.1731)*f0_9+\n    mat4(.9032,.2493,-.3086,1.2220,-.2887,-.1775,-.4025,.8669,.3019,-.5728,.9847,.8164,-.9552,-.9301,-.1912,.3465)*f0_10+\n    mat4(-.3311,.5271,.2927,-.3916,.6306,-.3419,.3718,.1515,.0418,1.0739,-.7191,.8809,.0110,.7637,-.4258,-.6431)*f0_11+\n    mat4(.1580,-1.0259,.2092,-.2840,.5273,-.6009,-.1781,-.6450,-.3668,.7591,-.3345,-.7599,-.4188,-.0200,.1078,-1.6394)*f0_12+\n    mat4(.4477,.1827,.0516,-.9464,.9875,.1074,-.5934,.9402,-.5171,1.0343,-.1398,.1835,-.0992,.8174,.7488,-1.2204)*f0_13+\n    mat4(-.3208,-.5990,.1092,1.0498,.2590,-.5355,-.2174,.9628,-.1540,1.0921,-1.0673,.1461,.1313,-.5075,-.1493,2.0566)*f0_14+\n    mat4(1.1052,.5535,-.1146,.7529,.0643,-.1401,.4916,-1.0195,-.2054,1.4136,.0221,.7822,.3825,-.3645,.0722,.0797)*f0_15+\n    vec4(15.1895,-25.4474,50.8418,-31.7513))/1.0+0.*f0_1;\nvec4 f1_2=sin(mat4(.6164,1.2490,.0857,.2626,-1.2478,-.3651,.2898,-.7735,-.4268,-.3786,.3861,-.0394,-.7551,.9983,-.6142,-.5917)*f0_0+\n    mat4(.6473,.7722,-.8400,.1929,-.7133,.4747,.4241,-.2163,-.0123,-.4034,-.6009,-1.0517,-.4606,.4748,-.1822,.5649)*f0_1+\n    mat4(.0445,-1.3707,-.1399,-.8228,.4133,.2914,-.1486,-.6174,.0984,.7998,-.3087,.0370,-.0164,1.0958,.3341,.0566)*f0_2+\n    mat4(.7639,-.1143,-.1959,-.0684,.8553,-.8495,.3486,-.1659,-1.1327,.8773,.0897,1.1229,.6529,1.3264,-.2419,.9189)*f0_3+\n    mat4(.8326,-.5249,-.7098,-.6267,.9802,.9539,.4920,-.0607,.0556,-.1893,.4655,.3480,.5463,.6107,-.4320,-.7043)*f0_4+\n    mat4(-.0432,.1353,-.1841,-.0799,1.0133,-.4795,.4732,-1.1621,-.3322,-.3699,-.2701,1.0441,1.1839,-.4213,-.1390,.4874)*f0_5+\n    mat4(.4041,-.3215,-.2601,-.3271,.7858,-.0416,.7984,.2732,1.1528,-.3753,-.1104,-.1131,.6032,.7360,-.5644,.1062)*f0_6+\n    mat4(-.3785,.5913,-.0010,-.0102,1.1691,-1.4693,-.6138,-.8474,.5449,.5993,.3853,-1.0850,.7905,-.1480,.4468,-.2615)*f0_7+\n    mat4(-.2803,-.6697,.1102,2.0029,-1.0897,.0049,.0352,.9307,.0563,.8381,-.1876,.4744,-.1182,.3562,-.8232,-.7249)*f0_8+\n    mat4(1.1055,-.4934,.8931,-.5599,-.9525,.7032,-.1968,1.2433,1.2126,.5646,-.5602,-.3493,-.5528,.6742,.3655,.5081)*f0_9+\n    mat4(.3559,.3614,.1737,-.3939,1.3784,.2402,-.0744,-.4818,.1563,.9144,-.3037,.1159,-.8699,-.2647,-.0627,-.1307)*f0_10+\n    mat4(-.2441,1.1155,.6841,.9305,-1.0969,-.5174,.0316,-.0808,1.1651,-1.2824,-.1252,1.8763,-.7201,-.1623,-.0906,.8670)*f0_11+\n    mat4(-1.1219,-.4714,-.4307,-.3832,-1.4215,.6651,.1349,.6320,-.6980,-.1666,-1.0534,-1.3543,1.0851,-.5467,-.1793,.7519)*f0_12+\n    mat4(1.4880,-.3125,.0685,.4452,.8798,-.1999,-.0184,-.1639,.2679,.4292,.3977,-.1258,.1871,-.9026,.9531,.0319)*f0_13+\n    mat4(.7725,-.6977,.1967,.0345,-.9832,-.8895,.2072,-.5430,-1.0056,-1.3968,-.7199,.6929,-.2226,-.4192,-.3248,-.9137)*f0_14+\n    mat4(.4137,1.0938,-.3353,.0563,-.2575,.9036,-.0196,-.4356,.1114,-.6230,.0253,-.2965,.6969,-1.0443,.7785,.7097)*f0_15+\n    vec4(100.0736,-24.8681,-57.0871,-81.9981))/1.0+0.*f0_2;\nvec4 f1_3=sin(mat4(-.2852,-.4655,1.7904,-.4164,-.5239,.0797,-.3956,-.0760,-.0196,.0384,-1.6017,.2083,.0642,-.4418,-.4804,-.5805)*f0_0+\n    mat4(.2584,-.4033,.5059,-.0540,-.0494,.5493,-.4788,-.1162,-.0485,1.1023,.1962,-.2490,-.4040,-.1265,.5220,.1556)*f0_1+\n    mat4(.6196,1.5695,-.7763,-.4208,.6747,.7271,1.2818,.2660,-.5822,-.2137,.7007,-.1017,.0607,-.9934,.1158,.0573)*f0_2+\n    mat4(-.0782,.2199,1.1949,-.2383,-.3424,.5199,-.8117,-.0006,.1281,-.4208,-1.5268,-.3198,.4923,-.9211,1.3466,-.0198)*f0_3+\n    mat4(-.1761,.0245,.8923,-.0051,.4243,.5453,.7385,-.4173,-.4334,-.0480,.0312,-.0516,.2767,-.6486,-.7739,-.1480)*f0_4+\n    mat4(.0555,-.0713,.9138,.0369,.2481,.1318,-1.2397,-.2980,.3024,-.7933,1.2569,-.1482,-.3699,.1996,.0311,-.2552)*f0_5+\n    mat4(.3471,-.0731,-.5720,-.3517,.1308,.2829,-.3187,-.2181,-.0675,-.2444,.4217,-.0740,.4352,1.1212,-1.0336,.1887)*f0_6+\n    mat4(-.3868,-.2427,-.1235,.1943,-.4341,-.6131,.5809,-.5202,-.6189,1.1289,-.6373,.2469,.3002,1.2291,-1.5329,.2520)*f0_7+\n    mat4(.3837,-.5763,-1.3853,.0690,.3623,-.2111,-.8268,-.8158,.3620,-.3221,.3034,.1368,-.2041,.7474,.8543,.0342)*f0_8+\n    mat4(-.2976,.3895,-.0555,-.3909,-.2076,.6696,-.3882,.2355,.0438,-.7892,1.1150,.4720,.0595,-.0658,-.2726,-.2012)*f0_9+\n    mat4(.1178,1.6118,-.0182,-.0017,-.4682,.8436,.5626,-.1020,.7830,.7209,-.3790,.3283,.5058,.0743,.9800,-.1138)*f0_10+\n    mat4(-.2040,.3106,-.1257,-.0058,-.2142,-.7657,-.4386,.1164,-.5269,-.8155,-.2401,-.2836,.3381,-.4371,-.8259,.3919)*f0_11+\n    mat4(-.0488,.1987,.9386,.2188,.1553,.4786,.1793,.4604,.1396,.6008,-1.3633,.1205,-.1237,.0736,-.6694,-.1672)*f0_12+\n    mat4(-.0027,-.2329,-.2533,.0417,-.1986,-.7406,.3293,-.2037,.5345,-.2702,.0646,-.2219,-.4768,.6405,-.7899,-.0755)*f0_13+\n    mat4(.4395,-.9008,-.6817,-.5218,-.0934,-.8738,1.0592,.0005,.3124,-.0716,-.6046,-.0706,-.5125,-.3400,-1.0057,-.1081)*f0_14+\n    mat4(-.4348,-.9899,.7661,.3152,-.0825,-.4833,.3064,.2901,.3170,.3522,-.3182,.4119,-.4049,.1329,-.2953,-.2229)*f0_15+\n    vec4(-49.3674,64.3796,109.5191,67.7079))/1.0+0.*f0_3;\nvec4 f1_4=sin(mat4(.7565,.3502,.3630,-.0148,-.2187,-.3698,.1585,-.1364,-.5697,-.1785,-.2893,1.0525,-.4393,-.5227,.0679,.6526)*f0_0+\n    mat4(-.5560,.3490,.2197,.3290,-.5319,.5467,-.8805,-.8266,-.5787,.7859,.5575,-.6515,-.3104,-1.0828,-.2262,-.7120)*f0_1+\n    mat4(-1.6063,.8484,.5332,.1604,-1.9373,-.5545,.6737,-.1557,-.9785,-.8764,.2798,.0298,-.4298,.2461,-1.2488,.0711)*f0_2+\n    mat4(-.9034,.0169,.3612,-.4784,.3243,.8247,.9058,-.4049,.2643,.4724,.7293,-.0040,-.9964,-.6806,.1125,.3549)*f0_3+\n    mat4(.2593,-.5588,-.8703,-.1720,.1878,1.3637,-.7478,-.0333,.3075,-.4087,.7783,-.0170,-.5175,.8218,.2588,.9118)*f0_4+\n    mat4(.9125,-.3369,.5571,-.0766,.7090,-.9312,.4144,.4238,-.5547,-.1110,-.1529,-.4122,-.0280,1.1639,.6107,-.3339)*f0_5+\n    mat4(-.8998,.6509,-.5509,-.5189,.3029,1.0557,-.8490,.0830,-1.9136,-.6394,.8746,.2369,-.5810,1.2965,-.4655,.0321)*f0_6+\n    mat4(1.0501,-.0915,-.0139,.0310,-.1411,-.6138,.3589,.5939,.3313,-1.0945,.1211,.1720,1.6834,-1.1606,-.9889,.1883)*f0_7+\n    mat4(-.0092,-.5977,.6462,-.2987,-.2661,.8608,-.5805,-.4770,-1.1407,-.4724,.1142,.6819,-.7590,-.0927,.4732,-.3163)*f0_8+\n    mat4(1.5231,.7244,-.0015,-.0531,-.2419,-1.1997,-.9982,.4299,-.7411,-1.0842,-.4487,.0485,.5256,-.9153,-.6227,.1896)*f0_9+\n    mat4(.3378,.5101,-.2593,.8512,-.4017,-.0047,.4958,.0668,.7485,1.1002,-.5015,.1294,-.6903,.0718,-.4872,.3686)*f0_10+\n    mat4(-.4712,-.5987,-.1334,-.4839,-.0520,-.4242,.3532,.0386,1.0848,-.0927,-.6661,-.2715,.0538,.0769,.4161,.4497)*f0_11+\n    mat4(-.7986,-.2535,-.6482,-.4501,.0427,-.4053,-.0820,-.1022,.6559,-.6595,-1.1048,.5912,1.9387,.8778,-.1167,-.0220)*f0_12+\n    mat4(-.2167,.3208,.6081,-.5588,-.4496,.7154,-1.0731,.1002,.5821,.1169,-.3106,-.1967,-.6120,-.5161,.2675,-.2598)*f0_13+\n    mat4(-1.0288,1.2866,.3784,-.4099,.2645,-.9256,.8585,-.1203,-.0417,.3551,-.6639,.1180,1.1571,.0292,1.0057,-.4940)*f0_14+\n    mat4(-.1124,-.9403,-.5114,.0474,-.0285,-.7024,-.1153,.6098,-.0507,.1199,.7503,-.6735,-.2325,-1.3741,-.9535,.3171)*f0_15+\n    vec4(62.8016,-53.4670,28.7346,-52.0802))/1.0+0.*f0_4;\nvec4 f1_5=sin(mat4(.4875,-.4124,-.9271,.6598,1.3877,-.6881,-.3810,.0010,.3588,.7300,.1053,.2408,-1.3400,.4228,.0208,-.7582)*f0_0+\n    mat4(1.0380,.6535,.4563,-.2147,.1897,.3128,-.5056,.2243,-.3314,1.3785,-.3109,.2082,-.6802,-.5984,.4070,.2119)*f0_1+\n    mat4(.9615,-.9194,-.6514,-.1492,1.0900,.2611,.3226,-.3600,.6619,.9349,.5884,-.1169,-.0123,.5412,-.3472,.0523)*f0_2+\n    mat4(.0323,-.1941,.6354,.0959,.5174,.3728,.0946,.1392,-.6784,-1.3659,-.4769,-.5095,.3673,-.6394,-.2686,.1966)*f0_3+\n    mat4(.5432,-.9273,.7368,.7019,.5436,.8167,.0899,.5571,.9227,.3701,-.4840,.7606,-.1006,.1558,-.8111,-.2018)*f0_4+\n    mat4(-.2329,-.1931,-.2992,.0794,.1962,.6291,.5778,-.7974,.1834,-.9419,-.3959,.6050,-.2842,-.4888,.9016,.3476)*f0_5+\n    mat4(-.0958,-.1413,.0944,-.2819,-.6290,-.2753,-.7384,-.0067,.2338,-.7728,.2330,-.1946,-.4444,-.4719,-.3148,-.7379)*f0_6+\n    mat4(.2401,-.0414,.1332,-.7064,.9917,.2758,.5692,.7212,.3035,-.3658,-.2507,-.4373,-1.1026,.5597,-.3235,.8654)*f0_7+\n    mat4(.8562,-.3548,.7484,.0625,-.8643,.6486,.2160,.3775,-.6310,1.4286,-.3079,-.2714,-.0956,-.3343,-.5448,.0467)*f0_8+\n    mat4(-.9417,.5295,.1036,-.1480,-.5455,-.6997,-.2535,-.4741,-1.2174,.8270,.3019,-.8679,-.8216,-.1982,-.4150,-.3823)*f0_9+\n    mat4(-.5155,-.7553,-.7422,-.3976,.5538,-.4908,.1991,-.0438,-.2289,-.9257,.0337,.2691,-.2336,-.6078,-.1822,-.4715)*f0_10+\n    mat4(-1.4600,.1420,.1451,.1878,-.6886,.3715,.3115,.2677,-.1159,.6896,.2262,-.7236,.5552,-1.2863,.1822,.1405)*f0_11+\n    mat4(-.1332,.3384,-.4980,-.3561,.2235,1.1877,-.3051,-.1130,.3922,-.0447,-.5175,-.1588,.0373,1.3371,-1.6405,-.2002)*f0_12+\n    mat4(.0373,.4167,-.0331,-.2663,.0690,-1.4803,.1836,-.7124,-.3893,-.1781,.0122,-.5137,-.6415,-.3513,-.1931,.4028)*f0_13+\n    mat4(-.7511,-.5683,.5778,-.1574,-.3846,-.3437,-.3900,-.3786,-.5345,.8245,-.3171,.2990,.0401,-.7920,-.0125,-.2591)*f0_14+\n    mat4(1.1662,-.4289,-.9294,-.2643,-.4118,.2379,-.1630,.2969,-1.6572,-1.1550,.5176,.2518,-.0822,-.2282,-.5695,.9484)*f0_15+\n    vec4(-103.0453,-93.2646,-91.2877,119.2630))/1.0+0.*f0_5;\nvec4 f1_6=sin(mat4(-1.0685,-.5871,-.1080,-.1819,.4722,.3078,-.1858,-.4184,.6018,.6339,.2593,-.0183,.0136,.9917,-.1284,-.1708)*f0_0+\n    mat4(.4753,-.2049,.1394,-.1743,-.4878,.1458,-.2023,.0191,.0005,.4994,.1004,-.0520,.1080,.4316,-.0839,.3519)*f0_1+\n    mat4(-.0610,-.5799,-.3670,.3869,.6954,.0763,-.4085,-.1172,.4444,.1208,-.0635,.3613,-.8978,-.4717,-.1670,-.2320)*f0_2+\n    mat4(.5791,.9384,.0355,-.0761,-.4264,.8215,.3769,.5498,.2978,-.4710,-.0739,-.4286,.2838,-.3849,.2369,-.3286)*f0_3+\n    mat4(-1.0063,.7420,.0979,-.3119,.4006,1.1658,-.0181,.0872,-.3339,1.4250,.0767,-.2622,-.6891,-.5210,.0012,.1494)*f0_4+\n    mat4(-.9155,-.0393,.1245,-.1381,.7055,.3675,.0694,.0362,-.1524,-.7766,.0582,.3075,.6690,.7008,.2466,.3039)*f0_5+\n    mat4(.4351,.4773,-.0666,.0435,-.4063,-.2766,-.1234,.4949,.0423,.1248,-.0013,-.2736,-.3231,.4982,-.0317,-.3772)*f0_6+\n    mat4(-.4943,.2716,.2210,.1453,.1670,.1464,-.2369,-.1930,-.3906,.4386,-.1996,.4048,-.1910,1.5002,.0975,.0532)*f0_7+\n    mat4(.3705,.0129,-.1293,-.3786,-.1403,-.0550,-.0090,.2072,-1.1777,.6084,-.4044,.0548,-.3298,-.3549,-.0389,.4170)*f0_8+\n    mat4(-.8725,.5854,.0532,-.4616,-.4041,-.5240,.0852,.0908,.1687,-.5434,-.0870,-.0962,.2676,-.6072,-.0426,-.1975)*f0_9+\n    mat4(-.2258,-.1841,-.0625,-.2864,.0019,.3186,-.1598,-.3973,.2941,-1.4987,.0376,-.4858,-.0989,-.4430,.1313,-.2007)*f0_10+\n    mat4(.3703,-.6629,-.1507,-.0439,.3376,-.2962,-.1252,-.1228,.5348,-.4535,.1135,.0843,.3623,-.1128,.2656,.5088)*f0_11+\n    mat4(-.0792,.5397,.4271,.1894,.1815,-.6388,.0189,-.3300,.3784,-.7816,.1127,.0728,-.2876,.1420,-.0010,-.1432)*f0_12+\n    mat4(-.4803,.1604,.2797,-.2009,.1649,-.3598,-.0635,-.7853,.3807,-.1195,-.0761,-.0679,.1695,.3924,-.0423,.0847)*f0_13+\n    mat4(.1752,-.1567,.0477,.1829,-.3321,-.9292,-.0188,-.5059,-.8138,.3258,.0639,.2062,.3937,-.4453,-.0216,.0278)*f0_14+\n    mat4(.9237,.9604,-.0991,.2433,.2399,-.7794,-.2164,-.4085,.5097,-1.3282,-.2960,.2620,.1327,-.3876,-.2966,.3365)*f0_15+\n    vec4(68.0597,-97.1007,108.5093,-55.0507))/1.0+0.*f0_6;\nvec4 f1_7=sin(mat4(.4221,-.4250,.2580,-.3287,.6251,-1.1074,-.4648,-.2877,-1.2887,-.7501,-.2853,1.1317,.0668,-.1219,-.6372,.4239)*f0_0+\n    mat4(.6814,.8392,.2423,.3675,.6747,.2636,.0128,.6501,.9052,1.3200,-.0880,-.0823,.3521,-.5146,.1073,.5574)*f0_1+\n    mat4(-.3786,-.5591,.6435,.1910,-.5343,-1.0020,-.0200,-.2316,-1.0946,-.2201,.1336,.8047,-.0645,.7615,.6873,.3935)*f0_2+\n    mat4(1.0109,.9931,-.2870,.0513,.4296,.4129,.3822,-.1495,-.6713,1.4113,-.7195,.1696,.8584,.5027,-.1993,-.0204)*f0_3+\n    mat4(.0004,-.5323,.4685,.8136,.7488,.3015,-.1111,.5304,.2826,.6559,.3975,-.2522,-.6758,.3001,.1203,.0272)*f0_4+\n    mat4(-.1676,.4774,-.0395,-.1176,1.2601,-.7995,.0586,.2011,.7962,.8724,-.3938,-.5356,-.1967,.5043,.6078,-.1237)*f0_5+\n    mat4(.2612,-.8166,-.0597,-.0999,-.4119,-.3345,.5212,-.5603,-1.8869,-.2566,-.2947,.3326,.8020,-.1428,.0827,.4325)*f0_6+\n    mat4(.4844,.6942,.3533,.2375,1.2744,-1.1738,.4061,.8577,.1967,.0497,.2304,.3535,-.0111,.0484,-.5012,1.0588)*f0_7+\n    mat4(-.2855,-.5274,.0802,-.3426,-.5498,-.0406,-.6154,-.0073,-.4048,.3261,-.2649,.3539,-.0922,-.4114,.4752,-1.1041)*f0_8+\n    mat4(-1.4115,-.6861,-.0555,-.0125,-.0305,-.2430,-.0585,.2011,-.5622,-.5143,-.0555,1.3141,1.8761,1.0142,.0602,.4577)*f0_9+\n    mat4(-.0441,.3096,.1626,-.6497,.1249,.9604,.0708,-.1252,.0488,-.4325,-.1654,.6541,.2932,.4813,-.1233,-.1469)*f0_10+\n    mat4(1.0156,-1.1947,-.2270,-.2282,-.0696,-.3151,.3860,.1075,.9768,.7102,.2123,.1190,.4135,-1.3039,.0455,.6014)*f0_11+\n    mat4(-.3997,-.8892,.1306,1.2413,-.5135,.1047,-.3034,-.6207,1.0548,.1172,-.4777,.4122,1.1334,.3483,.5169,-.2347)*f0_12+\n    mat4(.6284,-.6653,.0243,-.0231,.5308,.5040,.2381,-.7042,-.1318,.8050,-.2069,-.1365,-.7061,-.0221,-.0697,-1.3195)*f0_13+\n    mat4(.0468,.1342,.3207,.4201,.3043,.2834,-.1257,-.2163,.5836,-.2771,-.2830,-.2682,-.9566,.6731,.3993,.8847)*f0_14+\n    mat4(-.6871,-.6262,.5056,-.8673,-.8050,-.8989,.3511,.4939,-1.5799,-.5811,.3924,.0728,-.5295,-.1210,-.1031,-.7041)*f0_15+\n    vec4(-28.1057,87.1687,-42.4783,119.7275))/1.0+0.*f0_7;\nvec4 f1_8=sin(mat4(-.5587,1.4501,1.0355,.2585,.3512,-.0542,.6707,.2117,.4412,.2690,-.7162,-.5720,.1537,-.6897,-.5193,.5634)*f0_0+\n    mat4(-.1074,.8375,.2750,-.0664,.0395,-1.8519,1.5715,-.1119,-.2515,-.7375,-.2435,-.3622,-.4393,.5386,1.3199,.3567)*f0_1+\n    mat4(-.0796,.8529,-.5045,-.3265,.3433,-.8026,-.0170,-.8627,-.2885,1.2054,-.3427,.7655,.0468,-.2698,-.4264,-.2250)*f0_2+\n    mat4(-.6789,1.0608,.8216,.1733,-.0023,.0196,-.2191,-.6453,-.2954,1.4093,.3834,.8758,-.4233,1.4102,.8700,.6808)*f0_3+\n    mat4(-.0778,-.1231,.2415,.6810,-.1062,-.7736,-.4491,-.5769,.0717,-.9525,-.3950,.2475,-.2256,-1.8154,-1.0378,-.8927)*f0_4+\n    mat4(-.2554,1.4218,.0899,.8387,-.0666,.6372,-.2571,.6367,.0529,1.4874,-.6392,.6431,.0422,-.8292,-.0369,-.3436)*f0_5+\n    mat4(.3936,-.0697,.5748,-.2522,.4725,.5264,-.0011,-.0638,.1765,1.0293,-.7904,.2393,-.3361,-1.6818,.4968,.6142)*f0_6+\n    mat4(-.0834,.8226,.8589,.1069,.4117,-.0590,-.7500,-.3387,-.5452,-.0089,1.0034,-.2461,.1233,-.2349,.0059,-.4320)*f0_7+\n    mat4(.2955,-.3407,-.3612,.9211,-.0577,1.3843,.2068,-.5104,.1619,-.0563,-.1618,.6169,.8651,.1152,-.3239,.2731)*f0_8+\n    mat4(.3203,-.7702,-1.3440,-.3471,-.1865,-.9197,.2944,-.0953,-.0586,.7491,-.3419,-.1992,.0820,.8312,.6467,-.2036)*f0_9+\n    mat4(.0515,.2761,1.6075,.3282,.2496,-.9545,.2383,.1417,.0804,.2547,-.7844,.1992,-.6148,.3441,-.0667,-.8312)*f0_10+\n    mat4(.5725,.6028,-.2240,-.6819,-.2269,.8037,.1944,.6655,-.0549,.9268,.4005,.5832,-.0585,.1822,-.4520,.2498)*f0_11+\n    mat4(.2839,-.1912,.1658,.6353,-.2345,1.5617,.2190,-1.6530,.0597,-.2571,-.2391,-.8820,.1547,-1.3217,.8057,-.0718)*f0_12+\n    mat4(-.6232,.3303,.7092,-.0502,.0887,-.0227,-.1297,.6672,.8208,-.2579,-.3528,-.0394,.7275,.7580,.4367,-.1836)*f0_13+\n    mat4(-.2378,1.1494,.8034,-.0547,-.4919,-.6060,-.7358,-.1353,-.3706,-1.4082,-.7882,.7181,-.5468,-.2667,.8899,.8978)*f0_14+\n    mat4(.4135,.7285,1.3007,-.1400,-.4991,1.6927,.9656,.9065,-.0542,1.7142,-.4463,-1.1860,.0593,.3752,-.0237,.9846)*f0_15+\n    vec4(100.9754,109.5918,55.8475,43.4287))/1.0+0.*f0_8;\nvec4 f1_9=sin(mat4(-.4100,1.0149,.4361,-.2621,-.8756,.0985,-.3735,.0575,-.1879,-.4983,-.6397,.1069,-.5494,1.6186,-.4890,-.3242)*f0_0+\n    mat4(-.9251,-.1640,-.8959,.2000,-.1130,.2905,-.4870,-.7155,-.8149,-.0706,-.0012,-.5744,.9164,.0043,.6349,.5696)*f0_1+\n    mat4(-.1172,.2054,.3782,-.1744,.8275,.5961,.1741,.2625,.4187,.8456,.0568,.4893,.2106,.9099,.4770,.2978)*f0_2+\n    mat4(-.0540,.2883,.8871,-.2062,-.1256,.6629,-.4299,.5084,-.1830,-.6075,.7531,.2437,.6076,.0577,.0562,.2468)*f0_3+\n    mat4(-1.0333,.3612,.1298,.1124,.0113,-.1639,.3004,-.9973,-1.5796,.7929,-.8371,.0638,.4700,.3816,.1184,.6612)*f0_4+\n    mat4(.4512,-1.0540,.7141,-.2527,.8290,.7864,-.3245,.4277,.2393,.5471,.4559,-.6861,.4213,.5621,-.2887,-.2709)*f0_5+\n    mat4(-.4229,.9965,-.5817,-.1235,.0034,-.6702,-.6815,-.2076,.5475,-.3064,-.7523,-.9557,-1.2755,-.3747,.6641,-.1823)*f0_6+\n    mat4(.8979,.0584,-.2420,-.1173,.4778,-1.2970,.1092,.5658,-.0624,-.5173,-.5519,.6358,.9712,-1.0260,-.2689,-.1821)*f0_7+\n    mat4(-.8083,-.5449,.7473,-.1464,.2313,.9238,-.3026,.1196,-.6088,.6439,.0616,-.4717,1.0256,-.7187,.4821,-.8154)*f0_8+\n    mat4(-.8581,-1.0326,.5816,-.0045,.3025,-.2993,-.1347,.0037,-.2183,-.3447,-.8774,.6788,.4006,-1.2362,1.1949,.1153)*f0_9+\n    mat4(1.1412,.0782,.0933,.2695,-.5201,.4672,-.4498,-.0118,-1.5222,.2892,.1270,-.3001,.6665,-.5504,-1.2297,-.1827)*f0_10+\n    mat4(1.1338,-.6409,-.4165,.0136,.7383,1.7062,-.1398,-1.1469,.7126,-.1079,-.0115,-.5580,-.4155,1.5307,1.2046,-.5696)*f0_11+\n    mat4(.3711,-1.1670,-1.2759,-.3122,1.0462,.6333,-.6196,-.5844,.2884,1.1234,-.4070,-.5199,-.7372,.0008,.8946,-.7825)*f0_12+\n    mat4(-.5467,-.6483,.5326,-.2286,.0153,.0797,-.4442,.1011,-.1221,-.6262,-.7293,.7286,-.8648,.6769,.6318,-.1481)*f0_13+\n    mat4(-1.2583,-.5095,.7014,.3756,.4824,-.4072,-.4574,.6522,.3382,.2300,-.3409,-.2328,.2594,-1.2188,.0725,.6966)*f0_14+\n    mat4(-1.3013,-.6180,-.4277,-.2986,-1.2127,.8213,-.4304,.4418,-.2144,1.6276,-.5281,.4840,.8984,.1305,-.4531,-.1407)*f0_15+\n    vec4(49.6401,21.7196,106.9850,-112.7500))/1.0+0.*f0_9;\nvec4 f1_10=sin(mat4(-.4256,-.1360,-.7700,-.7483,-.5898,-.3912,.2316,.3234,-1.2630,-.4057,-.2438,.6515,1.1215,.4455,.7266,-.9138)*f0_0+\n    mat4(.1875,.8107,-.6296,-.6425,-.4165,-.1075,.8156,-.0092,.2349,.8754,-.6269,-.5318,-.5621,.9059,.7855,.5670)*f0_1+\n    mat4(.3083,.8182,.3502,.0637,-.5524,.0508,-.3903,-.9083,.3881,-.2490,-1.6390,-1.1165,-.2623,-.0558,-.2560,.5960)*f0_2+\n    mat4(-.7043,-.0858,-.4378,-1.1650,-.1243,-.6474,.9767,-.3168,.3651,-.3536,.3762,-.6100,-.4569,-.6243,-.0361,-.2767)*f0_3+\n    mat4(-.4404,.2956,.6553,-.4380,.2553,.1050,-.0539,-.1189,.4152,.2843,.4835,.1088,.3337,.0184,-.1854,-.3612)*f0_4+\n    mat4(-.6251,-.2090,-.9030,.4956,-1.3391,-.0280,.4037,-.2100,.9024,.2157,-.6092,-.6805,.2892,-.0264,.4656,-.6307)*f0_5+\n    mat4(.7395,-.2257,.7402,-.5589,.4343,.0124,-.8368,.3736,.1744,.4885,.1587,1.6897,.6643,-.4500,.1920,.1001)*f0_6+\n    mat4(.4142,-.0153,-.1262,.5136,.0975,-.2084,.2573,.3876,-1.1317,-.3525,.6741,1.7290,-.3756,.3159,.9203,1.5362)*f0_7+\n    mat4(-.2165,.4414,-.3707,.4525,-.1144,.6803,-.8193,.6971,-.6218,.6593,-1.2012,-.1194,-.3130,-.2729,-.5169,.1463)*f0_8+\n    mat4(.6069,.1653,-.1374,.0161,.1021,.5747,.6632,-.3847,1.2295,1.3415,.1715,.3348,-.1888,.8897,-.5274,.3117)*f0_9+\n    mat4(-.1021,.9536,.6239,.3703,-.3740,.1180,-.4230,-.0840,.5246,-.1527,.6409,-.5768,.3158,.2254,.8541,-.1235)*f0_10+\n    mat4(-.1761,-.1145,-.4220,-.3671,-.1405,-.4439,.1052,-.3613,-1.1042,.1596,-.3912,1.3738,.6869,-.0722,.2028,-.4700)*f0_11+\n    mat4(-.5761,-.1154,.7309,.6872,-.5263,-.2016,-.6218,.5233,.5140,-.2469,.0979,-.3403,.4705,-.4497,1.1940,-.4513)*f0_12+\n    mat4(-.3208,-.4857,-.8403,-.6392,-.9586,.0948,.2202,-.2549,-.0520,.5986,.1606,-.0637,-.2268,.7728,1.3528,.3438)*f0_13+\n    mat4(.9437,.1906,1.3783,-.1363,.3427,-.0552,.3035,.9460,-.9565,.9507,.2078,-.5185,.2318,-.5897,.7124,-.0231)*f0_14+\n    mat4(.7537,-.4646,-.4826,.6784,.0120,-.2329,-1.1354,.0271,-.7815,.2544,.8533,1.2429,-.6251,.7301,-.5586,-.2308)*f0_15+\n    vec4(109.4877,116.9410,-38.1665,85.4134))/1.0+0.*f0_10;\nvec4 f1_11=sin(mat4(-.1022,.1867,.3430,.4561,1.2429,-.3268,-1.0138,-.6681,-1.1704,.2218,.8167,.6171,-.1030,.2916,-.0470,-.0091)*f0_0+\n    mat4(.3398,-.1853,-.3696,-.4653,-.7326,.1606,-.4427,.9393,-1.0666,.3244,.8606,-.2602,.8584,-.3985,-.7235,-.8037)*f0_1+\n    mat4(-.2182,.0738,.9528,.4519,.8880,.8485,-.4911,.1595,-.1774,-.3335,.0954,.1318,-.4030,.1486,-.3933,.5698)*f0_2+\n    mat4(-.2893,.0414,.9473,-.5036,.3164,.2919,1.4033,.4238,.5899,.0078,-.6246,.4429,-.8743,.3368,.8788,.3957)*f0_3+\n    mat4(.9825,-.4503,-1.3473,.2619,-.3503,.5865,-.0837,-.3170,.5687,-.0193,-.6239,.2500,-.0443,.3565,.6611,-.3980)*f0_4+\n    mat4(-.5940,.1908,.2091,1.2145,.0849,.4494,.2812,-.5634,.5555,.5174,-.7733,-.4658,-.6181,-.1093,-.7760,-.8062)*f0_5+\n    mat4(.7222,.2858,-.8056,.0012,.4585,.2243,1.1461,.6974,.8778,.2136,.6710,.2603,.0864,.5203,-1.3141,.6159)*f0_6+\n    mat4(-.5682,.7177,-.5722,-.1082,1.3242,-.4914,.5137,-.0377,1.2202,-.3261,-.0991,-.6162,-.6499,-.7179,-.7596,.8971)*f0_7+\n    mat4(-.7093,-.1821,-.8214,.2925,.5183,-.1497,-.6031,.2034,-.4580,-.2426,-.4501,-.3889,-.6237,.3807,-.7522,.2235)*f0_8+\n    mat4(.8634,.4686,.1712,-.7097,-.6780,-.3695,-.0307,-.9680,1.1228,.2062,.1579,-.9000,-.7936,.5761,-.1433,.4794)*f0_9+\n    mat4(.5903,.1651,-.4845,.0482,-.3997,.3247,-.9186,.1511,-1.1584,.2505,.3546,-.2935,-1.1066,-.5958,-1.4012,-.8043)*f0_10+\n    mat4(.1364,-.0291,-.5568,-.4028,-1.2861,-.4973,.8318,.4546,-.0343,-.1932,-1.1256,.0826,.8807,-.3748,-.4688,-.2711)*f0_11+\n    mat4(.9675,.1664,.9085,.0323,-.5908,-.3826,.4106,.3277,.6444,-.3963,-.1602,-.0296,.0365,.1003,-.9140,-.6091)*f0_12+\n    mat4(-1.5966,.8906,-1.0421,-.3727,-.7833,.3701,1.3632,.1401,-1.3031,-.2678,.7775,.6468,.7135,-.0258,-.0825,-.5392)*f0_13+\n    mat4(.2090,-.3003,-.4948,-.3082,-1.0822,-.0871,1.0679,-.2349,-.3806,-.2995,1.2604,-.1903,.1553,.7306,-.3041,.7041)*f0_14+\n    mat4(-.3382,-.3709,-.5091,-.1059,-.0673,.3514,-.1046,-.2857,.3260,-.5434,-.6468,.4053,-.6345,.4042,-.1863,.1637)*f0_15+\n    vec4(-88.5372,9.4009,-64.9947,2.0681))/1.0+0.*f0_11;\nvec4 f1_12=sin(mat4(.0889,-1.0013,-.0235,-.1927,-.3661,-.0209,-.3425,-.4868,-.3532,-.5527,-.2912,.7524,.0098,.6490,.4461,1.2373)*f0_0+\n    mat4(-.3344,-.1156,.5127,-.3738,.3124,-.0876,-.7668,.9253,.2689,.4913,-.1870,.4873,.1100,.2741,.6301,-.5706)*f0_1+\n    mat4(1.5036,-.9788,.7333,.4678,.2888,.4093,.4958,-.7211,.1047,.0018,.5170,.5355,-.5102,.3113,-.1108,-.3821)*f0_2+\n    mat4(-.5269,1.2731,.2331,.4499,-.0413,-.4030,.0239,-.5574,-.1103,.2215,.1838,-.6629,-.5748,-.4694,.6507,-.0962)*f0_3+\n    mat4(.0267,-.0457,-.1740,-.8061,.1793,-.0800,-.8377,.1571,-.5109,1.0710,.7706,.1917,.2647,.5126,.0782,1.0012)*f0_4+\n    mat4(-.4321,-.2623,.6641,-.4288,-.1751,-.6405,-.4111,.2461,-.4762,.4976,-.0722,-.6310,-.0443,.7803,.6849,-.9917)*f0_5+\n    mat4(1.0458,.4608,-.1033,-.0012,-.1796,.0763,-.1981,.6616,.3746,-.4128,-.3282,.5362,-.4955,-.4512,.3755,-1.1700)*f0_6+\n    mat4(-.0179,.7798,-.4331,.8260,-.0782,-.8281,.2390,-1.5135,-.3104,-1.0140,.9515,-.6252,.4862,.3209,.5397,.3185)*f0_7+\n    mat4(.0788,-.8134,-.4283,-.3800,.0972,.5895,.4554,.7597,.0492,.2157,.2773,.7951,.1663,-.4915,-.7139,.1465)*f0_8+\n    mat4(.0005,-.1545,-.6351,.6062,-.5271,-.1818,-.3629,.6020,.0174,.3029,-.0461,-.3053,.2946,-.1897,-.5015,.3575)*f0_9+\n    mat4(-.2975,-.0157,.2904,.2588,.1779,.7509,-.6402,.2599,.8298,-.1292,-.1709,.1428,.4998,.7462,.0466,-.7124)*f0_10+\n    mat4(.8171,-.1733,1.2411,.1695,-.2769,-1.3147,.5569,-.6906,-.7192,-.7328,-.4483,.2692,-.2599,.8436,-.0017,.3565)*f0_11+\n    mat4(-.3624,-.2966,.0222,-.8291,-.2557,-.0168,-.6216,.6560,-.5443,.7994,.3275,.5762,-.2136,-.1943,.8071,.0538)*f0_12+\n    mat4(-.2748,.9159,-.5236,-.2764,.0460,-.1167,-.6905,-1.3027,-.2949,-.2991,-.1212,-.3701,-.0489,.6664,-.1046,.9924)*f0_13+\n    mat4(.0207,-.3984,.5693,-.1470,-.1995,.6313,-.4946,-.8700,-.8011,.6921,.4528,.4608,.1374,-.6373,1.0271,-.1805)*f0_14+\n    mat4(.1323,-.3872,.2240,.6529,-.5124,.7581,-.0325,.0480,-.5966,.3199,-1.0126,-.9681,-.6636,-.4776,.3124,-.9494)*f0_15+\n    vec4(-37.7820,30.9132,-113.7312,-109.7336))/1.0+0.*f0_12;\nvec4 f1_13=sin(mat4(.0243,-.1688,.4130,.9430,.3683,-.0764,.6502,-1.1977,.0130,-.3297,-.1971,.9399,-.2582,-.2300,.3746,-.5670)*f0_0+\n    mat4(.0282,-.8303,-.3386,.0640,-.3531,.3436,.2096,-.4297,.0580,.8641,-.4421,-.0905,.0348,-.3828,.0187,.2364)*f0_1+\n    mat4(-1.2801,-.0017,-.9719,.3249,-.8831,.4914,-.9430,-.2932,-.3852,-.0552,-.3380,-.5651,.8250,.2154,-.4969,.1518)*f0_2+\n    mat4(.7771,.1864,-.1805,-1.4624,-.0532,.3170,-.5086,-.5317,-.7335,-.0031,.1478,-.7760,.4362,.0157,.3689,.7188)*f0_3+\n    mat4(-.5929,.2957,-.2017,.3746,-.3835,.6584,-.3993,.1365,-.0371,-.3116,.5095,.6583,-.5118,.0317,.4613,.5853)*f0_4+\n    mat4(-.0498,-.0013,-.2454,-.9020,.3414,-.1695,-.6905,-.1574,-.2967,.3180,.1140,-.5700,-.4273,-.1611,-.2263,.9767)*f0_5+\n    mat4(.5049,.0687,-.2512,.0627,-.1324,-.3118,.4145,.6035,.4526,.3764,-.1102,.6069,.5300,.6509,.2880,-.2129)*f0_6+\n    mat4(.1553,.3857,.5259,-.5839,1.2298,-.5219,.1054,.6263,.9473,-.8758,.4316,1.2086,.1501,.0236,-.1525,-.2780)*f0_7+\n    mat4(-.8548,-.6595,.2990,.2715,.2488,.8834,-.0723,-.9969,-.2918,-.4273,-.2454,.2157,.9610,.0105,-.0863,1.4773)*f0_8+\n    mat4(.1356,.4353,.1904,-.1757,.1269,.2932,.7965,.3658,.2357,.4627,.2406,-.7314,-.4069,.1225,.6423,-1.2593)*f0_9+\n    mat4(.0493,-.6558,.3674,.0101,-.5500,-.0539,-.1485,.9930,.4755,-.3960,.0506,-.1256,-.5408,-.3489,-.2031,-.4714)*f0_10+\n    mat4(1.2417,-.9797,.4953,-.7301,-.9623,-.3091,-.7208,.7567,-1.8664,.4624,.2087,-.3719,.0134,-.8422,.1840,.1192)*f0_11+\n    mat4(.4914,.1478,-.0153,.3350,-.2291,-.7048,.7831,.2256,.4477,-.1151,-1.0345,.4574,-.2489,-.1178,-1.1835,1.0862)*f0_12+\n    mat4(-.6550,-.5204,-.6514,1.2183,-.2742,-.6138,.7711,-.1552,.4150,-.0259,.5514,-.4392,.6008,.4694,-.0135,-.1068)*f0_13+\n    mat4(.1975,-.2659,-.3950,1.0907,.4264,.4706,-.0296,.8073,1.2196,-.7558,.2072,.8360,.9276,-.4049,-.4842,-.8045)*f0_14+\n    mat4(-.3686,-.2446,.2510,-.5196,.9084,.2539,-.2609,-.2407,.0561,.4455,.0855,-1.1484,.7451,-.4362,-.1824,-.6478)*f0_15+\n    vec4(-15.1838,-119.1111,22.8247,-28.9723))/1.0+0.*f0_13;\nvec4 f1_14=sin(mat4(.5782,-.3078,-.3510,.6702,-.6523,-.5744,-.1913,.3580,-.3996,.6283,.1071,.0763,-.5122,.1582,-.2759,.5394)*f0_0+\n    mat4(.8430,-1.6285,-.1025,-.4416,-.4099,.7326,.0099,.7823,.1497,-.6940,-.0905,-.6195,-.1165,-.0128,.0016,.0349)*f0_1+\n    mat4(.4885,-.7548,-.3222,.4684,-.0798,.5119,-.0496,-.5285,.1056,.6820,-.2286,.5387,-.5106,-.2509,.4177,.4705)*f0_2+\n    mat4(.1888,-.3511,.4995,-.0692,.5094,-.8152,.0735,.7276,.6637,-.3534,.0815,-.5001,.6116,-.4832,-.0357,1.2135)*f0_3+\n    mat4(-.1435,-.3935,-.2221,.9700,.0652,.8690,-.5340,-1.4766,-.6417,.5872,.2750,.9297,-.7525,-.4376,.3633,.0760)*f0_4+\n    mat4(.4676,.7870,.2059,.4802,-.5784,1.2285,-.2419,-.5560,-.1106,.0265,.0531,.6666,.4742,-.8754,.0011,-.8338)*f0_5+\n    mat4(.3823,.1351,-.5100,.3962,-.0275,-.6194,.2588,.6659,-.3207,-.2607,.1176,.4630,-.1132,.7122,-.1132,-.8449)*f0_6+\n    mat4(-.3847,.4982,-.2680,-.6710,.1983,.6952,.0191,.7369,.3175,1.4125,.1440,-.4585,.9559,-.4978,.4703,-.2005)*f0_7+\n    mat4(.0457,-.0205,.4027,.2923,.0732,.3508,-.1866,-.2207,.0817,-.4296,-.3059,.4127,-.0572,-.4174,.3141,.0352)*f0_8+\n    mat4(-.2013,.6059,-.3804,.4740,-.7820,.0675,.0888,.5321,1.0878,-.2123,-.3797,-1.8706,.1765,1.1318,.1594,.2702)*f0_9+\n    mat4(-.4450,-.4163,-.4039,-.8601,-.2052,.3482,-.1913,-.4903,-.1741,.0596,-.3060,.2733,-.2170,1.5027,.0116,-.2378)*f0_10+\n    mat4(.0185,-.2546,-.1480,.8632,.1920,-1.0580,.3383,-.6669,.4230,1.1079,.1405,-.0128,.2483,-.4395,-.3057,-.1169)*f0_11+\n    mat4(.0763,-.2679,-.3383,-.0755,.2104,-.2132,-.0248,-.2280,-.9272,.4205,.4389,-.3899,-.6144,-.6881,-.2964,-.5438)*f0_12+\n    mat4(.1063,-.1214,.3798,1.4401,-.0645,.0491,-.0309,-.5886,.1368,.1822,-.0859,-.5243,.0107,-.8553,.1964,-.3353)*f0_13+\n    mat4(-.9784,.6166,-.1441,-.5831,.2493,-.4085,-.0170,-.8303,-.4214,.5221,.1099,.3150,.3697,.0992,-.1229,.1761)*f0_14+\n    mat4(.3901,-.4806,-.1012,.0182,-1.1512,.4621,-.0399,.5427,.1862,-.8509,-.4284,-.6517,.3267,.5189,.4286,-.2343)*f0_15+\n    vec4(-107.5038,3.2266,-109.2395,-47.4674))/1.0+0.*f0_14;\nvec4 f1_15=sin(mat4(.2034,.3713,-.9588,.7612,.6767,.1719,-1.8000,-.1779,-.2166,-.5489,-1.0405,.2518,-.7236,-.4192,-.0792,-.9210)*f0_0+\n    mat4(.0464,.3612,-.3406,.3747,-.6267,-.4794,.8575,-.0175,.5389,-.7832,1.6116,1.1383,-.5958,-1.1350,.3196,.6941)*f0_1+\n    mat4(-.0403,.2642,.1840,1.0373,-.3661,-.4497,.7767,-.2364,.1143,.3332,-.3153,-.3789,.6130,.7527,.4634,-.1542)*f0_2+\n    mat4(-.2113,.8109,.2573,.2738,.3959,-.1163,.8473,-.0747,-.4138,.0172,-1.8515,-1.2227,.2082,-.3713,.1766,-.7011)*f0_3+\n    mat4(.2365,-1.2106,-.9699,-1.0009,.4406,-.1580,.0250,-.9750,.1346,-.0566,1.4813,1.0546,.0007,.9388,-.8184,.0642)*f0_4+\n    mat4(.9675,.0006,.5086,.9190,-.9830,.0803,-.1769,-.6067,.5988,-.7653,-.3007,-.6159,.0363,.5169,.7323,-.8201)*f0_5+\n    mat4(-.4440,-.6632,.7853,1.0071,-.9415,-.2509,-.0438,.1928,-.1166,1.1306,-.3738,-.0639,.6677,.3627,.3894,.8137)*f0_6+\n    mat4(.3727,.0153,-.6344,.0378,.1328,-.2276,-1.0343,1.2258,-.0086,.1907,-1.5971,-.3840,.5745,.4394,.4544,.6182)*f0_7+\n    mat4(.8519,.8481,.0691,-.8210,.3902,-.5102,-.2228,.5088,.1921,1.0001,-.1958,.2090,.1036,-.1643,-.1451,.0081)*f0_8+\n    mat4(.1215,-.5663,.5919,.4720,.9912,-1.1358,.1887,-.3399,-.5076,-.7490,-.9516,.7666,-.5433,-1.0124,-.6928,-.2456)*f0_9+\n    mat4(-.4877,-.2733,.2314,.3469,.2753,.0455,1.2989,.5723,.4903,-.4972,.1258,-.8702,-.7811,-.7895,.8972,1.2938)*f0_10+\n    mat4(-.2308,-.3425,.7924,-.0390,.4476,-.3077,-.4636,-.4859,.5350,-.2862,.5153,-.6059,.9599,1.3926,-.0346,-.4096)*f0_11+\n    mat4(-.5782,-.4635,-.5749,.5676,-.4022,-.4678,-.2857,.8294,-.4244,-.7541,1.6430,.1304,-.0294,-.3423,-.4674,.9090)*f0_12+\n    mat4(-.5820,-.3067,-.7939,-.6252,.7779,.1176,-.9111,.0080,.3067,.6889,-.0930,.5771,-.5591,-.1642,-1.1804,.6700)*f0_13+\n    mat4(.3825,.3140,.2409,.0530,1.0211,.6228,-1.1802,1.5904,-.2322,-.4457,-.1827,-.4663,-.3072,-1.0292,.7161,-.3397)*f0_14+\n    mat4(.9944,.3421,-.3275,-.7246,1.1529,-1.4620,-.0214,.4671,.5232,-.2116,-.8070,1.1670,.4921,.1899,-.6017,-.6681)*f0_15+\n    vec4(43.7814,-53.0218,47.5794,-71.4783))/1.0+0.*f0_15;\nvec4 f2_0=sin(mat4(-.1807,.7132,-.0498,.5097,.4050,.0475,.3823,-.6169,.4022,-.3765,.6672,-.4560,.2761,-.4610,.0299,-.0470)*f1_0+\n    mat4(.1491,-.4294,.0264,-.3114,.3895,.1894,-.0301,-.2633,-.0448,.1562,-.5771,.3078,-.1098,.1823,-.8608,.0369)*f1_1+\n    mat4(.0682,-.5198,.3932,-.0359,.3036,-.4488,-.2436,-.1361,.0588,-.7796,.8686,-.3175,.3236,-.2183,.8956,.1524)*f1_2+\n    mat4(-.2178,.2994,.2582,.2435,-.1156,.6613,-.5677,.1134,-.2693,-.2673,-.2643,-.5567,.2793,.0652,1.0756,-.0691)*f1_3+\n    mat4(.3705,-.2450,-.0621,.0445,-.1054,-.2307,.1887,-.1826,-.3145,-.0196,.8125,-.2339,-.1330,-.7868,.4561,-.3222)*f1_4+\n    mat4(.2962,-.5808,.3048,-.2003,.1513,.0974,.1096,.3102,-.5462,.2812,-.1982,-.1028,.1439,.5225,.1498,.6553)*f1_5+\n    mat4(.7188,-.2733,.5095,-.6654,-.2416,.7914,.3423,.0574,-.7778,.2595,-1.6298,.3173,-.9549,1.0308,-.0775,.0665)*f1_6+\n    mat4(.3292,-.5400,-.2325,-.4730,-.1316,-.2877,-.4537,.3970,-.5459,.3491,.2819,.2631,-.4542,.2718,-.0630,.3094)*f1_7+\n    mat4(-.3662,.1483,-.4251,.4479,.0578,-.3994,.2488,-.2837,-.6339,.4037,-.4204,.2041,-.2101,.0730,.8852,.2181)*f1_8+\n    mat4(.0741,-.4892,.8946,-.2916,.2370,-.0507,.2719,-.1680,.1120,.1785,.0126,.1832,-.2037,.0373,.4258,-.4929)*f1_9+\n    mat4(-.1682,.6334,-.5681,.5401,.2650,.4082,.6636,-.6139,.2369,-.7448,-.1508,.1517,.3310,.1316,.5445,-.2813)*f1_10+\n    mat4(.3927,-.0771,-.1583,-.3612,-.3176,-.1498,-.3108,.6967,.4179,-.0277,-.0308,-.8587,-.2667,.1816,-.0265,.1407)*f1_11+\n    mat4(.5015,-.0382,.6774,-.1952,.6257,-.2779,.5582,-.1051,.2384,-.0553,.1622,-.1219,-.1481,.1678,-.3391,-.0374)*f1_12+\n    mat4(.0657,-.0459,-.3726,.3067,-.6088,.0259,-1.0340,.4528,-.1081,-.6221,.3366,-.1868,-.0248,.2687,-.1452,-.1404)*f1_13+\n    mat4(.3660,-.5051,.2304,-.1925,-.2499,.3168,.8472,-.1157,-.1058,-.0639,.6436,-.2757,-.0961,.0348,-.7730,.5210)*f1_14+\n    mat4(.4300,-.2951,.4616,-.4236,-.2228,.1921,.2203,.0246,.3126,-.7163,.1934,-.2188,.5486,-.2168,.7760,-.4613)*f1_15+\n    vec4(-6.8301,19.9986,-84.3803,38.7021))/1.4+0.*f1_0;\nvec4 f2_1=sin(mat4(.0252,.1705,.3778,-.4936,.3838,.0506,-.6186,.6724,.2703,-.3433,-.1804,.2484,.0446,-.3527,-.1466,.5056)*f1_0+\n    mat4(-.1626,-.1873,.2616,-.1877,.0234,-.5214,-.2657,.5084,-.5567,.5571,.2304,-.3507,.0282,.4547,-.0855,-.0868)*f1_1+\n    mat4(-.0365,-.0886,.1691,.2441,-.4013,-.2841,-.4802,-.0245,1.3522,-1.1961,-.1867,.0663,-.0332,.0206,-.0499,.5882)*f1_2+\n    mat4(-1.6019,-.0834,.1672,-.4789,.1934,.5211,-.2576,-.6266,-.3092,-.2122,.0887,.1031,.9632,-.4353,-.7086,.2205)*f1_3+\n    mat4(.3952,-.4320,.4701,.6986,-.3473,.7129,.0303,-.0232,-.1595,-.0734,.2132,.4697,.7747,-1.1901,.6479,.0696)*f1_4+\n    mat4(-.7872,.1053,-.0366,.3771,-.0658,.0484,.7247,.3510,.2048,-.4431,.7158,-.4247,-.4114,.6229,-.0050,-.4486)*f1_5+\n    mat4(.1228,-.4218,.2156,.6328,-.6565,.2100,-.1909,.3532,-.3913,-1.2928,.8841,-1.3713,-.6388,-.5276,.3092,-.6247)*f1_6+\n    mat4(-.1796,.3070,.3679,.6088,.2616,.6620,.3443,.1871,.3878,.3492,.3046,-.2723,-.0161,-.0381,-.0716,.0196)*f1_7+\n    mat4(-.6899,.3579,.5682,-1.4483,.4432,.3694,-.1286,.8509,-.1359,.3966,.3399,-.8949,.3911,.4631,.6130,.8207)*f1_8+\n    mat4(.5911,-.1084,-.3374,.4980,-.0430,-.4599,-.5323,-.1199,-.4792,.5989,-.0722,-.2110,.5741,-.5222,-.9955,-.1888)*f1_9+\n    mat4(-.2349,.7353,-.7849,.0545,.5208,.3774,.6102,.5588,-.0705,-.3612,-.4231,.1821,-.3332,.0939,-.7148,.5232)*f1_10+\n    mat4(.3976,-.4467,-.5486,.1528,.0775,-.3098,.3185,-.0221,.3972,-.0947,-.4078,.2359,-.3939,.1880,.8265,.2079)*f1_11+\n    mat4(.4171,-.4972,-.6119,.4679,.3315,-.4769,-.7950,.3772,.2145,-.1099,-.4135,.2017,-.1571,.2120,-.2734,.0122)*f1_12+\n    mat4(.7010,.0845,.1374,.3302,-.4633,.2640,-.2328,.1692,.4271,-.4332,.0648,.7742,-.3232,.4009,-.0400,.2186)*f1_13+\n    mat4(-.3576,-.6900,.3155,-.9636,.0097,.0773,.5348,.3499,.3695,-.5364,-.4702,-.4358,-.0315,.4703,.2211,-.4998)*f1_14+\n    mat4(.3195,.4120,-.6409,.6157,.2874,.6550,.3912,.0366,.1949,-.2216,-.2767,.8978,-.0689,-.1308,-.3729,-.1313)*f1_15+\n    vec4(-97.5454,-57.8203,91.3405,-97.2657))/1.4+0.*f1_1;\nvec4 f2_2=sin(mat4(-.3194,-.2455,.2965,1.1778,-.1606,.5068,-1.2769,-.4991,-.8073,.6542,-.4279,-.3269,-.5770,.1973,.5088,-.6932)*f1_0+\n    mat4(-.0743,.5018,-.8484,-.2746,-.4003,.4772,-.8701,-.6233,.3459,.4925,.7644,.4546,.1178,.6297,-1.2294,-.0658)*f1_1+\n    mat4(-.2138,.2575,.5172,-.2926,.1436,-.1254,-.1542,.1494,-.4882,.0903,-.1029,-.5539,-.6732,.2970,.3268,-.7820)*f1_2+\n    mat4(.4865,1.0657,.6394,-.1011,.8566,.0770,-.4025,1.3432,-.0411,-.0470,.0961,-.4374,-.3168,.0557,.9132,-.1824)*f1_3+\n    mat4(-.0298,-.1603,.0205,-.2785,.5170,-.5292,.0764,.6233,.1222,.6012,-.7666,-.5970,-.5830,.0011,-.8794,-.4638)*f1_4+\n    mat4(.1285,-.3500,-.3198,-.4841,-.0980,.2127,.2588,-.0262,-.1580,.0297,-.0716,-.2393,-.1756,-.2219,-.3753,.0892)*f1_5+\n    mat4(-.1064,.2208,.7676,-1.0378,.6811,-.5246,.9531,.3207,.3251,-.5329,-1.7159,-.1642,.4621,-.6202,1.1447,.1395)*f1_6+\n    mat4(-.5143,1.1834,-.6699,.4411,.6476,-.6602,-.5724,-.4222,.0133,-.7818,.2885,.2237,-.5412,-.2558,.5324,-.2462)*f1_7+\n    mat4(.7302,-.7021,.5290,-.1667,.2304,-.5821,-.9616,-.7081,.4537,-.8685,-.6966,-.6240,.0543,-.3702,.5742,.5778)*f1_8+\n    mat4(-.2478,-.0129,.0018,.2928,.1858,.0369,-1.5408,-.6636,.2847,-.4004,-1.0181,-.2848,-.6520,-.0803,-1.0219,-.2382)*f1_9+\n    mat4(-.1490,-.1274,.6827,-.4484,-.5823,-.1812,-1.6279,-.6709,-.2785,.1629,.1546,-.3320,.0199,.2307,-1.2293,-.1590)*f1_10+\n    mat4(-.2492,.3606,-.4771,.3640,-.2393,-.8963,.5625,.4161,-.3897,-.2383,-.3959,-.1797,-.0029,-.7315,.9352,.3613)*f1_11+\n    mat4(-.1621,.3916,-.3603,.3191,-.2520,.4542,.1409,-.4924,.1702,.9035,-.4207,.1452,.4998,.2525,.3921,-.3534)*f1_12+\n    mat4(-.3480,-.6883,1.1390,.3037,.2506,-.5745,.2329,.2572,-.0029,.2999,-.3701,.4044,-.0621,-.0702,-.8015,.5244)*f1_13+\n    mat4(.6052,.0121,-1.6856,-.7532,-.0350,.0593,.1444,.8154,-.1817,1.1686,-.4252,-.3174,.2972,-.0854,.6527,-.1063)*f1_14+\n    mat4(-.5528,.5838,.3628,.2292,.1928,.3788,1.0050,.2358,-.8046,-.3629,-.2712,.3489,.0424,.5361,-1.1026,-.4789)*f1_15+\n    vec4(7.0565,-91.9671,-30.6587,-57.8044))/1.4+0.*f1_2;\nvec4 f2_3=sin(mat4(.3069,.1135,.0316,.5017,-.4764,-.3468,.0532,.5882,.0044,-.3627,.0337,.3725,.3375,-.8095,-.0818,1.2081)*f1_0+\n    mat4(-.2760,-.2326,.1283,-.3058,.2266,.2337,-.7470,.0560,.2508,.6969,.5708,-1.1359,.7428,.0259,-.0251,.0782)*f1_1+\n    mat4(-.0967,-.2970,-.2846,.3371,-.1497,.4419,-.0138,.4549,-.2513,.3915,.0692,.0923,-.6582,-.0386,-.7226,.1394)*f1_2+\n    mat4(.4344,-.4915,.6966,-.6801,-.1805,-.1726,.8464,-.0392,-.0216,-.8659,-.1612,.4172,-.0387,.6640,.3791,.0003)*f1_3+\n    mat4(-.3536,-.5601,.4213,-.1150,.3224,-.1396,.7542,.3051,.2439,-.3298,-.5806,.6681,-.2464,-.0666,-1.0478,.9167)*f1_4+\n    mat4(-.4467,-.1556,-.3126,-.1178,.8063,-.0032,.0601,-.5793,.3037,.3524,.1759,.2949,.5267,.8257,.3589,-.3449)*f1_5+\n    mat4(-.5165,-.0977,-.1434,1.0633,.1064,.6787,.1656,-.5058,.2515,-.2368,-.5365,.8777,.4957,.0229,.9253,-1.0416)*f1_6+\n    mat4(.3959,-.4609,.2662,.4761,-.1314,.4979,-.1167,-.1389,-.4027,-.8310,.3249,-.1248,.1942,.4930,-1.0144,-.0411)*f1_7+\n    mat4(.2124,.3734,-.1905,.2997,-.4355,-.0985,.1325,.5559,-.0410,.3383,.0411,.1113,-.7156,-.0525,.0933,.3297)*f1_8+\n    mat4(.1006,-.6758,.0766,.3680,.3015,.2831,-.5001,-.0276,.4833,.6993,.1654,.3478,-.5073,.3412,-.6786,-.4030)*f1_9+\n    mat4(-.0454,.0366,.1134,-.2154,-.4289,-.8446,-.4452,.4486,-.2728,-.4934,-.9591,-.2699,.2313,-.6124,.1360,-.1794)*f1_10+\n    mat4(.4640,-1.2417,-.1255,.7747,-.0761,.3321,.9159,-.8854,-.2685,-.3947,.2813,-.0291,.9060,.8645,-.0624,-.2619)*f1_11+\n    mat4(-.4246,-.8518,-.3443,1.0417,-.4517,.2088,.0374,.1404,-.2670,.4658,.2405,.5365,.3729,-.1707,.3115,-.1796)*f1_12+\n    mat4(-.2952,.2085,-.5859,.3902,.4299,.3970,.4982,-.5760,-.4348,-.6651,.6984,.3859,.5168,.0054,.8039,-.1039)*f1_13+\n    mat4(-.4511,.1441,-.7207,-.3626,.5557,.0456,-.5336,-1.1290,.0882,.9200,-.3620,-.4991,-.0899,.3169,.2924,.4153)*f1_14+\n    mat4(-.0506,-.5203,.4089,.1795,-.2278,.3560,.9635,-.1056,-.1330,-.2329,-.1172,-.4286,-.6442,-.7017,-.3008,.0114)*f1_15+\n    vec4(7.1256,-76.6237,-108.0238,73.1916))/1.4+0.*f1_3;\nvec4 f2_4=sin(mat4(.4468,-.2175,.5015,.4943,-.0475,.2806,.0816,.2753,.0645,.3366,-.4451,-.0767,.2462,.1564,.0681,.1406)*f1_0+\n    mat4(-.5512,.2094,-.6325,-.5887,.5650,-.8303,.1409,-.5495,.0200,.2638,.3721,.1413,-.7016,-.3941,-.2345,-.5915)*f1_1+\n    mat4(-.2412,-.2706,-.0864,-.0790,-.6664,-.4551,-.3543,.2679,-.6266,-.3718,-.5593,.0457,-.5132,-.0017,-.4458,.2904)*f1_2+\n    mat4(1.0051,-.5949,.6739,.1869,.1268,.6874,.4893,.3778,.1609,-.6818,.1900,-.2382,-.7363,.0605,-.8500,-.5862)*f1_3+\n    mat4(-.2763,-.4749,-.0395,-.3208,-.0187,.1770,.4224,1.0368,-.3557,-.1678,-.3781,-.2988,.1401,.4445,.4233,-.0405)*f1_4+\n    mat4(-.3566,-.6817,-.3041,-.5350,.6676,-.1495,.5112,.2734,.9343,-.5813,.3417,.4154,-.0463,-1.0320,.3039,-.4942)*f1_5+\n    mat4(-.2842,.2723,-.4903,.1739,.5817,.9663,-.1757,.4148,2.3304,.3899,.6700,.5729,.6470,.0976,.5286,.7400)*f1_6+\n    mat4(.2142,-1.0761,-.1211,-.3846,.4361,-.4350,.2072,.2845,.0651,.0062,.3376,.6533,.4255,-.0598,.4014,.5131)*f1_7+\n    mat4(.1078,-.7688,.7593,.2678,-.5571,-.1180,.1549,-.0658,.2287,.4756,.3764,.1046,-.2951,1.0499,-.2148,-.1301)*f1_8+\n    mat4(.1212,-.0327,-.3117,-.0291,-.2651,-.1192,-.4657,-.3067,-.0452,.1999,-.3263,.8798,-.0044,-.6200,-.1000,-.6519)*f1_9+\n    mat4(.1208,.3743,-.2199,.6873,-.1369,.2889,-.1996,.2635,-.1190,-.4460,-.4150,-.2562,-.4858,-.5586,-.2936,.0601)*f1_10+\n    mat4(-.3405,.0244,-.1471,.4186,.0342,.6664,-.1186,-.2102,-.1062,-.3719,-.8897,-.5948,.2748,.5607,.2093,.4616)*f1_11+\n    mat4(.2792,-1.0983,-.2556,-.1862,-.5170,-.3759,-.0013,-.4744,-.1322,.0205,-.3103,-.2520,-.1894,.1479,.1558,.6299)*f1_12+\n    mat4(-.3398,-.5367,-.6214,-.7855,.8032,-.1307,.3815,.5673,-.4007,-.3269,-1.0524,-.5717,.8437,-.0514,.0788,.1934)*f1_13+\n    mat4(-.0527,.1884,.0313,-.5335,-.1207,.5959,-.3870,-.0027,.0667,-.8486,-.2098,-.2624,.4335,.4668,.5272,-.2163)*f1_14+\n    mat4(-1.3267,.0108,.1256,.1660,.0769,.9064,.3355,.0979,-.0539,.3420,-.5109,.1805,-.0663,-.7660,-.0269,-.1142)*f1_15+\n    vec4(49.5659,-68.0226,9.6196,7.5799))/1.4+0.*f1_4;\nvec4 f2_5=sin(mat4(.7166,.4730,-.9490,.4238,.5343,-.4643,-.1876,-.2844,.1636,-.4211,.6607,-.2565,-.1920,-.3241,-.6942,-.8720)*f1_0+\n    mat4(-.2479,-.5088,.2509,-.6680,.3644,-.4682,.2387,-.3790,-.6658,.4565,.1070,.5617,-.7867,.1420,-.5799,-.5037)*f1_1+\n    mat4(-.4538,-.3948,.3291,.0316,-.1909,-.4450,.1814,.0726,-.3403,-.4843,.6421,-.8212,-1.6252,-.4244,-.0303,.0008)*f1_2+\n    mat4(.1745,.4033,.1579,-.4823,-.7018,.2938,.4639,.3016,.6455,-.3169,.2432,-.1261,.2016,-.6858,.4937,-.7332)*f1_3+\n    mat4(-.0960,-.3537,.3903,-.0362,.1015,.3099,.2795,.4498,-.7761,-.3442,.0887,-.6397,-1.1874,-.5455,.2411,-.7383)*f1_4+\n    mat4(1.2598,-.3775,.5202,-.1794,.8874,.3702,-.0029,.4072,1.5853,.4539,.6465,.3536,-.3705,.4600,-.5107,.1406)*f1_5+\n    mat4(-1.0073,-.4262,.6929,-.9320,.4924,.4582,.0126,.1505,-.4963,.6685,-.3140,.3026,.9846,.8477,-.2943,.1343)*f1_6+\n    mat4(-.5900,-.3443,-.0356,-.3827,.9929,.3426,.2538,-.2918,-.5561,.5812,-.7341,-.0272,.0459,.4889,.0910,.5976)*f1_7+\n    mat4(.1010,.5578,.2608,-.1464,-.2161,-.2946,-.1774,-.6259,-.1331,.3382,.1096,.2037,1.1990,.3487,-.8457,.0381)*f1_8+\n    mat4(-.7239,-.3133,-.2313,.0450,-.0870,-.4910,.0723,-.2889,1.3525,.3865,-.7465,.1244,-.0955,-.3408,1.1367,.0241)*f1_9+\n    mat4(-.2547,.5753,.8376,.1820,-.0220,-.3730,-.2601,-.2250,.1294,-.4758,-.4158,-.3432,-.4115,-.3183,-.2975,-.2660)*f1_10+\n    mat4(-.1866,-.3881,.9093,.0773,.3356,.5289,-.4114,.0788,-.9434,-.4222,.4523,-.1281,.4617,.4735,.0043,.0842)*f1_11+\n    mat4(.1955,-.6363,.3928,-.9473,-.1605,-.4784,.4344,-.1648,.4769,-.4803,-.0819,-.4064,.3772,.2927,.1248,.2254)*f1_12+\n    mat4(1.3760,-.5578,-.0908,.2900,1.4895,.4921,.2082,.2462,-.5035,-.4970,.6765,-.6822,-.3270,.4223,-.2933,.6472)*f1_13+\n    mat4(-.4224,-.4788,.5274,-.3607,.0805,.2683,-.2091,.2874,-1.1669,-.6192,.8013,.2076,-.3863,.5163,-.5024,.3242)*f1_14+\n    mat4(-.0483,-.4812,.3128,.1360,-1.6911,.4773,-.5050,.3633,-.5970,-.3389,.1462,.2779,-.6434,-.4465,.8726,-.0410)*f1_15+\n    vec4(47.5162,113.3253,-70.1131,4.0759))/1.4+0.*f1_5;\nvec4 f2_6=sin(mat4(.0975,-.0872,.2717,.1207,-.5943,-.4324,-.4060,.8229,.1959,-.0205,.0019,-.2822,-.1631,.2390,.7171,.3121)*f1_0+\n    mat4(-.5015,.1721,.9527,-.0678,-.1732,.9854,.0788,.0183,.7714,.0654,-1.5007,-.5649,.3661,-.3236,-.2450,-.4229)*f1_1+\n    mat4(-.0706,.2467,.1416,.0377,.3998,.6729,-.3796,.1834,-.1304,.3120,1.0786,.5517,-.4395,.4068,.5315,.1861)*f1_2+\n    mat4(.7588,-.6161,-.4054,-.0038,-.1042,-.8151,-.8786,-.1486,.1780,.2215,.2966,-.2123,-.1733,1.0778,.3144,.7790)*f1_3+\n    mat4(-.3543,.3480,.4695,.2350,.2865,-.0472,.0388,-.5487,-.0721,.1851,-.4407,-.1719,-.5139,.4247,.6442,.4561)*f1_4+\n    mat4(-.2214,.1097,.7299,-.2703,.4587,-.4261,.0674,.2028,.4593,-.4236,.3433,-.2608,.1263,.1578,.3859,-.5702)*f1_5+\n    mat4(-.1579,-.1746,.2877,.2132,.0922,-.1919,.4995,.3714,1.1946,.5524,-.8198,-.6487,.7515,-.0111,.2197,-.5769)*f1_6+\n    mat4(.1040,.3443,.2574,.1864,.4892,.1933,.8335,-.3938,.2632,.0567,.0240,.0417,.0028,-.0875,-.1161,-.0367)*f1_7+\n    mat4(.4200,-.2072,-.6042,-.9082,-.1639,-.1140,-.0191,.5513,-.1573,.3057,-.3356,-.8129,.0184,.0007,.9945,.2070)*f1_8+\n    mat4(-.0095,-.2434,-.1999,.4476,-.6711,.0852,.3179,.2616,.5379,-.0070,-.1162,-.0646,.2088,.2027,.5632,.3479)*f1_9+\n    mat4(-.1760,.2772,.1663,-.5366,-.3927,.9130,.6831,.5082,.4559,.9185,-.2651,-.4110,.1405,-.0221,-.1284,.1816)*f1_10+\n    mat4(-.5627,-.1297,.0133,.6188,.1946,-.7070,-.6120,-.5633,-.3052,.0460,.3378,-.0107,.3058,.2776,.1391,-.6945)*f1_11+\n    mat4(.0251,.1645,.4006,.4585,-.3792,-.0496,.5495,-.0201,-.0891,.5879,.0797,.5670,.1301,-.3076,-.3013,-.0358)*f1_12+\n    mat4(.1098,.5495,.0489,-.1614,.3444,.0653,-.7640,-.7592,-.1283,.9377,.7788,.6315,.7260,-.0935,-.5241,-.5729)*f1_13+\n    mat4(-.7194,.2449,.0496,-.3245,.1655,-.4673,-.0817,-.1399,-.5291,-.1676,.2956,-.1191,.0118,-.7032,-.3712,-.1990)*f1_14+\n    mat4(-.7766,.0621,-.3684,.5088,-.1036,-.4684,-.6627,-.2941,.8056,.1826,.4805,-.4132,.7262,.6934,.3041,-.0079)*f1_15+\n    vec4(60.7790,70.5855,-50.4770,-22.2373))/1.4+0.*f1_6;\nvec4 f2_7=sin(mat4(-.1196,-.1768,.2574,.0910,.1819,.3411,.2370,-.3746,.1802,.5906,-.4617,.0352,.2239,-.0276,-.7794,.0446)*f1_0+\n    mat4(.3492,.6744,.0892,-.2034,-.1981,-.5712,-.7884,-.2586,-.6546,-.1658,.4186,-.1115,.0653,-.1284,.1517,.2917)*f1_1+\n    mat4(-.1357,.5840,-.1092,.2028,.7446,.0255,-.8504,-.1633,.9044,.3043,-.4690,-.9587,.1695,-.0144,-.7717,-.2661)*f1_2+\n    mat4(-.0799,-.4703,.5468,.2722,-.8447,.3010,-.0356,.4191,-.2538,-.2218,.2363,.4234,.6854,.0716,.4583,-1.0455)*f1_3+\n    mat4(.0647,.3308,.0067,.0037,-.3267,.0017,.3027,.1651,-.0678,.4062,-.0334,-.4654,.8340,.7861,-.4360,-.6059)*f1_4+\n    mat4(.0113,-.3552,.3609,.0700,.6942,-.2014,-.1813,.8795,-.1580,.1672,.0763,.1887,.2228,-.2787,.4636,.8357)*f1_5+\n    mat4(.1730,.0558,-.1629,.1669,-.5427,-.7472,.4887,.1020,.1008,-1.0667,1.4243,.1586,.7547,-.1907,.2232,.0856)*f1_6+\n    mat4(.3506,.2511,.1239,-.1266,-1.0005,-.4406,.2884,.4355,-.4659,-.3826,-.1996,.5236,-.0084,-.1774,.8289,.3497)*f1_7+\n    mat4(-.0590,-.2091,.5760,.4379,-.6510,-.0848,-.4040,-.1752,-.1078,.3466,.2518,-.1835,-.2106,-.8326,.4630,.0662)*f1_8+\n    mat4(-.6834,-.0499,.3016,-.2924,-.1555,.4239,.3146,-.5595,.1839,-.4367,-.1831,.0432,.2557,-.2558,-.7784,.0052)*f1_9+\n    mat4(-.2440,-.1522,-.1407,.2983,.5428,.3128,-.4367,-.5011,.9161,.1003,-.4378,.3407,.4133,.7470,.0078,.0258)*f1_10+\n    mat4(.2915,.2834,-.6194,-.3105,-.0928,-.4420,.8123,.3329,-.0266,.1393,.0891,.2185,-.2150,-.5540,.0179,.0961)*f1_11+\n    mat4(.9825,-.3833,-.0582,-.8246,1.0469,-.1430,-.4670,.0041,1.0115,.6558,.1856,-.3525,-.6101,-.2145,.4767,-.0959)*f1_12+\n    mat4(.2989,.5466,-.2194,-.1215,-.4174,-.0029,.5650,.4459,.2009,.0286,.5157,-.5875,.1474,-.2962,.1639,.3013)*f1_13+\n    mat4(.4634,.3118,-.2037,.2399,-.0794,-.3937,.2795,.3035,-.0160,.6815,-.1764,-1.1540,.2847,-.0370,-.3530,.3437)*f1_14+\n    mat4(.4787,.2831,.0025,-.1903,-.6527,-.1180,.6664,.2318,-.0190,-.0955,-.5924,.2545,.2835,.1952,.2079,-.0914)*f1_15+\n    vec4(42.6189,-37.9406,103.9820,-64.9717))/1.4+0.*f1_7;\nvec4 f2_8=sin(mat4(.2701,-.6042,-.5876,-.0140,-.8468,-.9979,.6691,-.7678,-.2252,-.0274,.6206,.1233,-.4730,-.3326,.5161,-.1332)*f1_0+\n    mat4(-.1193,.1659,-.3635,-.0978,.5065,-.5415,-.4458,-.3239,-.0496,-.0566,-.9663,-.2471,-.2833,-.3289,.1128,.0652)*f1_1+\n    mat4(-.5478,.2624,-.1569,-.5267,-.1803,-.1620,-.6049,-.1983,-.6351,-.0346,.7368,-.0658,.3889,-.0224,.7159,-.6880)*f1_2+\n    mat4(.9050,-.1131,.2889,.2590,.4050,.7014,-1.3302,.1010,-.0862,-.6207,-.0291,-.3824,-.5872,.3968,-.7672,.0960)*f1_3+\n    mat4(-.4176,-.0005,-.1979,.0934,.2418,.1413,-.5067,.6150,-.2029,-.2016,.4679,-.2481,-.9134,-.0834,1.0806,-.0692)*f1_4+\n    mat4(-.3953,-.7156,-.4697,-.5072,.6462,.1088,-.3055,-.0228,.2397,.6452,-.8179,-.0822,-.1929,.3444,-1.6731,.6189)*f1_5+\n    mat4(.2292,.1398,1.0829,-.6043,.2105,.1449,-.8190,-.2780,1.9750,-.4830,3.5704,-.1257,.8878,.7365,-1.8156,.6698)*f1_6+\n    mat4(-.2014,-.5329,-.7745,-.1575,.0393,.3904,.6809,.6303,.1396,.0816,-.0254,.1737,.7166,1.0091,-1.7512,-.1429)*f1_7+\n    mat4(.2934,.6926,-1.6898,.4667,-.2182,.5448,-.3461,-.1814,.1060,.9818,.7852,.1418,.8355,.4204,.2236,-.1239)*f1_8+\n    mat4(-.1294,-.3599,1.1215,-.4195,.0549,-.2440,-1.0474,-.5944,-.2692,.3794,-.3649,.2856,-.2180,-.5582,.9469,-.5057)*f1_9+\n    mat4(.4075,.8959,-.6261,.3671,-.3495,.0620,.9575,-.5013,-.2686,-.4659,-.7238,-.4268,.2189,-.4065,-.1486,.1176)*f1_10+\n    mat4(-.1666,-.2482,.1772,-.2930,.2395,.3535,-.4270,.4135,.1717,-.5863,1.0329,.0668,.2040,.3699,-.3861,-.1446)*f1_11+\n    mat4(.3116,-.8224,-.5518,-.3542,.6186,-.5399,.0663,-.2822,-.1950,-.5680,.0968,-.3354,-.0261,1.1052,-1.3138,.4741)*f1_12+\n    mat4(-.2658,-.5690,-1.7337,-.2372,.1935,.9459,1.0954,.4590,-.2110,.2489,1.1293,-.0717,.4313,-.4541,.6269,-.1690)*f1_13+\n    mat4(-.3437,.2300,1.3068,.3535,-.1864,-.4504,.6548,.6857,-.4121,.3656,.0133,-1.0627,-.1172,.3123,-.2252,-.3440)*f1_14+\n    mat4(-.3732,-.4384,1.2721,-.3534,.6806,.5190,.6212,.4836,-.0217,-.1045,-.1320,.0070,.2153,-.1002,.6129,.0188)*f1_15+\n    vec4(84.2518,-63.4373,49.4543,-121.2853))/1.4+0.*f1_8;\nvec4 f2_9=sin(mat4(.3746,-.2049,.2429,-.5380,-.0096,.1339,1.0507,-.0329,-.2061,.0944,.1907,.0415,-.3494,-.1785,-.8082,-.0770)*f1_0+\n    mat4(-.6176,-.6150,.8642,.9480,-.2409,.2500,.6465,-.4155,.1825,-.0410,.4062,-.2057,.1834,.5162,.4329,.6211)*f1_1+\n    mat4(-.1750,-.5074,.1673,.3780,-.3832,-.4059,-.5036,.5931,-.2508,.0425,1.0935,-.5045,-.1905,-.5276,.0206,-.0822)*f1_2+\n    mat4(.1175,.1365,.5865,.5840,.3428,.3021,.1929,-.6290,.0392,.9835,-.3389,-.1619,-.4185,-.8140,-1.3949,1.0399)*f1_3+\n    mat4(-.0078,-.2668,-.8914,.7009,.3168,.5882,-.7480,.2545,-.1944,-1.3747,-.4847,.5947,.0740,-1.2730,-.0911,.5761)*f1_4+\n    mat4(-.1748,-.2157,.0703,-.3273,.0941,.6763,.9402,.0134,.3980,-.4086,.7208,-.3835,.1639,-.0681,1.7889,-1.0488)*f1_5+\n    mat4(-.3401,-.3202,-1.4996,-.1787,-.1081,-.2989,1.1476,-.1099,.6553,.5676,2.6414,-1.1191,.9294,-.1387,1.4359,.6438)*f1_6+\n    mat4(-.0253,-.5406,.7915,.3440,-.0759,.0088,.0037,-.8182,.5680,.3077,-.0161,-.7169,-.1321,1.3736,-.2758,-.6992)*f1_7+\n    mat4(-.0648,-.0475,.8183,.3022,-.2514,-.1751,-.5976,-.4648,.4785,-.0247,-.7926,-.3086,.1694,.1848,.1665,-.6835)*f1_8+\n    mat4(-.2273,-.1161,.4966,-.1218,-.4609,.2364,.6582,-.0003,.4182,.3291,-.3521,-.5942,-.2747,-.1375,.3608,.3597)*f1_9+\n    mat4(.2963,.2963,-.2997,-.9392,.1525,-.6307,.6692,-.1047,-.2570,.7176,-.3355,.1234,-.7161,-.0654,-.6226,.0298)*f1_10+\n    mat4(-.3678,-.2010,.0918,.7177,.2594,.2167,.1932,.3211,-.0721,.4725,-.2522,-.2103,-.0556,.8333,1.6749,-.6338)*f1_11+\n    mat4(.1403,-.0395,.0636,-.0734,-.0844,.1096,.7638,-.6616,-.1678,.2589,-.9986,.7793,.4932,-.6247,-.1369,-.1724)*f1_12+\n    mat4(.1118,.1219,-.4515,-.0821,.0382,.0966,1.6490,.2369,-.1650,.0089,.1954,-.1734,.1728,.8098,-1.1426,-.4405)*f1_13+\n    mat4(-.3468,-.4713,-.4854,.9903,.0623,.6350,.5888,.6133,-.9974,.2131,-2.2221,.7829,.8684,.0113,.6754,-.5368)*f1_14+\n    mat4(.1877,.8281,-1.4515,.2318,.2053,-.1210,.6581,.3518,-.1261,-.1969,-.3216,.5793,-.2304,.0403,.0574,.7931)*f1_15+\n    vec4(-12.1731,-89.8442,55.8140,86.8938))/1.4+0.*f1_9;\nvec4 f2_10=sin(mat4(-.3937,.2804,-.4188,.4322,-.5624,-.0395,.2822,-.2367,-.3640,-.3465,-.2432,-.4102,-.4998,-.3454,-.0544,-.3161)*f1_0+\n    mat4(.6965,.0402,-.0600,-.5424,1.0342,-.4589,.8384,-.1597,.0011,.4475,-.2967,.2658,-.3198,.2863,-.2512,-.0943)*f1_1+\n    mat4(.6583,-.3056,.3164,.0115,-.4813,-.0787,.8365,-.3326,.1842,-.0156,.3561,.1894,-.3842,-.1522,-.0188,-.3092)*f1_2+\n    mat4(-.6043,-.1122,.1649,.5960,-.0387,.3158,-.1802,.0017,.6427,-.0684,.5925,.2838,-1.0541,-.0494,.3515,-.8683)*f1_3+\n    mat4(-.0831,-.2280,.2315,-.4038,.5761,-.8034,-.7273,.2496,-1.8426,.2361,-.1087,-.3291,-.2993,-.5826,-.1786,.1285)*f1_4+\n    mat4(-.5536,-.7295,-.3476,.0573,-.0501,-.1573,-.2822,-.1358,.7337,-.1963,-.3896,.1498,1.0523,.2673,-.6051,.1739)*f1_5+\n    mat4(-.2742,-.1795,-.0350,-.0148,.1616,.3163,-.3565,.7465,-1.0825,-.1602,-.8742,-.1075,.0986,.1089,-.2733,.2205)*f1_6+\n    mat4(-1.2445,.2560,.1196,-.3971,1.4321,.4062,-.5313,.0456,.6397,.5001,-1.0096,.1912,-.9375,.3958,.0075,.4691)*f1_7+\n    mat4(1.3754,-.3291,-.6735,.0950,.0100,.0999,.4689,-.0855,.3426,.1882,-.0713,-.1237,2.1759,.7172,.0679,.7022)*f1_8+\n    mat4(.3170,-.2769,-.1729,-.0363,-.8416,-.0566,-.0667,.2099,1.3964,.7693,-.4796,.0148,-1.4081,-.2126,.4024,.0499)*f1_9+\n    mat4(.4319,.5404,.0441,.3091,-.4924,-.6976,-.2062,.0445,.2054,-.5711,.5865,-.3091,-.5407,-.1964,-.2050,-.0802)*f1_10+\n    mat4(.0910,-.0836,.2324,-.0287,.8665,-.1863,-.5976,.3848,-.4616,-.8433,-.2762,-.0778,.4709,-.0906,-.5660,.3774)*f1_11+\n    mat4(-.2158,-1.0889,.0463,-1.1016,.0309,-.3915,-.0506,-.0849,-1.0212,-.6347,.1683,-.4579,-.2528,.3924,-.3387,-.8728)*f1_12+\n    mat4(1.0590,-.1840,.7819,-.9781,.3996,.5196,.5552,.1822,-.6705,.1258,-.3393,.1861,-.1861,.1568,.2531,.1965)*f1_13+\n    mat4(-.9986,-.2083,-.0853,-.5744,-.5927,.3549,-.7335,.3736,-.4116,-.5426,.9421,-.3277,1.4129,.8508,-.2352,.0276)*f1_14+\n    mat4(.1826,-.0255,-.0053,-.2062,-.1465,.2666,-.7243,.5147,.0283,-.5647,-.0710,-.6201,-.3816,-.5005,-.0550,-.4717)*f1_15+\n    vec4(-33.2576,-99.2351,5.8420,117.3820))/1.4+0.*f1_10;\nvec4 f2_11=sin(mat4(-.6115,.1840,-.2988,.1768,.2362,.0013,.2996,-.3143,.2295,-.1764,.1948,.1175,.4105,-.0823,.2261,-.5008)*f1_0+\n    mat4(-.3863,-.2665,.1179,-.1607,-.0612,-.4926,.2630,-.0669,-.4114,-.1064,-.2814,-.1990,.1872,-.0143,-.0165,-.3132)*f1_1+\n    mat4(.4911,-.1682,.3373,-.5847,.4160,-.4630,.2109,.2186,-.1170,-.2297,.0562,.3832,-.3295,-.6328,.2599,.2186)*f1_2+\n    mat4(-.3116,.9515,-.0916,.3182,.0729,.1579,-.1153,.3902,.6023,.3948,.2464,-.4939,.0213,-.4821,.3030,-.5868)*f1_3+\n    mat4(.6927,-.1856,.3043,-.3266,-.3951,.9696,-.0404,-.0362,.1718,-.2711,.4046,-.0371,.4882,-.6926,.2459,.8110)*f1_4+\n    mat4(.2572,-.4605,.3281,.1367,-.0377,-.4558,-.3965,-.3921,-.7107,.1143,-.4289,.7313,-.6251,-.2906,-.2040,-.2643)*f1_5+\n    mat4(.1098,-.5737,.1718,-.2707,-.6643,-.5023,-.2695,.1380,1.8859,.1995,-.3121,-.3117,-1.1018,.5468,-.4153,.0586)*f1_6+\n    mat4(.0864,-.4567,.1212,-.0884,.5652,.5510,-.2454,.0126,-.0665,1.5917,-.3607,.1305,-.2410,-.0781,-.2795,.5185)*f1_7+\n    mat4(.3327,-.0803,-.2190,.6734,.4878,-.3218,.2089,-.4635,.3212,.7795,-.0734,.2577,-1.6172,-.5177,-.2942,-.2043)*f1_8+\n    mat4(-.3759,.1633,.3601,.1952,.1065,-.0377,.2997,-.0965,-.1003,-.7122,-.2128,.1141,.0893,.0428,.2095,-.4757)*f1_9+\n    mat4(-.4709,-.0080,-.2637,.4184,-.1631,.5557,.0388,-1.0276,.8595,-.2664,.2739,-.1579,-.5598,-.3080,.1959,-.4626)*f1_10+\n    mat4(.6864,.1919,.2651,.0058,-.2451,-.1235,-.3786,.8097,-.1915,-.2200,.0898,.3310,-.9643,.0626,-.3429,-.0038)*f1_11+\n    mat4(.5409,-.3055,.2290,-.3568,.4937,-.3331,.1976,.0190,.1734,-.5881,.1982,.0324,-.7096,.0627,-.1926,.4251)*f1_12+\n    mat4(.0227,-.2067,.3919,-.1855,-.6887,.2649,-.2920,.1874,.0408,-.6456,.2092,-.6059,-.2534,.3293,-.3045,.4333)*f1_13+\n    mat4(.8641,-.7254,.3526,-.8033,-.7611,.2386,-.2276,.3679,.0606,-.9541,.1737,-.1019,.1207,-.0654,-.3080,.7345)*f1_14+\n    mat4(.3689,.1589,.3899,-.6911,-.9141,.8214,-.1057,.3959,-.1042,.3636,.2607,-.1558,.4929,-.2652,.1231,.5275)*f1_15+\n    vec4(63.2126,75.5789,99.4795,-105.4012))/1.4+0.*f1_11;\nvec4 f2_12=sin(mat4(.3411,-.5044,-.1958,-.7269,.3260,-.7287,-1.1008,-.2679,.0417,-.3866,-.4045,-.4616,.2143,-.4504,-.0189,-.4930)*f1_0+\n    mat4(-.2080,-.4485,.9496,-.1950,-.5232,-.2946,.9092,.0896,.3160,.0898,1.3171,.7822,.0530,.7232,-.5356,.2833)*f1_1+\n    mat4(-.0499,-.2744,.0700,-.2000,-.7109,.2832,-.3484,.2393,-.1851,-.7939,-1.0979,.1060,-.3237,-.7005,-.2712,.0675)*f1_2+\n    mat4(.3373,.8254,-.1927,.8017,.3702,.0533,.4801,.1728,.1844,-.1315,.3657,-.2176,.1494,-.7544,.5256,-.1292)*f1_3+\n    mat4(-.2600,-.4986,.3155,-.0203,.1616,.1529,1.0216,.3980,-.1691,-.2901,-.4005,-.3534,-.4667,-.5770,-.5160,-.1203)*f1_4+\n    mat4(-.1517,.1780,-.7219,-.2950,.0532,-.2066,.8570,-.1218,.3941,.2008,1.9334,.4283,.7641,.4539,-.7474,.6434)*f1_5+\n    mat4(-.4423,-.6358,-.3395,-.1548,.0060,.2482,.3179,-.1225,.2464,2.9659,-1.4528,.1757,.7274,1.0782,.0397,.3713)*f1_6+\n    mat4(-.3788,.4046,.1038,-.1675,.3794,.3311,1.2749,.4123,.6152,.3953,1.8973,-.2289,-.1566,-.1993,.4466,.7790)*f1_7+\n    mat4(.6804,.4700,2.3393,.2846,-.0488,-.3236,-.0458,-.1090,.5981,.0335,.1042,.5236,.4112,.1603,1.3942,.4962)*f1_8+\n    mat4(-.1001,-.1211,.8798,-.0176,-.1537,-.7641,-.3478,-.4398,-.4119,.3060,1.3163,-.1404,.0708,.2395,-1.4290,-.1751)*f1_9+\n    mat4(-.5310,.1644,-.2155,.5488,-.5706,.1533,.4013,-.5231,-.3130,.3063,1.5844,-.2679,.1282,.2996,-.0225,-.7065)*f1_10+\n    mat4(-.4783,-.3386,.2300,-.5401,-.1551,-.4566,.4243,-.3033,-.1481,-.4315,-.1811,-.4327,.0616,.5860,-.7205,.0085)*f1_11+\n    mat4(-.7647,-.5116,.0530,-.5833,-.1755,.0311,-.8114,-.7284,-1.0372,.1231,.1592,.1706,.3211,.5906,-.4309,-.1829)*f1_12+\n    mat4(-.2867,-.1869,1.0389,-.3557,.4484,.0668,.5678,.2715,-.6335,-.6704,-.4637,-.1833,.1851,.0722,.7542,.0408)*f1_13+\n    mat4(-.0448,.2696,.2999,-.5752,.2262,.1763,-.1519,-.3197,-.0715,-.3424,-1.0539,.1490,-.1021,.2355,.7303,.1030)*f1_14+\n    mat4(-.0856,-.6126,-2.0751,-.0682,.8370,-.1813,.2735,.4564,-.2486,.3634,.4207,-.0336,-.4824,.2808,.4046,-.9395)*f1_15+\n    vec4(-14.3182,124.1302,-108.0174,-55.5100))/1.4+0.*f1_12;\nvec4 f2_13=sin(mat4(.0259,.9425,.9185,.7032,.6778,.1958,-.3538,-.1975,-.1823,-.4252,-.2336,.4056,.2708,-.3612,.0409,-.4372)*f1_0+\n    mat4(.3418,.0648,-.2474,.3357,.1726,-.9756,-.1956,.4360,-.8480,.3671,.8200,-.7306,-.1474,-.1184,-.0537,.4474)*f1_1+\n    mat4(-.2057,.0099,-.6763,.0741,.1091,-.0590,-.2347,.8723,.4153,-.5045,-.4886,.1379,.4128,.1782,-.4031,-.6912)*f1_2+\n    mat4(-.7487,.3618,1.5392,-.2638,.0744,-.1108,.4910,-.7391,.2266,-.4600,.1057,-.2771,.5183,-.3776,-1.0155,1.0073)*f1_3+\n    mat4(.2086,.0782,-.0479,.2539,-.4652,.1155,.0915,.4997,.6810,-1.2673,-.2550,-.1175,.4726,-.1447,-.5734,.5999)*f1_4+\n    mat4(-.9492,.5018,.0183,-.3707,-.1721,.1107,-.6963,-.4054,-.5783,.1326,.5993,-.2371,-.7355,.8176,.4167,.5213)*f1_5+\n    mat4(.9859,-.9373,-.7022,-.6676,-.5024,.6231,.0876,-.6198,-.1179,.1340,.9655,1.3830,-.8084,.6852,-.1596,-.7640)*f1_6+\n    mat4(.4078,.0530,.4578,-.6190,.4342,.8159,-.4710,-.3781,.6955,.1596,.1655,.7364,-.6521,.0058,1.2404,-.3240)*f1_7+\n    mat4(.3506,.1343,-.5528,-.5839,.0092,-.1322,.2851,-.7074,-.1449,-.0960,-.2008,.6619,-.0678,-.5931,.7677,.0821)*f1_8+\n    mat4(-.4133,-.2794,.2867,-.0506,-.1515,-.1145,-.2034,-.0448,-.9201,.0834,.6530,1.5345,.7298,-.3051,-.2562,.4836)*f1_9+\n    mat4(-.3766,.8489,-.4772,-.0458,-.2756,-.4233,-.0088,-.9807,.0257,.3152,-.1990,-.6062,.7307,-.1767,-.8164,-.3331)*f1_10+\n    mat4(.1047,.2799,.3671,-.1840,-.0776,-.6759,.1743,.1075,-.2062,-.4349,.0293,-.4508,-.4420,.9963,.0642,-.7070)*f1_11+\n    mat4(.1788,-.3508,-.1167,-.3798,-.1292,.0780,.0600,-.2851,.1110,-.7327,-.7905,1.1713,-.5280,.5460,-.5001,.4855)*f1_12+\n    mat4(.0630,-.2016,.2473,-.4582,-.8255,.1685,.6663,-1.0097,-.1491,-.7777,-.4347,-.2521,-.0390,.2682,.3823,.6576)*f1_13+\n    mat4(.2965,.2372,.1282,.0418,-.1521,-.2585,.3967,.4718,.1355,-.8120,.2683,.4048,-.6101,.2239,.1735,-.7276)*f1_14+\n    mat4(.1017,.1801,-.4200,.4858,-.3349,.0316,-.2696,.0532,-.4421,-.1219,-.2603,.0381,.3950,.1068,-.6673,-.1714)*f1_15+\n    vec4(-29.3224,119.9647,3.3558,68.0709))/1.4+0.*f1_13;\nvec4 f2_14=sin(mat4(.2593,.1982,-.5171,.0393,-.4336,.3516,.5450,-.7379,.4600,-.1347,-.0201,.1342,-.5179,-.9330,-.0054,-.4747)*f1_0+\n    mat4(-.9700,-.4772,.3074,-.0097,-.2130,-.3800,.6093,-.3881,.6186,.7717,-.2366,.1618,.3651,.2301,-.9766,.2675)*f1_1+\n    mat4(-.0404,-.0378,.3433,.2434,-.4851,.1008,-.1766,.2990,-.7731,-.5810,-.1082,-.8713,.4021,-.4228,.1140,-.3354)*f1_2+\n    mat4(.5148,.5418,-.1842,.3298,-.2396,.1546,.2852,.0994,-.8845,.3597,.4665,-.6690,-.4736,.4589,.5287,-.4932)*f1_3+\n    mat4(-.6861,.0461,-.0477,-.2997,.3935,.3782,-.3688,.3016,-.6902,.0778,.1297,-.6141,-.0686,-.7296,.4882,-.7698)*f1_4+\n    mat4(.2384,.0720,-.1918,.4795,.2487,-.5373,.0245,.3721,-.2930,-.6364,-.4205,-.4668,-.1562,.4141,-.5134,-.0467)*f1_5+\n    mat4(-.2837,-.8382,.4885,.0205,.3154,-.2309,-.8329,.1088,.4754,-1.2941,.1116,-.1312,-.1256,.2941,-.6274,-.0449)*f1_6+\n    mat4(-.5337,-.3723,.1150,-.1720,.0199,.4689,-.0177,.2544,-.7628,-.5506,.1647,-.0031,-.6949,.2858,.1742,-.2105)*f1_7+\n    mat4(-.0236,1.6169,-.2381,.4797,-.1431,-.2594,.3462,-.0279,-.5789,.1616,-.0067,.2808,.2809,.0248,-.4628,-.2298)*f1_8+\n    mat4(.0402,-.4246,.3511,.0838,-.3799,.0349,.2027,.1224,.6813,.3734,-.7484,.6843,-.5854,-1.0217,.2615,-.3448)*f1_9+\n    mat4(.1691,.1146,-.3980,.2306,-.2588,-.7672,.5181,.0060,.0664,-.2431,-.0218,-.0170,.2352,-.0423,-.3960,-.1658)*f1_10+\n    mat4(-.2009,-.6034,.1076,-.4577,.0251,-.5376,-.6203,.6670,-.6326,-.6777,.0211,-.5424,.7223,.5709,-.1663,.1414)*f1_11+\n    mat4(-.8586,-.5988,.3524,-.4188,-.5318,-.2849,.1672,-.3603,-.0441,-.6302,.5547,-.7058,.2351,.2087,-.3018,.2562)*f1_12+\n    mat4(-1.0648,-.6140,-.0400,-.0818,.1623,.1092,-.0703,.0895,-.3696,.2286,.2123,-.2343,.5350,.4950,-.2954,.5723)*f1_13+\n    mat4(-.2661,-.5841,.7612,-.5589,.4992,-.0290,-1.1232,.3581,.2523,.3336,.6652,.0221,.3640,-.1525,-.1160,.2111)*f1_14+\n    mat4(.5459,.3842,.2144,-.5400,.2027,.6437,-.5481,-.1300,-.4889,-.4920,.0796,-.1429,.1048,-.0845,-.2094,-.7690)*f1_15+\n    vec4(-77.4035,-100.7937,108.2716,51.3795))/1.4+0.*f1_14;\nvec4 f2_15=sin(mat4(-.2755,.0957,-.0680,-.3903,.5138,-.3921,.4617,.1382,.0673,-.7357,-.2869,.6970,-.0427,.0078,-.4233,.7192)*f1_0+\n    mat4(.3215,-.3035,-.2357,.2458,.5174,.8889,-.6305,-.1160,.1563,-.1113,-.1923,-.0114,-.2935,-.1962,.3515,.1133)*f1_1+\n    mat4(.0694,-.4670,-.6840,.3397,.4097,-.3710,-.2901,.2434,.2404,-.2182,-.2428,.4804,.6769,.2519,-.4765,-.1533)*f1_2+\n    mat4(-.2861,.1450,.2109,.2507,-.2919,.2282,.2613,-.3120,.5665,.1185,-.1175,.0337,.0500,-.5699,-.7028,.3304)*f1_3+\n    mat4(-.3552,-.3001,-.6076,.4667,-.1035,-.2808,.2774,-.1237,.4928,.1989,.6572,.0804,.5753,.4266,-.0097,.4769)*f1_4+\n    mat4(.4714,-.5539,.0215,.6325,-.3021,.2120,.0129,-.8103,-.2136,.4745,-.3014,-.7004,-.3981,.0500,.4383,-.6354)*f1_5+\n    mat4(.2289,-.3936,-.4283,.2344,-.1414,.0101,1.0957,-.3388,-.8963,2.1460,.7749,.8045,.1957,.1898,.0977,.3660)*f1_6+\n    mat4(-.0830,-.4679,-.3192,.6056,-.1003,-.1458,-.0907,.1207,-.2776,1.0290,.7439,-.2098,-.4735,.1713,.1941,-.4783)*f1_7+\n    mat4(.3884,.6397,.5398,.0397,-.0579,-.3540,-.4003,.4898,-.3575,-.1379,.0511,-.7292,.2165,.6096,-.0693,-.3129)*f1_8+\n    mat4(.1851,-.0307,.1262,.1702,.1053,-.0479,-.3279,.3627,-.2006,-.0977,.7745,.4183,.0911,.0509,-.8800,.4094)*f1_9+\n    mat4(-.6595,-.1206,.6516,-.5526,.2291,-.1574,-.5481,.4818,-.0957,-.2617,-.1874,.5019,.5259,-.3462,-.2929,.2345)*f1_10+\n    mat4(-.2439,-.4925,-.1447,.1639,-.6514,.5407,.2692,.1986,-.0680,-.4509,-.3314,.0472,-.4831,.0165,-.3484,-.0632)*f1_11+\n    mat4(.5464,-.1047,.1862,-.5419,.0793,.0476,-.1024,.3364,-.2469,-1.0696,-.0976,.0731,-.1406,.8046,.3062,-.4974)*f1_12+\n    mat4(.3130,.1374,-.3271,.2906,-.1917,.2394,-.3799,-.6481,.1165,-.4296,-.2751,.4853,-.0571,-.0445,.2223,.3079)*f1_13+\n    mat4(-.1937,.4806,-.6572,.5059,.2841,-.2800,-.0149,-.3216,.6905,-.9387,-.1396,.5543,.0305,-.0601,.1009,.2080)*f1_14+\n    mat4(.2421,-.9323,.5120,-.0864,-.6506,-.0642,.4060,-1.2328,.2683,-.7269,-.1016,.0655,.8459,-.0032,.4725,.6864)*f1_15+\n    vec4(56.1177,56.0484,19.5058,33.3241))/1.4+0.*f1_15;\nreturn dot(f2_0,vec4(.0196,-.0160,-.0151,-.0183))+\n    dot(f2_1,vec4(-.0170,.0167,.0168,-.0146))+\n    dot(f2_2,vec4(-.0157,-.0150,-.0127,.0156))+\n    dot(f2_3,vec4(-.0153,.0152,.0171,.0146))+\n    dot(f2_4,vec4(-.0160,-.0153,.0180,-.0146))+\n    dot(f2_5,vec4(-.0136,.0473,.0148,.0163))+\n    dot(f2_6,vec4(.0163,-.0165,.0131,-.0180))+\n    dot(f2_7,vec4(.0152,.0170,.0150,.0177))+\n    dot(f2_8,vec4(.0184,.0138,.0146,.0192))+\n    dot(f2_9,vec4(-.0193,.0145,.0139,.0147))+\n    dot(f2_10,vec4(-.0128,-.0171,.0169,.0154))+\n    dot(f2_11,vec4(-.0143,-.0164,.0452,-.0155))+\n    dot(f2_12,vec4(.0175,-.0184,-.0134,-.0148))+\n    dot(f2_13,vec4(-.0147,-.0153,.0150,.0151))+\n    dot(f2_14,vec4(.0151,.0154,-.0166,-.0164))+\n    dot(f2_15,vec4(.0156,-.0161,-.0161,-.0155))+\n    0.0644;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( 2.0*step(time, 17.0)*siren(time) );\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 127, 127, 85094], [85096, 85096, 85153, 85153, 85339]], "test": "untested"}
{"id": "3tdBDr", "name": "Sine Islands", "author": "eiffie", "description": "Its a world made of sine waves.", "tags": ["sine"], "likes": 5, "viewed": 350, "published": 3, "date": "1612539964", "time_retrieved": "2024-07-30T19:40:26.616277", "image_code": "//Sine Islands by eiffie (everything is sine waves)\n#define PI 3.14159265 \n#define size iResolution \n#define time iTime\n#define maxDepth 200.\nconst int iters=11,steps=256,shadowsteps=32; \nfloat eps,spec=0.5; \nconst float aocc=0.0,aoe=0.75,specExp=32.0,contrast=0.45;//light params \nconst vec3 cDiffuse=vec3(0.75,0.54,0.33),cLight=vec3(1.0,1.0,1.0); \nconst vec3 cBGround=vec3(0.5,0.6,1.0),light=vec3(0.0,1.0,0.0); \nvec3 diffuse=vec3(0.3,0.4,0.5),normal,cGlow=vec3(0.0,0.05,0.1); \nbool bColoring=false; \nvec3 eye;\nmat2 RMat2(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));} \nmat2 rmx; \nfloat wvTrn(vec2 z, float amp, float freq, float wave){ \n float h=0.0; \n vec2 offset=vec2(2.5+wave*0.1,1.0+wave*0.07); \n for(int i=0;i<8;i++){ \n  z=z*rmx*freq+offset; \n  h+=sin(z.x+wave)*sin(z.y+wave*1.33)*sin(length(z)*2.33+wave)*amp; \n  amp=pow(amp,1.25); \n } \n return h; \n}\nfloat Mnt(vec2 z){return wvTrn(z*0.01,0.25,2.0,0.0)*25.+1.;}\nfloat DE(vec3 z) { \n float r=length(z.xz-eye.xz);\n float dMnt=Mnt(z.xz)+z.y+r*0.02; \n float dWtr=wvTrn(z.xz*1.0,0.2,1.75,time)*0.25+z.y+1.0; \n float d=min(dMnt,dWtr); \n if(bColoring){ \n  cGlow=vec3(0.1+r*0.002); \n  if(d==dMnt){diffuse=vec3(0.5+wvTrn(z.xz,0.25,2.0,0.0),0.7,0.4)*(0.2+dMnt*4.0);} \n  else if(d==dWtr){diffuse=vec3(0.0,0.1,0.55);cGlow=vec3(0.8);} \n } \n return d; \n} \n \nfloat fakeAO(vec3 ray, vec3 norm, float ao_eps) {//from rrrola \n float ao=1.0,w=0.1/ao_eps,dist=2.0*ao_eps; \n for (int i=0; i<5; i++) { \n  float D = DE(ray + norm*dist); \n  ao -= (dist-D) * w; w *= 0.5; dist = dist*2.0 - ao_eps; \n } \n return clamp(ao, aocc, 1.0); \n} \n \nfloat rand(vec2 co){ \n // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html \n return fract(sin(dot(co.xy*0.123,vec2(12.9898,78.233))) * 43758.5453); \n} \n \nvoid mainImage(out vec4 O, in vec2 U) {\n rmx=RMat2(0.6); \n vec2 uv=(2.*U-size.xy)/size.xy;\n vec3 ray = vec3(time,1.,time*1.5), rayDir = normalize(vec3(uv,3.));\n rayDir.xz=rayDir.xz*RMat2(-.5);\n ray.y=max(-.8,1.5-0.5*(Mnt(ray.xz)+Mnt(ray.xz+rayDir.xz)));eye=ray;\n vec3 color=cBGround+vec3(max(wvTrn(rayDir.xy*5.0,0.25,2.0,-time*0.25)*0.5,0.0)); \n cGlow=vec3(0.2,0.3,0.4);\n eps=1.25/max(size.x,size.y); \n int iSteps=0;\n float rayLen,dist,smoothSteps; \n rayLen=dist=max(DE(ray)*rand(gl_FragCoord.xy),eps); \n for(iSteps=0;iSteps<steps && dist>=eps*rayLen && rayLen<=maxDepth;iSteps++){ \n  rayLen+=dist=DE(ray+rayLen*rayDir)*0.9; \n } \n eps*=rayLen; \n if(dist<eps){//we hit the fractal \n  smoothSteps=(float(iSteps)+dist/eps)/float(steps); \n  ray+=rayLen*rayDir; \n  bColoring=true;DE(ray);bColoring=false;\n  vec2 ve=vec2(eps,0.0); \n  normal=normalize(vec3(-DE(ray-ve.xyy)+DE(ray+ve.xyy),-DE(ray-ve.yxy)+DE(ray+ve.yxy),-DE(ray-ve.yyx)+DE(ray+ve.yyx))); \n  float cheapAO=1.0-smoothSteps*aoe; \n  if(diffuse.x==0.){//hit water\n    float d=Mnt(ray.xz)+ray.y+length(ray.xz-eye.xz)*0.02;\n    if(d<0.5){\n      vec3 c=vec3(0.5+wvTrn(ray.xz,0.25,2.0,0.0),0.7,0.4)*.4;\n      diffuse=mix(c,diffuse,clamp(d*2.,0.,1.));\n    }\n  }else{//ground\n    diffuse+=rand(ray.xz)*0.1;\n    if(aocc>0.0)cheapAO*=fakeAO(ray,normal,eps*4.0);\n  }\n  diffuse=(dot(normal,light)*contrast+0.75)*diffuse;\n  diffuse+=spec*pow(max(dot(normal,normalize(light-rayDir)),0.0),specExp)*cLight;  \n  color=diffuse*cheapAO; \n  color=mix(color,cBGround,clamp(log(rayLen/maxDepth),0.0,1.0));//FOG \n }else {//missed\n  cGlow=vec3(0);\n  rayLen=maxDepth-0.2;//keep rayLen in bounds for models \n  smoothSteps=(float(iSteps)-2.0*dist/rayLen+rand(gl_FragCoord.xy))/float(steps);\n  cGlow=vec3(min(-(rayDir.y-1.)*10.,.8)); \n } \n color=mix(color,cGlow,smoothSteps);//GLOW \n O = vec4(clamp(color,0.0,1.0),1.0);\n} \n\n", "image_inputs": [], "sound_code": "//beats per sec\n#define bps 4.\n//how many beats notes are held\n#define holds 4.\nfloat rnd(float t){return fract(sin(mod(t,32.123)*32.123)*41.123);}\nvec2 nofs(float n){//the song's \"random\" ring\n  float r=0.5+0.5*rnd(floor(n));//random volume\n  n=mod(n,8.0);//random ring for brownian motion\n  if(n<1.)n=3.;\n  else if(n<2.)n=1.;\n  else if(n<3.)n=-2.;\n  else if(n<4.)n=-1.;\n  else if(n<5.)n=0.;\n  else if(n<6.)n=-1.;\n  else if(n<7.)n=-3.;\n  else n=3.;\n  //n=(n<1.?3.:n<2.?1.:n<3.?-2.:n<4.?-1.:n<5.?0.:n<6.?-1.:n<7.?-3:3.);\n  return vec2(n,r);\n}\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.); \n return ((n2==1.)||(n2==3.)||(n2==6.)||(n2==8.)||(n2==10.))?-100.:note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(float n){return (n>0.0)?440.0 * pow(2.0, (n - 67.0) / 12.0):0.0;}\nfloat env(float att, float bt){return (1.0-exp(-bt*att))*max(1.0-pow(bt,.1),0.);}\n\nvec2 inst(float n,float t,float bt){//note, time and beat within note\n float sn=scale(floor(n));if(sn<0.0)return vec2(0.0);\n float f=ntof(sn);\n float a=sin(f*t*6.283+bt*3.14159*sin(f*t*1.57));\n return vec2(1.5-n/90.0+sin(bt),n/90.0-sin(bt))*a*env(2000.0,bt/holds)*60.0/n;\n}\nvec2 mainSound(int samp, float time){\n float tim=time*bps;\n vec2 a=vec2(0);//accumulator\n for(float i=0.;i<holds;i+=1.){//creating held notes by backing up and playing the\n   float b0=floor(tim),t0=fract(tim);//..tails of old notes\n   vec2 n0=nofs(b0*0.125)+nofs(b0*0.25)+nofs(b0*0.5)+nofs(b0);//sloth canon (fbm for music)\n   a+=inst(n0.x+60.0,time,t0+i)*n0.y;\n   a+=inst(n0.x+67.0,time,t0+i)*n0.y;//a harmonic 7th\n   //if(mod(i,2.0)<1. && n0.x>0. && scale(floor(n0.x+1.))>0.)a+=0.5*(rnd(time)-.5)*n0.y*env(100.,t0*5.);\n   tim-=1.;//go back in time\n }\n return clamp(a/(8.*float(holds)),-1.,1.);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[512, 512, 532, 532, 575], [588, 588, 643, 643, 864], [865, 865, 883, 883, 925], [926, 926, 944, 944, 1304], [1308, 1308, 1357, 1371, 1574], [1578, 1578, 1598, 1673, 1748]], "test": "untested"}
{"id": "3ltBDr", "name": "Fractal Condos", "author": "eiffie", "description": "Arrow keys: up/down to accel, right/left to roll\nMouse button down to steer", "tags": ["fractal"], "likes": 17, "viewed": 360, "published": 3, "date": "1612539272", "time_retrieved": "2024-07-30T19:40:27.391205", "image_code": "// Fractal Condos by eiffie\n#define size iResolution\n\nvec2 rep(vec2 p, vec2 a){return abs(mod(p+a,a*2.0)-a);}\n\nvec4 mcol=vec4(0.0);\nfloat DE(vec3 z0){\n vec3 scol;\n z0.xz=rep(z0.xz,vec2(4.25,4.25)); \n float dB=min(z0.y+1.41,max(min(abs(z0.x-3.16),abs(z0.z-1.46))-0.25,abs(z0.y-0.38)-0.02)); \n vec4 z = vec4(z0,1.0),c=vec4(0.0,1.0,0.66,0.0);//amazing surface/box thnx to kali/tglad \n float dS=1000.0; \n for (int n = 0; n < 3; n++) { \n  z.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz; \n  z*=2.0/clamp(dot(z.xyz,z.xyz),0.75,1.37); \n  z+=c; \n  dS=min(dS,(length(max(abs(z.xyz)-vec3(0.82,2.83,0.82),0.0))-0.33)/z.w); \n } \n float dG=dS+0.037;//interior is glass\n if(mcol.z>0.0){//save for coloring\n   c=floor(z*2.5);\n   scol=vec3(0.6+abs(fract(z.x*z.y*0.5)*0.4-0.2));\n } \n z.xyz=abs(mod(z.xyz,0.4)-0.2); \n dS=max(dS,-max(z.y-0.16,min(z.x,z.z)-0.15)/z.w);//cut out windows \n if(mcol.z>0.0){//now the coloring \n  if(dS<dB && dS<dG){ \n   z*=200.0; \n   dS+=sin(z.x+2.4*sin(z.y+2.4*sin(z.z)))*0.00005; \n   mcol+=vec4(scol*vec3(1.0,0.9,0.7),1.0); \n  }else if(dB<dG){ \n   float d=0.1; \n   if(min(abs(z0.x-3.16),abs(z0.z-1.46))-0.24>0.0 && fract((z0.x+z0.z)*10.0)>0.5)d=1.0; \n   mcol+=vec4(d,d,0.2,32.0); \n  }else{ \n   float spec=1.0; \n   if(sin((1.0+iTime*0.01)*(4.0*c.x-c.y+3.0*c.z))<-0.8)spec=-1.0; \n   mcol+=vec4(0.3,0.4+fract((c.x+c.z-c.y)*0.32454213)*0.3,0.5,spec);   \n  }\n } \n dS=(abs(min(dS,dG))-0.002)*0.8; \n return max(0.0,min(dS,dB)); \n} \n \nfloat rnd; \nfloat ShadAO(vec3 ro, vec3 rd){ \n float res=1.0,t=0.0; \n for(int i=0;i<24;i++){ \n  float d=abs(DE(ro+rd*t)); \n  res=min(res,2.0*d/t+t*0.1); \n  t+=d; \n } \n return clamp(res+0.1,0.0,1.0); \n} \nvec3 light_dir,light_col=vec3(1.0,0.9,0.6); \nvec3 Light(vec3 so, vec3 rd, float t, float dist){ \n float px=t*1.66/size.y;\n so+=rd*(dist-px);\n mcol=vec4(0.01); \n float d=DE(so); \n vec2 v=vec2(px,0.0);//px is pixelSize*t \n vec3 dn=vec3(DE(so-v.xyy),DE(so-v.yxy),DE(so-v.yyx)); \n vec3 dp=vec3(DE(so+v.xyy),DE(so+v.yxy),DE(so+v.yyx)); \n vec3 norm=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));  \n if(norm!=norm)norm=rd; \n vec4 scol=mcol*0.143;mcol=vec4(0.0); \n float shad=ShadAO(so+norm*(0.002+rnd*0.001),light_dir); \n float camLightStrength=exp(-t); \n if(scol.w<-0.75)shad=-4.0*(scol.w+0.75); \n if(scol.w<0.0)scol.w=10.0; \n vec3 R=reflect(rd,norm); \n float dif=max(max(0.0,camLightStrength*dot(norm,-rd)),dot(norm,light_dir)); \n float spec=dot(light_dir,R); \n vec3 diffuse_col=scol.rgb+vec3(0.12,0.05,-0.125)*spec; \n dif=min(dif,shad); \n spec=min(pow(max(0.0,spec),scol.w),shad); \n return diffuse_col*dif*1.5+light_col*spec+vec3(0.5,0.7,0.9)*pow(max(0.0,dot(R,-rd)),10.0)*camLightStrength; \n} \n//mat3 lookat(vec3 fw){ \n// fw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw); \n//} \n//vec3 path(float t){return vec3(t,-1.27,4.3);}\nvec3 getBackGround(vec3 rd){return light_col*max(0.0,rd.y);}\n#define quat vec4 \nquat qid(){return quat(0.0,0.0,0.0,1.0);} \nquat qmulq(quat q1, quat q2){//multiply two quats \n return quat(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz)); \n} \nquat qinv(quat q){return quat(-q.xyz,q.w)/dot(q,q);}//inverse quaternion \nvec3 qmulv(quat q, vec3 p){quat qi=qinv(q),q2=quat(p*qi.w+cross(p,qi.xyz),-dot(p,qi.xyz));\nreturn q.xyz*q2.w+q2.xyz*q.w+cross(q.xyz,q2.xyz);}\n//vec3 qmulv(quat q, vec3 p){return qmulq(q,qmulq(quat(p,0.0),qinv(q))).xyz;}//rotate a vector \nvec4 load(in int re) { \n return texture(iChannel0, (0.5+vec2(re,0.0)) / iChannelResolution[0].xy, -100.0 ); \n}\nvoid mainImage(out vec4 O, in vec2 U){\n light_dir=normalize(vec3(0.2,0.7,0.25));\n float px=1.66/size.y,ptim=iTime*0.25;  \n //vec3 ro=path(ptim),tg=path(ptim+0.5);\n vec3 rd=normalize(vec3((2.0*U-size.xy)/size.x,1.0)); \n vec3 ro=load(0).xyz; \n quat fw=load(1); \n rd=qmulv(fw,rd);\n vec2 co=gl_FragCoord.xy-17.0*vec2(fract(iTime*0.66)); \n rnd=fract(sin(co.x+cos(co.y))*4317.6219);\n float t=DE(ro)*(0.5+0.5*rnd); \n float d,pd=10.0,step,dm=100.0,tm,de=100.0,te=0.0;  \n for(int i=0;i<128;i++){ \n  d=DE(ro+rd*t); \n  if(de==100.0 && d>pd && pd<px*(t-step)){de=pd;te=t-step;} \n  step=d; \n  if(d<dm){dm=d;tm=t;}//save max occluder  \n  t+=step; \n  pd=d; \n  if(t>100.0 || d<0.000001)break; \n } \n vec3 col=getBackGround(rd); \n if(dm<px*tm)col=mix(Light(ro+rd*tm,rd,tm,dm)*exp(-tm*0.02),col,clamp(dm/(px*tm),0.0,1.0)); \n if(de<px*te)col=mix(Light(ro+rd*te,rd,te,de)*exp(-te*0.02),col,clamp(de/(px*te),0.0,1.0)); \n //fog from marius' boxplorer\n    float fog3 = 0.1;  // higher = thicker \n    float fogFalloff3 = 0.01;  // higher = closer \n    vec3 backgroundColor3 = vec3(0.8, 0.8, 0.8);  \n    col= mix(mix(backgroundColor3,col*0.5,abs(rd.y)), col, clamp(exp(-pow(t * exp(fogFalloff3), 1.0) * fog3),0.0,1.0));  \n O=vec4(col,1.0); \n}  \n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//re-usable flight code with stabilizer\n//up/down=thrust right/left=roll\n \n#define THRUST 0.04*iTimeDelta \n#define ROLL 1.0*iTimeDelta \n#define ROTATE 4.0*iTimeDelta \n#define TOO_CLOSE 0.01 \n \n#define LEFT_ARROW 37 \n#define UP_ARROW 38 \n#define RIGHT_ARROW 39 \n#define DOWN_ARROW 40 \n \n//originally from iq but messed up by me \nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); } \n \nvec4 load(in int re) { \n    return texture(iChannel0, (0.5+vec2(re,0.0)) / iChannelResolution[0].xy, -100.0 ); \n} \n \nvoid store( in int re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) { \n    fragColor = ( isInside(fragCoord,vec2(re,0.0)) > 0.0 ) ? va : fragColor; \n} \n \nbool KeyDown(in int key){return (texture(iChannel1,vec2((float(key)+0.5)/256.0, 0.25)).x>0.0);} \n \n//some quaterion math just to be different \n#define quat vec4 \nquat qid(){return quat(0.0,0.0,0.0,1.0);} \nquat qmulq(quat q1, quat q2){//multiply two quats \n return quat(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz)); \n} \nquat aa2q(vec3 axis, float angle){return quat(normalize(axis)*sin(angle*0.5),cos(angle*0.5));} \nquat qinv(quat q){return quat(-q.xyz,q.w)/dot(q,q);}//inverse quaternion \nvec3 qmulv(quat q, vec3 p){quat qi=qinv(q),q2=quat(p*qi.w+cross(p,qi.xyz),-dot(p,qi.xyz));\nreturn q.xyz*q2.w+q2.xyz*q.w+cross(q.xyz,q2.xyz);}\n//vec3 qmulv(quat q, vec3 p){return qmulq(q,qmulq(quat(p,0.0),qinv(q))).xyz;}//rotate a vector \nquat qpyr(vec3 o){ o*=0.5; vec3 s=sin(o),c=cos(o); //rotate pitch,yaw,roll in that order \n return quat(s.x*c.y*c.z+s.y*c.x*s.z, s.y*c.x*c.z-s.x*c.y*s.z, s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z); \n} \n \n/*//extras \nquat q2aa(quat q){return quat(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle \nquat qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v \nvec3 vmulq(vec3 p, quat q){return qmulq(qinv(q),qmulq(quat(p,0.0),q)).xyz;}//inverse rotation \nquat qslerp(quat q1, quat q2, float f){ \n float d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta));  \n return normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost);  \n} \n*/ \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n if(fragCoord.y>0.5 || fragCoord.x>1.5)discard; \n vec4 pos; \n quat qrot; \n if(iFrame<2){ \n  pos=vec4(0.1,0.0,0.0,0.01); \n  qrot=normalize(vec4(0.1,0.2,0.3,0.8)); \n }else{ \n  pos=load(0); \n  qrot=load(1); \n  vec3 fw=vec3(0.0,0.0,1.0); \n  fw=qmulv(qrot,fw); \n  vec3 newp=pos.xyz+fw*pos.w; \n  if(newp.y>-1.3)pos.xyz=newp; \n  else{ pos.xz=newp.xz;} //keep above ground\n  if(KeyDown(UP_ARROW))pos.w+=THRUST; \n  if(KeyDown(DOWN_ARROW))pos.w-=THRUST; \n  float roll=0.0; \n  if(KeyDown(LEFT_ARROW))roll-=ROLL; \n  if(KeyDown(RIGHT_ARROW))roll+=ROLL; \n  vec2 mous=vec2(0.0); \n  if(iMouse.z>0.0){ \n   //mous.xy=(iMouse.xy-iMouse.zw)/iResolution.xy; mous.xy*=sign(mous.xy)*mous.xy;\n   mous.xy=(iMouse.xy-iResolution.xy*.5)/iResolution.xy; mous.xy*=sign(mous.xy)*mous.xy;\n  }\n  qrot*=vec4(0.99,1.0,0.99,1.0);//nice little trick to stabilize the flight \n  //x and z rotations go to zero and the quaternian is normalized later  \n  quat qp=qpyr(vec3(-mous.y*ROTATE,mous.x*ROTATE,roll));//finally did the math!! \n  qrot=normalize(qmulq(qrot,qp));//normalize before saving \n }\n store(0,pos,fragColor,fragCoord);//position,velocity \n store(1,qrot,fragColor,fragCoord);//rotation \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 79, 79, 109], [132, 132, 150, 150, 1424], [1440, 1440, 1471, 1471, 1628], [1675, 1675, 1725, 1725, 2621], [2623, 2802, 2830, 2830, 2862], [2882, 2882, 2893, 2893, 2923], [2925, 2925, 2954, 2975, 3069], [3071, 3071, 3089, 3089, 3123], [3123, 3145, 3172, 3172, 3286], [3287, 3383, 3405, 3405, 3493], [3494, 3494, 3532, 3532, 4710]], "test": "untested"}
{"id": "3ldfWr", "name": "Moiré 3d - rev", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled disks. \nHere, the second plates is distorted (show alone on left).\n( you might try a slight perspective effect by changing the coef line 16. )", "tags": ["aliasing", "interference", "moir", "reproduction", "glasspatterns"], "likes": 3, "viewed": 364, "published": 3, "date": "1612538616", "time_retrieved": "2024-07-30T19:40:28.165136", "image_code": "// reverse pattern of https://shadertoy.com/view/wl3fWr\n\n#define D   length( mod( U += T/2. , T ) - k )           //\n#define P   clamp( ( min( D, D ) -.6*k.y )/10. ,0.,1.)   // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O-=O;\n    vec2 R = iResolution.xy,\n        U = 6.*(u-R/2.),\n        V =   U // * mat2(cos(.01 +vec4(0,11,33,0))) \n            + 30.* sin( U*mat2(1,-.7,.4,-1)/300. + iTime ),\n  \n        k = vec2(360)/8., T = vec2( 2, 3.5 )*k;\n    O += U.x>0. ? P : 1.;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 243, 243, 539]], "test": "untested"}
{"id": "WtdfWr", "name": "Moiré 3c - rev", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled disks. \nHere, the second plates rotate over time. \n( you might try a slight perspective effect by changing the coef line 14. )", "tags": ["aliasing", "interference", "moir", "reproduction", "glasspatterns"], "likes": 9, "viewed": 256, "published": 3, "date": "1612538504", "time_retrieved": "2024-07-30T19:40:28.929093", "image_code": "// reverse pattern of https://shadertoy.com/view/wt3fWr\n\n#define D   length( mod( U += T/2. , T ) - k )               //\n#define P   clamp(  ( min( D, D ) -.6*k.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n   vec2 R = iResolution.xy,\n        U = 4.*(u-R/2.),\n        V = U * mat2( cos( .05*iTime + vec4(0,11,33,0) ) ),\n\n        k = R.yy/8., T = vec2( 2, 3.5 )*k;\n    O += P -O;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 248, 248, 461]], "test": "untested"}
{"id": "3tdfWr", "name": "Moiré 3b - rev", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled disks. Slight perspective cause moiré.\nHere, the 2 plates are rotated by pi/2.", "tags": ["aliasing", "interference", "moir", "reproduction", "glasspatterns"], "likes": 3, "viewed": 237, "published": 3, "date": "1612538462", "time_retrieved": "2024-07-30T19:40:29.704021", "image_code": "// reverse pattern of https://shadertoy.com/view/3ldBzM\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( ( min( D, D ) -.6*R.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 3.;\n    vec2 R = iResolution.yy/8., T = vec2( 2, 3.5 )*R;\n    O += P -O;\n\n    U = 1.1*U.yx + 10.*iTime;\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 247, 247, 374]], "test": "untested"}
{"id": "WltfWr", "name": "Moiré 3 - rev", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled disks. Slight perspective cause moiré.", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 3, "viewed": 251, "published": 3, "date": "1612538081", "time_retrieved": "2024-07-30T19:40:30.466981", "image_code": "// reverse pattern of https://shadertoy.com/view/WltBzM\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( ( min( D, D ) -.6*R.y )/6. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 4.;\n    vec2 R = iResolution.yy/12., T = vec2( 2, 3.5 )*R;\n    O += P -O;\n\n    U = 1.1*U + 10.*iTime;\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 247, 247, 372]], "test": "untested"}
{"id": "3ttfWr", "name": "pandora", "author": "YitingLiu", "description": "Creating a trippy kaleidoscopic effect. ", "tags": ["fractal", "texture", "rotate", "kaleidoscopic", "kifs", "trippy", "function", "smoothstep", "angle", "snowflake", "koch", "layering", "system", "iterated"], "likes": 3, "viewed": 302, "published": 3, "date": "1612537124", "time_retrieved": "2024-07-30T19:40:31.239914", "image_code": "// tutorial https://www.youtube.com/watch?v=il_Qg9AqQkE&t=863s \n\n\nvec2 N(float angle){\nreturn vec2(sin(angle),cos(angle));\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    uv.x=abs(uv.x);\n    uv.y+= tan((5./6.)*3.1415)*.5;  // tan(a)=y/0.5 -> y = tan(a)*.5 - how far we need to shift things up \n    vec2 n = N((5./6.)*3.1415);\n\n    float d =dot(uv-vec2(.5,0.),n);\n    uv -=n*max(0.,d)*2.;// only one side is reflected \n    \n    //abs(sin(iTime*0.3)*2.)/abs(sin(iTime*0.3)*8.)\n    n = N(abs(sin(iTime*0.3)*2.)/abs(sin(iTime*0.3)*8.)*iTime*0.01*3.1415)*rotate2d(3.14*iTime*0.05);\n    float scale = 1.;\n    uv.x+=0.5;\n    // col+=smoothstep(.01,.0,abs(d));\n\n    for(int i=0; i<8; i++){\n    float val = 3.;\n      uv *=val;\n      scale *=val;\n      uv.x -=val/2.;\n        \n      uv.x=abs(uv.x);\n      uv.x-=0.5;\n      uv -=n*max(0.,dot(uv,n))*2.;// folding the space - only one side is reflected   \n    }\n    \n \n\n\n    d = length (uv-vec2(clamp(uv.x,-1.,1.),0));\n    col+=smoothstep(1./iResolution.y,.0,d/scale);\n    uv/=scale;\n    uv*=rotate2d(3.14*iTime*0.05);\n    col+= texture(iChannel0, uv*2.+iTime*0.05).ggg;\n    col/= texture(iChannel2, uv*3.+iTime*0.005).rbb;\n    col-= texture(iChannel1, uv*3.+iTime*0.05).gbr;\n    col-= texture(iChannel3, uv*3.+iTime*0.05).grb;\n  \n  \n    fragColor = vec4(col,1.0);\n}   \n\n/**\n    float d = dot(uv,n); //uv.x*n.x+uv.y*n*y; // same as uv.x*0+uv.y*1=uv.y;\n    \n    uv -=n*min(0.,dot(uv,n))*2.;// only one side is reflected \n    col.rg+=uv;\n    col+=smoothstep(.01,.0,abs(d));\n    **/\n    \n    ", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttfWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 86, 86, 124], [125, 125, 153, 153, 239], [241, 241, 298, 298, 1566]], "test": "untested"}
{"id": "wl3fWr", "name": "Moiré 3d", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. \nHere, the second plates is distorted (show alone on left).\n( you might try a slight perspective effect by changing the coef line 17. )", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 8, "viewed": 279, "published": 3, "date": "1612514962", "time_retrieved": "2024-07-30T19:40:32.133525", "image_code": "// variant of https://shadertoy.com/view/wt3fWr\n// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - k )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*k.y )/10. ,0.,1.)   // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n    O-=O;\n    vec2 R = iResolution.xy,\n        U = 6.*(u-R/2.),\n        V =   U // * mat2(cos(.01 +vec4(0,11,33,0))) \n            + 30.* sin( U*mat2(1,-.7,.4,-1)/300. + iTime ),\n  \n        k = vec2(360)/8., T = vec2( 2, 3.5 )*k;\n    O += U.x>0. ? P : 1.;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 293, 293, 589]], "test": "untested"}
{"id": "wt3fWr", "name": "Moiré 3c", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. \nHere, the second plates rotate over time. \n( you might try a slight perspective effect by changing the coef line 16. )", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 7, "viewed": 264, "published": 3, "date": "1612514071", "time_retrieved": "2024-07-30T19:40:33.013173", "image_code": "// variant of https://shadertoy.com/view/3ldBzM\n// variant of https://shadertoy.com/view/WltBzM\n// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - k )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*k.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 u) {\n   vec2 R = iResolution.xy,\n        U = 4.*(u-R/2.),\n        V = U * mat2( cos( .05*iTime + vec4(0,11,33,0) ) ),\n\n        k = R.yy/8., T = vec2( 2, 3.5 )*k;\n    O += P -O;\n\n    U = 1.0*V; // try 1.1\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 341, 341, 554]], "test": "untested"}
{"id": "wt3fDn", "name": "Doorway Transition", "author": "turboplay", "description": "A nice transition from glsl-transitions. Modify the reflection, perspective,depth parameters.", "tags": ["transition"], "likes": 7, "viewed": 517, "published": 3, "date": "1612507221", "time_retrieved": "2024-07-30T19:40:33.778128", "image_code": "\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec2 boundMin = vec2(0.0, 0.0);\nconst vec2 boundMax = vec2(1.0, 1.0);\n\n\n\nbool inBounds (vec2 p) {\n  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));\n}\n\nvec2 project (vec2 p) {\n  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);\n}\n\nvec4 bgColor (vec2 p, vec2 pto,float reflection) {\n  vec4 c = black;\n  pto = project(pto);\n  if (inBounds(pto)) {\n    c += mix(black, texture(iChannel1,p), reflection * mix(1.0, 0.0, pto.y));\n  }\n  return c;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat reflection = 0.4;\nfloat perspective = 0.4;\nfloat depth = 3.;\n\n\n\n    float progress = fract(iTime/4.);\n    vec2 p = fragCoord/iResolution.xy;\n    \n    progress = smoothstep(0., 1., progress);\n    vec2 pfr = vec2(-1.), pto = vec2(-1.);\n     float middleSlit = 2.0 * abs(p.x-0.5) - progress;\n     if (middleSlit > 0.0) {\n    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*progress, 0.0);\n    float d = 1.0/(1.0+perspective*progress*(1.0-middleSlit));\n    pfr.y -= d/2.;\n    pfr.y *= d;\n    pfr.y += d/2.;\n  }\n  float size = mix(1.0, depth, 1.-progress);\n  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);\n  if (inBounds(pfr)) {\n    fragColor = texture(iChannel0,pfr);\n  }\n  else if (inBounds(pto)) {\n    fragColor =texture(iChannel1,pto);\n  }\n  else {\n    fragColor = bgColor(p, pto,reflection);\n  }\n  }", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 92], [219, 219, 243, 243, 312], [314, 314, 337, 337, 388], [390, 390, 440, 440, 599], [605, 605, 662, 662, 1485]], "test": "untested"}
{"id": "tt3fDn", "name": "Crosshatch Transition", "author": "turboplay", "description": "A nice transition from glsl-transitions. Modify the threshold/fadeEdge, center parameters. ", "tags": ["transition", "crossfade"], "likes": 5, "viewed": 538, "published": 3, "date": "1612506394", "time_retrieved": "2024-07-30T19:40:34.618880", "image_code": "\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float threshold = 3.;\n    float fadeEdge = 0.1;\n    vec2 center = vec2(0.5);\n\n\n    float iTime2 = fract(iTime/4.);\n    vec2 uv = fragCoord/iResolution.xy;\n    float dist = distance(center, uv) / threshold;\n    float r = iTime2 - min(rand(vec2(uv.y, 0.0)), rand(vec2(0.0, uv.x)));\n    vec4 c1 = texture(iChannel0,uv);\n    vec4 c2 = texture(iChannel1,uv);\n    fragColor = mix(c1, c2, mix(0.0, mix(step(dist, r), 1.0, smoothstep(1.0-fadeEdge, 1.0, iTime2)), smoothstep(0.0, fadeEdge, iTime2)));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 92], [94, 94, 151, 151, 649]], "test": "untested"}
{"id": "ttcBWn", "name": "Strange Life", "author": "oneshade", "description": "An interesting variant of fractal noise.", "tags": ["noise", "strange", "hairynoise", "hairy"], "likes": 12, "viewed": 291, "published": 3, "date": "1612493619", "time_retrieved": "2024-07-30T19:40:35.464619", "image_code": "float WhiteNoise(in vec3 p) {\n    return fract(1853.475 * cos(dot(p, vec3(1385.846, 1548.847, 4.837))));\n}\n\nfloat SmoothNoise(in vec3 p) {\n    vec3 c = floor(p);\n    vec3 l = fract(p);\n    l *= l * (3.0 - 2.0 * l);\n\n    float ldb = WhiteNoise(c);\n    float rdb = WhiteNoise(c + vec3(1.0, 0.0, 0.0));\n    float lub = WhiteNoise(c + vec3(0.0, 1.0, 0.0));\n    float rub = WhiteNoise(c + vec3(1.0, 1.0, 0.0));\n    float ldf = WhiteNoise(c + vec3(0.0, 0.0, 1.0));\n    float rdf = WhiteNoise(c + vec3(1.0, 0.0, 1.0));\n    float luf = WhiteNoise(c + vec3(0.0, 1.0, 1.0));\n    float ruf = WhiteNoise(c + 1.0);\n\n    return mix(mix(mix(ldb, rdb, l.x), mix(lub, rub, l.x), l.y),\n               mix(mix(ldf, rdf, l.x), mix(luf, ruf, l.x), l.y),\n               l.z);\n}\n\nfloat HairyNoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        // Magic numbers\n        p.xz *= mat2(-0.48406725864, -0.87503079323, 0.87503079323, -0.48406725864);\n        p.yz *= mat2(0.15022546991, -0.98865176285, 0.98865176285, 0.15022546991);\n\n        value += abs(SmoothNoise(p) * 2.0 - 1.0) * nscale;\n        tscale += nscale;\n        nscale *= 0.25;\n\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(pow(1.0 - HairyNoise(vec3(uv * 5.0, 0.25 * iTime), 1.0, 10.0), 5.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 106], [108, 108, 138, 138, 755], [757, 757, 820, 820, 1324], [1326, 1326, 1381, 1381, 1540]], "test": "untested"}
{"id": "tl3BWn", "name": "For Mickey", "author": "MacLin", "description": "for mickey test", "tags": ["test"], "likes": 1, "viewed": 284, "published": 3, "date": "1612493298", "time_retrieved": "2024-07-30T19:40:36.524784", "image_code": "/*\nMIT License\n\nCopyright (c) 2019 - 2021 Dimas \"Dimev\", \"Skythedragon\" Leenman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nUpdate 1 (25-9-2019): added 2 lines to prevent mie from shining through objects inside the atmosphere\nUpdate 2 (2-10-2019): made use of HW_PERFORMANCE to improve performance on mobile (reduces number of samples), also added a sun\nUpdate 3 (5-10-2019): added a license\nUpdate 4 (28-11-2019): atmosphere now correctly blocks light from the scene passing through, and added an ambient scattering term\nUpdate 5 (28-11-2019): mouse drag now changes the time of day\nUpdate 6 (28-11-2019): atmosphere now doesn't use the ray sphere intersect function, meaning it's only one function\nUpdate 7 (22-12-2019): Compacted the mie and rayleigh parts into a single vec2 + added a basic skylight\nUpdate 8 (15-5-2020): Added ozone absorption (Can also be used as absorption in general)\n\nScattering works by calculating how much light is scattered to the camera on a certain path/\nThis implementation does that by taking a number of samples across that path to check the amount of light that reaches the path\nand it calculates the color of this light from the effects of scattering.\n\nThere are two types of scattering, rayleigh and mie\nrayleigh is caused by small particles (molecules) and scatters certain colors better than others (causing a blue sky on earth)\nmie is caused by bigger particles (like water droplets), and scatters all colors equally, but only in a certain direction. \nMie scattering causes the red sky during the sunset, because it scatters the remaining red light\n\nTo know where the ray starts and ends, we need to calculate where the ray enters and exits the atmosphere\nWe do this using a ray-sphere intersect\n\nThe scattering code is based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\nwith some modifications to allow moving the planet, as well as objects inside the atmosphere, correct light absorbsion\nfrom objects in the scene and an ambient scattering term tp light up the dark side a bit if needed\n\nthe camera also moves up and down, and the sun rotates around the planet as well\n\nNote: \tBecause rayleigh is a long word to type, I use ray instead on most variable names\n\t\tthe same goes for position (which becomes pos), direction (which becomes dir) and optical (becomes opt)\n*/\n\n// first, lets define some constants to use (planet radius, position, and scattering coefficients)\n#define PLANET_POS vec3(0.0) /* the position of the planet */\n#define PLANET_RADIUS 6371e3 /* radius of the planet */\n#define ATMOS_RADIUS 6471e3 /* radius of the atmosphere */\n// scattering coeffs\n#define RAY_BETA vec3(5.5e-6, 13.0e-6, 22.4e-6) /* rayleigh, affects the color of the sky */\n#define MIE_BETA vec3(21e-6) /* mie, affects the color of the blob around the sun */\n#define AMBIENT_BETA vec3(0.0) /* ambient, affects the scattering color when there is no lighting from the sun */\n#define ABSORPTION_BETA vec3(2.04e-5, 4.97e-5, 1.95e-6) /* what color gets absorbed by the atmosphere (Due to things like ozone) */\n#define G 0.7 /* mie scattering direction, or how big the blob around the sun is */\n// and the heights (how far to go up before the scattering has no effect)\n#define HEIGHT_RAY 8e3 /* rayleigh height */\n#define HEIGHT_MIE 1.2e3 /* and mie */\n#define HEIGHT_ABSORPTION 30e3 /* at what height the absorption is at it's maximum */\n#define ABSORPTION_FALLOFF 3e3 /* how much the absorption decreases the further away it gets from the maximum height */\n// and the steps (more looks better, but is slower)\n// the primary step has the most effect on looks\n#if HW_PERFORMANCE==0\n// edit these if you are on mobile\n#define PRIMARY_STEPS 12 \n#define LIGHT_STEPS 4\n# else\n// and these on desktop\n#define PRIMARY_STEPS 64 /* primary steps, affects quality the most */\n#define LIGHT_STEPS 4 /* light steps, how much steps in the light direction are taken */\n#endif\n\n// camera mode, 0 is on the ground, 1 is in space, 2 is moving, 3 is moving from ground to space\n#define CAMERA_MODE 0\n\n/*\nNext we'll define the main scattering function.\nThis traces a ray from start to end and takes a certain amount of samples along this ray, in order to calculate the color.\nFor every sample, we'll also trace a ray in the direction of the light, \nbecause the color that reaches the sample also changes due to scattering\n*/\nvec3 calculate_scattering(\n\tvec3 start, \t\t\t\t// the start of the ray (the camera position)\n    vec3 dir, \t\t\t\t\t// the direction of the ray (the camera vector)\n    float max_dist, \t\t\t// the maximum distance the ray can travel (because something is in the way, like an object)\n    vec3 scene_color,\t\t\t// the color of the scene\n    vec3 light_dir, \t\t\t// the direction of the light\n    vec3 light_intensity,\t\t// how bright the light is, affects the brightness of the atmosphere\n    vec3 planet_position, \t\t// the position of the planet\n    float planet_radius, \t\t// the radius of the planet\n    float atmo_radius, \t\t\t// the radius of the atmosphere\n    vec3 beta_ray, \t\t\t\t// the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\n    vec3 beta_mie, \t\t\t\t// the amount mie scattering scatters colors\n    vec3 beta_absorption,   \t// how much air is absorbed\n    vec3 beta_ambient,\t\t\t// the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter\n    float g, \t\t\t\t\t// the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\n    float height_ray, \t\t\t// how high do you have to go before there is no rayleigh scattering?\n    float height_mie, \t\t\t// the same, but for mie\n    float height_absorption,\t// the height at which the most absorption happens\n    float absorption_falloff,\t// how fast the absorption falls off from the absorption height\n    int steps_i, \t\t\t\t// the amount of steps along the 'primary' ray, more looks better but slower\n    int steps_l \t\t\t\t// the amount of steps along the light ray, more looks better but slower\n) {\n    // add an offset to the camera position, so that the atmosphere is in the correct position\n    start -= planet_position;\n    // calculate the start and end position of the ray, as a distance along the ray\n    // we do this with a ray sphere intersect\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (atmo_radius * atmo_radius);\n    float d = (b * b) - 4.0 * a * c;\n    \n    // stop early if there is no intersect\n    if (d < 0.0) return scene_color;\n    \n    // calculate the ray length\n    vec2 ray_length = vec2(\n        max((-b - sqrt(d)) / (2.0 * a), 0.0),\n        min((-b + sqrt(d)) / (2.0 * a), max_dist)\n    );\n    \n    // if the ray did not hit the atmosphere, return a black color\n    if (ray_length.x > ray_length.y) return scene_color;\n    // prevent the mie glow from appearing if there's an object in front of the camera\n    bool allow_mie = max_dist > ray_length.y;\n    // make sure the ray is no longer than allowed\n    ray_length.y = min(ray_length.y, max_dist);\n    ray_length.x = max(ray_length.x, 0.0);\n    // get the step size of the ray\n    float step_size_i = (ray_length.y - ray_length.x) / float(steps_i);\n    \n    // next, set how far we are along the ray, so we can calculate the position of the sample\n    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere\n    // if it's inside, it should start at the position of the camera\n    // the min statement makes sure of that\n    float ray_pos_i = ray_length.x;\n    \n    // these are the values we use to gather all the scattered light\n    vec3 total_ray = vec3(0.0); // for rayleigh\n    vec3 total_mie = vec3(0.0); // for mie\n    \n    // initialize the optical depth. This is used to calculate how much air was in the ray\n    vec3 opt_i = vec3(0.0);\n    \n    // also init the scale height, avoids some vec2's later on\n    vec2 scale_height = vec2(height_ray, height_mie);\n    \n    // Calculate the Rayleigh and Mie phases.\n    // This is the color that will be scattered for this ray\n    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them\n    float mu = dot(dir, light_dir);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float phase_ray = 3.0 / (50.2654824574 /* (16 * pi) */) * (1.0 + mumu);\n    float phase_mie = allow_mie ? 3.0 / (25.1327412287 /* (8 * pi) */) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg)) : 0.0;\n    \n    // now we need to sample the 'primary' ray. this ray gathers the light that gets scattered onto it\n    for (int i = 0; i < steps_i; ++i) {\n        \n        // calculate where we are along this ray\n        vec3 pos_i = start + dir * (ray_pos_i + step_size_i * 0.5);\n        \n        // and how high we are above the surface\n        float height_i = length(pos_i) - planet_radius;\n        \n        // now calculate the density of the particles (both for rayleigh and mie)\n        vec3 density = vec3(exp(-height_i / scale_height), 0.0);\n        \n        // and the absorption density. this is for ozone, which scales together with the rayleigh, \n        // but absorbs the most at a specific height, so use the sech function for a nice curve falloff for this height\n        // clamp it to avoid it going out of bounds. This prevents weird black spheres on the night side\n        density.z = clamp((1.0 / cosh((height_absorption - height_i) / absorption_falloff)) * density.x, 0.0, 1.0);\n        density *= step_size_i;\n        \n        // Add these densities to the optical depth, so that we know how many particles are on this ray.\n        opt_i += density;\n\n        // Calculate the step size of the light ray.\n        // again with a ray sphere intersect\n        // a, b, c and d are already defined\n        a = dot(light_dir, light_dir);\n        b = 2.0 * dot(light_dir, pos_i);\n        c = dot(pos_i, pos_i) - (atmo_radius * atmo_radius);\n        d = (b * b) - 4.0 * a * c;\n\n        // no early stopping, this one should always be inside the atmosphere\n        // calculate the ray length\n        float step_size_l = (-b + sqrt(d)) / (2.0 * a * float(steps_l));\n\n        // and the position along this ray\n        // this time we are sure the ray is in the atmosphere, so set it to 0\n        float ray_pos_l = 0.0;\n\n        // and the optical depth of this ray\n        vec3 opt_l = vec3(0.0);\n        \n        // now sample the light ray\n        // this is similar to what we did before\n        for (int l = 0; l < steps_l; ++l) {\n\n            // calculate where we are along this ray\n            vec3 pos_l = pos_i + light_dir * (ray_pos_l + step_size_l * 0.5);\n\n            // the heigth of the position\n            float height_l = length(pos_l) - planet_radius;\n\n            // calculate the particle density, and add it\n            vec3 density_l = vec3(exp(-height_l / scale_height), 0.0);\n            density_l.z = clamp((1.0 / cosh((height_absorption - height_l) / absorption_falloff)) * density_l.x, 0.0, 1.0);\n            opt_l += density_l * step_size_l;\n\n            // and increment where we are along the light ray.\n            ray_pos_l += step_size_l;\n            \n        }\n        \n        // Now we need to calculate the attenuation\n        // this is essentially how much light reaches the current sample point due to scattering\n        vec3 attn = exp(-(beta_mie * (opt_i.y + opt_l.y) + beta_ray * (opt_i.x + opt_l.x) + beta_absorption * (opt_i.z + opt_l.z)));\n\n        // accumulate the scattered light (how much will be scattered towards the camera)\n        total_ray += density.x * attn;\n        total_mie += density.y * attn;\n\n        // and increment the position on this ray\n        ray_pos_i += step_size_i;\n    \t\n    }\n    \n    // calculate how much light can pass through the atmosphere\n    vec3 opacity = exp(-(beta_mie * opt_i.y + beta_ray * opt_i.x + beta_absorption * opt_i.z));\n    \n\t// calculate and return the final color\n    return (\n        \tphase_ray * beta_ray * total_ray // rayleigh color\n       \t\t+ phase_mie * beta_mie * total_mie // mie\n            + opt_i.x * beta_ambient // and ambient\n    ) * light_intensity + scene_color * opacity; // now make sure the background is rendered correctly\n}\n\n/*\nA ray-sphere intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray sphere intersect built in\n*/\n\nvec2 ray_sphere_intersect(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\nTo make the planet we're rendering look nicer, we implemented a skylight function here\n\nEssentially it just takes a sample of the atmosphere in the direction of the surface normal\n*/\nvec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {\n\n    // slightly bend the surface normal towards the light direction\n    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));\n    \n    // and sample the atmosphere\n    return calculate_scattering(\n    \tsample_pos,\t\t\t\t\t\t// the position of the camera\n        surface_normal, \t\t\t\t// the camera vector (ray direction of this pixel)\n        3.0 * ATMOS_RADIUS, \t\t\t// max dist, since nothing will stop the ray here, just use some arbitrary value\n        background_col,\t\t\t\t\t// scene color, just the background color here\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height\n        LIGHT_STEPS, \t\t\t\t\t// steps in the ray direction\n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n}\n\n/*\nThe following function returns the scene color and depth \n(the color of the pixel without the atmosphere, and the distance to the surface that is visible on that pixel)\n\nin this case, the function renders a green sphere on the place where the planet should be\ncolor is in .xyz, distance in .w\n\nI won't explain too much about how this works, since that's not the aim of this shader\n*/\nvec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {\n    \n    // the color to use, w is the scene depth\n    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);\n    \n    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white\n    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);\n    \n    // get where the ray intersects the planet\n    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); \n    \n    // if the ray hit the planet, set the max distance to that ray\n    if (0.0 < planet_intersect.y) {\n    \tcolor.w = max(planet_intersect.x, 0.0);\n        \n        // sample position, where the pixel is\n        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;\n        \n        // and the surface normal\n        vec3 surface_normal = normalize(sample_pos);\n        \n        // get the color of the sphere\n        color.xyz = vec3(0.0, 0.25, 0.05); \n        \n        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law\n        vec3 N = surface_normal;\n        vec3 V = -dir;\n        vec3 L = light_dir;\n        float dotNV = max(1e-6, dot(N, V));\n        float dotNL = max(1e-6, dot(N, L));\n        float shadow = dotNL / (dotNL + dotNV);\n        \n        // apply the shadow\n        color.xyz *= shadow;\n        \n        // apply skylight\n        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);\n    }\n    \n\treturn color;\n}\n\n/*\nnext, we need a way to do something with the scattering function\n\nto do something with it we need the camera vector (which is the ray direction) of the current pixel\nthis function calculates it\n*/\nvec3 get_camera_vector(vec3 resolution, vec2 coord) {\n\tvec2 uv    = coord.xy / resolution.xy - vec2(0.5);\n         uv.x *= resolution.x / resolution.y;\n\n    return normalize(vec3(uv.x, uv.y, -1.0));\n}\n\n/*\nFinally, draw the atmosphere to screen\n\nwe first get the camera vector and position, as well as the light dir\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // get the camera vector\n    vec3 camera_vector = get_camera_vector(iResolution, fragCoord);\n    \n    // get the camera position, switch based on the defines\n#if CAMERA_MODE==0\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 100.0, 0.0);\n#endif\n#if CAMERA_MODE==1\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS , ATMOS_RADIUS);\n#endif\n#if CAMERA_MODE==2\n    vec3 camera_position = vec3(0.0, ATMOS_RADIUS + (-cos(iTime / 2.0) * (ATMOS_RADIUS - PLANET_RADIUS - 1.0)), 0.0);\n#endif\n#if CAMERA_MODE==3\n    float offset = (1.0 - cos(iTime / 2.0)) * ATMOS_RADIUS;\n    vec3 camera_position = vec3(0.0, PLANET_RADIUS + 1.0, offset);\n#endif\n    // get the light direction\n    // also base this on the mouse position, that way the time of day can be changed with the mouse\n    float theta = (iMouse.y - iResolution.y/2.0) / (iResolution.y/2.0) * (3.14/4.0);\n    float phi   = (iMouse.x + iResolution.x) / (iResolution.x/2.0) * (3.14/2.0);\n\n    float y = sin(theta);\n    float x = cos(theta) * cos(phi);\n    float z = cos(theta) * sin(phi);\n    \n    vec3 light_dir = normalize(vec3(x, y, z));\n    \n    // get the scene color and depth, color is in xyz, depth in w\n    // replace this with something better if you are using this shader for something else\n    vec4 scene = render_scene(camera_position, camera_vector, light_dir);\n    \n    // the color of this pixel\n    vec3 col = vec3(0.0);//scene.xyz;\n    \n    // get the atmosphere color\n    col += calculate_scattering(\n    \tcamera_position,\t\t\t\t// the position of the camera\n        camera_vector, \t\t\t\t\t// the camera vector (ray direction of this pixel)\n        scene.w, \t\t\t\t\t\t// max dist, essentially the scene depth\n        scene.xyz,\t\t\t\t\t\t// scene color, the color of the current pixel being rendered\n        light_dir,\t\t\t\t\t\t// light direction\n        vec3(40.0),\t\t\t\t\t\t// light intensity, 40 looks nice\n        PLANET_POS,\t\t\t\t\t\t// position of the planet\n        PLANET_RADIUS,                  // radius of the planet in meters\n        ATMOS_RADIUS,                   // radius of the atmosphere in meters\n        RAY_BETA,\t\t\t\t\t\t// Rayleigh scattering coefficient\n        MIE_BETA,                       // Mie scattering coefficient\n        ABSORPTION_BETA,                // Absorbtion coefficient\n        AMBIENT_BETA,\t\t\t\t\t// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it\n        G,                          \t// Mie preferred scattering direction\n        HEIGHT_RAY,                     // Rayleigh scale height\n        HEIGHT_MIE,                     // Mie scale height\n        HEIGHT_ABSORPTION,\t\t\t\t// the height at which the most absorption happens\n        ABSORPTION_FALLOFF,\t\t\t\t// how fast the absorption falls off from the absorption height \n        PRIMARY_STEPS, \t\t\t\t\t// steps in the ray direction \n        LIGHT_STEPS \t\t\t\t\t// steps in the light direction\n    );\n        \n    // apply exposure, removing this makes the brighter colors look ugly\n    // you can play around with removing this\n    col = 1.0 - exp(-col);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BWn.jpg", "access": "api", "license": "mit", "functions": [[5035, 5358, 7017, 7112, 13245], [13438, 13438, 13600, 13737, 14016], [14018, 14204, 14294, 14363, 15946], [15948, 16335, 16390, 16441, 17895], [17897, 18097, 18150, 18150, 18297], [18299, 18415, 18470, 18504, 21578]], "test": "untested"}
{"id": "tt3BWn", "name": "Missile Reticle Test!", "author": "Dutracgi", "description": "Doing some tests to understand how it works... links for more info below:\nhttps://medium.com/@OpenSeason/1946-germany-has-been-defeated-and-its-military-technology-put-under-the-microscope-the-west-e60b82926b40\n", "tags": ["rocket", "reticle", "gun", "missile", "segments", "war", "guidance"], "likes": 1, "viewed": 314, "published": 3, "date": "1612491911", "time_retrieved": "2024-07-30T19:40:37.363542", "image_code": "//Thanks to https://www.shadertoy.com/view/4tl3Dj for the stripes/sections!\n\nfloat circle(vec2 uv, vec2 off, float r){\n    float cir = pow(uv.x-off.x,2.) + pow(uv.y-off.y,2.);\n    return step(cir,pow(r,2.));\n}\nfloat counter =0.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5,0.5);\n    //Aspect ratio correction\n    uv.x *= iResolution.x/iResolution.y;\n      \n    //Calculate the angle from the center + offset\n    uv+=vec2(0.3,0.);\n    vec2 uvo = uv + 0.1*vec2(cos(0.5*iTime),sin(0.5*iTime));\n    float angle = atan(uvo.y,uvo.x)+(2.*iTime);\n    \n    //8 strips representing the offset reticle.\n    vec3 intensity = vec3(step(0.01,sin(angle*8.0)) * circle(uvo,vec2(0),0.5));\n    \n    //Target position -> fixed\n    vec2 uvx = vec2(0.0);\n    \n    //Draw target\n    float cx = circle(uv,uvx,0.05);\n    intensity+= vec3(cx,-cx,-cx);\n    \n    //How to send the target intersection to my scope shader -> target over black strip = hit ?\n    \n    //if(hit) square wave = 1.0 else square wave = 0.0\n    \n    //https://www.shadertoy.com/view/wldfWr <- This one\n    \n    \n    //Set the final color\n    fragColor = vec4(intensity, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 118, 118, 209], [229, 229, 286, 286, 1195]], "test": "untested"}
{"id": "wttBzM", "name": "4D Wild Kifs", "author": "iapafoto", "description": "Alien mineral stones and creatures", "tags": ["fractal", "ifs", "4d", "kifs"], "likes": 38, "viewed": 895, "published": 3, "date": "1612476326", "time_retrieved": "2024-07-30T19:40:38.140464", "image_code": "#define AA\n#define iTime (iTime + cos(.75*iTime)-17.)\nvoid mainImage( out vec4 O, in vec2 U ) { \n    O = texture(iChannel0, U/iResolution.xy);\n\n#ifdef AA\n    if (O.w < DIST_MAX) {\n        vec4 T;         \n        for (float x=-.3; x<.4; x+=.6) {              \n            for (float y=-.3; y<.4; y+=.6) {  \n                mainImage2(T, U+vec2(x,y), iResolution.xy, iMouse.xy, iTime);  \n                O += T;\n            }\n        }\n        O /= 5.;\n    }\n#endif\n\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by sebastien durand - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ----------------------------\n// based on [wyatt] kaleidoscope iterative function - https://www.shadertoy.com/view/MdKyRw\n// ----------------------------\n\n\n// Kifs paremeters\n#define ITER 17\n#define SCALE .766\n#define ADD -.75*vec4(3.,-.075,0.,2.3)\n\n\n// Ray Marching parameters\n#define RAY_STEP 100\n#define DIST_MAX 5.5\n\nmat4 rot1, mRot;\nvec4 closest = vec4(999.,0,0,0);\n\n// 4D adaptation of Kif fractal\nvec4 map(vec4 p) {\n    vec4 ot = vec4(0);\n    float t = .09;\n    for (int i = 0; i < ITER; i++) {\n        t = t*SCALE;\n        p += t*ADD;      \n        p.wxyz *= mRot;\n        p = abs(p) - t;\n        ot += p/t;\n    }\n    return vec4((length(p)-2.*t),         // Distance\n                4.*ot.xwz/(pow(abs(ot.y),1.7)+.01)); // Color (4th Dimension give electric colors tuch !!!)\n}\n\nvec4 castRay(vec4 ro, vec4 rd) {\n\tconst float precis = .005;\n    float h = precis*2., t = 1.;\n\tvec4 res;\n    closest = vec4(999.,0,0,0);\n    for (int i=0; i<RAY_STEP; i++ ) {\n        if (abs(h)<precis || t>DIST_MAX) break;\n        t += h;\n        res = map( ro+rd*t );\n        h = res.x;\n        if (h < closest.x) // get closest for halo\n            closest.x = h;\n        closest.yzw += res.yzw; // halo color\n    }\n    return vec4( t, res.yzw );\n}\n\nfloat softshadow(vec4 ro, vec4 rd, float mint) {\n\tfloat res = 1.,\n          h,t = mint;\n    for( int i=0; i<16; i++ ) {\n        h = map( ro + rd*t ).x;\n        res = min( res, 7.*h/t );\n        t += .028;\n    }\n    return clamp( res-.6, .0, 1. );\n}\n\nvec4 calcNormal(vec4 p) {\n    const vec2 e = vec2( 1e-3, 0.);\n\treturn normalize(vec4(\n\t    map(p+e.xyyy).x - map(p-e.xyyy).x,\n\t    map(p+e.yxyy).x - map(p-e.yxyy).x,\n\t    map(p+e.yyxy).x - map(p-e.yyxy).x,\n\t\tmap(p+e.yyyx).x - map(p-e.yyyx).x\n\t));\n}\n\nfloat calcAO(vec4 p, vec4 n ){\n\tfloat dd, hr, ao = 0., k = 1.;\n    vec4 pos; \n    for( int aoi=0; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        pos =  n * hr + p;\n        ao += -(map(pos).x-hr)*k;\n        k *= .75;\n    }\n    return clamp( 1. - 4.*ao, 0., 1. );\n}\n\nvec3 render(vec4 ro, vec4 rd , vec3 backColor, out float d, vec4 lig){ \n    vec3 col;\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n\tvec3 uvw = .85*res.yzw;\n    \n    if (t<DIST_MAX) {\n        vec4 pos = ro + t*rd,\n             nor = calcNormal( pos );\n\n\t\tcol = vec3(.4) + .6*abs(uvw);\n\t\t\n        float ao = calcAO( pos, nor ); ao*=ao;\n        float dif = clamp( dot( nor, lig ), 0., 1. ),\n              bac = clamp( dot( nor, normalize(vec4(-lig.x,0.,-lig.z,0.))), 0., 1. )*clamp(1.-pos.y,0.,1.);\n\n\t\tfloat sh = 1.;\n\t\tif (dif>.02) { \n            sh = softshadow( pos, lig, .025); \n            dif *= sh; \n        }\n\n\t\tvec3 brdf =  .1*vec3(.10,.11,.13)*ao;\n             brdf += .2*bac*vec3(.15)*ao;\n             brdf += .8*dif*vec3(1,.9,.7);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0., 1. ),\n              spe = sh*pow(pp,16.),\n              fre = ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2. );\n\n\t\tcol = col*brdf + 2.*(.5+.5*col)*spe + .4*fre*(.6+.4*col);\n\t\n    } else {\n        col = mix(backColor, clamp(.004*closest.yzw,0.,1.), smoothstep(.42,0.,pow(closest.x,.4)));\n    }\n    \n    d = t;\n\treturn vec3( clamp(col,0.,1.) );\n}\n\n// Rotation Matrix to apply to 4D objects\nmat4 Rot4(float a, float b, float c) {        \n    float c1 = cos(a), s1 = sin(a), \n          c2 = cos(b), s2 = sin(b), \n          c3 = cos(c), s3 = sin(c);\t\n    return mat4(c2,  s2*s3,   0, -s2*c3,   \n                 0,  c1*c3, -s1,  c1*s3,\n                 0,  c3*s1,  c1,  s1*s3,\n                s2, -c2*s3,   0,  c2*c3);\n}\n\n\nvoid mainImage2(out vec4 fragColor, vec2 fragCoord, vec2 R, vec2 M, float iTime ) {\n\n    vec2 q = fragCoord.xy/R.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= R.x/R.y;\n    \n    // Noisy background\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453123));\t\n\tvec3 colorSum = .75*(vec3(.0512) + .05*fract(sin(h)*43758.5453123));\n    \n    float d = 999.;\n    if (length(p)<.92) {\n        \n        vec2 mo = M.xy/R.xy;\t \n        float time = .5*iTime;\n        // Rotations\n        mRot = Rot4(.1*time, .351*time+2., .232*time+1.3);\n        rot1 = Rot4((iTime-3.)/2.031, 1.+(iTime-3.)/2.1, .1*iTime);\n        \n        // Camera (real cam4D definition available at: https://www.shadertoy.com/view/4tX3Rn)\n        vec4\n            ro = vec4(3.2*cos(.24*iTime + 6.*mo.x+ 1.), 1.5 + 2.*mo.y, 3.2*sin(.24*iTime+ 6.*mo.x+1.),0),\n            ta = vec4(0),\n            cw = normalize( ta-ro ),\n            cp = vec4(0,1,0,0),\n            cu = normalize(vec4(cross(cw.xyz,cp.xyz),0)),\n            cv = normalize(vec4(cross(cu.xyz,cw.xyz),0)),\n            rd = normalize( p.x*cu + p.y*cv + 2.5*cw ),\n            light = normalize(-cw*.5-cu+cv+.5*cp);\n\t\t\n        // Rotation of 4D scene\n        ro *= rot1;\n    \trd *= rot1;\n        light *= rot1;\n        \n        // Render\n\t\tcolorSum = render( ro, rd, colorSum, d, light);\n    }\n    \n    // Post process\n    vec3 col = pow(colorSum.xyz,vec3(.56));\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .5);    \n\tfragColor = vec4(col, d);\n}\n\n", "buffer_a_code": "#define iTime (iTime + cos(.75*iTime)-17.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    mainImage2(fragColor, fragCoord, iResolution.xy, iMouse.xy, iTime);  \n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 95, 95, 467]], "test": "untested"}
{"id": "3lcfWn", "name": "Day 415", "author": "jeyko", "description": "pot", "tags": ["mdtmjvm"], "likes": 23, "viewed": 424, "published": 3, "date": "1612475777", "time_retrieved": "2024-07-30T19:40:39.034075", "image_code": "// http://roy.red/infinite-regression-.html#infinite-regression\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= 0.99;\n    fragCoord += 0.5*iResolution.xy;\n    \n    float n1d = texelFetch(iChannel1,ivec2(mod(fragCoord + vec2(float(iFrame),0.),iResolution.xy/4.)),0).x;\n    vec3 n  = texelFetch(iChannel1,ivec2(mod(fragCoord  + n1d*200. ,iResolution.xy/4.)),0).xyz;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor.xyz =texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.7,1.1,1.5));\n    \n    //fragColor.xyz = 1. - fragColor.xyz;\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.5545 - n*0.15));\n    \n    \n    //fragColor.xyz *= 1. - dot(uv,uv)*0.4;\n    \n    \n    fragColor.xyz += n*0.15;\n    \n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\n\n#define pmod(p,a) mod(p - 0.5*(a),(a)) - 0.5*(a)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(0.5);\n    float amp = 1.;\n    float gain = 0.9 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp = 2.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*(1.4 - 0.4*smoothstep(0.5,1.,iTime-2.));\n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 uvuv = uv;\n    float a = 0.;\n    \n    \n    \n    \n    float s = 4.;\n    vec2 offs = vec2(0);\n    \n    \n    float t = iTime*0.1;\n    t = 35.*0.1 - t;    \n        \n    float unenv = smoothstep(1.,0.9,mod(t/2., 2.));\n    unenv = 1.;\n    unenv *= 1.- smoothstep(0.8,1.,t - 2.);\n    \n    if(iMouse.z < 1.){\n    \n        //float id\n        float side = mod(floor(t/2.), 2.)*2. - 1.;\n        //t = mod(t,4.);\n        side = sign(-1.);\n        \n        offs = vec2(\n            0. + side*smoothstep(0.,0.1,t/1.-1.)*s + 0.,0. + sin(iTime)*0.00001\n        );\n    } else {\n        offs = vec2(\n            0. + muv.x*s,0. + muv.y*s*iResolution.x/iResolution.y\n        );\n    }\n    \n    \n    float zoomAmt = 0.95;\n    \n    \n    float zoomA = mix( 0., 1., abs(offs.x)/s);\n    float zoomB = smoothstep(0.,0.8,t - 1.)*(1.-zoomAmt)*0.999;\n    \n    zoomB *= zoomA;\n    zoomA *= zoomAmt;\n    \n    \n    if(iMouse.z < 1.){\n        zoomA *= unenv;\n        zoomB *= unenv;\n        offs *= unenv;\n    }\n    \n    \n    //*zoomAmt\n    float zoom = 6.*(1. - \n            + zoomA\n            - zoomB) + sin(iTime)*0. - 0.;\n    \n    \n    uv *= zoom;\n    \n    uv += offs;\n    \n    \n    \n    //uv = pmod(uv,0.76);\n    \n    \n    \n    \n    vec2 ouv = uv;\n    \n    uv.x = abs(uv.x);\n    \n    float scale = 1./pow(2., floor(log2(\n            abs(\n                max(\n                (mod(abs(uv.x),8.)) - 4.,\n                (mod(abs(uv.y),8.)) - 4.\n                )\n            )\n        )) );\n    \n    \n    vec2 id = floor(uv*scale);\n    vec2 fuv = fract(uv*scale);\n    \n    \n    fuv = abs(fuv - 0.5) - 0.5;\n    float d = abs(fuv.x);\n    \n    d = min(d,abs(fuv.y));\n    \n    d /= scale;\n    \n    float n = cyclicNoise(vec3(uvuv,floor(iTime*10.))*(51.), false, 0.); \n    \n    //d -= n*0.0001/dFdx(ouv.x);\n    d -= n*dFdx(ouv.x)*1.;\n    \n    \n    \n    if(iFrame > 2){\n        //vec2 uv = fragCoord/iResolution.xy;\n        vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n        //uv -= scale*0.1;\n        //uv -= 0.5;\n        uv -= id/scale - offs;\n        uv*=rot(0.3 + iTime*0.02 + id.x + sin(id.y));\n        \n        uv += id/scale - offs;\n        \n        uv *= iResolution.y;\n        uv += 0.5*iResolution.xy;\n        uv /= iResolution.xy;\n        //uv += 0.5;\n        fragColor.xyz =texture(iChannel0,uv).xyz*0.5;\n    } else {\n        fragColor.xyz -= fragColor.xyz ;\n    }\n    \n    fragColor.xyz = mix( fragColor.xyz,vec3(1.),smoothstep(dFdx(ouv.x),0.,d - 0.0));\n    \n    n = cyclicNoise(vec3(uvuv,4.)*140., false, 0.); \n    \n    d = abs(abs(uvuv.x) - iResolution.x/iResolution.y*0.5) - n*0.005;\n    \n    d = min(d,abs(abs(uvuv.y) - 0.5) - n*0.005);\n    \n    fragColor.xyz = mix( fragColor.xyz,vec3(1.),smoothstep(dFdx(uvuv.x),0.,d ));\n    \n    \n    \n    \n    \n    \n    \n    //fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 122, 847]], "test": "untested"}
{"id": "WlGyWt", "name": "Block city", "author": "z0rg", "description": "A fun project far from the original intent but who cares ?\nThe code is provided as is whithout any warranty :)", "tags": ["city", "block"], "likes": 1, "viewed": 326, "published": 3, "date": "1612468170", "time_retrieved": "2024-07-30T19:40:39.799030", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x, l.y), l.z);\n}\n\nfloat getFog(float dist, float offset, float density)\n{\n    return exp((-dist+max(offset, 0.))*density);\n}\n\nvec2 map2(vec3 p)\n{\n    vec2 lim = vec2(1.25);\n    vec2 rep = vec2(1.);\n    ivec2 idx;\n    \n    vec3 pBat = p;\n    idx = ivec2(((pBat.xz+rep*.5) / rep));\n    vec2 fidx = vec2(float(idx.x), float(idx.y));\n    //pBat.xz = clamp(pBat.xz, -lim, lim);\n    //pBat.xz = pBat.xz-rep*clamp(fidx, -lim, lim);// clamp(pBat.xz, -lim, lim);\n    pBat.xz = mod(pBat.xz+rep*.5, rep)-rep*.5;\n    \n    float d = 0.2*sin(5.*length(vec2(idx))+iTime*5.);\n    vec2 sz = 0.1*texture(iChannel1, fidx*.1).xx;\n    vec2 bats = vec2(_cube(pBat, vec3(sz.x, d+(1.-sat(.1*length(fidx)))*2.+pow(texture(iChannel1, fidx*.5).x,.7)*2., sz.y)), 0.);\n    vec2 ground = vec2(-p.y, 1.);\n    \n    return _min(ground, bats);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p*vec3(1.,-1.,1.)+vec3(0.,-8.,0.);\n    p2.xz *= r2d(iTime*.5);\n    return _min(map2(p), map2(p2));\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 eps = vec3(0.001, 0., 0.);\n    return normalize(map(p).xxx-vec3(map(p-eps.xyy).x, map(p-eps.yxy).x, map(p-eps.yyx).x));\n}\n\nvec3 getCam(vec3 dir, vec2 uv)\n{\n    vec3 l = normalize(cross(dir, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(dir, l));\n    return dir+l*uv.x+u*uv.y;\n}\n\nstruct material\n{\n    vec3 SpecularColor;\n    float SpecularPower;\n    vec3 DiffuseColor;\n};\n\n// x is distance to point\n// y is index to object (for material)\n// -1.,-1. if no hit\nvec2 traceRay(vec3 p, vec3 rd, float maxDist, int steps)\n{\n    vec2 hit = vec2(-1.); \n    vec3 ro = p;\n    float totDist = 0.0;\n    for (int i = 0; (i < steps) && (totDist < maxDist); ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            hit = res;\n            hit.x = length(ro-p);\n            break;\n        }\n        float distF = 0.5; // To avoid glitch due to mod\n        totDist += res.x*distF;\n        p += res.x * rd*distF;\n    }\n    \n    return hit;\n}\n\nvec3 getSky(vec3 rd)\n{\n    return texture(iChannel0, normalize(rd)).xyz;\n}\nvec3 grid(vec2 uv)\n{\n  vec2 r = clamp(mod(uv,vec2(.25))-vec2(.001),vec2(0.),vec2(1.));\n  return vec3(.5)*(1.-sat(10.*(min(r.x,r.y))))*(.5+.5*sin(uv.y*500.))\n  *(.5+.5*sin(uv.x*500.))*(sat(length(uv)-.4));\n}\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    vec3 ta = vec3(0.,-3.,0.);\n    float rad = 10.;\n    float spd = -.3;\n    float t = iTime*spd;\n    vec3 ro = vec3(sin(t)*rad,-5.+sin(t)*.5,cos(t)*rad);\n    \n    vec3 dir = normalize(ta-ro);\n    vec3 rd = normalize(getCam(dir, uv));\n    \n    vec3 p = ro;\n\n    vec2 res = traceRay(ro, rd, 100.0, 128);\n    \n    \n    float dist;\n    if (res.x > 0.0)\n    {\n        vec3 n = normal(p+rd*res.x);\n        vec3 inter =  ro + rd*res.x + n*0.1;\n        dist = res.x;\n        vec3 lPos = vec3(5.,25.,0.);\n        vec3 lDir = lPos-inter;\n        vec3 baseCol = vec3(1.);\n        if (inter.z > 0.5 && inter.z < 1.5)\n            baseCol = vec3(0.000,1.000,0.298);\n        col = baseCol*(1.-sat(dot(n,normalize(lDir))))*(sat(length(lDir)/35.));\n        if (res.y > 0.5)\n        {\n            //col *= .5;\n            float ao = 1.0;\n            int aoSamples = 8;\n            for (int i = 0; i < aoSamples; ++i)\n            {\n                float fi = float(i);\n                \n                vec2 giRes = traceRay(inter, normalize(vec3(sin(fi), 1., cos(fi))), 1., 16);\n                if (giRes.x > 0.0)\n                    ao -= pow(giRes.x/1., .25)/float(aoSamples);\n                    //col += pow(1.-(sat(giRes.x/10.)/15.),5.1);\n            }\n            col = vec3(pow(1.-sat(ao), 1.));\n        }\n        else\n        {\n            vec3 refl = normalize(reflect(rd, n));\n            col *= mix(vec3(1.), getSky(refl), 1.);\n        }\n        \n       // col = n * .5+.5;\n    }\n    else\n    {\n        dist = 100.0;\n    }\n    \n    col = mix(col, vec3(209, 246, 255)/255., 1.-getFog(dist, 5.5, 0.15));\n    //col *= pow(1.-sat(fwidth(col.x)), 1.5)*1.1;\n    \n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(0.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    \n    float beat = 1./2.;\n    float beatF = mod(iTime, beat)/beat;\n    vec2 ouv = uv;\n    // I know this makes the below \"antialising\" malfunction\n    // but I found the effect cool\n    uv *= mix(1.,1.05, pow(beatF, 5.));\n    float diff = pow(fwidth(col.z), .6);\n\n    { // Not so cheap antialiasing SSAA x4\n\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot);\n        acc += rdr(uv-off.xy*rot);\n        acc += rdr(uv-off.yy*rot);\n        acc += rdr(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    \n    col *= 1.-sat((length(uv)-.3)*2.);\n    col = pow(col, vec3(1.45));\n    \n    col = col.yzx*(1.-col.xxx)+col.yzx;\n    \n    col = pow(col, vec3(1.45));\n    \n    col = mix(col, pow(col.yyy, vec3(5.)), sat((abs(uv.x+uv.y)-.4)*iResolution.x));\n    \n    col -= grid(uv*2.)*2.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25351, "src": "https://soundcloud.com/d-leria/d-leria-makumba-mst-4416", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyWt.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 448, 448, 503], [505, 505, 526, 526, 558], [560, 560, 587, 587, 640], [642, 642, 669, 669, 722], [724, 724, 753, 753, 814], [816, 816, 871, 871, 922], [924, 924, 943, 943, 1609], [1611, 1611, 1629, 1629, 1744], [1746, 1746, 1767, 1767, 1898], [1900, 1900, 1932, 1932, 2055], [2151, 2237, 2295, 2295, 2729], [2731, 2731, 2753, 2753, 2805], [2806, 2806, 2826, 2826, 3012], [3013, 3013, 3032, 3032, 4720], [4722, 4722, 4779, 4779, 5895]], "test": "untested"}
{"id": "wttfzM", "name": "Comparison of Smooth Minimums", "author": "iY0Yi", "description": "Here is a comparison of different implementations of Smooth Minimum, as described on iq's website.\nhttps://iquilezles.org/articles/smin/smin.htm\nThank you iq.\nmouse.", "tags": ["boolean", "smin"], "likes": 6, "viewed": 473, "published": 3, "date": "1612459932", "time_retrieved": "2024-07-30T19:40:40.654742", "image_code": "const float MIN_DIST = .001;\nconst float MAX_DIST = 100.;\nconst int ITR = 100;\nconst float INV_ITR = (1./float(ITR));\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n    // You can try ellipsoid too...(>_<)\n    #if 0\n        return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n    #else\n        float k0 = length(p/r);\n        float k1 = length(p/(r*r));\n        return k0*(k0-1.0)/k1;\n    #endif\n}\n\n// https://iquilezles.org/articles/smin\n\n//--------------------------------------------------------\n\n// polynomial smooth min (k = 0.1);\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminPoly_MediaMolecule( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// return a factor for blending material too.\nfloat sminQuadratic ( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m).x : vec2(b-s,1.0-m).x;\n}\n\n//--------------------------------------------------------\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// return a factor for blending material too.\nfloat sminCubic2( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m).x : vec2(b-s,1.0-m).x;\n}\n\n// return a factor for blending material too.\nfloat sminN( float a, float b, float k )\n{\n    const float n = 3.; //3.\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m).x : vec2(b-s,1.0-m).x;\n}\n\n// return a factor for blending material too.\nfloat sminExp( in float a, in float b, in float k )\n{\n    float f1 = exp2( -k*a );\n    float f2 = exp2( -k*b );\n    return vec2(-log2(f1+f2)/k,f2).x;\n}\n//--------------------------------------------------------\n\n// power smooth min (k = 8);\nfloat sminPow( float a, float b, float k )\n{\n    k/=2.;\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n\n#define FLAT false\n\n#define NUM_TYPES 8.\nint id=0;\nfloat map(in vec3 p)\n{\n#define shapes(method, mix1, mix2)\\\n    float anim = sin(iTime)*.5+.5;\\\n    if(iMouse.z>0.)anim = u2s(iMouse.y/iResolution.y);\\\n    d = method(sdEllipsoid(p+vec3(0., -2.0128, 0.), vec3(.4571, 1., .4571)), d, mix1);\\\n\td = method(sdEllipsoid(p+vec3(0., -3.9932, 0.), vec3(.4571, 1., .4571)), d, mix1);\\\n\td = method(sdEllipsoid(p+vec3(0., -5.9811, 0.), vec3(.4571, 1., .4571)), d, anim*mix2);\\\n\n    p.y+=6.;\n    float d = sdEllipsoid(p, vec3(1., 1., 1.));\n    float cbf = 1.35;\n    //--------------------------------------------------------\n    if(id==0){\n        shapes(sminPoly, .5, 3.);\n    }\n    else\n    if(id==1){\n        shapes(sminPoly_MediaMolecule, .5, 3.);\n    }\n    else\n    if(id==2){\n        shapes(sminQuadratic, .5, 3.);\n    }\n    //--------------------------------------------------------\n    else\n    if(id==3){\n        shapes(sminCubic, .5*cbf, 3.*cbf);\n    }\n    else\n    if(id==4){\n        shapes(sminCubic2, .5*cbf, 3.*cbf);\n    }\n    else\n    if(id==5){\n        shapes(sminN, .5*cbf, 3.*cbf);\n    }\n    //--------------------------------------------------------\n    else\n    if(id==6){\n        shapes(sminExp, .5*10., 3.); //animation is reversed.\n    }\n    else\n    if(id==7){\n        shapes(sminPow, .99, .9); // I don't know why this doesnt work..\n    }\n    //--------------------------------------------------------\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec3 e = vec3(0, 1,-1)*MIN_DIST;\n    return normalize(vec3(map(p+e.yxx)-map(p+e.zxx),map(p+e.xyx)-map(p+e.xzx),map(p+e.xxy)-map(p+e.xxz)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<ITR; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p)*.5;\n        if(d<=MIN_DIST) break;\n        t += d;\n        if(t >= MAX_DIST) return MAX_DIST;\n    }\n    return t;\n}\n\nvec3 render(in vec2 fragCoord){\n      vec2 uv = fragCoord/iResolution.xy;\n      float line = step(.99, fract(uv.x*NUM_TYPES))*step(uv.x,.9);\n      line += step(.9, fract(uv.x*NUM_TYPES*5.))*.1;\n      line += step(.9, fract(uv.y*20.))*.1;\n      id = int(uv.x*NUM_TYPES);\n      uv.x = fract(uv.x*NUM_TYPES);\n      \n      uv = uv*2.-1.;\n      uv.x *= 1./NUM_TYPES;\n      uv.y *= iResolution.y/iResolution.x;      \n      \n      vec3 ro = vec3(0,0,-10);\n      vec3 rd = normalize(vec3(uv-vec2(0,.55), 2));\n      float d = march(ro, rd);\n      \n      vec3 col = vec3(.025);\n      \n      if(d<MAX_DIST){\n          vec3 p = ro + rd * d;\n          vec3 n = normal(p);\n          //dbg_3V( n*.5+.5 );\n          col = vec3(0.000,0.616,1.000)*.75;\n          if(!FLAT){\n              float l = max(0., dot(n, vec3(.5,1,-.5)));\n              float l2 = max(0., dot(n,-vec3(.5,1,-.5)));\n              col = mix(vec3(0),col, l+.1*l2);\n          }\n          \n      }\n      col+=line*.1;\n      col = pow(col, vec3(.45));\n      return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = render(fragCoord);\n    fragColor = vec4(col,1.0);\n    drawDebug(fragColor);\n}", "image_inputs": [], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 159, 200, 388], [491, 527, 572, 572, 665], [667, 703, 762, 762, 846], [848, 894, 945, 945, 1093], [1155, 1191, 1237, 1237, 1323], [1325, 1371, 1418, 1418, 1569], [1571, 1617, 1659, 1659, 1835], [1837, 1883, 1936, 1936, 2034], [2095, 2124, 2168, 2168, 2257], [2311, 2311, 2333, 2333, 3694], [3696, 3696, 3716, 3716, 3862], [3864, 3864, 3894, 3894, 4113], [4115, 4115, 4146, 4146, 5136], [5138, 5138, 5194, 5194, 5287]], "test": "untested"}
{"id": "tldBzM", "name": "3 balls, 3 colors", "author": "Wazass", "description": "It's 3 balls light by 3 differents colors", "tags": ["ballscolors"], "likes": 1, "viewed": 217, "published": 3, "date": "1612452746", "time_retrieved": "2024-07-30T19:40:41.425681", "image_code": "vec4 getIntersection(vec3 origin, vec3 ray, vec4 sphere) {\n\n    float h = length(sphere.xyz - origin);\n    float a = dot(sphere.xyz - origin, ray);\n    float sq_o = h*h - a*a; \n    \n    // Check if there is an intersection\n    float sq_d = sphere.w*sphere.w - sq_o;\n    if (sq_d > 0.) {\n        float d = sqrt(sq_d);\n        vec3 intersection = origin + (a - d)*ray;        \n        return vec4(intersection, 1.0);\n    }\n    else\n    {\n        return vec4(0.);\n    } \n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec3 posOeil = vec3(iResolution.xy/2., 1000.0);\n    vec3 posEcran = vec3(fragCoord, 0.0);\n    \n    vec3 ray = normalize(posEcran - posOeil);\n    \n    // notre sphere\n    // rayon 1\n    // en position au milieu de l'écran, assez loin\n    \n    vec4 sphere = vec4(iResolution.xy/1.25, -200., 100.); \n    vec4 sphere2 = vec4(iResolution.xy/2., -200., 100.);\n    vec4 sphere3 = vec4(iResolution.xy/5., -200., 100.);\n    \n    vec3 light_pos = vec3(iMouse.xy, 0.0);\n\n\n\n    vec3 col = vec3(0.);\n    \n    vec4 intersection = getIntersection(posOeil, ray, sphere);\n    if (intersection.w > 0.) {\n        vec3 normal = normalize(intersection.xyz - sphere.xyz);\n        vec3 surface_pos = intersection.xyz;\n                \n        vec3 incidence = light_pos - surface_pos;\n        vec3 incidence2 = light_pos - surface_pos;\n        float intensite = length(incidence);\n        float intensite2 = length(incidence2);\n        \n        incidence = normalize(incidence);\n        intensite = 10000. / (intensite*intensite);\n        incidence2 = normalize(incidence2);\n        intensite2 = 3000. / (intensite2*intensite2);\n    \n        //Lambert\n        col = (dot(incidence, normal) * vec3(1., 0., 1.) * intensite)+(dot(incidence2, normal) * vec3(0.6,1.,1.) * intensite2);\n    }\n    \n    vec4 intersection2 = getIntersection(posOeil, ray, sphere2);\n    if (intersection2.w > 0.) {\n        vec3 normal2 = normalize(intersection2.xyz - sphere2.xyz);\n        vec3 surface_pos = intersection2.xyz;\n    \n        vec3 incidence = light_pos - surface_pos;\n        vec3 incidence2 = light_pos - surface_pos;\n        float intensite = length(incidence);\n        float intensite2 = length(incidence2);\n    \n        incidence = normalize(incidence);\n        intensite = 10000. / (intensite*intensite);\n        incidence2 = normalize(incidence2);\n        intensite2 = 3000. / (intensite2*intensite2);    \n    \n        //Lambert\n        col = max(col, (dot(incidence, normal2) * vec3(1.,1.,0.) * intensite)+(dot(incidence2, normal2) * vec3(0.6,1.,1.) * intensite2));\n    }\n    \n    vec4 intersection3 = getIntersection(posOeil, ray, sphere3);\n    if (intersection3.w > 0.) {\n        vec3 normal3 = normalize(intersection3.xyz - sphere3.xyz);\n        vec3 surface_pos = intersection3.xyz;\n    \n        vec3 incidence = light_pos - surface_pos;\n        vec3 incidence2 = light_pos - surface_pos;\n        float intensite = length(incidence);\n        float intensite2 = length(incidence2);\n    \n        incidence = normalize(incidence);\n        intensite = 10000. / (intensite*intensite);\n        incidence2 = normalize(incidence2);\n        intensite2 = 3000. / (intensite2*intensite2);     \n    \n        //Lambert\n        col = max(col, (dot(incidence, normal3) * vec3(0.,1.,1.) * intensite)+(dot(incidence2, normal3) * vec3(0.6,1.,1.) * intensite2));\n    }\n\n    //vec4 sphere2 = vec4(iMouse.xy, -100., 100.);\n    //mask = max(mask, (intersects(posOeil, ray, sphere2)) ? 0. : 1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 479], [481, 481, 537, 537, 3558]], "test": "untested"}
{"id": "wttfzN", "name": "fireworks with fake physics", "author": "stduhpf", "description": "inspired by bigwing's (the art of code on youtube) video", "tags": ["simulation", "fireworks", "cineshader"], "likes": 23, "viewed": 8647, "published": 3, "date": "1612452515", "time_retrieved": "2024-07-30T19:40:42.187643", "image_code": "vec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec2 dir(float id){\n    vec2 h = hash21(id);\n    h.y*=2.*acos(-1.);\n    return h.x*vec2(cos(h.y),sin(h.y));\n}\n\n#define PARTICLES_MIN 20.\n#define PARTICLES_MAX 200.\n\nfloat bang(vec2 uv, float t,float id){\n    float o = 0.;\n    if(t<=0.){\n        return .04/dot(uv,uv);\n    }\n    float s = (sqrt(t)+t*exp2(-t/.125)*.8)*10.;\n    float brightness = sqrt(1.-t)*.015*(step(.0001,t)*.9+.1);\n    float blinkI = exp2(-t/.125);\n    float PARTICLES = PARTICLES_MIN+(PARTICLES_MAX-PARTICLES_MIN)*fract(cos(id)*45241.45);\n    for(float i=0.;i<PARTICLES;i++){\n        vec2 d = dir(i+.012*id);\n        \n        vec2 p = d*s;\n        \n        \n        vec2 h = hash21(5.33345*i+.015*id);\n        float blink = mix(cos((t+h.x)*10.*(2.+h.y)+h.x*h.y*10.)*.3+.7,1.,blinkI);\n        \n        o+=blink*brightness/dot(uv-p,uv-p);\n    }\n    return o;\n}\n\nconst float ExT = 1./4.;\n\n#define duration 2.2\n\nfloat firework(vec2 uv,float t,float id){\n    if(id<1.)return 0.;\n    vec2 h = hash21(id*5.645)*2.-1.;\n    vec2 offset = vec2(h.x*.1,0.);\n    h.y=h.y*.95;\n    h.y*=abs(h.y);\n    vec2 di = vec2(h.y,sqrt(1.-h.y*h.y));\n    float thrust = sqrt(min(t,ExT)/ExT)*25.;\n    vec2 p = offset+duration*(di*thrust+vec2(0.,-9.81)*t)*t;\n    return sqrt(1.-t)*bang(uv-p,max(0.,(t-ExT)/(1.-ExT)),id);\n}\n\n#define NUM_ROCKETS 3.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy*vec2(1.,0.))/iResolution.y;\n    vec3 col = vec3(.01,.011,.015)*0.;\n    \n    float time = .75*iTime;\n    float t = time/duration;\n    uv.y-=.65;\n    uv*=35.;\n    float m = 1.;\n    float d =0.;\n    //water\n    if(uv.y<0.){\n        const float h0 = 5.;\n        const float dcam = 1000.5;\n        \n        float y = uv.y-h0;//translated y position, to add fake earth curvature (horizon not at infinity)\n        \n        float z = dcam*h0/y;//fake depth\n        d=-40.*uv.y/(h0*dcam);\n        \n        float x = uv.x*z/dcam; //parallax-aware x coordinate\n        \n        uv+=vec2(sin((x*1.5+z*.75)*.0005-t*1.5),cos((z*2.-x*.5)*.0005-t*2.69))\n        *(sin(x*.07+z*.09+sin(x*.2-t)-t*15.)+cos(z*.1-x*(.08+.001*sin(x*.01-t))-t*16.)*.7+cos(z*.01+x*.004-t*10.)*1.7)\n        *.15*dcam/z; //waves\n        \n        float ndv = -uv.y/sqrt(dcam*dcam+uv.y*uv.y);\n        m=mix(1.,.98,pow(1.-ndv,5.));//fresnel factor\n        \n        uv.y = -uv.y;\n    }\n    //sky\n    col+=(exp2(-abs(uv.y)*vec3(1.,2.,3.)-.5)+exp2(-abs(uv.y)*vec3(1.,.2,.1)-4.))*.5;\n    \n    //land\n    if(uv.y*1.5<(uv.x-20.)*.01*(-uv.x+90.)+sin(uv.x)*cos(uv.y*1.1)*.75)\n        col*=0.;\n    \n    for(float i = 0.;i<ceil(NUM_ROCKETS);i++){\n        float T = 1.+t+i/NUM_ROCKETS; \n        \n        float id = floor(T)-i/NUM_ROCKETS; //should give a unique integer for each rocket\n        \n        vec3 color = hash31(id*.75645);\n        color/=max(color.r,max(color.g,color.b));//making colors as bright as possible\n\n        col+=firework(uv,fract(T),id)*color;\n    }\n    //col = vec3(1);\n    fragColor = vec4(m*col,1.0);\n    \n    vec4 noise = texture(iChannel0,(fragCoord)/iChannelResolution[0].xy);\n    noise = noise*255./256.+noise.w/256.;\n       //linear dithering to avoid banding (linear means less overshoot for dark pixels, so better contrast)\n    vec4 lcol = clamp(fragColor,0.,1.); //clamp input\n    vec4 gcol = pow(lcol,vec4(1./2.2)); //convert to output gamma space\n\n    vec4 gcol_f = floor(gcol*255.)/255.; //floor to get the lower bound\n\n    vec4 lcol_f = pow(     gcol_f         ,vec4(2.2)); // convert the lower bound to linear\n    vec4 lcol_c = pow(ceil(gcol*255.)/255.,vec4(2.2)); // ceil to get the upper bound, convereted to linear\n\n    vec4 x = (lcol-lcol_f)/(lcol_c-lcol_f); // get x such as lcol_f + x*(lcol_c-lcol_f) == lcol\n\n    // compare x to the noise to chose what bounding value should be selected (in gamma space)\n    fragColor = gcol_f+step(noise,x)/255.;\n    fragColor.a = d;\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 151], [153, 153, 175, 175, 383], [385, 385, 404, 404, 494], [550, 550, 588, 588, 1213], [1263, 1263, 1304, 1304, 1648], [1674, 1674, 1731, 1731, 4234]], "test": "untested"}
{"id": "Wltfz7", "name": "racing hearts", "author": "YitingLiu", "description": "creating racing hearts ", "tags": ["mouse", "grid", "random", "rotate", "heart", "interaction", "smoothstep", "scale", "max", "valentine"], "likes": 9, "viewed": 324, "published": 3, "date": "1612447950", "time_retrieved": "2024-07-30T19:40:42.950603", "image_code": "//tutorial https://www.youtube.com/watch?v=dXyPOLf2MbU\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define HEART_COLOR vec3(1.,0.02,0.02)\n\nfloat smax(float a, float b, float k){\n\n    float h = clamp((b-a)/k+.5,0.,1.);\n    return mix(a,b,h)+h*(1.-h)*k*.5;\n}\n\n\nfloat Heart(vec2 uv, float b, float r){\n  \n    b*=r;\n\n    uv.x*=1.;\n    uv.y-=smax(sqrt(abs(uv.x))*.4,b,.1);\n    uv.y+=.1*r;\n    \n    float d = length(uv);\n    return S(r+b,r-b-0.01,d);\n\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(20.,2006.)))*\n        400008.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m= iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n\n    uv*=10.;\n\n    vec2 f =fract(uv)*3.-1.5;\n    vec2 id = floor(uv);\n    f*=rotate2d(abs(sin(iTime*0.5))*3.14*(id.x+id.y+0.08)*2.);\n    f *= scale( vec2(abs(cos(iTime*0.5)+.2)) ) ;\n\nfloat c= Heart(f,m.y,0.5*abs(sin(iTime*0.5)));\n    col = vec3(c*HEART_COLOR*(random(id)+0.5));\n  \n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wltfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 169, 169, 248], [251, 251, 290, 290, 439], [440, 440, 464, 464, 527], [529, 529, 557, 557, 643], [645, 645, 669, 669, 772], [773, 773, 830, 830, 1274]], "test": "untested"}
{"id": "WttfR7", "name": "Segment - gradient 3D", "author": "iq", "description": "Computes the analytic gradient of a segment or capsule's SDF, which is much faster than doing it numerically (useful when the normal is needed inside the SDF evaluation itself or inside the raymarching loop for example).", "tags": ["3d", "sdf", "gradient", "normal", "analytic", "segment", "capsule"], "likes": 16, "viewed": 809, "published": 3, "date": "1612442384", "time_retrieved": "2024-07-30T19:40:43.717553", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgSegment() returns the segments/capsule SDF and its\n// analytical gradient. This means the normal to the \n// capsule's surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n// Ellipsoid: https://www.shadertoy.com/view/flXyRS\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\nvec4 sdgSegment( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = pa-h*ba;\n    float d = length(q);\n    return vec4(d-r,q/d);    \n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    vec3  pa = vec3(-0.5,-0.4,-0.3);\n    vec3  pb = vec3( 0.2, 0.4, 0.1);\n    float ra = 0.25+0.2*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgSegment(pos,pa,pb,ra).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgSegment(pos,pa,pb,ra).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgSegment( pos + e.xyy*eps, pa, pb, ra ).x + \n                             e.yyx*sdgSegment( pos + e.yyx*eps, pa, pb, ra ).x + \n                             e.yxy*sdgSegment( pos + e.yxy*eps, pa, pb, ra ).x + \n                             e.xxx*sdgSegment( pos + e.xxx*eps, pa, pb, ra ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfR7.jpg", "access": "api", "license": "mit", "functions": [[1540, 1657, 1709, 1709, 1883]], "test": "untested"}
{"id": "wtcfzM", "name": "Torus - gradient 3D", "author": "iq", "description": "Computes the analytic gradient/normal of a torus SDF, which is much faster than doing it numerically (useful when the normal is needed inside the SDF evaluation itself or inside the raymarching loop for example).", "tags": ["3d", "sdf", "torus", "gradient", "normal", "analytic"], "likes": 23, "viewed": 1481, "published": 3, "date": "1612442284", "time_retrieved": "2024-07-30T19:40:44.483505", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// sdgTorus() returns the torus SDF and its gradient, by \n// computing it analytically. This means the normal to\n// the torus surface can be used during the raymarch loop\n// rather inexpensivelly (compared to sampling the SDF\n// multiple times to evaluate a normal for it)\n\n// Other SDF analytic gradients:\n//\n// Torus:   https://www.shadertoy.com/view/wtcfzM\n// Capsule: https://www.shadertoy.com/view/WttfR7\n// Ellipsoid: https://www.shadertoy.com/view/flXyRS\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .w = ∂f(p)/∂z\n// .yzw = ∇f(p) with ‖∇f(p)‖ = 1\nvec4 sdgTorus( vec3 p, float ra, float rb )\n{\n    float h = length(p.xz);\n    return vec4( length(vec2(h-ra,p.y))-rb,\n                 normalize(p*vec3(h-ra,h,h-ra)) );\n}\n\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.65, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // animate torus\n    float ra = 0.5;\n    float rb = 0.2+0.1*sin(iTime);\n    \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = sdgTorus(pos,ra,rb).x;\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = sdgTorus(pos,ra,rb).yzw;\n\n            // compute normal numerically, for comparison\n            // https://iquilezles.org/articles/normalsSDF\n            #if 0\n            const vec2 e = vec2(1,-1);\n            const float eps = 0.0002;\n            nor = normalize( e.xyy*sdgTorus( pos + e.xyy*eps, ra, rb ).x + \n                             e.yyx*sdgTorus( pos + e.yyx*eps, ra, rb ).x + \n                             e.yxy*sdgTorus( pos + e.yxy*eps, ra, rb ).x + \n                             e.xxx*sdgTorus( pos + e.xxx*eps, ra, rb ).x );\n\n            #endif\n\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n            col *= (0.5+0.5*nor)*(0.5+0.5*nor);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfzM.jpg", "access": "api", "license": "mit", "functions": [[1542, 1659, 1704, 1704, 1829]], "test": "untested"}
{"id": "3ltfzM", "name": "Metallic Tubeworms", "author": "dr2", "description": "Seen on another planet", "tags": ["life", "tube", "kinematics"], "likes": 13, "viewed": 343, "published": 3, "date": "1612434241", "time_retrieved": "2024-07-30T19:40:45.441943", "image_code": "// \"Metallic Tubeworms\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (=0/1) optional antialising\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllips2Df (vec3 p, vec2 r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec4 Hashv4v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, hgSize, grLim, sLoop, hBase, lEnd, tubRot, bkAop, szFac, ghMax;\nint idObj;\nconst int idTube = 1, idEx = 2, idEnd = 3, idBk = 4;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndHt (vec2 p)\n{\n  vec2 gIdL;\n  float h, hh, nl, nf;\n  nf = 0.5;\n  p = (floor (nf * p) +  smoothstep (0.1, 1., mod (nf * p, 1.))) / nf;\n  hh = Fbm2 (0.1 * p);\n  nl = 10.;\n  h = ghMax * (floor (nl * hh) + smoothstep (0.4, 0.6, mod (nl * hh, 1.))) / nl + 0.05 * hh;\n  gIdL = PixToHex (p / hgSize);\n  if (Maxv3 (abs (vec3 (gIdL, dot (gIdL, vec2 (1.))))) <= grLim)\n     h *= 0.2 + 0.8 * smoothstep (0., 2., length (p - HexToPix (gIdL * hgSize)) - 1.5);\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, dLoop, aLoop, rCyl, rc, s, dc, dy;\n  dLoop = 6. * sLoop;\n  aLoop = 0.25 * pi / sLoop;\n  rCyl = 0.6;\n  rc = 0.6;\n  dMin = dstFar / szFac;\n  p.xz -= HexToPix (gId * hgSize);\n  p /= szFac;\n  q = p;\n  dy = - q.y;\n  q.y -= 0.3;\n  d = max (PrRoundCylDf (q.xzy, rCyl + 0.4, 0.1, 0.3), dy);\n  DMINQ (idEx);\n  q = p;\n  q.y -= 2. * lEnd + hBase + 0.3;\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) - rc, rc),\n     abs (q.y + lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n  s = mod (3. * dLoop * atan (q.y, - q.x) + 0.5, 1.);\n  qq = q;\n  dc = dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)));\n  q.xz = Rot2D (vec2 (length (q.xy) - dLoop, q.z), tubRot);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s)) - rc),\n     rc), dc), dy);\n  DMINQ (idTube);\n  q = qq;\n  q.xy = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  q.xz = Rot2D (q.xz, - tubRot);\n  s = mod (3. * q.y + 0.5, 1.);\n  d = max (max (PrRound4Box2Df (q.xz, vec2 (rCyl * (1. - 0.03 * SmoothBump (0.2, 0.8, 0.15, s))) - rc, rc),\n     abs (q.y - lEnd) - lEnd - 0.01), dy);\n  DMINQ (idEnd);\n  q.y -= 2. * lEnd + 0.1;\n  d = PrRoundCylDf (q.xzy, rCyl + 0.1, 0.05, 0.05);\n  DMINQ (idEx);\n  q.y -= 0.2;\n  d = PrCapsDf (q.xzy, 0.25, 0.25);\n  DMINQ (idEx);\n  q.y -= 1.2;\n  q.xz = abs (q.xz);\n  q.xz = (q.x + q.z * vec2 (-1., 1.)) / sqrt(2.);\n  q.yz = Rot2D (q.yz + vec2 (0.7, 0.), bkAop) - vec2 (0.8, 0.);\n  d = max (abs (PrEllips2Df (q.xzy, vec2 (0.5, 1.))) - 0.02, - 0.01 - (q.z - abs (q.x)) / sqrt(2.));\n  DMINQ (idBk);\n  return 0.8 * szFac * dMin;\n}\n\nvoid SetObjConf ()\n{\n  vec4 r4;\n  float tCyc, t;\n  r4 = Hashv4v2 (19.1 * gId + 99.1);\n  tCyc = 20. + 10. * r4.x;\n  t = (tCur + 13.1) / tCyc;\n  tubRot = mod ((10. + 5. * r4.y) * t, 2. * pi) * sign (r4.z - 0.5);\n  t = mod (t, 1.);\n  sLoop = (1. / (1. + 0.25 * r4.w)) / (0.01 + 0.99 * SmoothBump (0.25, 0.75, 0.15, t));\n  lEnd = 1.;\n  hBase = - (6. * (0.5 * pi) + 4. * lEnd) * (1. - SmoothBump (0.1, 0.9, 0.08, t));\n  bkAop = -0.5 * pi * SmoothBump (0.25, 0.75, 0.15, mod ((12. - 0.6 * r4.y) * t, 1.)) *\n     SmoothBump (0.3, 0.7, 0.1, t);\n  szFac = 0.7 + 0.3 * r4.w;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim) {\n      if (gId != gIdP) {\n        gIdP = gId;\n        SetObjConf ();\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.01, 1.);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim) {\n      if (gId != gIdP) {\n        gIdP = gId;\n        SetObjConf ();\n      }\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n    } else h = 0.1;\n    d += clamp (h, 0.01, 1.);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.4, 0.4, 0.55), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.x -= tCur;\n  f = Fbm2 (0.01 * (ro + rd * (200. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd), vec3 (1.), clamp (f * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstGrnd, dstObj, nDotL, sh;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = vec4 (HsvToRgb (vec3 (0.9 * Hashfv2 (17.1 * gId), 0.3, 0.9)), 0.1);\n      if (idObj == idTube || idObj == idEnd) col4 = col4 * (0.93 + 0.07 * smoothstep (-0.1, 0.,\n         cos (32. * atan (qHit.z, - qHit.x))));\n      else if (idObj == idEx) col4 *= 0.9;\n      else if (idObj == idBk) col4 = (PrEllips2Df (qHit.xzy, vec2 (0.5, 1.)) < -0.01) ?\n         vec4 (0.8 + 0.2 * sin (32. * pi * tCur), 0., 0., -1.) : col4 *\n         (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (64. * qHit.y)));\n      if (col4.a >= 0.) {\n        nDotL = max (dot (vn, sunDir), 0.);\n        nDotL *= nDotL;\n        sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n        col = col4.rgb * (0.2 + 0.8 * sh * nDotL) + col4.a * step (0.95, sh) *\n           pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n    } else {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      vn = VaryNf (ro, vn, 1.);\n      col = mix (vec3 (0.4, 0.4, 0.1), vec3 (0.8, 0.7, 0.7), mod (floor (10. * ro.y / ghMax) / 10., 1.));\n      col *= 1. - 0.2 * Fbm2 (64. * ro.xz);\n      sh = GrndSShadow (ro + 0.01 * vn, sunDir);\n      gId = PixToHex (ro.xz / hgSize);\n      if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim)\n         sh = min (sh, ObjSShadow (ro + 0.01 * vn, sunDir));\n      col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n    }\n    col = mix (col, SkyBg (rd), pow (min (dstObj, dstGrnd) / dstFar, 4.));\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, t, ar;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize = 12.;\n  grLim = 12.;\n  ghMax = 1.5;\n  el = -0.08 * pi;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 0.4 * pi * mPtr.x;\n    el += 0.25 * pi * mPtr.y;\n  }\n  t = mod (0.003 * tCur, 2.);\n  ar = -0.5 * pi + 2.5 * pi * (0.5 - abs ((floor (32. * t) + smoothstep (0.8, 1.,\n     mod (32. * t, 1.))) / 32. - 1.));\n  az -= ar;\n  ro = vec3 (0., 15., - 1.02 * sqrt3 * hgSize * grLim);\n  ro.xz = Rot2D (ro.xz, ar);\n  sunDir = normalize (vec3 (1., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, ar);\n  el = clamp (el, -0.2 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.;\n  dstFar = 2. * sqrt3 * hgSize * grLim;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  return sqrt (sqrt (dot (p, p)));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  return Length4 (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39);\n  return fract (sin (dot (p, cHashVA2) + vec4 (0., cHashVA2.xy, cHashVA2.x + cHashVA2.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1128, 1128, 1151, 1151, 1597], [1599, 1599, 1633, 1633, 2113], [2115, 2115, 2137, 2137, 2276], [2278, 2278, 2300, 2300, 4082], [4084, 4084, 4104, 4104, 4650], [4652, 4652, 4685, 4685, 6025], [6027, 6027, 6048, 6048, 6303], [6305, 6305, 6343, 6343, 6621], [6623, 6623, 6660, 6660, 7167], [7169, 7169, 7191, 7191, 7284], [7286, 7286, 7318, 7318, 7479], [7481, 7481, 7516, 7516, 9273], [9275, 9275, 9328, 9328, 10764], [10766, 10766, 10790, 10790, 10837], [10839, 10839, 10872, 10872, 10899], [10901, 10901, 10949, 10949, 10997], [10999, 10999, 11056, 11056, 11132], [11134, 11134, 11177, 11177, 11250], [11252, 11252, 11288, 11288, 11343], [11345, 11345, 11367, 11367, 11405], [11407, 11407, 11429, 11429, 11467], [11469, 11469, 11493, 11493, 11723], [11725, 11725, 11749, 11749, 11809], [11811, 11811, 11847, 11847, 12053], [12055, 12055, 12085, 12085, 12198], [12200, 12200, 12257, 12257, 12340], [12342, 12342, 12366, 12366, 12483], [12517, 12517, 12541, 12541, 12601], [12603, 12603, 12627, 12627, 12757], [12759, 12759, 12783, 12783, 12920], [12922, 12922, 12947, 12947, 13133], [13135, 13135, 13156, 13156, 13311], [13313, 13313, 13342, 13342, 13554], [13556, 13556, 13595, 13595, 13775]], "test": "untested"}
{"id": "WltfzM", "name": "大龙猫 -  Quicky#050", "author": "totetmatt", "description": "quicky", "tags": ["quicky"], "likes": 15, "viewed": 346, "published": 3, "date": "1612434199", "time_retrieved": "2024-07-30T19:40:46.205900", "image_code": "float bbox(vec2 uv, vec2 a,vec2 b,float t){\n    float l = length(b-a);\n    vec2 d = (b-a)/l;\n    vec2 q = uv - (a+b)*.5;\n    q = mat2(d.x,-d.y,d.y,d.x)*q;\n    q = abs(q) - vec2(l,t)*.5;\n    return length(max(q,vec2(0.))) + min(max(d.x,d.y),0.);\n}\nfloat tt (vec2 uv,vec2 offset){\n    float d = bbox(uv,vec2(.0,.2)+offset,vec2(.2,-.2)-offset,.001);\n     d = min(d,bbox(uv,vec2(-.2,-.2)-(offset/offset),vec2(0,.2)+offset,.001));\n      d = min(d,bbox(uv,vec2(-.2,-.2)+offset,vec2(.2,-.2)-offset,.001));\n    d = (.01+sin(uv.y*20.+uv.x*10.+iTime)*.005)/d;\n    return d;\n}\nvec2 h21(float t){\n    float x = fract(sin(t*546.54)*815.2);\n    float y = fract(sin(t*461.541)*401.5);\n    return vec2(x,y);\n}\n\nmat2 r(float a){\n    float c=cos(a),s= sin(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) / iResolution.y;\n    uv*=2.0;\n    vec3 col = vec3(0.);\n    const float lim = 10.;\n    for(float i=0.;i<lim;i++){\n      float rr = fract((-iTime-100.)*i/lim);\n      rr = mix(.05,10.,rr);\n      vec2 lv = uv;\n      \n    float d = tt((lv*r(iTime+100.+i)*rr),h21(floor(100.+iTime*.05+i))*.09);\n      col += vec3(d,d-.1,d-.2);\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 246], [247, 247, 278, 278, 565], [566, 566, 584, 584, 693], [695, 695, 711, 711, 770], [771, 771, 826, 826, 1239]], "test": "untested"}
{"id": "3ldBzM", "name": "Moiré 3b", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. Slight perspective cause moiré.\nHere, the 2 plates are rotated by pi/2.\nRéférence:\n[img]https://img.srgcdn.com/e/w:750//UlJBQm5VN2xnbnBnU1N3WTBWR2sucG5n.jpg[/img]", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 7, "viewed": 309, "published": 3, "date": "1612432479", "time_retrieved": "2024-07-30T19:40:46.969857", "image_code": "// variant of https://shadertoy.com/view/WltBzM\n// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*R.y )/5. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 3.;\n    vec2 R = iResolution.yy/8., T = vec2( 2, 3.5 )*R;\n    O += P -O;\n\n    U = 1.1*U.yx + 10.*iTime;\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 257, 293, 293, 420]], "test": "untested"}
{"id": "WltBzM", "name": "Moiré 3", "author": "FabriceNeyret2", "description": "Shadows of 2 identical parallel plates with hexa-tiled holes. Slight perspective cause moiré.\nInspiration:\n[img]https://img.srgcdn.com/e/w:750//UlJBQm5VN2xnbnBnU1N3WTBWR2sucG5n.jpg[/img]", "tags": ["aliasing", "interference", "moir", "reproduction"], "likes": 13, "viewed": 297, "published": 3, "date": "1612432063", "time_retrieved": "2024-07-30T19:40:47.784679", "image_code": "// adapted from https://shadertoy.com/view/ttd3D7\n\n#define D   length( mod( U += T/2. , T ) - R )               //\n#define P   clamp( 1.- ( min( D, D ) -.8*R.y )/6. ,0.,1.)    // draw an hexa tiling of disks\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U *= 4.;\n    vec2 R = iResolution.yy/8., T = vec2( 2, 3.5 )*R;\n    O += P -O;\n\n    U = 1.1*U + 10.*iTime;\n    O *= P;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 245, 245, 369]], "test": "untested"}
{"id": "wl3fR7", "name": "Slicing a 4D apollian", "author": "mrange", "description": "License CC0: Slicing a 4D apollian\nWas experimenting with slicing 3D fractals in 2D.\n", "tags": ["3d", "4d", "apollian"], "likes": 30, "viewed": 627, "published": 3, "date": "1612423823", "time_retrieved": "2024-07-30T19:40:48.557612", "image_code": "// License CC0: Slicing a 4D apollian\n// Was experimenting with slicing 3D fractals in 2D.\n// Naturally I wondered how it looks if we +1 dimension\n// Based upon: https://www.shadertoy.com/view/4ds3zn\n#define PI  3.141592654\n\nconst int   max_iter      = 130;\nconst vec3  bone          = vec3(0.89, 0.855, 0.788);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n \n  vec4 ap = abs(p) / scale;\n  float d = length(ap.yw);\n  d = min(d, length(ap.xz));\n\n  return 0.55*d;\n}\n\nfloat df(vec3 p) { \n  vec4 p4 = vec4(p, 0.125);\n  float tm = 0.1*iTime;\n  rot(p4.xw, tm*sqrt(0.5));\n  rot(p4.yw, tm*sqrt(0.4));\n  rot(p4.zw, tm*sqrt(0.3));\n  float d1 = apollian(p4, 1.0/0.75);\n  float db = box(p - vec3(0.0, 0.5, 0.0), vec3(1.5)) - 0.5;\n  return max(d1, db); \n} \n\n\nfloat intersect(vec3 ro, vec3 rd, out int iter) {\n  float res;\n  float t = 0.2;\n  iter = max_iter;\n    \n  for(int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + rd * t;\n    res = df(p);\n    if(res < 0.0003 * t || res > 20.) {\n      iter = i;\n      break;\n    }\n    t += res;\n  }\n    \n  if(res > 20.) t = -1.;\n  return t;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.012;\n  float t = stepSize;\n\n  float oc = 0.0;\n\n  for(int i = 0; i < 12; i++) {\n    float d = df(p + n * t);\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n  vec3  eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 lighting(vec3 p, vec3 rd, int iter) {\n  vec3 n = normal(p);\n  float fake = float(iter)/float(max_iter);\n  float fakeAmb = exp(-fake*fake*9.0);\n  float amb = ambientOcclusion(p, n);\n\n  vec3 col = vec3(mix(1.0, 0.125, pow(amb, 3.0)))*vec3(fakeAmb)*bone;\n  return col;\n}\n\nvec3 post(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.65)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  { \n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 uv = -1.0 + 2.0*q; \n  uv.y += 0.225;\n  uv.x*=iResolution.x/iResolution.y; \n    \n  vec3 la = vec3(0.0, 0.0, 0.0); \n  vec3 ro = vec3(-4.0, 1., -0.0);\n  rot(ro.xz, 2.0*PI*iTime/120.0);\n  vec3 cf = normalize(la-ro); \n  vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n  vec3 cu = normalize(cross(cs,cf)); \n  vec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n  vec3 bg = mix(bone*0.5, bone, smoothstep(-1.0, 1.0, uv.y));\n  vec3 col = bg;\n\n  vec3 p=ro; \n\n  int iter = 0;\n  \n  float t = intersect(ro, rd, iter);\n    \n  if(t > -0.5) {\n    p = ro + t * rd;\n    col = lighting(p, rd, iter); \n    col = mix(col, bg, 1.0-exp(-0.001*t*t)); \n  } \n    \n\n  col=post(col, q);\n  fragColor=vec4(col.x,col.y,col.z,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3fR7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[313, 313, 346, 346, 431], [433, 433, 460, 460, 547], [549, 549, 582, 582, 873], [875, 875, 893, 893, 1152], [1156, 1156, 1205, 1205, 1477], [1479, 1479, 1519, 1519, 1721], [1723, 1723, 1749, 1749, 1957], [1959, 1959, 2001, 2001, 2231], [2233, 2233, 2262, 2262, 2511], [2513, 2513, 2571, 2571, 3355]], "test": "untested"}
{"id": "tlcfRM", "name": "To The Top", "author": "Plento", "description": "Anyone know any tricks to get rid of the ugly artifacts here? I know its because offseting the steps messes with the distance function so I guess I'm looking for ways to compensate for that in general (besides just decreasing the march step bias.)", "tags": ["3d", "stairs"], "likes": 9, "viewed": 373, "published": 3, "date": "1612416041", "time_retrieved": "2024-07-30T19:40:49.321569", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define tA(p) texture(iChannel0, p)\n#define tB(p) texture(iChannel1, p)\n\nfloat sub(float d1, float d2){return max(-d1, d2);}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 rep(vec3 p, vec3 b){return mod(p, b) - b*0.5;}\n\n#define stepWidth 0.2\n#define stepHeight 0.25\n#define stepLength 4.0\n\n#define b vec3(0., 8., stepWidth*2.0)\n\nfloat map(vec3 rp){\n    float d = 99.;\n    rp += vec3(-1.3, 3.65+iTime - 5., -12. + iTime);\n    vec3 p = rp;\n    \n    vec3 id = floor(p / b);\n    \n    p.y -= id.z*0.4; // Offset for stairs\n    p = rep(p, b);\n    \n    d = min(box(p, vec3(stepLength, stepHeight, stepWidth)), d);\n    d = min(stepLength - abs(rp.x), d);\n    \n    rp = mod(rp, vec3(12.))-b*0.5;\n    d = sub(box(rp, vec3(6.0, 6.0, 6.0)), d);\n    \n    return d;\n}\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = 2.*vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.9));\n    vec3 ro = vec3(0.);\n    \n    rd.yz*=rot(-.2+cos(iTime*3.)*0.02);\n    rd.xz*=rot(-.2);\n    \n    float t = 0., d = 0., ns = 0.;   \n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .002){\n            break;\n        }\n        t += d * .7;\n        ns++;\n    }   \n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    vec3 lp = vec3(0., 5.0, .1);\n    vec3 ld = lp-p;\n    \n    float dif = max(dot(n, ld), .1);\n    float dd = length(ld);\n    float fal = 1.9/(dd*dd) + (cos(iTime*44.)+cos(iTime*32.))*0.0005;\n    \n    p += vec3(-1., 3.+iTime - 5., -12. + iTime);\n    \n    vec3 id = floor(p / b);\n    float o = cos(id.z*2233.3)*.5;\n    \n    p.x*=.5;\n    vec3 col = (abs(n.x)>.99) ? tB(p.yz*.2).xyz : mix(tB((p.xy+o)*.2).xyz, tA(p.xz*.2).xyz, abs(n.y));\n    col *= dif * fal;\n    \n    //col *= max(ss(2.0, 0.4, ns/24.), 0.0);\n    \n    col = mix(vec3(.12), col, exp(-t*t*t*0.00001));\n    \n    \n    \n    col *= 4.;\n    col = col.xyy*col.xyy*col.xyy;\n    \n    \n    //col -= fwidth(p-ro)*1.;\n    //col *= 10.*fwidth(t);\n    \n    //col*=ss(.9,.895, abs(uv.y));\n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n    //f = vec4(10.*fwidth(p-ro),1); return;\n    //f = vec4(10.*fwidth(t)); return;\n}\n\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 240, 240, 261], [263, 263, 291, 291, 378], [380, 380, 405, 405, 431], [542, 542, 561, 561, 966], [967, 967, 994, 994, 1195], [1197, 1197, 1237, 1237, 2549]], "test": "untested"}
{"id": "wl3cDj", "name": " Water Surface Simulation", "author": "TinyTexel", "description": "A minimalist grid based water simulation that accounts for the dispersion relation of surface gravity waves.\n", "tags": ["wave", "simulation", "water"], "likes": 92, "viewed": 2944, "published": 3, "date": "1612401925", "time_retrieved": "2024-07-30T19:40:50.473490", "image_code": "// author: Mirko Salm (https://twitter.com/Mirko_Salm)\n\n/*\n\nA minimalist grid based water simulation that accounts for the dispersion relation of surface gravity waves.\n\n\nMy main contributions here are: \n\n    - two dispersion kernels (13 tabs in 1 pass / 30 tabs in 2 passes) with which the vertical acceleration of deep water can be computed\n    - a blending scheme that locally morphs a deep water kernel into one that handles shallow water\n    - a high quality rendering approach based on an efficient C2 continuous bicubic reconstruction of the water height field\n\n\nAlgorithm overview:\n\n    Buffer A: water simulation (solves a simple second order partial differential equation using Verlet integration)\n    Buffer B: horizontal pass of the high quality dispersion kernel (the complementing vertical pass is part of Buffer A)\n    Buffer C: bicubic pre-filtering of the simulation result (computes smoothed partial derivatives + height field values at grid vertices)\n    Image   : rendering using the pre-filtered water height field stored in Buffer C\n\n\nControls:\n\n    left mouse (hold/click) - add water (hold shift key for individual droplets)\n    space key  (hold)       - flatten/dampen water surface\n\n    [1] - toggle terrain animation off/on\n    [2] - toggle grid windowing off/on (off leads to waves being reflected at the borders of the grid)\n    [3] - toggle mini map on/off (also shows if windowing is active)\n    [4] - toggle wave field rendering style in mini map between |gradient|² and height value\n    [5] - toggle rain drops off/on\n\n\n\n▬▬▬ 0.Motivation and previous work ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nVolumetric fluid simulations can achieve impressive and interesting results both visually as well as gameplay-wise.\nHowever, in cases where we are only interested in a small subset of those possible results, a more minimalist approach might suffice.\nA typical case could be a scene where objects interacting with a body of water are supposed to cause believable disturbances to its surface. \nIf those disturbances are rather small than it can be reasonable to model them as deformations to a height field instead of to a volume.\n\nCompared to volumetric models height field based fluid simulations are usually less memory and performance intensive while being easier to implement and maintain.\nNaturally, this makes them an attractive choice in many cases.\n\nAs early as 1990 [1] described the idea of using a height field based water simulation in the context of computer graphics.\nWhere [1] proposed to use an implicit integration scheme to advance the simulation, [2] instead opted for a simple Verlet integrator; effectively trading stability for simplicity.\nAnother aspect in which [1] and [2] differed is that in an attempt to simulate deep instead of shallow water (as was done in [1]) [2] replaced the operator with \nwhich the vertical acceleration of the height field was computed. Source code of a practical implementation of that method can be found in [4].\nIn [5] the same author addressed the stability issue of the Verlet integrator by introducing an exponential solver.\n\nThe deep water operator introduced in [2] is rather computationally expensive as it is implemented via a non-separable 13x13 convolution kernel.\nAlso, no theoretical background on that operator is provided. Both of these concerns will be addressed here.\n\nBefore moving on it seems sensible to shortly motivate, from a phenomenological point of view, why we care about the difference of shallow and deep water.\nFor that purpose let us consider the idealized case of a single rain drop falling onto a perfectly flat water surface for which we ignore its surface tension. \nIn both cases circular wavefronts begin to emitt from the point where the drop hits the surface.\nIn the case of shallow water we can actually only observe a single wavefront while in deep water multiple wavefronts of different wavelengths \ntraveling at different velocities emerge. Replicating this dispersive behavior in deep water is one of the major challenges addressed here.\n\nIt is also important to note that for the type of waves considered here we are not interested in the absolute depth of the water but the wavelength-relative depth.\nTherefore, an absolute water depth that may be considered \"deep\", i.e. larger than 0.5*λ, for some wave with a wavelength λ of ~1m, could easily count as \"shallow\", \ni.e. smaller than 0.05*λ, for, let's say, a tsunami wavefront.\n\n\nabridged sources as a quick reference:\n\n[1] - \"Rapid, Stable Fluid Dynamics for Computer Graphics\"\n[2] - \"Interactive Water Surfaces\"\n[3] - \"Nonlocal diffusion and applications\"\n[4] - \"Simulating Ocean Water\"\n[5] - \"eWave: Using an Exponential Solver on the iWave Problem\"\n\n\n▬▬▬ 1.Basics and shallow water ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n \nA straightforward way to simulate an interactable water surface is to numerically solve the wave equation on a deformed height field [1]. The wave equation reads as follows:\n( https://en.wikipedia.org/wiki/Wave_equation )\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                         ░\n   ∂²                      \n   ―― h(x,y) = c ∇²h(x,y),   (Equation 1.1)\n   ∂t²                     \n ░                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nwhere\nt is time,\nh(x, y) is the water height at the coordiantes (x,y),\nc is a constant, and\n∇² is the spatial Laplace operator (sum of the second order partial derivatives, i.e. ∇²h(x, y) = ∂²h(x,y)/∂x² + ∂²h(x,y)/∂y²).\n\nThis equation tells us that the second derivative of the height field with respect to time (i.e. its vertical accelertion) is directly propotional to its Laplacian.\n\nIn [1] the authors show that the wave equation can indeed provide a reasonable approximation for shallow water if we set \n\n ░░░░░░░░░░░░\n ░          ░\n   c = g*D,   (Equation 1.2)\n ░          ░\n ░░░░░░░░░░░░\n \nwhere \ng is the acceleration due to gravity and \nD is the water depth (D>0).\n\nA minimalist implementation of a grid based simulation based on equation 1.1 can be broken down into two steps:\na. Compute the vertical acceleration of the height field using a discrete Laplace operator.\nb. Update the value of the height field based on its vertical acceleration.\n\n\n▬▬▬ Computing the Laplacian and the vertical acceleration ▬▬▬\n\nOn a regular grid the discrete Laplacian can be computed using one of the ubiquitous 3x3 Laplace kernels (see en.wikipedia.org/wiki/Discrete_Laplace_operator).\nUnfortunately, their quality is insufficient for our use case and does not result in a reasonable behaviour when plugged into the simulation.\nWe can, however, quite easily build kernels of good quality by windowing the infinite impulse response (IIR) filter we get from computing the Laplacian of the 2d sinc filter:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                                                       ░\n                 ∂²             ∂²\n   ∇²sinc(x,y) = ―― sinc(x,y) + ―― sinc(x,y)                                // the continuous IIR filter\n                 ∂x²            ∂y²\n                 \n   wnd(x) = max(0, 1-x²)²                                                   // the windowing function (falls off to 0 at x = 1)\n   \n                 ∂²\n   _lapKern[x] = ―― sinc(x) * wnd(x/(radius+1))                             // the unnormalized discrete FIR kernel in 1d (x ∈ int && |x| <= radius)\n                 ∂x²                                                        // square brackets are used to denote that only integer arguments are allowed\n   \n   lapKern[x] = x!=0 ? _lapKern[x] : _lapKern[0] - sum_all_tabs(_lapKern)   // the re-normalized 1d kernel, i.e. sum_all_tabs(lapKern) == 0\n   \n   lapKern[x,y] = s*(lapKern[x] + lapKern[y])                               // the final 2d kernel; \n ░                                                                        ░ // s is a constant that scales lapKern's frequency response so as to better match that of ∇²sinc\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n\n\nAs we can see, the resulting 2d filter is the sum of two 1d filters that compute the second order partial derivatives in the x and y directions, respectively.\nAs a result the number of tabs scales linearly with the filter radius making it feasible to use filters with relatively wide footprints.\nHowever, a filter with radius=4 already produces good results:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  \n ▒                                                                              ▒\n   float lapKern[5] = float[5](3.14, -1.848826, 0.353877, -0.091300, 0.016249);   // the associated 2d filter has 18 tabs = (radius*2+1) + (radius*2+1)\n ▒                                                                              ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  \n \nNote that we work with a negated Laplacian kernel here, i.e. s < 0. The reasons for doing so is that it will later help to streamline the generalization of the operator.\nA consequence of negating the kernel is that we need to alter equation 1.2 slightly: \n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒           ▒\n   c = -g*D.   (equation 1.2b)\n ▒           ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nWe can now compute the vertical acceleration A at a given grid vertex with coordinates (x,y) as\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                 ▒\n   A[x,y] = -g*D[x,y] * convolve(h[x,y], lapKern).   (equation 1.3)\n ▒                                                 ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n\n▬▬▬ Updating the height field ▬▬▬\n\nGiven the vertical acceleration we can use a basic Verlet integrator to update our height field:\n( https://en.wikipedia.org/wiki/Verlet_integration#Verlet_integration_(without_velocities) )\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                 ▒\n   h₀[x,y] = (2*h₋₁[x,y] - h₋₂[x,y]) + A[x,y]*Δt²,   (equation 1.4)\n ▒                                                 ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\nwhere\nh₀  is the height field state after the current time step,\nh₋₁ is the previous height field state,\nh₋₂ is the height field state preceding h₋₁,\nA   is the vertical acceleration at the previous time step, and\nΔt  is the duration of the time step (assumed to be constant).\n\nThe derivation shown on Wikipedia uses finite differences. \nA different approach to derive equation 1.4 is to perform a quadratic extrapolation using h₋₁, A, and h₋₂ to determine the parameters of the curve:\n   \n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ \n ░                                             ░\n   quadratic(t) = a + b*t + c*t²,\n   \n                    ∂² \n   quadratic''(t) = ―― quadratic(t) = 2c\n                    ∂t²\n                     \n   solve\n       h₋₁ = quadratic  (-1*Δt)\n       A   = quadratic''(-1*Δt)\n       h₋₂ = quadratic  (-2*Δt)\n   for a, b, and c.\n   \n   h₀ = quadratic(0) = (2*h₋₁ - h₋₂) + A*Δt² □ \n ░                                             ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nAt this point we have all we need to build a simple simulation for shallow water.\n\nThe approach outlined so far is very similar to the one described in [2].\nOne difference is that [2] adds a friction parameter α to the integration scheme resulting in the following expression:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                                ░\n            1            \n   h₀ = ―――――――――― ((2 + α Δt)*h₋₁ - h₋₂ + A*Δt²).  (equation 1.5)\n         1 + α Δt\n ░                                                ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n\nThe addition of friction helps to smooth out some of the high frequency noise that the Laplacian kernel produces.\nA similarly, if not even more, effective approach in that regard is to apply a subtle exponential smoothing to the height field state buffer:\n( https://en.wikipedia.org/wiki/Exponential_smoothing )\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                           ▒\n   h₀'  = h₋₁*(1-w) + h₀ *w,   (equation 1.6)\n   h₋₁' = h₋₂*(1-w) + h₋₁*w,\n ▒                           ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nwhere w = 1 - exp(-Δt*β) with β >= 0 being a damping constant.\n\nHowever, both approaches do not substantially improve the stability of the explicit integration scheme. \nEven just extending the integrator to support variable time steps can lead to the simulation becoming increasingly unstable over time.\nThese instabilities can manifest themselves for instance in the form of coherent wavefronts dispersing into multiple ones, additional wavefronts \nbeing spawned that travel in wrong directions, or, in the worst case, the whole simulation blowing up and corrupting the entire state buffer in a heartbeat.\nStable solvers for partial differential equations do of course exist (see [5] for one example specifically tailored to the problem at hand), \nbut they generally come at the cost of a lot of additional complexity.\n\n\nThe most substantial aspect in which the approach presented in [2] differs from the one described so far is the choice of the convolution kernel.\nThe reason for that is that [2] attempts to simulate deep instead of shallow water. In deep water the wavelength-to-speed relation is quite different. \nTo account for that [2] proposes to use a kernel that implements the half-Laplacian [3] instead of the common Laplacian.\nThe reasoning behind that choice is detailed in the following section.\n\n\n\n▬▬▬ 2.Intermediate depths and deep water ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nThe velocity of water waves depends on a variety of factors like their wavelengths, gravity, surface tension, and water depth.\nFor waves that are large enough that the effects of surface tension are negligible, i.e. so called surface gravity waves, \nthis dependency can be described by the following dispersion relation\n( https://en.wikipedia.org/wiki/Dispersion_(water_waves) )\n\n ░░░░░░░░░░░░░░░░░░░░░░░\n ░                     ░\n   ω² = g*k*tanh(k*D),   (equation 2.1)\n ░                     ░\n ░░░░░░░░░░░░░░░░░░░░░░░\n\nwhere\nω is the angular velocity of the wave,\ng is the acceleration due to gravity,\nk is the wavenumber (k = 2π/λ; λ being the wavelength),\nD is the water depth (D>0), and\ntanh is the hyperbolic tangent (tanh(x) = 2/(1 + exp(-2x)) - 1), which is a sigmoid curve ranging from -1 to 1 on the interval (-inf, +inf).\n\nIn shallow water, i.e. when D < 0.05*λ, equation 2.1 reduces to\n\n ░░░░░░░░░░░░░░░░\n ░              ░\n   ω² ≈ g*D*k².   (equation 2.2)\n ░              ░\n ░░░░░░░░░░░░░░░░\n\nIn deep water, i.e. when D > 0.5*λ, we get\n\n ░░░░░░░░░░░░░░░\n ░             ░\n   ω² ≈ g*|k|.   (equation 2.3)\n ░             ░\n ░░░░░░░░░░░░░░░\n \n\nIn an effort to generalize the shallow water model from the previous chapter let us first consider how the dispersion relation \ncan be used to relate the vertical acceleration of an individual sine wave to its function value:\n\n        wave(x,t) =     s*sin(k*x - ω*t), (Equation 2.4a)\n \n     ∂²\n A = ―― wave(x,t) = -ω²*s*sin(k*x - ω*t), (equation 2.4b)\n     ∂t²\n \n              ░░░░░░░░░░░░░░░░░░░░░░\n              ░                    ░\n  it follows    A = -ω²*wave(x,t).        (equation 2.5)\n              ░                    ░\n              ░░░░░░░░░░░░░░░░░░░░░░\n \nwhere\ns is the amplitude,\nk is the wavenumber (k = 2π/λ),\nω is the angular velocity,\nt is time, and\nA is the vertical acceleration.\n\nLet us now consider the height field that represents our water surface as a superposition, i.e. a sum, of an arbitrary number of sine waves.\nFor the purpose of computing the vertical acceleration of that height field we simply apply equation 2.5 to each of those sine waves individually.\nProceeding in this manner is justified by linearity and can be formally expressed via the Fourier transform as\n( https://en.wikipedia.org/wiki/Fourier_transform )\n\n ░░░░░░░░░░░░░░░░░░░░\n ░                  ░\n   A = ℱ⁻¹(-ω²*ℱh),   (equation 2.6)\n ░                  ░\n ░░░░░░░░░░░░░░░░░░░░\n \nwhere\n ℱ⁻¹ is the inverse Fourier transform,\n ℱ   is the forward Fourier transform, and\n h   is the height field representing the water surface.\n\nWhile equation 2.6 may look complicated, its practical implications are actually rather tame.\nTo compute A in our shallow water model we use a convolution kernel that approximates a negative Laplacian (remember that we flipped the sign of the operator (see Equation 1.2b)).\nThe frequency response of the (negative) Laplacian is a radially symmetric, bi-variate paraboloid:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                         ░\n   -∇²h(x,y) = ℱ⁻¹((kᵪ²+kᵧ²)*(ℱh)(kᵪ,kᵧ)).   (equation 2.7)\n ░                                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nIn the generalized model we simply replace this filter with one that has a frequency response that is equal to equation 2.1, i.e. the more general version of dispersion relation.\nIt is straightforward to show that inserting the shallow water dispersion relation, i.e. equation 2.2, into equation 2.6 gives us a result that is consistent with our work so far:\n \n A = ℱ⁻¹(-(g*D*k²)*ℱh) \n \n   = g*D*ℱ⁻¹(-k²*ℱh)  // g and D do not depend on the wavenumber so they can be moved out of the inverse Fourier transform\n            \n   = g*D*∇²h\n   \n   =-g*D*(-∇²)h. \n            \nDoing the same but with the deep water dispersion relation gives us:\n\n A = ℱ⁻¹(-(g*|k|)*ℱh) \n \n   = -g*ℱ⁻¹(|k|*ℱh) \n             ______   \n   = -g*ℱ⁻¹(√-(-k²)*ℱh) \n         ___\n   = -g*√-∇²h. \n                                                          ___\nThe square root of the Laplacian, or half-Laplacian [3], √-∇² does, at least for our purposes, nothing more than denote an operator that when applied to\na function convolves it with a linear filter that has a frequency response equal to |k| (in contrast to the frequency resonse of the negative Laplacian, which is k²).\n(The half-Laplacian is a special case of the fractional Laplacian [3], for which it is convention to defined it based on the negative Laplacian: (-∇²)ˢ with s ∈ (0,1).)\nThe frequency response of the half-Laplacian in 2d is a radially symmetric, bi-variate (upside down) cone:\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░  ___               _______              ░\n   √-∇²h(x,y) = ℱ⁻¹(√kᵪ²+kᵧ²*(ℱh)(kᵪ,kᵧ)).   (equation 2.8)\n ░                                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nLikewise, we can define the operator based on equation 2.1 as [3]\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░  ___      ___                  _______       _______                 ░\n   √-∇²tanh(√-∇²*D)h(x,y) = ℱ⁻¹(√kᵪ²+kᵧ²*tanh(√kᵪ²+kᵧ²*D)*(ℱh)(kᵪ,kᵧ)).   (equation 2.9)\n ░                                                                      ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n \nPutting it all together the ground-truth version of our generalized model computes the vertical acceleration of the height field as [4]\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒           ___      ___          ▒\n   A = -g * √-∇²tanh(√-∇²*D)h(x,y)   (equation 2.10)\n ▒                                 ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \n \nWhat complicates implementing equation 2.10 is the dependency of the filter kernel on the water depth D.\nFor the shallow water model this dependency reduced to a vertical scaling by D.\nBut in the general case the way the shape of the kernel changes with D is less straightforward.\nBasically, the shape of the frequency response of the kernel at intermediate depths is a cone with a bulge instead of a sharp tip at its center.\nHow large this bulge is depends on D. For shallow water this bulge grows so large that it covers all relevant frequency ranges and can be approximated by a paraboloid scaled by D.\nFor deep water, on the other hand, it shrinks so much that we can simply omit it and assume the spectrum to be a perfect cone with a sharp apex.\n\n[4] proposes to pre-compute a whole array of filter kernels for different values of D and than interpolate between them at runtime based on the local water depth.\nHowever, no reasonably sized FIR filter kernel can faithfully reproduce the desired asymptotic frequency response for deep water, i.e. |k|.\nThe reason for that is that windowing the IIR filter blurs out its frequency response.\nThis effect is quite prominent around the DC, i.e. at k=0, where the spectrum has a C¹ discontinuity (the apex of the cone shape).\nAs a consequence a kernel of practical size typically resembles the ground-truth at D~1 more so than it does for the originally intended D->∞.\n\nAlternatively, we could implement equation 2.9 directly using fast Fourier transforms (FFTs). This would get us an accurate frequency response but at the cost of performance.\nOther downsides of this approach would be a substantial increase in implementation complexity and reduced flexibility.\nThis is because when using FFTs we would need to simulate the entire grid at each time step while using spatial FIR kernels allows us to selectively \ncompute A where it is required (after all, large parts of the grid might be masked out due to geomtry replacing the water in these regions).\n\nTherefore, we will stick to the spatial FIR filter based implementation approach here and simply accept that as a consequence we are not able to accurately handle D>1.\n\nIn an attempt to support variable water depths with minimal effort we simply interpolate between a shallow and a deep water kernel.\nThe shallow water kernel is already given by the discrete Laplacian filter described in section 1.\nIn order to complete the picture we still need a discrete FIR kernel for deep water and\na blending scheme that combines the two kernels in a way that results in a sensible approximation of equation 2.10.\n\n\n▬▬▬ Deep water dispersion kernels ▬▬▬\n\nSimilar to the shallow water kernel, the shape of the deep water kernel in frequency space is not particularly complex.\nHowever, the additional square root operation that turns the paraboloid into a cone does complicate the computation of the spatial kernel shape considerably [3].\nLuckily in our case the computation of the kernel is not performance critical so we can brute force the problem numerically by \npeforming an approximate inverse Fourier transform of the brick-wall filtered half-Laplacian to determine the tab weights of the discrete filter.\nThe resulting weights are windowed using max(0, 1-(x²+y²))², which is just a radially symmetric variant of the window we used in section 1.\nLastly the windowed kernel is renormalized and empricially scaled to match the ground-truth reference.\nAs discussed before no reasonably large FIR filter can actually approximate the half-Laplacian, i.e. asymptotic deep water kernel, well.\nTherefore we use the general model with D=1 as the reference that we try to match when scaling the kernel.\nBy not already using the general model with D=1 for the computation of the original tab weights we end up with a\ncompromise between the kernel we would ideally like to approximate and the one that we can actually still decently replicate in practice.\n\nComputing a 5x5 and a 15x15 kernel with this approach results in the following weights (one quadrant):\n\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n ░                                                                ░  \n   float hLapKern[9] = float[9]( 2.25    , -0.509315,  0.023306, \n                                -0.509315, -0.070842, -0.002754,    (kern5x5)\n                                 0.023306, -0.002754, -0.000141);\n ░                                                                ░  \n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ \n        \n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░      \n ░                                                                                                                         ░\n   float hLapKern[64] = float[64]( 2.32    , -0.472083,  0.050161, -0.030779,  0.009510, -0.005206,  0.001515, -0.000381, \n                                  -0.472083, -0.083063, -0.008956, -0.005801, -0.000604, -0.000797, -0.000027, -0.000047,  \n                                   0.050161, -0.008956, -0.006594, -0.002202, -0.001030, -0.000306, -0.000111, -0.000012, \n                                  -0.030779, -0.005801, -0.002202, -0.001290, -0.000496, -0.000210, -0.000049, -0.000004,    (kern15x15)\n                                   0.009511, -0.000604, -0.001030, -0.000496, -0.000259, -0.000084, -0.000018,  0.      , \n                                  -0.005206, -0.000797, -0.000306, -0.000210, -0.000084, -0.000025, -0.000001,  0.      , \n                                   0.001515, -0.000027, -0.000111, -0.000049, -0.000018, -0.000001,  0.      ,  0.      , \n                                  -0.000381, -0.000047, -0.000012, -0.000004,  0.      ,  0.      ,  0.      ,  0.      );        \n ░                                                                                                                         ░\n ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░\n\n\nWhen comparing the simulation behaviors resulting from these two kernels it becomes clear that kern5x5 provides only a poor approximation of kern15x15.\nAnd that while, judging from its frequency response, even Kernel15x15 itself is only a decent approximation for D=1. \nThe two takeaways here are that on the one hand using a compact kernel we can not expect to get much more out of it than a rough scetch of the wave behavior in deep water.\nAnd on the other hand, if we do aim to achieve even just a decent approximation of the ground-truth behavior at reasonable \ncomputational costs we need a more efficient way to compute the half-Laplacian.\n\n\n--- Compact deep water kernels ---\n\nConsidering our modest expectations regarding the simulation quality achieveable by small kernels like kern5x5 \nit seems worth exploring how far further we can reduce the number of used filter tabs without sacrificing even more quality.\n\nThe two important optimization criteria we need to balance here are the isotropy of the spectral response and \nits shape in the upper frequency range (the lower range is a lost case for small kernels anyway).\nThe construction approach outlined in the following attempts to streamline this balancing act.\n\nFirst, we construct a high-pass filter kernel with optimized radial symmetry in frequency space (by optimizing the tab weights explicitly via least squares). \nIts frequency response will be naturally bell curve shaped (since FIR filters tend towards a shoulder/toe when approaching Nyquist).\nWe then blend this kernel with a discrete Laplacian, which has a paraboloid shaped frequency response, to match the reference spectrum as well as possible.\nSince both kernels individually already feature decently isotropic spectra any kernel resulting from a weighted sum of the two does as well.\n\nA possible result using a 13 taps kernel with a diamond shaped footprint has the following weights (one quadrant; including 0-weights):\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                                ▒\n   float hLapKern[9] = float[9]( 2.093378, -0.329871, -0.026409,\n                                -0.329871, -0.167064,  0.      ,    (kern13)\n                                -0.026409,  0.      ,  0.      ); \n ▒                                                                ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nThe choice to use a diamond shaped footprint is motivated by the fact that by using a 3x3 footprint we can already construct a reasonably isotropic spectrum \nfor the high-pass kernel while the quality of the blended in Laplace kernel benefits from a slightly larger radius. \nAdding another 8 tabs in the main directions so an even wider Laplace kernel can be used results in the following 21 tabs kernel (one quadrant; including 0-weights):   \n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                                                      ▒\n   float hLapKern[25] = float[25]( 2.269921, -0.450589, 0.017898, -0.010277, 0.003477, \n                                  -0.450589, -0.127990, 0.      ,  0.      , 0.      , \n                                   0.017898,  0.      , 0.      ,  0.      , 0.      ,    (kern21)\n                                  -0.010277,  0.      , 0.      ,  0.      , 0.      , \n                                   0.003477,  0.      , 0.      ,  0.      , 0.      );     \n ▒                                                                                      ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\nThe difference in quality between kern13 and kern21 becomes only really noticeable once we end up dynamically \nfading out the high-pass kernel contribution in shallow water (see the \"Blending shallow and deep water kernels\" section).\n\n\n--- A high quality deep water kernel ---\n\nThe idea of blending multiple kernels together can also be used to construct a (comparatively) high quality half-Laplacian kernel with a wider footprint.\nWe achieve this by replacing the single compact high-pass kernel used previously with two larger separable kernels.\nHaving, in addition to the discrete Laplacian, two instead of just one high-pass filtering results available gives us \nanother degree of freedom for optimizing the spectral response of the filter.\nThe disantvantage of this approach over the compact kernels described previously is that in order to be efficient we need to perform the convolution in two passes.\nDoing so increases implementation complexity as well as causing a not insignificant performance overhead due to the necessary round trip through global memory.\nThe following kernels and pseudo code demonstrate a possible implementation of this idea:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                                                                                                               ▒\n   float lowKern3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    \n   float lowKern7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    \n   float lapKern7[8] = float[8](3.22, -1.933599, 0.438458, -0.163745, 0.070153, -0.02964, 0.01061, -0.002237);   \n ▒                                                                                                                                               ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                           ▒\n   h' = (convolveX(h₋₁, lowKern3), \n         convolveX(h₋₁, lowKern7), \n                   h₋₁           , \n         convolveX(h₋₁, lapKern7))\n   \n   lowpass3  = convolveY(h'.x, lowKern3)\n   lowpass7  = convolveY(h'.y, lowKern7)\n   laplacian = convolveY(h'.z, lapKern7) + h'.w\n   \n   highpass = h'.z - lerp(lowpass3, lowpass7 , 0.772)\n   halfLaplacian =   lerp(highpass, laplacian, 0.190)*1.255;    (kernHQ)\n   \n   A = -g * halfLaplacian\n ▒                                                           ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  \n\n(An isolated implementation of this pseudo code can be found here: https://www.shadertoy.com/view/wtGyzK (also shows a plot of the spectral response of the kernel).)\n\nThe resulting kernel kernHQ is a reasonable approximation for the ground-truth kernel at D=2. \nThis means that we, in addition to performance, also improved the quality of the simulation when compared to the results achieved with kern15x15.\n\nLooking at the simulation results we can see that, in comparison to the compact kernels, the high quality kernel produces a less stiff wave propagation behavior   \ndue to the increased relative speed of the lower frequency waves. That behavior can, however, become somewhat less apparent the more chaotic the wave field becomes.\n\n(Side note: the deep water kernel proposed in [2] is the half-Laplacian of a Gaussian (which is not explicitly stated in the article). \nI managed to derive the analytical form from the numerical one presented there, but failed (in multiple attempts) to achieve useful results using that kernel. \nUsing the half-Laplacian of a Gaussian instead of a sinc function leads to incorrect dispersion behavior in the high ends. \nFor example, in the case of a water drop hitting a flat surface this leads to high frequency oscillations being emitted from the point of impact for a long time.\nI suspect that the author might have compensated this erroneous behavior by additionally damping the integration.)\n\n\n▬▬▬ Blending shallow and deep water dispersion kernels ▬▬▬\n\nWith a shallow and a deep water kernel at hand we can now dynamically blend between the two in an attempt to approximate the wave propagation behavior at intermediate depths.\nThe reference operator we try to match is the one based on the intermediate depth dispersion relation for surface gravity waves (equations 2.1 and 2.10):\n\n shallow (D < 0.05*λ)               intermediate                   deep (D > 0.5*λ)\n ░░░░░░░░░░░░░░░░░░░░░     ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒      ░░░░░░░░░░░░░░░░░░░░░\n ░                   ░     ▒           ___      ___      ▒      ░             ___   ░\n   A = -g * D*(-∇²)h  🠈🠊   A = -g * √-∇²tanh(√-∇²*D)h    🠈🠊    A = -g * (√-∇²)h \n ░                   ░     ▒                             ▒      ░                   ░\n ░░░░░░░░░░░░░░░░░░░░░     ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒      ░░░░░░░░░░░░░░░░░░░░░\n \nFor now let us assume that if D>1 using the deep water kernel without further modifications is already optimal. This means we concern ourselfs only with the interval D ∈ [0,1].\nUnder this assumption a reasonable choice for a straightforward blending approach is:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                            ▒\n   kern = (shallowKern*(1-w) + deepKern*w)*D,   (equation 2.11)\n ▒                                            ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nwith w = ξ(D), where ξ(D) is a transfer function that optimizes the blending behaviour.\n\nA good approximation to a possible least-squares optimization result for this transfer function is\n\n ░░░░░░░░░░░░░░░░░░░░\n ░                  ░\n            13 D²\n   ξ(D) = ――――――――.   (equation 2.12)\n          4 + 9 D²\n ░                  ░\n ░░░░░░░░░░░░░░░░░░░░\n \nThe way the kernel stops morphing as D approaches 1 can be a bit abrupt, though.       \nTo mitigate this we can slightly dampen the blending behavior by adapting the coefficients as follows\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                  ▒\n            7 D²\n   ξ(D) = ――――――――.   (equation 2.13)\n          2 + 5 D²\n ▒                  ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nIf we chose to use the high quality deep water kernel we need account for the fact that kernHQ approximates D=2 instead of D=1 (as was our initial assumption here).\nIt is however relatively straightforward to do so by only slightly modifying how the highpass filtering contribution is computed:\n \n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                                                       ▒\n   highpass = h'.z - lerp(lowpass3, lowpass7, 0.772*D2),\n ▒                                                       ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n \nwhere D2 = min(max(0, D-1), 1) (i.e. we linearly blend in the lowpass7 contribution as D approaches 2 after passing 1).\n\nAn animated spectrum plot of the resulting kernel can be found here: https://www.shadertoy.com/view/WtcfzN (also allows to plot kern13).\n\nOne complication with equation 2.11 is that scaling the vertical acceleration by D leads to erroneous simulation \nbehavior along shorelines (shorelines emitting high frequency waves) if the features of the obstacle height map are not aligned with the main axes of the grid. \nOversampling the [0,1]-clamped D value does help, but not substantially.\nOversampling the whole simulation step using high quality reconstructions when sampling both the water state buffer as well as the obstacle height field would likely\nresolve the issue, but is impractical in many cases. An easy and effective way to mitigate the problem is to linearly remap D so it does not completely fall off to 0:\n\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒\n ▒                   ▒\n   D' = D*(1-σ) + σ,   (equation 2.14)\n ▒                   ▒\n ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ \n \nwhere σ is a remapping constant.\n \nDoing so sacrifices simulation accuracy while still retaining the non-linear character of the overall behavior.\n\n\n▬▬▬ 3.Rendering ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nThere are two primary issues we face when it comes to rendering the water surface. First our height field likely contains a significant amount of \nhigh frequency noise caused by the contributions of the Laplacian kernels (even by those baked into the deep water kernels).\nAnd second, we need an efficient way to compute high quality normals since the shading of water is typically characterized by specular reflections\nof which the quality is quite susceptible to C2 discontinuities and, especially inconvenient for us, to high frequency noise.\n\nFortunately both of those concerns can be accounted for by performing a C2 continuous bicubic reconstruction using an aggressive filter during the pre-filtering pass.\nA demo of the technique can be found here: www.shadertoy.com/view/WtsBDH (\"Bicubic C2 cont. Interpolation\").\nAnd the derivation is documented here:     www.shadertoy.com/view/3tfBzX (\"Cubic Reconstruction\").\n\nWhat this approach boils down to is that in a pre-filtering pass we reconstruct the height field exactly at its vertices using a C2 continuous bicubic filter kernel\nto evaluate the function value plus a number of partial derivatives of the filter-associated continuous height field.\nBy storing the filtered derivatives alongside the filtered value we are able to efficiently evaluate the continuous height field\nusing only the data stored at the vertices of the local 2x2 neighborhood of any given evaluation point.\nDifferent to the demo linked above we don't use the interpolating kernel here but a generalization of the bicubic B-spline that uses \nadditional side lobes (resulting in a 5x5 kernel). We set the side lobes weight so that the frequency response of the filter falls off to 0 at the Nyquist frequency.\nThis filters out virtually all of the noisy frequency content and does so in a highly radially symmetric fashion.\n\n\n▬▬▬ 4.Conclusion ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n\nImplementing a height field based water simulation is comparatively straightforward. \nHowever, the choice of the dispersion kernel used to compute the vertical acceleration of the height field can be surprisingly nuanced.\nHere we proposed a number of shallow and deep water dispersion kernels that offer different performance-quality tradeoffs.\nIn addition, we presented a novel approach that locally performs a water depth dependent blending between a given shallow and a deep water kernel.\nFinally, we showed how the rendering of the resulting height field can benefit from using a C2 continuous reconstruction and how to implemented it efficiently.\n\nAn interesting extention to the algorithm at hand would be a phase shift filter that computes the horizontal offsets necessary for turning the sinusoidal wave field\ninto one that is composed of Gerstner waves. [4] shows how to do just that using FFTs. However, an implementation based on spatial FIR filters might be more practical.\n\n\n▬▬▬ Sources ▬▬▬\n▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬\n \n[1] - Kass, Michael, and Gavin Miller. \"Rapid, stable fluid dynamics for computer graphics.\" \n      Proceedings of the 17th annual conference on Computer graphics and interactive techniques. 1990.\n      pdf: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.89.1204&rep=rep1&type=pdf\n\n[2] - Jerry Tessendorf, “Interactive Water Surfaces,” \n      Game Programming Gems 4 , ed. Andrew Kirmse, Charles River Media, (2004).\n      pdf: http://people.clemson.edu/~jtessen/papers_files/Interactive_Water_Surfaces.pdf\n      \n[3] - Bucur, Claudia, and Enrico Valdinoci. \"Nonlocal diffusion and applications.\" \n      Vol. 20. Cham: Springer, 2016.\n      pdf: https://www.researchgate.net/publication/275669247_Nonlocal_Diffusion_and_Applications\n\n[4] - Tessendorf, Jerry. \"Simulating ocean water.\" \n      Simulating nature: realistic and interactive techniques. SIGGRAPH 1.2 (2001): 5.\n      pdf: https://www.researchgate.net/publication/264839743_Simulating_Ocean_Water\n      \n[5] - Tessendorf, Jerry. \"eWave: Using an Exponential Solver on the iWave Problem.\" \n      Technical Note (2014).      \n      pdf: https://people.cs.clemson.edu/~jtessen/reports/papers_files/ewavealgorithm.pdf\n      \n      \n      \nRelated:\n\n  Simulation\n- https://www.shadertoy.com/view/wtGyzK | \"half-Laplacian\"                     (plot of the half-Laplacian kernel)\n- https://www.shadertoy.com/view/WtcfzN | \"Gravity Waves Dispersion Kernel\"    (plot of the frequency response of the depth dependent dispersion kernel)\n\n  Rendering\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"               (derivation of the bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/wlsBz2 | \"C2-interpolating cubic Kernel\"      (plot + background info on the kernel used to compute the derivatives)\n\n*/\n\n\n\n\n\n// CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n// To the extent possible under law, Mirko Salm has waived all copyrights and related or neighboring rights to this work.\n\n// CUBIC AND BICUBIC RECONSTRUCTION KERNELS ============================================================================================\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nfloat kern_vD1(float x) { return x*(abs(x)*6.0-6.0); }\nfloat kern_dD1(float x) { return (abs(x)-1.0)*(abs(x)*3.0-1.0); }\n\nfloat kern_vD2(float x) { return abs(x) * 12.0 - 6.0; }\nfloat kern_dD2(float x) { return x * 6.0 + (x > 0.0 ? -4.0 : 4.0); }\n\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nmat4 kern4x4(vec2 p)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    mat4 m = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n    \n    return m;\n}\n\nvoid kern4x4(vec2 p, out mat4 mA, out mat4 mB)\n{\n    vec2 v   = vec2(kern_v  (p.x), kern_v  (p.y));\n    vec2 d   = vec2(kern_d  (p.x), kern_d  (p.y));\n    \n    vec2 vD1 = vec2(kern_vD1(p.x), kern_vD1(p.y));\n    vec2 dD1 = vec2(kern_dD1(p.x), kern_dD1(p.y));\n    \n    vec2 vD2 = vec2(kern_vD2(p.x), kern_vD2(p.y));\n    vec2 dD2 = vec2(kern_dD2(p.x), kern_dD2(p.y));\n    \n    mA = mat4\n    (\n        /*   kernDx       |  kernDy       |  kernDxy        |  kern    */\n        vec4(dD1.x * v.y  ,  d.x * vD1.y  ,  dD1.x * vD1.y  ,  d.x * v.y),\n        vec4(vD1.x * d.y  ,  v.x * dD1.y  ,  vD1.x * dD1.y  ,  v.x * d.y),\n        vec4(dD1.x * d.y  ,  d.x * dD1.y  ,  dD1.x * dD1.y  ,  d.x * d.y),\n        vec4(vD1.x * v.y  ,  v.x * vD1.y  ,  vD1.x * vD1.y  ,  v.x * v.y)\n    );\n\n    mB = mat4\n    (\n        /*   kernDxx      |  kernDyy      |  kernDxxy       |  kernDxyy    */\n        vec4(dD2.x * v.y  ,  d.x * vD2.y  ,  dD2.x * vD1.y  ,  dD1.x * vD2.y),\n        vec4(vD2.x * d.y  ,  v.x * dD2.y  ,  vD2.x * dD1.y  ,  vD1.x * dD2.y),\n        vec4(dD2.x * d.y  ,  d.x * dD2.y  ,  dD2.x * dD1.y  ,  dD1.x * dD2.y),\n        vec4(vD2.x * v.y  ,  v.x * vD2.y  ,  vD2.x * vD1.y  ,  vD1.x * vD2.y)\n    );\n}\n\n\n// BICUBIC SAMPLING ROUTINES =============================================================================================================\n\n// this is the most basic version which only evaluates the function value\nfloat SampleBicubic(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n// ... this version also outputs derivatives (used here to compute normals)\nvec4 SampleBicubic2(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        r += kern4x4(l) * c;\n    }\n    \n    // r = vec4(df/dx, df/dy, ddf/dxy, f)\n\treturn r;\n}\n\n// ... this version also outputs higher order derivatives (only used to debug C2 continuity here)\nvec4 SampleBicubic3(sampler2D channel, vec2 uv, out vec4 d2)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    d2 = vec4(0.0);\n    vec4 r = vec4(0.0);\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        if(i != 0) l.x -= 1.0;\n        if(j != 0) l.y -= 1.0;\n        \n        mat4 mA, mB;\n        kern4x4(l, /*out*/ mA, mB);\n        \n        r  += mA * c;\n        d2 += mB * c;\n    }\n    \n    // r  = vec4(  df/dx,   df/dy,  ddf/dxy ,         f)\n    // d2 = vec4(ddf/dxx, ddf/dyy, dddf/dxxy, dddf/dxyy)\n\treturn r;\n}\n\n\n// IMAGE ==========================================================================================================================\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel2, ivec2(keyCode, 2), 0).x;}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    #if 0\n    fragColor = texelFetch(iChannel1, ivec2(uv0-0.5), 0);\n    return;\n    #endif\n\n    bool isTerrainAnimated = ReadKeyToggle(KEY_N1) == 0.0;\n\n   #if 1\n    // mini map\n    bool doShowWaveField = ReadKeyToggle(KEY_N3) != 0.0;\n   \n    if(doShowWaveField)\n    if(uv0.x < GridSize && uv0.y < GridSize)\n    {\n        vec3 col = vec3(1.0) - normalize(vec3(texelFetch(iChannel0, ivec2(uv0 - 0.5), 0).xy, .01)).z;\n        \n        float d = EvalTerrainHeight(uv0, isTerrainAnimated ? iTime : 0.0);\n        \n        bool doShowHeightField = ReadKeyToggle(KEY_N4) != 0.0;\n        if(doShowHeightField) col = (texelFetch(iChannel0, ivec2(uv0 - 0.5), 0).www * 1.0 + 0.5);\n        \n        col *= col;\n\n        float l = -min(d, 0.0)*3.;\n        col = mix(vec3(0.125, 0.125, 1.0 ), col, 1.0-(exp2(-(l*2.0 + l*l*1.0))));\n        col = mix(col, vec3(1.0  , 0.0  , 0.25), smoothstep(-0.05, 0.0, d));\n\n        bool isGridWindowSharp = ReadKeyToggle(KEY_N2) != 0.0;\n        if(isGridWindowSharp && (uv0.x == 0.5 || uv0.y == 0.5 || uv0.x == GridSize-0.5 || uv0.y == GridSize-0.5)) col = vec3(0.0, 1.0, 1.0); \n\n        fragColor = vec4(sqrt(clamp01(col.rgb)), 0.0);\n        return;\n    }\n   #endif\n \n    vec3 col;\n    \n    vec2 uv = uv0;\n    vec2 tc = uv0 / iResolution.xx;\n    \n   #if 0\n    if(uv0.x >= iResolution.x*0.5)\n    uv.x -= iResolution.x*0.5;\n   #endif\n    \n    col = vec3(texture(iChannel0, uv0/iResolution.xy*0.125).r);\n    \n    \n    vec2 uv2 = PatchUVfromScreenUV(uv0.xy, iResolution.xy);\n\n    float time = isTerrainAnimated ? iTime : 0.0;\n\n    vec3 V = vec3(0.0, 0.0, 1.0);\n    vec3 L = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 L2 = normalize(vec3(-1.0, -1.0, 2.0));\n    vec3 H = normalize(L + V);\n\n\n    vec3 terrN;\n    {\n        float s = 1.0/128.0;\n        \n        float hx0 = EvalTerrainHeight(uv2 - vec2(s, 0.0), time);\n        float hx1 = EvalTerrainHeight(uv2 + vec2(s, 0.0), time);\n        float hy0 = EvalTerrainHeight(uv2 - vec2(0.0, s), time);\n        float hy1 = EvalTerrainHeight(uv2 + vec2(0.0, s), time);\n        \n        vec2 dxy = vec2(hx1 - hx0, hy1 - hy0) / (2.0 * s);\n        \n        terrN = normalize(vec3(-dxy, 0.03));\n    }\n    \n    vec3 terrCol = clamp01(dot(terrN, L))*(1.0/(1.0+1.0*(1.0-clamp01(dot(terrN, H)))))*vec3(1.0)*0.05;\n\n\n    vec4 d2;\n    vec4 h = SampleBicubic3(iChannel0, uv2, d2);// sample water surface\n    \n    float nscale = 32.0;\n    vec3 N = normalize(vec3(-h.xy * nscale, 1.0));\n    \n    vec3 R = 2.0*dot(V, N)*N - V;\n\n    float ct = clamp01(dot(N, L));\n    float ct2 = dot(N, L) * 0.5 + 0.5;\n    \n    float d = h.w - EvalTerrainHeight(uv2-N.xy*4.0, time);\n    \n    float waterMask = smoothstep(-0.01, 0.01, d);\n    \n    // diffuse\n    float v =  clamp01(ct2+0.15);\n    v = 1.0-v;\n    v = cubic(v);\n    \n    col = exp(-(v * 12.0 + 5.) * vec3(0.05, 0.3, 1.))*1.4;\n    //col *= mix(0.25, 1.0, clamp01(dot(terrN, L)+0.5));\n\n    float l = max(0.0, d);\n    col = mix(terrCol, col, (1.0-exp2(-(l*2.0 + l*l*1.0))));\n    col += vec3(0.0, 0.25, 1.0)*0.1;\n    \n    // specular\n    float c = 1.0 - (dot(R, L)*0.5+0.5);\n    float c2 = 1.0 - (dot(R, L2)*0.5+0.5);\n    float spec = 0.0;\n    spec += smoothstep(0.9, 0.99, dot(R, L))*0.5; \n    float spec0 = spec;\n    spec += smoothstep(0.7, 0.9, dot(R, L))*0.125; \n    spec += smoothstep(0.8, 0.9, dot(R, L2))*0.02; \n    spec += smoothstep(0.95, 0.99, N.z)*0.02; \n    spec += exp2(-32.0*(c))*0.25;\n    \n    col += vec3(1.0) * spec * waterMask;\n    \n    col = GammaEncode(clamp01(col));\n    \n    fragColor = vec4(col, 0.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n    #define USE_HQ_KERNEL\n     \n    // #define USE_AXISALIGNED_OBSTACLES\n\nconst float GridScale = 100.0;// vertex spacing; 1 -> meters | 100 -> centimeters \n\nconst float GridSize = 256.0;// vertex count per dimension\n\n\n\nfloat TrigNoise(vec3 x, float a, float b)\n{\n    vec4 u = vec4(dot(x, vec3( 1.0, 1.0, 1.0)), \n                  dot(x, vec3( 1.0,-1.0,-1.0)), \n                  dot(x, vec3(-1.0, 1.0,-1.0)),\n                  dot(x, vec3(-1.0,-1.0, 1.0))) * a;\n\n    return dot(sin(x     + cos(u.xyz) * b), \n               cos(x.zxy + sin(u.zwx) * b));\n}\n\nfloat TrigNoise(vec3 x)\n{\n    return TrigNoise(x, 2.0, 1.0);\n}  \n\n\n\nfloat EvalTerrainHeight(vec2 uv, float time)\n{\n    uv -= vec2(GridSize * 0.5);\n    \n  #ifdef USE_AXISALIGNED_OBSTACLES\n    return max(max((-uv.x-64.0), uv.y-64.0), min((uv.x-32.0), -uv.y-8.0)) * 0.02;\n  #endif\n    \n    float w = time * 0.125;\n    //w = 0.0;\n    \n    float terr = -(TrigNoise(vec3(uv * 0.01, w)) + 1.0) * 0.5;\n    \n    return terr;\n}\n\n\nvec2 PatchUVfromScreenUV(vec2 screenUV, vec2 screenResolution)\n{\n    return vec2(GridSize * 0.5) + (screenUV - screenResolution.xy*0.5)/screenResolution.xx * 226.0;\n}\n\n\n/*\n// x: [0, inf], s: (-1, 1] / (soft, hard]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\nvec3 SoftClip(vec3 x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\n}\n\n*/\n\n\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nfloat cubic(float x) {return x*x*(3.-2.*x);}\nvec2  cubic(vec2  x) {return x*x*(3.-2.*x);}\nvec3  cubic(vec3  x) {return x*x*(3.-2.*x);}\nvec4  cubic(vec4  x) {return x*x*(3.-2.*x);}\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// constants rounded to nearest primes\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 v) { return uvec2(WellonsHash(v.x), WellonsHash(v.y)); }\n\n", "buffer_a_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* Simulation */\n\nfloat ReadKey(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\n#define FETCH(uv) texelFetch(iChannel0, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0).r\n#define FETCH2(uv) texelFetch(iChannel2, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0).r\n#define FETCH3(uv) texelFetch(iChannel2, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0)\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n\n    // =================================================================================== //\n    // program state\n    bool isGrid = uv0.x < GridSize && uv0.y < GridSize;\n    bool isStateColumn = uv0.x == iResolution.x - 0.5;\n    \n    if(!isGrid && !isStateColumn) { discard; }\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    int stateColumnX = int(iResolution.x - 1.0);\n    \n    float iFrameTest     = texelFetch(iChannel0, ivec2(stateColumnX, 0), 0).x;\n    vec4  iMouseLast     = texelFetch(iChannel0, ivec2(stateColumnX, 1), 0);\n    float iTimeDeltaLast = texelFetch(iChannel0, ivec2(stateColumnX, 2), 0).x;\n\n    bool isInit = float(iFrame) == iFrameTest;\n    if( !isInit)\n    {\n        iTimeDeltaLast = iTimeDelta;\n    }\n    \n    if(isStateColumn)\n    {\n        if(uv.y == 0) col = vec4(float(iFrame) + 1.0, 0.0, 0.0, 0.0);\n        if(uv.y == 1) col = iMouse;\n        if(uv.y == 2) col = vec4(iTimeDelta, 0.0, 0.0, 0.0);\n        \n        return;\n    }\n    \n    if(!isGrid) return;\n    // =================================================================================== //\n\n    col = vec4(0.0);\n    \n    vec2 h12 = texelFetch(iChannel0, uv, 0).xy;\n\n    bool isTerrainAnimated = ReadKeyToggle(KEY_N1) == 0.0;\n    \n    float terrH = EvalTerrainHeight(uv0, isTerrainAnimated ? iTime : 0.0);\n    float mask = smoothstep(0.0, -0.05, terrH);\n    float D = clamp01(-terrH);\n    float lD2 = clamp01(-terrH-1.0);\n    \n   \n#ifdef USE_HQ_KERNEL\n\n    // 30 tabs version (vertical pass; horizontal pass in Buffer B)\n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int y = -7; y <= 7; ++y)\n    {\n        vec3 f = FETCH3(uv + ivec2(0, y)).xyz;\n    \n        int i = abs(y);\n\n        lowpass3  += f.x * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f.y * lowp7[i];\n        laplacian += f.z * lapl7[i];\n    }\n\n    vec4 f0 = FETCH3(uv);\n    \n    laplacian += f0.w;\n    \n    float highpass = f0.z - mix(lowpass3, lowpass7, 0.772 * lD2);\n    float halfLaplacian =   mix(highpass, laplacian, 0.19)*1.255;\n\n    float Aa = laplacian;\n    float Ab = halfLaplacian;\n   \n#else\n\n   #if 0\n    // 21 tabs version\n    const int r  = 4;\n    const int r1 = r + 1;\n\n    float kernA[r1] = float[r1](3.14, -1.8488262937460072, 0.3538769077873216, -0.0913000638886917, 0.016249449847377015);\n\n    float kernB[r1*r1] = float[r1*r1](2.269921105564736    , -0.4505893247500618, 0.01789846106075618, -0.01027660288590306, 0.0034772145111404747, \n                                     -0.4505893247500618   , -0.1279900243271159, 0.                 ,  0.                 , 0.                   , \n                                      0.01789846106075618  ,  0.                , 0.                 ,  0.                 , 0.                   , \n                                     -0.01027660288590306  ,  0.                , 0.                 ,  0.                 , 0.                   , \n                                      0.0034772145111404747,  0.                , 0.                 ,  0.                 , 0.                   );  \n   #else\n    // 13 tabs version\n    const int r  = 2;\n    const int r1 = r + 1;\n \n    float kernA[r1] = float[r1](2.85, -1.5792207792207793, 0.15422077922077923);\n \n    float kernB[r1*r1] = float[r1*r1](2.0933782605117255  , -0.32987120049780483, -0.026408964879028916, \n                                     -0.32987120049780483 , -0.1670643997510976 ,  0.0                 ,\n                                     -0.026408964879028916,  0.0                ,  0.0                 );\n   #endif\n     \n      \n    float Aa = 0.0;\n    float Ab = 0.0;\n\n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float w = (kernB[abs(x) + abs(y) * r1]);\n\n        if(w == 0.0) continue;\n\n        float f = FETCH(uv + ivec2(x, y));\n\n        Ab += f * w;\n\n        if(y == 0) Aa += f * kernA[abs(x)];                \n        if(x == 0) Aa += f * kernA[abs(y)];                \n    }     \n\n#endif\n\n  #ifndef USE_AXISALIGNED_OBSTACLES\n    // mitigate erroneous simulation behavior along shorelines\n    D = mix(0.25, 1.0, D);\n  #endif\n  \n    float A = mix(Aa, Ab, (D*D) / (2.0/7.0 + 5.0/7.0 * (D*D))) * D;\n    \n   // A = Ab;// deep\n   // A = Aa * 0.5;// shallow\n\n    A *= -9.81*GridScale;\n\n\n    // painting\n    bool isSingleDrop = ReadKey(KEY_SHIFT) != 0.0;\n    \n    if(iMouse.w > 0.0 || (!isSingleDrop && iMouse.z > 0.0 || (iMouse.x != iMouseLast.x && iMouse.y != iMouseLast.y)))\n    {\n        vec2 c = PatchUVfromScreenUV(iMouse.xy, iResolution.xy);\n        \n        vec2 vec = (uv0 - c);\n  \n        if(!isSingleDrop)\n        if(iMouseLast.z > 0.0 || iMouseLast.w > 0.0)\n        {\n            vec2 c2 = PatchUVfromScreenUV(iMouseLast.xy, iResolution.xy);\n            \n            vec = uv0 - (c2 + (c-c2)*clamp01(dot(c-c2, uv0-c2)/dot(c-c2,c-c2)));\n        }\n  \n        float v = exp2(-dot(vec, vec) * 1.0);\n        h12 = mix(h12, vec2(0.75), v);\n    }\n    \n    if(iFrame == 0) h12 = vec2(0.0);\n\n    // rain drops\n    if(ReadKeyToggle(KEY_N5) == 0.0)\n    if(WellonsHash(uint(iFrame)) < 100000000u)\n    {\n        vec2 c = Float01(WellonsHash(uint(iFrame) * uvec2(3242174893u, 2447445397u) + 3u)) * GridSize;\n        vec2 vec = (uv0 - c);\n    \n        float v = exp2(-dot(vec, vec) * 1.0);\n        h12 = mix(h12, vec2(0.75), v);\n    }\n\n    float dt = 0.016667;\n    float dt2 =  dt * dt;\n\n    float h0 = 0.0;\n    float h1 = h12.x;\n    float h2 = h12.y;\n\n#if 1\n    // Verlet integration\n    h0 = (2.0 * h1 - h2) + A * dt2;\n\n#else\n\n    // ...damped version\n    float a = 1.0/2.0;\n    float adt = a * dt;\n    \n    h0 = (((2.0 + adt) * h1 - h2) + A * dt2) / (1.0 + adt);\n\n#endif\n\n    vec2 h01 = vec2(h0, h1);\n\n    // exponential state buffer smoothing\n    float beta = 2.0;\n    h01 = mix(h01, h12, 1.0-exp2(-dt*beta));\n\n    // mask out obstacles\n    h01 *= mask;\n\n    // grid windowing\n    bool isGridWindowed = ReadKeyToggle(KEY_N2) == 0.0;\n    if(isGridWindowed)\n    {\n        float r = 32.0;\n\n        vec2 u = min((vec2(GridSize*0.5) - abs(uv0 - vec2(GridSize*0.5))) / r, vec2(1.0));\n\n        u = 1.0 - u;\n        u *= u;\n        u *= u;\n        u = 1.0 - u;\n\n        float s = u.x*u.y;\n\n        h01 *= mix(0.75, 1.0, s);        \n    }\n    \n    if(ReadKey(KEY_SPACE) != 0.0) { h01 *= 0.95; } \n    \n    col = vec4(h01, 0.0, 0.0);\n}\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/* horizontal pass of hq deep water kernel */\n\n#define FETCH(uv) texelFetch(iChannel0, clamp(uv, ivec2(0), ivec2(GridSize-1.0)), 0).r\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n  #ifndef USE_HQ_KERNEL\n    discard; return;\n  #endif\n  \n    bool isGrid = uv0.x < GridSize && uv0.y < GridSize;\n\n    if(!isGrid) return;\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int x = -7; x <= 7; ++x)\n    {\n        float f = FETCH(uv + ivec2(x, 0));\n    \n        int i = abs(x);\n\n        lowpass3  += f * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f * lowp7[i];\n        laplacian += f * lapl7[i];\n    }\n\n    float f0 = FETCH(uv);\n    \n    col = vec4(lowpass3, lowpass7, f0, laplacian);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    pre-filter pass (prepares height field for rendering)\n    https://www.shadertoy.com/view/WtsBDH (\"Bicubic C2 cont. Interpolation\")\n*/\n\n#define FETCH(uv) (texelFetch(iChannel0, uv, 0).r)\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    if(uv0.x > GridSize || uv0.y > GridSize) return;\n\n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n    \n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[3];\n    float kernD1[3];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 0\n   \n    sw = 0.25;// similar to 1/3 but less ringing\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 1\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n    \n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cDj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[49621, 49621, 49644, 49644, 49679], [49680, 49680, 49703, 49703, 49743], [49745, 49745, 49770, 49770, 49799], [49800, 49800, 49825, 49825, 49865], [49867, 49867, 49892, 49892, 49922], [49923, 49923, 49948, 49948, 49991], [49994, 49994, 50013, 50013, 50188], [50190, 50190, 50212, 50212, 50851], [50853, 50853, 50901, 50901, 52045], [52188, 52262, 52311, 52311, 52734], [52736, 52812, 52861, 52861, 53330], [53332, 53430, 53492, 53492, 54134], [54270, 54270, 54298, 54298, 54352], [54353, 54353, 54387, 54387, 54441], [54443, 54443, 54494, 54494, 58007]], "test": "untested"}
{"id": "WtcfzN", "name": "Gravity Waves Dispersion Kernel", "author": "TinyTexel", "description": "Spectrum plot of the depth dependent dispersion kernel used by the water simulation at: https://www.shadertoy.com/view/wl3cDj.", "tags": ["dispersion"], "likes": 5, "viewed": 404, "published": 3, "date": "1612401920", "time_retrieved": "2024-07-30T19:40:51.246423", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\nSpectrum plot of the depth dependent dispersion kernel used by the water simulation at: https://www.shadertoy.com/view/wl3cDj.\n\nBlue     - ground-truth spectrum\nMagenta  - cross-section of 2d spectrum along diagonals\nOrange   - cross-section of 2d spectrum along main axes\n\nThe value of the water depth D is shown at the bottom left (can be manually changed via mouse).\n\nCommon   - #define USE_HQ_KERNEL (13 tabs kernel is used if not defined)\nBuffer A - horizontal filter pass\nBuffer B - vertical filter pass + blending\nBuffer C - Fourier transform (used for visualisation purposes only)\nBuffer D - absolute magnitude of Fourier transform\nImage    - plot\n\n\nRelated:\n\n- https://www.shadertoy.com/view/wl3cDj | \"Water Surface Simulation\"  (practical application of the kernel)\n- https://www.shadertoy.com/view/wtGyzK | \"half-Laplacian\"            (the kernel on which this one here is based on)\n\n*/\n\n#define FETCH(x,y) length(textureLod(iChannel2, mix(vec2(1.5), vec2(SIZE-0.5), vec2(x,y)*0.5+0.5)/iResolution.xy, 0.0))\n\nfloat ReferenceSpectrum(float x, float D)\n{\n    return x*tanh(x*D);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\nvoid ValueText(inout vec3 col, vec2 uv0, float n)\n{\n    vec2 p = uv0 * 0.5;\n    p.x -= 1.0;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 4.0 || t.y != 0.0) return;\n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = floor(n) == 0.0 ? 48.0 : floor(n) == 1.0 ? 49.0 : 50.0;\n    else if(t.x == 1.0) c = 46.0;\n    else\n    c = 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c);\n    sdf = smoothstep(0.08, -0.08, sdf);\n    col = mix(col, vec3(0.0), sdf);\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex /= iResolution.xy;\n\n    tex = tex * 2.0 - 1.0;\n    tex.y += 1.0-0.125;\n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    float s = 0.333;// vertical scaling factor used to fit plot into viewport\n    \n    // water depth\n  #ifdef USE_HQ_KERNEL\n    float D = iMouse.z > 0.0 ? iMouse.x/iResolution.x*2.0 : GetD(iTime);\n  #else\n    float D = iMouse.z > 0.0 ? iMouse.x/iResolution.x*1.0 : GetD(iTime);\n  #endif\n  \n    // ground-truth spectrum\n    col = mix(col, vec3(0.0, 0.5, 1.0), Graph(ReferenceSpectrum((tex.x)*(Pi*sqrt(2.0)), D)*s - tex.y, 1.5) * 0.5);// blue\n    \n    // cross-section of 2d spectrum along diagonals\n    col = mix(col, vec3(1.0, 0.0, 0.5), Graph(FETCH(tex.x, tex.x)*s - tex.y, 0.5) * 0.75);// magenta\n    \n    // cross-section of 2d spectrum along main axes\n    col = mix(col, vec3(1.0, 0.4, 0.0), Graph(FETCH(-abs(tex.x)*sqrt(2.0), 0.)*s - tex.y, 0.5) * (abs(tex.x)*sqrt(2.0)<1.0?1.0:0.0));// orange\n    \n    // show value of D\n    ValueText(col, uv0, D);\n\n\n    #if 1\n    {\n        // vignetting\n        vec2 s = (uv0/iResolution.xy*2.0-1.0);\n        s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n        col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    }\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#define FETCH(uv) (uv).x == uint(SIZE*0.5) && (uv).y == uint(SIZE*0.5) ? 1.0 : 0.0\n\nfloat EvalWhiteNoise(uvec2 uv)\n{\n    const uint r  = 2654435761u;\n    const uint r0 = 3242174893u;\n    const uint r1 = 2447445397u;\n    uint h = ((uv.x * r0 + uv.y) ^ (uv.y * r1 + uv.x)) * r;\n    return float(h) * (1.0 / 4294967295.0);\n}\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n  #ifndef USE_HQ_KERNEL\n    discard; return;\n  #endif\n  \n    if(uv0.x > SIZE || uv0.y > SIZE) { discard; return; }\n    \n    uvec2 uv = uvec2(uv0 - 0.5);\n    \n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int x = -7; x <= 7; ++x)\n    {\n        float f = FETCH(uv + uvec2(x, 0));\n    \n        int i = abs(x);\n\n        lowpass3  += f * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f * lowp7[i];\n        laplacian += f * lapl7[i];\n    }\n\n    float f0 = FETCH(uv);\n    \n    col = vec4(lowpass3, lowpass7, f0, laplacian);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n*/\n\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE) { discard; return; }\n\n    uvec2 uv = uvec2(uv0 - 0.5);\n\n\n  #ifdef USE_HQ_KERNEL\n  \n    float D = iMouse.z > 0.0 ? iMouse.x/iResolution.x*2.0 : GetD(iTime);\n  \n    #define FETCH(uv) texelFetch(iChannel0, ivec2(uv), 0)\n  \n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int y = -7; y <= 7; ++y)\n    {\n        vec3 f = FETCH(uv + uvec2(0, y)).xyz;\n    \n        int i = abs(y);\n\n        lowpass3  += f.x * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f.y * lowp7[i];\n        laplacian += f.z * lapl7[i];\n    }\n\n    vec4 f0 = FETCH(uv);\n    \n    laplacian += f0.w;\n\n    float D2 = clamp01(D - 1.0);\n\n    float highpass = f0.z - mix(lowpass3, lowpass7, 0.772 * D2);\n    float halfLaplacian =   mix(highpass, laplacian, 0.19)*1.255;\n    \n  #else\n  \n    float D = iMouse.z > 0.0 ? iMouse.x/iResolution.x*1.0 : GetD(iTime);\n  \n    #define FETCH(uv) (uv).x == uint(SIZE*0.5) && (uv).y == uint(SIZE*0.5) ? 1.0 : 0.0\n  \n    // 13 tabs version\n    const int r  = 2;\n    const int r1 = r + 1;\n \n    float kernA[r1] = float[r1](2.85, -1.5792207792207793, 0.15422077922077923);\n \n    float kernB[r1*r1] = float[r1*r1](2.0933782605117255  , -0.32987120049780483, -0.026408964879028916, \n                                     -0.32987120049780483 , -0.1670643997510976 ,  0.0                 ,\n                                     -0.026408964879028916,  0.0                ,  0.0                 );\n     \n    float laplacian = 0.0;\n    float halfLaplacian = 0.0;\n\n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float w = (kernB[abs(x) + abs(y) * r1]);\n\n        if(w == 0.0) continue;\n\n        float f = FETCH(uv + uvec2(x, y));\n\n        halfLaplacian += f * w;\n\n        if(y == 0) laplacian += f * kernA[abs(x)];                \n        if(x == 0) laplacian += f * kernA[abs(y)];                \n    }  \n    \n   #endif\n    \n    D = clamp01(D);\n    \n  #if 1\n    float S = 7.0 * (D*D) / (2.0 + 5.0 * (D*D));  \n  #else\n    float S = 13.0 * (D*D) / (4.0 + 9.0 * (D*D));\n  #endif\n  \n    float kern = mix(laplacian, halfLaplacian, S) * D;\n\n    //kern = laplacian*0.3;\n\n    col = vec4(kern, 0.0, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {discard; return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n   #define USE_HQ_KERNEL\n\n\nfloat GetD(float time)\n{\n    float D = (sin(time*0.5)*0.5+0.5);\n    \n  #ifdef USE_HQ_KERNEL\n    D *= 2.0;\n  #endif\n  \n    return D;\n}\n\n#define SIZE 128.0\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "buffer_d_code": "\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {discard; return;}\n    \n\tfragColor = vec4(length(texelFetch(iChannel0, ivec2(uv), 0).rg), 0.0, 0.0, 0.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfzN.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1095, 1095, 1138, 1138, 1164], [1166, 1207, 1243, 1243, 1426], [1427, 1427, 1478, 1478, 2090], [2093, 2093, 2141, 2141, 3575]], "test": "untested"}
{"id": "Wl3BR7", "name": "Cyclic noise I guess", "author": "michael0884", "description": "noise", "tags": ["fractal", "noise"], "likes": 29, "viewed": 574, "published": 3, "date": "1612394538", "time_retrieved": "2024-07-30T19:40:52.122082", "image_code": "#define pi 3.14159265\n#define iterations 13\n\nvec3 function(vec3 x){\n    vec3 ca = vec3(0.420,0.827,1.000)*cos(x.xxx)+vec3(1.000,0.902,0.859)*cos(x.yyy);\n    vec3 cb = vec3(0.898,1.000,0.922)*cos(x.zzz*1.5);\n    return ca*cb-cb;\n}\n\nmat2 ROT(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n#define SCALE 1.5\n#define SHIFT vec3(2.3, -5.2, 1.0)\n\nvec3 fractal(vec3 x){\n    x *= pi;\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat2 rmZ = SCALE*ROT(0.35);\n    mat2 rmX = SCALE*ROT(0.46);\n    for (int i = 0; i < iterations; i++){\n        vec3 F =function(x); \n        v += a*F;\n        x.xy = rmZ*x.xy;\n        x += 0.3*F;\n        x.yz = rmX*x.yz;\n        x += SHIFT;\n        a /= 1.1*SCALE;\n    }\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = 1.5*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 color = 0.8*fractal(vec3(uv, 0.05*iTime))+0.4;\n    fragColor = vec4(tanh(pow(color, vec3(1.4))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 67, 67, 229], [231, 231, 252, 252, 312], [368, 368, 389, 389, 735], [737, 737, 791, 791, 989]], "test": "untested"}
{"id": "Wl3fzM", "name": "Apollian with a twist", "author": "mrange", "description": "License CC0: Apollian with a twist\nPlaying around with apollian fractal\n", "tags": ["2d", "apollian"], "likes": 225, "viewed": 6090, "published": 3, "date": "1612391093", "time_retrieved": "2024-07-30T19:40:53.001730", "image_code": "// License CC0: Apollian with a twist\n// Playing around with apollian fractal\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define L2(x)           dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat apollian(vec4 p, float s) {\n  float scale = 1.0;\n\n  for(int i=0; i<7; ++i) {\n    p        = -1.0 + 2.0*fract(0.5*p+0.5);\n\n    float r2 = dot(p,p);\n    \n    float k  = s/r2;\n    p       *= k;\n    scale   *= k;\n  }\n  \n  return abs(p.y)/scale;\n}\n\nfloat weird(vec2 p) {\n  float z = 4.0;\n  p *= ROT(TIME*0.1);\n  float tm = 0.2*TIME;\n  float r = 0.5;\n  vec4 off = vec4(r*PSIN(tm*sqrt(3.0)), r*PSIN(tm*sqrt(1.5)), r*PSIN(tm*sqrt(2.0)), 0.0);\n  vec4 pp = vec4(p.x, p.y, 0.0, 0.0)+off;\n  pp.w = 0.125*(1.0-tanh(length(pp.xyz)));\n  pp.yz *= ROT(tm);\n  pp.xz *= ROT(tm*sqrt(0.5));\n  pp /= z;\n  float d = apollian(pp, 1.2);\n  return d*z;\n}\n\nfloat df(vec2 p) {\n  const float zoom = 0.5;\n  p /= zoom;\n  float d0 = weird(p);\n  return d0*zoom;\n}\n\nvec3 color(vec2 p) {\n  float aa   = 2.0/RESOLUTION.y;\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 lp1 = vec3(0.5, lh, 0.5);\n  const vec3 lp2 = vec3(-0.5, lh, 0.5);\n\n  float d = df(p);\n\n  float b = -0.125;\n  float t = 10.0;\n\n  vec3 ro = vec3(0.0, t, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 rd = normalize(pp - ro);\n\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  float bt = -(t-b)/rd.y;\n  \n  vec3 bp   = ro + bt*rd;\n  vec3 srd1 = normalize(lp1-bp);\n  vec3 srd2 = normalize(lp2-bp);\n  float bl21= L2(lp1-bp);\n  float bl22= L2(lp2-bp);\n\n  float st1= (0.0-b)/srd1.y;\n  float st2= (0.0-b)/srd2.y;\n  vec3 sp1 = bp + srd1*st1;\n  vec3 sp2 = bp + srd2*st1;\n\n  float bd = df(bp.xz);\n  float sd1= df(sp1.xz);\n  float sd2= df(sp2.xz);\n\n  vec3 col  = vec3(0.0);\n  const float ss =15.0;\n  \n  col       += vec3(1.0, 1.0, 1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))/bl21;\n  col       += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))/bl22;\n  float l   = length(p);\n  float hue = fract(0.75*l-0.3*TIME)+0.3+0.15;\n  float sat = 0.75*tanh(2.0*l);\n  vec3 hsv  = vec3(hue, sat, 1.0);\n  vec3 bcol = hsv2rgb(hsv);\n  col       *= (1.0-tanh(0.75*l))*0.5;\n  col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n  col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = color(p);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fzM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[352, 352, 374, 374, 543], [545, 545, 578, 578, 793], [795, 795, 816, 816, 1178], [1180, 1180, 1198, 1198, 1280], [1282, 1282, 1302, 1302, 2618], [2620, 2620, 2657, 2657, 2910], [2912, 2912, 2967, 2967, 3154]], "test": "untested"}
{"id": "Wt3BzM", "name": "Animated Lyapunov", "author": "rsiqueira", "description": "Animation of Lyapunov bifurcations.", "tags": ["fractal", "lyapunov"], "likes": 4, "viewed": 175, "published": 3, "date": "1612389500", "time_retrieved": "2024-07-30T19:40:53.849463", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// More info here:  https://iquilezles.org/articles/lyapunovfractals\n\nvec3 calc( in vec2 p )\n{\n    float x = 0.5;\n\tfloat h = 0.0;\n\tfor( int i=0; i<9; i++ )\n\t{\n\t\tx = p.x*x*(1.0-x+sin(iTime)/100.);\n        h += log2(abs(p.x*(1.0-2.0*x)));\n        \n\t\tx = p.x*x*(1.0-x+sin(iTime*2.)/100.);\n        h += log2(abs(p.x*(1.0-2.0*x)));\n        \n\t\tx = p.x*x*(1.0-x);\n        h += log2(abs(p.x*(1.0-2.0*x)));\n        \n\t\tx = p.x*x*(1.0-x);\n        h += log2(abs(p.x*(1.0-2.0*x)));\n\n        x = p.y*x*(1.0-x);\n        h += log2(abs(p.y*(1.0-2.0*x)));\n        \n\t\tx = p.y*x*(1.0-x+sin(iTime/2.)/50.);\n        h += log2(abs(p.y*(1.0-2.0*x)));\n        \n\t\tx = p.y*x*(1.0-x);\n        h += log2(abs(p.y*(1.0-2.0*x)));\n        \n\t\tx = p.y*x*(1.0-x+sin(iTime*1.5)/100.);\n        h += log2(abs(p.y*(1.0-2.0*x)));\n\t}\n    h /= 290.0;\n\t\n\t\n\tvec3 col = vec3(0.0);\n\tif( h<0.0 )\n\t{\n\t\th = abs(h);\n\t\tcol =  1.0*sin( vec3(0.9,0.5,0.0) + 6.8*h );\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col =  calc( vec2(2.2,3.4) + 1.5*(fragCoord) / iResolution.x );\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3BzM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[195, 195, 219, 219, 1055], [1057, 1057, 1114, 1114, 1217]], "test": "untested"}
{"id": "Wl3fRM", "name": "Ciphers of the Monks", "author": "bgolus", "description": "https://en.wikipedia.org/wiki/The_Ciphers_of_the_Monks", "tags": ["digits"], "likes": 28, "viewed": 1477, "published": 3, "date": "1612387223", "time_retrieved": "2024-07-30T19:40:54.714151", "image_code": "float sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCistercianNumberal(vec2 uv, int n, float s, float t)\n{    \n    vec2 absuv = abs(uv);\n    \n    float zero  = sdSegment(absuv, vec2( 0.0, s/2.), vec2( 0.0,-s/2.));  // center vertical line\n    \n    float one   = sdSegment(absuv, vec2( 0.0, s/2.), vec2( s/3., s/2.)); // horizontal line at end\n    float two   = sdSegment(absuv, vec2( 0.0, s/6.), vec2( s/3., s/6.)); // horizontal line 1/3 from end\n    float three = sdSegment(absuv, vec2( 0.0, s/2.), vec2( s/3., s/6.)); // diagonal line from end going in\n    float four  = sdSegment(absuv, vec2( 0.0, s/6.), vec2( s/3., s/2.)); // diagonal line 1/3 from end going out\n    float five  = min(one, four);                                        // one + four\n    float six   = sdSegment(absuv, vec2(s/3., s/2.), vec2( s/3., s/6.)); // 1/3 height vertical line to the side\n    float seven = min(one, six);                                         // one + six\n    float eight = min(two, six);                                         // two + six\n    float nine  = min(one, eight);                                       // one + two + six\n    \n    // top right is ones\n    // top left is tens\n    // bottom right is hundreds\n    // bottom left is thousands\n    int place = 1;\n    if (uv.x < 0.0)\n        place *= 10;\n    if (uv.y < 0.0)\n        place *= 100;\n    n = int(mod(float(n / place), 10.));\n    return min(zero, n==1?one:n==2?two:n==3?three:n==4?four:n==5?five:n==6?six:n==7?seven:n==8?eight:n==9?nine:zero) - t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float number = mod(iTime * 5., 9999.);\n    \n    float size = 0.5 * iResolution.y;\n    float thickness = 3.;\n    \n    float numDist = sdCistercianNumberal(uv*iResolution.y, int(floor(number)), size, thickness);\n    \n    // blend for animation\n    numDist = mix(numDist, sdCistercianNumberal(uv*iResolution.y, int(ceil(number)), size, thickness), smoothstep(0.5,1.,fract(number)));\n    \n    float col = smoothstep(-0.5, 0.5, numDist);\n    \n    float digits = PrintValue(uv * 10. + vec2(-0.1, 4.0), number, 1., 0.);\n    \n    col *= 1. - digits;\n\n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "float DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 171], [173, 173, 235, 235, 1646], [1648, 1648, 1705, 1705, 2395]], "test": "untested"}
{"id": "3t3fRM", "name": "Shader Saturday 1: Raymarching#1", "author": "psicomante", "description": "Shader Saturday 1", "tags": ["raymarching", "sdf"], "likes": 2, "viewed": 239, "published": 3, "date": "1612386367", "time_retrieved": "2024-07-30T19:40:55.559890", "image_code": "#define MAT_FLOOR 0.0\n\n#define PI 3.14159265359\n#define EPSILON 1e-6\n#define INFTY 1e6\n#define TIME_M 0.5\n\nmat3 rotX(float t) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, sin(t), cos(t),\n        0.0, - cos(t), sin(t)\n    );\n}\nmat3 rotY(float t) {\n    return mat3(\n        sin(t), 0.0, cos(t),\n        0.0, 1.0, 0.0,\n        - cos(t), 0.0, sin(t)\n    );\n}\nmat3 scalar(float t) {\n    return mat3(\n        t, 0.0, 0.0,\n        0.0, t, 0.0,\n        0.0, 0.0, t\n    );\n}\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sphereCloud(vec3 p) {\n    p = abs(p);\n    return length(mod(3.0 * p, 1.0) - 0.5) - 0.4 * (1.0 - max(max(p.x, p.y), p.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\n// positive sin\nfloat ps(float v) {\n    return sin(v)*0.5 + 0.5;\n}\n\nfloat s1sdf(vec3 p, float t) {\n    t = t*2.;\n    float tor = sdTorus(p, vec2(0.1, 0.1));\n    float b = sdBox(p, vec3(0.2, 0.5, 0.5));\n    float u1 = opSmoothUnion(tor,b, 0.4);\n    float u2 = opSmoothSubtraction(sdSphere(p, 0.2), u1, 0.5*ps(t));\n    return u2;    \n}\n\nfloat surfaceSDF(vec3 p, float t) {\n    vec3 q = opRepLim(p, 2., vec3(1., 1., 1.));\n    return s1sdf(p, t);\n}\n\nvec3 getNormal(vec3 p, float t) {\n    float d = EPSILON;\n    return normalize(vec3(\n            surfaceSDF(p + vec3(d, 0.0, 0.0), t) - surfaceSDF(p, t),\n            surfaceSDF(p + vec3(0.0, d, 0.0), t) - surfaceSDF(p, t),\n            surfaceSDF(p + vec3(0.0, 0.0, d), t) - surfaceSDF(p, t)\n    ));\n}\n\nfloat getAngle(vec3 p, vec3 q) {\n    return acos(dot(normalize(p), normalize(q)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragment position, thx toeme\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // light pos\n    vec3 l = vec3(0.0, 2.0, 1.0);   \n    \n    // time multiplier\n    float t = iTime * TIME_M;\n\n    // camera\n    vec3 camOr = vec3(0.0, 0.0, 2.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    float targetDepth = 2.0;\n    mat3 g = rotX(PI/4.) * rotY(t);\n    vec3 rCamOr = g * camOr;\n    vec3 rCamDir = g * camDir;\n    vec3 rCamUp = g * camUp;\n    vec3 rCamRight = cross(rCamDir, rCamUp);\n    \n    vec3 lightDir = l*g;\n\n    \n    // ray\n    vec3 rayDir = normalize(rCamRight * uv.x + rCamUp * uv.y + rCamDir * targetDepth);\n    float ang = getAngle(rayDir, -normalize(rCamOr));\n    vec3 rayOr = rCamOr + (1.0 / cos(ang)) * rayDir;    \n    \n    float d = 0.;\n    float dist = 0.;\n    vec3 p = rayOr;\n    \n\t// marching loop\n    for(int i = 0; i < 150; i ++ ) {\n        d = surfaceSDF(p, t);\n        dist += d;\n        p = rayOr + dist*rayDir;\n        \n        if (d < 0.01) {\n            break;\n        }       \n    }\n    \n    \n    vec3 normal = getNormal(p, t);\n    float lamb = clamp(dot(normalize(lightDir - p), normal), 0.01, 1.0);\n    float fresnel = 1. - clamp(dot(normalize(rayOr - p), normal), 0.01, 1.0);\n    \n    // hit check\n    if (d < 0.01) {\n        fragColor = vec4(lamb * fresnel * vec3(248., 255., 174.)/255., 1.0);\n        fragColor.rgb = pow(fragColor.rgb, vec3(0.25));\n    } else {\n        vec3 g1 = vec3(252./255., 92./255., 125./255.);\n        vec3 g2 = vec3(106./255., 130./255., 251./255.);\n        vec3 g3 = vec3(150., 201., 61.)/255.;\n        vec3 g4 = vec3(0., 176./255., 155./255.);\n        fragColor = vec4(mix(g4, g3, uv.y*0.5 + 0.5), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3fRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 127, 127, 235], [236, 236, 256, 256, 364], [365, 365, 387, 387, 475], [477, 477, 500, 500, 515], [517, 517, 550, 550, 578], [580, 580, 617, 617, 638], [640, 640, 683, 683, 705], [707, 707, 751, 751, 772], [774, 774, 826, 826, 925], [927, 927, 985, 985, 1085], [1087, 1087, 1146, 1146, 1245], [1247, 1247, 1274, 1274, 1376], [1378, 1378, 1409, 1409, 1496], [1498, 1498, 1531, 1531, 1596], [1598, 1598, 1648, 1648, 1689], [1691, 1707, 1726, 1726, 1757], [1759, 1759, 1789, 1789, 2024], [2026, 2026, 2061, 2061, 2135], [2137, 2137, 2170, 2170, 2436], [2438, 2438, 2470, 2470, 2522], [2524, 2524, 2581, 2617, 4319]], "test": "untested"}
{"id": "tltfz4", "name": "Day 413", "author": "jeyko", "description": "poato", "tags": ["mdtmjvm"], "likes": 22, "viewed": 411, "published": 3, "date": "1612381184", "time_retrieved": "2024-07-30T19:40:56.459485", "image_code": "\n// Don't fullscreen lol\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    C -= C;\n    \n    C += texture(iChannel1,U/iResolution.xy);\n\n \n    \n     \n    \n    C.xyz *= vec3(1.1,0.7,0.05);\n    C.xyz = pow(C.xyz,vec3(1.4,0.5,0.1));\n    C = pow(C,vec4(0.8));\n    \n    vec2 uv = U/iResolution.y;\n    float df = dFdx(uv.x);\n    /*\n    uv = pmod(uv,0.3);\n    \n    C -= smoothstep(df,0.,abs(uv.x))*0.1;\n    C -= smoothstep(df,0.,abs(uv.y))*0.1;\n    */\n    //C = 1. - C;\n    \n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float r11(float i) {return fract(sin(i*125.214)*124.125124);}\nfloat valueNoise(float i) {return mix(r11(floor(i)), r11(floor(i) + 1.),smoothstep(0.,0.3,fract(i)));}\n\n#define boxFold(z, foldingLimit)  z = clamp(z, -(foldingLimit), (foldingLimit)) * 2.0 - z;\nfloat map(vec3 p){\n    float d = 10e5;\n    p.y += 0.1;\n    \n    float rt = iTime/15.; \n    float id = floor(rt);\n    rt = fract(rt);\n    \n    p.yx *= rot(mod(id,4.)*0.25*pi*smoothstep(0.,0.1,rt)*(1. - smoothstep(0.3,0.5,rt)));//\n   \n    \n    p.xz *= rot(-1.2 + iTime*0.3);\n    vec4 q = vec4(p,1);\n    \n    \n    float m = valueNoise(iTime*0.5);\n    float mb = valueNoise(iTime*0.5 + 40. + 0.5);\n    \n    \n    //q = q/dot(q.xyz,q.xyz)/0.2;\n    \n    \n    //q = mix( q, qrev*0.2,1.);\n    \n    rt = fract(iTime/26. + 0.5);\n    //q = mix( q, q / dot(q.xyz,q.xyz)/0.2, smoothstep(0.,0.015,rt)*(1. - smoothstep(0.2,0.22,rt)));\n    \n    for(float i = 0.; i < 7.; i++){\n            \n        \n        if(q.x < q.z) q.xz = q.zx;\n        if(q.z > q.y) q.zy = q.yz;\n        \n        if(q.x > q.y) q.yx = q.xy;\n        \n        q = abs(q);\n         \n        if( i == 1. || i == 2.)\n            pmod(q.y,13.1 + mb*5.);\n        \n        if(i== 1.)\n            boxFold(q.x,4. - 1.*mb);\n        q *= 1.6;\n        \n        //q.xz *= rot(1.5*pi);\n        q.xyz -= vec3(.5,0.- m ,2.5 )*4.;\n    }\n    \n    \n    q.xyz /= q.w;\n    \n    d = length(q.x) - 0.01;\n\n\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0);\n    return normalize(\n        map(p) - vec3(\n            map(p -t.xyy),\n            map(p -t.yxy),\n            map(p -t.yyx)\n        )\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    \n    vec3 ro = vec3(0);\n    \n    vec3 rd = normalize(vec3(uv,0.4));\n    ro.z -= 2.;\n    \n    vec3 p = ro;\n    float t = 0.;\n    bool hit = false;\n    \n    for(int i = 0; i < 150; i++){\n        float d = map(p);\n        if(d < 0.01){\n            hit = true;\n            break;\n        }\n        \n        p = ro + rd*(t += d*0.5);\n    }\n    \n    \n    vec3 n = getNormal(p);\n    \n    \n    fragColor = vec4(n,t);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "\n#define R iResolution.xy\n#define T(a) texture(iChannel0, (a)/R)\n\n#define steps 5.\nvoid getEdge( vec4 me, vec2 U, vec2 dir, inout float dEdge){\n    for(float i = 0.; i < steps; i++){\n        vec2 sampleP = U + dir*i;\n        vec4 t = T(sampleP);\n        //if(abs(t.z - me.t) < 0.5 && dot(me.xyz,t.xyz) < 0.6){\n        if(dot(me.xyz,t.xyz) < 0.95 || abs(t.w - me.w) > 0.15){\n        //if(dot(me.xyz,t.xyz) < 0.95 ){\n        \n            dEdge = min(dEdge, i);\n            break;\n        }\n    }\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    vec2 uvn = (U - 0.5*R)/R.y;\n    vec4 me = T(U);\n        \n    \n    float dEdge = 10e2;\n    getEdge( me, U, vec2(0,1), dEdge);\n    getEdge( me, U, vec2(0,-1), dEdge);\n    getEdge( me, U, vec2(1,0), dEdge);\n    getEdge( me, U, vec2(-1,0), dEdge);\n    \n    getEdge( me, U, vec2(1,1), dEdge);\n    getEdge( me, U, vec2(1,-1), dEdge);\n    getEdge( me, U, vec2(-1,1), dEdge);\n    getEdge( me, U, vec2(1,1), dEdge);\n    \n    \n    dEdge /= (R.y);\n    \n    C += 1.;\n    vec2 nuv = U/R.y*20.;\n    \n    nuv*= rot(0.5);\n    \n    nuv.x  *= 12.;\n    \n    \n    float shading = cyclicNoiseB(vec3(nuv + vec2( floor(iTime*12.5)*0.2,0.),floor(iTime*12.5)*10.1 ), false, 0.)\n        + cyclicNoise(vec3(U/R.y*410. ,floor(iTime*12.5)*10.1 ), false, 0.) - 0.2\n        ;\n    \n    C = mix(C,vec4(shading)*0.8, max(dot(me.xyz,normalize(vec3(1,1,0))),0.1));\n    \n    //C = mix(C,vec4(shading)*1., dot(uvn,uvn*0.3));\n    \n    \n    //dEdge = mix(dEdge,-0., max(dot(me.xyz,normalize(vec3(-1,-1,-1))),0.));\n    \n    //C += me.xyzz;\n    nuv = U/R.y*120.;\n    \n    nuv*= rot(0.5);\n    \n    nuv.x  *= 2.;\n    float n = cyclicNoise(vec3(nuv,4. + floor(iTime*12.5)*10.1 ), false, 0.);\n    n = n*2. - 1.;\n    dEdge += n*0.002;\n    dEdge -= 0.0005;\n    C = mix(C,vec4(0),smoothstep(dFdx(U.x/R.y)*2.25,0.,dEdge + 0.0004)*1.);\n    \n    \n    \n    //C = texture(iChannel0,U/R);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pi acos(-1.)\n\n\n#define pmod(p,a) p = mod(p - 0.5*(a),(a)) - 0.5*(a)\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(0.5);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\nfloat cyclicNoiseB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(0.5);\n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =2.2;    \n    float warpTrk =1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 67, 67, 464]], "test": "untested"}
{"id": "Wt3fz8", "name": "Geometry Warp", "author": "mla", "description": "Smooth transition between Euclidean, Hyperbolic and Spherical geometry.\n\nMouse moves centre point (with an isometry in the appropriate geometry).", "tags": ["geometry", "spherical", "hyperbolic"], "likes": 12, "viewed": 399, "published": 3, "date": "1612368826", "time_retrieved": "2024-07-30T19:40:57.314200", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Geometry Warp, Matthew Arcus, mla, 2021\n//\n// Smooth transition between Euclidean,  Hyperbolic and Spherical geometry.\n//\n// Mouse moves centre point (with an isometry in the appropriate geometry). \n//\n// Uses hyperboloid model for hyperbolic geometry.\n// \n// k controls the geometry - use a sphere or hyperboloid of radius 1/sqrt(|k|),\n// with inner product x^2+y^2+sign(k)*z^2. For k = 0 (the Euclidean case),\n// the radius is infinite and we use some asymptotic approximations.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Stereographic projection from (0,0,-R) to z = 0, where R^2 = |1/k|\nvec3 project(vec2 p, float k) {\n  float t = 2.0/(1.0+k*dot(p,p));\n  return vec3(t*p,(t-1.0)/sqrt(abs(k)));\n}\n\n// Inner product\nfloat kdot(vec3 p, vec3 q, float k) {\n  return dot(p*vec3(1,1,sign(k)),q);\n}\n\nvec3 diagram(vec2 p2, vec2 q2) {\n  p2 = rotate(p2,iTime);\n  q2 = rotate(q2,iTime);\n  float k = -sin(0.5*iTime);\n  float R = 1.0/sqrt(abs(k)); // Sphere or hyperboloid radius\n  vec3 p = project(p2,k);\n  vec3 q = project(q2,k); // Mouse position\n  vec3 r = vec3(0,0,R);\n  vec3 n = q+r; // This reflects q to -r & then flipping z coord takes us to N. pole\n  p -= k == 0.0 ? n : 2.0*kdot(p,n,k)/kdot(n,n,k)*n; // Asymptotic value for k = 0\n  p.z = -p.z;\n  float s = length(p.xy);\n  // Calculate distance from centre\n  // For small x, atanh(x) = atan(x) = x and for small k, p.z = R\n  float d = abs(k) < 1e-4 ? s : R*(k < 0.0 ? atanh(s/p.z) : atan(s/abs(p.z)));\n  vec2 uv = vec2(16.0*d,12.0*atan(p.y,p.x));\n  uv /= 2.0*PI;\n  vec2 index = floor(uv);\n  uv -= index;\n  uv *= 2.0*PI;\n  vec3 col = h2rgb(fhash(index));\n  col *= (0.5-0.5*cos(uv.x))*(0.5-0.5*cos(uv.y));\n  if (k < 0.0) {\n    col = mix(vec3(0),col,smoothstep(0.0,0.05,R-length(p2)));\n    col = mix(vec3(0.2),col,smoothstep(-0.01,0.0,R-length(p2)));\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec2 q = vec2(-0.75,-0.25);\n  if (iMouse.x > 0.0) q = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  vec3 col = diagram(p,q);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159;\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat fhash(vec2 index) {\n  uint h = ihash(uint(int(index.x))^ihash(uint(int(index.y))));\n  return float(h)/exp2(32.0);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  //rgb *= rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3fz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[654, 724, 755, 755, 832], [834, 851, 888, 888, 927], [929, 929, 961, 961, 1951], [1953, 1953, 2006, 2006, 2252]], "test": "untested"}
{"id": "3ldfRN", "name": "Is it the wind of stars?", "author": "YitingLiu", "description": "Creating windy effect of stars. ", "tags": ["math", "tutorial", "sin", "rotate", "atan", "cos", "hexagon", "stars", "hex", "tile", "wind", "max", "tan", "cloth", "coordinate", "theartofcode"], "likes": 4, "viewed": 326, "published": 3, "date": "1612361896", "time_retrieved": "2024-07-30T19:40:58.077160", "image_code": "//tutorial https://www.youtube.com/watch?v=VmrIDyYiJBA\n\nfloat HexDist(vec2 uv){\n  uv=abs(uv);\n  float c = dot (uv, normalize(vec2(1,1.73)));// 1.73 is from sqrt of (2 to the power of 2 - 1 to the power of 2)\n  c=max(c,uv.x);\n    \n   return c;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 HexCoords(vec2 uv){\n    vec2 r = vec2(1.,1.73);\n    vec2 h = r/2.;\n    \n    vec2 a = mod(uv,r)-h;\n    vec2 b = mod(uv-h,r)-h;\n    \n    vec2 gv = dot(a,a)<dot(b,b)?a:b; // shorter version of if statement \n    \n    vec2 id = (uv-gv)*rotate2d(3.1415*cos(iTime/100.));\n   \n    float x = atan(gv.x,gv.y);// which angle the x is at according to the center of y\n    float y = 0.5-HexDist(gv);// center of the hex\n    \n    return vec4(x,y,id.x,id.y);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    uv*=8.;\n    vec4 hex= HexCoords(uv);\n    float c = smoothstep(.05,1.,hex.y*sin(hex.x+hex.z+iTime*0.6));\n    col+=c;\n    \n    col*=abs(uv.y-uv.x);  \n    \n    \n    /**\n    Moving Hex\n    col+=sin(HexDist(uv*10.+iTime));\n\n    */\n    \n    fragColor = vec4(col*(abs(sin(iTime*0.5))+0.1),1.0);\n}", "image_inputs": [{"id": 25361, "src": "https://soundcloud.com/yitingliu/dreamstate", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 79, 79, 244], [246, 246, 274, 274, 360], [362, 362, 386, 386, 812], [814, 814, 871, 871, 1255]], "test": "untested"}
{"id": "3ltfz4", "name": "I love aliasing ( sometime :-) )", "author": "FabriceNeyret2", "description": ".", "tags": ["aliasing"], "likes": 9, "viewed": 324, "published": 3, "date": "1612357946", "time_retrieved": "2024-07-30T19:40:58.853085", "image_code": "// from https://shadertoy.com/view/Wttfz4\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy;\n    u -= .5* R;\n \n    O = vec4( cos( exp(15.*length(u/R.x)) - 10.*iTime  + vec4(0,1,2,0) ) );\n    \n // if ( u.x > 0.) O /= fwidth(O);           // right: normalize to get B/W strips\n    \n    O = sqrt(.5+.5*O);                       // to sRGB\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 82, 82, 357]], "test": "untested"}
{"id": "Wttfz4", "name": "don't apply fwidth on high freq", "author": "FabriceNeyret2", "description": "...as for Finites Diff.\nVertical sinusoids with freq increasing from center to left/right borders (note the spectra wrap-over on left).\nRight: normalized by fwidth.  At first create clean B/W strips, then aliase.\n→ use fwidth only on patterns > 2 pixels.", "tags": ["antialiasing", "fwidth"], "likes": 1, "viewed": 299, "published": 3, "date": "1612357331", "time_retrieved": "2024-07-30T19:40:59.620034", "image_code": "void mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy;\n    u -= .5* R;\n \n    float x = 13.* u.x/R.x;\n    O = vec4( cos( x * u.y + 0.*iTime) );\n    if (u.y<0.) O = vec4( cos( exp(20.*length(u/R.x)) ) );\n    \n    if ( u.x > 0.) O /= fwidth(O);           // right: normalize to get B/W strips\n    \n    O = sqrt(.5+.5*O);                     // to sRGB\n    \n    if (floor(u.x)==0.) O = vec4(1,0,0,1); // vertical separator\n    if (floor(u.y)==0.) O = vec4(0,1,0,1); // horizontal separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wttfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 501]], "test": "untested"}
{"id": "tl3BR4", "name": "Path-Tracing: Volumetric Cloud", "author": "Zi7ar21", "description": "Revised Volumetric Path-Tracing with a new sky from LoicVDB (https://www.shadertoy.com/user/loicvdb) with more optimizations and visual enhancements. It is using the built-in Noise volume, because other options for 3D Noise are either slow or obfuscated.", "tags": ["raymarching", "ray", "raymarch", "clouds", "clouds", "volumetric", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "path", "volumetrics"], "likes": 14, "viewed": 1987, "published": 3, "date": "1612328100", "time_retrieved": "2024-07-30T19:41:00.388979", "image_code": "// ##### Path-Tracing: Volumetric Cloud #####\n// Made by Zi7ar21 on February 2nd, 2020\n// Last updated: February 2nd, 2020 21:50 Mountain Time\n\n// If you found this anywhere other than Shadertoy, a possibly updated version can be found at:\n// https://www.shadertoy.com/view/tl3BR4\n\n// Common is for Parameters, Constants, and Other Functions.\n// Buffer A is for Path-Tracing the scene.\n// Buffer B is for Exporting a 32-BPC Floating Point OpenEXR Image.\n// This is for Drawing the main image.\n\n// ##### Contributors #####\n// LoicVDB Made the Sky Background for this, check his profile out:\n// https://www.shadertoy.com/user/loicvdb\n\n// Michael0884 has helped with other things, check his profile out:\n// https://www.shadertoy.com/user/michael0884\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This is for Parameters, Constants, and Other Functions.\n// ##### General Parameters #####\n// Controls Sensitivity of the Mouse Input\n#define mousesensitivity 4.0\n// Controls the Camera Field of View\n#define camfov 1.0\n// Controls the Maximum Number of the Path-Tracing Steps\n#define maxsteps 1024\n// Controls the Size of the Path-Tracing Steps\n#define stepsize 0.05\n// Controls the Maximum Distance from the Scene\n#define scenesize 4.0\n// Controls the Maximum Distance Travelled\n#define maxdist 32.0\n// Controls the Maximum Number of Bounces\n#define maxbounces 128U\n// Controls the Density of the Volume\n#define volumedensity 128.0\n// Controls the Scattering of the Volume\n#define scattering 1.0\n// Controls the Detail of the FBM Noise\n#define octaves 8\n\n// ##### LoicVDB's Sky Parameters #####\n// Controls Sky Quality\n#define SkySamples 8\n// Controls Sky Color\n#define SkyColor vec3(0.25, 0.5, 1.0)\n// Controls Light Color\n#define LightColor vec3(1.0, 1.0, 1.0)\n// Controls Sky Direction\n#define SkyUp vec3(0.0, 1.0, 0.0)\n// Controls Light Direction\n#define LightDirection normalize(vec3(1.0, 1.0, -1.0))\n// Controls Sky Intensity\n#define SkyIntensity 0.2\n// Controls Light Intensity\n#define LightIntensity 1.0\n// Controls the Radius of the Light\n#define LightRadius 0.125\n// Controls Mie Scattering Intensity\n#define MieIntensity 0.05\n// Controls Mie Scattering Anisotropy\n#define MieAnisotropy 0.6\n\n// ##### Constants and Functions #####\n// Pi (Quadruple Precision Float Future-Proof)\n#define pi 3.1415926535897932384626433832795028\n#define quarterpi pi*0.25\n#define twopi pi*2.0\n\n// LoicVDB's (Slightly Modified) Sky Functions (Loic's Profile: https://www.shadertoy.com/user/loicvdb)\n// (I don't know where to link to other than his profile page, since this\n// is from a Fragmentarium shader he shared on the Marble Marcher Discord)\nfloat anisotropicWeight(vec3 dirI, vec3 dirO, float a){\n \treturn quarterpi*(1.0-a*a)/pow(1.0+a*(a-2.0*dot(dirI, dirO)), 1.5);\n}\n\nvec3 skyDirectLight(vec3 pos, int i) {\n    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}\n    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;\n    float alt, dist, ds;\n    for(; i < SkySamples; i++){\n        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));\n    \tdist = alt/dot(LightDirection, SkyUp);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        volAbs *= stepAbsMie*stepAbsRay;\n        pos += LightDirection*dist;\n    }\n    return LightColor.rgb*LightColor*volAbs;\n}\nvec3 backgroundDirectLight(vec3 dir) {\n\tif(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}\n\tfloat sphericalCapArea = sin(LightRadius)*sin(LightRadius);\n\tfloat lightStrength = LightIntensity/(sphericalCapArea);\n\treturn lightStrength*LightColor.rgb;\n}\n\nvec3 skyScatter(vec3 dir, bool hasSun) {\n    vec3 pos = vec3(0.0), volCol = vec3(0.0), volAbs = vec3(1.0);\n    vec3 stepAbsRay, stepAbsMie, stepColRay, stepColMie;\n    float alt, dist, ds;\n    float aw = anisotropicWeight(dir, LightDirection, MieAnisotropy);\n    for(int i = 0; i < SkySamples; i++) {\n        alt = -log(1.0-sign(dot(dir, SkyUp))*float(i)/float(SkySamples));\n    \tdist = min(alt/dot(dir, SkyUp), 5.0);\n        ds = exp(-dot(pos, SkyUp));\n        stepAbsRay = exp(-ds*dist*SkyColor.rgb*SkyIntensity);\n        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));\n        stepColRay = (1.0-stepAbsRay);\n        stepColMie = (1.0-stepAbsMie)*aw;\n        volCol += (stepColMie+stepColRay)*volAbs*skyDirectLight(pos, i);\n        volAbs *= stepAbsRay*stepAbsMie;\n        pos += dir*dist;\n    }\n    return volCol+(hasSun ? backgroundDirectLight(dir)*volAbs:vec3(0.0));\n}\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u)) ^ state)*277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884: https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// This is for Path-Tracing the scene.\n// 3D FBM: https://www.shadertoy.com/view/3dSBRh\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*texture(iChannel1, x).r;\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// Alternate Noise, Slower than Sampling Built-In Noise\n// (I would use Nimitz's Cyclic Noise but it's hard to understand / the mat3 random numbers it uses seem sub-optimal)\n/*// Hash: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 pos){\n\tpos =  fract(pos*vec3(0.1031, 0.1030, 0.0973));\n    pos += dot(pos, pos.yxz+33.33);\n    return fract((pos.xxy+pos.yxx)*pos.zyx);\n}\n\n// Gradient Noise: https://iquilezles.org/articles/gradientnoise\nfloat noise(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 ga = hash(p+vec3(0.0,0.0,0.0));\n    vec3 gb = hash(p+vec3(1.0,0.0,0.0));\n    vec3 gc = hash(p+vec3(0.0,1.0,0.0));\n    vec3 gd = hash(p+vec3(1.0,1.0,0.0));\n    vec3 ge = hash(p+vec3(0.0,0.0,1.0));\n    vec3 gf = hash(p+vec3(1.0,0.0,1.0));\n    vec3 gg = hash(p+vec3(0.0,1.0,1.0));\n    vec3 gh = hash(p+vec3(1.0,1.0,1.0));\n    float va = dot(ga, w-vec3(0.0,0.0,0.0));\n    float vb = dot(gb, w-vec3(1.0,0.0,0.0));\n    float vc = dot(gc, w-vec3(0.0,1.0,0.0));\n    float vd = dot(gd, w-vec3(1.0,1.0,0.0));\n    float ve = dot(ge, w-vec3(0.0,0.0,1.0));\n    float vf = dot(gf, w-vec3(1.0,0.0,1.0));\n    float vg = dot(gg, w-vec3(0.0,1.0,1.0));\n    float vh = dot(gh, w-vec3(1.0,1.0,1.0));\n    return va+\n    u.x*(vb-va)+\n    u.y*(vc-va)+\n    u.z*(ve-va)+\n    u.x*u.y*(va-vb-vc+vd)+\n    u.y*u.z*(va-vc-ve+vg)+\n    u.z*u.x*(va-vb-ve+vf)+\n    u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\n// 3D FBM: https://www.shadertoy.com/view/3dSBRh\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < octaves; i++){\n\t\tv += a*noise(x+vec3(8.0));\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}*/\n\n// Volumetric Density Function, outputs: (vec3 Volume Color, float Density)\nvec4 densityfunction(vec3 pathpos){\n    vec3 color = vec3(1.0);\n    float density = max(0.0, fbm(pathpos*0.1)-(length(pathpos)*0.75));\n    return vec4(color, density*volumedensity);\n}\n\n// Volumetric Path-Tracing\nvec3 pathtrace(vec3 pathdir, vec3 pathori){\n    vec4 density;\n    float absorbance, disttrav = 0.0;\n    vec3 attenuation = vec3(1.0);\n    vec3 pathpos = pathori+(pathdir*stepsize*rand());\n    uint bounces = 0U;\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathpos);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){\n            attenuation *= clamp(density.rgb*scattering, 0.0, 1.0);\n            pathdir = normalize(nrand3(1.0, vec3(0.0)));\n            bounces++;\n        }\n        pathpos += pathdir*stepsize;\n        disttrav += stepsize;\n        if(length(pathpos) > scenesize || disttrav > maxdist || bounces > maxbounces){break;}\n    }\n    return skyScatter(pathdir, true)*attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    vec2 uv = 2.0*((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec2 mouse = ((iMouse.xy/iResolution.xy)-0.5)*pi*mousesensitivity;\n    //vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n    mat3 rotmat = mat3(cos(mouse.x), 0.0, -sin(mouse.x), 0.0, 1.0, 0.0, sin(mouse.x), 0.0, cos(mouse.x));\n    vec3 pathdir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n    vec3 pathtraced = pathtrace(pathdir, vec3(-sin(mouse.x)*2.0, 0.0, -cos(mouse.x)*2.0));\n    fragColor += vec4(clamp(pathtraced, 0.0, 32.0), 1.0);\n}", "buffer_a_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This is for Exporting a 32-BPC Floating Point OpenEXR Image.\n/* Look at the bottom of the editor, there is a little Image icon. If\nyou click it, then Shadertoy will save a 32-Bit-Per-Channel Floating Point\nOpenEXR Image. It is more optimal for Image editing than right-clicking\nthe canvas and pressing copy/save image (as).*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[748, 748, 802, 802, 858]], "test": "untested"}
{"id": "tt3fRN", "name": "Fork Paint stre Clark 180", "author": "Clark", "description": "Cellular automaton particle tracking used for advection in a fluid which is also fully conservative\nEach pixel has 1 virtual particle\nhttps://michaelmoroz.github.io/Reintegration-Tracking/", "tags": ["particles", "ca"], "likes": 4, "viewed": 390, "published": 3, "date": "1612326259", "time_retrieved": "2024-07-30T19:41:01.154930", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n    col = vec4(3.);\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.5*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [295, 295, 311, 311, 339], [341, 341, 386, 386, 1548]], "test": "untested"}
{"id": "3lcfzN", "name": "Simple Sphere Audio Visualizer", "author": "BigETI", "description": "This shader visualizes the currently played audio in channel index 0. Select any other audio file if you want to change the currently played music.", "tags": ["simple", "audio", "visualizer"], "likes": 3, "viewed": 516, "published": 3, "date": "1612308470", "time_retrieved": "2024-07-30T19:41:01.919885", "image_code": "// Anti aliasing level\nconst uint antiAliasing = 8U;\n\n// Minimal circle radius\nconst float minimalCircleRadius = 0.25;\n\n// Maximal circle radius\nconst float maximalCircleRadius = 0.5;\n\n// Rotations per second\nconst float rotationsPerSecond = 0.0625;\n\n// Minimal bar count\nconst float minimalBarCount = 8.0;\n\n// Maximal bar count\nconst float maximalBarCount = 16.0;\n\n// Sample volume count\nconst uint sampleBassVolumeCount = 16U;\n\n// Low background color\nconst vec4 lowBackgroundColor = vec4(0.0, 0.0625, 0.125, 1.0);\n\n// High background color\nconst vec4 highBackgroundColor = vec4(0.03125, 0.03125, 0.03125, 1.0);\n\n// Low volume color\nconst vec4 lowVolumeColor = vec4(0.0, 0.0, 1.0, 1.0);\n\n// Middle volume color\nconst vec4 middleVolumeColor = vec4(0.0, 1.0, 0.0, 1.0);\n\n// High volume color\nconst vec4 highVolumeColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n// Two pi\nconst float twoPi = 6.2831853071795864769252867665590057683943387987502116419498891846;\n\n// Samples scene\nvec4 SampleScene(const vec2 fragmentCoordinates)\n{\n    // UV coordinates\n    vec2 uv = (fragmentCoordinates - (iResolution.xy * 0.5)) / min(iResolution.x, iResolution.y);\n    \n    // Samples bass volume\n    float bass_volume = 0.0;\n    for (uint x = 0U; x != sampleBassVolumeCount; x++)\n    {\n        bass_volume += texture(iChannel0, vec2(float(x) / float(sampleBassVolumeCount * 4U), 0.0)).x;\n    }\n    bass_volume /= float(sampleBassVolumeCount);\n    \n    // Circle radius\n    float circle_radius = mix(minimalCircleRadius, maximalCircleRadius, bass_volume);\n    \n    // Bar count\n    float bar_count = round(mix(maximalBarCount, minimalBarCount, bass_volume));\n    \n    // Sampled volume\n    float volume = texture(iChannel0, vec2(floor((1.0 - (sqrt((uv.x * uv.x) + (uv.y * uv.y)) / circle_radius)) * bar_count) / bar_count, 0.0)).x;\n    \n    // Angle\n    float angle = -iTime * twoPi * rotationsPerSecond;\n    \n    // Renders visualization\n    return ((((uv.x * uv.x) + (uv.y * uv.y)) > (circle_radius * circle_radius)) || (((dot(vec2(-sin(angle), cos(angle)), normalize(uv)) + 1.0) * 0.5) > volume)) ? mix(lowBackgroundColor, highBackgroundColor, uv.y) : ((volume > 0.5) ? mix(middleVolumeColor, highVolumeColor, (volume - 0.5) * 2.0) : mix(lowVolumeColor, middleVolumeColor, volume * 2.0));\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    // Samples subpixels of scene\n    vec4 color_sum = vec4(0.0);\n    for (uint x = 0U, y; x != antiAliasing; x++)\n    {\n        for (y = 0U; y != antiAliasing; y++)\n        {\n            color_sum += SampleScene(fragmentCoordinates + vec2(((float(x) + 0.5) / float(antiAliasing)) - 0.5, ((float(y) + 0.5) / float(antiAliasing)) - 0.5));\n        }\n    }\n    fragmentColor = color_sum / float(antiAliasing * antiAliasing);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[947, 964, 1014, 1036, 2263]], "test": "untested"}
{"id": "WtcfRN", "name": "Dar 413", "author": "jeyko", "description": "I hate gpus ", "tags": ["mdtmjvm"], "likes": 49, "viewed": 854, "published": 3, "date": "1612302936", "time_retrieved": "2024-07-30T19:41:02.684840", "image_code": "\n// Fork of \"Day 410\" by jeyko. https://shadertoy.com/view/tlKcDd\n// 2021-02-02 11:34:36\n\n\n// Cyclic Noise from nimitz. \n// fwidth analytic SDF AA suggested by Fabrice (another solution suggested before that by mla)\n\n// Why does the fwidth totally break in far off distances and look blocky AAAAAAAAAAAAAAAAAAAA\n\n\nconst float slices = 124.;\n\nconst float sliceDepth = 3.5;\n\nfloat yOffs = 3.5;\n\nconst float width = 0.;\n\nconst float aaSteps = 2.; // aa unused\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n#define offs(z,x) + (sin(z + sin(x))*0.5 - sin(x*0.5)*0.5)\n\nfloat fun(vec3 p){\n    float f = 0.;\n    \n    p.z += iTime;\n    f += cyclicNoise(p*1. + vec3(0,iTime*0.,0), false, iTime*0.)\n        - 0.5;\n    /*\n        - mix(-0.,1.,smoothstep(0.,0.4,-p.y))*0.\n        + 0.*mix(1.,0.,smoothstep(0.,1.,-abs(p.y )+ yOffs ));\n      */  \n    //f = max(f,-dot(p.xy,p.xy) + 0.);\n\n    //f = max(f,-length(p.y) + 0.51);\n    f = opSmoothSubtraction( f,\n        opSmoothUnion(\n            length(p.x + offs(p.z,p.x) ) - 0.2,\n            p.y,\n            1.5\n        )\n        , 0.4 );\n\n    \n    //f = opSmoothSubtraction(-f,p.y+ 0.3,0.1);\n    \n    //f = max(f,-p.y + 0.);\n    \n    return f;\n}\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1);\n    \n    vec3 ro = vec3(0,yOffs,0);\n    \n    vec3 rd = normalize(vec3(uv,3.6));\n    rd.yz *= rot(0.33);\n    \n    \n    for(float i = 0.; i < slices ; i++ ){\n        \n        float t = plaIntersect( ro - vec3(0,i/slices*sliceDepth,0.), rd, vec4(0,1,0,1.) );\n        vec3 p = ro + rd*t;\n        \n        float fn = fun(p);\n        \n        \n        \n        \n        vec3 c = pal(0.5,vec3(0.6,0.05,.15),vec3(4.9,1.,9),1.,i/slices*22. + iTime*1.);\n        \n        \n        float fw = fwidth(fn);\n        \n        \n        fw = mix(fw, fw/4.,smoothstep(1.,0.,i/slices));\n        float d = (fn)/fw;\n        /*\n        if(fwidth(fn) < dFdx(uv.x)*4.)\n            d = fn*220.01;\n        */\n        \n        float n = cyclicNoiseb((p - vec3(0,0,-iTime))*mix(7.,110.,i/slices) + vec3(0,i*0.,0), false, 0.);\n        \n        //n = mix(n*1.,0.,smoothstep(1.,0.04,i/slices));\n        \n        //n /= fwidth(n)*22.001;\n        \n        n = pow(abs(n),2.);\n        \n        //d -= (n*2. - 1.)*0.9*smoothstep(0.1,1.,i/slices);\n        \n        d -= (n*2. - 1.)*0.9;\n        \n        \n        //d = mix(d,3.,n);\n        float g = smoothstep(1.,0.,abs(d )- width - n - (1. - i/slices)*0.);\n        float gb = smoothstep(1.,0.,d - width);\n        \n        //g = max(g,-n + 0.05);\n        \n        col = mix(col, vec3(1), gb );\n        col = mix(col, vec3(0), g);\n        col = max(col,0.);\n\n\n         \n        \n        /*\n            col = mix(col, c*c*0.7, gb);\n            col = mix(col, c*2., g);\n        \n        }*/\n        \n    }\n    \n    /*\n    \n    \n    fn = opSmoothSubtraction(-fn, p.z - 2.,0.5);\n    \n\n    float fw = fwidth(fn)*1. ;\n    //float fw = 0.001;\n    //float fw = length(vec2(dFdx(fn),dFdy(fn))) + 0.0 ;\n\n\n    float d = (fn)/fw;\n    \n    float n = cyclicNoiseb((p - vec3(0,0,-iTime))*110. + vec3(0,0.,0), false, 0.);\n\n    n = pow(n,1.);\n    d -= (n*2. - 1.)*1.;\n\n    //d = mix(d,3.,n);\n    float g = smoothstep(1.,0.,d - 2.5 - n);\n    \n    g = max(g,-n + 0.05);\n\n    col = mix(col, vec3(0), g);\n    col = max(col,0.);\n    \n    */\n    // ------- bird ------- // \n    {\n        float no = cyclicNoiseb(( - vec3(4,1,iTime*0.5)), false, 0.);\n\n        ro.z += sin(iTime)*0.3 + no*2.;\n\n        ro.x -= no;\n        ro.y +=  + cos(iTime*1.5 + sin(iTime*2.5))*0.05 - no*0.2;\n        rd.xy *= rot(sin(iTime)*0.1) - no*0.2;\n\n        float t = plaIntersect( ro - vec3(0,sliceDepth - 1.,0.), rd, vec4(0,1,0,1.) );\n        vec3 p = ro + rd*t;\n        vec3 op = p;\n\n\n        #define smsin(a) smoothstep(0.,1.,sin(a))*sign(a) \n\n\n        float wt = fract(iTime/2.)*1.;\n\n        if(mod(floor(iTime/2.),3.) < 1.)\n            wt *= 0.;\n\n        float wingsoffs = sin(abs(op.x)*5. + iTime/1.*3.14)*0.46; \n\n        wt = pow(wt,0.6);\n        wingsoffs *= smoothstep(1.,0.,wt)*smoothstep(0.,0.7,wt)*4.;\n\n        wingsoffs = mix(wingsoffs*0.6,wingsoffs,smoothstep(0.,0.2,abs(p.x)));\n        float n = cyclicNoiseb((p - vec3(0,0,iTime*0.))*110., false, 0.);\n        n = pow(abs(n),2.);\n\n        t += cyclicNoiseb(( p - vec3(0,0,iTime*2.))*9., false, 0.)*0.02;\n\n        p.xz -= vec2(0,7);\n        p.x = abs(p.x);\n\n        p.z *= 1.;\n        p.xz +=  vec2(0,wingsoffs*0.5);\n        float bird = length(p.xz) - 0.1;\n\n        float bd = sdBox(p.xz*vec2(1,0.3)*rot(0.25*2.6),vec2(0.06));\n\n        bd = max(bd, -sdBox(vec2(abs(p.x),p.z) - vec2(0.14,0),vec2(0.1,0.4)));\n        //bd = \n\n        bird = min(bird, bd );\n\n        p = ro + rd*t;\n\n        p.xz -= vec2(0,7);\n        p.x = abs(p.x);\n\n        p.z *= 1. + smoothstep(0.,1.,p.x*17.);\n\n\n\n        //fn = opSmoothSubtraction(-fn, p.z - 2.,0.5);\n\n\n        p.z += wingsoffs;\n\n        float dwings = sdBox(p.xz - vec2(0.1,0),vec2(.14,0.1));\n        dwings = min(dwings, sdBox((p.xz - vec2(0.25,-0.04))*rot(0.5),vec2(.1,0.1)));\n\n        if(p.z < 0.){\n            dwings -= cyclicNoiseb(op*144.*vec3(1,1,0.2) + vec3(0,iTime,iTime*4.), false, 0.)*0.1;\n        }\n\n\n        bird = min(bird,dwings);\n        //d -= (n*2. - 1.)*0.9*smoothstep(0.1,1.,i/slices);\n\n        bird -= (n*2. - 1.)*0.005;\n\n\n\n\n        float fw = fwidth(bird)*1. ;\n\n        bird /=fwidth(bird);\n\n\n        col = mix(col, vec3(1) - cyclicNoiseb(( - vec3(op.xz,1.))*140.*vec3(1,0.2,1), true, 0.)*0. , smoothstep(1.,0.,bird));\n\n        col = mix(col, vec3(0), smoothstep(1.,0.,abs(bird) - n));\n        col = max(col,0.);\n        }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    col = max(col, 0.);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define pal(a,b,c,d,e) ((a) +(b)*sin((c)*(d) + (e)))\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// TRIANGLE MODE - substitutes sine for tri \n//#define sin(a) (asin(sin(a)))\n//#define sin(a) (fract((a) /3.14/2.)*1. - 0.)\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.6;\n    const int octaves = 5;\n    \n    const float warp =1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\nfloat cyclicNoiseb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.4;\n    const int octaves = 2;\n    \n    const float warp = 1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    } else{\n        //return 0.;\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 459, 517, 517, 617], [620, 620, 672, 672, 771], [834, 834, 852, 852, 1451], [1454, 1454, 1482, 1482, 5905], [5907, 5907, 5964, 5964, 6362]], "test": "untested"}
{"id": "Wtcfz4", "name": "Multispectral Paint Blending", "author": "cornusammonis", "description": "A paint mixing simulation using 16 8-bit color channels.", "tags": ["fluid", "blending", "poisson", "paint", "mixing", "cfd", "multispectral"], "likes": 57, "viewed": 1710, "published": 3, "date": "1612298959", "time_retrieved": "2024-07-30T19:41:03.635299", "image_code": "/*\n    Created by Cornus Ammonis (2021)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n    \n    This is an approach to paint mixing that solves the \"blue + yellow = green\"\n    problem. In most color spaces, blending between blue and yellow will produce\n    gray instead of green. This is a general problem; without a more robust\n    representation of the color spectrum, we are unable to reliably achieve color\n    blending results that are consistent with real-life expectations. In practical\n    terms, that means that when we only use 3 or 4 color channels and repeatedly\n    blend colors together, we tend to rapidly end up with a muddy gray color.\n    Or worse, repeated blending may not be stable at all, and the result may tend \n    to blow up or settle on some fixed point in the color space no matter what \n    the input colors are. \n    \n    Here, color space is represented by 16 8-bit log-space spectral components,\n    which are packed into a vec4. Blending is achieved using simple linear blends\n    on the 16 log-space components.\n    \n    A fluid simulation (Buffer A, C, D) is used to supply advection offset vectors \n    to the paint blending layer (Buffer B). The fluid simulation makes use of the \n    separable multistep Poisson solver method described here \n    \n        Fast Separable Poisson SVD https://www.shadertoy.com/view/wsVyzD\n        \n    to solve for pressure. The fluid simulation is multiscale and incorporates\n    methods developed here\n    \n        Multiscale MIP Fluid https://www.shadertoy.com/view/tsKXR3\n        \n    along with a few other techniques. I have adapted paniq's Analytical Biquadratic\n    Gradient Interpolation method to take an LOD argument (Common Tab).\n    \n    Developing a colorspace is tricky and requires some choice of tradeoffs.\n    I chose constants here to get a relatively accurate conversion from RGB\n    while maintaining good saturation. It would be preferable to use higher \n    bit-depth values for each of the spectral components.\n    \n    A HI_QUALITY #define in the common tab can be enabled to use higher-order\n    sampling for the fluid simulation. Buffer A and B have a variety of\n    configurable parameters in #defines to change the fluid and blending\n    properties.\n    \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 texel = 1.0/iResolution.xy;\n\tvec2 uv = fragCoord.xy * texel;\n    vec3 n = vec3(sample_biquadratic_gradient(iChannel2, iResolution.xy, uv, 0.0),0.04);\n\n    n = normalize(n);\n\n    vec3 light = normalize(vec3(1,4,3));\n    \n    float spec = ggx(reflect(light,n), vec3(0,1,0), light, 0.4, 0.8);\n    \n    float d = texture(iChannel2,uv).x;\n    float occ = 0.0;\n    float occs = 0.0;\n    for (float m = 1.0; m <= 10.0; m +=1.0) {\n        float dm = texture(iChannel2, uv, m).x;\n        float occw = pow(m,1.0);\n        occs += occw;\n        occ += occw*softclamp(-1.0, 1.0, (d - dm),8.0);\n    }\n    occ /= occs;\n\n    occ = pow(softclamp(0.0,1.0,occ,12.0), 0.06);\n\n\tfragColor = occ*(0.1*spec + (1.2+0.5*spec) * vec4(colorFromSpectrum(getPackedSpectrum(iChannel1, fragCoord)),1));\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define HI_QUALITY\n\nivec2 imod(ivec2 x, ivec2 p) {\n\t\treturn x - p * (x/p);\n}\n\n#define MOUSE_RADIUS 0.0002\n\n#define MOUSE_VEC vec4(mousePath(iTime),mousePath(iTime-2.0))\nvec2 mousePath(float T) {\n    return vec2(0.5 + 0.3 * cos(T) / (1.0 + sin(T)*sin(T)), 0.5+0.5*cos(T)*sin(T) / (1.0 + sin(T)*sin(T)));\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x,0.0, 1.0) * 255.0);\n    uvec4 r = uvec4(x) & uvec4(0xFF);\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    vec4 fmag = vec4(r) / 255.0;\n    return fmag;\n}\n\n#define unpack(x) unpackUnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packUnorm4x8(x))\n\n#define unpack16(x) unpackSnorm2x16(floatBitsToUint(x))\n#define pack16(x) uintBitsToFloat(packSnorm2x16(x))\n\n\n#define WAVELENGTHS 16\n\n#define SQRT_TWO_PI 2.50662827463\nfloat gaussian(float x, float mu, float sig) {\n    return (1.0/(SQRT_TWO_PI*sig)) * exp(-0.5 * pow((x-mu)/sig,2.0));\n}\n\n#define SS 1.04\n#define GSS 1.0\n//          |         |\n//0 1 2 3 4 5 6 7 8 9 A B C D E F\nvec3 sampleWeights(float i) {\n\treturn vec3(gaussian(i,2.666,SS),gaussian(i,7.5,GSS*SS),gaussian(i,12.333,SS));\n}\n\n#define LOG_SCALE0 0.90\n#define LOG_SCALE1 0.09\n#define LOG_SCALE2 5.28\n\nvoid upsample(vec3 upsamp, inout float spectrum[WAVELENGTHS]) {\n    vec3 col = vec3(0);\n    vec3 dw = vec3(0);\n    \n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        dw += sw;\n    }\n    \n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n\t\tspectrum[i] = -LOG_SCALE1*log(LOG_SCALE2*LOG_SCALE0*dot(sw/dw,1.0-upsamp));\n    }\n}\n\nvec3 downsample(float spectrum[WAVELENGTHS]) {\n    vec3 col = vec3(0);\n\t\tvec3 dw = vec3(0);\n\t\tfor(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        dw += sw;\n    }\n\n\t/* METHOD 1\n    for(int i = 0; i < WAVELENGTHS; i++) {\n        vec3 sw = sampleWeights(float(i));\n        col += (sw/dw)*(1.0-exp(-spectrum[i]/LOG_SCALE1))/LOG_SCALE0;\n    }\n    return col;*/\n\n\t// METHOD 2\n\tfor(int i = 0; i < WAVELENGTHS; i++) {\n\t\tvec3 sw = sampleWeights(float(i));\n\t\tcol += -(sw/dw)*spectrum[i];\n\t}\n\treturn (1.0-exp(col/LOG_SCALE1))/LOG_SCALE0;\n}\n\nvoid vec16toArray(inout float spectrum[WAVELENGTHS], vec4 spec0, vec4 spec1, vec4 spec2, vec4 spec3) {\n    spectrum[0] = spec0.x;\n    spectrum[1] = spec0.y;\n    spectrum[2] = spec0.z;\n    spectrum[3] = spec0.w;\n    spectrum[4] = spec1.x;\n    spectrum[5] = spec1.y;\n    spectrum[6] = spec1.z;\n    spectrum[7] = spec1.w;\n    spectrum[8] = spec2.x;\n    spectrum[9] = spec2.y;\n    spectrum[10] = spec2.z;\n    spectrum[11] = spec2.w;\n    spectrum[12] = spec3.x;\n    spectrum[13] = spec3.y;\n    spectrum[14] = spec3.z;\n    spectrum[15] = spec3.w;\n}\n\nvoid unpackSpectrum(vec4 packed_spectrum, inout float spectrum[WAVELENGTHS]) {\n\tvec4 unpack0 = unpack(packed_spectrum.x);\n    vec4 unpack1 = unpack(packed_spectrum.y);\n    vec4 unpack2 = unpack(packed_spectrum.z);\n    vec4 unpack3 = unpack(packed_spectrum.w);\n\n    vec16toArray(spectrum, unpack0, unpack1, unpack2, unpack3);\n}\n\nvec3 colorFromSpectrum(vec4 packed_spectrum) {\n\t\tfloat spectrum[WAVELENGTHS];\n\t\tunpackSpectrum(packed_spectrum, spectrum);\n\t\treturn downsample(spectrum);\n}\n\nvec4 packSpectrum(float spectrum[WAVELENGTHS]) {\n\treturn vec4(\n        pack(vec4(spectrum[0],spectrum[1],spectrum[2],spectrum[3])),\n        pack(vec4(spectrum[4],spectrum[5],spectrum[6],spectrum[7])),\n        pack(vec4(spectrum[8],spectrum[9],spectrum[10],spectrum[11])),\n        pack(vec4(spectrum[12],spectrum[13],spectrum[14],spectrum[15]))\n    );\n}\n\nvec4 getPackedSpectrum(sampler2D channel, vec2 fragCoord) {\n\treturn texelFetch(channel, ivec2(floor(fragCoord)), 0);\n}\n\n// Fast Biquadratic Interpolation by paniq, Public Domain\n// https://www.shadertoy.com/view/wtXXDl\n\n// avoid hardware interpolation\n#define RESMOD(d,r) ivec2(imod((ivec2(r) + ivec2(imod(ivec2(d),ivec2(r)))), ivec2(r)))\n\nvec4 sample_biquadratic_exact(sampler2D channel, vec2 iResolution, vec2 uv) {\n\tivec2 LODres = textureSize(channel, 0);\n    vec2 q = fract(uv * vec2(LODres));\n    ivec2 t = ivec2(floor(uv * vec2(LODres)));\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, RESMOD(t + e.xx, LODres), 0);\n    vec4 s01 = texelFetch(channel, RESMOD(t + e.xy, LODres), 0);\n    vec4 s02 = texelFetch(channel, RESMOD(t + e.xz, LODres), 0);\n    vec4 s12 = texelFetch(channel, RESMOD(t + e.yz, LODres), 0);\n    vec4 s11 = texelFetch(channel, RESMOD(t + e.yy, LODres), 0);\n    vec4 s10 = texelFetch(channel, RESMOD(t + e.yx, LODres), 0);\n    vec4 s20 = texelFetch(channel, RESMOD(t + e.zx, LODres), 0);\n    vec4 s21 = texelFetch(channel, RESMOD(t + e.zy, LODres), 0);\n    vec4 s22 = texelFetch(channel, RESMOD(t + e.zz, LODres), 0);\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);\n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n#define PM(d) fract(d)\n\nvec4 sample_biquadratic_exact_lod(sampler2D channel, vec2 uv, int lod) {\n    ivec2 LODres = textureSize(channel, lod);\n    vec2 FC = uv * vec2(LODres);\n    vec2 q = fract(FC);\n    ivec2 t = ivec2(floor(FC));\n    ivec3 e = ivec3(-1, 0, 1);\n    vec4 s00 = texelFetch(channel, RESMOD(t + e.xx, LODres), lod);\n    vec4 s01 = texelFetch(channel, RESMOD(t + e.xy, LODres), lod);\n    vec4 s02 = texelFetch(channel, RESMOD(t + e.xz, LODres), lod);\n    vec4 s12 = texelFetch(channel, RESMOD(t + e.yz, LODres), lod);\n    vec4 s11 = texelFetch(channel, RESMOD(t + e.yy, LODres), lod);\n    vec4 s10 = texelFetch(channel, RESMOD(t + e.yx, LODres), lod);\n    vec4 s20 = texelFetch(channel, RESMOD(t + e.zx, LODres), lod);\n    vec4 s21 = texelFetch(channel, RESMOD(t + e.zy, LODres), lod);\n    vec4 s22 = texelFetch(channel, RESMOD(t + e.zz, LODres), lod);\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);\n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n// accurate analytical gradient with 8 taps\nvec2 sample_biquadratic_gradient(sampler2D channel, vec2 res, vec2 uv, float mip) {\n    vec2 q = fract(uv * res);\n\t\tfloat sc = pow(2.0,mip);\n    vec2 c = sc * (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec2 cc = sc * 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx0 = textureLod(channel, fract(vec2(ww1.x, w0.y)), mip).r - textureLod(channel, fract(vec2(ww0.x, w0.y)), mip).r;\n    float nx1 = textureLod(channel, fract(vec2(ww1.x, w1.y)), mip).r - textureLod(channel, fract(vec2(ww0.x, w1.y)), mip).r;\n\n    float ny0 = textureLod(channel, fract(vec2(w0.x, ww1.y)), mip).r - textureLod(channel, fract(vec2(w0.x, ww0.y)), mip).r;\n    float ny1 = textureLod(channel, fract(vec2(w1.x, ww1.y)), mip).r - textureLod(channel, fract(vec2(w1.x, ww0.y)), mip).r;\n\n\treturn vec2(nx0 + nx1, ny0 + ny1) / 2.0;\n}\n\n#define SAMPLE_CHAN x\n\nvec2 sample_biquadratic_gradient_lod(sampler2D channel, vec2 uv, int lod) {\n    ivec2 LODres = textureSize(channel, lod);\n    vec2 FC = uv * (vec2(LODres));\n    vec2 q = fract(FC);\n    ivec2 t = ivec2(floor(FC));\n    ivec3 e = ivec3(-1, 0, 1);\n    float s_sw = texelFetch(channel, RESMOD(t + e.xx, LODres), lod).SAMPLE_CHAN;\n    float s_w  = texelFetch(channel, RESMOD(t + e.xy, LODres), lod).SAMPLE_CHAN;\n    float s_nw = texelFetch(channel, RESMOD(t + e.xz, LODres), lod).SAMPLE_CHAN;\n    float s_n  = texelFetch(channel, RESMOD(t + e.yz, LODres), lod).SAMPLE_CHAN;\n    float s_c  = texelFetch(channel, RESMOD(t + e.yy, LODres), lod).SAMPLE_CHAN;\n    float s_s  = texelFetch(channel, RESMOD(t + e.yx, LODres), lod).SAMPLE_CHAN;\n    float s_se = texelFetch(channel, RESMOD(t + e.zx, LODres), lod).SAMPLE_CHAN;\n    float s_e  = texelFetch(channel, RESMOD(t + e.zy, LODres), lod).SAMPLE_CHAN;\n    float s_ne = texelFetch(channel, RESMOD(t + e.zz, LODres), lod).SAMPLE_CHAN;\n\n    vec2 p = q * (q-1.0) + 0.5;\n    vec2 nq  = 1.0 - q;\n    vec2 nq2 = 1.0 - 2.0*q;\n    vec2 np  = 1.0 - p;\n    vec2 ppq = p+q-0.5;\n    vec2 pmq = p-q+0.5;\n\n    vec2 W_c  = vec2(2.0 * np.y * nq2.x, 2.0 * np.x * nq2.y);\n    vec2 W_n  = vec2(ppq.y * nq2.x, 2.0 * q.y * np.x);\n    vec2 W_s  = vec2(pmq.y * nq2.x, -2.0 * nq.y * np.x);\n    vec2 W_e  = vec2(2.0 * q.x * np.y, ppq.x * nq2.y);\n    vec2 W_w  = vec2(-2.0 * nq.x * np.y, pmq.x * nq2.y);\n    vec2 W_nw = vec2(-nq.x * ppq.y, pmq.x * q.y);\n    vec2 W_se = vec2(q.x * pmq.y, -ppq.x * nq.y);\n    vec2 W_ne = vec2(q.x * ppq.y, ppq.x * q.y);\n    vec2 W_sw = vec2(-nq.x * pmq.y, -pmq.x * nq.y);\n\n    vec2 sum = W_c * s_c + W_n * s_n + W_s * s_s + W_e * s_e + W_w * s_w\n            + W_nw * s_nw + W_se * s_se + W_ne * s_ne + W_sw * s_sw;\n\n    return sum / 2.0;\n}\n\nvec4 biquad(vec2 q, vec4 s00, vec4 s01, vec4 s02, vec4 s10, vec4 s11, vec4 s12, vec4 s20, vec4 s21, vec4 s22) {\n    vec2 q0 = (q+1.0)/2.0;\n    vec2 q1 = q/2.0;\n    vec4 x0 = mix(mix(s00, s01, q0.y), mix(s01, s02, q1.y), q.y);\n    vec4 x1 = mix(mix(s10, s11, q0.y), mix(s11, s12, q1.y), q.y);\n    vec4 x2 = mix(mix(s20, s21, q0.y), mix(s21, s22, q1.y), q.y);\n\treturn mix(mix(x0, x1, q0.x), mix(x1, x2, q1.x), q.x);\n}\n\n// avoid hardware interpolation\nvoid sample_biquadratic_exact_unpack(sampler2D channel, vec2 uv, vec2 iResolution, out float spectrum[WAVELENGTHS]) {\n    vec2 q = fract(uv * iResolution);\n    ivec2 t = ivec2(floor(uv * iResolution));\n    ivec3 e = ivec3(-1, 0, 1);\n\n    vec4 p00 = texelFetch(channel, RESMOD(t + e.xx, iResolution), 0);\n    vec4 p01 = texelFetch(channel, RESMOD(t + e.xy, iResolution), 0);\n    vec4 p02 = texelFetch(channel, RESMOD(t + e.xz, iResolution), 0);\n    vec4 p12 = texelFetch(channel, RESMOD(t + e.yz, iResolution), 0);\n    vec4 p11 = texelFetch(channel, RESMOD(t + e.yy, iResolution), 0);\n    vec4 p10 = texelFetch(channel, RESMOD(t + e.yx, iResolution), 0);\n    vec4 p20 = texelFetch(channel, RESMOD(t + e.zx, iResolution), 0);\n    vec4 p21 = texelFetch(channel, RESMOD(t + e.zy, iResolution), 0);\n    vec4 p22 = texelFetch(channel, RESMOD(t + e.zz, iResolution), 0);\n\n\n    vec4 spec0 = biquad(q,\n                   unpack(p00.x), unpack(p01.x), unpack(p02.x),\n                   unpack(p10.x), unpack(p11.x), unpack(p11.x),\n                   unpack(p20.x), unpack(p21.x), unpack(p21.x));\n\n    vec4 spec1 = biquad(q,\n                   unpack(p00.y), unpack(p01.y), unpack(p02.y),\n                   unpack(p10.y), unpack(p11.y), unpack(p11.y),\n                   unpack(p20.y), unpack(p21.y), unpack(p21.y));\n\n    vec4 spec2 = biquad(q,\n                   unpack(p00.z), unpack(p01.z), unpack(p02.z),\n                   unpack(p10.z), unpack(p11.z), unpack(p11.z),\n                   unpack(p20.z), unpack(p21.z), unpack(p21.z));\n\n    vec4 spec3 = biquad(q,\n                   unpack(p00.w), unpack(p01.w), unpack(p02.w),\n                   unpack(p10.w), unpack(p11.w), unpack(p11.w),\n                   unpack(p20.w), unpack(p21.w), unpack(p21.w));\n\n    vec16toArray(spectrum, spec0, spec1, spec2, spec3);\n\n}\n\nvec4 bilin(vec2 q, vec4 p11, vec4 p12, vec4 p21, vec4 p22) {\n    vec4 x1 = mix(p11, p21, q.x);\n    vec4 x2 = mix(p12, p22, q.x);\n    return mix(x1, x2, q.y);\n}\n\n\nvoid sample_bilinear_unpack(sampler2D channel, vec2 uv, vec2 iResolution, out float spectrum[WAVELENGTHS]) {\n\n    vec2 p = uv * iResolution - 0.5;\n    vec2 q = fract(p);\n    vec2 tx = 1.0 / iResolution;\n    \n    ivec2 t = ivec2(floor(p));\n    \n    ivec3 e = ivec3(-1, 0, 1);\n\n    vec4 p12 = texelFetch(channel, RESMOD(t + e.yz, iResolution), 0);\n    vec4 p11 = texelFetch(channel, RESMOD(t + e.yy, iResolution), 0);\n    vec4 p21 = texelFetch(channel, RESMOD(t + e.zy, iResolution), 0);\n    vec4 p22 = texelFetch(channel, RESMOD(t + e.zz, iResolution), 0);\n\n    vec4 spec0 = bilin(q,\n                   unpack(p11.x), unpack(p12.x),\n                   unpack(p21.x), unpack(p22.x));\n\n    vec4 spec1 = bilin(q,\n                   unpack(p11.y), unpack(p12.y),\n                   unpack(p21.y), unpack(p22.y));\n\n    vec4 spec2 = bilin(q,\n                   unpack(p11.z), unpack(p12.z),\n                   unpack(p21.z), unpack(p22.z));\n\n    vec4 spec3 = bilin(q,\n                   unpack(p11.w), unpack(p12.w),\n                   unpack(p21.w), unpack(p22.w));\n\n    vec16toArray(spectrum, spec0, spec1, spec2, spec3);\n\n}\n\n\n// Only used for rendering, but useful helpers\nfloat softmax(float a, float b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nfloat softmin(float a, float b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nvec4 softmax(vec4 a, vec4 b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nvec4 softmin(vec4 a, vec4 b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nfloat softclamp(float a, float b, float x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(vec4 a, vec4 b, vec4 x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(float a, float b, vec4 x, float k) {\n\treturn (softmin(vec4(b),softmax(vec4(a),x,k),k) + softmax(vec4(a),softmin(vec4(b),x,k),k)) / 2.0;    \n}\n\n\n\n\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// a simple modification for this shader to get a vec4\nvec4 rand4( vec2 fragCoord, vec2 iResolution, int iFrame ) {\n    uvec2 p = uvec2(fragCoord);\n    uvec2 r = uvec2(iResolution);\n    uint c = p.x + r.x*p.y + r.x*r.y*uint(iFrame);\n\treturn vec4(hash3(c),hash1(c + 75132895U));\n}\n// End IQ's integer hash\n\n\n\n\n\n\n\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n", "buffer_a_code": "#define K_FUNC_VEL 1.0\n#define K_FUNC_OFF 0.0\n#define OFFSET_SCALE_OFF 1.0\n#define OFFSET_SCALE_VEL 1.0\n#define OFFSET_TEMPORAL_SMOOTH 0.0\n#define ADVECT_TIMESTEP 1.0\n#define DIVERGENCE_MIN -0.02\n#define VELOCITY_FEED 1.0\n#define VISCOSITY 0.0015\n#define DAMPING 0.005\n#define MOUSE_AMP 1.0\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n#ifdef HI_QUALITY\n    #define E(d) sample_biquadratic_exact_lod(iChannel0, uv + texel * (d+0.), 0)\n#else\n    #define E(d) textureLod(iChannel0, uv + texel * (d+0.), 0.0)\n#endif\n#define K_F(k) (K_FUNC_VEL*k.xy+K_FUNC_OFF*k.zw)\nvec4 advect(vec2 uv, vec2 v, float ts){\n    vec2 texel = 1.0/iResolution.xy;\n    uv -= v * texel;\n    vec4 k1 = E();\n    vec4 k2 = E(-0.5*K_F(k1)*ts);\n    vec4 k3 = E(-0.5*K_F(k2)*ts);\n    vec4 k4 = E(-K_F(k3)*ts);\n    return 1.0*(k1+2.0*k2+2.0*k3+k4)/6.0;\n}\n#ifdef HI_QUALITY\n    #define C(x,y) sample_biquadratic_exact_lod(iChannel0, t*(U+float(1<<s)*vec2(x,y)), s)\n#else\n    #define C(x,y) textureLod(iChannel0, t*(U+float(1<<s)*vec2(x,y)), float(s))\n#endif\n#define D() sample_biquadratic_gradient_lod(iChannel2, uv, s)\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = O-O;\n    vec2 t = 1./iResolution.xy;\n    vec2 uv = U*t;\n\n    int s = int(max(log2(iResolution.x),log2(iResolution.y)));\n    vec2 mdiff = vec2(0);\n    vec4 sample_prev = textureLod(iChannel0, uv, 0.0);\n    vec2 offset_prev = sample_prev.zw;\n\tconst float L0 = -3.0;\n\tconst float L1 = 0.5;\n\tconst float L2 = 0.25;\n\tvec4 lapl = vec4(0);\n    for (; s >= 0; s--) {\n\t\tvec4 c_n = C(0,1);\n\t\tvec4 c_s = C(0,-1);\n\t\tvec4 c_e = C(1,0);\n\t\tvec4 c_w = C(-1,0);\n\t\tvec4 c_ne = C(1,1);\n\t\tvec4 c_se = C(1,-1);\n\t\tvec4 c_nw = C(-1,1);\n\t\tvec4 c_sw = C(-1,-1);\n\t\tvec4 c = C(0,0);\n\t\tlapl += pow(float(s+1),1.0) * (L0 * c + L1 * (c_n+c_e+c_w+c_s) + L2 * (c_ne+c_se+c_nw+c_sw));\n\t\tO.xy += pow(float(s+1),1.0) * (2.0 * vec2(c_n.x + c_s.x, c_e.y + c_w.y) -4.0 * c.xy + (c_se - c_ne - c_sw + c_nw).yx);\n        mdiff += pow(float(s+1),1.0) * D();\n    }\n    vec2 offset = OFFSET_SCALE_OFF*O.xy + OFFSET_SCALE_VEL*sample_prev.xy;\n    vec2 new_offset = mix(offset,offset_prev,OFFSET_TEMPORAL_SMOOTH);\n    O = vec4(advect(uv,new_offset,ADVECT_TIMESTEP).xy \n            + DIVERGENCE_MIN * mdiff \n            + VELOCITY_FEED * t.xx * new_offset \n            + VISCOSITY * lapl.xy \n            - DAMPING * sample_prev.xy\n            , new_offset\n    );\n\n    // mouse control\n    vec4 mouseUV;\n    if (iMouse.z > 0.0) {\n        mouseUV = iMouse / iResolution.xyxy;\n    } else {\n        mouseUV = MOUSE_VEC;\n    }   \n    vec2 delta = -normz(mouseUV.xy - abs(mouseUV.zw));\n    vec2 md = (mouseUV.xy - uv) * vec2(1.0,t.x/t.y);\n    float amp = clamp(exp(max(-24.0,-dot(md,md)/MOUSE_RADIUS)),0.0,1.0);\n    O += vec4(MOUSE_AMP * delta * amp,0,0);\n\n    // init\n    if(iChannelResolution[1].z < 1.0) {\n    \tO = vec4(1e-4);    \n    } else if(reset()) {\n        O = vec4(1e-4);\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define K_FUNC_VEL 0.0\n#define K_FUNC_OFF 1.0\n#define ADVECT_INIT_VEL 0.0\n#define ADVECT_INIT_OFF 0.5\n#define ADVECT_TIMESTEP 0.7\n#define ADVECT_BLEND 1.0\n#define MOUSE_AMP 10.0\n#define SPEC_AMP_MAX 0.5\n#define SPEC_AMP_MIN -1.5\n\n#ifdef HI_QUALITY\n    #define E(d) sample_biquadratic_exact_lod(iChannel0, uv + tx * (d+0.), 0)\n#else\n    #define E(d) textureLod(iChannel0, uv + tx * (d+0.), 0.0)\n#endif\n\n#define K_F(k) (K_FUNC_VEL*k.xy+K_FUNC_OFF*k.zw)\nvec4 advect(vec2 uv, vec2 v, float ts, out float result[WAVELENGTHS]){\n    vec2 tx = 1.0/iResolution.xy;\n    uv -= v * tx;\n    vec4 k1 = E();\n\t\tfloat spectrum_advect0[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv - tx*K_F(k1), iResolution.xy, spectrum_advect0);\n    vec4 k2 = E(-0.5*K_F(k1)*ts);\n\t\tfloat spectrum_advect1[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv -0.5*tx*K_F(k2), iResolution.xy, spectrum_advect1);\n    vec4 k3 = E(-0.5*K_F(k2)*ts);\n\t\tfloat spectrum_advect2[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv -0.5*tx*K_F(k3), iResolution.xy, spectrum_advect2);\n    vec4 k4 = E(-K_F(k3)*ts);\n\t\tfloat spectrum_advect3[WAVELENGTHS];\n\t\tsample_bilinear_unpack(iChannel2, uv - tx*K_F(k4), iResolution.xy, spectrum_advect3);\n\n\t\tfor (int i = 0; i < WAVELENGTHS; i++) {\n\t\t\t result[i] = (spectrum_advect0[i]+2.0*spectrum_advect1[i]+2.0*spectrum_advect2[i]+spectrum_advect3[i])/6.0;\n\t\t}\n    return 1.0*(k1+2.0*k2+2.0*k3+k4)/6.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 tx = 1.0 / iResolution.xy;\n\n    float spectrum[WAVELENGTHS];\n\n    vec4 A = textureLod(iChannel0, uv, 0.0);\n\n    vec4 packed_spectrum = getPackedSpectrum(iChannel2, fragCoord);\n    unpackSpectrum(packed_spectrum, spectrum);\n\n    float spectrum_advect[WAVELENGTHS];\n\n\tadvect(uv, ADVECT_INIT_OFF*A.zw + ADVECT_INIT_VEL*A.xy, ADVECT_TIMESTEP, spectrum_advect);\n\n    for (int i = 0; i < WAVELENGTHS; i++) {\n    \t spectrum[i] = mix(spectrum[i], spectrum_advect[i], ADVECT_BLEND);\n    }\n\n    // mouse control\n    vec4 mouseUV;\n    vec2 delta;\n    if (iMouse.z > 0.0) {\n        mouseUV = iMouse / iResolution.xyxy;\n        delta = -normz(mouseUV.xy - abs(mouseUV.zw));\n    } else {\n        mouseUV = MOUSE_VEC;\n        delta = -normz(mouseUV.xy - abs(mouseUV.zw));\n    }\n    \n    vec2 md = (mouseUV.xy - uv) * vec2(1.0,tx.x/tx.y);\n    float amp = clamp(MOUSE_AMP*exp(max(-24.0,-0.5*dot(md,md)/MOUSE_RADIUS)),0.0,1.0);\n\n    // generate a paint color spectrum\n    vec4 r0 = rand4(vec2(iTime), iResolution.xy, 0);\n    vec4 r1 = rand4(vec2(iTime), iResolution.xy, 1);\n    vec4 r2 = rand4(vec2(iTime), iResolution.xy, 2);\n    for (int i = 0; i < WAVELENGTHS; i++) {\n        float spec = (\n            r0.x * gaussian(float(i), float(WAVELENGTHS) * r0.y, r0.z * 2.0) +\n            r1.x * gaussian(float(i), float(WAVELENGTHS) * r1.y, r1.z * 2.0) +\n            r2.x * gaussian(float(i), float(WAVELENGTHS) * r2.y, r2.z * 2.0));\n\n        spectrum[i] = max(1.0/255.0,spectrum[i] + mix(SPEC_AMP_MIN,SPEC_AMP_MAX,r0.w) * spec * amp);\n    }\n\n    // init\n    if(iChannelResolution[1].z < 1.0) {  \n        fragColor = vec4(0);\n    } else if((iChannelResolution[1].z == 1.0 && texture(iChannel2,vec2(0.5)) == vec4(0))) {\n        vec3 up = textureLod(iChannel1, uv, 0.0).xyz;\n        upsample(up, spectrum);  \n        fragColor = packSpectrum(spectrum);\n    } else {\n\t\tfragColor = packSpectrum(spectrum);\n    }\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    \n/*\nU:\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-7.0606907e-001   4.6167731e-001  -1.4625093e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n\nV:\n 6.2750203e-003  5.2398670e-002  3.7276962e-001\n-1.6414278e-003  4.2486224e-002  5.4995743e-001\n-4.3498466e-002 -1.0892533e-001  2.4023362e-001\n-1.3135171e-001 -3.3953004e-001 -7.8265086e-004\n-3.0484343e-001 -5.0984393e-001  1.8311873e-002\n-6.2280256e-001  3.2918550e-001 -2.3270335e-002\n-5.8224388e-076  3.2916004e-064 -1.0109051e-055\n 6.2280256e-001 -3.2918550e-001  2.3270335e-002\n 3.0484343e-001  5.0984393e-001 -1.8311873e-002\n 1.3135171e-001  3.3953004e-001  7.8265088e-004\n 4.3498466e-002  1.0892533e-001 -2.4023362e-001\n 1.6414278e-003 -4.2486224e-002 -5.4995743e-001\n-6.2750203e-003 -5.2398670e-002 -3.7276962e-001\n\ndiag(S):\n\n  5.2045614e-001\n  4.5787111e-002\n  5.3607463e-003\n  1.3379961e-003\n  2.4305267e-005\n  6.5520767e-008\n  2.7241624e-013\n  1.8098574e-013\n  4.2556708e-014\n  3.2104951e-014\n  5.6655005e-016\n  2.1958056e-018\n  1.0637097e-030\n\n*/\n\n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n\n    #define Po(m,n) texelFetch(iChannel0, RESMOD(ivec2(fragCoord) + ivec2(m,n), iResolution.xy), 0)\n    #define Go(m,n) texelFetch(iChannel1, RESMOD(ivec2(fragCoord) + ivec2(m,n), iResolution.xy), 0)\n\n    vec2 P1 = vec2(0);\n    vec2 P2 = vec2(0);\n    vec2 P3 = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n\n        vec2 t = Po(i,0).xy;\n        float g = Go(i,0).x;\n        \n        P1 += vec2(p_x1[index], p_y1[index]) * t;\n        P2 += vec2(p_x2[index], p_y2[index]) * t;\n        P3 += vec2(p_x3[index], p_y3[index]) * t;\n        \n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(iFrame <= 1 || reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(pack16(P1),pack16(P2),pack16(P1), G);\n    }\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n\n    #define Po(m,n) texelFetch(iChannel0, RESMOD(ivec2(fragCoord) + ivec2(m,n), iResolution.xy), 0)\n\n    vec2 P = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n        \n        vec4 tx = Po(0,i);\n        vec2 t1 = unpack16(tx.x);\n        vec2 t2 = unpack16(tx.y);\n        vec2 t3 = unpack16(tx.z);\n\n        float g = tx.w;\n        \n        P += s_i[0] * vec2(p_x1[index], p_y1[index]).yx * t1;\n        P += s_i[1] * vec2(p_x2[index], p_y2[index]).yx * t2;\n        P += s_i[2] * vec2(p_x3[index], p_y3[index]).yx * t3;\n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(iFrame <= 1 || reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(P.x + P.y + G);\n    }\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtcfz4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2287, 2287, 2344, 2344, 3125]], "test": "untested"}
{"id": "ttdBzH", "name": "Made something really weird", "author": "LowSpecCorgi", "description": "idfk what this is supposed to be", "tags": ["noise", "random", "weird"], "likes": 3, "viewed": 310, "published": 3, "date": "1612281246", "time_retrieved": "2024-07-30T19:41:04.395267", "image_code": "// Author:\n// Title:\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct) {    \n    return smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.970, st.y);\n}\n\n\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= tan(st.x);\n    vec3 color = vec3(sin(iTime)-plot(st, snoise(cos(st * 1.5) * 4.456 + iTime)) * 50.0,sin(iTime * 3.0)-plot(st, snoise(sin(st * 2.0) * 4.456 + iTime)) * 50.0,  sin(iTime * 2.0)-plot(st, snoise(tan(st * 1.392) * 4.456 + iTime)) * 50.0);\n\n    fragColor = vec4(color,2.000);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 90, 90, 137], [138, 138, 159, 159, 206], [207, 207, 229, 229, 264], [266, 266, 290, 290, 397], [399, 449, 481, 481, 578], [582, 582, 604, 604, 1652], [1654, 1654, 1711, 1711, 2095]], "test": "untested"}
{"id": "wtdfz8", "name": "Serpents ", "author": "YitingLiu", "description": "Creating the evil moving snake", "tags": ["noise", "texture", "evil", "snake", "truchet", "flow", "floor", "mask", "angle", "fract", "width"], "likes": 2, "viewed": 315, "published": 3, "date": "1612269891", "time_retrieved": "2024-07-30T19:41:05.142269", "image_code": "// created by Yiting Liu 2021\n// www.yitingliu.com\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n\n\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col =vec3(0);\n    \n    uv*=4.;\n    uv+=iTime*0.5;\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);//checking each box \n    \n    float n = Hash21(id);// random number between 0 to 1 \n    \n    float width =0.3*UV.y;\n    \n    if(n<.5) gv.x*=-1.;//reverse tiling depending on the random num\n    float d = abs(abs(gv.x+gv.y));\n    vec2 cUv =gv-0.5*sign(gv.x+gv.y+0.001); // give -PI to PI \n    d = length(cUv);\n    // sign returns 1 when x is positive, -1 when x is negative, 0 when x is 0\n    \n    float mask = smoothstep(.01,-.01,abs(d-.5)-width);\n    float angle = atan(cUv.x, cUv.y);\n    float checker = mod(id.x+id.y,2.)*2.-1.;\n    float flow = sin( iTime+checker*angle*10.);\n    //col+=flow*mask;// checker allows it to flow consistently - works with quart truchet\n    //col+=n;\n    \n    float x = fract(checker*angle/1.57-iTime*0.5); //divide by half PI - get the range from 0 to 1 by using fract \n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    vec2 tUv = vec2(x,y);\n    col.rb+=1.-tUv/mask;\n    \n    // apply any texture\n    col *=texture(iChannel0,tUv).rgb*mask;\n\n    col +=texture(iChannel1,tUv).rgb-mask;\n    col +=1.-tUv.y;\n    //if(gv.x>.48||gv.y>.48) col=vec3(1,0,0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdfz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 73, 73, 171], [174, 174, 231, 231, 1576]], "test": "untested"}
{"id": "tt3BRH", "name": "Advanced data packing", "author": "michael0884", "description": "Trying to cram as much useful data into a buffer as possible.\nUniform quantization, Log quantization(emulates floats) and Fibonacci vector quantization. \nP.S. 8 bit log numbers are... uhh at best", "tags": ["datapacking"], "likes": 12, "viewed": 572, "published": 3, "date": "1612235402", "time_retrieved": "2024-07-30T19:41:05.956094", "image_code": "//MIT License\n//Copyright 2020 Mykhailo Moroz\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n//PACKING FUNCTIONS ARE IN COMMON\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 tp  = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    //log2 range\n    vec2 r = vec2(-5.0, 5.0); //from 2^-5 to 2^5\n    vec3 t0 = UNPACK4LOG(tp.x, r).xyz; //4 8 bit unsigned logarithmic numbers in 1 float32\n    vec3 t1 = UNPACKVEC3(tp.y, r); //fibonacci encoded direction + log length in 1 float32\n    vec3 t2 = vec3(UNPACK2SLOG(tp.z, r).xy, .0); //signed log numbers\n    vec3 t3 = UNPACK4LOG(tp.w, r).xyz;\n    \n    vec2 c = 0.5 + 0.25 * vec2(cos(iTime), sin(iTime));\n    \n    vec3 tx = t1;\n    vec3 ty = mix(t2, t3, bvec3(uv.x > c.x));\n    // Output to screen\n    fragColor.xyz = mix(tx, ty, bvec3(uv.y > c.y));;\n    fragColor.w = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//from https://www.shadertoy.com/view/wtKyR1\n\nvec4 b127_ieee754_encode (uvec4 v) {\n  v.w&=0x7FFFFFFFu;\n  uvec4 l = uvec4( v.xyz&0xFFFFFFu , v.x>>24 | v.y>>24<<8 | v.z>>24<<16 );\n  return uintBitsToFloat( (l&0x800000u)<<8 | l&0x7FFFFFu\n   | 1u+uvec4(v.w/uvec4(1,254,254*254,254*254*254))%254u <<23 );\n}\n\nuvec4 b127_ieee754_decode (vec4 f) {\n  uvec4 e = floatBitsToUint(f);\n  uvec4 l = (e&0x80000000u)>>8 | e&0x7FFFFFu;\n  uvec4 h = (e>>23&0xFFu)-1u;\n  return uvec4(\n    l.xyz | uvec3(l.w)>>uvec3(0,8,16)<<24,\n    h.x+254u*h.y+(254u*254u)*h.z+(254u*254u*254u)*h.w );\n}\n\n\n// UINT PACKING \n//8bit number packing \nuint encode4to1(uvec4 x)\n{\n    x = min(x, uvec4(1<<8) - 1u);\n    return x.w << 24 | x.z << 16 | x.y << 8 | x.x;\n}\n\nuvec4 decode1to4(uint x)\n{\n    return (uvec4(x) >> uvec4(0, 8, 16, 24)) & (uvec4(1<<8) - 1u);\n}\n\n//11 11 10 bit number packing\nuint encode3to1(uvec3 x)\n{\n    x = min(x, uvec3(1)<<uvec3(11,11,10) - 1u);\n    return x.z << 22 | x.y << 11 | x.x;\n}\n\nuvec3 decode1to3(uint x)\n{\n    return (uvec3(x) >> uvec3(0, 11, 22)) & ((uvec3(1) << uvec3(11,11,10)) - 1u);\n}\n\n//16bit number packing \nuint encode2to1(uvec2 x)\n{\n    x = min(x, uvec2(1<<16) - 1u);\n    return x.y << 16 | x.x;\n}\n\nuvec2 decode1to2(uint x)\n{\n    return (uvec2(x) >> uvec2(0, 16)) & (uvec2(1<<16) - 1u);\n}\n\n\n//UINT TO FLOAT CONVERSION \n\n//uniform quantization\nuint uquant(float x, vec2 range, int bits) \n{\n    return uint( exp2(float(bits)) *((x) - range.x)/(range.y - range.x) );\n}\n\n//decode\nfloat ufloat(uint x, vec2 range, int bits) \n{\n    return float(x)*(range.y - range.x)/exp2(float(bits)) + range.x;\n}\n\n\n//signed logarithmic quantization\n//to emulate floating point numbers\nuint slogquant(float x, vec2 range, int bits) \n{\n    uint value = uint(exp2(float(bits - 1)) *(log2(abs(x)) - range.x)/(range.y - range.x));\n    uint sig = uint(exp2(float(bits - 1))*sign(x));  \n    return value + sig;\n}\n\n//decode\nfloat slogfloat(uint x, vec2 range, int bits) \n{\n    uint value = x&((1u<<(bits - 1)) - 1u);\n    uint sig = x>>(bits - 1);\n    return (float(sig)*2.0 - 1.0)*exp2(float(value)*(range.y - range.x)/exp2(float(bits - 1)) + range.x);\n}\n\n//unsigned logarithmic quantization\nuint logquant(float x, vec2 range, int bits) \n{\n    return uint( exp2(float(bits)) *(log2(abs(x)) - range.x)/(range.y - range.x) );\n}\n\n//decode\nfloat logfloat(uint x, vec2 range, int bits) \n{\n    return exp2(float(x)*(range.y - range.x)/exp2(float(bits)) + range.x);\n}\n\n//fibonacci uniform sphere quantization\n//to store normals and other vector stuff  \n\n\n//from https://www.shadertoy.com/view/lllXz4\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n#define M_PI 3.141592653\n\nvec2 fibonacci_lattice(int i, float N)\n{\n    return vec2((float(i)+0.5)/N, mod(float(i)/PHI, 1.)); \n}\n\nvec3 fibonacciDecode(int i, float N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*M_PI*xy.y, acos(2.*xy.x - 1.) - M_PI*0.5);\n    return vec3(cos(pt.x)*cos(pt.y), sin(pt.x)*cos(pt.y), sin(pt.y)); \n}\n\nvec2 fibonacciEncode( vec3 p, float n) \n{\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\n\n//final packing functions\n\nfloat PACK4U(vec4 x, vec2 range)\n{\n    //quantize\n    uvec4 quant = uvec4(uquant(x.x, range, 8),\n                        uquant(x.y, range, 8),\n                        uquant(x.z, range, 8),\n                        uquant(x.w, range, 8));\n    //pack\n    return uintBitsToFloat(encode4to1(quant));\n}\n\nvec4 UNPACK4U(float x, vec2 range)\n{\n    uvec4 unpack = decode1to4(floatBitsToUint(x));\n\n    //unquantize\n    return vec4(ufloat(unpack.x, range, 8),\n                ufloat(unpack.y, range, 8),\n                ufloat(unpack.z, range, 8),\n                ufloat(unpack.w, range, 8));\n}\n\nfloat PACK3U(vec3 x, vec2 range)\n{\n    //quantize\n    uvec3 quant = uvec3(uquant(x.x, range, 11),\n                        uquant(x.y, range, 11),\n                        uquant(x.z, range, 10));\n    //pack\n    return uintBitsToFloat(encode3to1(quant));\n}\n\nvec3 UNPACK3U(float x, vec2 range)\n{\n    uvec3 unpack = decode1to3(floatBitsToUint(x));\n\n    //unquantize\n    return vec3(ufloat(unpack.x, range, 11),\n                ufloat(unpack.y, range, 11),\n                ufloat(unpack.z, range, 10));\n}\n\nfloat PACK2U(vec2 x, vec2 range)\n{\n    //quantize\n    uvec2 quant = uvec2(uquant(x.x, range, 16),\n                        uquant(x.y, range, 16));\n    //pack\n    return uintBitsToFloat(encode2to1(quant));\n}\n\nvec2 UNPACK2U(float x, vec2 range)\n{\n    uvec2 unpack = decode1to2(floatBitsToUint(x));\n\n    //unquantize\n    return vec2(ufloat(unpack.x, range, 16),\n                ufloat(unpack.y, range, 16));\n}\n\n\nfloat PACK4LOG(vec4 x, vec2 range)\n{\n    //quantize\n    uvec4 quant = uvec4(logquant(x.x, range, 8),\n                        logquant(x.y, range, 8),\n                        logquant(x.z, range, 8),\n                        logquant(x.w, range, 8));\n    //pack\n    return uintBitsToFloat(encode4to1(quant));\n}\n\nvec4 UNPACK4LOG(float x, vec2 range)\n{\n    uvec4 unpack = decode1to4(floatBitsToUint(x));\n\n    //unquantize\n    return vec4(logfloat(unpack.x, range, 8),\n                logfloat(unpack.y, range, 8),\n                logfloat(unpack.z, range, 8),\n                logfloat(unpack.w, range, 8));\n}\n\nfloat PACK2LOG(vec2 x, vec2 range)\n{\n    //quantize\n    uvec2 quant = uvec2(logquant(x.x, range, 16),\n                        logquant(x.y, range, 16));\n    //pack\n    return uintBitsToFloat(encode2to1(quant));\n}\n\nvec2 UNPACK2LOG(float x, vec2 range)\n{\n    uvec2 unpack = decode1to2(floatBitsToUint(x));\n\n    //unquantize\n    return vec2(logfloat(unpack.x, range, 16),\n                logfloat(unpack.y, range, 16));\n}\n\n//signed log packing\nfloat PACK2SLOG(vec2 x, vec2 range)\n{\n    //quantize\n    uvec2 quant = uvec2(slogquant(x.x, range, 16),\n                        slogquant(x.y, range, 16));\n    //pack\n    return uintBitsToFloat(encode2to1(quant));\n}\n\nvec2 UNPACK2SLOG(float x, vec2 range)\n{\n    uvec2 unpack = decode1to2(floatBitsToUint(x));\n\n    //unquantize\n    return vec2(slogfloat(unpack.x, range, 16),\n                slogfloat(unpack.y, range, 16));\n}\n\n\n//FIBONACCI VECTOR PACKING \n//range here is length range\nfloat PACKVEC3(vec3 x, vec2 range)\n{\n    float L = length(x);\n    vec3 N = normalize(x);\n    \n    vec2 fe = fibonacciEncode(N, exp2(16.0));\n    //quantize\n    uvec2 quant = uvec2(fe.x, logquant(L, range, 16));\n    //pack\n    return uintBitsToFloat(encode2to1(quant));\n}\n\nvec3 UNPACKVEC3(float x, vec2 range)\n{\n    uvec2 unpack = decode1to2(floatBitsToUint(x));\n\n    //unquantize\n    vec3 N = fibonacciDecode(int(unpack.x), exp2(16.0));\n   \n    return N*logfloat(unpack.y, range, 16);\n}\n\n\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 d0 = texture(iChannel0, uv);\n    vec3 d1 = texture(iChannel1, uv).xyz;\n    vec2 d2 = texture(iChannel2, uv).xy;\n    vec4 d3 = texture(iChannel3, uv);\n    \n    vec4 tp = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 r = vec2(-5.0, 5.0);//from 2^-5 to 2^5\n    \n    if(iFrame%200> 10) //test reencoding stability\n    {\n        d0 = UNPACK4LOG(tp.x, r);\n        d1 = UNPACKVEC3(tp.y, r);\n        d2 = UNPACK2SLOG(tp.z, r);\n        d3 = UNPACK4LOG(tp.w, r);\n        d1 += 0.01; //test change\n    }\n   \n    fragColor = vec4(PACK4LOG(d0,r),PACKVEC3(d1,r),PACK2SLOG(d2,r),PACK4LOG(d3,r));\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BRH.jpg", "access": "api", "license": "mit", "functions": [[1111, 1111, 1168, 1218, 1912]], "test": "untested"}
{"id": "3ltBR8", "name": "Nefertiti Statue", "author": "oneshade", "description": "Another neural model.", "tags": ["3d", "raymarching", "sdf", "neuralnetwork", "siren", "statue", "nefertiti", "bust"], "likes": 4, "viewed": 162, "published": 3, "date": "1612227943", "time_retrieved": "2024-07-30T19:41:06.713070", "image_code": "// Nefertiti model\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 intersect = vec3(0.0);\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom; // 1st root\n        float t2 = -(root + b) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nfloat sdNefertiti(in vec3 p) {\n    if (length(p) > 1.2) return length(p) - 1.0;\n    p = p.yxz * vec3(1.0, 1.0, -1.0);\n    vec4 f0_0=sin(p.y*vec4(3.51,-3.13,-.40,.35)+p.z*vec4(-.86,-1.62,-3.98,3.57)+p.x*vec4(3.59,5.25,-3.42,4.02)+vec4(-8.49,-10.08,8.78,-6.04));\n    vec4 f0_1=sin(p.y*vec4(-1.63,-2.98,3.49,1.58)+p.z*vec4(.52,-4.85,-1.08,1.32)+p.x*vec4(.01,1.37,4.03,3.90)+vec4(-13.95,-7.99,4.53,-5.74));\n    vec4 f0_2=sin(p.y*vec4(-3.29,-1.02,3.65,4.56)+p.z*vec4(1.07,-.72,-1.34,-1.61)+p.x*vec4(-3.36,4.21,-4.95,-4.13)+vec4(-11.44,.60,-6.32,-2.63));\n    vec4 f0_3=sin(p.y*vec4(.58,-1.38,3.34,-1.44)+p.z*vec4(.05,3.23,-2.07,3.21)+p.x*vec4(3.88,-3.73,-1.75,-3.57)+vec4(-1.33,-11.77,-1.04,6.43));\n    vec4 f1_0=sin(mat4(.22,-.86,.36,-.54,-.07,-.24,-.06,-.15,.13,-.26,-.64,.19,.10,.03,.61,-.16)*f0_0+\n        mat4(.09,-.67,.43,.06,.04,.28,-.16,.14,.16,.74,-.06,.00,.27,.35,-.53,.29)*f0_1+\n        mat4(.66,.45,.54,-.43,.28,.24,-.25,.45,-.14,.19,-.08,-.00,-.22,.04,.13,-.13)*f0_2+\n        mat4(-.46,-.57,-.45,.26,.88,1.04,-.13,-.26,-.05,-.43,-.00,-.27,-.30,-1.25,-.02,-.62)*f0_3+\n        vec4(4.81,-.98,6.28,-.74))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(-.27,.42,-.36,.32,-.08,-.20,-.26,-.02,.29,.29,.20,-.02,-.20,-.35,-.30,.02)*f0_0+\n        mat4(1.66,-1.29,-.06,-.21,.05,.08,.15,-.06,.27,-.36,.28,-.34,-.15,-.54,.26,-.63)*f0_1+\n        mat4(.35,.21,-.38,-.52,-.08,-.10,.06,.66,.07,-.16,-.32,-.12,.27,-.65,-.07,-.34)*f0_2+\n        mat4(-.07,.78,.46,-.01,.54,-.32,-.94,.17,-.29,-.23,-.20,.06,-.45,-.15,.62,.10)*f0_3+\n        vec4(-1.89,1.74,-.76,-.96))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(-.87,-.24,1.15,-.29,-.15,.03,.38,-.11,.08,-.11,-.86,.64,-.49,.53,.66,-.60)*f0_0+\n        mat4(-.71,-1.29,-1.90,.82,-.04,.07,-.61,-.32,.46,1.63,-1.38,1.04,-.01,-.78,.18,.13)*f0_1+\n        mat4(-.07,1.04,-1.08,1.20,-.09,.41,-.85,-.72,-.32,-.48,-.20,.62,-.18,-.37,.04,.25)*f0_2+\n        mat4(.45,.78,-.19,.47,-.52,.66,-.36,.12,.28,.78,.43,.22,.38,-1.23,-.20,-.15)*f0_3+\n        vec4(.60,1.14,-6.51,-1.79))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(-.41,.70,.41,-.73,.14,.38,.27,.20,.11,.11,-.59,.07,-.18,-.25,.42,-.10)*f0_0+\n        mat4(-.28,-.63,1.12,-.41,-.34,-.43,.19,-.04,.15,-.73,-1.26,.16,.68,.39,-.15,-.22)*f0_1+\n        mat4(-.42,-.54,-.83,-.19,.04,.28,.99,.48,.13,.10,-.20,-.20,-.35,.17,-.08,-.18)*f0_2+\n        mat4(.10,.49,-.16,-.17,.48,1.18,-.31,.88,.20,.61,.04,.08,-.23,-.93,.22,-1.21)*f0_3+\n        vec4(3.90,-.94,-3.29,-1.35))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(.24,-.06,.61,-.51,-.19,.21,.23,-.06,1.15,.42,-.74,.79,-.63,-.64,.25,-.38)*f1_0+\n        mat4(.70,-.21,-1.04,2.07,.36,.20,-.16,.18,-.71,-.09,-.90,-.17,.97,.82,-.08,1.25)*f1_1+\n        mat4(-.15,-.55,.15,-.33,-.27,-.03,-.02,-.11,-.31,.22,-.10,-.01,-.15,-.20,-.03,.25)*f1_2+\n        mat4(.42,.42,-.54,.36,.36,.26,.07,.09,-.54,.20,.35,-.22,-.49,-.84,-.59,.14)*f1_3+\n        vec4(6.07,-2.37,6.11,-.52))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(-.62,.67,-1.20,1.23,-.16,-.56,.31,.00,1.21,.40,.54,-.50,-.89,-.76,-.26,.18)*f1_0+\n        mat4(1.84,-1.51,1.06,-2.01,-.23,-.11,-.24,-.28,.13,.16,.10,-.21,.59,-.08,.78,-1.07)*f1_1+\n        mat4(-.72,.58,-.23,.79,-.03,.32,.04,.39,-.20,.50,-.66,-.22,.20,.31,-.44,-.76)*f1_2+\n        mat4(1.10,-.44,1.30,-.81,-.31,-.63,.87,-.41,-.23,-.10,-.34,-.12,.03,.43,-.75,-1.37)*f1_3+\n        vec4(-.97,-5.92,-1.36,4.12))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.18,-.08,-1.15,.44,-.04,.34,.32,-.10,-.36,-.11,-.88,.12,.53,.39,-.17,.05)*f1_0+\n        mat4(-1.51,-.88,-1.64,-1.42,.17,.32,-.64,-.39,.35,.01,.05,.30,-.67,.28,1.26,-1.26)*f1_1+\n        mat4(.64,.74,-2.54,.82,.16,.09,-.81,.17,-.41,.80,-.17,-.11,-.56,-.00,-1.03,-.64)*f1_2+\n        mat4(-.67,.07,1.58,-1.46,-.35,.17,-.50,-.03,.28,.45,-.10,-.61,.85,-.02,.70,-1.91)*f1_3+\n        vec4(-2.05,-2.64,-6.35,.91))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.14,.63,-.10,-.10,.03,1.54,.35,-.15,.35,-1.13,-.32,.77,-.64,.85,-.27,-.90)*f1_0+\n        mat4(-.74,2.39,-1.83,.94,.27,-.73,-.13,.18,-.65,-1.80,.31,-.33,.57,-1.26,-.17,.36)*f1_1+\n        mat4(-.57,-2.96,.40,-.89,-.09,.41,-.20,-.64,-.00,-.05,.01,.26,.05,-.13,-.33,.43)*f1_2+\n        mat4(.74,1.25,-.18,.51,-.27,-.71,.35,-.53,.24,-.45,.16,.05,.50,-.22,.36,.63)*f1_3+\n        vec4(-1.12,3.49,-2.69,-4.95))/1.4+f1_3;\n    return dot(f2_0,vec4(-.08,-.10,.13,-.16))+\n        dot(f2_1,vec4(-.10,.07,-.07,-.04))+\n        dot(f2_2,vec4(-.13,-.06,-.02,-.03))+\n        dot(f2_3,vec4(-.11,.01,-.08,-.11))+\n        -0.175;\n}\n\nvec3 getStatueNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(sdNefertiti(p + e.xyy) - sdNefertiti(p - e.xyy),\n                          sdNefertiti(p + e.yxy) - sdNefertiti(p - e.yxy),\n                          sdNefertiti(p + e.yyx) - sdNefertiti(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(iTime, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec3 skyColor = mix(vec3(1.0, 0.6, 0.0), vec3(1.0, 1.0, 0.8), 0.5 + 0.5 * rd.y);\n\n    vec3 bSphereIntersect = IntersectSphere(ro, rd, 1.0);\n    if (bSphereIntersect.z > 0.5) {\n        float tMin = min(bSphereIntersect.x, bSphereIntersect.y);\n        float tMax = max(bSphereIntersect.x, bSphereIntersect.y);\n\n        vec3 p;\n        bool hitModel = false;\n        float t = tMin;\n        for (int i=0; i < 100; i++) {\n            p = ro + rd * t;\n            float d = sdNefertiti(p);\n            if (d < 0.001) {\n                hitModel = true;\n                break;\n            }\n\n            if (t > tMax) {\n                break;\n            }\n\n            t += d;\n        }\n\n        if (hitModel) {\n            vec3 n = getStatueNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            vec3 refr = refract(rd, n, 1.0003 / 1.5);\n\n            fragColor.rgb += vec3(0.7, 0.4, 0.0) + 0.1;\n\n            float lambertian = dot(n, l);\n            fragColor.rgb *= max(0.3, lambertian);\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += max(0.0, pow(specAngle, 16.0)) / 3.0;\n            }\n        }\n\n        else {\n            fragColor.rgb += skyColor;\n        }\n    }\n\n    else {\n        fragColor.rgb += skyColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 78, 78, 508], [510, 510, 540, 540, 4867], [4869, 4869, 4902, 4902, 5166], [5168, 5168, 5223, 5223, 7180]], "test": "untested"}
{"id": "tl3fzH", "name": "Random little fractal", "author": "mrange", "description": "License CC0: Random little fractal\nWeird but to me appealing results after a bit of tinkering with no clear goals\n\n", "tags": ["2d"], "likes": 13, "viewed": 484, "published": 3, "date": "1612220495", "time_retrieved": "2024-07-30T19:41:07.467054", "image_code": "// License CC0: Random little fractal\n// Weird but to me appealing results after a bit of tinkering with no clear goals\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define L2(x)           dot(x, x)\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\nconst float fixed_radius2 = 1.9;\nconst float min_radius2   = 0.5;\nconst float folding_limit = 1.0;\nconst float scale         = -2.8;\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    } else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvec3 polySoftMin3(vec3 a, vec3 b, vec3 k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0);\n  \n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n  const float k = 0.05;\n  // Soft clamp after suggestion from ollij\n  vec3 zz = sign(z)*polySoftMin3(abs(z), vec3(folding_limit), vec3(k));\n  // Hard clamp\n  // z = clamp(z, -folding_limit, folding_limit);\n  z = zz * 2.0 - z;\n}\n\nfloat sphere(vec3 p, float t) {\n  return length(p)-t;\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    float fd = 0.0;\n    for(int n = 0; n < 5; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.0;        \n        float r1 = sphere(z, 5.0);\n        float r2 = torus(z, vec2(8.0, 1));\n        r2 = abs(r2) - 0.25;\n        float r = n < 4 ? r2 : r1;        \n        float dd = r / abs(dr);\n        if (n < 3 || dd < fd) {\n          fd = dd;\n        }\n    }\n    return fd;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat weird(vec2 p) {\n  const float s = 0.55;\n  p /= s;\n  float rep = 20.0;\n  float ss = 0.05*6.0/rep;\n  vec3 p3 = vec3(p.x, p.y, PSIN(TIME*0.53));\n  p3.yz *= ROT(TIME*0.1);\n  float n = smoothKaleidoscope(p3.xy, ss, rep);\n  return mb(p3)*s;\n}\nfloat df(vec2 p) {\n  float d = weird(p);\n  return d;\n}\n\nvec3 color(vec2 p) {\n  float aa   = 2.0/RESOLUTION.y;\n  const float lw = 0.0235;\n  const float lh = 1.25;\n\n  const vec3 lp1 = vec3(0.5, lh, 0.5);\n  const vec3 lp2 = vec3(-0.5, lh, 0.5);\n\n  float d = df(p);\n\n  float b = -0.125;\n  float t = 10.0;\n\n  vec3 ro = vec3(0.0, t, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 rd = normalize(pp - ro);\n\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n\n  float bt = -(t-b)/rd.y;\n  \n  vec3 bp   = ro + bt*rd;\n  vec3 srd1 = normalize(lp1-bp);\n  vec3 srd2 = normalize(lp2-bp);\n  float bl21= L2(lp1-bp);\n  float bl22= L2(lp2-bp);\n\n  float st1= (0.0-b)/srd1.y;\n  float st2= (0.0-b)/srd2.y;\n  vec3 sp1 = bp + srd1*st1;\n  vec3 sp2 = bp + srd2*st1;\n\n  float sd1= df(sp1.xz);\n  float sd2= df(sp2.xz);\n\n  vec3 col  = vec3(0.0);\n  const float ss =15.0;\n  \n  col       += vec3(1.0)*(1.0-exp(-ss*(max((sd1+0.0*lw), 0.0))))/bl21;\n  col       += vec3(0.5)*(1.0-exp(-ss*(max((sd2+0.0*lw), 0.0))))/bl22;\n  col       = mix(col, vec3(1.0), smoothstep(-aa, aa, -d));  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = color(p);\n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3fzH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[644, 644, 692, 692, 962], [964, 964, 1007, 1007, 1095], [1097, 1097, 1142, 1142, 1370], [1372, 1372, 1403, 1403, 1427], [1429, 1429, 1458, 1458, 1523], [1525, 1525, 1543, 1543, 2032], [2034, 2034, 2056, 2056, 2100], [2102, 2102, 2123, 2123, 2168], [2170, 2170, 2215, 2215, 2369], [2371, 2371, 2432, 2432, 2645], [2647, 2647, 2668, 2668, 2889], [2890, 2890, 2908, 2908, 2944], [2946, 2946, 2966, 2966, 3970], [3972, 3972, 4009, 4009, 4262], [4264, 4264, 4319, 4319, 4509]], "test": "untested"}
{"id": "ttcfRH", "name": "Something like the Night Sky", "author": "Zi7ar21", "description": "Not Physically accurate, but it sure is pretty. See the code for details.", "tags": ["noise", "fbm", "sky", "night"], "likes": 32, "viewed": 1441, "published": 3, "date": "1612215306", "time_retrieved": "2024-07-30T19:41:08.218046", "image_code": "// Something like the Night Sky by Zi7ar21 --- February 1st, 2020\n// Updated February 1st, 17:15 Mountain Time\n\n// If you didn't find this on Shadertoy, the original can be found at:\n// https://www.shadertoy.com/view/ttcfRH\n\n/*\nThis is a somewhat Night-Sky like scene. It is rendered in 2D, and is NOT physically accurate.\nI didn't take into account proper gas colors, gas distribution, etc.\nAlso the stars have a Blackbody pallete but the probability of a random sampled star's\ncolor and luminance is not based on something accurate like Hertzsprung-Russell.\n*/\n\n// Hashes https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 pos) {\n\tvec3 p3  = fract(vec3(pos.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nfloat noise(vec2 n) {\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\n// Atmospheric Distortion \"Twinkling\"\nfloat noise(vec2 coord, float n) {\n    float componenta = hash13(vec3(coord, round(n - 0.5)));\n    float componentb = hash13(vec3(coord, round(n + 0.5)));\n    float componentc = mix(componenta, componentb, mod(n, 1.0));\n    return componentc;\n}\n\n// FBM Terrain Line\nfloat noise(float coord) {\n    float componenta = hash11(round(coord - 0.5));\n    float componentb = hash11(round(coord + 0.5));\n    return mix(componenta, componentb, mod(coord, 1.0));\n}\n\n// Color Offset, as Reccomended by user \"elenzil\"\n// https://www.shadertoy.com/user/elenzil\nvec3 colorednoise(vec2 coord, float n) {\n    vec3 componenta = hash33(vec3(coord, round(n - 0.5)));\n    vec3 componentb = hash33(vec3(coord, round(n + 0.5)));\n    vec3 componentc = mix(componenta, componentb, mod(n, 1.0));\n    return componentc;\n}\n\n// FBM https://www.shadertoy.com/view/3dSBRh\n#define octaves 8\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.4;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tv += a * noise(x);\n\t\tx  = x * 2.0;\n\t\ta *= 0.6;\n\t}\n\n\treturn v;\n}\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tv += a * noise(x);\n\t\tx  = x * 2.0;\n\t\ta *= 0.5;\n\t}\n\n\treturn v;\n}\n\n// Blackbody Coloration (Made into a Function by LoicVDB)\n// https://www.shadertoy.com/view/4tdGWM\nvec3 blackbody(float temperature) {\n    vec3 O = vec3(0.0);\n\n    for(float i = 0.0; i < 3.0; i += 0.1) {\n        float f = 1.0 + 0.5 * i;\n\n        O[int(i)] += 10.0 * (f * f * f) / (exp((19e3 * f / temperature)) - 1.0);\n    }\n\n    return O;\n}\n\n// Stars\nvec3 stars(vec2 coord) {\n    float luminance = max(0.0, (hash12(coord) - 0.985));\n    float temperature = (hash12(coord + iResolution.xy) * 6000.0) + 4000.0;\n    vec3 colorshift = normalize(colorednoise(coord, float(iTime * 16.0)));\n    return (luminance * noise(coord, iTime * 4.0)) * blackbody(temperature) * 4.0 * (colorshift * 0.5 + 1.0);\n}\n\n// Galaxy\nfloat galaxygas(vec2 coord) {\n    return max(0.0, fbm((coord * 4.0) + fbm(coord * 4.0)) - 0.35);\n}\n\nfloat galaxydust(vec2 coord) {\n    return max(0.0, fbm((coord * 2.0) + fbm(coord * 2.0) + vec2(4.0, 4.0)) - 0.5);\n}\n\n// Nebula\nfloat nebula(vec2 coord) {\n    float gas0 = max(0.0, fbm((coord * 2.0) + fbm(coord * 2.0) + vec2(4.0, 4.0)) - length(coord));\n    float gas1 = max(0.0, fbm((coord * 4.0) + fbm(coord * 2.0) + vec2(4.0, 4.0)) - length(coord * 1.01));\n    return max(0.0, gas0 - gas1);\n}\n\n// Main Image\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    if(fbm((uv.x + 4.0) * 4.0) > (uv.y + 0.5) * 4.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        return;\n    }\n\n    vec3 star = stars(fragCoord);\n    float gas = galaxygas(uv);\n    vec3 dust = galaxydust(uv) * vec3(0.500, 0.400, 0.300);\n    vec3 nebulae = nebula(uv)  * vec3(0.600, 0.500, 0.750);\n    vec3 color = star + mix(vec3(gas), dust * 0.5, 0.75) + nebulae;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[613, 613, 636, 636, 722], [724, 724, 748, 748, 868], [870, 870, 893, 893, 996], [998, 998, 1020, 1020, 1151], [1153, 1153, 1174, 1174, 1366], [1368, 1406, 1440, 1440, 1650], [1652, 1672, 1698, 1698, 1859], [1861, 1953, 1993, 1993, 2200], [2265, 2265, 2284, 2284, 2418], [2420, 2420, 2440, 2440, 2574], [2576, 2675, 2710, 2710, 2917], [2919, 2928, 2952, 2952, 3272], [3274, 3284, 3313, 3313, 3382], [3384, 3384, 3414, 3414, 3499], [3501, 3511, 3537, 3537, 3778], [3780, 3794, 3845, 3845, 4353]], "test": "untested"}
{"id": "tlcBRH", "name": "modulo_n_001", "author": "catafest", "description": "Given two positive numbers a and n, a modulo n (abbreviated as a mod n) is the remainder of the Euclidean division of a by n, where a is the dividend and n is the divisor. ", "tags": ["math", "division", "turcoaz"], "likes": 1, "viewed": 359, "published": 3, "date": "1612212510", "time_retrieved": "2024-07-30T19:41:08.969038", "image_code": "// modulo with tree colors \nvoid mainImage(out vec4 O, vec2 U) {\n    U += U - iResolution.xy;\n    O = vec4(\n    int(iTime - atan(U.y, U.x)) / ivec2(1,7) % 6,\n    int(iTime - atan(U.y, U.x)) / ivec2(0,2) % 3\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 64, 64, 215]], "test": "untested"}
{"id": "3tcfzH", "name": "Simple GGX Implementation", "author": "Zi7ar21", "description": "I made a simple implementation of GGX.", "tags": ["raymarching", "ray", "raymarch", "shadow", "raymarcher", "specular", "metal", "hard", "ggx", "metallic", "hardshadow"], "likes": 1, "viewed": 587, "published": 3, "date": "1612205104", "time_retrieved": "2024-07-30T19:41:09.719033", "image_code": "// Simple GGX Implementation by Zi7ar21 --- February 1st, 2021\n// Updated February 1st, 2021 11:45 Mountain Time\n\n// If you didn't find this on Shadertoy, the original (and possibly updated version) can be found at: https://www.shadertoy.com/view/3tcfzH\n\n// Sensitivity of Mouse Controls\n#define mousesensitivity 4.0\n// Camera Field of View\n#define camfov 1.0\n// Maximum Number of Ray-Marches\n#define maxmarches 1024\n// Collision Distance\n#define collisiondist 1e-4\n// Scene Size\n#define scenesize 7.75\n// Light Direction\n#define lightdir normalize(vec3(1.0, 1.0, -0.5))\n// FBM Noise Octaves\n#define NUM_OCTAVES 8\n\n// Pi (Quadruple Precision Float Future-Proof)\n#define pi 3.1415926535897932384626433832795028\n\n// Test Object SDF\nfloat test(vec3 raypos){\n    float sphere0 = length(raypos+vec3( 0.0, -0.5, 0.0))-0.5;\n    float sphere1 = length(raypos+vec3(-0.5, -0.5, 0.0))-0.5;\n    float sphere2 = length(raypos+vec3( 0.0, -0.5, 0.0))-0.45;\n    float sphere3 = length(raypos+vec3(-0.5, -0.5, 0.0))-0.4;\n    float sphere4 = length(raypos+vec3( 0.0, -0.5, 0.0))-0.35;\n    return min(sphere4, max(-sphere3, min(sphere2, max(-sphere1, sphere0))));\n}\n\n// Ground SDF\nfloat plane(vec3 raypos){\n    return raypos.y;\n}\n\n// Scene Distance Estimators\nfloat DE(vec3 raypos){\n    float DE0 = test(raypos);\n    float DE1 = plane(raypos);\n    return min(DE0, DE1);\n}\n\n// Lookup Material ID\nint getmat(vec3 raypos){\n    float DE0 = test(raypos);\n    float DE1 = plane(raypos);\n    float minimum = min(DE0, DE1);\n    if(minimum == DE0){return 0;}\n    if(minimum == DE1){return 1;}\n    return -1;\n}\n\n// FBM Noise https://www.shadertoy.com/view/3dSBRh\n// Hash https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx)*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nfloat noise(vec2 n){\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\nfloat fbm(vec2 x){\n\tfloat v = 0.0;\n\tfloat a = 0.4;\n\tfor (int i = 0; i < NUM_OCTAVES; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.6;\n\t}\n\treturn v;\n}\n\n// Material Properties (Color, Specular)\nvec4 matprop(int material, vec3 raypos){\n    // Sphere Object\n    if(material == 0){\n        return vec4(vec3(0.75, 0.8, 0.95), 0.45);\n    }\n    // Ground\n    if(material == 1){\n        return vec4((vec3(0.95, 0.8, 0.75)/length(raypos))-0.125, clamp((fbm(raypos.xz*2.0)/1.0), 0.0, 1.0));\n    }\n    // Non-Defined Material\n    return vec4(0.0);\n}\n\n// Forwards and Central Differences\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 raypos){\n    vec2 diff = vec2(collisiondist, 0.0);\n    return normalize(vec3(DE(raypos+diff.xyy)-DE(raypos-diff.xyy),\n                          DE(raypos+diff.yxy)-DE(raypos-diff.yxy),\n                          DE(raypos+diff.yyx)-DE(raypos-diff.yyx)));\n}\n\n// https://learnopengl.com/PBR/Theory\nfloat GGX(vec3 normal, vec3 highlightdir, float a){\n    float a2     = a*a;\n    float NdotH  = max(dot(normal, highlightdir), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom    = a2;\n    float denom  = (NdotH2*(a2-1.0)+1.0);\n          denom  = pi*denom*denom;\n    return nom/denom;\n}\n\n// Shading\nvec3 shade(vec3 reflection, float specularity){\n    return vec3(GGX(reflection, lightdir, specularity));\n}\n\n// Ray-Marching\nvec3 raymarch(vec3 raydir, vec3 rayori){\n    // Define our distance estimate\n    float distest;\n\n    // Define our ray position\n    vec3 raypos = rayori;\n\n    // Define the closest point to the Sscene (Not Colliding)\n    vec3 closestpos = raypos;\n\n    // Define our output color\n    vec3 outCol = vec3(1.0);\n\n    // Define our material properites\n    vec4 matprops;\n\n    // Start the Ray-Marching\n    for(int i = 0; i < maxmarches; i++){\n        // Check the distance to the scene\n        distest = DE(raypos);\n        // If the ray is not colliding then it is the nearest non-colliding point so far\n        if(distest > collisiondist){closestpos = raypos;}\n        // If the ray is colliding...\n        if(distest < collisiondist){\n            // Find the properties of our material\n            matprops = matprop(getmat(raypos), raypos);\n            // Find the normal of where we collided\n            vec3 normals = normal(raypos);\n            // Multiply the output color by the material color\n            outCol *= matprops.rgb;\n            // Return our shaded color\n            return shade(reflect(raydir, normals), matprops.w)*outCol;\n        }\n        // If we didn't collide, March the Ray\n        raypos += raydir*distest;\n        // If the ray flies off to who knows where, we yeet it\n        if(length(raypos) > scenesize){break;}\n    }\n    // Our ray never hit anything so we just return 0.0\n    return vec3(0.0);\n}\n\n// Main Function\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    // Sceen UV Coorinates Centered on [0.0, 0.0]\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Mouse\n    vec2 mouse = ((iMouse.xy/iResolution.xy)-0.5)*pi*mousesensitivity;\n    //vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n\n    // Rotation Matrix\n    mat3 rotmat = mat3(cos(mouse.x), 0.0, -sin(mouse.x), 0.0, 1.0, 0.0, sin(mouse.x), 0.0, cos(mouse.x));\n\n    // Direction of the Ray\n    vec3 raydir = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Perform Ray-Marching\n    vec3 raymarched = raymarch(raydir, vec3(-sin(mouse.x)*2.0, 0.5, -cos(mouse.x)*2.0));\n\n    // Gamma Correction\n    vec3 color = pow(raymarched, vec3(1.0/2.2));\n\n    // Output the Image\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 730, 754, 754, 1146], [1148, 1162, 1187, 1187, 1210], [1212, 1241, 1263, 1263, 1352], [1354, 1376, 1400, 1400, 1581], [1583, 1680, 1701, 1701, 1810], [1812, 1812, 1832, 1832, 2024], [2026, 2026, 2044, 2044, 2176], [2178, 2219, 2259, 2280, 2564], [2566, 2648, 2673, 2673, 2920], [2922, 2960, 3011, 3011, 3247], [3249, 3260, 3307, 3307, 3366], [3368, 3384, 3424, 3460, 4814], [4816, 4833, 4884, 4934, 5640]], "test": "untested"}
{"id": "Wl3fzH", "name": "Trig Calculator", "author": "eiffie", "description": "re-up When Squatterman returns to reset technology while you're hiding behind a rock finding religion I'll be getting a jump start on building the new world with my manual trig calculator. This also calculates pi and the golden ratio.", "tags": ["trig"], "likes": 12, "viewed": 407, "published": 3, "date": "1612194819", "time_retrieved": "2024-07-30T19:41:10.551806", "image_code": "//trig calc by eiffie\n//does all trig functions, chord lengths, some square roots\n//pi and the golden ratio but can you get Euler's constants?\n#define maxDepth 6.\nconst int MarchSteps=48,ShadowSteps=24; \nconst float FudgeFactor=1.0,shadows=0.6,contrast=0.6; \nconst float spec=1.0,specExp=64.0,HitDistance=0.001;//,maxDepth=10.0; \nconst vec3 dirLight=vec3(0.577,0.577,-0.577),colLight=vec3(1.0,0.9,0.7); \nbool bColoring=false; \nfloat px; \nmat2 rmx; \nvec3 pg,pg2,dc; \n#define tex iChannel0 \n#define size iResolution \n#define time iTime \nvec3 faketexture(vec2 v){return vec3(.8,.4+v.x*.1,.2+v.y*.2)+0.1*sin(v.x*120.+sin((v.y-v.x*2.1)*11.));}\nfloat RBox(in vec3 z, in vec4 r){return length(max(abs(z)-r.xyz,0.0))-r.w;} \nfloat RCyl(in vec3 z, in vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;} \nfloat DE(in vec3 z){//thingy \n float dT=RBox(z-vec3(-1.0,-1.3,3.0),vec4(5.0,0.245,3.1,0.05)); \n float dW=RCyl(z-vec3(-px,0.0,0.25),vec3(0.95,0.245,0.05)); \n float dA=RCyl((z-vec3(-px,-0.45,-0.1)).xzy,vec3(0.0,0.45,0.025)); \n dA=min(dA,RCyl(z-vec3(-px,0.0,0.0),vec3(0.0,0.05,0.025))); \n float dA2=RBox(z-pg-vec3(0.0,-1.0,-0.15),vec4(0.05,1.0,-0.04,0.05)); \n float dA3=RBox(z-pg2-vec3(0.0,-1.0,-0.2),vec4(0.05,1.0,-0.04,0.05)); \n float dP=RCyl(z-pg,vec3(0.0,0.15,0.015)); \n dP=min(dP,RCyl(z-pg2,vec3(0.0,0.2,0.015))); \n float dS=min(dP,min(min(dT,dW),min(dA,min(dA2,dA3)))); \n if(bColoring){//since all the pixels get colored at once \n  bColoring=false;\n  if(dS==dW){//wheel \n   vec3 p=z-vec3(-px,0.0,0.0); \n   p.xy=p.xy*rmx; \n   dc=faketexture(p.xy+vec2(0.0,sin(p.y+p.z*(10.0-p.x*3.0))*0.02)).rgb; \n   dc=mix(vec3(0.0),dc,step(0.01,abs(length(p.xy+vec2(0.0,0.7))-0.03))); \n   float r=length(p.xy); \n   if(r>0.75 && r<0.975){ \n    float d=atan(p.y,p.x)*0.318; \n    dc=mix(vec3(0.0),dc,step(0.0075,mod(d,0.25))); \n    if(r>0.85){ \n     dc=mix(vec3(0.0),dc,step(0.005,mod(d,0.02777777))); \n    } \n   } \n  }else if(dS==dA)dc=vec3(1.0,0.0,0.0);//angle marker \n  else if(dS==dA2 || dS==dA3 || dS==dT){//sine and cosine rulers \n   dc=vec3(0.75);vec3 p2=pg;\n   if(dS==dT){dc=z.z<-0.13?vec3(0):vec3(.4,.7,.4);p2=vec3(0);z.xy=z.zx-vec2(0,1);}\n   if(dS==dA3){p2=pg2;dc=vec3(0.9,0.6,0.3);} \n   vec3 p=z-p2-vec3(0.0,-1.0,-0.15); \n   dc=mix(vec3(0.0),dc,step(0.01,abs(length(p.xy)-0.03))); \n   if(p.x<0.0){ \n    float d=p.y; \n    dc=mix(vec3(0.0),dc,step(0.01,mod(d,0.1))); \n    if(p.x<-0.05){ \n     dc=mix(vec3(0.0),dc,step(0.01,mod(d,0.025))); \n    } \n   } \n  }else dc=vec3(0.25);//pegs \n } \n return dS; \n} \n \nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) \n{ \n float t=mint*10.0,d=1.0,fStep=0.0; \n for( int i=0; i<ShadowSteps; i++ ){ \n  if(t>maxt || d<0.001)continue; \n  t+=d=DE(ro+rd*t); \n  fStep+=1.0; \n } \n if(d<0.01)return 0.0; \n return 1.0-(fStep-d*k/t)/float(ShadowSteps);//no rationale, just seems to work \n} \n \nvec3 scene( vec3 ro, vec3 rd ) \n{// find color of scene \n vec3 col=vec3(0.4+rd.y*0.5); \n float t=0.0,d=10.0; \n for(int i=0;i<MarchSteps;i++){ \n  if(t>maxDepth || d<HitDistance)continue; \n  t+=d=DE(ro+rd*t)*FudgeFactor; \n } \n if(d<0.01){ \n  bColoring=true; \n  t+=d=DE(ro+rd*t); \n  ro+=rd*(t-HitDistance); \n  const vec2 ve=vec2(0.0002,0.0); \n  vec3 nor=normalize(vec3(-DE(ro-ve.xyy)+DE(ro+ve.xyy), \n   -DE(ro-ve.yxy)+DE(ro+ve.yxy),-DE(ro-ve.yyx)+DE(ro+ve.yyx))); \n  float dif=max(0.0, dot(dirLight, nor)),shad=0.0; \n  if(shadows>0.0 && dif>0.0)shad=softshadow(ro,dirLight,HitDistance,maxDepth,12.0); \n  col=dc*(1.0-shadows+shad*shadows)*(1.0-contrast+dif*contrast) \n   +colLight*shad*spec*pow(max(0.0,dot(rd,reflect(dirLight,nor))),specExp); \n } \n return clamp(col,0.0,1.0); \n}   \n \nmat3 lookat(vec3 fw,vec3 up){ \n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw); \n} \n \nvoid mainImage(out vec4 O, in vec2 U) { \n px=5.0*iMouse.x/size.x; \n float f=0.0,cx=cos(px-f),sx=sin(px-f); \n rmx=mat2(cx,sx,-sx,cx); \n pg=vec3(rmx*vec2(-1.0,0.0),0.0)-vec3(px,0.0,0.0); \n pg2=vec3(rmx*vec2(0.0,-1.0),0.0)-vec3(px,0.0,0.0); \n vec3 clr=vec3(0.0); \n vec3 ro=vec3(-2.0,0.5,-3.0); \n mat3 rotCam=lookat(vec3(-px,-0.5,0.0)-ro,vec3(0.0,1.0,0.0)); \n vec3 rd=rotCam*normalize(vec3((2.0*U.xy-size.xy)/size.y,2.0)); \n O = vec4(scene(ro,rd),1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3fzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 535, 560, 560, 638], [639, 639, 672, 672, 714], [716, 716, 749, 749, 814], [816, 816, 836, 845, 2509], [2513, 2513, 2591, 2591, 2848], [2852, 2852, 2885, 2908, 3627], [3633, 3633, 3662, 3662, 3760], [3764, 3764, 3803, 3803, 4215]], "test": "untested"}
{"id": "3lcBzH", "name": "abyss in your eye ", "author": "YitingLiu", "description": "Making an eye using fbm", "tags": ["noise", "mix", "fbm", "eye", "color", "random", "galaxy", "smoothstep", "frequency", "amplitude", "similarity", "octaves"], "likes": 5, "viewed": 382, "published": 3, "date": "1612193541", "time_retrieved": "2024-07-30T19:41:11.299806", "image_code": "// followed the tutorial here https://youtu.be/emjuqqyq_qc\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// for fbm, increase f, decrease amplitude \n/****\nfloat fbm(vec2 p){\n    float f=0.;\n    f+= 0.5000*noise(p); p*=2.02;\n    f+=0.2500*noise(p); p*=2.03;\n    f+=0.1250*noise(p); p*2.01;\n    f+=0.0625*noise(p); p*=2.04;\n    f/= 0.9375;\n    return f; \n\n}\n***/\n\n// code from https://thebookofshaders.com/13/\n#define OCTAVES 4\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 p = -1.+2.*uv;\n    \n    p.x-=0.75;\n    float f = fbm(2.*p);\n    \n    float r = sqrt(dot(p,p));\n    float a = atan(p.y,p.x);\n    vec3 col = vec3(1.);\n    \n    float ss = 0.5+0.5*sin(iTime);\n    float anim = 1.+0.5*ss*clamp(1.-r,0.,1.);;\n    r*=anim;\n    \n    if(r<0.8){\n    \n    col = vec3(0.,0.,0.8);\n    \n    float f=fbm(p);\n    col = mix(col, vec3(0.2,0.5,0.4),f);\n   \n    \n    a+=0.08*fbm(32.*p);\n    \n    f=fbm(vec2(5.*r,20.*a));\n    col= mix(col, vec3(1.),f);\n    \n    f= smoothstep (0.2,.8,fbm(vec2(4.*r,a*18.)));\n    col *=0.5-f;\n    \n    f=1. - smoothstep(0.2,clamp(r,0.,0.5),r);\n    col*=1.-0.5*f;\n    \n    f=1.-smoothstep(0.2,0.5,r);\n    col += mix(col, vec3(sin(iTime),0.6,0.2),f);\n\n    \n    f=1.-smoothstep(0.2,0.25,r);\n    col*=1.-f;\n     \n    //adding reflections to the eye  \n    f = 1.-smoothstep(0.,0.5,length(p- vec2(0.3,0.3)*rotate2d(3.14*iTime*0.3) ));\n    col +=vec3(sin(iTime),0.9,0.5)*f*0.6;\n    \n    f=smoothstep(0.6,0.8,r);\n    col = mix(col, vec3(0.9),r);\n     \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 87, 87, 194], [196, 196, 224, 224, 310], [312, 312, 338, 338, 718], [1042, 1042, 1066, 1088, 1342], [1345, 1345, 1402, 1402, 2518]], "test": "untested"}
{"id": "3tcBzH", "name": "Perlin noise fire shader", "author": "trinketMage", "description": "Perlin Noise generation, fire shader after @febucci\nhttps://www.febucci.com/2019/05/fire-shader/\nAvailable on Cineshader here: https://cineshader.com/view/3tcBzH", "tags": ["perlinnoise", "fire", "cineshader"], "likes": 39, "viewed": 12104, "published": 3, "date": "1612193263", "time_retrieved": "2024-07-30T19:41:12.136569", "image_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hermite(float t)\n{\n  return t * t * (3.0 - 2.0 * t);\n}\n\nfloat noise(vec2 co, float frequency)\n{\n  vec2 v = vec2(co.x * frequency, co.y * frequency);\n\n  float ix1 = floor(v.x);\n  float iy1 = floor(v.y);\n  float ix2 = floor(v.x + 1.0);\n  float iy2 = floor(v.y + 1.0);\n\n  float fx = hermite(fract(v.x));\n  float fy = hermite(fract(v.y));\n\n  float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);\n  float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);\n\n  return mix(fade1, fade2, fy);\n}\n\nfloat pnoise(vec2 co, float freq, int steps, float persistence)\n{\n  float value = 0.0;\n  float ampl = 1.0;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    sum += ampl;\n    value += noise(co, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float gradient = 1.0 - uv.y;\n    float gradientStep = 0.2;\n    \n    vec2 pos = fragCoord.xy / iResolution.x;\n    pos.y -= iTime * 0.3125;\n    \n    vec4 brighterColor = vec4(1.0, 0.65, 0.1, 0.25);\n    vec4 darkerColor = vec4(1.0, 0.0, 0.15, 0.0625);\n    vec4 middleColor = mix(brighterColor, darkerColor, 0.5);\n\n    float noiseTexel = pnoise(pos, 10.0, 5, 0.5);\n    \n    float firstStep = smoothstep(0.0, noiseTexel, gradient);\n    float darkerColorStep = smoothstep(0.0, noiseTexel, gradient - gradientStep);\n    float darkerColorPath = firstStep - darkerColorStep;\n    vec4 color = mix(brighterColor, darkerColor, darkerColorPath);\n\n    float middleColorStep = smoothstep(0.0, noiseTexel, gradient - 0.2 * 2.0);\n    \n    color = mix(color, middleColor, darkerColorStep - middleColorStep);\n    color = mix(vec4(0.0), color, firstStep);\n\tfragColor = color;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Fire shader\",\n\t\"description\": \"Fire shader after @febucci\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 118, 118, 154], [156, 156, 195, 195, 608], [610, 610, 675, 675, 894], [896, 896, 953, 953, 1857]], "test": "untested"}
{"id": "3lcfR8", "name": "Ellipse - gradient 2D", "author": "iq", "description": "Signed distance and gradient to an ellipse. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "ellipse"], "likes": 12, "viewed": 756, "published": 3, "date": "1612186680", "time_retrieved": "2024-07-30T19:41:12.956377", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to an ellipse. Probably\n// faster than central differences or automatic\n// differentiation/dual numbers.\n//\n// It uses 4 iterations of Newton's root solver, but could need more for\n// very eccentric ellipses (see line 46). For an analytic solver see\n// https://www.shadertoy.com/view/4sS3zz\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Ellipse:            https://www.shadertoy.com/view/3lcfR8\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgEllipse( vec2 p, in vec2 ab )\n{\n    // symmetry\n    vec2 sp = sign(p);\n\tp = abs( p );\n    \n    // determine in/out and initial value\n    bool s = dot(p/ab,p/ab)>1.0;\n\tfloat w = atan(p.y*ab.x, p.x*ab.y);\n    if(!s) w=(ab.x*(p.x-ab.x)<ab.y*(p.y-ab.y))? 1.570796327 : 0.0;\n    \n    // Newton root solver\n    for( int i=0; i<4; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    vec2  q = ab*vec2(cos(w),sin(w));\n\n    // compute distance and gradient (everything above\n    // could probably be replaced by something better)\n    float d = length(p-q);\n    return vec3( d, sp*(p-q)/d ) * (s?1.0:-1.0);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        vec2 ab = 0.7 + vec2(0.4,0.2)*cos(iTime*0.52+vec2(1,2));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgEllipse(p,ab);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        //g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n        \n        // draw gradient discontinuty\n        if( false )\n        {\n            float f2 = ab.x*ab.x - ab.y*ab.y;\n            if( ab.x>ab.y )\n            {\n                float foc = f2/ab.x;\n                p.x -= clamp(p.x,-foc,foc);\n            }\n            else\n            {\n                float foc = -f2/ab.y;\n                p.y -= clamp(p.y,-foc,foc);\n            }\n            d = length(p);\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.005,0.010,abs(d)) );\n        }\n    \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcfR8.jpg", "access": "api", "license": "mit", "functions": [[2295, 2390, 2429, 2445, 3131]], "test": "untested"}
{"id": "Wl3BRH", "name": "Simple Menger Hall", "author": "butadiene", "description": "menger hall", "tags": ["raymarching", "fractal"], "likes": 4, "viewed": 324, "published": 3, "date": "1612185430", "time_retrieved": "2024-07-30T19:41:13.709364", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nprecision mediump float;\n\nuniform float time;\nuniform vec2 resolution;\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat cube2(vec2 p,vec2 s){\n    vec2 q = abs(p);\n    vec2 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(m.x,m.y);\n}\n\nfloat cube3(vec3 p,vec2 s){\n    return min(min(cube2(p.xy,s),cube2(p.yz,s)),cube2(p.zx,s));\n}\n\nvec2 pmod(vec2 p,float n){\n  float np = 3.141592*2./n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\n\nfloat menger(vec3 p){\n  \n  //p.y += 0.3;\n    float d0 = cube(p,vec3(10000.));\n    \n    float k =1.8;\n        \n    float s = 1.0/3.;\n    for(int i = 0;i<6;i++){\n     \n        \n        vec3 sp = mod(p-vec3(k/2.),k)-0.5*k;\n        \n        float d1 = cube3(sp,vec2(s));\n        \n        d0 = max(d0,-d1);\n        \n          k /= 3.;\n        s /= 3.;\n        \n    }\n    \n    return d0;\n}\n\nfloat dist(vec3 p){\n    p.y -= 0.21;\n    p.z -= 0.2*iTime;\n    p.xy  = pmod(p.xy,8.);\n    p.x -= -0.1;\n    float k = 0.4;\n    //p = mod(p,k)-0.5*k;\n    float d = menger(p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n     vec2 p = (uv-0.5)*2.0;\n    \n    p.y *= iResolution.y/iResolution.x;\n\n    vec3 ro = vec3(0,0,0);\n    \n    vec3 rd = normalize(vec3(p,0.5)-ro);\n    rd.yz *= rot(0.4);\n    float d,t =0.;\n    float ac = 0.;\n    for(int i = 0;i<66;i++){\n        d = dist(ro+rd*t);\n        t += d;\n        ac += 0.8*exp(-0.2*t);\n        if(d<0.0000001)break;\n    }\n\n    vec3 col = vec3(0);\n    \n    col = vec3(0.7,0.4,0.3)*ac*0.1;\n    \n    col = pow(col,vec3(1.4));\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BRH.jpg", "access": "api", "license": "mit", "functions": [[187, 187, 205, 205, 252], [254, 254, 280, 280, 383], [385, 385, 412, 412, 506], [508, 508, 535, 535, 601], [603, 603, 629, 629, 757], [759, 759, 780, 799, 1142], [1144, 1144, 1163, 1163, 1332], [1334, 1334, 1391, 1441, 1994]], "test": "untested"}
{"id": "tttBzr", "name": "cyclic cellular automata shader", "author": "zzggbb", "description": "http://psoup.math.wisc.edu/mcell/rullex_cycl.html\n\npress the 'r' key to restart the cellular automata", "tags": ["automata", "cellular"], "likes": 4, "viewed": 354, "published": 3, "date": "1612175878", "time_retrieved": "2024-07-30T19:41:14.460356", "image_code": "void mainImage(out vec4 color, in vec2 pixel){\n    color = vec4(texelFetch(GRID, ivec2(pixel), 0));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031 + fract(iTime));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 fetch(vec2 center, int offx, int offy) {\n    ivec2 new = ivec2(center) + ivec2(offx, offy);\n    ivec2 MAX = ivec2(iResolution) - 1;\n    if (new.x > MAX.x) new.x = new.x - MAX.x;\n    if (new.y > MAX.y) new.y = new.y - MAX.y;\n    if (new.x < 0) new.x = MAX.x + new.x;\n    if (new.y < 0) new.y = MAX.y + new.y;\n    return texelFetch(GRID, new, 0);\n}\n\nvec3 get_color(float index) {\n    float t = index / (N_COLORS - 1.0);\n    #if COLOR_MODE == 1\n        return mix(COLOR_A, COLOR_B, t);\n    #else\n        return cos_gradient(t);\n    #endif\n}\n\nvec4 next_state(vec4 state) {\n    float index = state.a + 1.0;\n    if (index > N_COLORS) index = 1.0;\n    return vec4(get_color(index-1.0), index);\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nint von_neumann_search(vec2 p, int range, float state) {\n    /*\n    Gets the number of cells that are in state 'state' within the \n    extended von-neumann neighborhood (specified by range) of point 'p'.\n    */\n    int matching_neighbors = 0;\n    for (int i=-range; i<range+1; i++) {\n        int Y = abs(abs(i) - range);\n        for (int j=-Y; j<Y+1; j++) {\n            if (fetch(p, i, j).a == state)\n                matching_neighbors++;\n        }\n    }\n    return matching_neighbors;\n}\n\nint moore_search(vec2 p, int range, float state) {\n    /*\n    Gets the number of cells that are in state 'state' within the\n    extended moore neighborhood (specified by range) of point 'p'.\n    */\n    int matching_neighbors = 0;\n    for (int i=-range; i<range+1; i++) \n        for (int j=-range; j<range+1; j++)\n            if (fetch(p, i, j).a == state)\n                matching_neighbors++;\n                \n    return matching_neighbors;\n}\n\nint search(vec2 p, int range, float state) {\n    #if NEIGHBORHOOD_MODE == 1\n        return von_neumann_search(p, range, state);\n    #else\n        return moore_search(p, range, state);\n    #endif\n}\n\nfloat majority_search(vec2 p, int range) {\n    /*\n    Gets the index of the color with the majority in the neighborhood.\n    */\n    \n    int counts[int(N_COLORS)];\n    \n    // search neighborhood and update counts\n    for (int i=-range; i<range+1; i++)\n        for (int j=-range; j<range+1; j++)\n            counts[int(fetch(p, i, j).a)-1]++;\n    \n    // find max index\n    int max_index = 0;\n    for (int i=0; i<int(N_COLORS); i++)\n        if (counts[max_index] < counts[i])\n            max_index = i;\n    \n    return float(max_index);\n}\n\nvoid mainImage(out vec4 pixel_state, in vec2 pixel){    \n    if (key_down(KEY_RESET) || fetch(pixel,0,0).a == 0.0) {\n        float index = floor(hash12(pixel)*N_COLORS);\n        pixel_state = vec4(get_color(index), index+1.0);\n        return;\n    }\n    vec4 state = fetch(pixel, 0, 0);\n    \n    #if (MAJORITY_SEARCH)\n        float index = majority_search(pixel, RANGE);\n        pixel_state = vec4(get_color(index), index+1.0);\n    #else\n        vec4 next_state = next_state(state);\n        if (GREENSBERG_HASTINGS && state.a > 1.0) {\n            pixel_state = next_state;\n            return;\n        }\n        int neighbors_next_state = search(pixel, RANGE, next_state.a);\n        pixel_state = neighbors_next_state >= THRESHOLD ? next_state : state;\n    #endif\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159\n\n#define GRID iChannel0\n#define KEYBOARD iChannel1\n\n// press 'r' key to reset. see https://keycode.info/ for other keycodes\n#define KEY_RESET 82\n\n// Use 1 to use majority update method\n// Use 0 to use Cyclic Celular Automata update method\n#define MAJORITY_SEARCH 0\n\n/*\nCyclic Cellular Automata (CCA) exhibit complex self-organization by \niteration of an extremely simple update rule. A specified number of \ncolors are arranged cyclically in a \"color wheel\". Each color can only \nadvance to the next, the last cycling to the first. \n\nIn each frame update, a cell's color advances to the next color if there \nare at least THRESHOLD cells of the next color within its neighborhood.\n\nIn the Greensberg-Hastings model, the threshold condition only applies to\ncells that have the first color. All cells that are colored with colors\nother than the first color automatically advance to the next color.\n\nThese simple dynamics exhibit complex self-organization starting from \nrandomness. This class of cellular automatons was discovered and explored \nby David Griffeath\n*/\n\n#define RANGE 3\n#define THRESHOLD 4\n#define N_COLORS 5.0\n\n// Use 1 for linear gradient between Color A and Color B\n// Use 2 for cosine gradient\n#define COLOR_MODE 2\n\n// Endpoint colors of the linear gradient, if color mode 1 is used.\n#define COLOR_A vec3(1.000,0.000,0.298)\n#define COLOR_B vec3(0.000,1.000,0.031)\n\n// Use 1 for Von-Neumann neighborhoods\n// Use 2 for Moore neighborhoods\n#define NEIGHBORHOOD_MODE 1\n#define GREENSBERG_HASTINGS false\n\nvec3 cos_gradient(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(2.0*PI*(c*t+d));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 101]], "test": "untested"}
{"id": "tt3BRr", "name": "tuto: adapt cost to computer2", "author": "FabriceNeyret2", "description": "For iterative rendering (e.g. path-tracing), better to adapt the cost per frame to the user computer ability.\nEasy: see end of  buffA ( illustrated with shader [url]https://shadertoy.com/view/wt2BRK[/url] )\nLeft: proportion of computed pixels per frame.", "tags": ["pathtracing", "tuto", "adaptive"], "likes": 5, "viewed": 293, "published": 3, "date": "1612175237", "time_retrieved": "2024-07-30T19:41:15.211348", "image_code": "// example shader in buffA adapted from https://shadertoy.com/view/wt2BRK\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = texelFetch(iChannel0, ivec2(U),0);\n#if 0\n    for (float l=0.; l<10.; l++, U/=2.)          // interpolation at undefined places\n        if (O.a==0.) O = texture(iChannel0, U,l);\n#endif\n    O.a > 0. ? O /= O.a : O;                     // normalization \n    O = pow( O, vec4(1./2.2) );                  // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// example shader adapted from https://shadertoy.com/view/wt2BRK\n\n#define R        iResolution.xy\n#define hash(p)  fract(sin( (p)* vec2(12.9898, 78.233) ) * 43758.5453)\n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))\n\nvec4 f(vec2 U) {\n    U = ( 2.*U - R ) / R.y;                           // normalized centered coords\n    float time = .5, w = 2./R.y,                      // line width\n          t=1.,s,C, v=0.;\n    vec3  D = normalize(vec3(.2*U, -1)),              // ray direction\n          p = vec3(0,0,30), T,a,f,q;                  // marching point along ray \n    for ( ; v < 1e3 && t > 1e-4 ; v++ ) {\n        q = p, \n        q.yz *= rot(-.2),                             // rotations\n        q.xz *= rot(.3*time),\n        T = q,                                      \n        a = abs(T), C = max(a.x,max(a.y,T.z))-8.03;   // big cube\n                                                      // --- tubes\n        q = mod(q+1.,2.)-1.,                          // 3D tiling (staggered compare to cube)\n        t = min(length(q.xy),                         // cylinders in 3 directions\n            min(length(q.yz),                         // ( cross at middle of cells )\n                length(q.xz)))-w,\n                                                      // --- balls\n        f = fract(4e5*sin(ceil(T/2.)*mat3(1,2,3,4,5,6,7,8,9))), // random seed per cell\n        f *= .95+.05*sin(time*40.+63.*f.y),           // shake\n        q = mod(T,2.)-1.,                             // now consider stagered cells (small cubes)\n\n        t = max( t, C );                              // --- intersection with big cube\n\n        p += t*D;                                     // step forward = dist to obj\n    }\n    p.z -= 30.;  vec4 O = vec4( min(1., length(p)/1e3)) ; // exp(-min(1e9,length(p)/1e3)) );\n    O.a = step(0.,O.x);\n    return O;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = texelFetch(iChannel0, ivec2(U),0);\n    \n// === adapting cost to computer =================================================\n  {  // suggestion: do only for iFrame > 0 so as to start with first guess (if not excessive ).\n    vec4 S = texelFetch(iChannel0,ivec2(0),0);    // stored state\n    float p = iFrame<1 ? .1 : S.w;                // pixel (0,0).w stores the adaptive sampling rate\n    if (U==vec2(.5)) {                            // --- manage adaptive sampling rate\n        if  (R.x != S.x) p *=  (S*S).x/(R*R).x;   // brutal change at resolution change\n        else\n         // p *= .0164/iTimeDelta;                // adapt to target fps\n            p = mix(p, p*.0174/iTimeDelta, .1);   // adapt to target fps with relaxation ( to filter iTimeDelta fluctuations )\n        O = vec4(R.x,0,0,max(.001,p));\n        return;\n    } \n    if (R.x != S.x ) O=vec4(0);                   // reset image at resolution change\n    if (U.x<8.) { O = vec4(U.y/R.y < p,0,0,0); return; }   // demo: show samping on left\n  //vec2 C = fragCoord;                           // render proportion p of random pixels: no gain !\n    vec2 C = floor(U/vec2(4,8));                  // render proportion p of random warps\n    if ( fract( 1e4*sin(dot ( C +iTime, vec2(1,17.761))) ) > p ) \n         return;\n }\n// ===============================================================================        \n    \n    O += f(U+hash(iTime)-.5);                     // cumulate rendering with subpixel jittering\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3BRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 111, 111, 432]], "test": "untested"}
{"id": "Wl3BR8", "name": "GLSL bug 74", "author": "FabriceNeyret2", "description": "at least on OpenGL(linux)/nVIDIA ,     in expression   a + ( cond ? ... ), the condition is incorrectly evaluated first:\n\nif correct, the bottom blue line should be offseted.\nwith bug, the green middle line is offseted.", "tags": ["glsl", "bug"], "likes": 1, "viewed": 374, "published": 3, "date": "1612170465", "time_retrieved": "2024-07-30T19:41:15.968325", "image_code": "#define f(U)   ( (U).x > 0. ? .5 : 0. )   // this should always equals .5\n\nvoid mainImage( out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = 2.* u / R - 1.;     // normalized coordinates  \n    O = vec4(0);\n    \n    if (U.y > .33)                                          // top\n       U = fract(U),   O.r = U.x + f(U);\n\n    else if (U.y > -.33)                                    // middle : should be like top\n       O.g = ( U = fract(U) ).x  + f(U);\n\n    else                                                    // bottom : should be offseted compare to top \n       O.b =  U.x  + f( U = fract(U) );\n    \n    O = step(.7,O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 112, 112, 640]], "test": "untested"}
{"id": "tttfzr", "name": "Ellipse - distance 2D II No Trig", "author": "iq", "description": "Computing the distance to an ellipse like in [url]https://www.shadertoy.com/view/4lsXDN[/url] but without trigonometric functions (not necessarily faster). Also see [url]https://www.shadertoy.com/view/4sS3zz[/url]", "tags": ["2d", "distance", "ellipse"], "likes": 10, "viewed": 1157, "published": 3, "date": "1612169670", "time_retrieved": "2024-07-30T19:41:16.725300", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the distance to an ellipse like in \n// https://www.shadertoy.com/view/4lsXDN, ie, using a\n// Newtwon root solver, but realizing that the deltas\n// in the variable of the solver can be interpreted as\n// rotations, hence removing all sin/cos calls, but\n// introducing a square root. This might or might not\n// be any faster than the trigonometric version, since\n// GPUs are really good at trigs.\n//\n// More information here:\n//\n// https://iquilezles.org/articles/ellipsedist\n//\n//\n// Ellipse distances related shaders:\n//\n// Analytical     : https://www.shadertoy.com/view/4sS3zz\n// Newton Trig    : https://www.shadertoy.com/view/4lsXDN\n// Newton No-Trig : https://www.shadertoy.com/view/tttfzr \n// ?????????????? : https://www.shadertoy.com/view/tt3yz7\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and https://iquilezles.org/articles/distfunctions2d\n\n\nfloat sdEllipse( vec2 p, vec2 ab )\n{\n    // symmetry\n\tp = abs( p );\n    \n    // initial value\n    vec2 q = ab*(p-ab);\n    vec2 cs = normalize( (q.x<q.y) ? vec2(0.01,1) : vec2(1,0.01) );\n    \n    // find root with Newton solver (see https://www.shadertoy.com/view/4lsXDN)\n    for( int i=0; i<5; i++ )\n    {\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        \n        float a = dot(p-u,v);\n        float c = dot(p-u,u) + dot(v,v);\n        float b = sqrt(c*c-a*a);\n        \n        cs = vec2( cs.x*b-cs.y*a, cs.y*b+cs.x*a )/c;\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*cs);\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n    vec2 ra = vec2(0.5,0.2) + 0.2*cos(iTime*vec2(1.1,1.3)+vec2(0.0,1.0) );\n    \n\tfloat d = sdEllipse( p, ra );\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdEllipse(m, ra);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttfzr.jpg", "access": "api", "license": "mit", "functions": [[1985, 1985, 2021, 2037, 2702], [2704, 2704, 2761, 2761, 3466]], "test": "untested"}
{"id": "tldfRr", "name": "Alien Lab", "author": "xavierseb", "description": "Another interesting find", "tags": ["3d", "geometric"], "likes": 1, "viewed": 258, "published": 3, "date": "1612150634", "time_retrieved": "2024-07-30T19:41:17.523167", "image_code": "// alien lab\n//\n// follow mouse cursor along red lined path to navigate outer walkway and inner chamber\n//\n\nconst mat2 RQ=mat2(cos(1.57),sin(1.57),-sin(1.57),cos(1.57));\n#define PI2 6.2831853\n\n#define X 0.  \n//#define X .5  // alternative\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y, m=iMouse.xy/iResolution.xy-.5;\n\tvec3 rd = normalize(vec3(uv, .85));\n\tfloat v=mod(iTime/6.,PI2), luv=length(uv);\n\tvec3 p = vec3(0), p1, p2;\n\tfragColor = vec4(0);\n\tfor (int i = 1; i < 160; i++) {\n\t\tp1 = p;\n\t\tfloat k = atan(m.y,m.x);\n\t\tp1.xz += vec2(cos(k),sin(k)) * (22.+36.*smoothstep(.18,.22,length(m*iResolution.xy/iResolution.y)));\n\t\tp1.yz *= RQ; p2=p1;\n\t\t{\n\t\t\tk = length(p1.xy); p1.x=k*(mod(atan(p1.y, p1.x), PI2/6.) -PI2/12.); p1.y=k-38.7;\t\t\n\t\t\tk = length(p1.xz); p1.x=k*(abs(sin(atan(p1.z, p1.x))) -X); p1.z=k-17.0;\n\t\t}\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tk = length(p1.xy); p1.x=k*(mod(atan(p1.y, p1.x), PI2/10.) -PI2/20.); p1.y=k-19.2;\t\t\n\t\t\tk = length(p1.xz); p1.x=k*(abs(sin(atan(p1.z, p1.x)))-.50); p1.z=k-17.0; \t\t\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tk = length(p1.xy); p1.x=k*(mod(atan(p1.y, p1.x), PI2/12.) -PI2/24.); p1.y=k-3.;\t\t\n\t\t\tk = length(p1.xz); p1.x=k*(mod(atan(p1.z, p1.x), PI2 /4.) -PI2/8.);  p1.z=k-3.48;\n\t\t}\n\t        float d = dot(abs(p1), normalize(vec3(5.5,12,14.2))) - 3.1;\t\t\t\t\n\t\tif (d < .001) {\n\t\t\tfragColor = vec4(10./float(i))*max(.5,-sin(iTime/4.));\n   \t\t\tfragColor.rb*=1.+pow(1./length(p2.xy),2.)*max(0.,sin(40.*sin(iTime)));\n\t\t\tfragColor.b*=1.+1.5-min(1.5,abs(length(p2.xy)-38.4));\n\t\t\tfragColor.gb+=pow(p1.z/3.,10.)*max(0.,sin(iTime/4.));\n\t\t\tif(luv<.3 && luv>.12) if(abs(uv.x)<.006 || luv>.29 || luv<.13) fragColor.r=1.;\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 297, 297, 1745]], "test": "untested"}
{"id": "wtdBRr", "name": "Motion-compensated ray marching", "author": "jarble", "description": "I use a depth buffer to predict the distance in the next frame from the distance in the previous frame.\nThis decreases the number of ray marching steps, but it makes some strange visual artifacts.\n\n", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 297, "published": 3, "date": "1612143281", "time_retrieved": "2024-07-30T19:41:18.286127", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS/8; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return depth;\n        }\n    }\n    return depth;\n}\n            \n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    vec4 dmap = depth_map(fragCoord);\n    //float dist = dmap.x;\n\tvec3 p = eye + dmap.x * worldDir;\n\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(vec3(1.0-sin(angle_between_vectors(worldDir,vec3(1,0,0.0)))), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end,out float steps) {\n    float depth = start;\n    int iters = 3;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        steps += 1.0;\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (abs(dist) < eps*(1.0+depth)) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n            \n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    \n    \n    float steps;\n    \n    float l0 = max(0.0,dmap.x-dmap.y*10.0);\n\n\n    \n    //float l0 = log(dmap.x+1.0)*2.0;\n    \n\n    \n    //if(dmap.y > 0.1){\n    //    l0 = max(0.0,log(l0)/2.0);\n    //}\n    \n    float dist;\n    \n    if(sceneSDF(eye+worldDir*dmap.x/2.0)>EPSILON){\n        //start from midpoint if it intersects anything\n        l0 = dmap.x/2.0;\n    }\n    \n    dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST,steps);\n\n    \n\n\n    \n    fragColor = vec4(dist,abs(dist-dmap.x),steps,0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SHADOW_ITER 20\n#define image_scale 1.0\n//change Z-buffer resolution\n\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\n\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nconst float MIN_DIST = EPSILON;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat angle_between_vectors(vec3 A, vec3 B){\n\n    return acos(dot(A,B) / (length(A) * length(B)));\n}\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n        if(i1 > iters) break;\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p,int iters){\n\treturn sceneSDF(p,1.0,iters);\n}\n\nfloat sceneSDF(vec3 p,float anim){\n\treturn sceneSDF(p,anim,4);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0,4);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 1086], [1101, 1101, 1128, 1128, 1183], [1185, 1185, 1242, 1242, 2180]], "test": "untested"}
{"id": "tltBRr", "name": "Simple Gradient Descent", "author": "oneshade", "description": "Simple gradient descent.", "tags": ["gradient", "machinelearning", "gradientdescent", "minima"], "likes": 22, "viewed": 519, "published": 3, "date": "1612141779", "time_retrieved": "2024-07-30T19:41:19.049087", "image_code": "/*\nI've gotten interested in neural networks again so I followed this tutorial explaining\ngradient descent: https://realpython.com/gradient-descent-algorithm-python/\nI didn't choose the best parameters because I thought these looked way more interesting :)\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = CONTOUR_THICKNESS / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    float hSpacing = 0.5 * CONTOUR_SPACING;\n    float fRes = f(uv);\n\n    color.br += vec2(1.0, 0.0) + vec2(-1.0, 1.0) * (0.5 + 0.5 * fRes);\n    color *= smoothstep(0.0, unit, abs(mod(fRes + hSpacing, CONTOUR_SPACING) - hSpacing) / length(d(uv)));\n\n    for (int i=0; i < NUMBER_OF_POINTS; i++) {\n        vec2 point = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - point) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    bool inPositions = iFragCoord.x < NUMBER_OF_POINTS && iFragCoord.y == 0;\n    bool inChanges = iFragCoord.x < NUMBER_OF_POINTS && iFragCoord.y == 1;\n\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        if (inPositions) {\n            fragColor = vec4(Hash12(fragCoord.x + iDate.w) * 4.0 - 2.0, 0.0, 1.0);\n        }\n    }\n\n    if (iFrame > 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        if (inPositions) {\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            vec2 change = texelFetch(iChannel0, ivec2(iFragCoord.x, 1), 0).xy;\n            vec2 grad = d(fragColor.xy);\n            fragColor.xy += DECAY_RATE * change - LEARNING_RATE * grad;\n        }\n\n        if (inChanges) {\n            fragColor = texelFetch(iChannel0, iFragCoord, 0);\n            vec2 position = texelFetch(iChannel0, ivec2(iFragCoord.x, 0), 0).xy;\n            vec2 grad = d(position);\n            fragColor.xy = DECAY_RATE * fragColor.xy - LEARNING_RATE * grad;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Number of points to be tracked\n#define NUMBER_OF_POINTS 200\n\n// Contour settings\n#define CONTOUR_SPACING 0.125\n#define CONTOUR_THICKNESS 2.0\n\n// Controls the speed at which the points move\n// Must be balanced for speed/accuracy\n#define LEARNING_RATE 0.001\n\n// Controls the points' momenta\n#define DECAY_RATE 0.999\n\n// Small number\n#define DELTA 0.001\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3  = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash12(in float p) {\n\tvec3 p3 = fract(p * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n\n// The function the points try to find the minima of\n// #define f(xy) dot(sin(xy * 3.0), vec2(1.0)) / 3.0\nfloat f(in vec2 xy) {\n    xy *= 0.75;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int octave=0; octave < 3; octave++) {\n        vec2 cell = floor(xy);\n        vec2 local = fract(xy);\n        local *= local * (3.0 - 2.0 * local);\n\n        float bl = Hash21(cell);\n        float br = Hash21(cell + vec2(1.0, 0.0));\n        float tl = Hash21(cell + vec2(0.0, 1.0));\n        float tr = Hash21(cell + 1.0);\n\n        value += mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n        tscale += nscale;\n        nscale *= 0.5;\n        xy *= mat2(-0.48406725864 * 2.0, -0.87503079323, 0.87503079323, -0.48406725864 * 2.0); // Rotate ~4.21 radians and scale by 2\n    }\n\n    return value / tscale - 0.8;\n}\n\n// Derivative of f for guiding the points (numeric)\n// #define d(xy) cos(xy * 3.0)\nvec2 d(in vec2 xy) {\n    return vec2(f(xy + vec2(DELTA, 0.0)) - f(xy - vec2(DELTA, 0.0)),\n                f(xy + vec2(0.0, DELTA)) - f(xy - vec2(0.0, DELTA))) / (2.0 * DELTA);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 316, 316, 965]], "test": "untested"}
{"id": "tttBRr", "name": "Curler 1.0 Test", "author": "sjdacruz", "description": "Author: https://www.shadertoy.com/view/XsVBzd", "tags": ["webcam"], "likes": 8, "viewed": 673, "published": 3, "date": "1612139469", "time_retrieved": "2024-07-30T19:41:19.806063", "image_code": "void mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    vec4 selfState = texture(iChannel0, (fragCoord / iResolution.xy));\n    \n    outFragColor = selfState;\n    //outFragColor = (selfState * pow(selfState.a, 20.0));\n    outFragColor.a = 1.0;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int k_blurRadius = 10;\n\nfloat RandomFloat(\n  vec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tfloat testCoordInGeneratorSpace = \n\t\tdot(testCoord, vec2(127.1, 311.7));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec2 RandomVec2(\n  vec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tvec2 testCoordInGeneratorSpace = vec2(\n\t\tdot(testCoord, vec2(127.1, 311.7)),\n\t\tdot(testCoord, vec2(269.5, 183.3)));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec3 RandomVec3(\n  vec2 testCoord)\n{\n    // From: https://www.shadertoy.com/view/Xd23Dh\n    // (just removed some dimensions)\n    vec3 testCoordInGeneratorSpace = vec3(\n        dot(testCoord, vec2(127.1, 311.7)),\n        dot(testCoord, vec2(269.5, 183.3)),\n        dot(testCoord, vec2(419.2, 371.9)));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec2 TransformFromCanvasTextureToFramedTexture(\n\tvec2 canvasTextureCoord,\n\tvec2 canvasTextureSize,\n\tvec2 framedTextureSize)\n{\t\n\tvec2 result = (canvasTextureCoord / canvasTextureSize);\n\n\tfloat canvasAspectRatio = (canvasTextureSize.x / canvasTextureSize.y);\n\tfloat framedAspectRatio = (framedTextureSize.x / framedTextureSize.y);\n\n\tif (framedAspectRatio < canvasAspectRatio)\n\t{\n\t\tfloat relativeAspectRatio = (canvasAspectRatio / framedAspectRatio);\n\n\t\tresult.x *= relativeAspectRatio;\n\t\tresult.x -= (0.5 * (relativeAspectRatio - 1.0));\n\t}\n\telse\n\t{\n\t\tfloat relativeAspectRatio = (framedAspectRatio / canvasAspectRatio);\n\n\t\tresult.y *= relativeAspectRatio;\n\t\tresult.y -= (0.5 * (relativeAspectRatio - 1.0));\n\t}\n\n\treturn result;\n}\n\nbool TextureCoordIsInBounds(\n\tvec2 texCoord)\n{\n\tvec2 inBounds = (\n        step(vec2(0.0), texCoord) * \n        step(texCoord, vec2(1.0)));\n    \n    return ((inBounds.x > 0.5) && (inBounds.y > 0.5));\n}\n\nvec4 SampleWebcam(\n\tsampler2D webcamTexture,\n\tvec2 webcamSize,\n    bool horizontallyMirrorWebcam,\n    vec2 canvasCoord,\n\tvec2 canvasSize)\n{\n\tvec2 webcamCoord = \n        TransformFromCanvasTextureToFramedTexture(\n            canvasCoord, \n            canvasSize, \n            webcamSize);\n\n    if (horizontallyMirrorWebcam)\n    {\n    \twebcamCoord.x = mix(1.0, 0.0, webcamCoord.x);\n    }\n    \n    vec4 result = TextureCoordIsInBounds(webcamCoord) ? \n        pow(texture(webcamTexture, webcamCoord), vec4(2.0)) : \n    \tvec4(0.0, 0.0, 0.0, 1.0);\n    \n    return result;\n}\n\nfloat GetBrightness(\n    vec4 color)\n{    \n    return (0.333 * (color.r + color.g + color.b));\n}\n\nvec4 ComputePseudoGaussianBlur(\n\tsampler2D source,\n    vec2 texelSize,\n    vec2 fragCoord,\n    vec2 blurDirection) // Unit-length. Typically (1, 0) or (0, 1).\n{\n    vec4 accumulator = vec4(0.0);\n    float totalWeight = 0.0;\n    \n    float oneOverBlurRadius = (1.0 / 10.0);\n\n    vec2 sampleUvIncrement = (blurDirection * texelSize);\n    vec2 sampleUv = (\n        (fragCoord * texelSize) - \n        (float(k_blurRadius) * sampleUvIncrement));\n    \n    float uncurvedSampleWeight = -1.0;\n    float uncurvedSampleWeightIncrement = (1.0 / float(k_blurRadius));\n    \n    for (int index = (-1 * k_blurRadius); index <= k_blurRadius; index++)\n    {\n        vec4 sampleColor = texture(source, sampleUv);\n\n        // NOTE: Small fudge to make the outermost texels non-zero.\n        float sampleWeight = smoothstep(\n            (1.0 + oneOverBlurRadius), \n            0.0, \n            abs(uncurvedSampleWeight));\n        sampleWeight = (sampleWeight * sampleWeight * sampleWeight); \n\n        accumulator += (sampleColor * sampleWeight);\n        totalWeight += sampleWeight;\n        \n        sampleUv += sampleUvIncrement;\n        uncurvedSampleWeight += uncurvedSampleWeightIncrement;\n    }\n\n    return (accumulator / totalWeight);\n}\n", "buffer_a_code": "// Pass: Webcam perspective correction.\n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{    \n    outFragColor = SampleWebcam(\n\t\tiChannel0,\n\t\tiChannelResolution[0].xy,\n    \ttrue, // horizontallyMirrorWebcam\n    \tfragCoord,\n\t\tiResolution.xy);\n    \n    outFragColor.a = GetBrightness(outFragColor);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Pass: Vertical blur.\n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    outFragColor = ComputePseudoGaussianBlur(\n        iChannel0,\n        (1.0 / iResolution.xy),\n        fragCoord,\n        vec2(0.0, 1.0));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Pass: Horizontal blur.\n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    outFragColor = ComputePseudoGaussianBlur(\n        iChannel0,\n        (1.0 / iResolution.xy),\n        fragCoord,\n        vec2(1.0, 0.0));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Pass: Curl and simulation.\n\nvec2 s_texelSize;\n\nvec2 ComputeGradient(\n    vec2 fragUv)\n{\n    // HAAAAACK!\n    \n    vec4 center = texture(iChannel0, fragUv);\n    vec4 right = texture(iChannel0, (fragUv + vec2(s_texelSize.x, 0.0)));\n    vec4 up = texture(iChannel0, (fragUv + vec2(0.0, s_texelSize.y)));\n\n    return vec2((center.a - right.a), (center.a - up.a));\n} \n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    s_texelSize = (1.0 / iResolution.xy);\n    \n    vec2 fragUv = (fragCoord * s_texelSize);\n    \n    vec2 gradient = ComputeGradient(fragUv);\n    vec2 curl = vec2((-1.0 * gradient.y), gradient.x);\n    \n    vec4 selfState = texture(iChannel1, fragUv);\n    \n    vec2 frameOffset = vec2(mod(float(iFrame), 97.0), mod(float(iFrame), 101.0));\n    vec2 frameRandom = RandomVec2(fragUv + frameOffset);\n    \n    if (frameRandom.x > selfState.a)\n    {\n        vec4 camera = texture(iChannel2, fragUv);\n        \n        outFragColor.rgb = mix(selfState.rgb, camera.rgb, 0.8);\n        //outFragColor.rgb = camera.rgb;\n        \n        //outFragColor.a = mix(outFragColor.a, 1.0, frameRandom.y);\n        outFragColor.a = 1.0;\n    }\n    else\n    {\n        vec2 normalizedCurl = (curl / (length(curl) + 0.00001));\n            \n        vec4 curlSourceState = texture(iChannel1, (fragUv + (normalizedCurl * s_texelSize)));\n        \n        outFragColor = curlSourceState;\n        //outFragColor.rg = smoothstep(vec2(-1.0), vec2(1.0), (25.0 * curl));\n        \n        outFragColor.a -= (0.005 * iTimeDelta);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 64, 64, 257]], "test": "untested"}
