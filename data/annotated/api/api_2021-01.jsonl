{"id": "Wtdfzr", "name": "Sunday fractals", "author": "mrange", "description": "License CC0: Sunday fractals\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nSABS from ollj\n", "tags": ["2d", "fractal"], "likes": 9, "viewed": 438, "published": 3, "date": "1612125971", "time_retrieved": "2024-07-30T19:41:20.554063", "image_code": "// License CC0: Sunday fractals\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n// SABS from ollj\n\n#define RESOLUTION      iResolution\n#define TIME            iTime\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)           dot(x,x)\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define PERIOD          30.0\n#define NPERIOD         floor(TIME/PERIOD)\n#define TIMEINPERIOD    mod(TIME, PERIOD)\n#define FADE            1.0\n#define HPERIOD         hash(NPERIOD)\n\nfloat hash(float co) {\n  co += 2313.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n  return tanh(x);\n  /*\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n  */\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat height(vec2 p, vec2 c, float hh) {\n  p*=mix(1.5, 0.5, TIMEINPERIOD/PERIOD);\n  p+=mix(0.2, 0.0, TIMEINPERIOD/PERIOD);\n  p*=ROT(TIMEINPERIOD*0.05);\n  vec2 op = p;\n  float l2 = L2(p);\n  float rep = 2.0*round(mix(3.0, 30.0, hh*hh));\n  float s = 0.05*6.0/rep;\n  float n = smoothKaleidoscope(p, s, rep);\n  p *= ROT(TAU*hh);\n  vec2 u = p;\n\n  float a = 0.0;\n\n  \n  for (int i = 0; i < 13; ++i) {\n    float m = dot(u, u);\n    u = SABS(u, 0.025)/m + c;\n  }\n  \n  float h = L2(u-p);\n  h = log(h-hh);\n  h = abs(h);\n  h = tanh_approx(.45*h*h+0.125/(l2+0.125));\n  \n  return h;\n}\n\nvec3 normal(vec2 p, vec2 c, float hh) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy, c, hh) - height(p - e.xy, c, hh);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx, c, hh) - height(p - e.yx, c, hh);\n  \n  return normalize(n);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float s = 1.25;\n  const vec3 lp1 = s*vec3(1.0, 2.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = s*vec3(-1.0, 2.25, 1.0)*vec3(s, 1.0, s);\n  \n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float hh = HPERIOD;\n\n  vec3 col = vec3(0.0);\n  vec2  c = vec2(-0.4-0.2*fract(7.0*hh), -0.4-0.2*fract(13.0*hh));\n\n  float h = height(p, c, hh);\n  vec3  n = normal(p, c, hh);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(po - ro);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  float l = length(p);\n\n  vec3 hsv1 = vec3(hh+mix(0.0, 0.2, PSIN(0.3*TIME-2.0*l+(p.x+p.y))), tanh_approx(h*h), tanh_approx(3.0*h*h));\n  hsv1.yz = clamp(hsv1.yz, 0.0, 1.0);\n  vec3 col1 = hsv2rgb(hsv1);\n  vec3 col2 = pow(col1, vec3(0.25, 0.5, 2.0));\n\n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  col += col1*mix(0.1, 1.0, pow(diff1, 8.0))*0.5;\n  col += col2*mix(0.1, 1.0, pow(diff2, 8.0))*0.5;\n  col = pow(col, vec3(1.5));\n  col += 8.0*col1*pow(ref1, 40.0);\n  col += 4.0*col2*pow(ref2, 10.0);\n\n  col = tanh(2.5*col);\n  col = postProcess(col, q);\n  \n  float fadeIn  = smoothstep(0.0, FADE, TIMEINPERIOD);\n  float fadeOut = 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEINPERIOD);\n  col = mix(vec3(0.0), col, fadeIn*fadeIn*fadeOut*fadeOut);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdfzr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[732, 732, 754, 754, 818], [820, 820, 848, 848, 952], [954, 954, 976, 976, 1020], [1022, 1022, 1043, 1043, 1088], [1090, 1090, 1135, 1135, 1289], [1291, 1291, 1352, 1352, 1565], [1567, 1567, 1607, 1607, 2135], [2137, 2137, 2176, 2176, 2410], [2412, 2412, 2434, 2434, 2603], [2605, 2605, 2642, 2642, 2895], [2897, 2897, 2952, 2952, 4491]], "test": "untested"}
{"id": "WttBRr", "name": "Kleinian Landscape", "author": "amoser", "description": "Basic Kleinian group limit set with fully dynamic GI (+ temporal reprojection denoising and some weird hacky thing where I try to accumulate encoded lighting data from neighboring pixels) plus a bunch of very superfluous postprocess effects. ", "tags": ["3d", "raymarching", "fractal", "math", "gi", "global", "dof", "bokeh", "pathtracing", "kleinian", "montecarlo", "apollonian"], "likes": 32, "viewed": 1115, "published": 3, "date": "1612116340", "time_retrieved": "2024-07-30T19:41:21.685040", "image_code": "// Final post-processing\n// \n\n// Sample scene color with FXAA, 0-1 range uvs\nvec4 sceneColor(vec2 uv)\n{\n    vec4 outColor = vec4(FXAA(uv, iChannel1, 1.0/iResolution.xy), 1.0);\n    \n    return outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvAspectCorrected = uv - 0.5;\n    uvAspectCorrected = vec2(uvAspectCorrected.x*(iResolution.x/iResolution.y), uvAspectCorrected.y);\n    uvAspectCorrected += 0.5;\n    \n    // Fringe\n\tconst int fringeSamples = 6;\n    float fringeAmount = fringeStrength*saturate(distance(uvAspectCorrected, vec2(0.5))-fringeStart);\n\n    vec4 outColor = vec4(0);\n\n    if(fringeAmount > 0.0)\n    {\n        for(int i = 0; i < fringeSamples; i++)\n        {\n            float fringe = 1.0+(float(i-fringeSamples/2)*fringeAmount)/float(fringeSamples);\n            outColor += vec4(sceneColor(((uv-0.5)*fringe + 0.5)))*HUE(mod(0.85-1.0*float(i)/float(fringeSamples), 1.0));\n        }\n        outColor /= float(fringeSamples)*0.6;\n    }\n    else\n    {\n        outColor = vec4(sceneColor(uv));\n    }\n\n    \n    // Vignette\n    outColor *= pow(saturate(1.25-1.5*distance(uv, vec2(0.5))), 0.9);\n    outColor += 0.001*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    // Saturation / discolor highlights\n    outColor = mix(outColor, vec4(1, 1, 0.66, 1)*vec4(dot(outColor.rgb, luma)), 1.0-saturate(1.05-dot(outColor.rgb, luma))); \n    \n    // Saturation / discolor shadows\n    outColor = mix(outColor, vec4(0.6, 0.8, 1, 1)*vec4(dot(outColor.rgb, luma)), saturate(0.3-3.0*dot(outColor.rgb, luma))); \n    \n    // Tonemap + color grade\n   \toutColor = toneMap(outColor, vec3(0.95,0.95,0.85), vec3(1.15, 1.3, 1.3));\n    \n    // Ungraded tonemap\n    //outColor = toneMap(outColor, vec3(1), vec3(1));\n    \n    fragColor = pow(outColor, vec4(1.0/gamma));\n    \n    // For debugging depth\n    //fragColor = vec4(1.0-UDEPTH(fragCoord)*maxDepth);\n    // For debugging GI\n\t//fragColor = textureLod(iChannel0, uv, 0.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Path tracing, partly based (unsurprisingly) on iq's implementation\n//\n// Single sample, one bounce, but stores indirect bounces as \"point lights\" for re-use across neighboring pixels (done in Buffer B) so we only compute final direct light here.\n// I have no idea if any of this is a good idea, but it was a fun experiment.\n// Supports specular (GGX) with multiple importancs sampling, and uses a roughness map\n\nvec4 orbitTrap;\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nfloat intersect(in ray ray, int maxSteps, float bias)\n{\n    float res = -1.0;\n\n    float t = bias;\n    \n    for(int i=1; i<maxSteps+1; i++ )\n    {\n\t\tvec3 samplePoint = ray.origin+ray.direction*t;\n        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)\n        {\n            return -1.0;\n        }\n\n        float h = sceneDistanceFunction(samplePoint, orbitTrap);\n        if(h < mix(0.0001, 0.01, saturate(distance(ray.origin, samplePoint)/12.0)/*smoothstep(0.0, 6.0, distance(ray.origin, samplePoint))*/) || t > maxDepth) \n        {\n            break;\n        }\n        //if( h<0.0012 || t>tmax ) break;\n        t +=  h;\n    }\n    \n    if(t<maxDepth) \n    {\n        res = t;\n    }\n    \n    return res;\n}\n\n// TODO this\n/*\nvec3 dropToFloor(in vec3 origin, int maxSteps)\n{\n    float res = -1.0;\n    \n    float t = 0.001;\n    for(int i=1; i<maxSteps+1; i++ )\n    {\n\t\tvec3 samplePoint = origin + vec3(0, -1, 0)*t;\n        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)\n        {\n            // No floor found\n            return origin;\n        }\n        float h = sceneDistanceFunction(samplePoint, orbitTrap);\n        if(h < 0.001 || t > maxDepth)\n        {\n            break;\n        }\n        t +=  h;\n    }\n    \n    if(t<maxDepth) \n    {\n        res = t;\n    }\n    \n    return origin + vec3(0, -res, 0);\n}\n*/\n\nfloat shadow(in ray ray, int maxSteps)\n{\n    float res = 0.0;\n\n    float t = 0.001;\n    \n    float k = 8.0;\n    \n    float h = 0.1;\n    \n    for(int i=1; i<maxSteps+1; i++ )\n    {\n        vec3 samplePoint = ray.origin+ray.direction*t;\n        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)\n        {\n            return 1.0;\n        }\n        h = sceneDistanceFunction(ray.origin+ray.direction*t, orbitTrap);\n        res = min( res, (k*h)/t );\n        //if( h<0.0015*pow(distance(ray.origin, samplePoint), 1.0) || t>tmax) break;\n        if(h < 0.00009 || t > maxDepth) \n        {\n            break;\n        }\n        t += h;\n    }\n\n    if(t > maxDepth)\n    {\n        res = 1.0;\n    }\n    \n    return res;\n}\n\nfloat softShadow(in ray ray, int maxSteps/*float mint, float k*/)\n{\n    float k = 4.0;\n    float res = 0.0;\n    float t = 0.001;\n\tfloat h = 1.0;\n    \n    for( int i=0; i<int(maxSteps); i++ )\n    {\n        h = sceneDistanceFunction(ray.origin + ray.direction*t, orbitTrap);\n\n        if(res<0.001)\n        {\n            break;\n        }\n        t += h;//clamp( h, 0.01, 0.05 );\n    }\n    return 1.0-saturate(res);\n}\n\nvoid calculateColor(ray cameraRay, float sa, vec2 fragCoord, out vec3 camHitPosition, out float depth, out vec3 camHitNormal, out vec3 baseColor, out vec3 directLight, out vec3 indirectLight, out pointLight bounceLight, vec3 sunDirection, vec3 sunColor)\n{\n    const float epsilon = 0.0001;\n    float seed = mod(iTime, 1024.0)+0.13*iMouse.x+1.25*iMouse.y;\n    \n    vec3 bounceColor = vec3(1);\n    \n    vec3 totalDirect = vec3(0);\n    vec3 totalGi = vec3(0);\n    \n    ray currentRay = cameraRay;\n    \n    // TODO manually unroll bounces to reduce number of ifs?\n    for(int bounce = 0; bounce<2; bounce++)\n    {\n        currentRay.direction = normalize(currentRay.direction);\n        \n       \n        float traced = -1.0;\n        if(bounce == 0)\n        {\n            traced = intersect(currentRay, 128, 0.005);\n        }\n        else\n        {\n            traced = intersect(currentRay, 80, 0.005);\n        }\n        if(traced < 0.0)\n        {\n            if( bounce==0 ) \n            {\n                // No hit, draw BG\n                vec3 bgColor = getSky(currentRay, sunDirection, sunColor);\n                totalDirect = bgColor;\n\n                // Out\n                directLight = bgColor;\n                indirectLight = vec3(0);\n\n                return;\n            }\n            break;\n        }\n\n        vec3 position = currentRay.origin + currentRay.direction*traced;\n        vec3 surfaceNormal = calcNormal(position);\n        \n        vec3 triplanarNormal = surfaceNormal;\n\t\t\n        float emissiveFactor = saturate((1.0 - orbitTrap.z*50.0)*100000.0);\n        \n        vec3 emissiveColor = pow(((sin(position.x*5.0+mod(iTime, 1024.0)/2.0)+1.0)/2.0), 8.0)*1.33*pow(vec3(0.35,1.0,0.55),vec3(2.0))*emissiveFactor + 0.02*vec3(0.35,1.0,0.55)*emissiveFactor;\n\n        vec3 surfaceColor1 = vec3(0.7);\n        vec3 surfaceColor2 = vec3(0.6, 0.5, 0.8);\n\n        vec3 surfaceColor = mix(surfaceColor1, surfaceColor2, saturate((orbitTrap.y*3.5-0.25)*1.0))*(1.0-emissiveFactor) + emissiveFactor*(vec3(0.5,0.8,1.0));\n        \n        #ifdef ROUGHNESS_MAP\n        \tfloat roughness = saturate(pow(triPlanarMapCatRom(iChannel2, 5.0, triplanarNormal, position*7.0, iChannelResolution[2].xy), vec3(2.0)).r*2.0);\n\t\t#else\n        \tconst float roughness = 0.4;\n        #endif\n        \n\t\t// Direct lighting\n        vec3 iColor = vec3(0.0);\n\n        // Direct sun light\n        vec3 currentSunDir = sunDirection;\n        \n        float sunDiffuse = 0.0;\n        float sunSpec = 0.0;\n\n        if(bounce == 0)\n        {\n            sunDiffuse = saturate(dot(currentSunDir, surfaceNormal))*0.9;\n            sunSpec = GGX(surfaceNormal, -currentRay.direction, currentSunDir, roughness, 0.1);\n        }\n        else\n        {\n            sunDiffuse = saturate(dot(currentSunDir, surfaceNormal));\n            sunSpec = 0.0;\n        }\n        float sunShadow = 1.0;\n        if(sunDiffuse > 0.0) \n        {\n            sunShadow = shadow(ray(position + surfaceNormal*epsilon, currentSunDir), 80);\n        }\n\n        iColor += sunColor*sunDiffuse*sunShadow + sunColor*sunSpec*sunShadow;\n        \n        // Carry surface color through next bounce\n        vec3 previousBounceColor = bounceColor;\n        bounceColor *= surfaceColor;\n\n\t\tif(bounce == 0)\n        {\n            totalDirect += bounceColor*iColor + emissiveColor;\n            // Out\n            camHitPosition = position;\n            depth = traced;\n            baseColor = surfaceColor;\n            camHitNormal = surfaceNormal;\n        }\n        else if(bounce == 1)\n        {\n            totalGi += bounceColor*iColor + emissiveColor;\n\n            // Virtual point light from direct lighting of first bounce, accumulated in Buffer B\n            bounceLight.worldPosition = position;\n            bounceLight.normal = surfaceNormal;\n            bounceLight.color = (previousBounceColor*iColor + emissiveColor);\n\n            // TODO texture map\n            \n            float lightDistance = distance(bounceLight.worldPosition, camHitPosition);\n            float NdotL = saturate(dot(normalize(camHitNormal), normalize(bounceLight.worldPosition - camHitPosition)));\n            \t\n            if(NdotL > 0.00001 && length(baseColor) > 0.00001)\n            {\t\n                // Cancel out cosine distribution\n                bounceLight.color /= NdotL;\n                // Cancel out inverse square attenuation \n                bounceLight.color *= lightDistance*lightDistance;\n                // For debugging direct light\n                //bounceLight.color *= 0.0;\n            }\n        }\n\n\t\t// Send bounce ray\n        vec3 reflectDirection = reflect(normalize(currentRay.direction), normalize(surfaceNormal));\n        currentRay.direction = cosineDirection(surfaceNormal, fragCoord, seed);\n\n        currentRay.origin = position;\n    }\n    \n    // Out\n\tdirectLight = totalDirect;\n    indirectLight = totalGi;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 rt, in float cr)\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3(cu, cv, -cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jitter = vec2(hash12(vec2(13.1, mod(float(iFrame*4),4096.0))),hash12(vec2(4.1, mod(float(iFrame*3),4096.0))))*AAjitter-(AAjitter/2.0);\n    \n    vec2 jitteredCoord = fragCoord + jitter;\n    vec2 uv = jitteredCoord/iResolution.xy;\n\tvec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n    \n    float sa = hash13(vec3(iFrame, fragCoord.x, fragCoord.y));\n    \n    ray cameraRay;\n    \n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n\t    mouseLocation += iTime/9.0;\n    #endif\n    #ifdef INTERACTIVE\n\t    mouseLocation += 0.002*iMouse.x;\n    #endif\n    \n    vec3 sunDirection = initialSunDirection;\n    vec3 sunColor = initialSunColor;\n    \n    #ifdef ANIMATE_SUN\n\t    sunDirection.yz *= ROT(mod(iTime*0.05, PI*2.0));\n    \tsunDirection.xy *= ROT(sin(mod(iTime*0.025, PI*2.0)));\n    \n    \t// \"moon\"\n    \tif (sunDirection.y <= 0.0)\n        {\n            float colorMix = smoothstep(0.0, -0.2, sunDirection.y);\n            if(sunDirection.y <= -0.2)\n            {\n\t            sunDirection.y += 0.2;\n    \t        sunDirection.y *= -1.0;\n        \t    sunDirection.y -= 0.2;\n            }\n           \tsunColor = mix(sunColor, moonColor, colorMix);\n        }\n\t#endif\n\n\n    // TODO more interesting camera movement\n    // TODO avoid intersections\n    cameraRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    //cameraRay.origin.y = 1.0;\n    //cameraRay.origin = dropToFloor(cameraRay.origin, 7) + vec3(0, 0.02, 0);\n    cameraRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    cameraRay.direction.xyz = normalize(cameraRay.direction.xzy);\n    \n    vec3 color = vec3(0.0);\n    \n    // Results from ray tracing to pack up for use in subsequent passes\n    pointLight bounceLight;\n    vec3 baseColor = vec3(0);\n    vec3 camHitPosition;\n    vec3 directLight;\n    vec3 indirectLight;\n    vec3 camHitNormal;\n    float depth;\n    \n\tcalculateColor(cameraRay, sa, fragCoord, camHitPosition, depth, camHitNormal, baseColor, directLight, indirectLight, bounceLight, sunDirection, sunColor);\n    \n    float dither = 0.008*hdrScale*(hash12(fragCoord+mod(iTime, 512.0)*0.21+0.1*iMouse.xy)-0.5);\n    \n    depth /= depthScale;\n    if(depth <= 0.0 || depth > maxDepth)\n    {\n        depth = maxDepth;\n    }\n    \n    directLight += dither;\n    bounceLight.color += dither;\n    \n    directLight /= hdrScale;\n    indirectLight /= hdrScale;\n    bounceLight.color /= hdrScale;\n    bounceLight.worldPosition /= depthScale;\n    \n    // Clamp brightness, preserve color\n    float totalLight = max(max(length(indirectLight), length(directLight)),  length(bounceLight.color));\n    if(totalLight >= 1.0)\n    {\n        directLight /= totalLight;\n        indirectLight /= totalLight;\n        bounceLight.color /= totalLight;\n    }\n    \n    // For debugging\n    //NdotL = saturate(dot(normalize(camHitNormal), normalize(bounceLight.worldPosition*depthScale - camHitPosition)));\n    //virtualPointColor = baseColor*bounceLight.color*NdotL;\n    //indirectLight = virtualPointColor;\n    //bounceLight.color = indirectLight;\n    \n    // For debugging\n    //bounceLight.color = camHitPosition/depthScale;//clamp(bounceLight.worldPosition, 0.0, depthScale);\n    //bounceLight.color = camHitNormal;\n    //bounceLight.color = bounceLight.worldPosition;\n    \n    \n    \n    // Buffer packing layout:\n    // x = vec4(directLight.rgb, baseColor.r)\n    // y = vec4(bounceLight.color.rgb, baseColor.g)\n    // z = vec4(bounceLight.position.xyz, baseColor.b)\n    // w = vec4(normal.xyz, depth)\n    \n    //#ifdef STORE_NORMAL\n        // Tried packing both normal and depth, loses too much precision in depth to be useful for temporal reprojection\n    //    fragColor = vec4(pack(vec4(directLight, baseColor.r)), pack(vec4(bounceLight.color, baseColor.g)), pack(vec4(bounceLight.worldPosition, baseColor.b)), pack(vec4(camHitNormal/2.0 + 0.5, pow((saturate(depth)), 1.0/depthDistributionExponent))));\n    //#else\n    \tfragColor = vec4(pack(vec4(directLight, baseColor.r)), pack(vec4(bounceLight.color, baseColor.g)), pack(vec4(bounceLight.worldPosition, baseColor.b)), pow((saturate(depth)), 1.0/depthDistributionExponent));\n    //#endif\n}", "buffer_a_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Kleinian Landscape\n//\n// Except where otherwise specified or cited, all work is my own and available under\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Constants, helper functions\n// \n\n#define CLAMP_INDIRECT\n#define ANIMATE_CAMERA\n#define ANIMATE_SUN\n#define INTERACTIVE\n#define ROUGHNESS_MAP\n#define INDIRECT_GATHER_CHECK_DIRECTION\n\n\n////////// GENERAL\n\n#define PI 3.1415926536\n\nconst float gamma = 2.2;\n\n// Dynamic range; keep as low as possible since these buffers are packed with very low precision\nconst float hdrScale = 2.0;\nconst float depthScale = 8.0;\nconst float maxDepth = 8.0;\nconst float depthDistributionExponent = 1.0;\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\nconst float goldenAngle = 2.4;\n\n#ifdef TEMPORAL_JITTER\n\tconst float AAjitter = 1.0;\n#else\n\tconst float AAjitter = 0.0;\n#endif\n\nfloat saturate(float a)\n{\n    return clamp(a, 0.0, 1.0);\n}\n\n// from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// from Fabrice Neyret\n#define ROT(a)  mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define HUE(v) ( .6 + .6 * cos( 2.*PI*(v) + vec4(0,-2.*PI/3.,2.*PI/3.,0) ) )\n\n\n\n// Buffer unpacking\n#define UBOUNCE_COLOR(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).y))\n#define UBOUNCE_POSITION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).z))\n#define UBOUNCE_LIGHT(coord) (texelFetch(iChannel2, ivec2(coord), 0))\n#define UBOUNCE_LIGHT_BLUR(coord) UBOUNCE_LIGHT(coord)\n\n#define UDIRECT_ILLUMINATION(coord) (unpack(texelFetch(iChannel0, ivec2(coord), 0).x))\n#define UNORMAL(coord) (((unpack(texelFetch(iChannel0, ivec2(coord), 0).w)).xyz - 0.5)*2.0)\n#define UDEPTH(coord) (pow(texelFetch(iChannel0, ivec2(coord), 0).w, depthDistributionExponent))\n\n#define UDEPTH_CHANNEL1(coord) (texelFetch(iChannel1, ivec2(coord), 0).w)\n#define UBASE_COLOR(coord) vec3((unpack(texelFetch(iChannel0, ivec2(coord), 0).x)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).y)).w, (unpack(texelFetch(iChannel0, ivec2(coord), 0).z)).w)\n\n// Color packing from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint packSnorm4x8(vec4 x) \n{\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 unpackSnorm4x8(uint x) \n{\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n\n#define unpack(x) unpackSnorm4x8(floatBitsToUint(x))\n#define pack(x) uintBitsToFloat(packSnorm4x8(x))\n\n\n////////// SCENE\n\nstruct pointLight\n{\n    vec3 worldPosition;\n    vec3 normal;\n    vec3 color;\n};\n    \nstruct directionalLight\n{\n    vec3 worldPosition;\n    float angle;\n    vec3 color;\n};\n    \nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float metal;\n};\n\nvec3 initialSunDirection = normalize(vec3(-0.2, 0.7, -0.4));\nvec3 initialSunColor = 1.25*vec3(1.0,0.60,0.3);\n// \"Moon\" is just sun reflected and re-colored when it crosses horizon line\nvec3 moonColor = 1.5*vec3(1.0,0.60,0.3)*vec3(0.25, 0.45, 0.75);\nvec3 skyColor = vec3(0);\n\n// Sphere inversion fractal, similar to iq's \"Apollonian\" (https://www.shadertoy.com/view/4ds3zn) but with octogonal symmetry\nfloat map(vec3 p, inout vec4 orbitTrap)\n{\n    const float s = 1.0;//0.97;\n    const float horizontalWrap = sqrt(s*2.0)/2.0;\n    \n\tfloat scale = 1.0;\n\n\torbitTrap = vec4(1000.0); \n    \n    for(int i=0; i<9; i++)\n\t{\n        p.xz /= horizontalWrap;\n        vec3 pOffset = (0.5*p+0.5);\n\n        vec3 pOffsetWrap = 2.0*fract(pOffset);\n        \n        p = -1.0 + pOffsetWrap;\n        p.xz *= horizontalWrap;\n        \n\t\tfloat r2 = dot(p,p);\n\t\t\n        if(i < 2)\n        {\n\t        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);\n        }\n        if(i > 2)\n        {\n            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);\n        }\n        \n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\tfloat fractal = 0.33*abs(p.y)/scale;\n    return fractal;\n}\n\nfloat sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)\n{\n    return map(p, orbitTrap);\n}\n\nvec3 calcNormal(in vec3 position)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n    vec4 dummyOrbitTrap;\n\n    return normalize( \n        vec3(\n        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),\n        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))\n    \t);\n}\n\nvec3 getSky(ray cameraRay, vec3 sunDirection, vec3 sunColor)\n{\n    // TODO could take dot product with some random hemisphere samples to create fake stars\n    vec3 bgColor = vec3(1.0);\n\n    #ifdef WATER\n        if(cameraRay.direction.y < 0.0)\n        {\n            cameraRay.direction *= vec3(1, -1, 1);\n            bgColor *= waterColor;\n        }\n    #endif\n\n    bgColor *= skyColor + saturate((dot(cameraRay.direction, sunDirection)-.9975)*800.0)*sunColor*80.0 + saturate(dot(cameraRay.direction, sunDirection)+0.75)*sunColor*0.015;\n\treturn bgColor;\n}\n\n\n////////// PATH TRACING\n    \nconst int unpackedNone = 0;\n\n// TODO flags for applying filters to packed textures\n/*\nconst int unpackedDirect = 1;\nconst int unpackedBounce = 2;\nconst int unpackedDepth = 3;\nconst int unpackedBaseColor = 4;\n*/\n\n// from hornet, who says:\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n//\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleLevel0(sampler2D sceneTexture, vec2 uv, float mipLevel)\n{\n    return textureLod(sceneTexture, uv, mipLevel);\n}\nvec4 SampleTextureCatmullRom(sampler2D sceneTexture, vec2 uv, vec2 texSize, float mipLevel, int getPacked)\n{\n    vec4 result = vec4(0.0);\n    if(getPacked == unpackedNone)\n    {\n        // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n        // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n        // location [1, 1] in the grid, where [0, 0] is the top left corner.\n        vec2 samplePos = uv * texSize;\n        vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n        // Compute the fractional offset from our starting texel to our original sample location, which we'll\n        // feed into the Catmull-Rom spline function to get our filter weights.\n        vec2 f = samplePos - texPos1;\n\n        // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n        // These equations are pre-expanded based on our knowledge of where the texels will be located,\n        // which lets us avoid having to evaluate a piece-wise function.\n        vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n        vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n        vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n        vec2 w3 = f * f * (-0.5 + 0.5 * f);\n\n        // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n        // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n        vec2 w12 = w1 + w2;\n        vec2 offset12 = w2 / w12;\n\n        // Compute the final UV coordinates we'll use for sampling the texture\n        vec2 texPos0 = texPos1 - vec2(1.0);\n        vec2 texPos3 = texPos1 + vec2(2.0);\n        vec2 texPos12 = texPos1 + offset12;\n\n        texPos0 /= texSize;\n        texPos3 /= texSize;\n        texPos12 /= texSize;\n        \n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos0.y), mipLevel) * w0.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos0.y), mipLevel) * w12.x * w0.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos0.y), mipLevel) * w3.x * w0.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos12.y), mipLevel) * w0.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos12.y), mipLevel) * w12.x * w12.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos12.y), mipLevel) * w3.x * w12.y;\n\n        result += sampleLevel0(sceneTexture, vec2(texPos0.x,  texPos3.y), mipLevel) * w0.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos12.x, texPos3.y), mipLevel) * w12.x * w3.y;\n        result += sampleLevel0(sceneTexture, vec2(texPos3.x,  texPos3.y), mipLevel) * w3.x * w3.y;\n    }\n    \n    return result;\n}\n\n\nvec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)\n{\n    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;\n    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;\n    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;\n    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));\n    \n    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);\n}\n\n// from tux: https://www.shadertoy.com/view/lsj3z3\nvec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)\n{\n    vec3 signs = sign(normal);\n    \n    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;\n    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;\n    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;\n    \n    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n  \n    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));\n}\n    \n\n// from iq\nvec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)\n{\n    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);\n    vec2 random = hash22(randomSeed);\n    float u = random.x;\n    float v = random.y;\n    \n    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// from John Hable: https://gist.github.com/Kuranes/3065139b10f2d85074da\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    float alpha = roughness*roughness;\n\n    vec3 H = normalize(V+L);\n\n    float dotNL = saturate(dot(N,L));\n\n    float dotLH = saturate(dot(L,H));\n    float dotNH = saturate(dot(N,H));\n\n    float F, D, vis;\n\n    // D\n    float alphaSqr = alpha*alpha;\n    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\n    D = alphaSqr/(PI * denom * denom);\n\n    // F\n    float dotLH5 = pow(1.0-dotLH,5.);\n    F = F0 + (1.-F0)*(dotLH5);\n\n    // V\n    float k = alpha/2.;\n    float k2 = k*k;\n    float invK2 = 1.-k2;\n    vis = 1./(dotLH*dotLH*invK2 + k2);\n\n    float specular = dotNL * D * F * vis;\n    return specular;\n}\n\n\n// Camera projection stuff\nvec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) \n{\n    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;\n    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;\n    return vec3(\n        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), \n\t    (-1.0 + x2 + y2) / (1.0 + x2 + y2),\n        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));\n}\nvec2 stereographicSphereToPlane(vec3 cartPointOnSphere) \n{\n    return vec2(\n        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), \n        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));\n}\nvec2 cameraRayToUv(ray cameraRay, float projectionDist)\n{\n    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);\n    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));\n    return uv;\n}\nray uvToCameraRay(vec2 uv, float projectionDist)\n{\n    ray cameraRay;\n    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));\n    return cameraRay;\n}\n\n\n////////// POST\n\n// Bloom settings\nconst float bloomIntensity = 0.02;\nconst float bloomRadius = 0.06;\n\n// Fringe/chromatic aberration settings\nconst float fringeStrength = 0.01;\nconst float fringeStart = 0.4;\n\n// Bokeh settings\nconst float bokehScale = 0.0075;\nconst float bokehClamp = 0.0125;\nconst float bokehForceSharp = 0.001;\nconst float bokehFringe = 0.6;\nfloat bokehAspectRatio = 1.75;\n\n// FXAA settings\nconst float spanMax = 3.0;\nconst float reduceMult = (1.0/spanMax);\nconst float reduceMin = (1.0/48.0);\nconst float subPixelShift = (1.0/4.0);\n\nvec3 FXAA( vec2 uv2, sampler2D tex, vec2 rcpFrame) \n{\n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + subPixelShift)));\n   \n    float lumaTopLeft = dot(textureLod(tex, uv.zw, 0.0).xyz, luma);\n    float lumaTopRight = dot(textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomLeft = dot(textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaBottomRight = dot(textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz, luma);\n    float lumaCenter  = dot(textureLod(tex, uv.xy, 0.0).xyz,  luma);\n\n    float lumaMin = min(lumaCenter, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));\n    float lumaMax = max(lumaCenter, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));\n\n    vec2 direction;\n    direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));\n    direction.y =  ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));\n\n    float dirReduce = max(\n        (lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (0.25 * reduceMult),\n        reduceMin);\n    float rcpDirMin = 1.0/(min(abs(direction.x), abs(direction.y)) + dirReduce);\n    \n    direction = min(vec2( spanMax,  spanMax),\n          max(vec2(-spanMax, -spanMax),\n          direction * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + direction * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + direction * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + direction * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n// \"Airy disc\" bloom, complete gibberish and not based on anything physical; I just like the way it looks.\nvec4 getBloom(sampler2D sceneTexture, vec2 uv, vec2 resolution, float seed, float aspectRatio)\n{ \n    vec2 randomSeed = (uv*resolution * .152 + seed);\n    float random = hash12(randomSeed)*PI*2.0;\n\n    float stepsCenter = 7.0;\n    float stepsRing = 6.0;\n    float mipLevel = log2(resolution.x)/2.25;\n    vec4 outColor = vec4(0);\n    \n    float bloomSum = 0.0;\n    float weight = 0.0;\n    float totalBloom = 0.0;\n\n    vec2 radius = vec2(bloomRadius);\n    radius.y *= aspectRatio;\n\n    vec2 offsetUv = uv;\n    \n    for(float j = 1.0; j < (stepsCenter + 1.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsCenter + 1.0), 0.75))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 1.0;\n        \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsCenter), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    radius *= 2.0;\n    \n    for(float j = 2.0; j < (stepsRing + 2.0); j++)\n    {   \n        offsetUv = uv + (radius*pow(j/(stepsRing + 2.0), 0.25))*vec2(sin(j*goldenAngle+random), cos(j*goldenAngle+random));\n\n        weight = 0.5;\n       \n        vec4 colorFringe = 6.0*vec4(1.0, 0.25, 0.7, 1.0) * HUE(mod((0.2 + 0.3*j/stepsRing), 1.0));\n        \n        outColor += weight*colorFringe*textureLod(sceneTexture, offsetUv, mipLevel);\n        totalBloom += weight;\n    }\n    \n    return outColor/totalBloom;\n}\n\nvec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)\n{\n    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);\n    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);\n    \n    vec3 x = clamp(graded.xyz,0.0001,0.999);\n    \n    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);\n}", "buffer_b_code": "// Final indirect light \n//\n// Makes use of what we computed in Buffer A.\n// Recalculates screen space normals (they couldn't be stored properly in the buffer packing scheme without precision issues).\n\n// Recalculate world position from depth, texture coordinate for reconstructing normal\n// TODO optimize, or use a simpler camera projection\nvec3 reCalcWorldPosition(vec2 uv)\n{\n    vec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n    ray currentRay;\n    \n    // Current frame ray direction, camera ray and direction must match Buffer A\n\n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n    mouseLocation += iTime/9.0;\n    #endif\n\n    #ifdef INTERACTIVE\n    mouseLocation += 0.002*iMouse.x;\n    #endif\n\n    currentRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    currentRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    currentRay.direction.xyz = normalize(currentRay.direction.xzy); \n\n    \n    // Recover world position of current frame intersection point from ray direction\n    float pixelDepthForReprojection = UDEPTH(uv*iResolution.xy)*depthScale;\n    return (currentRay.direction)*pixelDepthForReprojection + currentRay.origin;\n}\n\n// Reconstructs screen space normal for deferred rendering. Bad.\nvec3 reCalcNormalFast(vec2 uv)\n{\n    float offsetPixel = 1.0;\n    \n    vec3 center = reCalcWorldPosition(uv);\n    \n    // Only sample two points, but vary which ones per frame in the hopes that temporal AA will smooth out artifacts\n    if(iFrame % 4 == 0)\n    {\n        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));\n        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));\n    \n        return normalize(cross(up-center, center-right));\n    }\n    else if(iFrame % 4 == 1)\n    {\n        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));\n        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(center-down, left-center));\n    }\n    else if(iFrame % 4 == 2)\n    {\n        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));\n        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(up-center, left-center));\n    }\n    else\n    {\n        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));\n        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));\n\n        return normalize(cross(center-down, center-right));\n    }\n}\n\n// Reconstructs normal for deferred rendering using distance function. Slow.\nvec3 reCalcNormalSlow(vec2 uv)\n{\n    float offsetPixel = 1.0;\n    vec3 center = reCalcWorldPosition(uv);\n    return calcNormal(center);\n}\n\n// Get the indirect lighting from a \"virtual point light\" as stored in Buffer A\nvec3 getVirtualLightContribution(vec2 uv, vec2 offsetUv, vec3 baseColor, float roughness, vec3 camHitNormal, vec3 camHitPosition, out float dotProduct, out float brdfRef)\n{\n    // Avoid hotspots from lights nearly touching geometry\n    float minDistance = 0.2;\n    \n    vec3 lightPosition = UBOUNCE_POSITION(offsetUv*iResolution.xy).xyz*depthScale;\n    \n    // Diffuse\n    float diffuse = saturate(dot(normalize(camHitNormal), normalize(lightPosition - camHitPosition)))*0.9;\n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n    \tmouseLocation += iTime/9.0;\n    #endif\n\n    #ifdef INTERACTIVE\n    \tmouseLocation += 0.002*iMouse.x;\n    #endif\n    vec3 camOrigin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    float specular = GGX(normalize(camHitNormal), -normalize(camHitPosition - camOrigin), normalize(lightPosition - camHitPosition), roughness, 0.1);\n    \n    \n    float lightDistance = max(distance(lightPosition, camHitPosition), minDistance);\n    float lightDistance2 = lightDistance*lightDistance;\n    dotProduct = dot(reCalcNormalFast(uv), reCalcNormalFast(offsetUv));\n    \n    brdfRef = diffuse + specular;\n    \n    return ((UBOUNCE_COLOR(offsetUv*iResolution.xy).rgb))/lightDistance2;\n}\n\n// This is where we accumulate the \"point lights\" from neighboring pixels that we stored in Buffer A\n// Requires some ad hoc corrections since this causes us to miss some occlusion/shadows, but since everything is localized to nearby pixels it works pretty OK?\nvec3 accumulateLights(vec2 uv)\n{\n    int steps = 32;\n    vec2 radius = max(vec2(.01), 13.0/iResolution.xy);\n    const float goldenAngle = 2.4;    \n    \n    float depth = UDEPTH(uv*iResolution.xy)*depthScale;\n    vec3 baseColor = UBASE_COLOR(uv*iResolution.xy)/hdrScale;\n    vec3 camHitNormal = reCalcNormalSlow(uv);\n    vec3 camHitPosition = reCalcWorldPosition(uv);\n    \n    vec2 offsetUv = uv;\n    vec3 sum = vec3(0);\n    float totalBlur = 0.0;\n    float weight = 1.0; \n    float dotProduct = 1.0;\n    float brdfRef = 1.0;\n    // Counterproductive to apply pixel jitter to low-discrepency points...\n    //float seed = nrand(uv*iResolution.xy + vec2(mod(iTime*131.5,4096.0), mod(iTime*535.1,4096.0)));\n    float seed = hash11(mod(iTime*33.1, 1024.0));\n    mat2 rot = ROT(mod(seed, 2.0*PI));\n    \n    #ifdef ROUGHNESS_MAP\n    \tfloat roughness = saturate(pow(triPlanarMapCatRom(iChannel2, 5.0, camHitNormal, camHitPosition*7.0, iChannelResolution[2].xy), vec3(2.0)).r*2.0);\n    #else\n    \tconst float roughness = 0.4;\n    #endif\n    \n    // Start with \"correct\" GI contribution (i.e. the path that was actually sent for this pixel)\n    sum += getVirtualLightContribution(uv+0.0, uv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);\n    sum *= brdfRef;\n    totalBlur += 1.0;\n  \n    for(float i = 0.0; i < float(steps); i++)\n    {       \n        // Rotated Hammersley disc kernel\n        //offsetUv = uv + ((hammersleyDisk(int(i), steps)))*radius*rot;\t\n        // Spiral kernel\n        offsetUv = uv + (radius*pow(((i+1.0)/float(steps)), 0.5))*vec2(sin(mod((i+1.0)*goldenAngle+seed, 2.0*PI)), cos(mod((i+1.0)*goldenAngle+seed, 2.0*PI)));\n\n        dotProduct = 1.0;\n        vec3 sampledIndirect = getVirtualLightContribution(uv, offsetUv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);\n        float sampledDepth = UDEPTH(floor(offsetUv*iResolution.xy))*depthScale;\n\n        // TODO magic numbers\n        weight = 1.0;\n        \n        // Add hoc occlusion part 1\n        #ifdef INDIRECT_GATHER_CHECK_DIRECTION\n        \tif((dotProduct < 0.7) || distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)\n        #else\n            if(distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)\n        #endif\n        {\n            weight = 0.0;\n        }\n        \n        // Ad hoc occlusion part 2\n        float curOcclusion = saturate(200000.0*(depth-sampledDepth-0.03));\n        weight *= saturate(1.0-curOcclusion);\n\n        sum += brdfRef*sampledIndirect*weight;\n        totalBlur += weight;\n    }\n    \n    // Fade into shadow when we don't have good sample coverage\n    sum *= smoothstep(1.0, 2.0, totalBlur);\n    \n    return hdrScale*(baseColor*sum)/totalBlur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 baseColor = UBASE_COLOR(fragCoord)/hdrScale;\n    vec3 indirectLight = accumulateLights(uv);\n    #ifdef CLAMP_INDIRECT\n\t    indirectLight = min(indirectLight, vec3(hdrScale/2.0));\n    #endif\n    float depth = UDEPTH(fragCoord);\n    \n    float currentDepthMin = 100000.0;\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,0))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,0))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(0,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(0,-1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(1,-1))*1.0, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoord+vec2(-1,-1))*1.0, currentDepthMin);\n    \n    fragColor = vec4(indirectLight, pow(currentDepthMin, 1.0/depthDistributionExponent));\n}", "buffer_b_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Temporal AA / denoise\n//\n// Lots more terrible ad hoc corrections to reduce ghosting, \"fireflies\" etc.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvAspectCorrected = vec2(uv.x*(iResolution.x/iResolution.y), uv.y);\n       \n    vec2 fragCoordDejittered = fragCoord;\n    vec2 uvDejittered = uv;\n    \n    vec3 currentDirect = UDIRECT_ILLUMINATION(fragCoordDejittered).rgb*hdrScale;\n    currentDirect = max(vec3(0), currentDirect);\n    \n    vec3 currentIndirect = vec3(0);\n    \n    currentIndirect = UBOUNCE_LIGHT(fragCoordDejittered).rgb*hdrScale;\n    currentIndirect = max(vec3(0), currentIndirect);\n    currentIndirect = clamp(currentIndirect, vec3(0.0001), vec3(hdrScale));\n       \n    float currentDepth = UDEPTH(fragCoordDejittered)*depthScale;\n    \n    float currentDepthMax = 0.0;\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,0))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,0))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(0,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(0,-1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(1,-1))*depthScale, currentDepthMax);\n    currentDepthMax = max(UDEPTH(fragCoordDejittered+vec2(-1,-1))*depthScale, currentDepthMax);\n\n    float currentDepthMin = 100000.0;\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,0))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,0))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(0,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(0,-1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(1,-1))*depthScale, currentDepthMin);\n    currentDepthMin = min(UDEPTH(fragCoordDejittered+vec2(-1,-1))*depthScale, currentDepthMin);\n    \n    float oldDepthMax = 0.0;\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,0)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,0)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(0,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(0,-1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(1,-1)), oldDepthMax);\n    oldDepthMax = max(UDEPTH_CHANNEL1(fragCoord+vec2(-1,-1)), oldDepthMax);\n\n\n    float oldDepthMin = 100000.0;\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,0)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,0)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(0,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(0,-1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(1,-1)), oldDepthMin);\n    oldDepthMin = min(UDEPTH_CHANNEL1(fragCoord+vec2(-1,-1)), oldDepthMin);\n    \n    ray currentRay;\n    // Current frame ray direction, camera ray and direction must match Buffer A\n    \n    \n    float mouseLocation = 0.1;\n    #ifdef ANIMATE_CAMERA\n\t    mouseLocation += /*0.01*iMouse.x+*/ + iTime/9.0;\n    #endif\n    \n    #ifdef INTERACTIVE\n\t    mouseLocation += 0.002*iMouse.x;\n    #endif\n  \n    currentRay.origin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );\n    currentRay.direction = stereographicPlaneToSphere((vec2(uvAspectCorrected) - 0.5)/1.5);\n    currentRay.direction.xyz = normalize(currentRay.direction.xzy); \n\n    // Recover world position of current frame intersection point from ray direction\n    float pixelDepthForReprojection = UDEPTH(uv*iResolution.xy)*depthScale;\n    vec3 currentWorldPosition = normalize(currentRay.direction)*pixelDepthForReprojection*2.0 + currentRay.origin;\n\n    // Previous frame data\n    vec3 prevRayOrigin = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    vec3 prevWorldPosition = currentWorldPosition+(currentRay.origin - prevRayOrigin);\n    vec3 prevRayDirection = prevWorldPosition-prevRayOrigin;\n    float prevPixelDepth = length(prevRayDirection);\n    prevRayDirection = normalize(prevRayDirection);\n    \n    // Find warped UV coords based on world space position of this pixel at previous frame\n    prevRayDirection.xzy = prevRayDirection.xyz;\n    vec2 prevUv = stereographicSphereToPlane(normalize(prevRayDirection))*1.5 + 0.5;\n    prevUv = vec2(prevUv.x/(iResolution.x/iResolution.y), prevUv.y);\n       \n    // Store temporal reprojection parameters\n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store latest camera pos for reprojection\n        fragColor.xyz = currentRay.origin;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Copy second-latest camera pos for reprojection\n        fragColor.xyz = texelFetch(iChannel1, ivec2(0,0), 0).xyz;\n        return;\n    }\n    \n    // Sample history color with Catmull-Rom filter\n    // since bilinear results in too much blurring from repeated re-sampling of reprojected history\n    vec3 oldColor = textureLod(iChannel1, prevUv, 0.0).rgb;\n    vec3 oldColorSharp = SampleTextureCatmullRom(iChannel1, prevUv, iChannelResolution[1].xy, 0.0, 0).rgb;\n   \n    // HW filtering is fine for depth\n    float oldDepth = textureLod(iChannel1, prevUv, 0.0).w*depthScale;\n    \n    bool offscreen = false;\n    float mixWeight = 0.0;\n    \n    // Don't read offscreen pixels or region reserved for non-color (camera) data\n    vec2 borderPadding = 1.0*vec2(1.0/(ceil(iResolution.x)), 1.0/(ceil(iResolution.y)));\n    if(prevUv.x <= borderPadding.x || prevUv.y <= borderPadding.y || prevUv.x >= 1.0 - borderPadding.x || prevUv.y >= 1.0 - borderPadding.y ||\n       (floor(prevUv.y*iResolution.y) <= 1.0 && floor(prevUv.x*iResolution.x) <= 10.0))\n    {\n        offscreen = true;\n    }\n\t\n    // TODO dilate motion vector, i.e. take longest in neighborhood?\n    // BUG for some reason this seems to behave differently based on overall distance to camera -- precision issue?\n    mixWeight = max(0.0,(50.0*(sqrt(currentDepth)-sqrt(oldDepth)-0.01)));\n    //mixWeight += saturate(200.0*(currentDepth-oldDepth));\n    mixWeight = (mixWeight + 0.04);\n\n    vec2 biasUv = vec2(0);\n   \t\n    mixWeight = saturate(mixWeight);\n\n    // Don't use Catmull-Rom for newly-unoccluded regions since they are extremely noisy\n    if(mixWeight < 0.1 && !offscreen)\n    {\n        oldColor = oldColorSharp;\n    }\n    \n    if(offscreen)\n    {\n       mixWeight = 1.0;\n    }\n    \n    #ifdef CLAMP_INDIRECT      \n        vec3 blurredGi1 = textureLod(iChannel2, uvDejittered, 1.5).rgb*hdrScale;\n        currentIndirect = min(currentIndirect, blurredGi1 + 0.01);\n        currentIndirect = max(currentIndirect, blurredGi1 - 0.02);\n\n        vec3 blurredGi2 = textureLod(iChannel2, uvDejittered, 2.5).rgb*hdrScale;\n        currentIndirect = min(currentIndirect, blurredGi2 + 0.03);\n        currentIndirect = max(currentIndirect, blurredGi2 - 0.04);\n\n        if(mixWeight > 0.15 || offscreen)\n        {\n            // Blur indirect pixels more when we don't have history data\n            vec3 blurredGi3 = textureLod(iChannel2, uvDejittered, 4.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi3 + 0.005);\n            currentIndirect = max(currentIndirect, blurredGi3 - 0.04);\n\n            vec3 blurredGi4 = textureLod(iChannel2, uvDejittered, 5.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi4 + 0.01);\n            currentIndirect = max(currentIndirect, blurredGi4 - 0.08);\n\n            // For debugging. Also happens to look neat.\n            //currentIndirect = vec3(1,0,0);\n        }\n        else\n        {\n            vec3 blurredGi5 = textureLod(iChannel2, uvDejittered, 4.5).rgb*hdrScale;\n            currentIndirect = min(currentIndirect, blurredGi5 + 0.08);\n            currentIndirect = max(currentIndirect, blurredGi5 - 0.1);\n        }\n    #endif\n    \n    //currentDirect += bloomIntensity*getBloom(iChannel1, prevUv, iChannelResolution[0].xy, mod(iTime*139.8 + iMouse.x, 4096.0), bokehAspectRatio*iResolution.x/iResolution.y).rgb;\n       \n    vec3 combinedColor = mix(oldColor, currentDirect + currentIndirect, mixWeight);\n    \n    if(currentDepth >= maxDepth - 0.01)\n    {\n        vec3 sunDirection = initialSunDirection;\n        vec3 sunColor = initialSunColor;\n        #ifdef ANIMATE_SUN\n            sunDirection.yz *= ROT(mod(iTime*0.05, PI*2.0));\n            sunDirection.xy *= ROT(sin(mod(iTime*0.025, PI*2.0)));\n            // \"moon\"\n            if (sunDirection.y <= 0.0)\n            {\n                float colorMix = smoothstep(0.0, -0.2, sunDirection.y);\n                if(sunDirection.y <= -0.2)\n                {\n                    sunDirection.y += 0.2;\n                    sunDirection.y *= -1.0;\n                    sunDirection.y -= 0.2;\n                }\n                sunColor = mix(sunColor, moonColor, colorMix);\n            }\n        #endif\n\n        combinedColor.rgb = getSky(currentRay, sunDirection, sunColor);\n    }\n    \n    combinedColor = clamp(combinedColor, vec3(0.0001), 2.0*vec3(hdrScale));\n\n\n\n    // For debugging\n    //float minMaxVisualize = distance(currentDepthMin, oldDepthMin) + distance(currentDepthMax, oldDepthMax);\n \n    float combinedDepth = currentDepth/depthScale;\n    \n    // For debugging\n    //fragColor = vec4(vec3(minMaxVisualize), combinedDepth);\n    //fragColor = vec4(vec3(mixWeight), combinedDepth);\n    //fragColor = vec4(vec3(biasUv, 0.0), combinedDepth);\n    //fragColor = vec4(vec3(distance(oldDepthMax, oldDepthMin)), combinedDepth);\n    //fragColor = vec4(vec3(distance(currentDepthMax, currentDepthMin)), combinedDepth);\n    //fragColor = vec4(blurGi(uv), combinedDepth);\n    //fragColor = vec4(currentDirect + currentIndirect, combinedDepth);\n    \n    fragColor = vec4(combinedColor, combinedDepth);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Bokeh with fake color fringing + autofocus, anamorphic (including realistic \"swirly\" artifacts near edges)\n//\n// Ended up quite hairy/hacky from to trying to avoid edge/background bleed artifacts, but works pretty well.\n// I originally wanted to do a separable version but didn't have enough buffers left, so it's fairly slow.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 randomSeed = (fragCoord * .152 + iTime * 1500. + iMouse.x);\n    float random = hash12(randomSeed)*PI*2.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float depth = textureLod(iChannel0, uv, 0.0).w*depthScale;\n        \n    // Autofocus\n    float focalDepth = texelFetch(iChannel1, ivec2(0), 0).w;\n    float focalDepthNew = min(min(min(textureLod(iChannel0, vec2(0.5, 0.25), 5.5).w*depthScale, textureLod(iChannel0, vec2(0.6, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.4, 0.5), 6.5).w*depthScale), textureLod(iChannel0, vec2(0.5, 0.5), 8.0).w*depthScale);\n    focalDepth = mix(focalDepth, focalDepthNew, 0.05);\n    \n    vec2 offsetUv = vec2(0);\n    vec4 foregroundColor = vec4(0);\n    vec4 backgroundColor = vec4(0);\n    vec4 midgroundColor = vec4(0);\n    vec4 midgroundColorNoFringe = vec4(0);\n    vec4 totalColor = vec4(0);\n    \n    const float steps = 32.0;\n    const float stepsSmooth = 24.0;\n    \n    vec2 radiusClamp = vec2(bokehClamp);\n    radiusClamp.y *= iResolution.x/iResolution.y;\n    \n    // Radius of circle of confusion based on depth at current pixel\n    vec2 trueRadius = vec2(bokehScale);\n    trueRadius.y *= iResolution.x/iResolution.y;\n    trueRadius *= 1.0-focalDepth/depth;\n  \n    vec2 erodedRadius = vec2(1);\n    vec2 smoothedRadius = vec2(0);\n    \n    const float additionalDilation = 1.25;\n    const float searchMipLevel = 0.0;\n    \n    // Preprocess, estimate kernel size etc.\n    for(float i = 0.0; i < stepsSmooth; i++)\n    {   \n        vec2 searchRadius = additionalDilation/**vec2(1.0/bokehAspectRatio, 1)*/*(radiusClamp*pow((i)/steps, 0.5));\n        offsetUv = uv + searchRadius*vec2(sin(i*goldenAngle/* + random*/), cos(i*goldenAngle/* + random*/));\n        \n        float depthGathered = textureLod(iChannel0, offsetUv, searchMipLevel).w*depthScale;\n\n        vec2 radiusGathered = vec2(bokehScale);\n        radiusGathered.y *= iResolution.x/iResolution.y;\n        radiusGathered *= 1.0-focalDepth/depthGathered;\n        \n        if(length(radiusGathered) >= length(radiusClamp))\n        {\n            radiusGathered = radiusClamp;\n        }\n        \n        smoothedRadius += abs(radiusGathered);\n        erodedRadius = min(abs(radiusGathered), erodedRadius);\n    }\n    smoothedRadius /= stepsSmooth;\n    \n    // Main blur\n    // Limited radius\n    vec2 radiusBias = vec2(bokehForceSharp);\n    radiusBias.y *= iResolution.x/iResolution.y;\n    vec2 radius = max(vec2(0), smoothedRadius-radiusBias);\n    radius /= (1.0-bokehForceSharp);\n    \n    float totalBlur = 0.0;\n    bool fringeValid = true;\n    \n    // Try to sample from lower-res mips to reduce noise, but don't want to go too low and introduce any visible blockiness\n    float mipLevel = min(max(log2(length(erodedRadius*iResolution.xy/3.0))+0.5, 0.0), max(log2(length(min(smoothedRadius, trueRadius)*iResolution.xy/3.0))-1.5, 0.0));   \n    mipLevel = min(mipLevel, 2.0);\n  \n    vec4 currentColor;\n    vec4 colorFringed;\n    float falloff = 1.0;\n    float vignette = 1.0;\n    if(length(radius) > 1.0/length(iResolution.xy))\n    {\n        for(float i = 0.5; i < steps; i++)\n        {   \n            vec2 offset = (radius*pow(i/steps, 0.5))*vec2(sin(i*goldenAngle + random), cos(i*goldenAngle + random));\n            \n            // \"Swirly\" bokeh\n            offset *= ROT(atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)-PI);\n            if(offset.y >= radius.y-3.0*(radius.y)*distance(uv, vec2(0.5)))\n            {\n                vignette = saturate(offset.y - (radius.y-3.0*(radius.y)*distance(uv, vec2(0.5))));\n                vignette = saturate(1.0 - 0.8*vignette/radius.y);\n                vignette = saturate(0.0001 + vignette);\n                offset.y /= 1.0+saturate(1.0-vignette)/2.0;\n                \n            }\n            offset *= ROT(-atan((uv.x-0.5)/(iResolution.y/iResolution.x), uv.y-0.5)+PI);\n\n            offset *= vec2(1.0/bokehAspectRatio, 1);\n            \n            offsetUv = uv + offset;\n\n            falloff = ((i+1.0)/steps);\n\n            // Using dilated depth to reduce bleed\n            float depthGathered = textureLod(iChannel2, offsetUv, 0.0).w*depthScale;\n\n            vec2 radiusGathered = vec2(bokehScale);\n            radiusGathered.y *= iResolution.x/iResolution.y;\n            radiusGathered *= 1.0-focalDepth/depthGathered;\n            radiusGathered *= vec2(1.0/bokehAspectRatio, 1);\n          \n            float distanceFromCenter = distance(offsetUv, uv);\n\n            if((depthGathered > depth && length(trueRadius) < bokehScale/6.0 /*&& length(radiusGathered) > length(trueRadius)*/))\n            {\n                float factor = smoothstep(bokehScale/80.0, bokehScale/6.0, length(trueRadius));\n                offsetUv = mix(uv, offsetUv, factor);\n            }\n            float curMipLevel = mipLevel;\n            currentColor = textureLod(iChannel0, offsetUv, mipLevel);\n            colorFringed = currentColor * 12.1*vec4(1.0, 0.16, 0.3, 1.0) * HUE(mod((0.2 + 0.3*float(i)/float(steps-1.0)), 1.0)) * falloff;\n            totalBlur += 1.0*vignette;\n\n            // Is the sample we gathered at a depth such that it would actually be scattered onto the current pixel?\n            if((length(radiusGathered) < distanceFromCenter*0.66))\n            {\n                fringeValid = false;\n                currentColor = vec4(0,0,0,1);\n                colorFringed = vec4(0,0,0,1);\n                totalBlur -= 1.0*vignette;\n            }\n             \n            midgroundColor += mix(currentColor, colorFringed, bokehFringe)*vignette;\n            midgroundColorNoFringe += currentColor*vignette;\n        }\n        // If we rejected some samples, the color fringe would become biased\n        if(!fringeValid)\n        {\n            midgroundColor = midgroundColorNoFringe;\n        }\n        else\n        {\n            midgroundColor = mix(midgroundColorNoFringe, midgroundColor, smoothstep(0.0, 4.0/length(iResolution.xy), length(radius)));\n        }\n        if(totalBlur > 0.0)\n        {\n\t        midgroundColor /= totalBlur;\n        }\n        else\n        {\n            midgroundColor = textureLod(iChannel0, uv, 0.0);\n        }\n    }\n    else\n    {\n        midgroundColor = textureLod(iChannel0, uv, 0.0);\n        // For debugging\n        //midgroundColor = vec4(1,0,0,1)*textureLod(iChannel0, uv, 0.0)*steps;\n    }\n    \n    totalColor += midgroundColor;\n    \n    // Bloom\n    totalColor += bloomIntensity*getBloom(iChannel0, uv, iChannelResolution[0].xy, mod(iTime*13.8 + iMouse.x, 1024.0), bokehAspectRatio*iResolution.x/iResolution.y);\n    \n    // Auto exposure\n    float exposure = texelFetch(iChannel1, ivec2(1, 0), 0).w;\n    float exposureNew = length(textureLod(iChannel0, vec2(0.5, 0.5), 8.0).rgb)*3.0 + 0.5;\n    exposure = mix(exposure, exposureNew, 0.05);  \n    exposure = max(exposure, 0.0) + 0.001;\n    totalColor /= exposure;\n\n    float outAlpha = 0.0;\n    \n    if(ivec2(fragCoord) == ivec2(0,0))\n    {\n        // Store focal depth\n        fragColor.w = focalDepth;\n        return;\n    }\n    if(ivec2(fragCoord) == ivec2(1,0))\n    {\n        // Store exposure\n        fragColor.w = exposure;\n        return;\n    }\n    \n    fragColor = vec4(totalColor.rgb, fragColor.w);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 77, 103, 103, 203]], "test": "untested"}
{"id": "tt3fRr", "name": "Day 411", "author": "jeyko", "description": "pot", "tags": ["mdtmjvm"], "likes": 6, "viewed": 365, "published": 3, "date": "1612111745", "time_retrieved": "2024-07-30T19:41:22.630511", "image_code": "// Fork of \"Day 408\" by jeyko. https://shadertoy.com/view/WlKyW3\n// 2021-01-31 09:55:41\n\n// thx to wyatt for teaching me storing voronoi particle tracking stuff in different buffers and packing!\n\n// cyclic noise by nimitz\n\n// int packing from somewhere on shadertoy\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 pPntr = T1(U);\n    vec4 p = T(pPntr.xy);\n    vec2 pos = unpackU16(p.x);\n    \n    C = texture(iChannel0,U/R);\n    \n        \n    C.xyz *= vec3(1.4,0.5,0.4);\n        \n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    //C *= 1. - smoothstep(0.3,0.,pow( cyclicNoisePap(vec3(uv*90.,1.),false,0.),1.))*0.5;\n    \n    \n    C = 1. - C*2.5;\n    \n    \n    C = max(C,0.);\n    C = pow(C,vec4(0.4545));  \n    //C -= texture(iChannel3,U/R);\n    \n    //C = texture(iChannel2,U/R);\n    \n    //C *= 1. - smoothstep(0.,1.,dot(uv,uv))*0.;\n\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ------------------------------- //\n//           Movement              //\n// ------------------------------- //\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\n//#define steps  floor(particleSz*iResolution.x*8.)\n\nfloat steps = 20.;\nfloat stepSz = 2.;\nvoid findNeighbors( vec4 me, vec2 mePos, vec2 dir){\n\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( mePos.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        \n        //if ( otherP.x != me.x){\n        //if ( unpackU16(otherP.x) != me.xy ){\n        if ( unpackU16(otherP.x).x != mePos.x && unpackU16(otherP.x).y != mePos.y ){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3){\n        \n        float pc = floor(sqrt(particleCount));\n        vec2 id = floor(U/R*pc) + 0.0001;\n        vec2 cellSz = R/(pc + 1.);\n        \n        vec2 pos = id*cellSz/R + cellSz/R;\n\n        vec2 vel = r24(id).xy*2. - 1.;\n\n        C.x = packU16(pos);\n        C.y = packS8(vel.xyxy);    \n        C.z = packU8(r24(id));\n        \n    } else {\n        C = T(U);\n        \n        vec4 pPtr = T1(C.xy*R);\n        \n        if (iFrame > startOffs){\n            \n            //C = T( pPtr.xy );\n            \n            vec2 pos = unpackU16(C.x);\n            vec2 vel = unpackS8(C.y).xy;\n            vec4 data = unpackU8(C.z);\n    \n            \n            findNeighbors( C, pos, vec2(1,0));\n            findNeighbors( C, pos, vec2(-1,0));\n            findNeighbors( C, pos, vec2(0,1));\n            findNeighbors( C, pos, vec2(0,-1));\n            \n            findNeighbors( C, pos, vec2(1,1));\n            findNeighbors( C, pos, vec2(1,-1));\n            findNeighbors( C, pos, vec2(-1,1));\n            findNeighbors( C, pos, vec2(-1,-1));\n            \n\n            //  collisions\n            for(int i = 0; i < neighborsCnt; i++){    \n                vec4 otherPtr = neighborPtrs[i];\n                vec4 other = T(otherPtr.xy);\n                vec2 otherVel = unpackS8(other.y).xy;\n                vec4 otherData = unpackU8(other.z);\n                \n                other.xy = unpackU16(other.x);\n                vec2 meToOther = (other.xy - pos.xy)*resFact.xy;\n                \n                //pos -= normalize(meToOther)*(abs(distBetween - sizes));\n                  \n                vel -= 11.*normalize(meToOther)*smoothstep(0.04,0.,length(meToOther));\n                \n\n\n\n            }\n            \n            \n            vec2 meToMouse = iMouse.xy/iResolution.xy-pos;\n            meToMouse *= resFact;\n            \n            if(iMouse.z > 0.)\n                vel -= 1.*normalize(meToMouse)*smoothstep(0.34,0.,length(meToMouse));\n                \n        \n            if (abs(pos.x - 0.5) > 0.5 - particleSz*0.5){\n                vel.x *= -1.;\n                if ( sign(vel.x) != sign(-pos.x + 0.5) )\n                    vel.x *= -1.;\n            }\n            if (abs(pos.y - 0.5) > 0.5 - particleSz*0.5){\n                vel.y *= -1.;\n                if ( sign(vel.y) != sign(-pos.y + 0.5) )\n                    vel.y *= -1.;            \n            }\n\n            \n            //vel.y -= 0.03;\n            //float n = cyclicNoise(vec3( pos/resFact*0.5, iTime*0.5), false, iTime*0.2);\n            vec3 n = texture(iChannel3,pos).xyz;\n            /*\n            if (iFrame > 0)\n                vel = mix(vel,n.yz*110.5,0.1 + data.y*0.6);\n            */\n            float lvel = length(vel);\n            vel = mix(vel,n.yz*110.5,0.0 + data.y*0.2);\n            \n            vel = normalize(vel)*lvel;\n            \n            //float dfn = fwidth(n);\n            \n            \n            //vel *= rot(n.x); \n            \n            //vel = length(vel);\n            //vel = vel*rot(atan(n.y,n.z)/pi);\n            \n            //vel *= rot(0.05 + sin(iTime*0.4 + data.x)*0.4); \n            \n            //vel *= rot(((n)*2. - 1.)*0.2);\n            \n            //vel = vel*rot(atan(dNoise.y,dNoise.x)*120.);\n            //vel = mix(vel, *length(vel), 0.1);\n            pos += vel/resFact*0.004;\n            \n            \n            C.x = packU16(pos);\n            C.y = packS8(vel.xyxy);\n            //C.x = packSnorm(vec4(pos,vel));\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R (iResolution.xy)\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n#define TF(u)  texelFetch(iChannel0,ivec2(u), 0)\n#define TF1(u) texelFetch(iChannel1,ivec2(u), 0)\n#define TF2(u) texelFetch(iChannel2,ivec2(u), 0)\n#define TF3(u) texelFetch(iChannel3,ivec2(u), 0)\n\n#define pi acos(-1.)\n\n#define startOffs 5\n\n\n#define particleCount 1432.\n\n#define particleSz 0.001\n\n//#define getSize(idx) particleSz*(sin(idx*26. + iTime)*0.5 + 0.5)\n#define getSize(idx) particleSz\n\n\n#define resFact vec2(R.x/R.y,1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define getIdx(a) vec2(mod(a,R.x), floor((a+R.x)/R.x)-1.)\n\n// 8bit\nhighp uint packU8(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackU8(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packU8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackU8(float a) { return vec4(unpackU8(floatBitsToUint(a))) / 255.; }\nfloat packS8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackS8(float a) { return clamp((vec4(unpackU8(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n\n// 16bit\nhighp uint packU16(highp uvec2 a) {\n    return uint( (a.x << 16)\n               | (a.y << 0)); }\nmediump uvec2 unpackU16(highp uint a) {\n    return uvec2( (a & 0xFFFF0000u) >> 16\n                , (a & 0x0000FFFFu) >> 0   ); }\nfloat packU16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec2  unpackU16(float a) { return vec2(unpackU16(floatBitsToUint(a))) / (pow(2.,16.) - 1.); }\n\n\n\nvec4 r24(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(1.1);\n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 4;\n    \n    const float warp = 1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .1;\n    \n    vec3 seed = vec3(-2,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*5.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n", "buffer_b_code": "// ------------------------------- //\n//           Tracking              //\n// ------------------------------- //\n\nfloat steps = 15.;\nfloat stepSz = 2.;\nvoid findMe( inout vec4 pPntr, inout vec2 pos, vec2 U, vec2 dir){\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = T1(U + dir*i);\n        vec4 otherP = T(otherPntr.xy);\n        vec2 otherPos = unpackU16(otherP.x);\n        \n        if (length( (U/R - otherPos.xy)/resFact.yx ) < length( (U/R - pos.xy)/resFact.yx )){\n            pos = otherPos;\n            pPntr = otherPntr;\n        }\n        \n    }\n\n}\n        \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3) {\n        //C = r24(U);\n        C.xy = U;\n        C.zw -= C.zw;\n    } else {        \n        C = T1(U);\n        \n        if (iFrame < startOffs){\n            steps = 100.;\n        }\n        \n        \n        vec4 pPntr = C;\n        vec4 p = T(pPntr.xy);\n        vec2 pos = unpackU16(p.x);\n        \n        findMe(pPntr,pos,U,vec2(0,1));\n        findMe(pPntr,pos,U,vec2(0,-1));\n        findMe(pPntr,pos,U,vec2(1,0));\n        findMe(pPntr,pos,U,vec2(-1,0));\n        findMe(pPntr,pos,U,vec2(1,1));\n        findMe(pPntr,pos,U,vec2(1,-1));\n        findMe(pPntr,pos,U,vec2(-1,1));\n        findMe(pPntr,pos,U,vec2(-1,-1));\n        \n        C = pPntr;\n        \n        if (iFrame == startOffs-1){\n            C.zw = 1. + floor(r24(C.xy).xy*2.99);\n        }\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ------------------------------- //\n//           Painting              //\n// ------------------------------- //\n\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\nfloat steps = 1.;\nvoid findNeighbors( vec2 p, vec2 dir){\n    float stepSz = 1. + mod(float(iFrame),2.);\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( p.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        vec2 otherPos = unpackU16(otherP.x);\n        \n        // TODO: don't unpack here\n        if ( otherPos.x != p.x ){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nfloat sdSq(vec2 p, float s){p = abs(p) - s; return max(p.x,p.y);}\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    float pixelSize = dFdx(uv.x)*3.;\n    \n    vec4 mePntr = T1(U);\n    vec4 me = T(mePntr.xy);\n    \n    vec2 mePos = unpackU16(me.x);\n    vec4 meData = unpackU8(me.z);\n    \n    \n    C = texture(iChannel2,U/R);\n    findNeighbors( mePos, vec2(1,0));\n    findNeighbors( mePos, vec2(-1,0));\n    findNeighbors( mePos, vec2(0,1));\n    findNeighbors( mePos, vec2(0,-1));\n    \n    findNeighbors( mePos, vec2(1,1));\n    findNeighbors( mePos, vec2(1,-1));\n    findNeighbors( mePos, vec2(-1,1));\n    findNeighbors( mePos, vec2(-1,-1));\n    \n    for(int i = -1; i < neighborsCnt; i++){\n        vec4 otherPtr;\n        vec4 otherP;\n        if (i == -1){\n            otherPtr = mePntr;\n            otherP = me;\n        } else {\n            otherPtr= neighborPtrs[i];\n            otherP = T(otherPtr.xy);\n        }\n        \n        \n        vec2 pos = unpackU16(otherP.x);\n        vec4 data = unpackU8(otherP.z);\n    \n        float size = data.x;\n    \n    \n        //vec3 col = pal(0.5,vec3(0.5,1.6,0.5),vec3(5,1,1),5. + sin(data.z), 0. + data.w*6. + iTime); \n    \n        //vec3 col = pal(0.5,vec3(0.5,1.6,0.5),vec3(5,1,1),5. + sin(data.z), 0. + data.w*6. + iTime); \n        \n        vec3 col = pal(0.5,vec3(0.5,1.6,0.5),vec3(5,1,1),5. + sin(data.z), 0. + data.w*6. + iTime); \n    \n        col *= 0.9;\n        float dFill = length((pos.xy - uv)*resFact.xy) - getSize(size) ;\n        float dOutline = abs(dFill) - 0.0000;\n        \n        \n        C.xyz *= C.w;\n        C.xyzw = mix(C.xyzw,vec4(1),smoothstep(pixelSize*1.,0.,dFill));\n        \n        C.w *= 0.9995;\n        \n        \n        if (data.y >= meData.y){\n        \n        \n        }\n        //return;\n        //C = mix(C,pal(0.5,0.5,vec4(3,2,1,1.),1.,otherPtr.z*1.*14. + 0.*otherPtr.w ),smoothstep(dFdx(uv.x),0.,length((otherP.xy - uv)*resFact.xy) - particleSz));\n    }\n\n    \n    \n    if(iFrame < 4)\n        C = vec4(0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n// noise buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor.x = cyclicNoise(vec3(fragCoord/iResolution.y*6., iTime*0.5), false, iTime*0.05);\n    \n    fragColor.yz = vec2(dFdx(fragColor.x), dFdy(fragColor.x));\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3fRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 309, 309, 830]], "test": "untested"}
{"id": "WltBzn", "name": "milky way", "author": "YitingLiu", "description": "Composed a galaxy milky way. ", "tags": ["time", "blur", "sin", "rotate", "cos", "mask", "rect", "twist", "band", "tan", "range", "remap"], "likes": 1, "viewed": 296, "published": 3, "date": "1612107997", "time_retrieved": "2024-07-30T19:41:23.401450", "image_code": "float Band (float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n\n    return step1*step2;\n}\n\n// rectangle based on center, width, and height \nfloat Rect(vec2 uv, float center, float width, float height, float blur){\n    \n    float left = center-width/2.;\n    float right = center+ width/2.;\n    float top = center + height/2.;\n    float bottom = center - height/2.;\n    \n    float band1 = Band(uv.x,left, right, blur);\n    float band2 = Band(uv.y,bottom, top, blur);\n    return band1*band2;\n}\n\nfloat remap01(float a, float b, float t){\n    return (t-a)/(b-a);\n}\nfloat remap(float a, float b, float c, float d, float t){\n    return remap01(a,b,t)*(d-c)+c;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;// -0.5 <> 0.5\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=1.5;\n    // center\n    uv*=rotate2d(3.1415*iTime*0.22);\n\n    float mask = 0.;\n    float m = sin(iTime+uv.x*10.)*0.8;\n    float blur = remap(-0.5,0.5,0.01,0.25,uv.x);\n    \n    //uv.x/=m;\n    uv.y-=m;\n    \n    mask = Rect(uv,0.,0.9,0.8,blur/2.);\n    \n    uv*=rotate2d(100.+iTime/3.14);\n    mask += Rect(uv/2.,0.,0.6,0.2,blur/5.);\n    \n    uv*=rotate2d(100.+iTime/200.);\n    mask -= Rect(uv,0.,0.5,0.8,blur/5.);\n    \n    uv*=rotate2d(iTime/100.);\n    mask *= Rect(uv,0.,0.2,0.4,blur/5.);\n    \n    uv*=rotate2d(3.14*iTime);\n    mask -= Rect(uv,0.,0.2,0.8,blur/2.);\n\n    vec3 col = vec3(blur-abs(tan(iTime*0.8)),abs(iTime),cos(iTime))*mask;\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 194], [196, 245, 318, 318, 595], [597, 597, 638, 638, 664], [665, 665, 722, 722, 759], [761, 761, 789, 789, 875], [877, 877, 934, 934, 1723]], "test": "untested"}
{"id": "wt3fzr", "name": "Neural Shrek", "author": "michael0884", "description": "A full Shrek body. Why? idk\nTook quite a lot of messing around in Blender to get the model to a reasonable state for an SDF.", "tags": ["sdf"], "likes": 10, "viewed": 432, "published": 3, "date": "1612107878", "time_retrieved": "2024-07-30T19:41:24.175381", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy); \n    fragColor = tanh(2.5*col/col.w);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 128\n#define MIN_DIST 1e-5\n#define MAX_DIST 8.0\n#define CAM_ANGLE 1e-3\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//internal RNG state \nuvec4 s0; \n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat head(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.05) {\n        return length(p)-0.99;\n    }\n    //neural networks can be really compact... when they want to be\nvec4 f0_0=sin(p.y*vec4(3.961,-1.055,.942,-1.745)+p.z*vec4(-3.652,.014,1.165,-.429)+p.x*vec4(1.942,.792,1.952,1.660)+vec4(-.367,-.141,-3.792,-6.830));\nvec4 f0_1=sin(p.y*vec4(2.529,-4.504,2.663,-3.360)+p.z*vec4(4.109,2.845,-1.286,2.371)+p.x*vec4(.023,.405,2.693,-3.301)+vec4(-6.805,-3.142,-1.470,-4.338));\nvec4 f0_2=sin(p.y*vec4(.500,-.695,.545,-3.515)+p.z*vec4(3.386,-2.527,2.547,3.027)+p.x*vec4(-.797,3.892,-1.655,-.885)+vec4(4.197,-.751,-.436,4.761));\nvec4 f0_3=sin(p.y*vec4(-3.010,-1.425,-3.763,.533)+p.z*vec4(2.291,.672,-.767,3.361)+p.x*vec4(2.191,3.627,-3.553,-4.030)+vec4(1.739,-8.091,-1.897,3.300));\nvec4 f1_0=sin(mat4(.217,-.382,.023,.253,.651,-.992,.160,.523,-.033,.180,.588,.550,-.482,.592,-.479,-.036)*f0_0+\n    mat4(.504,.266,-.575,.005,-.777,.146,.153,.139,.380,.580,-.633,-.827,-.535,.487,-.511,-.998)*f0_1+\n    mat4(.347,.592,.316,.003,-.168,.734,-.340,-.376,-.047,-.455,-.560,-.208,-.204,.892,.111,-.027)*f0_2+\n    mat4(.780,-.439,.125,-.145,-.248,-.369,.032,.040,-.393,-.063,.044,-.014,.283,-.549,.161,.078)*f0_3+\n    vec4(2.504,.894,.837,-.731))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.167,-.277,.221,-.245,-.533,.157,-.853,-.326,.202,-.477,.088,-.208,-.259,.111,.476,.487)*f0_0+\n    mat4(-.007,.408,.223,-.730,-.181,.477,.653,-.170,-.096,-.083,-.057,-.061,-.386,.493,.130,-.442)*f0_1+\n    mat4(.168,-.548,.303,.394,.333,-.407,.667,.179,.590,.669,.626,-.536,-.543,.097,.404,-.592)*f0_2+\n    mat4(1.061,-.384,.322,.204,.093,-.226,.033,-.066,-.362,.308,.061,.370,-.037,.071,-.732,.220)*f0_3+\n    vec4(-3.142,2.644,.317,3.649))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.251,.101,-.205,-.090,1.331,.104,-1.553,-.331,-.761,.451,-.727,.306,-1.000,.466,.298,1.109)*f0_0+\n    mat4(-.467,.078,.810,-.177,-.111,.223,-.178,.133,.565,.216,.479,.318,.044,-.283,.034,-.358)*f0_1+\n    mat4(.702,-.135,.058,.494,.024,-.673,-.034,.294,-.054,.078,-.155,-.078,-.101,-.028,.262,-.344)*f0_2+\n    mat4(.233,.827,-.382,.588,.147,-.794,-.217,.308,.078,-.016,.274,-.317,.527,.080,-.224,-.233)*f0_3+\n    vec4(.653,-.422,-.349,.963))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.005,-.183,.111,.421,-.329,-.421,.314,.010,-.045,.287,.901,-.752,.388,.630,-.373,-.489)*f0_0+\n    mat4(-.461,-.053,.238,.357,-.067,-.163,.602,-.165,.661,-.231,.586,-.542,.348,-.087,.633,.205)*f0_1+\n    mat4(.055,.347,-.941,.262,.259,.607,-.093,.465,-.414,.063,-.294,.478,-.789,-.463,.147,-.117)*f0_2+\n    mat4(.481,.786,-.125,.187,.175,.355,-.415,.139,-.377,.024,.561,.486,.102,-.389,-.569,.292)*f0_3+\n    vec4(-1.498,.446,3.432,-3.483))/1.0+f0_3;\nvec4 f2_0=sin(mat4(-.182,-.330,-.610,.592,-.335,-.176,-.437,.512,.833,.251,-.306,-.177,.231,-.183,-.126,.660)*f1_0+\n    mat4(.418,.438,-.826,-.737,-.746,.271,.481,.671,.007,.163,-.178,-.827,.161,-.037,-.224,.303)*f1_1+\n    mat4(.414,-.416,.155,.128,.414,.179,-.572,-.316,-.092,-.526,-.254,.995,.734,-.700,-.622,.313)*f1_2+\n    mat4(-.662,.713,.156,-.232,-.519,-.006,-.406,.609,-.530,-.345,.185,.647,.417,-.025,-.428,.107)*f1_3+\n    vec4(-2.443,1.407,-2.546,.464))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.130,-.213,-.332,-.689,-.034,-.830,-.344,-.474,-.086,-1.701,-.525,-.114,-.451,-.162,.323,.599)*f1_0+\n    mat4(-.236,-.417,-.184,-.223,.085,-.411,-1.036,1.257,-1.102,.403,-.232,-.119,-.031,.017,.026,.170)*f1_1+\n    mat4(.010,.464,.270,-1.014,-.300,.076,-.501,-.565,1.190,.026,-.034,1.163,.647,.123,1.461,.661)*f1_2+\n    mat4(.059,.491,-.009,-.247,-.148,-.899,-1.048,.801,.100,.397,.096,.240,-.098,.067,.216,.485)*f1_3+\n    vec4(-1.128,1.700,-2.844,2.620))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.020,-.540,-.053,-.203,.238,-.314,-.187,-.288,-.034,-.215,.475,-.131,-.178,-.175,.009,.353)*f1_0+\n    mat4(-.483,-1.019,.669,-.115,.374,-.117,.416,-.134,-.154,.407,-.388,-.091,-.431,.462,-.227,.168)*f1_1+\n    mat4(.303,.291,.666,.098,-.023,.213,-.087,.376,.558,.195,-.468,.779,-.206,.886,.789,.742)*f1_2+\n    mat4(.453,.010,-.311,.083,-.120,-1.144,-.069,.018,-.128,.262,-.136,.407,.141,-.967,-.170,-.653)*f1_3+\n    vec4(-3.048,1.519,.624,-3.587))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.394,-.308,.031,-.340,-.841,-.308,-.496,-.355,-.768,.023,-.802,.693,.415,-.098,.722,-.834)*f1_0+\n    mat4(-.471,.276,.047,-.252,.668,.005,.003,.349,.012,.182,-.232,.872,.511,.027,.761,.564)*f1_1+\n    mat4(-.395,.246,-.477,-.452,-.502,-.296,-.391,.377,.655,-.024,.398,-.656,.239,.582,-.361,-.537)*f1_2+\n    mat4(-.383,.885,.686,-.136,-.383,-.726,-.599,-.199,.105,.014,.251,-.113,.763,-.089,.224,-.141)*f1_3+\n    vec4(3.311,-2.779,-2.553,2.737))/1.4+f1_3;\nvec4 f3_0=sin(mat4(-.403,-.396,-.704,-.058,.385,-.277,.629,.354,.400,.052,-.539,.018,-1.156,.768,-.012,.543)*f2_0+\n    mat4(.720,-.160,-.561,-.549,.614,.618,-.406,.173,.769,-.152,.421,-.076,-.288,.102,-.358,-.084)*f2_1+\n    mat4(.291,.328,.099,-.314,-.730,.092,-.027,-.065,-.446,-.082,.150,-.236,.078,-.121,.400,-.189)*f2_2+\n    mat4(-.370,-.360,-.676,-.254,.135,-.585,.845,-.415,.137,-.383,.340,.601,-.316,-.251,-.378,.996)*f2_3+\n    vec4(-2.431,1.731,-.416,3.801))/1.7+f2_0;\nvec4 f3_1=sin(mat4(-.170,.196,.714,-.426,-.137,.787,-.097,-.517,-.051,.364,.230,.362,-.074,.237,.303,.520)*f2_0+\n    mat4(-.242,.238,.206,-.202,.016,.239,-.128,-.163,-.138,1.177,.289,.738,-.641,.137,-.335,-.444)*f2_1+\n    mat4(.084,.031,.167,.199,.001,.120,-.723,-.458,-.896,.199,.055,-1.153,-.899,.041,.121,-.942)*f2_2+\n    mat4(.276,-.188,.421,-.338,-.571,.595,-.577,-.130,.256,.044,-.059,-.921,-.199,-.443,.839,-.005)*f2_3+\n    vec4(.916,1.803,-3.200,-.396))/1.7+f2_1;\nvec4 f3_2=sin(mat4(.647,.159,.207,-.030,1.136,.561,.002,.807,-.390,-.314,.588,.261,-.819,.210,.493,-.183)*f2_0+\n    mat4(-.158,-.872,-.572,.061,-.001,.657,-.281,-.572,-.263,-.076,.179,-.034,-.550,.522,.265,-.251)*f2_1+\n    mat4(.391,1.975,.285,.020,-.683,.213,.656,.144,-.288,-.322,-.171,.024,.324,-.410,.266,.186)*f2_2+\n    mat4(.196,-.746,-.460,.131,.003,.367,.089,-.616,.350,-.902,-.741,.013,-.042,.008,-.557,.849)*f2_3+\n    vec4(-2.677,2.979,2.418,2.764))/1.7+f2_2;\nvec4 f3_3=sin(mat4(-.114,.373,-.130,.123,-.699,-.598,-.938,.466,.247,.129,-.384,-.717,.462,-.645,-.069,.319)*f2_0+\n    mat4(-.365,.385,.452,-.195,-.019,.433,1.002,.019,.340,-.841,-1.044,-.450,.287,-.479,-.516,.439)*f2_1+\n    mat4(.512,-1.027,.083,.408,-.030,-.338,.242,.388,-.189,.271,-1.018,.021,.066,-.224,.220,.517)*f2_2+\n    mat4(-.204,.522,.750,-.581,-.045,.530,-.334,1.052,-.339,.528,-.052,.813,.525,-.166,-.219,-.981)*f2_3+\n    vec4(-2.943,1.925,2.531,-2.310))/1.7+f2_3;\nreturn dot(f3_0,vec4(-.031,.112,-.039,-.032))+\n    dot(f3_1,vec4(-.076,-.033,.058,-.029))+\n    dot(f3_2,vec4(.072,-.019,.053,.079))+\n    dot(f3_3,vec4(-.087,.055,.030,-.029))+\n    0.139;\n}\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 plane = vec2(p.z + 0.7, 0);\n    vec2 h = vec2(0.85*head(p), 1);\n    return opUnion(h, plane);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p).x - vec3(scene(k[0]).x,scene(k[1]).x,scene(k[2]).x));\n}\n\nfloat trace(inout vec4 ro, vec3 rd)\n{\n    vec2 de = vec2(-1);\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        de = scene(ro.xyz); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de.x - 2.0*step(de.x, md)*md); \n        if(de.x < md) return de.y;\n        if(ro.w > MAX_DIST) return -1.0;\n    }\n    return de.y;\n}\n\nvec3 pathtrace(vec4 ro, vec3 rd)\n{\n    vec3 outcol = vec3(0.); vec3 matcol = vec3(1.);\n    for(int i = 0; i<2; i++)\n    {\n        float hit = trace(ro, rd);\n        if(hit>=0.0)\n        {\n            vec3 n = norm(ro.xyz); //geometric normal\n           \n            float roughness =(rand()>0.5)?0.5:0.05;\n            if(hit == 0.0)\n            {\n                bool tile =mod(ro.x, 1.0) + mod(ro.y, 1.0) > 1.0;\n                matcol *= tile?vec3(0.780,0.678,0.678):vec3(1.000,1.000,1.000); \n            }\n            else\n            {\n                roughness = 0.5;\n                matcol *= vec3(0.804,0.914,0.996);\n            }\n            vec3 m = normalize(nrand3(roughness, n)); //material normal\n            rd = reflect(rd,m);\n        }\n        else\n        {\n            outcol += matcol*pow(texture(iChannel1, rd.xzy).xyz,vec3(1.4));\n            break;\n        }\n    }\n    return outcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //RNG\n    s0 = uvec4(fragCoord, uint(iFrame), uint(fragCoord.x) + uint(fragCoord.y));\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragCoord += rand2();\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.0,0,-0.1);\n    \n    float yrot = 0.5 - 0.5*mouse.y;\n    float zrot = 3. + 4.0*mouse.x;\n    if (iMouse.z > 0.) {\n        fragColor *= 0.0;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    init = erot(init, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    fragColor += vec4(pathtrace(vec4(init, 0.), cam), 1.0);\n}\n", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3fzr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 251, 251, 352]], "test": "untested"}
{"id": "WttfRn", "name": "Distorted Spinning Stars", "author": "gaboose", "description": "Split the origin point into two for distance and angle in polar coordinates and voila!", "tags": ["stars", "night", "hash", "gravity", "distorted"], "likes": 3, "viewed": 313, "published": 3, "date": "1612103326", "time_retrieved": "2024-07-30T19:41:24.924378", "image_code": "#define HASHSCALE1 .1031\n\n// From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst float PI = 3.1415;\n\n// From HuaTham (https://stackoverflow.com/a/26070411)\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centerD = vec2(.2, .8) * iResolution.y;\n    vec2 centerA = vec2(-.2, 0.) * iResolution.y;\n    \n    vec2 rCoord = vec2(\n        distance(fragCoord, centerD),\n        atan2(fragCoord.x-centerA.x, fragCoord.y-centerA.y)\n    );\n    \n    rCoord.y -= iTime*0.1;\n    \n    vec2 rCoordFloor = vec2(floor(rCoord.x *0.75), 0.);\n    rCoordFloor.y = floor(rCoord.y * 20. * pow(rCoordFloor.x, 0.5));\n    \n    float v = pow(hash12(rCoordFloor*100.), 200.);\n    \n    vec3 col = vec3(v);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 87, 109, 109, 231], [259, 314, 351, 351, 435], [437, 437, 494, 494, 1008]], "test": "untested"}
{"id": "wtcfzr", "name": "No1.", "author": "CZ", "description": "SpatialColorDistribution", "tags": ["spatialcolordistribution"], "likes": 1, "viewed": 210, "published": 3, "date": "1612099196", "time_retrieved": "2024-07-30T19:41:25.680357", "image_code": "mat2 rot(float deg)\n{    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\n\n\nvoid mainImage( out vec4 f, in vec2 fC )\n{\n    float t = iTime;\n\tvec2 uv = fC.xy / iResolution.xy;\n    \n\tuv-=.5;\n    uv*=15.;\n    \n    uv*=rot(uv.y/5.-t*.15);\n    uv-=sin(sqrt(uv.x*uv.x+uv.y*uv.y)-t*2.)*3.;\n    uv.y+=sin(uv.x-t)*1.2;\n    uv-=sin(sqrt(uv.x*uv.x+uv.y*uv.y)+t)*.6;\n    uv.x+=sin(uv.y*1.4+t)*.6;\n    \n    \n    uv*=rot(uv.x/5.-t*.8);\n    uv.x/=length(.75*uv);\n\tuv.y/=length(.75*uv);\n    //uv+=length(uv-.5);\n    f = vec4(sin(uv.x-t*.6),sin(uv.y+uv.y-t*.7),sin(uv.x+uv.y-t*.8),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 109], [112, 112, 154, 154, 607]], "test": "untested"}
{"id": "wl3Bzr", "name": "NO1.", "author": "bey", "description": "First try", "tags": ["color"], "likes": 1, "viewed": 236, "published": 3, "date": "1612092417", "time_retrieved": "2024-07-30T19:41:26.430351", "image_code": "mat2 rot(float deg)\n{    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\n\n\nvoid mainImage( out vec4 f, in vec2 fC )\n{\n    float t = iTime;\n\tvec2 uv = fC.xy / iResolution.xy;\n    \n\tuv-=.5;\n    uv*=15.;\n    \n    uv*=rot(uv.y/5.-t*.15);\n    uv-=sin(sqrt(uv.x*uv.x+uv.y*uv.y)-t*2.)*3.;\n    uv.y+=sin(uv.x-t)*1.2;\n    uv-=sin(sqrt(uv.x*uv.x+uv.y*uv.y)+t)*.6;\n    uv.x+=sin(uv.y*1.4+t)*.6;\n    \n    \n    uv*=rot(uv.x/5.-t*.8);\n    uv.x/=length(.75*uv);\n\tuv.y/=length(.75*uv);\n    //uv+=length(uv-.5);\n    f = vec4(sin(uv.x-t*.6),sin(uv.y+uv.y-t*.7),sin(uv.x+uv.y-t*.8),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3Bzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 109], [112, 112, 154, 154, 607]], "test": "untested"}
{"id": "tt3Bzr", "name": "UnionPoly", "author": "iY0Yi", "description": "I found iq's polyAbs() here.\nhttps://www.shadertoy.com/view/3sVBRG\nI turned it into a boolean function and did some testing and found it useful, so I wanted to share it.\nI think it will be especially useful when modeling organic shapes.\nmouse.", "tags": ["boolean"], "likes": 7, "viewed": 420, "published": 3, "date": "1612091609", "time_retrieved": "2024-07-30T19:41:27.179349", "image_code": "const float MIN_DIST = .001;\nconst float MAX_DIST = 100.;\nconst int ITR = 100;\nconst float INV_ITR = (1./float(ITR));\n\n// I found iq's polyAbs() at:\n// https://www.shadertoy.com/view/3sVBRG\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat opUnionPoly(float a, float b, float m, float n){\n    float x = abs(a-b);\n    // iq's polyAbs:\n    if( x<m ){\n        float xa = 2.0*n - m;\n        float xb = 2.0*m - 3.0*n;\n        float t = x/m;\n        x = (xa*t + xb)*t*t + n;\n    }\n\treturn (a+b-x)*.5;\n}\n\nfloat sdSphere(vec3 p)\n{\n    return length(p)-2.;\n}\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nfloat map(in vec3 p)\n{\n    R(p.xz,iTime*.3);\n\tfloat d = sdSphere(p);\n    p.x = abs(p.x);\n    p.x-=2.;\n    R(p.xy,PI*.5);\n    \n    float m = s2u(sin(iTime*.8))*2.+.25;\n    float n = s2u(cos(iTime))*2.;\n    if(iMouse.z>0.){\n        m = iMouse.x/iResolution.x*2.;\n        n = iMouse.y/iResolution.y*2.;\n    }\n\n    d = opUnionPoly(d, sdCapsule(p, .6, 2.), m, n);\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec3 e = vec3(0, 1,-1)*MIN_DIST;\n    return normalize(vec3(map(p+e.yxx)-map(p+e.zxx),map(p+e.xyx)-map(p+e.xzx),map(p+e.xxy)-map(p+e.xxz)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<ITR; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p)*.5;\n        if(d<=MIN_DIST) break;\n        t += d;\n        if(t < MIN_DIST) break;\n        if(t >= MAX_DIST) return MAX_DIST;\n    }\n    return t;\n}\n\nvec3 render(in vec2 fragCoord){\n      vec2 uv = fragCoord/iResolution.xy;\n      uv = uv*2.-1.;\n      uv.y *= iResolution.y/iResolution.x;      \n\n      vec3 ro = vec3(0,3,-12);\n      vec3 rd = normalize(vec3(uv-vec2(0,.55), 2));\n      float d = march(ro, rd);\n      \n      vec3 col = vec3(0);\n      \n      if(d<MAX_DIST){\n          vec3 p = ro + rd * d;\n          vec3 n = normal(p);\n          dbg_3V( n*.5+.5 );\n          \n          float l = max(0., dot(n,vec3(.5,1,-.5)));\n          col = vec3(.8)*l;\n      }\n      col = pow(col, vec3(.45));\n      return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = render(fragCoord);\n    fragColor = vec4(col,1.0);\n    drawDebug(fragColor);\n}", "image_inputs": [], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define sat(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3Bzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 249, 303, 303, 511], [513, 513, 537, 537, 564], [566, 566, 609, 609, 706], [758, 758, 780, 780, 1132], [1134, 1134, 1154, 1154, 1300], [1302, 1302, 1332, 1332, 1583], [1585, 1585, 1616, 1616, 2148], [2150, 2150, 2206, 2206, 2299]], "test": "untested"}
{"id": "wlyyWd", "name": "Rollin out", "author": "Plento", "description": "swoosh", "tags": ["3d", "orthographic"], "likes": 14, "viewed": 341, "published": 3, "date": "1612087138", "time_retrieved": "2024-07-30T19:41:27.939317", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat sub(float d1, float d2){return max(-d1, d2);}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z))-.04,0.0);\n}\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid trn(inout vec3 p){\n    p.yz*=rot(-0.8);\n    p.xy*=rot(0.475);\n    p.x += iTime + 50.;\n}\n\n#define b vec3(5., 5., 0.)\n\nfloat map(vec3 rp){\n    float d = 999.;\n    vec3 p = rp-vec3(0., -5., 9.);\n    vec3 pp = p;\n    trn(pp);\n    \n    for(float i = 0.; i < 2.; i++){\n        p = pp;\n        vec3 id = floor(p / max(b, 0.0001));\n        p.z += i*-5.;\n    \n        float rnd = hash12(i*33.+id.xy*vec2(333., 588.));\n        p = mod(p, b)-b*.5;\n        \n        p.xz *= rot(sign(rnd-0.5)*.8*iTime+id.x+id.y);\n        p.xy *= rot(sign(rnd-0.5)*.8*iTime+id.x+id.y);\n    \n        d = min(sdBox(p, vec3(1.6 - rnd*0.2, 1.6 - rnd*0.4, 1.0 + rnd*0.9)), d);\n        if(rnd > 0.4) d=sub(length(p)-1.68, d);\n    }\n    \n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(0., 0.0, 1.));\n    vec3 ro = vec3(uv * 12., 0.);\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    for(int i = 0; i < 44; i++){\n    \td = map(ro + rd*t); \n        if(abs(d) < 0.01 || t > 40.)break;\n        t += d * .55;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    vec3 lp = vec3(-2., 37.0, -30.);\n    vec3 ld = normalize(lp-p);\n    \n    float dif = max(dot(n, ld), .3);\n    vec3 col = .43 + .3*cos(vec3(0.5, 2., 1.1)*(n.x+n.y+n.z)*1.2 + vec3(2., 1.8, 0.2));\n    \n    col *= max(ss(1.85, 0.6, ns/24.), 0.03) * dif;\n    \n    col = mix(vec3(0.0), col, exp(-t*t*t*0.0001));\n    col = pow(col*1.4, vec3(1.85));\n    \n    col*=ss(.42, .419, abs(uv.y));\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 167, 167, 188], [190, 190, 220, 220, 311], [313, 313, 334, 334, 451], [453, 453, 476, 476, 545], [575, 575, 594, 594, 1174], [1177, 1177, 1204, 1204, 1405], [1408, 1408, 1448, 1448, 2248]], "test": "untested"}
{"id": "tlcBRr", "name": "Neural Teddy Bear - Yes!", "author": "oneshade", "description": "Well this one worked quite well :)", "tags": ["3d", "raymarching", "sdf", "teddybear", "ai", "neuralnetwork", "siren"], "likes": 4, "viewed": 170, "published": 3, "date": "1612086805", "time_retrieved": "2024-07-30T19:41:28.800016", "image_code": "/*\nAnother test of blackle's mesh to SDF siren network notebook.\nMesh source: https://groups.csail.mit.edu/graphics/classes/6.837/F03/models/teddy.obj\n\nThe siren network liked this one better (it even made it smoother!) :)\n\nI also optimized by analytically doing an intersection test with the model's bounding\nsphere to avoid running the neural network too many times.\n\nHere's my copy of the notebook:\nhttps://colab.research.google.com/drive/1zdP-LymbnhIzhxOEdZx39C0GBr4AzbFU?authuser=1#scrollTo=O2uKIwI5chcp\n*/\n\n// ?!?\n//#define SPIKY\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 intersect = vec3(0.0);\n\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom; // 1st root\n        float t2 = -(root + b) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nfloat sdTeddyBear(in vec3 p) {\n    if (length(p) > 1.2) return length(p) - 1.0;\n    p = vec3(p.z, p.x, p.y);\n    vec4 f0_0=sin(p.y*vec4(-3.54,.16,-3.85,-3.46)+p.z*vec4(-4.11,1.46,3.18,-1.08)+p.x*vec4(.87,2.37,2.00,-.06)+vec4(-4.84,6.35,4.67,1.28));\n    vec4 f0_1=sin(p.y*vec4(-.79,-2.43,1.17,.08)+p.z*vec4(2.96,4.06,-.50,2.33)+p.x*vec4(2.18,1.64,-3.70,-2.06)+vec4(2.49,-2.94,-1.55,-4.40));\n    vec4 f0_2=sin(p.y*vec4(-2.82,-1.15,-1.02,-2.78)+p.z*vec4(.61,-2.66,-1.37,2.07)+p.x*vec4(-3.03,1.62,-2.73,2.17)+vec4(1.85,6.48,2.10,-8.41));\n    vec4 f0_3=sin(p.y*vec4(1.13,-1.73,.30,-.71)+p.z*vec4(2.68,3.20,-3.55,3.69)+p.x*vec4(-2.77,.68,3.42,-2.48)+vec4(2.86,-.73,-.16,-2.31));\n    vec4 f1_0=sin(mat4(.71,.16,.40,-.11,-.07,-.53,-.52,-.30,.39,.16,.25,-.29,-.38,-.15,-.24,.24)*f0_0+\n        mat4(-1.10,-.65,.12,-.36,-.03,-.40,-.34,.64,.18,.11,.13,.68,1.15,.81,.17,.01)*f0_1+\n        mat4(.25,.05,.65,-.42,-.81,.22,-.35,.55,.45,-.11,-.42,.25,-.77,.68,.13,.18)*f0_2+\n        mat4(.77,-.04,-.00,-.32,-.56,-.92,-.23,-.20,-.78,.24,-.69,-.19,.94,.18,.51,.51)*f0_3+\n        vec4(-2.07,-2.21,-2.80,1.04))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(.39,.31,.25,.08,.52,-.71,.79,1.11,.16,.16,-.58,.04,.73,.24,.42,-.43)*f0_0+\n        mat4(.52,.25,-.04,.49,-.22,.75,-.06,-.03,.16,-.11,-.13,-.07,.42,.21,-.31,.54)*f0_1+\n        mat4(.33,-.33,-.62,-.35,.02,.31,.29,.30,.35,-.26,.20,-1.30,.31,.07,1.34,.07)*f0_2+\n        mat4(-.04,.22,-.42,-.32,-.03,.40,.30,.07,.25,-.47,-.02,.62,-.09,1.04,-.28,-.46)*f0_3+\n        vec4(2.91,-3.76,-.66,2.25))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(-.05,.69,.54,.50,1.04,-.74,-.04,-.61,-.24,-.46,-.08,-.04,.41,.24,.43,.69)*f0_0+\n        mat4(-.04,.07,-.14,-.04,.47,.84,.41,-.45,.09,.11,-.10,.20,.10,-.26,-.15,.86)*f0_1+\n        mat4(.70,1.12,.49,.18,-.25,1.15,.54,-.11,-.77,-.40,.76,.56,.38,-.47,-.92,.27)*f0_2+\n        mat4(-.25,-.72,-.11,-.33,1.01,.68,.08,-.76,-.19,.45,-.31,-.48,.31,-.21,.05,.66)*f0_3+\n        vec4(-2.16,.49,-2.85,-1.92))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(.55,.17,.17,.47,-.46,.91,.81,1.00,.08,.30,.28,.01,-.31,-.58,.39,-.31)*f0_0+\n        mat4(.58,.46,-.13,.75,-.17,-.14,-.21,-.19,-.11,.37,.47,.35,.77,-.42,.11,.01)*f0_1+\n        mat4(-.50,.03,-.61,.79,.04,-.54,.39,-.45,.69,-.43,-.04,-1.36,-.06,-.00,.08,1.19)*f0_2+\n        mat4(-.55,.87,-.21,.29,-.26,-.10,.02,.71,-.28,-.47,.62,-.24,.21,.14,-1.35,-.25)*f0_3+\n        vec4(.41,.31,1.27,3.67))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(.05,-.62,.18,.13,1.28,-.06,-.32,.05,1.17,-.09,.00,1.21,-.92,1.33,-1.33,.75)*f1_0+\n        mat4(2.55,.44,-1.25,.31,-.87,-.11,.27,-1.17,.81,.29,.68,.73,.73,.02,-.16,.51)*f1_1+\n        mat4(.56,-.56,-.05,1.78,1.40,.15,-.90,-.86,.02,.91,.66,.14,.81,-1.19,-.74,.50)*f1_2+\n        mat4(.88,.59,-.45,.10,.05,.00,-.94,.24,.49,-.29,-.50,.75,-.22,-.25,.40,-.03)*f1_3+\n        vec4(-.41,-2.09,2.22,-.79))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(.06,.37,.57,-.46,.47,.97,-.03,.98,-.30,-.73,.13,-.62,-.38,-.49,.23,-.11)*f1_0+\n        mat4(-.59,.02,-.25,.32,-.50,.80,-.38,.40,.06,.09,-.74,.05,-1.98,-.87,-.49,-.25)*f1_1+\n        mat4(.86,-.97,.09,.09,-.91,.05,1.04,-.09,.01,-1.03,.10,-.10,1.25,1.01,-.79,.27)*f1_2+\n        mat4(-.06,-.11,-.10,-.32,-.25,-.58,-.30,1.49,-.72,.10,-.50,-1.04,.22,.31,-.44,.38)*f1_3+\n        vec4(2.22,1.33,-3.42,.01))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(-.67,-.19,-.86,.11,-.73,-.33,.89,.59,-.28,-.15,-.72,-.18,.39,1.06,.28,.65)*f1_0+\n        mat4(.16,.20,.41,-.03,.18,.20,-.10,-.05,-.33,-1.03,-.06,-.94,.35,.18,.54,.32)*f1_1+\n        mat4(-.07,-.11,.32,.26,.13,-.48,-.74,.97,-.84,.19,.74,.91,-.15,.07,.34,-.09)*f1_2+\n        mat4(.02,.33,.90,-.43,-.35,.97,1.09,-.03,.87,-.29,-.26,.11,-.36,.65,.71,.05)*f1_3+\n        vec4(2.32,1.86,2.46,-.34))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.16,.74,.45,.23,-.68,-.06,-.63,1.13,.09,.48,.42,-1.22,.08,.13,.64,.55)*f1_0+\n        mat4(.36,.41,.50,.01,.42,-.13,-.86,-.88,-.43,-.22,-.77,-.18,1.05,.25,.87,-1.13)*f1_1+\n        mat4(.11,-.18,.34,.54,-.53,.63,-.11,-.55,-.41,.78,-.46,-.41,.23,-.31,.16,.20)*f1_2+\n        mat4(.50,-.89,-.30,-.24,.81,-.96,.50,-.25,.31,-.32,.20,.37,.36,-.25,-.52,-.86)*f1_3+\n        vec4(1.63,-3.71,2.15,.50))/1.4+f1_3;\n    float d=(dot(f2_0,vec4(.02,-.07,-.06,.03))+\n        dot(f2_1,vec4(.07,.05,.05,-.04))+\n        dot(f2_2,vec4(-.09,.09,.05,-.06))+\n        dot(f2_3,vec4(-.12,.11,.07,-.03))+\n        0.177)*.8;\n   #ifdef SPIKY\n   p*=150.;\n   if (d<.03) d+=.01*dot(sin(p), cos(p.zxy));\n   #endif\n   return d;\n}\n\nvec3 getTeddyNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(sdTeddyBear(p + e.xyy) - sdTeddyBear(p - e.xyy),\n                          sdTeddyBear(p + e.yxy) - sdTeddyBear(p - e.yxy),\n                          sdTeddyBear(p + e.yyx) - sdTeddyBear(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(iTime, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec3 bSphereIntersect = IntersectSphere(ro, rd, 1.0);\n    if (bSphereIntersect.z > 0.5) {\n        float tMin = min(bSphereIntersect.x, bSphereIntersect.y);\n        float tMax = max(bSphereIntersect.x, bSphereIntersect.y);\n        fragColor.rgb += tMin / 10.0;\n\n        vec3 p;\n        bool hitModel = false;\n        float t = tMin;\n        for (int i=0; i < 100; i++) {\n            p = ro + rd * t;\n            float d = sdTeddyBear(p);\n            if (d < 0.001) {\n                hitModel = true;\n                break;\n            }\n\n            if (t > tMax) {\n                break;\n            }\n\n            t += d;\n        }\n\n        if (hitModel) {\n            vec3 n = getTeddyNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            float tex = 1.0;\n\n            #ifdef SPIKY\n            p *= 150.0;\n            tex = 1.0 + 0.5 * dot(sin(p), cos(p.zxy));\n            #endif\n\n            fragColor.rgb += vec3(0.6, 0.4, 0.2) * tex;\n            fragColor.rgb *= max(0.2, dot(n, l));\n        }\n\n        else {\n            fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n        }\n    }\n\n    else {\n        fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 595, 595, 1025], [1027, 1027, 1057, 1057, 5397], [5399, 5399, 5431, 5431, 5695], [5697, 5697, 5752, 5752, 7592]], "test": "untested"}
{"id": "wsVBR1", "name": "Infinite wooden spheres", "author": "Rowsej", "description": "A small test that I never got around to finishing. Uses IQs soft shadow method. Move your mouse to the right half of the screen for better graphics.", "tags": ["raymarching", "spheres", "textures"], "likes": 2, "viewed": 333, "published": 3, "date": "1612084815", "time_retrieved": "2024-07-30T19:41:29.646752", "image_code": "#define MAX_RAY_DIS 10.\n#define EPSILON .001\n\n#define GROUND_TEXTURE true\n#define SPHERE_TEXTURE true\n#define BETTER_LIGHT iMouse.x > iResolution.x / 2.\n\nfloat randIndex = 0.;\n\nfloat sdSphere(vec3 s, float r, vec3 p);\nfloat getSde(vec3 p);\n// Thanks to IQ for this\nvec3 estimateNormal(vec3 p) {\n    vec2 h = vec2(EPSILON, 0.0);\n    return normalize(vec3(getSde(p + h.xyy) - getSde(p - h.xyy),\n                         getSde(p + h.yxy) - getSde(p - h.yxy),\n                         getSde(p + h.yyx) - getSde(p - h.yyx)));\n}\nfloat rand(vec2 fragCoord) {\n    float index = iTime + randIndex;\n    vec2 coords = fragCoord;\n    coords.x += index;\n    while(coords.x > 63.) {\n        coords.x -= 64.;\n        coords.y += 1.;\n    }\n    return texture(iChannel2, coords).x;\n}\n\nfloat sdSphere(vec3 s, float r, vec3 p) {\n    return length(p - s) - r;\n}\nfloat sdGround(vec3 p) {\n    return p.y + .5;\n}\nfloat getSde(vec3 p) {\n    return min(sdSphere(vec3(.5), .25, mod(p, 1.)), sdGround(p));\n}\nvec2 getBlinnPhongShading(vec3 n, vec3 v, vec3 l, float shininess) {\n    float ambient = .1;\n    float diffuse = clamp(dot(n, l), 0., 1.);\n    float specular = clamp(pow(dot(normalize(l - v), n), shininess) * (1. - diffuse), 0., 1.);\n    return vec2(ambient + diffuse, specular);\n}\nfloat marchShadowRay(vec3 f, vec3 l) {\n    vec3 ro = f;\n    vec3 rd = normalize(l - f);\n    float md = length(l - f);\n    float res = 1.;\n    for(float t = EPSILON * 15.; t < md;) {\n        vec3 p = ro + rd * t;\n        float sde = getSde(p);\n        if(sde < EPSILON) return 0.;\n        res = min(res, 64. * sde / t);\n        t += sde;\n    }\n    return res;\n}\n\nvec3 getCol(vec2 coords) {\n    vec3 ro = vec3(0., 0., sin(iTime));\n    vec3 rd = normalize(vec3(coords, 1.));\n    vec3 p = ro;\n    for(float t = 0.; t < MAX_RAY_DIS;) {\n        float sde = getSde(p);\n        p += rd * sde;\n        if(sde < EPSILON) {\n            vec3 n = estimateNormal(p);\n            vec3 v = rd;\n            vec3 light = vec3(cos(iTime), 1., -sin(iTime));\n            vec3 lightDir = normalize(light - p);\n            vec2 shading = getBlinnPhongShading(n, v, lightDir, 64.);\n            float shadow = marchShadowRay(p, light);\n            shading.y *= pow(shadow, 4.);\n            shading.x *= max(shadow, .3);\n            vec3 obCol = mod(floor(p.x * 2.) + floor(p.y * 2.) + floor(p.z * 2.), 2.) == 0.? vec3(0., 1., 0.) : vec3(1., 0., 0.);\n            if(SPHERE_TEXTURE) {\n\t            obCol = texture(iChannel1, p.xz).xyz;\n            }\n            if(sdGround(p) < EPSILON) {\n                obCol = floor(mod(p.x / .3, 2.)) == floor(mod(p.z / .3, 2.))? vec3(.6) : vec3(.8);\n                if(GROUND_TEXTURE) {\n\t                obCol *= texture(iChannel0, p.xz).x;\n                }\n            }\n            vec3 col = obCol * shading.x + vec3(1.) * shading.y;\n            if(BETTER_LIGHT) {\n\t            col /= length(light - p) / 4.;\n            }\n            vec3 fogCol = vec3(0.);\n            return col;\n        }\n        t += sde;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mind = min(iResolution.x, iResolution.y);\n    if(!(BETTER_LIGHT)) {\n        fragCoord.x = floor(fragCoord.x / 8.) * 8.;\n        fragCoord.y = floor(fragCoord.y / 8.) * 8.;\n    }\n    vec2 coords = fragCoord / mind * 2. - 1.;\n    coords.x -= (iResolution.x - mind) / mind;\n    coords.y -= (iResolution.y - mind) / mind;\n    vec3 col = getCol(coords);\n    \n    // Add the light effect (which, if you look close enough, still shows even if the light is behind shadow).\n    const float bloomSize = .2;\n    const float strength = 1.;\n    float bloom = 0.;\n    vec3 ro = vec3(0., 0., sin(iTime));\n    vec3 rd = normalize(vec3(coords, 1.));\n    for(float t = 0.; t < MAX_RAY_DIS;) {\n        vec3 p = ro + rd * t;\n        float sde = length(p - vec3(cos(iTime), 1., -sin(iTime)));\n        if(sde < bloomSize) {\n            bloom = (1. - sde / bloomSize) * strength;\n            break;\n        }\n        t += sde;\n    }\n    col += vec3(1.) * bloom;\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 265, 294, 294, 524], [525, 525, 553, 553, 768], [770, 770, 811, 811, 843], [844, 844, 868, 868, 891], [892, 892, 914, 914, 982], [983, 983, 1051, 1051, 1264], [1265, 1265, 1303, 1303, 1625], [1627, 1627, 1653, 1653, 3020], [3022, 3022, 3077, 3077, 4059]], "test": "untested"}
{"id": "3lKyDc", "name": "Meta-furballs", "author": "yonatan", "description": "name says it all", "tags": ["metaballs", "fur"], "likes": 32, "viewed": 885, "published": 3, "date": "1612079166", "time_retrieved": "2024-07-30T19:41:30.451600", "image_code": "// texture based 3D value noise by iq - https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Metaballs and analytic normals from Klems' https://www.shadertoy.com/view/4dj3zV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 a, q, p, gradient, normal, dir;\n    float b, dist, bdist;\n    dir = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y), 1.7));\n    p = vec3(0, 0, -3);\n    for(int i = 0; i < 200; i++) {\n        q = p; // save current position\n        p += dir * dist; // step\n        gradient = vec3(0);\n        dist = 1.;\n        for(float j = 0.; j < 3.; j++) {\n            vec3 ballp = sin(vec3(1,2,5) * j + iTime); // ball position\n            b = dot(a = p - ballp, a);\n            // gradient += a / (b * b); // actual normals\n            gradient += a / sqrt(b); // Shane's fur grooming tip\n            dist -= .5 / b;\n        }\n        normal = normalize(gradient);\n        bdist = dist;\n        if(i>90 && dist<.01) {\n            dist += noise(normal*60.);\n            dist *= .02;\n        }\n     }\n    vec3 col = normal.yyy*.4+.5;\n    if(dist<.1) col = col * vec3(.9,.3,.5) + .1;\n    else col = col * vec3(.7,.8,.5);\n    fragColor.rgb = col * (1.+bdist);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 104, 104, 311], [313, 397, 454, 454, 1443]], "test": "untested"}
{"id": "tlcfRn", "name": "Smooth Abs()", "author": "oneshade", "description": "Smooth abs() function.", "tags": ["blending", "function", "smooth", "absolute", "sabs", "smoothabs"], "likes": 6, "viewed": 230, "published": 3, "date": "1612075854", "time_retrieved": "2024-07-30T19:41:31.286368", "image_code": "//#define sabs(x, k) (2.0 * k * log(exp(-x / k) + 1.0) + x)\n//#define sabs(x, k) (2.0 * k * log(exp(-abs(x) / k) + 1.0) + abs(x))\n#define sabs(x, k) sqrt(x * x + k * k)\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n    float k = 0.2 + 0.2 * sin(iTime);\n    return length(sabs(p, k) - 0.75) - 0.75;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 197, 197, 386], [388, 388, 415, 415, 661], [663, 663, 718, 718, 1282]], "test": "untested"}
{"id": "tlcBRn", "name": "Neural Shrek Head", "author": "michael0884", "description": "thanks: https://youtu.be/8pwXpfi-0bU", "tags": ["bunny"], "likes": 12, "viewed": 565, "published": 3, "date": "1612067965", "time_retrieved": "2024-07-30T19:41:32.115152", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    //loss 0.000032\nvec4 f0_0=sin(p.y*vec4(1.614,-.384,3.461,-1.449)+p.z*vec4(-1.740,-3.099,1.257,-4.194)+p.x*vec4(1.423,-.731,3.950,2.749)+vec4(8.860,-6.088,-1.444,-.854));\nvec4 f0_1=sin(p.y*vec4(-.614,4.579,-2.415,-.228)+p.z*vec4(-3.400,.411,2.157,5.092)+p.x*vec4(-.270,-3.123,3.553,-2.081)+vec4(-4.280,7.037,6.676,-4.043));\nvec4 f0_2=sin(p.y*vec4(-2.214,-1.697,-2.458,4.407)+p.z*vec4(-.505,-.133,1.820,-1.197)+p.x*vec4(.871,-2.552,-1.096,2.168)+vec4(-4.484,.480,4.456,6.656));\nvec4 f0_3=sin(p.y*vec4(-.262,-2.127,-1.644,2.066)+p.z*vec4(.936,-1.286,-2.796,-1.724)+p.x*vec4(-2.576,-3.029,3.619,-2.664)+vec4(-2.128,-1.856,.912,-4.219));\nvec4 f1_0=sin(mat4(-.175,-.141,-.181,.472,.489,.042,.178,.065,-.133,-.601,.384,.606,.263,-.225,.024,.052)*f0_0+\n    mat4(.098,-.435,.407,.053,.141,.108,.168,.313,-.374,.313,-.633,-.237,.296,-.092,.360,-.109)*f0_1+\n    mat4(-.176,-.664,.937,.178,-.583,-.178,-.535,.900,-.029,.356,-.298,.286,-.024,-.326,-.247,-.266)*f0_2+\n    mat4(-.835,.224,-.646,.308,-.166,.522,-.570,-.073,.047,-.005,-.242,-.191,.909,-.777,.278,.586)*f0_3+\n    vec4(-.176,2.932,2.633,-2.581))/1.0+f0_0;\nvec4 f1_1=sin(mat4(.749,-.599,.060,.201,-.584,-.380,-.259,-.265,-.113,-.045,-.065,.320,-.000,-.157,-.369,-.111)*f0_0+\n    mat4(-.400,.668,1.048,.477,.226,-.053,.362,.106,.470,-.557,.278,-.050,-.536,.537,.612,.275)*f0_1+\n    mat4(.685,.667,.474,-.149,.817,.178,.281,-.997,.225,-.281,-.254,-.012,.430,-.658,-.169,-.168)*f0_2+\n    mat4(-.089,-.062,.411,-.270,.016,-.351,.504,-.621,-.372,-.099,.459,-.068,-.388,.787,.695,.653)*f0_3+\n    vec4(.874,2.704,2.734,2.805))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.333,.630,-.095,-.111,.342,-.102,1.435,-.043,.302,-.710,-.089,-.692,.067,-.047,.046,-.422)*f0_0+\n    mat4(-.534,1.033,.178,-.453,.696,-.087,.148,.130,-.115,.143,-.336,-.327,-.102,-.410,.370,.048)*f0_1+\n    mat4(-.007,-.061,.888,-.374,-.059,-.973,.430,.050,-.113,-.428,-.590,-.414,-.198,-.424,.016,.285)*f0_2+\n    mat4(-.424,.566,.485,-.124,.416,.015,-.159,.513,-.429,.508,-.177,.190,-.571,.348,.324,-.368)*f0_3+\n    vec4(-.466,2.862,1.568,-2.639))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.026,-.149,-.096,-.071,.120,-.360,-1.019,-.550,-.089,-.020,.527,-.275,-.345,.112,-.160,-.434)*f0_0+\n    mat4(-.155,-.337,.294,-.055,.492,-.659,.231,.273,-.218,.718,.127,.420,-.238,-.451,.167,.370)*f0_1+\n    mat4(-.100,.416,-.164,-.078,.739,.003,-.123,-.696,-.125,.202,-.117,-.863,.344,-.077,-.164,-.210)*f0_2+\n    mat4(.194,-.275,-.282,-.496,.212,-.590,.201,-.477,-.228,-.461,-.468,.123,.167,-.749,.085,-.343)*f0_3+\n    vec4(-1.475,1.966,-.599,1.170))/1.0+f0_3;\nvec4 f2_0=sin(mat4(1.080,.872,.711,.104,-.660,-.142,.339,.249,-.538,.418,-.618,-.306,-.245,-.175,.919,.010)*f1_0+\n    mat4(.106,.512,.018,.883,-.682,-.317,-.718,.475,.948,.038,.574,-.350,.023,.970,-.766,-.102)*f1_1+\n    mat4(-.030,.754,.336,.579,.234,-.428,.030,.166,-.002,.211,.055,.803,.260,.031,-.520,.381)*f1_2+\n    mat4(1.245,.856,.354,.121,.430,.305,.790,.595,.811,-.195,-.067,-.106,-1.421,-.204,-.224,.791)*f1_3+\n    vec4(.633,2.190,2.576,2.018))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.996,.390,-.566,-.109,.387,1.037,-.638,.502,.281,-1.178,-.828,.312,.283,-.481,-.210,.117)*f1_0+\n    mat4(-.602,-1.130,.273,-.236,.057,.597,-.631,.156,-.654,.380,.573,-.101,-.234,.068,-1.024,.173)*f1_1+\n    mat4(-.701,-.500,-.727,-.173,.118,.611,.552,-.199,.059,.022,.418,.257,-.545,-.647,.448,-.700)*f1_2+\n    mat4(-.117,.682,.589,-.177,.646,-.025,.158,.017,-.317,.787,1.245,-.632,.519,-.488,-1.065,-.338)*f1_3+\n    vec4(1.238,2.124,-.652,1.610))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.041,.230,-.114,-1.108,.284,.695,.812,.578,1.379,-.228,-.261,-.672,-1.183,.124,-.086,-.331)*f1_0+\n    mat4(.336,.228,-.854,.183,.180,.017,.893,.442,-.643,.418,-.519,.101,1.136,.074,.436,.166)*f1_1+\n    mat4(.056,-.419,-.569,-.230,-1.501,.016,.276,-.461,.651,.871,.042,.257,-.036,.253,-.484,-.337)*f1_2+\n    mat4(.759,-.194,.608,-1.026,-1.631,.967,-.322,.307,.793,-.334,.523,.013,.792,-.088,-.167,.215)*f1_3+\n    vec4(-.405,2.659,-1.339,3.678))/1.4+f1_2;\nvec4 f2_3=sin(mat4(-.339,1.039,.044,.203,.042,-.744,.374,-1.190,.583,.152,-.218,-.236,.024,.066,-.172,.659)*f1_0+\n    mat4(.220,-.253,1.000,-.678,.038,-.133,-.593,-.444,-.459,-.264,.763,.378,-.388,.042,-.395,-.742)*f1_1+\n    mat4(.392,.475,.196,-.626,.014,.124,-.313,.056,-.065,-.452,.111,-.250,-.420,.529,-.215,1.039)*f1_2+\n    mat4(-.607,-.029,.254,.600,.523,.250,-.227,.773,.091,-.398,.193,-.483,.781,.248,-.055,.150)*f1_3+\n    vec4(-1.623,-2.998,-.552,-3.926))/1.4+f1_3;\nreturn dot(f2_0,vec4(-.054,-.051,.066,.043))+\n    dot(f2_1,vec4(.045,.041,.025,.086))+\n    dot(f2_2,vec4(.011,-.046,.074,-.094))+\n    dot(f2_3,vec4(-.053,.089,-.084,.041))+\n    0.077;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-2.,0,0);\n    \n    float yrot = 0.;\n    float zrot = 3. + iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 3. + 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(0.478,1.000,0.478)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcBRn.jpg", "access": "api", "license": "cc0-1.0", "functions": [[435, 435, 473, 473, 535], [537, 537, 558, 644, 5391], [5393, 5393, 5412, 5412, 5528], [5530, 5530, 5587, 5587, 6872]], "test": "untested"}
{"id": "WtcBzr", "name": "-Transitions- ", "author": "Plento", "description": "I like cubes", "tags": ["3d", "cubes", "random"], "likes": 11, "viewed": 406, "published": 3, "date": "1612056679", "time_retrieved": "2024-07-30T19:41:32.868139", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sub(float d1, float d2){return max(-d1, d2);}\n\n#define b vec3(3., 3., 3.)\n#define r 0.45\n#define r2 0.42\n\nvoid q(inout vec3 p, in float rnd){\n    p.yz += .35*vec2(cos(iTime + rnd*333.), sin(iTime*2. + rnd*333.));\n    p.x += sign(rnd-0.5)*iTime*(rnd+.4) + rnd*3.;\n}\n\nfloat map(vec3 p){\n    float d = 999.;\n    vec3 pp = p;\n    \n    vec2 id = floor(p.zy/b.xy);\n    float rnd = hash12(id*733.3);\n    \n    q(p, rnd);\n    \n    p = mod(p, b)-b*0.5;\n    \n    p.xy*=rot(rnd*23.+iTime);\n    p.xz*=rot(rnd*73.+iTime);\n    \n    d = min(box(p, vec3(r)), 4.7 - abs(pp.x));\n    \n    if(rnd > 0.6){\n        d = sub(box(p, vec3(r2, r2, 2.2)), d);\n        d = sub(box(p, vec3(r2, 2.2, r2)), d);\n        d = sub(box(p, vec3(2.2, r2, r2)), d);\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 rd = normalize(vec3(uv, 0.8));\n    vec3 ro = vec3(-1.8, .5, 0.);\n    \n    rd.xy *= rot(-.3);\n    rd.xz *= rot(-.2);\n    rd.yz *= rot(.7);\n    \n    ro.z += iTime*1.3;\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        \n        if(d < 0.002 || t > 40.) break;\n        t += d * .55;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    \n    vec3 col = vec3(.001);\n    \n    col = mix(vec3(.05), col, exp(-t*t*t*0.0001));\n    col = pow(col*3.4, vec3(1.6));\n\n    \n    f = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 158, 158, 275], [277, 277, 305, 305, 392], [394, 394, 424, 424, 445], [506, 506, 541, 541, 664], [666, 666, 684, 684, 1146], [1149, 1149, 1189, 1189, 1817]], "test": "untested"}
{"id": "WlcBzr", "name": "Neural Knight - Test", "author": "oneshade", "description": "I tried creating an SDF of a guy (the mesh was described as being a cartoonish\nmobster) but the neural network disagreed and I ended up with this.", "tags": ["guy", "ai", "neuralnetwork", "siren", "knight", "meshtosdf", "mobster"], "likes": 3, "viewed": 213, "published": 3, "date": "1612054838", "time_retrieved": "2024-07-30T19:41:33.629104", "image_code": "/*\nTrying out blackle's mesh to SDF siren network notebook.\nMesh source: https://people.sc.fsu.edu/~jburkardt/data/obj/al.obj\nGround truth: https://people.sc.fsu.edu/~jburkardt/data/obj/al.png\n\nI tried using it to create an SDF of a guy (the mesh was described as being a cartoonish\nmobster) but the neural network disagreed and I ended up with this.\n\nIn case you are interested here's my copy of the notebook:\nhttps://colab.research.google.com/drive/1zdP-LymbnhIzhxOEdZx39C0GBr4AzbFU?authuser=1#scrollTo=O2uKIwI5chcp\n*/\n\n// Smooth abs() by ollj (https://www.shadertoy.com/view/Ws2SDK):\n#define sabs(x, k) mix(0.5 / k * x * x + k * 0.5, abs(x), step(0.0, abs(x) - k))\n\nfloat sdNeuralGuy(in vec3 p) {\n    // The SDF is undefined outside the unit sphere\n    if (length(p) > 1.1) {\n        return length(p) - 0.9;\n    }\n\n    p = vec3(p.z, -sabs(p.x, 0.02), p.y);\n    vec4 f0_0=sin(p.y*vec4(1.10,4.23,.31,-.47)+p.z*vec4(.61,-1.66,-.70,-1.52)+p.x*vec4(-3.05,.39,2.67,-3.37)+vec4(4.47,-4.20,6.87,-1.76));\n    vec4 f0_1=sin(p.y*vec4(2.13,1.71,-1.55,3.30)+p.z*vec4(-2.24,1.68,3.70,2.21)+p.x*vec4(-.65,2.93,1.02,-2.82)+vec4(-1.42,2.31,5.44,6.00));\n    vec4 f0_2=sin(p.y*vec4(-.15,-3.64,3.45,3.88)+p.z*vec4(-1.10,2.45,-1.97,1.96)+p.x*vec4(-1.78,2.13,-1.37,.82)+vec4(.59,-3.16,-5.44,6.75));\n    vec4 f0_3=sin(p.y*vec4(-.10,1.31,-2.10,-2.22)+p.z*vec4(-1.61,3.93,.20,.20)+p.x*vec4(-2.34,-2.20,3.68,.42)+vec4(2.89,5.78,-.56,.59));\n    vec4 f1_0=sin(mat4(-.59,-.39,-.05,-.37,.50,-.22,-.48,-.36,-.41,-.68,.31,.12,-.33,.36,-.61,-.76)*f0_0+\n        mat4(-.40,-.32,.35,.04,-.22,.77,-.11,-.32,-.18,-.72,-.25,-.34,.25,-.09,-.11,.56)*f0_1+\n        mat4(.14,-.34,.47,-.84,.69,-.60,.06,-.49,-.51,.27,.85,.48,.74,.01,.17,.75)*f0_2+\n        mat4(-1.56,-.69,1.26,-.58,-.57,-.43,.29,.04,-.20,-.30,.50,.25,-.40,.26,-.01,-.33)*f0_3+\n        vec4(-2.24,-1.05,.67,.83))/1.0+f0_0;\n    vec4 f1_1=sin(mat4(.37,.05,.36,-.23,.43,.69,.93,-.48,-.09,-.11,.02,.39,.75,-.09,-.31,-.27)*f0_0+\n        mat4(.29,-.50,.45,-.46,1.19,.01,.46,-.13,-.32,.15,-.17,.11,.15,-.13,-.41,-.02)*f0_1+\n        mat4(.05,.59,.62,-.08,.60,-.65,.15,-.47,.14,.84,-.29,-.39,-.39,-.59,-.60,-.06)*f0_2+\n        mat4(-.73,-.17,-.01,-.02,-.18,.53,-.06,-.75,-.03,-.29,-.73,.51,.52,.15,-.20,.87)*f0_3+\n        vec4(-1.78,2.03,-.74,-1.06))/1.0+f0_1;\n    vec4 f1_2=sin(mat4(.13,-.72,-.14,.23,-.32,.09,.71,.57,-.24,1.16,-.02,-.49,-.80,-.55,.16,-.02)*f0_0+\n        mat4(.34,-.57,-.07,-.24,-.18,-.81,-.08,.74,-.06,-.17,.46,.60,-.15,-.13,.40,-.03)*f0_1+\n        mat4(-.26,.58,1.51,-.91,.11,-1.22,.32,.47,-.31,.56,-.36,-.20,.20,.08,.63,.12)*f0_2+\n        mat4(.16,1.05,-.57,-.36,-.14,.05,.61,.29,.05,.10,-.10,-.48,-.28,-.26,.55,-.18)*f0_3+\n        vec4(-.45,.89,1.70,2.01))/1.0+f0_2;\n    vec4 f1_3=sin(mat4(.08,-.56,.20,-.09,-.31,.15,.14,-.29,.28,.03,.23,.11,-.61,-.51,-.33,.36)*f0_0+\n        mat4(.63,-.92,-.20,-.13,.16,.17,-.38,.32,.31,.27,.28,-.51,-.11,-.61,-.11,-.26)*f0_1+\n        mat4(-.46,-.07,.82,1.14,.15,-.30,.93,.39,.57,.42,-.47,.21,-.34,-.13,-.06,-.57)*f0_2+\n        mat4(.22,-.18,-.31,.64,.04,-.33,.94,-.61,.17,.04,.44,.53,.17,-.24,.45,-.15)*f0_3+\n        vec4(-.20,-.22,2.08,-.74))/1.0+f0_3;\n    vec4 f2_0=sin(mat4(.02,-.45,.49,-.11,1.20,-.02,-.52,-1.08,-.09,-.19,.95,.63,.33,-.79,-.57,-1.00)*f1_0+\n        mat4(-.16,-.04,-.85,.42,-.79,-.57,.05,-.04,-.68,-.56,.16,-.71,-.23,-.12,-.35,-.45)*f1_1+\n        mat4(.91,-1.09,.00,-1.45,.91,-.04,.01,-.73,-1.51,.24,.26,-.20,-.49,.83,-.51,.79)*f1_2+\n        mat4(.38,.38,-1.29,.00,1.00,.11,-.89,-.67,1.47,.60,-.16,.62,-.60,.09,.05,.21)*f1_3+\n        vec4(.17,-.97,-1.08,3.60))/1.4+f1_0;\n    vec4 f2_1=sin(mat4(-.42,.03,.26,.01,1.28,.52,1.16,.14,.12,-.14,-.21,-.46,.01,-.40,-1.97,-.41)*f1_0+\n        mat4(.20,-.33,-.45,-.31,.23,-.11,-.46,-.09,.49,.57,-.30,-.05,.90,-.08,-.25,-.21)*f1_1+\n        mat4(-.17,-.61,-.56,1.13,.00,.22,-.08,-.43,.25,.02,-.57,-1.04,.80,-.37,.44,1.12)*f1_2+\n        mat4(1.08,-.13,.50,1.64,.41,.15,1.11,-.10,-.14,-.21,.93,-.29,-.21,-.67,-.56,.14)*f1_3+\n        vec4(-.56,-1.73,-.20,.88))/1.4+f1_1;\n    vec4 f2_2=sin(mat4(.09,.34,.07,-.65,-.63,-.78,-1.35,.63,.70,.87,-.13,.72,-.29,-.87,-2.10,-.30)*f1_0+\n        mat4(-.24,.26,1.39,.81,-.57,-.49,-.68,.38,.00,-.68,-.77,-.90,-.42,-.16,.58,.29)*f1_1+\n        mat4(-.95,-.26,-1.00,-1.50,-.77,.21,.05,.20,.75,-.70,-.24,.35,1.34,.35,.06,1.01)*f1_2+\n        mat4(-.15,.02,.05,1.41,.01,.36,.06,.17,-.44,.12,.36,-.17,1.12,-.94,.82,.29)*f1_3+\n        vec4(1.27,-.34,1.88,2.82))/1.4+f1_2;\n    vec4 f2_3=sin(mat4(-.13,.23,.41,-.10,.78,.03,-.30,-.17,.52,.69,.23,.19,2.79,.57,.03,.19)*f1_0+\n        mat4(-1.54,-.42,-1.12,.57,.57,-.62,-.04,-.88,.22,.49,.04,-.42,-1.39,-.03,-.27,.03)*f1_1+\n        mat4(2.55,1.16,-.23,.27,.40,-.15,.01,.65,-.03,.47,.60,-.59,-1.38,.90,-.52,-.59)*f1_2+\n        mat4(-.65,-.81,-1.18,.70,-.47,.53,-.06,-.01,-.87,-.25,-.50,.27,-.25,.55,-.20,.45)*f1_3+\n        vec4(.97,1.87,-.95,3.89))/1.4+f1_3;\n    return dot(f2_0,vec4(.05,-.09,-.07,-.06))+\n        dot(f2_1,vec4(-.07,-.09,-.03,-.08))+\n        dot(f2_2,vec4(-.07,-.05,-.05,.03))+\n        dot(f2_3,vec4(.03,-.12,.08,-.06))+\n        0.222;\n}\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    return sdNeuralGuy(p);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 p;\n    bool hit = false;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        vec3 l = vec3(-0.58, 0.58, 0.58);\n        fragColor.rgb += max(0.2, dot(n, l));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[669, 669, 699, 751, 5051], [5053, 5053, 5080, 5080, 5182], [5184, 5184, 5211, 5211, 5457], [5459, 5459, 5514, 5514, 6141]], "test": "untested"}
{"id": "Wl3BRr", "name": "feelsgood.glsl", "author": "tdhooper", "description": "This is a couple of years old, however I only recently managed to get running fast enough to publish. I had been using about 100 (!) samples to get a smooth dispersion gradient, now I'm using just 3 thanks to some blue noise and frame averaging.", "tags": ["head"], "likes": 73, "viewed": 2394, "published": 3, "date": "1612041733", "time_retrieved": "2024-07-30T19:41:34.579563", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1./2.2));\n    \n    fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "/*\n\n    Head SDF\n    --------\n\n\tThis gets written into a \"3D\" texture using the utilities in Common.\n\t\n\tFor other appearances see:\n\n    * https://www.shadertoy.com/view/wlf3WX\n\t* https://www.shadertoy.com/view/wtf3RM\n\n*/\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pRi(vec2 p, float a) {\n    pR(p, a);\n    return p;\n}\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner2(vec2 p) {\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat fDisc(vec3 p, float r) {\n    float l = length(p.xz) - r;\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n\nfloat fHalfCapsule(vec3 p, float r) {\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\n}\n\n\n// IQ https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\n\n// Modelling\n\nfloat ellip(vec3 p, vec3 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float r = vmin(s);\n    p *= r / s;\n    return length(p) - r;\n}\n\nfloat helix(vec3 p, float lead, float thick) {\n    // p.z += iTime * .1;\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\n    d = abs(d) - thick;\n    return d;\n}\n\nvoid fMouth(inout float d, vec3 pp) {\n    vec3 p;\n    // mouth base\n    p = pp;\n    p += vec3(-.0,.29,-.29);\n    pR(p.yz, -.3);\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\n\n    p = pp;\n    p += vec3(0,.37,-.4);\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\n\n    p = pp;\n    p += vec3(-.09,.37,-.31);\n    d = smin(d, ellip(p, vec3(.04)), .18);\n\n    // bottom lip\n    p = pp;\n    p += vec3(0,.455,-.455);\n    p.z += smoothstep(.0, .2, p.x) * .05;\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\n    float w = .192;\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\n    d = smin(d, bottomlip, lb);\n    \n    // top lip\n    p = pp;\n    p += vec3(0,.38,-.45);\n    pR(p.xz, -.3);\n    ls = vec3(.065,.03,.05);\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\n    vec3 pl = p * vec3(.78,1,1);\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\n    p = pp;\n    p += vec3(0,.33,-.45);\n    pR(p.yz, .7);\n    float cut;\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\n    float dip = smin(\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\n        .025\n    );\n    cut = smax(cut, dip, .04);\n    cut = smax(cut, p.x - .1, .05);\n    toplip = smax(toplip, cut, .02);\n\n    d = smin(d, toplip, .07);\n\n\n    // seam\n    p = pp;\n    p += vec3(0,.425,-.44);\n    lb = length(p);\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\n    pR(p.yz, .1);\n    p.y -= smoothstep(0., .03, p.x) * .002;\n    p.y += smoothstep(.03, .1, p.x) * .007;\n    p.z -= .133;\n    float seam = fDisc(p, .2);\n    seam = smax(seam, -d - .015, .01); // fix inside shape\n    d = mix(d, smax(d, -seam, lr), .65);\n\n}\n\nbool isMap = true;\nbool isEye = false;\n\nfloat mHead(vec3 p) {\n\n    pR(p.yz, -.1);\n    //p.y -= .13;\n\n    vec3 pa = p;\n    p.x = abs(p.x);\n    vec3 pp = p;\n\n    float d = 1e12;\n\n    // skull back\n    p += vec3(0,-.135,.09);\n    d = ellip(p, vec3(.395, .385, .395));\n\n    // skull base\n    p = pp;\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\n\n    // forehead\n    p = pp;\n    p += vec3(0,-.145,-.175);\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\n\n    p = pp;\n    pR(p.yz, -.5);\n    float bb = fBox(p, vec3(.5,.67,.7));\n    d = smax(d, bb, .2);\n\n    // face base\n    p = pp;\n    p += vec3(0,.25,-.13);\n    d = smin(d, length(p) - .28, .1);\n\n    // behind ear\n    p = pp;\n    p += vec3(-.15,.13,.06);\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\n\n    p = pp;\n    p += vec3(-.07,.18,.1);\n    d = smin(d, length(p) - .2, .18);\n\n    // cheek base\n    p = pp;\n    p += vec3(-.2,.12,-.14);\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\n\n    // jaw base\n    p = pp;\n    p += vec3(0,.475,-.16);\n    pR(p.yz, .8);\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\n\n    // brow\n    p = pp;\n    p += vec3(0,-.0,-.18);\n    vec3 bp = p;\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\n    brow = length(p) - .36;\n    p.x -= .37;\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\n    p = bp;\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\n    p = bp;\n    pR(p.yz, -.5);\n    float peak = -p.y - .165;\n    peak += smoothstep(.0, .2, p.x) * .01;\n    peak -= smoothstep(.12, .29, p.x) * .025;\n    brow = smax(brow, peak, .07);\n    p = bp;\n    pR(p.yz, .5);\n    brow = smax(brow, -p.y - .06, .15);\n    d = smin(d, brow, .06);\n\n    // nose\n    p = pp;\n    p += vec3(0,.03,-.45);\n    pR(p.yz, 3.);\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\n\n    p = pp;\n    p += vec3(0,.06,-.47);\n    pR(p.yz, 2.77);\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\n\n    // jaw\n\n    p = pp;\n    vec3 jo = vec3(-.25,.4,-.07);\n    p = pp + jo;\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\n\n    p = pp;\n    p += vec3(0,.63,-.2);\n    pR(p.yz, .15);\n    float cr = .5;\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\n\n    p = pp + jo;\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\n\n    p = pa;\n    p += vec3(.2,.5,-.1);\n    float jb = length(p);\n    jb = smoothstep(.0, .4, jb);\n    float js = mix(0., -.005, jb);\n    jb = mix(.01, .04, jb);\n\n    d = smin(d, jaw - js, jb);\n\n    // chin\n    p = pp;\n    p += vec3(0,.585,-.395);\n    p.x *= .7;\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\n\n    // return d;\n\n    // cheek\n\n    p = pp;\n    p += vec3(-.2,.2,-.28);\n    pR(p.xz, .5);\n    pR(p.yz, .4);\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.26,.02,-.1);\n    pR(p.xz, .13);\n    pR(p.yz, .5);\n    float temple = ellip(p, vec3(.1,.1,.15));\n    temple = smax(temple, p.x - .07, .1);\n    d = smin(d, temple, .1);\n\n    p = pp;\n    p += vec3(.0,.2,-.32);\n    ch = ellip(p, vec3(.1,.08,.1));\n    d = smin(d, ch, .1);\n\n    p = pp;\n    p += vec3(-.17,.31,-.17);\n    ch = ellip(p, vec3(.1));\n    d = smin(d, ch, .1);\n\n    fMouth(d, pp);\n\n    // nostrils base\n    p = pp;\n    p += vec3(0,.3,-.43);\n    d = smin(d, length(p) - .05, .07);\n\n    // nostrils\n    p = pp;\n    p += vec3(0,.27,-.52);\n    pR(p.yz, .2);\n    float nostrils = ellip(p, vec3(.055,.05,.06));\n\n    p = pp;\n    p += vec3(-.043,.28,-.48);\n    pR(p.xy, .15);\n    p.z *= .8;\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\n\n    d = smin(d, nostrils, .02);\n\n    p = pp;\n    p += vec3(-.033,.3,-.515);\n    pR(p.xz, .5);\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\n\n    // return d;\n\n    // eyelids\n    p = pp;\n    p += vec3(-.16,.07,-.34);\n    float eyelids = ellip(p, vec3(.08,.1,.1));\n\n    p = pp;\n    p += vec3(-.16,.09,-.35);\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\n\n    // edge top\n    p = pp;\n    p += vec3(-.173,.148,-.43);\n    p.x *= .97;\n    float et = length(p.xy) - .09;\n\n    // edge bottom\n    p = pp;\n    p += vec3(-.168,.105,-.43);\n    p.x *= .9;\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\n\n    float edge = max(max(eb, et), -d);\n\n    d = smin(d, eyelids, .01);\n    d = smin(d, eyelids2, .03);\n    d = smax(d, -edge, .005);\n\n    // eyeball\n    p = pp;\n    p += vec3(-.165,.0715,-.346);\n    float eyeball = length(p) - .088;\n    if (isMap) isEye = eyeball < d;\n    d = min(d, eyeball);\n\n    // tear duct\n    p = pp;\n    p += vec3(-.075,.1,-.37);\n    d = min(d, length(p) - .05);\n\n    \n \t// ear\n    p = pp;\n    p += vec3(-.405,.12,.10);\n    pR(p.xy, -.12);\n    pR(p.xz, .35);\n    pR(p.yz, -.3);\n    vec3 pe = p;\n\n    // base\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\n\n    // inner\n    pR(p.xz, -.5);\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\n    float ridge = iear;\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\n    ear = smax2(ear, -iear, .04);\n    earback = smin(earback, iear - .04, .02);\n\n    // ridge\n    p = pe;\n    pR(p.xz, .2);\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\n\n    float ridger = .01;\n\n    ridge = max(-ridge, ridge - ridger);\n\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\n\n    ear = smin(ear, ridge, .045);\n\n    p = pe;\n\n    // outline\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\n\n    // edge\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\n\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\n    edgeo = smax(edgeo, -edgeoin, .05);\n\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\n    eedent = min(eedent, 1.);\n\n    eedge += eedent * .06;\n\n    eedge = smax(eedge, -edgeo, .01);\n    ear = smin(ear, eedge, .01);\n    ear = max(ear, earback);\n\n    ear = smax2(ear, outline, .015);\n\n    d = smin(d, ear, .015);\n\n    // hole\n    p = pp;\n    p += vec3(-.36,.19,.06);\n    pR(p.xz, -.5);\n    pR(p.xy, -.2);\n    p.x += .02;\n\n    // targus\n    p = pp;\n    p += vec3(-.34,.2,.02);\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\n    p = pp;\n    p += vec3(-.37,.18,.03);\n    pR(p.xz, .5);\n    pR(p.yz, -.4);\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\n    \n    return d;\n}\n\nfloat map(vec3 p) {\n    p -= OFFSET;\n    p /= SCALE;\n   \treturn mHead(p);\n\treturn length(p) - .3;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    int id = faceIdFromDir(rayDir);\n    \n    vec2 coord = fragCoord.xy;\n    vec2 size = iResolution.xy;\n    vec2 uv = coord / size;\n    \n    vec4 lastFrame = texture(iChannel0, rayDir);\n    if (lastFrame.x != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n    \treturn;\n    }\n    \n    mat4 space = texToSpace(coord, id, size);\n    \n    vec3 p0 = space[0].xyz;\n    vec3 p1 = space[1].xyz;\n    vec3 p2 = space[2].xyz;\n    vec3 p3 = space[3].xyz;\n\n    fragColor = vec4(\n        map(p0),\n        map(p1),\n        map(p2),\n        map(p3)\n    );\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define PI 3.14159265359\n\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Read head sdf from '3D' texture\nfloat mHead(vec3 p) {\n    p.x = -abs(p.x);\n    p += OFFSET / SCALE;\n    float bound = fBox(p, 1./SCALE);\n    if (bound > .01) return bound;\n    p *= SCALE;\n    float d = mapTex(iChannel0, p, iChannelResolution[0].xy);\n    return d;\n}\n\nfloat sinstep(float t) {\n\treturn sin(t * PI + PI * .5) * .5 + .5;\n}\n\nfloat map(vec3 p) {\n    p.y -= .06;\n    \n    vec2 im= iMouse.xy / iResolution.xy;\n    im= vec2(.38,.6);\n    \n    if (im.x > 0. && im.y > 0.) {\n    \tpR(p.zx, ((im.x)*2.-1.)*1.5);\n    \tpR(p.zy, ((im.y)*2.-1.)*1.5);\n    }\n\n    float r = sin(1. * fTime * PI * 2. - PI * .6);\n    r = smoothstep(0., 1., clamp((r - .4) * .7, -1., 1.) * .5 + .5);\n    float t = mod(fTime - .2, 1.);\n    r = sinstep(range(.05, .45, fTime)) - sinstep(range(.45, 1., fTime));\n    r = r * .05;\n    pR(p.zy, -r);\n\n    float d = mHead(p);\n    return d;\n}\n\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n}\n\nconst float DISPERSION_SAMPLES = 3.; // Higher = slower but smoother blending\n\nvec3 drawBg(vec3 rd) {\n    float t = atan(rd.y, rd.z);\n    t = sin(t * 15. - fTime * PI * 2.);\n\tvec3 c = vec3(smoothstep(-.2, .0, -1. + t)) * 2.;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n\n    if (iMouse.z > 0.) {\n    \tp /= 1.8;\n    }\n\n    p /= 1.15;\n    \n    float wavelength;\n    vec3 pos;\n    vec3 nor;\n    vec3 rrd;\n    float ri;\n    vec3 sam;\n\n    float rand = texture(iChannel1, fragCoord.xy / iChannelResolution[1].xy).r;\n    rand = fract(rand + 1.61803398875 * float(iFrame)); // https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n\n    vec3 origin = vec3(0,.05,3.2);\n    vec3 rd = normalize(vec3(p + vec2(0,-0),-4));\n    float rayLength = 0.;\n    float dist = 0.;\n\n    for (int i = 0; i < 50; i++) {\n        rayLength += dist;\n\n        pos = origin + rd * rayLength;\n        dist = map(pos);\n\n        if (dist < .0005) {\n            nor = calcNormal(pos);\n\n            for(float r = 0.; r < DISPERSION_SAMPLES; r++){\n                wavelength = r / DISPERSION_SAMPLES;\n                wavelength += (rand * 2. - 1.) * (.5 / DISPERSION_SAMPLES);\n                wavelength = mod(wavelength, 1.);\n\n                ri = 1.3 + (wavelength - .5) * .9;\n                ri = 1. / ri;\n                rrd = refract(rd, nor, ri);\n                col += drawBg(rrd) * spectrum(wavelength);\n            }\n\n            break;\n        }\n\n        if (rayLength > 5.) {\n            break;\n        }\n    }\n\n    col /= DISPERSION_SAMPLES / 2.;    \n    \n    if (iFrame > 2) {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec3 lastcol = texture(iChannel2, uv).rgb;\n        col = mix(lastcol, col, clamp(15. * iTimeDelta, 0., 1.));\n    }\n\n    fragColor = vec4(col,1);\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\n    '3D' Texture Utils\n    ------------------\n\n\tThese allow reading and writing to a cubemap texture that's\n    repurposed as a 3D texture.\n\n*/\n\n\n#define fTime mod(iTime / 3., 1.)\n//#define fTime (0.)\n\nvec2 texSubdivisions = vec2(8,2);\n\n#define MIRROR\n#define SCALE (vec3(4.1,1.73,1.75)/1.1)\n#define OFFSET vec3(.95, .094, -.088)\n\n// #define SCALE vec3(1)\n// #define OFFSET vec3(0)\n\n// Cube face ID from direction\n// 0 x\n// 1 y\n// 2 z\n// 3 -x\n// 4 -y\n// 5 -z\nint faceIdFromDir(vec3 v) {\n    vec3 va = abs(v);\n    int id = 0;\n    float m = va.x;\n    if (va.y > m) id = 1, m = va.y;\n    if (va.z > m) id = 2;\n    if (v[id] < 0.) id += 3;\n    return id;\n}\n\n\n// Direction from uv and cube face ID\n// uv: vec2(0,0) to vec2(1,1)\n// id: 0 to 5\nvec3 dirFromFaceId(vec2 uv, int id) {\n    vec3 dir = vec3(.5, .5 - uv.yx);\n    dir = normalize(dir);\n    if (id == 4) dir.yz *= -1.;\n    if (id > 2) dir.xz *= -1., id -= 3;\n    if (id == 1) return (dir * vec3(1,-1,-1)).zxy;\n    if (id == 2) return (dir * vec3(1,1,-1)).zyx;    \n    return dir;\n}\n\n\n// Divide texture into 3d space coordinates\n// uv = 2d texture coordinates 0:1\n// c = channel 0:3\n// id = face id 0:6\n\n// xy is split for each z\n// z is split across channels and cube map faces (4 * 6 = 24)\n\n// Returns matrix representing four positions in space\n// vec3 p0 = mat4[0].xyz;\n// vec3 p1 = mat4[1].xyz;\n// vec3 p2 = mat4[2].xyz;\n// vec3 p3 = mat4[4].xyz;\n\nvec3 texToSpace(vec2 coord, int c, int id, vec2 size) {\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n    vec2 subCoord = floor(coord / subSize);\n    float z = 0.;\n    z += float(id) * 4. * sub.y * sub.x; // face offset\n    z += float(c) * sub.y * sub.x; // channel offset\n    z += subCoord.y * sub.x; // y offset\n    z += subCoord.x; // x offset\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    z /= zRange;\n    vec2 subUv = mod(coord / subSize, 1.);\n    vec3 p = vec3(subUv, z);\n    p = p * 2. - 1.; // range -1:1\n    return p;\n}\n\nmat4 texToSpace(vec2 coord, int id, vec2 size) {\n    return mat4(\n        vec4(texToSpace(coord, 0, id, size), 0),\n        vec4(texToSpace(coord, 1, id, size), 0),\n        vec4(texToSpace(coord, 2, id, size), 0),\n        vec4(texToSpace(coord, 3, id, size), 0)\n    );\n}\n\n\n// Transform xyz coordinate in range -1,-1,-1 to 1,1,1\n// to texture rayDir and channel\nvec4 spaceToTex(vec3 p, vec2 size) {\n    p = clamp(p, -1., 1.);\n    p = p * .5 + .5; // range 0:1\n\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n\n    // Work out the z index\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float i = round(p.z * zRange);\n\n    // return vec3(mod(i, sub.x)/sub.x);\n    // translate uv into the micro offset in the z block\n    vec2 coord = p.xy * subSize;\n\n    int faceId = int(floor(i / (4. * sub.y * sub.x)));\n    float channel = mod(floor(i / (sub.x * sub.y)), 4.);\n    float y = mod(floor(i / sub.x), sub.y);\n    float x = mod(i, sub.x);\n    \n    // Work out the macro offset for the xy block from the z block\n    coord += vec2(x,y) * subSize;\n\tcoord /= size;\n    \n    vec3 dir = dirFromFaceId(coord, faceId);\n\n    return vec4(dir, channel);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat mapTex(samplerCube tex, vec3 p, vec2 size) {\n    // stop x bleeding into the next cell as it's the mirror cut\n    #ifdef MIRROR\n        p.x = clamp(p.x, -.95, .95);\n    #endif\n    vec2 sub = texSubdivisions;\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float z = p.z * .5 + .5; // range 0:1\n    float zFloor = (floor(z * zRange) / zRange) * 2. - 1.;\n    float zCeil = (ceil(z * zRange) / zRange) * 2. - 1.;\n    vec4 uvcA = spaceToTex(vec3(p.xy, zFloor), size);\n    vec4 uvcB = spaceToTex(vec3(p.xy, zCeil), size);\n    float a = texture(tex, uvcA.xyz)[int(uvcA.w)];\n    float b = texture(tex, uvcB.xyz)[int(uvcB.w)];\n    return mix(a, b, range(zFloor, zCeil, p.z));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3BRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 216]], "test": "untested"}
{"id": "tlKcDd", "name": "Day 410", "author": "jeyko", "description": "pot", "tags": ["mdtmjvm"], "likes": 21, "viewed": 539, "published": 3, "date": "1612041271", "time_retrieved": "2024-07-30T19:41:35.350502", "image_code": "\n// Cyclic Noise from nimitz. \n// fwidth analytic SDF AA suggested by Fabrice (another solution suggested before that by mla, who afaik found it from iq)\n\n// check out triangle mode in common\n\n\nconst float slices = 124.;\n\nconst float sliceDepth = 2.;\n\nfloat yOffs = 1.5;\n\nconst float width = 0.;\n\nconst float aaSteps = 1.; // aa unused\n\n\nfloat fun(vec3 p){\n    float f = 0.;\n    \n    p.z += iTime;\n    f += cyclicNoise(p*2. + vec3(0,iTime*0.2,0), true, iTime*0.1)\n        - mix(-0.5,2.,smoothstep(0.,1.,-p.y))\n        + mix(2.,0.,smoothstep(0.,1.,-abs(p.y )+ yOffs ));\n        \n    f = max(f,-dot(p.xy,p.xy) + 0.);\n\n\n    return f;\n}\n\n\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,yOffs,0);\n    \n    vec3 rd = normalize(vec3(uv,3));\n    rd.yz *= rot(0.4);\n    \n    for(float i = 0.; i < slices; i++ ){\n        \n        float t = plaIntersect( ro - vec3(0,i/slices*sliceDepth,0.), rd, vec4(0,1,0,1.) );\n        t = abs(t);\n        vec3 p = ro + rd*t;\n        \n        float fn = fun(p);\n        \n        \n        float fw = fwidth(fn) ;\n        \n        \n        vec3 c = pal(0.5,vec3(0.6,0.05,.15),vec3(4.9,1.,9),1.,i/slices*22. + iTime*1.);\n        \n        float d = (fn)/fw;\n        \n        float g = smoothstep(1.,0.,abs(d)- width);\n        float gb = smoothstep(1.,0.,d - width);\n        \n        \n        col = mix(col, c*c*0.7*1. + 0.*smoothstep(1.51,0.,abs(fn)*20.0005), gb);\n        col = mix(col, c*2., g);\n        col = max(col,0.);\n\n\n         \n        \n        /*\n            col = mix(col, c*c*0.7, gb);\n            col = mix(col, c*2., g);\n        \n        }*/\n        \n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    col = mix(col,col*col*0.1,exp(-dot(uv,uv)*5422.));\n    \n    col = max(col, 0.);\n\t\n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define pal(a,b,c,d,e) ((a) +(b)*sin((c)*(d) + (e)))\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n// TRIANGLE MODE - substitutes sine for tri \n//#define sin(a) (asin(sin(a))*1.)\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    float gain = 0.8 + sin(p.z*0.2)*0.2;\n    const float lacunarity = 1.4;\n    const int octaves = 5;\n    \n    const float warp = 1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 356, 356, 632], [637, 637, 665, 665, 1720], [1722, 1722, 1779, 1779, 2232]], "test": "untested"}
{"id": "3tcBRn", "name": "flower clock ", "author": "YitingLiu", "description": "psychedelic flower clock moving as time goes by. ", "tags": ["noise", "time", "time", "clock", "flower", "random", "rotate", "psychedelic", "shape", "thickness", "changingcolor", "shapeborder"], "likes": 1, "viewed": 319, "published": 3, "date": "1612026063", "time_retrieved": "2024-07-30T19:41:36.117451", "image_code": "//psychedelic flower clock moving as time goes by. \n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat shape(vec2 st, float radius) {\n\tst = vec2(0.5)-st;\n    float r = length(st)*2.0;\n    float a = atan(st.y,st.x);\n    float m = abs(mod(a+iTime*2.,3.14*2.)-3.14)/3.6;\n    float f = radius;\n    m += noise(st+iTime*0.1)*0.972;\n     a *= 1.0+abs(atan(iTime*-0.376))*0.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f += sin(a*10.)*noise(st+iTime*.2)*.1;\n    f += (sin(a*19.312)*.1*pow(m,2.));\n    return 1.-smoothstep(f,f+0.007,r);\n}\n\nfloat shapeBorder(vec2 st, float radius, float width) {\n    return shape(st,radius)-shape(st,radius-width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    vec3 changingCol = vec3(random(st),noise(st),abs(cos(sin(iTime))));\n    changingCol*=abs(sin(iTime));\n    vec3 color = vec3(changingCol) * shapeBorder(st,1.,abs(tan(iTime*.05)));\n    st-=0.5;\n\n    st*=rotate2d(iTime*3.1415/2.);\n        color/=st.y+st.x*sin(iTime*0.5)*1e1;\n        color/=st.x+st.x*sin(iTime*0.05)*1e1;\n    color-=random(st);\n\n    st+=0.5;\n\n    color += vec3(changingCol*random(st)) * shapeBorder(st,0.8,abs(tan(iTime*.05*0.2)));\n\t color += vec3(changingCol-noise(st)) * shapeBorder(st,0.6,abs(tan(iTime*.05)*0.4));\n\t color += vec3(changingCol+noise(st)) * shapeBorder(st,0.4,abs(tan(iTime*.05)*0.6));\n\t color += vec3(changingCol/random(st)*random(st*0.5)) * shapeBorder(st,0.2,abs(tan(iTime*.05)*0.8));\n\n\tfragColor = vec4( abs(sin(iTime))/color-noise(st), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 75, 75, 214], [215, 215, 243, 243, 351], [352, 437, 459, 459, 863], [865, 865, 893, 893, 979], [981, 981, 1017, 1017, 1416], [1418, 1418, 1473, 1473, 1527], [1529, 1529, 1587, 1587, 2413]], "test": "untested"}
{"id": "ttKyW3", "name": "Perlin Noise Swirls", "author": "pprovins", "description": "First attempt at doing a GPU accelerated version of https://avinayak.github.io/art/2021/01/09/noise-planets.html", "tags": ["perlin"], "likes": 4, "viewed": 428, "published": 3, "date": "1612018277", "time_retrieved": "2024-07-30T19:41:37.017046", "image_code": "const float PI = 3.141527;\n\nvec2 hash2(vec2 p) {\n  return fract(vec2(5978.23857, 2915.98275)*sin(vec2(\n                                                         p.x*832.2388 + p.y*234.9852,\n                                                         p.x*921.7381 + p.y*498.2348\n                                                         )))*2.-1.;\n}\n\nfloat getPerlinValue(vec2 uv, float scale, float offset){\n  uv *= scale;\n  vec2 f = fract(uv);\n  vec2 m = f * f * (3.-f-f);\n  vec2 p = uv - f;\n  \n  float n = mix(\n                mix(dot(hash2(p + offset + vec2(0,0)), f - vec2(0,0)),\n                    dot(hash2(p + offset + vec2(1,0)), f - vec2(1,0)), m.x),\n                mix(dot(hash2(p + offset + vec2(0,1)), f - vec2(0,1)),\n                    dot(hash2(p + offset + vec2(1,1)), f - vec2(1,1)), m.x),\n                m.y);\n  \n  return float(0.5 * n + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = 1.0 - vec3(0.98, 0.96, 0.92);\n    \n    vec2 circCenter = vec2(0.0, 0.0);\n    if(length(circCenter - uv) < 0.5){\n        //col = vec3(1.0, 0.0, 0.0);\n        float circlePoints = 0.0;\n        for(float i = 0.0; i < 250.0; ++i){\n            vec2 randNum = hash2(vec2(i));\n            vec2 position = sin(randNum * iTime * 0.25);\n            float n = 2.0 * PI * getPerlinValue(uv + cos(iTime * 0.5), 3.0 + sin(iTime), 5.0);\n            for(float j = 0.0; j < 5.0; ++j){\n                position.x = mod(position.x + cos(n), 1.0) - 0.5;\n                position.y = mod(position.y + sin(n), 1.0) - 0.5;\n                float dist = length(uv - position);\n                circlePoints += 1.0 - smoothstep(0.009, 0.020, dist);\n            }\n        }\n        col = max(vec3(circlePoints), col);//max(vec3(circlePoints), col);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 48, 48, 343], [345, 345, 402, 402, 861], [863, 863, 920, 971, 2028]], "test": "untested"}
{"id": "wtKyWt", "name": "The Rubber Flag", "author": "Alkama", "description": "A late night fake shiny/specular look test.\n\nThe \"Rubber Pride Flag\" was designed by Peter Tolos and Scott Moats in 1994.\n\n(Special thx to NuSan for the continuity fix, you're awesome!).", "tags": ["rubber", "flag"], "likes": 8, "viewed": 493, "published": 3, "date": "1611999129", "time_retrieved": "2024-07-30T19:41:37.840844", "image_code": "float t;\nconst float pi=acos(-1.0);\nfloat hlane(vec2 uv, float a) { const float aa=0.0025; float a2=a*0.5; return smoothstep(-a2-aa,-a2+aa,uv.y)-smoothstep(a2-aa,a2+aa,uv.y); }\nvec3 flag(vec2 uv) {\n\tconst vec3 r=vec3(0.8275,0.1255,0.0666);\n\tconst vec3 y=vec3(0.988,0.784,0.0);\n\tvec3 c=vec3(0.0);\n\tuv.y-=0.2920;c+=hlane(uv,0.045)*r;\n\tuv.y+=0.0955;c+=hlane(uv,0.146)*y;\n\tuv.y+=0.0955;c+=hlane(uv,0.045)*r;\n\tuv.y+=0.1900;c+=hlane(uv,0.045)*r;\n\treturn c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    t=mod(iTime, 20.0*pi);\n\tfloat motion=sin(sin(t*0.75)+t*0.445);\n\tmotion*=motion*motion;\n\tuv *= 1.0+0.25*uv.x*motion*motion;\n\tuv.x-=0.02+0.04*motion;\n\tvec3 col=vec3(0.0);\n\tfloat decal=(0.9+0.1*sin(uv.x*3.0-(t*2.0)*2.0))*sin(1.5*(sin(t+2.0*sin(t*0.25))-3.0*sin(4.0*uv.x+5.0*uv.y)+uv.x+uv.y)-3.0*t);\n\tuv *= 1.0-0.04*decal;\n\t{\n\t\tvec2 uv = uv, tuv = uv;\n        uv.y += max(0.,dot(tuv,normalize(vec2(1.0,-0.070*pi)))+0.15)*1.6;\n        uv.y += max(0.,dot(tuv,normalize(vec2(1.0,-0.035*pi)))-0.07)*-2.4;\n        col = flag(uv);\n\t}\n\tcol+=0.1*decal+pow(abs(decal), 10.0)*(uv.x+0.1*sin(t+sin(t*2.0)))*0.8;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 67, 67, 176], [177, 177, 197, 197, 452], [453, 453, 510, 510, 1187]], "test": "untested"}
{"id": "3lVcDd", "name": "tuto: progressiv sampling vs GPU", "author": "FabriceNeyret2", "description": "every 4 seconds :\n- reference FPS for full rendering\n- FPS for p% of pixels rendered at random:  no gain at all, because of warp SIMD (see comments in code)\n- FPS for p% of warps rendered at random: gain.\nCrucial for progressive sampling (e.g. path tracin", "tags": ["warp", "tuto", "gpu"], "likes": 4, "viewed": 307, "published": 3, "date": "1611998256", "time_retrieved": "2024-07-30T19:41:38.590838", "image_code": "/* Progressive sampling + cumulate in buffA (e.g. for path tracing), or dithered calculus, are ways to improve FPS.\n   But one has to take care of the structure of parallelism on GPUs:\n   On nVIDIA, warps of 4*8 pixels are evaluated in SIMD, so rendering 1 single pixel in a block \n   costs exactly the same that rendering the full 32  (if the computation story\n   is quite the same in all pixels) : sampling that way is innefficient.\n    better to samples along warps.\n*/\n\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\n#define p    1./16.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    int t = int(iTime/4.) % 3;\n    vec2 R = iResolution.xy;\n    float v = max(0., 10.-length(U-R.y*vec2(.05,.15+float(t)/3.) )); // mode indicator\n    O += v;\n    \n    if (t==1 && hash(U+iTime) > p )                  return;         // eval only proprotion p of pixels\n    if (t==2 && hash(floor(U/vec2(4,8))+iTime) > p ) return;         // eval only proprotion p of warps\n    \n    for (float i=0.; i < 2e4; i++ )                                  // some costly computation\n        O = (.8+.2*cos(O+vec4(U*.1,U.y,0))) * texture(iChannel0, U/R);\n        \n    O += v;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[572, 572, 610, 610, 1188]], "test": "untested"}
{"id": "3lKyDd", "name": "What the Devil?", "author": "kstyler", "description": "Fiery 5 pointed star. ", "tags": ["2d", "flame", "devil"], "likes": 4, "viewed": 305, "published": 3, "date": "1611994160", "time_retrieved": "2024-07-30T19:41:39.340833", "image_code": "#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat random(vec2 p){\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat noise(vec2 uv){\n\tvec2 id = floor(uv*10.);\n    vec2 lc = smoothstep(0.,1.,fract(uv*10.));\n    \n    float a = random(id);\n    float b = random(id + vec2(1.,0.));\n    float c = random(id + vec2(0.,1.));\n    float d = random(id + vec2(1.,1.));\n    \n    float ud = mix(a,b,lc.x);\n    float lr = mix(c,d,lc.x);\n    float fin = mix(ud,lr,lc.y);\n    return fin;\n}\n\nfloat octaves(vec2 uv){\n    float amp = 0.5;\n    float f = 0.;\n    for(int i =1; i<5;i++){\n    \tf+=noise(uv)*amp;\n        uv*=2.;\n        amp*=0.5;\n    }\n    return f;\n}\n\nfloat circle(vec2 uv,float r){\n    return length(uv) - r;\n}\n\nfloat star(vec2 uv, int pts, float r){\n    uv = uv*4.-2.;\n    float tau = 3.141592*2.;\n    float a = atan(uv.y,uv.x)/tau;\n    float seg = a * float(pts);\n    a = ((floor(seg) +.5)/float(pts) + mix(r,-r,step(.5,fract(seg))))*tau;\n    return abs(dot(vec2(cos(a),sin(a)),uv));\n}\n\nfloat stroke(float x, float s, float w){\n    float o = (step(s,x+w)-step(s,x-w));\n    o = clamp(o,0.,1.);\n\treturn o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv+=.5;\n    uv.y+=.05;\n    uv.y = 1.-uv.y;\n    uv.x+=sin(iTime*2.+uv.y*3.)*.02 + cos(iTime*10.+uv.y*20.2)*.01;\n    vec3 col = vec3(0.);\n    float s = star(uv.yx,5,.099+octaves(uv+vec2(0.,iTime/2.))*.06*(.3-uv.y));\n    float s2 = star(uv.yx,5,.888+octaves(uv+vec2(0.,iTime/2.))*.06*(.3-uv.y));\n    col+=min(smoothstep(0.49,.5,s),1.-stroke(circle(uv-.5,.01),.25,.001+octaves(uv+vec2(0.,iTime/2.))*.05*(1.-uv.y)));  \n    col = 1.-col;\n    col*=mix(vec3(1.0,0.,.1),0.6+vec3(0.3,0.5,0.2),uv.y-.1);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 178, 178, 267], [269, 269, 290, 290, 630], [632, 632, 655, 655, 801], [803, 803, 833, 833, 862], [864, 864, 902, 902, 1139], [1141, 1141, 1181, 1181, 1259], [1261, 1261, 1317, 1317, 1930]], "test": "untested"}
{"id": "WlVcWt", "name": "2D Implicit Function Plotter", "author": "oneshade", "description": "2D implicit plotter.", "tags": ["2d", "math", "graph", "function", "plot", "implicit"], "likes": 9, "viewed": 278, "published": 3, "date": "1611979209", "time_retrieved": "2024-07-30T19:41:40.176598", "image_code": "#define CONTOUR_SPACING 1.0\n#define CONTOUR_THICKNESS 2.0\n#define DELTA 0.001\n\n// Hardware derivatives don't seem to produce good contours on my computer\n//#define USE_HARDWARE_DERIVATIVES\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat f(in vec2 p) {\n    p *= 3.0;\n    vec3 p3 = vec3(p, iTime);\n    return dot(sin(p3), cos(p3.zxy));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = CONTOUR_THICKNESS / iResolution.y * 4.0;\n\n    float hSpacing = 0.5 * CONTOUR_SPACING;\n    float fRes = f(uv);\n\n    #ifdef USE_HARDWARE_DERIVATIVES\n    float grad = length(fwidth(fRes)) * iResolution.y / 5.0;\n\n    #else\n    float grad = length(vec2(f(uv + vec2(DELTA, 0.0)) - f(uv - vec2(DELTA, 0.0)),\n                             f(uv + vec2(0.0, DELTA)) - f(uv - vec2(0.0, DELTA)))) / (2.0 * DELTA);\n    #endif\n\n    float contour = abs(mod(fRes + hSpacing, CONTOUR_SPACING) - hSpacing) / grad;\n\n    fragColor = vec4(hue2rgb(fRes * 0.5) - smoothstep(unit, 0.0, contour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVcWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 347, 347, 431], [433, 433, 488, 488, 1156]], "test": "untested"}
{"id": "wlyyDd", "name": "Fractal Wormhole", "author": "jarble", "description": "This fractal's shape changes as I move through it.", "tags": ["3d", "raymarching", "fractal"], "likes": 4, "viewed": 305, "published": 3, "date": "1611969843", "time_retrieved": "2024-07-30T19:41:41.019345", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS/8; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return depth;\n        }\n    }\n    return depth;\n}\n            \n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(iTime*10.0,0,0);\n\n\tvec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp,float time){\n    int t = -int(time * 8000.0);\n    int t1 = (t*1024);\n    t *= ((t1)>>(t));\n    t = (t>>1024&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.)/100.0;\n}\n", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x), (coord.y)));\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)*image_scale) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n            \n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(iTime/8.0);\n    viewDir.xz *= rot(iTime/8.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec4 dmap = depth_map(fragCoord);\n    float l0 = length(eye-dmap.xyz+estimateNormal(dmap.xyz)/10.0); //distance to point in last frame\n\n    float l1 = dmap.w; //distance between points in consecutive frames\n    \n    float l2;\n    if(l1 >= 1.0){ //how much does the depth change between frames?\n        //l2 = max(log(l0)*1.0,0.0);\n        l2 = 0.0;\n        //l2 = 0.0;\n        //l2 = l0*.8;\n        //l0 /= 2.0;\n        //l2 = l0;\n    }\n    else{\n        \n        l2 = l0*.9;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4((p*.5+dmap.yzx*.5), min(0.0,abs(l0-dist)));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SHADOW_ITER 20\n#define image_scale 8.0\n//change Z-buffer resolution\n\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\n\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nconst float MIN_DIST = EPSILON;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n        if(i1 > iters) break;\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p,int iters){\n\treturn sceneSDF(p,1.0,iters);\n}\n\nfloat sceneSDF(vec3 p,float anim){\n\treturn sceneSDF(p,anim,4);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0,4);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 1086], [1101, 1101, 1128, 1128, 1277], [1279, 1279, 1336, 1336, 1854]], "test": "untested"}
{"id": "ttycWt", "name": "Neural Head", "author": "michael0884", "description": "trying to train a SIREN based SDF\nThe LPS head model used as base https://casual-effects.com/data/", "tags": ["sdf"], "likes": 11, "viewed": 525, "published": 3, "date": "1611955974", "time_retrieved": "2024-07-30T19:41:41.865084", "image_code": "// Fork of \"NeuroShrek Tracer\" by michael0884. https://shadertoy.com/view/WtyyWd\n// 2021-01-29 21:24:45\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy); \n    fragColor = tanh(2.5*col/col.w);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 128\n#define MIN_DIST 1e-5\n#define MAX_DIST 8.0\n#define CAM_ANGLE 1e-3\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//internal RNG state \nuvec4 s0; \n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat head(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 0.5) {\n        return length(p)-0.4;\n    }\n    //neural networks can be really compact... when they want to be\nvec4 f0_0=sin(p.y*vec4(1.88,-.81,-.05,-2.36)+p.z*vec4(6.32,-7.54,8.30,2.29)+p.x*vec4(8.00,-3.88,3.96,-2.00)+vec4(5.08,-8.90,8.31,10.01));\nvec4 f0_1=sin(p.y*vec4(-.04,-.37,-6.79,-1.39)+p.z*vec4(.41,8.56,-.99,.76)+p.x*vec4(.32,3.60,7.42,8.09)+vec4(-11.81,-1.23,-4.85,8.52));\nvec4 f0_2=sin(p.y*vec4(3.37,4.65,1.89,-3.96)+p.z*vec4(-.30,-3.34,4.91,.92)+p.x*vec4(-.60,2.87,2.63,-.10)+vec4(6.00,.25,-1.88,-1.05));\nvec4 f0_3=sin(p.y*vec4(5.63,3.39,2.44,-5.25)+p.z*vec4(-2.16,1.23,.91,-5.30)+p.x*vec4(.02,2.07,2.31,6.52)+vec4(-11.97,-10.67,12.86,11.03));\nvec4 f1_0=sin(mat4(.01,.18,.02,-.24,-.02,-.26,.02,-.07,.01,-.56,-.31,.29,-.27,.34,-1.12,-.25)*f0_0+\n    mat4(.06,-.52,.68,-.44,.04,-.04,-.80,.26,-.13,.09,.10,-.05,.10,-.02,-.13,-.18)*f0_1+\n    mat4(-.12,.51,-1.04,-.29,-.10,.08,.03,.54,-.22,-.09,-.10,.48,-.50,-.55,-.07,-.36)*f0_2+\n    mat4(-.26,.05,-.03,.11,.41,.32,.26,-.05,.04,.88,-.36,-.03,.11,-.04,.00,-.07)*f0_3+\n    vec4(-1.44,4.65,-1.85,-7.09))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.13,-.35,-.08,.39,-.27,.29,-.03,-.33,.04,.78,-.46,-.08,-.46,.31,.65,.36)*f0_0+\n    mat4(-1.20,.72,-1.36,-.43,.24,.18,-.65,.55,-.08,.26,.22,-.38,-.19,.13,-.14,.09)*f0_1+\n    mat4(.51,.90,-1.08,.01,-.07,-.02,-.11,-.09,-.01,.15,.52,.41,-.14,.79,.77,.06)*f0_2+\n    mat4(-.30,.54,.37,-.20,.44,.99,.53,-.00,-.06,.02,1.25,.12,.07,-.30,-.08,.27)*f0_3+\n    vec4(-2.26,7.29,2.56,-6.35))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.27,-.15,.32,.14,.40,.14,-.01,-.12,.10,.07,.05,-.33,1.00,.25,.36,-.62)*f0_0+\n    mat4(-.25,-.68,-.71,.28,-.09,-.23,.27,-.14,.07,-.10,.12,-.08,-.29,-.06,.32,.14)*f0_1+\n    mat4(.25,.52,.02,-.05,-.42,-.14,.50,.37,.27,-.31,.61,.00,.06,-.28,-.21,-.59)*f0_2+\n    mat4(.05,-.05,.01,.12,.44,.23,.35,.14,-.57,.67,-.42,.11,.08,-.13,-.11,-.02)*f0_3+\n    vec4(-5.91,-6.82,4.07,7.43))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.28,.09,.28,.24,-.12,-.17,.12,-.40,.12,-.08,-.13,-.02,-1.39,-.55,.46,-.13)*f0_0+\n    mat4(.67,.36,-.20,-.04,.11,.07,-.08,-.22,.09,-.07,.08,-.02,.12,-.06,.24,.40)*f0_1+\n    mat4(-1.09,-.85,.29,-.08,.04,-.49,-.28,.09,.14,.12,.13,.19,-.38,-.15,.15,.18)*f0_2+\n    mat4(-.13,-.18,.08,.27,.33,-.07,-.48,.58,-.33,-.65,-.51,-.07,-.02,-.09,-.00,-.65)*f0_3+\n    vec4(4.36,-1.86,-5.92,6.75))/1.0+f0_3;\nvec4 f2_0=sin(mat4(-.09,-.07,-.51,.25,.47,.30,-.30,.05,1.07,.04,-.18,.55,.05,.17,.17,.02)*f1_0+\n    mat4(-.39,-.05,.47,-.84,.61,.03,-.34,-.33,-.03,.15,-.12,-.04,-.02,.18,.27,.68)*f1_1+\n    mat4(-.36,-.08,.97,-.25,.45,.35,.40,.84,-.16,.09,-.07,.19,-.42,-.74,-.16,-.30)*f1_2+\n    mat4(.31,.06,.02,.92,-.76,.73,.26,-.63,-.38,-.01,1.53,-.31,-.11,-.16,-.00,-1.03)*f1_3+\n    vec4(-4.95,-.21,-2.47,-.85))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.53,-.21,.23,.27,.26,-.38,.41,.24,-.06,-1.12,.86,.06,-.32,.38,.32,.18)*f1_0+\n    mat4(-.14,-1.02,-.38,-.28,.07,-.10,.27,-.06,.09,-.53,.23,.05,.02,-.78,.43,.09)*f1_1+\n    mat4(-.43,.31,-.23,-.25,.04,-1.50,.33,-.01,.29,-1.63,-.22,.23,-.29,.61,-.02,-1.00)*f1_2+\n    mat4(-.08,.74,.03,.12,-.03,-.22,.69,.28,-.61,-.62,-.95,-.56,.12,.80,-.50,.06)*f1_3+\n    vec4(-4.10,6.87,-5.48,6.59))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.24,-.26,-.40,.01,.45,.72,-.21,-.39,.01,.24,.94,.12,.11,.32,-.20,.08)*f1_0+\n    mat4(-.09,.29,-.39,.43,-.15,-.02,.47,-.42,-.08,-.25,.09,-.15,.10,-.11,.38,-.28)*f1_1+\n    mat4(-.22,.26,-.87,.44,-.15,-.39,.22,-.33,.29,-.15,-.10,-.45,-.82,.91,-.80,.47)*f1_2+\n    mat4(.23,-.20,.27,-.35,.17,-.57,-.72,-.08,-.83,.54,.23,.73,.02,.38,-.08,-.25)*f1_3+\n    vec4(3.58,-3.04,5.11,5.56))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.30,.13,.16,.20,.42,.39,.37,.55,.32,.21,-.00,.23,.22,-.38,-.21,.35)*f1_0+\n    mat4(.05,.52,-.81,-.07,.43,.06,-.69,.13,.11,-.12,.04,-.14,.32,.47,.46,.05)*f1_1+\n    mat4(-.04,.14,-.22,-.24,1.01,-.23,1.28,.20,1.11,-.09,.67,-.06,-1.17,.19,-.20,.13)*f1_2+\n    mat4(.34,-.27,.57,.39,.50,-.05,-.21,.09,-.06,-.77,-.44,-.66,.19,-.27,-.60,.72)*f1_3+\n    vec4(-4.60,-2.76,-.76,-2.67))/1.4+f1_3;\nreturn dot(f2_0,vec4(-.07,-.05,-.05,-.06))+\n    dot(f2_1,vec4(.11,-.02,-.04,-.05))+\n    dot(f2_2,vec4(.05,-.09,-.02,.05))+\n    dot(f2_3,vec4(-.06,-.06,.05,.05))+\n    0.077;\n}\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 plane = vec2(p.z + 0.3, 0);\n    vec2 h = vec2(0.85*head(p), 1);\n    return opUnion(h, plane);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p).x - vec3(scene(k[0]).x,scene(k[1]).x,scene(k[2]).x));\n}\n\nfloat trace(inout vec4 ro, vec3 rd)\n{\n    vec2 de = vec2(-1);\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        de = scene(ro.xyz); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de.x - 2.0*step(de.x, md)*md); \n        if(de.x < md) return de.y;\n        if(ro.w > MAX_DIST) return -1.0;\n    }\n    return de.y;\n}\n\nvec3 pathtrace(vec4 ro, vec3 rd)\n{\n    vec3 outcol = vec3(0.); vec3 matcol = vec3(1.);\n    for(int i = 0; i<3; i++)\n    {\n        float hit = trace(ro, rd);\n        if(hit>=0.0)\n        {\n            vec3 n = norm(ro.xyz); //geometric normal\n           \n            float roughness =(rand()>0.5)?0.5:0.05;\n            if(hit == 0.0)\n            {\n                bool tile =mod(ro.x, 1.0) + mod(ro.y, 1.0) > 1.0;\n                matcol *= tile?vec3(0.780,0.678,0.678):vec3(1.000,1.000,1.000); \n            }\n            else\n            {\n                matcol *= vec3(0.804,0.914,0.996);\n            }\n            vec3 m = normalize(nrand3(roughness, n)); //material normal\n            rd = reflect(rd,m);\n        }\n        else\n        {\n            outcol += matcol*pow(texture(iChannel1, rd.xzy).xyz,vec3(2.0));\n            break;\n        }\n    }\n    return outcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //RNG\n    s0 = uvec4(fragCoord, uint(iFrame), uint(fragCoord.x) + uint(fragCoord.y));\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragCoord += rand2();\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-1.0,0,-0.1);\n    \n    float yrot = 0.5 - 0.5*mouse.y;\n    float zrot = 3. + 4.0*mouse.x;\n    if (iMouse.z > 0.) {\n        fragColor *= 0.0;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    init = erot(init, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    fragColor += vec4(pathtrace(vec4(init, 0.), cam), 1.0);\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycWt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[299, 299, 356, 356, 457]], "test": "untested"}
{"id": "3tGcWd", "name": "Day 409", "author": "jeyko", "description": "spiktato ", "tags": ["mdtmjvm"], "likes": 17, "viewed": 379, "published": 3, "date": "1611955057", "time_retrieved": "2024-07-30T19:41:42.617073", "image_code": "// Fork of \"day idk wip\" by jeyko. https://shadertoy.com/view/ttKcWc\n// 2021-01-29 16:17:36\n\n// Fork of \"Day 407\" by jeyko. https://shadertoy.com/view/3tycWV\n// 2021-01-29 08:24:51\n\n// Fork of \"Day 405\" by jeyko. https://shadertoy.com/view/ttVcRt\n// 2021-01-27 11:17:18\n\n\nconst float slices = 100.;\n\nconst float aaSteps = 2.; // not really steps, it's the exponentially ^3 area growing area around the fragCoord \n\nconst float disp = .4;\n\nconst float width = 0.002;\n\n#define pal(a,b,c,d,e) ((a) +(b)*sin((c)*(d) + (e)))\n\n#define sin(x) mix( sin(x), abs(fract((x + 3.14/2.*sin(iTime*0.5))/3.14*1.) - 0.5)*2., (sin(iTime)*0.5 + 1.)*0.52)\n\nfloat fun(float p, float py){\n    py *= 90. + sin(iTime)*15.;\n    \n    py += iTime*8.;\n    p *= 1.;\n    float f = abs(sin(p*9. + sin(py*(.15)*1.5  )*9.));\n    \n    f = pow(max(f,0.001),3.);\n    \n    f += (sin(py*0.1 + iTime + sin(p*8. + iTime*.5 + sin(py*2.)*0.1)))*.2;\n    \n    return f*disp;\n}\n\n\nfloat graph(float y, float fn0){\n  return smoothstep(1. ,0., \n                    abs(fn0-y)/fwidth(fn0-y)- width);\n}\nfloat graphNoAbs(float y, float fn0){\n  return smoothstep(1.,0., \n                    -(fn0-y)/fwidth(fn0-y) - width);\n}\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec2 ouv = uv;\n    uv = vec2(atan(uv.y,uv.x),log(length(uv) ));\n    \n    for(float i = 0.; i < slices; i++ ){\n        vec2 p = uv + vec2(0.,i/slices*5. );\n        \n        float fn = fun(p.x,i/slices);\n        \n        float bg = graphNoAbs( p.y, fn);\n        \n        col *= 1.- bg;\n        \n        vec3 c = pal(0.5,vec3(0.6,0.05,.15),vec3(4.9,1.,9),1.,i + iTime*4.);\n        col += 2.*bg*max(c,0.);\n        \n        c -= 1.;\n        \n        #define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n        \n        c.xz *= rot(-1.5);\n        \n        c += 1.;\n        col = mix(col, c*0.2*c*c, graph( p.y, fn ));\n        \n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    col = max(col, 0.);\n\t\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    col = mix(col,col*col*0.1,exp(-dot(uv,uv)*5422.));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[636, 636, 665, 665, 931], [934, 934, 966, 966, 1051], [1052, 1052, 1089, 1089, 1172], [1175, 1175, 1203, 1203, 1956], [1958, 1958, 2015, 2015, 2430]], "test": "untested"}
{"id": "ttyyWt", "name": "Another Neural Bunny Variation", "author": "oneshade", "description": "Another variation of blackle's neural network bunny distance estimator: [url=https://www.shadertoy.com/view/wtVyWK]https://www.shadertoy.com/view/wtVyWK[/url].", "tags": ["bunny", "neuralnetwork", "stanfordbunny", "siren", "testmodel"], "likes": 4, "viewed": 226, "published": 3, "date": "1611950251", "time_retrieved": "2024-07-30T19:41:43.415937", "image_code": "// Neural Network distance estimator for Stanford Bunny: https://www.shadertoy.com/view/wtVyWK\nfloat sdStanfordBunny(in vec3 p, in float s){\n    p/=vec3(-s,s,s);\n    p+=vec3(.08,.475,0);\n    p=p.zxy;\n\n    if (length(p)>1.) return length(p)-.8;\n\n    vec4 x=vec4(p,1),\n    f00=sin(x*mat4(-1.74,-1.05,-1.82,2.64,-3.5,-4.23,2.91,-3.83,-.67,2.72,1.37,10.45,-1.46,-1.9,3.0,5.41)),\n    f01=sin(x*mat4(-3.12,-3.3,1.11,-1.54,2.91,-2.94,.82,-9.88,.92,1.34,2.62,2.71,1.16,1.04,-1.25,-9.69)),\n    f02=sin(x*mat4(3.42,-1.21,2.28,9.64,-2.02,1.15,1.83,-4.09,3.23,-.52,2.07,5.01,.52,-.6,3.35,.87)),\n    f10=sin(mat4(-.99,.53,-.28,.66,.15,-.02,-.09,-.06,-.01,-.05,-.04,-.56,-.1,-.31,-.83,-.43)*f00+mat4(.15,.04,-.09,.21,.42,-.23,.02,.17,.23,.31,.6,.56,-.93,1.47,.0,-.48)*f01+mat4(.71,-.44,-.18,.43,-.6,.42,.45,.5,-.92,.35,-.72,-.44,.0,.76,-.31,-.05)*f02+vec4(-13.95,-3.14,5.36,-9.25)),\n    f11=sin(mat4(-.54,-.75,-.21,-.24,-.38,.06,-.03,.55,.81,.51,-1.12,-.01,-.38,.11,-.02,.67)*f00+mat4(.11,.15,-.05,1.59,.04,-.23,-.18,-1.16,-.08,-.14,-.53,-.07,.23,-.36,-.4,-.15)*f01+mat4(.72,.28,-.18,-.61,.22,-.23,-.65,.28,.83,.41,.11,-.29,-.39,-.32,-.92,-.51)*f02+vec4(-4.81,6.95,9.26,-6.26)),\n    f12=sin(mat4(.73,.76,-.2,-1.04,-.46,.18,.21,1.15,-.06,-.43,.94,.13,.37,-.67,.6,.11)*f00+mat4(.38,.4,.04,.88,-.27,-1.18,.03,-.33,.14,1.54,.69,1.17,.37,1.3,.26,-1.7)*f01+mat4(.33,.42,-.4,-.97,-.23,.84,.42,-.1,-.67,.39,-.84,-.62,.45,.69,.37,1.29)*f02+vec4(-4.38,5.86,13.65,-9.16)),\n    f20=sin(mat4(-.39,.06,1.14,.07,-.06,-.82,.13,-.17,.19,-.79,-1.93,.11,-.39,-.02,-.48,-.05)*f10+mat4(-.51,-.77,-.35,-.02,.1,.47,-1.25,.08,-.1,-.3,1.4,.13,-.1,.21,-.59,.21)*f11+mat4(-.23,.03,-.68,-.08,.06,.15,1.01,-.11,-.27,-.01,-1.56,.02,-.34,.06,.51,.13)*f12+vec4(4.79,-5.84,7.28,4.74)),\n    f21=sin(mat4(.18,.07,.29,-.19,.59,-.03,-.27,.18,.05,.16,.17,-.06,.14,.36,-.24,.0)*f10+mat4(-.38,-.24,-.07,.23,.11,.1,.04,.55,.3,-.2,-.09,.03,.12,.13,.05,.01)*f11+mat4(-.09,.19,.08,.15,.18,.06,-.08,-.03,-.26,-.09,.15,.17,-.06,.07,.14,.19)*f12+vec4(-7.29,1.85,-4.88,.69)),\n    f22=sin(mat4(.32,-.19,.24,.29,.95,.0,.93,.07,1.3,-.76,-.57,-.45,.22,.87,-.6,.95)*f10+mat4(-.65,-.3,-.38,-.3,-.61,.58,-.78,1.04,-.32,-.06,.12,.59,-.94,-.06,-.04,-.07)*f11+mat4(.16,-.5,.46,1.24,.39,-.43,.28,-.91,-.76,-.98,-1.13,.27,-1.26,-.3,-.01,-.11)*f12+vec4(-6.24,1.26,-1.13,-13.77));\n\n    return (dot(vec4(-.18,.16,.02,-.4),f20)+dot(vec4(-.18,-.51,-.55,.39),f21)+dot(vec4(.03,.08,.11,.05),f22)+.28)*s;\n}\n\nfloat mapScene(in vec3 p, in float bounce, in float stretch) {\n    p.y /= stretch;\n    p.y -= bounce;\n    return sdStanfordBunny(p - vec3(-0.5, 0.5, 0.0), 3.0);\n}\n\nvec3 getNormal(in vec3 p, in float bounce, in float stretch) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy, bounce, stretch) - mapScene(p - e.xyy, bounce, stretch),\n                          mapScene(p + e.yxy, bounce, stretch) - mapScene(p - e.yxy, bounce, stretch),\n                          mapScene(p + e.yyx, bounce, stretch) - mapScene(p - e.yyx, bounce, stretch)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float frac1 = 1.0 - fract(iTime);\n    float frac2 = fract(iTime);\n    float stretch = frac1 * (1.0 - frac1) * 2.5 + 0.5;\n    float bounce = frac2 * (1.0 - frac2) * 5.0;\n\n    float t = 0.0;\n    for (float i=0.0; i < 100.0; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p, bounce, stretch);\n        if (d < 0.001) {\n            vec3 n = getNormal(p, bounce, stretch);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 tex1 = texture(iChannel0, p.xy).rgb;\n            vec3 tex2 = texture(iChannel0, p.xz).rgb;\n            vec3 tex3 = texture(iChannel0, p.yz).rgb;\n\n            // How to remove texture slipping?\n            float w1 = n.x * n.x;\n            float w2 = n.y * n.y;\n            float w3 = n.z * n.z;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += tex1 * w1 + tex2 * w2 + tex3 * w3 * max(0.2, lambertian);\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += max(0.0, pow(specAngle, 16.0));\n            }\n\n            break;\n        }\n\n        if (t > 20.0) {\n            fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 95, 140, 140, 2424], [2426, 2426, 2488, 2488, 2588], [2590, 2590, 2652, 2652, 3000], [3002, 3002, 3057, 3057, 4949]], "test": "untested"}
{"id": "WtycDt", "name": "flow like the hot chocolate", "author": "YitingLiu", "description": "Creating the texture of hot chocolate flowing. ", "tags": ["2d", "noise", "texture", "blackandwhite", "turbulence", "flow", "function", "chocolate", "material", "tweak", "twist"], "likes": 2, "viewed": 306, "published": 3, "date": "1611931117", "time_retrieved": "2024-07-30T19:41:44.288604", "image_code": "#define PI 3.141592653\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n    // m /=m/0.02;\n    m *=p*abs(sin(iTime/PI));\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0*abs(sin(iTime*0.05));\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 30\nfloat turbulence (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.25;\n    float frequency = 0.0;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * abs(snoise(st));\n        st *= 0.5;\n        amplitude *= 0.04;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st-=min(st.x,st.y)/2.;\n    st*=rotate2d(st.x*sin(iTime*0.2)*PI)-0.08;\n    st*=rotate2d(st.y*cos(iTime*0.05)-2.*PI);\n    color -= turbulence(st*6.);\n    st+=min(st.x,st.y)/2.;\n\n    fragColor = vec4(smoothstep(0.01,0.02,color+st.y*st.x),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtycDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 49, 70, 70, 117], [118, 118, 139, 139, 186], [187, 187, 209, 209, 244], [245, 245, 273, 273, 359], [361, 361, 383, 436, 2203], [2224, 2224, 2255, 2277, 2543], [2545, 2545, 2601, 2601, 2961]], "test": "untested"}
{"id": "3tGcWt", "name": "bokeh (ml approach)", "author": "NLIBS", "description": "Separated circle bokeh into two spatial passes using offline gradient descent, 128 samples used for what's normally ~1257 sample filter (radius 20 pixels).\n\nUpdate - added a github repo for the python code: https://github.com/Nl1bs/Machine-learned-bokeh\n\n", "tags": ["blur", "filter", "dof", "bokeh", "seperable"], "likes": 44, "viewed": 1434, "published": 3, "date": "1611927880", "time_retrieved": "2024-07-30T19:41:45.145313", "image_code": "//pass 2\n#define v3 vec3\n#define v2 vec2\nconst int SAMPLES = 41;\nconst v3 kernel[SAMPLES] = v3[](\n    v3(-14,-4,0.010556), v3(-13,-7,0.0220622), v3(-13,-3,0.0106089), v3(-13,-2,0.0138105), v3(-13,1,0.0241276), v3(-13,4,0.018078), v3(-11,-10,0.0152755), v3(-11,6,0.0173816), v3(-10,-10,0.0080971), v3(-9,8,0.0109473), v3(-8,-12,0.0167525), v3(-8,9,0.0134778), v3(-5,-13,0.0140858), v3(-5,10,0.0169594), v3(-4,-5,0.0136783), v3(-3,-13,0.0088453), v3(-3,-6,0.0152172), v3(-3,-5,0.0127249), v3(-3,-3,0.0111569), v3(-3,1,0.0079278), v3(-3,2,0.0136226), v3(-3,3,0.0184189), v3(-2,1,0.0093688), v3(-2,10,0.0136266), v3(-1,-13,0.0144894), v3(0,10,0.0102296), v3(1,-12,0.0101111), v3(2,9,0.0155008), v3(3,-11,0.0139016), v3(4,8,0.0117719), v3(5,-10,0.0102714), v3(5,-9,0.0071847), v3(5,6,0.0147457), v3(6,-7,0.0123404), v3(6,-2,0.0021469), v3(7,-6,0.0103128), v3(7,-4,0.0176724), v3(7,1,0.0144658), v3(7,4,0.0193837), v3(8,-2,0.0141245), v3(8,1,0.0082815)\n);\n\nvoid mainImage( out vec4 fragColor, in v2 fragCoord )\n{\n    v2 pix = 1./iResolution.xy;\n    v2 uv = fragCoord*pix;\n    float pl = (iMouse.z>0.) ? iMouse.y*pix.y : 0.5+sin(iTime)*0.4;\n    float coc = get_coc(uv.y, pl);\n    \n    v3 acc = v3(0);\n    for (int i = 0; i<SAMPLES; i++) {\n        v3 tap = kernel[i];        \n        acc   += tap.z*texture(iChannel0, uv+pix*tap.xy*coc).rgb;\n    }\n    \n    v3 col    = max(acc,0.);\n    col       = v3(1) - exp(-col * EXPOSURE); //tone mapping\n    col       = pow(col,v3(1./GAMMA));        //gamma correction combined with hdr effect\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GAMMA 4.5\n#define EXPOSURE 1.5\n#define THRESHOLD 0.08\n#define NEAR 0.3\n#define APERTURE 2.5\n\nfloat get_coc(float z, float pl)\n{\n    return abs(z-pl)/(z+NEAR)*APERTURE;\n}", "buffer_a_code": "//pass 1\n#define v3 vec3\n#define v2 vec2\nconst int SAMPLES = 87;\nconst v3 kernel[SAMPLES] = v3[](\n    v3(-3,-2,0.0099343), v3(-3,-1,0.0158491), v3(-3,0,0.0198582), v3(-3,1,0.0193742), v3(-3,2,0.01562), v3(-3,3,0.0092086), v3(-2,-3,0.0036023), v3(-2,-2,0.017351), v3(-2,-1,0.026431), v3(-2,0,0.0318141), v3(-2,1,0.0318476), v3(-2,2,0.0282652), v3(-2,3,0.0207794), v3(-2,4,0.0100408), v3(-1,-3,0.0118306), v3(-1,-2,0.0230702), v3(-1,-1,0.028688), v3(-1,0,0.0287297), v3(-1,1,0.0291755), v3(-1,2,0.0288904), v3(-1,3,0.0242141), v3(-1,4,0.0133157), v3(0,-3,0.0177183), v3(0,-2,0.0269386), v3(0,-1,0.0255012), v3(0,0,0.0231038), v3(0,1,0.0240891), v3(0,2,0.0266765), v3(0,3,0.026509), v3(0,4,0.0185881), v3(1,-4,0.0066892), v3(1,-3,0.0225386), v3(1,-2,0.0271861), v3(1,-1,0.0236909), v3(1,0,0.0199988), v3(1,1,0.0204911), v3(1,2,0.0250744), v3(1,3,0.0265619), v3(1,4,0.0210398), v3(2,-4,0.0087099), v3(2,-3,0.0241667), v3(2,-2,0.027311), v3(2,-1,0.0227511), v3(2,0,0.019024), v3(2,1,0.0192731), v3(2,2,0.023786), v3(2,3,0.0278565), v3(2,4,0.022605), v3(2,5,0.0069317), v3(3,-4,0.0080222), v3(3,-3,0.0218081), v3(3,-2,0.0268296), v3(3,-1,0.0238996), v3(3,0,0.0200351), v3(3,1,0.0195484), v3(3,2,0.0230739), v3(3,3,0.0269896), v3(3,4,0.0210053), v3(3,5,0.0032463), v3(4,-3,0.0189985), v3(4,-2,0.026861), v3(4,-1,0.0267855), v3(4,0,0.0236707), v3(4,1,0.0230364), v3(4,2,0.0262396), v3(4,3,0.0261808), v3(4,4,0.0176466), v3(5,-3,0.0156334), v3(5,-2,0.0255458), v3(5,-1,0.0285479), v3(5,0,0.029006), v3(5,1,0.0285642), v3(5,2,0.0279639), v3(5,3,0.0220895), v3(5,4,0.011235), v3(6,-3,0.007862), v3(6,-2,0.021451), v3(6,-1,0.0280171), v3(6,0,0.0326608), v3(6,1,0.032852), v3(6,2,0.0261432), v3(6,3,0.0160087), v3(7,-2,0.0028554), v3(7,-1,0.0142694), v3(7,0,0.0180889), v3(7,1,0.0194572), v3(7,2,0.0142807)\n);\n\nvoid mainImage( out vec4 fragColor, in v2 fragCoord )\n{\n    v2 pix    = 1./iResolution.xy;\n    float asp = iResolution.y*pix.x;\n    v2 uv     = fragCoord*pix;\n    float pl  = (iMouse.z>0.) ? iMouse.y*pix.y : 0.5+sin(iTime)*0.4;\n    v2 coc    = get_coc(uv.y, pl)*v2(1,asp); //fix verical blur stretching\n    \n    uv.y *= asp; //must be after get_coc\n    uv.x += iTime*0.1;\n    \n    v3 acc = v3(0);\n    for (int i = 0; i<SAMPLES; i++) {\n        v3 tap  = kernel[i];\n        v3 samp = texture(iChannel0, (uv+pix*tap.xy*coc)*2.5).rgb; //Multiply coords for some cheap detail\n        samp    = max(samp - THRESHOLD,0.) / (1.-THRESHOLD);\n        acc    += tap.z*pow(samp,v3(GAMMA)*v3(0.8,0.7,1));\n    }\n\n    fragColor = vec4(acc,1);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[951, 951, 1006, 1006, 1555]], "test": "untested"}
{"id": "WlycWt", "name": "Abyss!", "author": "illus0r", "description": "Directed by Darya Kolesnikova https://youtube.com/channel/UC-92Wm8nea2J6hX5jN166Eg\nMade with code by Ivan Dianov https://twitter.com/i_dianov\nMusic by Leonid Zazulin https://soundcloud.com/skillpnk", "tags": ["video"], "likes": 2, "viewed": 258, "published": 3, "date": "1611927719", "time_retrieved": "2024-07-30T19:41:46.198498", "image_code": "// PLEASE, FabriceNeyret2, DO NOT READ THIS\n\n#define MAX_STEPS 70\n#define MAX_DIST 90.\n#define EPSILON .01\n#define PI 3.14159265\n\n#define EMPTY 0.\n#define MIRROR 1.\n#define BLUE 2.\n#define BLACK 3.\n#define RED 4.\n#define WHITE_MIRROR 5.\n#define PUREWHITE 6.\n#define FUNNEL 7.\n#define GLOW 8.\n#define ROCKET 9.\n#define METHEORS 10.\n#define LIGHTNING 11.\n#define TUNNEL 12.\n#define BUGNETWORK 13.\n#define FUNNEL_BUGNETWORK 14.\n\n#define BEAT0 texture(iChannel0, vec2(0.25, 0.25) ).x\n#define BEAT1 texture(iChannel0, vec2(0.5, 0.25) ).x\n#define BEAT2 texture(iChannel0, vec2(0.75, 0.25) ).x\n\n#define FUNNELROT p.xy+=vec2(sin(p.z),cos(p.z))*.4*smoothstep(7.8, 8.2, T)*sin(T*3.1415);p.x-=2.0*sin(T*5.);p.xy*=rot(sin(T*4.*PI)*.05)\n#define CHUNK  4.28125\n#define ROCKET_LIGHTNINGS_SWING p.y+=(2.*noise(vec2(iTime+1.))-1.)*2.;p.x += (2.*noise(vec2(iTime+5.))-1.)*2.;\n\n\n#define tBeam vec2(.2,.5)\n\n#define PHI (sqrt(5.)*0.5 + 0.5)\n// Total time (1. = 1 beat)\n#define T ((iTime-.36) / 4.28125)+0.\n// Number of current beat\n#define Ti floor(T)\n// Number of current subbeat (03)\n#define ti floor(t*4.)\n\nfloat rnd(float x) {return 2.*fract(54321.987139 * sin(987.123452331 * x))-1.;}\n#define strLen 32.\n\nfloat text(vec2 uv, float t)\n{\n    float o=0.;\n    vec2 FC = uv*iResolution.xy;\n    int str[int(strLen)];\n    float id = floor(uv.x*strLen);\n    float thresh = .49;\n    uv.x-=id/strLen;\n    uv.x*=strLen;\n    float names[3];\n    for(int n=0; n<3; n++){\n        if(n==0)\n            if(uv.y>.5)str = int[](48,48,48,48,84,121,130,117,115,132,117,116,48,114,137,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n            else {str = int[](48,48,48,48,84,113,130,137,113,48,91,127,124,117,131,126,121,123,127,134,113,48,48,48,48,48,48,48,48,48,48,48);thresh+=.01+.1*pow(rnd(iTime+length(FC)),16.);}\n        if(n==1)\n            if(uv.y>.5)str = int[](48,48,48,48,93,113,116,117,48,135,121,132,120,48,115,127,116,117,48,114,137,48,48,48,48,48,48,48,48,48,48,48);\n            else str = int[](48,48,48,48,89,134,113,126,48,84,121,113,126,127,134,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n        if(n==2)\n            if(uv.y>.5)str = int[](48,48,48,48,93,133,131,121,115,48,114,137,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n            else str = int[](48,48,48,48,92,117,127,126,121,116,48,106,113,138,133,124,121,126,48,48,48,48,48,48,48,48,48,48,48,48,48,48);\n        int i=int(float(str[int(id)])+32.*0.)%256;\n        ivec2 xy=ivec2(i%16,16-i/16);\n        vec2 uv_ = uv;\n        uv_.y=clamp(uv_.y*16.-7.-(uv_.y>.5?1.:0.),0.,1.);\n        names[n] = texture(iChannel1,vec2(xy)/16.+uv_/16.).a;\n    }\n\n    float name = mix(1.,names[0],smoothstep(.0,1.5,t-0.));\n    name = mix(name,names[1],smoothstep(.0,1.5,t-3.));\n    name = mix(name,names[2],smoothstep(.0,1.5,t-6.));\n    o += step(-thresh,-name);\n    o = min(o,1.-smoothstep(.6,.8,t-9.));\n    return o;\n}\n\nfloat g_glow;\n\nmat2 rot(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0); }\nfloat sdOctahedron( vec3 p, float s) { p = abs(p); float m = p.x+p.y+p.z-s; vec3 q; if( 3.0*p.x < m ) q = p.xyz; else if( 3.0*p.y < m ) q = p.yzx; else if( 3.0*p.z < m ) q = p.zxy; else return m*0.57735027; float k = clamp(0.5*(q.z-q.y+s),0.0,s); return length(vec3(q.x,q.y-s+k,q.z-k)); }\nfloat opSmoothUnion( float d1, float d2, float k ) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ){float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );return mix( d2, -d1, h ) + k*h*(1.0-h); }\n//float sdTorus(vec3 p, vec2 t){ vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat snoise(vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n        permute( i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n        dot(x0,x0),\n        dot(x1,x1),\n        dot(x2,x2)\n    ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n    //https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nvec2 p2d(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\nvec2 d2p(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\nvec2 snowflakeSymmetry(vec2 p, float rays){\n    vec2 ar = d2p(p);\n    float astep = 2. * 3.1415 / rays;\n    float a = ar.x, r = ar.y;\n    a = mod(a, astep);\n    a -= astep / 2.;\n    a = abs(a);\n    p = p2d(vec2(a, r));\n    return p;\n}\nfloat sdWater(vec3 p) {\n    float tt = iTime * 10.1;\n    p.y += .001*sin(p.z*17.+tt);\n    p.y += .001*sin(p.z*13.+tt);\n    p.y += .001*sin(p.x*11.+tt*.5);\n    return p.y;\n}\nfloat bullets (vec3 p){\n    float dist = length(p);\n    p.z+=iTime*1.;\n    p.xy*=rot(p.z+p.z*BEAT0*.001);\n    p.xy*=(1.+2.1*BEAT0);\n    p = mod(p,1.)-.5;\n\treturn (length(p)*(1.-.01*BEAT1)-.02)*.7*(1.+8.*smoothstep(10., 10.1, dist));\n}\nfloat rocket (vec3 p){\n    //if(T>4. && T<4.25){\n    \t//p.z += 4.;\n    \t//p.z += fract(T*40.)*.1;\n    \tp.z -= 10.-10.*pow(smoothstep(4., 4.25, T),1.);\n        //pow(1.-mod(T*4.,1.),.8)\n    //}\n    //if(T>4.25){\n    \tp/=1.+(BEAT2)*1.;\n    //\tp.y/=((BEAT2))*4.;\n    //\tp.z-=((BEAT2))*8.;\n    //\tp.xz*=((BEAT2))*3.;\n    //\tp.xy *= rot(PI/4.);\n    //}\n    float sph=length(p)-1.3-5.*smoothstep(8.,8.5,T); \n        //-0.*pow(sin((T-.25)*PI*8.)*.5+.5,16.) // time beat\n        //-0.*pow(BEAT2,1.5)*4.-.2; // sound beat\n    //for(float i=2.;i<3.;i+=0.5){\n    //    // float shift = 4.*sin(iTime*i);\n    //    // float shift = 20.*(fract(.1*iTime*(1.2+.4*Rnd(i))+Rnd(i))*2.-1.)*i;\n    //    float shift = tan(iTime*(1.2+.4*rnd(i))+rnd(i));\n    //    float spread = 4.;\n    //    sph=opSmoothUnion(sph, (length(p*i+vec3(spread*rnd(i),shift,spread*rnd(i+1.))) - 1.)/i, .4);\n    //}\n    return sph;\n}\nfloat bugNetwork(vec3 p) {\n    float plane = -p.z+70.-20.*smoothstep(9.5,10.,T+.1*rnd(p.x+p.y));\n    p.z+=iTime;\n    p.x += .5*sin(p.z+T*4.);\n    p.z = fract(p.z+.5);\n    p.xy = abs(p.xy);\n    p.xy-=1.;\n    p.xy*=rot(PI/4.+p.z);\n    return min(plane, length(p.yz)+.1);\n}\nfloat lightning(vec3 p, vec2 amp){\n    float id = floor(p.x);\n    \n    //p.xy += 10.*smoothstep(40., 50., -p.x)*rnd(iTime+p.x+p.y+1.);\n    //p.xy += 10.*smoothstep(3.5, 4.5, T)*rnd(iTime+p.x+p.y+1.);\n    \n    vec2 shift=      vec2(rnd(id+   iTime*.0),\n                          rnd(id+   iTime*.0+10.));\n    vec2 shiftNext = vec2(rnd(id+1.+iTime*.0),\n                          rnd(id+1.+iTime*.0+10.));\n    // vec2 shift_ = shift, shiftNext_ = shiftNext;\n    shift=shift*.5; shiftNext=shiftNext*.5;\n    // shift=pow(shift,vec2(4.)); shiftNext=pow(shiftNext,vec2(4.));\n    // shift*=shift/abs(shift); shiftNext*=shiftNext/abs(shiftNext);\n    // shift=shift*2.-1.; shiftNext=shiftNext*2.-1.;\n    shift*=amp; shiftNext*=amp;\n    // shift.y=shiftNext.y=0.;\n    // shift.x=shiftNext.x=0.;\n    p.x -= id;\n    p.yz += shift;\n    // p.zx *= rot(iTime);\n    float dx = 1.,\n        dy = shiftNext.x-shift.x,\n        dz = shiftNext.y-shift.y;\n    p.xy *= rot(atan(dy, dx));\n    p.zx *= rot(-atan(dz, length(vec2(dx, dy))));\n    return (length(p.yz)-0.01*BEAT2);\n}\nfloat metheors(vec3 p){\n    // p-=.05*(rnd(floor(p.z*50.)/50.)-.5)*2.;\n    p-=.005*length(p)*(rnd(p.z)-.5)*2.;\n    p.z+=4.;\n    float tt = iTime*4.;//4.*sin(iTime*5.);\n    float scale = 1.;\n    p=normalize(p)/length(p);\n    for(int j=0;j<3;j++){\n        p.xz*=rot((tt / 3.91));\n        p.xy*=rot((tt / 2.91));\n        // if(rnd(p.y)<.001)break;\n        p=abs(p)-(j<2?0.1:.4);\n        p*=2.1;\n        scale*=2.1;\n    }\n    // p.xz*=rot(t);\n    return 10.*sdBox(p, vec3(.1))/scale;\n}\nfloat funnel(vec3 p){\n    //p.xy\n\t//    p.z += sin(iTime*10.)*10.;\n\t//    //if (T<4.){\n\t        FUNNELROT;\n    //if(p.z > 100.) return -1.;\n\t//    //}\n\t//    //p.z-=1.5;\n\t//    p/=4.;\n\t//\n\t//    //if (T<4.){\n\t//\t    p.y*=3.;\n\t//    //}\n\t//    //else {\n\t//    //\tp.y*=9.;\n\t//    //}\n\t//    vec2 q = vec2(length(p.xz)-16.1,p.y);\n\t//    return -(length(q)-16.)*1.8;\n\t//    // return length(p)-.1;\n    return -(length(p.xy)-4.)*(1.+8.*pow(smoothstep(7.,9.,T-sin(d2p(p.xy).x*4.)*.5+.5),1.));\n}\nfloat tunnel(vec3 p) {\n    p.z += iTime * 1.1;\n    float w = p.z * 1.5;\n    p.x += .4*cos(w);\n    p.y += .4*sin(w);\n    p.xy*=rot(p.z * 2.9 + iTime);\n    // p.x += 1.4;\n    return -(length(p.xy) - 1.);\n}\n\n// \nvec2 getDist(vec3 p) {\n    vec2 obj = vec2(9999.);\n\n    // // float metheors = metheors(p);\n    \n\tfloat bn = bugNetwork(p);\n    float funnel = funnel(p);\n    //obj = obj.x < bn ? obj : vec2(funnel,BUGNETWORK);\n    float funnel_bg_mix = mix(funnel, bn, smoothstep(7.5,8.5,T));\n    obj = obj.x < funnel_bg_mix ? obj : vec2(funnel_bg_mix,FUNNEL_BUGNETWORK);\n\n    \n    if(T>11.5){\n    }\n    \n    //float tunnel = tunnel(p);\n    //obj = obj.x < tunnel ? obj : vec2(tunnel, TUNNEL);\n\n    if(T>8.){\n        vec3 p_ = p;\n        ROCKET_LIGHTNINGS_SWING\n        float rocket = rocket(p);\n        p=p_;\n        rocket=opSmoothSubtraction(-rocket,-funnel,1.5);\n    \tfloat metheors = metheors(p);\n        float r_m_mix = mix(rocket, metheors, smoothstep(8.,11.,T));\n        float bullets = bullets(p);// / smoothstep(11.5,12.5,T);\n        float r_m_b_mix = mix(r_m_mix, bullets, smoothstep(11.,12.,T));\n    \tobj = obj.x < r_m_b_mix ? obj : vec2(r_m_b_mix, ROCKET);\n    }\n\n    if (T>4. && T<8.){\n        ROCKET_LIGHTNINGS_SWING\n        float rocket = rocket(p);\n        rocket=opSmoothSubtraction(-rocket,-funnel,1.5);\n        obj = obj.x < rocket ? obj : vec2(rocket, ROCKET);\n\n        p.z/=3.;\n        p.xz*=rot(PI/2.+BEAT1-0.5);\n        p.x-=BEAT1*100.;\n        //p.zy *= rot(0.5);\n        p.zy *= rot(iTime+BEAT1-0.5);\n        vec2 amp=vec2(2.);\n        float lightnings = lightning(p, amp)*1.4 * (1.+2.*smoothstep(7.5,8.,T));\n        // // p.zy *= rot(-1.6*iTime);\n        // // p.x *=-1.;\n        // // lightnings = min(lightnings, lightning(p, amp)*1. );\n        obj = obj.x < lightnings ? obj : vec2(lightnings, LIGHTNING);\n    }\n\n    return obj;\n    // return vec2(length(p)-1., WHITE_MIRROR);\n}\n// \n\n\n\n\n\n\n\n\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.;\n    float info = EMPTY;\n    float minAngleToObstacle = 1e10;\n    float glow = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 distToClosest = getDist(ro + rd * d);\n        info = distToClosest.y;\n        // minAngleToObstacle = min(minAngleToObstacle, atan(distToClosest.x, d));\n        if(info == BUGNETWORK)\n            glow += 0.00001/pow(distToClosest.x,10.);\n        d += abs(distToClosest.x);\n        if(abs(distToClosest.x) < EPSILON || d > MAX_DIST) {\n            break;\n        }\n    }\n    return vec3(d, info, glow);\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.);\n    vec3 n_ = getDist(p).x - vec3(getDist(p - e.xyy).x,\n                                  getDist(p - e.yxy).x,\n                                  getDist(p - e.yyx).x);\n    return normalize(n_);\n}\n\nvec3 getRayDirection (vec3 ro, vec2 uv, vec3 lookAt) {\n    vec3 rd;\n    rd = normalize(vec3(uv - vec2(0, 0.), 1.));\n    vec3 lookTo = lookAt - ro;\n    float horizAngle = acos(dot(lookTo.xz, rd.xz) / length(lookTo.xz) * length(rd.xz));\n    rd.xz *= rot(horizAngle);\n    return rd;\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// used recursively for reflections\n// vec3 getColor(vec3 ro, vec3 rd, vec3 color, int depth) {\n// }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d, info, dtotal=0., glow, marches, lightSpots=0.;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro, rd, color=vec3(0), p, rm, n;\n\n    // \n    if (T > 0. && T < 5. || T > 16.) {\n        vec2 uvLs = uv;\n        uvLs.x += sin(uvLs.y+T+BEAT2)*cos(uvLs.y) + T;\n        uvLs.y+=T;\n        lightSpots = (sin(uvLs.x*5.)+sin(uvLs.y*5.))*.5;\n        lightSpots = clamp(0.,1.,lightSpots);\n        uvLs = uv;\n        uvLs.x *= .6;\n        uvLs.y *= .7;\n        lightSpots *= 1.-length(uvLs*2.);\n\n    }\n    if (Ti == 3. || Ti == 4.) {\n        vec2 uvKl = uv;\n        float katarsisLight = 3.*pow(smoothstep(3.3, 4., T),10.)-length(uvKl);\n        katarsisLight = clamp(katarsisLight, 0., 1.);\n        katarsisLight -= smoothstep(4., 4.1, T);\n        lightSpots += katarsisLight;\n    }\n\n    if (T<4.){\n\t\tuv.y *= pow(2.,1.+10.*smoothstep(4.0, .0, T));\n    }    \n    if (T>15.){\n\t\tuv.y *= pow(2.,10.*smoothstep(15., 17., T));\n    }\n\n    float camDist = -10.;\n    ro = vec3(0,0,camDist);\n    rd = getRayDir(uv, ro, vec3(0), 1.);\n\n    // making several marches outside and inside\n    // the surface along the ray\n    for (int i = 0; i < 1; i++) {\n        rm = rayMarch(ro, rd);\n        dtotal += d = rm[0];\n        p = ro + rd * d;\n        info = rm[1];\n        glow = rm[2];\n\n\n\n        if (dtotal > MAX_DIST) break;\n\n        if(info==LIGHTNING) {\n            // color += 100./glow;\n            color = vec3(1.);\n        }\n        \n        if(info==BUGNETWORK) {\n            color = vec3(1.);\n            //color += glow;\n        }\n\n        if(info==FUNNEL_BUGNETWORK) {\n            FUNNELROT;\n            vec3 pf = p;\n            //if (T<4.){\n            //}   \n            //  \n            //n = getNormal(p);\n            // color+= n*.5+.5;\n            //vec2 po = d2p(p.xz*rot(PI));\n            //po.x += .1;\n            //po.x+=po.y*(p.y/abs(p.y))*.4;\n            //po.y/=16.;\n            //po.y-=iTime/16.;\n            //color = (vec3(snoise(po*19.))+1.);\n            pf.z+=iTime*10.;\n            pf.xy*=rot(pf.z/10.);\n            color+=sin(pf.x*32.)+sin(pf.y*32.)\n                +sin(pf.z+pf.y);\n            color+=sin(pf.x*19.)+sin(pf.y*21.)\n                +sin(pf.z+pf.y);\n            color/=6.;\n            color+=.5;\n            color = clamp(color, 0., 1.);\n            color = pow(color, vec3(1.2));\n            //color = smoothstep(1., 1.9, color); // noise threshold\n            //color *= smoothstep(16., 0., length(p.xz));\n            if (T<4.){\n               color *= 1.-smoothstep(.0, 8., dtotal);\n            }\n            else {\n               color *= smoothstep(-20.0, 10., -dtotal);\n               color+= (sin(T*4.)*.5+.5)*smoothstep(10.0, 21., dtotal);\n            }\n            \n            //// color *= 1.-smoothstep(-.7, 3.5, dot(rd,n));\n            //// color *= 1.-smoothstep(-.7, 3.5, dot(rd,n));\n            color = clamp(color, 0., 1.);\n            //color *= fract(iTime/2.);\n            marches+=.2;\n        }\n        if (info == TUNNEL) {\n            n = getNormal(p);\n            vec2 pol = d2p(p.xy);\n            p.z +=  iTime * 1.1;\n            float pz = p.z * 50.;\n            float px = pol.x * 50.;\n            float idx = floor(px/PI);\n            float idz = floor(pz/PI - .5);\n            // pol.x += Rnd(idx + floor(iTime * 4.));\n            color = vec3(sin(px) + cos(pz));\n            color = pow(color, vec3(10.));\n            color /= 500. * d;\n            color *= rnd(idx + 10. * idz + floor(iTime*.00005+p.z))<0. ? 0. : 1.;\n            marches+=1.;\n            // color.r += Rnd(idx + 10. * idz + floor(iTime+p.z))<0. ? 0. : 1.;\n            // color = nn*.5+.5;\n        }  if(info==METHEORS) {\n            //  \n            n = getNormal(p);\n            // color+= n*.5+.5;\n            color+= 2.*dot(n,vec3(0,1,0))+1.;\n            color*=smoothstep(5.,3.,d);\n            marches+=1.;\n        }\n        if(info==ROCKET) {\n            //  \n            n = getNormal(p);\n            // color = n*.5+.5;\n            color = vec3(1.) * dot(n*.5+.5,vec3(0.,1.,0.));\n            marches+=.5;\n        }\n        // marches+=1.;\n        //  .\n        // n = getNormal(p);\n        // //  \n        // float refK = 7.;\n        // ref = reflect(rd, n);\n        // color+=refK*textureCubeZ(bg, ref).xyz;\n        // marches+=refK;\n        //  \n        // color+=2.*smoothstep(-.5,1.,dot(ref, rd));\n        // color+=2.*smoothstep(.6,1.,dot(ref, rd));\n\n\n        ro = p + rd * 0.05;\n    }\n    //color/=marches;\n    color += vec3(glow);\n    color = clamp(color, 0., 1.);\n\n    color *= smoothstep(0., 1., T);;\n    color *= smoothstep(17., 15., T);\n    color += lightSpots*smoothstep(2., 2.1, T);\n    \n    if(T>16.&&T<25.){\n        color+=text(fragCoord/iResolution.xy,(T-16.5)*CHUNK);\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25344, "src": "https://soundcloud.com/ivan-zorin/skillpunk-abyss", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1092, 1092, 1112, 1112, 1171], [2897, 2897, 2916, 2916, 2974], [2975, 2975, 3006, 3006, 3089], [3090, 3090, 3128, 3128, 3378], [3379, 3379, 3431, 3431, 3522], [3523, 3523, 3580, 3580, 3670], [3671, 3764, 3787, 3787, 3823], [3824, 3849, 3870, 3870, 3917], [3918, 3918, 3939, 3939, 3986], [3987, 3987, 4009, 4009, 4044], [4045, 4045, 4067, 4119, 5560], [5561, 5561, 5581, 5581, 5650], [5651, 5651, 5672, 5744, 5950], [5951, 5951, 5973, 5973, 6108], [6109, 6109, 6132, 6132, 6235], [6236, 6236, 6279, 6279, 6470], [6471, 6471, 6494, 6494, 6643], [6644, 6644, 6667, 6667, 6878], [6879, 6879, 6901, 6976, 7768], [7769, 7769, 7795, 7795, 8039], [8040, 8040, 8074, 8074, 9092], [9093, 9093, 9116, 9163, 9574], [9575, 9575, 9596, 9661, 10063], [10064, 10064, 10086, 10086, 10267], [12129, 12129, 12162, 12162, 12720], [12722, 12722, 12746, 12746, 12975], [12977, 12977, 13031, 13031, 13258], [13260, 13260, 13310, 13310, 13501], [13606, 13606, 13662, 13662, 18595]], "test": "untested"}
{"id": "tlVcD3", "name": "Analytic Quartic Solver", "author": "mla", "description": "A variation of mattz's [url]https://www.shadertoy.com/view/XdKyRR[/url], with a different solver and showing the quartic in the complex plane and solving for complex roots. Same root generation as original, but can use mouse to override two of the roots.", "tags": ["domain", "complex", "solver", "quartic", "analytic", "polynomial"], "likes": 15, "viewed": 516, "published": 3, "date": "1611927499", "time_retrieved": "2024-07-30T19:41:47.218769", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Analytic Quartic Solver remix by mla, 2021, original by mattz, 2018.\n//\n// * different quartic solver\n// * finds all solutions, real and complex\n// * shows domain mapping for polynomial\n// * select two roots with mouse (upper half for complex, lower for real).\n//\n// 'x': show unmapped domain\n//\n// As usual, multiple roots can be problematic. It might be a good idea\n// to add some special case code for triple and quadruple roots, \n// as in mattz's original, but for now there are no tricks.\n//\n// quartic solver is from Lanczos\n// cubic solver is choice of analytic solver from Numerical Recipes (qcubic0)\n// or semi-iterative solver by Kahan (qcubic1)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n///////////// mattz header /////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n/* \"analytic quartic solver\", by mattz\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   I hunted around a little bit on Shadertoy but couldn't find any\n   examples of a standalone, single-function quartic solver \n   capable of returning all real roots of a 4th-degree polynomial.\n\n   The result is the solve_quartic function below, feel free to \n   use it in your own projects under the license linked above.\n\n   With respect to testing, I wanted to make sure to test\n   all eight cases of root distribution (see generate_roots below).\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a quartic polynomial whose first coefficient is 1.\n\n#define qcubic qcubic1 // Which cubic solver to use\n\nfloat poly4(vec4 p, float x) {\n  return (((x + p[0])*x + p[1])*x + p[2])*x + p[3];\n}\n\nvec3 polycolor(vec2 z) {\n  vec2 z0 = z;\n  float h = 0.5+0.5*atan(z.y,z.x)/PI;\n  vec3 col = hsv2rgb(min(h,1.0-h),1.0,sqrt(1.0/(1.0+length(z))));\n  z -= floor(z);\n  z = min(z,1.0-z);\n  col *= mix(0.5+0.5*smoothstep(0.0,0.1,min(z.x,z.y)),1.0,min(1.0,length(z0)/20.0));\n  return col;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\nvec2 complex(float x) {\n  return vec2(x,0);\n}\nvec2 cpoly4(vec4 p, vec2 x) {\n  return cmul(cmul(cmul(x+complex(p[0]),x) + complex(p[1]),x) + complex(p[2]),x) + complex(p[3]);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Complex quadratic\nvoid cquadratic(float A, float B, float C, out vec4 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) {\n    float r = sqrt(-q);\n    res[0] = res[2] = b/A;\n    res[1] = -r/A;\n    res[3] = r/A;\n    return;\n  }\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A; res[1] = 0.0;\n    res[2] = -res[0]; res[3] = 0.0;\n  } else {\n    res[0] = C/r; res[1] = 0.0;\n    res[2] = r/A; res[3] = 0.0;\n  }\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic0(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // And select the largest\n  float psi = roots[0];\n  if (nroots > 1 && roots[1] > psi) psi = roots[1];\n  if (nroots > 2 && roots[2] > psi) psi = roots[2];\n  // and give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float DQ, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  DQ = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Kahan cubic solver.\n// Semi iterative, no trig.\n// Probably best, particularly if cos is poor quality.\nfloat qcubic1(float B, float C, float D) {\n  float A = 1.0;\n  float X,b1,c2;\n  if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      X = x0;\n      for (int i = 0; i < 4; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        X -= q/dq;\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  vec2 res;\n  if (quadratic(A,b1,c2,res) != 0) {\n    X = max(X,res.x);\n    X = max(X,res.y);\n  }\n  return X;\n}\n\n// The Lanczos quartic method\nvoid lquartic(float c1, float c2, float c3, float c4, out vec4 roots0, out vec4 roots1) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi == 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  cquadratic(1.0,alpha+a,beta+b,roots0);\n  cquadratic(1.0,alpha-a,beta-b,roots1);\n}\n\nvoid solve_quartic(vec4 coeffs, out vec2 roots[4]) {\n  float B = coeffs[0], C = coeffs[1], D = coeffs[2], E = coeffs[3];\n  vec4 roots0, roots1;\n  lquartic(B,C,D,E,roots0,roots1);\n  roots[0] = roots0.xy;\n  roots[1] = roots0.zw;\n  roots[2] = roots1.xy;\n  roots[3] = roots1.zw;\n}\n\n//////////////////////////////////////////////////////////////////////\n// evaluate a cubic polynomial with given coefficients\n\nfloat poly3(vec4 p, float x) {\n  return ((p[0]*x + p[1])*x + p[2])*x + p[3];\n}\n\n//////////////////////////////////////////////////////////////////////\n// from Dave Hoskins' \"Hash without sine\"\n// https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n\nfloat hash12(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat noise(vec2 xc) {\n    \n  float x0 = floor(xc.x);\n  float t = fract(xc.x);\n    \n  float a = hash12(vec2(x0-1., xc.y));\n  float b = hash12(vec2(x0, xc.y));\n  float c = hash12(vec2(x0+1., xc.y));\n  float d = hash12(vec2(x0+2., xc.y));\n    \n  float t2 = t*t;\n  float t3 = t2*t;\n    \n  float h00 = (2.*t3 - 3.*t2 + 1.);\n  float h01 = (t3 - 2.*t2 + t);\n  float h10 = (-2.*t3 + 3.*t2);\n  float h11 = (t3 - t2);\n    \n  return (h00*b + h01*(c-a) + h10*c + h11*(d-b))*2. - 1.;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// generate coefficients for 4th degree quartic from roots\n// note that c is the complex part of roots 0 & 1 and 2 & 3\n// if c[0] != 0, then we expect r[0] == r[1] and similarly\n// if c[1] != 0\n\nvec4 poly_from_roots(vec4 r, vec2 c) {\n    \n  float s01 = r[0] + r[1];\n  float p01 = r[0] * r[1] + c[0] * c[0];\n  float s23 = r[2] + r[3];\n  float p23 = r[2] * r[3] + c[1] * c[1];\n    \n  return vec4(-s01 - s23,\n              p01 + s01*s23 + p23,\n              -p01*s23 - s01*p23,\n              p01*p23);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// for a quartic with real coefficients, there are eight different\n// cases for roots, which we cycle through over time:\n//               \n//   case timestep #real multiplicity\n//     A  0-0.99       4   4 single           \n//     B  1-1.99       4   1 double, 2 single \n//     C  2-2.99       4   2 double\n//     D  3-3.99       4   1 triple, 1 single \n//     E  4-4.99       4   1 quad\n//     F  5-5.99       2   2 single\n//     G  6-6.99       2   1 double\n//     H  7-7.99       0   no real roots\n//\n//        8-8.99   repeat case C to move smoothly back to A\n//\n\nvoid generate_roots(out vec4 r, out vec2 c) {\n    \n  float t = 0.1*iTime;\n  float d = 2.2;\n\n  r = vec4(noise(vec2(t, 10.)),\n           noise(vec2(t, 1.)),\n           noise(vec2(t, 12.)),\n           noise(vec2(t, 3.)))*d;\n    \n  vec3 cc = vec3(noise(vec2(t, 14.))+0.2*d,\n                 noise(vec2(t, 5.))+0.2*d,\n                 0);\n    \n  t = 0.05*iTime;\n  float rep = floor(t/9.);\n    \n  float phase = mod(t, 9.);\n  float u = smoothstep(0.8, 1.0, fract(phase));\n    \n  c = vec2(0);\n            \n  if (phase < 1.) { \n    r = mix(r, r.xxzw, u); // A -> B\n  } else if (phase < 2.) {\n    r = mix(r.xxzw, r.xxzz, u); // B -> C\n  } else if (phase < 3.) {\n    r = mix(r.xxzz, r.xxxz, u); // C -> D\n  } else if (phase < 4.) {\n    r = mix(r.xxxz, r.xxxx, u); // D -> E\n  } else if (phase < 5.) {\n    r = mix(r.xxxx, r.xxzw, u); // E -> F\n    c = mix(cc.zz, cc.xz, u);\n  } else if (phase < 6.) {\n    r = mix(r.xxzw, r.xxzz, u); // F -> G\n    c = cc.xz;\n  } else if (phase < 7.) {\n    r = r.xxzz; // G -> H\n    c = mix(cc.xz, cc.xy, u);\n  } else if (phase < 8.) {\n    r = r.xxzz; // H -> C\n    c = mix(cc.xy, cc.zz, u);\n  } else {\n    r = mix(r.xxzz, r, u); // C -> A\n  }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// given point p, function value at p.x and function derivative at\n// p.x, determine estimated distance to curve of function plot.\n\nfloat dist_to_plot(vec2 p, vec2 fdf) {\n    \n  vec2 p0 = vec2(p.x, fdf.x);\n  vec2 n = normalize(vec2(-fdf.y, 1));\n  return abs(dot(p - p0, n));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  float scl = 6.0 / iResolution.x;\n    \n  vec2 p = (fragCoord - 0.5 - vec2(0.5, 0.5)*iResolution.xy)*scl;\n    \n  vec4 r; vec2 c;\n  generate_roots(r, c);\n\n  if (iMouse.z > 0.0) {\n    vec2 q = (iMouse.xy - 0.5 - vec2(0.5, 0.5)*iResolution.xy)*scl;\n    if (q.y > 0.0) {\n      r.zw = vec2(q.x,q.x);\n      c.y = q.y;\n    } else {\n      r.zw = vec2(q.x+q.y,q.x-q.y);\n      c.y = 0.0;\n    }\n  }\n  \n  vec4 poly = poly_from_roots(r, c);\n    \n  vec2 solved_roots[4];\n  solve_quartic(poly, solved_roots);\n    \n  vec4 pder = vec4(4,3,2,1) * vec4(1, poly.xyz);\n    \n  const float Y_ZOOM = 0.5;\n\n  vec2 fdf = Y_ZOOM*vec2(poly4(poly, p.x),poly3(pder, p.x));\n\n  vec3 color = polycolor(cpoly4(poly,p));\n  if (key(CHAR_X)) color = polycolor(p);\n\n  // grid lines\n  vec2 gp0 = .5*floor(2.*p + 0.5);\n  vec2 gp = fract(abs(p - gp0));\n  color = mix(vec3(1), color, 0.9+0.1*smoothstep(0.0, scl, min(gp.x, gp.y)));\n    \n  // axis line\n  vec2 ap = abs(p);\n  //color = mix(vec3(0.37, 0.55, 0.37)*.9, color, 0.8+0.2*smoothstep(0.0, scl, min(ap.x, ap.y)-0.5*scl));      \n    \n  // plot line\n  float dline = dist_to_plot(p, fdf);\n  color = mix(color, vec3(.03, .03, .03), smoothstep(scl, 0., dline-.5*scl));\n    \n  // known roots\n  for (int i=0; i<4; ++i){\n    int j = i/2;\n    float sign = i%2==0 ? -1.0 : 1.0;\n    float dc = length(p - vec2(r[i], sign*c[j]));\n    color = mix(color, vec3(.25, .02, .02), smoothstep(scl, 0., dc-3.*scl));\n  }\n    \n  // solved roots\n  for (int i=0; i<4; ++i){\n    //if (solved_roots[i].y != 0.0) continue;\n    float dc = length(p - solved_roots[i]);\n    color = mix(color, vec3(0, 0, 0.4), smoothstep(scl, 0., abs(dc-8.*scl)-.25*scl));\n  }\n\n  // stole iq's vignette code\n  vec2 q = fragCoord.xy / iResolution.xy;\n  color *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );       \n  //color *= 0.9 + 0.1*texture(iChannel0, fragCoord.xy/256.).x;\n\n  color = pow(color, vec3(1.0/2.2));\n  fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nconst float PI = 3.1415927;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_X = 88;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVcD3.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[1790, 1790, 1820, 1820, 1874], [1876, 1876, 1900, 1900, 2157], [2159, 2159, 2186, 2186, 2236], [2237, 2237, 2260, 2260, 2282], [2283, 2283, 2312, 2312, 2412], [2414, 2414, 2434, 2434, 2489], [2491, 2491, 2548, 2548, 2572], [2574, 2574, 2636, 2636, 2666], [2668, 2699, 2755, 2755, 2987], [2989, 3010, 3068, 3068, 3440], [3442, 3500, 3561, 3561, 4368], [4370, 4370, 4412, 4412, 4815], [4817, 4817, 4937, 4937, 5024], [5026, 5132, 5174, 5174, 5830], [5832, 5862, 5951, 5951, 6362], [6364, 6364, 6416, 6416, 6640], [6769, 6769, 6799, 6799, 6847], [7030, 7030, 7052, 7052, 7171], [7245, 7245, 7267, 7267, 7723], [7991, 7991, 8029, 8029, 8301], [8942, 8942, 8987, 8987, 10112], [10317, 10317, 10355, 10355, 10466], [10540, 10540, 10597, 10597, 12512]], "test": "untested"}
{"id": "tlSyzV", "name": "Basic Tile", "author": "Yahor10", "description": "256 tile texture", "tags": ["tile"], "likes": 0, "viewed": 357, "published": 3, "date": "1611919095", "time_retrieved": "2024-07-30T19:41:48.148284", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 rpos = fragCoord.xy/vec2(128);\n    vec3 col = texture(iChannel0,rpos).xyz;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 253]], "test": "untested"}
{"id": "ttVcW3", "name": "Gradient Normalization Test", "author": "oneshade", "description": "Testing gradient normalization in 3D for estimating the distance to implicit surfaces. It works\nsurprisingly well. Some of the surfaces are based off the [url=https://en.wikipedia.org/wiki/Implicit_surface]wikipedia article[/url].", "tags": ["gradient", "implicit", "distanceestimate", "normalization"], "likes": 3, "viewed": 194, "published": 3, "date": "1611899346", "time_retrieved": "2024-07-30T19:41:49.460775", "image_code": "/*\nTesting gradient normalization in 3D for estimating the distance to implicit surfaces. It works\nsurprisingly well. Some of the surfaces are based off the wikipedia article:\nhttps://en.wikipedia.org/wiki/Implicit_surface\n*/\n\n// Just in case ;)\n#define EXTRA_FUDGE_FACTOR 1.0\n\n// Settings\n#define MAX_TRACE_DIST 10.0\n#define MIN_HIT_DIST 0.001\n#define GRAD_STEP 0.001\n#define GRAD_CAP 20.0\n#define MAX_STEPS 100.0\n\n// Uncomment one to see a different surface\n//#define GENUS_2\n//#define SPHERICAL_HARMONIC\n//#define CASSINI_OVAL\n//#define QUARTIC_SPHERE\n#define TANGLECUBE\n\nfloat mapSceneImplicit(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    #ifdef GENUS_2\n    float t1 = 2.0 * p.y * (p.y * p.y - 3.0 * p.x * p.x) * (1.0 - p.z * p.z);\n    float t2 = p.x * p.x + p.y * p.y; t2 *= t2;\n    float t3 = (9.0 * p.z * p.z - 1.0) * (1.0 - p.z * p.z);\n    return max(t1 + t2 - t3, dot(p, p) - 4.0); // Theres other stuff that gets in the way\n    #endif\n\n    #ifdef SPHERICAL_HARMONIC\n    p /= 2.0;\n    const float k = 0.3153915652; // sqrt(5/)/4\n    return dot(p, p) - pow(3.0 * k * p.y * p.y / dot(p, p) - k, 2.0);\n    #endif\n\n    #ifdef CASSINI_OVAL\n    float q1 = length(p - vec3(-1.5,  0.0,  0.0));\n    float q2 = length(p - vec3( 1.5,  0.0,  0.0));\n    float q3 = length(p - vec3( 0.0, -1.5,  0.0));\n    float q4 = length(p - vec3( 0.0,  1.5,  0.0));\n    float q5 = length(p - vec3( 0.0,  0.0, -1.5));\n    float q6 = length(p - vec3( 0.0,  0.0,  1.5));\n    return q1 * q2 * q3 * q4 * q5 * q6 - 14.0;\n    #endif\n\n    #ifdef QUARTIC_SPHERE\n    return dot(p * p, p * p) - 4.0;\n    #endif\n\n    #ifdef TANGLECUBE\n    return dot(4.0 * p * p, 4.0 * p * p) + dot(-10.0 * p, 2.0 * p) + 11.0;\n    #endif\n}\n\nfloat getGrad(in vec3 p) {\n    vec3 e = vec3(GRAD_STEP, 0.0, 0.0);\n    return length(vec3(mapSceneImplicit(p + e.xyy) - mapSceneImplicit(p - e.xyy),\n                       mapSceneImplicit(p + e.yxy) - mapSceneImplicit(p - e.yxy),\n                       mapSceneImplicit(p + e.yyx) - mapSceneImplicit(p - e.yyx))) / (2.0 * e.x);\n}\n\nfloat mapScene(in vec3 p) {\n    return mapSceneImplicit(p) / max(getGrad(p), GRAD_CAP) * EXTRA_FUDGE_FACTOR;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(GRAD_STEP, 0.0, 0.0);\n    return normalize(vec3(mapSceneImplicit(p + e.xyy) - mapSceneImplicit(p - e.xyy),\n                          mapSceneImplicit(p + e.yxy) - mapSceneImplicit(p - e.yxy),\n                          mapSceneImplicit(p + e.yyx) - mapSceneImplicit(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < MAX_STEPS; iters++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < MIN_HIT_DIST) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += n * max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > MAX_TRACE_DIST) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[575, 575, 610, 610, 1771], [1773, 1773, 1799, 1799, 2103], [2105, 2105, 2132, 2132, 2215], [2217, 2217, 2244, 2244, 2543], [2545, 2545, 2600, 2600, 3262]], "test": "untested"}
{"id": "wtVyW3", "name": "Path-Tracing: Stanford Bunny", "author": "Zi7ar21", "description": "I guess this is a meme on Shadertoy now (at least for today, and hopefully for a long time to come...)\nI used my new Cornell Box I made today. Long live the bunny!\nThe original Stanford Bunny Neural SDF by blackle: https://www.shadertoy.com/view/wtVyWK", "tags": ["raymarching", "ray", "raymarcher", "pathtracing", "pathtracer", "path", "neural", "bunny", "neuralnetwork", "stanford", "stanfordbunny"], "likes": 17, "viewed": 1159, "published": 3, "date": "1611893600", "time_retrieved": "2024-07-30T19:41:50.468082", "image_code": "// Fork of Path-Tracer Cornell Box by Zi7ar21: https://shadertoy.com/view/3lGyDc\n// January 29th, 2020 13:00\n\n// Common contains adjustable parameters and RNG functions\n// Buffer A contains the Path-Tracer\n// Buffer B contains an image export\n// This contains the output to the screen\n\n// ATTENTION! Mega-Poggers Neural Network Distance Estimator from blackle: https://www.shadertoy.com/view/wtVyWK\n// Path-Tracing: Stanford Bunny by Zi7ar21 --- January 28th, 2020\n// Last Updated: January 28th, 2020 21:10 Mountain Time\n\n// If you didn't find this on ShaderToy there may be an updated version at:\n// https://www.shadertoy.com/view/wtVyW3\n\n// Michael0884 fixed this like a lot, check him out:\n// https://www.shadertoy.com/user/michael0884\n\n// Also check out LoicVDB, who offered other advice:\n// https://www.shadertoy.com/user/loicvdb\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This contains adjustable parameters and RNG functions\n\n// Camera Settings\n#define camerafov 0.35\n#define camerapos vec3(0.0, -0.4, -8.0)\n\n// Adjustable Path-Tracing Settings\n#define maxbounces 32\n#define maxmarches 1024\n#define collisiondist 1e-4\n#define scenesize 6.0\n#define ditherradius 0.5\n\n// PBR Not Fully Implemented Yet, Going to Work From This:\n// PBR Theory (Albedo, Normal, Metallic, Roughness)\n// https://learnopengl.com/PBR/Theory\n\n// Material (Albedo, Roughness)\nvec4 materialproperties(vec3 pos, int material){\n    // Material of the Fractal\n    if(material == 0){\n        //return vec4(vec3(1.0), clamp((fbm(pos*8.0)-0.2)/8.0, 0.0, 0.5));\n        return vec4(vec3(1.0, 1.0, 0.5), 0.125);\n    }\n    // Material of the Podium\n    if(material == 1){\n        return vec4(vec3(1.0, 1.0, 1.0), 0.125);\n    }\n    // White Diffuse\n    if(material == 2){\n        return vec4(vec3(1.0), 0.5);\n    }\n    // Red Diffuse\n    if(material == 3){\n        return vec4(vec3(1.0, 0.25, 0.25), 0.5);\n    }\n    // Green Diffuse\n    if(material == 4){\n        return vec4(vec3(0.25, 1.0, 0.25), 0.5);\n    }\n    // Non-Defined Material\n    return vec4(0.0);\n}\n\n// Constants (ShaderToy uses Single Precision which can represent Pi as 3.14159265 whilst Double Precision\n// can encode pi as 3.141592653589793, who knows maybe in the future ShaderToy will support Double so why not\n// include the 3589793)\n#define pi 3.141592653589793\n#define twopi pi*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state>>((state>>28u)+4u))^state)*277803737u;\n    ns = (word>>22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Nor3alized Random also from Michael0884: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}", "buffer_a_code": "// This contains the Path-Tracer\n\n// https://www.shadertoy.com/view/wtVyWK\nfloat scene(vec3 p){\n    p += vec3(0.08, 0.475, 0.0);\n    p = p.zxy;\n    // SDF is undefined outside the unit sphere, uncomment to witness the abominations\n    if(length(p) > 1.0){\n        return length(p)-0.8;\n    }\n    // Neural Networks can be really compact... When they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n}\n\n// Cube Distance Estimator\nfloat sdBox(vec3 p){\n  p += vec3(0.0, 1.5, 0.0);\n  vec3 b = vec3(0.5);\n  vec3 q = abs(p)-b;\n  return length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Infinite Plane Distance Estimators\nfloat plane      (vec3 pos){return  pos.y+2.0;}\nfloat leftplane  (vec3 pos){return  pos.x+2.0;}\nfloat rightplane (vec3 pos){return -pos.x+2.0;}\nfloat backplane  (vec3 pos){return -pos.z+2.0;}\n\n// Nearest Distance Estimator\nfloat DE(vec3 pos){\n    float DE0 = sdBox(pos);\n    float DE1 = plane(pos);\n    float DE2 = backplane(pos);\n    float DE3 = leftplane(pos);\n    float DE4 = rightplane(pos);\n    float fractal = scene(pos);\n    return min(min(fractal, DE0), min(min(DE1, DE2), min(DE3, DE4)));\n}\n\nint getmat(vec3 pos){\n    float DE0 = sdBox(pos);\n    float DE1 = plane(pos);\n    float DE2 = backplane(pos);\n    float DE3 = leftplane(pos);\n    float DE4 = rightplane(pos);\n    float fractal = scene(pos);\n    float hit = min(min(fractal, DE0), min(min(DE1, DE2), min(DE3, DE4)));\n    if(hit == fractal){return 0;}\n    if(hit == DE0){return 1;}\n    if(hit == DE1 || hit == DE2){return 2;}\n    if(hit == DE3){return 3;}\n    if(hit == DE4){return 4;}\n    return -1;\n}\n\nfloat light(vec3 pos){\n  return -pos.y+2.0;\n}\n\n// Tetrahedron Normal Function\nvec3 normal(vec3 pos){\n    float normprecision = collisiondist*0.1;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*DE(pos+k.xyy*normprecision)+\n                     k.yyx*DE(pos+k.yyx*normprecision)+\n                     k.yxy*DE(pos+k.yxy*normprecision)+\n                     k.xxx*DE(pos+k.xxx*normprecision));\n}\n\n// Forward and Central Differences Normal Function (Alternate Option, Slower)\n/*vec3 normal(vec3 pos){\n    const vec2 diff = vec2(collisiondist*0.1, 0.0);\n    return normalize(vec3(DE(pos+diff.xyy)-DE(pos-diff.xyy),\n                          DE(pos+diff.yxy)-DE(pos-diff.yxy),\n                          DE(pos+diff.yyx)-DE(pos-diff.yyx)));\n}*/\n\n// Path-Tracing\nvec3 raymarch(vec3 pathdir, vec3 pathorig){\n    vec3 pathpos = pathorig;\n    pathpos += pathdir*6.0;\n    vec3 surfnormal;\n    float distest, lightdistest;\n    int bounces = 0;\n    int object = 0;\n    vec3 closestpos = pathpos;\n    vec3 outCol = vec3(1.0);\n    for(int i = 0; i < maxmarches; i++){\n        // Check if the path is done\n        if(length(pathpos) > scenesize || pathpos.z < -4.0 || bounces > maxbounces){break;}\n        if(light(pathpos) < collisiondist){return outCol*vec3(1.0);}\n\n        // Find the distance to the scene\n        distest = DE(pathpos);\n        lightdistest = light(pathpos);\n\n        // Michael0884: Closest Non-Colliding Position\n        if(distest > min(collisiondist, lightdistest)){closestpos = pathpos;}\n\n        // Bounce the Path if it hits something\n        if(distest < collisiondist){\n            int object = getmat(pathpos);\n            vec4 matprops = materialproperties(pathpos, object);\n            outCol *= matprops.rgb;\n            surfnormal = normal(pathpos);\n            pathpos = closestpos;\n            pathdir = reflect(pathdir, normalize(nrand3(matprops.w, surfnormal)));\n            bounces++;\n        }\n\n        // Otherwise just keep going\n        else{pathpos += pathdir*min(distest, lightdistest);}\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates, centered on [0.0, 0.0] and extends to 1.0 x or y, so that it looks fine no matter the aspect ratio.\n    vec2 uv = 2.0*((fragCoord.xy+nrand2(ditherradius*0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Rotation Matrix\n    mat3 rotmat = mat3(\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Direction of the path\n    vec3 pathdir = normalize(camerafov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Run the Path-Tracing\n    vec3 raymarched = raymarch(pathdir, camerapos);\n\n    fragColor += vec4(max(vec3(0.0), raymarched), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This contains an image export\n\n// Along the bottom at the right of this editor, there is a little image icon.\n// If you click it, ShaderToy will save a 32-Bit Floating Point OpenEXR Image.\n// A 32-Bit OpenEXR is much better for editing than saving an 8-BPC PNG Image.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.rgb / fragColor.a : fragColor.rgb, 1.0);\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[836, 836, 891, 891, 953]], "test": "untested"}
{"id": "wtGcD3", "name": "Castle in the field and guardian", "author": "intrakits", "description": "I am making a cool castle thing. I also tried to make a character for the first time.", "tags": ["3d", "wall", "grass", "castle", "character", "weapon"], "likes": 11, "viewed": 769, "published": 3, "date": "1611882735", "time_retrieved": "2024-07-30T19:41:51.433501", "image_code": "#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 sdSphere( vec3 p, float s )\n{\n    return vec2(length(p)-s,0);\n}\n\nvec2 sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),1.);\n}\n\nvec2 sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return vec2(min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),2.);\n}\nvec2 sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec2(k0*(k0-1.0)/k1,3.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2(length( pa - ba*h ) - r,16.);\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nvec2 sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),21.);\n}\n\n// arbitrary orientation\nvec2 sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return vec2(sign(d)*sqrt(abs(d))/baba,21.);\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return vec2(abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness,15.);\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nvec2 cactus (vec3 pos){\n    //add cactus\n    vec2 uv4 = vec2(atan(pos.x,pos.z)/(3.14159*1.),pos.y/1.);\n    float disp4 = texture(iChannel1,uv4).r;\n    vec2 cactus = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .2 );\n    vec2 thorn = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .14 );\n    thorn.x-=disp4*.1;\n    thorn.y = 17.;\n    cactus = opU(cactus,thorn);\n    \n    vec3 nP = pos;\n    nP.y += (sin(nP.x*4.) * .1 * smoothstep(1.1,1.2,nP.x));\n    vec2 cactusR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .13 );\n    vec2 thornR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .08 );\n    \n    thornR.x-=disp4*.1;\n    thornR.y = 17.;\n    cactusR = opU(cactusR,thornR);\n    cactus.x = smin(cactusR,cactus, .1).x;\n    return cactus;\n}\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    //get rock displacement\n    vec2 uv = vec2(pos.z*.4, pos.y*.4);\n    float disp = texture(iChannel0,uv).r;\n    \n    vec2 uv2 = vec2(pos.x*.1, pos.z*.1);\n    float disp2 = texture(iChannel0,uv2).r;\n    \n    vec2 uv3 = vec2(pos.x*.3, pos.z*.3);\n    float disp3 = texture(iChannel1,uv3).r;\n    \n    \n    \n    \n    //add floor to scene\n    vec2 floorP = vec2(pos.y,20.);\n    //apply rocky displacement to floor\n    floorP.x-=disp2*.1;\n    res = opU(floorP,res);\n    \n    //wall\n    vec2 wall= sdBox( pos-vec3(0,1,0), vec3(.5,1,10) );\n    wall.x-=disp*.3;\n    //cut hole in wall for door\n    vec2 wallMask = sdCapsule(pos, vec3(0,-.5,0), vec3(0,.7,0), 1. );\n    wall.x = differenceSDF(wall.x, wallMask.x);\n    res = opU(wall,res);\n     \n    //path\n    vec3 nP = pos;\n    nP.z += sin(nP.x *.4);\n    vec2 path = sdBox( nP-vec3(0,0,-.1), vec3(10.,.1,1.3) );\n    path.x-=disp2*.2;\n    path.y = 26.;\n    res = opU(path,res);\n    \n    //gate\n    vec2 bars = sdCylinder(pos, vec3(.5,0,0), vec3(.5,2,0), .01);\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.1), vec3(.5,2,-.1), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.2), vec3(.5,2,-.2), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.3), vec3(.5,2,-.3), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.4), vec3(.5,2,-.4), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.5), vec3(.5,2,-.5), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.6), vec3(.5,2,-.6), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.7), vec3(.5,2,-.7), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.8), vec3(.5,2,-.8), .01)));\n    \n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.1), vec3(.5,2,.1), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.2), vec3(.5,2,.2), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.3), vec3(.5,2,.3), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.4), vec3(.5,2,.4), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.5), vec3(.5,2,.5), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.6), vec3(.5,2,.6), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.7), vec3(.5,2,.7), .01)));\n    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.8), vec3(.5,2,.8), .01)));\n    \n    res = opU(bars,res);\n    \n    //plants\n   /* vec3 pPos = pos-vec3(1.3,0,1.3);\n    pPos.xz *= Rot(iTime);\n    pPos.xz -= sin(pPos.y*4.+.4)*.4+.4;\n    \n    vec2 bush = sdCylinder( pPos, vec2(.01-.01*pPos.y,.3) );\n    bush.y = 90.;\n    res = opU(bush,res);*/\n    \n    vec2 grass = vec2(pos.y,90.);\n    grass.x-=disp3*.1;\n    res = opU(grass,res);\n    \n    //flag\n     //add flag\n    vec3 flagP = pos - vec3(1.,0,1);\n    vec2 pole = sdCylinder(flagP, vec2(.01,1.4) );\n    res = opU(pole,res);\n    //add cloth\n    flagP.x += (sin(flagP.z + iTime*5.)*.1) * smoothstep(.1,1.1,flagP.z);\n    vec2 cloth = sdBox( flagP-vec3(0,1.1,0.5), vec3(.01,.3,.5) );\n    cloth.y = 91.;\n    //cloth.x -=disp3*.03;\n    res = opU(cloth,res);\n    \n    //second flag\n    flagP.xz *= Rot(3.145);\n    flagP = flagP - vec3(0,0,3);\n    pole = sdCylinder(flagP, vec2(.01,1.4) );\n    res = opU(pole,res);\n    //add cloth\n    flagP.x += (sin(flagP.z + iTime*5.)*.1) * smoothstep(.1,1.1,flagP.z);\n    cloth = sdBox( flagP-vec3(0,1.1,0.5), vec3(.01,.3,.5) );\n    cloth.y = 91.;\n    res = opU(cloth,res);\n    \n    //guardian\n    vec2 guard = sdSphere( pos-vec3(2,1,0), 0.2);\n    guard = smin(guard,sdSphere( pos-vec3(2,.6,0), 0.3),.3);\n    vec2 guardMask = sdCapsule(pos, vec3(2.1,1.1,.05), vec3(2.1,1.1,-.1), .2 );\n    guard = max(-guardMask, guard);\n    \n    //add arms\n    //shoulder\n    vec2 arms = sdSphere( pos-vec3(2.18,1.,0.25 + sin(iTime)*.01), 0.13);\n    guard = smin(guard,arms,.1);\n    guard.y = 100.;\n    //arm\n    vec2 arm = sdCapsule(nP, vec3(2.18,1,1.), vec3(2.2,.8+ sin(iTime)*.01,1.2), .08 );\n    \n    \n    vec2 hand = sdSphere( pos-vec3(2.5,.8+ sin(iTime)*.01,0.4),.04);\n    arm = smin(arm,hand,.4);\n    arm.y = 26.;\n    res = opU(arm,res);\n    \n    //left\n    //shoulder\n    vec2 armsL = sdSphere( pos-vec3(2.18,1.+ sin(iTime)*.01,-0.25), 0.13);\n    guard = smin(guard,armsL,.1);\n    guard.y = 100.;\n    //arm\n    vec2 armL = sdCapsule(nP, vec3(2.18,1,.48), vec3(2.2,.8+ sin(iTime)*.01,.38), .08 );\n    vec2 handL = sdSphere( pos-vec3(2.5,.8+ sin(iTime)*.01,-0.4+cos(iTime)*.07),.04);\n    armL = smin(armL,handL,.4);\n    armL.y = 26.;\n    res = opU(armL,res);\n    //spear\n    vec2 spear = sdCylinder(pos-vec3(2.5,.8+ sin(iTime)*.01,-0.4+cos(iTime)*.07), vec2(.01,.5) );\n    vec3 bladeP = pos;\n    bladeP.x -= sin(bladeP.y*4.-.2);\n    vec2 blade = sdBox( bladeP-vec3(3.5,1.3+ sin(iTime)*.01,-0.4+cos(iTime)*.07), vec3(.1,.1,.014*(1./(pos.y*4.))) );\n    res = opU(spear,res);\n    blade.y = 26.;\n     res = opU(blade,res);\n    //head\n    vec3 headPos = pos;\n    headPos.y -= sin(iTime)*.05+.05;\n    vec2 head = sdSphere( headPos-vec3(2.13,1.13,0), 0.2);\n    head = smin(guard,head,.04);\n    head.y = 100.;\n    res = opU(head,res);\n    \n    //helmet\n    vec2 helmet = sdSphere( headPos-vec3(2.13,1.13,0), 0.22);\n    head = sdSphere( headPos-vec3(2.13,1.13,0), 0.15);\n    helmet.x = max(helmet.x,-head.x);\n    vec2 helmetM = sdBox( headPos-vec3(02.2,0.85,0), vec3(.3,.2,.3) );\n    \n    helmet.x = max(helmet.x,-helmetM.x);\n   \n    vec2 helmetM2 = sdBox( headPos-vec3(02.2,0.85,0), vec3(.4,.4,.01 *headPos.y*2.) );\n    helmet.x = max(helmet.x,-helmetM2.x);\n    \n    vec2 helmetM3 = sdBox( headPos-vec3(02.17,1.2,0), vec3(.2,.01 * abs(headPos.z)*40.+.01,.1));\n    helmet.x = max(helmet.x,-helmetM3.x);\n    helmet.y = 26.;\n    res = opU(helmet,res);\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    \n    // raymarch primitives   \n    // distance from origin\n    float dO=0.;\n    float ID = -1.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        vec2 getObj = map(p);\n        ID = getObj.y;\n        float ds = getObj.x;\n        //move origin to new point\n        if(ID == 15.){\n            dO+=ds*.8;\n        }\n        else if(ID == 17.){\n            dO+=ds*.8;\n        }\n        else if(ID == 1.){\n            dO+=ds*.8;\n        }\n        else if(ID == 90.){\n            dO+=ds*.8;\n        }else{\n            dO+=ds;\n        }\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return vec2(min(dO, MAX_DIST),ID);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        float ks = .3;\n        \n        vec3 colXZ = texture(iChannel2, pos.xz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel2, pos.xy*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel2, pos.yz*.5+.5).rgb;\n        \n        vec3 colXZ2 = texture(iChannel3, pos.xz*.5+.5).rgb;\n        vec3 colXY2 = texture(iChannel3, pos.xy*.5+.5).rgb;\n        vec3 colYZ2 = texture(iChannel3, pos.yz*.5+.5).rgb;\n        \n        vec3 colXZ3 = texture(iChannel1, pos.xz*.5+.5).rgb;\n        vec3 colXY3 = texture(iChannel1, pos.xy*.5+.5).rgb;\n        vec3 colYZ3 = texture(iChannel1, pos.yz*.5+.5).rgb;\n        // material        \n        if(m == 1.){\n            nor = abs(nor);\n            col = (colXZ2*nor.y + colXY2*nor.z + colYZ2*nor.x) * .5;\n            //col = nor;\n            ks = .01;\n        }\n        else if( m==20.)\n        {\n            // project pixel footprint into the plane\n            /*vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);*/\n            col = colXZ*nor.y + colXY*nor.z + colYZ*nor.x;\n            ks = .01;\n        }\n        else if( m==15.){\n            col = vec3(0.4,.1,0);\n            ks = .1; \n        }\n         else if( m==16.){\n            col = vec3(0,.1,0);\n            ks = .1; \n        }\n        else if( m==21.){\n            col = vec3(.1);\n            ks = 5.; \n        }\n        else if( m==26.){\n            col = vec3(.5) * .01;\n            ks = .1; \n        }\n        else if( m==90.){\n            col = vec3(0,1,0) * .1;\n            ks = .1; \n        }\n        else if( m==91.){\n            col = vec3(1,0,0) * .1;\n            ks = .1; \n        }\n        else if( m==100.){\n            col = vec3(1,pos.y,pos.y) * .1;\n            ks = .1; \n        }\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(0.6, 0.7, -0.9) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 1.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0, 0, 0 );\n    vec3 ro = ta + vec3( 4.5, 1.3 + 2.0*mo.y, 4.5*sin(0.1 + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 239, 264, 264, 283], [284, 284, 309, 309, 328], [329, 329, 365, 365, 393], [395, 395, 420, 420, 435], [437, 437, 471, 471, 505], [507, 507, 537, 537, 637], [639, 639, 686, 686, 983], [984, 984, 1042, 1042, 1140], [1142, 1142, 1175, 1175, 1230], [1232, 1232, 1302, 1302, 1442], [1444, 1444, 1480, 1480, 1791], [1793, 1793, 1849, 1849, 2351], [2353, 2353, 2404, 2404, 2528], [2530, 2530, 2594, 2594, 2872], [2874, 2874, 2937, 3001, 3588], [3590, 3590, 3626, 3626, 3976], [3978, 3990, 4025, 4025, 4138], [4140, 4165, 4215, 4215, 4580], [4582, 4594, 4641, 4641, 4986], [4988, 4988, 5059, 5059, 5397], [5399, 5399, 5463, 5463, 6023], [6025, 6071, 6119, 6119, 6288], [6290, 6290, 6327, 6327, 6921], [6923, 6923, 6965, 6965, 7565], [7567, 7607, 7671, 7671, 7929], [8001, 8001, 8031, 8031, 8064], [8166, 8235, 8282, 8282, 8315], [8316, 8316, 8381, 8381, 8468], [8469, 8469, 8488, 8488, 8550], [8551, 8591, 8629, 8629, 8726], [8728, 8768, 8809, 8809, 8881], [8882, 8882, 8905, 8922, 9611], [9612, 9612, 9637, 9637, 15281], [15283, 15331, 15382, 15382, 15587], [15589, 15589, 15629, 15692, 16446], [16448, 16493, 16571, 16594, 16981], [16983, 17029, 17061, 17061, 17632], [17634, 17634, 17676, 17676, 17985], [17987, 18039, 18103, 18124, 18357], [18359, 18359, 18424, 18443, 22273], [22275, 22275, 22327, 22327, 22504]], "test": "untested"}
{"id": "3tKyD3", "name": "Bernoulli Lemniscate DE", "author": "oneshade", "description": "Distance estimator for bernoulli lemniscate. Useful for propellers and things.", "tags": ["2d", "distanceestimation", "bernoulli", "lemniscate"], "likes": 3, "viewed": 176, "published": 3, "date": "1611881869", "time_retrieved": "2024-07-30T19:41:52.315144", "image_code": "// Desmos graph: https://www.desmos.com/calculator/mbr8h5vo9q\nfloat BernoulliDE(in vec2 p, in vec2 scale) {\n    vec2 ps = p / scale;\n\n    float l = ps.x - 1.0;\n    float r = ps.x + 1.0;\n    float ys = ps.y * ps.y;\n\n    float bernoulli = sqrt(l * l + ys) * sqrt(r * r + ys) - 1.0;\n\n    vec2 pSqrS = p / (scale * scale);\n    float sInvX = 1.0 / scale.x;\n    float ls = pSqrS.x - sInvX;\n    float rs = pSqrS.x + sInvX;\n\n    float psSqrY = ps.y * ps.y;\n    float ld = sqrt(l * l + psSqrY);\n    float rd = sqrt(r * r + psSqrY);\n\n    float pdx = (ls * rd) / ld + (rs * ld) / rd;\n    float pdy = (rd / ld + ld / rd) * pSqrS.y;\n    float bernoulliGrad = sqrt(pdx * pdx + pdy * pdy);\n\n    return bernoulli / bernoulliGrad;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    float unit = 5.0 / iResolution.y;\n\n    vec2 uv = (fragCoord - screenCenter) / screenCenter.y;\n    vec3 color = vec3(0.0);\n\n    vec2 size = vec2(cos(iTime), sin(iTime));\n\n    float shape = BernoulliDE(uv, size);\n    color.g = smoothstep(unit, 0.0, abs(shape));\n    color.rb = shape < 0.0 ? vec2(0.0, sin(shape * 200.0)) : vec2(sin(shape * 200.0), 0.0);\n\n    vec2 ro = (iMouse.xy - screenCenter) / screenCenter.y;\n    vec2 rd = -normalize(ro);\n    float t = 0.0;\n    for (int i=0; i < 50; i++) {\n        vec2 p = ro + rd * t;\n        float d = BernoulliDE(p, size);\n        color += smoothstep(unit, 0.0, abs(length(uv - p) - abs(d)));\n        if (abs(d) < 0.001 || t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 107, 107, 715], [717, 717, 772, 772, 1587]], "test": "untested"}
{"id": "WlKyW3", "name": "Day 408", "author": "jeyko", "description": "ptot", "tags": ["mdtmjvm"], "likes": 6, "viewed": 385, "published": 3, "date": "1611871529", "time_retrieved": "2024-07-30T19:41:53.328434", "image_code": "// thx to noby and yx/luna for figuring out a bug:\n// DONT INDEX OPENGL ARRAYS AT -1 :D \n\n\n// thx to wyatt for teaching me storing voronoi particle tracking stuff in different buffers and packing!\n\n// cyclic noise by nimitz\n\n// int packing from somewhere on shadertoy\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 pPntr = T1(U);\n    vec4 p = T(pPntr.xy);\n    vec2 pos = unpackU16(p.x);\n    \n    C = texture(iChannel0,U/R);\n    \n        \n    C.xyz *= vec3(1.4,0.5,0.4);\n        \n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    C *= 1. - smoothstep(0.3,0.,pow( cyclicNoisePap(vec3(uv*90.,1.),false,0.),1.))*0.5;\n    \n    \n    C = 1. - C*2.5;\n    \n    \n    C = max(C,0.);\n    C = pow(C,vec4(0.4545));  \n    \n    \n    //C = texture(iChannel2,U/R);\n    \n    //C *= 1. - smoothstep(0.,1.,dot(uv,uv))*0.;\n\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ------------------------------- //\n//           Movement              //\n// ------------------------------- //\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\n//#define steps  floor(particleSz*iResolution.x*8.)\n\nfloat steps = 20.;\nfloat stepSz = 2.;\nvoid findNeighbors( vec4 me, vec2 mePos, vec2 dir){\n\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( mePos.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        \n        //if ( otherP.x != me.x){\n        //if ( unpackU16(otherP.x) != me.xy ){\n        if ( unpackU16(otherP.x).x != mePos.x && unpackU16(otherP.x).y != mePos.y ){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3){\n        \n        float pc = floor(sqrt(particleCount));\n        vec2 id = floor(U/R*pc) + 0.0001;\n        vec2 cellSz = R/(pc + 1.);\n        \n        vec2 pos = id*cellSz/R + cellSz/R;\n\n        vec2 vel = r24(id).xy*2. - 1.;\n\n        C.x = packU16(pos);\n        C.y = packS8(vel.xyxy);    \n        C.z = packU8(r24(id));\n        \n    } else {\n        C = T(U);\n        \n        vec4 pPtr = T1(C.xy*R);\n        \n        if (iFrame > startOffs){\n            \n            //C = T( pPtr.xy );\n            \n            vec2 pos = unpackU16(C.x);\n            vec2 vel = unpackS8(C.y).xy;\n            vec4 data = unpackU8(C.z);\n    \n\n            findNeighbors( C, pos, vec2(1,0));\n            findNeighbors( C, pos, vec2(-1,0));\n            findNeighbors( C, pos, vec2(0,1));\n            findNeighbors( C, pos, vec2(0,-1));\n            \n            findNeighbors( C, pos, vec2(1,1));\n            findNeighbors( C, pos, vec2(1,-1));\n            findNeighbors( C, pos, vec2(-1,1));\n            findNeighbors( C, pos, vec2(-1,-1));\n            \n\n            // elastic collisions\n            for(int i = 0; i < neighborsCnt; i++){    \n                vec4 otherPtr = neighborPtrs[i];\n                vec4 other = T(otherPtr.xy);\n                vec2 otherVel = unpackS8(other.y).xy;\n                vec4 otherData = unpackU8(other.z);\n                \n                other.xy = unpackU16(other.x);\n                vec2 meToOther = (other.xy - pos.xy)*resFact.xy;\n                \n                \n                float distBetween = length(meToOther);\n                \n                \n                float sizes =  getSize(data.x) + getSize(otherData.x); \n                \n                if( distBetween < sizes ){\n                    \n\n                    vec2 normal = normalize(meToOther);\n                    vec2 tangent = vec2(-normal.y,normal.x);\n\n\n                    float meNorm = dot(vel, normal);\n                    float meTan = dot(vel, tangent);\n                    float otherNorm = dot(otherVel, normal);\n                    float otherTan = dot(otherVel, tangent);\n\n                    float massMe = 1.;\n                    float massOther = 1.;\n                    \n                    \n                    meNorm = ( meNorm * (massMe - massOther) + 2.*massOther*otherNorm ) / (massMe + massOther);\n                    \n                    vel = tangent * meTan + normal*meNorm;\n                    \n                    pos -= normalize(meToOther)*(abs(distBetween - sizes));\n                    \n                }\n\n\n\n\n            }\n        \n        \n            if (abs(pos.x - 0.5) > 0.49 - particleSz*0.5){\n                vel.x *= -1.;\n                if ( sign(vel.x) != sign(-pos.x + 0.5) )\n                    vel.x *= -1.;\n            }\n            if (abs(pos.y - 0.5) > 0.49 - particleSz*0.5){\n                vel.y *= -1.;\n                if ( sign(vel.y) != sign(-pos.y + 0.5) )\n                    vel.y *= -1.;            \n            }\n\n            \n            \n            float rotFact = sin(cyclicNoise(vec3( pos/resFact*3.5, iTime*1.), false, iTime*0.2)*2. - 1.);\n            \n            vel *= rot(rotFact * 0.2);\n            pos += vel/resFact*0.008;\n            \n            \n            C.x = packU16(pos);\n            C.y = packS8(vel.xyxy);\n            //C.x = packSnorm(vec4(pos,vel));\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R (iResolution.xy)\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n#define TF(u)  texelFetch(iChannel0,ivec2(u), 0)\n#define TF1(u) texelFetch(iChannel1,ivec2(u), 0)\n#define TF2(u) texelFetch(iChannel2,ivec2(u), 0)\n#define TF3(u) texelFetch(iChannel3,ivec2(u), 0)\n\n#define pi acos(-1.)\n\n#define startOffs 6\n\n#define iTime mod(iTime,2.)\n\n#define particleCount 32.\n\n#define particleSz 0.05\n\n#define getSize(idx) particleSz*(sin(idx*26. + iTime)*0.5 + 0.5)\n\n\n#define resFact vec2(R.x/R.y,1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define getIdx(a) vec2(mod(a,R.x), floor((a+R.x)/R.x)-1.)\n\n// 8bit\nhighp uint packU8(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackU8(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packU8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackU8(float a) { return vec4(unpackU8(floatBitsToUint(a))) / 255.; }\nfloat packS8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackS8(float a) { return clamp((vec4(unpackU8(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n\n// 16bit\nhighp uint packU16(highp uvec2 a) {\n    return uint( (a.x << 16)\n               | (a.y << 0)); }\nmediump uvec2 unpackU16(highp uint a) {\n    return uvec2( (a & 0xFFFF0000u) >> 16\n                , (a & 0x0000FFFFu) >> 0   ); }\nfloat packU16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec2  unpackU16(float a) { return vec2(unpackU16(floatBitsToUint(a))) / (pow(2.,16.) - 1.); }\n\n\n\nvec4 r24(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 2.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(2,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoisePap(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    p.yz *= rot(5.6);\n    float amp = 1.;\n    const float gain = 0.62;\n    const float lacunarity = 1.8;\n    const int octaves = 1;\n    \n    const float warp = 1.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .1;\n    \n    vec3 seed = vec3(2,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n", "buffer_b_code": "// ------------------------------- //\n//           Tracking              //\n// ------------------------------- //\n\nfloat steps = 15.;\nfloat stepSz = 2.;\nvoid findMe( inout vec4 pPntr, inout vec2 pos, vec2 U, vec2 dir){\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = T1(U + dir*i);\n        vec4 otherP = T(otherPntr.xy);\n        vec2 otherPos = unpackU16(otherP.x);\n        \n        if (length( (U/R - otherPos.xy)/resFact.yx ) < length( (U/R - pos.xy)/resFact.yx )){\n            pos = otherPos;\n            pPntr = otherPntr;\n        }\n        \n    }\n\n}\n        \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3) {\n        //C = r24(U);\n        C.xy = U;\n        C.zw -= C.zw;\n    } else {        \n        C = T1(U);\n        \n        if (iFrame < startOffs){\n            steps = 100.;\n        }\n        \n        \n        vec4 pPntr = C;\n        vec4 p = T(pPntr.xy);\n        vec2 pos = unpackU16(p.x);\n        \n        findMe(pPntr,pos,U,vec2(0,1));\n        findMe(pPntr,pos,U,vec2(0,-1));\n        findMe(pPntr,pos,U,vec2(1,0));\n        findMe(pPntr,pos,U,vec2(-1,0));\n        findMe(pPntr,pos,U,vec2(1,1));\n        findMe(pPntr,pos,U,vec2(1,-1));\n        findMe(pPntr,pos,U,vec2(-1,1));\n        findMe(pPntr,pos,U,vec2(-1,-1));\n        \n        C = pPntr;\n        \n        if (iFrame == startOffs-1){\n            C.zw = 1. + floor(r24(C.xy).xy*2.99);\n        }\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ------------------------------- //\n//           Painting              //\n// ------------------------------- //\n\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\nfloat steps = 17.;\nvoid findNeighbors( vec2 p, vec2 dir){\n    float stepSz = 1. + mod(float(iFrame),2.);\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( p.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        vec2 otherPos = unpackU16(otherP.x);\n        \n        // TODO: don't unpack here\n        if ( otherPos.x != p.x ){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nfloat sdSq(vec2 p, float s){p = abs(p) - s; return max(p.x,p.y);}\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    float pixelSize = dFdx(uv.x)*3.;\n    \n    vec4 mePntr = T1(U);\n    vec4 me = T(mePntr.xy);\n    \n    vec2 mePos = unpackU16(me.x);\n    vec4 meData = unpackU8(me.z);\n    \n    \n    C = texture(iChannel2,U/R);\n    findNeighbors( mePos, vec2(1,0));\n    findNeighbors( mePos, vec2(-1,0));\n    findNeighbors( mePos, vec2(0,1));\n    findNeighbors( mePos, vec2(0,-1));\n    \n    findNeighbors( mePos, vec2(1,1));\n    findNeighbors( mePos, vec2(1,-1));\n    findNeighbors( mePos, vec2(-1,1));\n    findNeighbors( mePos, vec2(-1,-1));\n    \n    for(int i = -1; i < neighborsCnt; i++){\n        vec4 otherPtr;\n        vec4 otherP;\n        if (i == -1){\n            otherPtr = mePntr;\n            otherP = me;\n        } else {\n            otherPtr= neighborPtrs[i];\n            otherP = T(otherPtr.xy);\n        }\n        \n        \n        vec2 pos = unpackU16(otherP.x);\n        vec4 data = unpackU8(otherP.z);\n    \n        float size = data.x;\n    \n    \n        //vec3 col = pal(0.5,vec3(0.5,1.6,0.5),vec3(5,1,1),5. + sin(data.z), 0. + data.w*6. + iTime); \n    \n        //vec3 col = pal(0.5,vec3(0.5,1.6,0.5),vec3(5,1,1),5. + sin(data.z), 0. + data.w*6. + iTime); \n        \n        vec3 col = pal(0.5,vec3(0.5,1.6,0.5),vec3(5,1,1),5. + sin(data.z), 0. + data.w*6. + iTime); \n    \n        col *= 0.9;\n        float dFill = length((pos.xy - uv)*resFact.xy) - getSize(size) ;\n        float dOutline = abs(dFill) - 0.00001;\n        \n        C.xyz = mix(C.xyz,col,smoothstep(pixelSize,0.,dFill));\n\n        vec3 crot = col - 1.;\n        crot.xz *= rot(-1.4);\n        crot += 1.;\n        C.xyz = mix(C.xyz,crot*0.1,smoothstep(pixelSize,0.,dOutline));\n        \n        if (data.y >= meData.y){\n        \n        \n        }\n        //return;\n        //C = mix(C,pal(0.5,0.5,vec4(3,2,1,1.),1.,otherPtr.z*1.*14. + 0.*otherPtr.w ),smoothstep(dFdx(uv.x),0.,length((otherP.xy - uv)*resFact.xy) - particleSz));\n    }\n\n    \n    \n    if(iFrame < 4)\n        C = vec4(0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 311, 311, 800]], "test": "untested"}
{"id": "3lKyW3", "name": "pulsar00113", "author": "lyurai", "description": "test 00002445", "tags": ["itime"], "likes": 2, "viewed": 260, "published": 3, "date": "1611869159", "time_retrieved": "2024-07-30T19:41:54.079426", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*1.6-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/1.;\n        for(int i=0;i<20;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+200));\n        }\n\t    col[c]= step(.5,fract(uv.x*20.));\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 479]], "test": "untested"}
{"id": "3lGyDc", "name": "My Path-Tracer Cornell Box", "author": "Zi7ar21", "description": "Testing my Path Tracer with a Cornell Box.", "tags": ["raymarching", "fractal", "ray", "raymarch", "cornellbox", "mandelbulb", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "cornell", "path"], "likes": 7, "viewed": 512, "published": 3, "date": "1611864189", "time_retrieved": "2024-07-30T19:41:54.884274", "image_code": "// Common contains adjustable parameters and RNG functions\n// Buffer A contains the Path-Tracer\n// Buffer B contains an image export\n// This contains the output to the screen\n\n// My Path-Tracer Cornell Box by Zi7ar21 --- January 28th, 2020\n// Last Updated: January 28th, 2020 13:00 Mountain Time\n\n// If you didn't find this on ShaderToy there may be an updated version at:\n// https://www.shadertoy.com/view/3lGyDc\n\n// Michael0884 fixed this like a lot, check him out:\n// https://www.shadertoy.com/user/michael0884\n\n// Also check out LoicVDB:\n// https://www.shadertoy.com/user/loicvdb\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This contains adjustable parameters and RNG functions\n\n// Camera Settings\n#define camerafov 0.25\n#define camerapos vec3(0.0, 0.0, -16.0)\n\n// Adjustable Path-Tracing Settings\n#define maxbounces 32\n#define maxmarches 1024\n#define collisiondist 1e-4\n#define scenesize 8.0\n#define ditherradius 0.5\n\n// Adujustable Fractal Settings\n#define iterations 4\n#define power 8.0\n\n// PBR Not Fully Implemented Yet, Going to Work From This:\n// PBR Theory (Albedo, Normal, Metallic, Roughness)\n// https://learnopengl.com/PBR/Theory\n\n// Material (Albedo, Roughness)\nvec4 materialproperties(vec3 pos, int material){\n    // Material of the Fractal\n    if(material == 0){\n        //return vec4(vec3(1.0), clamp((fbm(pos*8.0)-0.2)/8.0, 0.0, 0.5));\n        return vec4(vec3(1.0, 1.0, 0.5), 0.125);\n    }\n    // Material of the Podium\n    if(material == 1){\n        return vec4(vec3(0.5, 0.5, 1.0), 0.25);\n    }\n    // White Diffuse\n    if(material == 2){\n        return vec4(vec3(1.0), 0.5);\n    }\n    // Red Diffuse\n    if(material == 3){\n        return vec4(vec3(1.0, 0.25, 0.25), 0.5);\n    }\n    // Green Diffuse\n    if(material == 4){\n        return vec4(vec3(0.25, 1.0, 0.25), 0.5);\n    }\n    // Non-Defined Material\n    return vec4(0.0);\n}\n\n// Constants (ShaderToy uses Single Precision which can represent Pi as 3.14159265 whilst Double Precision\n// can encode pi as 3.141592653589793, who knows maybe in the future ShaderToy will support Double so why not\n// include the 3589793)\n#define pi 3.141592653589793\n#define twopi pi*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state>>((state>>28u)+4u))^state)*277803737u;\n    ns = (word>>22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Nor3alized Random also from Michael0884: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}", "buffer_a_code": "// This contains the Path-Tracer\n\n// Mandelbulb Distance Estimator\nfloat mandelbulb(vec3 pos){\n    pos = vec3(pos.x, pos.z, -pos.y);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iterations; i++){\n\t\tr = length(z);\n\t\tif(r > 4.0){break;}\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Cube Distance Estimator\nfloat sdBox(vec3 p){\n  p += vec3(0.0, 1.5, 0.0);\n  vec3 b = vec3(0.5);\n  vec3 q = abs(p)-b;\n  return length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Infinite Plane Distance Estimators\nfloat plane      (vec3 pos){return  pos.y+2.0;}\nfloat leftplane  (vec3 pos){return  pos.x+2.0;}\nfloat rightplane (vec3 pos){return -pos.x+2.0;}\nfloat backplane  (vec3 pos){return -pos.z+2.0;}\n\n// Nearest Distance Estimator\nfloat DE(vec3 pos){\n    float DE0 = sdBox(pos);\n    float DE1 = plane(pos);\n    float DE2 = backplane(pos);\n    float DE3 = leftplane(pos);\n    float DE4 = rightplane(pos);\n    float fractal = mandelbulb(pos);\n    return min(min(fractal, DE0), min(min(DE1, DE2), min(DE3, DE4)));\n}\n\nint getmat(vec3 pos){\n    float DE0 = sdBox(pos);\n    float DE1 = plane(pos);\n    float DE2 = backplane(pos);\n    float DE3 = leftplane(pos);\n    float DE4 = rightplane(pos);\n    float fractal = mandelbulb(pos);\n    float hit = min(min(fractal, DE0), min(min(DE1, DE2), min(DE3, DE4)));\n    if(hit == fractal){return 0;}\n    if(hit == DE0){return 1;}\n    if(hit == DE1 || hit == DE2){return 2;}\n    if(hit == DE3){return 3;}\n    if(hit == DE4){return 4;}\n    return -1;\n}\n\nfloat light(vec3 pos){\n  return -pos.y+2.0;\n}\n\n// Tetrahedron Normal Function\nvec3 normal(vec3 pos){\n    float normprecision = collisiondist*0.1;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*DE(pos+k.xyy*normprecision)+\n                     k.yyx*DE(pos+k.yyx*normprecision)+\n                     k.yxy*DE(pos+k.yxy*normprecision)+\n                     k.xxx*DE(pos+k.xxx*normprecision));\n}\n\n// Forward and Central Differences Normal Function (Alternate Option, Slower)\n/*vec3 normal(vec3 pos){\n    const vec2 diff = vec2(collisiondist*0.1, 0.0);\n    return normalize(vec3(DE(pos+diff.xyy)-DE(pos-diff.xyy),\n                          DE(pos+diff.yxy)-DE(pos-diff.yxy),\n                          DE(pos+diff.yyx)-DE(pos-diff.yyx)));\n}*/\n\n// Path-Tracing\nvec3 raymarch(vec3 pathdir, vec3 pathorig){\n    vec3 pathpos = pathorig;\n    pathpos += pathdir*14.0;\n    vec3 surfnormal;\n    float distest, lightdistest;\n    int bounces = 0;\n    int object = 0;\n    vec3 closestpos = pathpos;\n    vec3 outCol = vec3(1.0);\n    for(int i = 0; i < maxmarches; i++){\n        // Check if the path is done\n        if(length(pathpos) > scenesize || pathpos.z < -3.9 || bounces > maxbounces){break;}\n        if(light(pathpos) < collisiondist){return outCol*vec3(1.0);}\n\n        // Find the distance to the scene\n        distest = DE(pathpos);\n        lightdistest = light(pathpos);\n\n        // Michael0884: Closest Non-Colliding Position\n        if(distest > min(collisiondist, lightdistest)){closestpos = pathpos;}\n\n        // Bounce the Path if it hits something\n        if(distest < collisiondist){\n            int object = getmat(pathpos);\n            vec4 matprops = materialproperties(pathpos, object);\n            outCol *= matprops.rgb;\n            surfnormal = normal(pathpos);\n            pathpos = closestpos;\n            pathdir = reflect(pathdir, normalize(nrand3(matprops.w, surfnormal)));\n            bounces++;\n        }\n\n        // Otherwise just keep going\n        else{pathpos += pathdir*min(distest, lightdistest);}\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates, centered on [0.0, 0.0] and extends to 1.0 x or y, so that it looks fine no matter the aspect ratio.\n    vec2 uv = 2.0*((fragCoord.xy+nrand2(ditherradius*0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Rotation Matrix\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\n    // Direction of the path\n    vec3 pathdir = normalize(camerafov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Run the Path-Tracing\n    vec3 raymarched = raymarch(pathdir, camerapos);\n\n    fragColor += vec4(max(vec3(0.0), raymarched), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This contains an image export\n\n// Along the bottom at the right of this editor, there is a little image icon.\n// If you click it, ShaderToy will save a 32-Bit Floating Point OpenEXR Image.\n// A 32-Bit OpenEXR is much better for editing than saving an 8-BPC PNG Image.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 639, 639, 695]], "test": "untested"}
{"id": "ttyyD3", "name": "Shakespeare Quest", "author": "eiffie", "description": "re-up. Monkeys can't write Shakespeare if their lives depended on it. I already did the research. Trust me you don't want to repeat it. I think I'll have better luck randomly reconstituting his DNA.", "tags": ["finger"], "likes": 14, "viewed": 380, "published": 3, "date": "1611856135", "time_retrieved": "2024-07-30T19:41:55.814786", "image_code": "// Shakespeare Quest by eiffie (solving for 2 joints)\n\n#define size iResolution\n#define SHADOWS\n\nfloat time;\n/* //\"solves\" for two joints (there is a better way I'm sure)\nvoid djsolve( vec3 a, vec3 b, vec3 l, vec3 rt, out vec3 j1, out vec3 j2 )//mod from iq's\n{//the vec \"l\" has the segment lengths, rt is axis of bend\n float l2=(l.y+l.z)*sqrt(length(a-b))/sqrt(l.x+l.y+l.z);\n vec3 p=b-a,q=p*(0.5+0.5*(l.x*l.x-l2*l2)/dot(p,p));\n j1=a+q+sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(p,rt));\n p=b-j1;q=p*(0.5+0.5*(l.y*l.y-l.z*l.z)/dot(p,p));\n j2=j1+q+sqrt(max(0.0,l.y*l.y-dot(q,q)))*normalize(cross(p,rt));\n}\n*/\n\nvec4 djsolve( vec2 p )//mod from fizzer's mod of iq's\n{//the segment lengths are precalculated as 0.5,0.4,0.3 and starts at point 0,0\n float l2=0.639*pow(dot(p,p),0.25);\n vec2 q=p*(0.5+0.5*(0.25-l2*l2)/dot(p,p));\n vec2 j1=q+sqrt(max(0.0,0.25/dot(q,q)-1.0))*q.yx*vec2(-1.0,1.0);\n p=p-j1;\n q=p*(0.5+0.035/dot(p,p));\n vec2 j2=j1+q+sqrt(max(0.0,0.16/dot(q,q)-1.0))*q.yx*vec2(-1.0,1.0);\n return vec4(j1,j2);\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nfloat Tube(vec3 pa, vec3 ba, float r){//mod from iq's\n float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n return length(pa - ba*h)-r+h*0.015;\n //return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0))-r;\n}\n\nfloat finger(vec3 p, float z){\n vec3 j4=vec3(0.7+sin(z+time+sin(z*1.3))*0.25,abs(sin(z+time))*0.6,0.0);\n vec4 j=djsolve(j4.xy);\n vec3 j2=vec3(j.xy,0.0),j3=vec3(j.zw,0.0);\n float d=Tube(p,j2,0.145);\n d=min(d,Tube(p-j2,j3-j2,0.13));\n return min(d,Tube(p-j3,j4-j3,0.115));\n}\nfloat DE(vec3 p0){\n vec3 p=p0;\n p.x=mod(p.x,2.0)-1.0;\n float d3=length(max(abs(p.xy+vec2(0.0,0.27))-vec2(0.47,0.2),0.0))-0.03;\n float d2=min(length(p.xy-vec2(0.75,0.0)),length(p.xy+vec2(0.75,0.0)));\n float za=0.0;\n if(abs(fract(p.z)-0.5)>0.25){\n  p.x=-p.x;\n  p.z+=0.5;\n  za=5.0;\n }\n p.x+=0.75;\n float z=floor(p.z)+floor(p0.x*0.5)*10.0+za;\n p.z=fract(p.z)-0.5;\n float d=finger(p,z);\n return min(0.16,min(d,min(d2-0.075,d3)));\n}\n\nfloat G(vec2 p){return smoothstep(0.0,0.05,min(max(abs(p.x-0.6)-0.15,abs(p.y-0.5)),max(min(p.x-p.y,p.y-0.5),abs(length(p-vec2(0.5))-0.25))));}\nfloat A(vec2 p){return smoothstep(0.0,0.05,min(max(0.25-p.y,abs(abs(p.x-0.5)+p.y*0.5-0.4)),max(abs(p.x-0.5)-0.1,abs(p.y-0.5))));}\nfloat C(vec2 p){return smoothstep(0.0,0.05,max(abs(length(p-vec2(0.5))-0.25),p.x-0.6));}\nfloat T(vec2 p){return smoothstep(0.0,0.05,min(max(abs(p.x-0.5),abs(p.y-0.5)-0.25),max(abs(p.x-0.5)-0.25,abs(p.y-0.75))));}\n\nvec3 getColor(vec3 p0){\n float tim=time-0.2;\n vec3 col;\n vec3 p=p0;\n p.x=mod(p.x,2.0)-1.0;\n float d3=length(max(abs(p.xy+vec2(0.0,0.27))-vec2(0.47,0.2),0.0))-0.03;\n float d2=min(length(p.xy-vec2(0.75,0.0)),length(p.xy+vec2(0.75,0.0)));\n float ftz=0.625,za=0.0;\n if(abs(fract(p.z)-0.5)>0.25){\n  p.x=-p.x;\n  p.z+=0.5;\n  ftz=0.125;\n  za=5.0;\n }\n p.x+=0.75;\n float z=floor(p.z)+floor(p0.x*0.5)*10.0+za;\n p.z=fract(p.z)-0.5;\n float d=finger(p,z);\n vec4 ft=vec4(0.7+sin(z+tim+sin(z*1.3))*0.25,abs(sin(z+tim))*0.6,p0.z+ftz,p.x);\n if(d2<d && d2<d3){col=vec3(0.7,0.65,0.4);}\n else if(d3<d){\n  p0.z+=0.125;\n  vec2 xz=abs(mod(p0.xz,0.25)-0.125);\n  col=(1.0-20.0*dot(xz,xz))*vec3(0.5,0.4,0.3);\n  xz=floor(p0.xz*4.0);\n  if(ft.y<0.1){//fat fingering :)\n   if(mod(floor(ft.w*4.0),4.0)==mod(floor(ft.x*4.0),4.0) && fract(ft.z)<0.25)\n    col*=vec3(4.0,3.0,2.0);\n  }\n  float i=mod(xz.x-xz.y,4.0);\n  xz=p0.xz*4.0-xz;\n  if(i<1.0)col*=G(xz);\n  else if(i<2.0)col*=A(xz);\n  else if(i<3.0)col*=C(xz);\n  else col*=T(xz);\n }else col=vec3(0.2,0.3,0.4);\n return col;\n}\n#ifdef SHADOWS\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}//from knighty\n//random seed and generator\nfloat randSeed,GoldenAngle;\nfloat randStep(){//crappy random number generator\n randSeed=fract(randSeed+GoldenAngle);\n return  (0.8+0.2*randSeed);\n}\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad){\n float t=0.01,d,s=1.0,r;\n ro+=rd*t;\n for(int i=0;i<8;i++){\n  r=t*coneGrad;\n  d=DE(ro+rd*t)+r*0.5;\n  s*=linstep(-r,r,d);\n  t+=d*randStep();\n }\n return clamp(s,0.2,1.0);\n}\n#endif\n\nvec3 Light(vec3 p, vec3 rd, vec3 L){\n vec2 v=vec2(0.001,0.0);\n vec3 mcol=getColor(p);\n vec3 N=normalize(vec3(DE(p+v.xyy)-DE(p-v.xyy),DE(p+v.yxy)-DE(p-v.yxy),DE(p+v.yyx)-DE(p-v.yyx)));\n vec3 col=mix(mcol.yzx,mcol,abs(dot(rd,N)))*max(0.0,dot(N,L));\n col+=vec3(1.0,0.5,0.7)*pow(max(0.0,dot(reflect(rd,N),L)),16.0);\n#ifdef SHADOWS\n col*=FuzzyShadow(p,L,0.5);\n#endif\n return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n time=iTime*2.5;\n#ifdef SHADOWS\n GoldenAngle=2.0-0.5*(1.0+sqrt(5.0));\n randSeed=fract(sin(dot(fragCoord.xy,vec2(13.434,77.2378))+time*0.1)*4132.34526);\n#endif\n vec3 ro=vec3(2.0*sin(time*0.1),1.5+sin(time*0.03)*0.6,time*0.6+cos(time*0.135));\n mat3 rotCam=lookat(vec3(0.0,0.3-0.5*ro.y,1.0),vec3(0.0,1.0,0.0));\n vec3 rd=rotCam*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,1.5));\n rd.x=-rd.x;\n float t=max(0.0,(0.875-ro.y)/rd.y),d=1.0,dm=d,tm=t;\n for(int i=0;i<24;i++){\n  t+=d=DE(ro+rd*t);\n  if(d<dm){dm=d;tm=t;}\n }\n vec3 col=vec3(rd.y*rd.y);\n vec3 L=normalize(vec3(0.2,0.6,-0.3));\n bool secondMarch=(dm>0.0002*tm);\n if(secondMarch){//unless we got really close speed up the march\n  for(int i=0;i<16;i++){\n   t+=d=DE(ro+rd*t)*1.5;//just experimenting\n   t+=0.01;\n  }\n  if(d<0.02*t){\n   vec3 p=ro+rd*t;\n   vec3 scol=Light(p,rd,L);\n   col=mix(scol,col,smoothstep(0.0,0.02*t,d));\n   col*=exp(-t*0.1);\n  }\n }\n if(dm<0.002*tm){\n  vec3 p=ro+rd*tm;\n  vec3 scol=Light(p,rd,L);\n  col=mix(scol,col,smoothstep(0.0,0.002*tm,dm));\n  col*=exp(-tm*0.1);\n }\n \n \n fragColor = vec4(clamp(col*2.0,0.0,1.0),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[613, 613, 668, 746, 1017], [1018, 1018, 1047, 1047, 1132], [1133, 1133, 1171, 1186, 1342], [1344, 1344, 1374, 1374, 1615], [1616, 1616, 1634, 1634, 2042], [2044, 2044, 2060, 2060, 2186], [2187, 2187, 2203, 2203, 2316], [2317, 2317, 2333, 2333, 2405], [2406, 2406, 2422, 2422, 2529], [2531, 2531, 2554, 2554, 3571], [4083, 4083, 4119, 4119, 4459], [4460, 4460, 4517, 4517, 5613]], "test": "untested"}
{"id": "ttycW3", "name": "Bad Mushrooms", "author": "eiffie", "description": "doodle", "tags": ["bytebeat"], "likes": 14, "viewed": 529, "published": 3, "date": "1611853997", "time_retrieved": "2024-07-30T19:41:56.657533", "image_code": "#define rez iResolution  \n#define time iTime*2.\nmat2 flap;\nconst vec4 c=vec4(0.0,0.22,0.0,1.0); \nfloat DE(in vec3 z0){\n float d=10.,ds=1.;\n vec4 z = vec4(z0.x-1.,z0.y-1.-abs(sin(time*.3)),z0.z-5.-time-sin(time+1.5),1.0); \n z.x=abs(z.x);\n for(int i=0;i<3;i++){\n   z.xy=z.xy*flap;\n   d=min(d,max(abs(z.x-.5)-.5,max(abs(z.y)-0.1,abs(z.z)-.1+z.x*.125))/z.w);\n   z.x=abs(z.x-.75);z.z+=.15;\n }\n z0+=vec3(.025,.2,.025)*sin((z0.yzx+sin(z0.zxy*2.))*vec3(5.,1.,5.));\n z0.z=mod(z0.z,10.)-5.;\n z = vec4(z0,1.0); \n for (int n = 0; n < 20; n++) { //from kali I think\n  z.xz=clamp(z.xz, -1.0, 1.0) *2.0-z.xz; \n  z/=min(dot(z.xyz,z.xyz),1.0); \n  z+=c; \n }\n return min(min(d*.15,z0.y+1.5),0.4*(length(z.xyz)-1.0)/z.w); \n}\n \nvoid mainImage(out vec4 O, in vec2 U) {\n vec2 uv=(2.0*U-rez.xy)/rez.y; \n vec3 ro=vec3(sin(time)*0.5+0.2,-0.75,time),rd=vec3(uv+.5+sin(time*vec2(.6,2.6))*.3,1.);\n float a=0.3*sin(time+uv.x);\n flap=mat2(cos(a),sin(a),-sin(a),cos(a))*1.3;\n float t=0.,d,ps=1./rez.y;\n for(int i=0;i<100;i++){\n   t+=d=DE(ro+t*rd);\n   if(t>20. || d<ps)break;\n }\n O=vec4(t/20.)*vec4(1.,.9,1.5-uv.y+0.3*sin(uv.y*100.)-uv.x*.25,1);\n}", "image_inputs": [], "sound_code": "float o(int t){return float(t%256)/256.-0.5;}\nvec2 mainSound( int samp, float time )\n{\n  int t=samp,t2=t;\n  t*=(t>>13 & t>>12);\n  t2*=(t2>>11 & t2>>12);\n  return vec2(o(t>>2)+o(t2>>3)*sin(time)+o(t),o(t>>1)+o(t2>>2)*sin(time+0.5)+o(t>>3))*.5;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 118, 118, 704], [707, 707, 746, 746, 1114]], "test": "untested"}
{"id": "tlGcW3", "name": "Fluffy's Breakfast", "author": "eiffie", "description": "reupload - see comments in code", "tags": ["socconetracing"], "likes": 18, "viewed": 459, "published": 3, "date": "1611853426", "time_retrieved": "2024-07-30T19:41:57.469363", "image_code": "// fluffy's breakfast by eiffie\n// Still re-uploading from having this done to me nonconsentually... \n// https://pubs.acs.org/doi/10.1021/nn5020616\n// ...high frequency subconscious messages, quiet effective when combined with torture\n// ...the method is actually derived from witchcraft which uses lodestone powder\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// using massive DoF to march around this little guy's furry butt\n\nconst float focalDistance=1.0,aperature=0.07,fudgeFactor=0.9;\n\n#define size iResolution\n#define time iTime\n\n//handy routines from iq\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))/k;}//negative k gives int and dif\nfloat Ellipsoid(vec3 z, vec4 r){float f=length(z*r.xyz);return f*(f-r.w)/length(z*r.xyz*r.xyz);}\nfloat Segment(vec3 p, vec3 p0, vec3 p1, float r){vec3 v=p1-p0;v*=clamp(dot(p-p0,v)/dot(v,v),0.0,1.0);return distance(p-p0,v)-r;}\nfloat Cone(in vec3 z, vec2 r){return max(abs(z.y)-r.y,(length(z.xz)-r.x*clamp(r.y-abs(z.y),0.0,r.y))/(1.0+r.x/r.y));}\nvec4 seg4( vec3 pa, vec3 ba )//iq's tube returning nearest point and distance along segment\n{//same as tube except it lets you shape the result with dot(j.xyz,rt) and j.w\n float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n return vec4(pa - ba*h,h);\n}\n// See https://iquilezles.org/articles/morenoise for a proper version :)\nfloat hash(float n) {return fract(sin(n) * 43758.5453123);}\nfloat noyz(vec2 x) {//simple version\n vec2 p=floor(x),f=fract(x),u=f*f*(3.0-2.0*f);\n const float tw=117.0;\n float n=p.x+p.y*tw,a=hash(n),b=hash(n+1.0),c=hash(n+tw),d=hash(n+tw+1.0);\n return a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\nfloat fbm(vec2 p) {return 0.5*noyz(p)+0.3*noyz(p*2.3)+0.2*noyz(p*3.7);}\n\nfloat RCyl(in vec3 z, vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;}\n\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat headbob,tailwag;\nfloat DE(in vec3 p)\n{\n vec3 z=p+vec3(0.0,1.2,2.5);\n float dB=Cone(z,vec2(0.75,1.5));//dog bowl\n dB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);//smooth difference to scoop out bowl\n float dF=z.y;  //floor\n float d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0)); //body\n vec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));//create tail segment\n j.z-=sin(j.w*3.1416)*0.1;//add a curve to the tail\n float d2=length(j.xyz); //tail distance\n vec2 uv=vec2(atan(p.z,p.x),p.y); //basic fur pattern\n p.x=abs(p.x);\n uv.xy=mix(vec2(uv.x+(p.y-0.32)*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));//changing fur direction for tail\n float d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02))); //ears\n uv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));//changing fur direction for ears\n d2=min(d2,d3);\n float h=fbm(uv*25.0); \n p.z=abs(p.z);\n d2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07))); //feet\n d=(smin(d2,d,8.0)-h*0.2)*0.5; //smooth together and add fur\n return min(d,min(dB,dF)); //return closest object\n}\nvec3 mcol;\nfloat CE(vec3 p){//same for coloring\n vec3 z=p+vec3(0.0,1.2,2.5);\n float dB=Cone(z,vec2(0.75,1.5));\n dB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);\n float dF=z.y;\n float d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0));\n vec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));\n j.z-=sin(j.w*3.1416)*0.1;\n float d2=length(j.xyz);\n vec2 uv=vec2(atan(p.z,p.x),p.y);\n p.x=abs(p.x);\n uv.xy=mix(vec2(uv.x+(p.y-0.32)*tailwag*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));//changing the direction for ears\n float d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02)));\n uv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));\n d2=min(d2,d3);\n float h=fbm(uv*25.0);\n p.z=abs(p.z);\n d2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07)));\n float d1=(smin(d2,d,8.0)-h*0.2)*0.5;\n d=min(d1,min(dB,dF));\n if(abs(d-dB)<0.001)mcol+=vec3(0.9,0.9,0.2);\n else if(abs(d-dF)<0.001){mcol+=vec3(1.0,0.4+noyz(z.xz*vec2(50.0,1.0))*0.4,0.4)*(0.4+0.6*clamp(d1*3.0,0.0,1.0));}\n else mcol+=vec3(0.7,0.5,0.3)*h+vec3(-p.y*0.5);\n return d;\n}\n\nfloat pixelSize;\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperature,pixelSize*t);\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n pixelSize=1.0/size.y;\n headbob=-0.6+abs(sin(time*9.0)*sin(time*3.5))*0.1;\n tailwag=sin(time*14.0)*0.1;\n vec3 ro=vec3(-1.5,0.15,2.75)+vec3(cos(time),sin(time*0.7)*0.5,sin(time))*0.25;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 L=normalize(ro+vec3(0.5,2.5,0.5));\n vec4 col=vec4(0.0);//color accumulator\n float t=0.0;//distance traveled\n for(int i=1;i<48;i++){//march loop\n  if(col.w>0.9 || t>7.0)continue;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  float d=DE(ro)+0.25*rCoC;\n  if(d<rCoC){//if we are inside add its contribution\n   vec3 p=ro;//-rd*abs(d-rCoC);//back up to border of CoC\n   mcol=vec3(0.0);//clear the color trap, collecting color samples with normal deltas\n   vec2 v=vec2(rCoC*0.5,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-CE(p-v.xyy)+CE(p+v.xyy),-CE(p-v.yxy)+CE(p+v.yxy),-CE(p-v.yyx)+CE(p+v.yyx)));\n   //if(dot(N,rd)<0.0){//doesn't seem to matter??\n    vec3 scol=mcol*0.1666*(0.7+0.3*dot(N,L));//do some fast light calcs (you can forget about shadow casting, too expensive)\n    scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*vec3(1.0,0.5,0.0);\n    float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n    col+=vec4(scol*alpha,alpha);//blend in the new color\n   //}\n  }\n  d=abs(fudgeFactor*d*(0.7+0.2*rand(fragCoord.xy*vec2(i))));//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n vec3 scol=mix(vec3(0.025,0.1,0.05)+rd*0.025,vec3(0.1,0.2,0.3)+rd*0.1,smoothstep(-0.1,0.1,rd.y));\n col.rgb+=scol*(1.0-clamp(col.w,0.0,1.0));\n\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[578, 603, 639, 639, 675], [675, 706, 738, 738, 802], [803, 803, 852, 852, 931], [932, 932, 962, 962, 1049], [1050, 1050, 1143, 1220, 1302], [1303, 1376, 1397, 1397, 1435], [1436, 1436, 1456, 1472, 1668], [1669, 1669, 1688, 1688, 1740], [1742, 1742, 1772, 1772, 1837], [1839, 1839, 1880, 1880, 1913], [1913, 1956, 1976, 2047, 2118], [2143, 2143, 2164, 2164, 3175], [3187, 3187, 3204, 3223, 4216], [4235, 4235, 4268, 4330, 4389], [4390, 4390, 4419, 4419, 4515], [4516, 4516, 4573, 4573, 6306]], "test": "untested"}
{"id": "3lyyWc", "name": "Path Traced Neural Bunny", "author": "michael0884", "description": "Really simple path tracing for this neural SDF thing", "tags": ["pathtracing", "bunny"], "likes": 33, "viewed": 1052, "published": 3, "date": "1611851560", "time_retrieved": "2024-07-30T19:41:58.284186", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy); \n    fragColor = tanh(2.5*col/col.w);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 128\n#define MIN_DIST 1e-5\n#define MAX_DIST 8.0\n#define CAM_ANGLE 1e-3\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//internal RNG state \nuvec4 s0; \n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat bunny(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return (length(p)-0.9);\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    float o = dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n    return o*0.85; //its a nonperfect sdf\n}\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 plane = vec2(p.z + 0.5, 0);\n    vec2 bunnys = vec2(bunny(p), 1);\n    return opUnion(bunnys, plane);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p).x - vec3(scene(k[0]).x,scene(k[1]).x,scene(k[2]).x));\n}\n\nfloat trace(inout vec4 ro, vec3 rd)\n{\n    vec2 de = vec2(-1);\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        de = scene(ro.xyz); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de.x - 2.0*step(de.x, md)*md); \n        if(de.x < md) return de.y;\n        if(ro.w > MAX_DIST) return -1.0;\n    }\n    return de.y;\n}\n\nvec3 pathtrace(vec4 ro, vec3 rd)\n{\n    vec3 outcol = vec3(0.); vec3 matcol = vec3(1.);\n    for(int i = 0; i<4; i++)\n    {\n        float hit = trace(ro, rd);\n        if(hit>=0.0)\n        {\n            vec3 n = norm(ro.xyz); //geometric normal\n            vec3 s = sin(100.*erot(ro.xyz, vec3(1), 3.2)) + sin(150.*erot(ro.xyz, vec3(0,1,0.5), 1.2));\n            \n            float roughness =(rand()>0.5)?0.5:0.05;\n            if(hit == 0.0)\n            {\n                bool tile =mod(ro.x, 1.0) + mod(ro.y, 1.0) > 1.0;\n                matcol *= tile?vec3(0.780,0.678,0.678):vec3(1.000,1.000,1.000); \n            }\n            else\n            {\n                matcol *= vec3(0.804,0.914,0.996);\n            }\n            vec3 m = normalize(nrand3(roughness, n) + 0.1*hit*s); //material normal\n            rd = reflect(rd,m);\n        }\n        else\n        {\n            outcol += matcol*pow(texture(iChannel1, rd.xzy).xyz,vec3(2.0));\n            break;\n        }\n    }\n    return outcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //RNG\n    s0 = uvec4(fragCoord, uint(iFrame), uint(fragCoord.x) + uint(fragCoord.y));\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    fragCoord += rand2();\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5 - 0.5*mouse.y;\n    float zrot = 4.0*mouse.x;\n    if (iMouse.z > 0.) {\n        fragColor *= 0.0;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    init = erot(init, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    fragColor += vec4(pathtrace(vec4(init, 0.), cam), 1.0);\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyWc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 251, 251, 352]], "test": "untested"}
{"id": "3lycWc", "name": "it's snowing", "author": "YitingLiu", "description": "Creating snow effect using cellular2x2 function made by Stefan Gustavson", "tags": ["noise", "function", "worleynoise", "snow", "min", "cellularnoise", "2x2", "permute"], "likes": 0, "viewed": 281, "published": 3, "date": "1611848425", "time_retrieved": "2024-07-30T19:41:59.041160", "image_code": "// Inspired by Stefan Gustavson's work on Worley noise 2x2 \n// I created the snow effect \n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 cellular2x2(vec2 P) {\n\t#define K 0.142857142857 // 1/7\n\t#define K2 0.0714285714285 // K/2\n\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t// Sort out the two smallest distances\n#if 0\n\t// Cheat and pick only F1\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated, F2 not computed\n#else\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = fragCoord.xy/iResolution.y;\n\n\tvec2 F = cellular2x2(st*100.+vec2(iTime/2000.,iTime));\n\tF += cellular2x2(st/1000.);\n\tF /= st+vec2(0.,1.)-abs(sin(iTime*0.5));\n\n\tfloat n =0.5-0.5*F.y;\n\tfragColor = vec4(n*iTime, n*iTime,n*iTime, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycWc.jpg", "access": "api", "license": "mit", "functions": [[307, 354, 376, 376, 421], [423, 747, 773, 773, 1753], [1755, 1755, 1812, 1812, 2055]], "test": "untested"}
{"id": "wtVcDV", "name": "lines are too hard", "author": "aliser", "description": "-", "tags": ["whatever"], "likes": 0, "viewed": 239, "published": 3, "date": "1611840018", "time_retrieved": "2024-07-30T19:41:59.855982", "image_code": "float calculateSlope(vec2 fromXY, vec2 toXY) {\n    return (toXY.y - fromXY.y) / (toXY.x - fromXY.x);\n}\n\nfloat calculateTheB(vec2 tipPnt, float slope) {\n    return tipPnt.y - slope * tipPnt.x;\n}\n\nfloat calculateYforX(float slope, float x, float b) {\n    return slope * x + b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 lineSegmentFromXY = vec2(128.0, 256.0);\n    vec2 lineSegmentToXY = iMouse.xy;\n    float tolerance = 5.0;\n    \n    float slope = calculateSlope(lineSegmentFromXY, lineSegmentToXY);\n    float b = calculateTheB(lineSegmentFromXY, slope);\n    float targetY = calculateYforX(slope, fragCoord.x, b);\n    \n    bool withinLine = abs(targetY - fragCoord.y) <= tolerance;\n    bool withinHorizontalBound = fragCoord.x >= min(lineSegmentFromXY.x, lineSegmentToXY.x) && \n                                 fragCoord.x <= max(lineSegmentFromXY.x, lineSegmentToXY.x);\n    bool withinVerticalBound = fragCoord.y >= min(lineSegmentFromXY.y, lineSegmentToXY.y) && \n                               fragCoord.y <= max(lineSegmentFromXY.y, lineSegmentToXY.y);\n    bool shouldDraw = withinLine && withinHorizontalBound && withinVerticalBound;\n    vec3 col = vec3(1., 1., 1.);\n    if(shouldDraw) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));   \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 102], [104, 104, 151, 151, 193], [195, 195, 248, 248, 276], [278, 278, 335, 335, 1472]], "test": "untested"}
{"id": "3tVcWV", "name": "Mirrored Goursat Surface", "author": "mla", "description": "The Goursat quartic surface, raytraced with reflections. Also a somewhat improved quartic solver (Lanczos method, with cubic solver from Numerical Recipes).", "tags": ["reflection", "raytrace", "cubic", "quartic", "lanczos", "goursat"], "likes": 15, "viewed": 460, "published": 3, "date": "1611833206", "time_retrieved": "2024-07-30T19:42:00.807437", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Mirror Goursat Quartic Surface\n//\n// http://mathworld.wolfram.com/GoursatsSurface.html\n// https://www.mathcurve.com/surfaces/goursat/goursat.shtml\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting parameters\n// 'c': clip at z = 0\n// 'g': show grid\n// 'r': do rotation\n// 'm': mirror surface\n// 's': no reflections\n// 'p': plain colouring\n//\n// Quartic surfaces with octahedral symmetry. Surface (including normals)\n// is raytraced using analytic solution to quartic due to Lanczos with\n// cubic solver from Numerical Recipes, plus some Newton-Raphson polishing.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, out vec3 res) {\n  assert(c != 0.0);\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),1.0/3.0);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(B,C,D,roots);\n  // And select the largest\n  float psi = roots[0];\n  if (nroots > 1 && roots[1] > psi) psi = roots[1];\n  if (nroots > 2 && roots[2] > psi) psi = roots[2];\n  // Give a quick polish with Newton-Raphson\n  for (int i = 0; i < 3; i++) {\n    // Just one round usually sufficient\n    psi -= evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n  }\n  return psi;\n}\n\n// The Lanczos quartic method. See \"Applied Analysis\".\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n1 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n2 = quadratic(1.0,alpha-a,beta-b,res.zw); \n  if (n1 == 0) res.xy = res.zw;\n  return n1+n2;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this seems to produce the least\n  // wild behaviour.\n  bool flip = abs(B/A) >= abs(D/E);\n  float c1,c2,c3,c4;\n  if (!flip) {\n    c1 = B/A; c2 = C/A; c3 = D/A; c4 = E/A;\n  } else {\n    // Solve for reciprocal\n    c1 = D/E; c2 = C/E; c3 = B/E; c4 = A/E;\n  }\n  nroots = lquartic(c1,c2,c3,c4,roots);\n  if (flip) {\n    // It can be advantageous to use the coefficients in the\n    // opposite order, thus solving for the reciprocal.\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}\n\nstruct Surface {\n  vec4 params;\n  vec3 p;\n};\n\n// Equation: pp.pp + k(p.p)^2 + k'a^2(p.p) + k''a^4 = 0\n// Derivative: 4ppp + 4k(p.p)p + 2k'a^2p\n// Expansion with p => p+tr:\n// pp => (p+tr)(p+tr) = pp + 2tpr + t^2rr\n// pp.pp => (pp + 2tpr + t^2rr).(pp + 2tpr + t^2rr)\n//  = pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr \n// p.p  => (p+tr).(p+tr) = p.p + 2tp.r + t^2r.r = p.p + 2tp.r + t^2\n// (p.p)^2 = (p.p + 2tp.r + t^2)(p.p + 2tp.r + t^2) =\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 2(2t(p.p)(p.r) + (p.p)t^2 + 2t^3(p.r))\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 4t(p.p)(p.r) + 2(p.p)t^2 + 4t^3(p.r))\n// ie.\n// pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr +\n// k(p.p^2 + t4[(p.p)(p.r)] + t^2[4(p.r)^2 + 2(p.p)] + t^3[4(p.r)] + t^4) +\n// k'a^2(p.p + 2tp.r + t^2) +\n// k''a^4\n// collecting terms:\n// t^0: pp.pp +   k(p.p)^2 +             k'a^2(p.p) + k''a^4\n// t^1: 4pp.pr + 4k(p.p)(p.r) +         2k'a^2(p.r)\n// t^2: 6pp.rr +  k[4(p.r)^2 + 2(p.p)] + k'a^2\n// t^3: 4pr.rr + 4k(p.r)\n// t^4: rr.rr +   k\n\nint goursatsurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float k2 = surface.params[2];\n  float a = surface.params[3];\n  vec3 pp = p*p;\n  vec3 pr = p*r;\n  vec3 rr = r*r;\n  float p2 = dot(p,p);\n  float a2 = a*a;\n  float a4 = a2*a2;\n#if 0\n  float pdr = dot(p,r);\n  float A = dot(rr,rr) + k;\n  float B = 4.0*dot(pr,rr) + 4.0*k*pdr;\n  float C = 6.0*dot(pp,rr) +     k*(4.0*pdr*pdr + 2.0*p2) + k1*a2;\n  float D = 4.0*dot(pp,pr) + 4.0*k*(p2*pdr)           + 2.0*k1*a2*pdr;\n  float E = dot(pp,pp)         + k*p2*p2 + k1*a2*p2 + k2*a4;\n#else\n  // Check we have adjusted p so that p.r = 0!\n  assert(eq(dot(p,r),0.0));\n  assert(eq(dot(r,r),1.0));\n  float A =     dot(rr,rr) +     k;\n  float B = 4.0*dot(pr,rr);\n  float C = 6.0*dot(pp,rr) + 2.0*k*p2    + k1*a2;\n  float D = 4.0*dot(pp,pr);\n  float E =     dot(pp,pp) +     k*p2*p2 + k1*a2*p2 + k2*a4;\n#endif\n  return quartic(A,B,C,D,E,roots);\n}\n\nvec3 goursatnormal(Surface surface, vec3 p) {\n  // 4ppp + 4k(p.p)p + 2k'a^2p\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float a = surface.params[3];\n  return 4.0*p*p*p + 4.0*k*dot(p,p)*p + 2.0*k1*a*a*p;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  return goursatsurface(surface,p0,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  return goursatnormal(surface,p);\n}\n  \nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < 4; i++) {\n    if (i == nroots) break;\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (!key(CHAR_C) || p.z > 0.0) { // clip at z == 0\n        t = roots[i];\n      }\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  if (!key(CHAR_G)) basecolor *= gridline(p);\n  if (key(CHAR_P)) basecolor = vec3(0.8);\n  result.p = p; result.n = n; result.color = applylighting(basecolor,p,n,r);\n  return true;\n}\n\nSurface surface;\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float att = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // If we've hit the surface some distance from origin,\n    // stop reflecting.\n    if (dot(p,p) > 1000.0) break;\n    // Solve from closest point on ray to origin.\n    // This makes p.r = 0.\n    float tmin = 0.0;\n    tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(surface,p,r,-tmin,res)) break;\n    if (key(CHAR_P) || key(CHAR_S)) return res.color;\n    color += att*res.color;\n    att *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (key(CHAR_P)) return vec3(0.5);\n  if (key(CHAR_M)) return texture(iChannel1,r).xyz;  \n  return color + att*pow(abs(r),vec3(2));\n}\n\n// Interesting parameters from:\n// https://www.mathcurve.com/surfaces.gb/goursat/goursat.shtml\nconst vec4 goursatparams[] = \n  vec4[](\n    vec4(0,-1,0,1),\n    vec4(-1,-0.25,0.25,1),\n    vec4(-1,1,1,1),\n    vec4(0,-2,2,1),\n    vec4(-0.5,-1,0.5,1),\n    vec4(-0.5,1,-1.5,1),\n    vec4(-1,4,-6,1),\n    vec4(-1,1,1,1),\n    vec4(-1,2,-2,1),\n    vec4(-0.333,-0.666,0.666,1));\n\nconst int nparams = goursatparams.length();\n\nvoid init() {\n  float ttime = 0.1*iTime;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  vec4 params;\n  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  isurface %= nparams+1;\n  if (isurface == 0) {\n    params = mix(goursatparams[int(rtime)%nparams],\n                 goursatparams[int(rtime+1.0)%nparams],\n                 ttime);\n  } else {\n    params = goursatparams[isurface-1];\n  }\n  surface = Surface(params,vec3(0));\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime + 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 4.0;\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  init();\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = normalize(vec3(uv, 2.0));\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color/(1.0+color),vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#define assert(x)\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[946, 946, 1003, 1003, 1027], [1029, 1029, 1091, 1091, 1121], [1123, 1154, 1210, 1210, 1442], [1444, 1502, 1554, 1554, 2197], [2199, 2199, 2240, 2240, 2651], [2653, 2708, 2776, 2776, 3252], [3254, 3254, 3328, 3328, 3908], [4921, 4921, 4990, 4990, 5881], [5883, 5883, 5928, 5959, 6109], [6111, 6111, 6171, 6171, 6408], [6475, 6475, 6499, 6535, 6652], [6654, 6654, 6719, 6719, 6766], [6770, 6770, 6810, 6810, 6847], [6851, 6851, 6930, 6930, 7633], [7653, 7653, 7681, 7681, 8407], [8823, 8823, 8836, 8836, 9265], [9267, 9299, 9326, 9326, 9676], [9678, 9678, 9735, 9735, 10519]], "test": "untested"}
{"id": "tlycDV", "name": "Projective disc study 2b", "author": "sig", "description": "Same as 2a except that instead of wrapping around the ray is reflected. So not a \"projective disc\" but a \"mirror disc\".\n\nEDIT: changed background so the geometry is easier to follow.", "tags": ["geometric"], "likes": 1, "viewed": 295, "published": 3, "date": "1611823455", "time_retrieved": "2024-07-30T19:42:01.566408", "image_code": "#define PI 3.141592653589793\n\nfloat signedpow(float x, float e) {\n    return sign(x) * pow(abs(x), e);\n}\n\nvec4 _tex_bg(vec2 p, float R_background) {\n    vec2 center = vec2(cos(iTime), sin(iTime) * 0.3) * R_background * 0.2; \n    return vec4(texture(iChannel0, (p + center) / R_background * 0.4 - vec2(0.5, 0.55)));\n}\n\nvec4 tex_bg(vec2 p, float R_background) {\n    return vec4(1, 0, 0, 1) * cos(length(p) / R_background * PI * 10.0)\n        + vec4(0, 0.4, 0, 1) * step(-cos(p.x / R_background * PI * 8.0), -0.9)\n        + vec4(0, 0, 1, 1) * step(-cos(p.y / R_background * PI * 8.0), -0.9);\n}\n\nvec4 tex_cursor(vec2 p, float R_cursor) {\n    if (length(p) > R_cursor) { return vec4(0); }\n    vec2 sprite_size = vec2(0.159, 1.0);\n    float sprite_i = mod(floor(iTime * 6.0), 6.0);\n    vec2 tex_uv = sprite_size * (0.5 - 0.5 * p / R_cursor);\n    return texture(iChannel1, tex_uv + sprite_i * vec2(sprite_size.x, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float R = 0.4 + 0.3 * signedpow(sin(iTime / 5.0), 0.3);\n\n    // pixel to evaluate\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // clamp the cursor cat to the edge of the disc\n    vec2 c = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec2 cursor = normalize(c) * min(length(c), R - 0.0001);\n    vec4 cursorSample = tex_cursor(cursor - p, R * 0.3);\n    \n    vec2 p0 = p;\n    if (length(p) > R) {\n        // direction from cursor to pixel in screen space (without wrapping)\n        vec2 look_dir = normalize(p - cursor);\n\n        // calculate distances for the inside-the-disc part\n        // q = projection of origin on look-dir line\n        // c = cursor\n        // a = intersection point\n        float qc = dot(cursor, look_dir);\n        vec2 d = cursor - qc * look_dir; // == 0q, perpendicular vector from origin to look_dir line\n        float qa = sqrt(R*R - d.x*d.x - d.y*d.y);\n        float chord_len = 2.0 * qa;\n        float len_before_wrap = qa - qc; // since p is outside the disc, this should be < distance(p, cursor)\n        \n        // find look_dir chord (intersection points of disc and look_dir line relative to origin)\n        // first wrap point = end of first chord = intersection point towards look_dir\n        vec2 intersect1 = d + qa * look_dir;\n        vec2 intersect2 = d - qa * look_dir;\n        float first_end_angle = atan(intersect1.y, intersect1.x);\n        float first_start_angle = atan(intersect2.y, intersect2.x);\n        float chord_angle = first_end_angle - first_start_angle;\n                \n        // number of wraps\n        float len_after_wrap = distance(p, cursor) - len_before_wrap; // since p is outside the disc, this should be positive\n        float n_wraps = floor(len_after_wrap / chord_len);        \n        \n        // find last chord by rotating the chord n_wraps times\n        float last_start_angle = first_end_angle + chord_angle * n_wraps;\n        float last_end_angle = last_start_angle + chord_angle;\n        vec2 last_start = R * vec2(cos(last_start_angle), sin(last_start_angle));\n        vec2 last_dir = normalize(R * vec2(cos(last_end_angle), sin(last_end_angle)) - last_start);\n\n        // add the remainder\n        float remainder = len_after_wrap - n_wraps * chord_len;\n        p0 = last_start + last_dir * remainder;\n    }\n        \n    fragColor = mix(tex_bg(p0, R), cursorSample, cursorSample.a);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlycDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 65, 65, 104], [106, 106, 148, 148, 316], [318, 318, 359, 359, 590], [592, 592, 633, 633, 914], [916, 916, 973, 973, 3385]], "test": "untested"}
{"id": "wtVyWK", "name": "Neural Stanford Bunny (5 kb)", "author": "blackle", "description": "my suspicions that mat4 multiplies and sines are really fast on the gpu are confirmed yet again\n\nexplainer: https://youtu.be/8pwXpfi-0bU", "tags": ["bunny"], "likes": 349, "viewed": 19518, "published": 3, "date": "1611814432", "time_retrieved": "2024-07-30T19:42:02.425112", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//like the last few shaders I've published, this is a neural network experiment.\n//this time, the neural network reproduces an SDF given the x,y,z coordinates\n//using siren networks with skip connections: https://vsitzmann.github.io/siren/\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    //sdf is undefined outside the unit sphere, uncomment to witness the abominations\n    if (length(p) > 1.) {\n        return length(p)-.8;\n    }\n    //neural networks can be really compact... when they want to be\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyWK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[435, 435, 473, 473, 535], [537, 537, 558, 644, 4849], [4851, 4851, 4870, 4870, 4986], [4988, 4988, 5045, 5045, 6313]], "test": "untested"}
{"id": "3lVyDV", "name": "Bouncy Bezier", "author": "oneshade", "description": "Experimenting with motion blur and made a bouncy version of my bezier plot shader!", "tags": ["2d", "bezier", "motionblur", "glow", "bouncy"], "likes": 5, "viewed": 210, "published": 3, "date": "1611802439", "time_retrieved": "2024-07-30T19:42:03.185081", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PLOT_RES 30.0\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 Bezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv * tInv +\n           b * 9.0 * t * tInv * tInv * tInv +\n           c * 9.0 * tInv * t * t * t +\n           d * t * t * t * t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 50.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float time = iTime * 3.0;\n\n    float t1 = 0.5 * time, t2 = time, t3 = 1.25 * time;\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c1      * 3.0, s2 * c3 * 2.0);\n    vec2 b = vec2(s3 * c2 * 3.0, c2      * 2.0);\n    vec2 c = vec2(c3 * c2 * 3.0, s2 * s1 * 2.0);\n    vec2 d = vec2(c2 * c1 * 3.0, s3      * 2.0);\n\n    vec2 prevPos = a;\n    float tStep = 1.0 / PLOT_RES;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 curPos = Bezier(a, b, c, d, t);\n        color = mix(color, hue2rgb(t + time), smoothstep(unit, 0.0, sdLine(uv, prevPos, curPos)));\n        prevPos = curPos;\n    }\n\n    fragColor = vec4(color * 2.0, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "#define MOTION_BLUR 0.9\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = mix(texture(iChannel0, uv), texture(iChannel1, uv), 1.0 - MOTION_BLUR);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "wtyyDK", "name": "Ray-Marching: Path Tracing", "author": "Zi7ar21", "description": "Path Tracing a scene with Ray-Marching.", "tags": ["raymarching", "raymarch", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "path"], "likes": 6, "viewed": 426, "published": 3, "date": "1611795231", "time_retrieved": "2024-07-30T19:42:04.042787", "image_code": "// Common contains adjustable parameters and RNG functions\n// Buffer A contains the Path-Tracer\n// Buffer B contains an image export\n// This contains the output to the screen\n\n// Ray-Marching: Path Tracing by Zi7ar21 --- January 27th, 2020\n// Last Updated: January 27th, 2020 22:30 Mountain Time\n\n// If you didn't find this on ShaderToy there may be an updated version at:\n// https://www.shadertoy.com/view/wtyyDK\n// A messy experimental version can be found at:\n// https://www.shadertoy.com/view/tlVyWK\n\n// Michael0884 fixed this like a lot, check him out:\n// https://www.shadertoy.com/user/michael0884\n\n// Also check out LoicVDB:\n// https://www.shadertoy.com/user/loicvdb\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This contains adjustable parameters and RNG functions\n\n// Camera Settings\n#define camerafov 1.0\n#define camerapos vec3(0.0, 0.0, -2.0)\n\n// Adjustable Path-Tracing Settings\n#define maxbounces 128\n#define maxmarches 1024\n#define collisiondist 1e-4\n#define scenesize 8.0\n#define ditherradius 1.0\n\n// Adujustable Fractal Settings\n#define iterations 4\n#define power 8.0\n\n// PBR Theory (Albedo, Normal, Metallic, Roughness)\n// https://learnopengl.com/PBR/Theory\n\n// Material (Albedo, Roughness)\nvec4 materialproperties(int material){\n    if(material == 0){\n        return vec4(vec3(1.0, 1.0, 0.5), 0.25);\n    }\n    if(material == 1){\n        return vec4(vec3(0.5, 0.5, 1.0), 0.125);\n    }\n    return vec4(0.0);\n}\n\n// Constants (ShaderToy uses Single Precision which can represent Pi as 3.14159265 whilst Double Precision\n// can encode pi as 3.141592653589793, who knows maybe in the future ShaderToy will support Double so why not\n// include the 3589793)\n#define pi 3.141592653589793\n#define twopi pi*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state>>((state>>28u)+4u))^state)*277803737u;\n    ns = (word>>22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Nor3alized Random also from Michael0884: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}", "buffer_a_code": "// This contains the Path-Tracer\n\n// Simple Scene Distance Estimator\n/*float DE(vec3 pos){\n    float sphere = length(pos)-0.5;\n    float plane = pos.y+0.25;\n    return min(plane, sphere);\n}*/\n\n// Mandelbulb Distance Estimator\nfloat mandelbulb(vec3 pos){\n    pos = vec3(pos.x, pos.z, pos.y);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iterations; i++){\n\t\tr = length(z);\n\t\tif(r > 4.0){break;}\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Infinite Plane Distance Estimator\nfloat plane(vec3 pos){\n    float plane = pos.y+0.5;\n    return plane;\n}\n\n// Nearest Distance Estimator\nfloat DE(vec3 pos){\n    float DE1 = mandelbulb(pos);\n    float DE2 = plane(pos);\n    return min(DE1, DE2);\n}\n\n// Tetrahedron Normal Function\n/*vec3 normal(vec3 pos){\n    float normprecision = collisiondist*0.1;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy*DE(pos+k.xyy*normprecision)+\n                     k.yyx*DE(pos+k.yyx*normprecision)+\n                     k.yxy*DE(pos+k.yxy*normprecision)+\n                     k.xxx*DE(pos+k.xxx*normprecision));\n}*/\n\n// Forward and Central Differences Normal Function (Alternate Option, Slower)\nvec3 normal(vec3 pos){\n    const vec2 diff = vec2(collisiondist*0.1, 0.0);\n    return normalize(vec3(DE(pos+diff.xyy)-DE(pos-diff.xyy),\n                          DE(pos+diff.yxy)-DE(pos-diff.yxy),\n                          DE(pos+diff.yyx)-DE(pos-diff.yyx)));\n}\n\n// Path-Tracing\nvec3 raymarch(vec3 pathdir, vec3 pathorig){\n    vec3 pathpos = pathorig;\n    vec3 surfnormal;\n    float distest;\n    int bounces = 0;\n    vec3 closestpos = pathpos;\n    vec3 outCol = vec3(1.0);\n    for(int i = 0; i < maxmarches; i++){\n        // Check if the path is done\n        if(length(pathpos) > scenesize) {return outCol*texture(iChannel1, pathdir).rgb;}\n        if(bounces > maxbounces){break;}\n\n        // Find the distance to the scene\n        distest = DE(pathpos);\n\n        // Michael0884: Closest Non-Colliding Position\n        if(distest > collisiondist){closestpos = pathpos;}\n\n        // Bounce the Path if it hits something\n        if(distest < collisiondist){\n            int object = 0;\n            if(mandelbulb(pathpos) < plane(pathpos)){object = 0;}\n            else{object = 1;}\n            vec4 matprops = materialproperties(object);\n            outCol *= matprops.rgb;\n            surfnormal = normal(pathpos);\n            pathpos = closestpos;\n            pathdir = reflect(pathdir, normalize(nrand3(matprops.w, surfnormal)));\n            bounces++;\n        }\n\n        // Otherwise just keep going\n        else{pathpos += pathdir*distest;}  \n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n\n    // Initialize RNG\n    INIT_RNG;\n\n    // Screen UV Coordinates, centered on [0.0, 0.0] and extends to 1.0 x or y, so that it looks fine no matter the aspect ratio.\n    vec2 uv = 2.0*((fragCoord.xy+nrand2(ditherradius*0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Rotation Matrix\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\n    // Direction of the path\n    vec3 pathdir = normalize(camerafov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Run the Path-Tracing\n    vec3 raymarched = raymarch(pathdir, camerapos);\n\n    fragColor += vec4(max(vec3(0.0), raymarched), 1.0);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This contains an image export\n\n// Along the bottom at the right of this editor, there is a little image icon.\n// If you click it, ShaderToy will save a 32-Bit Floating Point OpenEXR Image.\n// A 32-Bit OpenEXR is much better for editing than saving an 8-BPC PNG Image.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[675, 675, 729, 729, 785]], "test": "untested"}
{"id": "WtVyWV", "name": "Octahedron SDF (not exact)", "author": "oneshade", "description": "I came across this somewhat by accident while playing with tdhooper's SDF mesher: http://tdhooper.github.io/glsl-marching-cubes/", "tags": ["distancefield", "sdf", "octahedron", "bound"], "likes": 2, "viewed": 185, "published": 3, "date": "1611793810", "time_retrieved": "2024-07-30T19:42:04.877555", "image_code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    const float c = 1.73205080757; // sqrt(3)\n    return (dot(abs(p), vec3(1.0)) - s) / c;\n}\n\nSurface mapScene(in vec3 p) {\n    vec3 planeColor = vec3(mod(dot(floor(p.xz), vec2(1.0)), 2.0));\n    Surface plane = Surface(p.y + 1.0, 1.6 * planeColor, planeColor, vec3(0.0), 0.0);\n    Surface shape = Surface(sdOctahedron(p, 0.5 + 0.5 * sin(iTime)), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 8.0);\n\n    if (plane.dist < shape.dist) {\n        return plane;\n    }\n\n    return shape;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    vec3 ro = vec3(-5.0 * c, 1.0, -5.0 * s);\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = -f;\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 152, 152, 245], [247, 247, 276, 276, 642], [644, 644, 671, 671, 948], [950, 950, 1005, 1005, 2140]], "test": "untested"}
{"id": "3tVyWV", "name": "Flag in the sand", "author": "intrakits", "description": "I am finally starting to get the hang of this shader thing. I figured out yesterday how to color objects by having them return a vec2, with the second value being an ID. Such a simple way to do it, but it never crossed my mind.\n", "tags": ["3d", "sdf", "flag", "sand"], "likes": 2, "viewed": 291, "published": 3, "date": "1611793324", "time_retrieved": "2024-07-30T19:42:05.928745", "image_code": "#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 sdSphere( vec3 p, float s )\n{\n    return vec2(length(p)-s,0);\n}\n\nvec2 sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),1.);\n}\n\nvec2 sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return vec2(min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),2.);\n}\nvec2 sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return vec2(k0*(k0-1.0)/k1,3.);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2(length( pa - ba*h ) - r,16.);\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nvec2 sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),21.);\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return vec2(abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness,15.);\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nvec2 cactus (vec3 pos){\n    //add cactus\n    vec2 uv4 = vec2(atan(pos.x,pos.z)/(3.14159*1.),pos.y/1.);\n    float disp4 = texture(iChannel1,uv4).r;\n    vec2 cactus = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .2 );\n    vec2 thorn = sdCapsule(pos, vec3(10,0,0), vec3(10,1,0), .14 );\n    thorn.x-=disp4*.1;\n    thorn.y = 17.;\n    cactus = opU(cactus,thorn);\n    \n    vec3 nP = pos;\n    nP.y += (sin(nP.x*4.) * .1 * smoothstep(1.1,1.2,nP.x));\n    vec2 cactusR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .13 );\n    vec2 thornR = sdCapsule(nP, vec3(10,.5,0), vec3(10.5,.5,0), .08 );\n    \n    thornR.x-=disp4*.1;\n    thornR.y = 17.;\n    cactusR = opU(cactusR,thornR);\n    cactus.x = smin(cactusR,cactus, .1).x;\n    return cactus;\n}\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    //get rock displacement\n    vec2 uv = vec2(atan(pos.x,pos.z)/(3.14159*2.),pos.y/5.);\n    float disp = texture(iChannel0,uv).r;\n    vec2 uv2 = vec2(pos.x*.1, pos.z*.1);\n    float disp2 = texture(iChannel0,uv2).r;\n    vec2 uv3 = vec2(pos.x*.1, pos.z*.1+iTime*.1);\n    float disp3 = texture(iChannel1,uv3).r;\n    disp3 *= smoothstep(.09,.32,abs(pos.z));\n    \n    \n\n    //make gyroid\n    vec2 gyroid = sdGyroid(pos-vec3(10.,-3.,5.), 0.3, 1., .8);\n    \n    //add floor to scene\n    vec2 floorP = vec2(pos.y,20.);\n    //apply rocky displacement to floor\n    floorP.x-=disp2*.1;\n    res = opU(floorP,res);\n    \n    //add gyriod to scene\n    res = opU(gyroid,res);\n    for(int i = 0; i < 2; i++){\n        for(int k = 0; k < 2; k++){\n            vec3 nP = pos;\n            nP.xz *= Rot(float(k)*3.1415);\n            res = opU(cactus(abs(nP-vec3(i+k*10,0,k+i*10))),res);\n        }\n    }\n    \n    \n    //add flag\n    vec2 pole = sdCylinder(pos, vec2(.01,1.4) );\n    res = opU(pole,res);\n    //add cloth\n    pos.x += (sin(pos.z + iTime*5.)*.1) * smoothstep(.1,1.1,pos.z);\n    vec2 cloth = sdBox( pos-vec3(0,1.1,0.5), vec3(.01,.3,.5) );\n    //cloth.x -=disp3*.03;\n    res = opU(cloth,res);\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    \n    // raymarch primitives   \n    // distance from origin\n    float dO=0.;\n    float ID = -1.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        vec2 getObj = map(p);\n        ID = getObj.y;\n        float ds = getObj.x;\n        //move origin to new point\n        if(ID == 15.){\n            dO+=ds*.1;\n        }\n        if(ID == 17.){\n            dO+=ds*.8;\n        }else{\n            dO+=ds;\n        }\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return vec2(min(dO, MAX_DIST),ID);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        float ks = .3;\n        // material        \n        if(m == 1.){\n            col = vec3(1,0,0);\n            float ks = .1;\n        }\n        else if( m==20.)\n        {\n            // project pixel footprint into the plane\n            /*vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);*/\n            col = vec3(0.4,.1,0);\n            ks = .1;\n        }\n        else if( m==15.){\n            col = vec3(0.4,.1,0);\n            ks = .1; \n        }\n         else if( m==16.){\n            col = vec3(0,.1,0);\n            ks = .1; \n        }\n        else if( m==21.){\n            col = vec3(1,1,1);\n            ks = 5.; \n        }\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(0.6, 0.7, -0.9) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 1.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 239, 264, 264, 283], [284, 284, 309, 309, 328], [329, 329, 365, 365, 393], [395, 395, 420, 420, 435], [437, 437, 471, 471, 505], [507, 507, 537, 537, 637], [639, 639, 686, 686, 983], [984, 984, 1042, 1042, 1140], [1142, 1142, 1175, 1175, 1230], [1232, 1232, 1302, 1302, 1442], [1444, 1444, 1480, 1480, 1791], [1793, 1793, 1849, 1849, 2351], [2353, 2353, 2404, 2404, 2528], [2530, 2530, 2594, 2594, 2872], [2874, 2874, 2937, 3001, 3588], [3590, 3590, 3626, 3626, 3976], [3978, 3990, 4025, 4025, 4138], [4140, 4165, 4216, 4216, 4571], [4573, 4585, 4632, 4632, 4977], [4979, 4979, 5050, 5050, 5388], [5390, 5390, 5454, 5454, 6014], [6016, 6062, 6110, 6110, 6279], [6281, 6281, 6318, 6318, 6912], [6914, 6914, 6956, 6956, 7556], [7558, 7598, 7662, 7662, 7920], [7992, 7992, 8022, 8022, 8055], [8157, 8226, 8273, 8273, 8306], [8307, 8307, 8372, 8372, 8459], [8460, 8460, 8479, 8479, 8541], [8542, 8582, 8620, 8620, 8717], [8719, 8759, 8800, 8800, 8872], [8873, 8873, 8896, 8913, 9602], [9603, 9603, 9628, 9628, 10866], [10868, 10916, 10967, 10967, 11172], [11174, 11174, 11214, 11277, 11905], [11907, 11952, 12030, 12053, 12440], [12442, 12488, 12520, 12520, 13090], [13092, 13092, 13134, 13134, 13443], [13445, 13497, 13561, 13582, 13815], [13817, 13817, 13882, 13901, 16705], [16707, 16707, 16759, 16759, 16936]], "test": "untested"}
{"id": "WtKyWV", "name": "GLSL smallpt fork", "author": "somebody", "description": "fork of https://www.shadertoy.com/view/4sfGDB but it averages color if mouse hasn't moved", "tags": ["3d", "raytracing", "reflection", "refraction", "globalillumination", "pathtracing", "montecarlo"], "likes": 3, "viewed": 339, "published": 3, "date": "1611792176", "time_retrieved": "2024-07-30T19:42:06.763513", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0,uv);\n    fragColor = vec4(draw.rgb,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// note: this is a fork of https://www.shadertoy.com/view/4sfGDB\n/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp://www.kevinbeason.com/smallpt/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*/\n\n// Play with the two following values to change quality.\n// You want as many samples as your GPU can bear. :)\n#define SAMPLES 6\n#define MAXDEPTH 4\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(600., vec3(50., 681.33, 81.6),\tvec3(12.), vec3(0.), DIFF);\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n\t\t//vec3 f = obj.c;\n\t\t//float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t//if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\n\n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = jitter(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n#ifdef ENABLE_NEXT_EVENT_PREDICTION\n\t\t\t//for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t// Sphere s = sphere(i);\n\t\t\t\t// if (dot(s.e, vec3(1.)) == 0.) continue;\n\n\t\t\t\t// Normally we would loop over the light sources and\n\t\t\t\t// cast rays toward them, but since there is only one\n\t\t\t\t// light source, that is mostly occluded, here goes\n\t\t\t\t// the ad hoc optimization:\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tfloat E = 1.;//float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc/nt, nt/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n\t\t\t\tif (rand()<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n\tseed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES; ++i)\n    {\n#ifdef DEBUG\n        vec3 test = radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n        if (dot(test, test) > 0.) color += vec3(1.); else color += vec3(0.5,0.,0.1);\n#else\n\t\tcolor += radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n#endif\n    }\n    float iterations = texelFetch(iChannel0, ivec2(0,0), 0).z * 1000.;\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) { // data\n        if (texelFetch(iChannel0, ivec2(0,0), 0).xy == iMouse.xy / iResolution.xy) { if (iterations < 1000.) { iterations++; } }\n        else { iterations = 0.; }\n        fragColor = vec4(iMouse.xy / iResolution.xy, iterations / 1000., 0.);\n    } else {\n        fragColor = mix(texture(iChannel0, fragCoord/iResolution.xy), vec4(pow(clamp(color/float(SAMPLES), 0., 1.), vec3(1./2.2)), 1.), 1. / (iterations + 1.));\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 177]], "test": "untested"}
{"id": "tlGcDK", "name": "Projective disc study 2", "author": "sig", "description": "This time projective disc from the cat's point of view\n\nClick inside the disc to move the cat (or outside, but the cat will prefer to remain inside the disc, thank you very much)", "tags": ["geometric"], "likes": 0, "viewed": 287, "published": 3, "date": "1611785582", "time_retrieved": "2024-07-30T19:42:07.516499", "image_code": "#define PI 3.141592653589793\n\nfloat signedpow(float x, float e) {\n    return sign(x) * pow(abs(x), e);\n}\n\nvec4 tex_bg(vec2 p, float R_background) {\n    vec2 center = vec2(cos(iTime), sin(iTime) * 0.3) * R_background * 0.2; \n    return vec4(texture(iChannel0, (p + center) / R_background * 0.4 - vec2(0.5, 0.55)));\n}\n\nvec4 tex_cursor(vec2 p, float R_cursor) {\n    if (length(p) > R_cursor) { return vec4(0); }\n    vec2 sprite_size = vec2(0.159, 1.0);\n    float sprite_i = mod(floor(iTime * 6.0), 6.0);\n    vec2 tex_uv = sprite_size * (0.5 - 0.5 * p / R_cursor);\n    return texture(iChannel1, tex_uv + sprite_i * vec2(sprite_size.x, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float R = 0.5 + 0.3 * signedpow(sin(iTime / 5.0), 0.3);\n\n    // pixel to evaluate\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // cursor cat stays inside the disc\n    vec2 c = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 cursor = normalize(c) * (abs(mod(length(c) - R, 4.0*R) - 2.0*R) - R);\n    vec4 cursorSample = tex_cursor(cursor - p, R * 0.1);\n    \n    vec2 p0 = p;\n    if (length(p) > R) {\n        // direction from cursor to pixel in screen space (without wrapping)\n        vec2 look_dir = normalize(p - cursor);\n\n        // calculate distances for the inside-the-disc part\n        // q = projection of origin on look-dir line\n        // c = cursor\n        // a = intersection point\n        float qc = dot(cursor, look_dir);\n        vec2 d = cursor - qc * look_dir; // == 0q, perpendicular vector from origin to look_dir line\n        float qa = sqrt(R*R - d.x*d.x - d.y*d.y);\n        float chord_len = 2.0 * qa;\n        float len_before_wrap = qa - qc; // since p is outside the disc, this should be < distance(p, cursor)\n        \n        // find look_dir chord (intersection points of disc and look_dir line relative to origin)\n        // first wrap point = end of first chord = intersection point towards look_dir\n        vec2 intersect1 = d + qa * look_dir;\n        vec2 intersect2 = d - qa * look_dir;\n        float first_end_angle = atan(intersect1.y, intersect1.x);\n        float first_start_angle = atan(intersect2.y, intersect2.x);\n        float chord_angle = first_end_angle - first_start_angle;\n                \n        // number of wraps\n        float len_after_wrap = distance(p, cursor) - len_before_wrap; // since p is outside the disc, this should be positive\n        float n_wraps = floor(len_after_wrap / chord_len);        \n        \n        // find last chord by rotating the chord n_wraps times\n        float last_start_angle = mod(first_end_angle + (PI + chord_angle) * n_wraps, 2.0*PI) - PI;\n        float last_end_angle = last_start_angle + chord_angle;\n        vec2 last_start = R * vec2(cos(last_start_angle), sin(last_start_angle));\n        vec2 last_dir = normalize(R * vec2(cos(last_end_angle), sin(last_end_angle)) - last_start);\n\n        // add the remainder\n        float remainder = len_after_wrap - n_wraps * chord_len;\n        p0 = last_start + last_dir * remainder;\n    }\n        \n    fragColor = mix(tex_bg(p0, R), cursorSample, cursorSample.a);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 65, 65, 104], [106, 106, 147, 147, 315], [317, 317, 358, 358, 639], [641, 641, 698, 698, 3136]], "test": "untested"}
{"id": "WlVcWK", "name": "Neon ball pit", "author": "loicvdb", "description": "Raytracing in a grid to instantiate objects, cheap enough to run multisampling (you can disable it in Common line 2)", "tags": ["reflection", "dof", "bloom", "aa", "fresnel", "neon", "multisampling", "aces", "fsaa"], "likes": 62, "viewed": 1419, "published": 3, "date": "1611785149", "time_retrieved": "2024-07-30T19:42:08.380190", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    o = sampleDof(iChannel0, iResolution.xy, vec2(.71, -.71), u);\n    float r = floor(log2(iResolution.y) - 5.5) + .5;\n    for(int i = 0; i < 4; i++)\n        o += texture(iChannel0, u/iResolution.xy, r+float(i*2))*.03;\n    vec3 x = o.rgb;\n    o = vec4((x*(2.51*x+.03))/(x*(2.43*x+.59)+.14), 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// uncomment this line for a faster version\n//#define LOW_QUALITY\n\n\n#ifdef LOW_QUALITY\n#define AA 1\n#define DOF_SAMPLES 3\n#else\n#define AA 2\n#define DOF_SAMPLES 6\n#endif\n\n\n#define APERTURE .01\n#define DOF_CLAMPING .7\n#define FOCAL_DISTANCE 8.\n\nvec4 sampleDof(sampler2D channel, vec2 channelDim, vec2 dir, vec2 u) {\n    float screenAperture = channelDim.y*APERTURE;\n    float sampleToRad = screenAperture * DOF_CLAMPING / float(DOF_SAMPLES);\n    vec4 o = vec4(0);\n    float sum = 0.;\n    for(int i = -DOF_SAMPLES; i <= DOF_SAMPLES; i++) {\n        float sRad = float(i)*sampleToRad;\n        vec4 p = texture(channel, (u+dir*sRad)/channelDim);\n        float rad = min(abs(p.a-FOCAL_DISTANCE)/p.a, DOF_CLAMPING);\n        float influence = clamp((rad*screenAperture - abs(sRad)) + .5, 0., 1.) / (rad*rad+.001);\n        o += influence * p;\n        sum += influence;\n    }\n    return o/sum;\n}\n\nfloat fresnel(const vec3 dir, const vec3 n) {\n    const float ior = 1.8;\n    const float r0 = ((1. - ior) / (1. + ior)) * ((1. - ior) / (1. + ior));\n    float x = 1.+dot(n, dir);\n    return r0 + (1.-r0) * x*x*x*x*x;\n}\n\nmat3 rotationMatrix(const vec3 rotation) {\n    vec3 c = cos(rotation), s = sin(rotation);\n    mat3 rx = mat3(1, 0, 0, 0, c.x, -s.x, 0, s.x, c.x);\n    mat3 ry = mat3(c.y, 0, -s.y, 0, 1, 0, s.y, 0, c.y);\n    mat3 rz = mat3(c.z, -s.z, 0, s.z, c.z, 0, 0, 0, 1);\n    return rz * rx * ry;\n}", "buffer_a_code": "vec4 sphereI(vec3 pos, const vec3 dir, vec3 sPos){\n    pos -= sPos;\n\tfloat b = -dot(pos, dir);\n\tfloat d = b * b - dot(pos, pos) + .2;\n\tif (d < 0.0) return vec4(-1.);\n\tb -= sqrt(d);\n\treturn vec4(normalize(pos+b*dir), b);\n}\n\nvec4 sceneI(const vec3 pos, const vec3 dir) {\n    vec3 s = sign(dir);\n    float t   = max(0., -(pos.y+s.y*1.3)/dir.y);\n    float end = max(0., -(pos.y-s.y*1.0)/dir.y);\n    for(int i = 0; i < 16 && t < end; i++) {\n        vec3 p = pos+t*dir;\n        vec2 fp = floor(p.xz);\n        vec2 co = cos(fp*.5+iTime);\n        vec4 sI = sphereI(pos, dir, vec3(fp+.5, co.x*co.y).xzy);\n        if(sI.w > 0.) return sI;\n        vec2 l = (s.xz*.5+.5+fp-p.xz) / dir.xz;\n        t += min(l.x, l.y) + .1;\n    }\n    return vec4(-1.);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    mat3 rot = rotationMatrix(vec3(-.7, iTime*.15, 0.));\n    o = vec4(0.);\n    for(int y = 1; y <= AA; y++) {\n        for(int x = 1; x <= AA; x++) {\n            vec2 uv = (floor(u)+vec2(x, y)/float(AA+1)-iResolution.xy*.5) / iResolution.y;\n            vec3 pos = vec3(0., 0., 7.) * rot;\n            vec3 dir = normalize(vec3(uv, -1.)) * rot;\n            pos.x += iTime*2.;\n            float att = 1.;\n            float d = 10.;\n            for(int i = 0; i < 2; i++) {\n                vec4 t = sceneI(pos, dir);\n                if(t.w < 0.) break;\n                if(i == 0) d = t.w;\n                pos += t.w*dir;\n                vec3 orientation = normalize(vec3(cos(floor(pos.xz) - iTime), .5).xzy);\n                vec3 emission = abs(dot(t.xyz, orientation)) < .2 ? (orientation.yxz+1.) : vec3(.0);\n                emission *= 4.*abs(fract(orientation.y*5.)*2.-1.);\n                float f = fresnel(dir, t.xyz);\n                o.rgb += att*(1.-f) * emission;\n                att *= f;\n                dir = reflect(dir, t.xyz);\n            }\n            o += vec4(att*vec3(1., 1.5, 2.)*step(0., dir.y), d);\n        }\n    }\n    o /= float(AA*AA);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 o, vec2 u) {\n    o = sampleDof(iChannel0, iResolution.xy, vec2(.71, .71), u);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 334]], "test": "untested"}
{"id": "wtycDV", "name": "0ptic. Illusion", "author": "aragorn38male", "description": "Just Fix the center of the Shader :)\n& You'll see a sort of depth...", "tags": ["illusion"], "likes": 1, "viewed": 223, "published": 3, "date": "1611777530", "time_retrieved": "2024-07-30T19:42:09.171075", "image_code": "// Rubino Marc - 2021\n// https://www.youtube.com/channel/UC4QabYdHqsMLv1WiwtYRzRw\n// Optical Illusion\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st -= 0.5;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 cr = vec3(1.,0.,0.);\n    float radius = 0.25;\n    float dist = length(st);\n    float a = smoothstep(dist,dist+0.3,radius);\n    float b = step(dist,radius);\n    vec4 fc1 = vec4(vec3(cr),1.0);\n\tvec4 fc2 = vec4(vec3(a)*vec3(1.),1.0);\n    vec4 fc3 = vec4(vec3(b)*vec3(cr),1.0);\n    fragColor = mix (fc1, fc2, fc3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 585]], "test": "untested"}
{"id": "ttycWV", "name": "Slightly more complex plane marc", "author": "mrange", "description": "Licence CC0: Slightly more complex plane marcher\nI had fun messing around with \"plane marching\" and FBMs\n", "tags": ["2d", "3d", "fbm"], "likes": 7, "viewed": 433, "published": 3, "date": "1611773610", "time_retrieved": "2024-07-30T19:42:10.054713", "image_code": "// Licence CC0: Slightly more complex plane marcher\n//  I had fun messing around with \"plane marching\" and FBMs\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)           dot(x, x)\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  co += 100.0;\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  const float ts = 2.5;\n  hpp.x = tanh_approx(hpp.x/ts)*ts;\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\nconst float  truchet_lw = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nfloat truchet_cell0(vec2 p) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2 = circle(p, 0.25);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nvec2 truchet(vec2 p, float h, out vec3 n) {\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  hp *= ROT(0.02*TIME);\n  hp += TIME*0.05;\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n  hp *= truchet_rots[int(r*4.0)];\n\n  float cd0 = truchet_cell0(hp);\n  float cd1 = truchet_cell1(hp);\n  float d0 = mix(cd0, cd1, (fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = abs(d) - truchet_lw;\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nfloat df(vec2 p, float h, out vec3 n) {\n  vec2 d = truchet(p, h, n); \n  return d.y;\n}\n\nfloat hf(vec2 p, float h) {\n  vec3 n;\n  float decay = 0.75/(1.0+0.125*L2(p));\n  float d = df(p, h, n);\n  const float ww = 0.085;\n  float height = (smoothstep(0.0, ww, d));\n  return pmax(2.0*height*decay, 0.5, 0.25);\n}\n\nfloat fbm(vec2 p, float h) {\n  const float aa = -0.45;\n  const mat2  pp = (2.03-0.0)*ROT(1.0);\n\n  float a = 1.0;\n  float d = 0.0;\n  float height = 0.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    height += a*hf(p, h);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return height/d;\n}\n\nconst float scale = 4.0;\n\nvec2 distortCoords(vec2 p, float h) {\n  p *= scale;\n  p.x = SABS(p.x, 0.1*abs(p.y)+0.001);\n  p*=ROT(TIME*0.075);\n  p*=ROT(-PI*tanh_approx(0.125*(L2(p)-0.25)));\n  \n  return p;\n}\n\nconst float exclusionRadius = 0.125*0.5;\n\nfloat distanceField(vec2 p, float h, out vec3 n) {\n  float c = circle(p, exclusionRadius);\n  p = distortCoords(p, h);\n//  return df(p, h, n);\n  return pmin(c, df(p, h, n), 0.25);\n}\n\nfloat height(vec2 p, float h) {\n  p = distortCoords(p, h);\n  return tanh_approx(fbm(p, h));\n}\n\nvec3 normal(vec2 p, float h, float aa) {\n  vec2 eps = vec2(2.0*aa, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy, h) - height(p + eps.xy, h);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx, h) - height(p + eps.yx, h);\n  \n  return normalize(n);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2(-b-h, -b+h);\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float np) {\n  float hh = hash(np);\n  vec2 p = pp.xy;\n  p -= off.xy;\n  float l = length(p);\n\n  vec3  dn;\n  float d  = distanceField(p, hh, dn)/scale;\n  float alpha = 1.0-smoothstep(-aa, aa, -d*4.0);\n  if (alpha < 0.1) return vec4(0.0);\n\n  float h  = height(p, hh);\n  vec3  n  = normal(p, hh, aa);\n\n  vec3 po = vec3(pp.xy, pp.z + h);\n\n  vec3 lp1 = ro + 1.0*vec3(1.0, -1.0, 1.25);\n  vec3 lp2 = ro+ 1.0*vec3(-1.0, -1.0, 2.5);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  vec3 hsv = vec3(0.0*hh+mix(0.6, 0.9, PSIN(TIME*0.1-10.0*l+(p.x+p.y))), tanh_approx(h*h*1.0), tanh_approx(1.0*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  baseCol1 *= mix(0.0, 4.0, 1.0/L2(lp1 - po));\n  baseCol2 *= mix(0.0, 3.0, 1.0/L2(lp2 - po));\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.25;\n  col += 1.00*matCol*baseCol1*mix(0.1, 1.0, pow(diff1, 4.0))*0.5;\n  col += 0.50*matCol*baseCol2*mix(0.1, 1.0, pow(diff2, 2.0))*0.5;\n  col = pow(col, vec3(1.25));\n  col += 4.0*baseCol1*pow(ref1, 20.0);\n  col += 2.0*baseCol2*pow(ref2, 10.0);\n\n  \n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n\n\n  return vec4(col, alpha);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return vec3(1.0, 0.0, 0.25)*tanh_approx(5.0*pow(ld, 200.0));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0+0.0;\n  const int furthest = 6;\n  const int fadeFrom = max(furthest-4, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  // Steps from nearest to furthest plane and accumulates the color\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n  \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.4;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[789, 789, 811, 811, 980], [982, 982, 1004, 1004, 1067], [1069, 1069, 1090, 1090, 1188], [1190, 1190, 1229, 1229, 1314], [1316, 1316, 1355, 1355, 1384], [1386, 1386, 1408, 1408, 1452], [1454, 1454, 1475, 1475, 1520], [1522, 1522, 1567, 1567, 1721], [1723, 1723, 1751, 1771, 1847], [1849, 1849, 1876, 1876, 1945], [1947, 1947, 2008, 2008, 2281], [2283, 2283, 2323, 2323, 2482], [2484, 2484, 2524, 2524, 2566], [2568, 2568, 2596, 2596, 2796], [2798, 2798, 2829, 2829, 2855], [3028, 3049, 3071, 3071, 3205], [3207, 3286, 3309, 3309, 3384], [3386, 3456, 3480, 3480, 3559], [3879, 3879, 3908, 3908, 4056], [4058, 4058, 4087, 4087, 4251], [4253, 4253, 4296, 4296, 4869], [4871, 4871, 4910, 4910, 4956], [4958, 4958, 4985, 4985, 5175], [5177, 5177, 5205, 5205, 5455], [5483, 5483, 5520, 5520, 5659], [5703, 5703, 5753, 5753, 5883], [5885, 5885, 5916, 5916, 5978], [5980, 5980, 6020, 6020, 6225], [6227, 6227, 6274, 6274, 6516], [6699, 6699, 6768, 6768, 8218], [8220, 8220, 8253, 8253, 8371], [8373, 8373, 8429, 8429, 9967], [9969, 9996, 10032, 10032, 10265], [10267, 10267, 10296, 10296, 10622], [10624, 10624, 10679, 10679, 10837]], "test": "untested"}
{"id": "ttyyDK", "name": "Volumetric fractal PT ", "author": "michael0884", "description": "A fork of MMSE specifically tuned for path tracing", "tags": ["interactive", "volumetric", "pathtracer"], "likes": 1, "viewed": 103, "published": 3, "date": "1611768580", "time_retrieved": "2024-07-30T19:42:11.461950", "image_code": "// Fork of \"Marble Marcher: SE\" by michael0884. https://shadertoy.com/view/3lKyDR\n// 2021-01-24 21:45:11\n\n//Marble Marcher Shadertoy Edition\n//Version 0.9 BETA\n\n//Ported by michael0884 (Mykhailo Moroz)\n\n//Original Marble Marcher by CodeParade\n//https://github.com/HackerPoet/MarbleMarcher\n\n//Also check out Marble Marcher Community Edition!\n//https://github.com/WAUthethird/Marble-Marcher-Community-Edition\n\n//Notable features:\n//Temporal antialiasing with disocclusion rejection, velocity vectors and neighbor clamping\n//Lots of blue noise\n//Ambient occlusion \n//PBR rendering\n//Path tracing support, uncomment the define in Common\n//Path tracer is also PBR with refraction support\n//Physics in purely shader based\n\n//Instructions\n//WASD/Arrows and mouse to move marble. Q/E camera distance. \n//R - restart level\n//SPACE - next level(only when you completed this one)\n//Backspace - return to main menu\n//F - go to free camera mode, in this mode Q/E regulate camera speed\n//Change parameters in Common tab\n//level transition buttons \n//P - next level\n//O - previous level\n//M - restart frame accumulation\n\n//comment if the compiler wasn't able to optimize text rendering\n#define RENDER_TEXT\n\n#define STRINGS 8\n#define TOTCHARS STRLENGTH*STRINGS\n/*\nconst uint[] TEXT_ARRAY = uint[](\n  STRING(M,a,r,b,l,e,_,M,a,r,c,h,e,r,_,_,_,_,_,_,_,_,_,_),     //0\n  STRING(S,h,a,d,e,r,t,o,y,_,E,d,i,t,i,o,n,_,_,_,_,_,_,_),     //1\n  STRING(P,o,r,t,_,b,y,_,m,i,c,h,a,e,l,_0,_8,_8,_4,_,_,_,_,_), //2\n  STRING(O,r,i,g,i,n,a,l,_,b,y,_,C,o,d,e,P,a,r,a,d,e,_,_),     //3\n  \n  STRING(P,r,e,s,s,_,S,p,a,c,e,_,t,o,_,C,o,n,t,i,n,u,e,_),     //4\n  STRING(P,r,e,s,s,_,R,_,t,o,_,R,e,s,t,a,r,t,_,L,e,v,e,l),     //5\n  \n  STRING(P,l,a,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),     //6\n  STRING(L,e,v,e,l,s,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),      //7\n  \n  STRING(B,a,c,k,_,t,o,_,M,a,i,n,_,M,e,n,u,_,_,_,_,_,_,_),\n  STRING(J,u,m,p,_,t,h,e,_,c,r,a,t,e,r,_,_,_,_,_,_,_,_,_),\n  STRING(T,o,o,_,m,a,n,y,_,t,r,e,e,s,_,_,_,_,_,_,_,_,_,_),\n  STRING(H,o,l,e,_,i,n,_,o,n,e,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,e,w,a,r,e,_,o,f,_,b,u,m,p,s,_,_,_,_,_,_,_,_,_),\n  STRING(M,o,u,n,t,a,i,n,_,c,l,i,m,b,i,n,g,_,_,_,_,_,_,_),\n  STRING(M,i,n,d,_,t,h,e,_,g,a,p,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(T,h,e,_,s,p,o,n,g,e,_,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,u,i,l,d,_,u,p,_,s,p,e,e,d,_,_,_,_,_,_,_,_,_,_),\n  STRING(A,r,o,u,n,d,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(T,o,p,_,o,f,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(M,e,g,a,_,C,i,t,a,d,e,l,_,_,_,_,_,_,_,_,_,_,_,_)\n);\n\n#define CONTOUR 1.1\n#define CHAR_WIDTH 0.5\n\nvoid draw_char(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, uint char)\n{        \n  p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size); \n  if(p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) return; \n  int code = int(char);\n  \n  p.x=(fract(p.x) - 0.5)*CHAR_WIDTH + 0.5; p.y=1.-p.y;                 \n  p+=vec2(code%16,15-code/16);                          \n  float sdf = (texture(iChannel3, p/16.).w - 0.5 + 1.0/256.0)*size;\n  \n  float blend = smoothstep(CONTOUR, 0.0, sdf);\n  vec3 color = tcol*(2.*smoothstep(CONTOUR, -CONTOUR, sdf) - smoothstep(1.2*CONTOUR, 0.0, sdf));\n  incol = mix(incol, color, blend);\n}\n\nvoid draw_string(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, int string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(STRLENGTH) || p.y < 0.0 || p.y > 1.0) return;\n  draw_char(incol, p0, tcol, pos + vec2(floor(p.x)*size*CHAR_WIDTH,0.), size, TEXT_ARRAY[int(p.x) + string*STRLENGTH]);   \n}\n\nvoid draw_string(inout vec3 incol, in vec2 p, in vec3 tcol, in vec2 pos, in float size, in uint[8] string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(8) || p.y < 0.0 || p.y > 1.0) return;\n  \n  //compiler doesn't want to optimize dynamic array indexing, idk why\n  //a loop doesn't work either\n  draw_char(incol, p0, tcol, pos + vec2(0.0*size*CHAR_WIDTH,0.), size, string[0]);\n  draw_char(incol, p0, tcol, pos + vec2(1.0*size*CHAR_WIDTH,0.), size, string[1]);\n  draw_char(incol, p0, tcol, pos + vec2(2.0*size*CHAR_WIDTH,0.), size, string[2]);\n  draw_char(incol, p0, tcol, pos + vec2(3.0*size*CHAR_WIDTH,0.), size, string[3]);\n  draw_char(incol, p0, tcol, pos + vec2(4.0*size*CHAR_WIDTH,0.), size, string[4]);\n  draw_char(incol, p0, tcol, pos + vec2(5.0*size*CHAR_WIDTH,0.), size, string[5]);\n  draw_char(incol, p0, tcol, pos + vec2(6.0*size*CHAR_WIDTH,0.), size, string[6]);\n  draw_char(incol, p0, tcol, pos + vec2(7.0*size*CHAR_WIDTH,0.), size, string[7]);\n}\n  */\n#define SHARPEN 2.\n#define LOWSAMPLE_BLUR 1.\nvec4 tone(vec4 col)\n{\n   return tanh(EXPOSURE*pow(col, vec4(0.8)));\n}\n\nvec4 sample_adaptive(sampler2D ch, vec2 uv)\n{\n    vec3 dx = vec3(1.0/vec2(textureSize(ch, 0)),0.);\n    \n    vec4 c = tone(texture(ch, uv));\n    vec2 v = decode(texelFetch(iChannel0, ivec2(uv*iResolution.xy), 0).w);\n    float k = mix(-LOWSAMPLE_BLUR, SHARPEN, smoothstep(0.1, 0.5, v.y));\n    \n    vec4 u = tone(texture(ch, uv + dx.zy));\n    vec4 d = tone(texture(ch, uv - dx.zy));\n    vec4 r = tone(texture(ch, uv + dx.xz));\n    vec4 l = tone(texture(ch, uv - dx.xz));\n    return (1.+k)*c - 0.25*k*(u+d+r+l); \n}\n  \nvoid mainImage( out vec4 c, in vec2 p )\n{\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec2 uv = p/iResolution.xy;\n    c.xyz = sample_adaptive(iChannel0, p/iResolution.xy).xyz;\n    //c.xyz = texture(iChannel1, p/(MR_SCALE*iResolution.xy)).xyz/5.0;\n    c.xyz = clamp(c.xyz, 0., 1.0);\n    \n    float ms = timers.x*100.0/60.0;\n    float fps = 1./timers.z;\n    float se = mod(timers.x/60., 60.);\n    float se0 = mod(-timers.x/60., 60.);\n    float dse0 = mod(se0, 1.0);\n    float mi = timers.x/3600.;\n    uint[8] timer = uint[](NUM2CHAR(mi/10.0),NUM2CHAR(mi),C(co),NUM2CHAR(se/10.0),NUM2CHAR(se),C(co),NUM2CHAR(ms/10.0),NUM2CHAR(ms));   \n    uint[8] fps_text = uint[](NUM2CHAR(fps/10.0),NUM2CHAR(fps),C(_),C(F),C(P),C(S),C(_),C(_));   \n    \n    float font_size = FONT_SCALE;\n    c.w = 1.0;\n    \n    //draw_string(c.xyz, p, vec3(1.), vec2(0.9, 0.01)*iResolution.xy, 20.0*font_size,  fps_text);\n    switch(int(MODE/64.0))\n    {\n    case GAMEMODE_MENU: //MAIN MENU\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.03)*iResolution.xy, 62.0*font_size,  0);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.40, 0.15)*iResolution.xy, 35.0*font_size,  1);\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  2);\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  3);\n       \n        break;\n    case GAMEMODE_LEVELS: //LEVELS MENU\n        \n        break;\n    case GAMEMODE_GAME: //TIMER\n        if(timers.x>=0.)\n        {\n           // draw_string(c.xyz, p, vec3(1.), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        }\n        else\n        {\n           // draw_char(c.xyz, p, vec3(1.), vec2(0.47 - 0.008*dse0, 0.01)*iResolution.xy, (80.0 + 40.0*dse0)*font_size,  NUM2CHAR(se0+1.0));\n        }\n        return;    \n    case GAMEMODE_FINISH: \n        //draw_string(c.xyz, p,  vec3(0.000,0.702,1.000), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  4);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  5);\n        break;    \n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//rendering settings\n#define MAX_STEPS 128\n#define MIN_DIST 1e-5\n#define MAX_DIST 120.0\n#define LIGHT_BRIGHTNESS 2.0\n#define FRACTAL_ITER 8\n#define FOV 1.6\n#define EXPOSURE 3.5\n#define ADAPTIVE_PHYSICS_ITERATIONS\n//#define FORCE_ALONG_CAMERA\n\n//multiresolution scaling\n#define MR_SCALE 3.0\n\n#define PATH_TRACING\n#define BOUNCES 4\n#define DIRECT_LIGHT\n#define AMBIENT 0.3\n#define APERTURE 0.00\n\n//TAA\n#define DISOCCLUSION_REJECTION 1e-4\n#define CAMERA_MOVEMENT_REJECTION 1e-3\n\n#ifdef PATH_TRACING\n    #define REPROJECTION 1.0\n#else\n    #define REPROJECTION 0.9\n#endif\n\n//#define AMBIENT_OCCLUSION\n//#define SHADOWS\n#define DIRECT_BRIGHTNESS vec3(6.0)\n\n#define FRACTAL_F0 vec3(0.025)\n#define FRACTAL_ROUGHNESS 0.02\n#define FRACTAL_TRANSPARENT false\n#define FRACTAL_WHITE 0.9\n\n#define DISOCCLUSION_REJECTION_STR 1.0\n\n//#define NEIGHBOR_CLAMP\n#ifdef PATH_TRACING\n    #define NEIGHBOR_CLAMP_RADIUS 3\n#else\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#endif\n\n\n//#define AUTO_FOCUS\n#define FOCAL_PLANE 0.3\n\n\n//gameplay defines\n#define NUM 16\n\n#define MOUSE_       0\n#define CAM_ANGLE_   1\n#define CAM_POS_     2\n#define PCAM_ANGLE_  3\n#define PCAM_POS_    4\n#define PRESOLUTION_ 5\n#define CAM_VEL_     6\n//scene\n#define LIGHT_POS_   7\n#define MARBLE_POS_  8\n#define DMARBLE_POS_ 9\n#define MARBLE_VEL_  10\n#define TIMER_MODE_  11\n#define FLAG_POS_    12\n\n//fractal angles, scale\n#define FRAC_PARAM1_ 13\n//shift\n#define FRAC_PARAM2_ 14\n//color\n#define FRAC_PARAM3_ 15\n\n#define GAMEMODE_MENU 0\n#define GAMEMODE_LEVELS 1\n#define GAMEMODE_GAME 3\n#define GAMEMODE_FINISH 4\n#define GAMEMODE_FREE 5\n\n#define GET_DATA(ch, i) texelFetch(ch, ivec2(i, 0), 0)\n\nfloat CAM_ANGLE;\n\n//fractal\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 iMarblePos, iFlagPos;\nvec3 iMarbleVel; vec4 dMarblePos;\n\nvec3 iLightDir;\nfloat isPlanet;\n\n//current and prev camera\nvec4 ang, pang; \nvec4 pResolution;\nmat3 cam, pcam;\nvec3 campos, pcampos;\nvec3 camvel;\nfloat radius;\n\nfloat time;\nvec3 timers;\nfloat MODE;\n\n\n//CAMERA stuff\nmat3 get_cam(vec2 ang)\n{\n    vec3 x_dir = vec3(cos(ang.x)*sin(ang.y), cos(ang.y), sin(ang.x)*sin(ang.y));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,1,0)));\n    vec3 z_dir = normalize(cross(y_dir, x_dir));\n    return mat3(-x_dir, y_dir, z_dir);\n}\n\n//use previous camera matrix and camera position to reproject a point onto previous frame\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = vec3(dot(pcam_mat[0],dir),dot(pcam_mat[1],dir),dot(pcam_mat[2],dir));\n    return vec3(screen.yz*iRes.y/(FOV*screen.x) + 0.5*iRes.xy, td);\n}\n\n//SCENE\nvoid load_scene(sampler2D data, float t, vec2 res)\n{\n    time = t;\n    CAM_ANGLE = 1./res.y;\n    vec4 d1 = GET_DATA(data, FRAC_PARAM1_);        \n    iFracScale = d1.x; iFracAng1 = d1.y+0.000*sin(t); iFracAng2 = d1.z; //Scale, Angle1, Angle2\n    isPlanet = d1.w;\n    iFracShift = GET_DATA(data, FRAC_PARAM2_).xyz;                //Offset\n    iFracCol =   GET_DATA(data, FRAC_PARAM3_).xyz;                    //Color\n    iMarblePos = GET_DATA(data, MARBLE_POS_);                //Marble radius + size\n    iFlagPos =  GET_DATA(data, FLAG_POS_);           //Flag radius + size\n    vec4 MV_ = GET_DATA(data, MARBLE_VEL_);\n    iMarbleVel = MV_.xyz;\n    radius = MV_.w;\n    \n    dMarblePos = GET_DATA(data, DMARBLE_POS_);\n    \n    vec4 TM_ = GET_DATA(data, TIMER_MODE_);\n    timers = TM_.xyz;\n    MODE = TM_.w;\n    \n    //current camera\n    ang = GET_DATA(data, CAM_ANGLE_);\n    campos = GET_DATA(data, CAM_POS_).xyz;\n    camvel = GET_DATA(data, CAM_VEL_).xyz;\n    cam = get_cam(ang.xy);\n    \n    //previous camera\n    pang = GET_DATA(data, PCAM_ANGLE_);\n    pcampos = GET_DATA(data, PCAM_POS_).xyz;\n    pcam = get_cam(pang.xy);\n    \n    iLightDir = normalize(GET_DATA(data, LIGHT_POS_).xyz);\n    \n    pResolution = GET_DATA(data, PRESOLUTION_);\n}\n\n//marble physics\nconst float ground_force = 0.008f;\nconst float air_force = 0.004f;\nconst float ground_friction = 0.99f;\nconst float air_friction = 0.995f;\nconst float orbit_speed = 0.005f;\nconst int max_marches = 10;\nconst int num_phys_steps = 6;\nconst float marble_bounce = 1.2f;\nconst float gravity = 0.005f;\n\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\nvec2 rand2t()\n{\n    pcg4d(s1); return vec2(s1.xy)/float(0xffffffffu);\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton(int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\n\n\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec3 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec3 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\nvec2 mp = vec2(-1.,1.);\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\nvoid boxFold(inout vec3 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_plane(vec3 p, vec4 d)\n{\n    return dot(p,d.xyz) + d.w;\n}\nfloat de_sphere(vec3 p, float r) {\n\treturn (length(p.xyz) - r);\n}\nfloat de_box(vec3 p, vec3 s) {\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0)));\n}\nfloat de_tetrahedron(vec3 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / sqrt(3.0);\n}\nfloat de_capsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n//##########################################\n//   Main DEs\n//##########################################\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec4 fractal(vec3 p)\n{\n    if(length(p) > 15.0) return vec4(1.,1.,1.,length(p) - 13.0);\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), de_box(p, vec3(6.0))/scale);\n}\n\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n// geometry\nfloat map (vec3 p)\n{\n    // hold space coordinates\n    vec3 pp = p;\n    \n    // distances\n    float scene = 1000.;\n    float shape = 1000.;\n    \n    // parameters\n    vec3 angle = vec3(1.,2.,3);\n    float range = .2;\n    \n    // amplitude of kifs\n    float a = 1.;\n    float falloff = 1.55;\n    \n    // kifs (kaleidoscopic iterated function)\n    const float count = 6.;\n    for (float index = 0.; index < count; ++index)\n    {\n        // rotate more and more\n        p.xz *= rot(angle.y/a);\n        \n        // fold and translate\n        p = abs(p)-range*a;\n        \n        // combine to scene\n        scene = min(scene, max(p.x, max(p.y, p.z)));\n        \n        // falloff\n        a /= falloff;\n    }\n    \n    // invert volume\n    scene = -scene;\n    \n    return scene;\n}\n\n\nvec4 mandelbulb(in vec3 p)\n{\n    p = p + vec3(9.4, 3., 2.);\n    mat2 rm = mat2(cos(p.x), -sin(p.x), sin(p.x), cos(p.x));\n  \n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec3 orbitrap = vec3(1.0);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<2; i++ )\n    {\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );     \n        \n        orbitrap = min( orbitrap, abs(w) );\n\n        m = dot(w,w);\n\t\tif( m > 2.0 )\n            break;\n    }\n    return vec4(orbitrap, 0.25*log(m)*sqrt(m)/dz);\n}\n\nvec3 function(vec3 x){\n    vec3 ca = vec3(0.420,0.827,1.000)*cos(x.xxx)+vec3(1.000,0.902,0.859)*cos(x.yyy);\n    vec3 cb = vec3(0.898,1.000,0.922)*cos(x.zzz*1.5);\n    return ca*cb-cb;\n}\n\nmat2 ROT(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n#define SCALE 1.5\n#define SHIFT vec3(2.3, -5.2, 1.0)\n\nvec3 cyclic(vec3 x){\n    x*= 5.0;\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat2 rmZ = SCALE*ROT(0.35);\n    mat2 rmX = SCALE*ROT(0.46);\n    for (int i = 0; i < 8; i++){\n        vec3 F =function(x); \n        v += a*F;\n        x.xy = rmZ*x.xy;\n        x += 0.3*F;\n        x.yz = rmX*x.yz;\n        x += SHIFT;\n        a /= 1.05;\n    }\n    return v;\n}\n\n\nvec2 de_fractal(vec3 p)\n{\n    return vec2(fractal(p).w, 0);\n}\n\nvec3 color_fractal(vec3 p)\n{\n    return fractal(p).xyz;\n}\n\nvec2 de_marble(vec3 p) \n{\n\tfloat de = de_sphere(p - iMarblePos.xyz, iMarblePos.w*0.98);\n    return vec2(de, 1);\n}\n\nvec2 de_flag(vec3 p) \n{\n\tvec3 f_pos = iFlagPos.xyz + vec3(1.5, 4, 0)*iFlagPos.w;\n\tvec3 p_s = p/iFlagPos.w;\n\tvec3 d_pos = p - f_pos;\n\tvec3 caps_pos = p - (iFlagPos.xyz + vec3(0, iFlagPos.w*2.4, 0));\n\t//animated flag\n\tfloat speed = 14.0;\n\tfloat oscillation = sin(8.0*p_s.x - 1.0*p_s.y - speed*time) +\n                    0.4*sin(11.0*p_s.x + 2.0*p_s.y - 1.2*speed*time) + \n                    0.15*sin(20.0*p_s.x - 5.0*p_s.y - 1.4*speed*time);\n\t//scale the flag displacement amplitude by the distance from the flagpole\n\tvec2 flag = vec2(0.6*de_box(d_pos + caps_pos.x*vec3(0,(0.02+ caps_pos.x* 0.5+0.01*oscillation),0.04*oscillation),\n                        vec3(1.5, 0.8, 0.005)*iFlagPos.w), 2);\n\tvec2 capsule = vec2(de_capsule(caps_pos, iFlagPos.w*2.4, iFlagPos.w*0.05), 3);\n    \n\treturn opUnion(flag, capsule);\n}\n\nfloat sdf(vec3 pos) {\n\n    const vec3 SPHERE_POS = vec3(-5.253294,-1.80966312,-5.07759864);\n    const vec3 FOLD = vec3(-9.8712444,-2.76394824,-3.5193132);\n    const vec3 SHIFT1 = vec3(-10.0219781,-6.85714272,2.4e-7);\n    const float SCALE1 = 1.89931036;\n    const float FIXED_R = 50.;\n    const float MIN_R = 13.6039885;\n    vec3 ot = vec3(1.5);\n    \n\tvec4 p = vec4(pos, 1.);\n\tfor (int i = 0; i < 18; i++) {\n\t\tp.xyz -= SPHERE_POS;\n\t\tp *= FIXED_R / clamp(dot(p.xyz, p.xyz), MIN_R, FIXED_R);\n\t\tp.xyz = abs(p.xyz+SPHERE_POS-FOLD) + FOLD;\n \t\tp *= SCALE1;\n\t\tp.xy = -p.xy;\n\t\tp.xyz += SHIFT1;\n        ot = min(abs(p.xyz), ot);\n\t}\n\treturn (length(p.xyz)-10.) / p.w;\n}\n\nvec4 fog(vec3 p)\n{\n    p += vec3(9., 3., 0.);\n    float d = p.y;\n \n    vec3 K = vec3(1.5)*smoothstep(2.01, 2.0, d);\n    float sc = min(K.x, min(K.y, K.z));\n    return vec4(0);//vec4(1.5*K,sc);\n}\n\nvec2 physics_scene(vec3 p)\n{\n    vec2 fractal = vec2(fractal(p).w,0);\n    vec2 bulb = vec2(map(p), 5);\n    //vec2 mandelbox = vec2(mb(p).w,5.0);\n    vec2 box = vec2(de_box(p + vec3(5., 1., 0.), vec3(1.0)), 7.);\n    vec2 torus = vec2(de_sphere(p + vec3(10.9, 3., 0.), 0.6), 1.);\n    vec2 plane =vec2(de_plane(p, vec4(0., 1.0, 0., 3.5)),6.);\n    //vec2 bunny = vec2(bunny(p.xzy + vec3(4.,0.,3.)), 6.);\n    return opUnion(opUnion(box,plane), fractal);\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 physical = physics_scene(p);\n    vec2 marble = de_marble(p);\n   // vec2 flag = de_flag(p);\n   \n    return opUnion(physical, marble);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  0.25*(k.xyyx*scene(p + k.xyy*dx).x +\n\t\t\t      k.yyxx*scene(p + k.yyx*dx).x +\n\t\t\t      k.yxyx*scene(p + k.yxy*dx).x +\n\t\t\t      k.xxxx*scene(p + k.xxx*dx).x)/vec4(dx,dx,dx,1.0);\n}\n\nvec3 closestPoint(vec3 p) {\n\tconst vec3 k = vec3(1,-1,0);\n    const float dx = 1e-3;\n    vec4 n = 0.25*(k.xyyx*physics_scene(p + k.xyy*dx).x +\n\t\t\t       k.yyxx*physics_scene(p + k.yyx*dx).x +\n\t\t\t       k.yxyx*physics_scene(p + k.yxy*dx).x +\n\t\t\t       k.xxxx*physics_scene(p + k.xxx*dx).x); \n\tn.xyz = normalize(n.xyz);\n    p -= n.w*n.xyz;\n    //trace a few steps to the surface\n    for(int i = 0; i<1; i++)\n    {\n    //    p -= n.xyz*physics_scene(p).x;\n    }\n    return p;\n}\n\nstruct material\n{\n    vec3 color;\n    vec3 emission;\n    vec3 normal;\n    vec3 cpoint; //closest point\n    vec3 velocity;\n    float roughness;\n    bool transparent;\n    vec3 F0;\n    float inside;\n};\n\nmaterial getMaterial(inout vec4 p)\n{\n    material cur;\n    float mindistance = 0.75*max(CAM_ANGLE*p.w,MIN_DIST);\n    cur.normal = normalize(calcNormal(p.xyz, mindistance).xyz);\n    vec2 scene = scene(p.xyz);\n    cur.inside = sign(scene.x);\n    vec3 dsurface = cur.normal*scene.x;\n    cur.cpoint = p.xyz - dsurface;\n    \n    //move away from the surface\n    p.xyz += cur.inside*cur.normal*mindistance;\n    \n    int id = int(scene.y);\n    cur.F0 = vec3(0.15);\n    cur.transparent = false; \n    cur.emission = vec3(0.0);\n    switch(id)\n    {\n    case 0:\n        cur.color = mix(vec3(1.0), color_fractal(cur.cpoint).xyz,FRACTAL_WHITE);\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = FRACTAL_ROUGHNESS;\n        cur.transparent = FRACTAL_TRANSPARENT; \n        cur.velocity = vec3(0.);//TODO with animations\n        cur.emission = 0.0*vec3(1.000,1.000,1.000)*exp(-300.*clamp(pow(abs(length( cur.color - vec3(0.000,0.298,1.000) )),2.),0.,1.));\n        break;\n    case 1:\n        cur.color = vec3(1.);\n        cur.roughness = 0.02;\n        cur.F0 = vec3(0.03);\n        cur.velocity = dMarblePos.xyz;\n        cur.emission = vec3(.0);\n        cur.transparent = true;\n        break;\n    case 2:\n        cur.color = vec3(1.000,0.078,0.078);\n         cur.transparent = true;\n        cur.roughness = 0.02;\n        cur.velocity = vec3(0.); //TODO\n        break;\n    case 3:\n        cur.color = vec3(1.000,0.867,0.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    case 4:\n        cur.color = vec3(0.000,0.118,1.000);\n        cur.roughness = 0.01;\n        cur.velocity = vec3(0.);\n        break;\n    case 5:\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = FRACTAL_ROUGHNESS;\n        cur.transparent = true; \n        cur.color = mix(vec3(1.),mandelbulb(p.xyz).xyz, 0.7);\n        cur.velocity = vec3(0.);\n        break;\n    case 6:\n        cur.roughness = 0.5;\n        cur.transparent = false; \n        cur.color = vec3(1.000,1.000,1.000);\n        cur.velocity = vec3(0.);\n        break;\n    default:\n        cur.color = vec3(1.000,1.000,1.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    }\n    cur.color = clamp(cur.color, 0., 1.);\n    return cur;\n}\n\nvec4 shadow_fog(vec4 ro, vec3 rd)\n{\n    vec4 scatter = vec4(0.);\n    float stepd = 0.1;\n    ro += stepd*rand()*vec4(rd, 1.0);\n    float td = 0.;\n    for(int i = 0; i < 15; i++)\n    {\n        float dx = stepd*(1. +0.4*td);\n        scatter += dx*fog(ro.xyz); //only outiside\n        ro += vec4(rd,1.)*dx; \n        td += dx;\n        if(scatter.w > 4.0 || ro.w>MAX_DIST) break;\n        stepd *= 1. + 50.*CAM_ANGLE;\n    }\n    return exp(-scatter);\n}\n\nvec4 trace_fog(vec4 ro, vec4 rd, out vec4 scatter)\n{\n    vec2 r = rand2();\n    float thresh = -log(r.x);\n    scatter = vec4(0.);\n    float stepd = 0.08;\n    float td = 0.;\n    ro += stepd*r.y*vec4(rd.xyz, 1.0);\n    for(int i = 0; i < 25; i++)\n    {\n        float dx = stepd*(1. + 0.4*td);\n        scatter += dx*fog(ro.xyz); //only outiside\n        td += dx;\n        ro += vec4(rd.xyz, 1.0)*dx;\n        if(ro.w > rd.w || ro.w > MAX_DIST) return ro;\n        if(scatter.w > thresh) return ro;\n    }\n    return vec4(1e10);\n}\n\nint trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float sdf = scene(ro.xyz).x;\n        float de = abs(sdf); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        de -= 0.5*step(de, md)*md;\n        ro += vec4(rd,1.)*de; \n        if(de < md) return 1; //hit surface\n        if(ro.w > MAX_DIST) return 0; //miss\n    }\n    return 1; //hit surface\n}\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nconst vec4 ca = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 cb = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = vec2(textureSize(tex,0));\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\nuvec2 unpack_uint2x(uint x)\n{\n    return uvec2(x%0x00010000u,x/0x00010000u);\n}\n\nuint pack_uint2x(uvec2 x)\n{\n    return x.x + x.y*0x00010000u;\n}\n\nvec2 decode(float data)\n{\n    return vec2(unpack_uint2x(floatBitsToUint(data)))/100.;\n}\n\nfloat encode(vec2 data)\n{\n    return uintBitsToFloat(pack_uint2x(uvec2(data*100.0)));\n}\n\n//simplified ttg's GLSL character printing library\n//https://www.shadertoy.com/view/Wd2SDt\nconst struct CHARS {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CHAR = CHARS(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n  0x7fu);\n\n#define C(c) CHAR.c\n#define NUM2CHAR(x) (CHAR._0 + uint(x)%10u)\n#define STRLENGTH 24\n#define STRING(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23) \\\n     C(c0),C(c1),C(c2),C(c3),C(c4),C(c5),C(c6),C(c7),C(c8),C(c9),C(c10),C(c11), \\\n     C(c12),C(c13),C(c14),C(c15),C(c16),C(c17),C(c18),C(c19),C(c20),C(c21),C(c22),C(c23)\n\n\n#define MAIN_POS vec2(0.03, 0.30)*iResolution.xy\n#define LEVELS_POS vec2(0.03, 0.03)*iResolution.xy\n\n#define FONT_SCALE min(iResolution.x,iResolution.y)/400.0\n", "buffer_a_code": "//Controller\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.2/60.\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 11;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n////Around the world\n//Level(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n//      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nint GMODE, curLVL;\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1;\n    iFracAng2 = LVL.FracAng2;\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n    iMarblePos = LVL.MarblePos;\n    iMarbleVel = vec3(0.);\n    iFlagPos = LVL.FlagPos;\n    isPlanet = float(LVL.isPlanet);\n    \n    //set cemera to point to the flag\n    vec3 m2f = normalize(iFlagPos.xyz - iMarblePos.xyz);\n    float phi = atan(m2f.z, m2f.x);\n    float theta = acos(m2f.y);\n    ang.xy = vec2(phi - PI,PI - theta);\n    //camera distance from marble\n    radius = 10.;\n}\n\nvoid PhysicsIteration(float dt, vec3 marble_force, float frictionm)\n{\n    vec3 closest_fractal_point = closestPoint(iMarblePos.xyz);\n    vec3 dx = closest_fractal_point - iMarblePos.xyz;\n    float dist = length(dx);\n    dx = normalize(dx);\n    float onGround = step(dist, iMarblePos.w);\n    float force = ((dist < iMarblePos.w*1.14)?ground_force:air_force)*iMarblePos.w;\n    float friction =((dist < iMarblePos.w*1.14)?ground_friction:air_friction);\n    vec3 Gvec = (isPlanet==1.0)?normalize(iMarblePos.xyz):vec3(0.,1.,0);\n    //unintersect\n    iMarblePos.xyz += 0.3*onGround*dx*(dist - iMarblePos.w);\n    //momentum update\n    iMarbleVel += -marble_bounce*onGround*max(0.,dot(iMarbleVel, dx))*dx;\n\n    //update velocity\n    iMarbleVel += (-iMarblePos.w*gravity*Gvec +  frictionm*(friction - 1.0)*iMarbleVel + force*marble_force)*dt;\n    //update position\n    iMarblePos.xyz += iMarbleVel*dt;\n}\n\nvoid START(int levelid)\n{\n    levelid = levelid%levelnum;\n    timers = vec3(-3.*60., 0., iTimeDelta);\n    GMODE = GAMEMODE_GAME;\n    curLVL = levelid;\n    LoadLevel(Levels[levelid]);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    ivec2 pi = ivec2(p);\n    if(pi.x >= NUM && pi.y >= 1) discard;\n    \n    ///Loading Data\n    c = GET_DATA(iChannel2, pi.x);\n\n    vec4 mouse = GET_DATA(iChannel2,MOUSE_);\n    vec2 mousespeed = mouse.xy;\n\n    load_scene(iChannel2, iTime, iResolution.xy);\n\n    GMODE = int(MODE/64.0);\n    curLVL = int(MODE)%64;     \n\n    //Initialization\n    if(iFrame < 5)\n    {\n      \n        START(1);\n    }\n\n    if(GMODE < GAMEMODE_GAME) //Menus\n    {\n        pang = ang;\n        ang.xy = vec2(0.2*iTime, PI*0.35);         \n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        pcampos = campos;\n        campos = cam*vec3(-12.0, 0, 0) + vec3(0, 2, 0);\n\n        bool MB = (iMouse.w > 1.0);\n        vec2 MP = iMouse.xy;\n        \n        float font_size = FONT_SCALE;\n        if(MB)\n        {\n           \n       } \n    }\n    else //Gameplay\n    {\n        //Go into free camera mode\n        if(KeyPressEvent(KEY_F))\n        {\n            GMODE = (GMODE == GAMEMODE_FREE)?GAMEMODE_GAME:GAMEMODE_FREE;\n        }\n        if(KeyPressEvent(KEY_BSPACE))\n        {\n            GMODE = 0;\n        }\n        if(KeyPressEvent(KEY_R) || iMarblePos.y < -15.0)\n        {\n            START(curLVL);\n        }\n        if((KeyPressEvent(KEY_SPACE) && GMODE == GAMEMODE_FINISH) || KeyPressEvent(KEY_P))\n        {\n            START(curLVL+1);\n        }\n        if(KeyPressEvent(KEY_O))\n        {\n            START(abs(curLVL-1));\n        }\n\n        /////////cam update\n        pang = ang;\n        ang.xy = ang.xy + ang.zw*MOUSE_SENSITIVITY; // angle delta\n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n        ang.zw += vec2(-1.0, 1.0)*mouse.xy; //velocity\n        ang.zw *= 0.76;\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        //marble update\n        vec3 marble_force = vec3(0.);\n        float frictionm = 1.0; //friction multiplier\n\n        if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n        {\n            marble_force += cam[0];\n        }\n        if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n        {\n            marble_force -= cam[0];\n        }\n        if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n        {\n            marble_force += cam[1];\n        }\n        if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n        {\n            marble_force -= cam[1];\n        }\n\n        if(GMODE == GAMEMODE_GAME)\n        {\n            #ifndef FORCE_ALONG_CAMERA\n                marble_force = vec3(marble_force.x, 0., marble_force.z);\n                marble_force = marble_force/(length(marble_force)+1e-4);\n            #endif\n\n            marble_force = marble_force/max(length(marble_force), 1.);       \n        }\n\n        if(GMODE == GAMEMODE_FINISH)\n        {\n            vec3 flagmarble = (iFlagPos.xyz + vec3(0,8.*iFlagPos.w,0) - iMarblePos.xyz)/iFlagPos.w;\n            marble_force = 2.5*normalize(flagmarble)*min(length(flagmarble), 3.); \n            frictionm = 12.;\n        }\n\n        //PHYSICS\n        #ifdef ADAPTIVE_PHYSICS_ITERATIONS\n            float iterations = clamp(10.*timers.z*60.0, 4., 32.);\n        #else\n            float iterations = 10.;\n        #endif\n        float dt = 0.1;\n        vec4 pMarblePos = iMarblePos;\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        for(float i = 0.0; i<iterations; i++)\n            PhysicsIteration((timers.x >= 0.)?dt:0.0, marble_force, frictionm);\n        \n\n        dMarblePos = iMarblePos - pMarblePos;\n\n        //update camera position\n        pcampos = campos;\n\n        if(isKeyPressed(KEY_Q))\n        {\n            radius *= 1.0 - iterations*0.002;\n        }\n        if(isKeyPressed(KEY_E))\n        {\n            radius *= 1.01 + iterations*0.002;\n        }\n\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        {\n            //camera unintersection\n            vec3 rd = -cam[0];\n            float camd =iMarblePos.w*radius;\n            vec4 ro = vec4(iMarblePos.xyz + rd*iMarblePos.w*1.03,1e8);\n            if(scene(iMarblePos.xyz + cam*vec3(-camd,0,0)).x <= iMarblePos.w*0.2)\n            { ro.w = 0.;  trace(ro,rd); camd = ro.w; }  \n            campos = iMarblePos.xyz + cam*vec3(-camd, 0, 0);\n        }\n        else\n        {\n            //reuse radius as the speed regulator\n            camvel += - camvel*0.1 + CAMERA_SPEED*iMarblePos.w*marble_force*radius/10.; \n            campos += camvel;\n        }\n\n        //Win condition\n        if(GMODE == 3 && distance(iMarblePos.xyz, iFlagPos.xyz) < iFlagPos.w*4.0) GMODE = 4;\n\n        timers = vec3(timers.x + ((GMODE == 3)?dt*iterations:0.0), 0., mix(timers.z,iTimeDelta,0.03)); \n\n    }\n\n    //////////mouse update\n    if(length(iMouse.zw - iMouse.xy) > 10.)\n    {\n        mouse.xy = iMouse.xy - c.zw; // mouse delta\n        if(iFrame < 1)\n        {\n            mouse.xy = vec2(0.);\n        }\n    }\n    else\n    {\n        mouse.xy = vec2(0.); // mouse delta\n    }\n    mouse.zw = iMouse.xy; // mouse pos\n\n    switch(pi.x)\n    {\n    case MOUSE_: \n        c = mouse;\n        break;\n    case CAM_ANGLE_:  \n        c = ang;\n        break;\n    case CAM_POS_:  \n        c.xyz = campos;\n        break;\n    case CAM_VEL_:  \n        c = vec4(camvel, 0.);\n        break;\n    case LIGHT_POS_:\n        c.xyz = vec3(-1.2, 0.4, 0.2);\n        break;\n    case PCAM_ANGLE_:\n        c = pang;\n        break;\n    case PCAM_POS_:\n        c.xyz = pcampos;\n        break;\n    case PRESOLUTION_:\n        c.xy = pResolution.zw;\n        c.zw = iResolution.xy;\n        break;\n    case MARBLE_POS_:  \n        c = iMarblePos;\n        break;\n    case DMARBLE_POS_:  \n        c = dMarblePos;\n        break;      \n    case MARBLE_VEL_:  \n        c = vec4(iMarbleVel, radius);\n        break;\n    case TIMER_MODE_:  \n        c = vec4(timers, float(GMODE*64 + curLVL));\n        break;\n    case FLAG_POS_:\n        c = iFlagPos;\n        break;\n    case FRAC_PARAM1_:\n        c = vec4(iFracScale, iFracAng1, iFracAng2, isPlanet);\n        break;\n    case FRAC_PARAM2_:\n        c = vec4(iFracShift, 0.);\n        break;\n    case FRAC_PARAM3_:\n        c = vec4(iFracCol, 0.);\n        break;  \n    }   \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Multiresolution ray marching/Cone marching \n//http://www.fulcrum-demo.org/wp-content/uploads/2012/04/Cone_Marching_Mandelbox_by_Seven_Fulcrum_LongVersion.pdf\n\nvec2 sResolution;\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*sResolution.xy)/sResolution.y;\n    vec4 r = vec4(0.);\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    sResolution = iResolution.xy/MR_SCALE;\n    if(any(greaterThan(p, sResolution))) discard;\n    \n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, sResolution);\n    CAM_ANGLE = 1.0/sResolution.y;\n    vec4 ro = vec4(0.); vec3 rd;\n    getRay(p, ro.xyz, rd, APERTURE);\n\n   // trace(ro, rd);\n\n    c = vec4(ro.w);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//blue noise\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\n\nconst float Br = 0.0025;\nconst float Bm = 0.0003;\nconst float g =  0.9800;\nconst vec3 nitrogen = vec3(0.650, 0.570, 0.475);\nconst vec3 Kr = Br / pow(nitrogen, vec3(4.0));\nconst vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\nvec3 sky_color(vec3 rd)\n{\n\t// Atmosphere Scattering\n\tvec3 fsun = iLightDir;\n\tfloat brightnees = exp(-sqrt(pow(abs(min(5.*(rd.y-0.1),0.)),2.)+0.1));\n\tif(rd.y < 0.)\n\t{\n\t\trd.y = 0.;\n\t\trd.xyz = normalize(rd.xyz);\n\t}\n    float mu = dot(rd, fsun);\n\t\n\tvec3 extinction = mix(exp(-exp(-((rd.y + fsun.y * 4.0) * (exp(-rd.y * 16.0) + 0.1) / 80.0) / Br) * (exp(-rd.y * 16.0) + 0.1) * Kr / Br) * exp(-rd.y * exp(-rd.y * 8.0 ) * 4.0) * exp(-rd.y * 2.0) * 4.0, vec3(1.0 - exp(rd.y)) * 0.2, -rd.y * 0.2 + 0.5);\n\tvec3 sky_col = brightnees* 3.0 / (8.0 * 3.14) * (1.0 + mu * mu) * (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm) * extinction;\n\tsky_col = 0.4*clamp(sky_col,0.,10.);\n\treturn LIGHT_BRIGHTNESS*sky_col/ 4.0; \n}\n\n\n#define LIGHT_ANGLE 0.02\n\nvec3 shadowtrace(vec3 ro, vec3 rd, float maxd)\n{\n    float td = 0.;\n    vec4 fog = shadow_fog(vec4(ro,0.), rd);\n    //noise to remove shadow artifacts\n    float phase = rand() - 0.5;\n    float angle = 1e10;\n    for(int i = 0; i < 40; i++)\n    {\n        float de = scene(ro).x*(1. + 0.2*phase);\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        if(td > maxd) break;\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.02, LIGHT_ANGLE, angle)*fog.xyz*LIGHT_BRIGHTNESS;\n}\n\nfloat ambitrace(vec3 ro, vec3 rd)\n{\n    float td = 0.;\n    float angle = 1e10;\n    for(int i = 0; i < 6; i++)\n    {\n        float de = 1.2*scene(ro).x;\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.0, 0.35, angle);\n}\n\n//rendering samplers\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n)\n{\n    vec3 x; vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 ggxSample(vec3 wi, float alphax, float alphay, vec2 xi)\n{   \n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(xi.x);\n    float phi = (xi.y < a) ? xi.y / a*PI : PI + (xi.y - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((xi.y < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\nvec2 sampleDisk(vec2 xi)\n{\n\tfloat theta = TWO_PI * xi.x;\n\tfloat r = sqrt(xi.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3 cosineHemisphere(vec2 xi)\n{\n    vec2 disk = sampleDisk(xi);\n\treturn vec3(disk.x, disk.y, sqrt(max(0.0, 1.0 - dot(disk, disk))));\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n#define ANISO_STR 0.85\n#define ANISO_COMP 0.6\n\nfloat scatterAnisotropy(vec3 ri, vec3 ro)\n{\n    return mix(1.0, 4.*PI*HenyeyGreenstein(ANISO_STR, dot(ri, ro)), ANISO_COMP);\n}\n\nvec3 scatterSample(vec3 ri)\n{   \n    return normalize(nrand3(ANISO_STR, step(rand(),ANISO_COMP)*ri*(1. - ANISO_STR))); \n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nvec3 simple_shading(inout vec4 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    int hit = trace(ro, rd);\n    if(hit > 0)\n    {\n        material mat = getMaterial(ro); \n        \n        vec3 V = - rd;\n        vec3 N = mat.normal;\n        vec3 R = reflect(rd, N);\n        vec3 L = iLightDir;\n        vec3 H = normalize(V + L);\n        \n        vec3 kS = fresnel(V, N, mat.F0);\n        vec3 kD = 1.0 - kS;\n        \n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n        \n        #ifdef SHADOWS\n            float shadow = 0.;\n            if(NdotL > 0.0) shadow = shadowtrace(ro.xyz, iLightDir, MAX_DIST);\n        #else\n            float shadow = 0.0;\n        #endif\n        \n        float selfshadow = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, mat.roughness);  \n        \n        vec3 direct = shadow * (kD * mat.color / PI + specular) * DIRECT_BRIGHTNESS * NdotL;\n        \n        //AO\n        #ifdef AMBIENT_OCCLUSION\n            vec4 rnd = rand4blue();\n            float ambientshadow = ambitrace(ro.xyz + mat.normal*ro.w*0.001, \n                                            normalize(mat.normal + udir(rnd.xy)));\n        #else\n            float ambientshadow = 0.5 + 0.5*NdotL;\n        #endif\n        \n        \n        vec3 reflection = kS*texture(iChannel3, R).xyz;\n        vec3 ambient =AMBIENT*0.25*mat.color*(ambientshadow + reflection);\n        \n        col = ambient + direct;\n    }\n    else\n    {\n        col = AMBIENT*texture(iChannel3, rd).xyz;\n    }\n    return col;\n}\n\nvec3 pathtrace(inout vec4 ro0, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec3 absorption = vec3(1.);\n    vec4 scatter;\n    vec4 ro = ro0; \n    for(int i = 0; i < BOUNCES; i++)\n    {\n        float id = 0.;\n        vec4 ro1 = ro;\n        material mat = getMaterial(ro);\n        \n        int hit = trace(ro, rd);\n        \n        vec4 rofog = trace_fog(ro1, vec4(rd, ro.w), scatter);\n       \n        \n        if(mat.inside>0.0) absorption *= exp(-scatter.xyz+scatter.w);    \n  \n        if(ro.w > rofog.w && mat.inside>0.0) //scatter \n        {\n            ro = rofog;\n            vec3 shadow = vec3(0.0);\n            #ifdef DIRECT_LIGHT\n            shadow = shadowtrace(ro.xyz, iLightDir, MAX_DIST);\n            #endif\n            col += absorption*shadow*scatterAnisotropy(rd, iLightDir)/(2.*PI);\n            rd = scatterSample(rd);\n            if(i == 0) {ro0 = ro;}\n            continue;\n        }\n        if(i == 0) {ro0 = ro;}\n        if(hit > 0)\n        {\n            material mat = getMaterial(ro);\n            vec4 rnd = rand4();\n            \n            float F0avg = (mat.F0.x + mat.F0.y + mat.F0.z)/3.0; \n            float IOR = (1.0 + sqrt(F0avg))/(1.0 - sqrt(F0avg));\n            \n            vec3 V = - rd;\n            vec3 N = mat.normal*mat.inside;\n            vec3 R = reflect(rd, N);\n            vec3 L = (mat.inside==1.0)?iLightDir:(-refract(-iLightDir, N, 1./IOR));\n            vec3 H = normalize(V + L);\n            \n            vec3 kS = fresnel(V, N, mat.F0);\n            \n            //specular probability\n            float pS = (kS.x + kS.y + kS.z)/3.0;\n            \n            mat3 basis = mat3FromNormal(N);\n            mat3 inv = inverse(basis);\n            vec3 V_local = inv*V;\n           \n            vec3 incoming = mat.emission; \n            \n            #ifdef DIRECT_LIGHT\n                float NdotL = max(dot(N, L), 2e-5);\n                float NdotV = max(dot(N, V), 2e-5);\n                \n                float selfshadowL = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness);\n                \n                vec3 specular = vec3(1.0)*NDF_ggx(H, N, mat.roughness)/max(4.0*NdotL*NdotV,1e-5);  \n                vec3 refracted = mat.color*((mat.transparent)?((mat.inside == 1.0)?vec3(0.):(specular)):(vec3(1.0/ PI))) ;\n                specular = selfshadowL*((mat.inside == -1.0)?vec3(0.0):specular);\n                vec3 direct = ((1. - kS)*refracted + kS*specular) * NdotL;\n                \n                vec3 shadow = vec3(0.);\n                vec3 rf = (mat.inside == -1.0)?(10.0*(mat.cpoint - ro.xyz)):(vec3(0.));\n                if(length(direct) > 0.001) shadow = shadowtrace(ro.xyz + rf, iLightDir, MAX_DIST);\n\n                col += absorption * shadow * direct;\n            #endif\n            \n            \n            //sample microfacet normal\n            vec3 M = ggxSample(V_local, mat.roughness, mat.roughness, rnd.xy);\n            \n            rd = reflect(-V_local, M); //new reflected ray direction\n\n            float selfshadowR = G_ggx(rd.z,mat.roughness)*G_ggx(V_local.z,mat.roughness);\n            \n            if(rnd.z < pS*selfshadowR) //specular bounce\n            {\n                absorption *= kS/pS;\n            }\n            else //diffuse/refraction bounce\n            { \n                if(mat.transparent) //refraction\n                {\n                    vec3 newrd = refract(-V_local, M, pow(IOR,-mat.inside));\n                    if(length(newrd) > 0.5) //not total internal reflection\n                    {\n                        absorption *= mat.color;\n                        rd = newrd;\n                        //reflect point inside\n                        ro.xyz = ro.xyz + 10.0*(mat.cpoint - ro.xyz);\n                    }\n                }\n                else //diffuse\n                { \n                    absorption *= mat.color;\n                    rd = cosineHemisphere(rnd.xy);  \n                }  \n            }\n            \n            col += absorption*incoming;\n            \n            if((absorption.x + absorption.y + absorption.z) < 0.03) break; \n           \n            rd = basis*rd; //return ray direction into world space\n        }\n        else //miss\n        {\n            col += absorption*sky_color(rd);  \n            break;\n        }\n        \n    }\n    return col;\n}\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 r = rand4blue();\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif\n    \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec4 col = vec4(0.);\n    \n    float td_PREV = texelFetch(iChannel0, ivec2(p/MR_SCALE), 0).x;\n    \n    vec4 ro = vec4(0.); vec3 rd; \n    vec2 jitter = 1.4*(halton(iFrame%64) - 0.5); \n    getRay(p + jitter, ro.xyz, rd, APERTURE);\n    \n    //ro += vec4(rd, 1.0)*td_PREV;\n    \n    #ifdef PATH_TRACING\n        col += vec4(pathtrace(ro, rd), 1.0);\n    #else\n        col += vec4(simple_shading(ro, rd), 1.0);\n    #endif\n\n    c.xyz =min(col.xyz/col.w, 8.0);\n    c.w = distance(ro.xyz, campos);\n}", "buffer_c_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//TAA\n\nvec3 encodePalYuv(vec3 rgb)\n{\n    return vec3(\n        dot(rgb, vec3(0.299, 0.587, 0.114)),\n        dot(rgb, vec3(-0.14713, -0.28886, 0.436)),\n        dot(rgb, vec3(0.615, -0.51499, -0.10001))\n    );\n}\n\nvec3 decodePalYuv(vec3 yuv)\n{\n    return vec3(\n        dot(yuv, vec3(1., 0., 1.13983)),\n        dot(yuv, vec3(1., -0.39465, -0.58060)),\n        dot(yuv, vec3(1., 2.03211, 0.))\n    ); \n}\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    vec2 jitter = halton(iFrame%16) - 0.5; \n    vec4 bufB = texture(iChannel0, (p-jitter)/iResolution.xy);\n    \n    vec4 col = vec4(bufB.xyz, 1.);\n    \n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 ro = vec4(campos, bufB.w);    \n    vec3 rd = normalize(cam*vec3(1, FOV*uv));\n    ro.xyz += ro.w*rd;\n    vec4 X = ro;\n    material mat = getMaterial(X);\n    ro.xyz -= mat.velocity;\n    \n    vec3 reprj = reproject(pcam, pcampos, pResolution.xy, ro.xyz);\n    vec2 puv = reprj.xy/iResolution.xy;\n    vec2 dpuv = abs(puv - vec2(0.5));\n\n    vec3 prev_col = abs(texture_Bicubic(iChannel1, puv).xyz);\n    \n    #ifdef NEIGHBOR_CLAMP\n        //neighborhood clamping\n        vec3 minc = vec3(1e10); \n        vec3 maxc = vec3(0.);\n        for(int i = -NEIGHBOR_CLAMP_RADIUS; i < NEIGHBOR_CLAMP_RADIUS; i++)\n            for(int j = -NEIGHBOR_CLAMP_RADIUS; j < NEIGHBOR_CLAMP_RADIUS; j++)\n        {\n            vec3 pix = encodePalYuv(texelFetch(iChannel0, ivec2(p) + ivec2(i,j), 0).xyz);\n            minc = min(pix, minc);\n            maxc = max(pix, maxc);\n        }\n        vec3 preclamp = encodePalYuv(prev_col);\n        prev_col = clamp(preclamp, minc, maxc);\n        prev_col = mix(preclamp, prev_col, 0.9);\n        float delta = distance(prev_col, preclamp);\n        prev_col = decodePalYuv(prev_col);\n    #endif \n    \n    vec2 v = decode(texelFetch(iChannel1, ivec2(puv*iResolution.xy), 0).w);\n    \n    vec4 prev = vec4(prev_col, 1.0)*v.y/0.025;\n    float prev_td = 2.0/v.x;\n    \n    vec3 prev_pos = normalize(ro.xyz - pcampos)*prev_td + pcampos;\n    float ang_distance = distance(normalize(prev_pos - campos),normalize(ro.xyz - campos));\n    \n    if(iFrame < 2) prev*=0.0;\n    //prev*=mix(1.0, smoothstep(0.6, 0.5, delta), 0.1);\n    //prev*=mix(1.0, step(ang_distance, DISOCCLUSION_REJECTION), DISOCCLUSION_REJECTION_STR);\n    float dist = distance(prev.xyz/prev.w, col.xyz/col.w);\n    prev*=mix(1.0, smoothstep(CAMERA_MOVEMENT_REJECTION, 0., distance(campos, pcampos)),0.14);\n    if(KeyPressEvent(KEY_M)) prev*= 0.0;\n\n    //prev*=mix(1.0, smoothstep(0.7, 0.6, dist),1.0);\n    col += prev*REPROJECTION*step(dpuv.x, 0.5)*step(dpuv.y, 0.5); \n    \n    c.xyz = col.xyz/col.w;\n    c.w = encode(vec2(2.0/ro.w, 0.025*col.w));\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4708, 4708, 4729, 4729, 4777], [4779, 4779, 4824, 4824, 5289]], "test": "untested"}
{"id": "wtycWK", "name": "Flowing Paint", "author": "YitingLiu", "description": "flowing paint with a cellular noise function", "tags": ["fractal", "noise", "simple", "fbm", "perlin", "gradient", "template", "function", "value", "cellular"], "likes": 0, "viewed": 275, "published": 3, "date": "1611765936", "time_retrieved": "2024-07-30T19:42:12.354564", "image_code": "// noise functions from youtube https://www.youtube.com/watch?v=ybbJz6C9YYA\n// git code https://github.com/Gonkee/Gonkees-Shaders/blob/master/noise%20textures.shader\n\n// making paint flowing effect with cellular noise function \n\n#define PI 3.141592653\n\n\nvec2 rand2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin(dot(coord, vec2(12.9898,78.233)))*43758.5453);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat cellular_noise(vec2 coord){\n   vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float min_dist=9999.;\n   for(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n        vec2 node = rand2(i+vec2(x,y))+vec2(x,y);\n        float dist = sqrt((f-node).x*(f-node).x+(f-node).y*(f-node).y);\n        min_dist = min(min_dist,dist);\n       }\n    }\n    return min_dist;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 3.;\n\n    float noise;\n    noise = rand(st);\n    noise=cellular_noise(st);\n\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    // Assign a color using the closest point position\n   //  color += dot(f_st,vec2(-0.060,-0.460)*PI/2.*sin(iTime));\n\n    st-=st/2.;\n    st*=rotate2d(noise+PI/cos(iTime*0.005));\n    st*=scale(vec2(rand(st*0.000075)*(atan(fract(iTime/100.)))));\n    st+=st*2.;\n        \n    st*=1.-noise;\n\n   // Add distance field to closest point center\n    color.r =rand(noise*st*0.5)*iTime/100.;\n    color.g =1.-rand(noise*st*0.02)*(abs(cos(iTime/10.)));\n    color.b =0.4-rand(st*noise/sin(iTime));\n\n\n    fragColor = vec4(1.-color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 276, 276, 369], [371, 371, 394, 394, 495], [497, 497, 525, 525, 611], [612, 612, 636, 636, 699], [701, 701, 734, 734, 1101], [1102, 1102, 1160, 1160, 1973]], "test": "untested"}
{"id": "3tycWV", "name": "Day 407", "author": "jeyko", "description": "polino", "tags": ["lines", "geometric", "mdtmjvm"], "likes": 22, "viewed": 491, "published": 3, "date": "1611749413", "time_retrieved": "2024-07-30T19:42:13.190329", "image_code": "// Fork of \"Day 405\" by jeyko. https://shadertoy.com/view/ttVcRt\n// 2021-01-27 11:17:18\n\n\nconst float slices = 350.;\n\nconst float aaSteps = 1.; // not really steps, it's the exponentially ^3 area growing area around the fragCoord \n\nconst float disp = .7;\n\nconst float width = 0.0004;\n\n// asin(sin) is a triangle wave\n#define sin(x) asin(sin(x))\n\nfloat fun(float p, float py){\n    \n    //float f = sin(p + iTime + cos(py*0.05 + sin(p))*0.7)*sin(py*0.1 + iTime*0.2);\n    py *= 170.;\n    \n    py += iTime*2.;\n    float f = abs(sin(p*9. + sin(py*0.2 )*1.));\n    \n    f = pow(max(f,0.001),0.15);\n    \n    //f += (sin(py*0.1 + iTime + sin(p*6. + iTime)))*0.1;\n    f += (sin(py*0.1 + iTime + sin(p*8. + iTime*.1 + sin(py*2.)*0.1)))*0.1;\n    \n    \n    \n    //f = cos(p*0.4- iTime + py)*cos(p*0.4*sin(p) + iTime)*(sin(py + iTime));\n    //f = sin(p*0.5 + sin(py))*(cos(py*0.1 + iTime));\n    /*\n    f *= mix(\n        smoothstep(0.,1.,abs(p + sin(py)*0.1)),\n        smoothstep(0.,1.,abs(p + sin(py*0.3 + iTime)*0.1)),\n        0.5 + sin(iTime*0.4 )*0.5\n        );\n    */\n    return f*disp;\n}\n\n\n\nconst float eps = 0.0004; // eps for derivative of graphing function\n\nfloat graph(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize ,0., \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.))- width);\n}\nfloat graphNoAbs(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize,0., \n                    -(fn0-y)/length(vec2((fn1-fn0)/eps,1.)) - width);\n}\n\n\nvec3 get(in vec2 fragCoord){\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    \n    float pixelSize = dFdx(uv.x);\n    \n    for(float i = 0.; i < slices; i++ ){\n        vec2 p = uv + vec2(0.,i/slices*2. - 0.6);\n        \n        //float funIdx = p.x*4. + sin(p.y*i/slices*2. + iTime)*1.5*sin(p.x - iTime);\n        float funIdx = p.x;\n        float funIdxY = i/slices;\n        \n        col -= graphNoAbs( p.y, fun(funIdx,funIdxY), fun(funIdx+eps,funIdxY), pixelSize);\n        col = max(col,0.);\n        col = mix(col, vec3(1), graph( p.y, fun(funIdx,funIdxY), fun(funIdx+eps,funIdxY ), pixelSize ));\n        \n    }\n    \n    \n    col = 1. - col;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    for(float i =0.; i < aaSteps*aaSteps + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + vec2(mod(i,aaSteps),floor(i/aaSteps))/aaSteps);\n    }\n    col /= aaSteps*aaSteps;\n    \n    \n    col = max(col, 0.);\n\t//col = pow(col, vec3(0.4545));\n    \n    \n    col = pow(col,vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 375, 464, 1078], [1152, 1152, 1212, 1212, 1321], [1322, 1322, 1387, 1387, 1494], [1497, 1497, 1525, 1525, 2202], [2204, 2204, 2261, 2261, 2628]], "test": "untested"}
{"id": "wlKyDy", "name": "Simple Audio Visualizer Matrix", "author": "BigETI", "description": "This shader visualizes the currently played audio in channel index 0. Select any other audio file if you want to change the currently played music.", "tags": ["simple", "audio", "visualizer"], "likes": 1, "viewed": 545, "published": 3, "date": "1611723968", "time_retrieved": "2024-07-30T19:42:13.998170", "image_code": "// Anti aliasing level\nuint antiAliasing = 4U;\n\n// Minimal bar count\nconst float minimalBarCount = 16.0;\n\n// Maximal bar count\nconst float maximalBarCount = 64.0;\n\n// Bar spacing\nconst float barSpacing = 0.25;\n\n// Sample volume count\nconst uint sampleBassVolumeCount = 16U;\n\n// Low background color\nconst vec4 lowBackgroundColor = vec4(0.0, 0.0625, 0.125, 1.0);\n\n// High background color\nconst vec4 highBackgroundColor = vec4(0.03125, 0.03125, 0.03125, 1.0);\n\n// Low volume color\nconst vec4 lowVolumeColor = vec4(0.0, 0.0, 1.0, 1.0);\n\n// Middle volume color\nconst vec4 middleVolumeColor = vec4(0.0, 1.0, 0.0, 1.0);\n\n// High volume color\nconst vec4 highVolumeColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n// Samples scene\nvec4 SampleScene(const vec2 fragCoord)\n{\n    // Scene UV coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Samples bass volume sum\n    float bass_volume_sum = 0.0f;\n    for (uint x = 0U; x != sampleBassVolumeCount; x++)\n    {\n        bass_volume_sum += texture(iChannel0, vec2(float(x) / float(sampleBassVolumeCount * 4U), 0.0)).x;\n    }\n    \n    // Number of columns\n    float columns = round(mix(maximalBarCount, minimalBarCount, bass_volume_sum / float(sampleBassVolumeCount)));\n    \n    // Number of rows\n    float rows = (columns * iResolution.y) / iResolution.x;\n    \n    // Current volume of sample\n    float volume = ((fract(uv.x * float(columns) + (barSpacing * 0.5)) > barSpacing) && (fract(uv.y * float(rows) + (barSpacing * 0.5)) > barSpacing)) ? texture(iChannel0, vec2(floor(uv.x * columns) / columns, 0.0)).x : 0.0;\n    \n    // Renders visualization\n    return (uv.y > volume) ? mix(lowBackgroundColor, highBackgroundColor, uv.y) : ((volume > 0.5) ? mix(middleVolumeColor, highVolumeColor, (volume - 0.5) * 2.0) : mix(lowVolumeColor, middleVolumeColor, volume * 2.0));\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Samples subpixels of scene\n    vec4 color_sum = vec4(0.0);\n    for (uint x = 0U, y; x != antiAliasing; x++)\n    {\n        for (y = 0U; y != antiAliasing; y++)\n        {\n            color_sum += SampleScene(fragCoord + vec2(((float(x) + 0.5) / float(antiAliasing)) - 0.5, ((float(y) + 0.5) / float(antiAliasing)) - 0.5));\n        }\n    }\n    fragColor = color_sum / float(antiAliasing * antiAliasing);\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 710, 750, 778, 1811]], "test": "untested"}
{"id": "ttVcWy", "name": "BigETI's Avatar", "author": "BigETI", "description": "This shader represents BigETI's avatar.\n\nUncomment `ENABLE_SNAPSHOT_MODE` to take a snapshot of my avatar.", "tags": ["z", "tetris", "bigeti", "eti", "tetrimino"], "likes": 4, "viewed": 277, "published": 3, "date": "1611718347", "time_retrieved": "2024-07-30T19:42:14.788057", "image_code": "#define ENABLE_BACKGROUND\n#define ENABLE_TETRIMINO_GLOW\n//#define DISABLE_COLORS\n//#define ENABLE_SNAPSHOT_MODE\n\n// Anti aliasing level\n#ifdef ENABLE_SNAPSHOT_MODE\nconst uint antiAliasing = 4U;\n#else\nconst uint antiAliasing = 1U;\n#endif\n\n#ifdef ENABLE_BACKGROUND\n\n// Background circle color\nconst vec4 backgroundColor = vec4(0.0, 0.0, 1.0, 1.0);\n\n#endif\n\n#ifdef ENABLE_TETRIMINO_GLOW\n\n// Glow effect size in pixels\nconst uint glowSize = 48U;\n\n// Glow effect iteration step size (more equals faster, but less quality)\n    #ifdef ENABLE_SNAPSHOT_MODE\nconst uint glowIterationStepSize = 1U;\n    #else\nconst uint glowIterationStepSize = 4U;\n    #endif\n#endif\n\n// Color multiplier\n#ifdef DISABLE_COLORS\nconst vec3 colorMultiplier = vec3(0.25, 1.0, 2.0);\n#else\nconst vec3 colorMultiplier = vec3(1.0, 1.0, 1.0);\n#endif\n\n// Music beats per minute\nconst float beatsPerMinute = 114.0;\n\n// Pi\nconst float pi = 3.1415926535897932384626433832795028841971693993751058209749445923;\n\n// Half of pi\nconst float halfPi = 1.5707963267948966192313216916397514420985846996875529104874722961;\n\n// Alpha factor for beats\nconst float beatsAlphaFactor = pi * beatsPerMinute / 60.0;\n\n// Alpha blends colors\nvec4 AlphaBlendColors(const vec4 baseColor, const vec4 appendColor)\n{\n    vec3 color = mix(baseColor.rgb, appendColor.rgb, appendColor.a);\n    return vec4(color.x, color.y, color.z, baseColor.a + ((1.0 - baseColor.a) * appendColor.a));\n}\n\n// Rotates given UV coordinates\nvec2 Rotate(const vec2 uv, const float alpha)\n{\n\tfloat sine_result = sin(alpha);\n\tfloat cosine_result = cos(alpha);\n\treturn mat2(cosine_result, -sine_result, sine_result, cosine_result) * uv;\n}\n\n// Gets scene UV coordinates\nvec2 GetSceneUV(const vec2 fragCoord)\n{\n    return (fragCoord - (iResolution.xy * 0.5)) / iResolution.y * 2.0;\n}\n\n// Gets tetrimino UV coordinates\nvec2 GetTetriminoUV(vec2 uv)\n{\n#ifdef ENABLE_SNAPSHOT_MODE\n    return uv * 0.5 + vec2(0.5, 0.5);\n#else\n    float cosine_of_beats_alpha_factor = cos(iTime * beatsAlphaFactor);\n    float cosine_of_beats_alpha_factor_cubed = cosine_of_beats_alpha_factor * cosine_of_beats_alpha_factor * cosine_of_beats_alpha_factor;\n    return Rotate(uv * 0.5, cosine_of_beats_alpha_factor_cubed * halfPi * 0.125) * (1.0 - (cosine_of_beats_alpha_factor_cubed * cosine_of_beats_alpha_factor_cubed * 0.125)) + vec2(0.5, 0.5);\n#endif\n}\n\nfloat GetBrightness(const vec3 color)\n{\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n// Samples scene\nvec4 SampleScene(const vec2 fragmentCoordinates)\n{\n    vec2 uv = GetSceneUV(fragmentCoordinates);\n    \n    // Background circle\n#ifdef ENABLE_BACKGROUND\n    vec4 color = AlphaBlendColors(vec4(0.0, 0.0f, 0.0, 1.0), backgroundColor * vec4(1.0, 1.0, 1.0, clamp(1.0 - distance(vec2(0.0, 0.0), uv), 0.0, 1.0)));\n#else\n    vec4 color = vec4(0.0);\n#endif\n\n    // Tetrimino\n    vec4 tetrimino_color = texture(iChannel0, GetTetriminoUV(uv));\n\n    // Tetrimino glow effect\n#ifdef ENABLE_TETRIMINO_GLOW\n    if (tetrimino_color.a < 1.0)\n    {\n        float tetrimino_alpha_sum = 0.0;\n        for (int x = -int(glowSize), y; x <= int(glowSize); x += int(glowIterationStepSize))\n        {\n            for (y = -int(glowSize); y <= int(glowSize); y += int(glowIterationStepSize))\n            {\n                float fragment_distance_squared = float(x * x) + float(y * y);\n                if (fragment_distance_squared < float(glowSize * glowSize))\n                {\n                    tetrimino_alpha_sum += texture(iChannel0, GetTetriminoUV(GetSceneUV(fragmentCoordinates + vec2(x, y)))).a;\n                }\n            }\n        }\n        color = AlphaBlendColors(color, vec4(1.0, 1.0, 1.0, tetrimino_alpha_sum / float((4U * glowSize * glowSize) + 1U)) * float(glowIterationStepSize));\n    }\n#endif\n#ifdef DISABLE_COLORS\n    color = AlphaBlendColors(color, tetrimino_color);\n    float brightness = GetBrightness(color.rgb);\n    return vec4(brightness * colorMultiplier.r, brightness * colorMultiplier.g, brightness * colorMultiplier.b, color.a);\n#else\n    color = AlphaBlendColors(color, tetrimino_color);\n    color.r *= colorMultiplier.r;\n    color.g *= colorMultiplier.g;\n    color.b *= colorMultiplier.b;\n    return color;\n#endif\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    vec4 color_sum = vec4(0.0);\n    for (uint x = 0U, y; x != antiAliasing; x++)\n    {\n        for (y = 0U; y != antiAliasing; y++)\n        {\n            color_sum += SampleScene(fragmentCoordinates + vec2(((float(x) + 0.5) / float(antiAliasing)) - 0.5, ((float(y) + 0.5) / float(antiAliasing)) - 0.5));\n        }\n    }\n    fragmentColor = color_sum / float(antiAliasing * antiAliasing);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Tetrimino width\nconst uint tetriminoWidth = 19U;\n\n// Tetrimino height\nconst uint tetriminoHeight = 19U;\n\n// Color palette of tetrimino\nconst vec4 tetriminoColorPalette[] = vec4[]\n(\n    // Background\n    vec4(0.0, 0.0, 0.0, 0.0),\n    \n    // Primary (red)\n    vec4(1.0, 0.0, 0.0, 1.0),\n    \n    // Light (light red)\n    vec4(1.0, 141.0 / 255.0, 141.0 / 255.0, 1.0),\n    \n    // Shadow (dark red)\n    vec4(122.0 / 255.0, 0.0, 0.0, 1.0)\n);\n\n// Bitmap of tetrimino\nconst uint tetriminoBitmap[tetriminoWidth * tetriminoHeight] = uint[]\n(\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 2U, 2U, 2U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 2U, 3U, 3U, 3U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 2U, 2U, 2U, 3U, 2U, 2U, 2U, 2U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 3U, 3U, 3U, 3U, 2U, 3U, 3U, 3U, 3U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 2U, 2U, 2U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 1U, 1U, 1U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 2U, 3U, 3U, 3U, 3U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n    0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U\n);\n\n// Samples tetrimino\nvec4 SampleTetrimino(vec2 uv)\n{\n    //vec2 tetrimino_uv = vec2((uv.x + 1.0) * 0.5, (1.0 - uv.y) * 0.5);\n    vec2 tetrimino_uv = vec2(uv.x, 1.0 - uv.y);\n    int x = int(round(tetrimino_uv.x * float(tetriminoWidth)));\n    int y = int(floor(tetrimino_uv.y * float(tetriminoHeight)));\n    return ((x >= 0) && (x < int(tetriminoWidth)) && (y >= 0) && (y < int(tetriminoHeight))) ? tetriminoColorPalette[tetriminoBitmap[x + (y * int(tetriminoWidth))]] : vec4(0.0);\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    fragmentColor = SampleTetrimino(fragmentCoordinates / iResolution.xy);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1158, 1181, 1250, 1250, 1418], [1420, 1452, 1499, 1499, 1645], [1647, 1676, 1715, 1715, 1788], [1790, 1823, 1853, 1853, 2336], [2338, 2338, 2377, 2377, 2429], [2431, 2448, 2498, 2498, 4172]], "test": "untested"}
{"id": "wlKyWG", "name": "Skyscrapers, 2D Perspective", "author": "mherreshoff", "description": "Abstract Skyscrapers in two point perspective.", "tags": ["skyscrapers", "twopoint", "perspectie"], "likes": 4, "viewed": 280, "published": 3, "date": "1611712187", "time_retrieved": "2024-07-30T19:42:15.536057", "image_code": "#define PI 3.14159\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\n\n// See: https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q= abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct result {\n    float dist;\n    vec3 color;\n};\n\n#define STREET_SZ 2.\nresult map(vec3 v, vec3 dv) {\n    vec2 cell = floor(v.xy);\n    result r;\n    r.dist = 1e38;\n    for (int dy = -1; dy <= 1; dy++) {\n        for (int dx = -1; dx <= 1; dx++) {\n            vec2 cell2 = cell + vec2(float(dx), float(dy));\n            vec3 rand = hash33(vec3(cell2, 0));\n            float height = 2.+floor(4.*rand.x);\n            if (rand.y > .99) height += 5.;\n            \n            if (mod(cell2.x, 10.) < STREET_SZ || mod(cell2.y, 10.) < STREET_SZ) height = 0.;\n            \n            float dist = sdBox(v-vec3(cell2.x+.5, cell2.y+.5, 0), vec3(.3,.3,height));\n            if (dist < r.dist) {\n                r.dist = dist;\n                r.color = vec3(.25+.75*rand.z);\n            }\n        }\n    }\n    r.dist = min(r.dist, 1.);\n\n    float mx = mod(v.x, 10.), my = mod(v.y, 10.);\n    if (mx < STREET_SZ) { // If we're in an alley, we know we can skip ahead.\n        if (dv.x < 0.) r.dist = max(r.dist, -mx/dv.x);\n        if (dv.x > 0.) r.dist = max(r.dist, (STREET_SZ-mx)/dv.x);\n    }\n\n    if (my < STREET_SZ) { // If we're in an alley, we know we can skip ahead.\n        if (dv.y < 0.) r.dist = max(r.dist, -my/dv.y);\n        if (dv.y > 0.) r.dist = max(r.dist, (STREET_SZ-my)/dv.y);\n    }\n    return r;\n}\n\nvec4 rayMarch(vec3 v, vec3 dv, vec4 sky) {\n    float totalDist = 0.;\n    for (int i = 0; i < 800; i++) {\n        result r = map(v, dv);\n        if (r.dist <= .01) return vec4(r.color, 0);\n        v += r.dist*dv;\n        totalDist += r.dist;\n        if (v.z < 0.1) return vec4(0,0,0,1);\n        //if (totalDist >= 100.) break;\n        \n    }\n    if (dv.z < 0. && -v.z/dv.z < 10.) return vec4(0,0,0,1);\n    \n    return sky;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, uv = (U - 0.5*R)/R.y;\n    float t = iTime*.1, m = mod(t, 2.);\n    float cx = 10.*(t - m + 2. * clamp(m, 0., 1.));\n    float cy = 10.*(t - m + 2. * clamp(m-1., 0., 1.));\n    vec3 camera = vec3(cx, cy, 3.);\n    float theta = PI/4. + uv.x*(PI/3.);\n    vec3 dv = normalize(vec3(cos(theta), sin(theta), uv.y));\n    vec4 sky = vec4(0., .8, 1., 1.);\n    O = rayMarch(camera, dv, sky);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 191, 220, 220, 310], [385, 385, 414, 414, 1614], [1616, 1616, 1658, 1658, 2039], [2041, 2041, 2082, 2082, 2491]], "test": "untested"}
{"id": "wlyczt", "name": "Suzanne Neural Light Field", "author": "blackle", "description": "a neural light field for a metallic monkey head", "tags": ["neuralnetwork"], "likes": 30, "viewed": 765, "published": 3, "date": "1611699757", "time_retrieved": "2024-07-30T19:42:16.467567", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//a neural network that represents a light field.\n//the network takes in the x and y coordinates of a plane, and the x,y,z coordinates of a view direction at that point\n//it then returns the colour of the scene given that direction\n//this can be used to construct a \"portal\" you can see the scene through.\n//the scene itself was rendered with blender and then trained into the neural network with a modified siren network\n//see: https://vsitzmann.github.io/siren/\n//the main modification was adding skip connections so the network can be deep instead of wide\n\n//this version has a metallic monkey head, which shows off the ability for the network to reproduce specularity\n//the code in the common tab compresses to about 8 kilobytes... so maybe something like it could be used in a 64k demo...\n\nvec3 plane_intersect(vec3 p, vec3 d, vec3 q, vec3 n) {\n    return p + d*dot(q-p, n)/dot(d, n);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p, ax)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 cam = normalize(vec3(uv, 1));\n    vec3 init = vec3(0,0,-cos(iTime/3.)*2.-3.);\n    init.x += cos(iTime/2.)*.5;\n    \n    float yrot = cos(iTime)*.5;\n    float xrot = sin(iTime/5.)*.5;\n    \n    if (iMouse.z > 0.) {\n        xrot = -3.*mouse.y;\n        yrot = 3.*mouse.x;\n    }\n    \n    cam = erot(cam, vec3(1,0,0), xrot);\n    init = erot(init, vec3(1,0,0), xrot);\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    \n    vec3 sect = plane_intersect(init, cam, vec3(0), vec3(0,0,-1));\n    float border = max(abs(sect.x),abs(sect.y));\n    if (border > 1. && init.z < 0.) {\n        fragColor = vec4(smoothstep(-.5,.5,sin(exp(-border)*200.))*.05+.1);\n        return;\n    }\n    vec3 f = vec3(lightfield(sect.xy, cam));\n\n\n    // Output to screen\n    fragColor = vec4(f, 1.);\n}", "image_inputs": [], "common_code": "float lightfield(vec2 uv, vec3 dir) {\n    float ft_0 = uv.x, ft_1 = -uv.y, ft_2 = -dir.y, ft_3 = dir.x, ft_4 = dir.z;\n//16x16 model, loss ~= .005\nvec4 f0_0=sin(ft_0*vec4(-.55,-1.20,.05,-.09)+ft_1*vec4(.92,.04,.75,.37)+ft_2*vec4(-.36,-.25,-.32,.44)+ft_3*vec4(-.07,-.03,-.40,.18)+ft_4*vec4(-.27,-.51,.71,.33)+vec4(.91,.64,-.60,.57));\nvec4 f0_1=sin(ft_0*vec4(-.12,-.47,.65,.80)+ft_1*vec4(-1.25,-.54,-.77,.48)+ft_2*vec4(-1.73,-.91,.50,-.55)+ft_3*vec4(.06,-1.21,.21,-.17)+ft_4*vec4(-.37,.46,-.99,-1.21)+vec4(.03,-.11,1.09,-1.36));\nvec4 f0_2=sin(ft_0*vec4(-.98,-1.18,-.32,-.67)+ft_1*vec4(-.69,.14,.67,-.42)+ft_2*vec4(.22,.06,.98,-.65)+ft_3*vec4(.36,-.85,-.59,-.84)+ft_4*vec4(-1.09,.96,-1.54,-1.69)+vec4(1.09,-.32,.06,-2.58));\nvec4 f0_3=sin(ft_0*vec4(.15,.20,-.82,-.55)+ft_1*vec4(.36,.12,.34,.43)+ft_2*vec4(.44,-.12,.37,.35)+ft_3*vec4(.04,.17,-1.23,-.31)+ft_4*vec4(-.43,-.19,.01,-.53)+vec4(.79,.04,-.67,.01));\nvec4 f1_0=sin(mat4(-.36,.52,.16,.12,.48,.70,.29,-.10,-.09,.31,.07,.24,-.22,.04,-.25,.03)*f0_0+\n    mat4(.25,-.58,.12,.17,-.49,-.17,-.80,.42,-.30,-.80,-.68,.36,.18,.41,-.13,-.02)*f0_1+\n    mat4(.29,.05,.11,-.16,-.03,.68,-.19,.68,.33,.95,.24,-.68,-.21,-.03,-.09,-.11)*f0_2+\n    mat4(-.12,-.17,-.30,.13,-.03,-.05,-.06,.40,-.19,.65,-.27,-.44,.12,.17,.45,.16)*f0_3+\n    vec4(-.04,-.15,-.35,.60))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.02,-.08,.11,.68,.36,.29,.24,-.64,-.19,-.53,.53,-.52,.47,.01,-.22,.38)*f0_0+\n    mat4(-.39,.72,-.97,-.55,-.06,.97,-.80,-.15,.21,.41,-.80,.17,-.55,.51,-.20,-.67)*f0_1+\n    mat4(.19,.82,-.29,-.18,-.07,.11,-.01,.04,-.11,-.08,.73,-.23,-.03,-.45,.44,-.13)*f0_2+\n    mat4(.67,.08,-.35,.44,-.44,.09,-.29,-.28,-.70,.25,.40,.13,-.31,-.25,.37,.05)*f0_3+\n    vec4(1.00,.33,-.58,.23))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.07,.11,.45,-.06,.35,.37,.09,.09,.08,-.01,.19,.22,-.21,-.26,.13,-.11)*f0_0+\n    mat4(-.06,-.18,-.61,-.40,.57,-.28,.02,-.17,-.10,-.12,-.24,.21,.52,.44,-.20,-.05)*f0_1+\n    mat4(.70,.17,-.22,.22,.66,.31,.09,.52,.36,-.28,.68,-1.35,-.23,.34,-.38,.76)*f0_2+\n    mat4(-.08,-.38,.33,.04,-.02,-.06,-.37,-.30,.40,.09,.39,-.05,.15,-.04,-.15,-.09)*f0_3+\n    vec4(-.01,-.57,.15,.39))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.30,.37,.25,.00,.16,-.04,-.19,.18,-.59,.42,-.17,.39,.28,.49,-.03,-.43)*f0_0+\n    mat4(.65,-.59,-.46,.38,.03,-.78,.93,.21,.24,-.50,.23,.33,.23,-.84,-.27,.16)*f0_1+\n    mat4(.16,-.69,.19,-.09,.26,.09,.40,-.42,-.51,-.18,-.07,.05,.06,.57,.41,-.29)*f0_2+\n    mat4(.18,.42,.01,-.36,-.53,.27,-.38,.50,-.06,-.23,.10,.07,.00,-.11,-.77,.50)*f0_3+\n    vec4(.41,.33,.17,-.66))/1.0+f0_3;\nvec4 f2_0=sin(mat4(.15,.43,-.90,-.14,.23,-.67,.10,-.06,.13,-.03,.32,.22,-.05,-.31,-.18,-.26)*f1_0+\n    mat4(-.46,.06,-.12,.25,-.55,-.17,.06,.19,-.41,.37,.02,-.14,-.91,-.11,-.33,.30)*f1_1+\n    mat4(-.81,.30,-.87,-.30,-.03,-.00,-.55,-.04,-.03,.65,-.57,.09,-.01,-.44,.45,-.19)*f1_2+\n    mat4(-.18,-.46,-.15,.05,.41,-.13,.11,.33,-.05,-.06,-.21,.53,.08,-.08,.31,-.19)*f1_3+\n    vec4(-.08,.04,-.35,-.36))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.01,.06,-.51,.08,.05,.54,-.34,-.29,.17,.31,-.03,-.02,-.29,-.13,.07,-.23)*f1_0+\n    mat4(.07,.46,.41,-.41,.04,-.57,-.27,-.11,-.37,-.13,.62,.20,-.23,-.02,-.10,.03)*f1_1+\n    mat4(-.38,-.03,.46,-.36,-.22,-.23,-.01,-.35,.21,.40,-.32,.05,-.30,-.30,.16,.34)*f1_2+\n    mat4(-.34,-.37,.17,.09,.43,.34,-.20,-.33,-.46,-.45,-1.02,-.27,.37,.27,-.06,-.01)*f1_3+\n    vec4(-.16,-.11,.14,.03))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.19,.32,-.06,.39,-.35,.42,.52,-.54,.40,.50,-.41,-.10,-.62,-.83,-.35,.30)*f1_0+\n    mat4(.07,.02,-.35,-.07,-.16,-.13,-.31,.08,.32,-.23,-.30,.05,-.11,.01,.11,.27)*f1_1+\n    mat4(-.25,-.16,-.35,.09,-.17,.60,-.11,-.06,.67,.71,.67,-.18,-.83,-.54,-.77,.84)*f1_2+\n    mat4(.07,-.74,-.15,.07,.11,.02,-.72,.07,-.34,.84,-.21,-.61,.29,.57,-.39,-.01)*f1_3+\n    vec4(-.23,-.47,-.05,.17))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.29,.66,.68,-.76,-.38,-.18,-.45,.67,.34,-.06,-.20,.24,-.62,.08,.46,-.38)*f1_0+\n    mat4(-.47,.70,.10,.28,.15,.04,-.02,.02,.43,-.09,-.22,-.24,.10,-.02,-.07,.47)*f1_1+\n    mat4(.25,.47,.47,-.17,.31,-.70,-.13,.49,-.56,.01,-.25,-.04,.21,-.68,.03,.52)*f1_2+\n    mat4(-.79,.10,.45,-.42,-.32,.26,.46,.25,-.34,-.86,-.28,.57,.64,.10,-.41,.38)*f1_3+\n    vec4(-.73,.12,.50,-.41))/1.4+f1_3;\nvec4 f3_0=sin(mat4(-.36,.23,-.01,-.71,-1.10,.31,.39,-.11,.10,-.34,.01,.02,.08,.07,-.38,.06)*f2_0+\n    mat4(-.65,-.41,.58,-.07,.55,-.62,.22,.35,.19,-.59,.28,.15,.07,-.42,.19,.09)*f2_1+\n    mat4(-.42,.27,.61,-.29,-.11,.45,-.23,-.09,-.34,.56,.00,-.70,.24,-.44,-.52,.64)*f2_2+\n    mat4(.42,-.19,-.66,-.38,.17,.40,-.39,-.24,-.44,.75,-.36,-.13,-.27,-.06,.34,-.29)*f2_3+\n    vec4(.56,.04,-.10,-.09))/1.7+f2_0;\nvec4 f3_1=sin(mat4(-.19,-.16,.29,-.25,-.35,-.88,-.36,.17,-.36,.12,.08,-.08,-.08,-.00,.34,-.38)*f2_0+\n    mat4(.40,-.35,-.07,.04,-.06,.65,-.11,.01,-.05,.17,-.27,.20,-.31,.42,-.42,.86)*f2_1+\n    mat4(.50,.17,.02,.83,-.45,.19,.08,.17,-.65,.01,-.55,.27,-.53,-.44,.78,-1.16)*f2_2+\n    mat4(-.32,-.05,-.33,.34,.10,-.07,.81,-.30,-.68,-.16,.84,-.17,.12,-.08,-.62,-.19)*f2_3+\n    vec4(-.28,-.01,-.09,-.19))/1.7+f2_1;\nvec4 f3_2=sin(mat4(-.30,-.17,.08,.22,-.17,-.06,.43,.48,-.73,-.07,.65,-.13,.22,.31,-.35,-.09)*f2_0+\n    mat4(.35,-.14,-.01,.20,.38,.05,-.55,-.19,-.33,-.03,-.38,-.23,-.16,-.27,-.12,-.33)*f2_1+\n    mat4(.72,.56,-.09,.46,.04,.59,-.09,.41,-.20,-.13,.43,.38,-.50,-.35,-.51,-.50)*f2_2+\n    mat4(-.12,.01,-.24,.01,-.07,.57,.10,.24,.02,.59,-.36,-.35,-.07,-.32,.78,.38)*f2_3+\n    vec4(-.18,.09,-.44,-.10))/1.7+f2_2;\nvec4 f3_3=sin(mat4(.70,-.25,.21,-.81,-.04,.11,-.42,-.06,.08,-.38,-.47,-.11,-.18,.71,.19,-.34)*f2_0+\n    mat4(.02,.54,-.11,.35,.33,.75,.19,.34,.44,.51,-.12,.65,.40,-.05,.40,-.01)*f2_1+\n    mat4(.25,.19,-.34,.23,-.31,-.45,.24,-.42,-.66,-.58,-.34,.30,.15,-.30,.47,-.30)*f2_2+\n    mat4(.20,-.21,.34,-.36,-.78,-.24,.04,-.58,-.22,.42,.16,.07,-.23,-.27,-.62,.13)*f2_3+\n    vec4(.13,-.05,.36,-.12))/1.7+f2_3;\nvec4 f4_0=sin(mat4(.11,-.54,.35,.44,.16,-.15,.23,-.39,.33,.33,-.30,-.03,-.18,-.32,.09,-.01)*f3_0+\n    mat4(-.52,-.36,.55,.32,-.18,.09,-.44,.10,-.19,.01,-.18,.10,.55,-.33,.54,-.33)*f3_1+\n    mat4(-.76,-.32,.54,-.57,-.79,-.69,.62,.57,.26,-.13,.26,-.47,.84,.23,-.54,.00)*f3_2+\n    mat4(.06,-.25,-.14,-.05,-.08,.32,.12,.09,-.50,.40,.97,-.08,.02,.23,.33,.01)*f3_3+\n    vec4(-.49,-.19,-.26,-.09))/2.0+f3_0;\nvec4 f4_1=sin(mat4(-.08,-.07,-.01,-.51,.05,-.28,-.15,-.23,-.28,.23,.02,.58,.07,.05,.09,-.24)*f3_0+\n    mat4(.95,.56,.01,.12,.15,.43,.12,-.33,-.05,.97,.64,-.48,-.38,-.60,.08,.11)*f3_1+\n    mat4(.02,.08,.36,-.43,.03,.00,-.20,-.37,-.36,-.76,-.10,-.04,-.16,-.38,-.44,.25)*f3_2+\n    mat4(-.45,.11,.64,-.23,-.31,.20,-.67,-.20,.39,-.07,-.23,-.76,-.15,-.06,-.34,.32)*f3_3+\n    vec4(-.32,.00,.33,-.12))/2.0+f3_1;\nvec4 f4_2=sin(mat4(.21,.49,.81,.23,-.10,-.06,-.60,-.45,.34,-.06,-.45,-.53,-.32,.19,.08,.34)*f3_0+\n    mat4(-.30,.45,.41,-.16,.04,-.02,-.30,.47,-.54,.54,.54,-.22,-.13,-.19,-.17,.18)*f3_1+\n    mat4(.21,-.26,-.39,.44,-.04,-.34,.09,.57,.55,-.98,.06,.18,-.24,.54,.12,-.54)*f3_2+\n    mat4(-.26,.08,.53,-.03,.33,-.30,.08,.71,.67,.18,-.40,.17,.08,-.11,.00,-.60)*f3_3+\n    vec4(-.05,.25,.29,.40))/2.0+f3_2;\nvec4 f4_3=sin(mat4(.06,-.01,.07,-.02,-.48,.33,.65,.38,-.40,-.02,-.05,.15,.82,.16,.32,-.20)*f3_0+\n    mat4(.23,.08,.10,.10,.06,.06,.30,-.25,-.09,-.36,-.11,.40,-.02,-.35,.27,.28)*f3_1+\n    mat4(.05,.95,.35,.03,.31,.03,.22,-.70,-.56,.54,-.03,.26,.23,-.69,-.01,-.18)*f3_2+\n    mat4(.23,.09,-.36,.06,.29,-.01,-.42,-.06,-.40,.19,-.15,.15,-.21,.01,-.07,.07)*f3_3+\n    vec4(.41,-.21,.05,-.09))/2.0+f3_3;\nvec4 f5_0=sin(mat4(1.11,-.61,.22,.34,-.33,-.13,.67,.73,.29,-.56,.00,.10,-.15,-.20,-.70,.13)*f4_0+\n    mat4(-.47,.19,-.06,.05,.33,-.21,-.61,-.58,-.09,.06,-.80,-.86,-.51,.12,-.47,-.45)*f4_1+\n    mat4(-.70,.08,-.31,-.05,.32,.33,.03,-.15,.14,-.40,.72,.35,-.27,.17,-.55,.06)*f4_2+\n    mat4(.20,.20,-.03,.03,.19,.79,.28,-.47,-.08,1.10,-.23,-.89,.05,.23,.07,.20)*f4_3+\n    vec4(.23,-.13,-.09,-.34))/2.2+f4_0;\nvec4 f5_1=sin(mat4(-.10,-.42,.15,1.20,-.66,.38,-.25,-.02,-.13,.24,-.37,-.27,.04,.28,.10,-.32)*f4_0+\n    mat4(.20,.18,.51,.38,.54,.21,-.79,.77,-.16,.14,-.11,-.03,.20,-.35,.40,.16)*f4_1+\n    mat4(.63,.64,.46,-.13,.80,.13,.69,.13,.26,-.29,.25,.09,-.53,.21,-.62,.21)*f4_2+\n    mat4(.09,.08,.55,.17,.09,-.72,-.68,.14,.02,-.03,.30,-.23,.17,-.20,-.38,.51)*f4_3+\n    vec4(-.32,.18,.30,-.94))/2.2+f4_1;\nvec4 f5_2=sin(mat4(.26,-.12,-.35,-.22,-.79,-.83,.27,.52,-.28,-.41,-.27,-.06,.18,.19,.24,.17)*f4_0+\n    mat4(.15,-.03,.30,.55,.31,-.27,.20,-.03,-.05,-.52,.09,.21,-.37,-.55,.20,-.06)*f4_1+\n    mat4(-.91,-.14,-.29,.11,.07,.05,-.24,-.45,-.36,-.01,-.06,-.73,.49,.44,.63,.02)*f4_2+\n    mat4(-.08,-.01,.24,-.23,-.01,.03,-.38,.27,.48,-.27,-.20,.02,-.66,.09,-.14,-.28)*f4_3+\n    vec4(-.02,-.17,.30,.31))/2.2+f4_2;\nvec4 f5_3=sin(mat4(.12,-.50,.09,-.11,.46,.14,-.01,.09,.20,-.19,.32,.23,.17,-.02,-.33,.40)*f4_0+\n    mat4(.18,-.17,.48,.91,.29,.45,-.01,.04,-.25,.08,-.40,.37,.18,-.74,-.15,-.31)*f4_1+\n    mat4(.27,-.11,-.26,1.06,-.16,-.15,.72,-.29,.32,-.39,-.12,-.60,.30,.64,.23,-.10)*f4_2+\n    mat4(-.39,-.31,-.56,-.39,-.15,-.51,-.51,-.12,.02,-.03,-.38,.17,.04,-.41,-.13,-.37)*f4_3+\n    vec4(.55,-.40,-.04,.41))/2.2+f4_3;\nvec4 f6_0=sin(mat4(.91,.19,.22,.24,-.06,.13,-.64,.02,.41,.26,-.54,-.05,.43,-.28,.50,.38)*f5_0+\n    mat4(-.50,.31,-.26,.03,.49,.20,.69,.13,-.54,.14,.35,.14,.93,.29,.06,.38)*f5_1+\n    mat4(.18,.11,-.36,-.22,-.47,-.34,-.13,-.49,-.30,.70,-.05,-.48,.14,-.28,-.29,.66)*f5_2+\n    mat4(-.13,-.46,.02,-.14,.23,.19,-.21,-.20,-.28,-.42,.43,-.82,-.01,-.04,-.95,-.51)*f5_3+\n    vec4(-.43,-.08,.95,.38))/2.4+f5_0;\nvec4 f6_1=sin(mat4(-.48,.46,.22,.61,.65,.47,.02,-.03,.05,.23,-.03,-.08,.12,-.34,-.18,-.22)*f5_0+\n    mat4(-.74,.02,.21,.04,-.28,-1.07,-.08,.44,.29,-.46,.51,.45,-1.18,.26,-.15,-.71)*f5_1+\n    mat4(-.14,.16,.26,.48,-.55,-.10,-.88,-.01,-.86,.33,.03,-.67,.14,-.06,-.41,-.11)*f5_2+\n    mat4(.55,-.21,-.02,-.10,.01,-.20,-.22,-.46,-.12,.50,-.23,-.39,-.04,.58,.23,.41)*f5_3+\n    vec4(-.31,.05,.22,-.39))/2.4+f5_1;\nvec4 f6_2=sin(mat4(-.43,.66,-.67,.27,.83,-.03,.70,-.09,-.53,-.08,.17,.06,.06,-.02,-.23,.03)*f5_0+\n    mat4(-.36,.04,-.02,.08,.00,.28,-.02,-.13,-.04,-.33,.31,-.31,-.52,-.18,.27,-.10)*f5_1+\n    mat4(.24,-.28,-.04,-.42,-.27,.59,-.42,-.05,.28,-.00,-.27,-1.04,-.50,.23,-.17,-.16)*f5_2+\n    mat4(-.36,.07,-.67,.51,.31,.05,-.45,.75,-.15,-.62,.22,-.10,.19,-.17,.19,-.18)*f5_3+\n    vec4(-.28,.12,-.56,-.02))/2.4+f5_2;\nvec4 f6_3=sin(mat4(.06,.08,-.84,.31,.68,.59,-.66,.23,-.07,.24,.17,.61,-.02,.02,-.13,-.12)*f5_0+\n    mat4(-.12,.64,-.67,.64,-.02,.43,-.47,.57,.25,.29,.04,-.15,1.01,.07,-.02,.02)*f5_1+\n    mat4(.21,.50,-.59,-.06,-.42,-.25,-.17,1.24,.20,.05,.01,.30,-.00,-.24,.79,-.68)*f5_2+\n    mat4(.26,.06,.50,.18,-.13,.66,.03,.21,-.32,-.33,.13,-.40,-.09,-.08,.02,.22)*f5_3+\n    vec4(.00,.31,.33,-.23))/2.4+f5_3;\nvec4 f7_0=sin(mat4(-.37,-.66,-.51,-.45,-.48,-.69,-.89,.39,-.37,.00,1.10,.10,-.50,.50,-.44,-.28)*f6_0+\n    mat4(-.59,-.05,-.58,-.13,.41,.45,.10,-.07,.51,.33,-.28,.27,.34,-.61,-.48,.30)*f6_1+\n    mat4(.17,.43,-.07,.41,-.05,.28,.69,-1.12,-.33,-.06,-.68,-.11,.30,-.18,-.04,.20)*f6_2+\n    mat4(-.09,-.15,-.17,-.50,-.51,.07,.72,-.17,.01,.38,-.37,-.57,.05,.06,.09,.10)*f6_3+\n    vec4(-.09,.15,-1.10,-.63))/2.6+f6_0;\nvec4 f7_1=sin(mat4(-.43,.49,.13,-.26,-.76,-.10,-.16,.08,-.07,.19,.30,-.12,.17,-.13,-.04,.49)*f6_0+\n    mat4(-.53,-.25,.55,-.32,.42,.78,.37,-.42,-.22,.09,.80,.08,-.19,-.05,-.13,-.62)*f6_1+\n    mat4(-.54,-.00,-.06,-.04,.61,-.16,.02,.12,.31,.11,.14,-.42,.38,.25,-.19,.72)*f6_2+\n    mat4(.24,-.08,.27,.16,.40,.52,-.61,.48,.29,-.68,.43,-.63,-.88,.10,-.03,.17)*f6_3+\n    vec4(-.05,-.16,.06,.14))/2.6+f6_1;\nvec4 f7_2=sin(mat4(-.02,.53,.23,-.22,.66,-.55,-.42,.20,.25,-.08,.24,.11,.36,.11,-.22,-.20)*f6_0+\n    mat4(.44,.37,.08,.06,-.31,.16,.67,-.93,.42,1.11,.25,.54,-.42,-.21,-.13,1.55)*f6_1+\n    mat4(.77,-.30,.35,-.21,.14,-.76,.78,-.62,-.38,-.64,-.25,.74,-.52,.52,-.29,.77)*f6_2+\n    mat4(.02,.42,-.06,-.33,.19,-.56,.20,-.71,.42,.27,-.59,-.21,-.05,-.27,.60,.06)*f6_3+\n    vec4(.22,.17,-.03,.22))/2.6+f6_2;\nvec4 f7_3=sin(mat4(.28,-.37,.43,-.07,.22,.38,.24,.06,-.90,-.22,-.30,.51,.22,-.16,-.33,.11)*f6_0+\n    mat4(-.18,.48,-.04,.62,.43,.25,.20,.07,-.22,-.44,.08,-.20,.02,.31,-.50,-1.33)*f6_1+\n    mat4(-.09,.42,.16,.29,.51,.17,.24,-.54,-.11,-.25,.17,-.63,-.47,-.13,-.50,-.68)*f6_2+\n    mat4(.70,-.23,.10,-.02,-.27,.19,-.67,-.47,.31,.36,1.01,-.52,-.30,-.17,.31,.18)*f6_3+\n    vec4(.34,.18,.43,.51))/2.6+f6_3;\nvec4 f8_0=sin(mat4(.26,-.68,-.25,.00,-.60,.40,-.74,.33,.04,.58,.54,.44,-.36,-.74,-.09,.25)*f7_0+\n    mat4(.48,.41,.64,-.73,-.17,.00,-.07,.76,-.04,.75,.11,-.13,-.06,.36,-.23,-.14)*f7_1+\n    mat4(-.43,.52,.12,-.32,.24,-.91,-.38,.41,.52,-.85,-1.03,.25,-.41,-.14,.10,.25)*f7_2+\n    mat4(.05,-.70,-.04,-.30,.38,-.57,.22,.41,.87,.19,.19,-.11,-.29,.14,-.18,-.88)*f7_3+\n    vec4(.11,-.88,-.62,-.02))/2.8+f7_0;\nvec4 f8_1=sin(mat4(.47,-.56,.04,-.72,-.03,1.04,-.29,.08,.11,.70,.34,-.34,.14,-.03,-.30,-.29)*f7_0+\n    mat4(.45,.59,.68,-.56,.21,.19,-.21,.52,.51,-.51,.50,-.43,.79,-.14,-.14,-.44)*f7_1+\n    mat4(.79,.50,.09,.09,-.28,.12,-.24,.58,.21,-.01,.38,-.29,.02,-.55,.01,.06)*f7_2+\n    mat4(.27,-.66,-.10,.27,-.04,.14,-.10,-.24,.88,-.07,-.68,.31,-.07,.50,-.02,-.25)*f7_3+\n    vec4(-.45,-.24,-.51,.55))/2.8+f7_1;\nvec4 f8_2=sin(mat4(-.06,-.31,-.13,1.04,.29,-.15,-.42,-.21,-.20,-.10,-.42,.59,-.16,-.22,-.34,.09)*f7_0+\n    mat4(.66,.35,-.08,-.77,-.21,.33,.12,-.40,-.02,-.42,.07,-.30,-.34,-.23,.08,-.69)*f7_1+\n    mat4(.59,-.09,-.34,-.40,-.80,.86,.68,-.06,.21,.72,-.05,.59,.31,-.18,-.18,.74)*f7_2+\n    mat4(-.12,-.41,.02,.01,.22,.07,.00,-.22,-.14,-.53,-.14,-.12,-.11,.36,-.12,-.02)*f7_3+\n    vec4(.27,.43,.06,.28))/2.8+f7_2;\nvec4 f8_3=sin(mat4(-.12,.49,-.26,-.37,.01,-.04,.52,.41,-.62,.41,-.76,.59,.35,.22,-.29,.26)*f7_0+\n    mat4(.86,-.81,.45,-.15,.89,1.27,-.32,-.01,.46,.19,.18,-.10,.36,.05,-.35,-.02)*f7_1+\n    mat4(.40,-.37,.38,.47,-.12,.69,-.11,.51,-.58,-.17,.17,-.01,-.52,.33,-.15,-.25)*f7_2+\n    mat4(-.64,.05,.01,-.15,-.28,.19,.05,-.08,-.46,.12,.10,-.52,.00,-.11,.11,.75)*f7_3+\n    vec4(-.86,.11,-.12,-.15))/2.8+f7_3;\nvec4 f9_0=sin(mat4(.36,.39,.02,.45,-.12,.28,.32,-.18,.20,.39,-.39,-.28,.04,.16,1.02,.28)*f8_0+\n    mat4(.11,-.51,.59,.15,-.13,-.83,.64,.26,-.07,.15,.77,-.30,-.24,-.29,-.35,.29)*f8_1+\n    mat4(.84,-.30,-.20,-.58,.76,-1.26,-.06,.45,-.16,-.82,-.45,.10,-.40,-.05,.19,.19)*f8_2+\n    mat4(1.14,.95,.28,.10,.17,-.11,-.23,-.01,.27,-.14,-.57,-.66,.46,-.39,.10,-.12)*f8_3+\n    vec4(-.74,.14,-.35,-.08))/3.0+f8_0;\nvec4 f9_1=sin(mat4(-.01,-1.18,-.30,-.56,.12,.76,-.23,-.82,.01,.57,-.28,-.38,.90,-.23,-.57,.14)*f8_0+\n    mat4(-.99,.12,.22,.01,-.17,.09,-.63,.10,-.08,-.26,.65,.04,-.14,-.29,-.17,-.31)*f8_1+\n    mat4(.13,.55,.57,-.64,-.22,.28,-.45,-.40,-.86,-.17,-.59,-.08,-.07,-.42,-.34,.24)*f8_2+\n    mat4(.66,-1.20,-.27,-.14,-.39,.54,.12,-.39,-.33,.76,-.18,.92,-.06,.66,-.10,-.73)*f8_3+\n    vec4(-.41,.22,.74,-.20))/3.0+f8_1;\nvec4 f9_2=sin(mat4(.04,.05,-.19,-.19,.95,.41,.33,-.40,.49,.09,-.12,-.25,.43,.50,.61,-.50)*f8_0+\n    mat4(-.38,-.09,-.21,-.17,-.34,.27,-.35,-.37,-.31,-.29,-.43,.46,-.58,.04,-.01,.52)*f8_1+\n    mat4(.52,.08,-.47,-.50,-.82,-.06,.30,-.02,.12,.69,-.08,.36,-.01,.09,.01,.17)*f8_2+\n    mat4(.38,.10,-.22,.08,-.21,-.96,.15,.31,-.97,-.18,.00,-.50,.49,-.16,.11,-.03)*f8_3+\n    vec4(.11,-.64,.07,.36))/3.0+f8_2;\nvec4 f9_3=sin(mat4(-.10,.08,-.12,.23,-.28,-.54,.77,.45,-.69,-.08,-.33,-.10,.58,.09,-.09,.57)*f8_0+\n    mat4(-.51,.10,.58,-.21,-.01,-.00,-.65,-.66,.47,.07,-.08,.08,-.06,.54,-.06,-.11)*f8_1+\n    mat4(-.10,.05,.23,.08,-.00,-.33,.04,-.27,-1.06,.12,.50,.67,.13,-.63,.21,-.48)*f8_2+\n    mat4(.29,-.01,.08,.51,.28,-.04,.08,.19,.54,1.03,1.11,.53,-.47,.12,-.20,-.01)*f8_3+\n    vec4(-.14,.31,-.03,.71))/3.0+f8_3;\nvec4 f10_0=sin(mat4(.69,-.20,.39,-.09,.31,-.12,-.68,.09,-.20,.67,.25,-.27,.35,-.91,-.54,.41)*f9_0+\n    mat4(.39,.30,-.67,.01,-.42,-.35,.23,.32,.53,.36,.68,-.26,.69,.59,-.21,.71)*f9_1+\n    mat4(.08,.56,.11,-.16,-.25,.13,.28,.21,1.14,-.37,-.92,.59,.13,-.61,-.29,.50)*f9_2+\n    mat4(.69,-.24,.16,-.59,-.07,.06,.65,-.49,-.28,.13,.50,-.07,.39,.34,-.29,.01)*f9_3+\n    vec4(1.01,-.37,-.40,.04))/3.2+f9_0;\nvec4 f10_1=sin(mat4(.38,-.63,-.21,-.71,-.32,.25,.52,-.64,.06,.06,-.52,-.38,-.56,.27,.62,.08)*f9_0+\n    mat4(-1.38,-.34,-.77,-.21,-.36,.72,.11,-.05,-.19,-.29,-.91,-.61,-.81,.65,.21,1.33)*f9_1+\n    mat4(-.41,-.03,-.18,.48,-.55,.72,.55,.65,-.56,-.01,.26,.56,-.28,.57,.17,.28)*f9_2+\n    mat4(-.27,-.20,.36,.06,-.35,.06,.29,-.07,-.21,-.08,-.03,.38,-.01,.16,-.20,.29)*f9_3+\n    vec4(-.68,.13,.33,.07))/3.2+f9_1;\nvec4 f10_2=sin(mat4(.45,-.22,-.75,-.32,.19,-.68,-.52,-.18,-.21,-.27,-.16,-.08,.08,.33,-.25,.79)*f9_0+\n    mat4(-.41,-.09,-.30,-.38,.68,.34,.87,.55,.18,-.01,-.12,.02,.21,-.75,.08,-.16)*f9_1+\n    mat4(.28,-.63,-.61,.67,-.01,-.03,.29,.42,-.60,.07,-.07,.96,.02,.22,.54,.50)*f9_2+\n    mat4(.21,.23,-.44,-.70,.08,.25,-.09,-.16,-.95,-.52,.08,-.19,-.63,-.23,-.27,.15)*f9_3+\n    vec4(-.63,.30,.08,.30))/3.2+f9_2;\nvec4 f10_3=sin(mat4(-.50,.43,-.03,.02,.09,.88,.24,-.14,.10,.15,-.55,-.95,.34,.47,.40,-.65)*f9_0+\n    mat4(-.39,.00,-.23,-.59,.51,.36,.50,-.28,.29,.09,.77,-.20,.09,.32,.10,.35)*f9_1+\n    mat4(.96,-.00,.19,-.15,.18,-.07,.07,.26,-.08,.39,-.25,-1.21,.15,.20,.20,-.24)*f9_2+\n    mat4(.44,.02,-.13,.33,-.66,.13,-.17,.07,.02,-.00,-.85,-.39,-.22,-.30,-.35,-.31)*f9_3+\n    vec4(.63,.23,-.01,-.14))/3.2+f9_3;\nvec4 f11_0=sin(mat4(-.44,-.11,.65,.49,.12,.11,-.99,-.40,-.36,.24,.10,-.02,.24,.39,-.28,.48)*f10_0+\n    mat4(-.78,-.86,-.48,.71,.55,.17,.18,-.27,-1.12,.02,.02,.47,.03,.23,-.40,.42)*f10_1+\n    mat4(.22,-.57,-.35,-.01,.77,-.15,-.53,-.03,.27,.47,-1.41,.19,.26,.78,-.06,.31)*f10_2+\n    mat4(-.55,-.51,-.21,.17,.14,-.23,.42,-.21,-1.14,.56,.68,-.30,.57,-.25,-.07,.00)*f10_3+\n    vec4(.81,-.67,-.64,.64))/3.3+f10_0;\nvec4 f11_1=sin(mat4(-.28,-.10,-.28,.64,-.21,.30,-.76,-.79,.64,.17,-.21,-.85,.62,-.12,-.34,-.21)*f10_0+\n    mat4(.96,.09,-.41,-.58,-.44,.54,-.20,.57,.44,-.03,.74,-.78,.72,.35,-.81,.01)*f10_1+\n    mat4(.68,-.01,-.04,-.29,-.31,.57,-.48,-.16,-.25,-.32,-.67,-.41,.31,.29,-.04,.16)*f10_2+\n    mat4(.10,-.42,.54,-.39,.02,.14,-.25,.29,.57,.66,.73,.37,-.14,-.54,.39,.11)*f10_3+\n    vec4(.40,-.39,.13,.72))/3.3+f10_1;\nvec4 f11_2=sin(mat4(.07,.82,.58,-.12,.23,.61,-.49,-.62,.80,-.37,-.16,.36,-.12,-.15,-.58,-.35)*f10_0+\n    mat4(-.25,-.45,.82,-.63,-.14,.01,.23,.63,.38,.03,1.44,-.38,-.40,-.26,-.03,-.60)*f10_1+\n    mat4(-.37,.55,.40,.14,-.26,.09,.12,.08,.45,.45,-.31,-.35,-.16,-.07,-.48,-.18)*f10_2+\n    mat4(.19,-.02,.19,-.28,-.80,-.13,-.01,.06,.10,-.68,.77,-.26,-.52,.04,-.47,-.92)*f10_3+\n    vec4(-.12,.05,.52,-.18))/3.3+f10_2;\nvec4 f11_3=sin(mat4(-.04,-.14,-.29,1.05,1.14,.17,-.90,-.37,.08,.14,.00,-1.12,.39,-.03,.18,-.59)*f10_0+\n    mat4(-.18,.09,-.17,.14,.01,-.50,-.26,.02,-.28,-.22,-.19,-.32,-.49,.13,-.33,-.35)*f10_1+\n    mat4(-.84,.10,.52,-.45,-1.20,-.99,.12,.64,.35,-.39,-.72,1.21,.21,.87,-.00,.10)*f10_2+\n    mat4(-.13,-.48,-.29,.42,-.13,-.35,.61,.01,-.42,.80,.71,-.34,-.55,-.12,-.16,-.19)*f10_3+\n    vec4(-.57,-.54,.29,-1.00))/3.3+f10_3;\nvec4 f12_0=sin(mat4(-.14,.04,-.44,.37,.50,.79,-.53,1.42,-.60,-.79,-.65,-.91,.45,.34,-.48,.41)*f11_0+\n    mat4(-.04,-1.42,-.45,.16,-.15,.40,.34,.52,-1.07,-1.24,-.10,-.06,.40,-.14,-.48,-.03)*f11_1+\n    mat4(-.01,-.78,-.45,.21,.42,.36,-.22,.27,.61,-.07,-1.83,.62,.10,.03,-.57,-.30)*f11_2+\n    mat4(-.39,.09,-.72,.32,-1.16,.01,.28,-.79,-1.18,-.68,.02,-1.33,.13,.62,-.28,-.35)*f11_3+\n    vec4(.47,-.01,-.52,-.52))/3.5+f11_0;\nvec4 f12_1=sin(mat4(-.36,-.81,.18,-.40,.26,-.55,.34,.39,-1.08,.26,.47,-.66,-.11,-.89,.03,.30)*f11_0+\n    mat4(.49,.24,.03,-.08,-.49,-.85,-.51,.74,-.41,-.01,.87,-.76,.64,.50,-1.40,1.03)*f11_1+\n    mat4(-.71,-.13,-.30,-.03,.32,-.29,-.19,-.21,.94,.38,-1.06,.04,.30,.19,-.44,-.14)*f11_2+\n    mat4(.09,.21,.19,-.55,.53,-.08,.05,.79,-.01,.23,.56,-.14,.15,.31,-.07,-.20)*f11_3+\n    vec4(-.48,.37,-.13,-.56))/3.5+f11_1;\nvec4 f12_2=sin(mat4(-.44,-.69,.19,-.04,-.89,-.31,.42,-.09,-.26,1.37,.29,-.14,-.04,-.03,.14,.44)*f11_0+\n    mat4(.33,-.58,-.86,-.60,-.20,1.14,-.38,.53,-.39,.25,-.00,-.40,.25,-.03,-1.02,.48)*f11_1+\n    mat4(-.26,-.15,-.05,.54,.28,-.43,-.36,.01,-.58,-.42,.11,.38,-.47,.17,.19,.82)*f11_2+\n    mat4(.85,-1.45,.88,-.69,.50,-.21,.40,-.29,-.24,.24,-1.26,-.27,-.21,-.96,-.08,-.22)*f11_3+\n    vec4(-.67,-.51,1.08,.16))/3.5+f11_2;\nvec4 f12_3=sin(mat4(.33,.00,-.24,.45,.56,-.07,-1.15,-.03,-.53,.09,.03,.21,.62,.21,.22,.81)*f11_0+\n    mat4(-.21,.87,-.04,.07,.60,-.08,-.12,.01,-1.16,.38,-.33,.65,.52,.08,.46,.28)*f11_1+\n    mat4(.17,.24,.47,.11,.12,.53,-.43,.16,.10,.10,-.33,.40,-.35,-.11,-.18,.37)*f11_2+\n    mat4(-.39,-.08,.36,-.35,-.25,.04,-.12,-.44,.18,.94,.61,-.23,-.02,.43,.20,.85)*f11_3+\n    vec4(.20,-.18,1.27,-.00))/3.5+f11_3;\nvec4 f13_0=sin(mat4(.25,-.39,-.23,-.27,-1.42,.60,-.04,-.18,-.55,.76,.69,.19,-.64,.56,.45,-.82)*f12_0+\n    mat4(-.14,-.20,.24,.06,.16,.29,.60,-.39,.02,.04,.00,.79,.03,.01,.13,-.74)*f12_1+\n    mat4(.07,.62,-.19,.06,.71,-.38,-.50,.59,-.58,.91,-1.26,-.25,.54,.23,-.10,-.56)*f12_2+\n    mat4(.90,-1.18,.01,.24,.26,-.44,-.63,.09,1.20,-.09,-.10,-.34,.12,.26,.01,.37)*f12_3+\n    vec4(.20,-.66,-.02,.10))/3.6+f12_0;\nvec4 f13_1=sin(mat4(-.84,-.04,.55,.12,-1.54,1.22,.46,.03,.27,-.29,.23,-.79,-1.33,.39,.00,.29)*f12_0+\n    mat4(.32,-.51,.69,.44,-.34,.32,1.07,.04,-.03,-.63,.92,.16,-.11,.38,-.28,.76)*f12_1+\n    mat4(.18,-.21,-.23,.08,.88,.36,-.89,.86,-.13,.70,-.59,-.14,-.03,.82,-.12,.35)*f12_2+\n    mat4(.07,-.49,-.29,.95,1.75,-.47,-1.01,.74,.30,-.82,-.95,1.58,.03,-.29,.24,-.06)*f12_3+\n    vec4(1.44,1.21,1.07,-1.80))/3.6+f12_1;\nvec4 f13_2=sin(mat4(.68,.48,.84,-.29,-.46,-.91,.36,1.30,.12,-.16,-.79,.18,-.24,-.25,.47,-.61)*f12_0+\n    mat4(-.64,-.16,-.39,-.39,.83,-.99,.52,-.09,.08,-.36,-.88,-.05,-.46,.01,-.07,-.36)*f12_1+\n    mat4(-.48,.67,-.01,-.06,.59,.17,.21,.18,-.28,-.17,.62,.43,-.07,-.35,-.19,.42)*f12_2+\n    mat4(.03,.45,-.18,-.43,.58,.02,-.22,-.26,-.07,-.05,-1.08,-.19,-.53,-.24,-.25,-.04)*f12_3+\n    vec4(.12,.14,-.38,-.20))/3.6+f12_2;\nvec4 f13_3=sin(mat4(-.10,.41,-.46,-.19,.09,.04,-.26,-.27,-.10,-.47,-.22,.55,.28,.85,-.53,.01)*f12_0+\n    mat4(.58,-.51,.73,-.19,.98,.31,.52,-.26,-.87,-.08,-.15,1.02,1.07,.33,-.02,-.49)*f12_1+\n    mat4(.01,-.24,-.43,-.20,.46,-.55,-.04,-.21,-.18,.33,-.43,.44,-.15,.29,-.95,.16)*f12_2+\n    mat4(-.45,-.47,.67,.49,-.17,-.27,-.14,.06,.23,.41,-.73,-.34,-.61,-.58,.36,.24)*f12_3+\n    vec4(-.99,-.07,.42,-.62))/3.6+f12_3;\nvec4 f14_0=sin(mat4(-2.19,.92,-.72,-.04,.40,-.38,.25,.49,-.52,-.78,.62,.21,.51,.18,-.27,.46)*f13_0+\n    mat4(.32,.13,-.63,.15,-.13,.03,-.19,.21,.19,-1.15,-.04,-.32,-1.58,.30,.71,-.10)*f13_1+\n    mat4(.48,-.26,-.11,.50,-.04,.43,-.24,-.90,.22,.28,.51,1.18,-.54,.14,.12,.38)*f13_2+\n    mat4(-.09,-.01,-.84,-.75,-.22,.56,.67,-.65,.14,-.10,-.29,-.34,.57,.11,.54,.53)*f13_3+\n    vec4(.32,.54,.90,-.19))/3.7+f13_0;\nvec4 f14_1=sin(mat4(.47,-.66,1.02,.48,-.75,.61,-.94,1.21,-.92,.09,-.44,-.88,-1.06,.69,-.55,1.00)*f13_0+\n    mat4(.50,.85,.65,-.60,.19,.08,.47,.35,.99,.81,-.31,-.27,.90,-.30,-.82,1.41)*f13_1+\n    mat4(-.84,.12,-.54,.19,1.09,.31,1.01,-.54,-.96,.32,-.37,.03,-.28,.24,.11,-.02)*f13_2+\n    mat4(.42,-.53,-.10,-.23,1.01,.01,1.17,.18,.10,-.93,.01,-.84,.09,-.18,-.14,-.60)*f13_3+\n    vec4(.39,.11,-.86,-1.14))/3.7+f13_1;\nvec4 f14_2=sin(mat4(.98,-.09,-.13,.14,-.86,-1.45,.46,1.24,-.47,.08,.35,1.01,-.53,-.82,.51,.28)*f13_0+\n    mat4(-.83,-.32,.32,-.22,-.06,.20,.63,-.09,.07,.35,.15,-.09,-.58,.44,-.27,.08)*f13_1+\n    mat4(-.61,.09,.16,.02,.17,.26,-.62,.38,-.42,-.85,.52,.11,.06,-.67,.48,.74)*f13_2+\n    mat4(.43,1.00,-.65,-.06,.30,.83,-.24,-.70,-.88,.27,.01,-.46,-.76,-.02,-.10,.20)*f13_3+\n    vec4(.29,-.01,-.82,-.61))/3.7+f13_2;\nvec4 f14_3=sin(mat4(.34,-.07,.38,-.12,-.71,-.41,-.88,-.24,-.29,-.24,-.68,-.08,-.72,-.06,-.82,.34)*f13_0+\n    mat4(-.19,.49,-.12,.06,-.71,-.45,-.35,-.04,.09,.18,.16,.14,-.52,.08,.54,-.15)*f13_1+\n    mat4(-.01,-.22,-.46,.13,.47,.23,-.52,.19,-.81,-.93,-.89,.92,-.16,-.16,-.31,-.61)*f13_2+\n    mat4(.68,.75,.65,.33,.46,.45,.37,.11,.66,.30,.92,.76,.47,-.13,-.00,.01)*f13_3+\n    vec4(.28,.32,-.55,-1.13))/3.7+f13_3;\nvec4 f15_0=sin(mat4(1.11,.20,-.67,-.22,-1.15,-.92,.45,.42,.05,.12,.17,.54,-1.34,-1.11,.75,.60)*f14_0+\n    mat4(.05,.22,-.36,.02,.19,.08,-.24,.24,.46,.53,-.50,-.41,-.35,-.78,.31,-.49)*f14_1+\n    mat4(-.84,-.25,.52,.93,-.06,.58,.62,-.47,-2.00,-.86,.41,1.00,-1.15,-.64,-.97,.11)*f14_2+\n    mat4(.80,.02,-.77,-.67,-.20,.82,-.52,-.47,1.68,.13,-.48,-.74,-.39,.26,-.08,.01)*f14_3+\n    vec4(1.16,-.51,.39,-.00))/3.9+f14_0;\nvec4 f15_1=sin(mat4(.40,-.60,.34,-.55,-2.65,1.28,-.79,-.34,.28,.50,.08,-.07,-1.38,.65,.13,.23)*f14_0+\n    mat4(-.99,.47,.21,-1.39,-1.19,.39,-.16,-.06,.29,-.15,.51,-.39,-.28,-.39,1.36,.33)*f14_1+\n    mat4(.03,.09,.02,-.34,.91,-.20,.36,.86,-1.74,.60,.48,-1.79,-1.14,-.10,-1.02,-1.26)*f14_2+\n    mat4(.76,-.18,.87,.71,1.29,-.83,1.36,.41,.34,-.90,.77,.17,-.21,-.14,-.41,-.00)*f14_3+\n    vec4(.35,-.09,-.52,-.78))/3.9+f14_1;\nvec4 f15_2=sin(mat4(-.33,-.20,.05,-.81,1.37,.88,-.72,.65,.35,-.11,-.15,.38,.52,1.32,-1.01,.55)*f14_0+\n    mat4(.69,.34,-.13,-.30,.37,.71,-.11,-.87,-.69,.10,-.11,-.08,.16,.43,-.02,-.62)*f14_1+\n    mat4(.15,-.00,-.42,.47,-.65,-1.44,.90,-.08,2.03,.54,-1.11,1.30,.36,.41,-.70,-.16)*f14_2+\n    mat4(-.16,.06,.22,.52,-1.33,-1.21,.77,.61,-.85,-.86,-.22,.35,.05,-.23,.23,.14)*f14_3+\n    vec4(-.46,.30,-.30,.06))/3.9+f14_2;\nvec4 f15_3=sin(mat4(.15,-.29,1.10,.05,-.51,.92,-1.15,1.66,-.35,.09,-.88,.61,-.86,.94,-.82,1.71)*f14_0+\n    mat4(.98,.80,-.61,.29,-.53,.22,-.67,.01,.38,-.14,.23,.38,.40,.32,.09,-.83)*f14_1+\n    mat4(-.16,.56,-.38,.73,.60,-.66,.67,-.98,-.24,1.46,-.77,1.81,-.17,.72,-.24,.63)*f14_2+\n    mat4(.40,-.42,.37,-.53,.90,-.48,.06,-.53,.46,-.35,.30,-1.16,-.21,-.52,-.19,-.17)*f14_3+\n    vec4(-.17,1.10,-.15,1.08))/3.9+f14_3;\nvec4 f16_0=sin(mat4(-.41,.17,-.20,-.07,-.74,-.77,.75,.81,-.21,-.28,.62,.25,-.13,-.67,.75,.72)*f15_0+\n    mat4(.44,.09,-.13,-.34,-.07,-.33,.48,.55,.41,.27,-.02,-.12,-.05,.09,.10,-.22)*f15_1+\n    mat4(-.04,-.37,.33,.48,.62,.33,-.85,-.70,-.43,-1.03,1.06,.93,-.35,-.23,.16,.26)*f15_2+\n    mat4(.66,.70,-.62,-.40,.12,.66,-.84,-.84,.01,.36,-.46,-.57,.34,-.47,.09,.45)*f15_3+\n    vec4(-1.03,1.68,.07,-.61))/4.0+f15_0;\nvec4 f16_1=sin(mat4(.27,-.29,.24,.24,-.68,1.60,.18,-.02,-.39,.73,-.33,-.01,-.75,1.32,.28,-.21)*f15_0+\n    mat4(.06,-.58,-.03,-.41,-.48,.94,-.05,-.57,-.07,-.26,-.25,.88,.03,-.18,-.32,-.21)*f15_1+\n    mat4(-.85,.83,.35,.35,.44,-1.03,.23,.06,-.71,1.85,.11,-1.95,-.30,.25,.21,.28)*f15_2+\n    mat4(.74,-.96,-.03,.68,.75,-1.54,.05,1.36,.48,-.99,.02,.59,.06,.55,.53,.45)*f15_3+\n    vec4(-.38,-.52,.42,-.69))/4.0+f15_1;\nvec4 f16_2=sin(mat4(.03,-.02,.37,.26,.95,-1.04,-.88,.41,.38,-.20,-.44,-.07,.61,-.80,-.78,.61)*f15_0+\n    mat4(-.37,.19,.03,-.30,.49,-.43,-.38,.45,-.37,.32,.27,-.10,-.20,-.03,-.08,-.42)*f15_1+\n    mat4(.28,-.30,-.40,.39,-.59,.98,.31,-.86,1.12,-1.16,-1.17,.57,.10,-.62,-.21,.24)*f15_2+\n    mat4(-.49,.83,.83,-.04,-.77,.69,.71,-.52,-.37,.29,.54,-.10,.22,.11,-.61,.44)*f15_3+\n    vec4(-.07,.42,1.74,.30))/4.0+f15_2;\nvec4 f16_3=sin(mat4(.15,-.04,.22,-.08,-.83,-.60,-.77,.82,-.39,-.08,-.48,.25,-.82,-1.11,-.59,.91)*f15_0+\n    mat4(.28,.28,.26,-.52,-.55,-.43,-.31,.42,.06,.18,.08,-.23,.04,.24,.03,.09)*f15_1+\n    mat4(-.55,-.43,-.46,.54,.50,.63,.23,-.49,-.91,-.71,-1.04,.99,-.21,-.33,-.30,.12)*f15_2+\n    mat4(.69,.49,.56,-.56,.89,.72,.80,-1.15,.48,.22,.56,-.33,.20,-.27,.17,.14)*f15_3+\n    vec4(.82,.93,.30,.22))/4.0+f15_3;\nfloat f_0=dot(f16_0,vec4(-.02,.13,.05,.13))+\n    dot(f16_1,vec4(-.03,.07,-.03,-.01))+\n    dot(f16_2,vec4(.07,-.08,.16,.04))+\n    dot(f16_3,vec4(-.10,-.12,-.07,.04))+\n    0.527;\n\nreturn f_0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyczt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[989, 989, 1043, 1043, 1085], [1087, 1087, 1125, 1125, 1192], [1194, 1194, 1251, 1251, 2184]], "test": "untested"}
{"id": "WlVcWy", "name": "Day 406", "author": "jeyko", "description": "marble tato", "tags": ["art", "artdeco", "mdtmjvm", "deco"], "likes": 15, "viewed": 416, "published": 3, "date": "1611695537", "time_retrieved": "2024-07-30T19:42:17.232522", "image_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\n//#define xor()\n\n\n#define ID_GOLD 1.\n#define ID_BLACK 0.\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\n\n\nvoid map(vec2 p, out float dBase, out float dGold){\n    p.x *= 0.8;\n    \n    \n    //dBase = length(p) - 0.55;\n    \n    p.x += 0.;\n    dBase = sdBox(p*rot(0.25*pi),vec2(0.5));\n    \n    float sideW = 0.47;\n    dBase = max(dBase, abs(p.y) - sideW);\n    \n    dBase = min(dBase, max(abs(p.y) - sideW,p.x));\n    \n    //dBase =  pmodlim(dBase,0.1,0.1);\n    \n    \n    //dBase = dBase-c*clamp(round(dBase/c),-l,l);\n    \n    dGold = abs(preplim(dBase + 0.11,0.1,1.)) - 0.01;\n    \n    \n    //dGold = xor(dGold,max(abs(p.y) - 0.3,abs(p.x + 0.1) - 0.25),0.4);\n    \n    dGold = xor(dGold,max(abs(p.y) - 0.3,abs(p.x + 0.35) - 0.25),0.4);\n    \n    //dGold = xor(dGold,max(abs(length(p.x + p.y + 0.04) - .5) - 0.,abs(p.y + 0.) - 0.),0.);\n    \n    \n    ////float db = xor(dGold, abs(length(p) - 0.2) - 0.0);\n    \n    //db = \n    //dGold = xor(dGold, db );\n    \n    //dGold = min(dGold,db);\n\n}\n\n\nvec3 getNormalGolda(vec2 p){\n    vec2 e = vec2(0.,0.2);\n    float idklol = 0.;\n    float dG = 0.;\n    map(p,idklol,dG);\n    \n    const float normalAtt = .1;\n    \n    float dGA = 0.;\n    map(p + e.xy,idklol,dGA);\n    float dGB = 0.;\n    map(p + e.yx,idklol,dGB);\n    \n    \n    dG = smoothstep(normalAtt,0.,dG);\n    dGA = smoothstep(normalAtt,0.,dGA);\n    dGB = smoothstep(normalAtt,0.,dGB);\n    \n    return normalize(dG - vec3(0,0,1.) - vec3(dGA, dGB,0.)*1.);;\n}\n\n\nvec3 getNormalGold(vec2 p){\n    vec2 e = vec2(0.,0.02);\n    \n    float normalAtt = 0.02;\n    \n    float idklol = 0.;\n    float dGXa = 0.;\n    map(p + e.yx,idklol,dGXa);\n    float dGXb = 0.;\n    map(p - e.yx,idklol,dGXb);\n    \n    float dGYa = 0.;\n    map(p + e.xy,idklol,dGYa);\n    float dGYb = 0.;\n    map(p - e.xy,idklol,dGYb);\n    \n    \n    dGXa = smoothstep(normalAtt,0.,dGXa);\n    dGXb = smoothstep(normalAtt,0.,dGXb);\n    dGYa = smoothstep(normalAtt,0.,dGYa);\n    dGYb = smoothstep(normalAtt,0.,dGYb);\n    \n    vec2 deriv = vec2(dGXa - dGXb, dGYa - dGYb);\n    \n    return normalize( -vec3(0,0,1.) + vec3(deriv,0.)*1.);;\n}\nvec3 getNormalGoldB(vec2 p){\n    vec2 e = vec2(0.,0.05);\n    float idklol = 0.;\n    float dG = 0.;\n    map(p,idklol,dG);\n    \n    const float normalAtt = .05;\n    \n    float dGA = 0.;\n    map(p + e.xy,idklol,dGA);\n    float dGB = 0.;\n    map(p + e.yx,idklol,dGB);\n    \n    \n    dG = smoothstep(normalAtt,0.,dG);\n    dGA = smoothstep(normalAtt,0.,dGA);\n    dGB = smoothstep(normalAtt,0.,dGB);\n    \n    return normalize(dG - vec3(0,0,0.5) - vec3(dGA, dGB,0.)*1.);;\n}\n\nvec2 globalPos;\nvec2 guv;\nvoid getTile( vec2 p, out vec3 col, out float dBase, vec2 gv){\n    \n    vec2 d = vec2(10e5);\n    col -= col;\n    \n    float dGold;\n    \n    map(p,dBase,dGold);\n    \n    // globalPos and guv should be offset by the tile offs but eh \n    \n    vec3 goldCol = vec3(1,0.5,0.1);\n    vec3 marbleCol = vec3(0.00);\n    \n    \n    //const vec3 lDir = normalize(vec3(-1,2,-1.));\n    const vec3 lDir = normalize(vec3(-1,2,-1.));\n\n    float nA = cyclicNoise(vec3(globalPos,0. + iTime)*0.4, false, iTime*1.);\n    float nB = cyclicNoise(vec3(globalPos,6.)*20., true, iTime);\n    float nC = cyclicNoiseMarb(vec3(globalPos,6.)*10., false, 0.);\n    float nE = cyclicNoiseMarbB(vec3(globalPos,6.)*11. + 4., false, 0.);\n    \n    \n    dGold += nB*0.001 + nC*0.003;\n    // marble\n\n    //marbleCol += pow(max(nC,0.),4.)*mix(vec3(1.1,0.5,0.2),vec3(0.1,0.6,1.),smoothstep(0.,1.,pow(nC,5.1)));\n    vec3 marbles = pow(max(nC,0.),4.)*mix(vec3(1.1,0.5,0.2),vec3(0.1,0.6,1.),smoothstep(0.,1.,pow(nC,5.1)));\n    //vec3 marblesb = pow(max(nE,0.),8.)*mix(vec3(1.1,0.5,0.2),vec3(0.1,0.6,1.),smoothstep(0.,1.,pow(nE,9.1)));\n    vec3 marblesb = smoothstep(0.35,0.,nE + 0.2)*vec3(1);\n    \n    marbleCol += 0.075*marbles;\n\n    marbleCol += 0.45*marblesb;\n\n\n    // gold\n    vec3 goldNormal = getNormalGold(p);\n    goldCol = mix(goldCol,goldCol*goldCol,nB*0.75);\n    \n    goldNormal = normalize(goldNormal + nA*5.);\n    \n    goldCol = mix(goldCol,goldCol*16.*vec3(0.7,0.6,0.9) ,max(dot(goldNormal,lDir),0.));\n    //goldCol = mix(goldCol,goldCol*0. ,max(dot(getNormalGoldB(p),vec3(1,-0.4,-0.)),0.));\n    goldCol = mix(goldCol,goldCol*0.3*vec3(0.5,0.5,1) ,max(dot(getNormalGoldB(p),vec3(1,-0.4,-0.)),0.));\n    \n    \n    goldCol = mix(goldCol,goldCol*0.4*vec3(0.5,0.5,1),smoothstep(0.01,0.00,abs(dGold)));\n    \n    \n    \n    //marbleCol = mix(marbleCol,.05*vec3(0.7,0.6,0.9) ,max(dot(goldNormal,lDir),0.));\n\n    //marbleCol = mix(marbleCol,.15*vec3(0.7,0.6,0.9), smoothstep(1.,0.,dot(guv,guv)) );\n    vec2 mguv = guv + vec2(0,iTime*0.146);\n    marbleCol += pow(texture(iChannel0,mguv*2.5*rot(0.5*pi),1.).xyz,vec3(4.))*vec3(0.2,1.,1.)*0.1*smoothstep(1.,0.,dot(guv - 0.25,guv - 0.25))*(1. + marbles*4.) ;\n    \n    marbleCol *= smoothstep(0.,0.12,dGold);\n    \n    col = mix(col,marbleCol, smoothstep(pixSz,dBase,dBase));\n    \n    col = mix(col,goldCol, smoothstep(pixSz,0.,dGold));\n    \n    col = mix(col,col*0.05*vec3(0.2,0.2,3.),smoothstep(0.,0.7,-p.x*1.4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    guv = uv;\n    \n    uv *= 4.;\n    \n    uv.y += iTime*0.5;\n    uv.y /= 0.8;\n    \n    globalPos = uv;\n    pixSz = dFdx(uv.x)*1.;\n    \n    uv *= rot(-0.5*pi);\n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        vec3 tileCol;\n        getTile(gv - offs, tileCol, d, uv - offs);\n        \n        \n        col = mix( col, tileCol, smoothstep(pixSz,0.,d));\n        \n    }\n    \n    \n    //col += smoothstep(pixSz,0.,hc.y);\n        \n        \n    //float n = cyclicNoise(vec3(uv,1.), false, 0.);\n\n    \n    //col = clamp(col,0.,1.);\n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(guv,guv)),0.5));\n\n    col *= vec3(1.,0.9,0.8);\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(0);\n    fragColor.xyz = col.xyz;\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 299, 322, 322, 419], [421, 421, 459, 459, 717], [778, 778, 806, 806, 850], [853, 853, 904, 904, 1727], [1730, 1730, 1758, 1758, 2191], [2194, 2194, 2221, 2221, 2821], [2822, 2822, 2850, 2850, 3286], [3314, 3314, 3376, 3376, 5729], [5731, 5731, 5788, 5788, 7377]], "test": "untested"}
{"id": "WlKcWy", "name": "raymarching with phong lighting", "author": "rskabin", "description": "A sphere and a cube are rendered via raymarching and beautified by phong lighting", "tags": ["raymarching", "lighting", "phonglighting"], "likes": 1, "viewed": 326, "published": 3, "date": "1611693894", "time_retrieved": "2024-07-30T19:42:17.979524", "image_code": "#define MAX_RAY_STEPS 100\n#define EPSILON       0.00001f\n#define MIN_DEPTH     0.0f\n#define MAX_DEPTH     100.0f\n\n#define OBJECT_ID_SPHERE 0u\n#define OBJECT_ID_CUBE   1u\n\nstruct GetMinDistResult\n{\n    float dist;\n    uint  object_id;\n};\n\nGetMinDistResult GetMinDist(vec3 ray_pos, vec4 sphere, vec4 cube)\n{\n    float dist_to_sphere = length(sphere.xyz - ray_pos) - sphere.w;\n    float dist_to_cube   = length(max(abs(cube.xyz - ray_pos) - cube.w, 0.0f));\n\n    GetMinDistResult result;\n    result.dist = min(dist_to_sphere, dist_to_cube);\n\n    /**/ if (result.dist == dist_to_sphere) result.object_id = OBJECT_ID_SPHERE;\n    else if (result.dist == dist_to_cube)   result.object_id = OBJECT_ID_CUBE;\n\n    return result;\n}\n\nmat4 LookAtLH(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 z_axis    = normalize(target - camera);\n    vec3 x_axis    = normalize(cross(up, z_axis));\n    vec3 y_axis    = cross(z_axis, x_axis);\n    vec3 translate = vec3(-dot(x_axis, camera),\n                          -dot(y_axis, camera),\n                          -dot(z_axis, camera));\n\n    return mat4(x_axis.x,    y_axis.x,    z_axis.x,    0.0f,\n                x_axis.y,    y_axis.y,    z_axis.y,    0.0f,\n                x_axis.z,    y_axis.z,    z_axis.z,    0.0f,\n                translate.x, translate.y, translate.z, 1.0f);\n}\n\nmat4 PerspLH(float aspect, float fov, float near, float far)\n{\n    float tanfov2 = tan(radians(fov / 2.0f));\n    return mat4(1.0f/(aspect*tanfov2),         0.0f,                        0.0f, 0.0f,\n                                 0.0f, 1.0f/tanfov2,                        0.0f, 0.0f,\n                                 0.0f,         0.0f,       (far+near)/(far-near), 1.0f,\n                                 0.0f,         0.0f, -(2.0f*near*far)/(far-near), 0.0f);\n}\n\nmat3 RotationY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(   c, 0.0f,   -s,\n                0.0f, 1.0f, 0.0f,\n                   s, 0.0f,    c);\n}\n\nmat3 RotationX(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(1.0f, 0.0f, 0.0f,\n                0.0f,    c,    s,\n                0.0f,   -s,    c);\n}\n\nvec3 GetNormal(GetMinDistResult mdr, vec3 ray_pos, vec4 sphere, vec4 cube)\n{\n    if (mdr.object_id == OBJECT_ID_SPHERE)\n    {\n        vec3 normal = normalize(ray_pos - sphere.xyz);\n        normal.z *= -1.0f;\n        return normal;\n    }\n    else if (mdr.object_id == OBJECT_ID_CUBE) // @NOTE: Awful\n    {\n        vec3 v1 = vec3(ray_pos.x - (cube.x - cube.w), 0.0f, 0.0f);\n        vec3 v2 = vec3(0.0f, ray_pos.y - (cube.y - cube.w), 0.0f);\n        vec3 v3 = vec3(0.0f, 0.0f, ray_pos.z - (cube.z - cube.w));\n        vec3 v4 = vec3(ray_pos.x - (cube.x + cube.w), 0.0f, 0.0f);\n        vec3 v5 = vec3(0.0f, ray_pos.y - (cube.y + cube.w), 0.0f);\n        vec3 v6 = vec3(0.0f, 0.0f, ray_pos.z - (cube.z + cube.w));\n\n        float l1 = length(v1);\n        float l2 = length(v2);\n        float l3 = length(v3);\n        float l4 = length(v4);\n        float l5 = length(v5);\n        float l6 = length(v6);\n\n        float min_length1 = min(min(l1, l2), l3);\n        float min_length2 = min(min(l4, l5), l6);\n        float min_length  = min(min_length1, min_length2);\n\n        /**/ if (min_length == l1) return vec3(-1.0f,  0.0f,  0.0f);\n        else if (min_length == l2) return vec3( 0.0f, -1.0f,  0.0f);\n        else if (min_length == l3) return vec3( 0.0f,  0.0f,  1.0f);\n        else if (min_length == l4) return vec3( 1.0f,  0.0f,  0.0f);\n        else if (min_length == l5) return vec3( 0.0f,  1.0f,  0.0f);\n        else if (min_length == l6) return vec3( 0.0f,  0.0f, -1.0f);\n    }\n    return vec3(0.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ((fragCoord / iResolution.xy) - 0.5f) * 2.0f;\n    uv.y *= iResolution.y / iResolution.x;\n\n    vec2 mouse_pos = ((iMouse.xy / iResolution.xy) - 0.5f) * 2.0f;\n    mouse_pos.y *= iResolution.y / iResolution.x;\n    \n    // @NOTE: Centralize on start.\n    if (iMouse.xy == vec2(0.0f)) mouse_pos = vec2(0.0f);\n\n    vec3 cam_pos = RotationX(-mouse_pos.y) * RotationY(mouse_pos.x) * vec3(0.0f, 0.0f, -0.4f);\n    vec3 target  = vec3(0.0f, 0.0f, 0.6f);\n\n    mat4 persp   = PerspLH(iResolution.x / iResolution.y, 90.0f, abs(cam_pos.z), 100.0f);\n    mat4 look_at = LookAtLH(cam_pos, target, vec3(0.0f, 1.0f, 0.0f));\n\n    vec3 light_pos = vec3(-1.0f, 1.0f, -0.7f);\n    vec4 sphere    = vec4( 0.4f, 0.0f,  0.4f, 0.3f);\n    vec4 cube      = vec4(-0.4f, 0.0f,  0.5f, 0.3f);\n\n    vec4 inter_sphere_pos = persp * look_at * vec4(sphere.xyz, 1.0f);\n    vec4 inter_cube_pos   = persp * look_at * vec4(cube.xyz, 1.0f);\n\n    if (inter_sphere_pos.w != 0.0f) inter_sphere_pos /= inter_sphere_pos.w;\n    if (inter_cube_pos.w   != 0.0f) inter_cube_pos   /= inter_cube_pos.w;\n\n    sphere.w *= length(inter_sphere_pos.xyz) / length(sphere.xyz);\n    cube.w   *= length(inter_cube_pos.xyz)   / length(cube.xyz);\n\n    sphere.xyz = inter_sphere_pos.xyz;\n    cube.xyz   = inter_cube_pos.xyz;\n\n    vec3 object_colors[2];\n    object_colors[OBJECT_ID_SPHERE] = vec3(0.9f, 0.0f, 0.0f);\n    object_colors[OBJECT_ID_CUBE]   = vec3(0.0f, 0.0f, 0.9f);\n\n    vec3 light_color  = vec3(0.7f, 0.8f, 0.8f);\n\n    vec3 ray_dir = normalize(vec3(uv, target.z) - cam_pos);\n\n    float depth = MIN_DEPTH;\n    for (int step = 0; step < MAX_RAY_STEPS && depth < MAX_DEPTH; ++step)\n    {\n        vec3 ray_pos = cam_pos * depth + ray_dir;\n\n        GetMinDistResult min_dist_res = GetMinDist(ray_pos, sphere, cube);\n\n        if (min_dist_res.dist < EPSILON)\n        {\n            vec3 view_dir  = normalize(ray_pos - cam_pos);\n            vec3 light_dir = normalize(ray_pos - light_pos);\n            vec3 normal    = GetNormal(min_dist_res, ray_pos, sphere, cube);\n            vec3 light_ref = reflect(-light_dir, normal);\n\n            float ambient_strength = 0.1f;\n            vec3  ambient          = ambient_strength * light_color;\n\n            float diff    = max(dot(normal, -light_dir), 0.0f);\n            vec3  diffuse = diff * light_color;\n\n            float spec_strength = 0.6f;\n            float shininess     = 32.0f;\n            float spec          = pow(max(dot(view_dir, light_ref), 0.0f), shininess);\n            vec3  specular      = spec_strength * spec * light_color;\n\n            fragColor = vec4((ambient + diffuse + specular) * object_colors[min_dist_res.object_id], 1.0f);\n            return;\n        }\n\n        depth += min_dist_res.dist;\n    }\n\n    fragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 305, 305, 719], [721, 721, 771, 771, 1308], [1310, 1310, 1372, 1372, 1773], [1775, 1775, 1804, 1804, 1961], [1963, 1963, 1992, 1992, 2149], [2151, 2151, 2227, 2227, 3650], [3652, 3652, 3707, 3707, 6480]], "test": "untested"}
{"id": "wsVyzD", "name": "Fast Separable Poisson SVD", "author": "cornusammonis", "description": "A separable Poisson solver method computed using singular value decomposition", "tags": ["poisson", "normal", "depth", "value", "decomposition", "vein", "melter", "svd", "singular"], "likes": 40, "viewed": 1052, "published": 3, "date": "1611691976", "time_retrieved": "2024-07-30T19:42:19.082576", "image_code": "/* \n\tCreated by Cornus Ammonis (2021)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n    Fork of \"Perceptual Depth Poisson Solver\" by cornusammonis. https://shadertoy.com/view/MlByW3\n    2020-10-10 22:58:33\n\n\tThis is an update of my previously-posted \"Perceptual Depth Poisson Solver\" shader.\n\tAs in the previous technique, a Poisson solver kernel is generated by recursively \n    solving multiple Jacobi iterations. See this shader (https://www.shadertoy.com/view/MdSczK)\n    by Robert Schuetze for another example of a multi-step kernel Poisson solver method. \n    \n    This approach sacrifices some accuracy for greatly improved performance by precomputing\n    separable Poisson solver kernels using singular value decomposition.\n    \n    Here, the Laplacian calculation step and Poisson solver step are combined together by \n    convolution, resulting in a single step with two kernels, one each for the x and y \n    components of the input vector field. The combined kernels are then decomposed into separable \n    kernels using singular value decomposition. Here, the 3 largest singular values are taken, \n    and the sum of the 3 resulting separable convolutions is used to approximate the 2 full \n    Poisson kernels. \n    \n    The result of the first pass (Buffer C) is packed to half floats in order to store each of the 6\n    values (3 each for x and y components) from the first convolution pass in a single buffer.\n    \n    I have also made some general performance improvements to the original shader by offloading\n    some computation in the dynamical system in Buffer A to a second pass in Buffer B. These \n    changes are ancillary to the Poisson-SVD method demonstrated here.\n\n\tComment out \"#define POISSON\" below to render using the original vector map without using the\n    Poisson solver.\n*/\n\n// displacement (for texturing)\n#define DISP 0.02\n\n// bump mapping scale\n#define BUMP 1.5\n\n// mip level\n#define MIP 0.0\n\n// comment to use the original vector field without running through the Poisson solver\n#define POISSON\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    #ifdef POISSON\n        float d   = texture(iChannel0, uv).x;\n        float d_n = texture(iChannel0, fract(uv+n)).x;\n        float d_e = texture(iChannel0, fract(uv+e)).x;\n        float d_s = texture(iChannel0, fract(uv+s)).x;\n        float d_w = texture(iChannel0, fract(uv+w)).x; \n\n        float d_ne = texture(iChannel0, fract(uv+n+e)).x;\n        float d_se = texture(iChannel0, fract(uv+s+e)).x;\n        float d_sw = texture(iChannel0, fract(uv+s+w)).x;\n        float d_nw = texture(iChannel0, fract(uv+n+w)).x; \n\n        float dxn[3];\n        float dyn[3];\n\n        dyn[0] = d_nw - d_sw;\n        dyn[1] = d_n  - d_s; \n        dyn[2] = d_ne - d_se;\n\n        dxn[0] = d_ne - d_nw; \n        dxn[1] = d_e  - d_w; \n        dxn[2] = d_se - d_sw; \n    #else\n        vec2 d   = texture(iChannel2, uv).xy;\n        vec2 d_n = texture(iChannel2, fract(uv+n)).xy;\n        vec2 d_e = texture(iChannel2, fract(uv+e)).xy;\n        vec2 d_s = texture(iChannel2, fract(uv+s)).xy;\n        vec2 d_w = texture(iChannel2, fract(uv+w)).xy; \n\n        vec2 d_ne = texture(iChannel2, fract(uv+n+e)).xy;\n        vec2 d_se = texture(iChannel2, fract(uv+s+e)).xy;\n        vec2 d_sw = texture(iChannel2, fract(uv+s+w)).xy;\n        vec2 d_nw = texture(iChannel2, fract(uv+n+w)).xy; \n\n        float dxn[3];\n        float dyn[3];\n\n        dyn[0] = d_n.y;\n        dyn[1] = d.y; \n        dyn[2] = d_s.y;\n\n        dxn[0] = d_e.x; \n        dxn[1] = d.x; \n        dxn[2] = d_w.x; \n    #endif\n    \n    #define I(d_x,d_y) texture(iChannel1, fract(vec2(0.5) + DISP * vec2(d_x,d_y)), MIP).xyz\n\n    vec3 i   = I(dxn[0],dyn[0]);\n    vec3 i_n = I(dxn[1],dyn[1]);\n    vec3 i_e = I(dxn[2],dyn[2]);\n    vec3 i_s = I(dxn[1],dyn[2]);\n    vec3 i_w = I(dxn[2],dyn[0]);\n    \n    vec3 ib = 0.4 * i + 0.15 * (i_n+i_e+i_s+i_w);\n\n    vec3 ld = normz(vec3(0.5+0.5*vec2(cos(iTime/2.0), sin(iTime/2.0)) - uv, -1.));\n    \n    float spec = 0.0;    \n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            vec3 dxy = normalize(vec3(-BUMP*vec2(dxn[i], dyn[j]), -1.0));\n            spec += ggx(dxy, vec3(0,0,-1), ld, 0.4, 0.1) / 9.0;\n        }\n    }\n\n    // end bumpmapping section\n\n    vec3 tc = 0.9*contrast(0.9*ib);\n\n    fragColor = vec4((tc + vec3(0.9, 0.85, 0.8)*spec),1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define STEPS 40  // advection steps\n\n#define ts 0.25    // advection curl\n#define cs -2.0   // curl scale\n#define ls 0.05   // laplacian scale\n#define ps -2.0   // laplacian of divergence scale\n#define ds -0.4   // divergence scale\n#define dp -0.03  // divergence update scale\n#define pl 0.3    // divergence smoothing\n#define amp 1.0   // self-amplification\n#define upd 0.4   // update smoothing\n\n#define _D 0.6    // diagonal weight\n\n#define _K0 -20.0/6.0 // laplacian center weight\n#define _K1 4.0/6.0   // laplacian edge-neighbors\n#define _K2 1.0/6.0   // laplacian vertex-neighbors\n\n#define _G0 0.25      // gaussian center weight\n#define _G1 0.125     // gaussian edge-neighbors\n#define _G2 0.0625    // gaussian vertex-neighbors\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0) ? vec2(0.0) : normalize(x);\n}\n\n#define T(d) texture(iChannel0, fract(aUv+d)).xyz\n\nvec3 advect(vec2 ab, vec2 vUv, vec2 texel, out float curl, out float div, out vec3 lapl, out vec3 blur) {\n    \n    vec2 aUv = vUv - ab * texel;\n    vec4 t = vec4(texel, -texel.y, 0.0);\n\n    vec3 uv =    T( t.ww); vec3 uv_n =  T( t.wy); vec3 uv_e =  T( t.xw);\n    vec3 uv_s =  T( t.wz); vec3 uv_w =  T(-t.xw); vec3 uv_nw = T(-t.xz);\n    vec3 uv_sw = T(-t.xy); vec3 uv_ne = T( t.xy); vec3 uv_se = T( t.xz);\n    \n    curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + _D * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + _D * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    lapl = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    blur = _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    return uv;\n}\n\nvec2 rot(vec2 v, float th) {\n\treturn vec2(dot(v, vec2(cos(th), -sin(th))), dot(v, vec2(sin(th), cos(th)))); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec3 lapl, blur;\n    float curl, div;\n    \n    vec3 uv = advect(vec2(0), vUv, texel, curl, div, lapl, blur);\n\n    float sp = ps * lapl.z;\n    float sc = cs * curl;\n\tfloat sd = uv.z + dp * div + pl * lapl.z;\n    vec2 norm = normz(uv.xy);\n\n    vec2 off = uv.xy;\n    vec2 offd = off;\n    vec3 ab = vec3(0);\n\n    for(int i = 0; i < STEPS; i++) {\n        //advect(off, vUv, texel, curl, div, lapl, blur);\n        vec4 samp = texture(iChannel2, fract(vUv - off * texel));\n        curl = samp.w;\n        blur = samp.xyz;\n        offd = rot(offd,ts*curl);\n        off += offd;\n    \tab += blur / float(STEPS);  \n    }\n    \n    vec2 tab = amp * ab.xy + ls * lapl.xy + norm * sp + uv.xy * ds * sd;    \n    vec2 rab = rot(tab,sc);\n    \n    vec3 abd = mix(vec3(rab,sd), uv, upd);\n    \n    if (iMouse.z > 0.0) {\n    \tvec2 d = (fragCoord.xy - iMouse.xy) / iResolution.x;\n        vec2 m = 0.1 * normz(d) * exp(-length(d) / 0.02);\n        abd.xy += m;\n        uv.xy += m;\n    }\n    \n    // initialize with noise\n    if(uv == vec3(0) || reset()) {\n        vec3 rnd = vec3(noise(8.0 * vUv + 1.1), noise(8.0 * vUv + 2.2), noise(8.0 * vUv + 3.3));\n        fragColor = vec4(rnd, 0);\n    } else {\n        abd.z = clamp(abd.z, -1.0, 1.0);\n        abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n        fragColor = vec4(abd, 0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This computes the laplacian of the input\n\n#define _G0 0.25      // gaussian center weight\n#define _G1 0.125     // gaussian edge-neighbors\n#define _G2 0.0625    // gaussian vertex-neighbors\n\n#define _D 0.6    // diagonal weight\n\n#define T(d) texture(iChannel0, fract(vUv+d)).xyz\n\nvec4 curl_gaussian(vec2 fragCoord, vec2 iResolution) {\n    vec2 texel = 1.0 / iResolution;\n    vec2 vUv = fragCoord * texel;\n    vec4 t = vec4(texel, -texel.y, 0.0);\n\n    vec3 uv =    T( t.ww); vec3 uv_n =  T( t.wy); vec3 uv_e =  T( t.xw);\n    vec3 uv_s =  T( t.wz); vec3 uv_w =  T(-t.xw); vec3 uv_nw = T(-t.xz);\n    vec3 uv_sw = T(-t.xy); vec3 uv_ne = T( t.xy); vec3 uv_se = T( t.xz);\n    \n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + _D * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    vec3 gaussian = _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    return vec4(gaussian, curl);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = curl_gaussian(fragCoord, iResolution.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    \n/*\nU:\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-7.0606907e-001   4.6167731e-001  -1.4625093e-001\n-4.7194022e-001  -1.2936001e-001   1.1920299e-001\n-1.5871959e-001  -5.5398879e-001   1.1805352e-001\n-5.1257182e-002  -2.5511910e-001  -3.1508410e-001\n-1.3499238e-002  -6.8390049e-002  -4.8179728e-001\n-2.0540590e-003  -4.4125709e-003  -3.4489894e-001\n 1.9000778e-006   2.6484959e-003  -1.0391083e-001\n\nV:\n 6.2750203e-003  5.2398670e-002  3.7276962e-001  \n-1.6414278e-003  4.2486224e-002  5.4995743e-001\n-4.3498466e-002 -1.0892533e-001  2.4023362e-001\n-1.3135171e-001 -3.3953004e-001 -7.8265086e-004\n-3.0484343e-001 -5.0984393e-001  1.8311873e-002\n-6.2280256e-001  3.2918550e-001 -2.3270335e-002\n-5.8224388e-076  3.2916004e-064 -1.0109051e-055\n 6.2280256e-001 -3.2918550e-001  2.3270335e-002\n 3.0484343e-001  5.0984393e-001 -1.8311873e-002\n 1.3135171e-001  3.3953004e-001  7.8265088e-004  \n 4.3498466e-002  1.0892533e-001 -2.4023362e-001\n 1.6414278e-003 -4.2486224e-002 -5.4995743e-001\n-6.2750203e-003 -5.2398670e-002 -3.7276962e-001\n\ndiag(S):\n\n  5.2045614e-001\n  4.5787111e-002\n  5.3607463e-003\n  1.3379961e-003\n  2.4305267e-005\n  6.5520767e-008\n  2.7241624e-013\n  1.8098574e-013\n  4.2556708e-014\n  3.2104951e-014\n  5.6655005e-016\n  2.1958056e-018\n  1.0637097e-030\n\n*/\n\n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n    \n    #define Po(m,n) texture(iChannel0, fract(uv + texel * vec2(m,n)))\n    \n    vec2 P1 = vec2(0);\n    vec2 P2 = vec2(0);\n    vec2 P3 = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n\n        vec2 t = Po(i,0).xy;\n        float g = texture(iChannel1, fract(uv + texel * vec2(i,0))).x;\n        \n        P1 += vec2(p_x1[index], p_y1[index]) * t;\n        P2 += vec2(p_x2[index], p_y2[index]) * t;\n        P3 += vec2(p_x3[index], p_y3[index]) * t;\n        \n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n    \n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(pack(P1),pack(P2),pack(P3), G);\n    }\n\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "bool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy;\n    \n    float p_y3[13] = float[](-1.0391083e-001, -3.4489894e-001, -4.8179728e-001, -3.1508410e-001,  1.1805352e-001,  1.1920299e-001, -1.4625093e-001,  1.1920299e-001,  1.1805352e-001, -3.1508410e-001, -4.8179728e-001, -3.4489894e-001, -1.0391083e-001);\n \tfloat p_y2[13] = float[](2.6484959e-003, -4.4125709e-003, -6.8390049e-002, -2.5511910e-001, -5.5398879e-001, -1.2936001e-001, 4.6167731e-001, -1.2936001e-001, -5.5398879e-001, -2.5511910e-001, -6.8390049e-002, -4.4125709e-003, 2.6484959e-003);\n    float p_y1[13] = float[](1.9000778e-006, -2.0540590e-003, -1.3499238e-002, -5.1257182e-002, -1.5871959e-001, -4.7194022e-001, -7.0606907e-001, -4.7194022e-001, -1.5871959e-001, -5.1257182e-002, -1.3499238e-002, -2.0540590e-003,  1.9000778e-006);\n\n    float p_x3[13] = float[](3.7276962e-001,  5.4995743e-001,  2.4023362e-001, -7.8265086e-004,  1.8311873e-002, -2.3270335e-002, -1.0109051e-055,  2.3270335e-002, -1.8311873e-002,  7.8265088e-004, -2.4023362e-001, -5.4995743e-001, -3.7276962e-001);\n    float p_x2[13] = float[](5.2398670e-002,  4.2486224e-002, -1.0892533e-001, -3.3953004e-001, -5.0984393e-001,  3.2918550e-001,  0.0, -3.2918550e-001,  5.0984393e-001,  3.3953004e-001,  1.0892533e-001, -4.2486224e-002, -5.2398670e-002);\n    float p_x1[13] = float[](6.2750203e-003, -1.6414278e-003, -4.3498466e-002, -1.3135171e-001, -3.0484343e-001, -6.2280256e-001, 0.0, 6.2280256e-001, 3.0484343e-001, 1.3135171e-001, 4.3498466e-002, 1.6414278e-003, -6.2750203e-003);\n        \n    float s_i[3] = float[](  5.2045614e-001, 4.5787111e-002, 5.3607463e-003);\n    \n    float g_x[13] = float[](1.8154960e-002, 5.1439053e-002, 1.1757498e-001, 2.2045309e-001, 3.4292702e-001, 4.4580513e-001, \n         4.8633287e-001, 4.4580513e-001, 3.4292702e-001, 2.2045309e-001, 1.1757498e-001, 5.1439053e-002, 1.8154960e-002);  \n\n    #define RANGE 6\n    \n    #define Po(m,n) texture(iChannel0, fract(uv + texel * vec2(m,n)))\n    \n    vec2 P = vec2(0);\n    float G = 0.0;\n    float Gw = 0.0;\n    for (int i = -RANGE; i <= RANGE; i++) {\n        int index = RANGE + i;\n        \n        vec4 tx = Po(0,i);\n        vec2 t1 = unpack(tx.x);\n        vec2 t2 = unpack(tx.y);\n        vec2 t3 = unpack(tx.z);\n\n        float g = tx.w;\n        \n        P += s_i[0] * vec2(p_x1[index], p_y1[index]).yx * t1;\n        P += s_i[1] * vec2(p_x2[index], p_y2[index]).yx * t2;\n        P += s_i[2] * vec2(p_x3[index], p_y3[index]).yx * t3;\n        Gw += g_x[index];\n        G  += g_x[index] * g;\n    }\n    \n    G /= Gw;\n\n    if(reset()) {\n        fragColor = vec4(0);\n    } else {\n        fragColor = vec4(-(P.x + P.y) + G);\n    }\n\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// For normalized fixed-point packing\n//#define unpack(x) unpackSnorm2x16(floatBitsToUint(x))\n//#define pack(x) uintBitsToFloat(packSnorm2x16(x))\n\n#define pack(d) uintBitsToFloat(packHalf2x16(d))\n#define unpack(d) unpackHalf2x16(floatBitsToUint(d))\n\n\n// contrast\n#define SIGMOID_CONTRAST 20.0\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec3 normz(vec3 x) {\n\treturn x == vec3(0) ? vec3(0) : normalize(x);\n}\n\n// Begin IQ's simplex noise:\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n// End IQ's simplex noise\n\n\n// GGX from noby's Goo shader https://www.shadertoy.com/view/lllBDM\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyzD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2070, 2070, 2126, 2126, 4600]], "test": "untested"}
{"id": "WtVyWy", "name": " hplus 2021", "author": "Alkama", "description": "Livecoded during \"Shader Royale\" @ HogmanayParty demoparty (that happened at new years eve 2021).\n30 more minutes of polish are added.\n\nTribute to the \"hplus / Halcyon\" 64kb intro.\nhttps://www.pouet.net/prod.php?which=115\n", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 8, "viewed": 539, "published": 3, "date": "1611691365", "time_retrieved": "2024-07-30T19:42:19.836559", "image_code": "const float pi = acos(-1.0);\n\nfloat t=0.0, g=0.0;\nint mat=0;\n\n#define sat(a) clamp(a,0.,1.)\n#define rep(p,r) (mod(p,(r))-(r)*.5)\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\n\nfloat box(vec3 p, vec3 s) {\n    vec3 b=abs(p)-s*.5;\n    return length(max(b,0.0)) + min(0.0, max(max(b.x, b.y), b.z));\n}\n\nvec2 moda(vec2 p, float r) {\n    r = 2.0*pi/r;\n    float a= mod(atan(p.y, p.x), r) - r*0.5;\n    return vec2(cos(a), sin(a)) * length(p);\n}\n\nfloat hash(float a) { return fract(sin(a*2958.9281)*5493.913); }\n\nvec3 tex(vec3 p) {\n    const float s = 0.2;\n    const float s2 = 0.005;\n    const float it = 10.;\n    float c = 0.0;\n    for(float i=1.0; i<it+1.0; i++) {\n        float h = 5.0*hash(i);\n        vec3 v = vec3(fract(     h*i+h*p.x),\n                      fract(0.50*h*i+h*p.y),\n                      fract(0.75*h*i+h*p.z));\n        float l=s-s2*h;\n        float r=s+s2*h;\n    \n        float a = 1.0;\n        a *= smoothstep(l,r,v.x)*smoothstep(l,r,1.0-v.x);\n        a *= smoothstep(l,r,v.y)*smoothstep(l,r,1.0-v.y);\n        a *= smoothstep(l,r,v.z)*smoothstep(l,r,1.0-v.z);\n        c += a/it;\n    }\n    return vec3(sat(c));\n}\n\nfloat city(vec3 p) {\n    p.y+=25.0;\n    float d=10000.0;\n    float s=1.5;\n    float ss=s-0.15;\n    vec2 id=floor(p.xz/s);\n    float den = texture(iChannel0, id*0.001).r;\n    den=pow(den, 2.0)*0.4+.1;\n    float h=pow(10.0*den, 3.0)+sin(t*2.0+id.x*id.y*0.01);\n    p.xz=rep(p.xz,s);\n    d = min(d,box(p, vec3(ss,h,ss)));\n    return d;\n}\n\nfloat hplus(vec3 p) {\n    vec3 pp=p;\n    const float s = .3;\n    p.xz *= rot(.25*pi);\n    p.xz = moda(p.xz, 4.);\n    p -= .1*(tex(pp*.4)-.5);\n    float o = box(p, vec3(2.,.8,2.));\n    o = min(o, box(p-vec3(1.5,0,0), vec3(3,s,s)));\n    o = min(o, box(p-vec3(2.8,0,0), vec3(1.4,.8,1.)));\n    return o;\n}\n\nfloat pawtickles(vec3 p) {\n    vec3 pp = p;\n    pp.xz *= rot(.25*pi);\n    pp.xz = moda(pp.xz, 4.);\n    float o = length(vec3(mod(pp.x+3.0*fract(t*2.0),3.0)-1.5, pp.y, pp.z))-0.05;\n    float a = sin(2.0*sin(t*2.0))*sin(t+pp.x*pp.z*(10.0*fract(t*2.0)));\n    g+=1.0/(0.01+pow(abs(o),2.0)*(10.0+9.7*a));\n    return o;\n}\n\nfloat scene(vec3 p) {\n    float d = 10000.;\n    p.xz *= rot(t*.25);\n    vec3 pp=p;\n    float a = pow(sin(2.0*sin(t*2.0)), 2.0);\n    pp.xz *= rot(a*0.05*sin(3.0*(p.y+t*10.0)));\n    pp.yz *= rot(a*0.05*sin(2.0*(p.x+t*6.0)));\n\n    float o = hplus(pp);\n    if(o<d) { d=o;mat=1; }\n\n    float ptk=pawtickles(p);\n    d = min(d,max(ptk, .1));\n\n    float c = city(p);\n    if(c<d) { d=c;mat=2; }\n\n    return d;\n}\n\nvec3 march(vec3 o, vec3 rd, float tr, float md) {\n    float d=0.0;\n    float ii=0.0;\n    for(float i=0.0; i<100.0; i++) {\n        float h=scene(o+rd*d)*0.8;\n        if(abs(h)<tr) return vec3(d,i,1.0);\n        if(d>md) return vec3(d,i,0.0);\n        d+=h;\n        ii=i;\n    }\n    return vec3(d,ii,0.0);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e=vec2(0.01,0.0);\n    return normalize(scene(p)-vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n  \n    t=mod(iTime, 20.0*pi);\n    uv *= 1. - length(uv)*.25;\n    vec3 eye = 4.5*vec3(1.,.6+.4*sin(t),-1.);\n    eye.xz+= 2.*vec2(sin(t), cos(t));\n    vec3 tg = vec3(0);\n    vec3 f=normalize(tg-eye);\n    vec3 s=normalize(cross(vec3(-.25+.5*sin(t),1,0), f));\n    vec3 u=normalize(cross(f, s));\n    vec3 dir=normalize(f*.6+uv.x*s+uv.y*u);\n  \n    vec3 lp = vec3(3);\n    lp.xyz-= 3.*vec3(sin(t), cos(t), cos(t));\n\n    vec3 col = vec3(0);\n    float ddd = 0.0;\n\n    vec3 m = march(eye, dir, .001, 500.);\n    ddd = m.x;\n    if(m.z == 1.0) {\n        vec3 p = eye+dir*m.x;\n        vec3 n=normal(p);\n        vec3 ld=normalize(lp-p);\n        float diff = (abs(dot(n, ld)));\n        float spec = (pow(abs(dot(dir, reflect(ld, n))), 30.0));\n        float fres = sat(pow(max(0.0, 1.0-dot(n, -dir)), 1.0));\n        if(mat == 1) {\n            col += sat(vec3(diff+spec)*fres);\n        }\n        if(mat == 2) {\n          col += 0.005*vec3(spec)*acos(-dir);\n        }\n        col *= pow(m.y/50., 2.);\n    } else {\n        col += smoothstep(0.,.3,dir.y+.07)*acos(-dir);\n    }\n    col += acos(-dir)*g*.01;\n    fragColor.rgb = pow(col, vec3(1./2.2));\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 148, 148, 198], [200, 200, 227, 227, 320], [322, 322, 350, 350, 460], [462, 462, 483, 483, 526], [528, 528, 546, 546, 1151], [1153, 1153, 1173, 1173, 1486], [1488, 1488, 1509, 1509, 1789], [1791, 1791, 1817, 1817, 2106], [2108, 2108, 2129, 2129, 2510], [2512, 2512, 2561, 2561, 2814], [2816, 2816, 2837, 2837, 2951], [2953, 2953, 3010, 3010, 4247]], "test": "untested"}
{"id": "WtVyWG", "name": "DEUTSCHLAND", "author": "aragorn38male", "description": "DEUTSCHLAND", "tags": ["deutschland"], "likes": 0, "viewed": 257, "published": 3, "date": "1611678281", "time_retrieved": "2024-07-30T19:42:20.664346", "image_code": "// Rubino Marc - 2021\n// https://www.youtube.com/channel/UC4QabYdHqsMLv1WiwtYRzRw\n// DEUTSCHLAND\n\nfloat pas = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 r = vec3(1.0,0.0,0.0);\n    vec3 g = vec3(0.0,1.0,0.0);\n    \n    vec3 col = vec3(0.);\n    \n    pas += 0.33;\n    float cr = step(pas,1.-uv.y);\n    col = vec3(cr*r);\n    fragColor = vec4(col,1.0);\n    \n    pas += 0.33;\n    float cg = step(pas,1.-uv.y);\n    col = vec3(cg*g);\n    fragColor += vec4(col,1.0);\n}", "image_inputs": [{"id": 25322, "src": "https://soundcloud.com/user-398813764/k0pixjgcmojv", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 173, 173, 528]], "test": "untested"}
{"id": "wlyyDy", "name": "ripple_", "author": "YitingLiu", "description": "Attempt to create ripple effects using simple noise. ", "tags": ["noise", "circles", "lines", "perlin", "mod", "ripple", "simplenoise", "permute"], "likes": 6, "viewed": 368, "published": 3, "date": "1611672921", "time_retrieved": "2024-07-30T19:42:21.415338", "image_code": "vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 2.374 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n    vec2 pos = vec2(st*3.);\n\n    float DF = 0.0;\n\n    // Add a random position\n    float a = 0.0;\n    vec2 vel = vec2(iTime*0.532);\n    DF += snoise(pos+vel*random(st-vel-pos)/1e6)*atan(sin(iTime)-0.0005,0.00005+cos(iTime))+sin(iTime*0.01);\n    DF += snoise(pos+vel/random(st-vel+pos)/1e4)*atan(cos(iTime)+0.0005,0.960+cos(iTime))+sin(iTime*0.001);\n\n    // Add a random position\n    a = snoise(pos*vec2(cos(iTime*0.726),sin(iTime*1.004))*1.268)*3.1415;\n    vel = vec2(cos(a),sin(a));\n    DF += snoise(pos+vel-st)*abs(sin(iTime/1e3))+-2.206;\n\n    color = vec3( smoothstep(1.004,0.950,fract(DF+atan(pos.y,pos.x))));\n\n    fragColor = vec4(1.0-color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 68], [69, 69, 90, 90, 137], [138, 138, 160, 160, 195], [197, 197, 219, 219, 1256], [1258, 1258, 1282, 1282, 1389], [1391, 1391, 1449, 1449, 2215]], "test": "untested"}
{"id": "wlGcWy", "name": "Basic \"plane marcher\"", "author": "mrange", "description": "Licence CC0: Simple plane marcher\nI had fun messing around with \"plane marching\"\n\nThought others might appreciate a basic \"plane marcher\" to play around with", "tags": ["2d", "3d", "planes"], "likes": 12, "viewed": 444, "published": 3, "date": "1611670415", "time_retrieved": "2024-07-30T19:42:22.183285", "image_code": "// Licence CC0: Simple plane marcher\n//  I had fun messing around with \"plane marching\"\n//  While not right to produce photo-realistic shaders you \n//  create some pretty interesting effects with them\n//  Thought others might appreciate a basic \"plane marcher\"\n//  to play around with\n\n// -----------------------------------------------------------------------------\n// COMMON\n// -----------------------------------------------------------------------------\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// -----------------------------------------------------------------------------\n// PATH\n// -----------------------------------------------------------------------------\n\n// The path function\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\n// The derivate of the path function\n//  Used to generate where we are looking\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\n// The second derivate of the path function\n//  Used to generate tilt\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE MARCHER\n// -----------------------------------------------------------------------------\n\n// Plane generating function returns rgba\n//  pp is point on plane\n//  off is path at plane z\n//  aa is estimated pixel size at the plane\n//  n is plane number\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h);\n  const float lw = 0.005;\n  float d = hex(p/s, 0.5)*s;   \n  float dd = abs(d) - lw;\n\n  float a  = smoothstep(-aa, aa, -dd);\n  float ha = smoothstep(-aa, aa, d+lw);\n\n  vec4 col = vec4(mix(vec3(1.0-tanh_approx(15.0*length(p))), vec3(0.0), a), ha);\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return vec3(tanh_approx(3.0*pow(ld, 100.0)));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.75;\n  const int furthest = 11;\n  const int fadeFrom = max(furthest-6, 0);\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = exp(-2.5*max((nz - planeDist*float(fadeFrom))/fadeDist, 0.0));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\n// Classic post processing\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.4;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[709, 709, 731, 731, 779], [781, 781, 821, 821, 980], [982, 982, 1022, 1022, 1064], [1066, 1066, 1094, 1114, 1190], [1192, 1192, 1219, 1219, 1288], [1290, 1290, 1318, 1318, 1518], [1520, 1520, 1551, 1551, 1577], [1750, 1771, 1793, 1793, 1927], [1929, 2008, 2031, 2031, 2106], [2108, 2178, 2202, 2202, 2281], [2463, 2623, 2691, 2691, 3082], [3084, 3084, 3117, 3117, 3220], [3222, 3222, 3278, 3278, 4816], [4818, 4845, 4881, 4881, 5114], [5116, 5116, 5145, 5145, 5471], [5473, 5473, 5528, 5528, 5686]], "test": "untested"}
{"id": "wlyyRW", "name": "T_Plotting", "author": "Thalikoth", "description": "plotting test", "tags": ["plotplotting"], "likes": 1, "viewed": 237, "published": 3, "date": "1611669226", "time_retrieved": "2024-07-30T19:42:22.928293", "image_code": "\n#define PI 3.14159265359\n\n\nfloat noise(float x) {\n    return fract(sin(x)*345.456);\n}\n\nfloat noise(vec2 x) {\n    return fract(sin(dot(x, vec2(2234.456, 1567.789)))*423.234);\n}\n\n// smooth gradient noise\nfloat grNoise(float x, float k) {\n\n    x *= k;\n    \n    // get integer / fractional parts\n    float i = floor(x);\n    float f = fract(x);\n\n    // smooth interpolation\n    float n1 = noise(i); \n    float n2 = noise(i+1.);\n    return mix(n1, n2, smoothstep(0., 1., f));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat noiseLine(vec2 uv) {\n    uv.y -= grNoise(uv.x + iTime, 2. + sin(iTime*0.002));\n    \n    return smoothstep(0.02, 0., uv.y) -\n            smoothstep(0., -0.02, uv.y);\n    \n}\n\nfloat sineLine(vec2 uv) {\n    uv.y += .6;\n    uv.x += iTime / .9;\n    uv.y -= sin(uv.x * 6.) / 5.;\n    \n    return smoothstep(0.02, 0., uv.y) -\n            smoothstep(0., -0.02, uv.y);\n    \n}\n\nfloat axis(vec2 uv) {\n    float y = smoothstep(0.005, 0., uv.y) -\n            smoothstep(0., -0.005, uv.y);\n    float x = smoothstep(0.005, 0., uv.x) -\n            smoothstep(0., -0.005, uv.x);\n    return x + y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y *= iResolution.y / iResolution.x;\n\n    uv *= 5.;\n\n    vec3 col = vec3(0.);\n    \n    \n    \n    col = vec3(axis(uv));\n    col.r = noiseLine(uv);\n    col.b = sineLine(uv);\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 50, 50, 86], [88, 88, 109, 109, 176], [178, 203, 236, 236, 472], [474, 474, 504, 504, 588], [590, 590, 616, 616, 767], [769, 769, 794, 794, 960], [962, 962, 983, 983, 1175], [1178, 1178, 1235, 1285, 1565]], "test": "untested"}
{"id": "wtycWG", "name": "Antialiased Bezier Fill (no SDF)", "author": "Lichtso", "description": "Using implicit bezier curves, not signed distance fields.\n\nBased on:\nLOOP, Charles; BLINN, Jim. Resolution independent curve rendering using programmable graphics hardware.\nIn: ACM SIGGRAPH 2005 Papers. 2005. S. 1000-1009.", "tags": ["2d", "bezier"], "likes": 4, "viewed": 448, "published": 3, "date": "1611655460", "time_retrieved": "2024-07-30T19:42:23.752090", "image_code": "vec3 cartesian_to_barycentric_2d(in vec2[3] t, in vec2 p) {\n    vec2 t1t2 = t[1]-t[2];\n    vec2 t2t0 = t[2]-t[0];\n    vec2 pt2 = p-t[2];\n    float determ = -dot(vec2(t1t2.y, -t1t2.x), t2t0);\n    float a = dot(vec2(t1t2.y, -t1t2.x), pt2)/determ;\n    float b = dot(vec2(t2t0.y, -t2t0.x), pt2)/determ;\n    return vec3(a, b, 1.0-a-b);\n}\n\nvec2 barycentric_to_cartesian_2d(in vec2[3] t, in vec3 p) {\n    return t[0]*p[0] + t[1]*p[1] + t[2]*p[2];\n}\n\nvec3 barycentric_to_cartesian_3d(in vec3[3] t, in vec3 p) {\n    return t[0]*p[0] + t[1]*p[1] + t[2]*p[2];\n}\n\nvec4 barycentric_to_cartesian_4d(in vec4[3] t, in vec3 p) {\n    return t[0]*p[0] + t[1]*p[1] + t[2]*p[2];\n}\n\nfloat quadratic_bezier(in vec2 weights) {\n    float value = weights.x*weights.x - weights.y;\n    vec2 weights_dx = dFdx(weights);\n    vec2 weights_dy = dFdy(weights);\n    vec2 derivative = mat2(\n        weights_dx.x, weights_dy.x,\n        weights_dx.y, weights_dy.y\n    ) * vec2(\n        2.0*weights.x,\n        -1.0\n    );\n    return 0.5 - value/length(derivative);\n}\n\nfloat rational_quadratic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        2.0*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5 - value/length(derivative);\n}\n\nfloat cubic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        3.0*weights.x*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5 - value/length(derivative);\n}\n\nfloat rational_cubic_bezier(in vec4 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z*weights.w;\n    vec4 weights_dx = dFdx(weights);\n    vec4 weights_dy = dFdy(weights);\n    vec4 derivative = mat4(\n        weights_dx.x, weights_dy.x, 0.0, 0.0,\n        weights_dx.y, weights_dy.y, 0.0, 0.0,\n        weights_dx.z, weights_dy.z, 0.0, 0.0,\n        weights_dx.w, weights_dy.w, 0.0, 0.0\n    ) * vec4(\n        3.0*weights.x*weights.x,\n        -(weights.z*weights.w),\n        -(weights.y*weights.w),\n        -(weights.y*weights.z)\n    );\n    return 0.5 - value/length(derivative);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 triangle[] = vec2[](\n        vec2(600.0, 10.0),\n        iMouse.xy,\n        vec2(sin(iTime)*500.0+600.0, cos(iTime)*300.0+400.0)\n    );\n    vec3 weights[] = vec3[](\n        vec3(0.0, 0.0, 1.0),\n        vec3(0.5*sqrt(2.0), 0.0, sqrt(2.0)),\n        vec3(1.0, 1.0, 1.0)\n    );\n    vec3 bary = cartesian_to_barycentric_2d(triangle, fragCoord);\n    if(bary.x < -0.1 || bary.y < 0.0 || bary.z < -0.1) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        vec3 w = barycentric_to_cartesian_3d(weights, bary);\n        float alpha = rational_quadratic_bezier(w);\n        fragColor = vec4(vec3(clamp(alpha, 0.0, 1.0)), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[661, 661, 702, 702, 1028], [1030, 1030, 1080, 1080, 1493], [1495, 1495, 1532, 1532, 1965], [1967, 1967, 2013, 2013, 2573]], "test": "untested"}
{"id": "ttGyWG", "name": "RGB - SWIRL", "author": "aragorn38male", "description": "My first !!!", "tags": ["swirl", "rgb"], "likes": 3, "viewed": 359, "published": 3, "date": "1611646208", "time_retrieved": "2024-07-30T19:42:24.514053", "image_code": "// Rubino Marc - 2021\n// https://www.youtube.com/channel/UC4QabYdHqsMLv1WiwtYRzRw\n// RGB - SWIRL\n\n#define TWO_PI 6.28318530718\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n       vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.x,toCenter.y);\n    float radius = length(toCenter)*2.0;\n\n    color = hsb2rgb(vec3((angle/TWO_PI)+sin(iTime),radius-.7,1.0));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 154, 154, 387], [389, 389, 445, 445, 747]], "test": "untested"}
{"id": "3lGcWy", "name": "derivative of a derivative", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/ltfSWn[/url]", "tags": ["3d", "raymarching", "fractal", "distancefield", "remix", "glitch", "derivative", "fork", "edit"], "likes": 1, "viewed": 291, "published": 3, "date": "1611635563", "time_retrieved": "2024-07-30T19:42:25.269034", "image_code": "//Remixer:404Glaciergargamel\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 3  // make AA 1 for slow machines or 3 for fast machines\n#endif\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.1 ) return vec2(-2.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 2.0; \n\tfor( int i=1; i<5; i++ )\n    {\n#if 1\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 9.0*sqrt(m4*m2*m)*dz + 2.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 7.0*y2*z2 - 7.0*x2*y2 + 3.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  74.0*x*y*z*(x2-z2)*k4*(x4-7.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -26.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -9.0*y*k4*(x4*x4 - 38.0*x4*x2*z2 + 80.0*x4*z4 - 38.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 9.0*pow(sqrt(m),8.0)*dz + 2.0;\n\t\tdz = 9.0*pow(m,4.5)*dz + 2.0;\n        float r = length(w);\n        float b = 9.0*acos( w.y/r);\n        float a = 9.0*atan( w.x, w.z );\n        w = p + pow(r,9.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        trap = min( trap, vec4(abs(w),m) );\n        m = dot(w,w);\n\t\tif( m > 356.0 )\n            break;\n    }\n    resColor = vec4(m,trap.yzw);\n    return 0.35*log(m)*sqrt(m)/dz;\n}\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -2.0;\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.1,0.1,0.1,2.25), ro, rd );\n    if( dis.y<0.1 )\n        return -2.0;\n    dis.x = max( dis.x, 0.1 );\n    dis.y = min( dis.y, 20.0 );\n    // raymarch fractal distance field\n\tvec4 trap;\n\tfloat t = dis.x;\n\tfor( int i=1; i<228; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.35*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    } \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n    return res;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 2.0;\n    float t = 0.1;\n    for( int i=1; i<74; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.002 ) break;\n        t += clamp( h, 0.02, 0.3 );\n    }\n    return clamp( res, 0.1, 2.0 );\n}\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(2.0,-2.0)*0.6773*0.35*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\nconst vec3 light1 = vec3(  0.677, 0.677, -0.677 );\nconst vec3 light2 = vec3( -0.807, 0.001,  0.807 );\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 2.5;\n    vec2  sp = (3.0*p-iResolution.xy) / iResolution.y;\n    float px = 3.0/(iResolution.y*fle);\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.1)).xyz );\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n\tvec3 col;\n    // color sky\n    if( t<0.1 )\n    {\n     \tcol  = vec3(0.9,1.0,2.1)*(0.7+0.5*rd.y);\n\t\tcol += 6.0*vec3(0.9,0.8,0.6)*pow( clamp(dot(rd,light1),0.1,2.0), 42.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.02);\n\t\tcol = mix( col, vec3(0.20,0.30,0.40), clamp(tra.y,0.1,2.0) );\n\t \tcol = mix( col, vec3(0.03,0.20,0.40), clamp(tra.z*tra.z,0.1,2.0) );\n        col = mix( col, vec3(0.40,0.20,0.03), clamp(pow(tra.w,7.0),0.1,2.0) );\n        col *= 0.6;\n\t\tcol = vec3(0.2);\n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.06*log(tra.x),0.1,2.0);\n        float fac = clamp(2.0+dot(rd,nor),0.1,2.0);\n        // sun\n        float sha1 = softshadow( pos+0.002*nor, light1, 42.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.1, 2.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.1,2.0), 42.0 )*dif1*(0.05+1.06*pow(clamp(2.0-dot(hal,light1),0.1,2.0),6.0));\n        // bounce\n        float dif2 = clamp( 0.6 + 0.6*dot( light2, nor ), 0.1, 2.0 )*occ;\n        // sky\n        float dif3 = (0.8+0.4*nor.y)*(0.3+0.9*occ);\n\t\tvec3 lin = vec3(0.1); \n\t\t     lin += 8.0*vec3(2.50,2.10,0.80)*dif1;\n\t\t     lin += 5.0*vec3(0.35,0.30,0.25)*dif2;\n        \t lin += 2.5*vec3(0.20,0.30,0.40)*dif3;\n             lin += 3.5*vec3(0.45,0.40,0.35)*(0.06+1.05*occ); // ambient\n        \t lin += 5.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.8,1.0,2.0) );                  // fake SSS\n        col += spe1*25.0;\n        col += 9.0*vec3(0.9,1.0,2.0)*(0.3+0.9*occ)*(0.04+1.07*pow(fac,6.0))*smoothstep(0.1,0.2,ref.y )*softshadow( pos+0.02*nor, ref, 3.0 );\n        col = vec3(occ*occ);\n    }\n    // gamma\n\tcol = sqrt( col );\n    // vignette\n    col *= 2.0 - 0.06*length(sp);\n    return col;\n}   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.2;\n    // camera\n\tfloat di = 2.4+0.2*cos(.39*time);\n\tvec3  ro = di*vec3( cos(.43*time), 0.9*sin(.47*time), sin(.41*time) );\n\tvec3  ta = vec3(0.1,0.2,0.1);\n\tfloat cr = 0.6*cos(0.2*time);\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.1);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.1, 0.1, 0.1, 2.0 );\n    // render\n    #if AA<3\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,1))\n    vec3 col = vec3(0.1);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\tfragColor = vec4( col, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 198, 198, 393], [394, 394, 437, 437, 1677], [1678, 1678, 1749, 1749, 2293], [2294, 2294, 2350, 2350, 2624], [2625, 2625, 2682, 2682, 2913], [3016, 3016, 3055, 3069, 5277], [5281, 5281, 5338, 5338, 6126]], "test": "untested"}
{"id": "WtGcWy", "name": "Cube Roots of a Complex Number", "author": "oneshade", "description": "Using De Moivre's formula to calculate the three cube roots of a complex number. Drag with mouse to change z.", "tags": ["complex", "polar", "formula", "demoivre", "cuberoot"], "likes": 5, "viewed": 179, "published": 3, "date": "1611635026", "time_retrieved": "2024-07-30T19:42:26.286314", "image_code": "#define HALF_PI 1.57079632679\n#define COS_120 -0.5\n#define SIN_120 0.86602540378\n\n// Container for 3 complex numbers\nstruct Complex3 {\n    vec2 a;\n    vec2 b;\n    vec2 c;\n};\n\nComplex3 complexCuberoot(in vec2 z) {\n    // De Moivre's formula\n    vec2 r = sin(atan(z.y, z.x) / 3.0 + vec2(HALF_PI, 0.0)) * pow(length(z), 1.0 / 3.0);\n    return Complex3(r,\n                    r * mat2(COS_120,  SIN_120, -SIN_120, COS_120),  // Rotate +120 degrees\n                    r * mat2(COS_120, -SIN_120,  SIN_120, COS_120)); // Rotate -120 degrees\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Draw grid\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(mod(uv.y + 0.125, 0.25) - 0.125)));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(mod(uv.x + 0.125, 0.25) - 0.125)));\n\n    // Draw axes\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.y)));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.x)));\n\n    // Complex number (demo if no mouse)\n    vec2 z = vec2(sin(iTime * 1.25) * 2.0, cos(iTime * 0.5));\n    if (iMouse.z > 0.0) {\n        z = (iMouse.xy - screenCenter) / iResolution.y * 4.0;\n    }\n\n    // Find cube roots of z and plot\n    Complex3 cbrt = complexCuberoot(z);\n\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - z) - 0.05));\n\n    color = mix(color, vec3(1.0, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - cbrt.a) - 0.05));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - cbrt.b) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - cbrt.c) - 0.05));\n\n    // Draw \"z\" character\n    vec4 zTexBbox = vec4(0.625, 0.5, 0.6875, 0.5625);\n    vec4 zScrBbox = vec4(-0.15, 0.1, 0.15, 0.4);\n\n    zScrBbox.xy += z;\n    zScrBbox.zw += z;\n\n    if (all(lessThan(uv, zScrBbox.zw)) && all(greaterThan(uv, zScrBbox.xy))) {\n        vec2 mappedUv = (uv - zScrBbox.xy) / (zScrBbox.zw - zScrBbox.xy) * (zTexBbox.zw - zTexBbox.xy) + zTexBbox.xy;\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, texture(iChannel0, mappedUv).w - 0.5));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 212, 239, 537], [539, 539, 594, 594, 2340]], "test": "untested"}
{"id": "3lVczd", "name": "CLOUD WATCHER", "author": "iY0Yi", "description": "My new look shader. It's almost developped accidentaly.\nThe sound is based on ttg's.\nhttps://www.shadertoy.com/view/4dlyWl\nThe basic performance algorithm is just a copy and paste of his shader.\nI made a few adjustments to make it fit my visuals.", "tags": ["clouds", "cineshader"], "likes": 15, "viewed": 1255, "published": 3, "date": "1611620012", "time_retrieved": "2024-07-30T19:42:27.265696", "image_code": "////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  .-----..-.            .--. .-.                 .-.        .-.   .-.       .-.      .-.                //\n//  `-. .-': :           : .--': :                 : :        : :.-.: :      .' `.     : :                //\n//    : :  : `-.  .--.   : :   : :   .--. .-..-. .-' : .--.   : :: :: : .--. `. .'.--. : `-.  .--. .--.   //\n//    : :  : .. :' '_.'  : :__ : :_ ' .; :: :; :' .; :`._-.'  : `' `' ;' .; ; : :'  ..': .. :' '_.': ..'  //\n//    :_;  :_;:_;`.__.'  `.__.'`.__;`.__.'`.__.'`.__.'`.__.'   `.,`.,' `.__,_;:_;`.__.':_;:_;`.__.':_;    //\n//                                                                                                        //\n//                                                                                                        //\n//  \"The Clouds Watcher\" by iY0Yi                                                                         //\n//  https://www.shadertoy.com/view/3lVczd                                                                 //\n//                                                                                                        //\n//  Created by Atsushi Hashimoto 2021                                                                     //\n//  License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.                   //\n//                                                                                                        //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 tonemapACES(vec3 color){\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\n}\n\n// Interpolation funcs from:\n// https://www.shadertoy.com/view/MsXGDj\nfloat tcCatmullRom(float x, float v0,float v1, float v2,float v3){\n    if(abs(v1-v2)<.001)return v1; // edited\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n}\nfloat tcThirdOrderSpline(float x, float L1,float L0, float H0,float H1){\n\treturn \t\t  L0 +.5 *\n\t\t\tx * ( H0-L1 +\n\t\t\tx * ( H0 + L0 * -2.0 +  L1 +\n\t\t\tx * ((H0 - L0)* 9.0\t + (L1 - H1)*3.0 +\n\t\t\tx * ((L0 - H0)* 15.0 + (H1 - L1)*5.0 +\n\t\t\tx * ((H0 - L0)* 6.0\t + (L1 - H1)*2.0 )))));\n}\nfloat tcCubic(float x, float v0,float v1, float v2,float v3){\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\nfloat tcSmoothstep(float x, float v0, float v1, float v2,float v3){\n\tx = x*x*(3.0-2.0*x);\n\treturn (v2-v1)*x + v1;\n}\nfloat tcLinear(float x, float v0, float v1, float v2,float v3){\n\treturn (v2-v1)*x + v1;\n}\n\n#define INTP tcCatmullRom\n\nfloat fivePointToneCurve(float col, float low, float lmid, float mid, float hmid, float high){\n    float VU = -0.25+low;\n\tfloat V1 =  0.0 +low;\n\tfloat V2 =  0.25+lmid;\n\tfloat V3 =  0.5 +mid;\n\tfloat V4 =  0.75+hmid;\n\tfloat V5 =  1.0 +high;\n\tfloat VO =  1.25+high;\n\n\tif(col<.25)\n\t\treturn INTP( col*4.,      VU, V1, V2, V3);\n\telse if(col<.5)\n\t\treturn INTP((col-.25)*4., V1, V2, V3, V4);\n    else if(col<.75)\n\t\treturn INTP((col- .5)*4., V2, V3, V4, V5);\n\telse if(col<1.)\n\t\treturn INTP((col-.75)*4., V3, V4, V5, VO);\n    else\n        return 0.;\n}\n\nvec3 fivePointToneCurve(vec3 col, float low, float lmid, float mid, float hmid, float high){\n\tvec3 res;\n\tres.x = fivePointToneCurve(col.r, low, lmid, mid, hmid, high);\n\tres.g = fivePointToneCurve(col.g, low, lmid, mid, hmid, high);\n\tres.b = fivePointToneCurve(col.b, low, lmid, mid, hmid, high);\n\treturn res;\n}\n\nfloat dithering(float v, vec2 coord){\n\tv=pow(v, 8.);\n\tvec2 p = coord;\n\tp = mod(p.xx + vec2(p.y, -p.y), vec2(.1));\n\tfloat res=0.;\n\tvec2 coords = coord;\n\n\tcoords.y *= .75+.25*hash12(p);\n\tfloat rand_ditherVal = gfbm(coords*.75, 2, .5);\n\tconst float paletteDist = 1.15;\n\tres=v + (rand_ditherVal - .5) * paletteDist;\n\tres=smoothstep(0.1,1.,res);\n\tres=sat(floor(res*6.)/5.);\n\n\treturn res;\n}\n\nvec3 unpackRenderData(in vec2 fragCoord){\n\tvec4 packedData = texelFetch(iChannel0, ivec2(fragCoord/ERNST_RENDER_SCALE), 0);\n\trenDat.albedo = unpackU4(packedData.x).rgb;\n\trenDat.shadow = unpackU4(packedData.x).a;\n\trenDat.diffuse = s2u(unpackS3(packedData.y).r);\n\trenDat.specular = s2u(unpackS3(packedData.y).g);\n\trenDat.ao = s2u(unpackS3(packedData.y).b);\n\trenDat.normal = normalize(unpackS3(packedData.z));\n\trenDat.depth = packedData.w;\n\tfloat shade = sat(u2s(renDat.diffuse)) * renDat.shadow;\n\tshade += renDat.ao * .3;\n\trenDat.result = mix(vec3(0), renDat.albedo, shade);\n\trenDat.result += renDat.specular * renDat.shadow;\n\trenDat.result = tonemapACES(renDat.result);\n\trenDat.result = pow(renDat.result, vec3(1./2.2));\n\treturn renDat.result;\n}\n\n#define getBuf(co) texelFetch(iChannel0, ivec2((co)/ERNST_RENDER_SCALE), 0)\nvec3 getAlbedo(vec2 coord){\n    R(coord, u2s(hash11(floor(fract(iTime*.01)*100.)))*.0025);\n    #define alb(c) unpackU4(getBuf(mod(coord+c*ERNST_RENDER_SCALE, floor(iResolution.xy*.95))).x).rgb\n    vec3 c00 = alb(vec2( 0, 0));\n    vec3 cp0 = alb(vec2( 1, 0));\n    vec3 c0p = alb(vec2( 0, 1));\n    vec3 cpp = alb(vec2( 1, 1));\n    vec3 cn0 = alb(vec2(-1, 0));\n    vec3 c0n = alb(vec2( 0,-1));\n    vec3 cnn = alb(vec2(-1,-1));\n    vec3 cpn = alb(vec2( 1,-1));\n    vec3 cnp = alb(vec2(-1, 1));\n    #define dst(x) distance(x,c00)<.1\n    bool bp0 = dst(cp0);\n    bool b0p = dst(c0p);\n    bool bpp = dst(cpp);\n    bool bn0 = dst(cn0);\n    bool b0n = dst(c0n);\n    bool bnn = dst(cnn);\n    bool bpn = dst(cpn);\n    bool bnp = dst(cnp);\n    \n    vec2 uv = fract(coord*INV_ERNST_RENDER_SCALE);\n    uv=abs((uv)*2.);\n    \n    if(!bpp && hash12(floor(coord*INV_ERNST_RENDER_SCALE)+floor(iTime))<(.1+abs(sin(iTime*.01))*.25)){\n        return mix(c00, cpp, sms(1.92, 2., length(uv-vec2(1,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime))<.25){\n        return mix(c00, cnn, sms(1.92, 2., length(uv-vec2(0,0)*2.)));\n    }\n    \n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        return mix(c00, cp0, sms(1.92, 2., length(uv-vec2(0,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.xy*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        return mix(c00, c0n, sms(1.92, 2., length(uv-vec2(1,0)*2.)));\n    }\n    \n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.025+abs(sin(iTime*.01))*.05){\n        return alb(floor(hash22(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2)*10.)*10.));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.1))<.15+abs(sin(iTime*.01))*.15){\n        return mix(c00, c0n, sms(1.92, 2., length(uv*2.-2.)));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.5+abs(sin(iTime*.01))*.15){\n        return mix(c00, c0n, sms(1.92, 2., dot(uv,vec2(1))));\n    }\n    \n\treturn unpackU4(getBuf(coord).x).rgb;\n}\nvec3 getNormal(vec2 coord){\n\treturn normalize(unpackS3(getBuf(coord).z));\n}\nfloat getShadow(vec2 coord){\n    R(coord, u2s(hash11(floor(fract(iTime*.021)*100.)))*.0025);\n\tfloat res = unpackU4(getBuf(coord).x).a;\n    \n    #define sha(c) unpackU4(getBuf(mod(coord+c*ERNST_RENDER_SCALE, floor(iResolution.xy*.95))).x).a\n    float c00 = sha(vec2( 0, 0));\n    float cp0 = sha(vec2( 1, 0));\n    float c0p = sha(vec2( 0, 1));\n    float cpp = sha(vec2( 1, 1));\n    float cn0 = sha(vec2(-1, 0));\n    float c0n = sha(vec2( 0,-1));\n    float cnn = sha(vec2(-1,-1));\n    float cpn = sha(vec2( 1,-1));\n    float cnp = sha(vec2(-1, 1));\n    #define dstsh(x) abs(x-c00)<.1\n    bool bp0 = dstsh(cp0);\n    bool b0p = dstsh(c0p);\n    bool bpp = dstsh(cpp);\n    bool bn0 = dstsh(cn0);\n    bool b0n = dstsh(c0n);\n    bool bnn = dstsh(cnn);\n    bool bpn = dstsh(cpn);\n    bool bnp = dstsh(cnp);\n    \n    vec2 uv = fract(coord*INV_ERNST_RENDER_SCALE);\n    uv=abs((uv)*2.);\n    \n    if(!bpp && hash12(floor(coord*INV_ERNST_RENDER_SCALE)+floor(iTime))<(.1+abs(sin(iTime*.01))*.25)){\n        res = mix(c00, cpp, sms(1.92, 2., length(uv-vec2(1,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime))<.25){\n        res = mix(c00, cnn, sms(1.92, 2., length(uv-vec2(0,0)*2.)));\n    }\n    \n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, cp0, sms(1.92, 2., length(uv-vec2(0,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.xy*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv-vec2(1,0)*2.)));\n    }\n    \n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.025+abs(sin(iTime*.01))*.05){\n        res = sha(floor(hash22(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2)*10.)*10.));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.1))<.15+abs(sin(iTime*.01))*.15){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv*2.-2.)));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.5+abs(sin(iTime*.01))*.15){\n        return mix(c00, c0n, sms(1.92, 2., dot(uv, vec2(1,-1))));\n    }\n    \n    return res;\n}\nfloat getDepth(vec2 coord){\n\treturn getBuf(coord).w;\n}\n\nfloat getSpecular(vec2 coord){\n\treturn s2u(unpackS3(getBuf(coord).y).g);\n}\nfloat getAO(vec2 coord){\n\treturn s2u(unpackS3(getBuf(coord).y).b);\n}\nvec3 getSharpenNormal(in vec2 coord, float strength){\n\tvec3 sum = getNormal(coord)  *  9. +\n\tgetNormal(coord+vec2( 1, 0)) * -1. +\n\tgetNormal(coord+vec2( 1, 1)) * -1. +\n\tgetNormal(coord+vec2( 0, 1)) * -1. +\n\tgetNormal(coord+vec2(-1, 0)) * -1. +\n\tgetNormal(coord+vec2(-1,-1)) * -1. +\n\tgetNormal(coord+vec2( 0,-1)) * -1. +\n\tgetNormal(coord+vec2(-1, 1)) * -1. +\n\tgetNormal(coord+vec2( 1,-1)) * -1. ;\n\treturn mix(getNormal(coord), sum , strength);\n}\n\nfloat getDiffuse(vec2 coord){\nR(coord, u2s(hash11(floor(fract(iTime*.007)*100.)))*.0025);\n\tfloat res = s2u(unpackS3(getBuf(coord).y).r);\n    \n    \n    #define dif(c) s2u(unpackS3(getBuf(mod(coord+c*ERNST_RENDER_SCALE, floor(iResolution.xy*.95))).y).r)\n    float c00 = dif(vec2( 0, 0));\n    float cp0 = dif(vec2( 1, 0));\n    float c0p = dif(vec2( 0, 1));\n    float cpp = dif(vec2( 1, 1));\n    float cn0 = dif(vec2(-1, 0));\n    float c0n = dif(vec2( 0,-1));\n    float cnn = dif(vec2(-1,-1));\n    float cpn = dif(vec2( 1,-1));\n    float cnp = dif(vec2(-1, 1));\n    #define dstdf(x) abs(x-c00)<.1\n    bool bp0 = dstdf(cp0);\n    bool b0p = dstdf(c0p);\n    bool bpp = dstdf(cpp);\n    bool bn0 = dstdf(cn0);\n    bool b0n = dstdf(c0n);\n    bool bnn = dstdf(cnn);\n    bool bpn = dstdf(cpn);\n    bool bnp = dstdf(cnp);\n    \n    vec2 uv = fract(coord*INV_ERNST_RENDER_SCALE);\n    uv=abs((uv)*2.);\n    \n    if(!bpp && hash12(floor(coord*INV_ERNST_RENDER_SCALE)+floor(iTime))<(.1+abs(sin(iTime*.01))*.25)){\n        res = mix(c00, cpp, sms(1.92, 2., length(uv-vec2(1,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime))<.25){\n        res = mix(c00, cnn, sms(1.92, 2., length(uv-vec2(0,0)*2.)));\n    }\n    \n    \n    if(!bnn && hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, cp0, sms(1.92, 2., length(uv-vec2(0,1)*2.)));\n    }\n    \n    if(!bnn && hash12(floor(coord.xy*INV_ERNST_RENDER_SCALE)+floor(iTime*2.))<.25){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv-vec2(1,0)*2.)));\n    }\n    \n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2))<.025+abs(sin(iTime*.01))*.05){\n        res = dif(floor(hash22(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.2)*10.)*10.));\n    }\n    \n    if(hash12(floor(coord.yx*INV_ERNST_RENDER_SCALE)+floor(iTime*.1))<.15+abs(sin(iTime*.01))*.15){\n        res = mix(c00, c0n, sms(1.92, 2., length(uv*2.-2.)));\n    }\n    \n    res+=sms(.1,.8, gnoise(floor(coord*INV_ERNST_RENDER_SCALE)+floor(hash11(floor(iTime*.5)*1000.)*20.)))*.3;\n\treturn res;\n}\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2){\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(.3, .2, difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord){\n\tvec2 coords = coord;\n\tcoords += u2s(gfbm((coord+iResolution.xy*.15)*.1, 1, .5))*.5;\n\tvec3 offset = vec3(1, -1, 0) * u2s(max(1., 1.5*gfbm(coord*.1, 3, .5))) * .4;\n\toffset.xy += u2s(hash22(coord*vec2(321.,2144.)))*.5;\n\tfloat edge = 1.0;\n\tedge *= calcEdge(getNormal(coords+offset.xx), getNormal(coords+offset.yy));\n\tedge *= calcEdge(getNormal(coords+offset.xy), getNormal(coords+offset.yx));\n\tedge *= calcEdge(getNormal(coords+offset.zy), getNormal(coords+offset.zx));\n\tedge *= calcEdge(getNormal(coords+offset.yz), getNormal(coords+offset.xz));\n\treturn edge;\n}\n\nfloat getShadowEdge( vec2 coord ){\n\tvec2 coords = coord;\n\tfloat sha = getShadow(coords);\n\tsha -= .5;\n\tsha = abs(sha);\n\tsha = smoothstep(.1,.2,sha);\n\treturn sha;\n}\nfloat getDottedShadow(vec2 coord){\n\tvec2 uv = coord;\n\tuv *= mat2(cos(.8+vec4(0, 11, 33, 0)));\n\tuv = mod(uv*.25, 1.);\n\tfloat res = 0.;\n\tfloat shadow = getShadow(coord);\n\tshadow = max(.65,shadow*.85) + .35*getAO(coord);\n\tshadow = 1. - shadow;\n\tres = smoothstep(shadow, shadow+1., pow(length(uv-.5), 4.));\n\tres = smoothstep(.0, .2, pow(res, .05));\n\treturn res;\n}\n\nfloat hatching(vec2 coord, float tickness, float angle, float dark, float light, bool centered, float contrast){\n\tvec2 v = coord.xy / iResolution.xy;\n\tvec3 n = normalize(getNormal(coord));\n\tR(v, angle);\n\tif((distance(getAlbedo(coord), MAT_CLOUD)<.15)){\n\t    tickness *=.5;\n\t}\n\t\n\tv.y = mod(v.y*iResolution.y/tickness, 1.)-.5;\n\tv.y += u2s(gfbm(coord.yx*.5, 2, .5))*.25;\n\n\tfloat shading = max(0., getDiffuse(coord)-.5)*2.;\n\tshading = shading * getShadow(coord);\n\tshading = sat(shading * .7 + .5 * pow(getAO(coord), .5));\n\tshading = shading*.85+.15*sat(gfbm(coord*.015, 3, .5));\n\tshading = pow(shading, .75);\n\tif((distance(getAlbedo(coord), MAT_CLOUD)<.15)){\n\t\tshading = max(0., getDiffuse(coord));\n\t\tshading = pow(shading, .65);\n\t}\n\t\n\tif(centered)\n\t{\n\t\tshading = (shading-.5)*2.;\n\t\tshading = abs(shading)*2.;\n\t\tshading = shading + .5;\n\t}\n\tif(renDat.depth>.9)\n\tshading = .825;\n\t\n\tshading = smoothstep(dark, light, pow(shading*contrast, .8));\n\tfloat line = smoothstep((1.-shading), 10.5*(1.-shading), abs(v.y));\n\treturn line;\n}\n\nfloat getHatching(vec2 coord){\n\tfloat ln = 1.;\n\tconst float mul = 1.;\n    ln*= pow(hatching(coord, 3., -PI*.55+.5, -1.4, 1.4, false, 1.5), 1.5);\n    ln*= pow(hatching(coord, 3., -PI*.5+1.5, -1.4, 1.4, false, 1.5), 1.5);\n    if(!(distance(getAlbedo(coord), MAT_CLOUD)<.15)){\n        ln*= pow(hatching(coord, 3.,  PI*.5-1.5, -1.4, 1.4, false, 1.9), 1.5);\n        ln*= pow(hatching(coord, 3.,  PI*.45-.5, -1.4, 1.4, false, 1.9), 1.5);\n    }\n\treturn ln;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tunpackRenderData(fragCoord);\n    \n\tvec3 col = vec3(.8, .77, .7);\n\n\tfloat shading = sat(u2s(renDat.diffuse));\n\tshading *= renDat.shadow;\n\tshading = shading*.7+.3*renDat.ao;\n\tshading = smoothstep(.3, 1., shading);\n\n\tfloat contrast = 8.8;\n\tfloat midpoint = .5;\n\tshading = sat(shading);\n\n\tcol*= getHatching(fragCoord);\n\tcol+=dithering((smoothstep(.0,1., renDat.specular*renDat.shadow)), fragCoord);\n\n\tvec3 albedo = getAlbedo(fragCoord+u2s(gfbm(fragCoord*.01, 1, .5))*u2s(gfbm(fragCoord.yx*.05, 1, .5))*64.*INV_ERNST_RENDER_SCALE);\n\tif((distance(getAlbedo(fragCoord), MAT_CLOUD)<.15)){\n\t\talbedo = mix(albedo, FOG_COL, sat(pow(renDat.depth-FOG_START*.5, FOG_POW)));\n\t}\n\telse{\n\t\talbedo = mix(albedo, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n    col*= albedo;\n    col*= dithering(gnoise(fragCoord*.18+iTime*5.)+gnoise(fragCoord*.35-iTime*5.)+.8, fragCoord*.1)*vec3(0.953,0.925,0.867)*1.2;\n    col+= 1.-dithering((1.-gnoise(fragCoord*.3+iTime*5.)*gnoise(fragCoord*.2-iTime*5.))+.8, fragCoord*.2);\n\n\tcol = pow(col, vec3(1./2.2));\n    vec2 uv = fract(fragCoord*INV_ERNST_RENDER_SCALE);\n    \n    //dbg_2V(abs((uv)*2.-1.));\n    \n    uv=abs((uv)*2.);\n    uv.x-=2.*step(.5, hash12(floor(fragCoord*INV_ERNST_RENDER_SCALE+floor(hash11(iTime)*1000.))));\n    uv.y-=2.*step(.5, hash12(floor(fragCoord*INV_ERNST_RENDER_SCALE+floor(hash11(iTime)*1000.)).yx));\n    //dbg_1F(sms(1.92, 2., length(uv)));\n\tfragColor = vec4(col, 1.);\n    drawDebug(fragColor);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n#define iFrameRate 60.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// Raymarching\n#define MIN_DIST .001\n#define MAX_DIST 2000.0\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n#define MAT_CLOUD vec3(.96)\n#define FOG_FLOAT .7\n#define MAT_SKIN vec3(.6795, .6921, .6281)\n#define MAT_TOPS vec3(.3248, .5531, .6038)\n#define MAT_TOPSARM vec3(.4392, .4885, .3929)\n#define MAT_GROUND vec3(.4385, .239, .1594)\n#define MAT_PANTS vec3(.2203, .179, .142)\n#define MAT_TOE vec3(.0637, .0637, .0637)\n#define MAT_FLOOR vec3(.8, .754, .4222)\n#define MAT_ERNST0 vec3(.8, .8, .8)\n\n#define AMB_COL vec3(.3588, .3672, .3269)\n#define AMB_STRENGTH .2\n#define FOG_COL vec3(.5903, .7484, .735)\n#define FOG_START .01\n#define FOG_POW 2.11\n\n#define isMat(name) (distance(getAlbedo(coord), name)<.25)\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n\tst *= .75;\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n\tvec2 u = smoothstep(0., 1., f);\n\n\tvec2 rnd_x0y0 = u2s(hash22(i+vec2(0,0)));\n\tvec2 rnd_x1y0 = u2s(hash22(i+vec2(1,0)));\n\tvec2 rnd_x0y1 = u2s(hash22(i+vec2(0,1)));\n\tvec2 rnd_x1y1 = u2s(hash22(i+vec2(1,1)));\n\n\tvec2 dir_x0y0 = st - (i+vec2(0,0));\n\tvec2 dir_x1y0 = st - (i+vec2(1,0));\n\tvec2 dir_x0y1 = st - (i+vec2(0,1));\n\tvec2 dir_x1y1 = st - (i+vec2(1,1));\n\n\tfloat dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n\tfloat dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n\tfloat dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n\tfloat dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n\tfloat res_x = mix(dot_x0y0, dot_x1y0, u.x);\n\tfloat res_y = mix(dot_x0y1, dot_x1y1, u.x);\n\treturn s2u(mix(res_x, res_y, u.y)*2.);\n}\nfloat gfbm(vec2 n, int rep, float pers){\n\tfloat res = 0.;\n\t\tfloat total = 0.;\n\tfloat frequency = 1.;\n\tfloat amplitude = 1.;\n\tfloat maxValue = 0.;\n\tfor(int i=0;i<rep;i++) {\n\t\ttotal += gnoise(vec2(n.x * frequency, n.y * frequency)) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= pers;\n\t\tfrequency *= 2.;\n\t}\n\tres = total/maxValue;\n\treturn res;\n}\n\n#define ERNST_RENDER_SCALE float(iResolution.x/1200.*floor(fract(pow(iTime*.002, 1.25))*256.+16.))\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\nstruct RenderData{\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\nuint packUnorm3x10(vec3 x) {\n\tx = round(clamp(x, 0., 1.) * 1023.);\n\tuvec3 r = uvec3(x);\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packU3(x) uintBitsToFloat(packUnorm3x10(x))\nvec3 unpackUnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tvec3 v = vec3(r) / 1023.0;\n\treturn v;\n}\n#define unpackU3(x) unpackUnorm3x10(floatBitsToUint(x))\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))", "buffer_a_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n\tvec3 up;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\n// \"init\": init camera/lights.\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(3.3043, .8457, -6.1505);\n\tcam0.quaternion = vec4(.6967, .1758, .1704, .6743);\n\tcam0.fov = .3456;\n\tcam0.orthoDist = 0.;\n\tcam0.orthoScale = 0.;\n\n\tlit0.direction = normalize(vec3(-.6948, .4383, -.8938));\n\tlit0.color = vec3(1., 1., 1.);\n\tlit0.shadowStart = .05;\n\tlit0.shadowEnd = 30.;\n\tlit0.shadowSoft = 32.;\n\tlit1.direction = normalize(vec3(-.0948, -.4383, .8938));\n\tlit1.color = vec3(.3, .3, .3);\n\tlit1.shadowStart = .05;\n\tlit1.shadowEnd = 30.;\n\tlit1.shadowSoft = 50.;\n}\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv){\n\n\tfloat pY = 1.35;\n    float cL = 1.8;\n    vec3 forcus = vec3(0,1.6,0);\n    float fov = .5;\n    vec2 h=vec2(.7,-.7);\n    \n    int LOOP = 60*30;\n    int cF = iFrame%LOOP;\n    if(cF<60*5){\n        pY = 10.;\n        cL = 5.;\n        h = vec2(.1,-.7);\n        forcus = vec3(0,10.88,0);\n        fov = .1+sin(iTime*.01)*.05;\n    }\n    else\n    if(cF<60*10){\n        //man\n        pY = 1.4+sin(iTime*.01);\n        cL = 1.5;\n        h = vec2(.0,.5);\n        forcus = vec3(0,1.58,0);\n        fov = .5;\n    }\n    else\n    if(cF<60*15){\n        pY = 10.+sin(iTime*.01);\n        cL = 5.;\n        h = vec2(.1,-.7);\n        forcus = vec3(0,10.88,-10.+sin(iTime*.01)*10.);\n        fov = 1.;\n    }\n    else\n    if(cF<60*20){\n        //man\n        pY = 1.4+sin(iTime*.01);\n        cL = 2.;\n        h = vec2(.5,-.5);\n        forcus = vec3(0,1.58,0);\n        fov = .8;\n    }\n    else\n    if(cF<60*25){\n        pY = 1.5;\n        cL = 15.;\n        h = vec2(2.1,-.7);\n        forcus = vec3(0,1.48,0);\n        fov = .53;\n    }\n    else\n    if(cF<60*30){\n        //man\n        pY = 1.;\n        cL = 5.;\n        h = vec2(.1,-.7);\n        forcus = vec3(0,10.88,0);\n        fov = 1.3;\n    }\n    \n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,pY,0);\n    pos.xz = normalize(h)*cL;\n\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcam0.up = up;\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n\n}\n\n// SDF functions\nfloat vmax(vec3 v){\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r){\n\treturn length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\t//return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nfloat pMirror(float x, float k){\n\treturn sqrt(x * x + k);\n}\n\n// \"polyAbs\" by iq:\n// https://www.shadertoy.com/view/3sVBRG\nfloat polyAbs(float x, float m, float n){\n\tx = abs(x);\n\tif( x>m ) return x;\n\tfloat a = 2.0*n - m;\n\tfloat b = 2.0*m - 3.0*n;\n\tfloat t = x/m;\n\treturn (a*t + b)*t*t + n;\n}\n\nfloat fOpUnionPoly(float a, float b, float m, float n){\n\treturn (a+b-polyAbs(a-b, m, n))*.5;\n}\n\nvec4 v4OpUnionPoly(vec4 a, vec4 b, float m, float n){\n\tfloat res = (a.x+b.x-polyAbs(a.x-b.x, m, n))*.5;\n\treturn vec4(res, mix(a.yzw, b.yzw, sat(exp(-res))));\n}\n\nvec4 sdMan(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p+vec3(0., -1., 0.)), bsr=2.5;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\tvec3 cpManRoot = p;\n\tcpManRoot.xyz += vec3(0., 0., 0.);\n\t\n\tvec3 cp000_002 = cpManRoot;\n\tcp000_002.xyz += vec3(0., 0., 0.);\n\t\n\tvec3 cpHead = cpManRoot;\n\tcpHead.xyz += vec3(0., -1.9, 0.);\n\t\n\tvec3 cpTorso = cpManRoot;\n\tcpTorso.xyz += vec3(0., -1.0317, 0.);\n\t{\n\t\tvec3 q = cpTorso;\n\t\tq.xz += u2s(gfbm(q.xy*10., 2, .25))*.025;\n\t\tcpTorso = q;\n\t}\n\n\tvec3 cp000_001 = cpManRoot;\n\tcp000_001.xyz += vec3(0., -1.6491, 0.);\n\t\t\n\tvec3 cpArmBase = cp000_001;\n\tcpArmBase.xyz += vec3(0., 0., 0.);\n\t\tvec3 cpArmBase_mir0_Pos = max(vec3(0), sign(cpArmBase));\n\tvec3 cpArmBase_mir0_Neg = max(vec3(0),-sign(cpArmBase));\n\tcpArmBase.x = pMirror(cpArmBase.x, 0.);\n\n\tvec3 cpArmBaseEf = cp000_001;\n\tcpArmBaseEf.xyz += vec3(0., 0., 0.);\n\t\tvec3 cpArmBaseEf_mir0_Pos = max(vec3(0), sign(cpArmBaseEf));\n\tvec3 cpArmBaseEf_mir0_Neg = max(vec3(0),-sign(cpArmBaseEf));\n\tcpArmBaseEf.x = pMirror(cpArmBaseEf.x, 0.);\n\t{\n\t\tvec3 q = cpArmBaseEf;\n\t\tq.xz += u2s(gfbm(q.xy*10., 2, .25))*.025;\n\t\tcpArmBaseEf = q;\n\t}\n\n\tvec3 cpLegBase = cpTorso;\n\tcpLegBase.xyz += vec3(0., .034, 0.);\n\t\tvec3 cpLegBase_mir0_Pos = max(vec3(0), sign(cpLegBase));\n\tvec3 cpLegBase_mir0_Neg = max(vec3(0),-sign(cpLegBase));\n\tcpLegBase.x = pMirror(cpLegBase.x, 0.);\n\n\tvec3 cpArmShoulder = cpArmBase;\n\tcpArmShoulder.xyz += vec3(-.3007, -.0087, 0.);\n\t\n\tvec3 cpArmShoulderEf = cpArmBaseEf;\n\tcpArmShoulderEf.xyz += vec3(-.3007, -.0087, 0.);\n\t\n\tvec3 cpLegHip = cpLegBase;\n\tcpLegHip.xyz += vec3(-.1523, .0438, 0.);\n\t\n\tvec3 cpArmElbow = cpArmShoulder;\n\tcpArmElbow.xyz += vec3(0., .3489, 0.);\n\t\n\tvec3 cpArmElbowEf = cpArmShoulderEf;\n\tcpArmElbowEf.xyz += vec3(0., .3489, 0.);\n\t\n\tvec3 cpLegKnee = cpLegHip;\n\tcpLegKnee.xyz += vec3(0., .4081, 0.);\n\t\n\tvec3 cpArmWrist = cpArmElbow;\n\tcpArmWrist.xyz += vec3(0., .3019, 0.);\n\t\n\tvec3 cpLegAnkle = cpLegKnee;\n\tcpLegAnkle.xyz += vec3(0., .4265, 0.);\n\t\n\td = sdEllipsoid(cpTorso+vec3(0., -.2067, 0.), vec3(.2456, .2, .1826));\n\tres = v4OpUnion(vec4(d, MAT_TOPS), res);\n\n\td = sdEllipsoid(cpTorso+vec3(-.0076, .011, 0.), vec3(.1347, .1347, .1347));\n\tres = v4OpUnionSmooth(vec4(d, MAT_PANTS), res, .01);\n\n\td = sdEllipsoid(cpTorso+vec3(0., -.5324, 0.), vec3(.253, .2, .1895));\n\tres = v4OpUnionSmooth(vec4(d, MAT_TOPS), res, .187);\n\n\td = sdEllipsoid(cpLegBase+vec3(-.1189, .0291, 0.), vec3(.1347, .1347, .1347));\n\td = fOpUnionSmooth(sdEllipsoid(cpLegHip+vec3(-.0028, .251, 0.), vec3(.1347, .2116, .1347)), d, .1044);\n\td = fOpUnionSmooth(sdEllipsoid(cpLegKnee+vec3(-.0028, .196, 0.), vec3(.1119, .1861, .1119)), d, .1044);\n\tres = v4OpUnionSmooth(vec4(d, MAT_PANTS), res, .1044);\n\n\td = sdEllipsoid(cpArmShoulderEf+vec3(.1115, .0417, -.011), vec3(.0669, .0669, .0669));\n\td = fOpUnionPoly(sdEllipsoid(cpArmShoulderEf+vec3(-.0085, .1711, 0.), vec3(.0871, .1683, .0871)), d, .268, .046);\n\tres = v4OpUnionPoly(vec4(d, MAT_TOPSARM), res, .097, .055);\n\n\td = sdEllipsoid(cpHead, vec3(.05, .05, .05));\n\tres = v4OpUnion(vec4(d, MAT_SKIN), res);\n\n\td = sdEllipsoid(cpArmElbowEf+vec3(-.0085, .1297, 0.), vec3(.0905, .1625, .0905));\n\tres = v4OpUnionPoly(vec4(d, MAT_TOPSARM), res, .133, .036);\n\n\td = sdEllipsoid(cpLegAnkle+vec3(-.0028, .0402, 0.), vec3(.0753, .0661, .1119));\n\tres = v4OpUnionSmooth(vec4(d, MAT_TOE), res, .01);\n\n\td = sdEllipsoid(cpArmWrist+vec3(.0028, .0697, 0.), vec3(.05, .05, .05));\n\tres = v4OpUnion(vec4(d, MAT_SKIN), res);\n\n\td = sdEllipsoid(cpLegAnkle+vec3(-.0028, .0402, .0892), vec3(.0753, .0575, .1119));\n\tres = v4OpUnionPoly(vec4(d, MAT_TOE), res, .115, .022);\n\treturn res;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp001_001 = p;\n\tcp001_001.xyz += vec3(0., -10.0332, 0.);\n\t{\n\t\tvec3 q = cp001_001;\n        q.y-=30.;\n\t\tq.y += gfbm(q.xz*.01, 4, .25)*80.;\n\t\tcp001_001 = q;\n\t}\n\n\td = sdPlane(cp001_001);\n\td = fOpUnion(sdSphere(cp001_001+vec3(0., 5., -4.8), 1.), d);\n\tres = v4OpUnion(vec4(d, MAT_GROUND), res);\n\tres = v4OpUnionSmooth(sdMan(p), res, .01);\n\treturn res;\n}\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yxz+33.33);\n\treturn fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec2 voronoi(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    vec2 res = vec2(100.);\n    for(int j=-1; j<=1; j++)\n    for(int k=-1; k<=1; k++)\n    for(int l=-1; l<=1; l++)    \n    {\n        vec3 b = vec3(j,k,l);\n        vec3 r = b-f+hash33(i+b);\n        float d = dot(r,r);\n\n        if( d < res.x )\n            res = vec2( d, res.x );\t\t\t\n        else if( d < res.y )\n            res.y = d;\n    }\n\n    return res;\n}\n// The clouds were borrowed from Bananaft's shader.\n// I have not understand it yet... \n// https://www.shadertoy.com/view/XldGR7\nfloat sdClouds(vec3 p)\n{\n    p.z+=iTime;\n    p.y-=80.;//terrainH(p.xz, 2, false)*.5;\n    // p.yz*=mat2(cos(.5+vec4(0,11,33,0)));\n    // vec2 vrn1 = voronoi(p * 0.03 + vec3(iTime * 0.025, -iTime * 0.05, 0.));\n    // vec2 vrn2 = voronoi(p * 0.2 + vec3(iTime * 0.5, -iTime * 0.1, 0.));\n\t// vrn1*=vec2(6,3)*3.5;\n    // float q = (vrn1.y - vrn1.x);\n    // float d = sdSphere(vec3(q, p.y, q), 10.);//+jitter.x*.5;\n    \n    // // vrn2*=vec2(3,1);\n    // float disp = (vrn2.y + vrn2.x);\n    // // float disp = (vrn2.x);\n    // return (d + disp*2.5);\n\tvec2 vrn2 = voronoi(p * 0.02);\n\tfloat v3 =  voronoi(p * 0.2).x;\n\tfloat v2 = 0.8 - vrn2.x * (1.5 - vrn2.y );\n\tfloat v =  voronoi(p * 0.125).x;// vrn.x;// * (1.4 - vrn.y);\n\tfloat cld = max(11. - v2 * 10., 0.);\n\tfloat d = sdSphere(vec3(cld, p.y, cld), 5.5);      \n\t//v = -.3 + v* 2.1 ;\n\td += v + v3 * 1.4;\n    \n    return d;\n}\n\nfloat hitClouds()\n{\n    float t = 1.;\n    const int ITR=300;\n    int i=ZERO;\n    for(; i < ITR; ++i)\n    {\n        float d = sdClouds(ray.origin + ray.direction * t);\n        t += d;\n\n        if((d)<MIN_DIST*300. || t>MAX_DIST)\n        {\n           break;\n        }\n    }\n    return t;\n}\n\nfloat ssClouds(vec3 p)\n{\n    float ss = 0.0;\n    const float LEN = 10.;\n    const float DEN = .97;\n    for(int i = 0 ;  i < 5; ++i)\n    {\n        float d = sdClouds(p + lit0.direction*LEN*float(i));\n        ss += d * (1.-DEN);\n    }\n    return sat(ss);\n}\n\nvec3 normalClouds(vec3 p){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n         vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n         n += e*sdClouds(p+0.001*e);\n     }\n     return normalize(n);\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0,1,0);\n\t\trenDat.diffuse = FOG_FLOAT*1.18;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 1.;\n\t\trenDat.ao = 1.;\n\t\trenDat.depth = .9;\n\t\trenDat.result = FOG_COL;\n\n        float t=hitClouds();\n        vec3 p=ray.origin+ray.direction*t;\n        if(t<MAX_DIST)\n        {\n\t\t\trenDat.albedo = MAT_CLOUD;\n\t\t\tvec3 n = normalClouds(p);\n\n\t\t\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\t\t\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\t\t\tvec3 pos = cam0.position;\n\t\t\tfloat fov = cam0.fov;\n\t\t\tvec3 target = pos-dir;\n\n\t\t\tvec3 cw = normalize(target - pos);\n\t\t\tvec3 cu = normalize(cross(cw, up));\n\t\t\tvec3 cv = normalize(cross(cu, cw));\n\n\t\t\tvec3 side = cross(dir, up);\n\t\t\trenDat.normal.x = dot(n, cu);\n\t\t\trenDat.normal.y = dot(n, up);\n\t\t\trenDat.normal.z = dot(n, -dir);\n\t\t\trenDat.normal = normalize(renDat.normal);\n\t\t\t\n            float ss = ssClouds(p);\n\t\t\trenDat.diffuse = ss;\n            renDat.result = vec3(ss);\n            renDat.result = mix(renDat.result, vec3(abs(ray.direction.y)), sat(t/MAX_DIST*1.));\n            renDat.diffuse = mix(renDat.diffuse, FOG_FLOAT, sat(t/MAX_DIST*1.));\n\t\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n            \n        }\n\t}\n\telse{\n\t\trenDat.albedo = res.yzw;\n\n\t\tvec3 n = normal(p);\n\n\t\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\t\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\t\tvec3 pos = cam0.position;\n\t\tfloat fov = cam0.fov;\n\t\tvec3 target = pos-dir;\n\n\t\tvec3 cw = normalize(target - pos);\n\t\tvec3 cu = normalize(cross(cw, up));\n\t\tvec3 cv = normalize(cross(cu, cw));\n\n\t\tvec3 side = cross(dir, up);\n\t\trenDat.normal.x = dot(n, cu);\n\t\trenDat.normal.y = dot(n, up);\n\t\trenDat.normal.z = dot(n, -dir);\n\t\trenDat.normal = normalize(renDat.normal);\n\n        float lamb1 = s2u(dot(n, lit0.direction));\n\t\tfloat lamb2 = sat(dot(n, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+n*.0001, n);\n\t\trenDat.ao = 1.;\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\t\t\n        renDat.diffuse += lamb2*renDat.ao;\n        renDat.diffuse += renDat.ao*AMB_STRENGTH;\n        \n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\t\trenDat.specular = 0.;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t\trenDat.diffuse = mix(renDat.diffuse, FOG_FLOAT, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\nvec4 packRenderData(){\n\t#define dlamp(x) clamp(abs(x)*.994+.003,.0, 1.)*sign(x)\n\treturn vec4(\n\t\t\tpackU4(vec4(renDat.albedo, renDat.shadow)),\n\t\t\tpackS3(dlamp(u2s(vec3(renDat.diffuse, renDat.specular, renDat.ao)))),\n\t\t\tpackS3(dlamp(renDat.normal)), // pack/unpackS3: data is alive in .003 to .997 only.\n\t\t\trenDat.depth\n\t\t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    fragColor = packRenderData();\n}", "buffer_a_inputs": [], "sound_code": "// This sound shader is based on ttg's shader.\n// \"Bitshift Variations in C Port\" by ttg:\n// https://www.shadertoy.com/view/4dlyWl\n// The basic performance algorithm is just a copy and paste of his shader.\n// I made a few adjustments to make it fit my visuals.\n\n/*\nBitshift Variations in C Minor\nCopyright 2013 Robert Miles <soundcloud.com/robertskmiles>\n*/\n\n// \"BY}6YB6%\", \"Qj}6jQ6%\"\nconst int seq1[] = int[](66,0,0,54,0,66,0,0);\nconst int seq2[] = int[](16,0,0,0,0,81,0,0);\n\nint g(int i,int x,int t,int o){\n    return((3&x&(i*((\n        (3&i>>16)!=0 ? seq1[t%8] : seq2[t%8] )+51\n        )>>o))<<4);\n}\n                     \nint s(int i, float time){\n\tint n, s;\n    return(\n        g(i,1+int(time*.1+1.)%3,n=i>>14,10+int(time*.2+1.)%5));\n}\n\n/* //////////////////////////\nSimple audio resampling\nCopyright 2017 Theron Tarigo\n*/\n\nvec2 mainSound( in int samp, float time )\n{\n    // Simple resampling algorithm\n    int samprate = 8000;\n    int i = int(fract(time)*float(samprate))+int(floor(time))*samprate;\n    float rem = fract(fract(time)*float(samprate));\n    uint s1 = uint(s(i,time))%256u;\n    uint s2 = uint(s(i+1,time))%256u;\n    float f1 = float(s1)/255.;\n    float f2 = float(s2)/255.;\n    float f = f1*(0.5+0.5*cos(3.141592653589793*rem));// +\n              //f2*(0.5-0.5*cos(3.141592653589793*rem)) ;\n    return vec2( f );\n}\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVczd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1636, 1636, 1665, 1665, 2106], [2108, 2178, 2244, 2244, 2460], [2461, 2461, 2533, 2533, 2736], [2737, 2737, 2798, 2798, 2896], [2897, 2897, 2964, 2964, 3012], [3013, 3013, 3076, 3076, 3102], [3131, 3131, 3225, 3225, 3672], [3674, 3674, 3766, 3766, 3984], [3986, 3986, 4023, 4023, 4370], [4372, 4372, 4413, 4413, 5116], [5194, 5194, 5221, 5221, 7287], [7288, 7288, 7315, 7315, 7363], [7364, 7364, 7392, 7392, 9501], [9502, 9502, 9529, 9529, 9556], [9558, 9558, 9588, 9588, 9632], [9633, 9633, 9657, 9657, 9701], [9702, 9702, 9755, 9755, 10146], [10148, 10148, 10177, 10177, 12228], [12230, 12230, 12267, 12267, 12351], [12353, 12353, 12382, 12382, 12942], [12944, 12944, 12978, 12978, 13106], [13107, 13107, 13141, 13141, 13466], [13468, 13468, 13580, 13580, 14490], [14492, 14492, 14522, 14522, 14943], [14945, 14945, 15001, 15001, 16452]], "test": "untested"}
{"id": "wlKczd", "name": "XOR Checkerboard Fractal", "author": "koi", "description": "A compact and efficient fractal checkerboard shader using bit-wise XOR.", "tags": ["fractal", "animated", "checkerboard", "xor", "pattern"], "likes": 4, "viewed": 486, "published": 3, "date": "1611616952", "time_retrieved": "2024-07-30T19:42:28.117419", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sr = iResolution.xy;\n    float t = fract(iTime * 0.5);                    // zoom 2x every 2 seconds\n    ivec2 ic = ivec2(fragCoord * exp2(t));           // scaled integer coordinates\n    float r = exp2(t + ceil(log2(max(sr.x, sr.y)))); // highest value that can appear on-screen (zooming breaks this somewhat)\n    float v = float(ic.x ^ ic.y) / r;                // XOR and divide result by r to keep within [0, 1]\n    fragColor = vec4(vec3(v), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 520]], "test": "untested"}
{"id": "ttVcRt", "name": "Day 405", "author": "jeyko", "description": "potat", "tags": ["mdtmjvm"], "likes": 36, "viewed": 525, "published": 3, "date": "1611604734", "time_retrieved": "2024-07-30T19:42:28.881376", "image_code": "\n#define slices 180.\n\nconst float disp = 0.4;\n\nconst float eps = 0.01;\n\nconst float width = 0.00035;\n\nfloat fun(float p, float py){\n    \n    float f = sin(p + iTime + cos(py*0.05 + sin(p))*0.7)*sin(py*0.1 + iTime*0.2);\n    \n    //f = cos(p*0.4- iTime + py)*cos(p*0.4*sin(p) + iTime)*(sin(py + iTime));\n    //f = sin(p*0.5 + sin(py))*(cos(py*0.1 + iTime));\n    \n    f *= mix(\n        smoothstep(0.,1.,abs(p + sin(py)*0.1)),\n        smoothstep(0.,1.,abs(p + sin(py*0.3 + iTime)*0.1)),\n        0.5 + sin(iTime*0.4 )*0.5\n        );\n    \n    return f*disp;\n}\n\n\n\nfloat graph(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize ,0., \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.))- width);\n}\nfloat graphNoAbs(float y, float fn0, float fn1, float pixelSize){\n  return smoothstep(pixelSize,0., \n                    -(fn0-y)/length(vec2((fn1-fn0)/eps,1.)) - width);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    \n    float pixelSize = dFdx(uv.x)*1.25;\n    \n    for(float i = 0.; i < slices; i++ ){\n        vec2 p = uv + vec2(0.,i/slices*2. - 0.8);\n        \n        //float funIdx = p.x*4. + sin(p.y*i/slices*2. + iTime)*1.5*sin(p.x - iTime);\n        float funIdx = p.x;\n        \n        col -= graphNoAbs( p.y + 0.0, fun(funIdx,i), fun(funIdx+eps,i), pixelSize);\n        col = max(col,0.);\n        col = mix(col, vec3(1), graph( p.y, fun(funIdx,i), fun(funIdx+eps,i), pixelSize ));\n        \n    }\n    \n    \n    col = 1. - col;\n    \n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 131, 131, 553], [557, 557, 617, 617, 726], [727, 727, 792, 792, 899], [903, 903, 960, 960, 1647]], "test": "untested"}
{"id": "tlyyzd", "name": "Smooth Waveforms", "author": "TinyTexel", "description": "Aliasing- and ringing artifacts free versions of the basic waveform types.\nTheir Fourier coeffcients are computed using two recursive procedures.\n\nThe horizontal mouse position maps to the number of used Fourier coefficients. ", "tags": ["wave", "audio", "waveforms", "sawtooth"], "likes": 15, "viewed": 690, "published": 3, "date": "1611603629", "time_retrieved": "2024-07-30T19:42:29.714149", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nAliasing- and ringing artifacts free versions of the basic waveform types.\nTheir Fourier coeffcients are computed using two recursive procedures.\nEvery additional Fourier coefficient is used to zero out another higher order derivative at x=1/2 and x=3/2;\n\nThe horizontal mouse position maps to the number of used Fourier coefficients n (procedure becomes numerically unstable for n>61).\n\n\nI found these procedure by computing the first few results manually and then staring at them with squinted eyes trying to identify possible relationships.\nThis is basically the same I did when deriving the FlatBand FIR filter ( https://www.shadertoy.com/view/ttfBzj ); just a bit more advanced this time.\n\nMathematica is actually able to reduce SquareWave(x,n) to a closed-form expression.\nIt does, however, turn out as a bit of a not so extraordinarily useful abomination:\n\nsqwave[x_, n_] :=\n    (2^(-3 - 2 n) E^(-2 I (1 + n) \\[Pi] x) Sqrt[\\[Pi]]\n    Gamma[3 + 2 n] (2 n! (E^(I (3 + 4 n) \\[Pi] x)\n    Hypergeometric2F1[-1 - 2 n, -(1/2) - n, 1/2 - n, E^(-2 I \\[Pi] x)] + E^(I \\[Pi] x)\n    Hypergeometric2F1[-1 - 2 n, -(1/2) - n, 1/2 - n, E^(\n    2 I \\[Pi] x)]) - (-1)^n E^(I (1 + 2 n) \\[Pi] x) (1 + 2 n) Sqrt[\\[Pi]] Gamma[2 + 2 n] \n    (HypergeometricPFQRegularized[{1/2, 1, -n}, {3/2, 2 + n},E^(-2 I \\[Pi] x)] + E^(2 I \\[Pi] x)\n    HypergeometricPFQRegularized[{1/2, 1, -n}, {3/2, 2 + n}, E^(2 I \\[Pi] x)])))/(n! Gamma[1/2 - n] Gamma[2 + n] Gamma[2 + 2 n])\n\n\nTODO:\n- find better or exact normalization procedure for SawtoothWave\n- pulse waveform with variable duty cycle\n*/\n\nconst float pi = 3.14159265359;\nconst float pi05 = pi * 0.5;\n\nfloat SquareWave(float x, float n)\n{\n    x = x * pi - pi05;\n    \n    float w = 1.0;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        w *= -(i * 2.0 + 1.0) / \n              (i * 8.0 + 8.0);\n    }\n    \n    float a = n * 2.0 + 1.0;\n    float b = n * 2.0 + 2.0;\n    float c = n * 2.0 + 3.0;\n    \n    float f = w * cos(a * x);\n    \n    for(float i = 1.0; i <= n; ++i)\n    {\n        w *= ((i * 2.0 - c) * (i - b)) / \n             ((i * 2.0 - a) *  i     );\n        \n        f += w * cos(((n-i) * 2.0 + 1.0) * x);\n    }\n    \n    return f;\n}\n\n\nfloat TriangleWave(float x, float n)\n{\n    x = x * pi;\n\n    float w = 1.0;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        w *= -(i * 2.0 + 1.0) / \n              (i * 8.0 + 8.0);\n    }\n    \n    float a = n * 2.0 + 1.0;\n    float b = n * 2.0 + 2.0;\n    float c = n * 2.0 + 3.0;\n    \n    float f = w * sin(a * x) / a;\n    float h = abs(w) / a;\n    \n    float s = 1.0;\n    for(float i = 1.0; i <= n; ++i, s = -s)\n    {\n        w *= ((i * 2.0 - c) * (i - b)) / \n             ((i * 2.0 - a) *  i     );\n        \n        float k = (n-i) * 2.0 + 1.0;\n        \n        f += w * sin(k * x) / k;\n        h += abs(w) / k;\n    }\n    \n    return f / h;\n}\n\n\nfloat SawtoothWave(float x, float n)\n{\n    float f;\n    {\n        x = x * pi05;\n    \n        float w = 1.0;\n        \n        for(float i = 0.0; i < n; ++i)\n        {\n            w *= -(i * 2.0 + 1.0) / \n                  (i * 8.0 + 8.0);\n        }\n        \n        float a = n * 2.0 + 1.0;\n        float b = n * 2.0 + 2.0;\n        float c = n * 2.0 + 3.0;\n        \n        float square = w * cos(a * x);\n        float tri    = w * sin(a * x) / a;\n        float h      = abs(w) / a;\n        \n        float s = 1.0;\n        for(float i = 1.0; i <= n; ++i, s = -s)\n        {\n            w *= ((i * 2.0 - c) * (i - b)) / \n                 ((i * 2.0 - a) *  i     );\n            \n            float k = (n-i) * 2.0 + 1.0;\n            \n            square += w * cos(k * x);\n            tri    += w * sin(k * x) / k;\n            h      += abs(w) / k;\n        }\n        \n        tri /= h;\n        \n        f = tri * square;\n    }\n    \n  #if 1\n    // empirical normalization\n    float u = 1.0;\n    \n    float b = 1.86;\n    float a = b * 0.798;\n    \n    for(float i = 0.0; i < n; ++i)\n    {\n        u *= (i+a)/(i+b)*0.999;\n    }\n    \n    f /= 1.0-u*0.5;\n  #endif\n  \n    return f;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.y * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n   #if 0\n    tex *= 0.25;\n    tex.x+=0.3;\n    tex.y+=0.8;\n   #endif\n   \n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    float n = floor((1.0-clamp01(iMouse.x/iResolution.x))*60.0);\n\n    //n += 0.3333\n    //n += 0.5;\n    //n += 0.6666;\n\n  #if 0\n    // visualize coefficients\n    {\n        float x = floor((uv0.x/iResolution.x)*16.0);\n    \n        float w = 1.0;\n    \n        for(float i = 0.0; i < n; ++i)\n        {\n            w *= -(i * 2.0 + 1.0) / \n                  (i * 8.0 + 8.0);\n        }\n\n        float a = n * 2.0 + 1.0;\n        float b = n * 2.0 + 2.0;\n        float c = n * 2.0 + 3.0;\n\n        if(x == n)\n        {\n            if(w > uv0.y/iResolution.y*1.25) col *= 0.5;\n        }\n        else    \n        for(float i = 1.0; i <= n; ++i)\n        {\n            w *= ((i * 2.0 - c) * (i - b)) / \n                 ((i * 2.0 - a) *  i     );\n                 \n            if((n-i) == x)\n            {\n                if(abs(w) > uv0.y/iResolution.y*1.25) col *= 0.5;\n                \n                break;\n            }\n        }\n    }\n  #endif\n  \n    col = mix(col, vec3(0.0, 0.5  , 1.0  ), Graph(  SquareWave(tex.x, n) - tex.y, 1.0)*0.925);\n    col = mix(col, vec3(0.0, 0.8  , 0.125), Graph(TriangleWave(tex.x, n) - tex.y, 1.0)*0.925);\n    col = mix(col, vec3(1.0, 0.125, 0.0  ), Graph(SawtoothWave(tex.x, n) - tex.y, 1.0)*0.925);\n    \n  #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n  #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n}\n\n", "image_inputs": [], "common_code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyyzd.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1701, 1701, 1737, 1737, 2239], [2242, 2242, 2280, 2280, 2889], [2892, 2892, 2930, 2930, 4062], [4065, 4065, 4113, 4113, 6012]], "test": "untested"}
{"id": "WtVyRt", "name": "Naive SDF morphing", "author": "DragonWolf", "description": "Test for morphing between different sdfs (circle, box and arcs)", "tags": ["sdfmorphing"], "likes": 1, "viewed": 517, "published": 3, "date": "1611595911", "time_retrieved": "2024-07-30T19:42:30.478108", "image_code": "/* First attempt at some morphing between arbitary SDF functions. Introduced a constant A that\n * varies depending on the target SDFs, had to manually update this until it looked good.\n *\n * - Could do with some algorithm to select an A value that is suitable for the SDFs somehow.\n * - Morph's aren't perfect, but will likely do for my purposes.\n */\n \n\nfloat sdBox( vec2 p, in vec2 bounds )\n{\n    vec2 d = abs(p)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdf(vec2 uv) {\n\n    int variation = int(mod(floor(iTime / 10.), 4.));\n    \n    float pulse = 0.5 + sin(((iTime / 5.) - 0.25) * 3.141 * 2.) * 0.5;\n    \n    float a;\n    float obj1 = 0.;\n    float obj2 = 0.;\n    \n    // Some static arc values.\n    float ta1 = 2.;\n    float tb1 = 2.;\n    float rb1 = 0.05;\n    float size1 = 1.;\n    \n    float ta2 = 3.141;\n    float tb2 = 1.;\n    float rb2 = 0.1;\n    float size2 = .5;\n    \n    vec2 arcPosition1 = vec2(.75,0.);\n    vec2 arcPosition2 = vec2(.5,0.);\n    \n    float radius1 = 0.15;\n    vec2 position1 = vec2(0., -0.2);\n    \n    float radius2 = 0.8;\n    vec2 position2 = vec2(0., 0.4);\n    \n    switch (variation) {\n        case 0:\n\n            obj1 = sdCircle(uv - position2, radius2);    \n            obj2 = sdCircle(uv - position1, radius1); \n            \n            a = 0.22;\n            \n            break;\n            \n        case 1:\n            obj1 = sdCircle(uv - position2, radius2); \n            obj2 = sdArc(uv - arcPosition1,vec2(sin(ta1),cos(ta1)),vec2(sin(tb1),cos(tb1)), size1, rb1);  \n            \n            a = 0.14;\n            \n            break;\n            \n        case 2:\n            obj1 = sdArc(uv - arcPosition1,vec2(sin(ta1),cos(ta1)),vec2(sin(tb1),cos(tb1)), size1, rb1);  \n            obj2 = sdArc(uv - arcPosition2,vec2(sin(ta2),cos(ta2)),vec2(sin(tb2),cos(tb2)), size2, rb2);\n            \n            // a = 0.09;\n            a = 0.3;\n            \n            break;\n            \n        case 3:\n\n\n            obj1 = sdBox(uv - position1, vec2(0.5, 0.5)); \n            obj2 = sdCircle(uv - position2, radius2); \n            \n            a = 0.09;\n            \n            break;\n    }\n    \n    return mix(obj1, obj2, pulse) - a * (1. - (2. * abs(pulse - 0.5)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from y = -1 to 1 with 0,0 in the center of the screen)\n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n    \n    // Calculate SDF\n    float d = sdf(uv);\n\n    // Set base colour depending on inside or outside bounding box.\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n   \n    // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n    vec3 col = vec3(1.0) - sign(d)*baseColor;\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 393, 393, 478], [480, 480, 518, 518, 551], [553, 553, 628, 628, 812], [814, 814, 834, 834, 2564], [2566, 2566, 2623, 2715, 3275]], "test": "untested"}
{"id": "WtVczt", "name": "wormhole memory", "author": "YitingLiu", "description": "experiment with colors and time using noise function. ", "tags": ["noise", "texture", "circle", "gradient", "metallic"], "likes": 0, "viewed": 250, "published": 3, "date": "1611589383", "time_retrieved": "2024-07-30T19:42:31.251040", "image_code": "#define PI 3.141592653\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    //st.x *= iResolution.x/iResolution.y;\n    \n    // suggested by @FabriceNeyret2 \n    vec2 st = fragCoord / iResolution.y;  \n    vec3 color = vec3(0.0);\n\n    float t = 1.0;\n    // Uncomment to animate\n     t = abs(1.0-sin(iTime*.1))*0.5;\n    // Comment and uncomment the following lines:\n    st /= noise(st*2.)*t; // Animate the coordinate space\n    color = vec3(1.) * smoothstep(0.1,0.8,noise(st)); // Big black drops\n    color -= smoothstep(0.1,0.5,noise(st*10.)); // Black splatter\n    color += smoothstep(1.-cos(iTime),1.-cos(iTime)+0.2,noise(st*10.)); // Holes on splatter\n\n    vec3 col = 0.5 + 0.5*cos(iTime+st.xyx+vec3(0,2,4));\n\n    fragColor = vec4(color*noise(st)/col/1e2-col*vec3(PI,(cos(st.x)-sin(st.y))*0.5, atan(st.y,st.x)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 46, 46, 185], [187, 272, 294, 294, 698], [700, 700, 757, 887, 1550]], "test": "untested"}
{"id": "WlVyzt", "name": "the puzzle", "author": "YitingLiu", "description": "Creating the puzzle that changes shapes and colors and line thickness based on time. ", "tags": ["noise", "line", "texture", "sin", "gradient", "rotate", "cos", "fract", "abs", "position", "puzzle", "tan"], "likes": 0, "viewed": 252, "published": 3, "date": "1611587829", "time_retrieved": "2024-07-30T19:42:32.149638", "image_code": "// wood texture and moving colors \n\n#define PI 3.141592653\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n\n    vec2 pos = st.yx*vec2(10.,7.);\n\n    float pattern = pos.x*sin(iTime)*10.;\n\n    // Add noise\n    pos = rotate2d( noise(pos)*PI*PI*sin(iTime)) * pos;\n    pos /=  abs(tan(iTime))*PI*0.5;\n    pos +=  cos(iTime)*PI*0.1;\n    \n    pos.x+=(abs(sin(iTime)))*10.;\n\n    // Draw lines\n    pattern = lines(pos,0.2+cos(iTime));\n\n    fragColor = vec4(vec3(pattern)/vec3(st.y,st.x+pos.x,pos.y)*fract(abs(tan(iTime))/2.5),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 87, 87, 203], [205, 287, 309, 309, 607], [609, 609, 636, 636, 718], [720, 720, 754, 754, 910], [912, 912, 969, 969, 1471]], "test": "untested"}
{"id": "3tKyRt", "name": "Soup Can Dynamics", "author": "dr2", "description": "Warhol's tomato soup cans live (mouse to upper-right for restart)", "tags": ["collision", "dynamics", "warhol", "physics"], "likes": 13, "viewed": 404, "published": 3, "date": "1611580983", "time_retrieved": "2024-07-30T19:42:33.227756", "image_code": "// \"Soup Can Dynamics\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 mRotHit;\nvec3 qHit, qnHit, ltDir;\nfloat dstFar, cylRad, cylLen, bCylRad, bCylHt;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nconst int nObj = 16;\n\nvec4 CylHit (vec3 ro, vec3 rd, float r, float h)\n{\n  vec3 s;\n  float d, a, b, w;\n  d = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - r * r);\n  if (w > 0.) {\n    if (a > 0.) {\n      d = (- b - sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s = vec3 (0., 0., h);\n    if (d < 0. || abs (s.z) > h) {\n      d = - (sign (rd.z) * ro.z + h) / abs (rd.z);\n      if (d < 0. || length (ro.xy + d * rd.xy) > r) d = dstFar;\n    }\n  }\n  return vec4 (s, d);\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 ds;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    ds = CylHit (rom, rdm, cylRad, cylLen);\n    if (ds.w < dMin) {\n      dMin = ds.w;\n      qHit = rom + dMin * rdm;\n      mRotHit = mRot;\n      qnHit = (abs (ds.z) > cylLen) ? vec3 (0., 0., - sign (rdm.z)) : vec3 (normalize (ds.xy), 0.);\n    }\n  }\n  if (dMin < dstFar) qnHit = mRotHit * qnHit;\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec4 ds;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n   for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = Loadv4 (4 * n).xyz;\n    mRot = QtToRMat (Loadv4 (4 * n + 2));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    ds = CylHit (rom, rdm, cylRad, cylLen);\n    if (ds.w < dMin) dMin = ds.w;\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vn.xz = - s.xz / bCylRad;\n    else {\n      d = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 vc, db4;\n  vec3 vn, col, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, ga, sh;\n  bool isLit;\n  isLit = true;\n  ro.y -= 0.25;\n  db4 = InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  ro += dCyl * rd;\n  if (vnCyl.y == 0.) {\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (32. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col = vec3 (0., 0., 1.);\n      isLit = false;\n    } else {\n      col = vec3 (0.4, 0.5, 0.4);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col = vec3 (0.6, 0.7, 0.5);\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05, 16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          col = vec3 (0.7, 0.75, 0.7);\n          qw = 8. * vec2 (12. * a, 2. * hy);\n          rg = ShStagGrid (qw);\n          col *= rg.y * (1. - 0.2 * Noisefv2 (32. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    vc = HexVor (0.5 * ro.zx);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.y, 4., - vc.z)), b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col = vec3 (0.65, 0.62, 0.6) * (0.7 + 0.3 * b * step (0.06 + 0.03 * vc.w, vc.x) *\n       (1. - 0.3 * Noisefv2 (16. * ro.xz))) * vec3 (1., 0.94 + 0.06 * vc.w, 1. - 0.06 * vc.w);\n  } else {\n    b = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = float (VAR_ZERO); n < 128.; n ++) b += 1. - smoothstep (0.03, 0.035,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0.6, 0.7, 1.), vec3 (1., 1., 0.4), b);\n    isLit = false;\n  }\n  if (isLit) {\n    sh = (vnCyl.y > -0.5) ? ObjHitSh (ro + 0.01 * ltDir, ltDir, 30.) : 1.;\n    col *= 0.5 + 0.5 * sh * max (dot (vn, ltDir), 0.);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, spec, sh, r, a;\n  bool isRefl;\n  HexVorInit ();\n  isRefl = false;\n  dstObj = ObjHit (ro, rd);\n  r = length (qHit.xy);\n  if (dstObj < dstFar && r < cylRad - 0.1) {\n    ro += dstObj * rd;\n    vn = qnHit * mRotHit;\n    a = atan (qHit.y, - qHit.x);\n    vn.xy = Rot2D (vn.xy, - a);\n    vn.xz = Rot2D (vn.xz, 0.05 * pi * sin (12. * pi * r / cylRad) * step (cylRad / 6., r));\n    vn.xy = Rot2D (vn.xy, a);\n    vn = mRotHit * vn;\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = qnHit;\n    r = length (qHit.xy);\n    if (r < cylRad - 0.001) {\n      col = mix (col, vec3 (0.8), step (cylRad - 0.1, r));\n    } else {\n      col = mix (vec3 (1., 0.2, 0.2), vec3 (0.9), step (0., qHit.z));\n      col = mix (col, vec3 (0.8), step (cylLen - 0.2, abs (qHit.z)));\n      r = length (qHit.xz);\n      col = mix (vec3 (1., 1., 0.2), col, smoothstep (0., 0.02, r - 0.5 * cylRad));\n      col = mix (vec3 (0.4, 0.4, 1.), col, smoothstep (0., 0.02, abs (r - 0.5 * cylRad) - 0.05));\n      if (abs (qHit.z) > 0.08 * cylRad || qHit.x * sign (qHit.y) > 0.)\n         col = mix (vec3 (0.4, 0.4, 1.), col, smoothstep (0., 0.02, abs (r - 0.3 * cylRad) - 0.15));\n      if (r > 0.5 * cylRad) vn = mRotHit * VaryNf (16. * qHit, vn * mRotHit, 0.4);\n    }\n    spec = 0.2;\n    sh = 0.5 + 0.5 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 30.);\n    col = col * (0.2 +  0.1 * max (dot (normalize (- ltDir.xz), vn.xz), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       spec * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  if (isRefl) col = mix (col, vec3 (0.5), 0.4);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (4 * nObj + 1);\n  cylRad = stDat.x;\n  cylLen = stDat.y;\n  bCylRad = stDat.z;\n  bCylHt = stDat.w;\n  stDat = Loadv4 (4 * nObj + 2);\n  mPtr.xyz = stDat.xyz;\n  dstFar = 200.;\n  az = 0.;\n  el = -0.13 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    el += 0.3 * pi * mPtr.y;\n    az += 0.45 * pi * mPtr.x;\n  }\n  el = clamp (el, -0.28 * pi, -0.05 * pi);\n  az = clamp (az, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.;\n  ro = vec3 (0., 1.5 * bCylHt, -0.9 * bCylRad);\n  rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uv.x / (zmFac * asp)))) * asp, uv.y / zmFac, 1.));\n  ltDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  if (mPtr.z > 0. && min (uv.x - asp, uv.y - 1.) > -0.07) col = mix (col, vec3 (1., 1., 0.), 0.5);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Soup Can Dynamics\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat todCur, nStep, cylRad, cylLen, bCylRad, bCylHt, fOvlap, fricN, fricT, fricS;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nconst int nObj = 16;\nconst int nSphObj = 62;\n\nvec3 RSph (float s)\n{\n  vec3 r;\n  float z;\n  if (s < 60.) {\n    z = floor (s / 10.);\n    r = vec3 ((cylRad - 0.5) * sin (2. * pi * mod (s + 0.5 * z, 10.) / 10. + vec2 (0.5 * pi, 0.)),\n       (cylLen - 0.5) * (z - 2.5) / 2.5);\n  } else {\n    r = vec3 (0., 0., (cylLen - 0.5) * (2. * (s - 60.) - 1.));\n  }\n  return r;\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float vRel, fo, drv;\n  fo = fOvlap * (1. / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot, mRotN;\n  vec3 rmN, vmN, wmN, dr, dv, rts, rtsN, rms, vms, fc, am, wam, rMom;\n  float farSep, rSep, grav, dt, tqUp;\n  fOvlap = 1000.;\n  fricN = 0.5;\n  fricT = 2.;\n  fricS = 2.;\n  tqUp = 2.5;\n  grav = 10.;\n  dt = 0.01;\n  rm = Loadv4 (4 * mId).xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  if (nStep < 20.) return;\n  mRot = QtToRMat (qm);\n  farSep = 2. * length (vec2 (cylRad, cylLen)) + 2.;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = Loadv4 (4 * n).xyz;\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      mRotN = QtToRMat (Loadv4 (4 * n + 2));\n      wmN = Loadv4 (4 * n + 3).xyz;\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rts = mRot * RSph (float (j1));\n        rms = rm + rts;\n        vms = vm + cross (wm, rts);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rtsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rtsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rtsN));\n        }\n        am += fc;\n        wam += cross (rts, fc);\n      }\n    }\n  }\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rts = RSph (float (j));\n    rMom += dot (rts, rts) - rts * rts + 1./6.;\n    rts = mRot * rts;\n    rms = rm + rts;\n    vms = vm + cross (wm, rts);\n    rSep = bCylRad - length (rms.xz);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (- rSep * normalize (rms.xz), 0.).xzy, rSep, vms);\n      am += fc;\n      wam += cross (rts, fc);\n    }    \n    rSep = abs (abs (rms.y + bCylHt) - bCylHt);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., rSep * sign (rms.y), 0.), rSep, vms);\n      am += fc;\n      wam += cross (rts, fc);\n    }\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  wam += tqUp * cross (vec3 (0., 1., 0.), mRot * vec3 (0., 0., 1.));\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b = Hashff (todCur + float (mId));\n  rm = vec3 (9. * (mod (float (mId), 4.) - 1.5), 9., 9. * (floor (float (mId) / 4.) - 1.5));\n  qm = EulToQt (vec3 (0., 0.5 * pi * (0.8 + 0.4 * b), 0.));\n  vm = vec3 (- 3. * rm.xz / max (0.1, length (rm.xz)), 0.).xzy;\n  wm = vec3 (0.5 * (b - 0.5));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float tCur, mxStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nObj + 3) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mId = (pxId < 4 * nObj) ? mId = pxId / 4 : -1;\n  doInit = false;\n  mxStep = 2400.;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    doInit = true;\n    cylRad = 2.2;\n    cylLen = 2.7;\n    bCylRad = 40.;\n    bCylHt = 15.;\n  } else {\n    stDat = Loadv4 (4 * nObj);\n    nStep = stDat.x;\n    stDat = Loadv4 (4 * nObj + 1);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    bCylRad = stDat.z;\n    bCylHt = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep) doInit = true;\n  }\n  if (mPtr.z > 0. && mPtr.x > 0.5 - 0.03 / asp && mPtr.y > 0.5 - 0.03 && nStep > 50.) doInit = true;\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nObj;\n    if      (pxId == kp + 0) stDat = vec4 (nStep, mxStep, 0., 0.);\n    else if (pxId == kp + 1) stDat = vec4 (cylRad, cylLen, bCylRad, bCylHt);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz = vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n     \n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;\n  a2 = 0.5 * (e.x - e.z);\n  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);\n  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3), c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Soup Can Dynamics\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat todCur, nStep, cylRad, cylLen, bCylRad, bCylHt, fOvlap, fricN, fricT, fricS;\nconst float txRow = 128.;\nconst float pi = 3.14159;\n\nconst int nObj = 16;\nconst int nSphObj = 62;\n\nvec3 RSph (float s)\n{\n  vec3 r;\n  float z;\n  if (s < 60.) {\n    z = floor (s / 10.);\n    r = vec3 ((cylRad - 0.5) * sin (2. * pi * mod (s + 0.5 * z, 10.) / 10. + vec2 (0.5 * pi, 0.)),\n       (cylLen - 0.5) * (z - 2.5) / 2.5);\n  } else {\n    r = vec3 (0., 0., (cylLen - 0.5) * (2. * (s - 60.) - 1.));\n  }\n  return r;\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float vRel, fo, drv;\n  fo = fOvlap * (1. / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot, mRotN;\n  vec3 rmN, vmN, wmN, dr, dv, rts, rtsN, rms, vms, fc, am, wam, rMom;\n  float farSep, rSep, grav, dt, tqUp;\n  fOvlap = 1000.;\n  fricN = 0.5;\n  fricT = 2.;\n  fricS = 2.;\n  tqUp = 2.5;\n  grav = 10.;\n  dt = 0.01;\n  rm = Loadv4 (4 * mId).xyz;\n  vm = Loadv4 (4 * mId + 1).xyz;\n  qm = Loadv4 (4 * mId + 2);\n  wm = Loadv4 (4 * mId + 3).xyz;\n  if (nStep < 20.) return;\n  mRot = QtToRMat (qm);\n  farSep = 2. * length (vec2 (cylRad, cylLen)) + 2.;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = Loadv4 (4 * n).xyz;\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = Loadv4 (4 * n + 1).xyz;\n      mRotN = QtToRMat (Loadv4 (4 * n + 2));\n      wmN = Loadv4 (4 * n + 3).xyz;\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rts = mRot * RSph (float (j1));\n        rms = rm + rts;\n        vms = vm + cross (wm, rts);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rtsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rtsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rtsN));\n        }\n        am += fc;\n        wam += cross (rts, fc);\n      }\n    }\n  }\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rts = RSph (float (j));\n    rMom += dot (rts, rts) - rts * rts + 1./6.;\n    rts = mRot * rts;\n    rms = rm + rts;\n    vms = vm + cross (wm, rts);\n    rSep = bCylRad - length (rms.xz);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (- rSep * normalize (rms.xz), 0.).xzy, rSep, vms);\n      am += fc;\n      wam += cross (rts, fc);\n    }    \n    rSep = abs (abs (rms.y + bCylHt) - bCylHt);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., rSep * sign (rms.y), 0.), rSep, vms);\n      am += fc;\n      wam += cross (rts, fc);\n    }\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  wam += tqUp * cross (vec3 (0., 1., 0.), mRot * vec3 (0., 0., 1.));\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b = Hashff (todCur + float (mId));\n  rm = vec3 (9. * (mod (float (mId), 4.) - 1.5), 9., 9. * (floor (float (mId) / 4.) - 1.5));\n  qm = EulToQt (vec3 (0., 0.5 * pi * (0.8 + 0.4 * b), 0.));\n  vm = vec3 (- 3. * rm.xz / max (0.1, length (rm.xz)), 0.).xzy;\n  wm = vec3 (0.5 * (b - 0.5));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float tCur, mxStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nObj + 3) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mId = (pxId < 4 * nObj) ? mId = pxId / 4 : -1;\n  doInit = false;\n  mxStep = 2400.;\n  if (iFrame <= 5) {\n    nStep = 0.;\n    doInit = true;\n    cylRad = 2.2;\n    cylLen = 2.7;\n    bCylRad = 40.;\n    bCylHt = 15.;\n  } else {\n    stDat = Loadv4 (4 * nObj);\n    nStep = stDat.x;\n    stDat = Loadv4 (4 * nObj + 1);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    bCylRad = stDat.z;\n    bCylHt = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep) doInit = true;\n  }\n  if (mPtr.z > 0. && mPtr.x > 0.5 - 0.03 / asp && mPtr.y > 0.5 - 0.03 && nStep > 50.) doInit = true;\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm);\n    else Step (mId, rm, vm, qm, wm);\n    kp = 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 4 * nObj;\n    if      (pxId == kp + 0) stDat = vec4 (nStep, mxStep, 0., 0.);\n    else if (pxId == kp + 1) stDat = vec4 (cylRad, cylLen, bCylRad, bCylHt);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz = vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n     \n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;\n  a2 = 0.5 * (e.x - e.z);\n  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);\n  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3), c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyRt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[798, 798, 848, 848, 1298], [1300, 1300, 1333, 1333, 1884], [1886, 1886, 1932, 1932, 2300], [2302, 2302, 2336, 2336, 2828], [2830, 2830, 2856, 2856, 3206], [3208, 3208, 3239, 3239, 5726], [5728, 5728, 5763, 5763, 7516], [7518, 7518, 7574, 7574, 8644], [8646, 8646, 8670, 8670, 8900], [8902, 8902, 8926, 8926, 8986], [9012, 9012, 9032, 9032, 9252], [9254, 9254, 9276, 9276, 9871], [9873, 9873, 9898, 9898, 10273], [10275, 10275, 10297, 10297, 10324], [10326, 10326, 10348, 10348, 10375], [10377, 10377, 10422, 10422, 10525], [10527, 10527, 10584, 10584, 10667], [10669, 10669, 10699, 10699, 10812], [10814, 10814, 10850, 10850, 11056], [11150, 11150, 11175, 11175, 11298], [11332, 11332, 11356, 11356, 11416], [11418, 11418, 11442, 11442, 11572], [11574, 11574, 11599, 11599, 11785], [11787, 11787, 11808, 11808, 11963], [11965, 11965, 11994, 11994, 12206], [12208, 12208, 12247, 12247, 12427]], "test": "untested"}
{"id": "3tyczd", "name": "Cubic Equation Solver", "author": "oneshade", "description": "Cubic equation solver.", "tags": ["math", "solver", "cubic", "equation"], "likes": 6, "viewed": 351, "published": 3, "date": "1611535267", "time_retrieved": "2024-07-30T19:42:33.978747", "image_code": "/*\nI wrote a cubic solver!\nNow using the complex solution (culling complex roots though).\n\nI heavily referenced the wikipedia article (its pretty good in my opinion):\nhttps://en.wikipedia.org/wiki/Cubic_equation\n\nAlso good video by Mathologer:\nhttps://www.youtube.com/watch?v=N-KXStupwsc\n\nThe solver is in the common tab.\nCubic solver in python: https://repl.it/@hathnoname/Cubic-Equation-Solver#main.py\nCubic solver on desmos: https://www.desmos.com/calculator/he38d6zfdd\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float a = sin(iTime) * 2.0;\n    float b = sin(iTime) * 5.0;\n    float c = cos(iTime * 0.75);\n    float d = sin(iTime * 0.5);\n\n    float f = a * uv.x * uv.x * uv.x + b * uv.x * uv.x + c * uv.x + d;\n    float g = 3.0 * a * uv.x * uv.x + 2.0 * b * uv.x + c; // Derivative for DE\n    color.r += smoothstep(unit, 0.0, abs(uv.y - f) / sqrt(1.0 + g * g));\n    color.b += smoothstep(unit, 0.0, abs(uv.y));\n\n    vec3 roots;\n    int nroots = solveCubic(a, b, c, d, roots);\n    for (int n=0; n < nroots; n++) {\n        color += smoothstep(unit, 0.0, length(uv - vec2(roots[n], 0.0)) - 0.05);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "const vec2 eta = vec2(-0.5, sqrt(0.75));\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return h < 0.0 ? 1 : 3;\n}\n\n/*\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float aa = a * a, bb = b * b;\n\n    float denom = 3.0 * aa;\n    float inflect = b / (3.0 * a);\n\n    float p = c / a - bb / denom;\n    float q = bb * b / (13.5 * aa * a) - b * c / denom + d / a;\n    float ppp = p * p * p, qq = q * q;\n\n    float p2 = abs(p);\n    float v1 = 1.5 / p * q;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (p < 0.0) roots[0] = sign(q) * cosh(acosh(v2 * -sign(q)) / 3.0);\n        else roots[0] = sinh(asinh(v2) / 3.0);\n        roots[0] = -2.0 * sqrt(p2 / 3.0) * roots[0] - inflect;\n        return 1;\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / p)) / 3.0; // 0/3,       2/3,               4/3\n        roots = 2.0 * sqrt(-p / 3.0) * cos(vec3(ac, ac - 2.09439510239, ac - 4.18879020479)) - inflect;\n        return 3;\n    }\n}\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[477, 477, 532, 532, 1299]], "test": "untested"}
{"id": "3tycRd", "name": "Cellular Automata Cobra", "author": "xavierseb", "description": "Interesting result from cellular automata formula\n\nIf you pick 1px (0.004 ?)  head size, you get the standard result of cellular automata.", "tags": ["automata", "feedback", "cellular", "backbuffer"], "likes": 2, "viewed": 333, "published": 3, "date": "1611529139", "time_retrieved": "2024-07-30T19:42:34.814513", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = vec2(uv.x, uv.y * (iResolution.y/iResolution.x));\n    \n    float x = texture(iChannel0, uv).r;\n    fragColor = vec4(vec3(pow(x, 4.)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cellular Automata Cobra \n\n\n// large head\n#define HEAD_SIZE .1\n\n// head for original cellular automata result\n//#define HEAD_SIZE .004\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  ) {\n\tvec2 uv=fragCoord/iResolution.xy;\n\tvec2 res=iResolution.xx/200000.;\n\tfloat c=1.;\n\t//vec2 pos= vec2(0.5,max(sin(iTime)*.8,sin(iTime*2.)*.1)); // Cobra\n\tvec2 pos = iMouse.x<1.? vec2(0.5+cos(iTime*4.)/24.,max(sin(iTime)*.9,sin(iTime*2.)*.1)) : iMouse.xy/iResolution.xy;\n    //if(pos.y<0.) pos.y=.0;     if(pos.y>1.) pos.y=.5; // prevent screen from filling\n\t\n    if(distance(uv,pos)>HEAD_SIZE) {\n    \n\t\tfloat p0 = round(texture( iChannel0, uv + res ).r); \n\t\tfloat p1 = round(texture( iChannel0, uv + vec2( 0.,res.y) ).r); \n\t\t//float p1 = texture2D( bb, uv - vec2( 0.,res.y) ).r; \n\t\tfloat p2 = round(texture( iChannel0, uv + vec2(-res.x,res.y) ).r); \n\t\n\t\tif(p0==p2) c=0.;                                           // #90\t\t\t\t\t\t\n\t\t// c=0.; if(p0+p1+p2==1.) c=1.; if(p0==0.&&p1==1.&&p2==1.) c=1.; // #30\t\t\n\t\t// c=0.; if(p0+p1+p2==1.) c=1.; if(p0+p1+p2==3.) c=1.;\t// #150\t\t\t\t\n\t\t// if(p0+p1==2.&&p2==0.) c=0.; if(p1+p2==2.&&p0==0.) c=0.; if(p0+p1+p2==0.) c=0.;\t// #182\t\t\t\t\t\n\t\t// if(p0+p1+p2==3.) c=0.; if(p0+p1+p2==0.) c=0.; if(p0==1.&&p1==0.&&p2==1.) c=0.;\t// #109\t\n\t}\n\n\tfragColor=vec4(c);\n    if(uv.y>.99)fragColor=vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 252]], "test": "untested"}
{"id": "3lGyRd", "name": "Fractal Path Tracer", "author": "michael0884", "description": "A fork of MMSE specifically tuned for path tracing", "tags": ["game"], "likes": 22, "viewed": 1072, "published": 3, "date": "1611528646", "time_retrieved": "2024-07-30T19:42:36.075142", "image_code": "// Fork of \"Marble Marcher: SE\" by michael0884. https://shadertoy.com/view/3lKyDR\n// 2021-01-24 21:45:11\n\n//Marble Marcher Shadertoy Edition\n//Version 0.9 BETA\n\n//Ported by michael0884 (Mykhailo Moroz)\n\n//Original Marble Marcher by CodeParade\n//https://github.com/HackerPoet/MarbleMarcher\n\n//Also check out Marble Marcher Community Edition!\n//https://github.com/WAUthethird/Marble-Marcher-Community-Edition\n\n//Notable features:\n//Temporal antialiasing with disocclusion rejection, velocity vectors and neighbor clamping\n//Lots of blue noise\n//Ambient occlusion \n//PBR rendering\n//Path tracing support, uncomment the define in Common\n//Path tracer is also PBR with refraction support\n//Physics in purely shader based\n\n//Instructions\n//WASD/Arrows and mouse to move marble. Q/E camera distance. \n//R - restart level\n//SPACE - next level(only when you completed this one)\n//Backspace - return to main menu\n//F - go to free camera mode, in this mode Q/E regulate camera speed\n//Change parameters in Common tab\n//level transition buttons \n//P - next level\n//O - previous level\n//M - restart frame accumulation\n\n//comment if the compiler wasn't able to optimize text rendering\n#define RENDER_TEXT\n\n#define STRINGS 8\n#define TOTCHARS STRLENGTH*STRINGS\n/*\nconst uint[] TEXT_ARRAY = uint[](\n  STRING(M,a,r,b,l,e,_,M,a,r,c,h,e,r,_,_,_,_,_,_,_,_,_,_),     //0\n  STRING(S,h,a,d,e,r,t,o,y,_,E,d,i,t,i,o,n,_,_,_,_,_,_,_),     //1\n  STRING(P,o,r,t,_,b,y,_,m,i,c,h,a,e,l,_0,_8,_8,_4,_,_,_,_,_), //2\n  STRING(O,r,i,g,i,n,a,l,_,b,y,_,C,o,d,e,P,a,r,a,d,e,_,_),     //3\n  \n  STRING(P,r,e,s,s,_,S,p,a,c,e,_,t,o,_,C,o,n,t,i,n,u,e,_),     //4\n  STRING(P,r,e,s,s,_,R,_,t,o,_,R,e,s,t,a,r,t,_,L,e,v,e,l),     //5\n  \n  STRING(P,l,a,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),     //6\n  STRING(L,e,v,e,l,s,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),      //7\n  \n  STRING(B,a,c,k,_,t,o,_,M,a,i,n,_,M,e,n,u,_,_,_,_,_,_,_),\n  STRING(J,u,m,p,_,t,h,e,_,c,r,a,t,e,r,_,_,_,_,_,_,_,_,_),\n  STRING(T,o,o,_,m,a,n,y,_,t,r,e,e,s,_,_,_,_,_,_,_,_,_,_),\n  STRING(H,o,l,e,_,i,n,_,o,n,e,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,e,w,a,r,e,_,o,f,_,b,u,m,p,s,_,_,_,_,_,_,_,_,_),\n  STRING(M,o,u,n,t,a,i,n,_,c,l,i,m,b,i,n,g,_,_,_,_,_,_,_),\n  STRING(M,i,n,d,_,t,h,e,_,g,a,p,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(T,h,e,_,s,p,o,n,g,e,_,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,u,i,l,d,_,u,p,_,s,p,e,e,d,_,_,_,_,_,_,_,_,_,_),\n  STRING(A,r,o,u,n,d,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(T,o,p,_,o,f,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(M,e,g,a,_,C,i,t,a,d,e,l,_,_,_,_,_,_,_,_,_,_,_,_)\n);\n\n#define CONTOUR 1.1\n#define CHAR_WIDTH 0.5\n\nvoid draw_char(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, uint char)\n{        \n  p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size); \n  if(p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) return; \n  int code = int(char);\n  \n  p.x=(fract(p.x) - 0.5)*CHAR_WIDTH + 0.5; p.y=1.-p.y;                 \n  p+=vec2(code%16,15-code/16);                          \n  float sdf = (texture(iChannel3, p/16.).w - 0.5 + 1.0/256.0)*size;\n  \n  float blend = smoothstep(CONTOUR, 0.0, sdf);\n  vec3 color = tcol*(2.*smoothstep(CONTOUR, -CONTOUR, sdf) - smoothstep(1.2*CONTOUR, 0.0, sdf));\n  incol = mix(incol, color, blend);\n}\n\nvoid draw_string(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, int string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(STRLENGTH) || p.y < 0.0 || p.y > 1.0) return;\n  draw_char(incol, p0, tcol, pos + vec2(floor(p.x)*size*CHAR_WIDTH,0.), size, TEXT_ARRAY[int(p.x) + string*STRLENGTH]);   \n}\n\nvoid draw_string(inout vec3 incol, in vec2 p, in vec3 tcol, in vec2 pos, in float size, in uint[8] string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(8) || p.y < 0.0 || p.y > 1.0) return;\n  \n  //compiler doesn't want to optimize dynamic array indexing, idk why\n  //a loop doesn't work either\n  draw_char(incol, p0, tcol, pos + vec2(0.0*size*CHAR_WIDTH,0.), size, string[0]);\n  draw_char(incol, p0, tcol, pos + vec2(1.0*size*CHAR_WIDTH,0.), size, string[1]);\n  draw_char(incol, p0, tcol, pos + vec2(2.0*size*CHAR_WIDTH,0.), size, string[2]);\n  draw_char(incol, p0, tcol, pos + vec2(3.0*size*CHAR_WIDTH,0.), size, string[3]);\n  draw_char(incol, p0, tcol, pos + vec2(4.0*size*CHAR_WIDTH,0.), size, string[4]);\n  draw_char(incol, p0, tcol, pos + vec2(5.0*size*CHAR_WIDTH,0.), size, string[5]);\n  draw_char(incol, p0, tcol, pos + vec2(6.0*size*CHAR_WIDTH,0.), size, string[6]);\n  draw_char(incol, p0, tcol, pos + vec2(7.0*size*CHAR_WIDTH,0.), size, string[7]);\n}\n  */\n#define SHARPEN 1.\n#define LOWSAMPLE_BLUR 1.\nvec4 tone(vec4 col)\n{\n   return tanh(EXPOSURE*pow(col, vec4(1.0/2.)));\n}\n\nvec4 sample_adaptive(sampler2D ch, vec2 uv)\n{\n    vec3 dx = vec3(1.0/vec2(textureSize(ch, 0)),0.);\n    \n    vec4 c = tone(texture(ch, uv));\n    vec2 v = decode(texelFetch(iChannel0, ivec2(uv*iResolution.xy), 0).w);\n    float k = mix(-LOWSAMPLE_BLUR, SHARPEN, smoothstep(0.1, 0.5, v.y));\n    \n    vec4 u = tone(texture(ch, uv + dx.zy));\n    vec4 d = tone(texture(ch, uv - dx.zy));\n    vec4 r = tone(texture(ch, uv + dx.xz));\n    vec4 l = tone(texture(ch, uv - dx.xz));\n    return (1.+k)*c - 0.25*k*(u+d+r+l); \n}\n  \nvoid mainImage( out vec4 c, in vec2 p )\n{\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec2 uv = p/iResolution.xy;\n    c.xyz = sample_adaptive(iChannel0, p/iResolution.xy).xyz;\n    //c.xyz = texture(iChannel1, p/(MR_SCALE*iResolution.xy)).xyz/5.0;\n    c.xyz = clamp(c.xyz, 0., 1.0);\n    \n    float ms = timers.x*100.0/60.0;\n    float fps = 1./timers.z;\n    float se = mod(timers.x/60., 60.);\n    float se0 = mod(-timers.x/60., 60.);\n    float dse0 = mod(se0, 1.0);\n    float mi = timers.x/3600.;\n    uint[8] timer = uint[](NUM2CHAR(mi/10.0),NUM2CHAR(mi),C(co),NUM2CHAR(se/10.0),NUM2CHAR(se),C(co),NUM2CHAR(ms/10.0),NUM2CHAR(ms));   \n    uint[8] fps_text = uint[](NUM2CHAR(fps/10.0),NUM2CHAR(fps),C(_),C(F),C(P),C(S),C(_),C(_));   \n    \n    float font_size = FONT_SCALE;\n    c.w = 1.0;\n    \n    //draw_string(c.xyz, p, vec3(1.), vec2(0.9, 0.01)*iResolution.xy, 20.0*font_size,  fps_text);\n    switch(int(MODE/64.0))\n    {\n    case GAMEMODE_MENU: //MAIN MENU\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.03)*iResolution.xy, 62.0*font_size,  0);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.40, 0.15)*iResolution.xy, 35.0*font_size,  1);\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  2);\n       // draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  3);\n       \n        break;\n    case GAMEMODE_LEVELS: //LEVELS MENU\n        \n        break;\n    case GAMEMODE_GAME: //TIMER\n        if(timers.x>=0.)\n        {\n           // draw_string(c.xyz, p, vec3(1.), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        }\n        else\n        {\n           // draw_char(c.xyz, p, vec3(1.), vec2(0.47 - 0.008*dse0, 0.01)*iResolution.xy, (80.0 + 40.0*dse0)*font_size,  NUM2CHAR(se0+1.0));\n        }\n        return;    \n    case GAMEMODE_FINISH: \n        //draw_string(c.xyz, p,  vec3(0.000,0.702,1.000), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  4);\n        //draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  5);\n        break;    \n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//rendering settings\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n#define LIGHT_BRIGHTNESS 2.0\n#define FRACTAL_ITER 12\n#define FOV 1.0\n#define EXPOSURE 1.0\n#define ADAPTIVE_PHYSICS_ITERATIONS\n//#define FORCE_ALONG_CAMERA\n\n//multiresolution scaling\n#define MR_SCALE 3.0\n\n#define PATH_TRACING\n#define BOUNCES 6\n#define DIRECT_LIGHT\n#define AMBIENT 5.0\n#define APERTURE 0.00\n\n//TAA\n#define DISOCCLUSION_REJECTION 6e-4\n#define CAMERA_MOVEMENT_REJECTION 5e-3\n\n#ifdef PATH_TRACING\n    #define REPROJECTION 1.0\n#else\n    #define REPROJECTION 0.9\n#endif\n\n//#define AMBIENT_OCCLUSION\n//#define SHADOWS\n#define DIRECT_BRIGHTNESS vec3(6.0)\n\n#define FRACTAL_F0 vec3(0.1)\n#define FRACTAL_ROUGHNESS 0.02\n#define FRACTAL_TRANSPARENT false\n#define FRACTAL_WHITE 0.9\n\n#define DISOCCLUSION_REJECTION_STR 1.0\n#ifdef PATH_TRACING\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#else\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#endif\n\n\n//#define AUTO_FOCUS\n#define FOCAL_PLANE 0.3\n\n\n//gameplay defines\n#define NUM 16\n\n#define MOUSE_       0\n#define CAM_ANGLE_   1\n#define CAM_POS_     2\n#define PCAM_ANGLE_  3\n#define PCAM_POS_    4\n#define PRESOLUTION_ 5\n#define CAM_VEL_     6\n//scene\n#define LIGHT_POS_   7\n#define MARBLE_POS_  8\n#define DMARBLE_POS_ 9\n#define MARBLE_VEL_  10\n#define TIMER_MODE_  11\n#define FLAG_POS_    12\n\n//fractal angles, scale\n#define FRAC_PARAM1_ 13\n//shift\n#define FRAC_PARAM2_ 14\n//color\n#define FRAC_PARAM3_ 15\n\n#define GAMEMODE_MENU 0\n#define GAMEMODE_LEVELS 1\n#define GAMEMODE_GAME 3\n#define GAMEMODE_FINISH 4\n#define GAMEMODE_FREE 5\n\n#define GET_DATA(ch, i) texelFetch(ch, ivec2(i, 0), 0)\n\nfloat CAM_ANGLE;\n\n//fractal\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 iMarblePos, iFlagPos;\nvec3 iMarbleVel; vec4 dMarblePos;\n\nvec3 iLightDir;\nfloat isPlanet;\n\n//current and prev camera\nvec4 ang, pang; \nvec4 pResolution;\nmat3 cam, pcam;\nvec3 campos, pcampos;\nvec3 camvel;\nfloat radius;\n\nfloat time;\nvec3 timers;\nfloat MODE;\n\n\n//CAMERA stuff\nmat3 get_cam(vec2 ang)\n{\n    vec3 x_dir = vec3(cos(ang.x)*sin(ang.y), cos(ang.y), sin(ang.x)*sin(ang.y));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,1,0)));\n    vec3 z_dir = normalize(cross(y_dir, x_dir));\n    return mat3(-x_dir, y_dir, z_dir);\n}\n\n//use previous camera matrix and camera position to reproject a point onto previous frame\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = vec3(dot(pcam_mat[0],dir),dot(pcam_mat[1],dir),dot(pcam_mat[2],dir));\n    return vec3(screen.yz*iRes.y/(FOV*screen.x) + 0.5*iRes.xy, td);\n}\n\n//SCENE\nvoid load_scene(sampler2D data, float t, vec2 res)\n{\n    time = t;\n    CAM_ANGLE = 1./res.y;\n    vec4 d1 = GET_DATA(data, FRAC_PARAM1_);        \n    iFracScale = d1.x; iFracAng1 = d1.y+0.000*sin(t); iFracAng2 = d1.z; //Scale, Angle1, Angle2\n    isPlanet = d1.w;\n    iFracShift = GET_DATA(data, FRAC_PARAM2_).xyz;                //Offset\n    iFracCol =   GET_DATA(data, FRAC_PARAM3_).xyz;                    //Color\n    iMarblePos = GET_DATA(data, MARBLE_POS_);                //Marble radius + size\n    iFlagPos =  GET_DATA(data, FLAG_POS_);           //Flag radius + size\n    vec4 MV_ = GET_DATA(data, MARBLE_VEL_);\n    iMarbleVel = MV_.xyz;\n    radius = MV_.w;\n    \n    dMarblePos = GET_DATA(data, DMARBLE_POS_);\n    \n    vec4 TM_ = GET_DATA(data, TIMER_MODE_);\n    timers = TM_.xyz;\n    MODE = TM_.w;\n    \n    //current camera\n    ang = GET_DATA(data, CAM_ANGLE_);\n    campos = GET_DATA(data, CAM_POS_).xyz;\n    camvel = GET_DATA(data, CAM_VEL_).xyz;\n    cam = get_cam(ang.xy);\n    \n    //previous camera\n    pang = GET_DATA(data, PCAM_ANGLE_);\n    pcampos = GET_DATA(data, PCAM_POS_).xyz;\n    pcam = get_cam(pang.xy);\n    \n    iLightDir = normalize(GET_DATA(data, LIGHT_POS_).xyz);\n    \n    pResolution = GET_DATA(data, PRESOLUTION_);\n}\n\n//marble physics\nconst float ground_force = 0.008f;\nconst float air_force = 0.004f;\nconst float ground_friction = 0.99f;\nconst float air_friction = 0.995f;\nconst float orbit_speed = 0.005f;\nconst int max_marches = 10;\nconst int num_phys_steps = 6;\nconst float marble_bounce = 1.2f;\nconst float gravity = 0.005f;\n\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec3 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec3 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\nvec2 mp = vec2(-1.,1.);\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\nvoid boxFold(inout vec3 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_plane(vec3 p, vec4 d)\n{\n    return dot(p,d.xyz) + d.w;\n}\nfloat de_sphere(vec3 p, float r) {\n\treturn (length(p.xyz) - r);\n}\nfloat de_box(vec3 p, vec3 s) {\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0)));\n}\nfloat de_tetrahedron(vec3 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / sqrt(3.0);\n}\nfloat de_capsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r);\n}\n//##########################################\n//   Main DEs\n//##########################################\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec4 fractal(vec3 p)\n{\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), de_box(p, vec3(6.0))/scale);\n}\n\n\nvec4 mandelbulb(in vec3 p)\n{\n    p = p - 0.*iFlagPos.xyz + vec3(0., 2.4, 0.);\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec3 orbitrap = vec3(1.0);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<3; i++ )\n    {\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );     \n        \n        orbitrap = min( orbitrap, abs(w) );\n\n        m = dot(w,w);\n\t\tif( m > 2.0 )\n            break;\n    }\n\n    return vec4(orbitrap, 0.25*log(m)*sqrt(m)/dz);\n}\n\nvec2 de_fractal(vec3 p)\n{\n    return vec2(fractal(p).w, 0);\n}\n\nvec3 color_fractal(vec3 p)\n{\n    return fractal(p).xyz;\n}\n\nvec2 de_marble(vec3 p) \n{\n\tfloat de = de_sphere(p - iMarblePos.xyz, iMarblePos.w*0.98);\n    return vec2(de, 1);\n}\n\nvec2 de_flag(vec3 p) \n{\n\tvec3 f_pos = iFlagPos.xyz + vec3(1.5, 4, 0)*iFlagPos.w;\n\tvec3 p_s = p/iFlagPos.w;\n\tvec3 d_pos = p - f_pos;\n\tvec3 caps_pos = p - (iFlagPos.xyz + vec3(0, iFlagPos.w*2.4, 0));\n\t//animated flag\n\tfloat speed = 14.0;\n\tfloat oscillation = sin(8.0*p_s.x - 1.0*p_s.y - speed*time) +\n                    0.4*sin(11.0*p_s.x + 2.0*p_s.y - 1.2*speed*time) + \n                    0.15*sin(20.0*p_s.x - 5.0*p_s.y - 1.4*speed*time);\n\t//scale the flag displacement amplitude by the distance from the flagpole\n\tvec2 flag = vec2(0.6*de_box(d_pos + caps_pos.x*vec3(0,(0.02+ caps_pos.x* 0.5+0.01*oscillation),0.04*oscillation),\n                        vec3(1.5, 0.8, 0.005)*iFlagPos.w), 2);\n\tvec2 capsule = vec2(de_capsule(caps_pos, iFlagPos.w*2.4, iFlagPos.w*0.05), 3);\n    \n\treturn opUnion(flag, capsule);\n}\n\nvec2 physics_scene(vec3 p)\n{\n    vec2 fractal = de_fractal(p);\n    //\\\\vec2 bulb = vec2(mandelbulb(p).w, 5);\n    //vec2 mandelbox = vec2(mb(p).w,5.0);\n    vec2 plane =vec2(de_plane(p, vec4(0., 1.0, 0., 3.5)),6.);\n    return opUnion(fractal, plane);\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 physical = physics_scene(p);\n    vec2 marble = de_marble(p);\n   // vec2 flag = de_flag(p);\n   \n    return opUnion(physical, marble);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  0.25*(k.xyyx*scene(p + k.xyy*dx).x +\n\t\t\t      k.yyxx*scene(p + k.yyx*dx).x +\n\t\t\t      k.yxyx*scene(p + k.yxy*dx).x +\n\t\t\t      k.xxxx*scene(p + k.xxx*dx).x)/vec4(dx,dx,dx,1.0);\n}\n\nvec3 closestPoint(vec3 p) {\n\tconst vec3 k = vec3(1,-1,0);\n    const float dx = 1e-3;\n    vec4 n = 0.25*(k.xyyx*physics_scene(p + k.xyy*dx).x +\n\t\t\t       k.yyxx*physics_scene(p + k.yyx*dx).x +\n\t\t\t       k.yxyx*physics_scene(p + k.yxy*dx).x +\n\t\t\t       k.xxxx*physics_scene(p + k.xxx*dx).x); \n\tn.xyz = normalize(n.xyz);\n    p -= n.w*n.xyz;\n    //trace a few steps to the surface\n    for(int i = 0; i<1; i++)\n    {\n    //    p -= n.xyz*physics_scene(p).x;\n    }\n    return p;\n}\n\nstruct material\n{\n    vec3 color;\n    vec3 emission;\n    vec3 normal;\n    vec3 cpoint; //closest point\n    vec3 velocity;\n    float roughness;\n    bool transparent;\n    vec3 F0;\n    float inside;\n};\n\nmaterial getMaterial(inout vec4 p)\n{\n    material cur;\n    float mindistance = 0.75*max(CAM_ANGLE*p.w,MIN_DIST);\n    cur.normal = normalize(calcNormal(p.xyz, mindistance).xyz);\n    vec2 scene = scene(p.xyz);\n    cur.inside = sign(scene.x);\n    vec3 dsurface = cur.normal*scene.x;\n    cur.cpoint = p.xyz - dsurface;\n     \n    int id = int(scene.y);\n    cur.F0 = vec3(0.15);\n    cur.transparent = false; \n    cur.emission = vec3(0.0);\n    switch(id)\n    {\n    case 0:\n        cur.color = mix(vec3(1.0), color_fractal(cur.cpoint).xyz,FRACTAL_WHITE);\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = FRACTAL_ROUGHNESS;\n        cur.transparent = FRACTAL_TRANSPARENT; \n        cur.velocity = vec3(0.);//TODO with animations\n        cur.emission = 0.0*vec3(1.000,1.000,1.000)*exp(-300.*clamp(pow(abs(length( cur.color - vec3(0.000,0.298,1.000) )),2.),0.,1.));\n        break;\n    case 1:\n        cur.color = vec3(1.);\n        cur.roughness = 0.02;\n        cur.F0 = vec3(0.03);\n        cur.velocity = dMarblePos.xyz;\n        cur.emission = vec3(.0);\n        cur.transparent = true;\n        break;\n    case 2:\n        cur.color = vec3(1.000,0.078,0.078);\n         cur.transparent = true;\n        cur.roughness = 0.02;\n        cur.velocity = vec3(0.); //TODO\n        break;\n    case 3:\n        cur.color = vec3(1.000,0.867,0.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    case 4:\n        cur.color = vec3(0.000,0.118,1.000);\n        cur.roughness = 0.01;\n        cur.velocity = vec3(0.);\n        break;\n    case 5:\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = 0.008;\n        cur.transparent = true; \n        cur.color = mix(vec3(1.),mandelbulb(p.xyz).xyz, 1.0);\n        cur.velocity = vec3(0.);\n        break;\n    default:\n        cur.color = vec3(1.000,1.000,1.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    }\n    cur.color = pow(cur.color, vec3(1.62));\n    return cur;\n}\n\nbool trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float de = abs(scene(ro.xyz).x); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de - 2.0*step(de, md)*md); \n        if(de < md) return true;\n        if(ro.w > MAX_DIST) return false;\n    }\n    return true;\n}\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\nvec2 rand2t()\n{\n    pcg4d(s1); return vec2(s1.xy)/float(0xffffffffu);\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton(int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nconst vec4 ca = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 cb = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = vec2(textureSize(tex,0));\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\nuvec2 unpack_uint2x(uint x)\n{\n    return uvec2(x%0x00010000u,x/0x00010000u);\n}\n\nuint pack_uint2x(uvec2 x)\n{\n    return x.x + x.y*0x00010000u;\n}\n\nvec2 decode(float data)\n{\n    return vec2(unpack_uint2x(floatBitsToUint(data)))/100.;\n}\n\nfloat encode(vec2 data)\n{\n    return uintBitsToFloat(pack_uint2x(uvec2(data*100.0)));\n}\n\n//simplified ttg's GLSL character printing library\n//https://www.shadertoy.com/view/Wd2SDt\nconst struct CHARS {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CHAR = CHARS(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n  0x7fu);\n\n#define C(c) CHAR.c\n#define NUM2CHAR(x) (CHAR._0 + uint(x)%10u)\n#define STRLENGTH 24\n#define STRING(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23) \\\n     C(c0),C(c1),C(c2),C(c3),C(c4),C(c5),C(c6),C(c7),C(c8),C(c9),C(c10),C(c11), \\\n     C(c12),C(c13),C(c14),C(c15),C(c16),C(c17),C(c18),C(c19),C(c20),C(c21),C(c22),C(c23)\n\n\n#define MAIN_POS vec2(0.03, 0.30)*iResolution.xy\n#define LEVELS_POS vec2(0.03, 0.03)*iResolution.xy\n\n#define FONT_SCALE min(iResolution.x,iResolution.y)/400.0\n", "buffer_a_code": "//Controller\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.2/60.\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 11;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n////Around the world\n//Level(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n//      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nint GMODE, curLVL;\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1;\n    iFracAng2 = LVL.FracAng2;\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n    iMarblePos = LVL.MarblePos;\n    iMarbleVel = vec3(0.);\n    iFlagPos = LVL.FlagPos;\n    isPlanet = float(LVL.isPlanet);\n    \n    //set cemera to point to the flag\n    vec3 m2f = normalize(iFlagPos.xyz - iMarblePos.xyz);\n    float phi = atan(m2f.z, m2f.x);\n    float theta = acos(m2f.y);\n    ang.xy = vec2(phi - PI,PI - theta);\n    //camera distance from marble\n    radius = 10.;\n}\n\nvoid PhysicsIteration(float dt, vec3 marble_force, float frictionm)\n{\n    vec3 closest_fractal_point = closestPoint(iMarblePos.xyz);\n    vec3 dx = closest_fractal_point - iMarblePos.xyz;\n    float dist = length(dx);\n    dx = normalize(dx);\n    float onGround = step(dist, iMarblePos.w);\n    float force = ((dist < iMarblePos.w*1.14)?ground_force:air_force)*iMarblePos.w;\n    float friction =((dist < iMarblePos.w*1.14)?ground_friction:air_friction);\n    vec3 Gvec = (isPlanet==1.0)?normalize(iMarblePos.xyz):vec3(0.,1.,0);\n    //unintersect\n    iMarblePos.xyz += 0.3*onGround*dx*(dist - iMarblePos.w);\n    //momentum update\n    iMarbleVel += -marble_bounce*onGround*max(0.,dot(iMarbleVel, dx))*dx;\n\n    //update velocity\n    iMarbleVel += (-iMarblePos.w*gravity*Gvec +  frictionm*(friction - 1.0)*iMarbleVel + force*marble_force)*dt;\n    //update position\n    iMarblePos.xyz += iMarbleVel*dt;\n}\n\nvoid START(int levelid)\n{\n    levelid = levelid%levelnum;\n    timers = vec3(-3.*60., 0., iTimeDelta);\n    GMODE = GAMEMODE_GAME;\n    curLVL = levelid;\n    LoadLevel(Levels[levelid]);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    ivec2 pi = ivec2(p);\n    if(pi.x >= NUM && pi.y >= 1) discard;\n    \n    ///Loading Data\n    c = GET_DATA(iChannel2, pi.x);\n\n    vec4 mouse = GET_DATA(iChannel2,MOUSE_);\n    vec2 mousespeed = mouse.xy;\n\n    load_scene(iChannel2, iTime, iResolution.xy);\n\n    GMODE = int(MODE/64.0);\n    curLVL = int(MODE)%64;     \n\n    //Initialization\n    if(iFrame < 5)\n    {\n      \n        START(1);\n    }\n\n    if(GMODE < GAMEMODE_GAME) //Menus\n    {\n        pang = ang;\n        ang.xy = vec2(0.2*iTime, PI*0.35);         \n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        pcampos = campos;\n        campos = cam*vec3(-12.0, 0, 0) + vec3(0, 2, 0);\n\n        bool MB = (iMouse.w > 1.0);\n        vec2 MP = iMouse.xy;\n        \n        float font_size = FONT_SCALE;\n        if(MB)\n        {\n           \n       } \n    }\n    else //Gameplay\n    {\n        //Go into free camera mode\n        if(KeyPressEvent(KEY_F))\n        {\n            GMODE = (GMODE == GAMEMODE_FREE)?GAMEMODE_GAME:GAMEMODE_FREE;\n        }\n        if(KeyPressEvent(KEY_BSPACE))\n        {\n            GMODE = 0;\n        }\n        if(KeyPressEvent(KEY_R) || iMarblePos.y < -15.0)\n        {\n            START(curLVL);\n        }\n        if((KeyPressEvent(KEY_SPACE) && GMODE == GAMEMODE_FINISH) || KeyPressEvent(KEY_P))\n        {\n            START(curLVL+1);\n        }\n        if(KeyPressEvent(KEY_O))\n        {\n            START(abs(curLVL-1));\n        }\n\n        /////////cam update\n        pang = ang;\n        ang.xy = ang.xy + ang.zw*MOUSE_SENSITIVITY; // angle delta\n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n        ang.zw += vec2(-1.0, 1.0)*mouse.xy; //velocity\n        ang.zw *= 0.76;\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        //marble update\n        vec3 marble_force = vec3(0.);\n        float frictionm = 1.0; //friction multiplier\n\n        if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n        {\n            marble_force += cam[0];\n        }\n        if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n        {\n            marble_force -= cam[0];\n        }\n        if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n        {\n            marble_force += cam[1];\n        }\n        if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n        {\n            marble_force -= cam[1];\n        }\n\n        if(GMODE == GAMEMODE_GAME)\n        {\n            #ifndef FORCE_ALONG_CAMERA\n                marble_force = vec3(marble_force.x, 0., marble_force.z);\n                marble_force = marble_force/(length(marble_force)+1e-4);\n            #endif\n\n            marble_force = marble_force/max(length(marble_force), 1.);       \n        }\n\n        if(GMODE == GAMEMODE_FINISH)\n        {\n            vec3 flagmarble = (iFlagPos.xyz + vec3(0,8.*iFlagPos.w,0) - iMarblePos.xyz)/iFlagPos.w;\n            marble_force = 2.5*normalize(flagmarble)*min(length(flagmarble), 3.); \n            frictionm = 12.;\n        }\n\n        //PHYSICS\n        #ifdef ADAPTIVE_PHYSICS_ITERATIONS\n            float iterations = clamp(10.*timers.z*60.0, 4., 32.);\n        #else\n            float iterations = 10.;\n        #endif\n        float dt = 0.1;\n        vec4 pMarblePos = iMarblePos;\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        for(float i = 0.0; i<iterations; i++)\n            PhysicsIteration((timers.x >= 0.)?dt:0.0, marble_force, frictionm);\n        \n\n        dMarblePos = iMarblePos - pMarblePos;\n\n        //update camera position\n        pcampos = campos;\n\n        if(isKeyPressed(KEY_Q))\n        {\n            radius *= 1.0 - iterations*0.002;\n        }\n        if(isKeyPressed(KEY_E))\n        {\n            radius *= 1.01 + iterations*0.002;\n        }\n\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        {\n            //camera unintersection\n            vec3 rd = -cam[0];\n            float camd =iMarblePos.w*radius;\n            vec4 ro = vec4(iMarblePos.xyz + rd*iMarblePos.w*1.03,1e8);\n            if(scene(iMarblePos.xyz + cam*vec3(-camd,0,0)).x <= iMarblePos.w*0.2)\n            { ro.w = 0.;  trace(ro,rd); camd = ro.w; }  \n            campos = iMarblePos.xyz + cam*vec3(-camd, 0, 0);\n        }\n        else\n        {\n            //reuse radius as the speed regulator\n            camvel += - camvel*0.1 + CAMERA_SPEED*iMarblePos.w*marble_force*radius/10.; \n            campos += camvel;\n        }\n\n        //Win condition\n        if(GMODE == 3 && distance(iMarblePos.xyz, iFlagPos.xyz) < iFlagPos.w*4.0) GMODE = 4;\n\n        timers = vec3(timers.x + ((GMODE == 3)?dt*iterations:0.0), 0., mix(timers.z,iTimeDelta,0.03)); \n\n    }\n\n    //////////mouse update\n    if(length(iMouse.zw - iMouse.xy) > 10.)\n    {\n        mouse.xy = iMouse.xy - c.zw; // mouse delta\n        if(iFrame < 1)\n        {\n            mouse.xy = vec2(0.);\n        }\n    }\n    else\n    {\n        mouse.xy = vec2(0.); // mouse delta\n    }\n    mouse.zw = iMouse.xy; // mouse pos\n\n    switch(pi.x)\n    {\n    case MOUSE_: \n        c = mouse;\n        break;\n    case CAM_ANGLE_:  \n        c = ang;\n        break;\n    case CAM_POS_:  \n        c.xyz = campos;\n        break;\n    case CAM_VEL_:  \n        c = vec4(camvel, 0.);\n        break;\n    case LIGHT_POS_:\n        c.xyz = vec3(0.2, 2.0, 1.5);\n        break;\n    case PCAM_ANGLE_:\n        c = pang;\n        break;\n    case PCAM_POS_:\n        c.xyz = pcampos;\n        break;\n    case PRESOLUTION_:\n        c.xy = pResolution.zw;\n        c.zw = iResolution.xy;\n        break;\n    case MARBLE_POS_:  \n        c = iMarblePos;\n        break;\n    case DMARBLE_POS_:  \n        c = dMarblePos;\n        break;      \n    case MARBLE_VEL_:  \n        c = vec4(iMarbleVel, radius);\n        break;\n    case TIMER_MODE_:  \n        c = vec4(timers, float(GMODE*64 + curLVL));\n        break;\n    case FLAG_POS_:\n        c = iFlagPos;\n        break;\n    case FRAC_PARAM1_:\n        c = vec4(iFracScale, iFracAng1, iFracAng2, isPlanet);\n        break;\n    case FRAC_PARAM2_:\n        c = vec4(iFracShift, 0.);\n        break;\n    case FRAC_PARAM3_:\n        c = vec4(iFracCol, 0.);\n        break;  \n    }   \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Multiresolution ray marching/Cone marching \n//http://www.fulcrum-demo.org/wp-content/uploads/2012/04/Cone_Marching_Mandelbox_by_Seven_Fulcrum_LongVersion.pdf\n\nvec2 sResolution;\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*sResolution.xy)/sResolution.y;\n    vec4 r = vec4(0.);\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    sResolution = iResolution.xy/MR_SCALE;\n    if(any(greaterThan(p, sResolution))) discard;\n    \n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, sResolution);\n    CAM_ANGLE = 1.0/sResolution.y;\n    vec4 ro = vec4(0.); vec3 rd;\n    getRay(p, ro.xyz, rd, APERTURE);\n\n    trace(ro, rd);\n\n    c = vec4(ro.w);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//blue noise\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\nfloat SG(vec3 rd, vec3 l, float r)\n{\n    float lamb = 1.0/r;\n    float ldotr = dot(rd,normalize(l)); \n    return lamb*exp(lamb*(ldotr - 1.0))/(2.0*PI*(1. - exp(-2.0*lamb)));\n}\n\nvec3 sky(vec3 rd)\n{\n    vec3 light = vec3(1., 0., 0.)*SG(rd, iLightDir + vec3(0,.1,0), 0.01)\n               + vec3(0.067,0.000,1.000)*SG(rd, iLightDir + vec3(.1,0,0), 0.01)\n               + vec3(0.000,1.000,0.067)*SG(rd, iLightDir + vec3(0,0,.1), 0.01);\n    vec3 ambi = vec3(0.120,0.37,1.000)*SG(rd, vec3(0,-1,0), 0.6);\n    return 0.*AMBIENT*light + 6.*ambi;\n}\n\n#define LIGHT_ANGLE 0.2\n\nfloat shadowtrace(vec3 ro, vec3 rd, float maxd)\n{\n    float td = 0.;\n    //noise to remove shadow artifacts\n    float phase = rand() - 0.5;\n    float angle = 1e10;\n    for(int i = 0; i < 40; i++)\n    {\n        float de = scene(ro).x*(1. + 0.2*phase);\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        if(td > maxd) break;\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.02, LIGHT_ANGLE, angle);\n}\n\nfloat ambitrace(vec3 ro, vec3 rd)\n{\n    float td = 0.;\n    float angle = 1e10;\n    for(int i = 0; i < 6; i++)\n    {\n        float de = 1.2*scene(ro).x;\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.0, 0.35, angle);\n}\n\n\n//rendering samplers\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n)\n{\n    vec3 x; vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 ggxSample(vec3 wi, float alphax, float alphay, vec2 xi)\n{   \n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(xi.x);\n    float phi = (xi.y < a) ? xi.y / a*PI : PI + (xi.y - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((xi.y < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\nvec2 sampleDisk(vec2 xi)\n{\n\tfloat theta = TWO_PI * xi.x;\n\tfloat r = sqrt(xi.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3 cosineHemisphere(vec2 xi)\n{\n    vec2 disk = sampleDisk(xi);\n\treturn vec3(disk.x, disk.y, sqrt(max(0.0, 1.0 - dot(disk, disk))));\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nvec3 simple_shading(inout vec4 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    bool hit = trace(ro, rd);\n    if(hit)\n    {\n        material mat = getMaterial(ro); \n        \n        vec3 V = - rd;\n        vec3 N = mat.normal;\n        vec3 R = reflect(rd, N);\n        vec3 L = iLightDir;\n        vec3 H = normalize(V + L);\n        \n        vec3 kS = fresnel(V, N, mat.F0);\n        vec3 kD = 1.0 - kS;\n        \n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n        \n        #ifdef SHADOWS\n            float shadow = 0.;\n            if(NdotL > 0.0) shadow = shadowtrace(ro.xyz, iLightDir, MAX_DIST);\n        #else\n            float shadow = 0.0;\n        #endif\n        \n        float selfshadow = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, mat.roughness);  \n        \n        vec3 direct = shadow * (kD * mat.color / PI + specular) * DIRECT_BRIGHTNESS * NdotL;\n        \n        //AO\n        #ifdef AMBIENT_OCCLUSION\n            vec4 rnd = rand4blue();\n            float ambientshadow = ambitrace(ro.xyz + mat.normal*ro.w*0.001, \n                                            normalize(mat.normal + udir(rnd.xy)));\n        #else\n            float ambientshadow = 0.5 + 0.5*NdotL;\n        #endif\n        \n        \n        vec3 reflection = kS*texture(iChannel3, R).xyz;\n        vec3 ambient =AMBIENT*0.25*mat.color*(ambientshadow + reflection);\n        \n        col = ambient + direct;\n    }\n    else\n    {\n        col = AMBIENT*texture(iChannel3, rd).xyz;\n    }\n    return col;\n}\n\nvec3 pathtrace(inout vec4 ro0, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec3 absorption = vec3(1.);\n    vec4 ro = ro0; \n    for(int i = 0; i < BOUNCES; i++)\n    {\n        float id = 0.;\n        bool hit = trace(ro, rd);\n        if(i == 0) {ro0 = ro;}\n        if(hit)\n        {\n            vec4 rnd = rand4();\n            \n            material mat = getMaterial(ro);\n            \n            float F0avg = (mat.F0.x + mat.F0.y + mat.F0.z)/3.0; \n            float IOR = (1.0 - sqrt(F0avg))/(1.0 + sqrt(F0avg));\n            \n            vec3 V = - rd;\n            vec3 N = mat.normal*mat.inside;\n            vec3 R = reflect(rd, N);\n            vec3 L = (mat.inside==1.0)?iLightDir:refract(iLightDir, mat.normal, IOR);\n            vec3 H = normalize(V + L);\n            \n            vec3 kS = fresnel(V, N, mat.F0);\n            \n            //specular probability\n            float pS = (kS.x + kS.y + kS.z)/3.0;\n            \n            mat3 basis = mat3FromNormal(N);\n            mat3 inv = inverse(basis);\n            vec3 V_local = inv*V;\n           \n            vec3 incoming = mat.emission; \n            \n            #ifdef DIRECT_LIGHT\n                float NdotL = max(dot(N, L), 2e-5);\n                float NdotV = max(dot(N, V), 2e-5);\n                \n                float selfshadowL = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness);\n                \n                vec3 specular = vec3(1.0)*NDF_ggx(H, N, mat.roughness)/max(4.0*NdotL*NdotV,1e-5);  \n                vec3 refracted = mat.color*((mat.transparent)?((mat.inside == 1.0)?vec3(0.):(specular)):(vec3(1.0/ PI))) ;\n                specular = selfshadowL*((mat.inside == -1.0)?vec3(0.0):specular);\n                vec3 direct = ((1. - kS)*refracted + kS*specular) * NdotL;\n                \n                float shadow = 0.;\n                vec3 rf = (mat.inside == -1.0)?(10.0*(mat.cpoint - ro.xyz)):(vec3(0.));\n                if(length(direct) > 0.005) shadow = shadowtrace(ro.xyz + rf, iLightDir, MAX_DIST);\n\n                col += absorption*DIRECT_BRIGHTNESS * shadow * direct;\n            #endif\n            \n            \n            //sample microfacet normal\n            vec3 M = ggxSample(V_local, mat.roughness, mat.roughness, rnd.xy);\n            \n            rd = reflect(-V_local, M); //new reflected ray direction\n\n            float selfshadowR = G_ggx(rd.z,mat.roughness)*G_ggx(V_local.z,mat.roughness);\n            \n            if(rnd.z < pS*selfshadowR) //specular bounce\n            {\n                absorption *= kS/pS;\n            }\n            else //diffuse/refraction bounce\n            { \n                if(mat.transparent) //refraction\n                {\n                    vec3 newrd = refract(-V_local, M, pow(IOR,mat.inside));\n                    if(length(newrd) > 0.5) //not total internal reflection\n                    {\n                        absorption *= mat.color;\n                        rd = newrd;\n                        //reflect point inside\n                        ro.xyz = ro.xyz + 10.0*(mat.cpoint - ro.xyz);\n                    }\n                }\n                else //diffuse\n                { \n                    absorption *= mat.color;\n                    rd = cosineHemisphere(rnd.xy);  \n                }  \n            }\n            \n            col += absorption*incoming;\n            \n            if((absorption.x + absorption.y + absorption.z) < 0.03) break; \n          \n            \n           \n            rd = basis*rd; //return ray direction into world space\n        }\n        else\n        {\n            #ifdef DIRECT_LIGHT\n            float ambient = AMBIENT*0.5;\n            #else\n            float ambient = AMBIENT;\n            #endif\n            col += absorption*sky(rd);\n            break;\n        }\n        \n    }\n    return col;\n}\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 r = rand4blue();\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif\n    \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec4 col = vec4(0.);\n    \n    float td_PREV = texelFetch(iChannel0, ivec2(p/MR_SCALE), 0).x;\n    \n    vec4 ro = vec4(0.); vec3 rd; \n    vec2 jitter = halton(iFrame%16) - 0.5; \n    getRay(p + jitter, ro.xyz, rd, APERTURE);\n    \n    ro += vec4(rd, 1.0)*td_PREV;\n    \n    #ifdef PATH_TRACING\n        col += vec4(pathtrace(ro, rd), 1.0);\n    #else\n        col += vec4(simple_shading(ro, rd), 1.0);\n    #endif\n\n    c.xyz =min(col.xyz/col.w, 1000.0);\n    c.w = distance(ro.xyz, campos);\n}", "buffer_c_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//TAA\n\nvec3 encodePalYuv(vec3 rgb)\n{\n    return vec3(\n        dot(rgb, vec3(0.299, 0.587, 0.114)),\n        dot(rgb, vec3(-0.14713, -0.28886, 0.436)),\n        dot(rgb, vec3(0.615, -0.51499, -0.10001))\n    );\n}\n\nvec3 decodePalYuv(vec3 yuv)\n{\n    return vec3(\n        dot(yuv, vec3(1., 0., 1.13983)),\n        dot(yuv, vec3(1., -0.39465, -0.58060)),\n        dot(yuv, vec3(1., 2.03211, 0.))\n    ); \n}\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    vec2 jitter = halton(iFrame%16) - 0.5; \n    vec4 bufB = texture(iChannel0, (p-jitter)/iResolution.xy);\n    \n    vec4 col = vec4(bufB.xyz, 1.);\n    \n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 ro = vec4(campos, bufB.w);    \n    vec3 rd = normalize(cam*vec3(1, FOV*uv));\n    ro.xyz += ro.w*rd;\n    vec4 X = ro;\n    material mat = getMaterial(X);\n    ro.xyz -= mat.velocity;\n    \n    vec3 reprj = reproject(pcam, pcampos, pResolution.xy, ro.xyz);\n    vec2 puv = reprj.xy/iResolution.xy;\n    vec2 dpuv = abs(puv - vec2(0.5));\n\n    vec3 prev_col = abs(texture_Bicubic(iChannel1, puv).xyz);\n    \n    //neighborhood clamping\n    vec3 minc = vec3(1e10); \n    vec3 maxc = vec3(0.);\n    for(int i = -NEIGHBOR_CLAMP_RADIUS; i < NEIGHBOR_CLAMP_RADIUS; i++)\n        for(int j = -NEIGHBOR_CLAMP_RADIUS; j < NEIGHBOR_CLAMP_RADIUS; j++)\n    {\n        vec3 pix = encodePalYuv(texelFetch(iChannel0, ivec2(p) + ivec2(i,j), 0).xyz);\n        minc = min(pix, minc);\n        maxc = max(pix, maxc);\n    }\n    \n    vec3 preclamp = encodePalYuv(prev_col);\n    //prev_col = clamp(preclamp, minc, maxc);\n    //prev_col = mix(preclamp, prev_col, 0.9);\n    float delta = distance(prev_col, preclamp);\n    //prev_col = decodePalYuv(prev_col);\n     \n    \n    vec2 v = decode(texelFetch(iChannel1, ivec2(puv*iResolution.xy), 0).w);\n    \n    vec4 prev = vec4(prev_col, 1.0)*v.y/0.02;\n    float prev_td = 4.0/v.x;\n    \n    vec3 prev_pos = normalize(ro.xyz - pcampos)*prev_td + pcampos;\n    float ang_distance = distance(normalize(prev_pos - campos),normalize(ro.xyz - campos));\n    \n    if(iFrame < 2) prev*=0.0;\n    //prev*=mix(1.0, smoothstep(0.6, 0.5, delta), 0.1);\n    prev*=mix(1.0, step(ang_distance, DISOCCLUSION_REJECTION), DISOCCLUSION_REJECTION_STR);\n    float dist = distance(prev.xyz/prev.w, col.xyz/col.w);\n    prev*=mix(1.0, smoothstep(CAMERA_MOVEMENT_REJECTION, 0., distance(campos, pcampos)),0.14);\n    if(KeyPressEvent(KEY_M)) prev*= 0.0;\n\n    //prev*=mix(1.0, smoothstep(0.7, 0.6, dist),1.0);\n    col += prev*REPROJECTION*step(dpuv.x, 0.5)*step(dpuv.y, 0.5); \n    \n    c.xyz = col.xyz/col.w;\n    c.w = encode(vec2(4.0/ro.w, 0.02*col.w));\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4708, 4708, 4729, 4729, 4780], [4782, 4782, 4827, 4827, 5292]], "test": "untested"}
{"id": "WtGyRd", "name": "Crystal tunnel", "author": "jarble", "description": "A 3D fractal based on my [url=https://www.shadertoy.com/view/wtKcRc]\"Fractal tile mosaic 2.\"[/url]", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 5, "viewed": 336, "published": 3, "date": "1611523772", "time_retrieved": "2024-07-30T19:42:37.347739", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 100.0,\nEPSILON = 0.01,\nsize = 1000.0;\n\n//change these parameters to get different tile patterns.\n#define scale 5.5\n#define scale1 2.0\n#define scale2 1.9\n#define scale3 4.0\n#define ITERATIONS 3\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \n\nfloat fract1(float a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec3 fract1(vec3 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec3 fractal(vec3 uv1){\n    vec3 col,uv;\n    for(int c=0;c<3;c++){\n        uv = uv1;\n        //uv += vec2(iTime/3.0,iTime/8.0)/2.0;\n        for(int i=0;i<ITERATIONS;i++)\n        {\n            uv = (fract1(uv/scale2))*scale1;\n            uv= fract1(uv/(2.0-fract1((uv.x-uv.y)/(8.0)))-(uv/(1.7+(fract1(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yzx/scale;\n        \tuv=uv.yzx;\n        }\n     col[c] = fract(fract(uv.y)+fract(uv.x));\n\t}\n    return col;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    return length(fractal(p/10.0));\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(fractal(p/5.0)+fractal(p.yzx/6.0));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 illumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    //vec3 light1Pos = eye;\n    //vec3 light1Intensity = vec3(0.8);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light1Pos,\n    //                              light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        viewDir.x+=-.5;\n        /*if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }*/\n    \n    vec3 eye = vec3(-35.0+sin(iTime/2.0)/2.0,1.0+cos(iTime/2.0)/2.0,iTime*2.0+50.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = illumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[683, 683, 705, 705, 746], [748, 748, 768, 768, 809], [811, 811, 831, 831, 872], [874, 874, 897, 897, 1358], [1361, 1361, 1385, 1385, 1423], [1425, 1425, 1453, 1453, 1507], [1509, 1930, 2021, 2021, 2385], [2400, 2654, 2719, 2719, 2851], [2853, 2853, 2933, 2933, 3290], [3292, 3619, 3668, 3703, 3834], [3836, 3836, 3893, 3893, 4966]], "test": "untested"}
{"id": "3tyczt", "name": "First Volumetric Raymarcher", "author": "oneshade", "description": "My first volumetric raymarcher! Based on treize's \"[url=https://www.shadertoy.com/view/3lBfWR]Simple Volume[/url]\" shader.", "tags": ["clouds", "volumetric", "first", "smoothnoise"], "likes": 9, "viewed": 206, "published": 3, "date": "1611520269", "time_retrieved": "2024-07-30T19:42:38.192481", "image_code": "float noise(in vec3 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(lub, rub, local.x),\n                   local.y),\n\n               mix(mix(ldf, rdf, local.x),\n                   mix(luf, ruf, local.x),\n                   local.y),\n\n               local.z);\n}\n\nfloat mapVolume(in vec3 p) {\n    float fbm = snoise(p);\n    fbm += snoise(p * 2.0) * 0.5;\n    fbm += snoise(p * 4.0) * 0.25;\n    return fbm / 1.75 - 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float iters = 50.0;\n    float stepSize = 0.1 / rd.z;\n    float absorption = 40.0;\n    vec3 volColor = vec3(1.0, 0.7, 0.4);\n\n    float t = 0.0;\n    float v = 1.0;\n    for (float i=0.0; i < iters; i++) {\n        vec3 p = ro + rd * t;\n        float density = mapVolume(p);\n        if (density > 0.0) {\n            float d = density / iters;\n            v *= 1.0 - d * absorption;\n            if (v < 0.01) {\n                break;\n            }\n\n            fragColor.rgb += (d * v + volColor * d * v) * 20.0;\n        }\n\n        t += stepSize;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 119], [121, 121, 146, 146, 872], [874, 874, 902, 902, 1029], [1031, 1031, 1086, 1086, 1999]], "test": "untested"}
{"id": "WlGyRt", "name": "pretend it's a club", "author": "YitingLiu", "description": "color experiment with noise functions and time.", "tags": ["fractal", "noise", "simple", "fbm", "perlin", "gradient", "template", "function", "value", "cellular"], "likes": 1, "viewed": 301, "published": 3, "date": "1611514731", "time_retrieved": "2024-07-30T19:42:39.192807", "image_code": "// noise functions from youtube https://www.youtube.com/watch?v=ybbJz6C9YYA\n// git code https://github.com/Gonkee/Gonkees-Shaders/blob/master/noise%20textures.shader\n\n#define PI 3.14159265358979323846\n\nfloat rand(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin(dot(coord, vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\n\nvec2 rand2(vec2 coord){\n    coord = mod(coord,10000.);\n    return fract(sin( vec2( dot(coord,vec2(127.1,311.7)), dot(coord,vec2(269.5,183.3)) ) ) * 43758.5453);\n}\n\nfloat circle (in vec2 _st, in float _radius, in float _size){\n    vec2 dist = _st-vec2(0.5);\n    return smoothstep(_radius-_radius*_size,_radius+_radius*_size,dot(dist,dist)*4.0) ;       \n}\n\nfloat value_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i);\n    float tr = rand(i + vec2(1.,0.));\n    float bl = rand(i + vec2(0.,1.));\n    float br = rand(i + vec2(1.,1.));\n    \n    //linear distance will cause sharp transition \n    //use smoothstep or cubic function\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tl,tr,cubic.x);\n    float botmix = mix(bl,br,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);\n    \n    return wholemix;\n\n}\n\nfloat perlin_noise(vec2 coord){\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float tl = rand(i) * 6.283;\n    float tr = rand(i + vec2(1.,0.))* 6.283;\n    float bl = rand(i + vec2(0.,1.))* 6.283;\n    float br = rand(i + vec2(1.,1.))* 6.283;\n    \n    vec2 tlvec = vec2(-sin(tl),cos(tl));\n    vec2 trvec = vec2(-sin(tr),cos(tr));\n    vec2 blvec = vec2(-sin(bl),cos(bl));\n    vec2 brvec = vec2(-sin(br),cos(br));\n    \n    float tldot = dot (tlvec,f);\n    float trdot = dot(trvec,f - vec2(1.,0.));\n    float bldot = dot(blvec, f- vec2(0.,1.));\n    float brdot = dot(brvec, f - vec2(1.,1.));\n    \n    // or delete the +0.5 after the wholemix - this shows different patterns \n    //tldot = abs(tldot);\n    ////trdot = abs(trdot);\n    //bldot = abs(bldot);\n    //brdot = abs(brdot);\n    \n    vec2 cubic = f*f*(3.-2.*f);\n    \n    float topmix = mix(tldot,trdot,cubic.x);\n    float botmix = mix(bldot,brdot,cubic.x);\n    float wholemix = mix(topmix,botmix,cubic.y);//maintain the brightness \n    \n    return wholemix+0.5;\n    \n}\n\nfloat cellular_noise(vec2 coord){\n   vec2 i = floor(coord);\n    vec2 f = fract(coord);\n    \n    float min_dist=9999.;\n   for(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n        \n        vec2 node = rand2(i+vec2(x,y))+vec2(x,y);\n        float dist = sqrt((f-node).x*(f-node).x+(f-node).y*(f-node).y);\n        min_dist = min(min_dist,dist);\n       }\n    }\n    return min_dist;\n    \n}\n\n// can use it to combine with other noise functions \nfloat fbm(vec2 coord, int OCTAVES){\n    //for loop size \n    //int OCTAVES =4;\n    \n    float normalize_factor =0.;\n    float value =0.;\n    float scale = 0.5; \n    \n    for (int i =0; i< OCTAVES; i++){\n    value += cellular_noise(coord)*scale;\n    normalize_factor +=scale; \n    coord *=2.;\n    scale *= 0.5;\n    }\n    return value/normalize_factor; \n\n\n}\n   \nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += smoothstep(0.0,1.0,abs(sin(iTime)));\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec2 coord = uv*10.*abs(tan(iTime))*rotate2D(uv,cos(iTime)*PI*5.);\n    vec3 color = vec3(0.);\n     \n    float noise;\n    //noise = rand(coord);\n    noise = value_noise(coord);\n   // noise = perlin_noise(coord);\n    noise = cellular_noise(coord);\n   //noise = fbm(coord,int(abs(tan(iTime))*2.));\n   \n   \n\nuv-=random(abs(sin(iTime)));\n    color= vec3(rotate2D(uv,cos(iTime)*PI*10.),0.8);\n  \n    color/= vec3(rotate2D(coord,clamp(0., PI/2.,tan(iTime/1e5)*PI)),noise);\n    color-=noise+random(smoothstep(0.1,1.,abs(cos(iTime))));\n    color*=vec3(random(abs(tan(iTime/1e5))),atan(coord.y,coord.x),noise/coord.y);\n  \n     uv+=random(abs(sin(iTime)));\n\n   \n\n    fragColor = vec4(color*uv.x,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 225, 225, 326], [328, 328, 355, 355, 387], [390, 390, 413, 413, 552], [554, 554, 615, 615, 743], [745, 745, 775, 775, 1265], [1267, 1267, 1298, 1298, 2303], [2305, 2305, 2338, 2338, 2714], [2716, 2769, 2804, 2847, 3124], [3129, 3129, 3169, 3169, 3341], [3343, 3343, 3400, 3450, 4234]], "test": "untested"}
{"id": "wtKcRc", "name": "Fractal tile mosaic 2", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "tile", "mosaic"], "likes": 6, "viewed": 286, "published": 3, "date": "1611504587", "time_retrieved": "2024-07-30T19:42:40.053505", "image_code": "//change these parameters to get different tile patterns.\n#define scale 5.5\n#define scale1 2.0\n#define scale2 2.0\n#define scale3 8.0\n#define ITERATIONS 6\n\n/*\n#define scale1 1.5\n#define scale2 4.0\n#define scale3 8.0\n#define ITERATIONS 3\n*/\n\nfloat fract1(float a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    for(int c=0;c<3;c++){\n        vec2 uv = (fragCoord*20.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/3.0,iTime/8.0)/2.0;\n        for(int i=0;i<ITERATIONS;i++)\n        {\n            uv = (fract1(uv/scale2)+fract1(uv/scale3/2.0))*scale1;\n            uv= fract1(uv/(2.0-fract1((uv.x-uv.y)/(8.0)))-(uv/(1.7+(fract1(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = abs(fract(uv.y)-fract(uv.x));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 262, 262, 303], [305, 305, 325, 325, 366], [368, 368, 425, 425, 1004]], "test": "untested"}
{"id": "ttVyRc", "name": "Metal Kaleidoscope 2", "author": "mrange", "description": "Licence CC0: Metal Kaleidoscope 2\nExperimenting with truchet, FBM, smooth kaleidoscope and metal like lighting take 2", "tags": ["2d", "fbm"], "likes": 14, "viewed": 471, "published": 3, "date": "1611498626", "time_retrieved": "2024-07-30T19:42:41.038871", "image_code": "// Licence CC0: Metal Kaleidoscope 2\n// Experimenting with truchet, FBM, smooth kaleidoscope and metal like lighting take 2\n\n// SABS        from: ollj (shadertoy) (SABS is a really great tool)\n// hsv2rgb     from: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// modMirror1  from: http://mercury.sexy/hg_sdf/\n// pmin        from: iq (shadertoy)\n// raySphere   from: iq (shadertoy)\n// tanh_approx from: some math site, don't remember\n// pmin        from: iq (shadertoy)\n\n// fbm described by iq here: https://iquilezles.org/articles/fbm\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PSIN(x)         (0.5+0.5*sin(x))\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define L2(x)           dot(x, x)\n\n#define PERIOD          30.0\n#define NPERIOD         floor(TIME/PERIOD)\n#define TIMEINPERIOD    mod(TIME, PERIOD)\n#define FADE            1.0\n#define HPERIOD         hash(NPERIOD)\n\nconst float  truchet_lw = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)/2.0,1.0/2.0,sqrt(3.0)/3.0);\n  p = p.yx;\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  co += 100.0;\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  const float ts = 2.5;\n  hpp.x = tanh_approx(hpp.x/ts)*ts;\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat truchet_cell0(vec2 p) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2 = circle(p, 0.25);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nvec2 truchet(vec2 p, float h, out vec3 n) {\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  hp *= ROT(0.02*TIME);\n  hp += TIME*0.05;\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n  hp *= truchet_rots[int(r*4.0)];\n\n  float cd0 = truchet_cell0(hp);\n  float cd1 = truchet_cell1(hp);\n  float d0 = mix(cd0, cd1, (fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = abs(d) - truchet_lw;\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nfloat df(vec2 p, float h, out vec3 n) {\n  vec2 d = truchet(p, h, n); \n  return d.y;\n}\n\nfloat hf(vec2 p, float h) {\n  vec3 n;\n  float decay = 0.75/(1.0+0.125*L2(p));\n  float d = df(p, h, n);\n  const float ww = 0.085;\n  float height = (smoothstep(0.0, ww, d));\n  return pmax(2.0*height*decay, 0.5, 0.25);\n}\n\nfloat fbm(vec2 p, float h) {\n  const float aa = -0.45;\n  const mat2  pp = (2.03-0.0)*ROT(1.0);\n\n  float a = 1.0;\n  float d = 0.0;\n  float height = 0.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    height += a*hf(p, h);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return height/d;\n}\n\nvec2 distortCoords(vec2 p, float h) {\n  p.x = SABS(p.x, 0.1*abs(p.y)+0.001);\n  float tp = TIMEINPERIOD/PERIOD;\n  p*=ROT(TIMEINPERIOD*0.075);\n  p*=ROT(-PI*tanh_approx(0.125*(L2(p)-0.25)));\n  \n  p*=mix(1.5, 2.5, mix(tp, 1.0-tp, h));\n  return p;\n}\nconst float exclusionRadius = 0.25;\n\nfloat distanceField(vec2 p, float h, out vec3 n) {\n  float c = circle(p, exclusionRadius);\n  p = distortCoords(p, h);\n//  return df(p, h, n);\n  return pmin(c, df(p, h, n), 0.25);\n}\n\nfloat height(vec2 p, float h) {\n  p = distortCoords(p, h);\n  return tanh_approx(fbm(p, h));\n}\n\nvec3 normal(vec2 p, float h) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy, h) - height(p + eps.xy, h);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx, h) - height(p + eps.yx, h);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sphere) {\n  vec3 ce = sphere.xyz;\n  float ra = sphere.w;\n  vec3 oc = ro - ce;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - ra*ra;\n  float h = b*b - c;\n  if (h<0.0) return vec2(-1.0); // no intersection\n  h = sqrt(h);\n  return vec2(-b-h, -b+h);\n}\n\nconst vec3 up  = vec3(0.0, 1.0, 0.0);\nconst vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\nconst vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\n\nvec4 sphereCol(vec3 ro, vec3 rd, float h) {\n  vec4 sphere = vec4(0.0, 0.0, 0.0, exclusionRadius*0.95);\n  vec2 sphereIntersect = raySphere(ro, rd, sphere);\n  if (sphereIntersect.x == -1.0) {\n    return vec4(0.0);\n  }\n\n  vec3 p = ro + rd*sphereIntersect.x;\n  vec3 n = normalize(p - sphere.xyz);\n  vec3 r = reflect(rd, n);\n\n  vec3 ld1 = normalize(lp1 - p);\n  vec3 ld2 = normalize(lp2 - p);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n  float ref1  = max(dot(r, ld1), 0.0);\n  float ref2  = max(dot(r, ld2), 0.0);\n  \n  vec3 hsv = vec3(h+mix(0.6, 0.9, PSIN(TIME*0.1)), 0.5, 1.0);\n  \n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n\n  float fres = dot(-n, rd);\n  \n  vec3 col = vec3(0.0);\n  col += baseCol1*pow(diff1, 5.0);\n  col += baseCol2*pow(diff2, 2.5);\n  col *= 0.125;\n  \n  col += 0.5*baseCol1*pow(ref1, 10.0);\n  col += 0.5*baseCol2*pow(ref2, 5.0);\n  \n//  col += vec3(pow(1.0-fres, 6));\n  float t = smoothstep(0.0, 0.25, fres);\n  \n  return vec4(col, t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float hh = HPERIOD;\n  float l  = length(p);\n  \n  float fakeNorthernLightPhase = L2(p.x)*10.0;\n  float fakeNorthernLightAmp = mix(2.0, 10.0, tanh_approx(0.25*abs(p.x)));\n  float eyeHeight = mix(10.0, mix(10.0, fakeNorthernLightAmp, sqrt(q.y)), PSIN(fakeNorthernLightPhase));\n\n  \n  vec3  dn;\n  float d  = distanceField(p, hh, dn);\n  float h  = height(p, hh);\n  vec3  n  = normal(p, hh);\n\n  vec3 ro = vec3(0.0, eyeHeight, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(po - ro);\n  vec3 prd = normalize(pp - ro);\n  \n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n\n  vec3 hsv = vec3(hh+mix(0.6, 0.9, PSIN(TIME*0.1-10.0*l+(p.x+p.y))), tanh_approx(h*h*1.0), tanh_approx(1.0*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n  vec3 matCol   = 1.0-baseCol1*baseCol2;\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  baseCol1 *= mix(0.0, 4.0, 1.0/L2(lp1 - po));\n  baseCol2 *= mix(0.0, 3.0, 1.0/L2(lp2 - po));\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.25;\n  col += 1.00*matCol*baseCol1*mix(0.1, 1.0, pow(diff1, 4.0))*0.5;\n  col += 0.50*matCol*baseCol2*mix(0.1, 1.0, pow(diff2, 2.0))*0.5;\n  col = pow(col, vec3(1.25));\n  col += 4.0*baseCol1*pow(ref1, 20.0);\n  col += 2.0*baseCol2*pow(ref2, 10.0);\n\n  float gd = d;\n  const float glow_lw = 0.025;\n  gd = abs(gd)-glow_lw*2.0;\n  gd = abs(gd)-glow_lw;\n  vec3 glowCol = vec3(1.0);\n  glowCol = mix(baseCol1, glowCol, max(dot(ld1, up), 0.0));\n  glowCol = mix(baseCol2, glowCol, max(dot(ld2, up), 0.0));\n  vec3 finalGlowCol = glowCol*exp(-20.0*max(gd, 0.0));\n  finalGlowCol = mix(finalGlowCol, glowCol, smoothstep(-aa, aa, -d+glow_lw));\n  \n  float tuneOut = sqrt(1.0-q.x);\n  \n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n\n  vec4 scol = sphereCol(ro, prd, hh);\n  col = mix(col, scol.xyz, scol.w);  \n  col -= 0.5*0.125*tuneOut*finalGlowCol;\n  \n  col = postProcess(col, q);\n  \n  float fadeIn  = smoothstep(0.0, FADE, TIMEINPERIOD);\n  float fadeOut = 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEINPERIOD);\n  col = mix(vec3(0.0), col, fadeIn*fadeIn*fadeOut*fadeOut);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1274, 1274, 1296, 1296, 1465], [1467, 1467, 1495, 1515, 1591], [1593, 1593, 1621, 1621, 1821], [1823, 1823, 1854, 1854, 1880], [1882, 1882, 1904, 1904, 1967], [1969, 1969, 1990, 1990, 2088], [2090, 2090, 2112, 2112, 2156], [2158, 2158, 2179, 2179, 2224], [2226, 2226, 2253, 2253, 2322], [2324, 2324, 2369, 2369, 2523], [2525, 2525, 2586, 2586, 2859], [2861, 2861, 2900, 2900, 2985], [2987, 2987, 3026, 3026, 3055], [3057, 3057, 3086, 3086, 3234], [3236, 3236, 3265, 3265, 3429], [3431, 3431, 3474, 3474, 4047], [4049, 4049, 4088, 4088, 4134], [4136, 4136, 4163, 4163, 4353], [4355, 4355, 4383, 4383, 4633], [4635, 4635, 4672, 4672, 4879], [4917, 4917, 4967, 4967, 5097], [5099, 5099, 5130, 5130, 5192], [5194, 5194, 5224, 5224, 5439], [5441, 5441, 5478, 5478, 5731], [5733, 5733, 5780, 5780, 6022], [6149, 6149, 6192, 6192, 7202], [7204, 7204, 7259, 7259, 9739]], "test": "untested"}
{"id": "3lVyRc", "name": "Nishita sky Equirectangular", "author": "AlexApps99", "description": "Based on https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\nCurrenty has a bug in it", "tags": ["skyboxnishita"], "likes": 9, "viewed": 1354, "published": 3, "date": "1611461651", "time_retrieved": "2024-07-30T19:42:41.797841", "image_code": "// Nishita sky equirectangular\n// I have run into a strange bug and am not sure why it occurs\n// Check it out by uncommenting the line below\n//#define BUG\n// If you have any idea why this jittering occurs please let me know\n// Likely something to do with the integrals\n\n// Based on:\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\nconst float Re = 6360e3;\nconst float Ra = 6420e3;\nconst float Hr = 7994.0;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6, 33.1e-6);\n#define MIE\n#ifdef MIE\nconst float Hm = 1200.0;\nconst vec3 betaM = vec3(21e-6);\nconst float g = 0.76;\n#endif\n\n#define PI radians(180.0)\n#define INFINITY uintBitsToFloat(0x7F800000u)\n\n#define SAMPLES (32u)\n#define SAMPLES_LIGHT (8u)\n#define ALTITUDE (1.0)\n// We use a magic number here for the intensity of the sun (20). We will make it more\n// scientific in a future revision of this lesson/code\n#define SUN_INTENSITY (20.0)\n#define MIE_EXTINCTION_MUL (1.1)\n\n// Dir must be normalized\n// Orig must be centered on sphere\nbool raySphereIntersect(const in vec3 orig, const in vec3 dir, const in float radius, out float t0, out float t1) {\n    float b = dot(dir, orig);\n    float c = dot(orig, orig) - (radius * radius);\n\tfloat test = b*b - c;\n    // Intersection should have two points\n    if (test <= 0.0) return false;\n\ttest = sqrt(test);\n\tt0 = -b - test;\n\tt1 = -b + test;\n\tif (t0 > t1) t0 = t1, t1 = t0;\n\treturn true;\n}\n\nvec3 computeIncidentLight(const in vec3 orig, const in vec3 dir, in float tmin, in float tmax, const in vec3 sunDirection) {\n    float t0, t1;\n    if (!raySphereIntersect(orig, dir, Ra, t0, t1) || t1 < 0.0) return vec3(0.0);\n    if (t0 > tmin && t0 > 0.0) tmin = t0;\n    if (t1 < tmax) tmax = t1;\n    float segmentLength = (tmax - tmin) / float(SAMPLES);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0); // rayleigh contribution\n    float opticalDepthR = 0.0;\n    float mu = dot(dir, sunDirection); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction\n    float phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu);\n    #ifdef MIE\n    vec3 sumM = vec3(0.0); // mie contribution\n    float opticalDepthM = 0.0;\n    float phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * mu, 1.5));\n    #endif\n    for (uint i = 0u; i < SAMPLES; ++i) {\n        vec3 samplePosition = orig + (tCurrent + segmentLength * 0.5) * dir;\n        float height = length(samplePosition) - Re;\n        // compute optical depth for light\n        float hr = exp(-height / Hr) * segmentLength;\n        opticalDepthR += hr;\n        #ifdef MIE\n        float hm = exp(-height / Hm) * segmentLength;\n        opticalDepthM += hm;\n        #endif\n        // light optical depth\n        float t0Light, t1Light;\n        raySphereIntersect(samplePosition, sunDirection, Ra, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(SAMPLES_LIGHT), tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        #ifdef MIE\n        float opticalDepthLightM = 0.0;\n        #endif\n        uint j;\n        for (j = 0u; j < SAMPLES_LIGHT; ++j) {\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - Re;\n            if (heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            #ifdef MIE\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            #endif\n            tCurrentLight += segmentLengthLight;\n        }\n        if (j == SAMPLES_LIGHT) {\n            #ifdef MIE\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * MIE_EXTINCTION_MUL * (opticalDepthM + opticalDepthLightM);\n            #else\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR);\n            #endif\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += attenuation * hr;\n            #ifdef MIE\n            sumM += attenuation * hm;\n            #endif\n        }\n        tCurrent += segmentLength;\n    }\n\n    #ifdef MIE\n    return (sumR * betaR * phaseR + sumM * betaM * phaseM) * SUN_INTENSITY;\n    #else\n    return (sumR * betaR * phaseR) * SUN_INTENSITY;\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 o = (fragCoord / iResolution.xy - 0.5) * 2.0 * PI;\n    o.y /= 2.0;\n\n    vec3 dir = normalize(vec3(cos(o.x), tan(o.y), sin(o.x)) * cos(o.y));\n    float time = 0.2 * PI * iTime;\n\n    #ifdef BUG\n    vec3 sun_dir = normalize(vec3(0.0, 1.0, 0.0));\n    float d = Re + ALTITUDE;\n    vec3 pos = vec3(0.0, d*sin(time), d*-cos(time));\n    #else\n    vec3 sun_dir = normalize(vec3(0.0, sin(time), -cos(time)));\n    vec3 pos = vec3(0.0, Re + ALTITUDE, 0.0);\n    #endif\n\n    float t0, t1, tMax = INFINITY;\n    if (raySphereIntersect(pos, dir, Re, t0, t1) && t0 > 0.0) {\n        tMax = t0;\n    }\n    \n    fragColor = vec4(computeIncidentLight(pos, dir, 0.0, tMax, sun_dir), 0.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4363, 4363, 4418, 4418, 5094]], "test": "untested"}
{"id": "WtKczc", "name": "Fork Underwater leecorn 572", "author": "leecorn", "description": "My one-week artwork! An underwater scene.", "tags": ["waves", "light", "underwater", "bubbles", "shafts"], "likes": 20, "viewed": 981, "published": 3, "date": "1611461582", "time_retrieved": "2024-07-30T19:42:42.599699", "image_code": "// Created by Yilin Yan aka greenbird10\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat hash(vec2 p) {\n\treturn 0.5*(\n    sin(dot(p, vec2(271.319, 413.975)) + 1217.13*p.x*p.y)\n    ) + 0.5;\n}\n\nfloat noise(vec2 p) {\n  vec2 w = fract(p);\n  w = w * w * (3.0 - 2.0*w);\n  p = floor(p);\n  return mix(\n    mix(hash(p+vec2(0,0)), hash(p+vec2(1,0)), w.x),\n    mix(hash(p+vec2(0,1)), hash(p+vec2(1,1)), w.x), w.y);\n}\n\n// wave octave inspiration\n// Alexander Alekseev - Seascape\n// https://www.shadertoy.com/view/Ms2SD1\nfloat map_octave(vec2 uv) {\n  uv = (uv + noise(uv)) / 2.5;\n  uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  vec2 uvsin = 1.0 - abs(sin(uv));\n  vec2 uvcos = abs(cos(uv));\n  uv = mix(uvsin, uvcos, uvsin);\n  float val = 1.0 - pow(uv.x * uv.y, 0.65);\n  return val;\n}\n\nfloat map(vec3 p) {\n  vec2 uv = p.xz + iTime/2.;\n  float amp = 0.6, freq = 2.0, val = 0.0;\n  for(int i = 0; i < 3; ++i) {\n    val += map_octave(uv) * amp;\n    amp *= 0.3;\n    uv *= freq;\n    // uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  }\n  uv = p.xz - 1000. - iTime/2.;\n  amp = 0.6, freq = 2.0;\n  for(int i = 0; i < 3; ++i) {\n    val += map_octave(uv) * amp;\n    amp *= 0.3;\n    uv *= freq;\n    // uv = vec2(uv.x*0.6-uv.y*0.8, uv.x*0.8+uv.y*0.6);\n  }\n  return val + 3.0 - p.y;\n}\n\nvec3 getNormal(vec3 p) {\n  float eps = 1./iResolution.x;\n  vec3 px = p + vec3(eps, 0, 0);\n  vec3 pz = p + vec3(0, 0, eps);\n  return normalize(vec3(map(px),eps,map(pz)));\n}\n\n// raymarch inspiration\n// Alexander Alekseev - Seascape\n// https://www.shadertoy.com/view/Ms2SD1\nfloat raymarch(vec3 ro, vec3 rd, out vec3 outP, out float outT) {\n    float l = 0., r = 26.;\n    int i = 0, steps = 16;\n    float dist = 1000000.;\n    for(i = 0; i < steps; ++i) {\n        float mid = (r+l)/2.;\n        float mapmid = map(ro + rd*mid);\n        dist = min(dist, abs(mapmid));\n        if(mapmid > 0.) {\n        \tl = mid;\n        }\n        else {\n        \tr = mid;\n        }\n        if(r - l < 1./iResolution.x) break;\n    }\n    outP = ro + rd*l;\n    outT = l;\n    return dist;\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttotal += noise(n) * amplitude; \n\t\tn += n;\n\t\tamplitude *= 0.4; \n\t}\n\treturn total;\n}\n\nfloat lightShafts(vec2 st) {\n    float angle = -0.2;\n    vec2 _st = st;\n    float t = iTime / 16.;\n    st = vec2(st.x * cos(angle) - st.y * sin(angle), \n              st.x * sin(angle) + st.y * cos(angle));\n    float val = fbm(vec2(st.x*2. + 200. + t, st.y/4.));\n    val += fbm(vec2(st.x*2. + 200. - t, st.y/4.));\n    val = val / 3.;\n    float mask = pow(clamp(1.0 - abs(_st.y-0.15), 0., 1.)*0.49 + 0.5, 2.0);\n    mask *= clamp(1.0 - abs(_st.x+0.2), 0., 1.) * 0.49 + 0.5;\n\treturn pow(val*mask, 2.0);\n}\n\nvec2 bubble(vec2 uv, float scale) {\n    if(uv.y > 0.2) return vec2(0.);\n    float t = iTime/4.;\n    vec2 st = uv * scale;\n    vec2 _st = floor(st);\n    vec2 bias = vec2(0., 4. * sin(_st.x*128. + t));\n    float mask = smoothstep(0.1, 0.2, -cos(_st.x*128. + t));\n    st += bias;\n    vec2 _st_ = floor(st);\n    st = fract(st);\n    float size = noise(_st_)*0.07+0.01;\n    vec2 pos = vec2(noise(vec2(t, _st_.y*64.1)) * 0.8 + 0.1, 0.5);\n    if(length(st.xy - pos) < size) {\n        return (st + pos) * vec2(.1, .2) * mask;\n    }\n    return vec2(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ro = vec3(0.,0.,2.);\n    vec3 lightPos = vec3(8, 3, -3);\n    vec3 lightDir = normalize(lightPos - ro);\n\n    // adjust uv\n    vec2 uv = fragCoord;\n    uv = (-iResolution.xy + 2.0*uv) / iResolution.y;\n    uv.y *= 0.5;\n    uv.x *= 0.45;\n    uv += bubble(uv, 12.) + bubble(uv, 24.); // add bubbles\n\n    vec3 rd = normalize(vec3(uv, -1.));\n    vec3 hitPos;\n    float hitT;\n    vec3 seaColor = vec3(11,82,142)/255.;\n    vec3 color;\n    \n    // waves\n    float dist = raymarch(ro, rd, hitPos, hitT);\n    float diffuse = dot(getNormal(hitPos), rd) * 0.5 + 0.5;\n    color = mix(seaColor, vec3(15,120,152)/255., diffuse);\n    color += pow(diffuse, 12.0);\n\t// refraction\n    vec3 ref = normalize(refract(hitPos-lightPos, getNormal(hitPos), 0.05));\n    float refraction = clamp(dot(ref, rd), 0., 1.0);\n    color += vec3(245,250,220)/255. * 0.6 * pow(refraction, 1.5);\n\n    vec3 col = vec3(0.);\n    col = mix(color, seaColor, pow(clamp(0., 1., dist), 0.2)); // glow edge\n    col += vec3(225,230,200)/255. * lightShafts(uv); // light shafts\n\n    // tone map\n    col = (col*col + sin(col))/vec3(1.8, 1.8, 1.9);\n    \n    // vignette\n    // inigo quilez - Stop Motion Fox \n    // https://www.shadertoy.com/view/3dXGWB\n    vec2 q = fragCoord / iResolution.xy;\n    col *= 0.7+0.3*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKczc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[110, 110, 130, 130, 217], [219, 219, 240, 240, 432], [434, 535, 562, 562, 801], [803, 803, 822, 822, 1290], [1292, 1292, 1316, 1316, 1463], [1465, 1563, 1628, 1628, 2054], [2056, 2056, 2075, 2075, 2228], [2230, 2230, 2258, 2258, 2731], [2733, 2733, 2768, 2768, 3278], [3280, 3280, 3335, 3335, 4682]], "test": "untested"}
{"id": "3lVyzc", "name": "Fork Cloud_tunn leecorn 144", "author": "leecorn", "description": "cloud tunnel shader", "tags": ["raymarching", "cloud"], "likes": 1, "viewed": 257, "published": 3, "date": "1611461165", "time_retrieved": "2024-07-30T19:42:43.556140", "image_code": "// Using code from\n\n//Morgan McGuire for the noise function\n// https://www.shadertoy.com/view/4dS3Wd\n\n#define time iTime\n#define depth 70.0\n#define fogSize 25.0\nfloat fogCoef=1.0/(depth-fogSize);\nfloat PI=acos(-1.0);\n\nfloat random (in float x) {\n\treturn fract(sin(x)*1e4);\n}\n\nfloat noise(in vec3 p) {\n\tconst vec3 step = vec3(110.0, 241.0, 171.0);\n\n\tvec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\t// For performance, compute the base input to a\n\t// 1D random from the integer part of the\n\t// argument and the incremental change to the\n\t// 1D based on the 3D -> 1D wrapping\n\tfloat n = dot(i, step);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix( mix(mix(random(n + dot(step, vec3(0,0,0))),\n\trandom(n + dot(step, vec3(1,0,0))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,0))),\n\trandom(n + dot(step, vec3(1,1,0))),\n\tu.x),\n\tu.y),\n\tmix(mix(random(n + dot(step, vec3(0,0,1))),\n\trandom(n + dot(step, vec3(1,0,1))),\n\tu.x),\n\tmix(random(n + dot(step, vec3(0,1,1))),\n\trandom(n + dot(step, vec3(1,1,1))),\n\tu.x),\n\tu.y),\n\tu.z);\n}\n\nmat2 rot(float a) {\n\tfloat ca=cos(a);\n\tfloat sa=sin(a);\n\treturn mat2(ca,sa,-sa,ca);\n}\n\nfloat cloud(in vec3 p, vec3 centerPos, float scale,float radius ) {\n\tfloat l = length(p*0.1);\n\tvec3 d = vec3(p.x+sin(l+time)*2.0,p.y+sin(l)*2.0,0.0);\n\tfloat coef = max(length(d)-1.5,0.0);\n\tfloat c=1.0;\n\tfloat n1=1.0;\n\tfor(int i=0; i<8; ++i) {\n\t\tn1+=1.0/c*abs(noise((p*c+time*1.0)*scale));\n\t\tc*=2.0;\n\t}\n\treturn n1+(coef);\n}\n\nfloat mapHyper(vec3 p){\n\treturn cloud(p,vec3(0,0,0),0.5,0.1);\n}  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tvec3 s=vec3(0.5,0.5,100);\n\tfloat t2=(time*1.5);\n\ts.xz *= rot(sin(t2)*0.005);\n\tvec3 t=vec3(0,0,0);\n\ts.x += cos(t2*0.2)*0.10*sin(time*0.01);\n\ts.y += sin(t2*0.2)*0.10*sin(time*0.01+10.0);\n\tvec3 cz=normalize(t-s);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=normalize(cross(cz,cx));\n\tvec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n\ts.z+=time*-8.0;\n\t\n\tvec3 p=s;\n\tfloat d;\n\tfloat seuil=5.1;\n\tfloat c= 0.0;\n\tfloat distMax =100.0;\n\tfloat steps = 300.0;\n\tfloat color = 0.0;\n\tfloat cl;\n\tfloat dist = clamp((1.0-dot(vec3(0,0,-1.0),r))*4.0,0.0,1.0);\n\tint cc =int(mix(300.0,1000.0,dist));\n\tfloat uu =mix(1.0,0.25,dist);\n\tvec3 p3 = vec3(0);\n\tfor(int i=0; i<cc; ++i) {\n\t\tfloat d2 ;\n\t\tfloat d;\n\t\tif(color<0.001)d = mapHyper(p);\n\t\tc =d;  \n\t\tif( c>seuil )\n\t\t{vec3 p2 =p;\n\t\t\tif(p3.x==0.0)p3=p;\n\t\t\tfor(int j;j<20;j++)\n\t\t\t{\n\t\t\t\tif(color<0.2)d2= mapHyper(p2);\n\t\t\t\telse\n\t\t\t\td2 = 5.2;\n\t\t\t\tif(d2>seuil)\n\t\t\t\t{\n\t\t\t\t\tcolor = color*0.9 + d2*0.02*0.1;\n\t\t\t\t}\n\t\t\t\tp2 +=normalize(vec3(-0.0,-0.0,-5.0))*0.42;\n\t\t\t} \n\t\t}\n\t\tcl = 1.0-color;\n        p+=r*distMax/steps*uu;\n\t\t//p+=r*distMax/float(cc)*uu;\n\t}\n\n\tvec2 off=vec2(1.1,0.0);\n\tvec3 n=normalize(mapHyper(p3)-vec3(mapHyper(p3-off.xyy), mapHyper(p3-off.yxy), mapHyper(p3-off.yyx)));\n\n\t//compositing\n\tvec3 col=vec3(0);\n\tcol = mix(vec3(0.0,0.0,0.2),vec3(0.88,0.88,0.9),cl);\n\tfloat fog =  clamp((length(p3-s)-fogSize)*fogCoef,0.0,1.0);\n\tcol = mix(col,vec3(0.88,0.88,0.9),fog);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 245, 245, 274], [276, 276, 300, 300, 1009], [1011, 1011, 1030, 1030, 1096], [1098, 1098, 1165, 1165, 1420], [1422, 1422, 1445, 1445, 1485], [1489, 1489, 1544, 1544, 3101]], "test": "untested"}
{"id": "WtGcz3", "name": "Reflective Mandelbox", "author": "Zi7ar21", "description": "Path traces a Mandelbox.", "tags": ["raymarching", "raymarching", "fractal", "raymarch", "raymarch", "raymarcher", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "mandelbox"], "likes": 0, "viewed": 299, "published": 3, "date": "1611460003", "time_retrieved": "2024-07-30T19:42:44.358994", "image_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// Common contains settings and common functions.\n// Buffer A contains the rendering process.\n// Buffer B contains the other half of Temporal Sampling along with Image Export.\n// This is for drawing the shader.\n\n// Zi7ar21's Reflective Mandelbox --- January 24th, 2020\n// Last modified January 24th, 2020 16:30 Mountain Time\n\n// This shader raymarches a Mandelbox fractal and uses normals to calculate\n// reflections and eventually after bouncing, a point on a cubemap in iChannel1 of Buffer A.\n\n// Output to screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains settings and common functions.\n\n// Shader Parameters, change these as you desire.\n// Camera Field of View, a larger value increases the Field of View.\n#define camerafov 2.5\n\n// Camera Position, controls the position of the camera.\n#define cameraposition vec3(0.0, 0.0, -16.0)\n\n// Maximum Ray-Marching Steps, more allows the rays to travel further distance\n// and collide with the scene more precisely but is also slower.\n#define maxmarches 1024\n\n// Collision Distance, controls how close a ray has to be to the scene to be considered a collision.\n#define collisiondistance 1e-2\n\n// Maximum Distance, controls the distance a ray can travel before it is considered escaped.\n#define maxdistance 64.0\n\n// Maximum Bounces, controls the maximum number of reflections.\n#define maxbounces 8\n\n// Mandelbox Iterations, controls the amount of times the Mandelbox function iterates.\n#define iterations 12\n\n// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.1415926535897932\n#define twopi pi*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random also from Michael0884: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}", "buffer_a_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains the rendering process.\n\n// Sphere Distance Estimator\n/*float distanceestimator(vec3 rayposition){\n    float sphere = distance(rayposition, vec3(0.0))-0.25;\n    float plane = distance(rayposition, vec3(rayposition.x, -0.35, rayposition.z))-0.1;\n    return min(sphere, plane);\n}*/\n\n// Mandelbox Distance Estimator\nvoid sphereFold(inout vec3 z, inout float dz){\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5){ \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;}\n    else if (r2 < 1.0){ \n\t\tfloat temp = 1.0/r2;\n\t\tz *= temp;\n\t\tdz*= temp;}}\nvoid boxFold(inout vec3 z, inout float dz){z = clamp(z, -1.0, 1.0)*2.0-z;}\nfloat distanceestimator(vec3 p){\n    float plane = distance(p, vec3(p.x, -7.0, p.z))-1.0;\n    float scale = 2.0;\n\tvec3 offset = p;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < iterations; n++){\n\t\tboxFold(p, dr);\n\t\tsphereFold(p, dr);\n        p = scale*p+offset;\n        dr = dr*abs(scale)+1.0;}\n\tfloat r = length(p);\n\treturn min(plane, r/abs(dr));}\n\n// Raymarching, takes the ray direction and ray origin, and outputs\n// the collision position and distance travelled (distance travelled not used here...)\nvec4 raymarch(vec3 raydirection, vec3 rayorigin){\n    vec3 rayposition = rayorigin;\n    float distanceestimate;\n    float distancetravelled = 0.0;\n    bool hit = false;\n    for(int i = 0; i < maxmarches; i++){\n        distanceestimate = distanceestimator(rayposition);\n        if(distanceestimate < collisiondistance){hit = true; break;}\n        rayposition += raydirection*distanceestimate;\n        distancetravelled += distanceestimate;\n        if(distancetravelled > maxdistance){break;}\n    }\n    if(hit){return vec4(rayposition, distancetravelled);}\n    else{return vec4(-1.0);}\n}\n\n// Signed Distance Function Normal Calculator\nvec3 calcNormal(vec3 p){\n    const float eps = collisiondistance;\n    const vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(distanceestimator(p+h.xyy)-distanceestimator(p-h.xyy),\n                          distanceestimator(p+h.yxy)-distanceestimator(p-h.yxy),\n                          distanceestimator(p+h.yyx)-distanceestimator(p-h.yyx)));\n}\n\n/*vec3 fresnel(vec3 rd, vec3 hvec){\n    vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-rd, hvec), 5.0);\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Progressive Rendering\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = oldFragColor;\n    //if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Calculate the Ray Direction based on Camera Parameters\n    vec2 uv = ((fragCoord.xy+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    //mat3 rotationmatrix = mat3(0.5, 0.0, 0.5, 0.0, 1.0, 0.0, -0.5, 0.0, 0.5);\n    vec3 raydirection = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n\n    // Perform the Ray-Marching\n    vec4 raymarched = raymarch(raydirection, cameraposition);\n    if(raymarched.w < -0.9){fragColor += vec4(texture(iChannel1, raydirection).rgb, 1.0); return;}\n    vec3 normal = calcNormal(raymarched.xyz);\n    vec3 reflection = normalize(reflect(raydirection, normal)+nrand3(0.1, vec3(0.0)));\n\n    // Raymarch again (because Light Bounces)\n    for(int i = 0; i < maxbounces; i++){\n        raymarched = raymarch(reflection, raymarched.xyz+(reflection*collisiondistance*2.0));\n        if(raymarched.w < -0.9){fragColor += vec4(texture(iChannel1, reflection).rgb, 1.0); return;}\n        normal = calcNormal(raymarched.xyz);\n        reflection = normalize(reflect(reflection, normal)+nrand3(0.1, vec3(0.0)));\n    }\n    fragColor += vec4(texture(iChannel1, reflection).rgb, 1.0);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains the other half of Temporal Sampling along with Image Export.\n// Click on the Image icon in the bottom right of the editor\n// to export a Full Precision 32-Bit Floating Point EXR.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(color, 1.0);}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 580, 634, 634, 690]], "test": "untested"}
{"id": "3tVyzc", "name": "Fork Ball Of Fi leecorn 726", "author": "leecorn", "description": "Without the corona : http://www.noisemachine.com/talk1/24a.html\n", "tags": ["3dnoise", "perlin"], "likes": 2, "viewed": 290, "published": 3, "date": "1611459776", "time_retrieved": "2024-07-30T19:42:45.172818", "image_code": "\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = -.5 + fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat color = 2.5 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*2.8, .5);\n\t\n\tfor(int i = 1; i <= 8; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (2. / power) * snoise(coord + vec3(2.,-iTime*.01, iTime*.008), power*16.);\n\t}\n\tfragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),4.)*0.15 , 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 35, 35, 559], [561, 561, 619, 619, 1060]], "test": "untested"}
{"id": "3lKyzc", "name": "Where the birds go ", "author": "xavierseb", "description": "Another lucky find!", "tags": ["3d", "geometric"], "likes": 4, "viewed": 267, "published": 3, "date": "1611458174", "time_retrieved": "2024-07-30T19:42:46.125271", "image_code": "// where the birds go\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nconst float TAU = atan(1.0) * 8.0;\n#define ss(f,g,h) smoothstep(f,g,t)*h\n\nvec3 map(vec3 p, float u, float v) {\t\n\tfloat k;\n\tp.yz *= rot(v);\n\tp.xy *= rot(u);\n\tfor (int i = 0; i < 6; i++) {\n\t\tk = length(p.xy); p.x = k * (mod(atan(p.y, p.x), TAU/8.) - TAU/16.); p.y = k - 2.752;\t\t\n\t\tk = length(p.yz); p.y = k * (mod(atan(p.z, p.y), TAU/12.) - TAU/24.);p.z = k - 10.0; //-9.\n\t}\n\t\n\tp.x = dot(abs(p), normalize(vec3(6.9,5,2.2))) - 1.6 ;\n\treturn p; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.x -.5;\n\tvec3 rd = normalize(vec3(uv, 1)); \n    vec2 mouse=iMouse.xy/iResolution.xy;\n\tfloat t =mod(iTime,30.)/30.,v=-8.*mod((iTime+50.)/266.,TAU), u=-mouse.x;\n\t//float y =ss(.1,.12,.06) + ss(.35,.37,.06) + ss(.6,.62,.28) + ss(.8,.82,.31) + ss(.9,.92,.24) - ss(.94,1.,.95); y+=y/10.+.02*mouse.y;  // auto pan\n\t//float y = mouse.y*.7; if(y>.2) y+=.15; if(y>.53) y+=.17; if(y>.9) y+=.05; // skip past boring regions\n\tfloat y = mouse.y*.47+.05; if(y>.2) y+=.15; if(y>.57) {y=mouse.y*1.51-.48;} if(y>.9) y+=.05; // skip past boring regions\n    //float y = mouse.y*.06+.05; if(y>.08) y+=.34; // bird spotting regions\n\n    //vec3 p = vec3(0, 60.*y+4.,  -8.25*y-6.);\n\tfloat s=min(iTime,3.)/3.;\n\tvec3 p = vec3(0,50,-120)*(1.-s) + vec3(0, 60.*y+4., -8.25*y-6.)*s;\n\tfragColor = vec4(0,y*2.-1.3,y*2.-1.,1);\n\tfor (int i = 1; i < 160; i++) {\n\t\tvec3 d = p.z<-s*10.? vec3(1): map(p, u, v);\t\t\t\t\n\t\tif (d.x <= 0.001) {\n\t\t\tfragColor = length(p.xy)<8.5? \n\t\t\t\t\t(2.-s)*vec4( 1, 0,.5, 1) *abs(d.y)*12./float(i): \n\t\t\t\t\t(2.-s)*vec4( 15.,20.,abs(p.y/20.)*10.,1)/float(i);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tp += rd * d.x;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 185, 185, 518], [520, 520, 577, 577, 1695]], "test": "untested"}
{"id": "3lVyz3", "name": "Testing space folding", "author": "public_int_i", "description": "Some space folding tests.", "tags": ["testing", "space", "folding"], "likes": 6, "viewed": 361, "published": 3, "date": "1611451888", "time_retrieved": "2024-07-30T19:42:47.039826", "image_code": "/*Visualizing how different space folding techniques work.\nUse grid, gradient and marker to help see whats happening.\n\nGrid = 0.1 units every grid cell\nGradient red = x position value, green = y position value\nMarker pointy end = negative y position\n*/\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat triwave(float x) {\n    return 1.-abs(fract(x)-.5)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //2d position coordinate\n    vec2 pos = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    float fold = mod(floor(iTime/10.),4.);//loop through different folds over time\n    //fold = 1.;//or set a specific fold\n    if (iTime < 2.) fold = -1.;//show no fold at start as reference\n    \n    \n    //mirror fold\n    if (fold == 0.) {\n        pos = abs(pos)-triwave(iTime*.1);\n    }\n    \n    //plane fold\n    if (fold == 1.) {\n        vec2 pnorm = vec2(sin(iTime),cos(iTime));\n        pos -= pnorm*2.*min(0.,dot(pos,pnorm));\n    }\n    \n    //box fold\n    if (fold == 2.) {\n        float ext = triwave(iTime*.13)*.5;\n        pos = clamp(pos,-ext,ext)*2.-pos;\n    }\n    \n    //polar/circular fold\n    if (fold == 3.) {\n        float sz = .1+2.*pow(triwave(iTime*.0876),4.),\n            ang = mod(atan(pos.y,pos.x),sz)-sz*.5;\n        pos = vec2(sin(ang),cos(ang))*length(pos)-vec2(0.,.5);\n    }\n\n\n    //visualize position as grid, gradient(red = x, green = y) and line(pointy end = negative y)\n    vec2 gpos = abs(mod(abs(pos),.1)-.05);//1 grid cell = 0.1 units\n    float grid = min(gpos.x,gpos.y);\n    \n    fragColor = vec4(pos.x*.5+.5,pos.y*.5+.5,0,1)*//gradient\n            clamp(max(0.,grid-.002)*iResolution.y*.2,0.,1.)+//grid\n            max(0.,1.-length(max(abs(pos)-vec2(pos.y>0.?.02:.02-abs(pos.y)*.1,.2),0.))*iResolution.y*.2);//line\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[254, 254, 272, 272, 329], [331, 331, 355, 355, 392], [394, 394, 451, 480, 1791]], "test": "untested"}
{"id": "WlVyRV", "name": "Dry ice 2", "author": "xjorma", "description": "Polished version of my previous shader \"Dry Ice\"\nhttps://www.shadertoy.com/view/3d3fRB\nI was sure that with bit polish (Polishing is unfortunately not my strenght) I could achieve a better result. To be honest The result is way better than i anticipated.", "tags": ["simulation", "fluid", "fog", "smoke", "advection", "incompressible", "incompressible", "navier", "stokes", "jos", "stam"], "likes": 508, "viewed": 21642, "published": 3, "date": "1611451553", "time_retrieved": "2024-07-30T19:42:48.051122", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define RENDER3D\t1\n\n#if  RENDER3D\n\n#define AA 0\n\nfloat sceneIntersection(in vec3 ro,in vec3 rd, out vec3 inter, out vec3 normal, out vec3 color, in float dist, out vec3 lightPos)\n{\n    float mint = dist;\n    inter = vec3(0);\n    normal = vec3(0);\n    color = vec3(0);\n   \t// Spheres\n    for(int i = 0 ; i < nbSphere ; i++)\n    {\n        vec2 p2d = spherePosition(i, iFrame);\n\t\tvec3 pos = vec3(p2d.x, ballRadius, p2d.y);\n        vec3 ballColor = vec3(1, 0, 0);\n        if( i == 0)\n        {\n            ballColor = vec3(1);\n            lightPos = pos + vec3(0, lightHeight, 0);\n        }\n\n        float t = sphIntersect( ro, rd, pos, ballRadius).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            inter = (ro + mint * rd);\n            normal = normalize(inter - pos);\n            color = ballColor;\n        }     \n    }\n\n    // Floor\n    {\n        float aspecRatio = iResolution.x / iResolution.y;  \n        vec3 boxNormal;\n    \tfloat t = boxIntersection(ro, rd, vec3(aspecRatio,0.1,1), vec3(0,-0.1,0),boxNormal).x;\n        if(t > 0. && t < mint)\n        {\n            mint = t;\n            inter = (ro + mint * rd);\n\t\t\tnormal = boxNormal;\n            ivec2 tileId = ivec2(vec2(inter.x, inter.z) * 3. + 100.);\n            color = ((tileId.x & 1) ^ (tileId.y & 1)) == 0 ? vec3(0.3) : vec3(0.15);  \n        }       \n    }\n\treturn mint;\n}\n\nfloat sampleFog(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    uv.x *= iResolution.y / iResolution.x;\n    uv = uv * 0.5 + 0.5;\n    if(max(uv.x, uv.y) > 1. || min(uv.x, uv.y) < 0.)\n    {\n        return 0.;\n    }\n    return texture(iChannel0, uv).z;\n}\n\nvec3 Render(in vec3 ro,in vec3 rd,in float dist, float fudge)\n{\n    vec3  inter;\n    vec3  normal;\n    vec3  baseColor; \n    vec3  lightPos;\n    float mint = sceneIntersection(ro, rd, inter, normal, baseColor, dist, lightPos);\n    \n    vec3 color = vec3(0);\n\n    \n    if(mint<dist)\n    {\n        vec3 lightDir = normalize(lightPos - inter);\n        float lightDist2 = dist2(lightPos - inter);\n        vec3 shadowStep = (fogHeigth / float(nbSlice)) * lightDir / lightDir.y;\n        float shadowDist = 0.;\n        for(int i = 0 ; i < nbSlice ; i++)\n        {\n            vec3 shadowPos = inter + shadowStep * float(i);\n            float v = sampleFog(shadowPos) * fogHeigth;\n            shadowDist += min(max(0., v - shadowPos.y), fogSlice) * length(shadowStep) / fogSlice;\n        }\n        float shadowFactor = exp(-shadowDist * shadowDensity * 0.25);\n        color = baseColor * (max(0., dot(normal, lightDir) * shadowFactor) + 0.2) / lightDist2;\n    }\n    else\n    {\n        color = vec3(0);\n    }\n    \n\n    // Compute Fog\n\tfloat t;\n    if(floorIntersect(ro, rd, fogHeigth, t))\n    {\n        vec3 curPos = ro + rd * t;\n        vec3 fogStep = (fogHeigth / float(nbSlice)) * rd / abs(rd.y);\n        curPos += fudge * fogStep;  // fix banding issue\n        float stepLen = length(fogStep);\n        float curDensity = 0.;\n        float transmittance = 1.;\n        float lightEnergy = 0.;\n        for(int i = 0; i < nbSlice; i++)\n        {\n            if( dot(curPos - ro, rd) > mint)\n                break;\n            float curHeigth = sampleFog(curPos) * fogHeigth;\n            float curSample = min(max(0., curHeigth - curPos.y), fogSlice) * stepLen / fogSlice;\n            if(curSample > 0.001)\n            {\n                vec3 lightDir = normalize(lightPos - curPos);\n                vec3 shadowStep = (fogHeigth / float(nbSlice)) * lightDir / lightDir.y;\n                float lightDist2 = dist2(lightPos - curPos);\n                vec3 shadowPos = curPos + shadowStep * fudge;\n                float shadowDist = 0.;\n\n                for (int j = 0; j < nbSlice; j++)\n                {\n                    shadowPos += shadowStep;\n                    if(shadowPos.y > fogHeigth)\n                    {\n                        break;\n                    }\n                    float curHeight = sampleFog(shadowPos) * fogHeigth;\n             \t\tshadowDist += min(max(0., curHeight - shadowPos.y), fogSlice) * length(shadowStep) / fogSlice;\n               }\n\n                \n            \tfloat shadowFactor = exp(-shadowDist * shadowDensity) / lightDist2;\n                curDensity = curSample * fogDensity;\n                float absorbedlight =  shadowFactor * (1. * curDensity);\n                lightEnergy += absorbedlight * transmittance;\n                transmittance *= 1. - curDensity;\t\n            }\n            curPos+= fogStep;       \n        }\n        color = mix(color, vec3(lightEnergy), 1. - transmittance);\n    }  \n    \n    \n    return color;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera       \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) - radians(90.);\n        float phi\t= -radians(30.);\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd, 6., hash12(fragCoord + iTime));\n        \n\n        tot += col;\n            \n#if AA\n    }\n    tot /= 4.;\n#endif\n\ttot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\t\n#else\t// RENDER3D \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xy, 0, 1);\n    fragColor = vec4(vec3(texelFetch(iChannel0, ivec2(fragCoord), 0).z), 1);\n}\n#endif\t// RENDER3D", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec2 fbm(vec3 p, int octaveNum)\n{\n\tvec2 acc = vec2(0);\t\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n    vec3 shift = vec3(100);\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tacc += vec2(noise(p), noise(p + vec3(0,0,10))) * amp;\n        p = p * 2.0 + shift;\n        amp *= 0.5;\n\t}\n\treturn acc;\n}\n\n\nvec3 sampleMinusGradient(vec2 coord)\n{\n    vec3\tveld\t= texture(iChannel1, coord / iResolution.xy).xyz;\n    float\tleft\t= texture(iChannel0,(coord + vec2(-1, 0)) / iResolution.xy).x;\n    float\tright\t= texture(iChannel0,(coord + vec2( 1, 0)) / iResolution.xy).x;\n    float\tbottom\t= texture(iChannel0,(coord + vec2( 0,-1)) / iResolution.xy).x;\n    float\ttop \t= texture(iChannel0,(coord + vec2( 0, 1)) / iResolution.xy).x;\n    vec2\tgrad \t= vec2(right - left,top - bottom) * 0.5;\n    return\tvec3(veld.xy - grad, veld.z);\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= mix(1., pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v), 0.02);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Euler advection\n    vec2\tvelocity = sampleMinusGradient(fragCoord).xy;\n    vec3\tveld = sampleMinusGradient(fragCoord - dissipation * velocity).xyz;\n    float\tdensity = veld.z;\n    velocity = veld.xy;\n\n    vec2\tuv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    // Small perturbation\n    vec2 detailNoise = fbm(vec3(uv*40., iTime * 0.5 + 30.), 7) - 0.5;\n    velocity += detailNoise * 0.2;\n    density += length(detailNoise) * 0.01;\n    \n    // Injection\n    vec2 injectionNoise = fbm(vec3(uv *1.5, iTime * 0.1 + 30.), 7) - 0.5;\n    velocity += injectionNoise * 0.1;\n    density += max((length(injectionNoise) * 0.04), 0.);\n\n    // Inject emiter\n    float influenceRadius = ballRadius * 2.;\n    for(int i = 0 ; i < nbSphere ; i++)\n    {\n        vec2 p = spherePosition(i, iFrame);\n        float dist = distance(uv, p);\n        if(dist < influenceRadius)\n        {\n            vec2 op = spherePosition(i, iFrame + 1);\n            vec2 ballVelocity = p - op; \n            density -= ((influenceRadius - dist) / influenceRadius) * 0.15;\n            density = max(0., density);\n         \tvelocity -= ballVelocity * 5.;   \n        }\n        \n    }\t    \n    density = min(1., density);\n    density *= 0.99;     // damp\n    veld = vec3(vec3(velocity, density));\n    veld = vignette(veld, fragCoord / iResolution.xy, 1.);\n    fragColor = vec4(veld, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Divergence\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 icoord = ivec2(fragCoord);\n    float vel_x_left\t= texelFetch(iChannel0, icoord + ivec2(-1,  0) , 0).x;\n    float vel_x_right\t= texelFetch(iChannel0, icoord + ivec2( 1,  0) , 0).x;\n    float vel_y_bottom\t= texelFetch(iChannel0, icoord + ivec2( 0, -1) , 0).y;\n    float vel_y_top\t\t= texelFetch(iChannel0, icoord + ivec2( 0,  1) , 0).y;\n    float divergence\t= (vel_x_right - vel_x_left + vel_y_top - vel_y_bottom) * 0.5;\n    fragColor = vec4(divergence,vec3(1)); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 1st interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless pass we need to do many pass at once.\n\n\n// code generated by :\n/*\n#include <iostream>\n\nconst int tabSize = 48;\n\nstd::int64_t divTab[tabSize][tabSize];\nstd::int64_t preTab[tabSize][tabSize];\n\n\nvoid recurse(int x, int y, int level)\n{\n    level--;\n    divTab[x][y] += std::int64_t(1) << std::int64_t(level * 2);\n    if (level)\n    {\n        recurse(x - 1, y, level);\n        recurse(x + 1, y, level);\n        recurse(x, y - 1, level);\n        recurse(x, y + 1, level);\n    }\n    else\n    {\n        preTab[x - 1][y]++;\n        preTab[x + 1][y]++;\n        preTab[x][y - 1]++;\n        preTab[x][y + 1]++;\n    }\n}\n\nvoid clear(std::int64_t (&tab)[tabSize][tabSize])\n{\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            tab[x][y] = 0;\n        }\n    }\n}\n\nvoid output(const char *functionName, std::int64_t(&tab)[tabSize][tabSize], std::int64_t multiplier)\n{\n    std::int64_t total = 0;\n    for (int x = 0; x < tabSize; x++)\n    {\n        for (int y = 0; y < tabSize; y++)\n        {\n            if (tab[x][y])\n            {\n                total += tab[x][y];\n                std::cout << \"\\tp += \" << tab[x][y] << \".*\" << functionName << \"(\" << x - tabSize / 2 << \", \" << y - tabSize / 2 << \");\\n\";\n            }\n        }\n    }\n    total *= multiplier;\n    std::cout << \"\\treturn\\tp / \" << total << \".;\\n\";\n}\n\nint main()\n{\n    clear(divTab);\n    clear(preTab);\n    recurse(tabSize / 2, tabSize / 2, 10);\n    output(\"div\", divTab, 2);\n    output(\"pre\", preTab, 1);\n}\n*/\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getDiv( void )\n{\n    float p = 0.;\n    p += 1.*div(-9, 0);\n    p += 9.*div(-8, -1);\n    p += 4.*div(-8, 0);\n    p += 9.*div(-8, 1);\n    p += 36.*div(-7, -2);\n    p += 32.*div(-7, -1);\n    p += 97.*div(-7, 0);\n    p += 32.*div(-7, 1);\n    p += 36.*div(-7, 2);\n    p += 84.*div(-6, -3);\n    p += 112.*div(-6, -2);\n    p += 436.*div(-6, -1);\n    p += 320.*div(-6, 0);\n    p += 436.*div(-6, 1);\n    p += 112.*div(-6, 2);\n    p += 84.*div(-6, 3);\n    p += 126.*div(-5, -4);\n    p += 224.*div(-5, -3);\n    p += 1092.*div(-5, -2);\n    p += 1280.*div(-5, -1);\n    p += 2336.*div(-5, 0);\n    p += 1280.*div(-5, 1);\n    p += 1092.*div(-5, 2);\n    p += 224.*div(-5, 3);\n    p += 126.*div(-5, 4);\n    p += 126.*div(-4, -5);\n    p += 280.*div(-4, -4);\n    p += 1694.*div(-4, -3);\n    p += 2752.*div(-4, -2);\n    p += 6656.*div(-4, -1);\n    p += 6464.*div(-4, 0);\n    p += 6656.*div(-4, 1);\n    p += 2752.*div(-4, 2);\n    p += 1694.*div(-4, 3);\n    p += 280.*div(-4, 4);\n    p += 126.*div(-4, 5);\n    p += 84.*div(-3, -6);\n    p += 224.*div(-3, -5);\n    p += 1694.*div(-3, -4);\n    p += 3520.*div(-3, -3);\n    p += 11016.*div(-3, -2);\n    p += 16128.*div(-3, -1);\n    p += 24608.*div(-3, 0);\n    p += 16128.*div(-3, 1);\n    p += 11016.*div(-3, 2);\n    p += 3520.*div(-3, 3);\n    p += 1694.*div(-3, 4);\n    p += 224.*div(-3, 5);\n    p += 84.*div(-3, 6);\n    p += 36.*div(-2, -7);\n    p += 112.*div(-2, -6);\n    p += 1092.*div(-2, -5);\n    p += 2752.*div(-2, -4);\n    p += 11016.*div(-2, -3);\n    p += 21664.*div(-2, -2);\n    p += 47432.*div(-2, -1);\n    p += 59712.*div(-2, 0);\n    p += 47432.*div(-2, 1);\n    p += 21664.*div(-2, 2);\n    p += 11016.*div(-2, 3);\n    p += 2752.*div(-2, 4);\n    p += 1092.*div(-2, 5);\n    p += 112.*div(-2, 6);\n    p += 36.*div(-2, 7);\n    p += 9.*div(-1, -8);\n    p += 32.*div(-1, -7);\n    p += 436.*div(-1, -6);\n    p += 1280.*div(-1, -5);\n    p += 6656.*div(-1, -4);\n    p += 16128.*div(-1, -3);\n    p += 47432.*div(-1, -2);\n    p += 92224.*div(-1, -1);\n    p += 163476.*div(-1, 0);\n    p += 92224.*div(-1, 1);\n    p += 47432.*div(-1, 2);\n    p += 16128.*div(-1, 3);\n    p += 6656.*div(-1, 4);\n    p += 1280.*div(-1, 5);\n    p += 436.*div(-1, 6);\n    p += 32.*div(-1, 7);\n    p += 9.*div(-1, 8);\n    p += 1.*div(0, -9);\n    p += 4.*div(0, -8);\n    p += 97.*div(0, -7);\n    p += 320.*div(0, -6);\n    p += 2336.*div(0, -5);\n    p += 6464.*div(0, -4);\n    p += 24608.*div(0, -3);\n    p += 59712.*div(0, -2);\n    p += 163476.*div(0, -1);\n    p += 409744.*div(0, 0);\n    p += 163476.*div(0, 1);\n    p += 59712.*div(0, 2);\n    p += 24608.*div(0, 3);\n    p += 6464.*div(0, 4);\n    p += 2336.*div(0, 5);\n    p += 320.*div(0, 6);\n    p += 97.*div(0, 7);\n    p += 4.*div(0, 8);\n    p += 1.*div(0, 9);\n    p += 9.*div(1, -8);\n    p += 32.*div(1, -7);\n    p += 436.*div(1, -6);\n    p += 1280.*div(1, -5);\n    p += 6656.*div(1, -4);\n    p += 16128.*div(1, -3);\n    p += 47432.*div(1, -2);\n    p += 92224.*div(1, -1);\n    p += 163476.*div(1, 0);\n    p += 92224.*div(1, 1);\n    p += 47432.*div(1, 2);\n    p += 16128.*div(1, 3);\n    p += 6656.*div(1, 4);\n    p += 1280.*div(1, 5);\n    p += 436.*div(1, 6);\n    p += 32.*div(1, 7);\n    p += 9.*div(1, 8);\n    p += 36.*div(2, -7);\n    p += 112.*div(2, -6);\n    p += 1092.*div(2, -5);\n    p += 2752.*div(2, -4);\n    p += 11016.*div(2, -3);\n    p += 21664.*div(2, -2);\n    p += 47432.*div(2, -1);\n    p += 59712.*div(2, 0);\n    p += 47432.*div(2, 1);\n    p += 21664.*div(2, 2);\n    p += 11016.*div(2, 3);\n    p += 2752.*div(2, 4);\n    p += 1092.*div(2, 5);\n    p += 112.*div(2, 6);\n    p += 36.*div(2, 7);\n    p += 84.*div(3, -6);\n    p += 224.*div(3, -5);\n    p += 1694.*div(3, -4);\n    p += 3520.*div(3, -3);\n    p += 11016.*div(3, -2);\n    p += 16128.*div(3, -1);\n    p += 24608.*div(3, 0);\n    p += 16128.*div(3, 1);\n    p += 11016.*div(3, 2);\n    p += 3520.*div(3, 3);\n    p += 1694.*div(3, 4);\n    p += 224.*div(3, 5);\n    p += 84.*div(3, 6);\n    p += 126.*div(4, -5);\n    p += 280.*div(4, -4);\n    p += 1694.*div(4, -3);\n    p += 2752.*div(4, -2);\n    p += 6656.*div(4, -1);\n    p += 6464.*div(4, 0);\n    p += 6656.*div(4, 1);\n    p += 2752.*div(4, 2);\n    p += 1694.*div(4, 3);\n    p += 280.*div(4, 4);\n    p += 126.*div(4, 5);\n    p += 126.*div(5, -4);\n    p += 224.*div(5, -3);\n    p += 1092.*div(5, -2);\n    p += 1280.*div(5, -1);\n    p += 2336.*div(5, 0);\n    p += 1280.*div(5, 1);\n    p += 1092.*div(5, 2);\n    p += 224.*div(5, 3);\n    p += 126.*div(5, 4);\n    p += 84.*div(6, -3);\n    p += 112.*div(6, -2);\n    p += 436.*div(6, -1);\n    p += 320.*div(6, 0);\n    p += 436.*div(6, 1);\n    p += 112.*div(6, 2);\n    p += 84.*div(6, 3);\n    p += 36.*div(7, -2);\n    p += 32.*div(7, -1);\n    p += 97.*div(7, 0);\n    p += 32.*div(7, 1);\n    p += 36.*div(7, 2);\n    p += 9.*div(8, -1);\n    p += 4.*div(8, 0);\n    p += 9.*div(8, 1);\n    p += 1.*div(9, 0);\n    return  p / 1048576.;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel1, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    float div = getDiv();\n    float p = getPre() - div;\n    fragColor = vec4(p, div, vec3(1));\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst float dissipation \t= 0.95;\n\nconst float ballRadius\t\t= 0.06;\nconst float fogHeigth\t\t= ballRadius * 4.;\nconst int\tnbSlice\t\t\t= 24;\nconst float fogSlice\t\t= fogHeigth / float(nbSlice);\nconst int\tnbSphere \t\t= 3;\nconst float shadowDensity \t= 25.;\nconst float fogDensity \t\t= 20.;\nconst float lightHeight     = 1.;\n\nconst float tau =  radians(360.);\n\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nbool floorIntersect(in vec3 ro, in vec3 rd, in float floorHeight, out float t) \n{\n    ro.y -= floorHeight;\n    if(rd.y < -0.01)\n    {\n        t = ro.y / - rd.y;\n        return true;\n    }\n    return false;\n} \n\n// https://iquilezles.org/articles/intersectors\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// https://iquilezles.org/articles/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 center,out vec3 oN ) \n{\n    ro -= center;\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nvec2 spherePosition(int id, int frame)\n{\n    vec4 offset = hash41(float(id)) * tau;\n    float fframe = float(frame);\n    return vec2(cos(offset.x + fframe * 0.015) + cos(offset.y + fframe * 0.020), cos(offset.z + fframe * 0.017) + cos(offset.w + fframe * 0.022)) * vec2(1., 0.5) * 0.9;\n}\n\nfloat dist2(vec3 v)\n{\n    return dot(v, v);\n}", "buffer_d_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pressure solver 2nd interation\n\n// Impired by https://www.shadertoy.com/view/MdSczK by Trirop\n// Since in shadertoy we don't have countless passed we need to do many pass at once.\n\n\nfloat div(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).y;\n}\n\nfloat pre(int x,int y)\n{\n    return texelFetch(iChannel0, ivec2(gl_FragCoord.xy) + ivec2(x,  y) , 0).x;\n}\n\nfloat getPre( void )\n{\n    float p = 0.;\n    p += 1.*pre(-10, 0);\n    p += 10.*pre(-9, -1);\n    p += 10.*pre(-9, 1);\n    p += 45.*pre(-8, -2);\n    p += 100.*pre(-8, 0);\n    p += 45.*pre(-8, 2);\n    p += 120.*pre(-7, -3);\n    p += 450.*pre(-7, -1);\n    p += 450.*pre(-7, 1);\n    p += 120.*pre(-7, 3);\n    p += 210.*pre(-6, -4);\n    p += 1200.*pre(-6, -2);\n    p += 2025.*pre(-6, 0);\n    p += 1200.*pre(-6, 2);\n    p += 210.*pre(-6, 4);\n    p += 252.*pre(-5, -5);\n    p += 2100.*pre(-5, -3);\n    p += 5400.*pre(-5, -1);\n    p += 5400.*pre(-5, 1);\n    p += 2100.*pre(-5, 3);\n    p += 252.*pre(-5, 5);\n    p += 210.*pre(-4, -6);\n    p += 2520.*pre(-4, -4);\n    p += 9450.*pre(-4, -2);\n    p += 14400.*pre(-4, 0);\n    p += 9450.*pre(-4, 2);\n    p += 2520.*pre(-4, 4);\n    p += 210.*pre(-4, 6);\n    p += 120.*pre(-3, -7);\n    p += 2100.*pre(-3, -5);\n    p += 11340.*pre(-3, -3);\n    p += 25200.*pre(-3, -1);\n    p += 25200.*pre(-3, 1);\n    p += 11340.*pre(-3, 3);\n    p += 2100.*pre(-3, 5);\n    p += 120.*pre(-3, 7);\n    p += 45.*pre(-2, -8);\n    p += 1200.*pre(-2, -6);\n    p += 9450.*pre(-2, -4);\n    p += 30240.*pre(-2, -2);\n    p += 44100.*pre(-2, 0);\n    p += 30240.*pre(-2, 2);\n    p += 9450.*pre(-2, 4);\n    p += 1200.*pre(-2, 6);\n    p += 45.*pre(-2, 8);\n    p += 10.*pre(-1, -9);\n    p += 450.*pre(-1, -7);\n    p += 5400.*pre(-1, -5);\n    p += 25200.*pre(-1, -3);\n    p += 52920.*pre(-1, -1);\n    p += 52920.*pre(-1, 1);\n    p += 25200.*pre(-1, 3);\n    p += 5400.*pre(-1, 5);\n    p += 450.*pre(-1, 7);\n    p += 10.*pre(-1, 9);\n    p += 1.*pre(0, -10);\n    p += 100.*pre(0, -8);\n    p += 2025.*pre(0, -6);\n    p += 14400.*pre(0, -4);\n    p += 44100.*pre(0, -2);\n    p += 63504.*pre(0, 0);\n    p += 44100.*pre(0, 2);\n    p += 14400.*pre(0, 4);\n    p += 2025.*pre(0, 6);\n    p += 100.*pre(0, 8);\n    p += 1.*pre(0, 10);\n    p += 10.*pre(1, -9);\n    p += 450.*pre(1, -7);\n    p += 5400.*pre(1, -5);\n    p += 25200.*pre(1, -3);\n    p += 52920.*pre(1, -1);\n    p += 52920.*pre(1, 1);\n    p += 25200.*pre(1, 3);\n    p += 5400.*pre(1, 5);\n    p += 450.*pre(1, 7);\n    p += 10.*pre(1, 9);\n    p += 45.*pre(2, -8);\n    p += 1200.*pre(2, -6);\n    p += 9450.*pre(2, -4);\n    p += 30240.*pre(2, -2);\n    p += 44100.*pre(2, 0);\n    p += 30240.*pre(2, 2);\n    p += 9450.*pre(2, 4);\n    p += 1200.*pre(2, 6);\n    p += 45.*pre(2, 8);\n    p += 120.*pre(3, -7);\n    p += 2100.*pre(3, -5);\n    p += 11340.*pre(3, -3);\n    p += 25200.*pre(3, -1);\n    p += 25200.*pre(3, 1);\n    p += 11340.*pre(3, 3);\n    p += 2100.*pre(3, 5);\n    p += 120.*pre(3, 7);\n    p += 210.*pre(4, -6);\n    p += 2520.*pre(4, -4);\n    p += 9450.*pre(4, -2);\n    p += 14400.*pre(4, 0);\n    p += 9450.*pre(4, 2);\n    p += 2520.*pre(4, 4);\n    p += 210.*pre(4, 6);\n    p += 252.*pre(5, -5);\n    p += 2100.*pre(5, -3);\n    p += 5400.*pre(5, -1);\n    p += 5400.*pre(5, 1);\n    p += 2100.*pre(5, 3);\n    p += 252.*pre(5, 5);\n    p += 210.*pre(6, -4);\n    p += 1200.*pre(6, -2);\n    p += 2025.*pre(6, 0);\n    p += 1200.*pre(6, 2);\n    p += 210.*pre(6, 4);\n    p += 120.*pre(7, -3);\n    p += 450.*pre(7, -1);\n    p += 450.*pre(7, 1);\n    p += 120.*pre(7, 3);\n    p += 45.*pre(8, -2);\n    p += 100.*pre(8, 0);\n    p += 45.*pre(8, 2);\n    p += 10.*pre(9, -1);\n    p += 10.*pre(9, 1);\n    p += 1.*pre(10, 0);\n    return  p / 1048576.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{ \n    float p = getPre() - div(0,0);\n    fragColor = vec4(p,vec3(1));\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyRV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [], "test": "untested"}
{"id": "tt33WX", "name": "Texture along spline", "author": "blurryroots", "description": "Approach to align texture along bezier spline.", "tags": ["bezier", "curve", "image"], "likes": 5, "viewed": 583, "published": 3, "date": "1611449747", "time_retrieved": "2024-07-30T19:42:48.879906", "image_code": "/**\nBezier Spline Texture\nBy blurryroots innovation qanat O\n*/\n// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n\n#define MouseV (iMouse.y / iResolution.y)\n#define MouseU (iMouse.x / iResolution.x)\n#define UV_DEBUG 0\n#define SHOW_CONTROL_RIG 1\n#define DEFORM_BEZIER 1\n\n//Inspired by https://www.shadertoy.com/view/4ljfRD\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nvec3 DrawLine(vec2 A, vec2 B, vec2 UV, float Thickness, vec3 Color)\n{\n    vec2 Direction = normalize(B - A);\n    float Dist = distance(A, B);\n    \n    vec3 Right = cross(vec3(Direction, 0.), vec3(0., 0., 1.));\n    \n    return vec3(0.);\n}\n\nvec2 QuadraticBezier(vec2 A, vec2 B, vec2 C, float t)\n{\n\tvec2 AB = mix(A, B, t);\n\tvec2 BC = mix(B, C, t);\n\n\tvec2 P = mix(AB, BC, t);\n\n\treturn P;\n}\n\nvec2 CubicBezier(float t, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n\tvec2 AB = mix(A, B, t);\n\tvec2 BC = mix(B, C, t);\n\tvec2 CD = mix(C, D, t);\n\n\tvec2 P = QuadraticBezier(AB, BC, CD, t);\n\n\treturn P;\n}\n\nvec2 DeformUVByControlPoints_Linear(vec2 UV, vec2 A, vec2 TangentA, vec2 TangentB, vec2 B)\n{\n    float x;\n    \n    if (UV.x <= TangentA.x) {\n    \tx = (UV.x - A.x) / (TangentA.x - A.x);\n        \n        UV.y += 0.5 - mix(A.y, TangentA.y, x);\n    }\n    else if (UV.x <= TangentB.x) {\n        x = (UV.x - TangentA.x) / (TangentB.x - TangentA.x);\n        \n        UV.y +=  0.5 - mix(TangentA.y, TangentB.y, x);\n        \n    }\n    else if (UV.x <= B.x) {\n        x = (UV.x - TangentB.x) / (B.x - TangentB.x);\n        \n        UV.y += 0.5 - mix(TangentB.y, B.y, x);\n    }\n    \n    return UV;\n}\n\nvec2 DeformUVByControlPoints_Bezier(vec2 UV, vec2 A, vec2 TangentA, vec2 TangentB, vec2 B)\n{\n\tfloat uvx = UV.x;\n    \n    vec2 NewUV = UV;\n    NewUV.y += 0.5 - CubicBezier(UV.x, A, TangentA, TangentB, B).y;\n\t\t\n\treturn NewUV;\n}\n\nvec3 OverlayControlRig(vec2 uv, vec2 Start, vec2 StartControl, vec2 End, vec2 EndControl, float size)\n{\n \tvec3 rigColor = vec3(0.);\n    \n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    // render control points\n    if (length((Start - uv) * aspect) < size) {\n    \trigColor += vec3(1.,1.,0.);\n    }\n    if (length((StartControl - uv) * aspect) < size) {\n    \trigColor += vec3(0.,1.,0.);\n    }\n    if (length((End - uv) * aspect) < size) {\n    \trigColor += vec3(0.,1.,1.);\n    }\n    if (length((EndControl - uv) * aspect) < size) {\n    \trigColor += vec3(0.,0.,1.);\n    }\n    \n    // draw lines for each control point segment\n    float lines = 0.\n        + drawLine(Start, StartControl, uv, 5.)\n        + drawLine(StartControl, EndControl, uv, 5.)\n        + drawLine(EndControl, End, uv, 5.)\n        ;\n    rigColor += vec3(lines, 0., 0.);\n    \n    return rigColor;\n}\n\nvec2 SheerEdges(vec2 UV, float LeftShearDistance, float RightShearDistance)\n{\n\tfloat RightShearSpaceX = UV.x - (2. * RightShearDistance * UV.y) + RightShearDistance;\n\tvec2 ShearRightUV = vec2(RightShearSpaceX, UV.y);\n\n\tfloat TotalLeftShearDistance = LeftShearDistance + -1. * RightShearDistance;\n\n    float TotalShearSpaceX = ShearRightUV.x - (2. * TotalLeftShearDistance * ShearRightUV.y) + TotalLeftShearDistance;\n    vec2 TotalShearUV = vec2(TotalShearSpaceX, ShearRightUV.y);\n\n    float DestretchX = TotalShearUV.x / (1. - (2. * TotalLeftShearDistance * ShearRightUV.y) + TotalLeftShearDistance);\n    TotalShearUV.x = DestretchX;\n\n\treturn TotalShearUV;\n}\n\nvec2 DeformAndSheer(vec2 UV, vec2 Start, vec2 StartControl, vec2 EndControl, vec2 End, float SkewLeft, float SkewRight)\n{\n    return DeformUVByControlPoints_Bezier(SheerEdges(UV, SkewLeft, SkewRight), Start, StartControl, EndControl, End);\n}\n\nvec2 RightVector(vec2 a, vec2 b)\n{\n    vec2 aa = a;\n    vec2 ba = b;\n    \n    vec2 diff = ba - aa;\n    vec2 right = vec2(diff.y, -diff.x);\n    \n    return vec2(right.x, right.y) + aa;\n}\n\nfloat PointSlope(vec2 a, vec2 b)\n{\n    vec2 diff = b - a;\n    return diff.y / diff.x;\n}\n\nvec2 InterceptionOfHorizontalLine(vec2 a, vec2 b, float line)\n{\n    float x = ((line - a.y) / PointSlope(a, b)) + a.x;\n    return vec2(x, line);\n}\n\nvec2 ToView(vec2 P)\n{\n     return P * iResolution.xy;\n}\n\nvec2 ToUV(vec2 P)\n{\n     return P / iResolution.xy;\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 StartPointAndControl = vec4(0.1, 0.5, 0.33, 0.4);\n    vec4 EndPointAndControl = vec4(MouseU, MouseV, 0.9, 0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ToUV(fragCoord);\n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    \n    // Setup Start, End and respective Control Points\n    vec2 Pstart = StartPointAndControl.rg;\n\tvec2 PstartControl = StartPointAndControl.ba;\n    \n\tvec2 PendControl = EndPointAndControl.xy;\n    vec2 Pend =EndPointAndControl.zw;\n    \n    vec3 color = vec3(0.);\n    \n    vec2 StartSkewControl = RightVector(Pstart * iResolution.xy, PstartControl * iResolution.xy)/iResolution.xy;      \n    float SkewStart = (InterceptionOfHorizontalLine(Pstart, StartSkewControl, 1.).x - Pstart.x) / aspect.y;\n    \n    vec2 EndSkewControl = RightVector(Pend * iResolution.xy, PendControl * iResolution.xy)/iResolution.xy;      \n    float SkewEnd = (InterceptionOfHorizontalLine(Pend, EndSkewControl, 1.).x - Pend.x) / aspect.y;\n    \n    // borders\n    vec2 clamped_uv = vec2((uv.x - Pstart.x) / (Pend.x - Pstart.x), uv.y);\n    \n    vec2 deformed_uv = DeformAndSheer(ToView(clamped_uv, \n                                      Pstart, PstartControl,\n                                      PendControl, Pend,\n                                      SkewStart, SkewEnd);\n    \n    color += texture(iChannel0, deformed_uv).rgb;\n    \n    if (0. > deformed_uv.x) color *= 0.;\n    if (0. > deformed_uv.y) color *= 0.;\n    if (1. < deformed_uv.x) color *= 0.;\n    if (1. < deformed_uv.y) color *= 0.;\n    \n    #if SHOW_CONTROL_RIG\n    color = max(OverlayControlRig(uv, Pstart, PstartControl, Pend, PendControl, 0.01), color);\n    #endif\n    \n    if (length((EndSkewControl - uv) * aspect) < 0.01) {\n    \tcolor += vec3(1.,1.,1.);\n    } \n    color += vec3(0,1,0) * drawLine(Pend, EndSkewControl, uv, 5.);\n    \n    fragColor = vec4(color, 1.0);\n}\n*/\nvec2 CaluclateUVs(vec2 UV, vec2 Start, vec2 StartControl, vec2 End, vec2 EndControl, vec2 Dimensions)\n{\n    float Aspect = Dimensions.y / Dimensions.x;\n\t// Calculate the skew amount for the start point.\n    vec2 StartSkewControl = RightVector(Start * Dimensions.xy, StartControl * Dimensions.xy) / Dimensions.xy;      \n    float SkewStart = (InterceptionOfHorizontalLine(Start, StartSkewControl, 1.).x - Start.x) / Aspect;\n    \n    // Calculate the skew amount for the end point.\n    vec2 EndSkewControl = RightVector(End * Dimensions.xy, EndControl * Dimensions.xy) / Dimensions.xy;      \n    float SkewEnd = (InterceptionOfHorizontalLine(End, EndSkewControl, 1.).x - End.x) / Aspect;\n    \n    // Reproject TexCoords so x=0 is at the start point and x=1 is at the end point. \n    vec2 PointSpaceUV = vec2((UV.x - Start.x) / (End.x - Start.x), UV.y);\n    // Take the reprojected uvs deform them along a cubic spline and sheer the start and end edges.\n    vec2 DeformationSpaceUV = DeformAndSheer(PointSpaceUV,\n    \tStart, StartControl,\n    \tEndControl, End, \n    \tSkewStart, SkewEnd\n    );\n\n    return DeformationSpaceUV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 StartPointAndControl = vec4(0.2, 0.5, 0.33, 0.4);\n    vec4 EndPointAndControl = vec4(0.8, 0.5, MouseU, MouseV);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 Dimensions = iResolution.xy;\n    vec2 TexCoords = ToUV(fragCoord);\n    \n    // Setup Start, End and respective Control Points\n    vec2 Start = StartPointAndControl.rg;\n\tvec2 StartControl = StartPointAndControl.ba + vec2(0., .2*sin(iTime));    \n    vec2 End = EndPointAndControl.xy;\n\tvec2 EndControl = EndPointAndControl.zw;\n    \n    vec2 DeformationSpaceUV = CaluclateUVs(TexCoords, Start, StartControl, End, EndControl, Dimensions);\n    \n    vec3 FinalColor = vec3(0.);\n    // Sample texture with deformed uvs.\n    FinalColor += texture(iChannel0, DeformationSpaceUV).rgb;\n    // Cut wrapped artefacts around deformed uv projection.\n    if (0. > DeformationSpaceUV.x) FinalColor *= 0.;\n    if (0. > DeformationSpaceUV.y) FinalColor *= 0.;\n    if (1. < DeformationSpaceUV.x) FinalColor *= 0.;\n    if (1. < DeformationSpaceUV.y) FinalColor *= 0.;\n    \n    #if SHOW_CONTROL_RIG\n    // Show cubic spline control points.\n    FinalColor += OverlayControlRig(TexCoords, Start, StartControl, End, EndControl, 0.01);\n    #endif\n    \n    fragColor = vec4(FinalColor, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt33WX.jpg", "access": "api", "license": "proprietary-license", "functions": [[1100, 1152, 1205, 1205, 1617], [1619, 1619, 1688, 1688, 1856], [1858, 1858, 1913, 1913, 2004], [2006, 2006, 2065, 2065, 2197], [2199, 2199, 2291, 2291, 2786], [2788, 2788, 2880, 2880, 3013], [3015, 3015, 3118, 3118, 3892], [3894, 3894, 3971, 3971, 4552], [4554, 4554, 4675, 4675, 4795], [4797, 4797, 4831, 4831, 4982], [4984, 4984, 5018, 5018, 5071], [5073, 5073, 5136, 5136, 5219], [5221, 5221, 5242, 5242, 5276], [5278, 5278, 5297, 5297, 5331], [5333, 7282, 7385, 7385, 8405], [8407, 8407, 8464, 8464, 9715]], "test": "untested"}
{"id": "tlGcz3", "name": "Neural Light Field", "author": "blackle", "description": "a neural network that represents a light field.", "tags": ["nn", "neuralnetwork", "lightfield", "siren"], "likes": 73, "viewed": 2324, "published": 3, "date": "1611445403", "time_retrieved": "2024-07-30T19:42:50.699042", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//a neural network that represents a light field.\n//the network takes in the x and y coordinates of a plane, and the x,y,z coordinates of a view direction at that point\n//it then returns the colour of the scene given that direction\n//this can be used to construct a \"portal\" you can see the scene through.\n//the scene itself was rendered with blender and then trained into the neural network with a modified siren network\n//see: https://vsitzmann.github.io/siren/\n//the main modification was adding skip connections so the network can be deep instead of wide\n\n//see the common tab for the network itself and a switch to enable a larger, higher quality model\n\nvec3 plane_intersect(vec3 p, vec3 d, vec3 q, vec3 n) {\n    return p + d*dot(q-p, n)/dot(d, n);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p, ax)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(uv, 1));\n    vec3 init = vec3(0,0,-cos(iTime/3.)*3.-2.);\n    init.x += cos(iTime/2.)*.5;\n    \n    float yrot = cos(iTime)*.5;\n    float xrot = sin(iTime/5.)*.5;\n    \n    if (iMouse.z > 0.) {\n        xrot = -3.*mouse.y;\n        yrot = 3.*mouse.x;\n    }\n    \n    cam = erot(cam, vec3(1,0,0), xrot);\n    init = erot(init, vec3(1,0,0), xrot);\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    \n    vec3 sect = plane_intersect(init, cam, vec3(0), vec3(0,0,-1));\n    float border = max(abs(sect.x),abs(sect.y));\n    if ((border > 1. && init.z < 0.) || cam.z < 0.) {\n        fragColor = vec4(smoothstep(-.5,.5,sin(exp(-border)*200.))*.05+.1);\n        return;\n    }\n    vec3 f = lightfield(sect.xy, cam);\n\n\n    // Output to screen\n    fragColor = vec4(f, 1.);\n}", "image_inputs": [], "common_code": "//ucomment for a higher quality (but slower to compile) model!\n//#define BIG_MODEL\n//uncomment to enable the really tiny, poor quality model\n//#define MICRO_MODEL\n\nvec3 lightfield(vec2 uv, vec3 dir) {\n    float ft_0 = uv.x, ft_1 = -uv.y, ft_2 = -dir.y, ft_3 = dir.x, ft_4 = dir.z;\n#ifdef MICRO_MODEL\n//smallest model, 12x16, loss ~= .007\nvec4 f0_0=sin(ft_0*vec4(-.091,.193,-.148,-.104)+ft_1*vec4(.093,.200,-.332,-.185)+ft_2*vec4(.020,.892,-2.834,-.727)+ft_3*vec4(1.110,1.255,-.156,-1.193)+ft_4*vec4(-.702,-2.152,-.331,3.107)+vec4(1.507,-5.089,-2.078,3.469));\nvec4 f0_1=sin(ft_0*vec4(.182,.245,.018,-.481)+ft_1*vec4(-.493,.480,-.029,.147)+ft_2*vec4(-1.859,2.050,-.179,-.023)+ft_3*vec4(1.238,1.646,.400,-1.731)+ft_4*vec4(-.832,1.409,.418,-2.309)+vec4(.664,5.429,.786,-.633));\nvec4 f0_2=sin(ft_0*vec4(-.323,-.386,-.139,.328)+ft_1*vec4(-.252,.228,.844,.090)+ft_2*vec4(.633,1.033,2.701,2.168)+ft_3*vec4(-.478,-1.668,-.537,.688)+ft_4*vec4(.559,-1.830,1.314,-.305)+vec4(2.779,-3.522,-.004,-1.438));\nvec4 f1_0=sin(mat4(-.980,.272,.423,.137,-.682,-.068,-1.099,.171,.043,-.739,-.547,1.321,-.531,-.418,.618,-.085)*f0_0+\n    mat4(1.111,-.548,-.113,-.046,.623,-.057,.486,.178,-.771,.726,.140,.499,.975,-.573,-.861,-.698)*f0_1+\n    mat4(.996,.002,.116,-.704,-.136,-.495,.095,-.600,-.137,-.087,.020,-.277,-.202,.353,.779,-.832)*f0_2+\n    vec4(-2.755,2.322,.236,2.002))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.270,.593,.433,.151,-.065,.469,.410,-.941,-.402,-.678,.349,-.678,-.022,.446,.994,-.544)*f0_0+\n    mat4(.581,.361,-.014,-.065,-.031,.051,-.204,.063,.488,.430,-.051,-.082,.151,.720,.090,.602)*f0_1+\n    mat4(-.008,.710,.055,-.510,-.813,.088,-.295,-.066,.291,-.164,-.252,.339,-.252,-.100,-.210,-.545)*f0_2+\n    vec4(.359,-.395,.811,.943))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.088,.090,-.012,-.139,-1.668,.662,-1.032,-.778,-.216,1.063,-.405,-.379,-.316,-.026,-.219,-.260)*f0_0+\n    mat4(.234,-.711,.220,-.949,-.486,-.759,-.359,.533,.656,-.205,.736,.233,.606,-.800,.192,.356)*f0_1+\n    mat4(-.040,-.398,-.778,-.331,.318,-.965,-.345,.957,.586,-.592,.102,.201,.213,-.796,-.068,-.157)*f0_2+\n    vec4(2.425,1.987,.167,.811))/1.0+f0_2;\nvec4 f2_0=sin(mat4(.623,-.434,.462,.055,.282,.024,.243,.391,.033,-.226,-.419,.400,-.034,.116,-.128,-.276)*f1_0+\n    mat4(.969,.010,1.003,-.131,.342,-.818,.010,.111,1.031,-.151,.670,.938,-.346,-.380,.124,.100)*f1_1+\n    mat4(.486,.269,-.221,.023,-.903,-.605,.059,.772,-.257,-.130,.408,-.402,.039,.307,.023,.599)*f1_2+\n    vec4(1.675,-.360,1.275,2.145))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.377,.740,-.195,.322,-.106,-.925,.285,.428,-.472,.407,-.046,-.169,.213,.060,-.036,-.322)*f1_0+\n    mat4(1.535,.101,-.577,-.435,.039,.503,-.679,.567,.081,-.101,-.368,-.153,-.190,1.039,.887,.259)*f1_1+\n    mat4(.144,-.848,-1.220,.281,-.260,.586,-.136,-.368,-.267,.420,-.145,-.413,.300,-.448,-.942,.840)*f1_2+\n    vec4(-.866,.306,-.832,-.551))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.060,-.176,-.119,.643,1.105,.052,-.314,.430,-.133,.627,.467,.720,-.720,-1.016,-.173,.623)*f1_0+\n    mat4(-.163,-.273,-.284,.338,.161,-.041,-.173,-.415,-.382,.497,.135,-.048,-.172,-.063,-.188,.676)*f1_1+\n    mat4(.141,.214,-.123,-.893,-.555,.944,.189,.084,.368,.033,.899,.168,.062,.290,.918,.330)*f1_2+\n    vec4(-.876,2.460,.200,.360))/1.4+f1_2;\nvec4 f3_0=sin(mat4(.504,.236,-.924,-.015,.857,-.435,-.083,-.354,.613,.088,-.304,-.514,.466,-.493,-.650,.229)*f2_0+\n    mat4(-.000,-.197,-.830,-.619,.207,-.252,-.222,.080,-.909,-.598,-.088,-.354,-.453,.974,-.025,-.069)*f2_1+\n    mat4(-.402,-.204,.133,.555,.113,.743,.312,-.535,.544,.263,-.473,.163,-.829,.285,-.806,-.206)*f2_2+\n    vec4(-.528,.485,.076,-.149))/1.7+f2_0;\nvec4 f3_1=sin(mat4(-.019,.041,.273,-.731,.742,-.056,-.010,.052,-.927,-.431,-.024,.010,.531,-.038,-.503,-.855)*f2_0+\n    mat4(-.907,.109,-.129,.259,-.179,.587,.235,.414,.732,-.083,-.144,.210,.846,.310,.473,.122)*f2_1+\n    mat4(-.274,.326,.218,.530,-.149,-.548,.450,-.571,1.268,.199,.310,.010,.764,.302,.284,.113)*f2_2+\n    vec4(1.345,.238,.573,-.079))/1.7+f2_1;\nvec4 f3_2=sin(mat4(-.350,.339,.061,-.151,.026,-.527,.320,-.009,.635,-.051,-.018,-.558,-1.312,-.430,-.560,.889)*f2_0+\n    mat4(-.333,-.158,.592,.398,.170,-.157,-.033,.363,-.135,.334,.702,-1.382,.051,.260,-.378,.448)*f2_1+\n    mat4(-.164,-.140,.300,-.530,-.088,.121,-.318,.185,-.177,-.313,.109,.087,-.511,-.713,.199,-.806)*f2_2+\n    vec4(.012,-.018,.561,-1.215))/1.7+f2_2;\nvec4 f4_0=sin(mat4(-.321,-.581,-.463,-.174,-.317,-.153,.314,-.028,-.118,-.574,-.037,.569,-.216,.702,-.838,-.674)*f3_0+\n    mat4(-.840,-.248,.722,.405,-.026,.294,.368,-.231,.395,.206,.102,-.619,.265,-.272,-.304,-.226)*f3_1+\n    mat4(.007,.240,.861,.418,-.446,.149,.038,-.224,.625,-.401,-.114,-.532,.461,.169,-.756,.158)*f3_2+\n    vec4(.358,-.366,.138,-.746))/2.0+f3_0;\nvec4 f4_1=sin(mat4(.200,.407,.656,.124,-.828,-.330,-.653,.111,-.070,.293,-.065,-.375,.201,-1.422,.118,1.111)*f3_0+\n    mat4(.154,-.452,.213,-.315,.161,.751,-.120,.010,-.239,-.318,.441,-.615,.078,.920,.049,-.526)*f3_1+\n    mat4(-.030,-.011,-.308,-.791,.879,.412,.414,.294,.159,.543,.236,-.011,-.397,-.111,.453,-.777)*f3_2+\n    vec4(.525,.518,-.186,-1.267))/2.0+f3_1;\nvec4 f4_2=sin(mat4(-.218,.269,.070,-.358,.101,.631,.093,1.082,-.194,.053,.042,-.038,-1.325,-.452,1.119,.446)*f3_0+\n    mat4(.443,.239,-.487,-.916,.256,.194,.074,-.078,-.132,-.194,.124,-.097,.056,.985,1.074,-.305)*f3_1+\n    mat4(.199,-.197,-.312,-.130,.263,-.042,.207,.567,-.290,.789,.586,-.647,.282,.285,.560,.469)*f3_2+\n    vec4(.824,.862,-.478,-.735))/2.0+f3_2;\nvec4 f5_0=sin(mat4(1.480,-.320,.510,.133,-.093,-.217,.089,.164,-.009,-.200,.461,-.723,.694,-.270,-.548,.308)*f4_0+\n    mat4(.835,.237,.201,-.838,.784,-.035,.026,-.239,.618,.023,-.895,-.350,-.132,.169,.319,.263)*f4_1+\n    mat4(-.302,-.211,.200,.114,.563,-1.000,-.555,.204,.611,-.104,-.586,.382,-.174,-.256,-.041,.614)*f4_2+\n    vec4(.390,-.139,-.749,-.169))/2.2+f4_0;\nvec4 f5_1=sin(mat4(.289,.394,.357,-.355,-.572,-.440,.086,-.467,.687,-.297,1.189,-.729,.700,-.260,-.152,.244)*f4_0+\n    mat4(1.295,-.883,.514,-.412,.581,.362,.080,-.307,-.285,.524,.147,.490,-.363,.339,.273,.819)*f4_1+\n    mat4(.042,.044,.250,.169,.504,.479,.025,.153,.078,.713,-.301,-.360,-.799,.550,-.244,.478)*f4_2+\n    vec4(.695,-.674,1.975,.768))/2.2+f4_1;\nvec4 f5_2=sin(mat4(-.527,.059,-.246,.015,.742,-.220,.026,1.821,.057,.401,-.236,.281,.023,.819,-.094,.609)*f4_0+\n    mat4(.335,-.505,-.025,-.137,-.116,.354,-.862,.143,.060,.460,.421,-.309,-.455,.044,-.416,-.061)*f4_1+\n    mat4(-.769,-.423,-.001,-.456,-1.010,.542,-1.136,.641,-.486,.596,-.287,-.291,-.001,.060,.098,.622)*f4_2+\n    vec4(.587,.495,-.175,-1.210))/2.2+f4_2;\nvec4 f6_0=sin(mat4(-.357,-.293,.393,-.581,-.134,.177,-.193,.196,.430,1.341,-.092,-.576,.702,-.056,.159,-.830)*f5_0+\n    mat4(-.815,.237,-.901,-.367,-.394,-1.205,-.364,.211,.214,.288,-.664,-.214,-1.128,-.777,-.719,.419)*f5_1+\n    mat4(-.292,-.026,.088,-.326,.559,.401,.101,-.679,.430,-.188,-.501,-.554,1.223,.150,-.128,.456)*f5_2+\n    vec4(.323,-.106,-.159,-.030))/2.4+f5_0;\nvec4 f6_1=sin(mat4(.225,.020,.040,.533,-.235,-.023,.142,-.109,-.237,.110,.014,.777,.313,.351,-.299,-.114)*f5_0+\n    mat4(-.110,-1.171,-.071,.498,.550,.248,-.191,.119,-.185,-.642,.534,-.318,-.437,-.058,.435,.984)*f5_1+\n    mat4(.280,.479,.247,-.785,.345,.957,.354,-.262,.011,-.526,.450,-.982,-.984,-.310,.605,.749)*f5_2+\n    vec4(-.408,.207,-.083,1.683))/2.4+f5_1;\nvec4 f6_2=sin(mat4(1.591,.197,.049,.365,.337,-.291,-.506,.769,-.059,-.011,-.612,.534,.405,-.474,-.165,.722)*f5_0+\n    mat4(-.062,.619,.236,.705,.533,-.769,.100,1.098,.106,.064,-.078,-.390,.583,.169,.936,.444)*f5_1+\n    mat4(-.119,.606,.160,-.781,.673,-.328,.124,-.239,.614,-.310,.288,-.491,.098,.566,-.127,-.563)*f5_2+\n    vec4(1.026,.201,.533,-.142))/2.4+f5_2;\nvec4 f7_0=sin(mat4(.639,-.345,-.331,1.360,.710,-.355,.074,-.614,.757,.141,-.424,.154,.236,.353,.457,-.143)*f6_0+\n    mat4(.035,.317,.041,.069,-.287,-.602,-.051,.547,.838,-.217,-.520,.722,-.354,.188,.511,.680)*f6_1+\n    mat4(-.691,-.649,.783,.237,-.519,.090,.178,.281,-.175,-.907,-1.133,.228,.240,.027,.516,.616)*f6_2+\n    vec4(-.773,-.904,-.610,.713))/2.6+f6_0;\nvec4 f7_1=sin(mat4(-.565,-.194,-.979,.450,.807,-.384,.888,-.069,-.216,.866,.392,.940,.467,.166,.133,.070)*f6_0+\n    mat4(.322,.630,-.796,1.046,.081,-.702,-.109,-.814,-.322,-.443,-.988,-.172,-.190,.319,-.906,-.395)*f6_1+\n    mat4(-.496,-.682,-.133,.294,-.182,.218,-.047,.060,-.008,-.604,-.686,-.000,.156,-.707,-.541,-.298)*f6_2+\n    vec4(.022,-.357,-.721,-.514))/2.6+f6_1;\nvec4 f7_2=sin(mat4(.586,-.068,-.429,.702,-.522,.269,.234,-.504,.538,.852,.823,-.099,-.015,-.063,.348,.237)*f6_0+\n    mat4(-.231,-.144,-.400,.029,.047,.017,-.302,-.110,1.159,.459,.116,.814,.700,.128,.337,.427)*f6_1+\n    mat4(-.254,.657,-.448,.338,-.588,-.396,.634,-.286,-.078,.172,.376,-.049,-.203,.219,.525,.578)*f6_2+\n    vec4(1.095,-.125,-.295,.097))/2.6+f6_2;\nvec4 f8_0=sin(mat4(.400,1.143,-.096,.018,-.243,-.094,.655,.064,-.339,.753,1.123,-.603,-.670,.501,-.514,.353)*f7_0+\n    mat4(-.259,.575,.462,-.518,.288,-.203,.027,-.305,-1.171,.329,-.225,-.306,.145,.377,.035,-.493)*f7_1+\n    mat4(-.010,-.755,-.186,-.162,-.309,-.845,-.123,.444,.494,.388,-.405,.980,-.152,.034,-.716,-.120)*f7_2+\n    vec4(-.044,.285,.045,-.547))/2.8+f7_0;\nvec4 f8_1=sin(mat4(-.535,.214,.640,.985,-.265,-.434,.298,-.699,-.153,.194,.598,.267,.441,-.241,.278,.134)*f7_0+\n    mat4(.333,-.379,.151,.641,-.759,.170,.716,-.237,-1.087,1.044,-.977,-.343,.085,.161,.226,.107)*f7_1+\n    mat4(.463,-.709,-.038,-.715,.185,-.498,-.130,-.072,-.212,.255,-.119,1.187,-.713,-.077,-.871,-.005)*f7_2+\n    vec4(-1.483,.013,-1.774,-.149))/2.8+f7_1;\nvec4 f8_2=sin(mat4(-.475,-.702,-.053,-.010,-.489,-.042,-.430,.544,-.110,-.372,-.381,-.004,.055,-.637,-.100,-.830)*f7_0+\n    mat4(.245,-.849,.180,-.618,-.002,.601,1.104,-.833,.021,.726,.187,.112,.619,.320,-.058,.123)*f7_1+\n    mat4(.110,-.130,.864,-.506,-.070,.182,-.428,-.632,.036,-.302,.005,.350,-.742,.299,-.601,.560)*f7_2+\n    vec4(-.651,-.555,-1.049,2.991))/2.8+f7_2;\nvec4 f9_0=sin(mat4(.233,.055,-.144,.693,.417,-.823,-.700,-.704,-.064,-.626,.144,-.512,-.005,.238,.104,-.603)*f8_0+\n    mat4(.962,-1.008,.154,-.537,-.485,1.391,.588,.218,-1.113,-.351,.075,.967,.299,-.227,-.981,.634)*f8_1+\n    mat4(.302,.598,-.016,.386,-.650,.203,.272,-.046,-.346,.048,1.122,.318,-.101,-.785,-1.227,-.001)*f8_2+\n    vec4(-.856,.585,-.518,1.860))/3.0+f8_0;\nvec4 f9_1=sin(mat4(.506,-.081,.878,.419,.252,-.293,-.667,-1.053,-.214,-.403,-.994,.528,.599,-.754,-.478,-.706)*f8_0+\n    mat4(.318,-1.378,-.529,.629,-.247,.506,.109,-.310,-.572,.720,.286,.473,.978,.175,-.076,.730)*f8_1+\n    mat4(.877,-.242,-.313,-.106,-.740,-.102,-.782,-.352,-1.140,1.064,.108,.288,.431,.052,.276,.476)*f8_2+\n    vec4(-.607,-.049,.330,-.611))/3.0+f8_1;\nvec4 f9_2=sin(mat4(-.901,.291,.300,.245,-.025,-.150,-.109,-.049,.136,-.019,.847,-.410,-.124,-1.395,-.975,.076)*f8_0+\n    mat4(-.128,-.517,.163,.220,-.583,-.267,.255,-.349,.758,1.017,.012,-1.023,-.746,.669,.196,.528)*f8_1+\n    mat4(-.621,.319,-.412,-.362,-.762,-.811,-1.406,-.528,-.720,.581,.557,-.373,.617,-.119,-.015,.421)*f8_2+\n    vec4(-.464,1.022,-.673,-.279))/3.0+f8_2;\nvec4 f10_0=sin(mat4(.238,-.578,-.656,-.662,.017,-.387,.089,.254,-1.041,.228,-1.987,-.568,.183,-.293,-.632,.105)*f9_0+\n    mat4(-.111,-.122,-.682,.807,.067,-.892,-.472,-1.071,.030,-.480,-.764,-.536,.675,-.013,-.725,-.115)*f9_1+\n    mat4(.490,.779,-.183,-.089,-.876,-.384,.074,-.112,-.324,-.787,-.628,-.249,.777,-.288,1.210,-.620)*f9_2+\n    vec4(-.497,1.303,.673,-.333))/3.2+f9_0;\nvec4 f10_1=sin(mat4(.312,-.984,-1.247,-.833,.489,.549,-.214,1.463,.931,.138,-.782,.689,-.572,-.743,-.721,-.342)*f9_0+\n    mat4(.815,-.009,-.278,-.301,-.293,-.273,-.717,.034,.444,.480,1.088,.187,.690,-.198,-.734,-.272)*f9_1+\n    mat4(.242,-1.000,.771,.721,.736,-.092,.216,.318,1.064,1.007,-.514,.082,-.127,-.465,.702,-.033)*f9_2+\n    vec4(.483,.848,-.779,-1.040))/3.2+f9_1;\nvec4 f10_2=sin(mat4(-.038,.768,.325,.024,.366,-.225,1.482,.157,-.119,.176,-.054,-.612,.625,-.525,.363,-.196)*f9_0+\n    mat4(.329,.952,.110,-1.184,1.034,-.815,.195,-.125,-.707,1.314,.257,.097,-.977,.586,-.196,-.442)*f9_1+\n    mat4(.871,.713,.108,-.216,-.206,-.679,.216,-.595,-.316,.522,1.310,-.430,-.119,.631,.603,1.257)*f9_2+\n    vec4(-1.162,1.307,-2.119,.884))/3.2+f9_2;\nvec4 f11_0=sin(mat4(-.584,.189,.191,.859,.476,-.203,.417,1.040,.575,-1.267,1.493,1.337,.502,-.299,-.215,.662)*f10_0+\n    mat4(1.217,.045,1.106,-.210,.015,-.475,.146,1.139,-.470,.966,.330,-.308,.610,-.840,.027,.741)*f10_1+\n    mat4(-.379,-.706,.734,-1.025,-.002,-.273,-.390,.515,.433,-.300,.878,-.483,-.358,.577,-.190,.540)*f10_2+\n    vec4(1.788,.737,2.134,-.805))/3.3+f10_0;\nvec4 f11_1=sin(mat4(-.727,-.476,-.997,.063,-.814,-.157,-.109,-.622,-.897,-.943,.573,-.598,.297,-.049,-.808,.373)*f10_0+\n    mat4(-1.412,-.663,-.693,.604,.049,-.249,.094,-.213,-.559,.031,-.712,.112,-.195,.336,.885,1.244)*f10_1+\n    mat4(-.468,-.700,-1.080,.321,.356,.343,-.883,.321,-.872,-.380,-.237,-.780,.406,.321,-.571,-.292)*f10_2+\n    vec4(1.565,-.172,.730,1.630))/3.3+f10_1;\nvec4 f11_2=sin(mat4(.448,-.431,-.456,-.306,.592,1.098,.111,-.042,1.078,-.672,1.115,.499,.181,-.702,.196,-.197)*f10_0+\n    mat4(-.449,-.600,-.538,.128,.146,-.768,.526,.134,.633,.504,.183,-.528,-.158,-.396,.714,.854)*f10_1+\n    mat4(-.733,.969,.001,.166,-.384,-.185,.385,-.013,.565,.639,1.000,-.854,.393,.298,-.412,-.742)*f10_2+\n    vec4(.635,-.687,.163,.930))/3.3+f10_2;\nvec4 f12_0=sin(mat4(-.171,-.092,.426,-.773,.397,.385,.419,-.205,-.725,-.091,1.104,.529,.107,-.502,.159,-.980)*f11_0+\n    mat4(-.659,-.180,1.289,.143,.339,-.509,.552,-.287,-.571,-.281,.026,.131,-.365,.366,.041,.376)*f11_1+\n    mat4(-.709,-.422,.265,.439,1.421,-.420,-.173,-1.044,.422,-.838,-.323,-.100,-.928,-.643,-.743,-1.159)*f11_2+\n    vec4(.212,.033,-1.112,-.695))/3.5+f11_0;\nvec4 f12_1=sin(mat4(-.181,-.098,-.168,-.237,1.374,-.223,-.396,-.487,1.172,.332,.525,-1.497,.543,1.116,-1.478,.289)*f11_0+\n    mat4(1.489,-1.044,.813,-.731,-.852,1.383,-1.470,-.106,.026,-.027,.873,.158,.157,-.762,1.185,.418)*f11_1+\n    mat4(-.115,-.293,.381,-.034,1.001,.690,-1.405,.257,.295,.796,-.411,-1.274,.048,-.396,.088,.368)*f11_2+\n    vec4(-.938,-2.093,-.080,-.373))/3.5+f11_1;\nvec4 f12_2=sin(mat4(-.314,.533,-.844,-.220,.635,-.317,-1.580,-.104,.486,.770,1.053,-.319,.999,-.148,-.844,.140)*f11_0+\n    mat4(-.287,1.006,.148,-.641,-.297,-.671,-.043,-.166,-1.892,.456,.449,.596,.238,.556,.950,-.097)*f11_1+\n    mat4(-.801,1.061,1.112,.274,-.222,-.671,-1.048,-.619,-.785,.070,1.047,.782,.211,-.128,.002,-.968)*f11_2+\n    vec4(1.031,.459,-.199,.419))/3.5+f11_2;\nvec4 f13_0=sin(mat4(.600,.154,.000,.600,.276,-1.391,.125,-.648,-.063,.332,2.032,-.345,.463,-1.425,.271,-.286)*f12_0+\n    mat4(.914,.129,.838,-1.162,-.230,.245,.531,.380,-.057,1.564,-.014,1.502,-.565,.823,-.025,-.395)*f12_1+\n    mat4(-.007,1.400,.498,1.227,.394,-.747,-.373,-1.244,-1.147,.820,.455,.059,-.510,-.497,-.203,-.294)*f12_2+\n    vec4(-2.030,-1.580,-2.235,-1.784))/3.6+f12_0;\nvec4 f13_1=sin(mat4(-.464,.701,-.054,.935,.581,-.642,1.342,-.350,.855,1.781,.884,-.034,.925,-.147,.405,-1.777)*f12_0+\n    mat4(.745,.279,1.862,-.005,.462,.858,-.903,-1.907,.097,.938,-.439,1.453,.007,.290,-.222,-.099)*f12_1+\n    mat4(.081,1.504,-1.048,1.365,.303,-.643,.499,-2.585,.751,.887,-.457,-.350,-.400,-1.068,.981,.304)*f12_2+\n    vec4(-1.506,.466,-.138,1.022))/3.6+f12_1;\nvec4 f13_2=sin(mat4(-.584,-.707,-.174,1.145,1.001,.729,-1.416,-.918,.662,-.615,.752,1.179,.861,1.373,-.654,.392)*f12_0+\n    mat4(1.119,-.222,-.049,.977,-.750,.215,.115,.252,-1.262,-.516,.906,1.291,.379,-.836,.719,.182)*f12_1+\n    mat4(-1.111,-.608,1.234,1.097,.806,.883,.343,-.584,-.635,.380,.396,.422,-.077,.008,-.834,.941)*f12_2+\n    vec4(1.274,-.821,-1.443,-2.386))/3.6+f12_2;\nvec4 f14_0=sin(mat4(.348,-.480,.148,.072,.307,-.226,-.125,-1.116,-.117,.062,-2.283,-.313,.492,-.054,-.021,-1.624)*f13_0+\n    mat4(.415,-1.021,-1.335,.806,-.482,.906,-.354,-.606,-1.474,-1.023,-.568,1.702,-.057,-.330,-.537,1.074)*f13_1+\n    mat4(-1.103,.208,-.615,1.242,.493,-.438,.429,-1.124,-.886,.043,-1.047,.582,.855,-.741,-.008,.212)*f13_2+\n    vec4(-.102,2.245,.984,-.038))/3.7+f13_0;\nvec4 f14_1=sin(mat4(.123,-.176,-.393,.764,-.686,-.160,-.164,-1.537,1.107,1.013,-.440,-.460,-.485,-.812,-1.008,-.576)*f13_0+\n    mat4(-.419,-.065,-.708,.361,1.298,.138,-1.316,-1.185,.058,.899,.844,1.104,-.074,.374,.909,.867)*f13_1+\n    mat4(.518,.240,.741,.692,-.019,-.038,-.803,-.712,1.281,.719,.149,-.251,-1.553,-.130,-1.030,1.053)*f13_2+\n    vec4(-.979,-.834,-1.216,-2.141))/3.7+f13_1;\nvec4 f14_2=sin(mat4(-.182,-.089,-.009,1.055,-.271,-.774,-.563,.005,-1.096,-1.939,.203,-1.227,.003,-.003,-.288,-.261)*f13_0+\n    mat4(-.759,-1.139,.457,.876,.468,.097,-.308,-.921,-.162,.541,.581,.279,.135,-.112,-.546,.565)*f13_1+\n    mat4(-.632,.692,.517,-.066,.518,.437,.691,.102,-.772,-.387,1.003,.427,-.460,-.014,-1.725,.433)*f13_2+\n    vec4(1.277,-.301,-.579,.570))/3.7+f13_2;\nvec4 f15_0=sin(mat4(-.282,-.810,-.343,.319,.401,.140,.242,-.113,-.769,.106,-1.363,-.239,-.550,1.064,-.176,-1.082)*f14_0+\n    mat4(-.561,.265,-1.219,-.470,.428,-.001,.493,-.081,.757,-.298,-.457,-.127,-.394,-.780,-.342,.496)*f14_1+\n    mat4(-.561,-.784,-.140,.685,.587,1.329,.314,-.503,-.280,.852,-.977,-.005,-1.206,.416,-.109,.516)*f14_2+\n    vec4(-1.116,-1.235,-1.281,-.965))/3.9+f14_0;\nvec4 f15_1=sin(mat4(.625,1.240,.086,-.219,.127,-.394,-.402,.639,-.560,.134,1.289,-1.224,-.719,-.704,-.413,1.179)*f14_0+\n    mat4(-.160,.887,.157,-.570,-.345,-.371,.184,-.078,.787,.926,-.020,-1.452,.035,.497,-.186,-1.104)*f14_1+\n    mat4(.498,.494,-.442,-.558,-.131,-1.258,-.079,1.430,-.100,.486,.361,-.663,-.076,.966,.125,-.009)*f14_2+\n    vec4(.894,-1.486,.034,1.697))/3.9+f14_1;\nvec4 f15_2=sin(mat4(-.391,1.126,.620,-.150,.397,-.432,-1.269,.066,-.195,1.349,-1.162,-.896,-.905,-1.144,-.705,1.259)*f14_0+\n    mat4(-.208,1.405,-1.005,-1.432,-1.133,-.791,.048,1.041,-.216,1.710,-.137,-.427,-.149,1.168,.064,-1.071)*f14_1+\n    mat4(-.306,1.509,.077,-.855,-.637,-1.670,-.038,.923,.346,.959,.730,-.555,-.178,.199,-.381,-.472)*f14_2+\n    vec4(1.840,-1.800,-.196,-.557))/3.9+f14_2;\nvec4 f16_0=sin(mat4(-.179,.425,-.465,.811,1.166,-.462,-.155,-.978,-.532,-1.031,.217,-.933,.860,.624,.166,-2.150)*f15_0+\n    mat4(-.030,-.532,-.422,-.547,.713,.298,1.147,-1.271,-.731,-.422,-.074,1.399,-.926,-.090,-.263,1.276)*f15_1+\n    mat4(-.424,-.491,.021,.082,1.028,.156,.846,-1.475,-.569,-.204,.489,-.105,-.870,-.805,-.651,.872)*f15_2+\n    vec4(-1.486,-4.088,.065,1.831))/4.0+f15_0;\nvec4 f16_1=sin(mat4(.281,-.967,-.797,1.062,-.801,.236,-.188,-.897,-.353,-.296,-1.599,.508,-.867,.234,.610,-.394)*f15_0+\n    mat4(-.477,.557,-1.323,.249,-.552,-.510,.056,.011,.012,-.449,-.871,.172,.665,-.117,-.327,.692)*f15_1+\n    mat4(.172,-.670,-.892,.099,-.910,.235,1.129,-1.087,-.228,-.322,-.728,-.016,.587,-.540,.022,1.346)*f15_2+\n    vec4(3.914,.133,1.319,-.133))/4.0+f15_1;\nvec4 f16_2=sin(mat4(-.213,-1.333,.124,.421,.273,.293,.775,-.142,-1.049,-.996,-1.707,.508,.668,.703,.253,-1.494)*f15_0+\n    mat4(-.521,-.833,.144,.670,.001,-.227,-1.476,-1.285,-.169,-.709,-.291,1.294,-.077,-.727,-.193,1.603)*f15_1+\n    mat4(-.792,-.449,-1.303,.445,1.434,1.045,.300,-.819,-1.051,.442,-1.298,.172,.568,-.349,1.172,1.071)*f15_2+\n    vec4(-1.388,.541,1.943,.871))/4.0+f15_2;\nfloat f_0=dot(f16_0,vec4(-.052,.097,.023,.103))+\n    dot(f16_1,vec4(.033,-.005,-.044,-.056))+\n    dot(f16_2,vec4(-.065,.103,-.012,-.016))+\n    0.531;\nfloat f_1=dot(f16_0,vec4(-.055,.056,.093,.088))+\n    dot(f16_1,vec4(.022,.068,-.036,-.054))+\n    dot(f16_2,vec4(-.005,.083,.046,-.074))+\n    0.473;\nfloat f_2=dot(f16_0,vec4(-.058,.037,-.056,.090))+\n    dot(f16_1,vec4(-.066,.054,-.079,-.082))+\n    dot(f16_2,vec4(-.060,.120,-.014,-.062))+\n    0.558;\n#else\n#ifdef BIG_MODEL\n//big model 32x16 loss = .2\nvec4 f0_0=sin(ft_0*vec4(.409,.133,-.050,.123)+ft_1*vec4(-.425,.121,-.463,.732)+ft_2*vec4(-.402,.281,-2.306,-.200)+ft_3*vec4(.084,-.041,-.634,-.825)+ft_4*vec4(-1.275,1.030,-.473,.866)+vec4(-1.851,2.320,-5.279,1.034));\nvec4 f0_1=sin(ft_0*vec4(.372,-.232,.129,-.632)+ft_1*vec4(.430,1.136,-.349,-.546)+ft_2*vec4(.587,.557,-.138,-2.463)+ft_3*vec4(.329,-.020,-.051,-1.184)+ft_4*vec4(1.027,.999,1.673,-.097)+vec4(2.182,.584,2.164,-.954));\nvec4 f0_2=sin(ft_0*vec4(-.703,-.186,-.007,-.028)+ft_1*vec4(-.225,-.344,-.021,-.651)+ft_2*vec4(.424,1.487,.412,-2.944)+ft_3*vec4(-1.963,.047,.012,-.030)+ft_4*vec4(.524,2.219,.922,2.159)+vec4(-2.854,3.645,2.376,3.604));\nvec4 f0_3=sin(ft_0*vec4(.188,.721,-.743,.462)+ft_1*vec4(.268,.072,.429,.088)+ft_2*vec4(-1.390,.815,-.242,2.014)+ft_3*vec4(1.527,2.516,-2.061,.805)+ft_4*vec4(1.437,.458,-1.028,.331)+vec4(.937,.519,1.400,-.996));\nvec4 f0_4=sin(ft_0*vec4(.018,-.350,.246,.568)+ft_1*vec4(.434,-.186,-.593,-.171)+ft_2*vec4(.279,-.439,-1.378,-1.606)+ft_3*vec4(.737,-1.913,2.547,2.246)+ft_4*vec4(-2.430,-2.341,.767,-.797)+vec4(-4.471,-4.027,-1.343,1.822));\nvec4 f0_5=sin(ft_0*vec4(-.747,.170,-.071,-.294)+ft_1*vec4(.414,.525,.342,.128)+ft_2*vec4(.801,1.726,.479,.076)+ft_3*vec4(.154,.163,.840,.079)+ft_4*vec4(-1.296,2.880,-.597,1.528)+vec4(-.920,4.362,-2.450,2.072));\nvec4 f0_6=sin(ft_0*vec4(.459,-.126,.027,-.403)+ft_1*vec4(-.400,.286,.171,.051)+ft_2*vec4(-1.179,.233,-.301,.744)+ft_3*vec4(.527,-.167,.761,.805)+ft_4*vec4(-2.008,.818,-1.454,.977)+vec4(-1.678,2.451,-2.118,1.750));\nvec4 f0_7=sin(ft_0*vec4(.029,.085,-.072,.424)+ft_1*vec4(.100,-.699,-.169,-.199)+ft_2*vec4(2.608,-1.039,.403,-1.846)+ft_3*vec4(-.057,1.183,.051,.102)+ft_4*vec4(.434,.753,1.232,.262)+vec4(-.927,2.969,2.210,-2.279));\nvec4 f1_0=sin(mat4(-.033,-.159,.160,-.184,.182,-.205,-.299,-.086,-.224,.107,-.423,.730,-.087,-.380,-.291,.333)*f0_0+\n    mat4(-.388,-.068,-.075,.130,.158,-.260,-.063,.269,-.349,.311,.215,-.173,-.385,.240,.100,.205)*f0_1+\n    mat4(.014,.065,.373,.451,-.129,.266,-.091,-.063,-.101,.044,.125,.190,-.749,-.611,.571,-.614)*f0_2+\n    mat4(.005,-.018,-.506,.491,.180,.283,.001,-.444,.226,.151,.283,-.212,-.068,-.342,.349,-.428)*f0_3+\n    mat4(.043,-.688,.341,.054,-.164,-.123,-.198,.120,-.212,-.202,.282,.441,.077,.126,-.235,.008)*f0_4+\n    mat4(-.177,.028,.196,.110,.629,.564,-.245,-.292,.009,.667,-.039,-.029,-.045,.014,.073,.217)*f0_5+\n    mat4(.383,.228,-.233,-.205,.102,-.174,-.205,.272,.051,-.144,-.289,.200,-.153,.016,-.147,.126)*f0_6+\n    mat4(-.244,.066,.663,-1.603,-.121,.377,.297,-.422,-.068,.103,.160,-.010,-.147,-.282,.521,-.395)*f0_7+\n    vec4(-.221,-.541,-.483,.452))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.317,-.022,.077,-.211,.079,.365,-.119,.207,.131,.130,-.627,-.095,-.115,-.060,-.229,.369)*f0_0+\n    mat4(.063,.176,-.378,.267,.134,-.442,-.084,.011,-.141,.295,.244,-.348,-.483,-.025,.075,-.617)*f0_1+\n    mat4(1.131,-.122,.546,-.113,-.081,.211,-.174,.160,-.000,.561,-.237,-.140,-.317,-.431,-.165,-1.079)*f0_2+\n    mat4(.123,.046,.049,.018,.638,.151,.103,.004,-.275,-.296,-.099,-.069,-.295,.045,.330,-.353)*f0_3+\n    mat4(.216,-.686,.354,-.154,-.506,.141,-.653,-.155,.189,.071,.426,.266,.391,-.028,.001,-.333)*f0_4+\n    mat4(.032,-.015,.004,.090,.196,-.103,-.000,.211,-.216,.281,-.332,.084,-.283,.109,-.050,-.204)*f0_5+\n    mat4(-.475,.037,-.421,.515,.091,.202,.076,.204,-.222,-.094,-.936,.500,.462,-.232,-.265,.134)*f0_6+\n    mat4(-.073,-.041,.396,.688,-.594,-.196,-.127,.075,.138,-.133,-.211,-.004,.159,.178,.272,.135)*f0_7+\n    vec4(.385,-.393,-.583,.390))/1.0+f0_1;\nvec4 f1_2=sin(mat4(.041,.348,-.043,-.028,.261,-.084,.250,-.091,.728,1.026,-.641,-.026,.414,.188,-.126,-.072)*f0_0+\n    mat4(.211,.172,.135,.068,.053,-.014,-.279,-.250,.146,-.027,.240,.346,-.316,-.141,-.098,.170)*f0_1+\n    mat4(.104,.260,.100,.156,-.127,.102,-.330,-.104,.110,.152,-.164,.133,.007,-.166,.825,2.075)*f0_2+\n    mat4(.164,-.451,-.079,.036,-.476,-.941,.055,-.125,.056,.131,.149,.088,-.649,-.613,.361,-.031)*f0_3+\n    mat4(.202,-.127,.714,-.018,.063,-.037,-.086,.061,.174,-.008,.083,.100,-.315,-.292,-.098,.374)*f0_4+\n    mat4(.074,.034,-.229,-.144,-.570,-.123,-.248,-.679,-.012,.219,-.485,-.048,.058,-.316,.299,-.196)*f0_5+\n    mat4(-.437,-.647,-.034,-.373,.262,-.271,.168,-.002,-.235,-.130,-.230,-.231,.070,.083,.028,-.030)*f0_6+\n    mat4(-.499,-.795,.771,.072,.011,.323,.041,.269,.100,.104,-.129,.074,.167,-.117,.330,-.039)*f0_7+\n    vec4(.186,-.408,.660,.322))/1.0+f0_2;\nvec4 f1_3=sin(mat4(.091,-.031,-.182,-.010,-.058,.080,-.120,-.135,-.286,.066,-.427,.527,.084,.085,-.079,.517)*f0_0+\n    mat4(-.146,.048,.200,.105,-.050,-.115,.225,-.078,.244,.273,-.826,-.244,.149,.177,.336,-.180)*f0_1+\n    mat4(-.060,-.009,.553,-.356,-.030,.060,.110,.198,-.004,-.216,-.254,-.120,.886,-.232,-.531,.119)*f0_2+\n    mat4(-.104,-.057,.271,-.362,-.030,-.893,.551,.083,.068,-.117,-.601,.479,.015,-.038,.256,-.068)*f0_3+\n    mat4(.375,.016,.107,-.162,-.408,.176,-.445,.918,.744,.327,.450,-.391,-.093,-.602,.749,-1.068)*f0_4+\n    mat4(.245,-.056,-.039,-.056,-.644,-.401,.159,.256,.128,.041,-.297,.097,.096,.361,-.160,.151)*f0_5+\n    mat4(-.828,-.480,.076,.226,-.126,.028,.190,.095,-.486,-.063,.257,.034,-.099,-.296,.068,.060)*f0_6+\n    mat4(-.249,.004,.091,.383,.040,.383,-.422,.787,.324,-.108,-.043,-.089,.286,.221,-.191,-.085)*f0_7+\n    vec4(-.414,-.533,.929,.574))/1.0+f0_3;\nvec4 f1_4=sin(mat4(-.177,-.061,-.049,-.269,.156,.087,.105,.066,.274,-.879,.296,-.009,-.123,-.231,.179,-.147)*f0_0+\n    mat4(-.000,-.294,.175,-.154,.436,-.098,.196,.004,-.078,.266,-.075,.088,.265,.169,-.177,.357)*f0_1+\n    mat4(.790,.067,.062,.506,-.055,-.328,-.127,-.200,.200,-.017,-.321,-.060,-1.176,.085,-.129,-.239)*f0_2+\n    mat4(.155,.141,-.238,.565,.107,.361,-.356,.154,-.379,.115,.105,-.353,-.218,.717,-.508,-.112)*f0_3+\n    mat4(.034,.355,.115,.227,-.291,.600,-.358,-.166,.107,-.068,.647,.627,.519,-.132,.074,.253)*f0_4+\n    mat4(-.123,.037,.023,-.131,-.133,.054,-.595,-.335,-.022,-.099,.131,-.244,-.186,.275,.050,.024)*f0_5+\n    mat4(-.386,.062,-.283,-.251,.206,-.092,.256,.059,-.423,-.402,.089,-.070,.102,.159,.048,.325)*f0_6+\n    mat4(-.827,1.239,-.076,-.494,-.452,.178,-.173,-.305,-.126,.096,.029,-.034,-.190,.091,.105,-.042)*f0_7+\n    vec4(-.195,.300,-.198,.498))/1.0+f0_4;\nvec4 f1_5=sin(mat4(-.238,.311,-.115,-.020,.005,-.031,.159,.074,.044,-.055,.369,-.453,.175,-.040,.284,.128)*f0_0+\n    mat4(.491,.142,.315,-.061,.096,-.078,.200,-.383,.004,.124,-.520,.069,-.269,-.215,-.406,-.146)*f0_1+\n    mat4(.257,.218,-.108,-.281,.169,.074,-.258,-.271,-.077,-.365,-.253,-.290,-1.355,.011,-.305,.968)*f0_2+\n    mat4(.051,.258,.186,-.255,-.164,-.341,-.540,.582,-.293,.118,.092,.404,.221,.591,-.578,.176)*f0_3+\n    mat4(-.045,-.119,.372,.244,.030,.258,-.469,-.318,.382,.231,-.103,-.314,-.711,-.068,.111,-.345)*f0_4+\n    mat4(.149,.183,-.231,-.097,-.144,-.369,-.078,.256,.071,.054,-.390,-.267,.169,-.035,-.214,-.107)*f0_5+\n    mat4(-.402,-.549,.278,.539,.023,-.144,.333,.028,-.087,-.271,.886,.277,.237,-.349,-.109,.143)*f0_6+\n    mat4(.043,-.253,.118,1.049,.300,-.056,-.278,.079,.267,-.413,-.294,-.192,-.010,-.088,-.237,.418)*f0_7+\n    vec4(.398,-.530,.779,.696))/1.0+f0_5;\nvec4 f1_6=sin(mat4(-.264,-.004,-.229,.023,-.023,.205,-.175,-.187,-.131,-.889,.359,.186,-.014,-.331,-.097,-.270)*f0_0+\n    mat4(-.072,.093,.307,-.149,.339,-.165,.009,-.173,.091,.198,-.745,.126,-.060,.345,.029,.748)*f0_1+\n    mat4(.348,-.192,-.263,-.107,-.447,-.135,-.024,.033,-.202,-.012,-.177,.595,-.085,.916,.439,.913)*f0_2+\n    mat4(.206,.073,.508,.664,.631,.243,-.497,.020,-.595,.119,.141,-.368,.088,.658,.228,.082)*f0_3+\n    mat4(.291,.344,.050,-.302,-.398,-.263,-.059,.337,.508,.126,-.191,-.527,.514,.589,.598,.382)*f0_4+\n    mat4(.016,-.025,-.383,.043,-.075,.050,.535,.070,-.334,-.200,-.314,.112,.076,.243,-.325,.273)*f0_5+\n    mat4(-.135,.231,.645,.351,-.017,-.045,.002,-.201,-.303,-.064,.755,.219,.358,.128,.333,-.135)*f0_6+\n    mat4(-.391,.674,.580,-.538,-.567,-.066,-.110,.317,-.024,-.166,-.146,-.122,-.440,.152,-.212,-.217)*f0_7+\n    vec4(.769,.056,.713,-.031))/1.0+f0_6;\nvec4 f1_7=sin(mat4(-.081,-.002,-.192,-.219,-.078,-.044,.118,.174,-.007,.022,-.542,-.209,.222,.362,-.173,.204)*f0_0+\n    mat4(-.154,.336,-.159,.462,-.010,.093,.006,-.092,-.451,.077,.052,-.391,-.397,-.188,.221,.152)*f0_1+\n    mat4(-.184,.170,.280,-.360,.113,-.065,-.164,.010,-.109,-.327,.021,-.237,.008,.075,-.849,.756)*f0_2+\n    mat4(-.335,.087,-.030,.263,.692,-.317,.736,.055,.113,-.055,-.043,-.068,-.001,-.025,.553,.309)*f0_3+\n    mat4(-.183,.206,.186,.209,-.385,.396,-.074,.180,.118,.359,-.315,.242,.122,-.395,.211,.155)*f0_4+\n    mat4(.214,.165,-.232,-.200,.664,-.653,.677,-.203,-.116,.039,-.374,-.335,-.662,.157,.174,-.242)*f0_5+\n    mat4(.281,-.673,.714,-.058,-.033,.184,-.112,.188,-.068,-.194,.292,.205,.030,-.134,.281,.039)*f0_6+\n    mat4(.618,-.024,.159,1.115,-.258,.243,-.280,-.228,-.075,-.152,.055,-.049,-.061,.163,-.291,.106)*f0_7+\n    vec4(.196,-.030,.316,.436))/1.0+f0_7;\nvec4 f2_0=sin(mat4(-.039,.210,-.168,-.151,-.239,.293,.141,-.203,.456,-.386,.166,.267,-.158,-.557,-.084,.111)*f1_0+\n    mat4(-.474,-.068,.215,.074,.235,-.118,-.033,-.180,.173,-.093,-.163,.001,-.325,-.089,-.286,.138)*f1_1+\n    mat4(.178,.066,.031,.328,-.111,.246,.157,-.004,-.507,.428,-.184,.235,-.397,.782,.900,-.659)*f1_2+\n    mat4(.575,-.402,-.122,.027,-.304,.010,.257,.250,.304,-.142,.226,-.218,-.224,.207,.369,-.371)*f1_3+\n    mat4(.050,.210,-.468,.227,.012,.055,.012,-.464,.091,.234,.420,.350,.094,.070,.257,-.050)*f1_4+\n    mat4(.082,-.059,-.110,.124,.007,.486,.260,-.242,.253,.154,-.129,.125,.036,.204,.005,-.312)*f1_5+\n    mat4(-.232,.131,-.407,.117,-.281,.421,-.014,-.354,-.060,-.173,.020,-.158,-.239,.100,.077,-.347)*f1_6+\n    mat4(-.374,.263,-.064,-.117,.304,-.010,.074,-.316,-.244,-.047,.310,-.094,-.413,.372,.215,-.475)*f1_7+\n    vec4(-.269,-.195,-.165,.268))/1.4+f1_0;\nvec4 f2_1=sin(mat4(.056,.453,.023,-.203,.240,-.109,.201,.044,-.375,.067,-.283,.615,.235,-.673,.076,.313)*f1_0+\n    mat4(-.090,-.039,-.004,.124,-.029,-.650,.026,.145,.536,.236,.285,.108,-.038,.365,.124,-.256)*f1_1+\n    mat4(.126,.185,.289,.235,-.054,.043,-.079,.044,.311,.291,.027,-.290,.021,.696,.512,-.399)*f1_2+\n    mat4(-.315,-.131,.105,.221,-.226,-.426,-.839,-.615,-.097,.023,-.485,.089,-.311,-.121,.026,.124)*f1_3+\n    mat4(-.422,-.062,.466,-.486,.456,-.204,.185,-.113,.222,-.144,.354,.401,-.877,-.035,.021,-.068)*f1_4+\n    mat4(.652,.136,.249,.528,.319,.040,-.258,.262,.574,.300,-.375,.010,.044,-.347,.441,.027)*f1_5+\n    mat4(-.300,-.414,-.439,-.153,.118,.371,.002,-.156,-.138,.029,.396,-.337,-.157,.049,-.255,-.048)*f1_6+\n    mat4(-.164,-.052,.158,-.769,.465,.519,-.084,-.033,-.209,.039,.180,-.021,.235,.062,.316,-.142)*f1_7+\n    vec4(-.571,-.303,.342,-.603))/1.4+f1_1;\nvec4 f2_2=sin(mat4(.200,-.267,-.195,-.116,.245,-.458,.321,-.651,.169,.241,.645,-.424,.197,.222,-.333,.182)*f1_0+\n    mat4(.058,.025,.396,-.248,-.104,.452,.230,.059,-.229,-.507,-.197,-.396,-.261,-.532,-.192,-.450)*f1_1+\n    mat4(-.103,.266,.500,.184,-.164,-.221,-.112,.044,.246,-.198,.328,-.149,-.503,-.314,.768,-.806)*f1_2+\n    mat4(.208,.178,.024,.041,-.191,-.033,-.099,.149,-.156,-.267,.218,.469,-.295,.141,.008,.001)*f1_3+\n    mat4(-.084,.524,-.415,-.251,.345,-.155,.312,.102,.081,.151,-.071,.092,-.793,.077,-.138,.286)*f1_4+\n    mat4(.404,-.107,.236,-.045,.149,-.407,-.116,-.040,-.092,.354,-.121,.036,-.057,.585,-.157,.224)*f1_5+\n    mat4(.120,-.200,-.129,.201,.263,.302,-.464,-.098,-.210,.087,-.289,.397,.081,-.086,.526,.183)*f1_6+\n    mat4(-.229,.076,-.275,.409,.394,-.013,.356,-.266,-.257,.233,-.017,.368,.268,-.039,-.128,-.197)*f1_7+\n    vec4(-.608,.291,-.473,1.012))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.393,-.141,-.357,-.169,-.085,-.154,-.013,-.126,.005,-.341,.460,-.079,-.312,-.031,.298,.222)*f1_0+\n    mat4(-.194,-.113,-.071,.011,.066,-.047,-.168,.460,.216,-.551,-.328,-.187,.230,.398,-.099,-.165)*f1_1+\n    mat4(.324,.066,-.411,.113,.166,.126,-.045,-.371,.130,.171,-.100,-.172,.172,-.115,-.338,-.367)*f1_2+\n    mat4(.256,-.324,.325,.282,-.135,.635,-.044,-.239,-.109,.188,.426,.143,.307,-.140,-.151,.132)*f1_3+\n    mat4(.355,-.385,-.564,.104,-.089,-.806,.347,.814,.171,.064,.066,-.010,.058,.316,-.556,-.541)*f1_4+\n    mat4(.195,-.010,-.391,.040,-.287,.408,-.265,-.275,-.113,-.162,.056,.280,.020,.318,-.588,.342)*f1_5+\n    mat4(-.165,.441,.096,-.515,-.284,-.073,-.543,-.235,-.350,-.069,-.148,.079,-.268,.011,-.109,.217)*f1_6+\n    mat4(-.580,.267,-.245,.131,.141,-.267,.104,.045,-.310,.008,.305,.435,-.168,-.221,-.091,-.396)*f1_7+\n    vec4(-.496,.022,.468,.253))/1.4+f1_3;\nvec4 f2_4=sin(mat4(-.027,-.082,-.328,-.544,.081,.185,.247,.014,-.036,-.514,.454,-.034,-.354,-.174,.283,-.121)*f1_0+\n    mat4(.239,.038,.500,-.661,-.213,-.073,.020,-.021,.076,.166,-.122,.252,.257,-.482,.012,.251)*f1_1+\n    mat4(.103,-.128,.042,.358,-.291,-.337,-.069,-.009,.250,.034,-.064,.042,1.163,.424,.298,-.188)*f1_2+\n    mat4(.141,.474,-.225,-.339,-.244,-.002,-.061,.164,-.428,-.152,.204,.217,-.144,.717,-.122,.047)*f1_3+\n    mat4(.451,.158,-.005,-.301,.168,.424,-.067,.465,-.006,-.383,-.124,.004,.177,.349,.241,-.206)*f1_4+\n    mat4(-.000,-.166,-.504,-.098,.184,-.221,.076,.321,.056,.099,-.143,-.054,.221,-.104,-.447,-.218)*f1_5+\n    mat4(-.128,-.154,-.062,-.111,.292,.715,-.150,.248,-.079,.068,-.001,-.132,-.188,-.085,.219,.179)*f1_6+\n    mat4(-.191,.153,-.138,.051,-.209,-.311,.362,.707,-.082,.213,.364,-.144,.325,.230,-.103,.217)*f1_7+\n    vec4(-.145,.531,-.336,-.148))/1.4+f1_4;\nvec4 f2_5=sin(mat4(-.011,.017,.240,.144,-.284,.140,.430,-.266,-.477,.006,.528,-.478,.065,.150,.189,.109)*f1_0+\n    mat4(-.295,.245,-.534,-.047,.077,-.107,.021,-.091,.208,-.126,-.683,.128,-.111,-.364,.041,-.274)*f1_1+\n    mat4(.090,.319,-.048,.244,-.319,.372,.413,.001,.060,.518,-.244,.451,-.702,.266,-.422,-.898)*f1_2+\n    mat4(.056,-.308,-.036,-.082,.035,.029,.100,.471,.268,-.127,.507,-.082,.178,-.037,-.037,-.251)*f1_3+\n    mat4(-.229,-.383,-.126,-.137,.626,.689,.032,.111,-.254,-.078,-.010,.324,-.730,-.356,-.231,.007)*f1_4+\n    mat4(.538,.120,.444,-.006,.308,.028,-.315,.119,-.200,.081,-.514,.032,-.174,.429,-.671,.250)*f1_5+\n    mat4(-.036,.103,-.240,-.286,.247,-.145,-.197,.071,-.103,.065,.091,-.386,-.324,.300,.189,-.191)*f1_6+\n    mat4(.024,.068,-.224,.396,.022,.464,-.004,-.074,.095,-.021,.162,.086,-.047,.433,-.507,-.020)*f1_7+\n    vec4(-.024,-.212,-.377,-.069))/1.4+f1_5;\nvec4 f2_6=sin(mat4(.433,.151,-.284,-.368,.602,.280,-.215,.409,.146,-.571,.177,-.153,-.011,-.361,.032,-.073)*f1_0+\n    mat4(.091,.113,-.076,.248,-.247,-.129,-.037,.523,-.551,.239,-.194,-.041,-.232,.163,-.150,.260)*f1_1+\n    mat4(-.192,.537,.002,.099,-.143,-.531,-.137,.227,-.007,.478,.169,.014,.239,.361,.050,1.019)*f1_2+\n    mat4(-.216,-.036,.298,-.035,.811,-.356,.331,.084,.237,-.454,.020,-.074,.705,.062,.024,.156)*f1_3+\n    mat4(-.005,.459,-.471,-.164,-.343,.097,.066,.133,-.047,.675,.324,.423,.069,.112,.043,-.185)*f1_4+\n    mat4(.140,.218,-.495,.041,.224,.247,-.653,.019,-.324,-.078,.012,-.230,-.129,-.355,.077,.111)*f1_5+\n    mat4(.736,-.534,-.021,-.196,-.121,.453,.441,.352,.034,-.544,.239,-.269,.040,-.336,.255,-.575)*f1_6+\n    mat4(.184,-.423,.454,-.178,-.449,.132,-.086,-.175,-.151,-.111,.256,-.251,-.186,-.118,-.102,.009)*f1_7+\n    vec4(-.448,-.296,.761,-.293))/1.4+f1_6;\nvec4 f2_7=sin(mat4(-.211,-.044,-.028,.244,-.096,.195,-.042,-.383,-.366,.464,-.316,-.532,.209,.309,-.248,-.162)*f1_0+\n    mat4(.107,.253,.171,.108,.027,.038,.317,.426,.254,-.168,.045,-.082,.073,-.619,.158,-.001)*f1_1+\n    mat4(.694,.544,-.440,-.389,-.164,-.155,-.006,.044,.029,.305,.004,-.320,-.264,-.218,-.234,.621)*f1_2+\n    mat4(-.062,-.280,.166,.281,-.208,.417,.744,.195,-.449,-.046,.089,-.054,-.398,.248,.400,.037)*f1_3+\n    mat4(.330,-.282,-.093,.217,.116,-.397,-.327,.592,.354,.726,-.392,-.572,-.308,.101,.299,.036)*f1_4+\n    mat4(.225,.124,-.308,-.331,-.092,.399,-.073,-.167,-.147,-.080,.004,.327,.017,.191,.073,.371)*f1_5+\n    mat4(-.433,-.349,.333,.144,.090,-.055,.408,.274,-.269,-.568,.011,.523,-.489,-.409,-.021,.265)*f1_6+\n    mat4(-.021,-.216,.376,.328,-.005,-.413,-.410,-.171,-.053,-.365,-.064,-.061,-.135,.002,.224,.452)*f1_7+\n    vec4(-.241,-.613,.405,.466))/1.4+f1_7;\nvec4 f3_0=sin(mat4(.012,-.133,-.022,-.174,-.255,-.392,.175,-.430,.081,-.713,.255,-.481,.108,.414,-.275,.142)*f2_0+\n    mat4(.533,.035,.458,.485,.038,-.195,.014,.140,-.369,-.075,.519,-.291,-.270,-.126,.253,.421)*f2_1+\n    mat4(-.082,-.421,.027,.150,.160,-.382,-.389,.181,-.209,.033,-.708,.112,-.333,-.228,.393,.012)*f2_2+\n    mat4(.128,.505,-.101,.439,.320,-.068,-.238,.396,.121,-.283,.224,.115,-.211,-.081,.335,-.111)*f2_3+\n    mat4(-.267,.420,.135,.250,-.160,.427,-.312,.472,-.402,-.331,-.083,-.536,.539,-.020,.053,.162)*f2_4+\n    mat4(-.283,-.059,-.283,-.581,.416,-.252,-.035,.435,.139,-.493,-.243,-.059,-.198,.405,-.540,.072)*f2_5+\n    mat4(.511,.062,.191,.175,.176,.290,.011,.244,-.052,.533,-.336,.540,.035,-.054,.384,.096)*f2_6+\n    mat4(-.326,.545,-.388,.423,-.278,-.086,-.083,.218,-.138,.139,-.043,.052,-.080,.269,-.083,.127)*f2_7+\n    vec4(.189,.722,-.300,.631))/1.7+f2_0;\nvec4 f3_1=sin(mat4(.194,.325,.366,.174,.628,-.161,.268,.252,-.245,.026,.169,-.181,.216,.141,-.053,-.689)*f2_0+\n    mat4(-.349,.357,.044,-.040,.222,.263,-.237,-.358,-.230,-.522,.406,.106,.114,-.371,.322,.407)*f2_1+\n    mat4(-.062,-.263,.385,-.158,.024,.364,-.100,-.352,-.332,.216,-.075,.136,.013,-.440,-.109,.209)*f2_2+\n    mat4(.524,-.038,-.351,-.257,-.101,.594,-.508,.190,.294,-.275,-.055,.266,.321,-.183,-.106,.183)*f2_3+\n    mat4(-.449,-.190,.030,.021,.652,-.503,-.185,.513,-.442,.180,.001,-.316,-.340,.265,.086,-.244)*f2_4+\n    mat4(.021,.609,.254,-.180,-.323,.392,-.238,.242,-.089,-.423,.238,.145,-.384,-.025,.195,-.299)*f2_5+\n    mat4(.084,.272,.120,.077,.532,-.072,-.066,.269,.308,-.340,.129,-.459,.099,.265,-.320,-.317)*f2_6+\n    mat4(-.369,.191,-.362,.171,.091,-.208,-.353,-.011,-.265,-.154,.201,.197,-.348,.088,.020,.175)*f2_7+\n    vec4(.568,-.593,-.311,-.308))/1.7+f2_1;\nvec4 f3_2=sin(mat4(-.318,-.026,.024,-.183,-.015,-.301,.094,.133,.358,.078,-.177,-.032,.131,-.060,-.023,-.240)*f2_0+\n    mat4(.487,-.251,-.339,.053,.042,.392,.043,-.258,.088,-.047,-.368,-.144,-.552,.178,.319,-.071)*f2_1+\n    mat4(.528,-.057,.004,-.468,-.295,-.575,-.081,-.001,-.214,-.245,.512,-.040,.208,-.205,-.189,1.385)*f2_2+\n    mat4(-.035,-.558,-.448,-.163,.059,-.183,-.085,.089,.087,-.021,-.024,-.163,-.217,-.011,-.015,.160)*f2_3+\n    mat4(.000,.071,.144,.525,.323,-.745,.367,-.057,.370,-.076,-.043,.324,.175,.031,-.135,.079)*f2_4+\n    mat4(.192,.103,.138,.236,-.133,-.078,.469,.100,-.136,-.238,.104,-.060,.112,.467,.584,-.233)*f2_5+\n    mat4(-.060,.683,-.022,-.127,-.109,-.109,.357,.052,.202,.143,-.054,-.201,-.130,-.344,-.401,.232)*f2_6+\n    mat4(.245,.163,.526,.052,.228,.063,.303,.034,-.268,.180,-.208,.051,.088,.053,.254,.364)*f2_7+\n    vec4(.360,.054,-.362,-.270))/1.7+f2_2;\nvec4 f3_3=sin(mat4(.180,-.321,-.052,-.362,.533,-.482,.234,-.092,-.065,.282,-.041,.083,-.137,-.017,.174,-.202)*f2_0+\n    mat4(-.180,.270,.127,-.088,.117,-.144,-.101,-.003,.239,-.064,.216,-.017,-.330,.355,-.261,.065)*f2_1+\n    mat4(-.531,-.023,.064,.006,.232,.132,-.223,.217,-.379,-.161,-.303,-.148,-.845,-.296,.142,-.013)*f2_2+\n    mat4(.403,-.140,-.167,-.224,-.010,.108,-.199,.448,-.046,.011,.209,.500,.140,-.000,.113,.198)*f2_3+\n    mat4(-.450,-.337,.399,-.699,-.450,-.528,-.081,-.216,-.109,.149,-.235,-.216,-.175,-.004,-.012,-.120)*f2_4+\n    mat4(.259,-.086,.021,-.045,-.042,.059,.041,-.581,.307,.019,-.301,.206,.046,-.446,-.230,-.717)*f2_5+\n    mat4(.136,.490,.410,.240,-.077,-.285,-.241,-.166,-.179,-.078,.266,-.199,-.079,.033,-.762,.032)*f2_6+\n    mat4(-.351,-.469,-.319,-.044,.302,.487,-.388,-.078,-.180,-.094,.443,-.196,.067,-.191,.002,-.437)*f2_7+\n    vec4(.009,.041,.762,.069))/1.7+f2_3;\nvec4 f3_4=sin(mat4(-.207,-.072,.003,.002,.068,-.203,.213,-.018,-.083,-.448,-.264,.020,-.095,-.262,-.802,-.136)*f2_0+\n    mat4(-.187,-.287,-.112,.009,-.148,-.030,.079,-.253,.276,.204,.285,.217,.485,.147,.119,.113)*f2_1+\n    mat4(.135,-.138,.109,-.646,.055,.110,-.386,.153,.154,.410,.340,-.317,.547,-.289,.343,.132)*f2_2+\n    mat4(-.328,-.198,.111,-.107,-.685,-.351,-.037,-.207,.032,-.351,-.100,.225,.142,.216,.176,.142)*f2_3+\n    mat4(.350,.223,.265,-.220,.392,-.208,-.171,.082,.532,.082,-.142,-.802,-.285,-.224,-.240,.127)*f2_4+\n    mat4(.207,.014,.197,-.480,.044,.371,-.089,-.360,-.111,-.021,.290,-.291,-.201,.367,.184,-.345)*f2_5+\n    mat4(-.547,-.130,.061,.489,.233,.080,.516,.022,-.287,-.650,-.581,.378,.309,-.257,.215,.168)*f2_6+\n    mat4(-.362,-.334,.426,.087,.347,-.310,.133,.006,.401,.017,-.394,-.266,.127,-.034,.328,.177)*f2_7+\n    vec4(-.388,-.472,-.506,.460))/1.7+f2_4;\nvec4 f3_5=sin(mat4(.014,.051,-.302,.211,.103,.153,.126,.084,.324,-.533,-.233,.169,-.311,.157,-.253,-.301)*f2_0+\n    mat4(-.418,.233,-.378,.426,.102,.205,.681,.210,.203,.176,-.181,.002,.339,.245,.155,.157)*f2_1+\n    mat4(-.226,-.350,-.438,.473,-.263,-.340,-.029,-.028,.237,.320,.298,-.068,-.088,-.397,.005,.080)*f2_2+\n    mat4(.028,.383,.086,.139,-.140,-.174,-.677,.605,-.467,-.290,-.273,-.259,.163,-.047,.467,-.106)*f2_3+\n    mat4(.123,.143,.073,.024,-.316,.168,.151,-.088,.258,-.422,-.483,.002,-.013,.021,-.438,.653)*f2_4+\n    mat4(.326,-.220,.154,.123,-.051,.057,.210,.401,-.106,-.139,.198,.237,-.669,.077,.058,.629)*f2_5+\n    mat4(-.623,-.219,-.282,-.001,-.002,.301,-.084,-.012,-.452,.294,-.468,-.225,.083,-.316,-.031,-.144)*f2_6+\n    mat4(-.509,.216,.150,.027,-.053,-.539,.589,-.167,.072,-.428,.278,-.243,.058,-.188,.340,-.062)*f2_7+\n    vec4(-.394,.570,-.577,-.111))/1.7+f2_5;\nvec4 f3_6=sin(mat4(-.143,.224,-.136,.106,.098,.055,-.178,.197,.109,-.312,-.042,.544,-.060,-.050,.578,-.191)*f2_0+\n    mat4(.192,-.433,.620,-.018,.247,.021,-.103,-.013,.160,-.318,.015,.337,.032,-.219,.277,-.162)*f2_1+\n    mat4(-.231,.076,.419,-.256,-.036,.200,-.250,.393,.335,-.306,.169,-.442,-.432,-.182,-.105,.122)*f2_2+\n    mat4(.075,.143,-.083,.044,.525,-.299,-.063,-.618,-.362,.159,.127,.314,.802,.106,.273,-.049)*f2_3+\n    mat4(.166,-.453,-.081,.046,-.235,-.116,.274,-.106,-.181,-.573,-.218,-.121,.049,-.339,.472,.245)*f2_4+\n    mat4(-.250,.009,-.740,-.079,.063,.222,-.083,-.067,-.072,.098,-.349,-.096,.249,-.133,-.208,-.254)*f2_5+\n    mat4(.513,.476,-.032,-.301,-.023,.119,-.064,-.159,-.072,-.206,.973,-.158,.041,.008,.061,-.091)*f2_6+\n    mat4(.570,.028,.623,-.370,-.510,-.235,.317,-.120,.101,-.182,.241,.360,.042,-.112,.120,.320)*f2_7+\n    vec4(-.274,-.606,.549,-.168))/1.7+f2_6;\nvec4 f3_7=sin(mat4(-.410,.098,.023,-.120,-.193,-.077,.140,-.510,-.142,-.167,-.084,-.049,.134,-.268,.082,.109)*f2_0+\n    mat4(-.054,-.180,.447,.020,.210,.057,.454,.038,-.018,.481,.034,-.251,-.045,.415,.091,.177)*f2_1+\n    mat4(.589,-.002,-.186,-.175,-.059,-.292,-.063,.058,.408,.214,-.373,.393,-.077,.470,-.013,-.373)*f2_2+\n    mat4(-.157,-.203,-.092,.219,-.331,-.236,-.305,.577,-.485,.212,.056,.111,-.714,.768,.484,.068)*f2_3+\n    mat4(.285,-.004,-.001,.346,.064,.326,.115,-.183,.473,-.325,-.062,-.014,.037,-.199,-.068,.073)*f2_4+\n    mat4(.447,-.153,-.467,-.022,-.206,-.119,.033,-.116,-.033,-.136,-.145,-.264,.146,-.443,-.201,.448)*f2_5+\n    mat4(-.733,-.134,.037,.115,-.091,.172,.194,-.267,-.195,-.166,-.122,.399,-.241,.086,-.044,.065)*f2_6+\n    mat4(-.273,-.532,.084,.031,.194,.391,-.095,.118,-.013,.727,-.716,-.064,-.191,-.203,-.042,-.151)*f2_7+\n    vec4(-.009,.238,.254,.717))/1.7+f2_7;\nvec4 f4_0=sin(mat4(-.199,.182,-.171,-.034,.287,-.038,.206,.198,.294,.284,-.725,.118,.348,.272,-.189,-.606)*f3_0+\n    mat4(-.058,.798,-.185,-.579,-.148,.216,.051,-.352,.329,.199,.066,-.092,.531,-.023,-.154,.283)*f3_1+\n    mat4(-.294,-.023,.016,-.279,.007,.172,.011,-.125,-.463,-.064,.614,.103,-.058,.071,-.070,.582)*f3_2+\n    mat4(-.149,-.090,-.030,-.268,.495,-.050,.121,-.317,-.012,-.364,-.234,-.361,.099,-.294,-.087,.120)*f3_3+\n    mat4(-.113,-.251,-.173,.063,.089,-.370,.380,.367,-.277,.030,-.069,.051,-.335,.471,-.411,.175)*f3_4+\n    mat4(-.201,.026,.451,.271,.005,-.078,.239,-.030,-.236,.534,-.051,.141,-.180,.119,-.078,-.276)*f3_5+\n    mat4(.381,.216,-.176,-.106,-.071,.079,.270,.642,-.239,.212,-.400,-.571,.164,.265,-.548,-.043)*f3_6+\n    mat4(.096,.132,.123,-.251,.240,-.034,.132,-.066,-.307,-.357,-.458,.345,.153,-.091,.212,.302)*f3_7+\n    vec4(-.058,.091,-.847,-.323))/2.0+f3_0;\nvec4 f4_1=sin(mat4(-.126,-.059,.111,-.376,.117,-.327,.098,-.059,-.321,-.254,.052,-.377,.261,-.309,-.035,.140)*f3_0+\n    mat4(.369,-.245,-.119,-.170,-.340,-.130,-.099,.088,.129,-.281,-.187,.265,-.097,.504,-.353,.640)*f3_1+\n    mat4(.450,-.328,-.422,-.093,.162,.297,.015,-.008,.637,-.023,.191,.154,.051,-.474,.099,-.050)*f3_2+\n    mat4(-.170,-.268,-.121,-.044,-.233,.204,-.492,-.381,-.120,-.272,.495,-.433,.096,.269,.701,.183)*f3_3+\n    mat4(-.257,.228,-.395,-.085,.537,.175,-.057,.202,.307,-.271,-.224,.239,-.001,.293,.211,-.498)*f3_4+\n    mat4(-.091,-.195,.134,.339,-.403,-.498,.327,-.140,.018,-.189,.328,-.092,.122,.279,-.172,-.471)*f3_5+\n    mat4(.122,.196,.312,-.101,.170,.392,-.029,.195,.198,-.046,.043,-.128,.130,-.373,-.410,-.008)*f3_6+\n    mat4(.259,-.027,.176,-.290,-.046,-.292,.136,.211,-.277,.090,-.446,.038,.369,-.298,.252,-.056)*f3_7+\n    vec4(-.048,.321,-.036,.284))/2.0+f3_1;\nvec4 f4_2=sin(mat4(.256,.104,-.125,-.001,.279,-.346,.366,-.173,.499,-.347,-.135,.321,.267,-.347,.125,-.016)*f3_0+\n    mat4(.313,-.233,.197,.261,.032,-.273,.009,.113,.155,.103,.154,-.315,-.036,.365,.344,-.173)*f3_1+\n    mat4(.195,-.031,.114,.140,-.203,-.007,.222,-.060,-.233,-.143,.542,.185,.070,-.612,.782,.862)*f3_2+\n    mat4(.096,-.097,-.119,-.117,-.354,-.018,-.087,.183,.326,.332,.056,-.040,-.189,-.480,-.056,.017)*f3_3+\n    mat4(-.171,-.120,.101,.566,-.228,-.299,.001,-.048,-.064,-.408,-.084,.325,.223,.142,.278,.273)*f3_4+\n    mat4(-.444,-.090,-.093,.304,.069,.060,.201,.063,-.139,.075,.162,.041,-.502,-.232,.394,-.024)*f3_5+\n    mat4(-.079,.271,.039,-.020,-.382,.349,-.374,.216,.199,.216,.072,.001,.091,.164,-.546,-.088)*f3_6+\n    mat4(-.118,-.592,.389,-.697,.152,.120,-.063,.133,.389,.212,.063,.059,-.094,-.211,.342,-.075)*f3_7+\n    vec4(.164,.076,-.188,-.326))/2.0+f3_2;\nvec4 f4_3=sin(mat4(-.102,-.005,.172,-.158,-.103,.231,.131,.105,-.195,-.297,-.320,.025,.029,.533,-.215,.047)*f3_0+\n    mat4(-.077,.007,.020,.313,-.025,.012,.088,-.037,-.076,.220,.001,-.142,.300,-.160,.079,.300)*f3_1+\n    mat4(-.410,-.004,-.151,.086,-.199,-.003,.074,-.189,-.377,-.201,-.063,-.151,-.283,.122,-.569,.883)*f3_2+\n    mat4(.024,.330,.114,-.147,.290,-.113,.003,.010,.042,.224,.528,-.316,.002,-.256,.081,.008)*f3_3+\n    mat4(.033,-.225,-.193,.419,-.212,.307,.170,-.337,-.466,-.475,.002,.223,-.367,-.182,-.204,.135)*f3_4+\n    mat4(-.312,.112,.245,-.253,.483,-.219,-.074,-.442,.227,.113,-.399,.245,-.122,-.437,.169,.030)*f3_5+\n    mat4(.408,.031,-.248,.215,.525,-.019,-.259,-.159,.169,.467,.210,.381,.259,.152,-.003,.419)*f3_6+\n    mat4(-.421,-.174,-.257,-.024,.113,-.161,.007,.051,.294,-.056,.013,.149,.417,.127,-.709,-.109)*f3_7+\n    vec4(.026,.230,.123,.030))/2.0+f3_3;\nvec4 f4_4=sin(mat4(.388,-.301,-.089,-.186,-.094,-.390,.305,.292,.561,.182,.296,-.194,.187,.188,-.480,.098)*f3_0+\n    mat4(.183,-.017,.148,-.090,-.139,-.030,.012,.326,.254,-.078,.436,-.045,-.415,.005,-.192,-.084)*f3_1+\n    mat4(.386,.074,-.202,-.014,.248,-.026,.344,-.115,-.337,.013,-.473,-.391,.097,-.570,.221,-.311)*f3_2+\n    mat4(.284,.001,.286,.016,.202,-.255,.116,.229,.134,.085,-.219,.106,-.372,.305,.147,-.405)*f3_3+\n    mat4(.397,-.244,-.166,.087,-.318,-.409,-.142,.268,.216,.188,.273,.203,.358,.266,.296,.117)*f3_4+\n    mat4(.054,-.285,.189,-.366,.018,-.184,-.025,-.127,.204,-.486,-.279,.157,-.260,-.223,-.208,.521)*f3_5+\n    mat4(-.023,.162,.149,-.120,-.135,-.075,.453,-.073,-.170,-.037,-.863,.137,.236,-.086,-.074,.489)*f3_6+\n    mat4(-.531,.247,-.278,-.262,-.179,-.347,.366,.450,.161,-.282,-.448,.756,.117,-.099,-.020,.103)*f3_7+\n    vec4(.536,.191,-1.259,.382))/2.0+f3_4;\nvec4 f4_5=sin(mat4(-.302,-.181,-.350,-.052,-.213,.292,.126,-.116,-.281,-.581,.484,.151,-.014,-.129,.394,-.261)*f3_0+\n    mat4(.078,-.288,.544,.035,-.218,.395,.249,-.112,-.098,-.301,.435,.176,-.010,.212,-.550,-.033)*f3_1+\n    mat4(.099,.279,.454,-.346,-.249,-.117,.505,-.152,.094,.094,-.341,-.036,.349,-.579,-.234,.106)*f3_2+\n    mat4(-.117,.335,-.364,.269,-.085,.123,.427,-.721,-.129,-.203,-.364,-.161,.136,-.631,-.170,-.332)*f3_3+\n    mat4(.214,-.023,-.134,.606,.193,-.020,-.099,-.069,-.198,-.171,.216,-.304,-.395,-.392,.149,.095)*f3_4+\n    mat4(.205,.340,.133,-.018,-.197,.530,.012,.223,.174,-.041,-.404,-.216,-.041,.406,-.132,-.131)*f3_5+\n    mat4(-.098,-.113,.393,.105,.231,.098,-.084,.263,.121,.022,-.165,-.055,.315,-.022,.175,-.078)*f3_6+\n    mat4(.384,-.016,-.373,-.477,-.210,.068,-.195,-.188,-.235,-.124,-.274,-.112,.954,-.160,-.227,.467)*f3_7+\n    vec4(.373,-.441,-.345,-.248))/2.0+f3_5;\nvec4 f4_6=sin(mat4(-.036,-.177,-.004,-.218,.260,-.240,-.071,.297,.308,.116,-.116,.335,-.030,-.270,.427,.445)*f3_0+\n    mat4(-.158,-.129,.317,.008,.177,-.382,-.249,-.083,-.149,.016,.199,-.232,.267,-.124,-.081,-.433)*f3_1+\n    mat4(.173,.260,-.017,.018,.252,-.006,-.101,-.121,.345,.332,.422,-.363,-.727,-.375,.399,.690)*f3_2+\n    mat4(-.412,-.238,.366,.292,-.162,-.054,.342,-.422,-.194,.212,.302,.093,-.260,-.349,-.049,.343)*f3_3+\n    mat4(-.062,.077,.382,.217,-.227,-.118,-.542,-.096,.051,-.345,-.049,.015,-.130,.399,-.010,.044)*f3_4+\n    mat4(.263,-.605,-.029,-.127,.424,-.070,.257,.221,.045,.090,.117,-.263,-.097,.228,.127,-.226)*f3_5+\n    mat4(-.380,-.049,-.395,.380,.217,-.658,.274,-.105,-.569,.356,1.060,-.277,-.317,-.666,-.277,-.259)*f3_6+\n    mat4(-.686,-.040,.058,.308,.493,-.110,-.259,.128,-.354,.359,.226,.247,.011,-.016,.219,.297)*f3_7+\n    vec4(-.362,.536,1.280,.118))/2.0+f3_6;\nvec4 f4_7=sin(mat4(-.129,-.152,-.659,.542,-.200,-.194,.178,.111,.201,.036,.174,-.114,-.065,-.637,-.247,-.305)*f3_0+\n    mat4(-.328,-.055,-.361,.019,.338,-.214,.165,.180,-.520,.210,.284,.122,-.490,-.037,-.259,-.085)*f3_1+\n    mat4(-.278,.155,.513,.128,-.119,.168,.103,.133,-.022,.125,-.391,-.163,-.076,-.296,-.001,-.444)*f3_2+\n    mat4(.351,.369,.311,.134,.933,-.501,-.600,.641,-.162,.008,-.154,.026,.518,-.435,.241,.176)*f3_3+\n    mat4(-.002,-.087,-.097,-.632,-.438,.818,.324,.196,-.039,.260,-.207,-.307,.327,-.129,-.162,-.485)*f3_4+\n    mat4(-.185,.152,.458,.161,-.045,-.134,.097,.315,-.095,-.055,.036,.182,-.265,-.576,-.100,.283)*f3_5+\n    mat4(.263,-.377,-.056,.100,.203,-.130,.246,-.237,-.166,-.238,-.091,-.371,.304,.388,-.066,-.542)*f3_6+\n    mat4(.186,-.343,.094,-.184,-.497,-.036,.010,-.162,.101,.016,-.043,-.193,.159,.037,.328,-.335)*f3_7+\n    vec4(.010,-.133,-.331,-.594))/2.0+f3_7;\nvec4 f5_0=sin(mat4(-.320,-.751,.036,.470,-.251,-.622,.054,.025,-.443,.170,-.410,.564,-.191,.230,-.271,-.133)*f4_0+\n    mat4(.273,.070,-.165,.361,-.096,-.161,.108,.201,.297,-.251,.390,-.171,.347,-.035,.040,-.333)*f4_1+\n    mat4(-.129,.524,-.201,-.013,-.151,-.742,.128,.314,-.177,.029,.624,-.252,.426,.761,.022,-.257)*f4_2+\n    mat4(.218,-.551,.260,.282,-.056,-.321,.054,.162,-.367,.440,-.020,.233,-.171,-.045,.082,-.129)*f4_3+\n    mat4(-.301,.386,-.184,-.259,.267,.123,.041,-.247,.232,-.273,.008,.361,-.168,.035,-.177,.476)*f4_4+\n    mat4(.252,-.203,.488,-.055,.207,-.109,.514,.034,.397,.119,-.030,-.068,-.130,-.128,.102,.245)*f4_5+\n    mat4(.421,.202,-.243,-.105,.736,.090,-.120,-.902,-.069,.618,-.078,-.306,.135,-.038,.021,.478)*f4_6+\n    mat4(-.210,.354,.408,-.068,.370,-.169,-.228,-.220,-.434,.142,.064,.015,.030,.089,.009,-.380)*f4_7+\n    vec4(-.751,1.146,-.492,-.089))/2.2+f4_0;\nvec4 f5_1=sin(mat4(-.154,.402,.533,-.075,.500,-.338,.002,-.326,-.298,.290,.406,.031,.329,.566,-.143,-.379)*f4_0+\n    mat4(.146,.257,-.360,-.394,.321,.069,-.220,-.204,-.370,-.077,.115,.115,.096,-.257,-.102,.262)*f4_1+\n    mat4(.347,.086,-.057,-.254,-.171,-.406,-.180,-.116,.131,-.231,-.410,.619,-.334,.817,-.046,.436)*f4_2+\n    mat4(.325,.373,-.257,-.106,-.266,-.022,.390,.127,-.074,.158,.054,-.051,-.343,.029,-.532,.082)*f4_3+\n    mat4(.604,.254,-.004,.196,.153,-.065,-.253,-.034,-.290,.282,.406,-.384,-.113,.265,.026,-.156)*f4_4+\n    mat4(-.092,-.245,.116,.147,.637,-.515,-.119,.531,.255,.119,.198,.655,.385,-.055,-.296,.240)*f4_5+\n    mat4(-.127,-.456,-.111,.056,.407,-.096,-.027,.010,.077,.384,.064,-.527,-.320,.182,.175,-.198)*f4_6+\n    mat4(-.397,-.178,-.259,.050,.366,-.130,.134,-.251,-.160,.185,.333,-.041,.107,-.034,-.326,.389)*f4_7+\n    vec4(-.784,.504,-.048,-.048))/2.2+f4_1;\nvec4 f5_2=sin(mat4(-.029,-.007,-.118,-.094,-.243,.606,.042,.193,-.280,.047,.519,-.500,.234,.581,-.179,.129)*f4_0+\n    mat4(-.130,-.188,-.322,.365,-.200,-.160,.346,.085,.365,.578,-.102,-.159,.173,-.435,.209,.276)*f4_1+\n    mat4(-.222,.212,-.354,-.213,-.161,.177,-.240,.125,.031,.330,-.476,-.004,-.286,-.074,.331,.333)*f4_2+\n    mat4(-.074,.166,.454,.073,.107,-.128,-.041,-.106,.276,-.314,.418,.201,-.273,.214,.366,.338)*f4_3+\n    mat4(-.204,.232,.314,-.107,-.061,-.220,-.130,.090,.322,.150,-.254,-.146,-.034,.047,-.459,-.412)*f4_4+\n    mat4(.209,-.075,.245,-.519,-.139,-.195,.391,-.117,.121,-.095,.118,.241,.230,.279,-.258,.207)*f4_5+\n    mat4(.069,-.066,.262,-.031,.341,-.274,.216,.164,.070,.468,-.453,.189,.091,-.271,.243,.290)*f4_6+\n    mat4(.345,.107,-.570,.181,-.238,-.343,.242,-.217,.162,.146,-.154,.014,.204,-.039,-.063,-.082)*f4_7+\n    vec4(.859,-.107,-.427,.135))/2.2+f4_2;\nvec4 f5_3=sin(mat4(-.233,-.053,-.178,.106,.478,.130,-.019,.138,-.253,.301,-.117,.339,-.026,-.329,-.209,.100)*f4_0+\n    mat4(.568,-.211,-.128,-.501,-.011,-.752,.213,-.136,-.281,-.357,.246,.277,-.061,.136,-.267,-.039)*f4_1+\n    mat4(.134,.157,.182,.097,.301,-.113,-.196,.330,-.584,.126,-.012,-.092,-.064,.363,-.125,-.470)*f4_2+\n    mat4(.025,.011,.031,.244,-.287,.301,.319,.212,-.074,.277,.577,.254,-.011,-.116,-.036,.283)*f4_3+\n    mat4(.273,.123,-.683,.013,-.067,-.234,-.093,-.243,-.120,-.117,.309,.394,-.138,.063,-.627,.095)*f4_4+\n    mat4(-.013,.182,1.020,-.037,.146,.038,.299,.290,.147,-.050,-.219,-.135,-.031,-.652,-.099,-.059)*f4_5+\n    mat4(.110,.600,-.051,-.011,.318,.023,-.161,-.314,-.120,.035,-.014,-.325,.309,.154,-.271,-.054)*f4_6+\n    mat4(.071,.058,.166,.043,.265,-.575,.137,-.089,-.399,.220,-.023,-.257,.082,.276,.170,-.701)*f4_7+\n    vec4(-.745,-.306,.362,-.948))/2.2+f4_3;\nvec4 f5_4=sin(mat4(-.312,-.253,-.214,.129,-.095,-.202,-.309,.572,-.186,-.267,-.719,.209,-.039,-.099,-.063,-.257)*f4_0+\n    mat4(-.087,.129,-.222,-.479,.345,-.119,-.161,-.034,-.104,-.111,.152,-.194,-.187,.370,.033,.411)*f4_1+\n    mat4(.134,-.395,.220,.035,.315,.039,.204,.203,.338,.080,.423,-.617,-1.139,-.578,-.219,-.897)*f4_2+\n    mat4(.102,.031,-.159,.240,.048,.131,-.115,.263,.328,-.117,-.282,-.214,-.406,-.502,-.578,-.118)*f4_3+\n    mat4(-.518,.205,.180,.166,.058,.038,.205,.057,-.312,-.604,.203,-.128,-.458,.156,.219,.686)*f4_4+\n    mat4(.312,-.610,.546,-.127,.347,.067,.096,-.251,.015,.152,-.350,-.200,.341,.345,-.088,.041)*f4_5+\n    mat4(.090,.249,-.325,.017,.010,.374,-.098,-.096,.244,.622,-.153,-.287,-.450,-.329,-.296,-.090)*f4_6+\n    mat4(.483,.069,.095,-.308,-.226,-.418,.156,-.270,-.012,.307,-.049,.127,.013,.158,-.026,-.153)*f4_7+\n    vec4(.564,.905,.020,-.107))/2.2+f4_4;\nvec4 f5_5=sin(mat4(-.018,.118,-.470,.215,-.241,.275,.590,.502,.478,-.001,-.011,.002,.321,.479,-.286,.001)*f4_0+\n    mat4(.190,.522,.054,.042,.106,-.012,.088,-.492,-.381,.187,-.073,-.777,-.279,-.183,.500,-.236)*f4_1+\n    mat4(.258,.686,.122,-.210,.343,-.036,.061,.289,-.196,-.341,.284,-.155,-.460,.474,.123,.781)*f4_2+\n    mat4(.019,.144,.482,-.055,.454,.111,.161,.240,-.115,.140,.195,-.003,.099,.200,-.415,.150)*f4_3+\n    mat4(.258,.236,-.034,.499,.060,-.125,.545,-.272,.012,.248,-.693,.449,.341,.497,-.239,.555)*f4_4+\n    mat4(-.720,-.148,.423,-.226,-.047,.350,.196,.062,.500,-.219,.040,.112,.181,-.216,-.290,.684)*f4_5+\n    mat4(.168,.176,.296,.074,.207,.135,-.006,.078,.292,-.077,-.056,.032,-.157,.225,.435,-.357)*f4_6+\n    mat4(.402,-.252,-.041,-.292,-.081,.087,.350,.008,.272,-.007,.320,-.412,-.208,.199,.195,.250)*f4_7+\n    vec4(1.036,-.134,-.492,.029))/2.2+f4_5;\nvec4 f5_6=sin(mat4(-.029,-.354,-.100,.375,-.136,-.216,.544,.086,-.060,.021,-.096,.293,-.580,-.243,.476,.116)*f4_0+\n    mat4(.028,-.170,-.071,.179,-.141,.529,-.542,-.226,.351,-.163,.111,.144,.063,-.699,.339,.394)*f4_1+\n    mat4(-.470,-.320,-.137,-.516,-.273,.214,-.114,.172,.218,.137,-.642,.130,.303,-.033,.050,.315)*f4_2+\n    mat4(.092,-.192,.180,.179,-.067,.171,-.073,-.238,-.025,-.506,.118,.194,.229,.319,.218,-.133)*f4_3+\n    mat4(.558,.034,-.101,.345,.422,-.374,.501,-.131,-.352,.536,.031,.219,-.078,-.025,-.373,.134)*f4_4+\n    mat4(-.104,.474,.117,.109,-.255,.007,-.316,.117,.045,.500,.199,.118,.139,-.300,.236,-.572)*f4_5+\n    mat4(.510,-.047,.339,-.257,-.131,.464,-.273,.091,.103,-.336,-.187,-.274,.417,.115,-.243,.410)*f4_6+\n    mat4(.295,.498,.359,-.549,-.013,-.064,.068,-.006,.228,-.337,.210,.283,.018,-.157,.162,-.428)*f4_7+\n    vec4(-.004,-.312,.218,-.162))/2.2+f4_6;\nvec4 f5_7=sin(mat4(-.177,-.160,.237,-.852,-.381,.363,.556,-.085,-.094,.428,-.328,.097,.089,.147,.027,.210)*f4_0+\n    mat4(-.193,.358,.315,.283,.358,.192,.013,.344,.553,-.028,.185,-.052,.752,-.179,-.435,-.553)*f4_1+\n    mat4(-.567,-.146,-.235,-.130,.140,.021,-.216,-.129,-.063,-.406,.247,-.113,-.738,.272,-.093,.465)*f4_2+\n    mat4(.377,.152,-.191,.197,.124,.134,.333,-.599,.225,.003,-.190,.433,-.155,.517,-.229,-.029)*f4_3+\n    mat4(.008,.135,.233,.068,-.104,-.158,-.034,.537,-.593,.144,.032,-.236,-.210,-.121,-.525,-.188)*f4_4+\n    mat4(.177,-.597,-.042,-.224,-.221,-.324,.166,-.101,-.538,.137,-.086,-.313,-.233,-.103,-.143,.366)*f4_5+\n    mat4(.244,.446,.169,-.203,-.050,-.040,-.028,-.318,.544,.112,.559,-.319,-.240,.355,-.546,.074)*f4_6+\n    mat4(-.269,-.485,.257,-.042,.260,-.102,-.314,.027,.100,-.069,.621,-.007,-.114,-.133,.022,.674)*f4_7+\n    vec4(.586,-.230,.184,-.786))/2.2+f4_7;\nvec4 f6_0=sin(mat4(.238,.171,.320,.172,.389,-.494,-.227,.931,.505,.344,-.167,.013,.045,.087,.042,.014)*f5_0+\n    mat4(-.205,.335,-.094,.243,.591,.018,.064,.069,-.165,-.190,.050,-.005,-.669,-.301,-.318,-.110)*f5_1+\n    mat4(.464,.401,.472,.079,.058,-.081,-.054,.571,-.567,-.107,-.365,.245,-.230,.307,.314,.020)*f5_2+\n    mat4(-.352,-.523,-.154,-.182,.060,-.304,.089,-.031,.203,.147,.257,.145,.525,.212,-.008,-.391)*f5_3+\n    mat4(-.338,.867,-.056,-.314,-.461,.350,-.116,-.021,.701,.233,.398,.250,.426,-.128,.359,-.195)*f5_4+\n    mat4(.194,-.176,.312,.218,.005,-.236,.254,.128,.127,.200,.170,.345,-.337,.403,-.058,.236)*f5_5+\n    mat4(.243,-.330,-.554,-.207,.217,-.337,-.279,-.734,-.481,.382,-.099,-.219,.072,.095,-.087,-.274)*f5_6+\n    mat4(.050,-.124,-.209,-.119,-.152,.093,.022,-.371,-.064,.233,-.434,-.563,-.083,.526,-.285,-.324)*f5_7+\n    vec4(-.479,.677,-.415,-.700))/2.4+f5_0;\nvec4 f6_1=sin(mat4(.120,.201,-.556,-.349,.367,.507,-.176,-.637,-.474,.156,-.196,.051,-.024,.082,.467,-.014)*f5_0+\n    mat4(.672,.521,.014,-.005,-.094,.216,.068,-.335,.183,-.349,.451,.278,.220,-.042,.394,-.154)*f5_1+\n    mat4(.448,-.142,-.219,-.129,.036,.509,.618,-.225,-.267,-.516,.472,.283,.155,-.297,-.136,-.326)*f5_2+\n    mat4(.014,-.011,-.174,-.073,-.374,.677,-.072,-1.134,-.596,-.295,-.258,-.009,-.483,.189,-.334,-.244)*f5_3+\n    mat4(.520,.499,.130,-.295,.080,-.173,-.290,.303,-.156,.294,.157,-.469,.256,.695,.147,-.459)*f5_4+\n    mat4(-.843,-.358,-.134,.047,.426,.303,-.501,.057,.385,.293,-.227,.118,.196,.017,-.047,.042)*f5_5+\n    mat4(.319,.146,-.200,.222,-.113,-.102,-.042,-.191,.081,-.378,.479,.223,.083,-.192,-.253,-.526)*f5_6+\n    mat4(.195,.259,-.276,.116,.006,-.277,.067,.408,.101,.072,.439,.042,.191,-.109,-.048,-.201)*f5_7+\n    vec4(-.471,-.395,.634,-.379))/2.4+f5_1;\nvec4 f6_2=sin(mat4(-.164,-.255,-.044,.386,-.204,.178,.204,.501,.141,-.213,-.733,.406,.119,-.240,.005,.516)*f5_0+\n    mat4(-.522,-.272,.083,.489,-.382,-.067,-.328,-.055,.172,.054,.489,-.026,-.299,.651,-.103,.477)*f5_1+\n    mat4(.527,-.055,.479,.333,-.091,-.036,-.380,.494,.194,.090,.366,-.241,-.200,.089,-.396,.238)*f5_2+\n    mat4(.124,-.191,-.133,.530,-.063,.116,.067,.101,-.379,-.061,-.045,-.136,-.159,.439,.050,-.241)*f5_3+\n    mat4(-.158,.098,-.224,-.239,.145,-.134,-.034,-.199,.456,-.034,.310,.506,.070,.603,.056,-.185)*f5_4+\n    mat4(-.037,.032,.349,.355,.163,.090,-.307,.148,-.067,.038,-.018,-.173,-.324,-.030,.044,.221)*f5_5+\n    mat4(-.477,.336,.286,.204,.233,-.496,.045,-.009,-.173,.285,-.005,-.176,-.252,-.340,-.507,.207)*f5_6+\n    mat4(-.318,-.126,.331,-.066,.138,.521,-.074,-.140,-.388,.251,-.262,-.183,-.272,.095,.242,-.139)*f5_7+\n    vec4(-.247,-.342,-.179,-.799))/2.4+f5_2;\nvec4 f6_3=sin(mat4(.329,-.183,.032,.063,.187,-.502,-.444,-.041,.225,-.095,.235,.043,.023,-.596,-.300,.038)*f5_0+\n    mat4(.412,.308,.019,-.156,.378,-.072,-.001,.508,-.026,-.054,.379,-.315,.283,.254,-.218,.064)*f5_1+\n    mat4(.181,.280,.349,-.285,-.015,.228,.361,.129,-.266,-.044,-.058,.007,.137,.825,-.164,.336)*f5_2+\n    mat4(.622,-.233,.088,.112,.158,.417,.291,.013,.206,-.307,-.668,-.608,-.009,-.072,.586,.274)*f5_3+\n    mat4(-.316,.393,.064,.298,.031,.141,.312,.265,-.306,-.557,.688,.037,-.135,.668,.424,-.333)*f5_4+\n    mat4(.088,-.352,-.345,.159,-.009,.074,.215,-.006,.162,.001,-.093,.165,-.295,-.198,.036,.321)*f5_5+\n    mat4(.135,.270,.131,-.399,-.054,.223,-.050,.548,.286,-.083,-.191,-.245,.511,.406,-.069,.100)*f5_6+\n    mat4(-.512,-.104,-.121,-.076,-.332,-.244,.215,.224,-.218,-.065,-.156,.017,-.116,-.025,.102,.480)*f5_7+\n    vec4(.460,.583,-.557,-.438))/2.4+f5_3;\nvec4 f6_4=sin(mat4(.055,.032,.101,-.215,-.142,.286,.324,-.065,.187,.228,.221,-.424,.064,-.242,-.366,.444)*f5_0+\n    mat4(.096,-.257,-.188,-.221,.339,-.114,.028,-.357,-.180,.365,-.108,-.135,-.121,.145,.430,-.512)*f5_1+\n    mat4(-.528,.443,-.596,.420,.236,.125,.158,.432,.340,-.263,-.070,.119,.155,.378,-.027,-.214)*f5_2+\n    mat4(.369,.170,-.063,.258,.557,-.013,-.032,-.434,.445,.614,.060,-.119,-.017,.455,.000,.309)*f5_3+\n    mat4(-.277,-.496,.337,.364,-.123,-.768,.130,.146,-.339,.132,-.209,-.117,.096,-.101,-.193,-.152)*f5_4+\n    mat4(-.021,-.019,-.047,-.083,-.201,.150,.360,-.060,.041,.268,.022,.201,.338,.141,-.501,.475)*f5_5+\n    mat4(.365,.152,.483,-.075,.223,.135,.289,-.169,.187,.046,-.123,.286,.079,.372,.310,-.210)*f5_6+\n    mat4(.055,.418,-.567,.349,-.137,-.148,.068,.055,-.224,-.217,.017,.137,-.273,.044,.064,.481)*f5_7+\n    vec4(.152,-.519,-.578,.358))/2.4+f5_4;\nvec4 f6_5=sin(mat4(-.227,.208,.265,.237,-.365,.345,.318,-.015,.141,.605,.621,-.273,.459,-.010,.588,-.011)*f5_0+\n    mat4(.031,.656,.330,.244,.138,.073,.402,-.078,-.121,-.024,.214,-.035,.110,-.079,-.576,.051)*f5_1+\n    mat4(-.435,.687,.436,-.179,-.052,-.216,.492,.146,.233,-.183,-.284,.229,.367,.247,-.257,.669)*f5_2+\n    mat4(-.028,-.164,-.243,-.414,-.437,-.298,.091,-.098,.144,.371,-.156,.286,.005,-.389,.229,-.026)*f5_3+\n    mat4(-.390,-.150,-.372,-.110,.478,.250,-.207,.531,.020,-.336,.637,.294,.074,.029,.047,-.097)*f5_4+\n    mat4(.014,-.387,.118,-.054,-.222,.257,-.211,-.326,.011,-.096,.192,.251,.284,.193,.259,-.359)*f5_5+\n    mat4(.176,.309,-.059,.358,-.032,-.176,-.331,-.224,.135,.027,-.299,.197,-.093,.262,.001,-.079)*f5_6+\n    mat4(-.116,-.095,-.051,-.214,.034,.361,-.342,-.177,.355,.269,-.373,-.092,.642,.082,-.007,.031)*f5_7+\n    vec4(.691,-.127,-.174,.041))/2.4+f5_5;\nvec4 f6_6=sin(mat4(.170,-.036,.008,-.075,.197,.263,-.119,.365,-.076,.079,-.062,.047,-.110,.394,.177,.202)*f5_0+\n    mat4(.633,.079,.089,-.155,.182,.266,-.400,-.275,.038,-.648,-.391,.155,-.085,-.465,.387,.311)*f5_1+\n    mat4(-.049,-.133,-.112,-.091,.243,.153,-.411,.292,.143,.074,.113,-.204,-.090,-.087,.368,.505)*f5_2+\n    mat4(.413,.231,.375,-.211,.288,-.113,-.360,.120,-.160,.621,.102,-.364,-.117,.290,-.153,.097)*f5_3+\n    mat4(-.190,-.099,.036,-.016,.035,-.728,-.001,-.304,-.445,-.169,.073,-.342,.254,-.032,.178,.297)*f5_4+\n    mat4(.329,.003,-.054,.154,.078,-.055,-.402,-.154,-.259,.370,-.306,.070,-.051,.054,-.343,-.543)*f5_5+\n    mat4(-.531,-.163,.148,.218,.282,-.699,-.574,.531,.489,.200,.965,-.437,.098,-.327,-.612,-.117)*f5_6+\n    mat4(.080,-.050,.237,-.227,.117,-.500,-.058,-.207,.246,.365,.108,.057,-.158,-.085,-.452,.083)*f5_7+\n    vec4(.336,.102,.175,-.189))/2.4+f5_6;\nvec4 f6_7=sin(mat4(.452,.035,.212,.106,.199,-.018,-.131,.005,.088,-.421,-.001,.811,-.272,.211,.124,-.277)*f5_0+\n    mat4(.327,-.275,.316,-.046,-.158,.154,.609,.372,-.152,.203,-.383,-.297,-.158,.048,-.098,-.764)*f5_1+\n    mat4(-.433,.007,.067,.824,.032,.011,.191,.088,.530,-.670,-.348,-.481,-.107,-.067,-.225,-.111)*f5_2+\n    mat4(-.353,.028,.668,.053,-.227,.400,.243,.391,.188,-.100,.057,.118,-.118,.660,.017,.143)*f5_3+\n    mat4(-.644,.199,-.093,-.323,-.100,-.754,-.087,-.170,-.065,.473,-.223,-.018,-.008,.429,-.078,.008)*f5_4+\n    mat4(.019,-.147,-.285,.131,.619,-.063,.107,-.020,.420,-.064,.024,.086,-.896,.083,.137,.083)*f5_5+\n    mat4(.130,.090,.065,-.306,-.253,.083,.212,-.047,-.092,-.258,.311,-.167,.059,-.405,.404,-.324)*f5_6+\n    mat4(.900,-.077,-.414,-.027,.202,-.039,-.054,.138,.166,-.190,-.520,-.230,.039,-.009,-.348,-.396)*f5_7+\n    vec4(-.386,.632,.537,-.371))/2.4+f5_7;\nvec4 f7_0=sin(mat4(.466,.078,-.012,.100,-.158,-.079,.112,.263,.050,-.235,.078,-.425,-.347,.287,-.564,.727)*f6_0+\n    mat4(.182,.306,.207,.277,-.150,.367,-.002,.542,-.182,-.135,-.021,-.402,.462,.074,-.079,-.061)*f6_1+\n    mat4(.012,.297,-.005,-.022,.030,.665,.193,-.260,-.679,-.543,.049,-.154,-.435,-.271,.101,.014)*f6_2+\n    mat4(.359,.300,.219,-.102,.216,-.253,-.269,.090,-.006,.103,.043,.354,-.369,.044,-.134,.339)*f6_3+\n    mat4(.499,.349,-.444,.070,-.324,.188,.370,-.154,.191,.387,-.059,.500,.095,-.127,.160,-.243)*f6_4+\n    mat4(.068,-.228,-.227,.318,-.271,.071,-.078,-.250,.055,-.166,-.055,-.211,-.149,.167,-.029,.099)*f6_5+\n    mat4(.348,.381,-.074,-.169,.337,-.164,.060,-.422,.115,-.099,-.021,.057,.366,-.219,-.271,-.690)*f6_6+\n    mat4(-.322,-.020,.182,.159,-.385,.189,.231,-.208,-.274,-.703,.479,.103,-.722,-.113,.426,-.380)*f6_7+\n    vec4(.654,-.143,-.652,-.491))/2.6+f6_0;\nvec4 f7_1=sin(mat4(-.012,.275,.265,-.140,-.382,.649,.089,.001,-.364,.473,.245,-.463,.169,.366,.060,.288)*f6_0+\n    mat4(.196,-.647,.307,-.037,.544,.173,-.030,.424,.313,-.306,.171,-.028,-.381,-.276,.858,-.521)*f6_1+\n    mat4(-.001,-.165,.290,-.027,-.398,.464,.284,-.086,.165,-.134,-.071,-.245,-.447,-.979,.123,-.645)*f6_2+\n    mat4(.042,-.001,-.118,.222,.485,.193,-.016,.400,.323,.318,-.139,-.497,-.673,-.134,-.296,-.501)*f6_3+\n    mat4(-.538,-.573,-.050,-.100,.154,-.290,-.131,-.268,.204,.254,-.324,-.236,-.310,-.049,.075,-.239)*f6_4+\n    mat4(.686,-.073,.113,.256,-.381,.309,.238,-.066,.132,-.126,-.085,-.188,-.177,-.299,-.650,.003)*f6_5+\n    mat4(.303,-.219,-.016,-.161,.100,.064,-.169,-.378,.028,-.271,.256,.233,.236,-.266,-.185,-.468)*f6_6+\n    mat4(.148,-.045,.243,.226,.153,-.399,-.038,.438,-.242,-.118,.599,.427,.094,-.540,-.815,-.062)*f6_7+\n    vec4(.407,-.477,-.341,.582))/2.6+f6_1;\nvec4 f7_2=sin(mat4(-.009,.123,.123,.208,-.062,.313,-.361,.199,.005,.051,-.119,.340,-.742,.177,.411,-.449)*f6_0+\n    mat4(.139,-.087,.149,-.116,-.214,-.003,-.110,.047,.279,.452,.404,.114,.285,.281,-.246,.621)*f6_1+\n    mat4(-.842,.423,-.287,-.161,.108,.473,.394,-.331,.013,-.041,.508,-.394,.185,-.290,-.020,.511)*f6_2+\n    mat4(.363,-.072,.267,.035,.317,-.035,.371,.023,-.090,-.158,.354,-.336,.269,-.569,.228,-.070)*f6_3+\n    mat4(.011,-.496,.039,.576,.422,-.213,-.086,.507,-.018,-.029,.187,-.202,.303,.313,.307,.428)*f6_4+\n    mat4(-.196,.084,.030,-.421,.376,.338,.218,-.159,-.194,-.474,.343,-.038,.114,.219,.092,-.085)*f6_5+\n    mat4(.200,-.432,.099,.203,.218,-.100,.128,.395,-.543,.043,-.185,.181,.373,.246,-.082,.407)*f6_6+\n    mat4(.007,-.646,.322,-.094,.290,.060,-.301,-.225,.171,.222,-.346,.398,.365,-.030,-.329,.204)*f6_7+\n    vec4(-1.019,.681,.041,-.269))/2.6+f6_2;\nvec4 f7_3=sin(mat4(-.121,.306,-.339,-.063,.190,-.148,-.325,.183,.468,.376,.343,.041,.020,-.169,.013,-.632)*f6_0+\n    mat4(.359,-.177,-.150,-.062,-.498,.013,-.612,.321,-.108,.353,-.116,.090,-.770,-.299,-.347,-.249)*f6_1+\n    mat4(.459,.502,.285,-.131,-.205,-.057,-.170,-.033,.219,-.472,-.463,.278,-.056,.271,-.195,-.128)*f6_2+\n    mat4(-.801,-.126,.268,.073,-.072,-.123,-.285,.448,.358,-.082,.564,-.318,-.430,.104,.192,-.567)*f6_3+\n    mat4(-.366,.097,-.498,-.149,-.066,-.011,-.372,.019,.291,.072,.325,-.184,.002,.126,.427,.072)*f6_4+\n    mat4(-.041,.107,.124,.665,-.021,.029,.594,-.107,-.338,.333,-.222,-.184,-.301,.374,-.327,-.155)*f6_5+\n    mat4(.054,.017,-.010,.131,-.600,-.051,-.316,.467,.160,-.111,.102,-.556,.014,.194,.401,-.044)*f6_6+\n    mat4(.275,-.636,.374,.184,.223,.567,-.007,.047,-.275,-.200,-.552,-.155,.139,.242,-.050,.499)*f6_7+\n    vec4(.311,-.705,.485,-.359))/2.6+f6_3;\nvec4 f7_4=sin(mat4(-.140,.192,-.138,.128,-.102,-.395,.325,.420,-.018,.023,-.140,-.052,-.429,.352,.693,-.070)*f6_0+\n    mat4(.193,-.396,.256,.404,-.475,-.032,.346,.497,-.274,-.011,-.079,-.394,.539,.213,-.330,-.241)*f6_1+\n    mat4(.262,-.308,-.214,.231,-.195,-.003,-.095,.072,-.127,.112,.053,-.517,.161,.212,.338,-.315)*f6_2+\n    mat4(-.771,.030,.450,.178,-.191,-.130,-.267,.005,-.036,.179,.146,-.231,.494,.121,.115,.116)*f6_3+\n    mat4(.180,.309,-.371,.998,.148,.254,-.144,.121,.167,.046,-.188,.131,.515,-.318,.190,.274)*f6_4+\n    mat4(-.321,-.055,.627,.045,.272,-.359,.235,-.170,-.186,.117,-.350,-.143,.274,.276,.096,.273)*f6_5+\n    mat4(.028,.001,.370,.082,-.107,.039,-.310,-.110,.053,-.495,.270,-.193,-.407,.450,-.120,-.157)*f6_6+\n    mat4(.423,.059,.361,-.289,.349,-.293,-.170,-.523,.329,.191,.283,-.439,.134,.224,.152,-.020)*f6_7+\n    vec4(.178,.286,-.108,.365))/2.6+f6_4;\nvec4 f7_5=sin(mat4(-.275,.521,-.786,-.225,-.056,.427,-.250,.161,-.261,-.250,-.519,.126,.595,.145,.504,.045)*f6_0+\n    mat4(-.212,-.315,.540,-.023,.266,-.133,-.317,-.283,-.397,.121,.499,-.482,-.231,.121,.061,.201)*f6_1+\n    mat4(-.206,-.500,.220,.038,-.134,.727,-.443,-.231,-.037,.284,.141,.192,-.292,-.326,.414,.361)*f6_2+\n    mat4(-.373,.288,-.284,.122,.110,-.166,-.046,.054,.136,.084,-.154,.163,.531,.180,-.040,.295)*f6_3+\n    mat4(.077,-.017,.290,-.306,.044,-.380,.137,.199,.327,-.390,.270,.202,-.229,-.218,.232,.128)*f6_4+\n    mat4(-.507,.433,-.094,.023,-.178,-.069,-.044,.182,.311,-.142,-.308,-.293,.011,.444,.020,-.684)*f6_5+\n    mat4(-.222,.513,-.676,-.104,-.330,-.062,-.122,-.297,.223,-.023,.347,.125,-.146,-.030,-.431,-.487)*f6_6+\n    mat4(.140,-.251,.024,-.126,.115,-.568,.268,-.111,.438,.053,.017,-.281,-.254,-.088,.519,.080)*f6_7+\n    vec4(.659,.325,.992,-.310))/2.6+f6_5;\nvec4 f7_6=sin(mat4(.279,.281,-.120,-.119,-.008,.391,-.008,.016,-.036,-.308,-.068,.621,-.315,.023,.936,-.113)*f6_0+\n    mat4(-.432,.374,.307,.107,-.088,.330,.184,-.375,.385,.322,.284,.291,.521,.378,-.049,.404)*f6_1+\n    mat4(-.503,.659,-.011,-.065,-.197,.185,-.151,.343,.089,-.341,.078,-.076,-.373,.047,-.809,.438)*f6_2+\n    mat4(.005,-.174,.357,.462,.406,.071,-.049,-.041,-.351,-.749,-.473,.248,-.199,-.132,.133,.168)*f6_3+\n    mat4(-.286,.562,.561,-.105,-.324,-.403,.276,-.215,.279,.494,.125,-.101,.354,.596,.012,-.029)*f6_4+\n    mat4(-.174,-.305,-.331,-.254,.059,-.042,-.205,-.054,.218,.214,.117,-.024,.287,.061,.062,-.443)*f6_5+\n    mat4(.254,-.135,.087,.263,.347,-.395,.273,.189,-.309,.073,.159,.484,.265,.222,-.059,.112)*f6_6+\n    mat4(.203,.078,-.207,.569,-.332,.016,-.075,.117,.190,.017,-.158,.221,-.027,-.399,.186,.007)*f6_7+\n    vec4(.237,-.058,1.153,-.035))/2.6+f6_6;\nvec4 f7_7=sin(mat4(.272,-.513,.175,.510,.468,-.414,.150,.302,-.246,.078,.078,-.442,.273,-.038,-.410,-.195)*f6_0+\n    mat4(-.037,-.128,-.114,-.164,-.082,-.164,.167,.368,.263,.327,-.190,-.107,.280,-.553,-.105,-.046)*f6_1+\n    mat4(-.269,.072,.292,.395,-.129,-.404,-.322,-.113,.357,.042,-.018,-.121,-.018,.089,.110,-.512)*f6_2+\n    mat4(-.072,-.219,.482,.119,.112,.325,-.189,.445,.215,.238,.267,.030,.017,-.368,.313,.018)*f6_3+\n    mat4(.071,-.236,-.065,-.499,.339,-.086,-.480,-.406,.228,-.059,-.166,.072,-.228,.033,-.224,-.354)*f6_4+\n    mat4(-.536,.203,.504,.036,.387,.377,-.046,.286,.296,-.062,.487,.062,-.225,.265,.417,-.242)*f6_5+\n    mat4(.040,.409,-.240,.130,.126,.045,.092,.125,.247,-.287,.047,-.274,-.018,.380,-.371,-.254)*f6_6+\n    mat4(.764,.120,-.211,.102,-.003,-.174,-.299,-.007,.145,.209,.260,-.382,.111,.688,-.487,-.955)*f6_7+\n    vec4(-.317,-.500,-.796,.091))/2.6+f6_7;\nvec4 f8_0=sin(mat4(-.971,.247,-.030,.008,-.802,.939,.352,.607,-.154,-.309,.866,-.196,.637,.322,-.105,.785)*f7_0+\n    mat4(-.073,.292,-.075,.104,.021,-.251,-.217,-.170,-.534,-.123,-.004,-.201,-.159,.501,.140,.248)*f7_1+\n    mat4(.154,.057,.536,-.084,-.050,-.027,-.363,-.305,.065,-.126,.273,-.150,-.031,-.029,-.190,-.346)*f7_2+\n    mat4(.054,-.084,-.252,-.129,-.391,-.147,.316,-.024,.383,-.277,.028,-.016,-.072,.115,.523,-.259)*f7_3+\n    mat4(.114,.285,.297,.142,-.245,-.071,-.720,.036,-.311,.236,.066,-.205,-.009,.083,.035,-.149)*f7_4+\n    mat4(-.100,-.313,-.310,.210,-.428,.089,.308,.199,.352,.534,-.091,.273,.195,.083,-.203,.051)*f7_5+\n    mat4(.110,.198,-.312,-.174,-.596,.051,-.277,-.473,.492,-.332,.058,-.281,-.085,.082,.156,-.469)*f7_6+\n    mat4(.062,.357,-.673,-.485,.025,.038,.015,-.725,.142,-.069,-.126,.357,.384,.087,.020,.031)*f7_7+\n    vec4(.865,-.242,-.130,-.980))/2.8+f7_0;\nvec4 f8_1=sin(mat4(-.014,.310,-.251,-.474,.186,.112,-.204,.064,-.215,-.123,.172,-.190,.355,-.113,.096,.602)*f7_0+\n    mat4(.616,.605,-.096,-.453,-.013,.379,-.288,.149,.187,.355,-.431,-.105,.211,-.171,-.146,-.832)*f7_1+\n    mat4(.170,-.017,.039,-.001,.220,.026,-.080,-.168,-.385,-.184,-.170,.100,.119,-.287,.444,-.183)*f7_2+\n    mat4(.198,.109,-.029,.529,-.116,.128,-.190,.067,-.060,.226,.152,-.039,.123,-.325,-.329,-.094)*f7_3+\n    mat4(.329,-.136,-.380,-.378,.317,.084,-.086,-.093,.366,.310,.026,-.648,.389,-.074,.175,-.288)*f7_4+\n    mat4(-.575,-.016,.550,-.176,-.424,.594,.470,-.340,-.114,.489,-.361,-.096,.319,-.220,.035,-.342)*f7_5+\n    mat4(-.047,.403,.243,-.206,-.672,.133,-.495,-.444,.373,-.396,-.115,.684,.216,-.142,.143,-.653)*f7_6+\n    mat4(-.079,.728,-.219,.084,.273,.171,.080,-.078,.061,-.086,-.267,-.065,-.196,-.354,-.022,-.118)*f7_7+\n    vec4(.224,-.068,-.159,.330))/2.8+f7_1;\nvec4 f8_2=sin(mat4(.277,.067,.117,-.159,.146,-.129,-.387,-.359,-.058,-.252,-.114,-.128,-.320,.057,.374,-.128)*f7_0+\n    mat4(.093,.534,.466,-.084,.276,-.080,.027,.197,-.155,-.124,.260,-.322,.451,.726,.052,-.220)*f7_1+\n    mat4(-.022,-.410,.013,.004,-.030,.582,-.024,-.567,.009,-.618,.644,-.435,.090,.170,-.314,-.188)*f7_2+\n    mat4(-.091,.239,.603,.296,-.286,-.152,.145,-.255,-.317,.505,.156,.576,-.208,-.439,-.131,.197)*f7_3+\n    mat4(.467,-.011,.000,-.624,.131,.367,.083,-.478,.080,-.791,.561,-.054,.119,.089,-.275,-.411)*f7_4+\n    mat4(-.431,.072,-.288,.016,-.058,-.194,.038,.166,.496,-.160,-.230,.199,.269,-.422,.035,-.153)*f7_5+\n    mat4(.064,.017,.153,.112,-.443,-.093,.226,-.160,-.309,.546,.519,.222,-.156,.200,.299,.395)*f7_6+\n    mat4(.485,-.307,.935,.143,.031,.011,.129,.699,.070,.197,.077,.010,-.451,.146,.098,-.130)*f7_7+\n    vec4(.071,-.163,.120,.095))/2.8+f7_2;\nvec4 f8_3=sin(mat4(-.260,.072,.248,.031,.194,-.335,.001,-.135,.438,-.341,.324,.134,-.079,.592,.014,.142)*f7_0+\n    mat4(-.047,.328,-.087,.127,.101,.239,.070,-.073,.113,-.435,.086,-.370,-.197,-.377,.294,.840)*f7_1+\n    mat4(.245,-.083,.393,.056,-.222,-.359,-.308,-.025,-.363,.023,-.727,-.034,-.302,-.191,-.019,-.212)*f7_2+\n    mat4(.820,.553,.185,-.083,.260,-.028,-.249,-.254,.014,.151,.024,.503,.004,-.187,.167,.935)*f7_3+\n    mat4(-.009,-.268,.206,-.389,-.174,-.093,-.004,-.360,-.380,.063,-.324,-.210,.145,.376,.253,-.421)*f7_4+\n    mat4(-.246,.064,.240,-.221,.622,.050,.276,.007,.162,.202,-.414,-.122,.329,.158,.097,-.380)*f7_5+\n    mat4(.096,.473,-.473,.076,-.005,.071,.543,-.043,.099,-.270,.154,-.246,-.234,-.077,-.079,.061)*f7_6+\n    mat4(.228,.055,-.074,.292,-.306,-.554,.289,.081,.137,-.360,.091,-.343,-.123,.273,-.326,-.474)*f7_7+\n    vec4(-.752,-.414,.076,-.173))/2.8+f7_3;\nvec4 f8_4=sin(mat4(.069,.008,-.382,-.506,.110,.103,.075,-.201,.182,.352,-.306,-.389,.459,-.173,.727,.131)*f7_0+\n    mat4(-.036,.127,.079,-.333,-.132,.279,.156,-.185,-.013,.090,-.392,-.225,.163,.299,-.084,.277)*f7_1+\n    mat4(.411,-.233,-.429,-.102,-.278,.574,-.213,-.046,-.353,.594,-.350,-.173,-.070,.265,-.578,-.035)*f7_2+\n    mat4(.339,-.331,.054,.369,-.305,.037,.006,-.305,.035,-.065,.592,.373,-.189,-.146,.312,.443)*f7_3+\n    mat4(-.745,.388,.053,.093,-.596,-.563,-.100,.085,.019,.463,-.500,-.259,-.079,-.106,-.156,.039)*f7_4+\n    mat4(-.397,.165,-.102,.314,-.179,.309,-.060,-.473,.084,.135,.196,-.178,.051,.393,.239,-.152)*f7_5+\n    mat4(-.329,-.457,-.120,-.227,.103,-.616,-.126,.148,.383,-.796,.255,.312,.107,.257,.076,-.485)*f7_6+\n    mat4(-.659,-.120,-.342,-.065,.313,-.102,-.565,-.377,.354,-.049,.093,.079,.110,-.161,-.083,-.043)*f7_7+\n    vec4(.347,-1.215,.526,.307))/2.8+f7_4;\nvec4 f8_5=sin(mat4(-.029,.209,-.265,-.227,.217,.087,-.576,-.445,.079,.064,-.061,-.102,-.256,.193,-.137,-.116)*f7_0+\n    mat4(-.177,.069,-.195,.226,-.513,.405,-.036,-.362,.333,.217,-.654,-.194,.076,-.378,.132,.136)*f7_1+\n    mat4(-.204,-.036,-.175,.195,.022,.032,-.030,.032,.132,-.122,.312,.548,.048,.449,.417,.354)*f7_2+\n    mat4(.140,.024,-.150,.364,.040,.106,.471,-.537,-.013,.095,.568,-.028,.482,-.226,-.214,.042)*f7_3+\n    mat4(-.771,.048,-.018,-.004,.224,.146,.234,-.053,-.664,.264,.193,-.243,-.342,-.073,-.231,.195)*f7_4+\n    mat4(.260,-.081,.088,.086,.070,1.017,-.180,-.486,.402,.430,.109,.016,-.473,-.201,-.266,-.299)*f7_5+\n    mat4(-.065,.064,-.296,-.275,.111,.398,.741,-.381,.145,.071,-.090,-.187,-.090,-.351,.132,-.565)*f7_6+\n    mat4(.589,.500,-.082,-.113,-.268,.420,.264,.115,.147,.285,-.061,-.151,.325,-.349,.353,.138)*f7_7+\n    vec4(-.584,.190,-.135,-.057))/2.8+f7_5;\nvec4 f8_6=sin(mat4(-.219,-.648,-.254,.226,.087,-.649,-.450,.376,-.452,.381,-.136,-.287,.207,.166,.237,.480)*f7_0+\n    mat4(.009,-.361,.376,.027,-.037,-.181,-.054,.287,-.065,.338,.022,-.176,-.272,-.034,-.111,-.632)*f7_1+\n    mat4(.316,.187,-.170,.455,-.497,-.417,.420,-.084,-.544,-.238,.163,-.654,.864,-.122,.097,-.593)*f7_2+\n    mat4(-.184,-.253,-.081,-.295,-.035,.130,-.150,.082,.126,.345,.209,.094,.337,-.079,-.369,-1.016)*f7_3+\n    mat4(.232,-.220,.112,-.344,-.180,-.035,.805,.265,-.227,-.322,-.117,-.063,-.147,-.560,.197,-.223)*f7_4+\n    mat4(-.139,.487,.307,.521,-.457,.329,-.342,-.280,.066,-.390,-.005,-.060,-.489,.016,-.246,.220)*f7_5+\n    mat4(-.385,-.237,.133,-.260,.079,.497,.248,-.344,.767,.076,.642,.060,-.098,-.395,-.160,.002)*f7_6+\n    mat4(.007,.120,-.068,-.414,.263,-.014,.199,.033,-.040,.080,-.265,-.123,.253,.238,.166,-.057)*f7_7+\n    vec4(.483,-.021,.084,1.050))/2.8+f7_6;\nvec4 f8_7=sin(mat4(.274,-.297,-.029,.232,.268,-.319,.103,-.035,.097,-.064,.644,-.566,.094,.166,-.113,-.048)*f7_0+\n    mat4(.211,.302,-.053,.644,-.427,.131,-.100,.248,.212,-.277,.135,-.118,.669,-.794,-.379,-.429)*f7_1+\n    mat4(-.208,.247,-.144,.683,.198,-.382,-.155,.441,-.004,-.625,.354,-.038,-.435,.121,-.163,-.481)*f7_2+\n    mat4(.452,.142,-.261,-.371,-.272,-.070,-.234,.554,.390,-.252,-.194,-.438,.133,-.061,.081,-.099)*f7_3+\n    mat4(-.468,.492,-.019,-.210,.320,.359,-.405,-.042,-.113,-.114,.030,.510,-.666,.313,.403,.491)*f7_4+\n    mat4(.007,-.125,-.554,-.146,.162,.504,-.366,-.197,.127,-.180,.188,-.251,-.480,-.431,-.070,.489)*f7_5+\n    mat4(.394,.157,-.297,-.073,.172,.671,.077,-.309,-.400,.374,-.339,.180,.379,-.388,-.280,-.388)*f7_6+\n    mat4(.209,.152,-.044,-.109,.005,.189,.014,-.443,.077,-.178,-.399,-.180,.073,.065,.100,-.342)*f7_7+\n    vec4(-.344,-.351,.144,.460))/2.8+f7_7;\nvec4 f9_0=sin(mat4(.121,.641,-.562,.145,.391,.978,-.121,.793,.266,-.298,-.394,-.397,.106,-.078,-.133,.789)*f8_0+\n    mat4(-.410,.101,-.228,-.409,.345,-.096,-.562,.498,.023,-.063,.336,-.483,.257,-.011,-.280,.000)*f8_1+\n    mat4(.126,.329,.144,-.240,-.230,-.023,-.087,-.112,-.408,-.122,-.246,-.401,-.297,-.214,-.103,-.169)*f8_2+\n    mat4(-.084,-.041,-.400,-.615,-.443,.804,-.325,-.173,.194,-.236,.128,-.059,.233,.116,.132,.094)*f8_3+\n    mat4(.124,-.024,.254,.446,-.197,.176,-.554,.281,.177,-.101,.184,.034,-.545,.399,.080,-.136)*f8_4+\n    mat4(-.046,-.549,-.013,-.257,.469,-.136,-.519,-.478,.436,.124,-.099,-.194,-.181,.174,.600,.110)*f8_5+\n    mat4(.100,-.437,.015,-.207,-.183,-.490,-.093,-.152,.026,.146,.159,-.181,.292,-.342,-.225,-.048)*f8_6+\n    mat4(-.315,.047,.261,-.232,.162,.308,-.405,-.146,-.020,.202,.272,.484,-.506,-.404,.580,.137)*f8_7+\n    vec4(.243,-1.217,.136,-.438))/3.0+f8_0;\nvec4 f9_1=sin(mat4(-.203,.054,-.005,.057,.401,-.472,.452,-.154,-.615,-.593,.155,-.006,-.016,.156,.381,-.123)*f8_0+\n    mat4(.507,.032,.511,-.055,-.199,.035,.462,-.102,.303,-.488,.064,.321,-.008,.122,.441,.364)*f8_1+\n    mat4(-.135,-.344,.700,.398,.274,-.387,.285,.338,-.210,.748,-.374,.042,.228,.401,.103,.060)*f8_2+\n    mat4(.543,.092,.513,.420,-.396,.066,.248,.432,-.110,-.294,-.474,.263,-.344,.161,.063,1.032)*f8_3+\n    mat4(.595,.513,.462,-.207,.354,-.082,.040,.239,-.355,-.047,.558,-.113,.532,.357,.198,-.284)*f8_4+\n    mat4(-.152,.120,-.204,-.055,.532,.729,.517,-.311,-.344,.046,.077,.260,.184,-.052,-.277,.200)*f8_5+\n    mat4(-.341,.243,-.112,-.033,-.397,.676,-.309,.242,.137,.321,-.445,.100,-.557,-.332,-.089,-.439)*f8_6+\n    mat4(-.458,.559,-.198,.036,-.072,-.694,.118,.157,.125,.217,-.547,-.471,.510,.050,-.571,-.280)*f8_7+\n    vec4(.324,.489,-.847,-.939))/3.0+f8_1;\nvec4 f9_2=sin(mat4(-.036,-.017,.228,.141,.233,-.399,-.283,-.330,-.165,.013,-.088,.413,-.074,-.547,.044,-.110)*f8_0+\n    mat4(.199,-.242,-.189,.079,.223,-.285,.359,.378,-.243,-.073,.167,-.074,-.070,.200,-.504,-.132)*f8_1+\n    mat4(-.355,-.512,-.264,.453,.297,.211,.332,-.142,-.284,-.168,-.639,.212,.289,-.023,-.237,-.605)*f8_2+\n    mat4(.154,.335,-.074,.203,.293,.261,-.043,-.153,.029,.094,-.261,-.270,.193,.114,.006,-.455)*f8_3+\n    mat4(.184,-.007,.411,-.076,.346,.031,.304,.004,.439,-.145,.245,.320,.180,.323,.010,-.666)*f8_4+\n    mat4(-.127,-.005,-.222,.611,.099,-.690,-.185,.670,.112,-.496,.360,.132,-.224,.206,.383,-.158)*f8_5+\n    mat4(-.223,.236,.063,-.129,.182,.378,.201,.590,.237,.027,-.197,-.521,-.236,-.144,.065,-.563)*f8_6+\n    mat4(-.039,-.691,.139,-.168,.312,-.030,.354,.204,-.203,.175,-.336,.210,.122,.028,-.281,-.827)*f8_7+\n    vec4(.625,.334,.122,-1.340))/3.0+f8_2;\nvec4 f9_3=sin(mat4(.411,-.111,-.351,.029,.067,.005,-.028,.072,.664,.375,-.100,.261,-.328,.231,.099,-.236)*f8_0+\n    mat4(-.363,-.050,-.027,.035,.264,.866,-.003,-.373,.003,.219,.709,.733,.108,-.290,.170,.686)*f8_1+\n    mat4(.111,.245,.136,-.060,-.171,-.100,-.513,.012,-.193,-.269,-.275,-.258,.733,.045,-.329,-.027)*f8_2+\n    mat4(-.323,-.304,.167,-.088,.265,-.071,-.340,.550,-.122,-.128,.177,-.042,.529,.592,-.421,.494)*f8_3+\n    mat4(-.020,.376,.250,.262,-.722,-.215,.044,-.216,.405,.012,.070,.376,.196,-.395,-.310,.093)*f8_4+\n    mat4(-.231,-.073,.708,-.494,.129,.057,-.490,.605,.532,-.142,.901,-.071,-.280,.598,.011,-.463)*f8_5+\n    mat4(.469,.223,-.180,.321,.293,-.305,.440,.011,-.877,-.531,-.283,.085,.190,.723,.162,.205)*f8_6+\n    mat4(-.048,.080,-.012,.250,.272,-.092,-.447,.084,-.076,.016,-.018,.017,-.069,.275,.170,-.682)*f8_7+\n    vec4(-.897,-.324,1.221,.178))/3.0+f8_3;\nvec4 f9_4=sin(mat4(-.138,.180,.339,-.013,.217,-.417,.003,.020,.038,-.484,.368,.494,.249,.218,.144,-.809)*f8_0+\n    mat4(.280,.603,-.174,.276,.174,-.427,-.532,-.127,-.425,.066,-.091,.129,.217,.082,-.206,.048)*f8_1+\n    mat4(.028,-.005,.080,-.303,-.407,.268,-.161,.310,-.678,-.036,.239,-.091,-.145,-.010,.034,.780)*f8_2+\n    mat4(.240,-.611,-.196,.284,-.154,-.119,.169,-.133,.070,-.262,.075,.083,.103,-.378,-.033,.236)*f8_3+\n    mat4(-.266,.885,-.111,-.007,.237,.832,-.165,.349,-.628,-.057,.356,-.590,.094,.188,-.159,-.242)*f8_4+\n    mat4(.079,.081,.302,-.119,-.165,.051,.098,.498,-.530,-.496,.062,.319,.144,-.045,-.042,.193)*f8_5+\n    mat4(.060,-.780,.238,.354,-.304,-.266,.723,.357,-.008,.210,.118,.190,.291,-.467,-.065,.701)*f8_6+\n    mat4(-.145,-.210,-.146,.383,-.382,-.311,-.078,-.127,.463,.148,.066,.286,-.015,.188,-.313,.258)*f8_7+\n    vec4(1.560,.981,-.778,-1.180))/3.0+f8_4;\nvec4 f9_5=sin(mat4(-.256,-.570,.432,-.537,-.012,-.421,.651,-.271,.010,-.188,.258,-.167,-.612,.371,.367,.063)*f8_0+\n    mat4(-.298,-.029,.558,.545,-.340,-.346,.147,-.243,.260,-.139,.151,.101,-.400,-.114,-.433,-.035)*f8_1+\n    mat4(.069,-.488,.668,.596,.165,.146,-.221,.002,-.065,-.526,-.416,.304,.142,-.026,.488,.621)*f8_2+\n    mat4(.093,-.032,.128,-.049,.360,-.376,.422,.035,-.189,.096,-.544,-.037,-.146,.164,.106,-.032)*f8_3+\n    mat4(.103,.175,-.010,.271,-.210,.038,-.238,-.291,.001,.151,.289,-.132,.167,.120,.532,.473)*f8_4+\n    mat4(.378,-.523,-.555,-.292,-.073,-1.125,-.330,.487,-.432,-.592,.382,.244,-.124,-.068,-.123,-.196)*f8_5+\n    mat4(.145,-.366,-.078,-.176,.469,-.559,-.384,.203,.045,.562,.318,.067,.153,-.017,-.374,-.159)*f8_6+\n    mat4(-.364,-.347,.048,.044,.481,-.241,-.224,-.025,-.288,.050,.485,-.163,-.359,.312,-.275,.225)*f8_7+\n    vec4(.695,.954,-.440,-.240))/3.0+f8_5;\nvec4 f9_6=sin(mat4(-.177,.140,.290,.369,-.074,-.516,-.091,-.435,.332,-.421,-.514,-.363,-.259,-.311,-.033,.358)*f8_0+\n    mat4(-.108,-.547,.521,-.121,.193,.022,.022,.366,.536,.256,.181,-.300,.154,.445,-.119,-.097)*f8_1+\n    mat4(-.142,-.662,.181,-.159,-.265,.433,.375,.294,-.029,.026,.283,-.173,.340,-.379,-.230,-.173)*f8_2+\n    mat4(.044,-.097,.012,-.234,-.164,.470,-.408,.200,.254,.480,-.354,-.369,.331,-.530,-.766,.430)*f8_3+\n    mat4(.214,-.272,-.138,-.045,-.328,.258,.332,.046,-.022,.055,-.218,-.086,-.465,-.006,.205,.532)*f8_4+\n    mat4(-.277,.130,.121,.020,.468,.135,-.255,-1.071,.257,.055,-.151,-.090,-.406,-.366,.541,.282)*f8_5+\n    mat4(.717,.786,.414,.245,-.068,.999,-.303,-.405,-.282,.283,-.060,.333,.460,.003,-.210,-.538)*f8_6+\n    mat4(-.002,.091,.074,-.615,.958,.058,-.699,-.314,-.492,-.119,.384,-.017,.236,-.153,.338,.016)*f8_7+\n    vec4(-.559,.481,1.126,.476))/3.0+f8_6;\nvec4 f9_7=sin(mat4(.737,-.504,.517,-.338,.256,-.101,-.522,-.190,-.356,-.148,-.134,-.907,.143,.053,.080,-.068)*f8_0+\n    mat4(.184,.024,-.353,.460,-.079,-.115,.421,.181,-.148,-.462,-.202,.101,-.064,.015,-.345,.115)*f8_1+\n    mat4(.193,.184,.068,-.667,-.105,-.932,.024,-.170,.024,-.212,.201,.245,.430,.247,-.234,.112)*f8_2+\n    mat4(-.017,.355,-.561,-.074,.541,-.076,.064,-.208,.183,.002,.091,-.524,.196,.360,-.569,-.159)*f8_3+\n    mat4(.245,-.193,-.195,.234,.230,-.359,.309,-.124,.342,-.447,.418,.064,.129,-.075,.008,.386)*f8_4+\n    mat4(.362,.196,-.201,-.255,.751,.477,-.254,-.744,-.038,-.410,.154,-.007,-.530,-.359,.082,.377)*f8_5+\n    mat4(-.258,-.174,.026,-.235,.504,-.051,-.027,-.218,.034,-.136,-.023,.019,.088,-.404,.182,-.079)*f8_6+\n    mat4(.585,-.519,.340,-.392,-.125,-.109,.479,-.546,-.360,-.125,-.305,.043,-.077,-.066,-.255,.888)*f8_7+\n    vec4(.457,.650,.302,.156))/3.0+f8_7;\nvec4 f10_0=sin(mat4(.572,-.444,-.711,.279,.784,-.580,-.773,.096,-.018,-.174,-.049,.123,-.040,.092,-.248,.261)*f9_0+\n    mat4(-.259,-.576,-.387,-.045,.322,.071,-.213,.496,-.275,.159,.093,-.098,-.394,-.144,.227,-.495)*f9_1+\n    mat4(-.252,-.252,-.181,.141,.093,-.044,-.047,-.286,-.089,.330,.056,-.287,.264,-.715,.280,.835)*f9_2+\n    mat4(-.154,-.272,-.055,-.207,.292,-.088,.866,.027,.420,.096,-.016,-.649,.011,-.543,.146,-.107)*f9_3+\n    mat4(.281,.341,.246,.433,.090,.149,-.241,-.274,.082,-.099,.027,-.352,-.330,-.438,-.128,-.040)*f9_4+\n    mat4(-.000,.200,.053,.040,.271,.045,-.276,-.003,.407,-.070,-.344,.032,-.200,-.349,.242,.803)*f9_5+\n    mat4(.267,.508,.085,.078,.096,.324,.771,-.308,-.012,.347,-.098,-.151,-.139,-.092,-.295,-.208)*f9_6+\n    mat4(.510,.564,-.314,-.237,.189,-.085,.347,-.271,-.225,-.020,-.442,.359,-.349,.144,.329,-.406)*f9_7+\n    vec4(-.247,.475,1.481,.317))/3.2+f9_0;\nvec4 f10_1=sin(mat4(.161,-.655,-.873,-.256,.400,-.416,-.506,.161,.114,.546,-.127,.399,-.260,-.393,-.176,.069)*f9_0+\n    mat4(.406,-.347,-.042,.227,.024,-.458,-.374,-.302,-.064,-.052,.049,.051,-.204,-.395,-.309,.721)*f9_1+\n    mat4(-.119,-.222,-.126,-.162,.760,-.205,-.414,.308,-.304,-.152,-.203,.262,.158,.266,.128,.001)*f9_2+\n    mat4(-.321,-.362,-.394,.490,-.007,.252,-.085,-.093,-.201,-.199,.004,.205,.045,-.054,.144,.526)*f9_3+\n    mat4(.445,-.205,-.204,.624,.161,.265,.307,.441,-.131,-.893,-.278,-.276,-.130,-.002,-.405,-.289)*f9_4+\n    mat4(-.410,.234,-.123,.378,.156,-.096,-.255,-.178,.444,-.734,-.138,-.320,.248,.089,-.487,-.815)*f9_5+\n    mat4(-.107,.085,-.619,-.386,-.594,.015,-.177,-.213,.622,.055,-.111,.551,.014,-.268,.391,-.035)*f9_6+\n    mat4(.086,-.895,-.393,.213,.019,.604,.066,-.477,.569,-.426,-.217,-.331,.160,.017,-.186,.144)*f9_7+\n    vec4(.776,.143,-.029,-.144))/3.2+f9_1;\nvec4 f10_2=sin(mat4(.118,-.220,.239,.121,.241,-.283,.087,-.287,.266,.045,.050,-.362,.122,-.118,.402,.129)*f9_0+\n    mat4(-.242,-.123,.190,.398,.339,.178,-.198,.197,-.812,-.228,.367,.176,.232,-.321,.007,-.606)*f9_1+\n    mat4(-.030,.305,-.414,.060,-.429,-.972,.254,.329,-.145,-.130,.106,-.549,-.019,.256,-.565,-.417)*f9_2+\n    mat4(-.251,.449,-.019,.326,.240,-.107,.240,-.408,.264,.016,-.223,-.205,.309,-.260,.206,-.537)*f9_3+\n    mat4(-.128,-.226,.364,-.121,-.117,-.648,.026,.215,-.201,-.508,.513,-.643,.339,-.116,-.453,.364)*f9_4+\n    mat4(.104,.119,-.145,.571,.059,.094,-.101,-.384,-.024,.061,-.430,-.596,-.394,.075,.207,-.290)*f9_5+\n    mat4(-.693,.280,-.299,.065,-.481,.585,-.039,-.489,-.261,.127,-.300,.830,-.114,.013,-.074,-.514)*f9_6+\n    mat4(-.200,-.069,.097,.087,.309,.188,.469,-.122,-.036,-.197,.488,-.266,-.261,-.069,-.072,-.006)*f9_7+\n    vec4(.096,-.152,-.221,1.640))/3.2+f9_2;\nvec4 f10_3=sin(mat4(-.454,.574,.119,-.516,-.662,.806,.029,-.296,.218,-.037,.067,.209,.598,.029,.352,-.030)*f9_0+\n    mat4(.030,-.313,.161,.583,-.450,.062,-.096,.008,.088,.397,.215,.215,.740,-.382,-.378,.100)*f9_1+\n    mat4(-.433,.296,-.536,-.360,.294,.145,-.233,-.256,-.486,.059,.065,.171,-.377,-.172,-.145,-.577)*f9_2+\n    mat4(.040,-.073,-.144,-.049,-.309,.459,.047,.003,.483,-.266,-.626,.053,.017,-.140,-.509,.010)*f9_3+\n    mat4(-.080,-.454,-.322,-.354,.353,-.062,.223,-.205,-.017,.410,.253,-.084,.007,.387,.091,.223)*f9_4+\n    mat4(-.241,.255,-.240,-.250,-.599,.478,-.645,.021,.005,.168,.353,-.676,-.112,-.226,.596,-.009)*f9_5+\n    mat4(.158,-.069,-.214,.113,-.085,-.354,-.463,-.016,.906,-.191,-.417,.240,-.270,.079,-.182,-.269)*f9_6+\n    mat4(.402,.049,-.073,-.050,-.044,-.136,.005,-.645,-.284,.366,.649,.105,.264,-.387,.481,.401)*f9_7+\n    vec4(.438,-.546,.335,.400))/3.2+f9_3;\nvec4 f10_4=sin(mat4(.124,.114,.262,.010,.656,.256,-.240,.276,.323,.977,-.127,-.080,.037,.142,.146,.238)*f9_0+\n    mat4(.407,-.557,-.116,.195,.012,-.010,-.031,-.444,.022,-.202,-.020,.191,-.031,.347,.305,.465)*f9_1+\n    mat4(.455,-.059,-.182,-.100,-.389,.658,.055,-.070,-.530,-.079,.165,.359,.192,.052,-.127,.130)*f9_2+\n    mat4(.478,-.525,.214,-.278,-.430,.402,.102,.106,-.014,.331,.315,-.410,-.073,.134,-.271,-.116)*f9_3+\n    mat4(.014,.409,-.445,.340,-.627,-.639,-.138,-.314,-.083,.233,1.175,-.053,.403,-.007,.013,.191)*f9_4+\n    mat4(.256,-.063,.278,.098,.629,-.483,.230,-.396,-.292,.451,.324,-.528,-.326,-.091,-.226,.832)*f9_5+\n    mat4(-.179,.222,.500,.176,-.426,.221,.479,-.322,.022,-.192,-.443,.215,-.252,.493,.391,.253)*f9_6+\n    mat4(-.436,-.735,.439,-.288,.122,.150,-.131,-.492,.374,-.328,-.579,-.124,-.535,-.022,-.356,.567)*f9_7+\n    vec4(-.215,-1.286,.339,1.201))/3.2+f9_4;\nvec4 f10_5=sin(mat4(-.058,.010,.391,.115,-.094,.117,-.198,.394,.184,.155,-.380,-.206,.469,.527,-.367,.011)*f9_0+\n    mat4(-.397,.245,.268,-.041,-.510,.318,.515,-.028,.364,-.472,.052,-.061,.017,-.129,-.024,.136)*f9_1+\n    mat4(.212,.553,.144,.175,.203,-.259,.032,.557,.603,-.593,-.135,.077,-.076,-.160,-.012,.227)*f9_2+\n    mat4(-.409,.493,.081,-.515,.202,-.123,.339,.069,-.267,-.052,-.512,-.114,-.407,.164,-.549,.203)*f9_3+\n    mat4(.181,.432,.600,.269,.130,-.540,-.516,.303,.615,-.315,-.203,-.128,-.461,.501,-.024,.169)*f9_4+\n    mat4(.206,-.190,.091,-.357,.097,-.308,.540,-.356,.451,.225,.465,-.122,-.131,.076,.413,.248)*f9_5+\n    mat4(-.070,-.335,.156,-.228,-.003,-.742,.318,-.204,-.408,.040,.144,.322,-.334,-.349,.213,.200)*f9_6+\n    mat4(.321,.178,.483,-.201,-.290,.185,.132,.731,.553,.168,.677,-.304,-.111,-.023,-.015,.680)*f9_7+\n    vec4(.704,-.432,-.047,.077))/3.2+f9_5;\nvec4 f10_6=sin(mat4(.390,.225,-.193,.160,.715,-.504,-.215,.126,.019,-.619,.500,.546,.292,-.201,-1.309,.031)*f9_0+\n    mat4(.346,-.017,-.263,-.493,.496,-.148,.219,.307,-.469,-.195,.452,.162,-.642,-.409,-.044,.591)*f9_1+\n    mat4(-.303,-.451,-.257,-.189,-.280,.266,.163,.687,-.143,.441,-.045,.319,-.231,-.201,-.649,.102)*f9_2+\n    mat4(-.084,-.300,.370,-.250,-.245,-.021,.043,-.104,-.018,-.320,.340,.090,.304,-.076,-.216,.350)*f9_3+\n    mat4(.338,.131,-.377,.322,-.406,-.130,.273,-.554,.351,.811,-.144,.420,.037,.150,-.161,.337)*f9_4+\n    mat4(-.471,-.106,-.041,-.565,-.530,.238,-.083,-.675,.528,.370,-.557,.129,.126,-.394,-.478,.337)*f9_5+\n    mat4(-.559,-.314,.119,.219,-.744,-.053,-.230,-.404,.139,-.287,-.054,.036,.022,-.354,.250,.240)*f9_6+\n    mat4(-.159,.714,-.309,-.696,.078,-.300,.497,-.021,-.035,.037,-.092,-.202,-.024,.026,-.290,.055)*f9_7+\n    vec4(.623,.197,-1.213,.235))/3.2+f9_6;\nvec4 f10_7=sin(mat4(.002,-.434,-.064,-.587,.220,-.494,-.516,.038,.094,.285,-.159,.407,.281,-.524,-.404,-.118)*f9_0+\n    mat4(-.094,-.247,-.285,.099,-.467,-.640,.104,-.172,-.101,-.150,-.231,.219,-.249,.145,-.740,-.069)*f9_1+\n    mat4(.148,.157,-.295,-.577,-.039,-.119,-.288,-.152,-.305,.040,.563,.159,.103,-.617,.079,-.276)*f9_2+\n    mat4(-.144,.405,-.376,-.108,-.102,-.150,.181,.077,-.163,-.205,-.127,.052,.218,-.347,-.178,.125)*f9_3+\n    mat4(.567,-.344,-.089,-.051,1.023,-.183,-.037,-.371,.296,-.327,.362,-.797,-.705,.457,-.206,.315)*f9_4+\n    mat4(.317,.158,.308,-.411,-.397,.490,.072,-.358,-.171,-.240,.459,.003,-.615,-.190,-.341,-.271)*f9_5+\n    mat4(.206,.148,.309,-.434,.356,-.007,.746,-.753,-.383,.166,.215,.170,-.057,-.355,-.378,-.149)*f9_6+\n    mat4(.967,-.145,.296,-.036,-.258,.309,-.421,.285,-.234,.000,.253,.153,-.362,-.037,-.126,.899)*f9_7+\n    vec4(-.369,-.574,.483,-.112))/3.2+f9_7;\nvec4 f11_0=sin(mat4(-.423,.378,.245,-.146,.226,-.022,.084,-.453,-.011,-.111,.972,-.084,-.014,-.292,.250,-.179)*f10_0+\n    mat4(-.135,-.081,-.069,.510,-.120,-.172,.192,-.013,-.067,.544,-.067,.073,.024,.368,-.275,-.165)*f10_1+\n    mat4(.653,.429,-.054,-.468,-.081,.670,.106,-.081,-.159,.103,-.027,.082,.273,.064,.037,.154)*f10_2+\n    mat4(.395,-.475,.045,.004,.078,-.270,.200,-.150,.282,-.095,-.069,.003,-.324,-.163,-.196,.839)*f10_3+\n    mat4(-.123,.161,.329,-.511,-.151,.211,-.308,.245,-.176,.286,.127,.490,-.029,-.144,.316,.108)*f10_4+\n    mat4(-.425,.403,-.218,-.135,-.064,-.174,.299,-.160,-.071,-.242,.307,.569,-.594,.303,.319,.287)*f10_5+\n    mat4(-.093,-.135,.264,-.550,.304,.136,-.090,-.120,.222,-.234,-.104,-.033,.027,.291,.306,-.446)*f10_6+\n    mat4(-.440,.088,-.455,.080,-.343,-.116,.418,.148,-.158,-.813,-.133,.466,.004,.290,-.267,.397)*f10_7+\n    vec4(-.291,-.303,-.122,-.075))/3.3+f10_0;\nvec4 f11_1=sin(mat4(-.213,.068,-.272,.051,.526,.526,-1.082,.016,-.632,-.574,.027,-.139,.520,.231,-.150,-.112)*f10_0+\n    mat4(.697,.561,.002,-.305,-.210,.237,-.394,.112,.078,.479,-.027,.678,.125,-.246,-.505,.296)*f10_1+\n    mat4(-.042,.300,-.842,-.118,.090,-.240,-.008,.197,-.554,.017,-.033,.087,.429,-.249,-.119,-.152)*f10_2+\n    mat4(.297,-.062,-.501,-.388,-.614,.126,.308,.228,-.543,-.200,-.032,.347,.282,.009,.111,-.269)*f10_3+\n    mat4(.168,-.037,.660,.458,.387,-.182,-.506,-.329,-.386,.208,-.078,.345,.468,-.241,-.078,-.162)*f10_4+\n    mat4(.227,.246,-.939,-.122,-.479,.134,-.394,.006,.214,.393,.008,.642,-.226,-.164,-.025,.783)*f10_5+\n    mat4(.101,.134,.176,-.286,-.224,-.169,-.223,.011,.315,-.050,-.020,-.419,-.320,.281,.417,.885)*f10_6+\n    mat4(-.114,.685,-.126,.454,.359,-.275,.535,-.338,.487,.088,.396,.305,.535,-.404,.619,.554)*f10_7+\n    vec4(.390,-.908,1.836,1.420))/3.3+f10_1;\nvec4 f11_2=sin(mat4(-.080,.607,-.011,-.105,-.054,.125,.572,-.354,.288,.037,-.591,-.623,-.162,.448,.216,.065)*f10_0+\n    mat4(-.148,.176,.081,-.297,-.060,-.012,-.241,-.554,-.556,-.401,.215,.141,.198,-.230,-.300,.403)*f10_1+\n    mat4(.134,-.735,.076,-.106,-.226,.432,.380,-.059,.135,.013,.529,.618,-.188,.753,.155,.409)*f10_2+\n    mat4(.480,.076,.061,-.504,-.072,-.337,-.174,.263,.508,.174,-.627,-.280,-.028,.272,-.444,-.012)*f10_3+\n    mat4(-.017,-.054,.356,-.221,-.570,.310,-.244,.138,.172,-.018,.246,.192,.480,.033,-.130,-.183)*f10_4+\n    mat4(.095,.066,.165,.256,.503,.160,.040,-.555,.391,.834,.302,-.361,-.272,-.108,.329,.176)*f10_5+\n    mat4(.352,.458,.151,.143,-.221,-.221,-.206,.690,.124,-.406,.156,.234,-.019,.282,-.111,-.167)*f10_6+\n    mat4(.440,.785,.251,.205,-.321,.110,.263,-.585,-.669,-.155,.093,-.206,.132,.195,.029,.010)*f10_7+\n    vec4(-.939,-2.065,-.395,-.219))/3.3+f10_2;\nvec4 f11_3=sin(mat4(.297,.570,.315,.422,-.323,.729,.242,.806,-.153,-.333,-.102,.212,.161,.478,-.153,-.715)*f10_0+\n    mat4(-.270,-.245,.170,.215,.465,-.021,-.477,-.200,-.083,.075,.218,-.086,.129,-.125,.349,.686)*f10_1+\n    mat4(-.275,.633,.355,.483,-.100,.111,.235,.229,.293,-.923,.212,.110,-.442,.157,.759,-.525)*f10_2+\n    mat4(.083,.338,.422,-.506,.484,-.232,.367,.513,.167,.337,.714,-.101,-.122,-.164,.070,-.198)*f10_3+\n    mat4(-.216,-.134,.439,-.152,.533,.066,-.144,-.137,-.099,.700,.233,-.021,-.549,-.025,.349,.042)*f10_4+\n    mat4(.318,.436,-.066,-.512,-.131,-.153,.187,.435,.074,.023,.128,-.139,.164,-.110,-.097,.582)*f10_5+\n    mat4(.289,.040,-.112,-.069,.591,.077,.184,-.161,-.012,.082,.739,-.268,.272,.062,.141,.107)*f10_6+\n    mat4(.087,-.096,.045,-.481,-.251,.444,-.442,-.014,.194,-.329,-.057,-.006,.022,-.462,.165,-.232)*f10_7+\n    vec4(-1.293,-.528,.206,-.514))/3.3+f10_3;\nvec4 f11_4=sin(mat4(.062,.098,.694,-.401,.098,-.105,.196,-.070,.166,-.216,-.263,-.724,.126,-.113,-.071,.741)*f10_0+\n    mat4(.078,.267,-.354,.177,-.143,-.283,.192,.012,.061,-.067,-.085,.411,-.203,.043,-.099,.150)*f10_1+\n    mat4(.093,.297,-.762,.095,.077,-.184,.596,.006,-.079,-.211,-.128,-.167,.183,.424,-.005,-.131)*f10_2+\n    mat4(.012,-.195,-.705,.404,.102,.153,.405,-.194,-.219,.240,.078,.178,.051,-.375,-.131,-.016)*f10_3+\n    mat4(-.301,.223,-.185,-.237,-.142,.622,.873,-.359,-.386,.306,.661,.143,.350,.010,-.204,-.071)*f10_4+\n    mat4(-.043,.289,.361,.210,-.091,-.006,.205,-.255,.063,.083,.192,-.339,.364,-.981,-.559,-.071)*f10_5+\n    mat4(.182,-.035,-.295,-.581,-.120,.569,.359,-.413,.402,-.016,-.188,.223,-.231,-.254,-.061,-.233)*f10_6+\n    mat4(-.892,.200,.009,-.119,-.413,-.306,-.168,-.470,.254,-.210,-.096,.331,.311,-.590,-.388,.344)*f10_7+\n    vec4(.269,-.468,-.432,.017))/3.3+f10_4;\nvec4 f11_5=sin(mat4(-.048,-.076,-.141,-.060,-.568,.041,-.301,.118,.113,-.344,.227,-.867,-.317,.181,-.072,.269)*f10_0+\n    mat4(-.067,.355,.128,.341,.169,.385,.213,-.139,.216,-.216,.202,.104,-.341,-.086,-.062,-.378)*f10_1+\n    mat4(-.053,.276,.168,.063,-.350,-.461,-.147,-.184,-.307,-.692,-.019,-.053,.263,-.351,-.368,-.172)*f10_2+\n    mat4(.005,.329,.020,-.085,-.617,-.196,.417,-.026,.106,-.209,-.247,-.459,-.104,-.191,-.782,.153)*f10_3+\n    mat4(-.388,.531,-.076,.284,.540,-.718,-.220,-.645,-.751,.000,.357,.621,-.295,.621,-.089,-.165)*f10_4+\n    mat4(.008,-.553,-.041,-.065,-.003,-.082,.427,.586,.493,.466,.456,-.005,-.385,-.130,-.217,-.535)*f10_5+\n    mat4(.154,.244,.433,.084,.547,-.573,.311,.018,.286,-.159,-.158,-.010,.246,.222,-.499,-.466)*f10_6+\n    mat4(-.044,-.148,.041,.338,.250,-.199,-.216,-.174,-.464,.478,.445,.195,-.174,-.008,-.796,-.001)*f10_7+\n    vec4(.995,-.022,-.773,.489))/3.3+f10_5;\nvec4 f11_6=sin(mat4(.113,-.650,-.240,-.250,.174,-.417,.093,.376,.353,-.528,-.392,.240,.056,-.371,.044,.044)*f10_0+\n    mat4(.163,-.543,-.288,-.160,.050,-.044,-.233,-.945,.101,.199,.206,.077,-.381,.087,-.351,.373)*f10_1+\n    mat4(.199,-.417,-.642,.540,.230,-.300,.892,-.266,-.900,-.280,-.437,.468,-.198,.231,.001,-.389)*f10_2+\n    mat4(.037,-.493,-.255,-.140,-.060,.403,.286,.705,.417,-.284,-.670,-.769,.220,.044,-.315,.507)*f10_3+\n    mat4(.235,-.086,.179,-.027,.464,.201,.758,.362,-.065,.153,-.159,.659,-.164,-.099,.574,-.182)*f10_4+\n    mat4(-.627,.133,-.310,-.064,-.633,-.483,-.922,-.271,-.017,-.291,-.006,-.468,.520,-.166,.414,.464)*f10_5+\n    mat4(-.682,-.355,.052,-.025,-.741,.881,.166,.189,-.081,.142,-.006,-.573,.314,-.318,-.356,-.784)*f10_6+\n    mat4(-.366,.001,-.168,.101,-.379,.712,-.180,.025,-.008,-.257,.197,-.150,.144,.179,-.125,-.332)*f10_7+\n    vec4(.111,.517,.542,.029))/3.3+f10_6;\nvec4 f11_7=sin(mat4(-.383,-.717,-.439,.130,-.122,-.325,-.396,-.156,.073,-.073,-.129,.271,-.028,.200,-.039,-.131)*f10_0+\n    mat4(.205,.308,.032,.028,.249,-.160,-.252,-.059,-.066,.394,.049,.067,.048,.279,.280,.253)*f10_1+\n    mat4(-.008,.484,-.149,-.644,.099,-.275,.588,.632,-.194,-.325,-.559,-.181,-.612,-.214,-.168,-.697)*f10_2+\n    mat4(-.220,.639,.207,.450,-.245,-.342,-.197,-.614,.473,-.187,.331,.009,-.457,.471,-.161,.447)*f10_3+\n    mat4(.198,-.226,.123,.132,-.018,-.970,-.206,-.177,-.364,-.832,.246,.019,.023,.181,.121,-.031)*f10_4+\n    mat4(-.494,-.045,-.376,-.230,-.132,.001,.033,-.338,-.318,-.466,.146,-.226,.115,.016,.115,.467)*f10_5+\n    mat4(-.325,.277,.458,-.551,.296,.042,.209,-.647,.285,-.370,-.061,-.291,-.085,-.059,.387,.476)*f10_6+\n    mat4(-.405,-.369,.054,-.128,-.344,-.555,-.093,-.171,-.173,-.399,-1.065,-.024,.164,.429,.315,.652)*f10_7+\n    vec4(.081,-.059,-1.153,-.223))/3.3+f10_7;\nvec4 f12_0=sin(mat4(-.733,.352,-.267,-.158,-.082,.433,.213,.496,.261,.524,-.238,-.959,.015,.390,.014,-.083)*f11_0+\n    mat4(.107,.084,-.395,.459,.146,.561,-.445,-.142,.148,-.270,.340,.151,.271,-.161,.353,-.582)*f11_1+\n    mat4(.559,-.092,.251,-.359,-.849,-.578,-.190,.484,.073,-.266,.421,-.321,-.295,.108,-.107,.171)*f11_2+\n    mat4(.479,.418,-.216,-.099,.209,-.160,.065,.137,-.037,-.156,.137,-.301,.630,.156,.136,-.439)*f11_3+\n    mat4(-.165,-.057,.262,.525,-.730,-.161,-.495,.438,-.227,-.992,.266,.361,-.210,-.235,.087,-.027)*f11_4+\n    mat4(.022,-.165,.139,-.431,-.071,-.009,.167,-.058,-.087,.437,.297,.085,.339,.127,-.624,-.548)*f11_5+\n    mat4(.232,.002,.489,-1.158,-.007,-.061,.300,.070,-.153,.052,-.284,.589,.105,.011,-.252,.205)*f11_6+\n    mat4(-.245,-.287,.291,-.119,-.250,.427,-.255,-.290,-.259,.081,-.494,.440,.060,-.463,-.005,.470)*f11_7+\n    vec4(-.354,.498,-.625,.578))/3.5+f11_0;\nvec4 f12_1=sin(mat4(-.199,.010,-.050,.480,.561,.244,-.011,-.257,.083,-.430,.154,.600,.036,.480,-.144,-.983)*f11_0+\n    mat4(.145,.068,-.035,.128,.076,-1.107,-.371,.712,.255,-.332,-.444,-.079,.375,.499,-.306,.311)*f11_1+\n    mat4(-.073,-.160,-.182,.836,-.442,.232,.323,-.378,.131,.398,-.297,-.208,-.113,.230,.328,-.874)*f11_2+\n    mat4(-.593,-.800,-.056,.544,.565,-.182,-.514,.403,-.692,-.190,.304,-.118,.132,.546,-.146,.120)*f11_3+\n    mat4(-.191,.758,.108,.840,-.207,.041,-.003,-.456,-.115,.268,.046,-.370,-.240,-.155,.501,.192)*f11_4+\n    mat4(-.317,-.267,-.496,-.272,-.452,-.123,-.747,.275,.077,-.353,-.637,-.483,.138,-.046,.207,.345)*f11_5+\n    mat4(-.297,.112,.103,-.350,-.026,-.403,-.680,.297,-.141,.203,.466,-.115,-.110,-.019,-.185,.483)*f11_6+\n    mat4(.057,.563,-.533,.063,1.272,-.278,-.145,-.121,.259,.283,.163,-.881,.185,.445,.005,-.001)*f11_7+\n    vec4(.100,1.272,.652,.631))/3.5+f11_1;\nvec4 f12_2=sin(mat4(-.119,-.381,.110,-.088,.337,.149,.296,.272,.243,.122,.327,-.153,.383,-.035,.139,.278)*f11_0+\n    mat4(-.442,.336,-.102,.150,-.068,-.443,.241,-.145,-.134,.204,-.266,-.032,.067,.144,-.189,-.016)*f11_1+\n    mat4(1.448,.050,-.631,.223,-.706,.419,.219,-.514,.103,-.102,-.275,-.297,-.510,-.201,-.110,.309)*f11_2+\n    mat4(-.413,-.271,-.605,.133,-.183,-.019,.126,.001,-.070,-.313,-.265,.096,-.134,-.687,.187,.270)*f11_3+\n    mat4(-.300,.230,-.193,-.187,-.321,-.513,.768,.019,-.008,-.219,-.096,.297,.046,.108,-.161,.152)*f11_4+\n    mat4(-.244,-.226,.470,-.546,.240,-.247,-.155,.637,.101,-.669,.176,.561,-.321,.182,.133,-.577)*f11_5+\n    mat4(.232,-.702,-.114,.492,.280,-.369,.679,.752,-.242,-.337,-.653,.268,-.183,.202,.030,-.720)*f11_6+\n    mat4(-.332,-.411,-.443,.491,-.328,.658,.375,-.158,-.059,-.446,-.431,-.378,-.416,.286,-.027,-.533)*f11_7+\n    vec4(.144,.528,.390,.319))/3.5+f11_2;\nvec4 f12_3=sin(mat4(-.132,.391,-.021,-.106,.425,.268,-.250,-.073,-.250,.143,-.209,.393,-.333,-.206,.021,.203)*f11_0+\n    mat4(.258,.184,-.074,-.126,.164,.125,-.185,.064,-.389,.353,.243,-.043,-.331,-.270,-.433,.232)*f11_1+\n    mat4(-.113,-.636,-.561,.180,-.568,.336,-.044,-.779,-.250,-.069,.045,.643,.175,-.441,.119,-.729)*f11_2+\n    mat4(.660,-.238,-.354,.664,.237,.741,-.184,.255,-.166,-.165,.438,-.706,-.273,.379,-.282,.647)*f11_3+\n    mat4(-.051,.195,-.491,-.203,-.579,.490,-.353,-1.304,-.707,-.002,.280,-.305,.561,-.372,.074,-.741)*f11_4+\n    mat4(-.220,-.303,-.278,-.059,.138,.172,-.558,.020,.384,.334,.591,.058,-.300,.726,.428,.015)*f11_5+\n    mat4(.313,-.195,-.224,.061,-.196,.336,.062,-.125,-.442,-.422,-.698,-.105,-.294,.292,.152,.056)*f11_6+\n    mat4(-.764,.112,-.124,-.047,-.429,.160,.346,-.046,.310,-.120,.895,.846,.404,-.150,.201,-.483)*f11_7+\n    vec4(-.554,-.468,.726,.165))/3.5+f11_3;\nvec4 f12_4=sin(mat4(-.194,-.078,.122,.071,-.175,.000,-.359,-.470,-.070,.331,.237,-.339,-.273,.212,-.185,-.346)*f11_0+\n    mat4(-.045,-.171,-.697,-.157,.517,.535,-.147,-.381,-.178,.169,.267,-.156,-.341,-.078,-.108,-.667)*f11_1+\n    mat4(-.150,.380,.214,-.682,-1.036,-.386,.139,.432,-.223,-.031,-.191,.365,.049,.068,-.244,-.172)*f11_2+\n    mat4(.023,-.046,.315,-.824,.082,-.261,.459,.319,-.602,.460,-.056,-.164,.070,-.022,-.579,-.742)*f11_3+\n    mat4(-.249,-.454,-.072,-.169,-.478,-.817,.450,.192,-.013,.158,.857,.395,-.074,-.093,.181,.350)*f11_4+\n    mat4(-.043,-.122,-.343,.327,.012,.685,.491,-.269,.637,.635,.216,.022,.185,-.102,-.566,.040)*f11_5+\n    mat4(.708,.036,.081,.251,.294,-.073,.739,.413,-.433,-.356,.192,.009,.020,.353,-.187,-.146)*f11_6+\n    mat4(-.114,-.584,-.008,.584,.262,.384,-.555,-.386,.593,-.566,.128,-.157,-.239,-.070,-.469,.682)*f11_7+\n    vec4(-.221,-1.027,-.882,1.200))/3.5+f11_4;\nvec4 f12_5=sin(mat4(.068,.377,-.005,-.034,-.186,-.172,-.059,-.388,.423,.668,.278,-.072,-.338,.248,-.187,-.124)*f11_0+\n    mat4(-.185,-.480,-.423,.192,.152,-.039,-.601,.223,.252,-.559,-.276,.412,.275,.087,.163,-.138)*f11_1+\n    mat4(.047,.465,.309,.111,-.242,-.075,-.097,.056,.158,.614,-.059,-.336,-.551,-.056,-.197,-.368)*f11_2+\n    mat4(-.156,-.238,.261,-.315,.139,.283,.568,.062,-.592,.243,.417,-.058,-.380,-.228,-.601,-.318)*f11_3+\n    mat4(.206,.014,.187,.264,.131,-.241,-.860,-.123,.344,.257,.178,-.325,.040,.306,.188,-.141)*f11_4+\n    mat4(.384,.203,.057,-.441,.224,.763,.317,-.928,-.162,.098,.575,-.089,.108,-.055,-.207,.518)*f11_5+\n    mat4(-.154,.688,.389,-.433,.412,.280,.664,-.302,-.354,.008,.321,-.626,.763,-.058,.073,.261)*f11_6+\n    mat4(.479,.020,.053,-.188,-.229,-.328,-.142,.359,.064,.418,.164,-.513,.130,-.091,-.565,.181)*f11_7+\n    vec4(-.078,-1.317,-.323,.319))/3.5+f11_5;\nvec4 f12_6=sin(mat4(.034,.373,-.464,-.361,.807,-.336,-.624,-.063,-.055,.506,-.231,-.794,-.114,.240,.374,.452)*f11_0+\n    mat4(.421,-.406,-.040,.191,-.095,-.130,.209,-.618,.168,-.181,-.371,-.435,-.045,.063,-.512,-.405)*f11_1+\n    mat4(.103,.537,1.051,.782,-.182,-.263,-.660,-.576,.421,.314,.603,.203,-.051,.175,-.030,-.239)*f11_2+\n    mat4(-.219,-.235,-.187,-.390,.043,.329,-.506,-.076,-.573,.177,-.319,-.537,.707,-.117,-.353,-.517)*f11_3+\n    mat4(-.069,-.183,-.036,-.754,.067,.131,.173,.372,-.301,.483,-.986,.436,-.365,.274,.117,.035)*f11_4+\n    mat4(-.015,.005,.478,.109,.074,.272,-.726,-.417,-.438,.517,-.721,-.207,-.007,.096,.427,-.172)*f11_5+\n    mat4(-.548,1.004,-.310,-.083,-.547,.864,-.310,.109,.072,-.157,.161,-.224,.413,.014,-.552,-1.221)*f11_6+\n    mat4(-.310,.065,-.503,.057,.262,-.100,.301,.216,.741,-.016,.048,-.172,.370,-.255,.213,-.528)*f11_7+\n    vec4(.567,-1.002,.742,-.616))/3.5+f11_6;\nvec4 f12_7=sin(mat4(-.081,-.809,.129,.504,.023,-.142,-.083,.338,-.429,.382,-.177,.309,.599,-.045,-.246,-.008)*f11_0+\n    mat4(-.046,-.048,-.623,-.103,-.457,.344,.424,.506,.318,-.109,-.141,-.328,-.616,.266,-.254,-.253)*f11_1+\n    mat4(-.471,.763,-.105,-.187,.475,-.411,-.676,-.447,.015,.397,-.363,.226,.334,.030,.145,-.160)*f11_2+\n    mat4(-.702,-.271,.365,-.645,-.261,-.322,-.238,.279,-.063,-.146,-.138,-.459,.263,-.092,.090,.422)*f11_3+\n    mat4(-.381,-.329,-.277,-.028,.435,-.725,-.082,.346,.282,-1.040,-.201,-.295,-.287,-.471,-.146,.280)*f11_4+\n    mat4(.249,-.324,.280,-.059,-.463,-.084,.070,.042,.651,.292,.250,-.266,.015,.660,-.086,.351)*f11_5+\n    mat4(.482,-.429,.350,-.541,.420,-.311,.557,-.679,.051,-.268,-.364,.307,-.238,-.537,-.047,.186)*f11_6+\n    mat4(.410,-.979,-.035,-.092,.130,.736,.242,.233,-.969,.569,-.461,.354,.004,.497,.024,-.486)*f11_7+\n    vec4(-.114,1.257,-.890,.459))/3.5+f11_7;\nvec4 f13_0=sin(mat4(-.988,.415,-.135,.185,.243,1.025,.330,-.031,.122,.669,.883,-.780,.222,-.052,-.062,.167)*f12_0+\n    mat4(.079,-.073,-.277,.219,-.112,-.131,.455,.547,.104,-.371,-.090,-.205,-.011,-.433,-.500,.210)*f12_1+\n    mat4(.568,-.252,.153,-.994,-.576,-.559,-.757,.395,.077,.552,-.172,-.125,-.002,-.109,.104,.238)*f12_2+\n    mat4(.113,.052,-.402,-.333,-.453,.513,-.273,.261,.213,-.278,-.079,-.355,.203,.389,.319,-.512)*f12_3+\n    mat4(-.204,-.340,.096,1.081,-.736,-.069,-.861,.778,-.180,-.036,-.277,-.269,-.363,-.264,-.211,.194)*f12_4+\n    mat4(-.575,-.066,-.210,.582,.000,.397,.406,.021,.031,.228,.373,-.560,-.325,.176,.113,.546)*f12_5+\n    mat4(-.042,-.517,.217,-.103,-.707,-.448,-.297,.427,-.194,-.068,-.114,.057,.081,-.289,.289,.071)*f12_6+\n    mat4(-.337,-.202,-.512,-.370,-.039,.265,.345,.398,-.213,1.633,.823,.063,.197,-.512,-.431,.693)*f12_7+\n    vec4(-.641,-.613,-.727,1.070))/3.6+f12_0;\nvec4 f13_1=sin(mat4(-.228,.425,-.208,-.227,.379,.096,.245,.335,-.527,.154,-.350,.173,.334,.296,.186,.026)*f12_0+\n    mat4(.229,-.524,.373,.397,-.350,-.242,.394,-.010,-.148,-.057,.274,-.153,-.420,-.042,.398,-.436)*f12_1+\n    mat4(.041,-.491,.603,-.427,.168,.289,-.485,-.118,.112,.206,-.451,-.543,.320,.409,.142,-.735)*f12_2+\n    mat4(-.130,.020,-.032,.044,-.337,.214,-.052,.807,.098,.438,.044,-.149,-.371,.280,-.047,.531)*f12_3+\n    mat4(.166,-.118,-.426,.191,.337,.312,.532,.060,.138,.673,-.680,.119,.316,-.018,-.062,-.401)*f12_4+\n    mat4(-.029,-.175,-.867,.006,.012,.657,-.350,.012,-.518,.587,-.698,-.176,-.515,-.346,.369,.382)*f12_5+\n    mat4(-.937,.588,-.237,-.453,-.914,.677,-.650,-.124,.261,.094,.328,-.432,-.133,.176,-.143,-.331)*f12_6+\n    mat4(-.048,.243,.029,-.550,-.106,-.399,.288,.160,.342,-.083,.235,-.303,.112,-.121,.079,.305)*f12_7+\n    vec4(-.088,-.147,.353,.450))/3.6+f12_1;\nvec4 f13_2=sin(mat4(-.075,-.515,.085,-.667,.382,.310,-.397,-.377,.761,.239,.041,-.765,.237,.422,-.710,.423)*f12_0+\n    mat4(-.265,-.063,-.630,-.135,.055,.363,-.067,-.675,-.033,.072,.311,-.054,-.030,-.125,-.063,-.383)*f12_1+\n    mat4(1.437,.925,-.550,-.044,-.929,-.817,.459,-.098,.077,.391,-.544,-.442,-.144,.437,.286,.900)*f12_2+\n    mat4(.198,-.321,-.668,-.842,.149,-.563,-.086,-.548,.488,-.119,.357,.066,-.224,.227,.278,-.626)*f12_3+\n    mat4(-.181,-.874,.123,-.640,-.721,-.954,.300,.993,-.569,-.534,.289,.030,.125,-.045,-.012,-.159)*f12_4+\n    mat4(-.049,-.210,.158,.191,.408,.099,.238,-.534,.118,.339,.119,-.127,-.097,.101,.078,-.120)*f12_5+\n    mat4(.044,.204,-.048,.101,.066,-.370,.426,.437,.028,-.352,-.609,.065,-.394,.059,.057,-.666)*f12_6+\n    mat4(-.416,-.429,.142,-.046,-.460,-.040,.360,.388,-.255,-.081,-.596,.211,-.194,.256,.184,.069)*f12_7+\n    vec4(-.235,-.064,-.487,-.070))/3.6+f12_2;\nvec4 f13_3=sin(mat4(-.282,-.092,-.381,.327,-.065,-.092,-.409,.471,-.631,-.481,-.404,.066,-.036,.138,-.289,-.144)*f12_0+\n    mat4(.079,.005,-.027,.073,-.237,.545,-1.098,.548,.165,.351,.175,-.308,-.435,-.156,-.150,-.324)*f12_1+\n    mat4(-.187,.402,.260,-.185,-.353,-.990,-.044,.439,.382,.852,.048,-.285,-.081,-.404,.280,-.462)*f12_2+\n    mat4(.040,-.083,.270,-.011,.109,-.037,-.406,.849,.312,-.047,.552,-.190,-.491,-.082,-.194,.219)*f12_3+\n    mat4(.317,-.226,-.753,-.101,.109,-.762,-.201,-.242,.416,.263,.453,-.270,-.238,-.233,.007,-.307)*f12_4+\n    mat4(.245,-.013,-.169,-.054,.520,.544,-.017,.039,-.292,-.562,.124,.044,-.269,-.189,-.253,.199)*f12_5+\n    mat4(.146,.082,.511,-.314,.366,.436,.394,.121,.413,.208,.269,.360,-.486,.034,-.061,.579)*f12_6+\n    mat4(.670,-.033,.682,.108,-.641,-.118,-.281,-.114,.243,.606,-.153,1.104,.018,-.052,-.290,.014)*f12_7+\n    vec4(.277,1.014,-.707,-1.070))/3.6+f12_3;\nvec4 f13_4=sin(mat4(-.069,.089,-.497,.380,.587,.172,.081,-.046,.145,.018,-.371,.339,.114,-.108,.408,-.179)*f12_0+\n    mat4(-.019,-.187,.473,-.126,-.209,-.327,-.160,-.028,-.482,-.363,-.384,.103,.030,-.026,-.039,-.138)*f12_1+\n    mat4(.230,.463,.163,-.048,-.730,-.090,-.527,.208,.415,-.284,.080,.276,.125,.507,.182,-.196)*f12_2+\n    mat4(.086,-.093,-.148,-.224,.045,.511,-.280,.595,-.045,-.121,.234,.214,.019,-.261,.173,.243)*f12_3+\n    mat4(-.783,.298,-.278,.201,-.408,.124,-.218,-.502,-.784,-.465,-.441,1.020,-.301,.421,-.469,-.608)*f12_4+\n    mat4(.016,-.145,.033,.156,-.208,.084,-.075,.219,.198,-.146,-.174,.337,.063,-.285,-.116,-.051)*f12_5+\n    mat4(-.085,-.027,-.440,.386,-.420,.281,-.770,.659,.286,.504,.471,-.122,-.486,-.727,-.061,1.025)*f12_6+\n    mat4(-.251,-.050,.086,.193,-.164,.206,.087,.264,1.024,-.570,.204,-.351,-.323,-.385,.114,-.335)*f12_7+\n    vec4(.721,-.509,1.524,-.748))/3.6+f12_4;\nvec4 f13_5=sin(mat4(.311,.066,.033,-.225,.541,-.118,.047,-.062,-.148,.306,.178,-.245,.039,-.378,-.086,-.490)*f12_0+\n    mat4(.062,.158,-.149,.133,-.660,-.663,.167,-.468,-.266,.232,.035,-.250,-.581,-.189,-.315,-.027)*f12_1+\n    mat4(-.177,.301,-.090,-.139,.741,-.627,-.097,.074,-.182,.514,-.085,.418,-.418,.190,-.342,.647)*f12_2+\n    mat4(-.434,.093,.403,.429,.536,.195,.154,-.507,-.496,.201,.378,-.144,.291,.139,-.800,-.506)*f12_3+\n    mat4(-.177,-.388,.210,.015,.099,-.876,-.551,-.000,.381,.294,.111,.023,.138,.155,-.123,.461)*f12_4+\n    mat4(-.019,.134,-.503,.613,-.007,.902,.792,.625,-.446,-.047,.987,-.096,.430,.144,.007,-.834)*f12_5+\n    mat4(.174,.567,.258,.261,-.024,.104,.451,-.171,-.196,.235,.172,-.148,-.029,-.232,-.157,-.527)*f12_6+\n    mat4(.507,.659,-.338,.024,.611,-.059,-.449,-.345,-.438,-.258,.057,.336,.015,-.619,.222,-.220)*f12_7+\n    vec4(.736,.193,-1.355,-1.590))/3.6+f12_5;\nvec4 f13_6=sin(mat4(-.086,.052,-.341,-.585,.631,-.543,-.519,-.324,-.324,.396,.374,.260,.168,-.008,.116,-.344)*f12_0+\n    mat4(.211,-.597,.086,-.088,-.123,-.030,.604,-.917,-.117,-.036,.353,-.180,.308,-.356,.396,.009)*f12_1+\n    mat4(.409,.319,-.099,.273,-.238,-.248,.081,-.072,-.373,-.396,.267,.583,.551,-.450,-1.329,.221)*f12_2+\n    mat4(-.409,-.376,.081,.013,-.001,.381,.137,-.456,.119,.690,.235,-.199,-.320,-.168,-.095,.218)*f12_3+\n    mat4(-.026,.010,.578,.292,-.041,.044,-.675,.013,-.674,.615,-.395,-.158,.488,.078,-.201,-.215)*f12_4+\n    mat4(-.524,-.304,-.633,-.013,.095,.335,-.289,-.160,.094,.075,.372,-.394,-.069,.178,.036,-.268)*f12_5+\n    mat4(-.144,.705,.314,-.288,.089,.849,.217,-.323,.414,-.392,.070,-.115,-.754,-.133,.665,-.340)*f12_6+\n    mat4(-.137,.236,.415,-.386,.171,-.222,-.026,.389,-.078,-.606,.328,.640,.490,-.532,.341,.647)*f12_7+\n    vec4(1.036,-1.060,.607,-.569))/3.6+f12_6;\nvec4 f13_7=sin(mat4(.240,-1.040,-.181,-.302,.181,-.645,-.405,-.362,-.169,.555,.304,.053,-.454,.070,-.154,-.401)*f12_0+\n    mat4(-.019,-.325,-.112,-.442,-.429,-.147,.182,-.030,.781,-.350,.286,.366,-.001,-.500,-.075,.430)*f12_1+\n    mat4(-.206,.054,-.345,.017,-.371,-.304,-.237,.316,-.011,-.340,-.381,.153,-.307,.211,-.084,-.250)*f12_2+\n    mat4(-.495,.233,.484,.259,-.036,.186,-.238,.039,.151,.427,-.186,.121,-.477,-.308,.316,.153)*f12_3+\n    mat4(.067,.103,-.301,-.163,.171,-.325,-.123,-.001,.095,-.208,-.538,-.094,-.506,-.384,-.448,-.011)*f12_4+\n    mat4(.247,-.584,.001,.307,.291,.276,.419,-.209,-.107,.535,.446,-.233,-.377,.190,.422,-.407)*f12_5+\n    mat4(-.018,.450,.713,-.246,.728,-.602,.410,-.409,.326,.091,-.497,.095,.095,-.551,.138,.784)*f12_6+\n    mat4(.460,.029,.286,-.201,.318,-.253,.054,-.295,-.237,.000,.017,.371,-.295,.263,-.131,.214)*f12_7+\n    vec4(-.159,-.884,-1.233,-.958))/3.6+f12_7;\nvec4 f14_0=sin(mat4(.987,-.304,.298,-.596,-.161,1.053,-.279,.169,.321,-.241,.162,-.568,-.066,.134,-.049,.316)*f13_0+\n    mat4(-.177,.367,-.362,.693,.423,.351,.642,-.041,-.170,.198,.421,-.393,-.034,.111,.055,.505)*f13_1+\n    mat4(-.600,.103,.192,.560,.359,-.273,-.466,.338,-.502,.358,-.009,.147,-.440,-.086,-.597,.085)*f13_2+\n    mat4(-.261,-.235,-.261,.112,.406,.022,.396,-.052,-.199,-.411,-.399,-.189,.416,.217,.412,.008)*f13_3+\n    mat4(.089,-.495,.187,-.310,.492,-.348,-.604,1.235,.321,-.555,-.105,-.670,-.124,-.078,-.279,.035)*f13_4+\n    mat4(.233,-.126,-.480,-.200,.175,-.290,.090,-.063,.096,-.151,.328,-.120,.419,.217,.339,.323)*f13_5+\n    mat4(.354,-.528,.376,-.835,.479,-.515,.493,-.507,-.540,-.159,-.105,.475,.346,.077,.520,-.150)*f13_6+\n    mat4(.125,-.514,-.349,.232,.275,.154,-.137,.552,.354,.816,-.351,.542,-.325,.217,.198,.624)*f13_7+\n    vec4(-.238,2.975,.040,-.768))/3.7+f13_0;\nvec4 f14_1=sin(mat4(-.236,-.209,.632,-1.086,.363,-.191,.512,.159,-.399,-.525,-.236,-.538,.500,.559,.015,.561)*f13_0+\n    mat4(.092,.360,-.375,.095,-.112,-.743,.446,.231,.346,-.258,-.127,-.132,.161,-.394,-.282,.292)*f13_1+\n    mat4(-.241,.123,.521,-.300,.118,-.554,-.204,-.018,-.742,-.316,-.505,.789,-.679,.444,-.447,-.100)*f13_2+\n    mat4(-.497,-.567,.500,.479,-.284,-.737,.674,-.565,.019,.257,-.051,-.460,.531,.038,-.074,-.658)*f13_3+\n    mat4(-.568,-.074,-.336,-.057,.529,.813,-.036,-1.060,.247,-.249,.561,.315,.093,-.420,-.073,-.134)*f13_4+\n    mat4(-.430,-.270,-.187,.506,-.716,-.564,.087,.405,-.698,-.499,.564,-.222,-.112,-.341,-.045,-1.476)*f13_5+\n    mat4(-.438,-.035,-.009,-.433,.169,.150,.823,-.328,-.182,1.031,-.432,.356,.040,-.647,-.059,-.392)*f13_6+\n    mat4(-.431,.750,-.263,-.134,.086,.333,-.236,-.346,-.457,-.505,.245,.614,.434,.149,-.395,.733)*f13_7+\n    vec4(.762,1.872,-.407,.381))/3.7+f13_1;\nvec4 f14_2=sin(mat4(-.221,-.146,.066,-.166,-.032,-.141,-.712,-.193,-.505,-.790,-.115,-.514,-.184,-.095,.036,.626)*f13_0+\n    mat4(.156,.030,.022,-.286,-.015,-.211,.247,-.682,.263,.235,.273,.083,.355,.081,-.176,-.046)*f13_1+\n    mat4(-.925,-.913,-.514,-.890,.577,1.013,.752,.670,-.380,-.357,-.810,.639,-.017,-.151,-.515,-.191)*f13_2+\n    mat4(.129,-.037,-.063,-.600,-.176,-.068,-.045,.404,.022,-.066,.132,-.202,.012,-.176,.014,-.204)*f13_3+\n    mat4(.365,.773,1.055,-.579,.363,.682,.690,.089,-.207,.509,.740,.333,-.095,-.015,-.339,-.562)*f13_4+\n    mat4(.600,.190,.109,.976,-.545,-.276,-.013,-.457,-.065,.008,.100,-.581,.088,-.210,.166,.500)*f13_5+\n    mat4(-.306,-.281,.238,.306,-.362,.041,.379,.382,-.089,-.159,-.339,-.153,.076,-.145,.230,-.125)*f13_6+\n    mat4(-.090,.509,.363,.599,.014,.048,.142,-.496,.273,-.754,-.924,-.222,.467,.339,-.149,.178)*f13_7+\n    vec4(-.883,1.044,-.397,-.711))/3.7+f13_2;\nvec4 f14_3=sin(mat4(-.081,.497,-.677,-.473,.137,.596,-.690,.107,-.308,.534,.218,-.036,-.051,-.297,.179,.060)*f13_0+\n    mat4(-.111,-.174,-.068,.390,-.318,.107,-.194,-.187,-.595,.635,.296,.388,.173,.450,.000,.558)*f13_1+\n    mat4(-.181,.285,.747,.548,.165,.331,-.249,.106,.436,-.163,-.085,-.462,.547,-.670,-.053,-.621)*f13_2+\n    mat4(-.445,.041,.213,-.295,-.665,.151,-.734,-.282,.295,.070,.485,.123,.222,.208,-.321,.414)*f13_3+\n    mat4(.095,.386,.203,-.050,-.014,.037,-.626,-.234,-.093,.752,-.068,-.274,.349,.012,-.200,-.533)*f13_4+\n    mat4(.498,-.206,-.297,-.902,-.430,.345,.193,-.358,.147,.236,.238,-.592,-.924,.247,-.070,.586)*f13_5+\n    mat4(-.403,.037,1.181,.042,-.669,.647,.319,.178,.371,-.286,.533,.139,-.301,.675,-.175,.257)*f13_6+\n    mat4(.504,-.099,.275,.116,.106,-.034,-.494,.300,-.046,-.177,-.786,-.281,.329,-.148,-.041,.349)*f13_7+\n    vec4(.355,-.314,.662,.326))/3.7+f13_3;\nvec4 f14_4=sin(mat4(-.236,.198,.576,-.289,.274,.057,-.284,-.336,-.624,.148,.215,.044,.370,-.163,.001,-.276)*f13_0+\n    mat4(.489,-.210,-.026,-.257,.002,-.805,.453,-1.217,-.164,-.816,-.088,-.175,-.018,.011,-.525,-.132)*f13_1+\n    mat4(-.049,.109,-.678,-.450,-.248,.530,.051,.670,.223,.089,-.525,.596,.460,.493,-.098,.361)*f13_2+\n    mat4(.238,.293,.033,-.055,-.247,-.184,-.095,-.147,-.466,-.024,.008,.275,-.331,-.087,-.092,-.333)*f13_3+\n    mat4(-.344,.151,.170,.461,.066,.691,.382,-.343,-.258,.154,1.045,-.255,.143,.649,.300,.731)*f13_4+\n    mat4(.405,.342,-.203,-.022,-.095,.370,.217,-.434,-.405,-.379,.187,-.754,-.047,-.277,-.037,.283)*f13_5+\n    mat4(-.075,-.494,.394,-.652,-.076,-.024,.285,-.653,.475,.305,-.252,.629,-.575,-.792,-.007,.337)*f13_6+\n    mat4(-.332,.120,.321,-.421,-.354,.198,-.170,.069,.541,-.177,-.263,-.108,.204,.070,-.218,1.029)*f13_7+\n    vec4(.992,-1.303,-1.216,.313))/3.7+f13_4;\nvec4 f14_5=sin(mat4(.376,.496,-.588,.219,.277,.234,-.069,-.162,.296,.063,.094,-.371,.125,-.546,.215,.159)*f13_0+\n    mat4(.353,-.078,-.321,.110,-.459,.097,-.474,-.326,-.170,.072,.406,-.539,.003,-.014,.538,.072)*f13_1+\n    mat4(.208,-.655,-.136,-.171,-.506,.832,-.129,.490,-.073,.683,-.313,-.228,.565,.677,-1.171,.675)*f13_2+\n    mat4(-.523,.319,-.661,-.512,-.155,.443,.142,-.264,-.605,.116,.650,.190,.242,.244,-.258,-.030)*f13_3+\n    mat4(-.225,-.262,-.560,.523,.692,.053,-.485,.728,-.282,-.287,.079,-.228,-.045,.285,-.821,.536)*f13_4+\n    mat4(.073,.007,-.508,.325,.306,.082,.404,-.414,.037,.924,.408,-.224,.121,.041,-.141,-.399)*f13_5+\n    mat4(-.382,-.038,1.057,-.667,-.034,-.647,.596,-.659,.223,.532,-.903,.599,-1.137,-1.059,.285,-.298)*f13_6+\n    mat4(-.064,-.460,.414,.087,.151,.605,.191,-.205,.481,.370,-.521,-.407,-.395,.112,-.153,.215)*f13_7+\n    vec4(-.744,-.000,.264,.830))/3.7+f13_5;\nvec4 f14_6=sin(mat4(.416,-.214,.097,-.037,-.007,-.266,.713,-.467,-.050,.530,.091,.273,-.057,.244,-.518,-.272)*f13_0+\n    mat4(.270,-.309,.031,-.301,.165,-.046,-.984,-.457,.066,-.092,-.519,-.007,.018,-.143,.214,-.470)*f13_1+\n    mat4(.038,.154,-.008,-.036,.310,-.263,-.253,-.687,-.127,.115,-.219,-.438,-.128,-.098,.966,1.198)*f13_2+\n    mat4(-.189,.070,.357,-.458,.031,.138,-.383,-.550,.029,.007,-.390,.521,-.149,-.148,.044,.149)*f13_3+\n    mat4(.188,-.265,-.166,-.389,-.301,-.101,.432,-.335,-.108,.276,-.129,.568,.033,.226,.677,-.208)*f13_4+\n    mat4(.042,-.311,.566,.330,.222,.615,.291,.541,.221,.222,-.232,.369,-.708,-.393,-.584,-.610)*f13_5+\n    mat4(.289,.773,.265,1.050,.296,.607,-.391,.568,-.045,-.224,.416,.162,.053,-.352,-1.027,-.266)*f13_6+\n    mat4(.207,.144,.147,.586,-.092,.043,-.390,.214,-.503,-.506,.409,-.369,-.662,.027,-.286,-.549)*f13_7+\n    vec4(.722,-1.640,-1.309,.379))/3.7+f13_6;\nvec4 f14_7=sin(mat4(.061,.537,.027,.296,-.105,.552,-.891,-.490,-.347,.209,.089,.185,-.349,.013,.128,.573)*f13_0+\n    mat4(-.051,.387,-.168,-.123,-.463,1.155,-.062,1.134,-.047,.151,.122,.679,-.088,-.019,.058,-.038)*f13_1+\n    mat4(.714,.001,.088,.245,.257,-.072,.566,-.015,.335,.260,-.416,.149,.930,-.556,-.144,-1.095)*f13_2+\n    mat4(.373,.547,-.013,.253,-.088,.273,.126,-.098,-.274,-.039,.237,.269,-.444,-.053,-.129,.151)*f13_3+\n    mat4(.132,-.641,.570,-.131,.584,.959,.258,-.165,.419,-.117,.462,.054,.274,-.566,-.028,-.295)*f13_4+\n    mat4(.140,.383,-.005,-.145,.258,.349,-.122,-.245,.051,.115,-.055,.070,-.101,.739,-.053,.292)*f13_5+\n    mat4(-.114,-.351,.801,.250,.583,-.063,.861,.743,.034,.295,-.141,-.476,-.407,.116,-.007,.654)*f13_6+\n    mat4(.155,-.574,.255,.052,-.079,.100,-.105,.151,.295,.699,-1.500,-.641,.005,-.057,.179,.006)*f13_7+\n    vec4(1.522,.717,-.490,.565))/3.7+f13_7;\nvec4 f15_0=sin(mat4(-.534,-.178,.213,.465,-.170,-1.440,.228,-.079,-.320,.329,.198,.364,.588,.008,.032,-.234)*f14_0+\n    mat4(.607,-.631,.004,-.304,-.296,-.049,.190,-.242,.264,.032,.118,-.141,.151,-.019,-.379,-.581)*f14_1+\n    mat4(.044,.303,.348,-.619,.533,.349,-.215,.419,.028,-.424,.331,-.569,.295,-.265,-.259,-.010)*f14_2+\n    mat4(.195,.092,-.313,.111,-.439,.020,.408,.470,.111,.506,-.145,-.208,-.297,-.308,.078,-.352)*f14_3+\n    mat4(.786,.720,-.352,-.127,.196,.247,-.255,-.179,.400,.559,-.453,.588,.413,.116,-.298,.448)*f14_4+\n    mat4(-.016,-.097,-.398,-.060,.094,.217,-.095,.356,-.636,.132,-.046,.276,-.457,-.163,.419,.613)*f14_5+\n    mat4(-.627,1.042,.460,.327,-.416,1.048,.658,.312,.547,-.192,-.290,-.337,-.323,-.157,.149,-.280)*f14_6+\n    mat4(-.029,.740,-.165,-.055,-.250,-.343,.005,.643,-.100,-1.972,-.662,-.574,.096,-.029,-.509,.379)*f14_7+\n    vec4(1.896,-.233,-.586,-.200))/3.9+f14_0;\nvec4 f15_1=sin(mat4(.109,-.239,.555,-.582,.422,-.143,-.065,-.748,-.341,.189,.107,-.490,-.036,-.067,-.346,.288)*f14_0+\n    mat4(.480,.016,.145,-.029,-.304,.403,-.150,-.306,.068,.416,-.506,-.279,-.203,.055,.304,-.134)*f14_1+\n    mat4(.234,.438,-.319,-.494,-.173,.061,-.050,.428,.043,-.155,-.052,.148,.492,-.824,.965,.083)*f14_2+\n    mat4(.364,.001,.009,.400,-.252,.328,-.206,-.386,.236,.145,-.043,-.001,.224,.183,.067,-.639)*f14_3+\n    mat4(-.065,.419,.101,-.257,-.117,-.300,-.293,-.564,.154,.000,.088,-.144,.167,-.413,.760,.527)*f14_4+\n    mat4(.249,-.602,.254,-.099,-.341,-.127,.544,-.595,.179,.115,-.316,.218,.702,.236,-.397,-.075)*f14_5+\n    mat4(-.102,.085,-.230,-.269,-.709,.211,-.666,-.904,-.039,-.192,.328,.361,-.022,.746,-.477,-.091)*f14_6+\n    mat4(.359,-.263,-.315,.262,.081,.302,-.016,-.642,.203,-.568,-.129,-.216,.194,.243,.165,1.395)*f14_7+\n    vec4(.117,.716,-1.742,-1.116))/3.9+f14_1;\nvec4 f15_2=sin(mat4(-.130,.022,-.547,.537,.540,-.650,.331,.248,-.342,.185,.044,-.042,-.170,.561,-.155,-.053)*f14_0+\n    mat4(.228,.299,.130,-.160,.040,.406,.041,-.661,.027,.193,-.642,-.476,.079,.065,-.149,.020)*f14_1+\n    mat4(-.409,-.227,-.460,-.320,-.010,-.102,-.612,-.039,-.252,-.351,.376,-.095,-.184,-.161,.862,.794)*f14_2+\n    mat4(-.053,.462,.394,-.290,.036,-.298,-.332,-.113,-.173,.274,.222,-.132,.323,.053,.503,.041)*f14_3+\n    mat4(.169,.162,.066,-.017,.255,-.310,-.186,.737,-.116,.275,-.235,.120,-.181,-.227,.057,.359)*f14_4+\n    mat4(-.040,.023,.244,.574,-.188,.252,.188,.513,.019,.015,-.282,.162,.110,-.176,.035,-.119)*f14_5+\n    mat4(-.307,.551,-.155,.497,-.399,.382,-.616,.292,-.006,-.102,.517,.321,.246,.311,-.401,-.768)*f14_6+\n    mat4(-.178,-.217,-.198,.366,.273,.094,.114,-.312,.498,-.909,.271,-.121,.274,.249,.224,-.265)*f14_7+\n    vec4(-.494,.459,-.653,-.281))/3.9+f14_2;\nvec4 f15_3=sin(mat4(-.366,-.247,.148,.172,.295,.064,-.555,-.076,-.445,.174,-.229,-.181,.144,-.170,-.314,.568)*f14_0+\n    mat4(.397,.309,-.157,.549,-.704,.324,.105,.543,-.140,.488,-.002,-.365,-.003,.672,.324,-.624)*f14_1+\n    mat4(.157,.177,.155,-.792,-.059,.048,.507,.601,-.092,-.111,-.091,-.144,.747,-.153,-.522,-.087)*f14_2+\n    mat4(-.178,.075,.454,-.769,-.190,-.200,-.186,.103,-.024,.129,.202,-.102,-.065,.391,.014,-.009)*f14_3+\n    mat4(.282,.393,.034,-.055,.861,-.679,-.189,.878,-.185,.423,.789,-.308,.300,-.043,-.210,-.295)*f14_4+\n    mat4(.391,-.393,.604,.009,-.150,.317,.246,-.391,-.763,.017,-.100,.722,-.484,-.690,-.715,.613)*f14_5+\n    mat4(-.807,-.091,.669,-.753,-.647,.065,.162,-.003,.396,-.282,-.295,-.138,-.617,.499,-.007,.061)*f14_6+\n    mat4(.058,-.012,-.011,-.327,-.059,-.152,-.661,.725,.582,-.119,-.914,.796,.085,.162,-.256,.313)*f14_7+\n    vec4(.432,-.703,.195,-.251))/3.9+f14_3;\nvec4 f15_4=sin(mat4(-.204,.284,-.570,-.426,-.257,.124,-.303,-.162,-.618,-.105,-.543,.233,-.048,-.302,.115,-.068)*f14_0+\n    mat4(.424,-.229,.376,.061,.022,-.507,-.339,.693,.361,.017,.250,.667,.211,-.012,-.101,-.308)*f14_1+\n    mat4(-1.548,-.666,.084,.218,1.260,-.139,.722,-.175,-.324,.127,.277,-.267,.020,.402,.254,-.892)*f14_2+\n    mat4(.173,-.105,.443,-.300,-.086,-.005,-.057,.590,-.231,-.226,-.017,.125,-.295,-.059,-.129,.042)*f14_3+\n    mat4(1.219,.149,.343,-.292,1.218,.731,-.135,-.133,.791,.562,.096,.171,-.021,.428,.441,-.603)*f14_4+\n    mat4(.231,.347,.164,-.721,-.091,.362,.096,-.269,-.090,-.292,-.404,.413,-.330,.030,-.409,.557)*f14_5+\n    mat4(-.233,-.001,.192,-.031,-.153,-.082,-.103,.285,.096,.286,.145,-.736,.121,-.142,.128,1.040)*f14_6+\n    mat4(.451,.067,.701,-.098,.010,-.169,-.391,.425,-.500,.316,-.618,.176,.412,.146,.420,-.100)*f14_7+\n    vec4(.843,-1.587,.379,-.127))/3.9+f14_4;\nvec4 f15_5=sin(mat4(-.017,-.736,.235,-.668,.406,.408,-.343,-.077,-.244,-.038,-.284,-.950,.008,.182,.002,.355)*f14_0+\n    mat4(-.068,.094,.373,.208,-.894,-.131,.518,-.923,-.673,-.627,-.442,-.282,.093,-.064,.094,.253)*f14_1+\n    mat4(-.503,1.040,.115,-.047,.304,-.739,-.167,.430,-.262,.687,.254,.137,.991,1.228,.023,.754)*f14_2+\n    mat4(.336,-.251,.098,.289,-.465,-.094,-.192,-.727,.174,.218,-.090,.149,-.044,-.293,.208,-.535)*f14_3+\n    mat4(-.293,-.465,.311,.354,.305,-.759,-.676,.465,.104,-.404,.118,-.091,.499,.369,.646,.722)*f14_4+\n    mat4(.265,-.216,.303,.202,-.004,.869,.631,-.228,-.299,-.248,-.746,-.494,-.553,-.662,-.491,-.794)*f14_5+\n    mat4(-.407,.534,.804,-.355,.070,-.125,.099,-.243,-.078,.295,1.015,1.025,-.524,-.842,.397,-1.002)*f14_6+\n    mat4(.286,-.425,.211,.487,-.064,-.336,-.038,-.008,.176,1.036,-.867,.119,.329,-.316,-.086,.295)*f14_7+\n    vec4(.100,.337,-.061,1.712))/3.9+f14_5;\nvec4 f15_6=sin(mat4(-.153,.367,.498,.065,-.642,-.230,.123,.368,.112,.361,.088,-.112,-.108,.256,.165,.194)*f14_0+\n    mat4(-.339,-.570,.041,.462,-.191,.046,-.586,.585,-.413,-.208,-.794,.716,.039,.146,-.038,-.047)*f14_1+\n    mat4(.592,.393,-.469,-.028,-.188,-.016,-.343,.434,.244,.319,.471,.051,.270,-.428,.980,-.625)*f14_2+\n    mat4(.132,-.054,.439,-.170,-.084,.443,-.315,.250,.269,.221,-.002,-.648,-.124,.108,.167,-.102)*f14_3+\n    mat4(.030,-.342,-.235,-.008,.059,-.362,.032,-.142,-.077,-.258,.236,-.085,.111,.169,.616,-.041)*f14_4+\n    mat4(.172,-.343,.605,-.356,.149,.206,.140,-.784,-.101,.116,-.176,-.183,-.291,.076,-.609,.452)*f14_5+\n    mat4(.617,.592,-.284,-1.017,.372,.832,-.245,-.317,.185,-.106,.450,-.322,-.433,.076,-.601,.701)*f14_6+\n    mat4(.279,-.014,.118,-.478,-.254,.135,.022,.216,-.458,-.499,.085,.129,-.359,.055,.076,.356)*f14_7+\n    vec4(-2.559,-.952,-.216,.412))/3.9+f14_6;\nvec4 f15_7=sin(mat4(-.287,.225,-.612,-.066,-.588,.575,-.186,-.422,-.426,.442,-.417,.129,.369,-.165,.129,.061)*f14_0+\n    mat4(.230,.499,.336,-.103,-.472,-.008,-.072,.277,-.224,-.363,.233,.194,-.187,-.239,.235,-.171)*f14_1+\n    mat4(-.097,.283,-.052,-.198,.765,-.260,.266,-.235,-.373,-.358,-.158,-.738,.116,-1.005,.148,-.877)*f14_2+\n    mat4(.024,-.106,.354,.500,-.222,.582,-.681,.251,.032,-.135,-.007,.217,-.499,.976,-.039,.153)*f14_3+\n    mat4(.696,-.280,.412,-.511,.323,.332,.008,.069,.500,-.156,-.155,-.481,.393,-.591,.172,-1.149)*f14_4+\n    mat4(.127,-.281,.177,-.368,.272,.136,-.235,.027,.047,.422,-.402,.520,-.096,.602,-.136,.041)*f14_5+\n    mat4(.405,-.303,-.342,.001,-.124,-.359,-.434,.747,-.098,-.469,.078,-.452,-.538,-.050,.107,.417)*f14_6+\n    mat4(.686,.359,.071,-.212,-.052,-.045,.030,.735,-.217,.903,-.239,.056,.025,-.549,.583,-.189)*f14_7+\n    vec4(-.549,-.368,1.858,.419))/3.9+f14_7;\nvec4 f16_0=sin(mat4(1.224,-.285,.342,.148,.071,-.109,.112,-.312,.589,.173,.513,-.141,-.180,-.204,.170,.178)*f15_0+\n    mat4(-.290,.185,-.243,-.290,.362,.156,.264,-.324,-.242,.147,.005,-.267,-.299,.089,-.246,-.188)*f15_1+\n    mat4(-.526,.304,.290,-.481,.344,-.273,-.480,.140,-.548,.184,-.189,.075,-.173,.041,-.088,-.124)*f15_2+\n    mat4(-.718,-.028,-.373,.285,.716,-.184,.232,-.406,-.078,-.043,-.121,-.053,.467,.147,.087,.552)*f15_3+\n    mat4(.612,-.172,-.583,.296,1.005,-.157,.160,.079,.099,-.454,-.019,.813,-.125,-.102,-.118,.302)*f15_4+\n    mat4(-.167,-.157,-.338,.282,-.121,-.339,.007,-.108,.193,-.183,.072,.023,.840,.153,.525,-.307)*f15_5+\n    mat4(.059,-.266,-.023,-.206,.277,-.224,.222,.422,-.159,.061,-.340,-.256,.259,.099,.088,-.109)*f15_6+\n    mat4(.034,-.154,-.291,-.033,.489,.161,-.109,-.063,-.225,.370,-.063,-.520,-.619,.153,-.145,.385)*f15_7+\n    vec4(-.008,.538,-1.252,.548))/4.0+f15_0;\nvec4 f16_1=sin(mat4(.363,.201,.401,-.766,.828,.399,-.301,.240,-.345,-.406,-.181,.227,.336,-.004,-.212,-.318)*f15_0+\n    mat4(.261,.181,.092,.378,-.148,.241,.445,-.249,-.044,.313,.533,-.154,-.061,-.184,-.276,.005)*f15_1+\n    mat4(-.553,-.348,-.809,.842,.323,.170,.322,-.839,-.123,-.532,-.307,.674,-.066,-.630,-.376,.562)*f15_2+\n    mat4(.025,-.398,-.433,.438,.130,.460,.281,-.776,-.357,-.633,-.156,-.098,.134,-.073,.442,-.684)*f15_3+\n    mat4(-.007,.188,.899,-.510,.401,.624,.458,-.787,.376,-.142,.178,.157,-.023,-.684,-.335,.395)*f15_4+\n    mat4(.217,-.016,-.065,-.288,.238,-.593,-.448,.413,.109,.121,-.034,.052,-.124,.693,.685,-.969)*f15_5+\n    mat4(-.392,-.358,-.863,.266,-.471,-.232,-.448,-.450,-.196,-.244,-.405,.851,.011,.289,.785,-.536)*f15_6+\n    mat4(-.273,.251,.191,-.096,-.107,.261,.441,.037,.619,.004,.089,.252,-.178,-.110,.157,-.031)*f15_7+\n    vec4(-.412,-.318,.227,.430))/4.0+f15_1;\nvec4 f16_2=sin(mat4(.201,-.394,-.736,-.482,.215,-.178,.333,-.063,-.317,-.506,-.466,.197,-.217,.129,.255,.036)*f15_0+\n    mat4(.349,.049,.280,-.102,-.086,-.231,-.105,.584,.249,.078,.116,.689,.033,.252,.387,.003)*f15_1+\n    mat4(-1.279,-.210,-.096,.052,.726,.439,-.157,.089,-.403,-.093,.128,-.244,-.038,.374,.211,-.760)*f15_2+\n    mat4(-.093,-.086,.294,.153,.082,-.465,-.451,.334,-.164,.035,-.074,.055,-.098,-.164,-.026,.016)*f15_3+\n    mat4(.649,.337,-.043,-.137,.772,.095,-.516,-.374,.505,.324,-.288,.271,-.077,.160,-.026,-.663)*f15_4+\n    mat4(.232,.295,.372,-.527,-.180,.009,-.145,-.347,-.087,-.107,-.086,.460,.045,-.562,-.449,.320)*f15_5+\n    mat4(-.556,-.042,-.363,.105,-.258,.026,-.383,.381,.094,.080,.181,-.790,.152,-.276,-.247,.688)*f15_6+\n    mat4(.159,.194,-.047,-.287,.081,.052,.201,.317,.543,-.290,.177,-.356,.081,.353,.561,.219)*f15_7+\n    vec4(-.553,.087,.291,-.912))/4.0+f15_2;\nvec4 f16_3=sin(mat4(-.328,-.244,-.354,-.035,.073,-.305,-.303,.753,-.305,.288,-.030,.089,-.243,.057,-.164,.395)*f15_0+\n    mat4(.003,-.290,-.395,.064,-.861,.654,-.293,.131,-.237,.647,-.418,.083,.264,-.102,-.253,-.363)*f15_1+\n    mat4(.477,.057,.372,-.217,.202,.135,-.856,-.594,.289,-.557,.410,.020,.776,-1.119,.539,-.159)*f15_2+\n    mat4(.495,-.294,.285,-1.005,-.471,.409,-.130,.714,.170,-.304,.316,-.246,-.612,.044,.179,.389)*f15_3+\n    mat4(-.026,.183,-.567,-.279,-.067,-.145,-.295,.169,-.090,.238,.016,-.099,.683,-.506,.115,-.352)*f15_4+\n    mat4(.357,-.316,.138,-.416,.247,-.538,-.031,-.268,-.112,.342,-.114,.262,-.818,.177,.047,.516)*f15_5+\n    mat4(-.027,.207,.705,-.331,-.259,.237,.292,-.392,.094,-.723,.097,-.182,-.574,.602,-.259,.334)*f15_6+\n    mat4(-.544,-.004,-.099,-.086,-.364,-.009,-.033,-.167,.197,-.719,-.944,.973,-.024,.107,-.010,-.168)*f15_7+\n    vec4(.268,.550,.669,-.606))/4.0+f15_3;\nvec4 f16_4=sin(mat4(-.220,-.261,-.490,-.666,.623,.280,.846,.050,.142,.111,.194,.565,.197,.040,.290,.145)*f15_0+\n    mat4(.065,-.121,.144,-.004,.047,-.128,.255,.693,-.073,-.124,-.354,.536,-.018,.295,.039,.208)*f15_1+\n    mat4(.769,.868,1.411,.202,-.696,-.635,-1.071,-.127,.470,.494,.772,.108,.101,.198,.275,-.859)*f15_2+\n    mat4(.087,.227,.072,.411,-.045,.035,-.035,-.125,-.106,.224,-.143,.132,.028,-.092,.094,-.023)*f15_3+\n    mat4(-.604,-.593,-1.150,-.414,-.691,-.775,-1.299,-.819,-.708,-.795,-1.242,-.060,-.042,.004,-.039,-.604)*f15_4+\n    mat4(-.043,.035,-.078,-.498,-.136,.106,.077,-.280,-.015,-.002,-.020,.438,.282,.080,.090,.039)*f15_5+\n    mat4(-.371,.153,-.251,.111,-.243,.039,-.493,.092,-.057,.252,.114,-.680,.013,-.230,-.312,.847)*f15_6+\n    mat4(-.432,-.350,-.683,-.711,.137,-.161,.028,.398,.543,.397,.822,.052,.161,.032,.060,.208)*f15_7+\n    vec4(.455,.156,.283,-1.422))/4.0+f15_4;\nvec4 f16_5=sin(mat4(-.629,-.986,-.716,-.366,.555,-.887,-.465,-.197,-.645,-.025,-.498,.340,-.096,.486,.222,.099)*f15_0+\n    mat4(.572,-.085,-.108,-.010,-.226,-.135,-.166,.652,.346,.202,.223,.527,.301,.346,.256,.172)*f15_1+\n    mat4(-.270,.837,.236,.576,.158,-.171,.249,.147,.134,.181,-.280,-.247,-.304,.255,.154,-.746)*f15_2+\n    mat4(.135,.534,.505,-.225,-.618,-.559,-.612,.234,.428,.450,.383,-.005,.340,-.511,-.659,-.211)*f15_3+\n    mat4(.460,-.048,.119,.140,-.102,-.959,-.799,-.490,-.297,.008,-.051,-.314,-.127,.070,.456,-.535)*f15_4+\n    mat4(-.091,.048,.133,-.531,-.486,.190,-.004,-.027,-.391,-.030,-.066,.280,-.719,-.317,-.941,.024)*f15_5+\n    mat4(-.589,.883,.434,.255,-.680,.683,.322,.226,.379,.354,.247,-.240,-.069,-.205,-.399,.631)*f15_6+\n    mat4(.106,.100,.160,-.025,-.141,-.004,-.577,.195,.276,-1.161,-.818,-.508,.527,.414,.463,.171)*f15_7+\n    vec4(-.451,-.010,-1.381,.841))/4.0+f15_5;\nvec4 f16_6=sin(mat4(.080,.564,-.375,-.390,1.212,.035,-.208,-.155,-.532,.435,.051,-.028,-.009,-.239,.359,.100)*f15_0+\n    mat4(.557,-.204,-.038,.094,-.025,.044,-.259,.592,.207,-.146,-.229,.732,.126,-.171,.332,-.006)*f15_1+\n    mat4(-.943,.009,.272,-.407,.275,-.323,-.314,.283,.285,.024,.574,-.407,.059,-.213,.308,-1.074)*f15_2+\n    mat4(-.220,-.343,-.179,-.256,.075,.267,-.473,.152,-.486,-.001,.426,.054,.206,.361,-.404,.053)*f15_3+\n    mat4(.054,-.344,-.130,.524,.374,.161,-.661,-.156,-.301,.133,-.186,.135,-.019,-.175,.379,-.616)*f15_4+\n    mat4(-.026,-.063,.282,-.281,-.261,.029,.165,-.487,-.164,.089,-.151,.243,-.044,.204,-.402,.354)*f15_5+\n    mat4(-1.155,.369,.034,-.131,-1.079,.260,.162,-.020,.014,-.118,.234,-.560,.169,.211,-.102,.869)*f15_6+\n    mat4(-.310,-.079,-.261,-.047,.229,.042,-.240,.244,1.196,-.124,-.059,-.224,.153,-.213,.192,.086)*f15_7+\n    vec4(-.808,.164,1.107,1.200))/4.0+f15_6;\nvec4 f16_7=sin(mat4(-.516,.600,-.117,-.284,-.718,.788,.752,-.083,-.450,-.469,-.162,-.378,.071,-.346,-.020,-.752)*f15_0+\n    mat4(-.165,.343,.449,.439,-.290,.005,-.032,-.227,.095,.012,-.016,.297,.123,-.045,.149,-.541)*f15_1+\n    mat4(-.176,-.868,-.249,-.819,.567,.135,-.175,.944,-.343,-.343,.296,-.621,.097,-.494,.057,-.197)*f15_2+\n    mat4(.358,-.303,.018,.256,-.150,.493,.021,-.291,.193,-.240,-.222,-.319,-.383,.621,.239,-.351)*f15_3+\n    mat4(.488,.130,-.289,.118,.127,.584,-.184,.071,.456,.255,-.367,.589,.182,-.284,-.086,.184)*f15_4+\n    mat4(.246,.105,-.007,.299,-.036,-.553,-.188,.245,.104,-.134,-.154,-.480,-.343,.611,-.098,-.413)*f15_5+\n    mat4(-.069,-1.227,-.590,-.243,-.153,-.440,-.703,-.541,.104,-.450,.221,-.016,-.296,.298,.021,-.304)*f15_6+\n    mat4(.421,.190,-.284,-.159,-.116,.025,.135,.064,-.342,.719,1.067,-.008,.153,-.155,.039,.037)*f15_7+\n    vec4(.558,-1.395,2.644,.805))/4.0+f15_7;\nfloat f_0=dot(f16_0,vec4(.024,.011,.043,.002))+\n    dot(f16_1,vec4(-.014,.044,.011,-.015))+\n    dot(f16_2,vec4(.043,-.039,-.002,-.040))+\n    dot(f16_3,vec4(-.024,.042,-.012,.013))+\n    dot(f16_4,vec4(-.037,-.024,-.031,-.037))+\n    dot(f16_5,vec4(-.030,-.007,.018,.055))+\n    dot(f16_6,vec4(.007,.016,-.027,.037))+\n    dot(f16_7,vec4(-.023,.014,.001,-.016))+\n    0.492;\nfloat f_1=dot(f16_0,vec4(.037,-.028,.032,-.009))+\n    dot(f16_1,vec4(-.019,.038,.021,-.019))+\n    dot(f16_2,vec4(-.014,.012,-.036,-.048))+\n    dot(f16_3,vec4(-.028,.043,-.008,.007))+\n    dot(f16_4,vec4(.015,.026,.024,-.034))+\n    dot(f16_5,vec4(-.023,-.009,.020,.048))+\n    dot(f16_6,vec4(.018,.036,-.035,.044))+\n    dot(f16_7,vec4(.006,.013,-.039,-.017))+\n    0.490;\nfloat f_2=dot(f16_0,vec4(.030,.038,.008,-.011))+\n    dot(f16_1,vec4(.017,.039,.025,-.012))+\n    dot(f16_2,vec4(-.046,.011,-.016,-.042))+\n    dot(f16_3,vec4(-.027,.042,-.029,.021))+\n    dot(f16_4,vec4(.005,.022,.000,-.039))+\n    dot(f16_5,vec4(-.018,-.024,.011,.045))+\n    dot(f16_6,vec4(-.040,-.022,-.029,.050))+\n    dot(f16_7,vec4(-.014,.025,.043,-.008))+\n    0.455;\n    \n#else\n//smaller model 20x20 loss ~= .003\nvec4 f0_0=sin(ft_0*vec4(-.245,.460,-.026,.081)+ft_1*vec4(-.735,-.205,.014,-.672)+ft_2*vec4(-2.731,-.842,.948,-1.421)+ft_3*vec4(.032,1.867,1.867,1.984)+ft_4*vec4(-.400,-1.653,1.133,.690)+vec4(-3.336,-2.074,1.182,.243));\nvec4 f0_1=sin(ft_0*vec4(.031,.498,.181,.069)+ft_1*vec4(.723,-.433,-.316,.553)+ft_2*vec4(2.755,-.477,-.485,-.730)+ft_3*vec4(.297,-.167,-.138,.404)+ft_4*vec4(-1.609,-2.036,-1.087,1.547)+vec4(2.389,-3.663,-2.320,1.435));\nvec4 f0_2=sin(ft_0*vec4(-.183,.026,-.071,.483)+ft_1*vec4(-.329,.575,-.254,.317)+ft_2*vec4(1.427,2.353,-2.967,1.402)+ft_3*vec4(-.862,1.058,.255,.472)+ft_4*vec4(-.753,-.645,.760,2.185)+vec4(-.330,3.068,.328,4.043));\nvec4 f0_3=sin(ft_0*vec4(-.059,-.688,-.410,-.020)+ft_1*vec4(.082,.301,-.234,.366)+ft_2*vec4(1.342,.982,1.360,-.662)+ft_3*vec4(-.361,-2.354,-1.993,-.221)+ft_4*vec4(1.944,.872,1.873,-2.600)+vec4(4.379,.470,3.367,-4.171));\nvec4 f0_4=sin(ft_0*vec4(-.098,.616,.112,-.183)+ft_1*vec4(.205,.034,-.279,-.178)+ft_2*vec4(-.636,-.586,.074,-1.941)+ft_3*vec4(-.297,2.140,-.113,-1.083)+ft_4*vec4(2.459,.695,2.045,-.946)+vec4(2.742,-3.864,2.056,3.527));\nvec4 f1_0=sin(mat4(.467,-.243,-.046,-.424,.580,.033,-.151,.182,-.279,-.280,-.326,-.216,-.328,-.287,-.465,-.222)*f0_0+\n    mat4(.732,-1.250,-1.248,-1.001,.055,-.261,-.019,-.307,.188,.489,.144,-.328,.126,-.524,-.676,-.372)*f0_1+\n    mat4(-.083,.073,.447,.057,-.265,.047,-.146,-.569,.924,-.354,-.987,-.140,.210,-.532,-.011,.318)*f0_2+\n    mat4(.234,.129,.277,.300,-.111,.067,.068,.345,.076,-.271,-.446,-.048,.046,.064,.275,-.294)*f0_3+\n    mat4(-.564,.053,.711,.304,-.289,.523,-.109,.231,-.706,-.298,.573,.205,.213,-.442,.276,.258)*f0_4+\n    vec4(.496,-.480,-.841,-1.592))/1.0+f0_0;\nvec4 f1_1=sin(mat4(-.242,.241,.101,-.273,.239,.186,.061,.289,.040,.011,-.729,-.163,-.162,.298,.205,-.617)*f0_0+\n    mat4(-1.512,-.085,1.017,-.072,-.186,-.547,-.150,-.107,.030,.060,-.136,-.407,-.628,-.028,-.090,-.485)*f0_1+\n    mat4(-.032,.068,.293,.218,.062,.020,.276,.494,.137,.153,.442,-.502,-.369,-.163,-.335,-.496)*f0_2+\n    mat4(-.235,.283,-.231,.340,.046,.019,.047,.624,.029,.048,.011,.497,.214,.595,.349,-.242)*f0_3+\n    mat4(.856,.293,-.242,-.203,-.231,.033,-.395,-.176,.291,-.140,-.087,.102,.040,-.734,-.466,-.178)*f0_4+\n    vec4(-1.282,-.556,-.420,-.908))/1.0+f0_1;\nvec4 f1_2=sin(mat4(-.089,-.030,.090,-.198,-.253,-.067,.093,-.284,-.183,.192,-.157,-.545,-.356,-.062,.249,-.500)*f0_0+\n    mat4(-.666,.391,.294,-.548,.275,.102,-.026,.138,-.191,-.448,.090,-.571,-.249,-.258,-.094,.054)*f0_1+\n    mat4(.212,.246,.219,-.363,.821,-.735,-.109,-.061,.099,.054,.560,.155,-.050,.230,.325,-.227)*f0_2+\n    mat4(-.322,.199,.531,.053,-.152,-.818,-.034,-.853,.177,.441,-.224,.672,.443,-.008,-.424,.024)*f0_3+\n    mat4(-.385,.587,-.116,.042,-.611,.007,.024,.590,.487,-.178,-.051,.299,-.219,.179,.302,-.749)*f0_4+\n    vec4(.115,-1.710,-.580,-1.529))/1.0+f0_2;\nvec4 f1_3=sin(mat4(-.323,-.096,-.666,.460,-.668,-.575,-.477,.443,-.234,-.395,-.060,.124,.001,.627,.258,-.325)*f0_0+\n    mat4(-.823,-.826,-.209,.227,.160,.008,.337,-.001,.295,-.142,-.803,.099,-.211,.024,-.281,.080)*f0_1+\n    mat4(.010,-.238,-.360,.257,-.317,-.199,.011,-.367,-1.297,-.396,.369,-1.121,.135,.705,.446,-.190)*f0_2+\n    mat4(-.024,.211,-.076,.299,-.093,.625,-.462,-.420,-.289,.229,-.234,-.443,-.122,-.107,.025,.001)*f0_3+\n    mat4(.513,.315,.533,-.389,-.635,.635,-.354,.733,.221,.230,.027,-.500,.407,.431,-.691,.536)*f0_4+\n    vec4(-.787,-1.006,-1.054,.408))/1.0+f0_3;\nvec4 f1_4=sin(mat4(.616,.312,-.044,-.516,.441,.112,-.230,-.934,-.212,-.263,-.420,.032,-.190,.170,-.220,.835)*f0_0+\n    mat4(-.026,-.125,.700,.129,-.014,-.141,.109,.542,-.414,-.063,-.211,.049,.314,.262,.048,-.180)*f0_1+\n    mat4(-.464,-.092,-.316,.019,.698,.308,-.005,-.887,.891,-.001,.994,.312,.405,-.777,.098,.485)*f0_2+\n    mat4(-.132,-.394,-.135,-.241,-.182,.509,-.691,-.033,.043,-.185,.609,-.157,-.253,.169,-.078,.017)*f0_3+\n    mat4(.101,-.130,.298,-.001,.364,.217,-.150,-.603,-.098,.117,.372,-.098,-.836,-.084,-.383,.498)*f0_4+\n    vec4(-.776,.816,-.911,1.328))/1.0+f0_4;\nvec4 f2_0=sin(mat4(.322,.724,.383,.448,-.026,-.468,-.035,.213,-.353,.247,.530,-.126,.752,.384,-.139,-.440)*f1_0+\n    mat4(.681,-.416,.046,.213,.128,-.133,-.469,-.622,.097,-.072,.149,.003,.216,-.218,-.458,-.708)*f1_1+\n    mat4(-.176,-.222,-.031,.061,-.313,-.354,.086,-.704,.158,-.238,.101,-.079,.214,.146,-.301,.477)*f1_2+\n    mat4(.103,-.278,-.118,-.216,-.304,.265,.188,.129,.162,-.124,.411,.314,-.344,.385,-.075,-.166)*f1_3+\n    mat4(-.126,-.712,.156,-.023,-.148,-.566,.106,.403,-.060,-.194,.464,-.296,-.555,.192,-.318,.345)*f1_4+\n    vec4(.032,.913,.059,.724))/1.4+f1_0;\nvec4 f2_1=sin(mat4(-.099,-.386,.345,-.729,.031,.179,-.325,.342,-.123,.376,-.402,-.244,-.245,-.059,.366,.445)*f1_0+\n    mat4(-.311,-.454,.271,-.493,-.074,.242,.205,.011,-.303,.273,.398,.291,.272,-.009,.450,.093)*f1_1+\n    mat4(.189,-.451,-.408,-.006,-.774,.026,-.707,-.049,-.707,.305,.064,.527,.008,.422,.072,.142)*f1_2+\n    mat4(.252,-.567,.071,.168,-.346,.119,-.097,.002,.274,-.542,-.045,-.162,.152,-.344,.443,.019)*f1_3+\n    mat4(-.034,-.556,.262,-.178,.257,.628,-.407,-.179,-.603,-.021,-.166,.175,.263,.513,-.544,.466)*f1_4+\n    vec4(.551,.439,.009,-1.130))/1.4+f1_1;\nvec4 f2_2=sin(mat4(-.246,-.134,.060,-.052,.057,.257,.345,-.201,-.131,.797,.012,.324,.605,-.141,-.495,.066)*f1_0+\n    mat4(.186,-.235,.122,-.205,.083,-.007,-.142,.165,-.123,-.054,.101,.227,-.123,-.742,.044,.362)*f1_1+\n    mat4(-.013,-.083,-.270,-.014,.324,.508,-.243,.014,.845,.241,.239,-.326,.465,-.027,.353,-.455)*f1_2+\n    mat4(-.014,-.022,.641,-.452,-.091,.177,.155,.058,.139,.082,-.274,-.342,-.309,.042,.532,-.238)*f1_3+\n    mat4(-.151,-.120,-.380,.118,.314,.577,.370,.271,.523,.114,-.028,-.398,.544,-.142,.135,.520)*f1_4+\n    vec4(-.508,.146,-.250,-.027))/1.4+f1_2;\nvec4 f2_3=sin(mat4(.179,.093,-.471,.136,-.562,.171,-.140,.120,.501,.428,.009,.179,.343,-.059,-.837,.470)*f1_0+\n    mat4(-.336,.076,-.672,-.148,-.152,.038,.121,-.746,-.275,.585,-.463,-.465,.272,-.277,.461,.063)*f1_1+\n    mat4(-.147,.262,-.119,.031,-.015,.401,-.472,.017,.368,-.578,-.710,.378,-.494,.269,.041,-.635)*f1_2+\n    mat4(-.393,-.015,-.223,-.207,-.645,.827,-.038,-.567,-.439,-.356,-.313,.256,.050,.360,.138,.169)*f1_3+\n    mat4(-.144,-.251,-.393,.263,-.379,-.081,-.034,-.204,-.162,-.245,-.544,.244,-.221,.203,.367,-.801)*f1_4+\n    vec4(.463,-.324,.516,-.096))/1.4+f1_3;\nvec4 f2_4=sin(mat4(.500,.014,-.158,-.287,-.347,-.133,.018,-.072,.201,1.037,-.084,-.082,.350,.175,-.033,-.027)*f1_0+\n    mat4(.106,.430,-.040,-.237,-.282,.022,-.485,.131,.102,.163,-.198,.146,.183,-.690,.066,-.298)*f1_1+\n    mat4(-.345,-.219,.027,.196,-.477,.004,-.354,.305,-.532,-.531,.225,-.143,-.048,.656,.377,.033)*f1_2+\n    mat4(-1.028,-.067,-.744,-.188,-.387,.592,-.406,.006,.325,-.109,.254,.035,-.064,-.100,-.268,.072)*f1_3+\n    mat4(-.648,-.013,.053,.522,.489,-.051,-.054,-.488,-.389,-.103,.490,.195,.146,.652,.423,-.589)*f1_4+\n    vec4(1.491,.333,-.119,-.762))/1.4+f1_4;\nvec4 f3_0=sin(mat4(-.730,.462,-.020,.261,-.127,.052,-.228,.089,.221,-.015,-.375,.405,.314,.361,.070,.463)*f2_0+\n    mat4(-.861,.115,-.037,.293,.078,-.607,-.276,.165,-.401,-.776,-.167,.111,.026,-.457,.244,.025)*f2_1+\n    mat4(.292,.788,-.477,.594,.444,.679,-.321,-.182,.345,-.542,-.262,.265,-.137,-.255,.122,.170)*f2_2+\n    mat4(.924,.111,-.183,.238,-.081,.088,-.123,.260,-.041,.577,.021,-.699,.199,-.276,.194,.246)*f2_3+\n    mat4(.521,-.426,-.194,.079,-.256,-.293,.154,-.656,.406,-.406,-.801,-.220,-.101,-.718,.012,.016)*f2_4+\n    vec4(-.834,.661,.560,-.089))/1.7+f2_0;\nvec4 f3_1=sin(mat4(.251,-.140,.522,-.096,-.023,-.506,.333,.054,-.588,.147,.702,.136,-.047,-.042,.293,-.215)*f2_0+\n    mat4(.757,.419,.794,-.277,-.269,-.102,-.128,-.152,-.197,-.312,.313,.096,.524,-.078,-.344,.220)*f2_1+\n    mat4(-.016,.338,.018,1.024,-.139,-.254,.108,-.017,-.390,-.190,.366,.141,-.122,.132,.126,.646)*f2_2+\n    mat4(.198,.348,.057,-.369,.036,.451,-.039,.324,.021,-.363,-.027,-.147,.019,.043,.499,-.307)*f2_3+\n    mat4(.060,.147,.295,.281,-.175,.035,-.226,-.709,-.205,-.175,.168,-.233,.066,-.347,-.005,.267)*f2_4+\n    vec4(-.058,-.139,-.366,-.461))/1.7+f2_1;\nvec4 f3_2=sin(mat4(-.439,-.076,-.064,-.285,-.070,.115,-.326,-.410,-.010,-.087,-.716,.168,-.092,.047,-.284,.127)*f2_0+\n    mat4(-.085,.200,.097,.045,-.179,-.607,.053,-.122,.198,.194,.232,-.079,-.020,.036,.147,.196)*f2_1+\n    mat4(.097,.349,-.069,.050,.058,.174,-.112,.103,-.433,.340,.249,-.491,-.188,-.123,.553,-.257)*f2_2+\n    mat4(.441,.143,.475,-.280,-.182,.542,.491,-.555,.196,-.454,.563,.433,.142,.190,-.310,.186)*f2_3+\n    mat4(.253,-.011,-.366,-.167,.186,.230,.050,.041,.082,-.092,.726,.456,-.813,.642,.019,-.643)*f2_4+\n    vec4(.038,.135,-.535,.020))/1.7+f2_2;\nvec4 f3_3=sin(mat4(-.709,-.123,.478,.249,-.217,-.458,.079,-.437,-.260,-.026,.209,-.139,.185,.629,-.156,.522)*f2_0+\n    mat4(-.666,-.138,.046,.059,.004,.277,-.005,.205,.037,.434,.130,.199,.034,-.023,-.304,.108)*f2_1+\n    mat4(.243,-.169,.068,-.156,.344,-.674,-.436,.380,-.118,-.263,-.599,-.165,-.179,.198,.275,.467)*f2_2+\n    mat4(-.089,.162,-.338,.032,-.124,-.105,-.162,.569,.483,-.197,-.163,-.511,-.304,.087,-.292,.140)*f2_3+\n    mat4(.022,-.367,-.409,-.306,-.530,-.417,-.212,-.004,.271,.039,-.375,-.397,.205,-.337,-.206,.348)*f2_4+\n    vec4(-.693,.290,.172,.223))/1.7+f2_3;\nvec4 f3_4=sin(mat4(-.275,.016,-.216,-.230,-.002,.099,.148,-.397,-.282,.236,.049,-.484,-.234,.463,-.211,.056)*f2_0+\n    mat4(-.078,-.597,.367,-.085,.459,.179,.562,.170,-.261,.256,-.242,.611,.326,-.041,-.166,-.055)*f2_1+\n    mat4(-.033,-.259,-.168,-.453,.333,.376,-.233,-.464,.783,.445,.542,.141,.356,-.077,.174,.188)*f2_2+\n    mat4(.083,-.113,-.326,.035,-.022,-.092,-.486,.115,.268,.413,.514,-.263,.213,-.113,-.003,-.039)*f2_3+\n    mat4(.057,.113,.135,-.478,.131,-.124,.102,-.060,.088,.252,.691,-.098,-.302,.406,.280,.505)*f2_4+\n    vec4(-.537,.563,.064,.210))/1.7+f2_4;\nvec4 f4_0=sin(mat4(-.331,-.049,.632,-.059,.328,.749,-.064,.130,.205,.180,.094,-.002,-.176,-.299,-.192,-.355)*f3_0+\n    mat4(.706,-.038,.411,.459,.255,-.376,-.418,-.448,.165,-.260,-.620,.194,.117,.036,.190,.548)*f3_1+\n    mat4(-.376,-.579,-.078,-.234,-.107,.475,-.333,.049,-.168,-.137,-.584,.319,-.091,.336,.387,.448)*f3_2+\n    mat4(-.238,.535,.020,.306,-.213,.392,.121,.411,.286,-.117,-.051,-.091,-.294,.168,.251,.224)*f3_3+\n    mat4(.173,.143,-.465,.601,-.113,.648,-.240,-.544,-.122,.158,-.304,.808,-.383,-.029,.111,.163)*f3_4+\n    vec4(.567,-.088,.378,-1.460))/2.0+f3_0;\nvec4 f4_1=sin(mat4(.797,-.424,-.246,.352,-.263,-.025,.047,.352,.543,.304,.533,.274,.116,-.032,.055,-.189)*f3_0+\n    mat4(.059,-.138,.301,.416,.286,-.497,-.233,.029,-.121,.151,-.124,.737,-.331,.271,-.081,.481)*f3_1+\n    mat4(-.214,-.130,.383,-.177,-.313,-.518,.275,-.240,-.271,.066,.250,.281,.588,.050,-.265,.012)*f3_2+\n    mat4(-.549,-.289,.225,.252,.316,.559,.691,-.418,-.288,-.626,-.513,.136,.120,.388,-.384,.527)*f3_3+\n    mat4(-.784,-.206,-.392,.128,.351,.404,.281,-.253,-.460,.653,-.553,.502,.491,.034,-.249,-.575)*f3_4+\n    vec4(1.297,.555,.387,-.266))/2.0+f3_1;\nvec4 f4_2=sin(mat4(-.548,.132,-.925,.214,-.202,.360,.261,.059,.659,-.381,.157,.315,.137,.114,-.312,-.001)*f3_0+\n    mat4(-.956,.403,-.779,.609,.088,.037,.149,-.590,-.187,.277,-.037,-.335,-.220,.019,.112,-.073)*f3_1+\n    mat4(-.063,.213,-.351,-.631,-.257,.667,.073,-.132,.052,.637,-.079,-.283,.245,.318,-.076,-.113)*f3_2+\n    mat4(-.099,.049,-.219,.244,.112,.592,.015,-.105,-.162,-.090,-.361,.075,-.065,-.107,-.024,.884)*f3_3+\n    mat4(.101,-.013,-.015,-.529,.290,-.195,.635,.330,.199,.220,-.035,-.246,.075,-.374,-.328,-.119)*f3_4+\n    vec4(-.012,-.059,.617,.166))/2.0+f3_2;\nvec4 f4_3=sin(mat4(.126,-.344,-.083,.181,.332,.064,-.151,-.213,-.339,-.097,.394,-.034,.052,-.225,.124,.451)*f3_0+\n    mat4(.452,-.056,-.442,.208,.556,-.341,-.328,-.441,.451,.329,-.123,.249,.032,-.544,.031,-.578)*f3_1+\n    mat4(-.225,.073,-.353,-.208,.116,.345,.008,-.080,.622,-.080,-.368,.175,.364,.642,-.047,-.058)*f3_2+\n    mat4(.825,-.283,-.045,-.081,-.069,.477,.116,.632,.181,-.400,.062,-.319,-.191,-.337,.231,-.286)*f3_3+\n    mat4(.185,.288,-.508,.047,.025,.270,.663,-.254,-.082,-.372,-.702,-.225,.069,.974,-.221,.217)*f3_4+\n    vec4(-.206,-.244,-.282,.023))/2.0+f3_3;\nvec4 f4_4=sin(mat4(.686,-.228,-.124,.179,-.007,-.109,-.026,.250,.149,-.085,-.510,.554,.405,.451,-.410,.229)*f3_0+\n    mat4(.688,.305,-.047,-.313,-.532,-.109,.406,-.356,-.814,.241,-.699,.027,-.347,-.025,-.686,.005)*f3_1+\n    mat4(-.256,-.115,-.123,-.035,-.398,-.229,.434,.036,-.505,-.525,.058,-.105,-.477,-.273,.188,-.725)*f3_2+\n    mat4(-.384,.293,.154,-.474,-.103,-.310,.046,-.181,-.157,-.416,.622,.041,.067,-.267,-.174,.167)*f3_3+\n    mat4(-.568,.237,.051,-.448,.451,-.332,.111,.305,-.018,-.230,.095,-.162,.492,-.049,.600,-.172)*f3_4+\n    vec4(.402,-.192,-.261,.650))/2.0+f3_4;\nvec4 f5_0=sin(mat4(.269,-.283,.248,-.495,.406,.842,-.020,-.033,.452,.363,.209,-.401,-.015,-.482,-.317,-.532)*f4_0+\n    mat4(-.270,.079,.139,-.693,.438,.290,.549,-.215,.224,-.083,.126,-.416,-.234,-.247,.265,-.016)*f4_1+\n    mat4(.048,-.188,-.820,-.137,.536,.314,.003,-.227,-.681,-.097,.225,.167,.054,.145,.021,-.220)*f4_2+\n    mat4(-.017,.096,-.337,.053,-.519,.400,-.307,-.063,.285,-.393,-.365,-.233,.489,-.247,.462,.674)*f4_3+\n    mat4(.051,-.072,-.029,.163,.312,.193,-.036,-.790,.061,.266,-.220,-.282,-.653,.599,.063,.189)*f4_4+\n    vec4(.125,.164,.725,-.528))/2.2+f4_0;\nvec4 f5_1=sin(mat4(.296,-.605,.064,-.005,.508,.018,-.332,-.295,-.265,.046,-.162,-.127,-.205,-.124,.187,.279)*f4_0+\n    mat4(-.343,-.385,-.596,-.715,.099,.146,-.051,-.665,.798,-.091,.141,-.172,.291,.631,-.249,-.359)*f4_1+\n    mat4(-.081,.386,-.412,-.292,.017,.092,-.341,.346,.135,-.452,.138,-.271,-.251,-.894,.795,.110)*f4_2+\n    mat4(.226,.008,-.219,-.406,-.411,-.395,.045,.672,.253,.012,.027,-.024,-.252,-.059,-.497,-.427)*f4_3+\n    mat4(.219,.397,-.147,-.789,.063,-.378,-.327,.349,-.310,.403,.285,-.794,-.116,-.308,.686,.461)*f4_4+\n    vec4(-.406,-.897,-.222,.596))/2.2+f4_1;\nvec4 f5_2=sin(mat4(-.189,-.284,-.311,.685,.326,.255,-.018,.281,.432,.708,-.195,.035,-.079,.208,.255,.034)*f4_0+\n    mat4(-.293,-.597,-.451,.115,.504,.358,-.514,.291,.110,.066,-.102,.086,-.530,.080,-.131,.168)*f4_1+\n    mat4(.476,.359,.499,-.203,.079,.370,-.050,-.066,-.124,-.335,.007,.019,.486,.055,-.002,.369)*f4_2+\n    mat4(.045,.776,.102,-.009,-.624,.135,.126,.087,.165,-.331,-.327,-.262,.022,.161,-.372,-.143)*f4_3+\n    mat4(.172,-.129,.441,.033,.028,.092,-.011,.552,-.001,-.075,-.156,.326,.059,.295,-.524,.136)*f4_4+\n    vec4(-.306,-.089,-.216,.194))/2.2+f4_2;\nvec4 f5_3=sin(mat4(.012,.423,.199,-.040,-.021,-.096,.317,-.277,.145,-.272,.427,-.054,-.712,.378,.283,.341)*f4_0+\n    mat4(-.323,.617,.296,-.096,-.110,.259,-.216,.535,.065,.013,-.175,-.015,.100,-.165,-.358,-.356)*f4_1+\n    mat4(-.604,-.095,-.180,-.198,.231,-.141,-.185,-.448,.095,.538,.331,.853,.160,.380,.277,.758)*f4_2+\n    mat4(-.280,.320,-.014,.501,-.310,.848,.157,-.134,.176,-.226,-.492,-.430,.171,.045,.604,.003)*f4_3+\n    mat4(-.476,-.109,-.519,-.232,.646,-.242,-.289,-.379,.077,.076,.105,-.318,-.138,-.087,-.029,.483)*f4_4+\n    vec4(.459,.286,.403,.331))/2.2+f4_3;\nvec4 f5_4=sin(mat4(-.344,.214,-.033,.035,.050,-.462,-.367,-.499,-.164,.002,-.306,-.070,.026,.467,.234,.624)*f4_0+\n    mat4(-.567,-.101,-.579,-.202,-.282,.150,.232,-.067,-.490,.304,.424,.364,-.210,.520,-.098,.001)*f4_1+\n    mat4(.220,.018,-.279,-.093,.602,-.305,-.078,-.178,-.016,-.047,.542,.422,-.054,-.540,.382,-.318)*f4_2+\n    mat4(.270,.199,-.169,-.414,.045,-.446,.213,.278,-.467,-.192,-.050,.148,.175,.170,.015,-.257)*f4_3+\n    mat4(.414,.050,-.470,.013,.347,.057,.242,.210,-.041,-.088,-1.008,-.239,.171,-.719,.361,-.062)*f4_4+\n    vec4(-.110,.051,.164,.145))/2.2+f4_4;\nvec4 f6_0=sin(mat4(.263,.602,.136,.281,-.202,-.571,.163,.396,-.274,-.180,-.440,.301,-.768,.475,-.526,.557)*f5_0+\n    mat4(.380,.255,-.514,-.008,-.299,.443,-.345,-.267,-.062,.118,-.521,.377,-.235,-.187,-.123,.259)*f5_1+\n    mat4(-.598,-.050,.254,-.101,-.126,-.579,-.264,.083,-.350,.076,-.329,-.487,.095,-.417,-.395,-.240)*f5_2+\n    mat4(-.047,-.103,-.518,.027,.073,-.273,-.636,-.548,.495,-.142,-.286,.251,-.323,.367,.077,-.183)*f5_3+\n    mat4(-.054,-.152,.268,.171,.168,.941,.073,.159,.333,-.497,.577,.084,.125,-.312,-.159,.414)*f5_4+\n    vec4(-.696,.781,-.696,.306))/2.4+f5_0;\nvec4 f6_1=sin(mat4(.145,.333,.319,-.292,.253,.027,.348,-.104,.093,-.657,-.059,-.174,-.007,-.031,-.122,-.001)*f5_0+\n    mat4(.496,-.144,.413,-.269,.990,.183,.466,.316,.550,-.542,-.074,-.493,.467,.146,-.696,-.490)*f5_1+\n    mat4(-.284,-.346,-.681,.091,.223,-.341,-.212,-.025,.570,-.496,.889,-.430,.105,.191,.417,.101)*f5_2+\n    mat4(.319,-.119,.076,-.475,-.377,.204,.091,-.585,.104,.352,-.293,-.057,.534,-.041,.005,.121)*f5_3+\n    mat4(-.162,.206,.160,.093,.011,-.555,-.357,-.762,.140,.090,-.057,-.154,-.276,.613,.670,.646)*f5_4+\n    vec4(-.104,.576,1.374,.286))/2.4+f5_1;\nvec4 f6_2=sin(mat4(.178,.093,.676,-.069,.487,.233,-.058,-.397,-.501,-.235,-.435,-.191,.119,-.435,-.235,.207)*f5_0+\n    mat4(.419,-.108,-.039,-.124,.225,.145,.286,.278,-.094,.151,-.535,.326,.615,.228,.089,-.015)*f5_1+\n    mat4(-.222,.199,-.091,-.400,.125,-.546,-.552,-.118,-.242,-.099,-.382,.170,-.238,-.315,.312,-.053)*f5_2+\n    mat4(.840,-.405,-.502,.280,.148,-.145,-.501,.066,.431,.147,.499,-.501,-.197,-.036,.359,-.329)*f5_3+\n    mat4(.033,.341,-.479,.552,.179,-.056,-.479,.038,.225,.277,.362,.172,.126,-.069,.235,.262)*f5_4+\n    vec4(.181,-.097,.579,.120))/2.4+f5_2;\nvec4 f6_3=sin(mat4(-.385,.127,-.052,.230,-.366,-.357,-.157,.117,-.042,-.339,-.195,.207,.154,.383,-.459,.366)*f5_0+\n    mat4(-.148,.143,.657,-.121,.680,-.282,.079,.174,.477,.284,-.353,-.036,.227,-.334,-.481,.216)*f5_1+\n    mat4(.405,-.095,-.218,.614,-.339,-.457,-.276,.184,.386,-.237,.001,.132,.087,.109,.308,-.190)*f5_2+\n    mat4(.017,-.036,.312,-.130,.150,-.695,.248,-.342,.295,.497,-.171,-.518,.344,-.296,.167,.314)*f5_3+\n    mat4(.121,-.378,.171,.270,-.413,.368,-.230,-.056,-.202,-.485,.247,.535,.053,-.031,.469,-.042)*f5_4+\n    vec4(-.718,.664,-.746,.308))/2.4+f5_3;\nvec4 f6_4=sin(mat4(.614,-.242,-.240,-.253,-.047,-.283,.349,-.658,.442,-.417,-.312,-.448,-.514,-.405,-.525,-.315)*f5_0+\n    mat4(.073,.020,-.388,.383,-.458,-.347,-.352,-.461,.587,-.576,-.374,-.150,.448,.204,-.312,.397)*f5_1+\n    mat4(-.736,.219,.563,-.145,.027,.090,-.073,-.444,.172,.318,.212,.008,.264,.006,-.028,-.637)*f5_2+\n    mat4(-.794,-.150,.208,-.266,-.474,.547,.503,-.201,.249,.343,-.175,.128,.392,.024,.065,-.245)*f5_3+\n    mat4(-.572,.365,.117,-.040,.273,.152,.542,.782,.055,.640,-.067,.110,.144,.143,.214,-.595)*f5_4+\n    vec4(1.077,.315,-.219,-.288))/2.4+f5_4;\nvec4 f7_0=sin(mat4(.191,-.396,-.645,-.591,.272,-.803,-.253,-.530,-.199,-.419,-.902,-.654,-.391,.292,-.265,-.853)*f6_0+\n    mat4(.361,-.090,-.539,-.271,-.143,.068,.128,.296,.191,.310,-.127,-.154,.133,.458,.379,-.092)*f6_1+\n    mat4(-.096,-.002,-.192,.355,.251,-.148,-.119,.007,-.163,.374,.731,.474,-.458,-1.027,-.369,.140)*f6_2+\n    mat4(-.810,.011,.043,.096,-.266,-.443,.005,.396,-.302,-.253,.109,-.080,.255,-.253,.053,.243)*f6_3+\n    mat4(-.026,.176,.283,.733,.252,-.206,-.251,.179,-.671,.005,.105,-.114,-.682,-.636,-.109,-.122)*f6_4+\n    vec4(.031,-.643,-.045,-.667))/2.6+f6_0;\nvec4 f7_1=sin(mat4(-.242,-.040,.057,.098,.261,.634,.190,-.423,.044,.541,.357,.322,.415,-.291,-.161,.581)*f6_0+\n    mat4(-.488,.141,.201,.664,-.416,-.437,.072,.051,.040,.410,-.055,.337,.008,.326,-.023,.292)*f6_1+\n    mat4(.399,-.037,-.198,.430,.051,.576,-.058,-.050,-.332,-.407,-.538,.314,-.272,.109,.250,.127)*f6_2+\n    mat4(.483,-.529,-.407,-.689,-.301,.362,-.068,.167,-.107,.125,-.106,.421,-.104,-.103,.725,.620)*f6_3+\n    mat4(.605,-.946,-.293,.108,-.599,.097,-.450,.056,.584,-.080,-.484,.060,.189,.221,.086,-.206)*f6_4+\n    vec4(-.755,-.076,1.138,-.201))/2.6+f6_1;\nvec4 f7_2=sin(mat4(-.117,-.748,.058,-1.055,.422,.153,-.241,.132,-.107,.118,-.544,-.602,-.096,-.385,.041,-.343)*f6_0+\n    mat4(.695,-.083,.360,-.708,.258,-.055,.213,.028,-.713,.325,.375,-.228,.251,.545,.018,.126)*f6_1+\n    mat4(-.187,.687,-.466,.038,.201,.299,.058,.018,-.153,.417,-.320,.338,-.123,-.066,.046,-.165)*f6_2+\n    mat4(.766,.333,.306,.510,-.452,.036,.417,.141,.288,.816,.441,.441,.116,.142,-.284,-.026)*f6_3+\n    mat4(.363,.019,.527,.112,-.413,-.089,.209,.299,.080,.236,.276,.042,.365,-.645,.542,-.083)*f6_4+\n    vec4(.005,-.674,-.372,-.329))/2.6+f6_2;\nvec4 f7_3=sin(mat4(.147,-.795,.403,.474,.289,-.067,.408,.433,.133,-.064,-.077,.071,.133,-.227,-.230,.479)*f6_0+\n    mat4(.641,.090,-.617,.320,-.233,.526,-.491,-.429,-.159,.545,.366,.086,-.435,-.342,.142,-.062)*f6_1+\n    mat4(.210,.052,.255,.243,-.088,.440,.419,-.359,-.448,-.043,-.179,.333,-.208,.565,-.284,-.239)*f6_2+\n    mat4(-.420,-.137,-.185,.118,.173,.299,.266,.207,-.036,-.264,.289,-.270,.041,-.686,.071,-.246)*f6_3+\n    mat4(.111,.284,-.131,.370,.364,.213,.005,-.462,-.199,.020,.327,.378,-.110,-.075,.411,-.080)*f6_4+\n    vec4(-.229,-.242,.214,.024))/2.6+f6_3;\nvec4 f7_4=sin(mat4(.127,.049,.046,-.277,.434,.166,.398,-.381,-.060,.041,.099,-.047,-.040,.728,.070,.160)*f6_0+\n    mat4(.685,-.225,.155,-.094,.303,.194,.690,-.231,.144,-.263,.014,-.281,-.416,.118,.413,-.335)*f6_1+\n    mat4(-.034,.139,-.219,.376,.172,-.039,-.291,-.109,.074,.313,.045,-.004,-.488,-.034,.209,.169)*f6_2+\n    mat4(-.126,.459,-.315,.504,-.161,-.192,.043,-.004,.026,-.235,-.034,-.267,.297,.075,.153,-.522)*f6_3+\n    mat4(.818,-.061,.060,.541,.509,-.228,-.625,-.218,-.232,.235,.487,.162,-.142,-.352,.026,-1.064)*f6_4+\n    vec4(-.668,-.022,-.589,-.277))/2.6+f6_4;\nvec4 f8_0=sin(mat4(-.002,-.252,.000,-.656,.267,-.046,.291,-.395,.125,-.005,.490,-.437,-.692,.115,.318,-1.205)*f7_0+\n    mat4(-.015,.381,-.086,-.253,.360,.057,.211,.049,-.356,.506,.147,.197,-.098,.490,.097,-.034)*f7_1+\n    mat4(-.304,.117,-.063,.146,.019,-.062,-.078,.181,.007,.070,-.469,.457,.015,-.646,.019,-.340)*f7_2+\n    mat4(-.403,-.045,-.044,-.428,.038,-.058,-.543,.414,-.210,-.808,-.429,-.337,.087,-.166,-.505,.243)*f7_3+\n    mat4(-.130,.384,.162,.343,.458,-.521,.241,.090,.130,.146,-.088,.076,.420,.101,-.005,-.404)*f7_4+\n    vec4(.146,-.356,-.007,-.647))/2.8+f7_0;\nvec4 f8_1=sin(mat4(.765,-.183,-.138,.203,.326,-.182,-.392,-.241,-.621,-.090,-.232,-.058,-.447,.320,.564,.254)*f7_0+\n    mat4(.115,-.510,.071,.527,.197,-.445,.026,-.130,.501,.082,.857,-.397,-.263,.410,.461,.244)*f7_1+\n    mat4(.129,-.304,-.418,-.541,.182,.003,-.227,-.721,.571,-.389,.474,.030,-.030,-.547,-.314,.151)*f7_2+\n    mat4(.454,-.827,.423,-.512,.136,-.193,-.285,-.688,-.078,.098,.022,-.410,-.374,.490,-.337,.377)*f7_3+\n    mat4(-.198,-.247,-.045,-.415,.423,.050,.051,.025,.502,.012,.094,.614,.344,.344,-.130,-.508)*f7_4+\n    vec4(-.114,.590,.125,.894))/2.8+f7_1;\nvec4 f8_2=sin(mat4(.538,-.010,-.202,.607,.110,.440,-.249,.151,.200,.251,.146,.078,.137,-.029,-.453,.028)*f7_0+\n    mat4(-.006,.150,-.406,.263,-.718,-.621,.641,-.160,-.426,-.617,.479,-.028,.045,-.871,-.060,.165)*f7_1+\n    mat4(-.278,.133,-.582,-.275,-.573,-.002,.424,-.327,.076,-.189,.125,.226,-.050,.171,-.458,-.289)*f7_2+\n    mat4(-.587,-.278,-.305,-.081,.459,.261,-.035,.197,-.220,.156,.214,.486,-.475,-.276,.286,.462)*f7_3+\n    mat4(-.306,.699,-.167,-.212,-.468,.652,.007,-.061,-.086,.208,-.204,.082,.480,-.250,.125,.621)*f7_4+\n    vec4(.729,-.216,.223,.345))/2.8+f7_2;\nvec4 f8_3=sin(mat4(.280,.761,.429,-.108,.192,-.405,.531,-.333,-.047,.126,-.173,.177,-.860,-.364,.268,.272)*f7_0+\n    mat4(-.064,.303,.101,.256,-.162,.117,-.309,.304,.057,.485,-.497,.782,-.421,-.324,-.467,-.309)*f7_1+\n    mat4(-.114,-.806,-.366,.125,.193,-.268,-.467,.530,-.087,.350,-.752,.483,.560,.463,-.374,.149)*f7_2+\n    mat4(-.091,-.263,-.265,.144,.346,-.453,-.191,.353,.447,.260,.593,.179,.458,.108,-.235,-.786)*f7_3+\n    mat4(-.404,-.227,-.094,.109,.427,.487,-.166,.328,-.166,.214,.248,.057,.346,-.106,-.015,.066)*f7_4+\n    vec4(-.214,.353,.443,-.492))/2.8+f7_3;\nvec4 f8_4=sin(mat4(.228,.126,.070,-.433,.399,.228,.926,.304,.664,-.138,.373,-.130,.416,-.612,-.071,-.220)*f7_0+\n    mat4(-.097,-.226,.195,-.025,-.270,-.220,.635,-.560,-.475,-.424,-.024,.192,-.222,-.631,-.086,-.019)*f7_1+\n    mat4(-.654,-.021,-.478,.693,-.489,.051,.194,-.061,-.034,-.028,.113,.071,.224,.835,.313,.082)*f7_2+\n    mat4(.053,-.354,-.302,.168,.204,.166,.091,-.297,-.159,.355,.262,.205,-.032,.056,.342,-.234)*f7_3+\n    mat4(-.373,-.758,-.054,1.007,.150,.877,-.042,-1.011,-.638,-.322,.679,.428,.215,.990,-.152,.066)*f7_4+\n    vec4(.871,-.239,.552,-.451))/2.8+f7_4;\nvec4 f9_0=sin(mat4(.284,-.323,-.124,-.034,.404,-.385,.306,-.102,.197,-.657,-.200,-.328,.337,-.678,.436,.217)*f8_0+\n    mat4(.141,.045,-.868,.161,-.323,-.059,.048,.174,-.884,-.190,.134,.355,-.003,-.470,.069,-.294)*f8_1+\n    mat4(-.460,.288,.117,-.008,.204,-.196,.146,.323,.061,.491,-.091,.128,-.072,-.332,.079,.712)*f8_2+\n    mat4(.283,-.325,-.523,.707,.137,.815,-.119,.065,-.559,.035,-.981,-.092,-.464,-.129,-.171,-.522)*f8_3+\n    mat4(-.159,.395,.343,.573,-.151,.018,-.417,-.506,.629,-.030,.114,.458,.464,-.399,.106,-.303)*f8_4+\n    vec4(-.443,-.539,.596,-.357))/3.0+f8_0;\nvec4 f9_1=sin(mat4(-.014,-.125,-.291,-.343,-.329,.026,.590,-.271,-.147,.112,-.173,.821,-.435,-.638,-.152,.751)*f8_0+\n    mat4(.172,-.705,.688,.614,.303,.229,.301,.415,.499,-.380,-.598,.334,-.431,.093,-.250,-.328)*f8_1+\n    mat4(-.066,-.013,.140,.289,-.012,-.101,-.084,.060,.240,-.765,.282,-.082,.390,-.408,-.527,-.351)*f8_2+\n    mat4(-.174,.241,-.330,.527,.690,-.178,.748,.431,-.557,.203,-.077,-.643,-.234,.142,.144,-.083)*f8_3+\n    mat4(.366,-.680,.665,.296,.500,-.313,-.272,.044,-.295,-.455,.173,-.284,.071,-.403,.171,-.418)*f8_4+\n    vec4(.466,.414,-1.002,-.100))/3.0+f8_1;\nvec4 f9_2=sin(mat4(-.208,.614,.092,.387,-.373,.632,.104,-.048,-.024,.077,.225,-.238,-.443,-.452,-.467,-.650)*f8_0+\n    mat4(-.410,.491,.514,.434,-.235,-.515,.779,-.389,.235,-.566,.552,-.384,-.083,-.155,-.104,.254)*f8_1+\n    mat4(.366,-.065,-.028,-.675,.859,.226,-.175,-.409,.284,.346,.193,-.032,-.289,.278,-.081,.002)*f8_2+\n    mat4(.196,.312,-.679,-.246,-.350,.648,.008,-.493,-.520,.027,-.147,-.053,-.254,-.337,.014,.475)*f8_3+\n    mat4(.304,-.440,.140,-.225,.142,-.220,-.383,.172,-.285,.312,.054,.530,.275,.534,.240,-.052)*f8_4+\n    vec4(.364,.786,.650,.212))/3.0+f8_2;\nvec4 f9_3=sin(mat4(-.276,-.053,-.123,.125,-.348,-.517,-.290,.560,-.518,-.676,-.736,.171,-.070,-.623,.080,.611)*f8_0+\n    mat4(-.426,.103,.701,-.564,-.000,.653,.316,.045,.648,.289,.189,-.193,.230,.553,.407,.311)*f8_1+\n    mat4(.332,.010,.094,.471,-.232,-.293,-.244,-.347,.292,.568,.365,.076,-.325,-.043,.281,.961)*f8_2+\n    mat4(-.133,-.055,.118,.202,.393,-.625,-.059,.143,-.145,.120,.758,.233,-.430,.468,.414,.648)*f8_3+\n    mat4(.423,.637,-.058,-.120,-.243,.583,-.029,-.151,-.078,.605,.175,.115,-.060,-.311,-.368,.364)*f8_4+\n    vec4(-.503,-.571,.011,-.014))/3.0+f8_3;\nvec4 f9_4=sin(mat4(-.017,-.361,.213,-.360,.213,.189,-.459,-.005,.391,-.642,.242,.652,.041,-.760,.087,-.023)*f8_0+\n    mat4(-.138,.021,-.079,-.028,.118,-.308,-.205,.038,.500,.236,-.269,.067,.449,.031,-.205,-.310)*f8_1+\n    mat4(.175,-.400,-.351,-.109,.759,.142,.165,-.043,-.359,.348,.320,-.570,.105,-.503,.165,-.226)*f8_2+\n    mat4(.155,-.014,.295,-.306,-.697,.360,-.006,-.028,-.429,.243,.183,.100,-.194,.362,.868,.289)*f8_3+\n    mat4(-.245,.230,-.408,-.360,-.380,.291,.164,.346,.240,.251,-.623,.006,.254,.374,.027,.049)*f8_4+\n    vec4(-.587,-1.291,1.229,.466))/3.0+f8_4;\nvec4 f10_0=sin(mat4(.086,-.079,.414,.215,.051,.148,.215,-.152,.214,.169,-.070,-.514,.231,.567,.487,.192)*f9_0+\n    mat4(.087,-.367,-.372,.182,.241,-.213,.590,-.004,-.132,.541,.640,-.260,-.507,.379,.138,-.138)*f9_1+\n    mat4(.046,-.377,.036,-.541,.159,.203,.214,-.107,-.564,-.079,-.267,-.042,-.135,.223,-.068,-.526)*f9_2+\n    mat4(.186,.138,-.078,.609,-.290,.126,-.372,.606,.579,.326,-.837,-.179,-.140,.515,-.358,-.453)*f9_3+\n    mat4(.376,.267,.124,.302,-.660,.202,.715,-.370,-.230,-.362,.013,-.236,.330,.597,-.690,-.842)*f9_4+\n    vec4(.756,-.131,-1.287,-.153))/3.2+f9_0;\nvec4 f10_1=sin(mat4(.105,-.712,-.318,.352,.076,.329,.639,.130,-.607,.327,.274,.159,.048,-.541,.103,.299)*f9_0+\n    mat4(-.911,-.263,-.301,.214,-.197,-.187,.123,-.235,-.217,-.631,-.170,-.860,.229,.286,.113,-.701)*f9_1+\n    mat4(.015,.337,.658,-.439,.097,.639,.507,-.129,-.387,.204,-.364,-.122,-.201,.228,.205,.567)*f9_2+\n    mat4(.720,-.188,-.191,-.256,-.554,.518,.136,.297,-.162,-.284,-.074,-.078,.414,-.109,-.340,.558)*f9_3+\n    mat4(.281,.420,.453,-.500,-.217,.635,.329,-.505,.118,.340,-.462,-.588,.390,.509,-.041,-.062)*f9_4+\n    vec4(.300,-.776,-.628,.519))/3.2+f9_1;\nvec4 f10_2=sin(mat4(.423,-.763,.063,-.466,-.051,.383,.198,.332,-.344,-.094,-.129,.064,.561,-.145,.458,-.033)*f9_0+\n    mat4(.119,.237,.301,.289,.209,.149,-.445,.199,.197,-.274,.188,-.433,-.047,-.377,.117,.561)*f9_1+\n    mat4(-.425,.445,-.156,.034,-.183,.684,-.196,.172,-.330,-.072,-.053,-.220,-.243,-.262,.288,-.680)*f9_2+\n    mat4(.265,.336,.411,-.441,.705,.633,-.312,.322,-.280,.579,.260,.127,-.159,.102,.427,.275)*f9_3+\n    mat4(-.521,.174,-.240,.104,-.548,.653,.103,-.581,.165,-.133,-.987,.394,-.121,-.519,-.242,.076)*f9_4+\n    vec4(.933,.012,.742,-.344))/3.2+f9_2;\nvec4 f10_3=sin(mat4(.184,-.210,-.021,.016,.113,-.433,-.423,-.556,-.535,-.637,-.037,-.673,.188,-.176,-.331,.052)*f9_0+\n    mat4(.147,-.183,.612,.027,-.268,.161,-.545,.160,.123,.509,.103,-.187,.363,.881,-.119,.183)*f9_1+\n    mat4(-.288,.182,.701,-.195,-.283,-.741,-.503,-.428,.018,.406,.352,.379,-.069,-.671,-.540,.445)*f9_2+\n    mat4(.413,.090,.138,-.525,.151,-.404,.013,.052,.373,-.033,-.520,-.054,.205,-.024,-.552,-.697)*f9_3+\n    mat4(-.446,-.333,-.225,-.265,.142,-.200,.804,-.603,.144,-.672,.111,.059,.633,-.193,-.195,.099)*f9_4+\n    vec4(-.044,.460,-.186,-.579))/3.2+f9_3;\nvec4 f10_4=sin(mat4(.302,-.011,-.237,.158,.064,.122,.108,-.254,.261,-.592,-.135,-.278,.936,-.114,.472,-.129)*f9_0+\n    mat4(.670,.527,-.503,.396,.259,.048,.513,.262,.024,.007,-.381,-.030,-.108,.266,.686,.132)*f9_1+\n    mat4(-.243,-.324,.052,-.142,.494,-.079,-.506,-.185,-.146,.357,-.232,.186,.133,.552,-.295,.422)*f9_2+\n    mat4(-.170,-.590,-.018,-.628,-.148,-.453,-.524,-.493,.068,.016,-.206,.267,.483,.501,.032,.120)*f9_3+\n    mat4(-.584,-.229,.562,.058,-.157,.068,-.346,.157,-.131,.820,-.477,-.453,.079,-.008,-.441,.906)*f9_4+\n    vec4(-.308,-.846,-.073,.174))/3.2+f9_4;\nvec4 f11_0=sin(mat4(.172,-.001,.375,-.293,-.559,-.097,-.780,-.846,-.072,-.928,-.789,.198,-.339,.144,-.522,.804)*f10_0+\n    mat4(.014,-.326,.503,.014,.013,.170,-.180,-.342,-.569,.420,-.658,-.008,-.032,-.314,-.772,.047)*f10_1+\n    mat4(-.383,.561,.020,.362,-.059,-.601,.078,-.327,-.646,.226,-.243,.167,.262,.447,-.157,-.484)*f10_2+\n    mat4(-.621,.069,-.639,.668,.806,-.328,.431,-.244,.625,.259,.051,.419,.134,.289,-.424,-.174)*f10_3+\n    mat4(.050,.083,-.163,-.169,.208,.337,.569,-.182,-.370,.325,.422,-.300,.487,-.263,-.018,-.126)*f10_4+\n    vec4(.677,-.706,.462,.572))/3.3+f10_0;\nvec4 f11_1=sin(mat4(.042,.014,.175,.203,-.565,.169,.050,.326,-.136,.327,.794,.158,-.369,-.614,.636,-.183)*f10_0+\n    mat4(-.254,.820,.152,.071,.441,-.234,-.411,.029,.226,.473,-.321,-.579,.712,.623,-.015,-.494)*f10_1+\n    mat4(.120,-.393,.556,-.274,-.474,.256,.111,-.234,.201,.066,-.354,.554,.133,-.117,-.365,.338)*f10_2+\n    mat4(.069,-.197,.886,-.004,-.501,.097,-.542,.240,.515,.373,-.630,-.574,.686,.321,-.434,.416)*f10_3+\n    mat4(-.294,-.092,-.412,.167,-.131,-.672,-.271,.326,-.188,.464,.032,.049,-.362,-.197,-.220,.502)*f10_4+\n    vec4(.832,-.951,-.382,.843))/3.3+f10_1;\nvec4 f11_2=sin(mat4(-.096,-.224,.151,.571,-.168,.800,.720,-.300,-.064,-.379,-.896,-.114,-.184,-.206,.186,.307)*f10_0+\n    mat4(.251,.366,.453,.231,-.182,-.245,-.150,.185,.155,-.064,-.290,.234,-.646,-.203,-.115,-.706)*f10_1+\n    mat4(.732,.624,-.312,-.201,.013,-.267,-.654,-.367,-.202,.241,-.007,-.136,-.672,-.004,.339,.171)*f10_2+\n    mat4(-.780,-.020,-.512,.378,.110,.402,.020,-.136,.011,-.500,.139,.305,.467,-.657,.185,.218)*f10_3+\n    mat4(.293,.831,-.096,.436,.005,-.119,-.188,-.949,-.159,.203,.498,-.209,.535,-.338,.355,.411)*f10_4+\n    vec4(.351,-1.906,.118,.702))/3.3+f10_2;\nvec4 f11_3=sin(mat4(-.271,.277,.088,-.149,.593,.074,-.288,-.389,-.228,.985,.115,-.045,-.306,.568,.319,.235)*f10_0+\n    mat4(-.682,.180,.286,.681,.457,-.402,-.487,.401,-.412,.276,-.066,.039,.194,-.655,.215,.127)*f10_1+\n    mat4(.102,-.027,.376,-.289,.269,.132,-.191,-.127,.000,-.351,-.386,.229,-.465,-.055,.125,.391)*f10_2+\n    mat4(.338,.509,.302,.226,-.411,.350,.467,.186,.156,-.468,-.108,-.593,.306,-.447,-.161,.162)*f10_3+\n    mat4(.107,-.672,-.073,-.253,-.494,.097,-.670,.055,.225,-.701,.378,-.548,-.010,.349,-.329,.517)*f10_4+\n    vec4(-.421,1.497,-1.204,1.062))/3.3+f10_3;\nvec4 f11_4=sin(mat4(.400,-.197,-.493,.142,-.151,-.915,-.657,.524,-.421,-.151,.184,.127,.094,-.232,-.032,.092)*f10_0+\n    mat4(.463,.295,.286,-.248,-.321,.332,-.463,-.685,.158,.160,.597,-.390,-.912,.562,.053,.570)*f10_1+\n    mat4(-.085,-.772,.788,-.262,-.508,-.327,.240,-.211,-.024,.460,-.063,-.481,.544,.000,.521,-.348)*f10_2+\n    mat4(-.541,-.135,-.166,-.289,.883,.194,-.332,-.008,-.136,.377,.090,-.610,-.452,.484,-.305,.135)*f10_3+\n    mat4(-.401,-.321,.220,-.523,.766,.825,.487,-.388,-.509,.211,.522,-.173,-.458,.476,.332,.725)*f10_4+\n    vec4(.880,.370,.365,-1.002))/3.3+f10_4;\nvec4 f12_0=sin(mat4(.085,.322,.200,.532,-.245,-.513,.810,.582,-.759,.124,.168,.195,-.035,.767,-.004,.713)*f11_0+\n    mat4(-.378,.480,.751,-.452,.820,.111,.148,-.108,.806,-.194,-.196,-.005,-.151,-.038,-.314,-.107)*f11_1+\n    mat4(-.237,-.178,-.206,-.536,-.009,.188,.373,.351,.683,.220,.298,-.382,.456,.070,.064,-.089)*f11_2+\n    mat4(.782,-.226,-.563,.884,-.497,.540,.443,-.003,.326,.357,.003,.249,-.567,-.101,.426,.369)*f11_3+\n    mat4(.191,-.606,-.088,-.190,-.004,.319,.499,-.892,.877,.020,.164,-.140,.140,-.815,.646,.137)*f11_4+\n    vec4(-1.390,-.447,-.286,-.116))/3.5+f11_0;\nvec4 f12_1=sin(mat4(.214,-.088,-.772,-.126,.139,-.156,-.259,.252,-.400,-.417,-.234,.322,-.256,-.334,-.233,-.532)*f11_0+\n    mat4(-.233,-.110,-.170,-.887,.335,-.180,-.299,-.435,.512,.291,.144,-.295,.805,-.086,-.141,.299)*f11_1+\n    mat4(-.174,-.280,.769,-.198,-.394,-.609,.320,.054,.250,.462,.512,-.046,-.372,-.461,.234,-.242)*f11_2+\n    mat4(.071,-.017,-.025,-.339,-.412,.652,.542,-.470,.048,.451,.393,-.530,.020,-.363,-.158,.329)*f11_3+\n    mat4(.141,.077,-.033,.259,-.429,.756,1.033,.074,.833,.233,-.336,.152,.416,.632,-.168,-.085)*f11_4+\n    vec4(-.784,-.630,.016,.269))/3.5+f11_1;\nvec4 f12_2=sin(mat4(.377,-.462,.007,-.305,.491,-.941,.308,.412,-.239,-.425,.185,-.107,-.384,-.351,-.524,-.006)*f11_0+\n    mat4(1.390,.640,-.411,.157,.159,.438,.599,-.443,.048,.582,.591,-.189,-.151,.437,.399,.651)*f11_1+\n    mat4(.556,.063,-.120,.336,-.265,-.506,.360,-.282,.701,.160,-.119,.090,-.128,.144,.722,-1.191)*f11_2+\n    mat4(.802,.058,-.056,-.155,.136,-.151,-.568,.154,-.214,.427,.516,.109,-1.027,.095,.578,.016)*f11_3+\n    mat4(-.385,-.175,-.252,.163,.070,.810,-.010,.140,.559,.362,-.184,.495,.512,-.589,.211,-.279)*f11_4+\n    vec4(-.060,-1.469,-.775,-.672))/3.5+f11_2;\nvec4 f12_3=sin(mat4(.098,-.093,-.320,.579,.007,.071,.108,-.069,-.022,-.039,-.619,.190,-.344,.609,-.428,.397)*f11_0+\n    mat4(-.579,.602,-.406,-.154,.763,.174,.223,.363,.327,.230,-.069,-.417,-.968,.505,-.389,-.177)*f11_1+\n    mat4(-.236,-.727,-.119,-.876,.302,-.346,-.317,.344,-.218,.511,-.279,-.457,.016,-.252,.050,.097)*f11_2+\n    mat4(.476,-.389,-.111,.009,-.368,.387,.052,-.134,.206,-.081,-.513,.131,-.443,-.387,.206,-.245)*f11_3+\n    mat4(-.115,-.258,.286,-.724,.396,.059,-.731,-.222,-.058,.072,-.327,-.144,.139,.196,.123,-.009)*f11_4+\n    vec4(.511,.986,-.175,.089))/3.5+f11_3;\nvec4 f12_4=sin(mat4(-.012,-.198,.534,-.351,-.152,.977,-.293,.123,1.364,.226,-.048,-.232,.300,.748,.280,-.112)*f11_0+\n    mat4(-.021,.051,-.283,-.627,.324,.130,.075,-.020,.033,-.445,.003,-1.068,-.519,-.454,.502,-.416)*f11_1+\n    mat4(-.102,.188,-.197,.293,1.037,.593,-.252,.042,.037,.309,-.626,.336,.393,.341,-.969,-.289)*f11_2+\n    mat4(.813,.949,-.940,.530,.067,.532,-.542,-.207,-.040,.450,-.159,-.461,1.047,-.033,-.136,-.146)*f11_3+\n    mat4(-.133,.173,-.429,.027,.451,-.751,.206,-.558,-.762,.169,-.228,.552,-.272,.256,.120,-.653)*f11_4+\n    vec4(.439,-1.643,.397,.291))/3.5+f11_4;\nvec4 f13_0=sin(mat4(-.227,.539,-.834,.073,-.212,-1.259,-.151,-.309,.520,-.117,1.105,-.019,.093,.572,.403,-1.079)*f12_0+\n    mat4(-.428,.002,.298,.522,.417,.241,.718,-.267,.771,.268,.890,-.435,.095,-.195,.100,-.343)*f12_1+\n    mat4(-.312,-.206,.035,-.319,-.555,.101,.117,-.014,-.159,-.146,-.007,.473,.626,-.367,-.262,-.846)*f12_2+\n    mat4(.745,-.010,.470,-.250,-.232,.060,-.769,.834,.095,.272,.048,.054,-.036,-.526,.216,.476)*f12_3+\n    mat4(-.699,.014,.304,.382,-.467,.227,-.739,.957,-.659,.433,.113,-.390,.147,-.819,-.085,-.349)*f12_4+\n    vec4(1.346,.117,.955,.716))/3.6+f12_0;\nvec4 f13_1=sin(mat4(.525,-1.017,.147,.093,-.579,.694,-.359,.122,-.522,.984,-.156,-.201,.123,-.332,.560,.174)*f12_0+\n    mat4(-.494,-.100,.691,-.113,-.297,.697,.131,-.161,-.288,-.818,.364,-.612,.275,-.142,-.095,.342)*f12_1+\n    mat4(.077,.068,-.317,.753,-.668,.439,-.082,-.230,-.247,-.098,-.059,.062,.044,-.703,.380,.093)*f12_2+\n    mat4(-.348,.717,.053,-.276,-.837,-.038,-.318,-.427,-.029,-.165,-.431,.364,.261,.141,-.681,.373)*f12_3+\n    mat4(-.019,.754,.011,.236,.454,-.431,-.187,-.307,-.214,.495,.497,-.105,-.185,.390,-.366,.199)*f12_4+\n    vec4(.068,.022,-.178,.630))/3.6+f12_1;\nvec4 f13_2=sin(mat4(.249,-.220,-.266,.381,.469,.143,-.477,-.355,.452,-.101,.168,.456,.098,.035,-.714,.371)*f12_0+\n    mat4(-.213,-.444,-.119,.394,-.809,-.513,-.508,.472,-.027,-1.158,-.390,.285,.357,.072,-.670,.143)*f12_1+\n    mat4(.470,.296,.128,-.188,-.264,-.116,-.294,.362,.153,.416,.058,-.365,-.363,-.602,-.591,.797)*f12_2+\n    mat4(-.193,-.183,-.553,.167,.064,.100,.377,.205,-.950,-.715,-.463,.599,-.074,.241,.119,-.560)*f12_3+\n    mat4(-.383,.253,-.083,-.379,-.018,-.370,.618,-.431,-.172,.803,-.445,.142,-.166,.538,-.097,-.002)*f12_4+\n    vec4(.500,-.266,-1.527,-.983))/3.6+f12_2;\nvec4 f13_3=sin(mat4(-.237,-.075,-.416,.256,.146,.021,-.420,.591,.293,.396,.513,.009,-.413,-.856,.408,.269)*f12_0+\n    mat4(.373,-.161,-.542,-.733,.699,.135,-.130,-.444,.464,-.037,.252,-.271,.179,.088,.047,.091)*f12_1+\n    mat4(-.734,-.469,-.426,-.280,.545,.394,.191,-.613,.210,.125,.009,-.652,.118,.289,.140,-.317)*f12_2+\n    mat4(-.056,.049,.402,-.131,-.699,.415,.882,-.835,-.379,-.231,.330,-.004,-.397,.505,-.308,.129)*f12_3+\n    mat4(-.105,.405,-.402,-.619,.295,-.156,.575,-.532,.510,-.202,-.810,-.363,-.324,-.119,.287,.518)*f12_4+\n    vec4(.016,.215,1.029,.833))/3.6+f12_3;\nvec4 f13_4=sin(mat4(.075,.264,.009,-.321,.286,-.167,.375,.420,-.651,-.268,.545,.274,.069,-.237,-.151,.482)*f12_0+\n    mat4(-.459,.522,.098,-.762,.279,-.475,-.305,1.140,-.621,.099,.518,.530,-.365,.296,.485,.120)*f12_1+\n    mat4(.372,.227,.485,.134,-.510,.187,.598,.115,-.246,.256,-.233,.152,.086,.111,.633,-.320)*f12_2+\n    mat4(.264,-.690,-.491,.613,.297,.517,-.104,-.039,.166,-.004,.227,-.309,-.360,.689,.202,-.129)*f12_3+\n    mat4(.932,-.158,-.047,.126,-.806,1.462,.228,-.336,.358,.483,.351,-.203,-.032,-.502,-.536,-.062)*f12_4+\n    vec4(-.764,-.383,.445,-.950))/3.6+f12_4;\nvec4 f14_0=sin(mat4(-.285,-.051,-.674,-.030,.475,.470,-.141,-.144,.760,-.384,1.084,-.180,-.187,.457,.045,.600)*f13_0+\n    mat4(.054,-.042,.151,-.302,.391,.226,.257,.026,.444,-.708,-.038,-.162,.298,-.410,-.489,-.019)*f13_1+\n    mat4(-.411,-.049,-.020,-.513,-.433,.356,-.402,.050,.062,.711,-.235,-.360,-.162,.386,-.380,-.073)*f13_2+\n    mat4(.024,-.070,.262,.463,-.250,.242,-.146,.472,.260,-.189,.193,.299,-.143,-1.134,.003,-1.140)*f13_3+\n    mat4(.189,-.130,.014,-.405,-.617,-.364,-.353,-1.137,-.437,.376,.085,-.161,.147,.692,-.153,-.678)*f13_4+\n    vec4(.067,-1.689,1.533,.031))/3.7+f13_0;\nvec4 f14_1=sin(mat4(.821,.377,.076,-.190,-.148,.226,-.078,.604,.637,.496,.207,.288,.147,-.212,-.147,.052)*f13_0+\n    mat4(.199,.243,-.358,.106,.335,.807,.721,.517,-.282,-.005,.698,-.826,-.753,-.176,-.259,-.195)*f13_1+\n    mat4(-.370,.244,-.002,.236,.386,.070,.051,.299,.386,.240,-.215,-.231,-.091,.864,.129,.267)*f13_2+\n    mat4(.016,.365,-.658,-.983,.791,-.478,-.142,-.411,.246,-.321,-.667,.047,-.523,.366,-.684,.329)*f13_3+\n    mat4(-.238,-.561,-.302,-.048,-.754,-.686,.363,-.090,-.660,.230,-.305,.317,-.065,.331,.227,-.349)*f13_4+\n    vec4(-.149,-.076,.577,-.415))/3.7+f13_1;\nvec4 f14_2=sin(mat4(.182,.315,.197,.187,-.011,-.045,-.529,.247,.606,.764,.066,.056,-.496,.158,.356,-.879)*f13_0+\n    mat4(.176,.000,.440,.558,.277,.447,.508,.062,.732,-.458,.592,-.066,-.039,-1.333,.507,-.748)*f13_1+\n    mat4(.162,-.237,-.194,-.200,-.072,.554,-.181,.480,.333,-.103,.016,.101,.309,.127,.133,-.200)*f13_2+\n    mat4(.636,.538,-.069,-.015,-.798,.619,.430,.001,.235,-.323,.411,.168,-.193,-.508,-.539,-.086)*f13_3+\n    mat4(.431,.063,-.795,.607,.137,-.125,.494,-.032,.793,-.239,-.571,.014,-.191,-.092,-.007,-.196)*f13_4+\n    vec4(.603,.016,.505,-.269))/3.7+f13_2;\nvec4 f14_3=sin(mat4(-.354,.183,.290,-.354,.207,-.162,.116,-.322,.002,.550,-.277,-.104,-1.037,.139,-.246,-.412)*f13_0+\n    mat4(.622,.470,.786,-.552,.023,.178,-.104,-.008,-.009,.388,-.296,-.272,-.089,.128,.292,-.589)*f13_1+\n    mat4(.014,.060,.507,-.197,-.191,.193,.086,.069,-.058,-.092,.040,-.215,-.005,.283,-.008,-.003)*f13_2+\n    mat4(-1.343,.558,.845,.226,.205,-.397,-.466,1.123,-.039,-.439,.069,-.260,.445,-1.089,-.831,-1.140)*f13_3+\n    mat4(.020,-.836,.216,.089,.595,-.613,-.095,-.327,-.663,.027,.142,.223,.083,-.768,-.169,-.451)*f13_4+\n    vec4(.636,.563,-.232,.327))/3.7+f13_3;\nvec4 f14_4=sin(mat4(-.854,-.472,1.051,-.909,.369,-.315,.001,-.248,.526,-.607,.695,.297,.564,-.723,.048,-.280)*f13_0+\n    mat4(-.273,.496,-.206,.320,-.380,.076,.810,.053,.576,-.255,-.062,.167,.092,.213,-.870,-.561)*f13_1+\n    mat4(.164,-.183,-.585,.423,.478,.314,.618,.207,-.396,.523,-.856,.350,.000,-.003,-.091,.096)*f13_2+\n    mat4(-1.140,-.145,.277,1.066,.030,.425,-.865,-.292,.133,-.227,-.187,.298,.338,.232,.374,.346)*f13_3+\n    mat4(.199,.401,-.390,.299,-.687,.423,.051,-.184,-.474,-.142,.030,.273,.415,-.305,-.008,-.164)*f13_4+\n    vec4(.333,1.117,.043,.521))/3.7+f13_4;\nvec4 f15_0=sin(mat4(1.085,.106,-.160,.306,-.069,.146,-.204,-.218,-.345,-.082,.063,.628,-.043,1.153,.143,.695)*f14_0+\n    mat4(-.139,-.382,-.245,-.414,-.436,.052,.358,.255,-.019,-.698,.220,.257,.127,-.605,.002,.120)*f14_1+\n    mat4(-.369,-.454,-.089,.258,.133,.256,.053,.225,-.111,.116,.526,.271,.852,-.089,-.586,-.088)*f14_2+\n    mat4(.752,.291,1.231,.869,-.362,.312,-.305,-.363,-.202,.517,-.171,-.019,-.024,.167,-.272,.140)*f14_3+\n    mat4(-.191,-.237,.447,-.765,.319,-.411,-.537,-.838,-.204,.164,.728,-.404,-.359,.530,.727,.203)*f14_4+\n    vec4(.178,-2.074,.160,1.043))/3.9+f14_0;\nvec4 f15_1=sin(mat4(-.546,-.284,.505,-.238,-.039,.083,.102,-.065,.340,-.486,.598,.733,-.676,.017,.402,.373)*f14_0+\n    mat4(1.503,-.079,-.631,-.522,.196,-.749,.024,.525,-.303,-.152,-.372,-.140,-.195,-.317,.017,.652)*f14_1+\n    mat4(-.474,.147,-.289,-.471,.124,-.070,.163,-.282,-.241,-.222,-.220,-.853,-.070,-.235,.069,.393)*f14_2+\n    mat4(-1.217,-1.045,.360,.194,.121,.914,-.278,-.878,.080,.303,-.099,.275,.645,.138,-.398,.992)*f14_3+\n    mat4(.425,.947,-.018,-.646,.332,-.290,-1.163,.071,-.544,.216,-.095,-.106,-.280,.243,-.106,-.296)*f14_4+\n    vec4(-1.452,-.193,-.471,-1.056))/3.9+f14_1;\nvec4 f15_2=sin(mat4(-.699,.109,.045,.161,.543,-.233,.359,.517,-.160,-.255,1.819,-.168,-.668,.285,.376,.319)*f14_0+\n    mat4(-.808,-.044,-.733,-.799,.226,-.377,.402,-.020,-.414,.963,-.190,.659,-.291,-.135,-1.122,-.090)*f14_1+\n    mat4(.618,.515,-.647,-.124,.207,-.518,.602,-.349,.262,.468,-.543,-.293,-.113,-.210,.639,.165)*f14_2+\n    mat4(.175,-.329,-.443,-.514,-.073,.008,.526,-.242,.366,-.077,-.145,.091,-.168,-1.092,.066,-.413)*f14_3+\n    mat4(.870,.286,-.115,-.594,.268,.035,-.064,-.197,.961,.425,-.573,-.418,-.090,-.555,.307,.472)*f14_4+\n    vec4(-1.333,-.065,.823,-.669))/3.9+f14_2;\nvec4 f15_3=sin(mat4(-.392,-.464,-.454,.155,.356,-.498,-.062,-.065,.278,.043,-.456,.170,-.805,-.294,1.037,-.395)*f14_0+\n    mat4(.445,-.650,.218,.723,.098,.366,-.008,.028,.437,-.405,-.436,-.032,.095,-.570,-.305,.432)*f14_1+\n    mat4(-.103,-.278,-.767,-.342,-.140,.056,.294,-.116,.068,-.777,-.009,-.074,.416,.128,-.228,-.108)*f14_2+\n    mat4(-1.184,-.011,-.158,-.879,-.157,-.653,.061,-.419,.259,.244,1.102,.643,.625,.454,.327,.919)*f14_3+\n    mat4(-.243,-.350,-.304,-.028,.564,.480,-.760,-.113,-.211,-.238,-.281,.554,.370,.560,.026,.198)*f14_4+\n    vec4(.623,.112,1.211,-.093))/3.9+f14_3;\nvec4 f15_4=sin(mat4(.098,.095,-.351,-.752,.381,-.091,.049,.677,.136,.225,.014,-.462,-.652,.788,.739,.246)*f14_0+\n    mat4(.277,-.795,-.435,.091,.218,.089,.044,.138,.289,.291,-.061,-.199,-.066,-.001,-.631,.408)*f14_1+\n    mat4(.644,.173,-.220,-.133,.606,-.031,.445,-.599,.249,.162,.222,.125,.160,-.479,.456,-.106)*f14_2+\n    mat4(-.750,1.168,-.703,-.014,-.299,-.226,.261,.654,-.701,.038,.855,.500,.734,-.835,.650,.284)*f14_3+\n    mat4(.358,.095,-.313,-.225,.124,-1.550,.069,.211,.892,.664,-.784,-.036,-.154,.644,.083,.729)*f14_4+\n    vec4(-1.518,-.868,2.023,-.054))/3.9+f14_4;\nvec4 f16_0=sin(mat4(1.231,1.110,-.378,.308,-.518,-1.066,-.018,.336,-.527,-.678,.920,-.339,.859,.280,.208,-.751)*f15_0+\n    mat4(-1.243,-.398,.688,.094,-.024,.211,.323,-.132,-.123,-.011,.619,.284,-.547,-.460,.070,.198)*f15_1+\n    mat4(.497,-.237,.036,.289,.232,.942,.133,-.513,-.032,.233,.452,-.108,.029,.306,.063,.191)*f15_2+\n    mat4(1.003,.580,.427,-.914,-.189,-.220,-.166,-.228,-.139,-.240,-.386,.061,-.785,-.677,-.416,-.417)*f15_3+\n    mat4(-.218,-.014,-.023,.026,-.479,.286,-.620,-.138,.773,.364,.165,.086,.276,-.334,-.188,.236)*f15_4+\n    vec4(.691,.098,-1.733,-1.033))/4.0+f15_0;\nvec4 f16_1=sin(mat4(-.658,-.058,.476,-.784,.180,-.689,.707,.133,.833,.985,-.149,.224,-.319,-1.530,-.527,-.467)*f15_0+\n    mat4(1.223,.101,.396,.226,.096,.218,-.088,.500,.004,.305,-.130,.271,.278,.309,.188,1.108)*f15_1+\n    mat4(.241,.196,.172,-.582,-.475,.138,-.251,-.379,.310,.202,.309,-.383,.206,-.134,-.551,-.753)*f15_2+\n    mat4(-.461,-.762,-.253,-.029,.030,-.307,-.122,-.542,-.222,-.307,.062,-.098,.193,-.061,.985,.795)*f15_3+\n    mat4(.335,-.121,.214,-.236,-.369,.734,.257,.241,-.016,.152,-.547,-.268,-.186,-.311,.258,-.543)*f15_4+\n    vec4(-.669,.666,1.145,1.121))/4.0+f15_1;\nvec4 f16_2=sin(mat4(.463,-.056,.341,-.972,.506,-.185,-.402,.720,-.030,-.934,-.491,.234,.435,.103,.158,.139)*f15_0+\n    mat4(-.276,.107,-.366,-.412,.962,.203,-.868,.116,.348,.112,-.715,-1.059,-.184,.106,.070,.293)*f15_1+\n    mat4(-.981,-.510,.266,-.603,.368,.515,-.960,.117,-.463,.041,.561,-.016,.358,-.612,-.494,-.157)*f15_2+\n    mat4(-.166,-.262,.876,1.296,-.300,-.366,.280,.077,.547,.330,.078,-.020,.885,.770,-.231,.585)*f15_3+\n    mat4(-.586,-.484,.193,-.407,-.113,.255,-.325,-.869,-.453,-.368,-.277,.351,.554,.738,-.478,.299)*f15_4+\n    vec4(.244,-.159,.083,.452))/4.0+f15_2;\nvec4 f16_3=sin(mat4(-.734,.285,-.568,-.068,.136,.626,-.650,.878,.272,.457,-.378,-.636,-1.211,-.211,.427,-.359)*f15_0+\n    mat4(.791,-.105,-.591,.965,-.117,.629,.551,-.551,-.127,.178,-.531,-.405,.021,1.037,-.268,.721)*f15_1+\n    mat4(-.066,-.651,-.341,.310,-.227,.329,.639,.243,-.051,-.720,-.079,.557,.479,-.344,.508,-.015)*f15_2+\n    mat4(-1.692,-.251,-.171,-.681,.197,-1.111,-.136,.344,.259,.306,.684,.128,.463,1.030,.101,.678)*f15_3+\n    mat4(.017,-.167,-.140,.210,.653,-.331,.332,.195,-.773,-.341,.217,1.317,-.085,.165,-.032,.319)*f15_4+\n    vec4(.976,-.368,.394,-.583))/4.0+f15_3;\nvec4 f16_4=sin(mat4(-.215,-.495,.229,-.118,-.120,.093,-.084,-.280,-.242,.621,-.206,.003,-.900,.526,-.363,-.364)*f15_0+\n    mat4(-.085,.499,.000,-.380,.092,.284,-.858,.404,.256,.267,.302,.371,1.354,.231,.238,.254)*f15_1+\n    mat4(.651,-.297,.137,-.204,.355,.138,-.814,.061,-.133,.010,.044,-.343,-.100,-.139,.371,.532)*f15_2+\n    mat4(.063,.390,.269,-.308,-.298,-.110,-.114,-.777,.455,.347,.000,-.076,.479,-.326,-.019,.293)*f15_3+\n    mat4(-.377,-.053,.419,-.374,-.234,-1.005,-.214,.126,.606,-.029,.112,-.887,.127,.130,-.435,1.153)*f15_4+\n    vec4(-.109,.840,.340,-.052))/4.0+f15_4;\nvec4 f17_0=sin(mat4(.406,-.394,-1.202,.018,-.481,.581,.856,.330,.322,.783,1.446,-.323,.404,.530,-.141,.262)*f16_0+\n    mat4(-.336,.297,.737,.351,-.409,-.068,.189,-.391,.287,.732,.464,-.730,-.398,.192,.432,-.359)*f16_1+\n    mat4(.423,.326,.092,.299,.182,-.848,-.751,-.371,.634,-.174,-.038,.180,-.540,.644,-.447,-.167)*f16_2+\n    mat4(.495,-.161,-.478,-.079,.283,-.007,.135,.741,-.733,-.151,.204,.297,-.633,-.273,.209,-.068)*f16_3+\n    mat4(.215,.307,-.168,.411,.171,-1.301,-1.129,-.099,.724,-.376,-.562,.159,-.127,1.130,.454,-.185)*f16_4+\n    vec4(.391,.188,-2.843,-.188))/4.1+f16_0;\nvec4 f17_1=sin(mat4(-.161,-.263,-.127,.438,-1.154,-.534,-.083,-.624,-.276,-.149,-.562,-.564,.472,-.095,-.579,-.158)*f16_0+\n    mat4(-.419,.696,-.270,-.194,-.107,-.813,.585,-.530,-.079,-.170,.662,-.142,-.172,.618,.976,-.043)*f16_1+\n    mat4(.162,.952,.260,-.041,.262,.030,.173,-.207,.183,.605,.040,-.307,.004,-.675,-.770,.159)*f16_2+\n    mat4(.533,.007,.041,-.127,-.345,.641,-.132,-.175,.135,-.720,-.852,.229,-.877,.024,.042,-.052)*f16_3+\n    mat4(-.446,.670,.340,-.399,-.069,.823,.746,-.147,.113,.342,.689,-.267,-.411,-.679,.578,-.399)*f16_4+\n    vec4(.498,.314,.491,-.686))/4.1+f16_1;\nvec4 f17_2=sin(mat4(.175,-.801,.134,-.486,-.311,.674,-.215,.519,-.138,.106,-.092,.733,1.000,.164,.625,-.492)*f16_0+\n    mat4(.268,.469,-.250,.489,-.008,-.712,.301,-.067,-.061,.250,-.652,-.837,.259,.205,-.070,-.013)*f16_1+\n    mat4(-.259,.574,-.137,-.214,.196,-.703,.621,.045,.037,.435,-.447,-.263,-.811,-.473,.331,.661)*f16_2+\n    mat4(.226,.083,.933,-.615,-.728,.411,-.483,.153,.580,-.300,.656,.095,.347,-.534,.710,.731)*f16_3+\n    mat4(-.153,.831,-.240,.332,-.068,-.155,.587,-.254,-.197,.198,-.467,-.499,-.850,-.199,-.155,-.052)*f16_4+\n    vec4(-.759,.475,-.465,-.567))/4.1+f16_2;\nvec4 f17_3=sin(mat4(.354,.373,-.342,-.282,-.185,.272,-.237,-.075,-.264,.081,-.033,.172,.371,.260,.279,-.901)*f16_0+\n    mat4(-.234,-.172,-.389,.338,-.362,-.946,.536,.494,-.143,-.103,.365,.004,-.068,.036,.100,.258)*f16_1+\n    mat4(.345,.727,-.369,.130,-.145,-.960,1.055,.464,-.094,.332,-.118,-.598,-.175,-.511,-.135,.275)*f16_2+\n    mat4(.944,-.159,.075,-.497,-.520,.484,-.557,-.342,.057,-.705,.971,.001,-.733,-1.118,.670,1.047)*f16_3+\n    mat4(-.180,.231,-.250,-.450,-.949,-.571,-.591,.827,.787,.169,.478,-.359,.126,.134,.564,.626)*f16_4+\n    vec4(1.392,-.167,.687,-1.502))/4.1+f16_3;\nvec4 f17_4=sin(mat4(.507,-.976,-.141,-.055,.429,.456,.763,.255,.668,1.391,.440,.056,-.046,.806,-.200,.039)*f16_0+\n    mat4(.644,.391,.571,.098,-1.044,.083,.309,-.780,.038,.377,.572,-.019,.223,.300,.452,-.202)*f16_1+\n    mat4(.903,-.060,-.356,-.075,.069,-.428,.189,-.622,.737,-.115,-.034,.257,-.540,-.581,-.142,-.108)*f16_2+\n    mat4(.077,.516,-1.531,-.129,.754,-.157,-.221,.707,-.579,.217,.066,-.301,-.632,-.239,.888,-.118)*f16_3+\n    mat4(.530,-.287,-.404,.585,-.565,-1.910,-.621,-.322,1.005,-.147,-.569,-.587,-.089,.237,.219,-.010)*f16_4+\n    vec4(.570,-.084,-.243,.785))/4.1+f16_4;\nvec4 f18_0=sin(mat4(.085,-.084,.039,-.124,-.085,-.626,.159,.390,.229,.122,-.050,.215,-.184,.040,.086,.400)*f17_0+\n    mat4(-.156,-.068,.339,-.352,.059,-.290,-.319,-.097,.114,-.194,.187,.362,.007,-.194,.041,.301)*f17_1+\n    mat4(.146,.554,-.249,-.017,-.082,-.018,-.635,-.365,-.310,.254,.416,-.364,1.032,-.244,.017,.339)*f17_2+\n    mat4(-.474,.042,-.473,.034,-.305,.530,.191,.041,.210,-.113,-.315,-.054,.358,-.249,-.548,.007)*f17_3+\n    mat4(-.136,.605,-.286,.012,.472,-.186,.120,-.166,-.328,.380,.065,-.114,.502,-.576,-.332,-.361)*f17_4+\n    vec4(-.178,1.287,.973,.971))/4.2+f17_0;\nvec4 f18_1=sin(mat4(-.496,-.049,-.165,-.707,.228,-.008,.038,.408,.239,.082,.007,.690,-.544,.391,-.095,-.026)*f17_0+\n    mat4(.966,-.219,-.226,-1.123,-.557,-.689,-.428,.662,-.746,-.155,-.183,1.171,-.267,.012,.779,.844)*f17_1+\n    mat4(.196,.697,.133,.335,-.406,-.466,-.507,-.173,.516,.303,.043,-.070,.320,-.517,-.709,-.422)*f17_2+\n    mat4(-1.108,.594,.660,.381,.759,-.098,-.110,-.550,-.227,-.447,-.257,-.354,-.020,-.855,-.532,.014)*f17_3+\n    mat4(.118,.704,-.044,-.617,.119,-.847,-.728,-1.276,-.324,.462,.405,-.532,.064,-.335,-.279,.781)*f17_4+\n    vec4(-.441,-.130,-.010,1.047))/4.2+f17_1;\nvec4 f18_2=sin(mat4(-.688,-.309,.045,-.245,-.155,.340,.121,-.045,.254,.299,.046,.243,-.070,.054,.111,-.272)*f17_0+\n    mat4(.384,.492,-.657,-.516,.180,-.816,.856,-.319,-.154,-.497,.245,-.501,-.399,.154,.144,-.393)*f17_1+\n    mat4(-.003,.718,-.726,.211,1.381,-.702,.744,.555,-.631,.247,-.979,-.703,.377,-.455,-.137,.453)*f17_2+\n    mat4(.089,-.254,.330,.511,-.702,.862,-.505,-.405,1.405,-.727,.587,.237,.677,-.738,.632,.204)*f17_3+\n    mat4(-.221,.568,-.431,-.306,-.140,-.649,-.992,-.237,.308,-.098,.337,-.272,-.387,-.219,.034,.076)*f17_4+\n    vec4(-1.466,-.608,-1.043,-1.018))/4.2+f17_2;\nvec4 f18_3=sin(mat4(-.291,.296,-.581,.186,.420,.343,.437,-.463,.373,.027,-.093,-.167,-1.063,.006,-.401,.701)*f17_0+\n    mat4(.391,-.125,.197,-.254,.240,-.859,-1.140,-.247,-.112,-.258,-.260,-.111,.246,.101,-.020,.018)*f17_1+\n    mat4(.070,.615,1.068,-.260,-.276,-1.105,-.689,-.523,-.347,.692,.246,.139,.119,-.404,.075,-.263)*f17_2+\n    mat4(-.988,.012,-.928,.650,.038,.675,.616,.215,-.238,-1.119,-.627,.168,.548,-.506,-.170,-.614)*f17_3+\n    mat4(-.145,.743,.229,-.329,.445,-.086,.185,.033,-.387,.113,-.470,-.594,.406,.172,-.247,-.222)*f17_4+\n    vec4(-.733,.689,-.182,.275))/4.2+f17_3;\nvec4 f18_4=sin(mat4(.059,-.357,.456,-.257,-.012,.033,.537,-.394,.108,.308,-.015,-.043,-.581,1.020,.248,-.434)*f17_0+\n    mat4(-.700,-.119,-.041,-.432,.971,.285,-.187,.230,.100,.040,-.032,-.352,.537,.440,.119,-.296)*f17_1+\n    mat4(-.291,-.263,.381,-.220,.492,-.400,-.364,.318,-.436,-.094,.284,-.374,.336,-1.024,-.632,.370)*f17_2+\n    mat4(.102,1.352,.332,-.017,-.735,-.039,-.418,-.552,-.310,.170,-1.096,.150,1.204,-.453,-.492,.885)*f17_3+\n    mat4(-1.171,.131,.275,.212,.533,-1.359,-.217,-.184,-.124,.596,-.032,-.678,.692,-.298,-.692,.223)*f17_4+\n    vec4(-.098,-.227,1.602,-1.107))/4.2+f17_4;\nvec4 f19_0=sin(mat4(-.505,-.807,-.400,-.028,.433,.294,-.023,-.424,.608,-.141,-.286,-.631,.601,.395,-.614,-.421)*f18_0+\n    mat4(-.194,.055,.105,-.058,.910,.160,.535,-.430,.673,-.180,.035,-.585,.501,-.379,.095,-.147)*f18_1+\n    mat4(-.764,.384,-.601,.148,.450,-.552,-.102,.102,-.553,.028,-.255,.116,.449,.140,.046,.244)*f18_2+\n    mat4(.303,-.375,-.405,-.239,-.577,.755,-.046,.172,.707,-.146,.590,.203,.717,-.231,.374,.024)*f18_3+\n    mat4(-.531,.389,-.134,.408,-.731,.210,.096,.675,-.304,-.424,-.075,.089,.485,.298,-.008,-.584)*f18_4+\n    vec4(.407,.384,-.392,-.283))/4.4+f18_0;\nvec4 f19_1=sin(mat4(-.758,-.607,.155,-.556,.040,-.348,-.163,.081,.551,.024,-.181,-.002,-.230,.476,.717,.085)*f18_0+\n    mat4(.733,.246,-.368,-.600,-.224,1.045,-.691,.606,-.233,.072,.219,.221,-.392,-.173,.336,.875)*f18_1+\n    mat4(-.220,-.933,-.160,-.495,-.270,.990,-.743,-.147,.623,-.550,.224,-.236,.074,-.011,-.253,.490)*f18_2+\n    mat4(-.121,.556,.613,-.103,.631,-.533,-.019,-.099,.545,1.133,-.067,.457,-.251,.701,-.910,-.187)*f18_3+\n    mat4(.458,-.324,.010,-.712,-.523,-.141,-.389,-.047,.071,.058,.158,-.011,-.075,-.128,-.320,.179)*f18_4+\n    vec4(.855,.645,-2.003,.911))/4.4+f18_1;\nvec4 f19_2=sin(mat4(-.530,-.349,.714,-.546,.265,-.227,.543,-.650,-.384,-.126,.566,.334,-.299,-.492,-.545,.853)*f18_0+\n    mat4(.367,.517,-.327,-.074,.588,.084,.619,-.189,.557,.482,.524,-.058,.503,.913,-.413,-.347)*f18_1+\n    mat4(-.213,-.151,-.212,.055,.581,-.411,.962,.206,-.360,-.251,-.576,.324,.139,.289,.902,-1.010)*f18_2+\n    mat4(-.317,-.496,-.149,.235,-.546,-.331,-.753,.135,.645,.243,.180,.363,.666,.640,.331,-.603)*f18_3+\n    mat4(.038,-.300,.327,-.346,-.154,.184,-.000,-.662,.177,-.354,.380,.174,.050,.024,-.498,-.259)*f18_4+\n    vec4(.102,.133,-.031,.859))/4.4+f18_2;\nvec4 f19_3=sin(mat4(.217,.634,.202,.112,-.005,-.239,-.678,-.762,-.060,-.418,.195,-.422,.308,.648,-.551,.525)*f18_0+\n    mat4(-.509,-.769,.925,.022,.522,.981,.149,-1.034,.026,.100,.330,-.254,.135,-.127,-.557,-.203)*f18_1+\n    mat4(-.514,-.904,-.062,.604,.262,1.003,.585,-.468,-.395,-.318,.241,.622,-.033,.785,-.645,-.932)*f18_2+\n    mat4(.475,1.001,-.496,.836,-.344,-.854,-.040,.401,.275,1.233,.519,-.558,.324,.502,.192,-1.338)*f18_3+\n    mat4(-.532,-.523,-.344,.688,.137,-.464,.347,-.347,.219,.106,.026,.750,.370,.212,.217,-.818)*f18_4+\n    vec4(.153,.335,-.322,-.006))/4.4+f18_3;\nvec4 f19_4=sin(mat4(-.281,.042,.746,.144,.543,.548,-.792,.364,-.273,.437,-.141,.137,-.730,-.427,-.005,.013)*f18_0+\n    mat4(.228,.575,-.156,.069,-.777,.034,-.637,-.124,-.695,.201,-.123,-.132,-.383,.059,.298,.840)*f18_1+\n    mat4(.522,-.066,.441,.618,-.925,.157,-.577,-1.002,.518,.204,-.062,.558,.657,.082,-.168,-.298)*f18_2+\n    mat4(-.527,-.447,.506,.343,.289,-.041,.045,.551,.194,-.097,.475,-.277,.062,.572,-.374,-.732)*f18_3+\n    mat4(.919,.071,-.208,.275,.608,.298,.073,-.800,-.092,-.131,.441,.114,.083,.593,-.112,.150)*f18_4+\n    vec4(.263,-1.600,-.531,.701))/4.4+f18_4;\nvec4 f20_0=sin(mat4(-.099,.030,-.650,-.550,-.141,.020,.703,.229,.389,-.313,.963,.009,.291,1.052,-.550,-1.327)*f19_0+\n    mat4(.138,-.506,.406,.833,.686,.165,.213,.042,.104,-.372,.533,.135,.046,-.119,.549,.135)*f19_1+\n    mat4(-.140,.016,-.058,.018,.149,.042,-.871,-.333,-.165,-.340,-.274,-.116,-.029,-.319,.310,.621)*f19_2+\n    mat4(-.234,1.155,-.633,-1.798,-.280,-.030,-.188,.114,.299,.346,.039,-.002,.407,-.262,.355,.486)*f19_3+\n    mat4(-.728,.170,-.439,.137,-.252,-.381,-.842,1.096,-.637,.670,-.512,-.544,.430,-.026,1.199,.002)*f19_4+\n    vec4(-.310,-.152,.234,1.058))/4.5+f19_0;\nvec4 f20_1=sin(mat4(-.143,-.355,-.524,-.198,.110,.011,-.035,.176,.019,-.387,.426,.441,-.230,.269,-.126,.692)*f19_0+\n    mat4(.500,.833,.718,-.372,-.431,-1.142,.889,.431,-.121,-.584,.073,.570,-.357,-.861,-.020,.742)*f19_1+\n    mat4(.376,.982,-.599,.061,-.511,-.511,1.249,.219,.603,1.328,-.443,-.142,-.084,-.083,-.462,-.324)*f19_2+\n    mat4(-.433,.189,.096,.489,.533,1.084,-.597,-.444,-.253,-.285,.780,-.005,-.056,-1.237,.932,-.049)*f19_3+\n    mat4(.466,1.223,-.495,-.473,-.099,.043,-.440,-.712,-.144,.601,-.288,-.143,-.197,-.596,.011,.057)*f19_4+\n    vec4(.091,-1.431,.140,1.007))/4.5+f19_1;\nvec4 f20_2=sin(mat4(.728,-.576,.354,-.200,-.006,-.537,.103,.014,-.073,-.020,-.170,.368,-.062,.281,-.366,.692)*f19_0+\n    mat4(-.315,.144,-.456,-.177,-1.153,.609,-.463,-.168,.046,-.179,.337,.080,.364,-.156,.182,.206)*f19_1+\n    mat4(.841,-.744,.726,.045,-.926,.774,-.684,-.398,.851,-.392,.575,.074,-.362,.044,-.424,-.562)*f19_2+\n    mat4(.328,.370,-.138,.545,.597,-.214,.287,.239,-1.443,.835,-1.240,-.322,-.718,.244,-1.032,-.306)*f19_3+\n    mat4(.311,-.127,-.142,-.084,.394,.114,.208,-1.116,.184,.131,.358,-.011,-.094,.084,.459,-.289)*f19_4+\n    vec4(.337,-.102,-.316,-.485))/4.5+f19_2;\nvec4 f20_3=sin(mat4(.151,.352,.165,.254,.051,-.119,.072,-.201,-.407,-.341,.183,-.311,-1.073,-.094,-.351,.001)*f19_0+\n    mat4(.188,-1.089,.216,.067,-.022,-.772,.777,-.427,-.051,.255,.537,-.340,-.120,.157,-.342,-.498)*f19_1+\n    mat4(.157,1.004,-.950,.302,.013,-.820,.914,-.155,-.209,.438,-.920,.562,.664,-.350,.256,.195)*f19_2+\n    mat4(-1.401,.273,-.790,.134,.106,.279,-.433,.329,-.143,-1.063,.848,-.295,.494,-.805,.270,-.292)*f19_3+\n    mat4(.005,-.016,.028,.004,1.296,-.200,-.016,.120,-.384,.266,.043,.020,.023,.323,-.009,-.145)*f19_4+\n    vec4(-.340,.909,.660,.802))/4.5+f19_3;\nvec4 f20_4=sin(mat4(.158,.144,-.398,-.554,.789,.121,.123,.491,-.745,-.231,.093,.769,-.258,-.520,-1.060,-.360)*f19_0+\n    mat4(-.515,-.098,.706,-.083,-.059,.000,.208,.514,-.473,-.056,.290,1.086,-.564,.162,-.186,.823)*f19_1+\n    mat4(.511,.016,.211,-.179,-.319,-.274,.014,-.187,.413,-.176,-.209,-.673,-.030,.318,.533,-.410)*f19_2+\n    mat4(.197,-.769,-.985,-.533,.181,.250,-.072,-.231,-.676,-.276,.099,-.426,-.174,.105,.551,.589)*f19_3+\n    mat4(.914,.070,-.044,-.796,.324,.533,.606,.321,.563,-.324,-.319,-.233,.003,-.370,.326,.614)*f19_4+\n    vec4(-1.368,2.006,1.245,-.563))/4.5+f19_4;\nfloat f_0=dot(f20_0,vec4(-.019,.017,.040,.005))+\n    dot(f20_1,vec4(.042,-.066,-.020,-.017))+\n    dot(f20_2,vec4(.042,-.061,.056,-.028))+\n    dot(f20_3,vec4(-.020,.051,-.031,-.042))+\n    dot(f20_4,vec4(.038,-.040,-.007,-.024))+\n    0.475;\nfloat f_1=dot(f20_0,vec4(.016,.000,-.021,-.047))+\n    dot(f20_1,vec4(.031,-.067,-.034,-.031))+\n    dot(f20_2,vec4(.043,-.043,.048,.011))+\n    dot(f20_3,vec4(-.064,.055,-.037,-.028))+\n    dot(f20_4,vec4(.046,.052,-.009,-.035))+\n    0.482;\nfloat f_2=dot(f20_0,vec4(.036,-.022,-.027,.042))+\n    dot(f20_1,vec4(-.012,-.067,-.041,-.035))+\n    dot(f20_2,vec4(.037,-.027,.057,-.030))+\n    dot(f20_3,vec4(.055,.045,-.032,-.070))+\n    dot(f20_4,vec4(.043,-.020,.033,-.040))+\n    0.475;\n\n#endif\n#endif\n    return vec3(f_0, f_1, f_2);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcz3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[853, 853, 907, 907, 949], [951, 951, 989, 989, 1056], [1058, 1058, 1115, 1165, 2108]], "test": "untested"}
{"id": "WlVyz3", "name": "Ray-Paraboloid Intersection (3D)", "author": "oneshade", "description": "Ray intersector for a 3D paraboloid.", "tags": ["raytracing", "ray", "intersection", "quadratic", "paraboloid"], "likes": 5, "viewed": 190, "published": 3, "date": "1611443350", "time_retrieved": "2024-07-30T19:42:51.607613", "image_code": "/*\nI'm getting into ray intersectors now :)\nI'm currently working on an intersector for a trilinear surface and am down to a cubic!\n*/\n\n// Ray intersector for 3D paraboloid in the form: x^2/a^2 + z^2/b^2 - y = 0\nvec3 IntersectParaboloid3D(in vec3 ro, in vec3 rd, in float a, in float b) {\n    float invSqrA = 1.0 / (a * a);\n    float invSqrB = 1.0 / (b * b);\n\n    float ra = invSqrA * rd.x * rd.x + invSqrB * rd.z * rd.z;\n    float rb = invSqrA * 2.0 * ro.x * rd.x + invSqrB * 2.0 * ro.z * rd.z - rd.y;\n    float rc = invSqrA * ro.x * ro.x + invSqrB * ro.z * ro.z - ro.y;\n\n    vec3 intersect = vec3(0.0);\n\n    // If the discriminant is less than zero there are no (real) solutions\n    float discr = rb * rb - 4.0 * ra * rc;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * ra;\n        float t1 =  (root - rb) / denom; // 1st root\n        float t2 = -(rb + root) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nvec3 getParaboloidNormal3D(in vec3 p, in float a, in float b) {\n    float dx = 2.0 / (a * a) * p.x;\n    float dz = 2.0 / (b * b) * p.z;\n    return vec3(dx, -1.0, dz) / sqrt(dx * dx + dz * dz + 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 mouse = vec2(0.0, 0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    }\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 3.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float a = 2.25 + 2.0 * sin(iTime);\n    float b = 2.25 + 2.0 * cos(iTime);\n    vec3 intersect = IntersectParaboloid3D(ro, rd, a, b);\n    if (intersect.z > 0.5) {\n        vec3 n = getParaboloidNormal3D(ro + rd * min(intersect.x, intersect.y), a, b);\n        vec3 l = normalize(vec3(-1.0, -1.0, 1.0));\n\n        l.yz *= mat2(cp, -sp, sp, cp);\n        l.xz *= mat2(cy, -sy, sy, cy);\n\n        float lambertian = max(0.0, dot(n, l));\n        fragColor.r += lambertian;\n        if (lambertian > 0.0) {\n            fragColor.rgb += max(0.0, pow(max(0.0, dot(reflect(l, n), rd)), 32.0));\n        }\n    }\n\n    else {\n        fragColor.rgb += mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 212, 288, 288, 988], [990, 990, 1053, 1053, 1190], [1192, 1192, 1247, 1247, 2547]], "test": "untested"}
{"id": "wtcyRN", "name": "Annotated Koch KIFS tutorial", "author": "mkennan", "description": "My annotations to Art of Code's KIFS Koch snowflake tutorial @ https://youtu.be/il_Qg9AqQkE .\n\nText code adapted from ttoinou's 'YAS': https://www.shadertoy.com/view/Xd2fzK\nKIFS code adapted from BigWings' tutorial: https://www.shadertoy.com/view/tdcGDj", "tags": ["tutorial", "kifs", "koch", "bigwings", "artofcode"], "likes": 8, "viewed": 414, "published": 3, "date": "1611438679", "time_retrieved": "2024-07-30T19:42:52.725624", "image_code": "/***********************************************************************\n\n  Annotations for BigWings/Art of Code's KIFS Koch curve tutorial\n\n    @ https://youtu.be/il_Qg9AqQkE\n    & https://www.shadertoy.com/view/tdcGDj\n\n  Near the bottom of the page are the two lines that draw our Koch\n  curve. Right now they test pixels to see how close they are to a\n  notional line segment from x=0.0 to x=1.0; if the pixel is close\n  enough, the color white is assigned to that pixel.\n\n  By the time we are done we will have a full Koch snowflake, and \n  those lines will *still* just draw a white line from x=0 to x=1.\n  Much like an actual kaleidoscope, we will have mapped all of the\n  other parts of the canvas that should be part of the snowflake\n  back onto this little line segment.\n  \n  Each new section below is commented out with '/*' on the left.\n  Remove the '/*' (or nullify it like so: '//*') and recompile\n  the sketch (ALT-Enter, or click the button) to see what each new\n  section adds.\n\n  - MK, January 2021\n  \n************************************************************************/\n\n// some variables we will need later\nfloat PI = 3.14159;\nfloat scale = 1.0;\nfloat angle;\nfloat d; // distance\nvec2  n; // normal vector\n\n\n// Step 0: start the tutorial by setting this to 1 and re-compiling\n\n#if 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n   \n  // As we start, the uv coordinates are mapped to the red and green\n  // color channels so we can see how our efforts change the shape of \n  // space. Later we will disable this, first to make small details \n  // easier to see, then to sample a texture.\n  \n  // I'm commenting out the original uv declaration, so we can\n  // see how and why space changes when we change uv. The original\n  // code normalizes the uv space, centers the origin, and accounts\n  // for the aspect ratio in one line:\n  //\n  //   vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  //\n  // we'll do those things one at a time to see how it all works.\n\n  // uv is our tool for navigating space.\n  vec2 uv;\n\n  // fragCoord is the current pixel; iResolution is the canvas\n  // dimensions [width, height]. Dividing fragCoord by the canvas\n  // resolution makes x and y go from 0.0 to 1.0, abstracting away\n  // the details of whatever hardware the shader is running on.\n  \n  // (The resolution, despite being declared as a vec2, sometimes\n  // has a third component that contains the pixel aspect ratio...\n  // if you get an error about wrong dimensions in the line that\n  // has fragCoord and iResolution in it, explicitly restrict the\n  // affected variables to x and y using the suffix '.xy'.)\n  uv = fragCoord.xy / iResolution.xy;\n\n/*\n  // Subtracting 0.5 moves (0,0) to the center. The bottom-left\n  // quadrant turns black, and the red and green colors become\n  // dimmer, because RGB values must be in the range [0..1] and\n  // their 'zero' is now the center of the canvas.\n  // Note that modifying a vector this way changes each vector\n  // component individually, i.e the following lines are all\n  // equivalent:\n  //\n  //   uv = uv - vec2(0.5, 0.5);\n  //   uv -= vec2(0.5, 0.5);\n  //   uv -= vec2(0.5);\n  //   uv -= 0.5;\n  uv -= 0.5;\n\n/*\n  // x & y now go from -0.5 to 0.5, but if the canvas is not\n  // square our uv elements are not square either. We need to\n  // account for this so we are working with consistent distances\n  // in both axes, by multiplying uv by the canvas aspect ratio:\n  uv.x *= iResolution.x / iResolution.y;\n  \n  // You can uncomment this copy of the original code to verify\n  // that what we have done is identical:\n  //uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  // We need to keep track of how much we shrink uv space, or our\n  // line will become too thin to see:\n  scale = 1.0;\n  \n/*\n  // The Koch curve is bilaterally symmetric, so our first \n  // 'mirror' is also our easiest. abs(x) maps points from\n  // -x to their reflection at +x.\n  uv.x = abs(uv.x);\n\n/*\n  // Multiplying uv by 3 is useful because it changes the scale\n  // at which we interact with features in the curve: every\n  // recursive step divides an existing line segment into thirds,\n  // then the middle section is raised to make a peak.\n  // In the video he multiplies uv by 3, and likewise multiplies\n  // scale to keep track of these changes:\n  uv    *= 3.0;\n  scale *= 3.0;\n  \n  // Then he \"moves the origin\", and this is where my intuition\n  // fell apart: I think if the length of the line segment is\n  // now 3, we'd need to move uv.x 1 to the right. If the length\n  // of the line segment is still 1, we'd need to move uv.x 1/3\n  // to the right. But the next line he adds is:\n  //\n  //  uv.x -= 0.5;\n  //\n  // W.T.F.?\n  //\n  // It took a while, but eventually it clicked:\n  // The line segment is still where it has always been, from \n  // x=0 to x=1. He speaks of 'bending' the line, and it is\n  // really easy to fall into the trap of thinking we are \n  // 'rotating' the line, but we aren't actually doing *anything*\n  // to the line. We're just positioning our 'mirrors' to map\n  // uv points across a line of reflection so they can be \n  // tested for their distance from the line segment.\n  \n  // So instead of a line with 3 parts, one of which we 'bend'\n  // or 'rotate' upward to create the bottom half of the peak (a),\n  // we need a line of length 2/3rds, *reflected* to create the\n  // entire peak (b):\n  //           (The vertical lines are the y-axis.)\n  //\n  //       |            |               |            |\\  / <- line of reflection\n  //  (a): | _ _ _  ->  | \\ _ _    (b): |   _ _  ->  | \\ _ _\n  //       |            |               |            | /\n  // \n  // And that is what he did: he moved 0.5 to the *left*. This\n  // makes the distance from uv to the far end of the line be\n  // 1.5, with the first third being blank and the other two\n  // thirds being our length=1 line segment: we moved uv so\n  // our line segment *became* the 2/3rds we needed, without\n  // changing anything else. This is the key to understanding\n  // this uv weirdness: since uv is all that we have, we move it\n  // and resize it until elements that are outside of our control,\n  // like our little white line segment, appear to be where we\n  // want them to be.\n  uv.x -= 0.5;\n  \n  // (The middle of the line segment will seem to disappear for\n  // a bit, since we aren't actually reflecting anything yet.\n  // What we are seeing is our line segment of length 1, moved\n  // 0.5 to the right, while the left half of the canvas 'reflects'\n  // everything on the right side.)\n  \n  // Now we need to fold space again, to 'reflect' the points\n  // that will become the peak in the center. But how do we \n  // reflect across an arbitrary vector?\n  \n  // We'll have to reproduce the details and behavior of the\n  // 'mirror' we used before, abs(x):\n  //\n  // abs(x):\n  //  * had a line of reflection, the y-axis.\n  //  * had a normal (perpendicular) vector, the x-axis\n  //  * took points that were some distance -x from the \n  //    line of reflection, and mapped them a distance of 2x\n  //    along along the normal vector to reach the target\n  //\n  // We need to do each of those things, adjusted for the angle:\n  \n  //  * we want our reflected section to be 120 around from the\n  //    line, so our line of reflection will be angled at half \n  //    of that: 60, or /3 radians.\n  //  * our normal vector n will be perpendicular to the line of\n  //    reflection, pointing in the /3 - /2 = -/6 radians\n  //    direction. (60 - 90 = -30)\n  // \n  // So our angle and normal vector are:\n  angle = -PI / 6.0;\n  n = vec2(cos(angle), sin(angle));\n  \n  // At this point in the video he writes:\n  //  angle = 2.0 *  / 3.0;           // which looked wrong, and\n  //  n = vec2(sin(angle), cos(angle)); // which looked backwards\n  //\n  // He was mapping the angle from 0.0 with the mouse at the left\n  // edge and the line 'unbent' (it was actually open by 180)\n  // to  with the mouse at the right edge with the line 'folded\n  // back along itself', (i.e. actually open 0). This made visual\n  // sense - and fit the rest of his code - but is the opposite of\n  // how angles work geometrically. Substituting ( - mouse.x)\n  // into his numbers results in angle of 60, which is the \n  // complement of 30.\n  //\n  // But:\n  //\n  //   sin(-/6) = cos(2*/3) = -0.500, and\n  //   cos(-/6) = sin(2*/3) = +0.866\n  //\n  // And sine waves have many symmetries and many identities:\n  // sin() and cos() mirror each other across /4 (45), which\n  // is equidistant to both of our angles. You can uncomment his\n  // numbers above to verify that the results are the same.\n  \n  // Now we need to find the perpendicular distance from a point to\n  // the line of refection.\n\n  // The dot() product is used to tell the extent to which one\n  // vector is aligned to another. If we take the dot product of\n  // a point and our normal vector, it will tell us the perpendicular\n  // distance to/from the line of reflection along the normal vactor:\n  d = dot(uv,n);\n\n  // Our mirrors only have one side. Squash any points that are\n  // on the wrong side of the line of reflection, so they\n  // don't reflect back and whack points we like.\n  d = min(0.0, d);\n\n/*\n  // With our tools constructed, we add the second 'mirror': points\n  // above the line reflect back d * 2.0 units in direction n to\n  // reach the matching point on the white line.\n  uv -= 2.0 * d * n;\n  \n  // we should now have a peak in the middle third of the line.\n\n  // video @ 15:48, https://youtu.be/il_Qg9AqQkE?t=948\n\n  /**************************************************************/\n\n/*\n  // Now we want to add a layer of recursion, replacing the center\n  // of each segment in the Koch curve with a peak. Our first\n  // mirror copied everything we do on the right to the left, and\n  // our second mirror copied everything we do on the original\n  // line segment to the upper peak, so to change all four lines\n  // we only need to change the original segment, on the right.\n  \n  // At this point in the video he says we need to \"reset uv\".\n  // Hopefully it is clear that is what we have been doing all\n  // along - note that after the initial setup we never declare\n  // that uv *equals* something, we always modify it to 'move\n  // the mirrors' of our kaleidoscope. So before we repeat what\n  // we have done above, we need to do this to get reoriented:\n  uv.x  -= 0.5; // we move one-third to the right\n  uv    *= 3.0; // we 'zoom in' by another factor of 3\n  scale *= 3.0; // ... and keep track of that, for later\n  \n  // we then repeat the process from before:\n  uv.x  = abs(uv.x);                     // mirror the two sides\n  uv.x -= 0.5;                           // move the origin\n  uv   -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n\n  // video @ 18:04, https://youtu.be/il_Qg9AqQkE?t=1084\n\n  /**************************************************************/\n\n/*\n  // ... and we can copy/paste those 6 lines to add another\n  // layer of recursion:\n  uv.x  -= 0.5;       // move origin\n  uv    *= 3.0;       // scale\n  scale *= 3.0;       // keep track\n  uv.x   = abs(uv.x); // mirror\n  uv.x  -= 0.5;       // move to point of rotation/reflection\n  uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n\n  // video @ 18:44, https://youtu.be/il_Qg9AqQkE?t=1124\n\n  /**************************************************************/\n\n  // At this point in the video, the recursion steps above are\n  // refactored and changes are made all the way back up to near\n  // the beginning. To keep things linear I am going to reset\n  // some variables here, without comment except where things\n  // change, and continue down the page\n/*\n  // reset\n  scale = 1.0;\n  uv    = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  uv.x  = abs(uv.x);\n  \n  // To reflect to the other sides of the snowflake, we need to\n  // position a new mirror. We do this first so everything we do\n  // later will automatically be reflected. The mirror goes half-\n  // way between the 0 top and the 60 side, at 30 or /6.\n  // The normal vector will thus be 30 - 90 = -60, or -/3:\n  angle = -PI / 3.0;\n  n = vec2(cos(angle), sin(angle));\n  \n  // (In the video he once again uses the mouse method to get a\n  // different angle and swaps sin() and cos(), but it once\n  // again equals what we get from analyzing the geometry.)\n  \n  // We have been working on the line centered vertically in the\n  // canvas. We need to shrink space, and raise everything, to\n  // fit the entire snowflake pattern in the canvas:\n  uv *= 1.25;\n  uv.y += 1.0 / tan(-PI / 3.0) * 0.5;\n  \n  // In the video he takes the tangent of a different angle, but\n  // he once again has the angles defined backwards. Analytically\n  // this distance is proportional to the cotangent of -/3; there\n  // is no cot() function in GLSL, but cot() = 1 / tan().\n\n/*\n  // Move uv such that the normal vector touches the right corner\n  // and map points across the line. This mirror reflects the other\n  // way, so we use max(), instead of min(), to whack unwanted\n  // re-reflections.\n  d = dot(uv - vec2(0.5,0.0),n);\n  d *= 2.0;\n  d = max(0.0, d);\n  uv -= d * n;\n  \n  // Now that uv is properly set up, we can once again use abs() to\n  // map the points across the mirror and complete our triangle.\n  // Very little changes, because the other mirrors are already doing\n  // their jobs.\n  uv.x  = abs(uv.x);\n\n  /**************************************************************/\n  \n/*\n  // To make the first outward 'bend' we first reset uv:\n  uv.x += 0.5;\n\n  // ... and reset the angle:\n  angle = -PI / 6.0;\n  n = vec2(cos(angle), sin(angle));\n  \n  // ... and we're back to what we did before:\n  uv    *= 3.0;       // scale\n  scale *= 3.0;       // track\n  uv.x  -= 1.5;       // move origin\n  uv.x   = abs(uv.x); // mirror\n  uv.x  -= 0.5;       // move to point of rotation/reflection\n  uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n\n/*\n  // Add another layer of recursion:\n  uv    *= 3.0;       // scale\n  scale *= 3.0;       // track\n  uv.x  -= 1.5;       // move origin\n  uv.x   = abs(uv.x); // mirror\n  uv.x  -= 0.5;       // move to point of rotation/reflection\n  uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n  \n  // ... etc. //*/\n  \n/*\n  // Additional levels can loop through those 6 lines as many\n  // times as you want.\n  int t = 5;            // play with different values of t\n  for(int i = 0; i < t; i++) {\n    uv    *= 3.0;       // scale\n    scale *= 3.0;       // track\n    uv.x  -= 1.5;       // move origin\n    uv.x   = abs(uv.x); // mirror\n    uv.x  -= 0.5;       // move to point of rotation/reflection\n    uv    -= n * min(0.0, dot(uv,n)) * 2.0; // reflect and step\n  }\n\n  /**************************************************************/\n\n  // Now we actually *do* something with what we have wrought:\n  \n  // 'col' is the color that will be assigned to fragColor in\n  // the final line of the shader:\n  vec4 col = vec4(0.0);\n\n  // color the background to help visualize how space changes\n  col = vec4(uv, 0.0, 1.0);\n  \n  // .. unless you no longer want the colors, in which case you\n  // can uncomment the next line\n  //col = vec4(0.0);\n\n  // find the distance from uv to our little white line segment\n  float dist = length(uv - vec2(clamp(uv.x, 0.0, 1.0), 0.0));\n\n  // Note that the original code clamped uv.x to [-1.0,1.0].\n  // I removed the left half because we only needed the right\n  // half, *and* we explicitly blocked the left half with min().\n  // You can uncomment this to see that nothing changed:\n  //dist = length(uv - vec2(clamp(uv.x, -1.0, 1.0), 0.0));\n\n  // This is the only line that actually draws anything, assigning\n  // a color of white to any uv that is within a small distance from\n  // our line segment. Every other part of the Koch curve is being\n  // filled in by the 'mirrors' we added.\n  // Here we finally use 'scale' to account for line thinning.\n  col += smoothstep(1.0 / iResolution.y, 0.00, dist / scale);\n  \n/*\n  // It's time to get our kaleidoscope on, to see what all of\n  // our reflections did to the shape of uv space. To do this, \n  // we'll sample a texture image.\n  \n  // First we must renormalize uv so we're sampling the texture\n  // into the largest scale, so our mirrors can do their job of \n  // kaleidoscoping everything. (Without renormalizing, we'd be\n  // copying the sample into the *smallest* feature, which just\n  // looks like pixel soup.) Adding a sine wave to uv samples\n  // the image at different places, to make out kaliedoscope\n  // move:\n  uv /= scale;\n  col += texture(iChannel1, uv - sin(iTime * 0.1)); //*/\n  \n  // you can change the sampled texture by clicking on iChannel1,\n  // below. There are 3 pages of images. I like 'Organic 1' and\n  // 'Organic 2' the best, but if nyancat is your thing, go for it.\n\n  // apply col to the pixel\n  fragColor = vec4(col.rgb, 1.0);\n}\n\n/**************************************************************/\n\n// this just shows the splash screen at the beginning\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  fragColor = texture(iChannel0, uv);\n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/******************************************************\n\n  For this tutorial you can ignore buffer A, it just\n  adds the splash screen at the beginning.\n \n*******************************************************\n\n  Credits:\n\n    Text code adapted from ttoinou's 'YAS':\n        \n      https://www.shadertoy.com/view/Xd2fzK\n        \n    KIFS code adapted from BigWings' tutorial:\n  \n      https://www.shadertoy.com/view/tdcGDj\n      \n    Everything else: Michael Kennan, January 2021\n\n*******************************************************/\n\n/*\n * Char Map, chars written with \"0xab\" a is X coord b is Y coord\n * (this is reverse-endian from most ASCII tables)\n * \n *    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n * 3  0  1  2  3  4  5  6  7  8  9 \n * 4  @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O\n * 5  P  Q  R  S  T  U  V  W  X  Y  Z  [  \\  ]  ^  _\n * 6     a  b  c  d  e  f  g  h  i  j  k  l  m  n  o\n * 7  p  q  r  s  t  u  v  w  x  y  z\n *\n * One uvec4 => 16 characters\n */\n#define SPACE_CHAR (0x02U)\n#define STOP_CHAR  (0x0AU)\n\nfloat fontSize;\nfloat fontSpacing;\nvec4 fontCol;\nvec4 fontColor;\nvec4 fontBorder;\nvec4 fontBuffer;\nvec2 fontStart;\nvec2 fontUV;\n\nvoid drawStr4(uint str) {\n  while (str < 0x1000000U)\n    str = str * 0x100U + SPACE_CHAR;\n  \n  for (int i = 0; i < 4; i++) {\n    uint xy = (str >> 8 * (3 - i)) % 256U;\n    if (xy != SPACE_CHAR) {\n      vec2 K = (fontUV - fontStart) / fontSize;\n      if (length(K) < 0.6) { /* lookup skipping : avoid useless font texture lookup */\n        vec4 Q = texture(\n          iChannel1,\n          (K + vec2(float(xy/16U) + 0.5, 16.0 - float(xy%16U) - 0.5)) / 16.0\n        );\n        fontBuffer.rgb += Q.rgb * smoothstep(0.6, 0.4, length(K));\n\n        if (max(abs(K.x), abs(K.y)) < 0.5) {\n          fontBuffer.a = min(Q.a, fontBuffer.a);\n        }\n      }\n    }\n    if (xy != STOP_CHAR) fontStart.x += fontSpacing * fontSize;\n  }\n}\n\nvec2 N(float angle) {\n  return vec2(sin(angle), cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 N1  = vec2(sin(2.618), cos(2.618));\n  vec2 N2  = vec2(sin(2.094), cos(2.094));\n  vec4 col = vec4(0.0);\n\n  // draw the background\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  \n  uv   *= 1.25;\n  uv.x  = abs(uv.x);\n  uv.y += tan(2.618) * 0.5;\n  uv   -= max(0.0, dot(uv - vec2(0.5, 0.0), N1)) * N1 * 2.0;\n\n  uv.x  = abs(uv.x);\n  uv   *= 3.0;\n  uv.x -= 0.5;\n  uv   -= N2 * min(0.0, dot(uv,N2) * 2.0);\n  \n  float dist  = 0.0;\n  float scale = 1.0;\n  \n  // left: map red and green to background\n  if (fragCoord.x / iResolution.x < 0.33) {\n    col = vec4(fragCoord.xy / iResolution.xy, 0.0, 1.0);\n  }\n  \n  // center: Koch curve outline\n  //col  = vec4(0.0);//\n  //if (fragCoord.x / iResolution.x > 0.33) {\n    for(int i = 0; i < 2; i++) {\n      uv   *= 3.0; scale *= 3.0;\n      uv.x  = abs(uv.x - 1.5) - 0.5;\n      uv   -= N2 * min(0.0, dot(uv,N2)) * 2.0;\n    }\n    dist = length(uv - vec2(clamp(uv.x, 0.0, 1.0), 0.0));\n    col += smoothstep(0.01, 0.00, dist/scale);\n  //}\n  \n  // right: Koch KIFS\n  if (fragCoord.x / iResolution.x > 0.66) {\n    for(int i = 0; i < 10; i++) {\n      uv    *= 3.0;\n      scale *= 3.0;\n      uv.x = abs(uv.x - 1.5) - 0.5;\n      uv -= N2 * min(0.0, dot(uv,N2)) * 2.0;\n    }\n    col += texture(iChannel0, uv/scale - sin(iTime*0.3));\n  }\n\n  // add the text\n  fontUV      = fragCoord.xy / iResolution.xy - 0.5;\n  fontUV.x   *= iResolution.x / iResolution.y;\n  fontColor   = vec4(1.0);\n  fontBorder  = vec4(0.0);\n  fontSpacing = 0.45;\n  \n  fontSize    = 0.25;\n  fontStart   = vec2(-8.0 * fontSpacing * fontSize / 2.0, +0.15);\n  fontBuffer  = vec4(0.0,0.0,0.0,1.0);\n  drawStr4(uint(0xB4F43484)); // 'KOCH'\n  \n  fontStart   = vec2(2.0 * fontSpacing * fontSize / 2.0, +0.15);\n  drawStr4(uint(0xB4946435)); // 'KI*FS'\n  \n  fontSize    = 0.20;\n  fontStart   = vec2(-11.0 * fontSpacing * fontSize / 2.0, -0.15);\n  drawStr4(uint(0x35475607)); // 'Step'\n  drawStr4(uint(0x02249702)); // ' By '\n  drawStr4(uint(0x35475607)); // 'Step'\n  \n  float a = smoothstep(1.0, 0.0, smoothstep(.55,.58,fontBuffer.a));\n  float b = smoothstep(0.0, 1.0, smoothstep(.45,.55,fontBuffer.a));\n  fontCol   = mix(fontColor, fontBorder, b);\n  fragColor = mix(col, fontCol, a);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlVyR3", "name": "Ray-Parabola Intersection (2D)", "author": "oneshade", "description": "Ray intersector for a 2D parabola.", "tags": ["2d", "raytracing", "ray", "quadratic", "intersect", "parabola"], "likes": 4, "viewed": 147, "published": 3, "date": "1611437157", "time_retrieved": "2024-07-30T19:42:53.698025", "image_code": "vec3 IntersectParabola2D(in vec2 ro, in vec2 rd, in float a, in float b, in float c) {\n    float ra = a * rd.x * rd.x;\n    float rb = 2.0 * a * ro.x * rd.x + b * rd.x - rd.y;\n    float rc = a * ro.x * ro.x + b * ro.x + c - ro.y;\n\n    vec3 intersect = vec3(0.0);\n\n    // If the discriminant is less than zero there are no (real) roots\n    float discr = rb * rb - 4.0 * ra * rc;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * ra;\n        float t1 =  (root - rb) / denom; // 1st root\n        float t2 = -(rb + root) / denom; // 2nd root\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 0.25;\n    vec3 color = vec3(0.0);\n\n    float a = sin(time);\n    float b = cos(time);\n    float c = sin(time * 2.0);\n\n    // Draw the parabola\n    float g = 2.0 * a * uv.x + b; // Derivative for DE\n    float f = a * uv.x * uv.x + b * uv.x + c;\n    color += smoothstep(unit, 0.0, abs(uv.y - f) / sqrt(1.0 + g * g));\n\n    // Ray origin (ro) and ray direction (rd)\n    vec2 ro = vec2(cos(time * 0.75) * 2.0, sin(time * 1.5));\n    vec2 rd = sin(sin(time * 0.25) * 3.14 + vec2(1.57, 0.0));\n\n    // Draw the ray\n    color += smoothstep(unit, 0.0, length(uv - ro) - 0.1);\n    color += smoothstep(unit, 0.0, abs(dot(uv - ro, rd.yx * vec2(-1.0, 1.0))));\n\n    // Draw the intersections:\n    vec3 intersect = IntersectParabola2D(ro, rd, a, b, c);\n    if (intersect.z > 0.5) {\n        color += smoothstep(unit, 0.0, length(uv - ro - rd * intersect.x) - 0.05);\n        color += smoothstep(unit, 0.0, length(uv - ro - rd * intersect.y) - 0.05);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 641], [643, 643, 698, 698, 1806]], "test": "untested"}
{"id": "ttyyzc", "name": "Dancing Bezier Whisps ", "author": "blurryroots", "description": "Adaption of a bezier curve shader by https://www.shadertoy.com/user/oneshade concatinating three splines and adding whispy colory things through voronoi noise by https://www.shadertoy.com/view/Xd23Dh", "tags": ["sound", "music", "bezier", "color", "curve", "trippy", "plot", "para", "glowmetric"], "likes": 3, "viewed": 393, "published": 3, "date": "1611430288", "time_retrieved": "2024-07-30T19:42:54.539773", "image_code": "#define SAMPLE_POINT_LOW vec2 (0.09, 0.2)\n#define SAMPLE_POINT_MID vec2 (0.3, 0.1)\n#define SAMPLE_POINT_HIGH vec2 (0.8, 0.2)\n\n#define SOUND_IN\n\n#ifdef SOUND_IN\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n#endif\n\nfloat sampleMusic(vec2 p) {\n    return normalize (texture (iChannel0, p)).r;\n}\n\nfloat getBass () {\n    return sampleMusic(SAMPLE_POINT_LOW);   \n}\n\nfloat getMids() {\n    return sampleMusic(SAMPLE_POINT_MID);\n}\n\nfloat getTreble () {\n    return sampleMusic(SAMPLE_POINT_HIGH);   \n}\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = InvGold * sin(iTime) * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 Bezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv +\n           b * Pi * t * tInv * tInv +\n           c * Pi * tInv * t * t +\n           d * t * t * t;\n}\n\nvec3 DrawSnake(vec2 uv, vec3 color, vec2 pts[4], float size, float time, float beat) {\n    vec2 positionBuffer = pts[0];\n    float stepSize = 1.0 / 12.;\n    \n    for (float t=stepSize; t < (1.0 + stepSize); t += stepSize) {\n        vec2 p = Bezier(pts[0],pts[1], pts[2], pts[3], t);\n        color = max(color, mix(\n            color,\n            hue2rgb(time + t),\n            smoothstep(size, 0.0, sdLine(uv, positionBuffer, p))\n        ));\n        color = max(\n            color, \n            mix(color,\n                vec3(0.1), \n                1.-10.*abs(sin(time + t)*2.*beat)*smoothstep(size, 0.0, sdLine(uv, positionBuffer, p))\n            )\n        );\n        positionBuffer = p;\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #ifdef SOUND_IN\n    // Overlay by FabriceNeyret2 https://www.shadertoy.com/view/MtyXRW\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n    #endif\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vp = 0.8*(2.*getBass()+1.*getTreble())*cos(3.*vec2(1.0,0.5) );\n\tfloat f = 2.-1./voronoise( 24.0*uv, vp.x, vp.y );\n    vec3 color = f*getTreble()*1.5*vec3(Silver, Silver, DimGold);\n\n    float t1 = 0.5 * iTime, t2 = iTime, t3 = 1.25 * iTime;\n    float c1 = cos(t1), s1 = sin(t1)+.5*cos(t1-Pi);\n    float c2 = cos(t2), s2 = sin(t2 - 2.*Pi);\n    float c3 = cos(t3), s3 = sin(t3)-DimGold*cos(t3-Pi);\n\n    vec2 p[4];    \n    vec2 uvW = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float pointSize = 96.0 / iResolution.y;\n    \n    vec2 b = p[0] = vec2(s3 * 1.0, s2 * 1.0);\n    p[1] = vec2(c1, c2) * 3. * getTreble();\n    p[2] = vec2(c3 * 3.0, c2 * 1.0) * 2. * getTreble();\n    p[3] = vec2(s2 * 1.0, s1 * 1.0);   \n    color = DrawSnake(uvW, color, p, .5*pointSize, iTime, getTreble ());\n    \n    p[3] = p[3];//vec2(c2, s1);   \n    p[0] = vec2(c1, s2) - vec2(+1.);\n    p[1] = vec2(s3, c2) * 3. * getBass();\n    p[2] = vec2(c3, s2) * -2. * (getMids() + getTreble());\n    color = DrawSnake(uvW, color, p, pointSize, iTime, getMids());\n    \n    p[0] = p[0];//vec2(c1, s2) - vec2(+1.);\n    p[1] = vec2(s1, c2) * 3. * getBass();\n    p[2] = vec2(s2 * -2. * (getMids() + getTreble()), s1);\n    p[3] = b;//vec2(c2, s1);   \n    color = DrawSnake(uvW, color, p, DimGold*pointSize, iTime, getBass());\n    \n    color *= GetVignetteMask(uv, 16., 1.99);\n    \n    fragColor = vec4(color, 0.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Pi = 355.0 / 113.0; // Thx Zu Chongzhi.\nconst float PiHalf = Pi / 2.0;\nconst float TwoPi = 2. * Pi;\nconst float Gold = (1.+sqrt(5.))/2.;\nconst float InvGold = 1./Gold;\nconst float DimGold  = InvGold*InvGold;\nconst float Silver = DimGold*DimGold;\nconst vec3 LUMA = vec3((1.-0.618)*0.6, 0.618, (1.-0.618)*0.4);\n\nfloat GetScaledTime(float rawTime) {\n    return rawTime*Pi;\n}\n\n// https://www.shadertoy.com/view/lsKSWR\nfloat GetVignetteMask(vec2 uv, float intensity, float extend) {\n    uv = uv * (1.0 - uv);\n    float mask = uv.x*uv.y * intensity;\n    return pow(mask, extend);\n}\n\nfloat getLuminance(vec3 rgb) {\n  return rgb.r * LUMA.r + rgb.g * LUMA.g + rgb.b * LUMA.b;\n}\n\n// Trig functions positive normalized.\n// Checkout https://www.desmos.com/calculator/tkqvncozq4 for a visualization of the approach.\n\nfloat psin(float x) {\n    return .5 * sin(x - PiHalf) + .5;\n}\nvec3 psin(vec3 x) {\n    return vec3(psin(x.r), psin(x.g), psin(x.b));\n}\n\nfloat pcos(float x) {\n    return .5 * sin(x) + .5;\n}\nvec3 pcos(vec3 x) {\n    return vec3(pcos(x.r), pcos(x.g), pcos(x.b));\n}\n\nfloat ptan(float x) {\n    return .87 * tan(x - Pi/2.3) + .5;\n}\nvec3 ptan(vec3 x) {\n    return vec3(ptan(x.r), ptan(x.g), ptan(x.b));\n}\n\n// Voronoi pattern from https://www.shadertoy.com/view/Xd23Dh\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[696, 696, 723, 723, 774], [776, 776, 794, 794, 841], [843, 843, 860, 860, 904], [906, 906, 926, 926, 974], [1113, 1113, 1160, 1160, 1317], [1319, 1319, 1388, 1388, 1551], [1553, 1553, 1639, 1639, 2273], [2275, 2275, 2330, 2330, 3979]], "test": "untested"}
{"id": "wtGyzc", "name": "Fractal tile mosaic", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "tile", "mosaic"], "likes": 6, "viewed": 284, "published": 3, "date": "1611428983", "time_retrieved": "2024-07-30T19:42:55.297746", "image_code": "float fract1(float a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvec2 fract1(vec2 a){\n    return (abs(fract(a/2.0)-.5))*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    \n        vec2 uv = (fragCoord*40.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/8.0)/2.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.5;\n        float scale1 = 2.0;\n        for(int i=0;i<3;i++)\n        {\n            uv = (fract1(uv/scale1)+fract1(uv/scale/2.0))*scale1;\n            uv= fract1(uv/(2.0-fract1((uv.x-uv.y)/(8.0)))-(uv/(1.7+(fract1(uv.x+uv.y))))/scale)*scale/scale1+scale1*scale;\n            uv /= scale1+col.yx;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = abs(fract(uv.y)-fract(uv.x));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 63], [65, 65, 85, 85, 126], [128, 128, 185, 185, 871]], "test": "untested"}
{"id": "3tKyzV", "name": "T-800 (Model 101)", "author": "dean_the_coder", "description": "\"I need your clothes, your boots, and your motorcycle.\"  And your GPU...\nSlow to compile on Windows, but nearly instant on my (old) Mac.  Apologies...", "tags": ["3d", "raymarching", "terminator", "movie", "cineshader"], "likes": 28, "viewed": 9949, "published": 3, "date": "1611418337", "time_retrieved": "2024-07-30T19:42:56.058712", "image_code": "// 'T-800 (Model 101)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/3tKyzV\n//\n// I wanted to create a metal material, and found a\n// cool resource describing the physical properties\n// of metal:\n//   https://www.chaosgroup.com/blog/understanding-metalness\n//\n// What better scene to try it than the T-800 arm\n// from Terminator 2? :)\n//\n// Tricks to get the performance:\n//   - The map() function checks if the point is within\n//\t the glass.  If not in the glass, we don't bother\n//\t calculating the SDF of the arm.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define Z0 min(iTime, 0.)\n\nfloat open;\n\n//#define AA\t// Disable to improve frame rate.\n\nvoid minH(inout vec2 a, vec2 b) {\n\tif (b.x < a.x) a = b;\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n\treturn mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.));\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdRod(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.)) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat sdPinkyPin(vec3 p) {\n\tp.x += .18;\n\treturn sdCapsule(p.yxz, .34, .12);\n}\n\nfloat sdPinky(vec3 p) {\n\tp.y -= .7;\n\n\tfloat d = sdCyl(p, vec2(.16));\n\tp.y += .24;\n\td = min(d, sdCyl(p, vec2(.2, .14))) - .04;\n\tp.y += .5;\n\td = min(d, sdPinkyPin(p));\n\tp.x += .12;\n\treturn min(d, max(sdCapsule(p, .3, .2), abs(p.x) - .1));\n}\n\nfloat sqHinge(vec3 p, float thk) {\n\tp.y += .2;\n\n\tvec3 tp = p;\n\ttp.x -= .12;\n\ttp.y += .1;\n\tfloat d = max(sdCapsule(tp, .38, .2), abs(tp.x) - .1);\n\tp.y += .1 + .04 * thk;\n\treturn max(min(d, sdBox(p, vec3(.2, .04 * thk, .19))), -p.y - .04);\n}\n\nfloat fingerBone(vec3 p, float l) {\n\tfloat d = min(\n\t\t\t\tsqHinge(p, 1.),\n\t\t\t\tsqHinge(p * vec3(-1, -1, 1) - vec3(0, l, 0), 1.));\n\n\tp.y += l * .5;\n\treturn min(d, sdCyl(p, vec2(.16, 1. - .8 / l)));\n}\n\nvec3 pToPinkyAttach(vec3 p, float r) {\n\tp.z += abs(r) * 5. - .7;\n\tmat2 t = rot(-r);\n\tp.xz *= t;\n\tp.xy *= t;\n\tp.yz *= rot(open * -.5);\n\n\tp.y -= .35;\n\tp.z += .25;\n\treturn p;\n}\n\nfloat sdFinger(vec3 p, float l1, float l2, float r, float r2) {\n\tp.z += abs(r) * 5. - .7;\n\tmat2 t = rot(-r);\n\tp.xz *= t;\n\tp.xy *= t;\n\n\t// Base hinge.\n\tfloat d = min(sqHinge(p, 4.), sdCyl(p + vec3(0, 2, 0), vec2(.14, 1.5)));\n\td = min(d, sdBox(p + vec3(0, .65, 0), vec3(.2, .12, .2 + step(abs(p.x), .08) * .03)));\n\n\tp.yz *= rot(open * -.5 + r2);\n\tvec3 fp, s, o = vec3(0, l1, 0);\n\n\t// Base bone.\n\td = min(d, min(sdPinkyPin(p), sdPinkyPin(p - o)));\n\t// todo - Bail ealy here?\n\td = min(d, fingerBone(p - o, l1));\n\n\t// Middle bone.\n\ts = o;\n\ts.yz += vec2(l2, 0) * rot(open);\n\tfp = p - s;\n\tfp.yz *= rot(-open);\n\td = min(d, fingerBone(fp, l2));\n\n\t// Pinky\n\tfp = p - s;\n\tfp.yz *= rot(open * -2.);\n\treturn min(d, sdPinky(fp));\n}\n\nfloat sdFingers(vec3 p) {\n\tp.x += .7 * 1.5;\n\tfloat d = sdFinger(p, .9, .85, -.1, 0.);\n\tp.x -= .7; d = min(d, sdFinger(p, 1.2, 1., -.03, 0.));\n\tp.x -= .7; d = min(d, sdFinger(p, 1.3, 1.1, .03, 0.));\n\tp.x -= .7;\n\treturn min(d, sdFinger(p, 1.2, 1.05, .1, 0.));\n}\n\nfloat pinkyPiston(vec3 p, vec3 basep, float r) {\n\tp = pToPinkyAttach(p, r);\n\n\tfloat d = step(length(vec3(0, -.2, -.2) - basep), 3.2) * .04;\n\treturn min(\n\t\tsdRod(p, vec3(0, -.03, .08), vec3(0, -.2, -.2), .05),\n\t\tsdRod(p, p - basep, vec3(0, -.2, -.2), .05 + d));\n}\n\nfloat sdPiston(vec3 p, vec3 p1, vec3 p2, float b) {\n\tp1.y -= .1;\n\tfloat l = p.y - p1.y;\n\tfloat r = .14\n\t\t\t  + .04 * step(-1.3, l) * sign(sin(p.y * 6. - 4.))\n\t\t\t  + .15 * b * smoothstep(-5., -5.1, l),\n\t\t\t  d = sdRod(p, p1, p2, r);\n\n\tp -= mix(p1, p2, .79);\n\tp.y = abs(abs(p.y) - .7) - .1;\n\treturn min(d, sdCyl(p, vec2(.16 + .15 * b, .05)));\n}\n\nfloat sdArm(vec3 p) {\n\t// Thumb.\n\tvec3 fp = p;\n\tfp.xz *= rot(-1.4);\n\tfloat d = min(sdFingers(p),\n\t\t\t\t  max(\n\t\t\t\t\t sdFinger(fp + vec3(-.5, 2.7, .05), 1.5, 1.4, .03, 1.),\n\t\t\t\t\t -fp.y - 3.5));\n\n\t// Wrist plate.\n\tfp = p;\n\tp.y += 3.5;\n\td = min(d, sdCyl(p, vec2(1, .1)));\n\n\t// Finger hydraulics.\n\tfp.x += .7 * 1.5; d = min(d, pinkyPiston(fp, p + vec3(.5, 0, .4), -.1));\n\tfp.x -= .7; d = min(d, pinkyPiston(fp, p + vec3(.2, 0, .6), -.03));\n\tfp.x -= .7; d = min(d, pinkyPiston(fp, p + vec3(-.1, 0, .5), .03));\n\tfp.x -= .7; d = min(d, pinkyPiston(fp, p + vec3(-.6, 0, .1), .1));\n\n\t// Main arm bone.\n\tfp = p;\n\tfp.y += 4.;\n\td = min(d, sdCyl(fp, vec2(.35 + step(3., fp.y) * (.1 - .02 * sign(abs(sin(fp.y * 24. + 1.6)) - .8) * step(fp.y, 3.5)), 4)));\n\n\t// Arm base.\n\td = min(min(d, length(p + vec3(0, 7.1, 1.25)) - .05),\n\t\t\tmax(abs(sdCyl(p + vec3(0, 7, .1),\n\t\t\t\t\t\t  vec2(1.1 - .01 *\n\t\t\t\t\t\t\t\t (\n\t\t\t\t\t\t\t\t\t step(abs(p.y + 7.7), .04) *\n\t\t\t\t\t\t\t\t\t step(.04, abs(p.x) - .3) -\n\t\t\t\t\t\t\t\t\t step(.04, abs(abs(p.x) - .3))\n\t\t\t\t\t\t\t\t ),\n\t\t\t\t\t\t\t   1\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t )) - .06,\n\t\t\t\tp.y - .3 * p.z + 6.6));\n\n\t// Arm pistons.\n\td = min(d, sdPiston(p, vec3(0, 0, -.8), vec3(0, -7.5, -.7), 1.5));\n\tp.x = abs(p.x) - .7;\n\treturn min(d, sdPiston(p, vec3(0), vec3(-.1, -7.5, 0), 1.));\n}\n\nfloat sdGlass(vec3 p) {\n\treturn sdCapsule(p + vec3(0,11,0), 13.5, 3.2);\n}\n\n// Map the scene using SDF functions.\nvec2 map(vec3 p) {\n\tvec2 h = vec2(min(p.y + 11.7, 6. - p.z), 1);\n\n\tif (sdGlass(p) < 0.)\n\t\tminH(h, vec2(sdArm(p - vec3(0,1.4,0)) * .8, 2));\n\n\tp.y += 10.9;\n\tminH(h, vec2(sdCyl(p, vec2(3.1, .5)) - .2, 2));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0017319 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * t).x;\n\t}\n\n\treturn normalize(n);\n}\n\nvec3 glassN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .0017319 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdGlass(p + e);\n\t}\n\n\treturn normalize(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).x / h; }\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tvec3 ld = normalize(vec3(12, 5, -10) - p),\n\t\t n = calcN(p, d), c;\n\tfloat f, alb;\n\n\tif (h.y == 1.) {\n\t\t// Walls.\n\t\talb = max(0., .1 + .9 * dot(ld, n));\n\t\tc = vec3(.5, .7, 1);\n\t\tf = .3;\n\t} else {\n\t\t// Metal.\n\t\tc = vec3(.6);\n\t\talb = 1.;\n\t\tf = 10.;\n\t}\n\n\tfloat ao = ao(p, n, .3),\n\n\t// Primary light.\n\tl1 = alb * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 3. * f)) * f,\n\n\t// Fresnel\n\tfre = 1. - smoothstep(.4, 1., 1. + dot(rd, n));\n\n\tif (h.y == 3.) // Glass\n\t\treturn vec3(spe);\n\n\t// Combine into final color.\n\tfloat lig = (l2 + spe) * ao + l1;\n\treturn fre * lig * c * vec3(2, 1.8, 1.7);\n}\n\nfloat glassCol(vec3 p, vec3 rd) {\n\tvec3 ld = normalize(vec3(12, 5, -10) - p),\n\t\t n = glassN(p);\n\treturn .01 + pow(max(0., dot(rd, reflect(ld, n))), 30.) * 3. + smoothstep(.4, 1., 1. + dot(rd, n)) * .3;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p = ro, col = vec3(0);\n\n\tfloat d = .01;\n\tvec2 h;\n\tbool inGlass = false, doneGlass = false;\n\tfor (float i = Z0; i < 120.; i++) {\n\t\th = map(p);\n\n\t\tfloat g = abs(sdGlass(p));\n\t\tif (!doneGlass && g < .005) {\n\t\t\tfloat c = glassCol(p, rd);\n\t\t\tif (!inGlass) {\n\t\t\t\tinGlass = true;\n\n\t\t\t\t// Add slight glass refraction.\n\t\t\t\tp += .5 * refract(rd, glassN(p), 1.0/3.);\n\t\t\t} else {\n\t\t\t\tc *= .1;\n\t\t\t\tdoneGlass = true;\n\t\t\t}\n\n\t\t\tcol += c;\n\t\t\tg += .1;\n\t\t}\n\n\t\tif (abs(h.x) < .005)\n\t\t\tbreak;\n\n\t\td += min(g, h.x); // No hit, so keep marching.\n\t\tp += rd * min(g, h.x);\n\t}\n\n\tcol += lights(p, rd, d, h) * exp(d * d * -.001);\n\n\tif (h.y == 1.)\n\t\treturn col; // Hit wall - No reflection needed.\n\n\t// We hit metal, so march along a reflection ray.\n\trd = reflect(rd, calcN(p, d)); ro = p; d = .01;\n\tfor (float i = Z0; i < 40.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.x) < .005)\n\t\t\tbreak;\n\n\t\td += h.x;\n\t}\n\n\treturn abs(h.x) < .005 ?\n\t\tmix(col, .6 * lights(p, rd, d, h), .9) :\n\t\tmix(col, vec3(1), .5);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\topen = .4;\n\n\tfloat T = mod(iTime * 2.5, 36.),\n\t\t  dim = 1. - pow(abs(cos(clamp(min(T, abs(T - 12.)), -1., 1.) * 1.57)), 10.);\n\n\tvec3 ro, lookAt;\n\tif (T < 12.) {\n\t\tfloat p = remap(T, 0., 12., 0., 1.);\n\t\tro = mix(vec3(-6, -6, -23), vec3(6, 2, -15), p);\n\t\tlookAt = mix(vec3(0, -5, 0), vec3(0, -2, 0), p);\n\t} else if (T < 24.) {\n\t\tfloat p = remap(T, 12., 24., 0., 1.);\n\t\tro = mix(vec3(2, -10, -9), vec3(-2, -4, -9), p);\n\t\tlookAt = mix(vec3(0, -10, 0), vec3(0), p);\n\t} else if (T < 36.) {\n\t\tfloat p = remap(T, 24., 36., 0., 1.);\n\t\tro = mix(vec3(3, 0, -12), vec3(-3, 0, -15), p);\n\t\tlookAt = vec3(0, -1, 0);\n\t\topen = .35 * sin(p * 11.) + .7462;\n\t}\n\n#ifdef AA\n\tvec3 col = vec3(0);\n\tfor (float dx = Z0; dx <= 1.; dx++) {\n\t\tfor (float dy = Z0; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n\t\t\tcol += march(ro, getRayDir(ro, lookAt, uv));\n\t\t}\n\t}\n\tcol /= 4.;\n#else\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, getRayDir(ro, lookAt, uv));\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0);\n}\n", "image_inputs": [{"id": 25282, "src": "https://soundcloud.com/randyheavenridgemusic/terminator-theme", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyzV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[837, 837, 870, 870, 895], [897, 897, 965, 965, 1032], [1034, 1034, 1053, 1053, 1113], [1115, 1115, 1144, 1144, 1231], [1233, 1233, 1263, 1263, 1363], [1365, 1365, 1408, 1408, 1460], [1462, 1462, 1508, 1508, 1614], [1616, 1616, 1663, 1663, 1796], [1798, 1798, 1824, 1824, 1875], [1877, 1877, 1900, 1900, 2115], [2117, 2117, 2151, 2151, 2356], [2358, 2358, 2393, 2393, 2553], [2555, 2555, 2593, 2593, 2728], [2730, 2730, 2793, 2793, 3447], [3449, 3449, 3474, 3474, 3708], [3710, 3710, 3758, 3758, 3972], [3974, 3974, 4025, 4025, 4314], [4316, 4316, 4337, 4348, 5563], [5565, 5565, 5588, 5588, 5638], [5640, 5678, 5696, 5696, 5894], [5896, 5896, 5925, 5925, 6128], [6130, 6130, 6151, 6151, 6352], [6354, 6382, 6417, 6417, 6448], [6536, 6536, 6568, 6568, 6683], [6685, 6685, 6732, 6732, 7480], [7482, 7482, 7515, 7515, 7685], [7687, 7687, 7717, 7731, 8722], [8724, 8724, 8769, 8769, 9872]], "test": "untested"}
{"id": "wtGcz3", "name": "1-Sample antialiasing?", "author": "Ric3cir121", "description": "This is an example of an antialiasing that use only one sample per frame", "tags": ["fast", "antialiasing", "sample"], "likes": 3, "viewed": 346, "published": 3, "date": "1611416738", "time_retrieved": "2024-07-30T19:42:56.828653", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = texelFetch(iChannel0,ivec2(u),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n\nfloat de(vec3 c){\n    return min(c.y+1.,length(c)-.2);\n}\nvec3 getmarch(vec3 pos,vec3 cam){\n    float d = 1.;\n    vec3 march = pos;\n    \n    for(int i = 0;i< 100;i++){\n        d = de(march);\n        march += d*cam;\n        if(d<0.01||length(cam)>100.)break;\n    }\n    return march;\n}\nvec3 getcolor(vec3 pos){\n    return de(pos)<1.?texture(iChannel1,pos.xz).xyz:vec3(.1,.5,.9);\n}\n#define hash11(iTime) fract(sin(iTime)*100.)\n#define _pos(iTime) vec3(sin((iTime)/2.),abs(sin(iTime))/2.,-1)\n#define _look(iTime) vec2(sin(iTime)/2.,0)\nvec3 image(out vec4 o,vec2 u){\n    vec2 uv = ((u+hash11(iTime))*2.-iResolution.xy)/iResolution.y;\n    vec2 look = _look(iTime);\n    vec3 pos = _pos(iTime);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,look.y).yxz,look.x);\n    vec3 march = getmarch(pos,cam);\n    \n    o.xyz = getcolor(march);\n    \n    return march;\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec3 pos = _pos(iTime-iTimeDelta);\n    vec2 look = _look(iTime-iTimeDelta);\n\n    vec4 col;\n    vec3 new = image(col,u);\n    \n    vec3 rot = rotate(rotate(normalize(new-pos),-look.y),-look.x);\n    vec2 R = iResolution.xy;\n    vec2 read = (rot.xy/normalize(rot).z*R.yy-hash11(iTime-iTimeDelta)*2.)/R/2.+.5;\n    vec4 tex = clamp(read,0.,1.)==read?texture(iChannel0,read):vec4(0,0,0,-10000);\n    o.xyz = mix(col.xyz,clamp(tex.xyz,0.,1.),1.-abs(tex.w-length(new))<.0?.0:.98);\n    o.w = length(new);\n    if(iMouse.z>0.)o.xyz = vec3(0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 78]], "test": "untested"}
{"id": "wtyyz3", "name": "Fake Blue noise (Voronoi-ed)", "author": "Dutracgi", "description": "Interesting...", "tags": ["voronoi", "noise", "blue", "bluenoise", "render"], "likes": 1, "viewed": 387, "published": 3, "date": "1611415610", "time_retrieved": "2024-07-30T19:42:57.893805", "image_code": "//2D noise generator & voronoi code -> https://www.youtube.com/watch?v=l-07BXzNdPw\nvec2 n22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //color\n    float m = 0.;\n    \n     //noise size 1/size\n    float mul = 16.;\n    \n    //local grids\n    vec2 gv = fract(uv*mul)-0.5;\n    //grid ids\n    vec2 id = floor(uv*mul);\n    \n    float MinDist = 100.;\n    vec2 point;\n\n    vec3 col = vec3(0);\n    //Voronoi-ing\n    for(float y = -2.; y<2.; y++){\n        for(float x = -2.; x<2.; x++){\n            vec2 of = vec2(x,y);\n            //random point generation (blue noise like)\n            vec2 p = of+sin(n22(id+of)*iTime)*0.4;\n            float d = length(gv-p);\n            if(d < MinDist){\n               //Cell Distance\n               MinDist = d;\n               //cell_index;\n               point = n22(id+of);\n            }\n        }\n    }\n    \n    //out color\n     if(smoothstep(0.1,0.08,MinDist)>0.0)\n         col = vec3(0);\n     else\n         col = vec3(1,.15,0)+vec3(point.x,point.y,0)*.2;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 83, 100, 100, 225], [227, 227, 284, 335, 1318]], "test": "untested"}
{"id": "tlGcR3", "name": "otherworld galaxy", "author": "YitingLiu", "description": "The sun is a pancake in another world. I created another galaxy in my mind. ", "tags": ["noise", "time", "sin", "color", "circle", "rotate", "cos", "galaxy", "distance", "radius", "pancake", "shadershop"], "likes": 1, "viewed": 282, "published": 3, "date": "1611412573", "time_retrieved": "2024-07-30T19:42:58.909092", "image_code": "// 2D Noise exercise with distance field \n\n\n#define PI 3.14159265359\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle (in vec2 _st, in float _radius, in float _size){\n    vec2 dist = _st-vec2(0.5);\n    return smoothstep(_radius-_radius*_size,_radius+_radius*_size,dot(dist,dist)*4.0) ;       \n}\n\n//shadershop function generation:http://tobyschachman.com/Shadershop/editor/\nfloat extension(in float x){\n        return ((abs( x/3. )) + floor( x / 3. / 4.22 ) + ((x / 3.)) + (fract( x / 3. ))) * 0.35;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n    vec3 color=vec3(0.0);\n    \n    // assign color value to the vec3 color with the extension function\n    // smoothstep to create blur effect of the middle circle \n    \n    float colorVal = circle(st+0.5,extension(abs(cos(iTime))),random(vec2(10.)*smoothstep(0.,PI,tan(iTime))));\n    \n    // Scale the coordinate system to see\n    // some noise in action\n    \n    // find the center of the shortest side \n    st-=min(st.x/2.,st.y/2.);\n    st = rotate2d( sin(cos(iTime))*PI*(abs(cos(iTime))/1e2+1.)) * st/abs(sin(iTime));\n    vec2 pos = vec2(st*0.756*abs(tan(iTime))*10.);\n    st+=min(st.x/2.,st.y/2.);\n\n\n    st-=min(st.x/2.,st.y/2.);\n    st *= rotate2d( PI*(fract(iTime))/1e3+fract(sin(iTime))) * st/(0.1+abs(sin(iTime)));\n    st *= rotate2d( PI*(cos(iTime))/1e2+1.) * st/3.280;\n    // Use the noise function with distance field \n    float n = noise(pos)*distance(st-vec2(0.760,0.670)*abs(sin(iTime)),pos);\n    st+=min(st.x/2.,st.y/2.);\n    \n    // color manipulation based on time and shapes \n    color=vec3(n,colorVal*abs(cos(iTime)),random(st-vec2(1e2*iTime/2.)));\n    color*=vec3(st.x,colorVal*abs(cos(iTime))*st.y,random(st-vec2(clamp(abs(sin(iTime)),0.,0.8))));\n    color-=color*colorVal*10.;\n\n    fragColor = vec4(color+abs(cos(iTime)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 82, 109, 109, 226], [228, 315, 341, 341, 858], [860, 860, 888, 888, 974], [976, 976, 1037, 1037, 1165], [1167, 1244, 1272, 1272, 1372], [1373, 1373, 1430, 1430, 2773]], "test": "untested"}
{"id": "3tyyzc", "name": "z Slime mold", "author": "illus0r", "description": "Slime mold simulation\nsensor snippet is from https://www.shadertoy.com/view/ttjSW1", "tags": ["slime", "cellular"], "likes": 2, "viewed": 540, "published": 3, "date": "1611406983", "time_retrieved": "2024-07-30T19:42:59.919390", "image_code": "void mainImage( out vec4 o, vec2 FC ) {\n    o = texelFetch(iChannel1,ivec2(FC),0);\n    o.rgb = pow(o.rgb,vec3(.3));\n    //o.rgb = pow(vec3(o.a),vec3(1.));\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R 1. // interaction radius\n#define C 2. // max speed\n#define LOOKUP_DIST (.1*1280./iResolution.x * iMouse.x/iResolution.x)\n#define LOOKUP_ANGLE (iMouse.y/iResolution.y)\n#define rnd(x) fract(54321.987*sin(987.12345*x))\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n", "buffer_a_code": "vec2 turn(vec2 uv, vec2 p){\n    vec2 sensorL = uv+(rot(-LOOKUP_ANGLE)*p)*LOOKUP_DIST; // location of sensor A\n    vec2 sensorC = uv+p*LOOKUP_DIST;\n    vec2 sensorR = uv+(rot(LOOKUP_ANGLE)*p)*LOOKUP_DIST;\n\n    float senseL = texture(iChannel1, sensorL).a;\n    float senseC = texture(iChannel1, sensorC).a;\n    float senseR = texture(iChannel1, sensorR).a;\n\n    if (senseC < senseL && senseC < senseR){\n      if(rnd(p.x)<.5)\n          p*=rot(LOOKUP_ANGLE);\n      else\n          p*=rot(-LOOKUP_ANGLE);\n    }\n    else if(senseL < senseR){\n      p *= rot(-LOOKUP_ANGLE);\n    }\n    else if(senseL > senseR){\n      p *= rot(LOOKUP_ANGLE);\n    }\n    return p;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 FC ){\n    vec2 uv=FC.xy/iResolution.xy,p_g,v_g;\n    vec4 n,g;\n    o-=o;\n    if(mod(iTime, 20000.)<=4.1){if(length(mod(vec2(FC.xy-.5), 10.)) == 0. && length(uv-.5) < .5)o+=vec4(.5,.5,-(uv+.5)*.5+.5);return;}\n    for(float i=-C;i<=C;i++){\n      for(float j=-C;j<=C;j++){\n        vec2 ij=vec2(i,j);\n        vec2 uv_g = fract(uv+ij/iResolution.xy);\n        g=texture(iChannel0,uv_g);\n        if(length(g)==0.)continue;\n        p_g=g.rg+ij;\n        v_g=g.ba;\n        if(p_g+v_g==fract(p_g+v_g)){\n          p_g = fract(p_g+v_g);\n          v_g=turn(uv_g,v_g);\n          \n          //v_g+=vec2(.0,.2)*rot(atan(uv.y-.5,uv.x-.5));\n          \n          vec2 g_ij=ij;\n          float sig = round(rnd(length(uv)))*2.-1.;\n          for(float di=-R*sig;abs(di)<=R;di+=sig){\n            for(float dj=-R*sig;abs(dj)<=R;dj+=sig){\n              vec2 n_ij=vec2(g_ij.x+di,g_ij.y+dj);\n              if(length(n_ij)>0.&&length(n_ij)<R){\n                vec2 uv_n=fract(uv+n_ij/iResolution.xy);\n                n=texture(iChannel0,uv_n);\n                if(length(n)==0.)continue;\n                vec2 p_n = n.rg+n_ij;\n                float dist=length(p_g-p_n);\n                v_g+=.5*normalize(p_g-p_n)/(dist*dist);\n              }\n            }\n          }\n          \n          v_g=C*normalize(v_g);\n          o=vec4(p_g,v_g);\n          break;\n        }\n      }\n    }\n\n    if(length(o)==0.){\n        vec2 ij=vec2(.0,2.)*rot(3.14159265*.5*float(iFrame%4));\n        vec4 n=texture(iChannel0,fract(uv+ij/iResolution.xy));\n        if(length(n)==0.)\n            return;\n        if(rnd(length(uv)+iTime)<.08)\n            o=n;\n    }\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 o, in vec2 FC ){\n    if(iFrame==0){o-=o;return;}\n    vec2 uv=FC.xy/iResolution.xy;\n    vec4 cell=texture(iChannel0,uv);\n    if(length(cell)>0.){o=vec4(cell.zw/C*.5+.5,1.,1.);return;}\n    o=(texture(iChannel1,uv,.1))*.99;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 156]], "test": "untested"}
{"id": "3tyczc", "name": "Fork Mandelbulb michaelzfr 088", "author": "michaelzfreeman", "description": "FORKED: My first forked edit ! Showing off my edit to allow chroma keying in video editing software once exported to frames. I just edited out two lines @ \"// color sky\" but need to add an actual chroma key colour rather than the default black.\n", "tags": ["3d", "raymarching", "fractal", "distancefield"], "likes": 1, "viewed": 333, "published": 3, "date": "1611405581", "time_retrieved": "2024-07-30T19:43:00.793054", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: https://iquilezles.org/articles/mandelbulb\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return -b + vec2(-h,h);\n}\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = raycast( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \t//col  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\t//col += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n\t\t//col = vec3(0.1);\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient\n        \t lin += 4.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n        col += spe1*15.0;\n        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occ)*(0.03+0.97*pow(fac,5.0))*smoothstep(0.0,0.1,ref.y )*softshadow( pos+0.01*nor, ref, 2.0 );\n        //col = vec3(occ*occ);\n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.1;\n\n    // camera\n\tfloat di = 1.4+0.1*cos(.29*time);\n\tvec3  ro = di*vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n    // render\n    #if AA<2\n\tvec3 col = render(  fragCoord, cam );\n    #else\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n\t    col += render( fragCoord + (vec2(i,j)/float(AA)), cam );\n    }\n\tcol /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyczc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[524, 524, 577, 577, 772], [774, 774, 817, 817, 2093], [2095, 2095, 2166, 2166, 2723], [2725, 2725, 2781, 2781, 3055], [3057, 3057, 3114, 3114, 3345], [3451, 3451, 3490, 3504, 5756], [5762, 5762, 5819, 5819, 6611]], "test": "untested"}
{"id": "3lyyzc", "name": "really fast blur", "author": "Ric3cir121", "description": "as shown here you can see a 9 samples fast blur using mimap levels", "tags": ["blur", "fast"], "likes": 7, "viewed": 1187, "published": 3, "date": "1611403494", "time_retrieved": "2024-07-30T19:43:01.619843", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = vec4(0);\n    \n    float blur = u.x/iResolution.x*7.;\n    \n    for(int i = -1;i<2;i++)for(int j = -1;j<2;j++)\n    o += texture(iChannel0,vec2(u/iResolution.xy)+vec2(i,j)/iChannelResolution[0].xy*blur*1.,blur);\n    o/=9.;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 264]], "test": "untested"}
{"id": "3lGyzc", "name": "Fake Tilt Shift / Miniature", "author": "serkan3k", "description": "Selective grain & simple radial blur applied except for an arbitrary quad. Inverse bilinear interpolation gives the appropriate UVs for the masking quad.", "tags": ["tiltshift", "selective", "miniature"], "likes": 1, "viewed": 738, "published": 3, "date": "1611399037", "time_retrieved": "2024-07-30T19:43:02.480542", "image_code": "// to see borders of the arbitrary quad, make this 1\n#define DRAWBORDERS 0\n\n// https://iquilezles.org/articles/ibilinear\nfloat cross2d(in vec2 a, in vec2 b ) { \n    return a.x*b.y - a.y*b.x; \n}\nvec2 invBilinear(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n    float k2 = cross2d(g,f);\n    float k1 = cross2d(e,f) + cross2d(h,g);\n    float k0 = cross2d(h,e);\n    float w = k1*k1 - 4.0*k0*k2;\n    if(w<0.0) {\n        return vec2(-1.0);\n    }\n    w = sqrt(w);\n    float v = 2.0*k0/(-k1 - w); \n    if(v<0.0 || v>1.0) v = 2.0*k0/(-k1 + w);\n    float u = (h.x - f.x*v)/(e.x + g.x*v) ;\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) {\n        return vec2(-1,0);\n    }\n    return vec2( u, v );\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h);\n}\n\nfloat rand(vec2 uv){\n return fract(sin(dot(uv, vec2(12.9898,78.233)))*43578.5453);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    fragColor = vec4(0.0);\n    vec2 a = vec2(-1,0.75);\n    vec2 b = vec2(1,0.75);\n    vec2 c = vec2(1.8,-0.5);\n    vec2 d = vec2(-1.8,-0.5);  //d = c + a -b;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mask_uv = invBilinear(p,a,b,c,d );\n    if( mask_uv.x>-1.0 && mask_uv.x < 1.0){\n        fragColor = vec4(texture(iChannel0, uv).xyz, 1.0);\n#if DRAWBORDERS\n        float h = 5.0/iResolution.y;\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,a,b)));\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,b,c)));\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,c,d)));\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,d,a)));\n#endif\n    }\n    else{\n        float dist = 1.0; \n        int iterations = 10; \n        vec2 texel = 1.0 / iResolution.xy;\n        vec2 texel_dist = texel * dist;\n        for(int i = 0; i < iterations; i++){\n            float r1 = clamp(rand(uv * float(i))*2.0-1.0, -texel_dist.x, texel_dist.x);\n            float r2 = clamp(rand(uv * float(i+iterations))*2.0-1.0, -texel_dist.y, texel_dist.y);\n            fragColor += texture(iChannel0, uv + vec2(r1 , r2));\n        }\n        fragColor /= float(iterations);\n        float twopi = 6.28318530718;\n        float dir = 16.0; \n        float step = 4.0; \n        float size = 4.0; \n        vec2 radius = size/iResolution.xy;\n        for( float d=0.0; d<twopi; d+=twopi/dir){\n            for(float i=1.0/step; i<=1.0; i+=1.0/step){\n                fragColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*radius*i) ;\t\n            }\n        }\n        fragColor /= step * dir ;\n    }\n    fragColor.w = 1.0f;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 121, 159, 159, 193], [194, 194, 268, 268, 772], [774, 774, 825, 825, 939], [941, 941, 961, 961, 1028], [1030, 1030, 1087, 1087, 2918]], "test": "untested"}
{"id": "3lycRc", "name": "fbm hypnotic sin", "author": "alexandrediasldev", "description": "Using two fbm to create an hypnotic pattern", "tags": ["fbm", "sin", "hypnotic"], "likes": 2, "viewed": 262, "published": 3, "date": "1611397115", "time_retrieved": "2024-07-30T19:43:03.321294", "image_code": "//Using two fbm to creqte an hypnotic pattern\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 inv = vec2(uv.y,uv.x);\n\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = fbm(uv);\n    float r2 = fbm(inv);\n\n    // Output to screen\n    col += sin((r/r2*t*10.0));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 73, 73, 180], [181, 181, 207, 207, 587], [606, 606, 630, 652, 906], [907, 907, 964, 1014, 1271]], "test": "untested"}
{"id": "WlycR3", "name": "Ellipse Bear", "author": "IWBTShyGuy", "description": "Bear drawn by ellipse.", "tags": ["sdf", "ellipse"], "likes": 6, "viewed": 269, "published": 3, "date": "1611376840", "time_retrieved": "2024-07-30T19:43:04.202937", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst vec4 NEON = vec4(174, 37, 137, 255) / 255.0;\nconst float THICK_BASE = 0.03;\nconst float THICK_AMP = 0.01;\n\nconst float EAR_ROT = 0.3;\nconst vec2 RIGHT_EAR_POS = vec2(0.2, 0.45);\nconst vec2 LEFT_EAR_POS = vec2(-0.2, 0.45);\nconst vec2 EAR_SPEC = vec2(0.2, 0.3);\n\nconst vec2 FACE_SPEC = vec2(0.7, 0.6);\n\nconst vec2 FACE_INNER_POS = vec2(0.0, -0.15);\nconst vec2 FACE_INNER_SPEC = vec2(0.4, 0.3);\n\nconst vec2 NOSE_POS = vec2(0.0, -0.1);\nconst vec2 NOSE_SPEC = vec2(0.1, 0.09);\n\nconst vec2 RIGHT_EYE_POS = vec2(0.2, 0.25);\nconst vec2 LEFT_EYE_POS = vec2(-0.2, 0.25);\nconst vec2 EYE_SPEC = vec2(0.04, 0.03);\n\nconst vec2 RIGHT_MOUTH_POS = vec2(0.1, -0.25);\nconst vec2 LEFT_MOUTH_POS = vec2(-0.1, -0.25);\nconst vec2 MOUTH_SPEC = vec2(0.1, 0.05);\n\nmat2 rot(float t) {\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat drawEllipse(in vec2 p, in vec2 ab) {\n    float thick = THICK_BASE + THICK_AMP * cos(iTime);\n    float r = abs(sdEllipse(p, ab));\n    r = clamp(r / thick, 0.0, 1.0);\n    return clamp(1.0 - r, 0.0, 1.0);\n}\n\nfloat fillEllipse(in vec2 p, in vec2 ab) {\n    return clamp(-sign(sdEllipse(p, ab)), 0.0, 1.0);\n}\n\nfloat basisfunc(in float t) {\n    t = fract(t);\n    float s0 = 1.0 - floor(clamp(3.0 - 3.0 * t, 0.0, 1.0));\n    float s1 = 1.0 - floor(clamp(4.0 - 3.0 * t, 0.0, 1.0));\n    float r0 = smoothstep(0.0, 1.0, 3.0 * t);\n    float r1 = smoothstep(0.0, 1.0, 4.0 - 3.0 * t);\n    return s0 * r0 + s1 * r1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0, 0, 0, 1);\n    float r;\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    r = drawEllipse(rot(EAR_ROT) * uv - RIGHT_EAR_POS, EAR_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(rot(-EAR_ROT) * uv - LEFT_EAR_POS, EAR_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = fillEllipse(uv, FACE_SPEC);\n    fragColor = min(vec4(1.0 - r, 1.0 - r, 1.0 - r, 1), fragColor);\n    r = drawEllipse(uv, FACE_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(uv - FACE_INNER_POS, FACE_INNER_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(uv - NOSE_POS, NOSE_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = fillEllipse(uv - RIGHT_EYE_POS, EYE_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(uv - RIGHT_EYE_POS, EYE_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = fillEllipse(uv - LEFT_EYE_POS, EYE_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(uv - LEFT_EYE_POS, EYE_SPEC);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(uv - RIGHT_MOUTH_POS, MOUTH_SPEC);\n    r *= clamp(-sign(uv.y - RIGHT_MOUTH_POS.y), 0.0, 1.0);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    r = drawEllipse(uv - LEFT_MOUTH_POS, MOUTH_SPEC);\n    r *= clamp(-sign(uv.y - LEFT_MOUTH_POS.y), 0.0, 1.0);\n    fragColor = max(vec4(r, r, r, 1), fragColor);\n    fragColor *= NEON;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycR3.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[822, 822, 841, 841, 893], [895, 946, 986, 986, 2008], [2010, 2010, 2052, 2052, 2219], [2221, 2221, 2263, 2263, 2318], [2320, 2320, 2349, 2349, 2617], [2619, 2619, 2674, 2674, 4168]], "test": "untested"}
{"id": "3lycR3", "name": "Trying out the Font Texture", "author": "oneshade", "description": "Just trying out the font texture.", "tags": ["distancefield", "texture", "font"], "likes": 4, "viewed": 250, "published": 3, "date": "1611374469", "time_retrieved": "2024-07-30T19:43:05.231187", "image_code": "float sampleFontSmooth(in vec2 uv) {\n    vec2 st = uv * iChannelResolution[0].xy;\n    ivec2 xy = ivec2(st);\n\n    float bl = texelFetch(iChannel0, xy, 0).w;\n    float br = texelFetch(iChannel0, xy + ivec2(1, 0), 0).w;\n    float tl = texelFetch(iChannel0, xy + ivec2(0, 1), 0).w;\n    float tr = texelFetch(iChannel0, xy + 1, 0).w;\n\n    vec2 local = fract(st);\n    //local *= local * (3.0 - 2.0 * local);\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nvec4 mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    float ww = 30.0, wh = 25.0, wd = 1.0;\n\n    float font = sampleFontSmooth((p.xy + vec2(ww, wh)) / vec2(2.0 * ww, 2.0 * wh)) - 0.5;\n    font = max(font, max(max(abs(p.x) - ww, abs(p.y) - wh), abs(p.z) - wd));\n\n    return vec4(font, vec3(1.0));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 50.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        vec4 scene = mapScene(p);\n        if (scene.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += scene.yzw;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 200.0) {\n            break;\n        }\n\n        t += scene.x;\n    }\n\n    //fragColor = smoothstep(0.05, 0.0, vec4(texture(iChannel0, fragCoord / iResolution.xy).w - 0.5));\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 472], [474, 474, 500, 500, 853], [855, 855, 882, 882, 1141], [1143, 1143, 1198, 1198, 1944]], "test": "untested"}
{"id": "wtKczV", "name": "Atmospheric Nebula cam", "author": "ollj", "description": "fork with (swiveled and physics disabled) [url=https://www.shadertoy.com/view/ttdyDl]quaternion camera[/url] \n\nmove= ESDF             +TG (=up down)   \nrotate= arrows/mouse +WR(roll)", "tags": ["volumetric", "nebula", "atmosphericscatteringquatenrioncamera"], "likes": 10, "viewed": 637, "published": 3, "date": "1611365154", "time_retrieved": "2024-07-30T19:43:06.306313", "image_code": "//commontab and BufferB are from\n//https://www.shadertoy.com/view/ttdyDl\n//imagetab modified to get Ro and rd from bufferB\n//but (once again) i had to swivel eYPR2q() inouts of Ca0() to get correct mouseRotation\n//but (once again) i had to swivel the keyboard inputs to match the mouse\n\n\n#define noiseResInverse      1.0 / 32.0\n\n#define PI                   radians(180.0)\n\n#define rayleighCoefficient  vec3(4.847e-6, 1.149e-5, 2.87e-5 )\n#define mieCoefficient       3e-6\n#define nebulaCoeff          rayleighCoefficient\n\n\n\n\n\n#define FieldOfView 2.5\nv22 getRay(vec2 u//uU is not normalized\n){u=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(tf(camA0),tf(camP0).xyz)\n ;mat3 m=m42Rot(ct) //;mat3 m=q2m(tf(camA0))\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                   +(m*vec3(1,0,0)*u.x//right+forward...\n                   +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n\nmat2 rotate(float r){return mat2(vec2(cos(r),-sin(r)),vec2(sin(r),cos(r)));}\n\nfloat bayer2(vec2 a){a=floor(a);return fract(dot(a,vec2(0.5,a.y*.75)));}\nfloat bayer4(vec2 a)  {return bayer2( 0.5  *a)*.25    +bayer2(a);}\nfloat bayer8(vec2 a)  {return bayer4( 0.5  *a)*.25    +bayer2(a);}\nfloat bayer16(vec2 a) {return bayer4( 0.25 *a)*.0625  +bayer4(a);}\nfloat bayer32(vec2 a) {return bayer8( 0.25 *a)*.0625  +bayer4(a);}\nfloat bayer64(vec2 a) {return bayer8( 0.125*a)*.015625+bayer8(a);}\nfloat bayer128(vec2 a){return bayer16(0.125*a)*.015625+bayer8(a);}\n\nfloat Get3DNoise(vec3 u){return texture(iChannel0,u*noiseResInverse).x;}\n\nbool raySphereIntersect(vec3 rd, vec3 sphere, float radius, out vec2 hit\n){hit=vec2(0)\n ;float b=dot(sphere, rd)\n ;float c=dot(sphere, sphere) - radius * radius\n ;float d=b*b-c\n ;//if (dot(rd, normalize(sphere)) > 1.0) return false\n ;if (d < 0.0)return false\n ;d=sqrt(d)\n ;hit=vec2(-b-d,d-b);return true;}\n\nfloat hgPhase(float r,float g){return(1./(4.*PI))*((1.-g*g)/pow(1.+g*g-2.*g*r,1.5));}\n\nfloat nebulaFBM(vec3 u\n){u+=6.\n ;float coverage=.22\n ;float noise=0.\n ;float a=1.\n ;mat2 rotMat = rotate(0.8)\n ;for(int i=0;i<4;i++\n ){noise+= texture(iChannel0, u * noiseResInverse).x*a\n  ;u.xy *= rotMat\n  ;u.yz *= rotMat\n  ;u*=3.5\n  ;a*=.4;}\n ;noise *= 0.25\n ;noise  = max(noise - coverage, 0.0) * 200000000.0 + 50000.0\n ;return noise;}\n\nfloat getNebulaVolume(vec3 r,float d){return nebulaFBM(r)*smoothstep(1.,0.,d/Nebula_Radius);}\n\nvec3 calculateStarlightVisibility(vec3 ray, const vec4 nebula, float startingOpticalDepth, float distFromCenter\n){const int samples  = 15\n ;float stepSize = (nebula.a * 2.0) / float(samples)\n ;float dirSwitch = -1.0\n ;if (ray.y > nebula.y) dirSwitch = 1.0\n ;vec3 centralRay   = ray - nebula.xyz //centralize ray on star\n ;vec3 rayDirection = -normalize(centralRay) * stepSize\n ;        ray         += rayDirection * 0.5\n ;float opticalDepth = -startingOpticalDepth\n ;//ray.xy =(ray.xy - vec2(0.0, 1.0)) * rotate(iTime * 0.1) + vec2(0.0, 1.0)\n ;for (int i = 0; i < samples; i++, ray += rayDirection\n ){opticalDepth -= nebulaFBM(ray)*smoothstep(1.,0.,distFromCenter/Nebula_Radius);;}\n ;return exp(nebulaCoeff * stepSize * opticalDepth);}\n\n//fucking hell, it couldnt just make a normal ramera\n//it had tro be a lazy orbit cam\n//main issue here is that rd input value is only set by uv\n\nvoid renderNebula(vec2 u,inout vec3 color,float dither\n){vec3 starColor =vec3(.5,.7,1)\n ;vec3 rd=normalize(vec3((u.xy*2.-iR.xy)/iR.y,1).xzy)\n ;vec3 ro=vec3(0)//rd*max(1.0 - Nebula_Radius, 0.0)\n ;v22 r=getRay(u)\n ;ro=r.a\n ;rd=r.b \n ;float starRadius=.015\n ;vec3 a=-nebulaCoeff/log(2.)\n ;vec3 b=-1./nebulaCoeff\n ;vec3 center=normalize(vec3(0,1,0))///center of nebular\n ;vec2 d\n ;raySphereIntersect(rd,ro-center,Nebula_Radius,d)//not sure about the ro-center\n ;//if(!raySphereIntersect(rd,ro,Nebula_Radius,d))return\n ;float l =(d.y-d.x) / float(Nebula_Quality)//stepSize\n ;//vec3 ro=tf(camP0).xyz//+* max(1. - Nebula_Radius, 0.0)\n ;//rd=qv2v(tf(camA0),vec3(1,0,0)) \n ;vec3  L =rd*l \n ;ro=ro+L*dither\n ;float phase        =hgPhase(dot(center, rd), 0.85) * PI\n ;vec3  scatter      =vec3(0.0)\n ;vec3  transmission =vec3(1.0)\n ;//RO.xy=(RO.xy-vec2(0.0, 1.0))*rotate(iTime * 0.1) + vec2(0.0, 1.0)\n ;for (int i = 0; i < Nebula_Quality; i++,ro+=L\n ){float distFromCenter = distance(ro,center)\n  ;if (distFromCenter > Nebula_Radius) continue\n  ;if (distFromCenter < starRadius){color = starColor;break;}\n  ;float lightFalloff   = inversesqrt(0.1 + distFromCenter)\n  ;float opticalDepth   = getNebulaVolume(ro, distFromCenter) * l\n  ;if (opticalDepth <= 0.0) continue\n  ;vec3  nebulaLighting = calculateStarlightVisibility(ro, vec4(center, Nebula_Radius), opticalDepth, distFromCenter) * lightFalloff * starColor * phase * nebulaCoeff\n  ;scatter      +=nebulaLighting *(exp2(a*opticalDepth)*b-b)*transmission\n  ;transmission *=exp(-nebulaCoeff * opticalDepth);}\n ;color = color * transmission + scatter;}\n\nvoid reinhardTonemap(inout vec3 color\n){color *= 8.0\n ;//color  = max0(color - 0.005)\n ;color  = color / (1.0 + color) * 1.08\n ;float luminance = dot(color, vec3(0.2125, 0.7154, 0.0721))\n ;color = mix(vec3(luminance), color, 1.0);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y\n ;float dither = bayer128(gl_FragCoord.xy)\n ;fragColor = vec4(vec3(0.0),1.0)\n ;renderNebula(fragCoord,fragColor.xyz, dither)\n ;reinhardTonemap(fragColor.xyz);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define noiseResInverse      1.0 / 32.0\n\n\n#define iR iResolution\n\n#define PI                   radians(180.0)\n\n#define rayleighCoefficient  vec3(4.847e-6, 1.149e-5, 2.87e-5 )\n#define mieCoefficient       3e-6\n#define nebulaCoeff          rayleighCoefficient\n\n\n#define Nebula_Quality 40\n#define Nebula_Radius  1.2\n\n\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n\n#define camType 1\n\n//its not just broken during rotation\n//, there are just-as-broken ghost-images during straving\n\n\nconst vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\nconst float\n //set to -100. to skip collisions\n //=.01 is reasonable for the mandelbulb distanceField\n PHYSICS_RADIUS=-100.\n,LIN_ACCE=.5//linear accelleration\n,ANG_ACCE=2.//angular accelleration\n,LIN_DRAG=1.//linear drag\n,ANG_DRAG=2.//angular drag\n;\n\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n\n//specific buffereB Addresses\nconst float \n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera angle    (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera angle    (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera angle    of previous frame\n,li2P0 =8.//light0 position\n,li3P0 =9.//light1 position\n,NBuffB=8.//max address count\n;\n#define tf(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n\nconst float tau=acos(-1.)*2.// 1/1 rotation in radians\n,pi=acos(-1.)               // 1/2 rotation in radians\n,pi2=acos(0.)               // 1/4 rotation in radians\n//,pi4=acos(0.)*.5            // 1/8 rotation in radians\n;\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec1 mav(vec2 a){return max(a.x,a.y);}\nvec1 mav(vec3 a){return max(mav(a.xy),a.z);}\nvec3 ma0(vec3 a){return max(a,0.);}\nvec1 mu(vec2 a){return a.x*a.y;}\nvec1 mu(vec3 a){return a.x*a.y*a.z;}\nvec1 su(vec2 a){return a.x-a.y;}\nvec1 su(vec3 a){return a.x+a.y-a.z;}\nvec1 ad(vec2 a){return a.x+a.y;}\nvec1 ad(vec3 a){return a.x+a.y+a.z;}\n\n//internal RNG state \nuvec4 s0,s1;\nivec2 pixel;\n\nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\n\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n\nfloat rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\nvec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\n\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\n\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec2 c=cos(r),s=sin(r)\n ;return vec3(c.x*s.y,s.x*s.y,c.y);}\n\nfloat HenyeyGreenstein(float g,float c//g,costh\n){return (4.*pi*pow(1.0+g*g-2.0*g*c,3./2.))/(1.-g*g);}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b;return length(ma0(q))+min(mav(q),0.);}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n \n//from https://www.shadertoy.com/view/XsSXDy\nvec4 pwS(float x){return vec4(x*x*x,x*x,x,1.0);}\n\n/*\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance , o.yzw=orbittrap\n//w.xyz=uv     ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break;mandelCore(o,w,u);}\n ;o.x=.25*log(w.w)*sqrt(w.w)/o.x;return o;}\n\nvec1 mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break;mandelCore(o,w,u);}\n ;return .25*log(w.w)*sqrt(w.w)/o.x;}\n*/\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\n/*\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}*/\n\n/*\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}*/\n\n\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/length(a)/length(b));}\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q){return q/dd(q);}//return normalize(q);}\n//\n// quaternion & vectors\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b// http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\n//vec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\n//vec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\n//vec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n//---end__ quaternion\n\n\n//https://www.shadertoy.com/view/ldjyRK\nconst float s2=sqrt(2.);\nvec2 scm(float a){return sin(vec2(a,a+pi2));}//NOT a rotation, but a reflection at a halfRotated axis.\nvec2 sc(float a){return scm(a);//lazy override\n return vec2(sin(a),cos(a)); ;}//actual reflection\n//Hammer.transform:\nvec2 tHammer(vec2 p){\n vec2 s=sc(p.y),o=sc(p.y*.5);\n return s2*vec2(2.*s.y*o.x,s.x)/sqrt(1.+s.y*o.y);}\n//Hammer.transform.Inverse\nvec2 tHammerI(vec2 p){float z=1.-(p.x*p.x/16.)-(p.y*p.y/4.);\n if(z<0.)discard;float s=sqrt(z);\n return vec2(2.*atan((s*p.x),(2.*(2.*z-1.))),asin(s*p.y));}\n \n//scale: (-0.5.-0.5) x (0.5..0.5) -> (l[0]..l[1]) x (l[2]..l[3])\nvec2 scale(vec2 p, vec4 l){\n return (p+vec2(.5))*vec2(l[1]-l[0],l[3]-l[2])+vec2(l[0],l[2]);}\n//scale.inverse p=scale1(scale_forward(p));\nvec2 scale1(vec2 p, vec4 l){\n return (p-vec2(l[0],l[2]))/vec2(l[1]-l[0], l[3]-l[2])-vec2(.5);}\n\nvec2 hammerScale(vec2 u,vec2 r\n){u=u.xy/r.xy-.5\n ;u*=sqrt(2.)\n ;//u*=1.; //fieldOfView\n ;vec4 CarLim=vec4(-2,2,-1,1);//carthesian limits\n ;return scale(u,CarLim);}\n \n ", "buffer_b_code": "//Controller\n\n//Keyboard constants\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\n  \n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyT,keyE ,keyF).zxy//right ,up  ,front      ==+linear\n           ,kln=ivec3(keyG,keyD ,keyS  ).zxy//left  ,down,back       ==-linear\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code:\nfloat kg(int key_code){return texelFetch(iChannel3, ivec2(key_code,0), 0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n  \nvec4 cp0(//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return vec4(0,0,0,1);\n ;vec3 r=tf(camP0).xyz\n /*\n ;if(PHYSICS_RADIUS>-99.){//optional collision\n  ;float d=PHYSICS_RADIUS-df(r.xyz)\n  ;if (d>0.)r.xyz+=normal(r)*d ;} */ //no physics in this one\n ;return vec4(r+(q2m(tf(camA0),vec3(0))\n               *vec4(tf(camP1).xyz,0)).xyz*iTimeDelta,0);}\n\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(tf(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iFrame <1)return aa2q(vec3(1,0,0),-5.5)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*tf(camA1).yzx),tf(camA0)));}\n\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;return vec4(drag(tf(camA1).xyz,a.yzx*ANG_ACCE,ANG_DRAG),0.);}\n\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=tf(q)\n ;if(key(k))c.xyz=tf(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return tf(camP0)//memorize previous pos\n ;if(u==camA0p)return tf(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;if(u==li2P0)return lightPos(u,keyO,vec4(-.1,.5,.5,0))\n ;if(u==li3P0)return lightPos(u,keyK,vec4(1.2,-1.,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[550, 550, 592, 592, 877], [879, 879, 900, 900, 955], [957, 957, 978, 978, 1029], [1030, 1030, 1053, 1053, 1096], [1097, 1097, 1120, 1120, 1163], [1164, 1164, 1187, 1187, 1230], [1231, 1231, 1254, 1254, 1297], [1298, 1298, 1321, 1321, 1364], [1365, 1365, 1388, 1388, 1431], [1433, 1433, 1458, 1458, 1505], [1507, 1507, 1582, 1582, 1812], [1814, 1814, 1845, 1845, 1899], [1901, 1901, 1926, 1926, 2239], [2241, 2241, 2279, 2279, 2334], [2336, 2336, 2450, 2450, 3071], [3219, 3219, 3276, 3276, 4811], [4813, 4813, 4853, 4853, 5044], [5047, 5047, 5103, 5103, 5330]], "test": "untested"}
{"id": "ttKczV", "name": "Bezier Curve Parametric Plot", "author": "oneshade", "description": "Horribly brute force bezier curve parametric plot.", "tags": ["bezier", "curve", "plot", "parametric"], "likes": 4, "viewed": 175, "published": 3, "date": "1611364534", "time_retrieved": "2024-07-30T19:43:07.070270", "image_code": "#define PLOT_RES 100.0\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 Bezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv +\n           b * 3.0 * t * tInv * tInv +\n           c * 3.0 * tInv * t * t +\n           d * t * t * t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float t1 = 0.5 * iTime, t2 = iTime, t3 = 1.25 * iTime;\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 a = vec2(c1 * 3.0, s2 * 2.0);\n    vec2 b = vec2(s3 * 3.0, c2 * 2.0);\n    vec2 c = vec2(c3 * 3.0, s2 * 2.0);\n    vec2 d = vec2(c2 * 3.0, s1 * 2.0);\n\n    vec2 prevPos = a;\n    float tStep = 1.0 / PLOT_RES;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 curPos = Bezier(a, b, c, d, t);\n        color = mix(color, hue2rgb(t + iTime), smoothstep(unit, 0.0, sdLine(uv, prevPos, curPos)));\n        prevPos = curPos;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 208, 208, 333], [335, 335, 404, 404, 569], [571, 571, 626, 626, 1421]], "test": "untested"}
{"id": "tlKcRK", "name": "Reaction diffusion using LOD", "author": "illus0r", "description": "Reaction diffusion using LOD", "tags": ["lod", "cellular"], "likes": 1, "viewed": 272, "published": 3, "date": "1611355012", "time_retrieved": "2024-07-30T19:43:07.858164", "image_code": "//IMG\nvoid mainImage(out vec4 o, vec2 FC) {\n    o = texelFetch(iChannel0, ivec2(FC), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// A\n#define rnd(x) fract(1e5 * sin(1e5 * x))\n#define S smoothstep(0., .2, iTime)\n#define K .062\n#define F .06\n#define Dab vec2(1,.4)*S\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage(out vec4 o, vec2 FC) {\n    vec2 uv = FC / iResolution.xy;\n    vec2 v = texture(iChannel0, uv, .0).xy;\n    vec2 d, delta;\n    uv = .5 + (uv - .5) * rot(.02 * length(uv - .5));\n    d = -v + texture(iChannel0,uv, 4.).xy;\n    delta = Dab * d\n        + vec2(-1., 1.) * v.x * v.y * v.y\n        + vec2(F * (1. - v.x), -(K + F) * v.y);\n    o = iTime < .1\n        ? vec4(rnd(floor(uv.x * 10.)))\n        : v.xyxx + delta.xyxx;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 6, 43, 43, 90]], "test": "untested"}
{"id": "3lVczV", "name": "Metal Kaleidoscope", "author": "mrange", "description": "Licence CC0: Metal Kaleidoscope\nExperimenting with truchet, FBM, smooth kaleidoscope and metal like lighting\n", "tags": ["2d", "fbm", "kaleidoscope"], "likes": 13, "viewed": 548, "published": 3, "date": "1611353252", "time_retrieved": "2024-07-30T19:43:08.739806", "image_code": "// Licence CC0: Metal Kaleidoscope\n// Experimenting with truchet, FBM, smooth kaleidoscope and metal like lighting\n\n// SABS        from: ollj (shadertoy) (SABS is a really great tool)\n// hsv2rgb     from: https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// modMirror1  from: http://mercury.sexy/hg_sdf/\n// pmin        from: iq (shadertoy)\n// tanh_approx from: some math site, don't remember\n\n// fbm described by iq here: https://iquilezles.org/articles/fbm\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n \n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PERIOD          30.0\n#define NPERIOD         floor(TIME/PERIOD)\n#define TIMEINPERIOD    mod(TIME, PERIOD)\n#define FADE            1.0\n\nconst float  truchet_lw = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nfloat l2(vec2 p){\n  return dot(p, p);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat hash(float co) {\n  co += 100.0;\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  co += 100.0;\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  const float ts = 2.5;\n  hpp.x = tanh_approx(hpp.x/ts)*ts;\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat truchet_cell0(vec2 p) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2 = circle(p, 0.25);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nvec2 truchet(vec2 p, float h, out vec3 n) {\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  hp *= ROT(0.02*TIME);\n  hp += TIME*0.05;\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n  hp *= truchet_rots[int(r*4.0)];\n\n  float cd0 = truchet_cell0(hp);\n  float cd1 = truchet_cell1(hp);\n  float d0 = mix(cd0, cd1, (fract(r*13.0) > 0.5));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = abs(d) - truchet_lw;\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nfloat df(vec2 p, float h, out vec3 n) {\n  vec2 d = truchet(p, h, n); \n  return d.y;\n}\n\nfloat hf(vec2 p, float h) {\n  vec3 n;\n  float decay = 0.75/(1.0+0.125*l2(p));\n  float d = df(p, h, n);\n  const float ww = 0.085;\n  float height = smoothstep(0.0, ww, d);\n  return pmax(2.0*height*decay, 0.5, 0.25);\n}\n\nfloat fbm(vec2 p, float h) {\n  const float aa = -0.45;\n  const mat2  pp = 2.03*ROT(1.0);\n\n  float a = 1.0;\n  float d = 0.0;\n  float height = 0.0;\n  \n  for (int i = 0; i < 4; ++i) {\n    height += a*hf(p, h);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }\n  \n  return height/d;\n}\n\nfloat height(vec2 p) {\n  p.x = SABS(p.x, 0.1*abs(p.y)+0.001);\n  float h = hash(NPERIOD);\n  float tp = TIMEINPERIOD/PERIOD;\n  p*=ROT(TIMEINPERIOD*0.075);\n//  p*=ROT(-pow(l2(p), mix(0.25, 0.75, h)));\n  p*=ROT(-PI*tanh_approx(0.125*(l2(p)-0.25)));\n  \n  p*=mix(1.5, 2.5, mix(tp, 1.0-tp, h));\n  return fbm(p, h);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(4.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float aa = 2.0/RESOLUTION.y;\n\n  vec3 ld1 = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 ld2 = normalize(vec3(-1.0, 0.75, 1.0));\n  vec3 e  = vec3(p.x, -1.0, p.y);\n\n  float l = length(p);\n  \n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 hsv = vec3(mix(0.6, 0.9, 0.5+ 0.5*sin(TIME*0.1-10.0*h*l+(p.x+p.y))), tanh_approx(0.5*h), tanh_approx(10.0*l*h+.1));\n  hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n  vec3 baseCol1 = hsv2rgb(hsv);\n  vec3 baseCol2 = sqrt(baseCol1.zyx);\n \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3 col = vec3(0.0);\n  const float basePow = 1.5;\n  col += 1.00*baseCol1*pow(diff1, 16.0*basePow);\n  col += 0.10*baseCol1*pow(diff1, 04.0*basePow);\n  col += 0.15*baseCol2*pow(diff2, 08.0*basePow);\n  col += 0.02*baseCol2*pow(diff2, 02.0*basePow);\n  \n  col *= 8.0;\n//  col = tanh(8.0*col);\n  col = postProcess(col, q);\n  \n  float fadeIn  = smoothstep(0.0, FADE, TIMEINPERIOD);\n  float fadeOut = 1.0-smoothstep(PERIOD-FADE, PERIOD, TIMEINPERIOD);\n  col = mix(vec3(0.0), col, fadeIn*fadeIn*fadeOut*fadeOut);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1082, 1082, 1099, 1099, 1121], [1123, 1123, 1145, 1145, 1314], [1316, 1316, 1344, 1364, 1440], [1442, 1442, 1473, 1473, 1499], [1501, 1501, 1523, 1523, 1586], [1588, 1588, 1609, 1609, 1707], [1709, 1709, 1731, 1731, 1775], [1777, 1777, 1798, 1798, 1843], [1845, 1845, 1872, 1872, 1941], [1943, 1943, 1988, 1988, 2142], [2144, 2144, 2205, 2205, 2478], [2480, 2480, 2519, 2519, 2604], [2606, 2606, 2645, 2645, 2674], [2676, 2676, 2705, 2705, 2853], [2855, 2855, 2884, 2884, 3048], [3050, 3050, 3093, 3093, 3666], [3668, 3668, 3707, 3707, 3753], [3755, 3755, 3782, 3782, 3970], [3972, 3972, 4000, 4000, 4244], [4246, 4246, 4268, 4268, 4555], [4557, 4557, 4578, 4578, 4781], [4783, 4783, 4820, 4820, 5073], [5075, 5075, 5130, 5130, 6309]], "test": "untested"}
{"id": "WtVyzV", "name": "Pattern with simple points", "author": "ManuManu", "description": "Playing with this ( serious and intersting ) shader : https://www.shadertoy.com/view/3tyyzK\nI found these patterns funny :\nIt's just a zoom in a grid \n", "tags": ["pattern2d"], "likes": 0, "viewed": 283, "published": 3, "date": "1611350152", "time_retrieved": "2024-07-30T19:43:09.553630", "image_code": "float grid_zoom( vec2 p, float size_ampl,float size_offset, float time_factor)\n{\n    //color\n    float m = 0.;\n    \n     //cell size 1/size\n    float mul = size_ampl * sin(iTime * time_factor) + size_ampl/2. + size_offset;\n    \n    //local grids\n    vec2 gv = fract(p*mul)-0.5;\n    //grid ids\n    vec2 id = floor(p*mul);\n    \n    //display points as dots\n    float point_start_size = 0.1;\n    float point_end_size = 0.09;\n    m = smoothstep(point_start_size,point_end_size,length(gv));\n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 color1 = vec3(0.282, 0.388, 0.612);\n    vec3 color2 = vec3(0.298, 0.298, 0.616);\n    vec3 color3 = vec3(0.443, 0.184, 0.475);\n    vec3 color4 = vec3(0.592, 0.388, 0.569);\n    vec3 color5 = vec3(0.969, 0.6, 0.431);\n    \n\n    float m1 = grid_zoom( uv, 2000., 100., 0.0001);\n    float m2 = grid_zoom( uv, 1000., 200., 0.0005);\n    float m3 = grid_zoom( uv, 500., 99., 0.00001);\n    float m4 = grid_zoom( uv, 800., 1000., 0.0015);\n    float m5 = grid_zoom( uv, 200., 0., 0.0015);\n\n    //out color\n    vec3 col =  m1 * color1 +\n                m2 * color2 +\n                m3 * color3 +\n                m4 * color4 +\n                m5 * color5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 80, 92, 501], [504, 504, 561, 612, 1385]], "test": "untested"}
{"id": "WlKczK", "name": "2D Volumetric Path Tracing", "author": "Zi7ar21", "description": "I don't even know why I did this", "tags": ["volumetric", "pathtrace", "pathtrace", "pathtracing", "volumetrics"], "likes": 0, "viewed": 342, "published": 3, "date": "1611348408", "time_retrieved": "2024-07-30T19:43:10.401364", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "#define stepsize 0.01\n#define scenesize 2.0\n\n// Value Noise, only takes whole numbers or else you get bands and stuff.\nfloat hash12(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx)*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// Convert the value Noise to gradient noise so it is smooth.\nfloat noise(vec2 n){\n    vec4 b = vec4(floor(n), ceil(n)); \n    vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(hash12(b.xy), hash12(b.zy), f.x), mix(hash12(b.xw), hash12(b.zw), f.x), f.y);\n}\n\n// 2D fBm Noise, basically justs adds noise, scales it by 2, adds it back with 1/2 the effect, and repeat.\n#define NUM_OCTAVES 8\nfloat fbm(vec2 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.5;}\n\treturn v;}\n\nvec4 densityfunction(vec2 pathposition){return vec4(vec3(1.0), max(0.0, fbm(pathposition*4.0)-distance(pathposition, vec2(0.0)))*50.0);}\n\nvec3 pathtrace(vec2 uv){\n    vec4 density;\n    float absorbance;\n    float distancetravelled = 0.0;\n    vec3 attenuation = vec3(1.0);\n    vec2 pathposition = vec2(-0.5, 0.5);\n    vec3 outputcolor = vec3(0.0);\n    vec2 pathdirection = normalize(nrand2(1.0, vec2(1.0, -1.0)))+(rand()-0.5)*2.0;\n    for(int i = 0; i < 128; i++){\n        density = densityfunction(pathposition);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){attenuation *= clamp(density.rgb, 0.0, 1.0); pathdirection = normalize(nrand2(1.0, vec2(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(distance(pathposition, vec2(0.0)) > scenesize || distancetravelled > 32.0){break;}\n        if(distance(uv, pathposition)-0.01 < 0.0){outputcolor += 32.0*(1.0-absorbance)*attenuation;}}\n    return outputcolor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    INIT_RNG;\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat2 rotationmatrix = mat2(1.0, 0.0, 0.0, 1.0);\n    //vec2 pathdirection = normalize((uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1]));\n\n    vec3 col = pathtrace(uv*2.0);\n\n    fragColor += vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 110]], "test": "untested"}
{"id": "wlKyRy", "name": "Limited Range Noise A2C Dither", "author": "bgolus", "description": "Various methods of applying dithering with and with out clamping techniques for use with Alpha to Coverage.\nMove mouse up & down to adjust simulated MSAA level.", "tags": ["dithering"], "likes": 7, "viewed": 736, "published": 3, "date": "1611348197", "time_retrieved": "2024-07-30T19:43:11.229151", "image_code": "// Various methods of applying blue noise dithering with and without clamping techniques for use with Alpha to Coverage.\n// Move mouse up & down to adjust the simulated MSAA level.\n//\n// ================================================================================================================================\n//\n// Most GPU dithering examples show a gradient or color image with few or no areas of solid white / black. This hides a significant\n// flaw with the usual \"ideal\" dithering technique of using a -0.5 to +1.5 triangular distribution noise. Solid white and black\n// areas are never fully solid white or black! This artifact is mostly fine to ignore for color values, especially when using HDR\n// rendering as it's rare for anything to be fully black, and values will rarely be exactly 1.0. But for dithering of alpha this is\n// a serious problem.\n//\n// This example shows off the problems with both basic unorm linear range dithering and snorm triangular dithering, basic clamping\n// solutions, and improved clamping solutions. Note, this is written with Nvidia's rounded Alpha to Coverage in mind, so noise is\n// 0.0 centered rather than 0.5 centered as you would want it to be for most dithering use cases.\n\n\n\n// Example 0\n// Basic rounding, no dithering\n// Here as an example of the current precision.\n\n\n\n// unorm linear dithering examples\n\n// Example 1\n// Effective at removing the banding, but still has something similar to banding due to there being areas with no dithering. This\n// contrast of dithered and not dithering isn't super obvious with blue noise, but it is still there. Switch to using random noise\n// and it becomes much more apparent. Also shows unwanted dithering in the black (or white) area due to dithering adding just enough\n// for it to get to the next quantized level.\n\n// Example 2\n// Removes unwanted dithering in the extremes by using a ternary to only apply dithering to values less than 1.0 and greather than 0.0.\n\n// Example 3\n// Removes unwanted dithering in the extremes by slightly scaling the step size. Virtually identical to the ternary based clamping,\n// but slightly faster.\n\n\n\n// snorm triangular remapped dithering examples\n\n// Example 4\n// Even more effective at removing banding, and completely removes the additional banding-like artifacts caused by there being area\n// no dithering. However has serious issues at the extremes showing very strong unwanted dithering artifacts. In very low precision\n// situations it also removes any apparent gradient!\n\n// Example 5\n// Using the same ternary operator to limit the dithering to values less than 1.0 and greater than 0.0. This removes the unwanted\n// dithering problem, but creates a new one as there is now an obvious hard edge cutoff when it hits the extremes. Neither the top\n// nor bottom of the gradient feel like they quite get close enough to 0.0 or 1.0 because the dithering is too strong.\n\n// Example 6\n// Hybrid unorm and snorm dithering! Blends between the two at the extremes of the gradient getting the best of both worlds. Removes\n// dithered / not dithered banding, but actually gets to 1.0 and 0.0 at the extremes without dithering appearing in the extremes.\n// Whether or not this is worthwhile over example 3 depends on your use case. On wider, softer gradients and MSAA 2x or 4x, this is\n// clearly visually superior. Especially so if using white noise instead of blue noise. Nearly identical to example 3 when doing\n// binary dithering, but obviously more expensive for no real benefit, so not useful with MSAA disabled.\n\n\n\n\n// animated noise assumes using an RGBA noise texture\n// don't use this with single channel noise\n// #define ANIMATED_NOISE\n\n#define DEFAULT_STEPS 4.0\n\n#define EXAMPLES 7.0\n#define EXAMPLE(n) if (uv.x < float(n+1)/EXAMPLES)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // alpha value rescaled so there are solid white and black areas\n    float y = uv.y * 1.25 - 0.125;\n    \n    float examples = 6.;\n    \n    float steps = DEFAULT_STEPS;\n    if (iMouse.y > 10.0)\n    {\n        steps = pow(2., round(mix(0., 4., clamp(iMouse.y / iResolution.y * 1.25 - 0.125, 0., 1.))));\n    }\n    \n    float a = clamp(y, 0., 1.);\n    \n    // texel matched UV for noise\n    vec2 noiseUV = fragCoord;\n    // offset so each example shows the same noise\n    noiseUV.x -= floor(uv.x * EXAMPLES) * floor(iResolution.x / EXAMPLES);\n    noiseUV /= iChannelResolution[0].xy;\n        \n    #if defined(ANIMATED_NOISE)\n    // assumes you're using RGBA noise texture\n    // scroll UVs\n    noiseUV.x += mod(float(iFrame), 32.) / 32.;\n    noiseUV.y += mod(float(iFrame), 64.) / 64.;\n    \n    vec4 noiseTex = texture(iChannel0, noiseUV);\n    \n    // select channel based on current frame\n    float frameMod = mod(float(iFrame), 4.);\n    float noise = dot(vec4(frameMod == 0., frameMod == 1., frameMod == 2., frameMod == 3.), noiseTex);\n    #else\n    \n    // just sample the noise texture\n    float noise = texture(iChannel0, noiseUV).r;\n    #endif\n    \n    EXAMPLE(0)\n    {\n        // no dithering, quantized value is simply rounded\n    }\n    \n    else EXAMPLE(1)\n    {\n        // -0.5 to +0.5 step range dithering\n        // shows unwanted dithering in the black, might show dithering white on some devices\n        // still has something like \"banding\" in lower precision situations due to stripes of un-dithered values\n        // this is more obvious with random noise\n        a = a + (noise - 0.5) / steps;\n    }\n    \n    else EXAMPLE(2)\n    {\n        // -0.5 to +0.5 step range dithering\n        // ternary op to prevent unwanted dithering on the extremes\n        // still has something like \"banding\" in lower precision situations due to stripes of un-dithered values\n        // this is more obvious with random noise\n        a = (1. > a && a > 0.) ? a + (noise - 0.5) / steps : a;\n    }\n    \n    else EXAMPLE(3)\n    {\n        // -0.5 to +0.5 step range dithering\n        // minor rescaling of step size to avoid unwanted dithering with a single extra MUL instead of using a ternary\n        // still has something like \"banding\" in lower precision situations due to stripes of un-dithered values\n        // this is more obvious with random noise\n        a = a + (noise - 0.5) / steps * 0.99999;\n    }\n    \n    else EXAMPLE(4)\n    {\n        // -1.0 to +1.0 step range dithering\n        // blue noise values remapped to a triangle noise (function outputs -1.0 to 1.0 range)\n        // shows significant artifacts outside the > 1.0 and < 0.0 alpha values\n        noise = remap_noise_tri_unity(noise);\n        a += noise / steps;\n    }\n    \n    else EXAMPLE(5)\n    {\n        // -1.0 to +1.0 step range dithering\n        // blue noise values remapped to a triangle noise (function outputs -1.0 to 1.0 range)\n        // ternary clamping removes artifacts outside the > 1.0 and < 0.0 alpha values, but shows harsh cutoff\n        noise = remap_noise_tri_unity(noise);\n        a = (1. > a && a > 0.) ? a + noise / steps : a;\n    }\n    \n    else EXAMPLE(6)\n    {\n        // hybrid -0.5 to +0.5 and -1.0 to +1.0 step range dithering\n        // blue noise values remapped to a triangle noise (function outputs -1.0 to 1.0 range)\n        // lerp from a \"2.0\" to a \"1.0\" range magnitude dither at the extremes over sqrt of 1 step\n        // minor rescaling of the step size to avoid unwanted dithering with a single extra MUL instead using a ternary\n        // with \"MSAA x1\" precision this is nearly identical to example 3, but much more expensive\n        noise = remap_noise_tri_unity(noise);\n        float factor = sqrt(clamp(min(a, (1.0 - a)) * steps, 0., 1.));\n        float error = mix(0.5, 1., factor) / steps * 0.99999;\n        a = a + noise * error;\n    } \n    \n    // rounded floor to mimic alpha to coverage\n    a = floor(a * steps + 0.5) / steps;\n    \n    // full precision gradient bands w/o dithering for direct comparison\n    if (fract(uv.x * EXAMPLES) < 0.5)\n        a = clamp(y, 0., 1.);\n    \n    fragColor = vec4(Linear2sRGB(a));    \n    \n    // UI stuff\n    \n    // display precision steps\n    float digit = PrintValue((fragCoord.xy / iResolution.x) * 44. - vec2((steps > 9. ? 19. : 16.) / EXAMPLES, 0.3), steps, 2., 0.);\n    fragColor = mix(fragColor, vec4(0.5,0.65,0.75,1.), digit);\n    \n    // display example nums\n    float num = PrintValue(vec2(fract(fragCoord.x / iResolution.x * EXAMPLES), (fragCoord.y - iResolution.y * 0.93) / iResolution.x ) * 44. / vec2(EXAMPLES, 1.), floor(uv.x * EXAMPLES), 1., 0.);\n    fragColor = mix(fragColor, vec4(0.), num);\n    \n    // 0.0 and 1.0 limit pips\n    if (abs(y - 0.5) > 0.5 && abs(y - 0.5) <= (0.5 + fwidth(y) * 2.))\n    {\n        if( mod(fragCoord.x + iResolution.x / (EXAMPLES * 2.) + 2., iResolution.x / EXAMPLES) < 4.)\n        {\n            fragColor = vec4(step(y, 0.5), 0.0, step(0.5, y), 1.);\n        }\n    }\n    \n    // separators\n    if (fract(uv.x * EXAMPLES) > 1. - fwidth(uv.x * EXAMPLES))\n    {\n        fragColor = vec4(0.);\n    }    \n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float remap_noise_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    return (v > 0.0 ? 1.0 : -1.0) * (1.0 - sqrt(1.0 - abs(v)));\n}\n\nfloat sRGB2Linear(float val)\n{\n    if( val <= 0.04045 )\n        val /= 12.92;\n    else\n        val = pow((val + 0.055)/1.055,2.4);\n    return val;\n}\n\nfloat Linear2sRGB(float val)\n{\n    if( val <= 0.0031308 )\n        val *= 12.92;\n    else\n        val = pow(val, 1./2.4) * 1.055 - 0.055;\n    return val;\n}\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtKcRV", "name": "Iridescent Cube Spheres", "author": "pprovins", "description": "A normal estimate is used to create a Phong lighting model. A normal map is generated from perlin noise and used to modify the normal. Still a Work in Progress!", "tags": ["phong", "sdf", "iridescent"], "likes": 0, "viewed": 285, "published": 3, "date": "1611347392", "time_retrieved": "2024-07-30T19:43:12.032004", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct BoundingBox {\n    vec3 center;\n    vec3 bounds;\n    float edge;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nfloat distToBoundingBox(Ray ray, BoundingBox bb) {\n    vec3 p = abs(ray.origin - bb.center) - bb.bounds;\n    vec3 q = abs(p + bb.edge) - bb.edge;\n    return min(min(\n             length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n             length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n             length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)\n    );\n}\n\nfloat distToSphere(Ray ray, Sphere s) {\n    return length(ray.origin - s.center) - s.radius;\n}\n\nfloat sdfSmoothIntersection( float d1, float d2, float k ) {\n  float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat distToBoundingBoxScene(Ray r) {\n    BoundingBox bb = BoundingBox(vec3(1.0), vec3(0.3), 0.1);\n    Sphere s = Sphere(vec3(1.0), 0.4);\n    Ray repeatRay = r;\n    repeatRay.origin = mod(r.origin, 2.0);\n    float d1 = distToBoundingBox(repeatRay, bb);\n    float d2 = distToSphere(repeatRay, s);\n    float dist = sdfSmoothIntersection(d1, d2, 0.2);\n    return dist;\n}\n\n\nvec3 sdfNormalEstimate(Ray r) {\n    float epsilon = 0.01;\n    vec3 p = r.origin;\n  \n    vec3 estimate = vec3(\n                             distToBoundingBoxScene(Ray(vec3(p.x + epsilon, p.y, p.z), r.direction)) - distToBoundingBoxScene(Ray(vec3(p.x - epsilon, p.y, p.z), r.direction)),\n                             distToBoundingBoxScene(Ray(vec3(p.x, p.y + epsilon, p.z), r.direction)) - distToBoundingBoxScene(Ray(vec3(p.x, p.y - epsilon, p.z), r.direction)),\n                             distToBoundingBoxScene(Ray(vec3(p.x, p.y, p.z  + epsilon), r.direction)) - distToBoundingBoxScene(Ray(vec3(p.x, p.y, p.z - epsilon), r.direction))\n                           );\n    return normalize(estimate);\n}\n\nvec2 hash2(vec2 p) {\n  return fract(vec2(5978.23857, 2915.98275)*sin(vec2(\n                                                         p.x*832.2388 + p.y*234.9852,\n                                                         p.x*921.7381 + p.y*498.2348\n                                                         )))*2.-1.;\n}\n\nfloat getPerlinValue(vec2 uv, float scale, float offset){\n    uv *= scale;\n    vec2 f = fract(uv);\n    vec2 m = f * f * (3.-f-f);\n    vec2 p = uv - f;\n  \n    float n = mix(\n                   mix(dot(hash2(p + offset + vec2(0,0)), f - vec2(0,0)),\n                      dot(hash2(p + offset + vec2(1,0)), f - vec2(1,0)), m.x),\n                  mix(dot(hash2(p + offset + vec2(0,1)), f - vec2(0,1)),\n                      dot(hash2(p + offset + vec2(1,1)), f - vec2(1,1)), m.x),\n                  m.y);\n  \n    return float(0.5 * n + 0.5);\n}\n\nvec3 getPerlinNormal(vec2 uv, float scale, float offsetLayer) {\n    float n1 = getPerlinValue(uv, scale, 0.0);\n    float n2 = getPerlinValue(uv, scale, offsetLayer);\n    vec3 p1 = vec3(n1);\n    p1.r = 0.5;\n    vec3 p2 = vec3(n2);\n    p2.g = 0.5;\n    vec3 normalValue = p1 + p2;\n    normalValue.b *= 1.2;\n    normalValue /= (normalValue.r + normalValue.g + normalValue.b);\n    normalValue /= max(max(normalValue.r, normalValue.g), normalValue.b);\n    normalValue = normalValue * 2.0 - 1.0;\n    return normalValue;\n}\n\nvec3 getJetSpectra(vec2 uv) {\n  float x = clamp((uv.x + 1.0) / 2.0, 0.0, 1.0);\n  vec3 c;\n  \n  if (x < 0.25)\n    c = vec3(0.0, 4.0 * x, 1.0);\n  else if (x < 0.35)\n    c = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n  else if (x < 0.65)\n    c = vec3(4.0 * (x - 0.35), 1.0, 0.0);\n  else if (x < 0.95)\n    c = vec3(1.0, 1.0 + 4.0 * (0.65 - x), 0.0);\n  else\n    c = vec3(0.4, 0.4, 0.4);\n  return clamp(c, vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= -1.0;\n    vec3 camPos = vec3(1000.0 + (sin(iTime) / 2.5) + 1.0, 1000.0 + (cos(iTime) / 2.5) + 1.0, iTime / 2.0); //time);\n    Ray ray = Ray(camPos, normalize(vec3(uv, 1.0)));\n    vec3 col = vec3(0.0);\n    for (float i=0.0; i<100.0; i++) {\n      float dist = distToBoundingBoxScene(ray);\n      if (dist < 0.001) {\n        vec3 surfacePosition = ray.origin;\n        vec3 ambient = vec3(0.2, 0.2, 0.2);\n        vec3 norm = normalize(sdfNormalEstimate(ray));\n        vec3 lightDirection = normalize(camPos - surfacePosition);\n        float diffuse = clamp(dot(norm, lightDirection), 0.0, 1.0);      \n        vec3 cameraDirection = normalize(camPos - surfacePosition);\n      \n        float specular = 0.0;\n        if (diffuse > 0.0) {\n            specular = pow(clamp(dot(cameraDirection, reflect(-lightDirection, norm)), 0.0, 1.0), 2000.0);\n            specular = pow(dot(cameraDirection, reflect(-lightDirection, norm)), 2000.0);\n        }\n        float distanceToLight = length(camPos - surfacePosition);\n        float attenuation = 1.0 / (0.9 + 0.2 * pow(distanceToLight, 2.0));\n      \n        vec3 colXZ = getPerlinNormal(mod(ray.origin.xz * 2.0 - 1.0, 1.0), 100.0, 123.45);\n        vec3 colYZ = getPerlinNormal(mod(ray.origin.yz * 2.0 - 1.0, 1.0), 100.0, 123.45);\n        vec3 colXY = getPerlinNormal(mod(ray.origin.xy * 2.0 - 1.0, 1.0), 100.0, 123.45);\n        vec3 powNorm = abs(norm);\n        powNorm *= pow(powNorm, vec3(2.0));\n        powNorm /= powNorm.x + powNorm.y + powNorm.z;\n        vec3 normalMap = colYZ * powNorm.x + colXZ * powNorm.y + colXY * powNorm.z;\n        vec3 bumpNormal = norm + normalMap;\n      \n        float NdotL = dot(vec3(dot(cameraDirection, reflect(-lightDirection, bumpNormal))), bumpNormal);\n        vec3 ramp = getJetSpectra(vec2(mod(NdotL, 3.0)));\n        col = (ambient + ramp * 0.2) + attenuation * (diffuse + specular) * (ambient + 0.4);\n        break;\n      }\n      ray.origin += ray.direction * dist;\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 234, 234, 598], [600, 600, 639, 639, 694], [696, 696, 756, 756, 859], [861, 861, 898, 898, 1228], [1231, 1231, 1262, 1262, 1932], [1934, 1934, 1954, 1954, 2249], [2251, 2251, 2308, 2308, 2790], [2792, 2792, 2855, 2855, 3306], [3308, 3308, 3337, 3337, 3728], [3730, 3730, 3787, 3787, 5849]], "test": "untested"}
{"id": "wtGyzK", "name": "half-Laplacian kernel", "author": "TinyTexel", "description": "A kernel that approximates the half-Laplacian operator in 2d using 30 filter tabs and two passes.\nleft: kernel in spatial domain \nright : kernel in frequency domain\ntop : cross sections             \nbottom: 2d top-down view", "tags": ["filter", "kernel", "laplacian", "laplace"], "likes": 2, "viewed": 371, "published": 3, "date": "1611344012", "time_retrieved": "2024-07-30T19:43:12.791972", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\nA kernel that approximates the half-Laplacian operator in 2d using 30 filter tabs and two passes.\n\nThe half-Laplacian in 2d is not separable due to its cone shaped frequency response.\nThis together with its heavy tailed falloff in the spatial domain make a practical implementation non trivial\n(in contrast to the Laplacian, which can be computed as the *sum* of two 1d filters due its spectrum being a paraboloid).\n\nI use a compact filter bank of 3 separable kernels here to construct a somewhat decent approximation from the weighted sum of their individual results.\nThe used kernels are two flat-band FIR filters ( https://www.shadertoy.com/view/ttfBzj ) for the low and mid ranges and a Laplacian to handle the highs.\n\n\nCommon   - #define settings \nBuffer A - horizontal filter pass\nBuffer B - vertical filter pass + weighted sum\nBuffer C - Fourier transform (used for visualisation purposes only)\n\nImage    - left: kernel in spatial domain | right : kernel in frequency domain\n           top : cross sections           | bottom: 2d top-down view\n           \n           \nMy main motivation for building this approximation is its application in the simulation of water surfaces:\n- http://jtessen.people.clemson.edu/papers_files/Interactive_Water_Surfaces.pdf\n- https://en.wikipedia.org/wiki/Dispersion_(water_waves)\n\nMathematical background and applications of the fractional Laplacian: \n- https://www.researchgate.net/publication/275669247_Nonlocal_Diffusion_and_Applications\n\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // spectrum 2d plot\n        float dc = length(textureLod(iChannel1, (vec2(SIZE*0.5+0.5)/iResolution.xy), 0.).xy);\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        float s = 1.0/SIZE;\n        \n      #if SOURCE_TYPE == 0\n        s = 0.32;\n      #endif\n        \n        amp *= s;\n        dc *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n      #ifdef SHOW_ERROR_IN_SPECTRUM\n      \n        vec2 xy = ((uv0-0.5-vec2(1.5, 0.5)*SIZE)/SIZE*2.0)*Pi;\n        float ampRef = length(xy);\n      #ifdef USE_LAPLACIAN_INSTEAD\n        ampRef = dot(xy, xy)*0.5;\n      #endif\n        ampRef *= s;\n        \n        col = mix(col, vec3(1.0, 0.0, 0.0), smoothstep(0.0, 0.05, ampRef-amp));\n        col = mix(col, vec3(1.0, 1.0, 0.0), smoothstep(0.0, 0.05, amp-ampRef));\n      \n      #endif\n    }\t\n    else\n    {\n        // kernel 2d plot\n        float n = textureLod(iChannel0, tc, 0.).r;\n\n      #if SOURCE_TYPE == 0\n        col = vec3(abs(n));\n      #else\n        col = vec3(clamp01(n));\n      #endif\n        \n      #if SOURCE_TYPE == 0\n        if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n      #endif\n                \n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n    // kernel 1d plot\n    if (uv0.y > SIZE && uv0.x < SIZE)\n    {\n        vec2 tc = (uv0 - vec2(0.0, SIZE)) / (iResolution.xy - SIZE);\n        \n        float v = 0.0;\n        \n        float f = texelFetch(iChannel0, ivec2(vec2(tc.x*SIZE, SIZE*0.5)), 0).r;\n        \n        col = vec3(0.0);\n        \n        // antialias plot (lazy brute force)\n        float count = 8.0;\n        for(float i = -count; i <= count; ++i)\n        {\n            float h = (tc.y + (i/count*1.) / (iResolution.y - SIZE)) * 2.0 - 1.0;\n            h += 0.25;\n\n            v = f < h ? 0.0 : 1.0;\n\n            col +=  mix(vec3(v), mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.02, 0.1), v), bvec3(h <= 0.0));\n        }\n        col /= count*2.0+1.0;\n        \n        col = pow(col, vec3(1.0/2.2));\n        \n    }\n    \n    // spectrum 1d plot\n    if (uv0.y > SIZE && uv0.x > SIZE)\n    {\n        vec2 tc = (uv0 - SIZE) / (iResolution.xy - SIZE);\n        \n     #if 1\n        float f = length(texelFetch(iChannel1, ivec2(vec2(SIZE*0.5 + (tc.x-0.5)*SIZE, SIZE*0.5)), 0).xy);// horizontal cross section\n     #else\n        float f = length(texelFetch(iChannel1, ivec2(vec2(SIZE*0.5 + (tc.x-0.5)*SIZE, SIZE*0.5+ (tc.x-0.5)*SIZE)), 0).xy);// diagonal cross section\n        \n        #ifdef USE_LAPLACIAN_INSTEAD\n        f *= 0.5;\n        #else\n        f *= sqrt(0.5);\n        #endif\n     #endif\n     \n      #ifdef USE_LAPLACIAN_INSTEAD\n        float ref = Pow2((tc.x*2.0-1.0)*Pi)*0.5;\n      #else\n        float ref = abs((tc.x*2.0-1.0)*Pi);\n      #endif\n      \n      #if SOURCE_TYPE == 0\n        f   *= 0.32;\n        ref *= 0.32;\n      #else\n        f   *= 1.0/SIZE;\n        ref *= 1.0/SIZE;\n      #endif\n        \n        float v    = smoothstep(0.0, 1.0, (f - tc.y) * (iResolution.y - SIZE) * 0.5);\n        float vref = smoothstep(0.0, 1.0, (ref - tc.y) * (iResolution.y - SIZE) * 0.5);\n        \n        col = v * vec3(0.125, 1.0, 0.5);\n        \n      #ifdef SHOW_ERROR_IN_SPECTRUM\n        col = mix(col, vec3(1.0, 1.0, .0), clamp01(v-vref));\n        col = mix(col, vec3(1.0, 0.0, .0), clamp01(vref-v));\n      #endif\n      \n        col = pow(col, vec3(1.0/2.2));\n    }\n\n    outCol = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n  //#define USE_LAPLACIAN_INSTEAD\n\n  //#define APPLY_AS_LOWPASSFILTER\n\n  //#define DONT_APPLY_FILTER\n\n  //#define SHOW_ERROR_IN_SPECTRUM\n\n    #define SOURCE_TYPE 0\n    /*\n        0 - discrete impulse\n        1 - white noise\n        2 - texture\n    */\n\n  \n  \n  #ifdef APPLY_AS_LOWPASSFILTER \n      #undef SHOW_ERROR_IN_SPECTRUM\n  #endif\n\n  #ifdef DONT_APPLY_FILTER\n      #undef SHOW_ERROR_IN_SPECTRUM\n  #endif\n  \n  #if SOURCE_TYPE != 0\n      #undef SHOW_ERROR_IN_SPECTRUM\n  #endif\n\n\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\n", "buffer_a_code": "\n\n#if SOURCE_TYPE == 0\n\n    #define FETCH(uv) (uv).x == uint(SIZE*0.5) && (uv).y == uint(SIZE*0.5) ? 1.0 : 0.0\n\n#elif SOURCE_TYPE == 1\n\n    #define FETCH(uv) EvalWhiteNoise(uv)\n\n#else\n\n    #define FETCH(uv) pow(texelFetch(iChannel0, ivec2(uvec2(uv)%512u), 0).r, 2.2)\n\n#endif\n\n\nfloat EvalWhiteNoise(uvec2 uv)\n{\n    const uint r  = 2654435761u;\n    const uint r0 = 3242174893u;\n    const uint r1 = 2447445397u;\n    uint h = ((uv.x * r0 + uv.y) ^ (uv.y * r1 + uv.x)) * r;\n    return float(h) * (1.0 / 4294967295.0);\n}\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE) { discard; return; }\n    \n    uvec2 uv = uvec2(uv0 - 0.5);\n    \n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int x = -7; x <= 7; ++x)\n    {\n        float f = FETCH(uv + uvec2(x, 0));\n    \n        int i = abs(x);\n\n        lowpass3  += f * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f * lowp7[i];\n        laplacian += f * lapl7[i];\n    }\n\n    float f0 = FETCH(uv);\n    \n    col = vec4(lowpass3, lowpass7, f0, laplacian);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n*/\n\n#define FETCH(uv) texelFetch(iChannel0, ivec2(uv), 0)\n\nvoid mainImage(out vec4 col, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE) { discard; return; }\n\n    uvec2 uv = uvec2(uv0 - 0.5);\n\n    float lowp3[4] = float[4](5.0/16.0, 15.0/64.0, 3.0/32.0, 1.0/64.0);   \n    float lowp7[8] = float[8](429.0/2048.0, 3003.0/16384.0, 1001.0/8192.0, 1001.0/16384.0, 91.0/4096.0, 91.0/16384.0, 7.0/8192.0, 1.0/16384.0);   \n    float lapl7[8] = float[8](3.22, -1.9335988099476562, 0.4384577800334821, -0.1637450351359609, 0.07015324480535713, -0.02963974593026339, 0.010609595665007715, -0.0022370294899667453);   \n\n    float lowpass3  = 0.0;\n    float lowpass7  = 0.0;\n    float laplacian = 0.0;\n    \n    for(int y = -7; y <= 7; ++y)\n    {\n        vec3 f = FETCH(uv + uvec2(0, y)).xyz;\n    \n        int i = abs(y);\n\n        lowpass3  += f.x * (i < 4 ? lowp3[i] : 0.0);\n        lowpass7  += f.y * lowp7[i];\n        laplacian += f.z * lapl7[i];\n    }\n\n    vec4 f0 = FETCH(uv);\n    \n    laplacian += f0.w;\n    \n    float highpass = f0.z - mix(lowpass3, lowpass7, 0.772);\n    float halfLaplacian =   mix(highpass, laplacian, 0.19)*1.255;\n\n    float v = halfLaplacian;\n\n  #ifdef USE_LAPLACIAN_INSTEAD\n    v = laplacian * 0.5;\n  #endif\n\n  #ifdef APPLY_AS_LOWPASSFILTER\n    #ifdef USE_LAPLACIAN_INSTEAD\n    v = f0.z - 0.22*v;\n    #else\n    v = f0.z - 0.32*v;\n    #endif\n  #endif\n    \n  #ifdef DONT_APPLY_FILTER\n    v = f0.z;\n  #endif\n    \n    col = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(20.0); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyzK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1560, 1560, 1606, 1606, 5225]], "test": "untested"}
{"id": "3lKyRV", "name": "Interlocking Hexgonal Pattern", "author": "oneshade", "description": "I am having WAY too much fun.", "tags": ["demo", "pattern", "tiling", "hexagonal", "interlocking"], "likes": 6, "viewed": 171, "published": 3, "date": "1611342932", "time_retrieved": "2024-07-30T19:43:13.545956", "image_code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexLink(in vec3 p, in float radius, in float thickness) {\n    p = abs(p);\n    return max(abs(max(dot(p.xz, vec2(0.5, 0.86602540378)), p.x) - radius), p.y) - thickness;\n}\n\nSurface mapScene(in vec3 p) {\n    p.xy = vec2(atan(p.y, p.x) * 10.0, length(p.xy));\n    p.y -= 10.0;\n\n    float tileSize = 8.0;\n    float thickness = 0.2;\n\n    vec2 repTile = vec2(1.0, 1.73) * tileSize;\n    vec2 hRepTile = 0.5 * repTile;\n\n    vec2 a = mod(p.xz, repTile) - hRepTile;\n    vec2 b = mod(p.xz - hRepTile, repTile) - hRepTile;\n    p.xz = dot(a, a) < dot(b, b) ? a : b;\n\n    float linkSize = 0.35 * tileSize;\n    float basePattern = sdHexLink(p, linkSize, thickness);\n\n    float repAng = 6.28 / 6.0;\n    float hRepAng = 0.5 * repAng;\n    p.xz = sin(mod(atan(p.z, p.x) - hRepAng, repAng) - hRepAng + vec2(1.57, 0.0)) * length(p.xz);\n    float links = sdHexLink(p.xzy - vec3(0.575 * tileSize, 0.0, 0.0), linkSize, thickness);\n\n    return Surface(min(basePattern, links), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 16.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, -iTime * 20.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c = cos(iTime), s = sin(iTime);\n    rd.xy *= mat2(c, -s, s, c);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 174, 174, 286], [288, 288, 317, 317, 1128], [1130, 1130, 1157, 1157, 1434], [1436, 1436, 1491, 1491, 2499]], "test": "untested"}
{"id": "wlycRV", "name": "glitchmarch", "author": "ompuco", "description": "silly little datamosh shader w/ reprojection filter code from https://www.shadertoy.com/view/lsG3D1", "tags": ["glitch", "datamosh"], "likes": 9, "viewed": 645, "published": 3, "date": "1611340158", "time_retrieved": "2024-07-30T19:43:14.417625", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 BS_A = vec4(   3.0,  -6.0,   0.0,  4.0 ) /  6.0;\nvec4 BS_B = vec4(  -1.0,   6.0, -12.0,  8.0 ) /  6.0;\nvec4 RE_A = vec4(  21.0, -36.0,   0.0, 16.0 ) / 18.0;\nvec4 RE_B = vec4(  -7.0,  36.0, -60.0, 32.0 ) / 18.0;\nvec4 CR_A = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nvec4 CR_B = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\nvec4 PS_A = vec4(   1.25,-2.25,   0.0,  1.0 ) /  1.0;\nvec4 PS_B = vec4(  -0.75, 3.75,  -6.0,  3.0 ) /  1.0;\n\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nvec4 ca, cb;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    ca = PS_A;\n    cb = PS_B;\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\n\n\n\n\n\n\n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat map(vec3 p) {\n    //_Mod = 0;// .6;//+sin(_Frame)*.1;\n\t//p=floor(p*128)/128;\n\t//p=floor(p*128.1)/128.1;\n    //p.xz=kaleido(p.xz,35.0);  \n      \n\n\tvec3 p2=p;\n\tp2.xz+=vec2(sin(p.y*4.0), cos(p.y*4.0))/16.0;\n     float d = sdBox(p, vec3(3.0, 1.0, 3.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<6; m++ )\n   {\n      //float3 a = mod( p*s, 3.0+(_Time.w%p.xyz/100.0)/3.0+.2 )-1.0;\n\n\n    //  float3 a = mod( p*s, 3.313)-1;//+sin(_Time.w)/2.0 )-1.0;\n      //float3 a = mod( p*s, 3.413+sin(_Time.x )/2.0-.5 )-1.0;\n      vec3 a = mod( p*s, 2.0 + .125 )-1.0;\n\n\n      //float3 a = mod( p*s, sin(p)+3.0)-1;//+sin(_Time.w)/2.0 )-1.0;\n     // float3 a = mod( p*s, round(sin(floor(p*32)/32)*1.0)+3.0)-1;//+sin(_Time.w)/2.0 )-1.0;\n      //float3 a = mod( p*s, 2 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0);\n       }\n   }\n\n   return res.x;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ) - map( pos-eps.xyy ),\n      map( pos+eps.yxy ) - map( pos-eps.yxy ),\n      map( pos+eps.yyx ) - map( pos-eps.yyx ) ) );\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.01;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n\n\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n    float tmax = 16.0;\n    float t = 0.001;\n    vec3 ord =rd;\n    for(int i=0; i<128; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax ) break;\n        \t\t//rd.zy = rotate(ord.zy,t*.3);\n        t +=  h;\n    }\n    \n    if( t<tmax ) res = t;\n\n    return res;\n}\n\n\n\n\nfloat hash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n&0x7fffffffU)/float(0x7fffffff);\n}\n", "buffer_a_code": "vec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 previousPos = texture(iChannel0, vec2(1.5,1.5) / iResolution.xy).xyz;\n\n    float t = iTime*1.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n     \n    vec2 p = (-iResolution.xy + 2.0*(fragCoord)) / iResolution.y;\n    vec3 ta = vec3(1.5,0.7,1.5);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(t+uv.xyx+vec3(0,2,4));\n    \n    vec3 ro = vec3(0.0, 0.0, sin(t*.25)*4.0);\n    vec3 rd = normalize(vec3(uv.x-.5,uv.y-.5,1.0));\n    mat3  ca = setCamera( ro, ta, 0.30 );\n    rd = normalize( ca * vec3(p,-1.3) );\n\n    float d = intersect(ro, rd);\n    \n    vec3 pos = ro + rd * d;\n    \n    \n    \n    \n    \n    \n    vec3 roPrev = previousPos;\n    vec3 rdPrev = normalize(vec3(uv.x-.5,uv.y-.5,1.0));\n    ta = vec3(1.5,0.7,1.5);\n    mat3  caPrev = setCamera( roPrev, ta, 0.30 );\n    mat4 cap2 = mat4(\n        caPrev[0][0],caPrev[0][1],caPrev[0][2], -dot(caPrev[0],roPrev),\n\n        caPrev[1][0],caPrev[1][1],caPrev[1][2], -dot(caPrev[1],roPrev),\n\n        caPrev[2][0],caPrev[2][1],caPrev[2][2], -dot(caPrev[2],roPrev),\n\n        0.0, 0.0, 0.0, 1.0);\n        \n        rdPrev = normalize( caPrev * vec3(p,-1.3) );\n    \n    float dPrev = intersect(roPrev, rdPrev);\n    \n    vec3 posPrev = roPrev + rdPrev * dPrev;\n    \n    vec3 cpos = (vec4(pos,1.0) * cap2).xyz;//(pos*caPrev).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = -1.3 * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    vec2 motion = spos - uv;\n    \n    \n\n    \n    \n    vec3 normal = calcNormal(pos);\n    \n    vec3 lDir = normalize(vec3(-2.3,2.3,2.1));//normalize(vec3(sin(iTime*.5),1.3,cos(iTime*.5)));\n    \n    vec3 sCol = vec3(1.0,1.0,1.0) * (dot(lDir,normal)*.5+.5);\n    float sh = shadow(pos, lDir);\n    sCol *= .3+.75*sh;\n    sCol = clamp(sCol,.0,1.);\n\n    float ns = hash1(uint(floor(fragCoord.x/32.0)+floor(fragCoord.y/32.)*iResolution.x+mod(float(iFrame/4) * iResolution.x * iResolution.y, 24562.7452)));\n    //if(mod(iTime,8.0)>1.0)\n    if(iFrame>10)\n    sCol = mix(sCol, texture_Bicubic(iChannel0, uv + motion).xyz,step(ns*.95 + length(motion)*.25,.9));//sin(coord.xyx*44.0)*.5+.5;//abs(pos - posPrev);\n    \n    sCol = clamp(sCol,.0,1.);\n    if(d>.0)col = sCol;//vec3(n, n, n);\n    // Output to screen\n    \n    if(ivec2(fragCoord.xy)==ivec2(1,1))col = ro; //rd & etc calculated from ro, so that's all we need\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlycRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 190]], "test": "untested"}
{"id": "3tKcRK", "name": "Procedural Mandelbulb Cubemap", "author": "Zi7ar21", "description": "I dunno, copy and paste this into Cubemap A and replace the Cubemap in another shader...", "tags": ["fractal", "mandelbulb", "cubemap"], "likes": 0, "viewed": 364, "published": 3, "date": "1611338807", "time_retrieved": "2024-07-30T19:43:15.296276", "image_code": "#define camerafov 2.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 raydirection = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n\n    vec3 col = texture(iChannel0, raydirection).rgb;\n\n    // Output to screen\n    fragColor += vec4(col, 1.0);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "#define power 8.0\n#define collisiondistance 0.001\n\nfloat distanceestimator(vec3 pos){\n    pos *= 0.5;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 8; i++){\n\t\tr = length(z);\n\t\tif (r > 4.0) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr = pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t// Convert back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;}\n\treturn 0.5*log(r)*r/dr;}\n\nvec3 raymarch(vec3 raydirection, vec3 rayorigin){\n    vec3 rayposition = rayorigin;\n    float distanceestimate = 0.0;\n    float distancetravelled = 0.0;\n    for(int i = 0; i < 128; i++){\n        distanceestimate = distanceestimator(rayposition);\n        if(distanceestimate < collisiondistance){return rayposition;}\n        distancetravelled += distanceestimate;\n        if(distancetravelled > 32.0){break;}\n        rayposition += raydirection*distanceestimate;}\n    return vec3(0.0);}\n\nvec3 normal(vec3 p){\n    const vec2 h = vec2(collisiondistance, 0.0);\n    return normalize(vec3(distanceestimator(p+h.xyy)-distanceestimator(p-h.xyy),\n                          distanceestimator(p+h.yxy)-distanceestimator(p-h.yxy),\n                          distanceestimator(p+h.yyx)-distanceestimator(p-h.yyx)));}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    // Ray direction as color\n    vec3 raymarched = raymarch(rayDir, vec3(0.0, 2.0, 0.0));\n    vec3 normals = normal(raymarched);\n\n    // Output to cubemap\n    fragColor = vec4(texture(iChannel0, normals).rgb, 1.0);\n    if(raymarched == vec3(0.0)){fragColor = vec4(texture(iChannel0, rayDir).rgb, 1.0);}\n}", "cube_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 77, 127, 510]], "test": "untested"}
{"id": "wtyczV", "name": "Audioviz", "author": "darkeclipz", "description": "Visualizer for audio", "tags": ["sound", "music", "audio", "visualizer", "visualiser"], "likes": 6, "viewed": 408, "published": 3, "date": "1611336238", "time_retrieved": "2024-07-30T19:43:16.052255", "image_code": "vec3 magma(float t) { // from Mattz\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid bar(vec2 uv, out vec3 col) {\n    float width = 5./iResolution.x;\n    vec2 moduv = mod(uv, width);\n    float nSamples = 10.;\n    float sampleWidth = width / nSamples;\n    float samples = 0.;\n    for(float i=0.; i < nSamples; i++) \n        samples += texture(iChannel0, vec2(uv.x-moduv.x + i*sampleWidth, 0.)).x;\n    float y = samples / nSamples;\n    float gap = 1./iResolution.x;\n    if(y > uv.y && moduv.x > gap && moduv.x < 1.0-gap) {\n        float t = 0.7 - 0.7*y;\n        col = magma(y);\n    }\n}\n\nvoid heat(vec2 uv, out vec3 col) {\n    float t = texture(iChannel0, uv).y;\n    col = magma(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0);\n    if(uv.y > 0.5) bar (uv*vec2(1.,2.)-vec2(0.,1.), col);\n    else           heat(uv*vec2(1.,2.)            , col);\n    col = mix(vec3(0), col, min(1.0, 2.25*sqrt(abs(uv.y-0.5))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    Calculates the height of the bar y.\n    If the bar is higher than what is stored in BuffA, store this\n    new height. Otherwise slowly lower the bar height.\n*/\n\n//#define HEAT_DECAY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel1, vec2(uv.x, 0.)); \n    \n    // Bar \n    float y = tex.x;\n    float buff = texture(iChannel0, uv).x;\n    float height = max(y, buff-0.275*iTimeDelta);\n    \n    // Heat\n    float map = 0.;\n    if(fragCoord.x < 1.5) {\n        map = texture(iChannel1, vec2(uv.y, 0.)).x;\n    }\n    else {\n        #ifdef HEAT_DECAY\n        map = max(texture(iChannel0, (fragCoord.xy - vec2(1., 0.)) / iResolution.xy).y,\n                  0.99*texture(iChannel0, (fragCoord.xy) / iResolution.xy).y);\n        #else\n        map = texture(iChannel0, (fragCoord.xy - vec2(1., 0.)) / iResolution.xy).y;\n        #endif\n        \n    }\n    \n    fragColor = vec4(height, map, 0, 0);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 35, 694], [696, 696, 729, 729, 1199], [1201, 1201, 1235, 1235, 1297], [1299, 1299, 1355, 1355, 1638]], "test": "untested"}
{"id": "WlKyzG", "name": "My Horrific Ray-Tracer", "author": "Zi7ar21", "description": "Big bruh moment, Raymarching is far better.", "tags": ["raytracing", "reflection", "sphere", "raytrace", "cineshader"], "likes": 6, "viewed": 9725, "published": 3, "date": "1611332443", "time_retrieved": "2024-07-30T19:43:16.869071", "image_code": "// ####### Ray-Tracing #######\n\n// p.s. i am currently fixing the cringe code, don't use it until I'm done, I beg you\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Preprocessor #####\n\n/*\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n/*\n#pragma debug(off)\n#pragma optimize(on)\n*/\n\n/*\n#pragma debug(on)\n#pragma optimize(off)\n*/\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// ##### Maths #####\n\n// Rotate a 2-Component Vector\nvec2 rotate(vec2 vector, float theta)\n{\n    float s = sin(theta), c = cos(theta);\n    return vec2(vector.x * c - vector.y * s, vector.x * s + vector.y * c);\n}\n\n// Dot Product\n// for optimizations involving comparing length, for example:\n// min(length(vector0), length(vector1))\n// This can be simplified and save using an extra sqrt() by changing it to:\n// sqrt(min(dotp(vector0), dotp(vector1)))\n\nfloat dot_p(vec2 vector) { return dot(vector, vector); }\nfloat dot_p(vec3 vector) { return dot(vector, vector); }\nfloat dot_p(vec4 vector) { return dot(vector, vector); }\n\n// ##### Random Number Generator #####\n\nuint pcg(uint x) {\n    uint state = x * 747796405u + 2891336453u;\n    uint word = ( ( state >> ( (state >> 28u) + 4u ) ) ^ state ) * 277803737u;\n    x = (word >> 22u) ^ word;\n    return x;\n}\n\n// Triple32 Hash: https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x) {\n    x ^= x >> 17u;\n    x *= 0xED5AD4BBu;\n    x ^= x >> 11u;\n    x *= 0xAC4C1B51u;\n    x ^= x >> 15u;\n    x *= 0x31848BABu;\n    x ^= x >> 14u;\n    return x;\n}\n\n// Random Number Generator Seed\nuint ns;\n\n// Initialize Random Number Generator\n#define INIT_RNG ns = uint(iFrame) * uint(iResolution.x * iResolution.y) + uint(fragCoord.x + fragCoord.y * iResolution.x) + 1u;\n\n// Uniform Random Value Between 0.0 and 1.0\nfloat rand() {\n    // Update RNG\n    ns = pcg(ns);\n    //ns = triple32(ns);\n\n    return float(ns) / float(0xFFFFFFFFu);\n}\n\n// 2-Component Uniform Random Vector\nvec2 rand2() {\n    vec2 vector;\n    vector.x = rand();\n    vector.y = rand();\n    return vector;\n}\n\n// 3-Component Uniform Random Vector\nvec3 rand3() {\n    vec3 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.y = rand();\n    return vector;\n}\n\n// 4-Component Uniform Random Vector\nvec4 rand4() {\n    vec4 vector;\n    vector.x = rand();\n    vector.y = rand();\n    vector.z = rand();\n    vector.w = rand();\n    return vector;\n}\n\n// Uniformly distributied random point on a unit circle\nvec2 udir2() {\n    float z = rand();\n    float r = two_pi * z;\n    float s = sin(r), c = cos(r);\n    return vec2(s, c);\n}\n\n// Uniformly distributed random point on the surface of a unit sphere\nvec3 udir3() {\n    vec2 z = rand2();\n    vec2 r = vec2( two_pi * z.x, acos(2.0 * z.y - 1.0) );\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x * s.y, s.x * s.y, c.y);\n}\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// 2D Gaussian Distribution\nvec2 nrand2(vec2 mean, float sigma) {\n    vec2 z = rand2();\n    return mean + sigma * sqrt( -2.0 * log(z.x   ) ) * vec2(cos(two_pi * z.y), sin(two_pi * z.y) );\n}\n\n// 3D Gaussian Distribution\nvec3 nrand3(vec3 mean, float sigma) {\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxy ) ) * vec3(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w) );\n}\n\n// 4D Gaussian Distribution\nvec4 nrand4(vec4 mean, float sigma) {\n    vec4 z = rand4();\n    return mean + sigma * sqrt( -2.0 * log(z.xxyy) ) * vec4(cos(two_pi * z.z), sin(two_pi * z.z), cos(two_pi * z.w), sin(two_pi * z.w) );\n}\n\n// ##### Misc #####\n\n// Blackman-Harris Pixel Filter\nvec2 pixel_filter(vec2 pixel_coord)\n{\n    // Gaussian Pixel Filter\n    //return nrand2(pixel_coord, 0.5);\n\n    // https://en.wikipedia.org/wiki/Window_function#BlackmanHarris_window\n    // w[n] = a0-a1*cos(2*pi*n/N)+a2*cos(4*pi*n/N)-a3*cos(6*pi*n/N)\n    // a0 = 0.35875; a1 = 0.48829; a2 = 0.14128; a3 = 0.01168\n    float n = 0.5 * rand() + 0.5;\n    float w = 0.35875 - 0.48829 * cos(2.0 * pi * n) + 0.14128 * cos(4.0 * pi * n) - 0.01168 * cos(6.0 * pi * n);\n    return pixel_coord + (udir2() * 2.0 * w);\n}\n\n/*\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\nfloat ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n*/", "buffer_a_code": "#define FOV 1.0\n\n/*\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect(in vec3 ro, in vec3 rd){\n    vec3 ce = sphereposition;\n    float ra = spheresize;\n    vec3 oc = ro-ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc)-ra*ra;\n    float h = b*b-c;\n    if(h < 0.0){return vec2(-1.0);}\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n*/\n\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra)\n{\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n\n    if(h < 0.0)\n    {\n        return vec2(-1);\n    }\n\n    h = sqrt(h);\n\n    return vec2(-b - h, -b + h);\n}\n\n/*\n// Suggested by Michael0884\nvec3 fresnel(vec3 rd, vec3 hvec){\n    vec3 F0 = vec3(1.0);\n    return F0+(1.0-F0)*pow(1.0-dot(-rd, hvec), 5.0);\n}\n*/\n\nvec3 fresnel(vec3 rd, vec3 h)\n{\n    const vec3 F0 = vec3(1);\n\n    //return F0 + (1.0 - F0) * pow(1.0 - dot(-rd, h), 5.0);\n\n    float p = 1.0 - dot(-rd, h);\n\n    return F0 + (1.0 - F0) * (p * p * p * p * p);\n}\n\nfloat mod289(float x) { return x - floor( x * (1.0 / 289.0) ) * 289.0; }\nvec4  mod289(vec4  x) { return x - floor( x * (1.0 / 289.0) ) * 289.0; }\nvec4  perm  (vec4  x) { return mod289( ( (x * 34.0) + 1.0 ) * x)     ; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p-a;\n    d = d*d*(3.0-2.0*d);\n    vec4 b = a.xxyy+vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n    vec4 c = k2+a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c+1.0);\n    vec4 o1 = fract(k3*(1.0/41.0));\n    vec4 o2 = fract(k4*(1.0/41.0));\n    vec4 o3 = o2*d.z+o1*(1.0-d.z);\n    vec2 o4 = o3.yw*d.x+o3.xz*(1.0-d.x);\n    return o4.y*d.y+o4.x*(1.0-d.y);\n}\n\nfloat fbm(vec3 p, int octaves)\n{\n    octaves = max(octaves, 1);\n\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < octaves; i++)\n    {\n        value += atten * noise(scale * p);\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value / accum;\n}\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec2 intersection = sphIntersect(ro, rd, vec3(0), 1.0);\n\n    if(intersection.x < 0.0)\n    {\n        return texture(iChannel1, rd).rgb;\n    }\n\n    vec3 normal = normalize(ro + rd * intersection.x);\n\n    vec3 randomnormal = normalize( nrand3( normal, 0.1 * fbm(16.0 * normal, 8) ) );\n\n    vec3 reflected = reflect(rd, randomnormal);\n\n    vec3 color = fresnel(rd, normal)*texture(iChannel1, reflected).rgb;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iFrame != 0 ? texelFetch(iChannel0, ivec2(fragCoord), 0) : vec4(0);\n\n    INIT_RNG;\n\n    vec2 uv = 2.0 * (nrand2(fragCoord, 0.5) - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize( vec3(FOV * uv, -1.0) );\n\n    vec3 color = radiance(ro, rd);\n\n    fragColor += vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor.rgb = texel.a != 0.0 ? texel.rgb / texel.a : texel.rgb;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 174, 174, 236]], "test": "untested"}
{"id": "wtGcRV", "name": "high on vertigo", "author": "YitingLiu", "description": "effects of vertigo and psychedelic. ", "tags": ["noise", "mix", "time", "color", "random", "rotate", "pi", "psychedelic", "generative", "code", "smoothstep", "scale", "step", "offset", "creative", "freq"], "likes": 5, "viewed": 322, "published": 3, "date": "1611330958", "time_retrieved": "2024-07-30T19:43:17.625050", "image_code": "#define PI 3.14159265359\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    // vec2 u = f*f*(3.0-2.0*f);\n    vec2 u = f*f*(3.0-15.*abs(tan(iTime*2.))*f);\n    u += smoothstep(0.,0.5,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat randomSerie(float x, float freq, float t) {\n    return step(.8,random( floor(x*freq)-floor(t) ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);    vec3 color = vec3(1.0);\n        // move space from the center to the vec2(0.0)\n    st -= vec2(random(0.5));\n    // rotate the space\n    st = rotate2d( sin(cos(iTime))*PI*(abs(cos(iTime))/1e2+1.)) * st/0.8;\n        st = scale( vec2(sin(iTime)+1.0) ) * st/5.;\n    // move it back to the original place\n    st += vec2(random(0.5));\n    \n    // Scale the coordinate system to see\n    // some noise in action\n    vec2 pos = vec2(st*10.0*smoothstep(0.,0.5,abs(sin(iTime))));\n    float freq = random(1.);\n    float t = random(10.);\n   float offset = 0.0005+random(0.5);\n        // Use the noise function\n\nfloat n = noise(pos);\n    color = vec3(randomSerie(st.x*n*1e1, freq*200., n*t+offset),\n                 randomSerie(atan(st.x,st.y), freq*100., n/t),\n                 randomSerie(tan(st.y), freq*1000.*cos(iTime), t-offset));\n    color/= vec3(n);\n    color*=vec3(n)*1e2;\n    \n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 39, 66, 66, 183], [186, 186, 213, 213, 245], [247, 247, 275, 275, 361], [363, 363, 387, 387, 450], [452, 539, 565, 565, 1138], [1139, 1139, 1188, 1188, 1244], [1245, 1245, 1302, 1302, 2300]], "test": "untested"}
{"id": "3lyyzV", "name": "Inverse Gray Coded Curve", "author": "Dain", "description": " Alternative space filling curve to morton and hilbert that apparently falls between them for both computational cost and clustering \n\n https://www2.cs.arizona.edu/~bkmoon/papers/tkde-hilbert.pdf\n", "tags": ["2d", "inverse", "graycode", "morton"], "likes": 2, "viewed": 295, "published": 3, "date": "1611319261", "time_retrieved": "2024-07-30T19:43:18.531626", "image_code": "//Started from iq \" Inverse Morton and Hilbert\": https://www.shadertoy.com/view/XdlcWr\n\n\n//https://www2.cs.arizona.edu/~bkmoon/papers/tkde-hilbert.pdf\n//This paper compares morton , hilbert and something called gray coded curve: \n//It claims the gray coded curve is better at clustering than morton  order for 3D, but worse than hilbert\n//It didn't really clarify what the gray coded curve was exactly but after fiddling with gray coding this appears to be the same as the curve in the paper\n\n//There is an ugly worm that traces it see the steps\n\n// 0 = Hilbert\n// 1 = Morton\n#define CURVE 1\n\nconst int level = 4;  // Number of points is 2^level in each dimension\n\nint GrayToBinary32(int num){\n\t\tnum ^= num >> 16;\n\t\tnum ^= num >> 8;\n\t\tnum ^= num >> 4;\n\t\tnum ^= num >> 2;\n\t\tnum ^= num >> 1;\n\t\treturn num;\n}\n\nivec2 curve( int i )\n{\n    ivec2 res = ivec2(0,0);\n    \n    i = GrayToBinary32(i);\n    for( int k=0; k<level; k++ )\n    {\n        #if CURVE==0\n        // inverse Hilbert, https://en.wikipedia.org/wiki/Hilbert_curve\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { res = (1<<k)-1-res; } res = res.yx; }\n        #else\n\t\t// inverse Morton, https://iquilezles.org/articles/wavelet\n        ivec2 r = ivec2( i, i>>1 ) & 1;\n        #endif\n        \n        res += r<<k;\n        i >>= 2;\n    }\n   // res.x = GrayToBinary32(res.x);\n   // res.y = GrayToBinary32(res.y);\n    return res;\n}\n\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b, out float outH )\n{\n\tvec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    outH = h;\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.y; // size of a pixel\n    vec2 p = (fragCoord - vec2(0.25*iResolution.x,0.0))*e;\n    \n    p = -0.05 + (1.0+2.0*0.05)*p; // add margin of 0.05\n    \n    const int numPoints = 1<<(level<<1);\n    const float w = float((1<<level)-1); // distance between grid points\n\n    // compute distance field\n    float d = 2.0;\n    ivec2 o = ivec2(0,0);\n    float nearI = -1.0;\n    for( int i=1; i<numPoints; i++ )\n    {\n        ivec2 m = curve(i);\n        \n        float oldD = d;\n        float oH;\n        d = min( d, sdSqLine( p, vec2(m)/w, vec2(o)/w, oH));\n        if(d != oldD){\n          nearI = float(i)+(1.0-oH);\n        }\n        o = m;\n    }\n    d = sqrt(d);\n    \n    // colors\n    float f  = smoothstep(0.0,2.0*e,d); \n          f *= 0.8 + 0.2*sqrt(clamp(d/(8.0*e),0.0,1.0));\n     \n    // float k = sin(float(nearI)+iTime);\n   //  if(d >0.01){\n   //  k = 0.0;\n    // }\n    //make ugly worm follow it\n     float k2 = 0.0;\n    if((abs(nearI-iTime)) < .25 && d<0.015){\n      k2 = .5;\n    }\n    fragColor = vec4( f , max(f- k2,0.0), f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[665, 665, 693, 693, 805], [807, 807, 829, 829, 1416], [1419, 1419, 1486, 1486, 1631], [1637, 1637, 1694, 1694, 2758]], "test": "untested"}
{"id": "3lyczK", "name": "Ripples in Hexagonal Tiling", "author": "oneshade", "description": "Fun with hexagonal tiling.", "tags": ["ripples", "demo", "sine", "hue", "tiling", "hexagonal"], "likes": 14, "viewed": 257, "published": 3, "date": "1611298431", "time_retrieved": "2024-07-30T19:43:19.280623", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Woah thats trippy!\n//#define PSYCHO_MODE\n\nstruct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdHexShape(in vec3 p, in float s) {\n    const vec2 n = normalize(vec2(1.0, sqrt(3.0)));\n    p = abs(p);\n    vec2 p2 = vec2(max(dot(p.xz, n), p.x), p.y);\n\n    #ifdef PSYCHO_MODE\n    return max(length(p.xz) - 1.0, abs(p.y - s) - s);\n    #else\n    return max(abs(p2.x - s), p2.y) - 0.1;//max(dot(p2, n), p2.x) - s;\n    #endif\n}\n\nSurface mapScene(in vec3 p) {\n    vec2 rep = vec2(2.0, 3.46); // 1.73 ~ sqrt(3)\n    vec2 hrep = 0.5 * rep;\n    vec2 a = mod(p.xz, rep) - hrep;\n    vec2 b = mod(p.xz - hrep, rep) - hrep;\n    vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cellId = p.xz - hexUv;\n    p.xz = hexUv;\n\n    float oscPoint = 0.5;\n    float freq = 0.5;\n    float amp = 0.4;\n    #ifdef PSYCHO_MODE\n    oscPoint = 5.0;\n    freq = 0.25;\n    amp = 2.5;\n    #endif\n\n    float ripples = oscPoint + amp * sin(length(cellId) * freq - iTime * 4.0);\n    return Surface(sdHexShape(p, ripples) * 0.25, vec3(0.2, 0.0, 0.0), hue2rgb(ripples * freq), vec3(1.0), 8.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float camDist = 5.0;\n    #ifdef PSYCHO_MODE\n    camDist = 20.0;\n    #endif\n\n    vec3 ro = vec3(cos(iTime), 2.0 + sin(0.5 * iTime), cos(1.5 * iTime)) * camDist;\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 332, 332, 621], [623, 623, 652, 652, 1257], [1259, 1259, 1286, 1286, 1563], [1565, 1565, 1620, 1620, 2896]], "test": "untested"}
{"id": "WlycRK", "name": "Octodecahedron SDF (not exact)", "author": "oneshade", "description": "I wondered what a 3D hexagon would look like and modelled this using the hexagonal distance function I learned in the Art of Code's hexagonal tiling tutorial.", "tags": ["3d", "raymarching", "distancefield", "sdf", "bound", "octodecahedron"], "likes": 1, "viewed": 159, "published": 3, "date": "1611291458", "time_retrieved": "2024-07-30T19:43:20.185205", "image_code": "struct Surface {\n    float dist;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nfloat sdOctoDecahedron(in vec3 p, in float s) {\n    const vec2 n = normalize(vec2(1.0, sqrt(3.0)));\n    p = abs(p);\n    vec2 p2 = vec2(max(dot(p.xz, n), p.x), p.y);\n    return max(dot(p2, n), p2.x) - s;\n}\n\nSurface mapScene(in vec3 p) {\n    vec3 planeColor = vec3(mod(dot(floor(p.xz), vec2(1.0)), 2.0));\n    Surface plane = Surface(p.y + 1.0, 1.6 * planeColor, planeColor, vec3(0.0), 0.0);\n    Surface shape = Surface(sdOctoDecahedron(p.yxz, 1.0), vec3(0.2, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(1.0), 8.0);\n\n    if (plane.dist < shape.dist) {\n        return plane;\n    }\n\n    return shape;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = 0.5 * iTime;\n    float c = cos(time), s = sin(time);\n    vec3 ro = vec3(-5.0 * c, 1.0, -5.0 * s);\n\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = -f;\n    l.xz *= mat2(c, s, -s, c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += scene.ambient;\n\n            float lambertian = max(0.0, dot(n, l));\n            fragColor.rgb += scene.diffuse * lambertian;\n\n            if (lambertian > 0.0) {\n                vec3 r = reflect(l, n);\n                float specAngle = max(0.0, dot(r, rd));\n                fragColor.rgb += scene.specular * max(0.0, pow(specAngle, scene.gloss));\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += scene.dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 156, 156, 313], [315, 315, 344, 344, 699], [701, 701, 728, 728, 1005], [1007, 1007, 1062, 1062, 2197]], "test": "untested"}
{"id": "WlGcRK", "name": "ciudad picos", "author": "jorge2017a1", "description": "ciudad picos", "tags": ["ciudadpicos"], "likes": 3, "viewed": 225, "published": 3, "date": "1611286966", "time_retrieved": "2024-07-30T19:43:21.263322", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nmat2 rot2Dinv(float a)\n{\n    float c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat shape(vec3 p, float a) \n{\n\tfloat s = sdSphere(abs(p) - vec3(2, 0, 0),  0.5);\n\tfloat b= sdCappedCone(  p, 2.0, 0.1, 1.0 );\n    vec3 pp=rotate_x(p, radians(90.0) );\n    vec3 pp2=rotate_x(p, radians(180.0) );\n    \n    float b1= sdCappedCone(  pp, 3.0, 0.1, 1.0 );\n    float b2= sdCappedCone(  pp2, 5.0, 0.1, 1.0 );\n    \n    float s2 = sdSphere(abs(p) - vec3(0, 1., 0),  0.5);\n    float res;\n    res=min(s, b);\n    res=min(res, b1);\n    res=min(res, b2);\n    res=min(res, s2);\n    \n\treturn res;\n}\n\nvec2 de(vec3 p) \n{\t\n\t\n\tvec4 q = vec4(p*0.1, 1.0);\n\tvec4 sq = q;\n\t\n\tfor(int i = 0; i < 7; i++) {\n\t\tq.xyz = abs(q.xyz) - vec3(1.7, 0.1, 0.8);\n\t\tq.xz *= rot2D(0.785*2.0 + float(i)*0.785);\n\t\t\n\t\tq *= 1.4;\n\t\t\n\t\tsq = q;\n\t\tsq.xz += 1.2;\n\t\t\n\t}\n\t\n\tq.xyz = abs(q.xyz) - vec3(0, 4, 0);\n\tfloat v = shape(q.xyz, 0.0)/(q.w*0.1);\n\t\n\tsq.xyz = abs(sq.xyz) - vec3(0, 4, 0);\n\tfloat h = shape(sq.xyz, 2.0)/(sq.w*0.1);\n\t\n    vec2 res=vec2(9999.9,-1.0);\n    res=opU2(res, vec2(v, 6.0));\n    res=opU2(res, vec2(h, 8.0));\n    res=opU2(res, vec2(p.y + 0.5, 3.0));\n    \n    \n    return res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    \n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    p.y=p.y-5.0;\n    vec2 d1= de(p);\n    res =opU3(res, vec3(d1.x,d1.y,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    \n     \n    float diff = dot(normal, l);\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\n    \n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n   \n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 ,0.0,0.0);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(4.0,15.0,-25.0+20.0*sin(iTime*0.25));\n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 448, 484, 484, 505], [506, 506, 538, 538, 622], [623, 667, 714, 714, 741], [743, 743, 786, 786, 813], [815, 815, 863, 863, 891], [892, 963, 997, 997, 1095], [1096, 1096, 1130, 1130, 1222], [1223, 1223, 1257, 1257, 1349], [1350, 1390, 1424, 1424, 1521], [1522, 1522, 1546, 1546, 1616], [1617, 1617, 1638, 1638, 1707], [1710, 1710, 1735, 1735, 1754], [1755, 1755, 1780, 1780, 1799], [1800, 1800, 1836, 1836, 1864], [1867, 1867, 1926, 1926, 2239], [2241, 2241, 2272, 2272, 2739], [2741, 2741, 2759, 2759, 3306], [3309, 3349, 3374, 3374, 3748], [3753, 3753, 3839, 3839, 4430], [4436, 4487, 4511, 4511, 4699], [4700, 4763, 4796, 4796, 5257], [5259, 5313, 5349, 5349, 5583], [5640, 5640, 5720, 5720, 5997], [6093, 6093, 6186, 6186, 6295], [6300, 6349, 6406, 6406, 7629]], "test": "untested"}
{"id": "3tGcRK", "name": "Pixelating uv coordiates ", "author": "mmahir", "description": "its my first shader code \nyou can use this simple code for pixelating image. channelstep function creates gaps between values.", "tags": ["pixelateuvcorrdinate"], "likes": 0, "viewed": 332, "published": 3, "date": "1611285660", "time_retrieved": "2024-07-30T19:43:22.278608", "image_code": "//Steps between values\n\nfloat channelstep (out float r, in float pstep ){\nr = floor(pstep*r)/pstep;\nreturn r;\n}\n\n//pixelating image\nvec3 pixelateimage(out vec3 img,float pixelstep )\n{\nfloat r = img.x;\nfloat g = img.y;\nfloat b = img.z;\nimg = vec3(channelstep(r,pixelstep),channelstep(g,pixelstep),channelstep(b,pixelstep));\nreturn img;\n}\n\n//main function \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float pixelstep = 8.0f;    \n    vec3 col = vec3 (uv, 0.0f);\n    col = pixelateimage(col,pixelstep);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 73, 73, 111], [113, 132, 183, 183, 336], [338, 355, 412, 412, 618]], "test": "untested"}
{"id": "WtyyRK", "name": "Hexagonal Pixelation Effect", "author": "oneshade", "description": "I followed another of the Art of Code's tutorials, this time on hexagonal tiling: [url=https://www.youtube.com/watch?v=VmrIDyYiJBA]https://www.youtube.com/watch?v=VmrIDyYiJBA[/url]", "tags": ["webcam", "tiling", "pixelate", "hexagonal"], "likes": 37, "viewed": 1260, "published": 3, "date": "1611285168", "time_retrieved": "2024-07-30T19:43:23.306858", "image_code": "#define TILINGS 20.0\n\nfloat hexDist(in vec2 p) {\n    p = abs(p);\n    float edgeDist = dot(p, normalize(vec2(1.0, 1.73)));\n    return max(edgeDist, p.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * TILINGS;\n    float unit = 2.0 * TILINGS / iResolution.y;\n\n    vec2 rep = vec2(1.0, 1.73); // 1.73 ~ sqrt(3)\n    vec2 hrep = 0.5 * rep;\n    vec2 a = mod(uv, rep) - hrep;\n    vec2 b = mod(uv - hrep, rep) - hrep;\n    vec2 hexUv = dot(a, a) < dot(b, b) ? a : b;\n    vec2 cellId = uv - hexUv;\n\n    vec2 sampleUv = cellId / TILINGS;\n    sampleUv.x *= iResolution.y / iResolution.x;\n    float brightness = dot(texture(iChannel0, sampleUv + 0.5).rgb, vec3(1.0 / 3.0));\n    fragColor = vec4(smoothstep(unit, 0.0, hexDist(hexUv) - brightness * 0.5));\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 48, 48, 154], [156, 156, 211, 211, 821]], "test": "untested"}
{"id": "wtycDD", "name": "Water waves height function", "author": "fuzdex", "description": "A small thing I made for simulating water use a noise texture\nFor any questions or concerns regarding this shader please contact me on discord: fuzdex#1998", "tags": ["water"], "likes": 2, "viewed": 1125, "published": 3, "date": "1611281143", "time_retrieved": "2024-07-30T19:43:24.174538", "image_code": "/* \nA little bit of context on this:\nThis is the shadertoy I'm using to test a water wave height function, which will be used in a minecraft shader I'm writing to simulate water\nThe shaders are availbe here: https://github.com/saada2006/MinecraftShaders\n*/\n// Shadertoy to optifine\n#define noisetex iChannel0 // Sample noise from the first channel\n#define frameTimeCounter iTime // frameTimeCounter is iTime\n#define texture2D texture // Since GLSL version 120 only has texture2D, and minecraft shaders for the most part are written in 120\n\nvec4 Cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0f*x2 - 3.0f*x + 1.0f;\n    w.y =  3.0f*x3 - 6.0f*x2       + 4.0f;\n    w.z = -3.0f*x3 + 3.0f*x2 + 3.0f*x + 1.0f;\n    w.w =  x3;\n    return w / 6.f;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord, float resolution) {\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    vec4 xcubic = Cubic(fx);\n    vec4 ycubic = Cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture2D(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture2D(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture2D(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture2D(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord) {\n    return BicubicTexture(tex, coord, iChannelResolution[0].x);\n}\n\nconst float freq = 0.5f;\n\n// This is heavily based on SEUS V10.1\nfloat CalculateWaves2D(in vec2 coords) {\n    float AnimationTime = frameTimeCounter * 0.9f;\n    \n    coords *= freq;\n    coords += 10.0f;\n    float waves = 0.0f;\n    coords += AnimationTime / 40.0f;\n    \n    float weight;\n    float weights;\n    \n    weight = 1.0f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.9f, 1.2f) + vec2(0.0f, coords.x * 1.856f)).r * weight;\n    weights += weight;\n    coords /= 1.8f;\n    coords.x -= AnimationTime / 55.0f;\n    coords.y -= AnimationTime / 45.0f;\n    weight = 2.24f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.5f, 1.3f) + vec2(0.0f,coords.x * -1.96f)).r * weight;\n    weights += weight;\n    coords.x += AnimationTime / 20.0f;     \n    coords.y += AnimationTime / 25.0f;\n    coords /= 1.3f;\n    weight = 6.2f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.1f, 0.7f) + vec2(0.0f, coords.x * 1.265f)).r * weight;\n    weights += weight;\n    coords /= 2.2f;\n    coords -= AnimationTime / 22.50f;\n    weight = 8.34f;\n    waves += BicubicTexture(noisetex, coords * vec2(1.1f, 0.7f) + vec2(0.0f, coords.x * -1.8454f)).r * weight;\n    weights += weight;\n    \n    return waves / weights;\n}\n\nfloat CalculateOverlayedWaves2D(in vec2 coords){\n    float waves0 = CalculateWaves2D(coords);\n    float waves1 = CalculateWaves2D(-coords);\n    return sqrt(waves0 * waves1); // take geometric mean of both values\n    \n} \n\nfloat CaclulateWaves3D(in vec3 coords){\n    return CalculateWaves2D(coords.xy + coords.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 texcoord = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(CalculateOverlayedWaves2D(texcoord));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 561, 561, 787], [789, 789, 861, 861, 1740], [1742, 1742, 1796, 1796, 1862], [1890, 1929, 1969, 1969, 3075], [3077, 3077, 3125, 3125, 3295], [3298, 3298, 3337, 3337, 3390], [3392, 3392, 3449, 3449, 3597]], "test": "untested"}
{"id": "wtVyRG", "name": "Spherical Repetition (Polar)", "author": "oneshade", "description": "Spherical repetition operator. No more messing with polar coordinates any more!", "tags": ["repetition", "mod", "spherical", "polar"], "likes": 35, "viewed": 502, "published": 3, "date": "1611257725", "time_retrieved": "2024-07-30T19:43:25.035237", "image_code": "#define TAU 6.28318530718 // 2 * pi\n#define PHI 1.57079632679 // pi / 2\n\n// r: vec2(horizontal repeats, vertical repeats)\nvoid pModSpherical(inout vec3 p, in vec2 r) {\n    vec2 a = TAU / r, ha = 0.5 * a;\n    p.xz = sin(mod(atan(p.z, p.x) + ha.x, a.x) - ha.x + vec2(PHI, 0.0)) * length(p.xz);\n    p.xy = sin(mod(atan(p.y, p.x) + ha.y, a.y) - ha.y + vec2(PHI, 0.0)) * length(p.xy);\n}\n\nfloat mapScene(in vec3 p) {\n    float c = cos(iTime), s = sin(iTime);\n    p.xz *= mat2(c, -s, s, c);\n    p.yz *= mat2(c, -s, s, c);\n\n    pModSpherical(p, vec2(27.0 + 23.0 * sin(iTime), 27.0 + 23.0 * cos(iTime)));\n    vec3 q = abs(p - vec3(2.0, 0.0, 0.0)) - 0.1;\n    float boxes = max(q.x, max(q.y, q.z));\n\n    return boxes;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.1, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 122, 167, 167, 381], [383, 383, 410, 410, 708], [710, 710, 737, 737, 984], [986, 986, 1041, 1041, 1606]], "test": "untested"}
{"id": "WtKyzy", "name": "Simple planet landscape", "author": "z0rg", "description": ":)", "tags": ["planet", "landscape", "abstract"], "likes": 8, "viewed": 275, "published": 3, "date": "1611255555", "time_retrieved": "2024-07-30T19:43:25.930843", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec3 cols[5];\nvoid setup()\n{\n    cols[0] = vec3(74, 0, 57)/255.;\n    cols[1] = vec3(145, 10, 62)/255.;\n    cols[2] = vec3(207, 4, 55)/255.;\n    cols[3] = vec3(255, 116, 36)/255.;\n    cols[4] = vec3(245, 205, 27)/255.;\n}\n\nvec3 getCol(float v)\n{\n    float mx = 4.;\n    float curV = v*mx;\n    float cur = min(floor(curV), mx);\n    float next = min(cur+1., mx);\n    float f = curV - cur;\n    vec3 a = cols[int(cur)];\n    vec3 b = cols[int(next)];\n    return mix(a, b, sat(f));\n}\nfloat lenny(vec2 p)\n{\n    return abs(p.x)+abs(p.y);\n}\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _leave(vec2 p, vec2 sz, float t)\n{\n    p.x /= abs(p.y*5.);\n    return max(max(max(p.x-sin(p.y*25.+t+.2)*sz.x*2., -(p.x+sz.x-sin(p.y*25.+t)*sz.x*2.)), p.y), -p.y-sz.y);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x<b.x)\n        return a;\n    return b;\n}\n\nvec2 _bush(vec2 p, int cnt, float sz)\n{\n    float mid = sz *.5;\n    vec2 acc = vec2(1., 0.);\n    \n    for (int i = 0; i < cnt; ++i)\n    {\n        float f = (float(i)-float(cnt)*.5)/(float(cnt)*.5);\n        acc = _min(acc, vec2(_leave(p+vec2(f*sz, 0.+abs(f)*.1+.01*sin(f*15.)), vec2(.005, .2-abs(f)*.1), float(i)+iTime*.25), float(i)));\n    }\n    return acc;\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float shp = 400.;\n    \n    col = vec3(.2)*(1.-sat(abs(uv.y*2.-.5)));\n    col += pow(texture(iChannel0, uv*5.).x, iResolution.x*.01);\n    \n    col += pow(1.-sat(lenny((uv-vec2(0.,.25))*vec2(3.,8.))), 5.);\n    \n    float planetY = .45;\n    col = mix(col, mix(vec3(0.), vec3(.25), pow(abs((uv.y+planetY)*2.), .5)), 1.-sat(_cir(uv-vec2(0.,-planetY), .45)*shp));\n    \n    vec2 mainBush = _bush(uv-vec2(0., .15), 10, .05);\n    col = mix(col, vec3(sin(mainBush.y*20.+iTime*.25)*.5+.5)*.25, 1.-sat(mainBush.x*shp));\n    \n    for (int i = 0; i < 16; ++i)\n    {\n        vec2 miniBush = _bush(uv*3.-vec2(float(i)*.25-1.15, sin(float(i)))*.25+.25, 10, 0.1);\n        col = mix(col, vec3(sin(miniBush.y*20.+iTime*.25)*.5+.5)*.25, (1.-sat(miniBush.x*shp))*.25);\n    }\n    \n   col += vec3(.05)*texture(iChannel0, vec2(iTime*5.+uv*3.)).x;\n    \n    col = getCol(col.x*3.);\n    \n    col = pow(col, vec3(1.45));\n    \n    col *= .01+sat(1.-sat((abs(uv.x)-.25)*shp));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv -= vec2(0.,-.1);\n    setup();\n    vec3 col = rdr(uv);\n    \n    col = pow(col, vec3(.45));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyzy.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[444, 444, 458, 458, 649], [651, 651, 673, 673, 904], [905, 905, 926, 926, 958], [959, 959, 988, 988, 1014], [1016, 1016, 1056, 1056, 1191], [1193, 1193, 1220, 1220, 1271], [1634, 1634, 1653, 1653, 2685], [2688, 2688, 2745, 2745, 2941]], "test": "untested"}
{"id": "WtKyRy", "name": "sampling Bbox src - no perspecti", "author": "FabriceNeyret2", "description": "uniformly sampling a Bbox, dispatching the sampling budget according to faces apparent size (next: blue noise?)\nMethod assuming the apparent Bbox is small ( i.e. doesn't account for perspective to select and weight the 3 faces ).\n\nMouse controls rotation.", "tags": ["sampling", "mm"], "likes": 4, "viewed": 300, "published": 3, "date": "1611254046", "time_retrieved": "2024-07-30T19:43:26.790545", "image_code": "#define N           300.                  // target number of samples\n\n#define PI          3.14159265359\n#define rot(a)      mat2( cos( a + vec4(0,-PI/2.,PI/2.,0) ) )\n#define rot3(V,a,b) V.xz *= rot(a), V.yz *= rot(b)\n#define hash2(p)    fract(sin( (p) * vec2(12.9898, 78.233)) * 43758.5453)\n#define R           iResolution.xy\n\nstruct Bbox {                             // object bounding box:\n    vec3 position, edgeX, edgeY, edgeZ;   // position (corner), local frame ( with size)\n};\n\nvec3 CameraPos = vec3(0,0,-30),\n     CameraDir = vec3(0,0,1);\nfloat fov = 10.;                          // high value  low perspective\n\n// uniformly sample a face with n samples\nfloat sampl(vec2 U, vec3 position, vec3 edgeU, vec3 edgeV, float n) {\n    float v = 0.;\n    for (float i=0.; i < n+.5; i++ ) {\n        vec2 r = hash2(i);                // should use better hash, + seed !\n        vec3 surfacePos = position + edgeU * r.x + edgeV * r.y,\n             P = surfacePos - CameraPos;\n        v += smoothstep(3./R.y,0.,length(fov*P.xy/P.z - U) ); // demo task: perspective-draw samples\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.*u - R ) / R.y,\n         M = length(iMouse.xy) < 15. ? cos( .1*iTime + vec2(1,.372))\n                                     : 2.*iMouse.xy/R - 1.;\n    O -= O;\n    \n    float a = -PI*M.x, b = -PI*M.y;       // setup bbox from rotation angles a,b\n    Bbox bbox = Bbox( vec3(0), vec3(3,0,0), vec3(0,2,0), vec3(0,0,1) );\n    rot3(bbox.edgeX,a,b);\n    rot3(bbox.edgeY,a,b);\n    rot3(bbox.edgeZ,a,b);\n\n    vec3 dir = normalize(bbox.position - CameraPos);\n    bbox.position -= ( bbox.edgeX+bbox.edgeY+bbox.edgeZ ) /2.; // from center to corner\n\n    float s1 = dot( cross(bbox.edgeX,bbox.edgeY), dir ), // apparent surface of each side\n          s2 = dot( cross(bbox.edgeY,bbox.edgeZ), dir ),\n          s3 = dot( cross(bbox.edgeZ,bbox.edgeX), dir ),\n          sT = abs(s1) + abs(s2) + abs(s3);              // total bbox footprint on screen (parallel projection)\n    vec3  d1 = s1 > 0. ? vec3(0) : bbox.edgeZ,           // for each face pair, offset to the visible face\n          d2 = s2 > 0. ? vec3(0) : bbox.edgeX, \n          d3 = s3 > 0. ? vec3(0) : bbox.edgeY; \n          \n    O.r += sampl(U, bbox.position+d1, bbox.edgeX, bbox.edgeY, N*abs(s1)/sT ); // sample faces at prorata of visibility\n    O.g += sampl(U, bbox.position+d2, bbox.edgeY, bbox.edgeZ, N*abs(s2)/sT );\n    O.b += sampl(U, bbox.position+d3, bbox.edgeZ, bbox.edgeX, N*abs(s3)/sT );\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[626, 668, 737, 737, 1100], [1102, 1102, 1140, 1140, 2505]], "test": "untested"}
{"id": "3lVczG", "name": "Fork Planet Fal ollj 571", "author": "ollj", "description": "dorked to add mouse controls and to take a dive into fibonacciSphere-recursion\n\nhttps://www.shadertoy.com/view/XlcfRs[/url]. Make AA 1 in line 7 if it renders too slow for you", "tags": ["3d", "raymarching", "fractal", "distancefield", "sdf"], "likes": 3, "viewed": 411, "published": 3, "date": "1611249653", "time_retrieved": "2024-07-30T19:43:27.835749", "image_code": "//parent        (iq): https://www.shadertoy.com/view/lltBWB\n//grandparent (Klem): https://www.shadertoy.com/view/XlcfRs\n//\n//grandparent==Romanesco Broccoli\n\n//parent Youtube: https://www.youtube.com/watch?v=q1OBrqtl7Yo\n\n//fastCompile has more loops (less unrolling) and less branches\n#define fastCompile\n\n\n//Created by inigo quilez - iq/2018\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\n\n\n#define INTERACTIVE\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2//Change AA to 1 if it renders too slow for you\n#endif\n\n\n#define PI acos(-1.)\n#define PHI 1.61803398875\n\n\n#define iR iResolution\n#define ZERO (min(iFrame,0))\n\n#define sat(a) clamp(a,0.,1.)\n#define ss(a,b,c) smoothstep(a,b,c)\n#define ss0( b,c) ss (0.,b,c)\n#define ss01(  c) ss0(  1.,c)\n\n\nfloat pd(vec2 F,vec2 G){return dot(F,G.yx*vec2(-1,1));}\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nfloat mu(vec2 a){return a.x*a.y;}\n\nmat3 makeBase(vec3 w\n){float k=inversesqrt(1.0-w.y*w.y)\n ;return mat3(vec3(-w.z,0.0,w.x)*k\n ,vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k\n ,w);}\n\n//https://iquilezles.org/articles/intersectors\nvec2 sphIntersect(in vec3 ro,vec3 rd,float rad\n){float b=dot(ro,rd)\n ;float c=dot(ro,ro)-rad*rad\n ;float h=b*b-c\n ;if(h<0.0)return vec2(-1.0)\n ;h=sqrt(h)\n ;return vec2(-b-h,-b+h);}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCapsule(vec3 p,float b,float r\n){return length(p-vec3(0,0,b)*sat(p.z/b))-r;}//*(0.2+1.6*h);\n\n//modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF(vec3 p,float n\n){vec2 q=vec2(p)\n ;float phi=min(atan(q.y,q.x),PI)\n ;float k=max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0)\n ;float Fk=pow(PHI,k)/sqrt(5.0)\n ;vec2 F=vec2(round(Fk),round(Fk*PHI))\n ;vec2 G=PI*(fract((F+1.0)*PHI)-(PHI-1.0))\n ;vec2 c=floor(mat2(F.y,-F.x,G.y,-G.x)/pd(F,G)\n               *.5*vec2(phi,n*p.z-n+1.0))\n ;float f=0.\n ;vec4 r=vec4(0)\n ;for(int i=0;i<4;i++\n ){float d=dot(F,vec2(i&1,i>>1)+c),t=1.-(2.*d+1.)/n  \n  ;vec3 q=vec3(cs(2.*PI*fract(d*PHI))*sqrt(1.-t*t),t)\n  ;t=dot(p,q);if(t>f){f=t;r=vec4(q,d);}}\n ;return r;}\n\n//return color.xyz,TileiD\nvec4 ground(vec3 p,float lp,inout float dmin,float TileCount\n){p/=lp\n ;float hh=max(3.,floor(TileCount*700.))//ugly below 3\n ;vec4 fibo=inverseSF(p,hh)\n ;hh=1.-ss(.05,.1,length(fibo.xyz-p))\n ;dmin-=.07*hh\n ;return vec4(.5,1,1,10)*.1*hh*(1.+.5*sin(fibo.w*111.1));}\n\n//https://www.shadertoy.com/view/XlcfRs\nvec4 romanesco(vec3 p,float s,vec3 fp,inout float dmin,bool doColor,vec4 color,float tileCount\n){float iTree=3.\n ;for(float i=0.;i<iTree;i++ //recursive fibbonacciSphere\n ){float h=i/(iTree-1.)\n  ;float fsi=max(3.,floor(tileCount*65.+75.*i/(iTree-1.)))//ugly below 3\n  ;vec4 f=inverseSF(normalize(p),fsi)\n  ;p-=f.xyz\n  ;p=p*makeBase(f.xyz)\n  ;float scale=6.6+2.0*sin(111.0*f.w)\n  ;p*=scale\n  ;p.xy*=1.2\n  ;p.z-=3.-length(p.xy)*.6*sin(f.w*212.1)\n  ;s*=scale\n  #ifdef INTERACTIVE\n  ;int j=int(i)\n  ;float d=sdCapsule(p+vec3(0,0,6),6.*fp[j],mix(-40.,.42*fp[j],ss0(.1,fp[j])))\n  #else\n  ;float d=sdCapsule(p,-6.,.42)\n  #endif\n  ;d/=s\n  ;if(d<dmin\n  ){if(doColor\n   ){color.w*=ss0(5./s,dmin-d)\n    ;if(i==0.//tree stem\n    ){color.xyz=vec3(0.425,0.36,0.1)*1.1//fall\n     ;//color.xyz=vec3(0.4,0.8,0.1);//summer\n     ;//color.xyz=vec3(0.4,0.4,0.8);//winter\n     ;}\n    ;color.zyx+=.3*(1.-sqrt(h))*sin(f.w*1111.+vec3(0,1,2))\n    ;color.xyz=max(color.xyz,0.);}\n   ;dmin=d\n  ;}else color.w*=.4*(.1+.9*ss0(1./s,d-dmin))\n ;}return color;}\n\nfloat map(vec3 p,out vec4 color,bool doColor\n){float lp=length(p)\n ;float dmin=lp-1.0;\n ;float s=1.0\n ;float tileCount=iMouse.y/iResolution.y\n ;color=ground(p,lp,dmin,tileCount)\n #ifdef INTERACTIVE\n ;//float tt=mod(iTime,5.0)\n ;float tt=4.0*iMouse.x/iR.x\n ;vec3 fp=ss01(tt-vec3(0,1,2))\n #endif\n ;color=romanesco(p,s,fp,dmin,doColor,color,tileCount)\n ;return dmin;}\n\n//https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos,float ep\n){vec4 kk\n #ifdef fastCompile\n ;//prevent the compiler from inlining map() 4 times\n ;vec3 n=vec3(0)\n ;for(int i=ZERO;i<4;i++\n ){vec3 e=0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0)\n  ;n+=e*map(pos+e*ep,kk,false);}\n ;return normalize(n);}\n #else\n ;vec2 e=vec2(1.0,-1.0)*0.5773\n ;return normalize(e.xyy*map(pos+e.xyy*ep,kk,false)\n +e.yyx*map(pos+e.yyx*ep,kk,false)\n +e.yxy*map(pos+e.yxy*ep,kk,false)\n +e.xxx*map(pos+e.xxx*ep,kk,false)) ;}\n #endif \n\n//https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(vec3 ro,vec3 rd,float tmin,float tmax,float k\n){vec2 bound=sphIntersect(ro,rd,2.1)\n ;tmin=max(tmin,bound.x)\n ;tmax=min(tmax,bound.y)\n ;float res=1.\n ;float t=tmin\n ;for(int i=0;i<50;i++\n ){vec4 kk\n  ;float h=map(ro+rd*t,kk,false)\n  ;res=min(res,k*h/t)\n  ;t+=clamp(h,.02,.2)\n  ;if(res<0.005 || t>tmax) break;}\n ;return sat(res);}\n\nfloat raycast(in vec3 ro,vec3 rd,float tmin,float tmax\n){vec4 kk\n ;float t=tmin\n ;for(int i=0;i<512;i++\n ){vec3 p=ro+t*rd\n  ;float h=map(p,kk,false)\n  ;if(abs(h)<(0.15*t/iR.x))break\n  ;t+=h*0.5\n  ;if(t>tmax) return -1.0;}\n ;//if(t>tmax) t=-1.0\n ;return t;}\n\nvec3 spe(vec4 mate,vec3 nor,vec3 pos,vec3 rd,vec3 col//specular\n){vec3 lig=normalize(vec3(1,0,.7))\n    ;float dif=sat(.5+.5*dot(nor,lig))\n    ;float sha=calcSoftshadow(pos+.0001*nor,lig,0.0001,2.,6.)\n    ;col+=mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha)\n    ;vec3 hal=normalize(lig-rd)\n    ;float spe=sat(dot(nor,hal))\n    ;float fre=sat(dot(-rd,lig))\n    ;fre=0.2+0.8*pow(fre,5.)\n    ;spe*=spe\n    ;spe*=spe\n    ;spe*=spe\n    ;return col+1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;}\n\nvec3 amb(vec4 mate,vec3 nor//ambient\n){vec3 lig=normalize(vec3(-1,0,0))\n ;float dif=sat(0.5+0.5*dot(nor,lig))\n ;return mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;}\n\nvec3 dif(vec4 mate,vec3 nor,vec3 upp\n){float dif=sat(0.3+0.7*dot(nor,upp))\n #if 0\n ;dif*=0.05+0.95*calcSoftshadow(pos+0.0001*nor,upp,0.0001,1.,1.)\n ;return mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;}\n #else\n ;return mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);}\n #endif\n\nvec3 fre(vec4 mate,vec3 nor,vec3 col,vec3 rd\n){float fre=sat(1.0+dot(rd,nor))\n ;return .3*vec3(1.,.3,.2)*mate.xyz*mate.xyz*fre*fre*mate.w;}\n\nvec3 gam(vec3 col\n){return 2.*pow(col,vec3(.7,.85,1))*(.7+0.3*smoothstep(0.0,25.0,abs(iTime-31.)));}\n\nvoid mainImage(out vec4 fragColor,vec2 u\n){float an=(iTime-10.0)*0.05\n ;vec3 ro=vec3(4.5*sin(an),0.0,4.5*cos(an))\n ;mat3 ca=makeBase(normalize(-ro))//cameraMatrix from RayDirection\n ;vec3 tot=vec3(0)\n #if AA>1\n ;for(int m=ZERO;m<AA;m++)for(int n=ZERO;n<AA;n++\n ){vec2 p=vec2(float(m),float(n))/float(AA) - 0.5\n #else \n ;vec2 p=0.\n #endif\n ;p=(-iR.xy+2.*(u+p))/iR.y\n ;vec3 rd=ca*normalize(vec3(p.xy,2.2))\n ;vec3 col=vec3(0.1,0.14,0.18)+0.1*rd.y\n ;vec2 bound=sphIntersect(ro,rd,2.1)//boundingVolume\n ;if(bound.x>0.\n ){float t=raycast(ro,rd,bound.x,bound.y)\n  ;if(t>0.\n  ){vec3 ro=ro+t*rd\n   ;vec3 nor=calcNormal(ro,0.01)\n   ;vec4 mate\n   ;map(ro,mate,true)\n   ;col=vec3(0)\n   ;col+=spe(mate,nor,ro,rd,col)\n   ;col+=amb(mate,nor)\n   ;col+=dif(mate,nor,normalize(ro))\n   ;col+=fre(mate,nor,col,rd)\n   ;col=gam(col)\n   ;}}\n ;col=pow(col,vec3(0.4545));//gamma\n ;tot+=col\n #if AA>1\n ;}tot/=float(AA*AA)\n #endif\n ;vec2 q=u/iR.xy\n ;tot*=pow(16.0*mu(q)*mu(1.-q),.2)\n ;fragColor=vec4(tot,1);\n}", "image_inputs": [], "common_code": "//https://www.shadertoy.com/view/lttfW2  \n//https://www.shadertoy.com/view/3dffDS\n//https://www.shadertoy.com/view/3llGWS\n//have better animation but worse colors\n\n//https://www.shadertoy.com/view/wtKyRG\n//NOT interpolate with neighboors\n//, but does smin() with a spheremapped displacementMap.\n\n//just some other inverseSF() funtions\n\n//=================================================================================================\n// https://dokumen.tips/documents/spherical-fibonacci-mapping-fibonacci-mapping-benjamin-keinert-1matthias-innmann.html\n//=================================================================================================\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n\n\nvec2 inverseSFBasic(vec3 p, float n//https://www.shadertoy.com/view/lllXz4\n){float m = 1.0 - 1.0/n\n ;float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[879, 879, 903, 903, 934], [935, 935, 952, 952, 980], [981, 981, 998, 998, 1014], [1016, 1016, 1039, 1039, 1153], [1155, 1202, 1251, 1251, 1382], [1384, 1432, 1473, 1473, 1516], [1533, 1596, 1628, 1628, 2164], [2166, 2192, 2255, 2255, 2455], [6043, 6043, 6090, 6090, 6182], [6184, 6184, 6204, 6204, 6284]], "test": "untested"}
{"id": "WlKcRG", "name": "Desolate planet", "author": "butadiene", "description": "3hour livecoding at January 22,2021 on https://youtu.be/8EC1wdPHiTs\n", "tags": ["raymarching", "livecoding"], "likes": 10, "viewed": 432, "published": 3, "date": "1611245729", "time_retrieved": "2024-07-30T19:43:28.923840", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat rand(vec2 p){\n  return fract(sin(dot(p,vec2(12.9898,78.233)))*43578.543123);\n}\nfloat PI = acos(-1.);\nfloat noise(vec2 st){\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  \n  float a = rand(i);\n  float b = rand(i+vec2(1,0));\n  float c = rand(i+vec2(0,1));\n  float d = rand(i+vec2(1,1));\n  \n  vec2 u = f*f*(3.0-2.0*f);\n  \n  return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;\n}\n\nfloat fbm(vec2 st){\n  float v = 0.0;\n  float a = 0.5;\n  for(int i = 0;i<4;i++){\n    v += a*noise(st);\n    st *=2.0;\n    a *= 0.5;\n  }\n  return v;\n}\nfloat cube(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.0);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cyl(vec3 p,float ln,float r){\n  \n  float s = max(length(p.xy)-r,0.);\n  \n  return length(vec2(max(abs(p.z)-ln,0.0),s))-min(max(ln-abs(p.z),0.),max(r-length(p.xy),0.));\n  \n}\n\nfloat  calcZ(){\n  float klt = mod(iTime*0.5,5.);\nreturn 40.0*pow(sin(klt)*exp(-klt),1.);\n}\n\nfloat  calcsZ(){\n  float klt = mod((iTime+0.7)*0.5,5.);\nreturn 40.0*pow(sin(klt)*exp(-klt),1.);\n}\n\nvec4 dist(vec3 p){\n  float k = 0.5;\n  vec3 sp = p;\n  \nfloat d2 =999.;\n\np = sp;\nfloat kt = 0.2*iTime;\n\n\np.xy += 1.*vec2(cos(kt),sin(kt));\n\np.xy *= rot(iTime*0.6+sin(iTime));\n\nfloat ksz = calcZ();\n\np.z += ksz;\n\nvec3 srp = p;\n\np.z -= 1.2;\nfloat s6 = cyl(p,.4,0.1*(0.5-abs(p.z)));\n\np=srp;\n\n\np.x = abs(p.x)-1.;\np.xz *= rot(0.25*PI);\nfloat d4 = cube(p,vec3(0.6,0.01,0.6));\np = srp;\n\np.z = abs(p.z)-1.;\nfloat d5 = cube(p,vec3(4.0,100.,0.4));\n\nd4 = max(d4,-d5);\n\np = srp;\np.xz *= rot(0.5*PI);\np.xy *= rot(-0.6);\np.zy *= rot(-0.5);\np.xz *= rot(2.05);\n\n//d4 = min(d4,s6);\n\nfor(int i = 0;i<4;i++){\n  vec3 ssp = p;\n  p.xz *= rot(PI*0.25);\n\n  d2 = cube(p,vec3(0.4,0.01,0.2));\n  p = ssp;\n  p.y += 0.05;\n  p.xz *= rot(1.7);\n  p.xy *= rot(PI*0.25); p.yz *= rot(PI*0.25);\n  float d3 = cube(p,vec3(0.2,0.2,0.2)*0.6);\n  d2 = min(d2,d3);\n  p.x = abs(p.x)-0.07;\n  p.z = abs(p.z)-0.2;\n  p.y = abs(p.y)-0.2;\n}\n\nd2 = min(d4,d2);\n\n  p = sp;\n\n  p.z -= 5.*iTime;\n  \n  float d1 = p.y+3.+0.3*fbm(p.xz*4.)*noise(p.xz)+2.*noise(p.xz*0.5+100.);\n  \n  float d = length(p)-0.1;\n  vec3 col = vec3(s6,d2,ksz);\n  \n  return vec4(col,min(d1,d2));\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.001,0.0);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    \n    ));\n}\n\nvec3 cloud(vec3 rd,vec3 col,float s){\n  float acyz = length(rd.xz)/abs(rd.y);\n  col = mix(col,vec3(0.3),fbm(iTime+s*vec2(rd.xz*2.*acyz)));\n  col =  mix(col,vec3(0.1),fbm(iTime+s*vec2(rd.xz*4.*acyz)));\n  col = mix(vec3(0.5),col,exp(-0.2*abs(acyz)));\n  return col;\n}\n\nvec3 LightDir = normalize(vec3(0.0,-1.0,1.0));\nvec3 getSky(vec3 rd){\n  vec3 col = vec3(0.4,0.4,0.5);\n  float sun = 0.004/(1.-dot(-rd,LightDir));\n  col += clamp(sun,0.0,1.3);\n  col = cloud(rd,col,1.0);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nfloat nt = fbm(p*10.3);\n\n\nfloat krt = iTime*0.+0.5*PI;\nfloat ra = 4.0;\nfloat kss = 1.;\nvec3 st = vec3(0);\nfloat kf = max(calcsZ(),0.);\nst = vec3(0,-2.-sin(iTime*0.7),-1)+0.3*vec3(fbm(vec2(iTime*kss)),fbm(vec2(iTime*kss+100.)),fbm(vec2(kss*iTime+1000.)));\nif(mod(iTime,34.)>14.){\n  st += vec3(0,sin(iTime*0.7)+4.,-calcZ());\n  float kt= 0.2*iTime;\n  st.xy += vec2(cos(kt),sin(kt));\n  krt = iTime*0.2;\n  ra = 1.;\n}else{\n  \n}\nvec3 ro =st+ vec3(cos(krt)*ra,0.5,ra*sin(krt));\nvec3 ta = st+vec3(0,0,0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nfloat fov = 1.;\n\nvec3 rd = normalize(p.x*side+p.y*up+fov*cdir);\n\nfloat d,t= 0.0;\n\nvec4 tdr;\n\nfloat thr = 0.001;\n\n\nvec3 ac = vec3(0.);\n\nfor(int i =0;i<108;i++){\n  tdr = dist(ro+rd*t);\n  d = tdr.w;\n  float sc = max(tdr.x,0.02);\n  d = min(sc,d);\n  t += d*0.7;\n  ac += (1.0+3.0*max(tdr.z,-0.2))*exp(sc*-4.)*vec3(0.6,0.4,0.05)+0.15*exp(tdr.y*-1.)*vec3(0.3,0.4,0.6);\n  if(thr>d||t>100.)break;\n}\nvec3 col = vec3(0.);\nif(thr>d){\n  vec3 normal = getNormal(ro+rd*t);\n  \n  float lm = max(dot(-LightDir,normal),0.);\n\n\n\n  col = vec3(lm);\n  \n  col += ac*0.3;\n  \n  //col = cloud(-LightDir+0.*fbm((ro+rd*t).xz),col,100.);\n  \n  col = mix(vec3(getSky(normal+rd*0.01).y),col,exp((-0.3*fbm((ro+rd*t).xz-vec2(0,2.*iTime)))*t));\n  col = mix(col,vec3(0.49),1.-clamp(exp(-0.05*(t-5.)),0.0,1.0));\n  \n}else{\n  if(thr<d) col = getSky(rd);\n}\n vec2 uv = fragCoord/iResolution.xy;\n\n  col =mix(col,texture(iChannel0,uv).xyz,0.3+0.05*kf);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcRG.jpg", "access": "api", "license": "mit", "functions": [[116, 116, 173, 173, 266]], "test": "untested"}
{"id": "3tKyzG", "name": "horizontal city", "author": "YitingLiu", "description": "the colors and motion give me a city vibe. ", "tags": ["grid", "interactive", "time", "sin", "color", "random", "atan", "cos", "city", "lights", "pattern", "velocity", "offset"], "likes": 9, "viewed": 421, "published": 3, "date": "1611244328", "time_retrieved": "2024-07-30T19:43:29.804486", "image_code": "// Inspiration https://thebookofshaders.com/edit.php#10/ikeda-03.frag\n// I created the city vibe with time, movements, and colors \n\n\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat pattern(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return step(t, random(cos(iTime/1e6)+p*0.00000001)+random(p.x)*0.5 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    vec2 grid = vec2(100.0,50.);\n    st *= grid;\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 vel = vec2(iTime*0.5*max(grid.x,grid.y)); // time\n    vel *= vec2(-1.,0.0) * random(1.0+ipos.y); // direction\n\n    // Assign a random value base on the integer coord\n    vec2 offset = vec2(cos(iTime*1e5));\n\n    vec3 color = vec3(0.905,0.613,0.081);\n    color.r = pattern(st+offset,vel,max(random(abs(tan(iTime))),0.5)+iMouse.x/iResolution.x);\n    color.g = pattern(st,vel,0.5+iMouse.x/iResolution.x);\n    color.b = pattern(st-offset,vel,0.5+iMouse.x/iResolution.x);\n\n    // Margins\n    color *= step(0.2,fpos.y);\n    color *= step(abs(sin(iTime)),fpos.y) - step(iTime,fpos.x/fpos.y);\n    // color *= s;\n\n    fragColor = vec4(color*(0.8+step(random(ipos.y),random(vel.y))),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 161, 161, 193], [195, 195, 222, 222, 296], [298, 298, 339, 339, 441], [443, 443, 499, 499, 1403]], "test": "untested"}
{"id": "3lVcRG", "name": "colorful barcodes", "author": "YitingLiu", "description": "moving colorful barcodes. ", "tags": ["mouse", "grid", "interactive", "color", "moving", "smoothstep", "velocity", "step", "barcode", "resolution"], "likes": 0, "viewed": 257, "published": 3, "date": "1611242529", "time_retrieved": "2024-07-30T19:43:30.589387", "image_code": "// Inspiration from @patriciogv - 2015 - Title: DeFrag - https://thebookofshaders.com/edit.php#10/ikeda-04.frag\n// I created a series of colorful barcodes while manipulating the numbers and trying to understand the original code \n\nfloat random (in float x) { return fract(sin(x)*1e4); }\nfloat random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233)))* 43758.5453123);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    // Grid\n    vec2 grid = vec2(100.0,10.);\n    st *= grid;\n\n    vec2 ipos = floor(st);  // integer\n\n    vec2 vel = floor(vec2(iTime*10.)); // time\n    vel *= vec2(0.8,0.); // direction\n\n    vel *= (step(1., mod(ipos.y,2.0))-0.5)*2.; // Oposite directions\n    vel *= random(ipos.y)*random(vel.y); // random speed\n\n    // 100%\n    float totalCells = grid.x*grid.y;\n\n    float t = mod(iTime*max(grid.x,grid.y)+floor(1.0+iTime),totalCells);//find out the remainder devided by totalCells \n    vec2 head = vec2(mod(t,grid.x), floor(t/grid.x));// vector of remainder and closet integer \n\n    vec2 offset = vec2(0.5+random((sin(iTime))),max(0.5,random(abs(sin(iTime)))));// randomize the offset of the colors for each bar \n\n    vec3 color = vec3(1.0);\n    color *= step(grid.y-head.y,ipos.y);                                // Y // determine the speed based on the remainder \n    color /= (1.0-step(head.x,ipos.x))*step(grid.y-head.y,ipos.y+1.);   // X // \n    color = clamp(color,vec3(0.),vec3(1.));\n\n    // Assign a random value base on the integer coord\n    color.r *= random(floor(st+vel+offset));\n    color.g *= random(floor(st+vel));\n    color.b *= random(floor(st+vel-offset));\n\n    color = smoothstep(0.,.5+iMouse.x/iResolution.x*.5,color*color); // smooth\n    color = step(0.5+iMouse.x/iResolution.x*0.5,color); // threshold - so no gray just black and white \n\n    //  Margin\n   color *= step(.1,fract(st.x+vel.x))*step(.1,fract(st.y+vel.y));\n      \n\n    fragColor = vec4(1.0-color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 258, 258, 286], [287, 287, 315, 315, 385], [387, 387, 444, 444, 2022]], "test": "untested"}
{"id": "tlKyWw", "name": "Mandlebrot set", "author": "travisj", "description": "Mandlebrot", "tags": ["mandlebrot"], "likes": 1, "viewed": 298, "published": 3, "date": "1611220871", "time_retrieved": "2024-07-30T19:43:31.417174", "image_code": "\nconst float PI = 3.14159265359;\n\nvec3 gammaCorrect(vec3 col)\n{\n\treturn pow(col, vec3(1.0 / 2.2));\n}\n\nstruct complex\n{\n\tfloat real, imag;\n};\n\nint mandlebrot(complex c, int iterations)\n{\n\tcomplex z = c;\n\tint iters = 0;\n\tfor (int i = 0; i < iterations; i++)\n\t{\n\t\tcomplex z2;\n\t\tz2.real = z.real * z.real - z.imag * z.imag;\n\t\tz2.imag = 2.0 * z.real * z.imag;\n\t\tz2.real += c.real;\n\t\tz2.imag += c.imag;\n\t\tz = z2;\n\t\titers++;\n\t\tif (z.real * z.real + z.imag * z.imag > 4.0)\n\t\t\tbreak;\n\t}\n\n\treturn iters;\n}\n\nvec3 getColorFromMandlebrot(int mand)\n{\n\tfloat n = float(mand);\n\tfloat x = log2(n) / 0.1;\n\tvec3 col1 = vec3((1.0 + cos(2.0 * PI * x)) / 2.0);\n\n\tconst float a = 0.1;\n\n\tvec3 col2 = vec3(5.0 * sin(a * n) + 0.5, 0.5 * sin(a * n + 2.094) + 0.5, 0.5 * sin(a * n + 4.188) + 0.5);\n    \n\treturn col1 * col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    position.y *= -1.0;\n    position += iMouse.xy / iResolution.xy;\n        \n    complex c = complex(position.x, position.y);\n    \n    float time = iTime - 20.0 * floor(iTime / 20.0);\n    \n    float zoom = pow(time, time * 0.1);\n    zoom *= zoom;\n    \n    c.real /= zoom;\n    c.imag /= zoom;\n    c.real += -1.4746;\n    //c.imag += sin(time) * (1.0 / (time)) * 0.001;\n    //c.real += cos(time) * (1.0 / (time)) * 0.001;\n    \n    \n    int mand = mandlebrot(c, int(time * 10.0) + 1);\n    vec3 color = getColorFromMandlebrot(mand);\n    color = gammaCorrect(color);\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 63, 63, 100], [142, 142, 185, 185, 495], [497, 497, 536, 536, 797], [799, 799, 856, 856, 1514]], "test": "untested"}
{"id": "ttGyzG", "name": "Fbm Warp", "author": "hanker", "description": "Fbm", "tags": ["noise", "fbm", "perlin", "warp"], "likes": 5, "viewed": 441, "published": 3, "date": "1611211515", "time_retrieved": "2024-07-30T19:43:32.283857", "image_code": "\n\nfloat random(float f){\n    return fract(sin(123.567 * f) * 567.897);\n}\nvec2 random2(vec2 p){\n     p = vec2(dot(p,vec2(123.341,251.135)),dot(p,vec2(372.632,723.213)));\n    return fract(sin(p) * 31411.524313) * 2. - 1.;\n}\nfloat perlin(vec2 uv){\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 lb = random2(i);\n    vec2 rb = random2(i + vec2(1.,0.));\n    vec2 lt = random2(i + vec2(0.,1.));\n    vec2 rt = random2(i + vec2(1.,1.));\n\n    float lb_value = dot(random2(lb),f);\n    float rb_value = dot(random2(rb),f - vec2(1.,0.));\n    float lt_value = dot(random2(lt),f - vec2(0.,1.));\n    float rt_value = dot(random2(rt),f - vec2(1.,1.));\n\n    f =smoothstep(0.,1.,f);\n    float n = mix(\n            mix(lb_value,rb_value,f.x),\n            mix(lt_value,rt_value,f.x),\n        f.y);\n\n\n    return n;\n}\n#define OCTAVES 5\nfloat fbm(vec2 uv){\n    float amplitude = 1.;\n    float frequency = 1.;\n    float result = 0.;\n    for(int i = 0; i < OCTAVES; i ++){\n        result += amplitude * perlin(uv * frequency);\n        amplitude *= .5;\n        frequency *= 2.;\n    }\n    return result;\n}\nfloat toRad(float r){\n    return r * 3.1415926 / 180.;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = uv;\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 col = vec3(0.);\n\n    float rotAngle = -90.;\n    mat2 rot = mat2(\n        cos(rotAngle),-sin(rotAngle),\n        sin(rotAngle),cos(rotAngle)\n    );\n\n    vec2 p = uv * 2.;\n    float fbm_value = fbm(p + fbm(p + fbm(p) + .1 * iTime) - .1 * iTime) * .5 + .5;\n    col = vec3(fbm_value);\n\n\n   // col = mix(col,green * blue,uv.y);\n    st *= fbm_value * 2.;\n    vec4 image0 = texture(iChannel0,st);\n    st.x *= iResolution.y / iResolution.x;\n    image0 *= step(fbm_value,st.x);\n    fragColor = image0 + vec4(fbm_value) * (1. - image0.a);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 24, 24, 72], [73, 73, 94, 94, 221], [222, 222, 244, 244, 806], [825, 825, 844, 844, 1089], [1090, 1090, 1111, 1111, 1146], [1147, 1147, 1200, 1200, 1845]], "test": "untested"}
{"id": "ttGyRG", "name": "sdPie3d", "author": "yasuo", "description": "sdPie3d", "tags": ["sdpie"], "likes": 3, "viewed": 293, "published": 3, "date": "1611198260", "time_retrieved": "2024-07-30T19:43:33.151537", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 1\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n// The calculation is based on the `sdPie` distance from the following 2d distance reference.\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPie3d(vec3 p, float rad, float r, float h) {\n    p.xy = abs(p.xy);\n    vec2 c = vec2(sin(rad),cos(rad));\n    float d = max(p.y-h,length(p.xz) - r);\n    float m = length(p.xz-c*clamp(dot(p.xz,c),0.0,r)); \n    return max(d,m*sign(c.y*p.x-c.x*p.z));\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float lt = mod(iTime*20.0,420.0);\n    if(lt>=360.0){\n        lt = 360.0-((lt-360.0)/60.0*360.0);\n    }\n    \n    float rad = radians((lt<180.0)?lt:180.0);\n    float rad2 = radians((lt>=180.0)?lt-180.0:0.0);\n    \n    float t = mod(iTime*20.0,240.0);\n    t = (t<180.0)?t:180.0-((t-180.0)/60.0*180.0);\n    float rad3 = radians(t);\n    \n    // loading demo\n    p.z+=1.6;\n    float d = sdPie3d(p,rad,1.5,0.05);\n    d = max(p.x,d);\n    p*=-1.0;\n    float d2 = sdPie3d(p,rad2,1.5,0.05);\n    d2 = (rad2 != 0.0)?max(p.x,d2):100.0;\n    d = min(d,d2);\n    d2 = sdPie3d(p,radians(180.),0.75,0.06);\n    d = max(-d2+0.01,d);\n    \n    // other demo\n    p =prevP;\n    p.z-=1.6;\n    float d3 = sdPie3d(p,rad3,1.5,0.05);\n    d2 = sdPie3d(p*matRotateY(radians(180.0))*matRotateZ(radians(90.0)),rad3,1.2,0.1);\n    d3 = min(d3,d2);\n    \n    d = min(d,d3);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyz+vec3(0,1,2));\n    vec4 res = vec4(col,d);\n        \n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*0.5+0.5;\n    vec3 col = mix(vec3(.9,.8,.8),vec3(.7,.9,.5),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -5.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-60.0));\n    ro.xz *= Rot(iTime*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r),vec3(dif),0.5)+spec;\n    } else {\n        // background\n        col += Bg(rd);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[514, 659, 711, 711, 915], [917, 917, 939, 939, 1936], [1938, 1938, 1971, 1971, 2224], [2226, 2226, 2250, 2250, 2451], [2453, 2453, 2495, 2495, 2690], [2692, 2692, 2710, 2710, 2809], [2811, 2811, 2868, 2868, 3660]], "test": "untested"}
{"id": "3tGcWw", "name": "Funny Volumetric Fractal", "author": "Zi7ar21", "description": "I was just messing around and I made a neat fractal.", "tags": ["fractal", "volumetric", "pathtrace", "pathtracing", "pathtracer", "trace", "path"], "likes": 12, "viewed": 460, "published": 3, "date": "1611194851", "time_retrieved": "2024-07-30T19:43:33.913499", "image_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// Common is for settings and some functions\n// Buffer A is for rendering\n// Buffer B is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor\n// This is for drawing the shader on the left (or above if you are in portrait mode XD)\n\n// Funny Volumetric Fractal by Zi7ar21 --- January 20th, 2020\n// Happy Biden and Kamala Inauguration Day!\n// If you found this anywhere except ShaderToy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/3tGcWw\n// Updated January 20th, 2020 19:00 Mountain Time\n// Made with help from LoicVDB (https://www.shadertoy.com/user/loicvdb)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for settings and some functions.\n\n// Adjustable settings (Feel free to change these!)\n\n// Maximum Path-Tracing Steps, more results in slower possible speed but very few paths will bounce\n// enough to end up taking so long.\n#define maxsteps 1024\n\n// Path Tracing Step Size, more results in faster speed but a less accurate volume and a lower possible density.\n#define stepsize 0.01\n\n// Volume Density, more results in a denser volume but values set too high require smaller steps.\n#define volumedensity 200.0\n\n// Scene Size, if a path is this far from the scene it will stop.\n#define scenesize 2.0\n\n// Starting Path Distance, a larger value results in saving steps but you can't render volumes\n// close to the camera. Make sure this is less than the closest point to your object from the camera.\n#define startingdistance 0.5\n\n// Position of the Camera.\n#define cameraposition vec3(0.0, 0.0, -1.0)\n\n// Camera's Field of View, a larger value results in a wider Field of View.\n#define camerafov 2.0\n\n// Size of the Camera's Aperture, a laerger value results in a shallower Depth of Field.\n#define aperturesize 0.0\n\n// Camera Focal Plane, volumes this far are in focus.\n#define focaldistance 1.75\n\n// Number of times to iterate the formula.\n// I mean technically it is fbm octaves but you will keep quiet and tell nobody about it, right?\n#define iterations 4\n\n#define rot(a) mat2( cos( a + vec4(0,11,33,0)))\n#define rot3(V,a,b) V.xz *= rot(a), V.yz *= rot(b)\n\n// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for rendering.\n\n// HSV (for Colors)\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx+K.xyz)*6.0-K.www);\n    return c.z*mix(K.xxx, clamp(p-K.xxx, 0.0, 1.0), c.y);}\n\n// I don't know, I was trying to make noise-like patterns and I made a neat fractal\nfloat iterate(vec3 x){\n    x *= pi;\n    float componenta = cos(x.x)+cos(x.y)+cos(x.z);\n    float componentb = sin(x.x)+sin(x.y)+sin(x.z);\n    return mix(componenta, componentb, (componenta+3.0)/3.0);}\n\n// Perform iterations on the function\nfloat fractal(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < iterations; i++){\n\t\tv += a*iterate(x);\n\t\tx = x.zyx*2.0;\n\t\ta *= 0.5;}\n\treturn v;}\n\n// 3D Volumetric Density Function, this is the heart of the fractal\nvec4 densityfunction(vec3 pathposition){\n    float density = fractal(pathposition+fractal(pathposition))-distance(pathposition, vec3(0.0));\n    float subdensity = max(0.5, fractal(pathposition)-0.5);\n    vec3 coloration = hsv2rgb(vec3(clamp(density, 0.0, 1.0), 0.5, clamp(density-subdensity, 0.0, 1.0)));\n    return vec4(coloration, max(0.0, density-subdensity)*volumedensity);}\n\n// Light Collision Checker\nbool light(vec3 pathposition){return distance(pathposition, vec3(pathposition.x, 2.0, pathposition.z))-0.5 < 0.0;}\n\n// Path-Tracing\nvec3 pathtrace(vec3 pathdirection, vec3 inputcameraposition){\n    vec4 density;\n    float absorbance;\n    float distancetravelled = 0.0;\n    vec3 emission = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    vec3 pathposition = inputcameraposition+(pathdirection*startingdistance)+(pathdirection*stepsize*2.0*(rand()-0.5));\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathposition);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){attenuation *= clamp(density.rgb*4.0, 0.0, 1.0); emission += density.rgb*0.01*max(0.0, 1.0-absorbance); pathdirection = normalize(nrand3(1.0, vec3(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(distance(pathposition, vec3(0.0)) > scenesize || distancetravelled > 32.0){break;}\n        if(light(pathposition)){return (vec3(4.0)*attenuation)+emission;}}\n    return vec3(0.0)+emission;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0){oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}\n    fragColor = oldFragColor;\n    INIT_RNG;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n    vec2 uv = ((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/iResolution.x;\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 aperture = vec3(nrand2(aperturesize, vec2(0.0)), 0.0);\n    vec3 pathdirection = normalize(vec3(camerafov*uv, 1.0)-aperture/focaldistance);\n    vec3 pathposition = aperture;\n    vec2 M =  -3.14*(iMouse.xy*2.0/iResolution.xy);\n    rot3(pathdirection, M.x, M.y);\n    pathposition.z += cameraposition.z;\n    rot3(pathposition, M.x, M.y);\n    pathposition.z -= cameraposition.z;\n    pathdirection *= rotationmatrix;\n    pathposition *= rotationmatrix;\n    pathposition += cameraposition;\n    vec3 pathtraced = pathtrace(pathdirection, pathposition);\n    fragColor += vec4(pathtraced, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[720, 720, 774, 774, 830]], "test": "untested"}
{"id": "3tyyzy", "name": "2D fern fractal", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "fern"], "likes": 4, "viewed": 256, "published": 3, "date": "1611190588", "time_retrieved": "2024-07-30T19:43:34.664491", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (-fragCoord*5.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/8.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.5;\n        float scale2 = 2.0;\n        for(int i=0;i<3;i++)\n        {\n            uv=fract(uv/(scale2+fract((uv.x+uv.y)*2.5))-(uv.yx/(scale2+(fract(uv.x+uv.y))))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = ((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 677]], "test": "untested"}
{"id": "ttKyDm", "name": "Playing with ByteBeats", "author": "eiffie", "description": "ByteBeats", "tags": ["bytebeat"], "likes": 8, "viewed": 326, "published": 3, "date": "1611165905", "time_retrieved": "2024-07-30T19:43:35.474326", "image_code": "void mainImage(out vec4 O, in vec2 U){\n  O=vec4(1)-texture(iChannel0,U/iResolution.xy);\n}\n//bytebeats see common for function", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int cnv1(float t){return int(t*44100.+.5);}\nint fun(int t){return\n  //t*(t%6 | t>>12 | t>>8);\n  //t/16*(t%16 | t>>8 & t>>7);\n  //t*(t>>8 & t>>12);\n  t*-1*(t>>(t%65536<62000?7:5) & t>>12);\n  //t*-1*(t>>12 | t>>8 & t>>8);\n}\nvec2 cnv2(int t){return mod(vec2(t/64,t/32),vec2(256.))/256.-.5;}\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n  int t=cnv1(time);\n  vec2 o=cnv2(fun(t))+cnv2(fun(t+1));\n  return mix(o,o.yx,fract(time*4.));\n}", "sound_inputs": [], "buffer_a_code": "float DE(vec2 p){\n  float t3=iTime*5.+4.*sin(iTime*2.);\n  p+=vec2(sin(t3),sin(t3*1.1))*0.2;\n  float r=length(p)-.3+sin(t3)*0.2,a=atan(p.y,p.x)/3.14159;\n  vec2 o=cnv2(fun(cnv1(iTime)))*2.; \n  return max(abs(r)*0.7,min(abs(a-o.x),abs(a-o.y))*abs(sin(t3))*4.);\n}\nvec3 pal(float a){return abs(vec3(sin(a),sin(a*1.3),sin(a*1.5)))*.1;}\nvoid mainImage(out vec4 O, in vec2 U){\n  if(iFrame<5){O=vec4(0);return;}\n  vec2 rez=iResolution.xy;\n  float t2=iTime+4.*sin(iTime);\n  vec2 uv=(U*2.-rez)/rez,U2=U/rez;\n  O=texture(iChannel0,U2*1.01+vec2(sin(t2),cos(t2))*0.01-0.005)*0.97;\n  float a=atan(uv.y,uv.x);\n  O.rgb+=pal(iTime+a)*smoothstep(0.1,0.0,DE(uv));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 89]], "test": "untested"}
{"id": "wtKyDm", "name": "dissolve and disappear", "author": "YitingLiu", "description": "Creating glitch effect with dissolve impact. ", "tags": ["mouse", "grid", "time", "sin", "color", "random", "cos", "rgb", "pattern", "fract", "step", "clamp", "offset", "tan", "fpos", "ipos", "atn"], "likes": 8, "viewed": 522, "published": 3, "date": "1611165407", "time_retrieved": "2024-07-30T19:43:36.326049", "image_code": "// inspiration code: https://thebookofshaders.com/edit.php#10/ikeda-03.frag\n// learned changeblae resolution size, fract, atan, patterns, and randoms ; used clamp, mouse\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat pattern(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return step(t, random(100.+p*.000001)+random(p.x)*0.8 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n //   vec2 st = fragCoord.xy/iResolution.xy;\n   vec2 st = (1.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n   st.x *= iResolution.x/iResolution.y;\n\n    vec2 grid = vec2(100.0,50.);\n    st *= grid;\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 vel = vec2(iTime*2.*min(grid.x,grid.y)); // time\n    vel *= vec2(1.)*sin(iTime)/1e4 * random(0.+max(ipos.x,ipos.y)); // direction\n\n    // Assign a random value base on the integer coord\n    vec2 offset = vec2(random(st),random(st*1e3)) ;\n    offset+=iTime/1e3;\n  \n    vec3 color = vec3(0.880,0.354,0.201);\n    color.r = pattern(st+offset,vel,0.5+iMouse.x/iResolution.x);\n    color.g = pattern(st,vel,0.5+iMouse.x/iResolution.x);\n    color.b = pattern(st-offset,vel,0.5+iMouse.x/iResolution.x);\n\n    // Margins\n    color /= step(sin(iTime*1.5),max(fpos.x,fpos.y));\n\n    fragColor = vec4(1.0-color*random(st)*1e3,clamp(abs(sin(iTime)), 0.8,1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 198, 198, 230], [232, 232, 259, 259, 333], [335, 335, 376, 376, 465], [467, 467, 525, 570, 1485]], "test": "untested"}
{"id": "3lyyWm", "name": "Temporal super sampling filter", "author": "public_int_i", "description": "Left: Single Jittered Frame, Right: Temporal Super Sampling.\nClick and drag to compare.", "tags": ["aliasing", "filter", "sampling", "aa", "super", "anti", "temporal"], "likes": 3, "viewed": 318, "published": 3, "date": "1611160951", "time_retrieved": "2024-07-30T19:43:37.121921", "image_code": "/*Left: Single Jittered Frame, Right: Temporal Super Sampling\nClick and drag to compare.*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float slideX = iMouse.z>0.?iMouse.x:\n                (sin(iTime)*.5+.5)*iResolution.x;\n    if (abs(fragCoord.x-slideX) < 2.) {\n        //display slide bar\n        fragColor = vec4(1,0,1,1);\n    } else if (fragCoord.x > slideX) {\n        //display temporal super sampling\n        vec4 c = texelFetch(iChannel0,ivec2(fragCoord),0);\n        fragColor = c/c.w;\n    } else {\n        //display single frame\n        fragColor = texelFetch(iChannel1,ivec2(fragCoord),0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\n//render example scene designed to test super sampling\nvec4 scene(vec2 uv) {\n\n    //static circle\n    float s = length(uv)-.1;\n    \n    //moving circle\n    s = min(s,length(uv-vec2(sin(iTime*3.3),cos(iTime))*.7)-.1);\n    \n    //rotating cube\n    s = min(s,length(max(abs((uv-vec2(1.,.2))*r2(iTime))-.2,0.)));\n    \n    //color shapes white\n    if (s <= 0.) return vec4(1);\n    \n    \n    //very noise moire checkerboard\n    if (uv.x < 0.) {\n        vec3 rd = normalize(vec3(uv,1));\n        rd = abs(rd*2./max(1e-4,abs(rd.y)));\n        return vec4(mod(floor(rd.x)+floor(rd.z),2.));\n    }\n\n    //texture used to induce errors in movement detection\n    return texture(iChannel1,uv)*max(0.,uv.x*.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //randomly jitter uv for super sampling(integrate area of the pixel square)\n    vec2 jitter = texelFetch(iChannel2,(ivec2(fragCoord)+ivec2(iFrame,iFrame/33))%1024,0).xy-0.5,\n        uv = ((fragCoord+jitter)*2.-iResolution.xy)/iResolution.y;\n\n    fragColor = scene(uv);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*Ethan Alexander Shulman 2021 - xaloez.com\n\nWhen temporal super sampling you combine old pixel samples with new pixel samples.\nHowever when you have a moving object or a shift due to reprojection you\nrun into motion blur/smearing issues. Commonly this is solved\nby outputting motion vectors to predict where objects move along with validating\ndepth/normals from gbuffers. However motion vectors can be tricky especially for\nprocedurally animated movements like foliage wind or water.\n\nThis attempts to solve the issue using only color values, the main issue with this\nis it requires minimal noise. You can see on the noisy checkboard the flickering\nspots where noise is 'breaking through'.\n\nI kept tweaking this shader over and over never really got it to a point where I\nwas happy with it. Decided it was a waste sitting private so here we are.\n*/\n\n\n#define MIN_THRESHOLD 90.\n#define MAX_THRESHOLD 100.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        //initialize black\n        fragColor = vec4(0);\n        return;\n    }\n\n    //compute average difference of nearby samples\n    #define ts(cx,cy) texelFetch(iChannel0,ivec2(fragCoord.x,fragCoord.y)+ivec2(cx,cy),0)\n    vec4 nw = ts(-1,1), n = ts(0,1), ne = ts(1,1),\n         w = ts(-1,0), c = ts(0,0), e = ts(1,0),\n         sw = ts(-1,-1), s = ts(0,-1), se = ts(1,-1);\n    \n    /*vec4 diff = max((abs(nw-c)+abs(n-c)+abs(ne-c)+\n    abs(w-c)+abs(e-c)+\n    abs(sw-c)+abs(s-c)+abs(se-c))/8., 1e-8);*/\n    vec4 diff = max((abs(n-nw)+abs(ne-n)+abs(c-w)+abs(e-c)+abs(s-sw)+abs(se-s)+\n    abs(w-nw)+abs(c-n)+abs(e-ne)+abs(sw-s)+abs(w-sw)+abs(s-c)+abs(se-e))/12., 1e-16);\n    \n    //filter out old sample based off difference\n    vec4 old = texelFetch(iChannel1,ivec2(fragCoord),0);\n    n = clamp((abs(c-old)/diff-MIN_THRESHOLD)/(MAX_THRESHOLD-MIN_THRESHOLD),0.,1.);\n    c.w = 1.;\n    c += old*(1.-max(n.x,max(n.y,n.z)));\n    \n    fragColor = c;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 149, 149, 624]], "test": "untested"}
{"id": "wtVcDw", "name": "hair on screen 2", "author": "FabriceNeyret2", "description": "reproduce the color effect of hair on an CRT, LCD or OLED screen, due to the correlation in the masking of the color grid.\ncompare to [url] https://shadertoy.com/view/3tyyDw[/url], the effect is now subpixel:\na white pixel is indeed made of 3 color bars.", "tags": ["aliasing", "subpixel", "correlation", "chromophore"], "likes": 7, "viewed": 421, "published": 3, "date": "1611159995", "time_retrieved": "2024-07-30T19:43:37.934748", "image_code": "// variant of https://shadertoy.com/view/3tyyDw\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n\n#define p 4.\n#define D(U) ( V = pow( abs(U),vec2(p)), pow(V.x+V.y,1./(p)) )\n\n#define draw smoothstep(.5,0., abs( D(U-.5*R-5.*vec2(sin(iTime),0)) - R.y*.4 ) )\n\n    O = vec4(1);\n    vec2 V;\n    U-=.5;       O.r -= draw;\n    U.x += .333; O.g -= draw;\n    U.x += .333; O.b -= draw;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 397]], "test": "untested"}
{"id": "tlKyDw", "name": "Wisdom in Bounces", "author": "blurryroots", "description": "Sometimes up, sometimes down, enjoy when its round, marvel when its spiky. Buy the ticket, take the ride.\n\nAdaption of https://www.shadertoy.com/view/Mdy3DV for cineshader.", "tags": ["bounce", "shape", "cineshader"], "likes": 5, "viewed": 9374, "published": 3, "date": "1611158396", "time_retrieved": "2024-07-30T19:43:38.693719", "image_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n#define PI 3.14159\n#define TWO_PI 6.28319\n\nconst float Gold = (1.0+sqrt(5.0)) / 2.0;\nconst float InvGold = 1. / Gold;\nconst float OneMinusInvGold = 1.0 - InvGold;\nconst float OneMinusInvGoldSquared = OneMinusInvGold * OneMinusInvGold;\n\nfloat superformula (float angle, vec4 shape, vec2 symmetry) {    \n    float m = shape.x;\n    float n1 = shape.y;\n    float n2 = shape.z;\n    float n3 = shape.w;\n    float a = symmetry.x;\n    float b = symmetry.y;\n\n    float rpart = (m * angle) / 4.;\n    float apart = abs (cos (rpart) / a);\n    float bpart = abs (sin (rpart) / b);\n\n    float r = pow (\n        pow (apart, n2) + pow (bpart, n3),\n        -1. / n1\n    );\n    \n    return r;\n}\n\nfloat angleBetween (vec2 a, vec2 b) {\n    float cosTheta = dot (a, b) / (length (a) * length (b));\n    \n    return acos (cosTheta);\n}\n\nvec4 createShape (float t) {    \n    float m = 1. + abs (sin (t) + cos (1.6 * t)) * 8.;\n    float n1 = 1. + abs (sin (2. * t) * 4.);\n    float n2 = 1. + (cos (t + PI / 1.6) * 2.);\n    float n3 = 2. + sin (1.6 * t + PI) * 4.;\n    \n    return vec4 (m, n1, n2, n3);\n}\n\nvec2 createSymmetry (float t) {\n    return  vec2 (.618 + sin (t + PI / 2.) * .5, .5 + cos (t) * .618);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    float restraint = Gold * PI;\n    float radius = iResolution.y / restraint;\n    float border = 23.07;\n    vec4 borderColor = vec4 (0.618, 0.123, 0.987, 1.0);\n    \n    vec2 center = iResolution.xy / 2.;\n    vec2 d = fragCoord - center;\n    vec2 up = vec2 (0., 1.);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n        \n    float t = iTime * 0.6;\n    float angle = angleBetween (up, d);\n    vec2 symmetry = createSymmetry (t);\n    vec4 shape = createShape (t);\n    float r = superformula (angle, shape, symmetry) * radius;\n    \n    float size = length (d); \n    vec4 colorFromShape = 1.-normalize (shape);\n    \n    if (size <= r) {\n        vec4 noise = vec4(OneMinusInvGoldSquared);\n        float much = (r-size);\n        fragColor = vec4(colorFromShape.rgb, much) + (noise*InvGold);\n    }\n    else if (size <= (r+border)) {\n        float much = ((r+border)-size)/border;\n        fragColor = mix(borderColor, colorFromShape, much);\n    }\n    else {\n        vec4 noise = vec4(OneMinusInvGoldSquared);\n        fragColor = noise;//vec4 (vec3(OneMinusInvGoldSquared), 1.) + OneMinusInvGoldSquared*vec4((.5*sin(iTime)+.5)*noise.rgb, 1.0);\n    }\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Wisdom in Bounces\",\n\t\"description\": \"Sometimes up, sometimes down, enjoy when its round, marvel when its spiky. Buy the ticket, take the ride.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKyDw.jpg", "access": "api", "license": "proprietary-license", "functions": [[1115, 1115, 1176, 1176, 1555], [1557, 1557, 1594, 1594, 1690], [1692, 1692, 1720, 1720, 1956], [1958, 1958, 1989, 1989, 2062], [2064, 2064, 2120, 2120, 3263]], "test": "untested"}
{"id": "ttKyDw", "name": "Electronic tower", "author": "butadiene", "description": "shader livecoding(1hour)", "tags": ["raymarching", "livecoding"], "likes": 3, "viewed": 307, "published": 3, "date": "1611157803", "time_retrieved": "2024-07-30T19:43:39.446705", "image_code": "\nfloat PI = acos(-1.);\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.0);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat loncylin(vec3 p,float s){\n  return length(p.xy)-s;\n}\n\nvec2 pmod(vec2 p,float n){\n  float np = 2.0*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n}\n\nvec4 dist(vec3 p){\n  \n  p.zy *= rot(0.5*PI);\n  \n  float ke = 1.5;\n  \n  float cs = 0.1/abs(mod(p.z+iTime,ke)-0.5*ke);\n  \n  \n  vec3 sp = p;\n  \n  sp.xy *= rot(p.z*10.3+0.8*iTime);\n  \n  sp.xy = pmod(sp.xy,12.);\n  \n  sp.x -= 0.02;\n  \n  float d5 = loncylin(sp,0.0001);\n  \n  p.z += 0.1*iTime;\n  \n  p.xy = pmod(p.xy,7.);\n\n  float k = 0.6;\n  \n  vec3 ssp = p;\n  p = mod(p,k)-0.5*k;\n  float d= cube(p,vec3(0.1));\n  float d1 = cube(p,vec3(0.03,0.03,10.));\n  float d2 = cube(p,vec3(0.03,10.,0.03));\n  float d3 = cube(p,vec3(10.,0.03,0.03));\n  d = min(d,d3);\n  d = min(d,d1);\n  d = min(d,d2);\n  \n  vec3 sssp = ssp;\n  \n  ssp.xy *= rot(0.25*PI);\n  sssp.xz *= rot(0.25*PI);\n  \n  ssp = mod(ssp,k)-0.5*k;\n  \n  sssp = mod(sssp,k)-0.5*k;\n \n  float d7 = cube(ssp,vec3(10.,0.03,0.03));\n   float d8 = cube(sssp,vec3(10.,0.03,0.03));\n  d = min(d,d7);\n  d = min(d,d8);\n  vec3 col = exp(-3.0*d)*(vec3(0.2,0.2,1.0)+0.8*cs*vec3(0.1,0.6,0.2));\n  if(d>d5) col = 0.03*vec3(0.5,0.5,0.1)/max(d5,0.01);\n  d = min(d,d5);\n  \n  return vec4(col,d);\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.0001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy).w-dist(p-e.xyy).w,\n    dist(p+e.yxy).w-dist(p-e.yxy).w,\n    dist(p+e.yyx).w-dist(p-e.yyx).w\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n\nfloat d,t=0.0;\n\n\nfloat ra = 0.2;\nfloat krt = iTime*0.4;\nvec3 ro = vec3(ra*cos(krt),0.0,ra*sin(krt));\n\nvec3 ta = vec3(0.0,0.1,0.0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\n\nvec3 rd = normalize(p.x*side+p.y*up+cdir*1.0);\n\nvec4 tsd;\n\nvec3 ac = vec3(0.0);\nfor(int i = 0;i<86;i++){\n  tsd = dist(ro+rd*t);\n  d = 0.7*tsd.w;\n  t += d;\n  ac += tsd.xyz;\n  if(d<0.001)break;\n}\n\nvec3 ac2 = vec3(0.0);\nif(d<0.001){\n  vec3 ps = ro+rd*t;\n  vec3 normal = getNormal(ps);\n  rd = reflect(rd,normal);\n  t = 0.04;\n  \n  ro =ps;\n  for(int i = 0;i<46;i++){\n    tsd = dist(ro+rd*t);\n    d = tsd.w;\n    t += d;\n    ac2 += tsd.xyz;\n    if(d<0.001)break;\n  }\n\n}\n\n\nvec3 col = vec3(0.5)*ac*0.1+normalize(ac)*vec3(1.3)*ac2*0.1;\ncol *= 0.7;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 42, 42, 89], [91, 91, 117, 117, 215], [217, 217, 248, 248, 275], [277, 277, 303, 303, 426], [428, 428, 446, 446, 1439], [1441, 1441, 1464, 1464, 1637], [1640, 1640, 1697, 1697, 2565]], "test": "untested"}
{"id": "wlVyWw", "name": "Slightly eery beams ", "author": "blurryroots", "description": "Color cycling adaption of the beautiful shader https://www.shadertoy.com/view/XtVczV by Carandiru with added sound", "tags": ["raymarching", "cineshader"], "likes": 2, "viewed": 9539, "published": 3, "date": "1611156735", "time_retrieved": "2024-07-30T19:43:40.291447", "image_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n// Adaption of https://www.shadertoy.com/view/XtVczV with cycling coloration.\n\nconst bool UsePostprocessing = true;\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n\n    float time = GetScaledTime(iTime);    \n    \n    vec2 uv = fragCoord/iResolution.xy;    \n    vec3 color = vec3(psin(iTime*0.324), pcos(iTime*0.1), ptan(iTime*0.01));\n    \t\n   \tfloat FOV = 1.25;    \n    vec2 remappedUV = uv *2.-1.; // Remap the space to -1. to 1.\n    remappedUV.x *= iResolution.x/iResolution.y;\n   \tvec3 ray = normalize(vec3(remappedUV, FOV));\n    \n    vec3 origin = vec3(psin(0.3*iTime+1337.0), pcos(0.2*iTime), -3.75);\n    float t = trace(origin, ray);\n    float expFog = Pi*psin(time) / (t*t* InvGold);\n    vec3 fc = vec3(expFog);\n    \n    if ( t < -0.98f ) {\n        color = 0.25-(0.5/t+color);\n        vec3 maincolor = pcos(-(fc+color)*Gold);\n        color = 1.618*mix(pcos(color) * maincolor, color * maincolor, pcos(time));\n        color += pcos(color) * maincolor;\n    }\n    else if (t < 0.) {\n        vec3 maincolor = pcos(-(fc+color)*Gold);\n        color = 1.618*mix(pcos(color) * maincolor, color * maincolor, pcos(time));\n    }\n    else {\n        color = vec3(InvGold, Silver, DimGold);\n    }\n    \n    // increase trippiness\n    const float minVisibilty = InvGold;\n    color = max(minVisibilty, ptan(psin(Silver*time)*PiHalf))-color;\n    \n    if (UsePostprocessing) {\n        color *= GetVignetteMask(uv, 23., 0.4);\n    }\n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nconst float Pi = 355.0 / 113.0; // Thx Zu Chongzhi.\nconst float PiHalf = Pi / 2.0;\nconst float TwoPi = 2. * Pi;\nconst float Gold = (1.+sqrt(5.))/2.;\nconst float InvGold = 1./Gold;\nconst float DimGold  = InvGold*InvGold;\nconst float Silver = DimGold*DimGold;\nconst vec3 LUMA = vec3((1.-0.618)*0.6, 0.618, (1.-0.618)*0.4);\n\nfloat GetScaledTime(float rawTime) {\n    return rawTime*Pi;\n}\n\n// https://www.shadertoy.com/view/lsKSWR\nfloat GetVignetteMask(vec2 uv, float intensity, float extend) {\n    uv = uv * (1.0 - uv);\n    float mask = uv.x*uv.y * intensity;\n    return pow(mask, extend);\n}\n\nfloat getLuminance(vec3 rgb) {\n  return rgb.r * LUMA.r + rgb.g * LUMA.g + rgb.b * LUMA.b;\n}\n\n// Trig functions positive normalized.\n// Checkout https://www.desmos.com/calculator/tkqvncozq4 for a visualization of the approach.\n\nfloat psin(float x) {\n    return .5 * sin(x - PiHalf) + .5;\n}\nvec3 psin(vec3 x) {\n    return vec3(psin(x.r), psin(x.g), psin(x.b));\n}\n\nfloat pcos(float x) {\n    return .5 * sin(x) + .5;\n}\nvec3 pcos(vec3 x) {\n    return vec3(pcos(x.r), pcos(x.g), pcos(x.b));\n}\n\nfloat ptan(float x) {\n    return .87 * tan(x - Pi/2.3) + .5;\n}\nvec3 ptan(vec3 x) {\n    return vec3(ptan(x.r), ptan(x.g), ptan(x.b));\n}\n\n\n// Library from the original shader by https://www.shadertoy.com/user/Carandiru\nvoid pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    p = mod(p + halfsize, size) - halfsize;\n}\n\nvoid pMod3(inout vec3 p, vec3 size) {\n    \n    p = mod(p - size*0.5, size) - size*0.5;\n}\n\nfloat sphere(vec3 p, float radius){\n    return length(p)-radius;\n\n}\n\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    vec3 qa = p;\n    pMod3(q, vec3(0.8, 1., 0.23));\n    pMod3(qa, vec3(0.8, 1., 0.18));\n    pMod1(p.x, 1.);\n    \n    float s1 = sphere(p, 0.75); \n    float s2 = sphere(q, 0.5);              \n    float s3 = sphere(qa, 0.555);\n    \n    float df1 = min(min(s1, s2),s3); // Union\n\n    return df1;\n}\n\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = origin + r * t;\n        float d = map(p);\n        t += d*0.22;\n        }\n    return t;\n}", "sound_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\nconst int l = 2;\nfloat s[l];\nfloat w[l];\n\nvec2 mainSound( int samp, float time )\n{\n    s[0] =\n        1.0 * sin(TwoPi*133.70*time)\n      + DimGold * cos(TwoPi*42.09*time - Pi)\n      ;\n    s[1] = sin(TwoPi*12.21*time - PiHalf) + sin(TwoPi*23.32*time) + cos(TwoPi*202.02*time + Pi);\n    \n    float t = GetScaledTime(time);\n    float decay = exp(Pi/5.-psin(t));\n\n    w[0] = decay;\n    w[1] = DimGold;\n    \n    float ts = 0.;\n    for (int i = 0; i < l; ++i) {\n        ts += w[i]*s[i];\n    }\n    ts /= float(l);\n\n    return vec2(ts);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVyWw.jpg", "access": "api", "license": "proprietary-license", "functions": [[1074, 1074, 1098, 1122, 1524], [1526, 1526, 1583, 1583, 2984]], "test": "untested"}
{"id": "ttVcWw", "name": "Marching Squares Approximation", "author": "oneshade", "description": "Marching Squares in a pixel shader!\nMouse drag to edit.\nLeft arrow key to clear.", "tags": ["grid", "squares", "reconstruction", "marchingsquares", "msquares"], "likes": 26, "viewed": 1597, "published": 3, "date": "1611156110", "time_retrieved": "2024-07-30T19:43:41.254871", "image_code": "/*\nMarching Squares in a pixel shader!\n\nAt least I didn't have to mess with all 256 cases of\nthe marching cubes algorithm ;)\n\nMouse drag to edit.\nLeft arrow key to clear.\n*/\n\n#define CELL_SIZE 0.2\n#define ADAPTIVE\n\n#ifdef ADAPTIVE\n// Solving for the zero isoline of the linear interpolation is much smoother\n#define zero(p1, p2, v1, v2) mix(p1, p2, v1 / (v1 - v2))\n\n#else\n// Naive averaging looks very blocky (you might find it cool though)\n#define zero(p1, p2, v1, v2) mix(p1, p2, 0.5)\n#endif\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba)); // No clamp needed here, the cells do it\n}\n\n// Distance field\nfloat map(in vec2 p) {\n    vec2 uv = p / 4.0 * vec2(iResolution.y / iResolution.x, 1.0) + 0.5;\n    return texture(iChannel0, uv).r; // abs(p.x - p.y) - 0.15; // Example of an ambiguous case (with CELL_SIZE = 0.3)\n}\n\nfloat msquares(in vec2 p) {\n    float ms = 1000000.0;\n\n    vec2 bl_p = floor(p / CELL_SIZE) * CELL_SIZE;\n    vec2 br_p = bl_p + vec2(CELL_SIZE, 0.0);\n    vec2 tl_p = bl_p + vec2(0.0, CELL_SIZE);\n    vec2 tr_p = bl_p + CELL_SIZE;\n\n    float bl_v = map(bl_p);\n    float br_v = map(br_p);\n    float tl_v = map(tl_p);\n    float tr_v = map(tr_p);\n\n    // Distance field cuts through top left corner\n    if ((tl_v <= 0.0 && tr_v >= 0.0 && bl_v >= 0.0 && br_v >= 0.0) || (tl_v >= 0.0 && tr_v <= 0.0 && bl_v <= 0.0 && br_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(bl_p, tl_p, bl_v, tl_v), zero(tl_p, tr_p, tl_v, tr_v)));\n    }\n\n    // Distance field cuts through top right corner\n    if ((tr_v <= 0.0 && tl_v >= 0.0 && bl_v >= 0.0 && br_v >= 0.0) || (tr_v >= 0.0 && tl_v <= 0.0 && bl_v <= 0.0 && br_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(tl_p, tr_p, tl_v, tr_v), zero(tr_p, br_p, tr_v, br_v)));\n    }\n\n    // Distance field cuts through bottom right corner\n    if ((br_v <= 0.0 && bl_v >= 0.0 && tl_v >= 0.0 && tr_v >= 0.0) || (br_v >= 0.0 && bl_v <= 0.0 && tl_v <= 0.0 && tr_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(tr_p, br_p, tr_v, br_v), zero(br_p, bl_p, br_v, bl_v)));\n    }\n\n    // Distance field cuts through bottom left corner\n    if ((bl_v <= 0.0 && tl_v >= 0.0 && tr_v >= 0.0 && br_v >= 0.0) || (bl_v >= 0.0 && tl_v <= 0.0 && tr_v <= 0.0 && br_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(br_p, bl_p, br_v, bl_v), zero(bl_p, tl_p, bl_v, tl_v)));\n    }\n\n    // Distance field cuts through top left and bottom right corner\n    if ((tl_v <= 0.0 && tr_v >= 0.0 && bl_v >= 0.0 && br_v <= 0.0)) {// || (tl_v >= 0.0 && tr_v <= 0.0 && bl_v <= 0.0 && br_v >= 0.0)) {\n        ms = min(ms, sdLine(p, zero(tl_p, bl_p, tl_v, bl_v), zero(tl_p, tr_p, tl_v, tr_v)));\n        ms = min(ms, sdLine(p, zero(bl_p, br_p, bl_v, br_v), zero(br_p, tr_p, br_v, tr_v)));\n    }\n\n    // Distance field cuts through top right and bottom left corner\n    if ((tl_v >= 0.0 && tr_v <= 0.0 && bl_v <= 0.0 && br_v >= 0.0)) {// || (tl_v <= 0.0 && tr_v >= 0.0 && bl_v >= 0.0 && br_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(tl_p, tr_p, tl_v, tr_v), zero(tr_p, br_p, tr_v, br_v)));\n        ms = min(ms, sdLine(p, zero(tl_p, bl_p, tl_v, bl_v), zero(bl_p, br_p, bl_v, br_v)));\n    }\n\n    // Distance field cuts through the cell vertically\n    if ((bl_v <= 0.0 && br_v >= 0.0 && tl_v <= 0.0 && tr_v >= 0.0) || (bl_v >= 0.0 && br_v <= 0.0 && tl_v >= 0.0 && tr_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(tl_p, tr_p, tl_v, tr_v), zero(bl_p, br_p, bl_v, br_v)));\n    }\n\n    // Distance field cuts through the cell horizontally\n    if ((tl_v <= 0.0 && tr_v <= 0.0 && bl_v >= 0.0 && br_v >= 0.0) || (tl_v >= 0.0 && tr_v >= 0.0 && bl_v <= 0.0 && br_v <= 0.0)) {\n        ms = min(ms, sdLine(p, zero(tl_p, bl_p, tl_v, bl_v), zero(tr_p, br_p, tr_v, br_v)));\n    }\n\n    return ms;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float unit = 8.0 / iResolution.y;\n\n    fragColor.rgb += smoothstep(unit, 0.0, msquares(uv));\n\n    float halfCellSize = 0.5 * CELL_SIZE;\n    fragColor.r += smoothstep(unit, 0.0, abs(mod(uv.x + halfCellSize, CELL_SIZE) - halfCellSize));\n    fragColor.r += smoothstep(unit, 0.0, abs(mod(uv.y + halfCellSize, CELL_SIZE) - halfCellSize));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 0) {\n        vec2 screenCenter = 0.5 * iResolution.xy;\n        vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n        vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y;\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n        if (iMouse.z > 0.0) {\n            vec2 toMouse = uv - mouse;\n            fragColor.r = min(fragColor.r, dot(toMouse, toMouse) - 0.005);\n        }\n    }\n\n    if (iFrame == 0 || bool(texelFetch(iChannel1, ivec2(37, 0), 0).r)) { // 37 corresponds to left arrow key\n        fragColor = vec4(1000.0, 0.0, 0.0, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 495, 542, 542, 674], [676, 694, 716, 716, 908], [910, 910, 937, 937, 3781], [3783, 3783, 3838, 3838, 4292]], "test": "untested"}
{"id": "WtKcWm", "name": "3D Sinusoid", "author": "darkeclipz", "description": "Flying through f = sin x + sin y + sin z.", "tags": ["raymarch", "cube", "sin", "hsv"], "likes": 9, "viewed": 430, "published": 3, "date": "1611148077", "time_retrieved": "2024-07-30T19:43:42.112577", "image_code": "mat2 rotate(float a) {\n    float si = sin(a), co = cos(a);\n    return mat2(co, si, -si, co);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 id = vec3(0);\nfloat map(in vec3 p) {\n    float scale = 40.;\n    p *= scale;\n    vec3 pmod = mod(p, 2.0) - 1.; \n    vec3 pint = p - pmod;\n    id = pint;\n    float period = 6.;\n    float t = (iTime + 9.24) * 2.;\n    float size = (sin(period*pint.x + t) \n               +  sin(period*pint.y + t) \n               +  sin(period*pint.z)) \n               * 0.5;\n    float roundness = 0.05;\n    pmod.xz *= rotate(size);\n    float sizeBox = size * 2. * (0.5 - roundness);\n    float box = sdBox(pmod, vec3(sizeBox)*.5) - roundness;\n    return box/scale;\n\n}\n\n#define MIN_MARCH_DIST 0.0001\n#define MAX_MARCH_DIST 40.\n#define MAX_MARCH_STEPS 60.\nfloat march(in vec3 ro, in vec3 rd) {\n    float t = 0.4, // don't render too close to camera\n          i = 0.;\n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if(abs(d) < MIN_MARCH_DIST)\n            break;\n        t += d;\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 shade(vec3 N, vec3 L, vec3 V, vec3 diffuse, vec3 specular) {\n    return diffuse * clamp(dot(L, N), 0., 1.)       // Lambertian Diffuse\n         + specular * brdf_ggx(N, V, L, 0.55, 0.1); // GGX Specular\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera\n    vec3 ro = vec3(0,0,-1.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    float time = (iTime + 9.24) * 0.1;\n    rd.zx *= rotate(time);\n    ro.z += time;\n    ro.y += time;\n    \n    // March\n    float t = march(ro, rd);\n    \n    // Shade\n    vec3 col = vec3(0);\n    if(t < MAX_MARCH_DIST) {\n        vec3 P = ro + t*rd;             \n        vec3 N = normal(P);                \n        vec3 V = normalize(ro - P); \n        vec3 ambient = vec3(.06);\n        vec3 diffuse = hsv2rgb(vec3(fract(length(id) / 80. + time * 0.2), 1., 1.));\n        vec3 specular = vec3(.9);      \n        vec3 tangent = cross(V, vec3(0,1,0));\n        col =       shade(N, normalize(ro-P+tangent*0.03), V, diffuse, specular)\n            + 0.3 * shade(N, normalize(P-ro+tangent*0.2), V, diffuse, specular)  \n            + ambient;                                               \n        col *= clamp(exp(-0.20*(t-0.2)), 0., 1.);                       \n    }\n    \n    fragColor = vec4(pow(col, vec3(2.2)),1.0); // Gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 94], [96, 96, 118, 118, 287], [289, 289, 318, 318, 405], [426, 426, 448, 448, 958], [1045, 1045, 1082, 1082, 1459], [1461, 1461, 1485, 1485, 1713], [1715, 1715, 1748, 1748, 1792], [1794, 1861, 1928, 1928, 2523], [2525, 2525, 2590, 2590, 2734], [2736, 2736, 2793, 2793, 4035]], "test": "untested"}
{"id": "ttlyDf", "name": "Simple Flames", "author": "adamosen", "description": "a fire using simple perlin noise", "tags": ["fire"], "likes": 10, "viewed": 496, "published": 3, "date": "1611141298", "time_retrieved": "2024-07-30T19:43:42.981255", "image_code": "float hash(vec2 p)  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vec2 (fragCoord.x-iResolution.x*0.5,fragCoord.y*0.5);\n    \n    vec2 uvBot = uv/335.5;\n\n    uvBot.x *= 0.4;\n    float noise1 = smoothstep(0.,5.,noise(vec2(uv.x*1.20,uv.y-iTime*555.)/66.));\n    float noise2 =  smoothstep(-1.5,2.2,noise(vec2(uv.x*0.9-300.,uv.y-iTime*222.)/33.))*2.;\n    float noise3 =  smoothstep(0.,1.6,noise(vec2(uv.x*0.7+100.,uv.y-iTime*150.)/55.))*2.;    \n    float noise4 = smoothstep(-0.4,1.,noise(vec2(uv.x*0.5+50.,uv.y-iTime*240.)/55.));\n    float noise5 =  smoothstep(0.,0.8,noise(vec2(uv.x*1.6+50.,uv.y-iTime*222.)/99.));\n    float noise6 =  smoothstep(0.,1.4,noise(vec2(uv.x+200.,uv.y-iTime*333.)/300.))*4.;\n    \n    \n    \n    float fieryNoise1 = ((noise1 + noise2 + noise3+ noise4 + noise5 + noise6 )/44.);\n    \n    float fieryNoise2 = ((noise1 + noise2 + noise3+ noise4 + noise5 + noise6 )/44.);\n    \n    vec2 uvDistort1 = uvBot + (fieryNoise1)*3.72;\n    vec2 uvDistort2 = uvBot + (fieryNoise2)*6.72;\n    \n    float mask1 = smoothstep(0.2,0.72,1.- smoothstep(0.0,1.,uvDistort1.y));  \n    float mask2 = smoothstep(0.44,0.66,1.- smoothstep(0.0,1.,uvDistort2.y));  \n    \n    float mask3 = mask1-mask2;\n    float mask4 = 1.-(mask3+mask2);     \n    \n    vec3 colorBot = vec3(0.88,0.44,0.1);\n    vec3 colorMid = vec3(.66,0.14,0.14);\n    \n\t//vec3 top = (1.-clamp(mask1,0.,1.))*colorTop;   \n    \n    vec3 color1 = (mix(colorBot,colorMid, mask3)- mask4) +mask2*0.9;\n    \n\n    // Output to screen\n    fragColor = vec4(color1,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlyDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 126], [128, 128, 154, 154, 448], [452, 452, 509, 559, 2022]], "test": "untested"}
{"id": "WtGXRc", "name": "Arc - gradient 2D", "author": "iq", "description": "Signed distance and gradient to an arc segment. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "arc"], "likes": 20, "viewed": 1052, "published": 3, "date": "1611122022", "time_retrieved": "2024-07-30T19:43:43.928722", "image_code": "// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a circle art.\n// Probably faster than central differences or automatic\n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nvec3 sdgArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    vec2 q = p;\n\n    mat2 ma = mat2(sca.x,-sca.y,sca.y,sca.x);\n    p = ma*p;\n\n    float s = sign(p.x); p.x = abs(p.x);\n    \n    if( scb.y*p.x > scb.x*p.y )\n    {\n        vec2  w = p - ra*scb;\n        float d = length(w);\n        return vec3( d-rb, vec2(s*w.x,w.y)*ma/d );\n    }\n    else\n    {\n        float l = length(q);\n        float w = l - ra;\n        return vec3( abs(w)-rb, sign(w)*q/l );\n    }\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        float ta = 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n        float tb = 3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n        float rb = 0.15*(0.5+0.5*cos(iTime*0.41+1.0));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgArc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGXRc.jpg", "access": "api", "license": "mit", "functions": [[2111, 2285, 2363, 2363, 2766]], "test": "untested"}
{"id": "tlyyDw", "name": "SimpleButton", "author": "hitthemoney", "description": "A simple button with a simple cursor shader.", "tags": ["simple", "mouse", "button", "input", "cursor"], "likes": 0, "viewed": 253, "published": 3, "date": "1611114346", "time_retrieved": "2024-07-30T19:43:44.729580", "image_code": "vec2 fix(vec2 vc, vec2 aspect) {\n    vc *= aspect;\n    vc -= aspect * 0.5;\n    vc /= 0.25;\n    \n    return vc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = fix(uv, aspect);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = fix(mouse, aspect);\n\n    float smth = 0.001; // smoothness\n    float scl = 1.0; // scale\n    \n    vec3 col = vec3(0.0);\n    vec3 bgCol = vec3(0.0);\n    vec3 mainCol = vec3(1.0);\n        \n    if (!( floor(length(uv)) < floor(length(mouse)) )) {\n        mainCol = vec3(1., 0., 0.);\n        scl /= 0.95;\n    }\n    \n    float c = length(uv * scl);\n    float b = smoothstep(c - smth, c + smth, 1.0);\n    col = vec3(b);\n    \n    col = mix(bgCol, mainCol, col);\n    \n    // cursor\n    col = mix(vec3(1.0), col, floor(length((uv - mouse) / 0.05)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 112], [114, 114, 169, 169, 935]], "test": "untested"}
{"id": "WtyyDm", "name": "Shining Vertices", "author": "avinitzca", "description": "Based in The Universe Within, from Martijn Steinrucken.\n(https://www.shadertoy.com/view/lscczl)\n\nSpent a lot of time implementing mouse picking on triangles, and it looks awful :)", "tags": ["voronoi", "lines", "stars", "points"], "likes": 8, "viewed": 596, "published": 3, "date": "1611108434", "time_retrieved": "2024-07-30T19:43:45.487554", "image_code": "\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat invLerp(float from, float to, float value){\n  return (value - from) / (to - from);\n}\n\n\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\n\nvec3 saturate(vec3 value)\n{\n    return clamp(value, vec3(0.0), vec3(1.0));\n}\n\nfloat point(vec2 current, vec2 target)\n{    \n    return smoothstep(0.0, 1.4, 0.01 / distance(current, target));\n}\n\nfloat pointInLine(vec2 current, vec2 target)\n{    \n    return smoothstep(0.0, 1.6, 0.01 / distance(current, target));\n}\n\nfloat line(vec2 point, vec2 a, vec2 b)\n{\n    float lineDistance = abs(sdSegment(point, a, b));    \n    float lineLength = smoothstep(2.0, 0.2, distance(a, b));\n    return saturate(smoothstep(0.01, 0.0, lineDistance) * lineLength);\n}\n\nfloat lineNoDistanceFade(vec2 point, vec2 a, vec2 b)\n{    \n    float lineDistance = abs(sdSegment(point, a, b));    \n    return saturate(smoothstep(0.005, 0.0, lineDistance));\n}\n\nvec4 positionsForTime(float time, float scale)\n{\n    float offseted = time + 0.05;\n    \n    vec4 positions;\n    positions.xy = random2(vec2(time, time));       \n    positions.zw = random2(vec2(offseted, offseted));    \n    \n    positions *= scale;\n    \n    positions.zw *= 1.2;\n    return positions;\n}\n\nconst int indexPerDifference[] = int[8]\n(\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7\n);\n\nint indexFromDifference(vec2 difference)\n{\n    float preIndex = difference.x * 3.0 + difference.y;\n    \n    preIndex -= max(sign(preIndex), 0.0);\n    int index = int(preIndex) + 4;        \n    \n    return indexPerDifference[index];\n}\n\n\n\n\nint inLine(vec2 start, vec2 end, vec2 position, int head, out vec4 positions)\n{\n    int x = int(start.x);\n    int y = int(start.y);\n    \n    int dx = abs(x - int(end.x));\n    int dy = abs(y - int(end.y));\n    \n    int sx = start.x < end.x ? 1 : -1;\n    int sy = start.y < end.y ? 1 : -1;\n    \n    int err = (dx > dy ? dx : -dy) / 2;\n    \n    \n    int index = head+1;\n    while(index > 0)\n    {   \n        positions.xy = vec2(x, y);\n        int e2 = err;\n        \n        if (e2 > -dx)\n        {\n            err -= dy;\n            x += sx;\n        }\n        \n        if (e2 < dy)\n        {\n            err += dx;\n            y += sy;\n        }\n        index--;\n    }\n    \n    positions.zw = vec2(x, y);\n    vec2 difference = abs(positions.zw - position);\n    vec2 difference2 = abs(positions.xy - position);\n    vec2 add = difference2 + difference;\n    \n    if(difference.x == 0.0 && difference.y == 0.0)\n        return 1;\n    else if(difference2.x == 0.0 && difference2.y == 0.0)\n        return 3;\n    else if(add == vec2(1.0, 1.0))\n        return 2;\n    else\n        return 0;\n}\n\nvec3 flashLines(in vec2 cell, in vec2 cellInner, in vec2 positions[8], float scale, vec2 cellInnerCoordinates)\n{    \n    float timeScaled = iTime * 1.1;\n    float floorTime = floor(timeScaled);    \n    \n    \n    if(random2(vec2(floorTime, floorTime)).x > 0.2)\n        return vec3(0.0);\n    \n    float time = fract(timeScaled);\n    \n    vec4 headCells;\n    \n    vec4 timedPositions = positionsForTime(floorTime, scale);\n    timedPositions.yw += iTime * 0.15;\n    \n    vec4 flooredPositions = floor(timedPositions);    \n    float distanceBetweenPositions = distance(flooredPositions.xy, flooredPositions.zw);    \n    vec2 difference = abs(flooredPositions.zw - flooredPositions.xy);\n    float amount = max(difference.x, difference.y);\n    float ti = amount * time;\n    \n    int result = inLine(timedPositions.xy, timedPositions.zw, cell, int(ti), headCells);\n    \n    if(result == 0)\n        return vec3(0.0);\n    else\n    {\n        vec2 positionA;\n        vec2 positionB;\n        vec3 pointAndLine;\n        \n        if(result == 1)\n        {\n            \n            positionA = positions[indexFromDifference(headCells.xy - cell)];                        \n            positionB = cellInner;\n            pointAndLine.x = point(cellInnerCoordinates, cellInner); \n        }\n        else if (result == 2)\n        {   \n            headCells -= cell.xyxy;\n            \n            positionA = positions[indexFromDifference(headCells.xy)];\n            positionB = positions[indexFromDifference(headCells.zw)];    \n        }\n        else if(result == 3)\n        {           \n            positionB = positions[indexFromDifference(headCells.zw - cell)]; \n            positionA = cellInner;              \n            pointAndLine.x = point(cellInnerCoordinates, cellInner);                                    \n        }\n    \n        pointAndLine.y = lineNoDistanceFade(cellInnerCoordinates, positionA, positionB);    \n        vec2 mid = mix(positionA, positionB, fract(ti));\n        pointAndLine.z = pointInLine(cellInnerCoordinates, mid);    \n        return pointAndLine;\n    }         \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n    \n    float scale = 10.0;\n\n    uv *= scale;\n    uv.y += iTime * 0.15;\n    \n    vec2 cellNumber = floor(uv);\n    vec2 cellInnerCoordinates = fract(uv);\n    \n    vec2 actualCell, randomPoint;\n    vec2 addedCell;    \n    \n    float points = 0.0;\n    float lines = 0.0;\n    \n    vec2 centeredPoint = random2(cellNumber);    \n    centeredPoint = 0.5 + 0.5*sin(iTime + 6.2831*centeredPoint );\n    \n    vec2 pointPositions[8];\n    vec2 actualPositions[8];\n    \n    int index = 0;\n    \n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++)\n        {                \n            if(x == 0 && y == 0)\n                continue;\n            addedCell = vec2(float(x), float(y));            \n            actualCell = cellNumber + addedCell;\n            randomPoint = random2(actualCell);            \n            randomPoint = 0.5 + 0.5 * sin(iTime + 6.2831 * randomPoint);\n            pointPositions[index] = addedCell + randomPoint;\n            actualPositions[index] = actualCell;\n            index++;\n        }\n    \n    for(index = 0; index < 8; index++)\n    {\n        vec2 randomPoint = pointPositions[index];                    \n        lines += line(cellInnerCoordinates, centeredPoint, randomPoint);\n        points += point(randomPoint, cellInnerCoordinates);      \n    }\n    \n    points += point(centeredPoint, cellInnerCoordinates);        \n      \n    vec2 top = pointPositions[1];\n    vec2 left = pointPositions[3];\n    vec2 right = pointPositions[4];  \n    vec2 bottom = pointPositions[6];\n    \n    // Left top    \n    lines += line(cellInnerCoordinates, left, top);    \n   \n    // Left bottom    \n    lines += line(cellInnerCoordinates, left, bottom);\n    \n    // Right top      \n    lines += line(cellInnerCoordinates, right, top);\n    \n    // Right bottom    \n    lines += line(cellInnerCoordinates, right, bottom);\n    \n    \n    //vec3 color = vec3(0.015 / minimumDistance);\n    vec3 color;\n    \n    vec3 flash = flashLines(cellNumber, centeredPoint, pointPositions, scale, cellInnerCoordinates);    \n       \n    vec3 co = vec3(0.83, 0.15, 0.455);\n   \n    color.rgb += points;\n    color.rgb += vec3(0.0, 0.45, 0.9) * lines;\n    \n    \n    color.rgb = mix(vec3(0.0), vec3(0.0, 0.45, 0.9), lines);\n    \n    color.rgb = mix(color.rgb, co, flash.x + flash.y * 0.35 + flash.z * .5); \n    color.rgb = mix(color.rgb, vec3(1.0), saturate(flash.x * 1.05 - .4) +  saturate(flash.y * 0.35 * 1.5 - 0.625) + saturate(flash.z * 1.05 - 0.625) + points);\n    \n    // Draw grid\n    //color.r += step(cellInnerCoordinates.x, 0.02) + step(cellInnerCoordinates.y, 0.02);\n  \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 172], [174, 174, 198, 198, 291], [293, 293, 342, 342, 383], [387, 387, 416, 416, 453], [456, 456, 483, 483, 532], [534, 534, 574, 574, 647], [649, 649, 695, 695, 768], [770, 770, 810, 810, 1002], [1004, 1004, 1058, 1058, 1181], [1183, 1183, 1231, 1231, 1484], [1587, 1587, 1629, 1629, 1820], [1825, 1825, 1904, 1904, 2904], [2906, 2906, 3018, 3018, 4983], [4985, 4985, 5042, 5092, 7766]], "test": "untested"}
{"id": "3tyyWm", "name": "Raymarch template GGX", "author": "darkeclipz", "description": "A raymarcher template with a camera, lambertian diffuse, GGX specular, and gamma correction.\n\nThis can be used to quickly create a new raymarching shader :)", "tags": ["raymarch", "camera", "fog", "ggx", "lambertian"], "likes": 4, "viewed": 400, "published": 3, "date": "1611101760", "time_retrieved": "2024-07-30T19:43:46.246524", "image_code": "// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdSphere(in vec3 p, float r) {\n    return length(p) - r;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat map(in vec3 p) {\n    \n    // Add your SDF's here: also remove line 87.\n\n    p = mod(p, 2.0) - 1.0; // Domain repetition    \n    \n    float sphere = sdSphere(p, 0.4);\n    float ears = sdSphere(abs(p) - vec3(.25, .25, 0), 0.25);\n    return smin(sphere, ears, 0.08);\n}\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_DIST 60.\n#define MAX_MARCH_STEPS 100.\nfloat march(in vec3 ro, in vec3 rd) {\n    float t = 0., \n          i = 0.;\n    for(i=0.; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if(d < MIN_MARCH_DIST)\n            break;\n        t += d;\n        if(t > MAX_MARCH_DIST)\n            break;\n    }\n    if(i >= MAX_MARCH_STEPS) {\n        t = MAX_MARCH_DIST;\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p) {\n    float eps = MIN_MARCH_DIST;\n    vec2 h = vec2(eps, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nfloat G1V(float dotNV, float k) {\n    return 1.0 / (dotNV * (1.0 - k) + k);\n}\n\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat brdf_ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    float alpha = roughness * roughness;\n    vec3 H = normalize(V+L);\n    float dotNL = clamp(dot(N,L), 0., 1.);\n    float dotNV = clamp(dot(N,V), 0., 1.);\n    float dotNH = clamp(dot(N,H), 0., 1.);\n    float dotLH = clamp(dot(L,H), 0., 1.);\n    float alphaSqr = alpha*alpha;\n    float pi = 3.14159;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (pi * denom * denom);\n    float dotLH5 = pow(1.0 - dotLH, 5.0);\n    float F = F0 + (1.0 - F0) * dotLH5;\n    float k = alpha / 2.0;\n    float vis = G1V(dotNL, k) * G1V(dotNV, k);\n    return dotNL * D * F * vis;\n}\n\nvec3 shade(vec3 N, vec3 L, vec3 V, vec3 diffuse, vec3 specular) {\n    return diffuse * clamp(dot(L, N), 0., 1.)       // Lambertian Diffuse\n         + specular * brdf_ggx(N, V, L, 0.55, 0.1); // GGX Specular\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera\n    \n    \n    \n    \n    vec3 ro = vec3(0,0,-1.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.0*ww);\n    ro.z += iTime;\n    \n    // March\n    float t = march(ro, rd);\n    \n    // Shade\n    vec3 col = vec3(0);\n    if(t < MAX_MARCH_DIST) {\n        vec3 P = ro + t*rd;                 // Intersection point P.\n        vec3 N = normal(P);                 // Normal to the surface.\n        vec3 L = normalize(vec3(0, 0, -1)); // Vector from P to light source.\n        vec3 V = normalize(ro - P);         // View vector, from P to camera.\n        vec3 ambient = vec3(0.00);\n        vec3 diffuse = vec3(64./255., 64./255., 4.0);\n        vec3 specular = vec3(.8, .8, 1.0);\n        col = shade(N, normalize(vec3(1, 0, -1)), V, diffuse, specular)  // Light 1\n            + shade(N, normalize(vec3(-5, 2, 1)), V, diffuse, specular)  // Light 2\n            + ambient;                                                   // Ambient light\n        col *= clamp(exp(-0.20*t + 0.4), 0., 1.);                        // Fog\n    }\n    \n    fragColor = vec4(pow(col, 1.0/vec3(2.2)),1.0); // Gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 79, 79, 161], [163, 163, 199, 199, 227], [229, 229, 248, 248, 314], [316, 316, 338, 392, 587], [674, 674, 711, 711, 1047], [1049, 1049, 1073, 1073, 1301], [1303, 1303, 1336, 1336, 1380], [1382, 1449, 1516, 1516, 2111], [2113, 2113, 2178, 2178, 2322], [2324, 2324, 2381, 2381, 3697]], "test": "untested"}
{"id": "3tyyDw", "name": "hair on screen", "author": "FabriceNeyret2", "description": "reproduce the color effect of hair on an CRT, LCD or OLED screen, due to the correlation in the masking of the color grid.", "tags": ["aliasing", "correlation", "chromophore"], "likes": 5, "viewed": 488, "published": 3, "date": "1611092694", "time_retrieved": "2024-07-30T19:43:46.993527", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    int x = int(U)%3;\n    O = vec4(x==0,x==1,x==2,1);\n    \n    vec2 R = iResolution.xy;\n    O -= smoothstep(1.,0., abs( length(U-.5*R-vec2(sin(iTime),0)*R/20.) - R.y*.4 ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 214]], "test": "untested"}
{"id": "WlycWw", "name": "ripping off Nick Teeple", "author": "mds2", "description": "Riff on something I saw Nick Teeple make on instagram.  Kind of looks like a hairy dyson clinder.", "tags": ["raycast", "glass", "soundcloud"], "likes": 1, "viewed": 359, "published": 3, "date": "1611091764", "time_retrieved": "2024-07-30T19:43:47.810343", "image_code": "#define BLOCKSIZE 0.5\n\n#define EXTENT 75.0\n\n#define MULTI_SAMPLE 1 // do not set higher than 8\n\n#define DO_SUBSURFACE 1\n\nvec3 camera = vec3(55.0, 0.0, 0.0);\nmat3 dir_mat = mat3(1.0, 0.0, 0.0,\n                    0.0, 1.0, 0.0,\n                    0.0, 0.0, 1.0);\n\nconst float error_bound = 1.0e-3;\n\nconst float blocks_max_height = -1.15; // -1.75 + 0.6 + 0.25 * BLOCKSIZE\nconst float waffle_max_height = -1.75; // -2.0 + 0.1 + 0.15\n\n\n#if 1\nvec2 polar(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat2 poly = mat2(-0.05313198,  1.52184169,\n                         0.02548278, -0.47818779); // note : transposed\n  float angle = dot(vec2(1.0, rel.y), poly * vec2(1.0, rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n#elif 0\n\nvec2 polar(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat3 poly = mat3(-0.02615218,  1.52408152,  0.06801275,\n                         0.06062274, -1.67373931,  0.77403607,\n                         -0.03068766,  1.16883771, -0.74732226\n                    ); // note : transposed\n  float angle = dot(vec3(1.0, rel.y, rel.y * rel.y), poly * vec3(1.0, rel.x, rel.x * rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = - angle;\n  }\n  if (pos.x < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\n#elif 0\n\nvec2 polar(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat4 poly = mat4(-0.01554769,  1.52800768,  0.17473044, -0.12072499,\n                         0.08148376, -3.49823103,  3.93686816, -1.51359643,\n                         -0.11363601,  6.09961648, -9.57827611,  4.39990684,\n                         0.04862359, -3.20708214,  5.6870433 , -2.79976505);\n  float angle = dot(vec4(1.0, rel.y, rel.y * rel.y * vec2(1.0, rel.y)),\n                    poly * \n                    vec4(1.0, rel.x, rel.x * rel.x * vec2(1.0, rel.x)));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\n#else\n\nvec2 polar(in vec2 pos) {\n  return vec2(length(pos), mod(atan(pos.y, pos.x), 2.0 * PI));\n}\n\n\n#endif\n\nvec3 xform(in highp vec3 point) {\n  const float h = 9.;\n  // point\n  point.y += h;\n  point.yz = polar(point.yz);\n  point.z *= 3.0 / 3.141592654;\n  \n  point.y -= h;\n  point.y += 1.0;\n  point.z = mod(point.z + 0.1 * iTime - 0.05 * point.y, 6.0);\n  point.z *= 10.0;\n  // point.z -= iTime;\n  return point;\n}\n\nfloat waffle_sdf(in highp vec3 point) {\n    point = xform(point);\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)), point.y).xzy;\n    vec2 lr_dists = max(abs(local.xz) - 0.275 * BLOCKSIZE, 0.0);\n    float lr_dist = max(0.25 * BLOCKSIZE - length(lr_dists), 0.0);\n    float updist = abs(local.y + 2.0);\n    return length(vec3(lr_dist, max(updist - 0.1, 0.0), \n                       max(length(point - camera) - EXTENT, 0.0))) - 0.05;\n}\n\nfloat blocks_sdf(in highp vec3 point) {\n    point = xform(point);\n\tvec3 local = vec3(abs(abs(mod(point.xz, BLOCKSIZE)) - vec2(0.5 * BLOCKSIZE)),\n                      abs(point.y + 1.75)).xzy;\n        float samp_loc = mod(9.1 * dot(point.xz - mod(point.xz, BLOCKSIZE),\n                             vec2(0.1733, 0.1321)), 1.0);\n\n    float samp = texture(iChannel0, vec2(samp_loc, 0.0)).r;\n\tvec3 to_core = max(vec3(0.0), local - BLOCKSIZE * vec3(0.05, 0.1 + 2.0 * samp, 0.075));\n    return max(length(to_core), \n                       max(length(point - camera) - EXTENT, 0.0)) - 0.125 * (1.0 + samp) * BLOCKSIZE;\n}\n\nfloat grid_sdf(in highp vec3 point) {\n    return min(waffle_sdf(point), blocks_sdf(point));\n}\n\nvec3 waffle_grad(in highp vec3 point) {\n    float p = waffle_sdf(point);\n    return normalize(vec3(waffle_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          waffle_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nvec3 blocks_grad(in highp vec3 point) {\n    float p = blocks_sdf(point);\n    return normalize(vec3(blocks_sdf(point + vec3(0.01, 0.0, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.01, 0.0)) - p,\n                          blocks_sdf(point + vec3(0.0, 0.0, 0.01)) - p));\n}\n\n\nfloat dist_to_grid(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n\t    float to_max = (point.y - waffle_max_height) / dir.y;\n    \tresult = to_max;\n    } else if (point.y > waffle_max_height + EXTENT * error_bound) {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 128; ++i) {\n    \tfloat d = 0.9 * waffle_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_to_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    if (dir.y < -error_bound) {\n        float to_max = (point.y - blocks_max_height) / dir.y;\n        result = to_max;\n    } else {\n        return 2.0 * EXTENT;\n    }\n    p = p + result * dir;\n    for (int i = 0; i < 512; ++i) {\n    \tfloat d = 0.35 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound || result > 2.0 * EXTENT || p.y > 100.0) {\n            return result;\n        }\n    }\n    return result;\n}\n\nfloat dist_out_of_blocks(in highp vec3 point, in highp vec3 dir) {\n\tvec3 p = point;\n    float result = 0.0;\n    for (int i = 0; i < 64; ++i) {\n    \tfloat d = -0.9 * blocks_sdf(p);\n    \tresult += d;\n        p = p + d * dir;\n        if (abs(d) < error_bound) {\n            return result;\n        }\n    }\n    return result;\n}\n\nconst vec3 light1 = vec3(0.36, 0.48, -0.8);\n\nconst vec3 light2 = vec3(-0.48, 0.64, -0.6);\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec4 color_mul = vec4(1.0);\n\n    vec3 ray_orig = camera; // vec3(0.0, 0.0, -1.0); // sin(iTime));\n    float distort = 0.85 + 0.65 * dot(uv, uv);\n    vec3 ray_dir = normalize(vec3(uv * distort - vec2(0.0, 0.1), -0.2));\n    ray_dir = dir_mat *\n        mat3(1.0, 0.0, 0.0,\n        \t 0.0, 0.8, -0.6,\n             0.0, 0.6, 0.8) * ray_dir;\n    float d1 = dist_to_grid(ray_orig, ray_dir);\n    float d2 = dist_to_blocks(ray_orig, ray_dir);\n    vec3 n = ray_dir;\n    const float eta = 1.85;\n    vec3 subsurface = vec3(0.0);\n    if (d2 < d1 && d2 < 20.0) {\n        ray_orig = ray_orig + ray_dir * (d2 + 0.01);\n    \tn = blocks_grad(ray_orig);\n        vec3 next_ray_dir = refract(ray_dir, n, eta);\n        float l = length(next_ray_dir);\n\n        if (l > 0.1) {\n            ray_dir = next_ray_dir / l;\n        \td2 = dist_out_of_blocks(ray_orig, ray_dir);\n        \tcolor_mul *= mix(vec4(1.0, 0.9, 0.5, 1.0), vec4(1.0),\n                         exp(-2.0 * max(d2, 0.0)));\n        \tray_orig = ray_orig + d2 * ray_dir;\n       \t\tn = blocks_grad(ray_orig);\n        \tnext_ray_dir = refract(ray_dir, -n, 1.0/eta);\n            l = length(next_ray_dir);\n            if (l > 0.1) {\n                ray_dir = next_ray_dir / l;\n            }\n        } else {\n            ray_dir = normalize(reflect(ray_dir, n));\n        }\n        d1 = dist_to_grid(ray_orig, ray_dir);\n        const float subsurface_dist_mul = 150.0;\n#if DO_SUBSURFACE        \n        float d_light_1 = dist_out_of_blocks(ray_orig, light1);\n        float d_light_2 = dist_out_of_blocks(ray_orig, light2);\n#else\n        float d_light_1 = 1000.0 / subsurface_dist_mul;\n        float d_light_2 = d_light_1;\n#endif        \n        subsurface = vec3(1.0 / max(2.0, subsurface_dist_mul * d_light_1),\n                          0.0,\n                          1.0 / max(2.0, subsurface_dist_mul * d_light_2));\n        subsurface.g = 0.5 * (subsurface.b + subsurface.r);\n        \n    }\n    vec3 bounce = ray_dir;\n    if ( d1 < 20.0) {\n        vec3 p = ray_orig + ray_dir * d1;\n        n = waffle_grad(p);\n        bounce = normalize(reflect(ray_dir, n));\n        color_mul *= vec4(vec3(0.6, 0.6, 0.7), 1.0);\n    }\n    \n    float diffuse1 = max(dot(n, light1), 0.0) + 0.1;\n    float diffuse2 = 0.4 * max(dot(n, light2), 0.0) + 0.1;\n    float spec1 = smoothstep(0.9, 1.0, dot(bounce, light1));\n    float spec2 = smoothstep(0.8, 0.9, dot(bounce, light2));\n    float mouseness = step(iMouse.y, fragCoord.y);\n    return vec4(subsurface * mouseness, 0.0) +\n        color_mul * vec4((diffuse1 + spec1) * vec3(1.0, 0.5, 0.0) +\n                         (diffuse2 + spec2) * vec3(0.0, 0.5, 1.0), 1.0);\n}\n\n/*\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0)); */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float c_theta = cos(0.01);\n    float s_theta = sin(0.01);\n\n    camera = mat3(c_theta, 0.0, s_theta,\n                  0.0, 1.0, 0.0,\n                  -s_theta, 0.0, c_theta) * camera;\n    \n    dir_mat = mat3(-c_theta, 0.0, -s_theta,\n                   0.0, 1.0, 0.0,\n                   s_theta, 0.0, -c_theta);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + vec2(-0.4));\n    nsamps += 1.0;\n    \n    if (MULTI_SAMPLE > 1) {\n\t    result += getSample(fragCoord + vec2(0.1, 0.45));\n    \tnsamps += 1.0;\n    }\n    \n    if (MULTI_SAMPLE > 2) {\n\t    result += getSample(fragCoord + vec2(0.45, -0.1));\n    \tnsamps += 1.0;\n    }        \n    \n    /*\n    for (int i = 0; i < 8; i += max(8 / MULTI_SAMPLE, 1)) {\n        result += getSample(fragCoord + offsets[i]);\n    \tnsamps += 1.0;\n    }\n*/\n    \n    fragColor = result / nsamps;\n}\n", "image_inputs": [{"id": 25242, "src": "https://soundcloud.com/reanimasiya/brad-mehldau-teardrop", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[5914, 5914, 5950, 5950, 8667], [9016, 9016, 9073, 9073, 9956]], "test": "untested"}
{"id": "tlVcWD", "name": "video storage", "author": "FabriceNeyret2", "description": "storing 1 minute of video in cubemap. ( Loading bar on bottom ).\nMouse.x to browse frames.   SPACE to display the full storage.\n\nLet as exercise :-D :  compression to save more resolution, + use alpha storage ( = extra 33% )", "tags": ["video", "cubemapa"], "likes": 16, "viewed": 490, "published": 3, "date": "1611090155", "time_retrieved": "2024-07-30T19:43:48.640125", "image_code": "#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U,P; vec3 D; int s,t;\n    \n    if ( keyClick(32) || iMouse.xy==vec2(0) ) {               // display full storage\n        U = vec2(3,2)*u/R;\n        s = int(U.x)%3 + 3*int(U.y);\n        P = 2.* fract(U) - 1.;\n    } else {                                                  // mouse browse stored images \n        t = int( iMouse.x / R.x * float(n*n*6) );\n        s = t/(n*n);\n        P = ( u/R + vec2( t%n ,  t%(n*n) / n ) ) / float(n) *2. - 1.;\n    }\n    \n    D =   s==0 ? vec3(1,-P.y,-P.x) : s==3 ? vec3(-1,-P.y,P.x) // fetch image\n        : s==1 ? vec3(P.x,1,P.y)   : s==4 ? vec3(P.x,-1,-P.y)\n        : s==2 ? vec3(P.x,-P.y,1)  :        vec3(-P.x,-P.y,-1);\n    O = texture(iChannel0, D );\n    \n    if (u.y < 5.) O = vec4( int(u.x/R.x* float(n*n*6)) < iFrame/2, 0,0,0 ); // loading bar\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )\n{\n    vec3 A = abs(D); \n    int t = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; if (D[t]<0.) t += 3;\n    t =  t * n*n + int(U.y)/W  * n +  int(U.x)/W;\n    O = iFrame/2 == t \n            ? texture(iChannel1, fract( U/R *float(n)) )\n            : texture(iChannel0, D );\n}", "cube_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int W = 64,              // size of stored images\n          n = 1024/W;          // CubeMap stores n*n*6 images\n          \n#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 106, 106, 901]], "test": "untested"}
{"id": "3tycWw", "name": "Minimal cellular particles", "author": "illus0r", "description": "Minimal cellular particles", "tags": ["cellular"], "likes": 3, "viewed": 229, "published": 3, "date": "1611089970", "time_retrieved": "2024-07-30T19:43:49.490850", "image_code": "void mainImage( out vec4 fragColor, vec2 FC ) {\n    fragColor = texelFetch(iChannel0,ivec2(FC),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R 8. // interaction radius\n#define C 1. // max speed\n#define r iResolution.xy\n#define t iTime\n\nfloat rnd(vec2 uv) {\nreturn fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\nvec2 uv=FC.xy/r,p,v;\nvec4 n;\no*=0.;\nif(rnd(uv+t)<.01&&abs(uv.x-.5)<.01){o+=.5;return;}\nfor(float di=-C;di<=C;di++){\n  for(float dj=-C;dj<=C;dj++){\n    vec2 ij=vec2(di,dj);\n    vec2 uv_n = fract(uv+ij/r);\n    n=texture(iChannel0,uv_n);\n    if(length(n)==0.)continue;\n    p=n.rg-ij;\n    v=C*(n.ba*2.-1.);\n    if(p+v==fract(p+v)){\n      p=fract(p+v);\n      vec2 g_ij=ij;\n      for(float di=-R;di<=R;di++){\n        for(float dj=-R;dj<=+R;dj++){\n          vec2 ij=vec2(g_ij.x+di,g_ij.y+dj);\n          if(length(ij)>0.&&length(ij)<R){\n            vec2 uv_n=fract(uv+ij/r);\n            n=texture(iChannel0,uv_n);\n            if(length(n)==0.)continue; // empty\n            vec2 p_n = n.rg-ij;\n            float dist=distance(p,p_n);\n            v+=5.*normalize(p-p_n)/dist*dist;\n          }\n        }\n      }\n      if(length(v)>C)v=C*normalize(v);\n      o=vec4(p,v/C*.5+.5);\n      break;\n    }\n  }\n}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 100]], "test": "untested"}
{"id": "WtGcWw", "name": "Second polar approximation test", "author": "mds2", "description": "wow, less discontinuous than I thought\n\nAlternate visualization of discontinuities for https://www.shadertoy.com/view/WlKcWD", "tags": ["test", "polar", "approx"], "likes": 2, "viewed": 255, "published": 3, "date": "1611088891", "time_retrieved": "2024-07-30T19:43:50.325618", "image_code": "#define PI 3.141592654\n\nvec2 fast_polar_1(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat2 poly = mat2(-0.05313198,  1.52184169,\n                         0.02548278, -0.47818779); // note : transposed\n  float angle = dot(vec2(1.0, rel.y), poly * vec2(1.0, rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\nvec2 fast_polar_2(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat3 poly = mat3(-0.02615218,  1.52408152,  0.06801275,\n                         0.06062274, -1.67373931,  0.77403607,\n                         -0.03068766,  1.16883771, -0.74732226\n                    ); // note : transposed\n  float angle = dot(vec3(1.0, rel.y, rel.y * rel.y), poly * vec3(1.0, rel.x, rel.x * rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\nvec2 fast_polar_3(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat4 poly = mat4(-0.01554769,  1.52800768,  0.17473044, -0.12072499,\n                         0.08148376, -3.49823103,  3.93686816, -1.51359643,\n                         -0.11363601,  6.09961648, -9.57827611,  4.39990684,\n                         0.04862359, -3.20708214,  5.6870433 , -2.79976505);\n  float angle = dot(vec4(1.0, rel.y, rel.y * rel.y * vec2(1.0, rel.y)),\n                    poly * \n                    vec4(1.0, rel.x, rel.x * rel.x * vec2(1.0, rel.x)));\n  if (pos.x * pos.y < 0.0) {\n    angle = PI - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + PI;\n  }\n  \n  return vec2(l, angle);\n}\n\nvec2 polar(in vec2 pos) {\n  return vec2(length(pos), mod(atan(pos.y, pos.x), 2.0 * PI));\n}\n\nfloat in_spiral(in vec2 polar) {\n  float diff = mod(20.0 * polar.x - polar.y + PI, 2.0 * PI);\n  return step(diff, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 p1 = fast_polar_1(uv);\n    vec2 p2 = fast_polar_2(uv);\n    vec2 p3 = polar(uv);\n    // Time varying pixel color\n    vec3 col = vec3(in_spiral(p1),\n                    in_spiral(p2),\n                    in_spiral(p3));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 56, 56, 463], [465, 465, 497, 497, 1045], [1047, 1047, 1079, 1079, 1761], [1763, 1763, 1788, 1788, 1853], [1855, 1855, 1887, 1887, 1976], [1978, 1978, 2035, 2085, 2437]], "test": "untested"}
{"id": "4tVGzy", "name": "Communion ", "author": "blurryroots", "description": "Generating sound and shapes.", "tags": ["wurst"], "likes": 0, "viewed": 272, "published": 3, "date": "1611088405", "time_retrieved": "2024-07-30T19:43:51.137448", "image_code": "// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float relativeFrameBoderThickness = DimGold*DimGold;\n    vec3 frameBorderColor = vec3(DimGold);\n    \n    float ratio = iResolution.x/iResolution.y;\n    float radius = iResolution.y / 2.;    \n    vec2 center = iResolution.xy / 2.;\n    vec2 distCenter = fragCoord - center;\n    vec2 right = vec2 (1., 0.);\n    \n    float borderThickness = 42.1337;\n    vec3 borderColor = vec3(InvGold, DimGold, InvGold);\n    \n    float scaledTime = iTime * TimeScale;    \n    float angle = angleBetween (right, distCenter);\n    float weightA = abs(fract(scaledTime + 3.0 * scaledTime));\n    float weightB = abs(tan(scaledTime) * cos(scaledTime));\n    float zoom = 123. * abs(0.5*sin(scaledTime)+.5)+250.;\n    \n    float theta = abs(sin(angle)-fract(angle)+cos(angle))/2.;\n    weightA = mix(\n        weightA, weightB,\n        getWeightAlpha(scaledTime)\n    );\n    weightB = mix(\n        weightB, weightA,\n        getWeightAlpha(scaledTime)\n    );\n    float s = shape (theta, weightA, weightB);\n    float r = zoom * s;\n    float d = length (distCenter);\n    float rd = r - d;\n    float rdb = r - d + borderThickness;\n   \n    vec3 shapeColor = vec3(theta, weightA, weightB);\n    vec3 backgroundColor = \n        vec3(DimGold)\n      + DimGold*texture(iChannel0, uv+vec2(scaledTime, sin(scaledTime))).rrr;\n    \n    if (0. < rd) {\n        fragColor = vec4 (shapeColor, 1.0);\n    }\n    else if (0. < rdb) {\n        float broderGradient = rdb / borderThickness;\n        fragColor = vec4(mix(shapeColor, backgroundColor, 1.-broderGradient), 1.);\n    }\n    else {\n        fragColor = vec4 (backgroundColor, 1.);\n    }\n    \n    float borderInlfuence = 0.1;\n    if (uv.x < relativeFrameBoderThickness\n     || uv.y < relativeFrameBoderThickness*ratio) {\n        fragColor = vec4(frameBorderColor, borderInlfuence);\n    }\n    \n    if ((uv.x + relativeFrameBoderThickness) > 1.) {\n        fragColor = vec4(frameBorderColor, borderInlfuence);\n    }\n    if ((uv.y + relativeFrameBoderThickness*ratio) > 1.) {\n        fragColor = vec4(frameBorderColor, borderInlfuence);\n    }\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415\n\nconst float Gold = (1. + sqrt(5.))/2.;\nconst float InvGold = 1. / Gold;\nconst float OneMinusInvGold = 1. - InvGold;\nconst float DimGold = OneMinusInvGold*OneMinusInvGold;\nconst float TimeScale = InvGold;\n\nfloat getWeightAlpha(float t) {\n    return (fract(t)+cos(t))/2.;\n}\n\nfloat shape (float theta, float weightA, float weightB) {\n    float offset = PI / 3.0;\n    return cos(theta + offset * weightA) * sin (theta + offset * weightB);\n}\n\nfloat angleBetween (vec2 a, vec2 b) {\n    float cosTheta = dot (a, b) / (length (a) * length (b));\n    \n    return acos (cosTheta);\n}", "sound_code": "vec2 mainSound( int samp, float time )\n{    \n    float angle = float(samp);\n    float scaledTime = time * TimeScale;\n    \n    float weightA = abs(fract(scaledTime + 3.0 * scaledTime));\n    float weightB = abs(tan(scaledTime) * fract(scaledTime));\n    float zoom = 2. * abs(0.5*sin(scaledTime)+.5)+5.;\n    \n    float s = shape (abs(tan(angle)), weightA, weightB);\n    float r = zoom * s;\n    \n    vec2 k = mix(\n        vec2( weightB, weightA ),\n        vec2( weightA, weightB ),\n        getWeightAlpha(scaledTime)\n    );\n    \n    return 2.*abs(cos(scaledTime)) * mix(k, s * k, zoom);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVGzy.jpg", "access": "api", "license": "proprietary-license", "functions": [[958, 958, 982, 1006, 1408], [1410, 1410, 1466, 1466, 3665]], "test": "untested"}
{"id": "ttVcWD", "name": "[util] debug_1F/2V/3V", "author": "iY0Yi", "description": "This is a debugging functions demo inspired by st_assert(). 3 debugging functions are provided, one for float output, one for vec2, and one for vec3. If you call each function at any time, you can check the value by overwriting the final output.", "tags": ["debug", "util", "feature"], "likes": 4, "viewed": 311, "published": 3, "date": "1611080114", "time_retrieved": "2024-07-30T19:43:51.943293", "image_code": "const float MIN_DIST = .001;\nconst float MAX_DIST = 100.;\nconst int ITR = 100;\nconst float INV_ITR = (1./float(ITR));\n\nfloat map(vec3 p){\n    float d = p.y;\n    vec3 q = p;\n    p.xz = mod(p.xz, 3.)-1.5;\n    p.y-= 1.;\n    d = min(length(p)-1., d);\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec3 e = vec3(0, 1,-1)*MIN_DIST;\n    return normalize(vec3(map(p+e.yxx)-map(p+e.zxx),map(p+e.xyx)-map(p+e.xzx),map(p+e.xxy)-map(p+e.xxz)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<ITR; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(d<=MIN_DIST) break;\n        t += d;\n        if(t < MIN_DIST) break;\n        if(t >= MAX_DIST) return MAX_DIST;\n        //EX: Marching Cost\n        //dbg_1F( float(i)*(1./float(ITR)) );\n        //st_assert(i<90, 0);\n    }\n    return t;\n}\n\nvec3 render(in vec2 fragCoord){\n      vec2 uv = fragCoord/iResolution.xy;\n      uv = uv*2.-1.;\n      uv.y *= iResolution.y/iResolution.x;      \n      //EX: UV coord\n      //dbg_2V(uv);\n      \n      vec3 ro = vec3(0,4,-5);\n      vec3 rd = normalize(vec3(uv-vec2(0,.55), 2));\n      rd.xz *= mat2(cos(iTime+vec4(0,11,33,0)));\n      float d = march(ro, rd);\n      //EX: Hit distance\n      //dbg_1F( d*INV_ITR );\n      \n      vec3 col = vec3(0);\n      \n      if(d<MAX_DIST){\n          vec3 p = ro + rd * d;\n          //EX: Hit position\n          //dbg_3V( p/MAX_DIST );\n          \n          vec3 n = normal(p);\n          //EX: Hit normal\n          dbg_3V( n*.5+.5 );\n          \n          float l = max(0., dot(n,vec3(.5,1,-.5)));\n          col = vec3(.8)*l;\n      }\n      col = pow(col, vec3(.45));\n      return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = render(fragCoord);\n    fragColor = vec4(col,1.0);\n\n    drawDebug(fragColor); //You can turn on/off all debugging.\n}", "image_inputs": [], "common_code": "// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 137, 137, 262], [264, 264, 284, 284, 430], [432, 432, 462, 462, 814], [816, 816, 847, 847, 1629], [1631, 1631, 1687, 1687, 1818]], "test": "untested"}
{"id": "tlGcDD", "name": "Fractal Warping", "author": "oneshade", "description": "Trying out iq's warping technique.", "tags": ["fractalnoise", "domainwarp"], "likes": 23, "viewed": 413, "published": 3, "date": "1611078049", "time_retrieved": "2024-07-30T19:43:52.774072", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 0.25;\n\n    // iq's domain warping technique:\n    float warp = 0.0;\n    for (int i=0; i < 5; i++) {\n        warp = fnoise(vec3(uv, time) + warp, 2.0, 5.0);\n    }\n\n    fragColor = vec4(hue2rgb(warp), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 325, 349, 349, 463], [465, 465, 490, 490, 1414], [1416, 1416, 1475, 1475, 1761], [1763, 1763, 1818, 1818, 2115]], "test": "untested"}
{"id": "wlKyWD", "name": "windows dark theme blur", "author": "Ric3cir121", "description": "simple blur like w10", "tags": ["blur", "windows"], "likes": 1, "viewed": 450, "published": 3, "date": "1611077788", "time_retrieved": "2024-07-30T19:43:53.593880", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = vec4(0);\n    float samples = 50.;\n    for(float i = 0.;i < samples; i++){\n        float es = sin(i+1.);\n        vec2 n = fract(sin(u.x*es*(u.x+u.y)/100.)*vec2(10.,300.));\n        o += texture(iChannel0,vec2(u+(n-.5)*100.)/iResolution.y,0.);\n    }\n    o /= samples;\n    o = mix(o,vec4(fract(sin(u.x*(u.x+u.y)/10.34439)*100.)/100.+.1),.7);\n    if((u+u).x>iResolution.x)o = texture(iChannel0,vec2(u)/iResolution.y,0.);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 460]], "test": "untested"}
{"id": "wlKcWW", "name": "Naive Conway's Game of Life", "author": "Zi7ar21", "description": "My attempt at Conway's game of life. Apparently he passed away in 2020, and that made me sad. I guess this is to honor him.", "tags": ["conway", "gameoflife", "gol", "naive"], "likes": 1, "viewed": 302, "published": 3, "date": "1611072916", "time_retrieved": "2024-07-30T19:43:54.424658", "image_code": "// Everything is in Buffer A since there is no backbuffer in Shadertoy yet...\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Settings\n// Speed, if N is this define then the game will update every N frames\n#define speed 4\n// Mouse interaction pixel radius\n#define mouseradius 8.0\n\n// Find all of the cell's neighbors\nmat3 nearestpoints(ivec2 c){\n    return mat3(texelFetch(iChannel0, ivec2(c)+ivec2(-1, 1), 0).a, texelFetch(iChannel0, ivec2(c)+ivec2(0, 1), 0).a, texelFetch(iChannel0, ivec2(c)+ivec2(1, 1), 0).a,\n                texelFetch(iChannel0, ivec2(c)+ivec2(-1, 0), 0).a, texelFetch(iChannel0, ivec2(c)            , 0).a, texelFetch(iChannel0, ivec2(c)+ivec2(1, 0), 0).a,\n                texelFetch(iChannel0, ivec2(c)+ivec2(-1,-1), 0).a, texelFetch(iChannel0, ivec2(c)+ivec2(0,-1), 0).a, texelFetch(iChannel0, ivec2(c)+ivec2(1,-1), 0).a);}\n\n// Check if the cell will live\nbool gol(mat3 points){\n    vec3 a = points[0];\n    vec3 b = points[1];\n    vec3 c = points[2];\n    int sum = int((a.x+a.y+a.z)+(b.x+b.z)+(c.x+c.y+c.z));\n    return sum == 3 || (sum == 2 && b.y == 1.0);}\n\n// Noise for the noise starting position (optional)\nfloat hash12(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx)*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Slow the game\n    if(iFrame % speed != 0){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); return;}\n    \n    // Check whether or not the Cell lives or dies\n    bool particle = false;\n    particle = gol(nearestpoints(ivec2(fragCoord)));\n\n    // Mouse interaction (optional)\n    if(distance(iMouse.xy, fragCoord) < mouseradius && iMouse.z > 0.0){particle = true;}\n\n    // Example starting state, replace the stuff inside the if loop for a different start.\n    if(iFrame == 0){if(hash12(fragCoord) < 1.0/3.0){particle = true;}}\n    \n    // Output the Buffer, we are storing the state in the alpha channel in case we want color or something.\n    fragColor = vec4(vec3(particle), float(particle));}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 78, 132, 132, 196]], "test": "untested"}
{"id": "wtKcWW", "name": "psychedelic vertigo", "author": "YitingLiu", "description": "derived from the 10 print exampel made by @patriciogv ", "tags": ["circles", "sin", "color", "random", "rotate", "atan", "cos", "psychedelic", "shader", "truchet", "pattern", "tile", "maze", "scale", "tan", "10print", "vertigo"], "likes": 0, "viewed": 270, "published": 3, "date": "1611068233", "time_retrieved": "2024-07-30T19:43:55.226515", "image_code": "\n// Learned from The Book of Shader https://thebookofshaders.com/10/?lan=ch\n// Derived from 10 print from @patriciogv - 2015\n// Title: Truchet - 10 print\n\n\n#define PI 3.14159265358979323846\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        1000.*iTime);\n}\n\nvec2 truchetPattern(in vec2 _st, in float _index){\n    _index = fract(((_index-0.5)*2.0));\n    if (_index > 0.75) {\n        _st = vec2(1.0) - _st;\n    } else if (_index > 0.5) {\n        _st = vec2(1.0-_st.x,_st.y);\n    } else if (_index > 0.25) {\n        _st = 1.0-vec2(1.0-_st.x,_st.y);\n    }\n    return _st;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st *= 10.0;\n    st -=5.;\n    st = rotate2d( sin(iTime)*PI ) * st;\nst+=5.;\n    st = (st-vec2(5.0))*(abs(sin(iTime/5.))*5.);\n\n    vec2 ipos = floor(st);  // integer\n    vec2 fpos = fract(st);  // fraction\n\n    vec2 tile = truchetPattern(fpos, random( ipos ));\n\n\n    float color = 0.0;\n\n    // Maze\n    color = smoothstep(tile.x-1.,tile.x,tile.y)-\n            smoothstep(tile.x,tile.x+1.,tile.y);\n\n    // Circles\n    color *= (step(length(tile),0.6) -\n             step(length(tile),0.4) ) +\n            (step(length(tile-vec2(1.)),0.6) -\n             step(length(tile-vec2(1.)),0.4) );\n\n    // Truchet (2 triangles)\n    // color += step(tile.x,tile.y/tile.x);\n\n    fragColor = vec4(vec3(st.x*color*abs(sin(iTime)),st.y/fpos.x*sin(iTime),color*abs(sin(iTime))),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKcWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 219, 219, 325], [327, 327, 377, 377, 638], [640, 640, 668, 668, 754], [756, 756, 812, 812, 1625]], "test": "untested"}
{"id": "tlVyWW", "name": "old_tv", "author": "YitingLiu", "description": "what an old tv look like on screen with mouse interactions. ", "tags": ["2d", "noise", "mouse", "sin", "random", "interaction", "dots", "white", "black", "television"], "likes": 0, "viewed": 338, "published": 3, "date": "1611066259", "time_retrieved": "2024-07-30T19:43:55.990472", "image_code": "\n// random 2D from https://thebookofshaders.com/10/?lan=ch\n\n// Adapted from the code made by Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(iMouse)))*10.*iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    //change it into responsive screen \n    vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n\n    float rnd = random( st );\n    \n    \n  if (iMouse.xy==vec2(0)){\n      fragColor = vec4(vec3(0.),1.0);\n\n  \n  }else{\n\n    fragColor = vec4(vec3(rnd)*iMouse.x/iMouse.y,1.0);\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 179, 179, 265], [267, 267, 325, 410, 679]], "test": "untested"}
{"id": "3lKcDD", "name": "the_weird_rectange", "author": "aliser", "description": "hello", "tags": ["pulse"], "likes": 0, "viewed": 243, "published": 3, "date": "1611066012", "time_retrieved": "2024-07-30T19:43:56.830227", "image_code": "bool isWithinRange(vec2 coord, vec2 from, vec2 to) {\n    vec2 fromBased = coord - from;\n    bool isFromWithin = fromBased.x >= 0.0 && fromBased.y >= 0.0;\n    vec2 toBased = to - coord;\n    bool isToWithin = toBased.x >= 0.0 && toBased.y >= 0.0;\n    return isFromWithin && isToWithin;\n}\n\nbool isWithinRange(float value, float from, float to) {\n    return value >= from && value <= to;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tolerance = 1.0;\n    float timeModifier = 2.0;\n    float[2] distanceBetweenRange = float[2](tolerance * 8.0, tolerance * 16.0);\n    float[2] centerAmplitudeRange = float[2](10.0, 100.0);\n\n    float distanceBetweenRangeDifference = distanceBetweenRange[1] - distanceBetweenRange[0];\n    float timeCosNormalized = (cos(iTime * timeModifier * 2.0) + 1.0) / 2.0;\n    float stepSize = distanceBetweenRange[0] + timeCosNormalized * distanceBetweenRange[1];\n\n    vec2 center = vec2(0.5, 0.5) * iResolution.xy;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float screenMaxResolution = max(iResolution.x, iResolution.y);\n    float timeSinNormalized = (sin(iTime * timeModifier * 2.0) + 1.0) / 2.0;\n    \n    for(int i = 0; i < int(screenMaxResolution); i++) {\n        float iF = float(i);\n        float t = (iF / screenMaxResolution - 1.0);\n        float offset = iF * stepSize;\n        float targetDistance = centerAmplitudeRange[0] + timeSinNormalized * centerAmplitudeRange[1] + offset;\n        \n        float horizontalLowerBound[2] = float[2](\n            center.y - targetDistance - tolerance,\n            center.y - targetDistance + tolerance\n        );\n        float horizontalUpperBound[2] = float[2](\n            center.y + targetDistance - tolerance,\n            center.y + targetDistance + tolerance\n        );\n        \n        float verticalLeftBound[2] = float[2](\n            center.x - targetDistance - tolerance,\n            center.x - targetDistance + tolerance\n        );\n        float verticalRightBound[2] = float[2](\n            center.x + targetDistance - tolerance,\n            center.x + targetDistance + tolerance\n        );\n\n\n        bool isWithinUpperMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalLeftBound[1], horizontalUpperBound[0]), \n            vec2(verticalRightBound[0], horizontalUpperBound[1])\n        );\n        bool isWithinLowerMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalLeftBound[1], horizontalLowerBound[0]), \n            vec2(verticalRightBound[0], horizontalLowerBound[1])\n        );\n\n        bool isWithinLeftMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalLeftBound[0], horizontalLowerBound[1]), \n            vec2(verticalLeftBound[1], horizontalUpperBound[0])\n        );\n        bool isWithinRightMiddlePart = isWithinRange(\n            fragCoord, \n            vec2(verticalRightBound[0], horizontalLowerBound[1]), \n            vec2(verticalRightBound[1], horizontalUpperBound[0])\n        );\n\n        bool someMiddlePartDrawApplicable = isWithinUpperMiddlePart || \n                                            isWithinLowerMiddlePart ||\n                                            isWithinLeftMiddlePart ||\n                                            isWithinRightMiddlePart;\n        if(someMiddlePartDrawApplicable) {\n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = fragCoord/iResolution.xy;\n\n            // Time varying pixel color\n            col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 285], [287, 287, 342, 342, 385]], "test": "untested"}
{"id": "WlKcWD", "name": "polynomial polar approximations", "author": "mds2", "description": "attempt to use ideas from https://github.com/mds2/simple-polynomial-function-approximation to approximate cartesian->polar conversion\n\nSee also : https://www.shadertoy.com/view/WtGcWw", "tags": ["approximation", "polar", "polynomial"], "likes": 2, "viewed": 287, "published": 3, "date": "1611053830", "time_retrieved": "2024-07-30T19:43:57.664995", "image_code": "#define TEST_ATAN 0\n#define TEST_FAST_1 0\n#define TEST_FAST_2 0\n#define TEST_FAST_3 0\n\nvec2 fast_polar_1(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat2 poly = mat2(-0.05313198,  1.52184169,\n                         0.02548278, -0.47818779); // note : transposed\n  float angle = dot(vec2(1.0, rel.y), poly * vec2(1.0, rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\nvec2 fast_polar_2(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat3 poly = mat3(-0.02615218,  1.52408152,  0.06801275,\n                         0.06062274, -1.67373931,  0.77403607,\n                         -0.03068766,  1.16883771, -0.74732226\n                    ); // note : transposed\n  float angle = dot(vec3(1.0, rel.y, rel.y * rel.y), poly * vec3(1.0, rel.x, rel.x * rel.x));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\nvec2 fast_polar_3(in vec2 pos) {\n  vec2 rel = abs(pos);\n  float l = length(rel);\n  rel = rel / l;\n  const mat4 poly = mat4(-0.01554769,  1.52800768,  0.17473044, -0.12072499,\n                         0.08148376, -3.49823103,  3.93686816, -1.51359643,\n                         -0.11363601,  6.09961648, -9.57827611,  4.39990684,\n                         0.04862359, -3.20708214,  5.6870433 , -2.79976505);\n  float angle = dot(vec4(1.0, rel.y, rel.y * rel.y * vec2(1.0, rel.y)),\n                    poly * \n                    vec4(1.0, rel.x, rel.x * rel.x * vec2(1.0, rel.x)));\n  if (pos.x * pos.y < 0.0) {\n    angle = 3.141592654 - angle;\n  }\n  if (pos.y < 0.0) {\n     angle = angle + 3.141592654;\n  }\n  \n  return vec2(l, angle);\n}\n\nvec2 polar(in vec2 pos) {\n  return vec2(length(pos), mod(atan(pos.y, pos.x), 2.0 * 3.141592654));\n}\n\nfloat grid_shade(in vec2 pos) {\n  vec2 p = pos * vec2(3.0, 20.0 / 3.141592654);\n  p = fract(p + 0.5);\n  p = abs(p - 0.5);\n  p = smoothstep(vec2(0.0), vec2(0.1), p);\n  return p.x * p.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float val1 = grid_shade(polar(uv));\n    float val2 = grid_shade(fast_polar_2(uv));\n    float val3 = grid_shade(fast_polar_3(uv));\n    \n    vec3 col = vec3(val1, val2, val3);\n    \n#if TEST_ATAN || TEST_FAST_1 || TEST_FAST_2 || TEST_FAST_3\n    vec2 acc = uv;\n    vec2 acc_out = vec2(0.0);\n    for (int i = 0; i < 1000; ++i) {\n#if TEST_ATAN\n      acc_out += polar(acc);\n#endif\n#if TEST_FAST_1\n      acc_out += fast_polar_1(acc);\n#endif\n\n#if TEST_FAST_2\n      acc_out += fast_polar_2(acc);\n#endif\n\n\n#if TEST_FAST_3\n      acc_out += fast_polar_3(acc);\n#endif\n\n      acc.y += 0.001;\n    }\n\n    col.rg += normalize(acc_out);\n#endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 119, 119, 526], [528, 528, 560, 560, 1108], [1110, 1110, 1142, 1142, 1842], [1844, 1844, 1869, 1869, 1943], [1945, 1945, 1976, 1976, 2131], [2133, 2133, 2190, 2240, 2998]], "test": "untested"}
{"id": "3lKcWD", "name": "onRelease() click and dragRadius", "author": "ollj", "description": "left click creates a blue circle of [clickRadius]\n\nWhle holding down left mouse outside the blue circle, it counts as a Drag (green circle gets filled)\n\nIf you release the mouse button inside the blue circle, it counts as a onClick (orange circle fills)\n", "tags": ["mouseclick", "mousedrag", "onrelease", "diegeticui", "spiel", "steeringwheelplay", "onclick"], "likes": 2, "viewed": 505, "published": 3, "date": "1611053615", "time_retrieved": "2024-07-30T19:43:58.458872", "image_code": "//modify\n#define clickRadius .05\n\n//constant\n#define iR iResolution\n#define iM iMouse\n#define dd(a) dot(a,a)\nvec4 tf(float i){return texture(iChannel0,vec2(i+.5,.5)/ iChannelResolution[0].xy,-100.0);}\n\n//onRelease of MainImage must be different\nbool onRelease(){return (tf(0.).w>0.);}\n\nvec2 fra(vec2 u\n){u=u/iR.xy\n ;u=u*2.-1.\n ;u.x*=iR.x/iR.y\n ;return u;}\n\n\n\nvoid mainImage(out vec4 c,vec2 u\n){bool released=false\n ;c=vec4(0);\n ;c=tf(2.)\n ;u=fra(u)\n ;vec2 m=fra(iM.xy)     //mouseNow\n ;vec2 n=fra(abs(iM.zw))//mouse where clicking started\n\n ;c.y=length(u-m)-.2//green mouse circle (to indicate onHoldDrag     event)\n ;c.z=length(u-n)-clickRadius//blue circle shows clickRadius\n ;if (length(m-n)<clickRadius\n ){//indicate noDragCase by making green circle a hollow ring\n  ;c.y=abs(c.y)-.01\n ;if(onRelease())released=true ;}\n ;c.x=length(u)-.3//default empty red circle  \n ;if(!released)c.x=abs(c.x)-.01//make redcircle hollow ring (indicate onReleaseClick event)\n\n ;//c.x=abs(c.x)-.01//ring thickness\n ;float s=.01//sharpness\n ;c.xyz=smoothstep(s,-s,c.xyz)\n ;c.y+=c.x*.7//red to orange (colorblind mode)\n ;}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 tf(float i){return texture(iChannel0,vec2(i+.5,.5)/ iChannelResolution[0].xy,-100.0);}\n\n\n//to get an onRelease event, we must buffer iMouse.z of the previous frame\n//but we cannot put THIS onRelease() function into the imageTab\n//to get onRelease() state to the imageTab, we must spend another Buffer bool\nbool onRelease(\n){if(tf(0.).z>0.&&iMouse.z<0.)return true   //oh man, it is still being done in order, so it fails in Image\n ;return false;}\n\nvoid mainImage( out vec4 c, in vec2 u//store state in (tf(0.).w\n){if(floor(u)==vec2(0)\n ){if(onRelease())c=vec4(0,0,iMouse.z,1);else c=vec4(0,0,iMouse.z,0);}\n ;}//else {if(onRelease())c=vec4(0,0,0,1);else c=vec4(0);}}\n\n/*\nvoid mainImage( out vec4 c, in vec2 u //store state in all .w except (tf(0.).w\n){if(floor(u)==vec2(0)\n ){c.z=iMouse.z\n  ;//if(onRelease())c=vec4(0,0,iMouse.z,1);else c=vec4(0,0,iMouse.z,0);}\n ;}else {if(onRelease())c=vec4(0,0,0,1);else c=vec4(0);}}\n */", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\nleft click creates a blue circle of [clickRadius]\n\nWhle holding down left mouse outside the blue circle\n,it counts as a Drag (green circle gets filled)\n\nIf you release the mouse button inside the blue circle\n,it counts as a onClick (orange circle fills)\n\n\nsadly this needs 1 bits of bufferA, to be readable in MainImage.\nis there a simpler way?\n\n<-\n<-\n<-\n\nto combine mouse controls of\nhttps://www.shadertoy.com/view/wl3yDs   (drag rotation momentum)\nhttps://www.shadertoy.com/view/ttycDW   (click navigation)\nhttps://www.shadertoy.com/view/Wl3cz8   (drag editor (non-Diegetic ui is bad here))\n\nI want to be able to drag the mouse\n,to look around or drag objects around (depending on states)\n\nI want to be able to click inWorld objects (or click to to an autopilot-target)\n,to change states and trigger onClick events\n\nthe trick to do both is to change the onClick() event to an onRelease() Event\nand to have a steering-wheel-game threshold of mouseMovement \nto differentiate [click]ing from [drag]ing.\n\nicdeally, your 3d-click-range is rather short (while your3d-drag-range is very long)\n,so that, if you do not hit any object within a short zFar of a click-hitscan\n, you instead MOVE towards that place in space in autopilot as in https://www.shadertoy.com/view/ttycDW\n\nideally, you click any obkject\n, and it creates an (exclusive) in-world object, that acts as its context-menu.\n. that contextMenu can also be dragable or rotateable handles.\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 126, 126, 200], [202, 245, 262, 262, 284], [286, 286, 304, 304, 355], [359, 359, 394, 394, 1106]], "test": "untested"}
{"id": "wtyyWD", "name": "Hard exterior ", "author": "Plento", "description": "Experiment with triplanar mapping and raymarching.", "tags": ["3d", "triplanar"], "likes": 18, "viewed": 454, "published": 3, "date": "1611020004", "time_retrieved": "2024-07-30T19:43:59.223827", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define tex(chan, p) texture(chan, p)\n\n// Get color from triplanar map. Not sure if this is 100% correct?\nvec3 trimap(vec3 p, vec3 n){\n    vec3 yz = tex(iChannel0, p.yz).xyz;\n    vec3 xz = tex(iChannel0, p.xz).xyz;\n    vec3 xy = tex(iChannel0, p.xy).xyz;\n   \n    n /= (n.x + n.y + n.z);\n    return yz*n.x + xz*n.y + xy*n.z;\n}\n\n\nvoid trn(inout vec3 p){\n    p.xz *= rot(.5);\n}\n\n// value for morphing/ color\nfloat val(vec3 p){return .5 + .5*cos(length(p)*15. - (iTime*.75 + 2. ));  }\n\n\nfloat map(vec3 p){\n    float d = 999.;\n    vec3 n = normalize(p);\n    \n    trn(p);\n    trn(n);\n    \n    float h = trimap((p+iTime*.2)*.26, abs(n)).x;\n    float r = 1. + h *.7;\n    \n    float dis = length(p)-r;\n    float reg = length(p)-1.;\n    \n    d = mix(dis, reg, val(p));\n    \n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nconst float pi = 3.14159;\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 ro = vec3(0., .0, -3.1);\n    \n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    \n    for(int i = 0; i < 64; i++){\n    \td = map(ro + rd*t); \n        \n        if(d < 0.001 || t > 100.) break;\n        t += d * .5;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    vec3 lp = vec3(-0.5, 0.5, -3.);\n    vec3 ld = normalize(lp-p);\n    \n    float dd = length(p - lp);\n    float fal = 3.5 / (dd*dd);\n    float dif = max(dot(n, ld), .01);\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 23.);\n    \n    trn(p);\n    \n    vec3 ref = reflect(rd, n);\n    vec3 cm = tex(iChannel1, ref).xyz;\n    vec3 mm = .5+.5*cos(vec3(1., 2., 3.0)*(iTime-2.)*.08+vec3(4., .8, .4));\n    vec3 mat = mix(cm*.7, mm*2.8, val(p)*0.1);\n    \n    vec3 col = mat * dif * fal;\n    col += spec * vec3(.9, .7, .7)*.5;\n    \n    col *= max(ss(25., 8., ns), .06);\n    col = mix(vec3(.01)*abs(u/R).y, col, exp(-t*t*t*.001));\n    \n    f = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 300, 328, 328, 519], [522, 522, 545, 545, 568], [570, 599, 617, 617, 674], [677, 677, 695, 695, 973], [976, 976, 1003, 1003, 1204], [1233, 1233, 1273, 1273, 2334]], "test": "untested"}
{"id": "tlGcWD", "name": "Depth of Civilization", "author": "blurryroots", "description": "A mix of two shaders by jarble:\nAutomaton: https://www.shadertoy.com/view/WljcRG\nBackground pattern: https://www.shadertoy.com/view/ttjXDK", "tags": ["remix", "pattern", "automaton", "jarble", "jarble"], "likes": 4, "viewed": 346, "published": 3, "date": "1611019079", "time_retrieved": "2024-07-30T19:44:00.041641", "image_code": "// A mix of two shaders by jarble:\n// Automaton: https://www.shadertoy.com/view/WljcRG\n// Background pattern: https://www.shadertoy.com/view/ttjXDK\n\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord/pow(2.0,mag)));\n}\n\n//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = (x)^(y);\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 9970 < 1000 );\n   \n   vec3 color1 = 0.*vec3(.1,.1,.1);\n    float maximum = 1.0+5.*(.5*sin(iTime/10.0)+.5);\n    for(float i = 0.0; i < maximum; i+=0.618){\n    \tcolor1 += magnify(U,i+2.0);\n    }\n    O = O-vec4(color1/(maximum+0.),0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 170, 170, 306], [308, 308, 347, 347, 396], [398, 452, 488, 488, 840]], "test": "untested"}
{"id": "wlyyWD", "name": "Beetle juice", "author": "tdhooper", "description": "This kind of happened by surprise, forked from [url=Fractured Orb]https://www.shadertoy.com/view/ttycWW[/url]", "tags": ["refraction", "dispersion"], "likes": 69, "viewed": 1619, "published": 3, "date": "1611016936", "time_retrieved": "2024-07-30T19:44:01.101806", "image_code": "/*\n\n    Beetle Juice\n    ------------\n\n    Forked from 'Fractured Orb' https://www.shadertoy.com/view/ttycWW\n\n*/\n\n//#define DISABLE_DOF\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = 1.; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 7.;\nconst float RAD_SCALE = 1.; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #if HW_PERFORMANCE==0\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; ang < 10000.; ang += GOLDEN_ANGLE) {\n        if (radius >= MAX_BLUR_SIZE) break;\n\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n       // if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    //fragColor = vec4(texture(iChannel0, uv).rgb, 1); return;\n\n    vec3 col = depthOfField(uv, .65, 3.);\n\n    col = pow(col, vec3(1.25)) * 2.5;\n    col = tonemap2(col);\n\n    fragColor = vec4(col, 1);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//#define DARK_MODE\n\n\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 10.;\n#else\n    const float MAX_DISPERSE = 3.;\n    const float MAX_BOUNCE = 6.;\n#endif\n\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\n\nfloat time;\n\nvec2 map(vec3 p) {\n\n    float scl = .9;\n\n    if (iMouse.z > 0.) {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    } else {\n        pR(p.yz, (.5 - .75) * PI / 2.);\n        pR(p.xz, (.5 - .875) * PI * 2.);\n    }\n\n    p /= scl;\n\n    p += sin(sin(p * 5.) * 3. + time * PI * 2.) * .1;\n    p += (sin(p.x * 10. + time * PI * 2.) * sin(p.y * 20.) * sin(p.z * 30.)) * .03;\n    float sc = 3.;\n    p += (sin(p.x * 20. * sc + time * PI * 2.) * sin(p.y * 20. * sc) * sin(p.z * 20. * sc)) * .002;\n    \n    pR(p.xy, -PI/4.);\n    pR(p.xz, -PI/4.);\n\n    float d = length(p) - 1.;\n       \n    float r = .3;\n    d = mix(d, fBox(p, vec3(.8 - r)) - r, 2.5);\n    d = max(d, -(d + .01));\n    \n    d *= scl;\n    \n    return vec2(d, 1);\n}\n\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.9,.83,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n    \n    understep *= .2;\n\n    for (float i = 0.; i < 300.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x * invert;\n        steps += 1.;\n        res = candidate;\n        if (dist < .001) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float duration = 4.;\n    time = mod(iTime / duration, 1.);\n    \n    #ifndef DARK_MODE\n        envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n    #else\n        envOrientation = sphericalMatrix((vec2(0.7299465240641712,0.3048128342245989) * 2. - 1.) * 2.);\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    \n    if (iMouse.z > 0.) {\n        uv /= 1.75;\n    }\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n    float focal = 3.8;\n    bool refracted;\n\n    vec3 bgCol = BGCOL * .22;\n\n    invert = 1.;\n    maxDist = 15.; \n    \n\tcamOrigin = vec3(0,0,9.5);\n   \tcamDir = normalize(vec3(uv * .168, -1.));\n\n    //camOrigin = vec3(1.8, 5.5, -5.5) * 1.75;\n\n    firstHit = march(camOrigin, camDir, invert, maxDist, .8);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n\n    float rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        wavelength = mix(-.5/5., 1. - .5/5., mod(wavelength, 1.));\n        \n\t\tbounceCount = 0.;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, maxDist / 2., 1.);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n\n            vec3 nor = normal(p) * invert;            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n            // refract\n            float ior = mix(.1, .95, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n        }\n\n        #ifndef DARK_MODE\n            sam += bounceCount == 0. ? bgCol : env(p, rayDir);\t\n        #endif\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE / 2.;\n            break;\n        } else {\n            vec3 extinction = vec3(.5,.5,.5) * .0;\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            col += sam * extinction * spectrum(-wavelength+.25);\n        }\n\t}\n    \n    // debug\n \t//fragColor = vec4(spectrum(steps / 2000.), 1); return;\n    //fragColor = vec4(vec3(bounceCount / MAX_BOUNCE), 1); return;\n    //fragColor = vec4(vec3(firstHit.steps / 100.), 1); return;\n\n    col /= MAX_DISPERSE;\n    \n    //col = mix(col, bgCol, clamp(range(9., 30., firstLen), 0., 1.));\n        \n    float depth = range(0., 13., firstLen);\n        \n    fragColor = vec4(col, depth);\n}\n", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 461, 529, 529, 647], [649, 649, 719, 719, 1921], [1924, 1986, 2016, 2016, 2183], [2185, 2185, 2240, 2240, 2557]], "test": "untested"}
{"id": "ttyyWD", "name": "IFS Revisited", "author": "darkeclipz", "description": "Changed my previous shader https://www.shadertoy.com/view/3djGDt, by adding different lighting, colouring, and patterns.", "tags": ["ifs"], "likes": 6, "viewed": 332, "published": 3, "date": "1611013030", "time_retrieved": "2024-07-30T19:44:01.947545", "image_code": "#define R iResolution.xy\n#define MaxSteps 60.\n#define MinDistance 0.001\n#define eps 0.001\n#define Iterations 16.\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nvec2 DE(vec3 z)\n{\n    float trap = 10000.;\n    float angl = cos(iTime/20.)*2.*3.14159;\n    mat3 rz = rotateZ(angl);\n    mat3 rot = rz;\n \n    float Scale = 2. + cos(iTime/8.)*.5;\n    float Offset = .65;\n    float n = 0.;\n    while (n < Iterations) {\n       z *= rot;\n       if(z.x - z.y < 0.) z.yx = z.xy;\n       if(z.x + z.y < 0.) z.yx = -z.xy;\n       if(z.x - z.z < 0.) z.xz = z.zx;\n       z *= rot;\n       z = abs(z);\n       z = z*Scale - vec3(vec3(Offset*(Scale-1.0)).xy, 0);\n       trap = min(length(z), trap);\n       n++;\n    }\n    return vec2((length(z) ) * pow(Scale, -float(n)), trap);\n}\n\nvec2 scene(vec3 p) {\n    float t = iTime/4.;\n    p *= rotateY(t);\n    float size = 1.3;\n\treturn DE(size*p - vec3(0,.1,0))/size;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p - vec3(0,.1,0)).x;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 h = vec2(0.0001,0);\n    return normalize(vec3(scene(p+h.xyy).x - scene(p-h.xyy).x, \n                          scene(p+h.yxy).x - scene(p-h.yxy).x, \n                          scene(p+h.yyx).x - scene(p-h.yyx).x));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        \n        if(hit.x < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n        t += hit.x;\n        if(t > 20.) {\n            break;\n        }\n        \n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\nfloat angle(vec3 a, vec3 b) {\n    return acos(dot(a,b) / (length(a)*length(b)));\n}\n\nvec3 brdf_gauss(vec3 N, vec3 L, vec3 V, vec3 diff, vec3 spec) {\n    vec3 H = normalize(L+V);\n    //specular\n    float m = 0.7;\n    float NHm = angle(N,H) / m;\n    float NHm2 = NHm*NHm;\n    float k_gauss = exp(-NHm2);\n    //diffuse\n    float wrap = 0.5;\n    float diffuse = max(0., dot(L, N));\n    float wrap_diffuse = max(0., (dot(L, N) + wrap) / (1. + wrap));\n    \n    return diff * diffuse + spec * k_gauss;\n}\n\nvec3 magma(float t) { // from Mattz\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    t *= 2.; if(t >= 1.) { t = 2. - t; }\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 light(vec3 P, vec3 N, vec3 rd, float trap) {\n   \n    vec3 ambient = vec3(.1);\n    vec3 diff = magma(trap);\n    vec3 spec = vec3(.9,.9,.7) * .5;\n    return brdf_gauss(N, normalize(vec3(3,5,-3) - P), -rd, diff, spec)\n         + brdf_gauss(N, normalize(vec3(-5,-5,3) - P), -rd, diff, spec)*.6;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0.18,-1); \n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n    \n    vec3 hit = march(ro, rd);\n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        col = light(p, n, rd, hit.z);\n        col *= hit.y;\n    }\n    else { \n        vec3 bg = texture(iChannel0, rd).rgb;\n        col = mix(bg*.8, bg*.5, smoothstep(.2, .6, fragCoord.y/R.y));\n        \n    }\n    fragColor = vec4(pow(col, vec3(2.2)),1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 141, 141, 227], [229, 229, 256, 256, 342], [344, 344, 371, 371, 449], [451, 451, 468, 468, 1046], [1048, 1048, 1068, 1068, 1177], [1179, 1179, 1205, 1205, 1239], [1241, 1241, 1266, 1266, 1490], [1492, 1492, 1522, 1522, 1862], [1864, 1864, 1901, 1901, 2137], [2139, 2139, 2168, 2168, 2221], [2223, 2223, 2286, 2286, 2634], [2636, 2636, 2657, 2671, 3371], [3373, 3373, 3422, 3422, 3670], [3672, 3672, 3729, 3729, 4269]], "test": "untested"}
{"id": "XsG3D3", "name": "Ill ", "author": "blurryroots", "description": "Don't get infected.", "tags": ["asdf"], "likes": 1, "viewed": 298, "published": 3, "date": "1611010818", "time_retrieved": "2024-07-30T19:44:02.719481", "image_code": "// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\nfloat message(vec2 uv) { // to alter in the icon\n    uv-=vec2(1.,10.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    if (iResolution.y<2000.) {float c=message(fragCoord.xy/8.);if(c>=0.){fragColor=vec4(c);return;}}  \n\n    vec2 up = vec2 (0, 1);\n\tvec2 center = iResolution.xy / 2.;\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 point = center - fragCoord;\n\tfloat angle = angleBetween (up, point);\n    float r = shape (angle + iTime) * ((tan (iTime) * RADIUS / 2.) + RADIUS / 2.);\n    float l = length (point);\n    \n    if (l < r) {\n        fragColor = vec4 (l / RADIUS, 1., 1., 1.);\n    }\n    else {\n        fragColor = vec4 (0.);\n    }\n    \n    vec4 videoColor = texture(iChannel0, uv);\n    \n    fragColor *= videoColor;\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( in int samp, float time )\n{\n    float signal = shape(time) * shape(time * RADIUS);\n    \n    return vec2(VOLUME * signal);\n}", "sound_inputs": [], "common_code": "#define PI 3.14159\n#define RADIUS 200.\n#define VOLUME 0.1\n// original sin\n#define APPROACH fract\n// original cos\n#define FRONT fract\n#define BACK fract\n\nfloat shape (float angle) {\n    return APPROACH (2. * FRONT (angle) + 1.6 * APPROACH (angle) + 0.5 * BACK (angle) + 1.6 * PI);\n}\n\nfloat angleBetween (vec2 a, vec2 b) {\n    return acos (dot (a, b) / (length (a) * length (b)));\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3D3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 102, 126, 528], [530, 530, 586, 586, 1205]], "test": "untested"}
{"id": "3tG3D1", "name": "Chroma Rocks", "author": "blurryroots", "description": "Testing approach to calculate 'distance' between colors.", "tags": ["chroma", "color", "space"], "likes": 0, "viewed": 282, "published": 3, "date": "1611010314", "time_retrieved": "2024-07-30T19:44:03.504382", "image_code": "vec3 desat (vec3 c) {\n    return vec3(0.299*c.r + 0.587*c.g + 0.114*c.b);\n}\n\nvec4 desat (vec4 c) {\n    vec4 d = vec4(0.299*c.r + 0.587*c.g + 0.114*c.b);\n    d.a = 1.0;\n    return d;\n}\n\nfloat luminance(vec3 color)\n{\n    return dot(color, vec3(1.0/3.0));\n}\n\nvec3 convertToYCrCb(vec3 rgbColor)\n{\n\tfloat Y = 0.2989 * rgbColor.r + 0.5866 * rgbColor.g + 0.1145 * rgbColor.b;\n\tfloat Cr = 0.7132 * (rgbColor.r - Y);\n\tfloat Cb = 0.5647 * (rgbColor.b - Y);\n\n\treturn vec3(Y, Cr, Cb);\n}\n\n// Checks how far 'away' two colors are.\nfloat getChromaDistance(vec3 YCbCrA, vec3 YCbCrB)\n{\n\tvec2 CbCrA = vec2(YCbCrA.y, YCbCrA.z);\n\tvec2 CbCrB = vec2(YCbCrB.y, YCbCrB.z);\n\n\treturn distance(CbCrA, CbCrB);\n}\n\nconst vec3 TargetColor = vec3(0.618, 0.33, 0.23);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 uv_color = texture(iChannel0, uv).rgb;\n    vec3 uv_color_y = convertToYCrCb(uv_color);\n    \n    vec3 grayscale = vec3 (1.0, 0.0, 0.0);\n   \t//vec3 grayscale = desat(uv_color);\n    // vec3 grayscale = vec3(luminance(uv_color));\n    vec3 grayscale_y = convertToYCrCb(grayscale);\n \n    vec3 d = vec3(getChromaDistance(uv_color_y, grayscale_y));\n\n    // Output to screen\n    fragColor = vec4(d, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tG3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 75], [77, 77, 98, 98, 183], [185, 185, 214, 214, 254], [256, 256, 292, 292, 474], [476, 517, 568, 568, 683], [736, 736, 793, 843, 1291]], "test": "untested"}
{"id": "XsG3W3", "name": "Incredibly inefficient cells", "author": "blurryroots", "description": "Tiling approach", "tags": ["procedural", "celllularautomaton"], "likes": 1, "viewed": 222, "published": 3, "date": "1611009637", "time_retrieved": "2024-07-30T19:44:04.295267", "image_code": "#define WIDTH 16\n#define HEIGHT 16\n#define PEN_WIDTH_X 2.\n#define PEN_WIDTH_Y 2.\n\nfloat random (vec2 co) {\n    return fract (sin (dot (co.xy ,vec2 (12.9898,78.233))) * 43758.5453);\n}\n\nstruct World {\n    vec4 cells[WIDTH * HEIGHT];\n    int generation;\n};\n\nvec2 getTileSize () {\n    return vec2 (iResolution.x / float (WIDTH), iResolution.y / float (HEIGHT));\n}\n\nvec2 getTilePosition (vec2 fragCoord) {\n    vec2 size = getTileSize ();\n    return vec2 (floor (fragCoord.x / size.x), floor (fragCoord.y / size.y));\n}\n\nbool isGridLine (vec2 fragCoord) {    \n    vec2 size = getTileSize ();\n    vec2 tile = getTilePosition (fragCoord);    \n    vec2 penWidthHalf = vec2 (PEN_WIDTH_X / 2., PEN_WIDTH_Y / 2.);\n    \n    float leftStart = clamp (size.x * tile.x - penWidthHalf.x, 0., iResolution.x);\n    float leftEnd = size.x * tile.x + penWidthHalf.x;\n    \n    float rightStart = size.x * (tile.x + 1.) - penWidthHalf.x;\n    float rightEnd = clamp (size.x * (tile.x + 1.) + penWidthHalf.x, 0., iResolution.x);\n    \n    float upStart = clamp (size.y * tile.y - penWidthHalf.y, 0., iResolution.y);\n    float upEnd = size.y * tile.y + penWidthHalf.y;\n    \n    float downStart = size.y * (tile.y + 1.) - penWidthHalf.y;\n    float downEnd = clamp (size.y * (tile.y + 1.) + penWidthHalf.y, 0., iResolution.y);\n    \n    \n\treturn (leftStart <= fragCoord.x && fragCoord.x <= leftEnd)\n        || (rightStart <= fragCoord.x && fragCoord.x <= rightEnd)\n        || (upStart <= fragCoord.y && fragCoord.y <= upEnd)\n        || (downStart <= fragCoord.y && fragCoord.y <= downEnd)\n        ;    \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;;\n    \n\tfragColor = isGridLine (fragCoord) \n        ? vec4 (1, 1, 0.6, 1)\n        : vec4 (0, 0, 0, 0)\n        ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsG3W3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 106, 106, 182], [255, 255, 276, 276, 359], [361, 361, 400, 400, 512], [514, 514, 548, 548, 1571], [1573, 1573, 1629, 1629, 1784]], "test": "untested"}
{"id": "wtKGz3", "name": "Debug Visuals", "author": "blurryroots", "description": "Debug visuals", "tags": ["fu"], "likes": 0, "viewed": 241, "published": 3, "date": "1611009530", "time_retrieved": "2024-07-30T19:44:05.176910", "image_code": "#define MouseV (iMouse.y / iResolution.y)\n#define MouseU (iMouse.x / iResolution.x)\n\n\n//Inspired by https://www.shadertoy.com/view/4ljfRD\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nfloat drawCircle(vec2 uv, vec2 p, float r)\n{\n    return distance(uv, p) - r;\n}\n\nvec2 rightVector(vec2 a, vec2 b)\n{\n    vec2 aa = a;\n    vec2 ba = b;\n    \n    vec2 diff = ba - aa;\n    vec2 right = vec2(diff.y, -diff.x);\n    \n    return vec2(right.x, right.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0);\n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    \n    vec2 a = vec2(MouseU, MouseV);\n    vec2 b = vec2(0.5,0.8);    \n    if(distance(uv*aspect, a*aspect) < 0.01) color+=vec3(1);\n    if(distance(uv*aspect, b*aspect) < 0.01) color+=vec3(1);\n\tcolor += vec3(drawLine(a, b, uv, 5.), 0, 0);\n    \n    \n    vec2 diff = b - a; \n    vec2 right = rightVector(a * iResolution.xy, b * iResolution.xy)/iResolution.xy;    \n    \n    vec2 rightPoint = (a + right);\n\tcolor += vec3(0, 0, drawLine(a, rightPoint, uv, 5.)); \n    \n    if(distance(uv*aspect, (a+right)*aspect) < 0.01) color+=vec3(1,1,0);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 138, 191, 191, 603], [605, 605, 649, 649, 683], [685, 685, 719, 719, 865], [867, 867, 924, 974, 1700]], "test": "untested"}
{"id": "ttGyDW", "name": "click Star+Galaxy 1", "author": "ollj", "description": "Click on Galaxies to go close.\nWhen close, click on it to enter inside. \nWhen inside, click on stars or clouds to go close or click another galaxy to go close to it.\nIf your computer is good enought you could try WITH_SUPERNOVA_REMNANT (by Duke)", "tags": ["interactive", "star", "space", "galaxy", "cosmos", "field", "supernova", "universe"], "likes": 13, "viewed": 1023, "published": 3, "date": "1611002296", "time_retrieved": "2024-07-30T19:44:06.142329", "image_code": "#define get(i)texture(iChannel0,vec2(i+.5,.5)/iChannelResolution[0].xy,-100.0)\n\n//abriceNeyret2 Black Body...  https://www.shadertoy.com/view/4tdGWM\nvec3 blackBody(float k\n){float T=(k*2.)*16000.\n ;vec3 c=vec3(1.,3.375,8.)/(exp((19e3*vec3(1.,1.5,2.)/T))- 1.)\n ;return c/max(c.r,max(c.g,c.b));}\n\n#define noiseTextureSize 256.\n\n// iq noise https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x\n){vec3 p=floor(x),f=fract(x)\n ;f*=f*(3.-f-f)\n ;vec2 uv=(p.xy+vec2(37.,17.)*p.z)+ f.xy\n ,rg=textureLod(iChannel1,(uv+.5)/noiseTextureSize,-100.).yx\n ;return mix(rg.x,rg.y,f.z);}\nfloat pn(vec3 x\n){vec3 p=floor(x),f=fract(x)\n ;f*=f*(3.-f-f)\n ;vec2 uv=(p.xy+vec2(37.,17.)*p.z)+ f.xy\n ,rg=textureLod(iChannel1,(uv+.5)/noiseTextureSize,-100.).yx\n ;return 2.4*mix(rg.x,rg.y,f.z)-1.;}\nfloat bm(vec3 x\n){vec3 p=floor(x),f=fract(x)\n ;f*=f*(3.-f-f)\n ;vec2 uv=(p.xy+vec2(37.,17.)*p.z)+ f.xy\n ,rg=textureLod(iChannel1,(uv+ .5)/noiseTextureSize,-100.).yx\n ;return 1.-.82*mix(rg.x,rg.y,f.z);}\nfloat fpn(vec3 p){return pn(p*.06125)*.5+pn(p*.125)*.25+pn(p*.25)*.125 ;}//+pn(p*.5)*.625\nfloat fbm(const in vec3 p){return bm(p*.06125)*.5+bm(p*.125)*.25+bm(p*.25)*.125+bm(p*.4)*.2;}\nfloat smoothNoise(in vec3 q\n){const mat3 msun=mat3(0.,.8,.6,-.8,.36,-.48,-.6,-.48,.64)\n ;float f=.5000*noise(q);q=msun*q*2.01\n ;f+=.2500*noise(q);q=msun*q*2.02\n ;f+=.1250*noise(q);q=msun*q*2.03\n ;f+=.0625*noise(q)\n ;return f;}\n\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\nfloat SpiralNoiseC(vec3 p,vec4 id\n){const float m=20.,n=inversesqrt(1.+m*m)\n ;float iter=2.,r=2.-id.x\n ;for (int i=0;i<SPIRAL_NOISE_ITER;i++\n ){r+=-abs(sin(p.y*iter)+ cos(p.x*iter))/iter\n  ;p.xy+=vec2(p.y,-p.x)*m;p.xy*=n\n  ;p.xz+=vec2(p.z,-p.x)*m;p.xz*=n\n  ;iter*=id.y+.733733;}return r;}\n\nfloat mapIntergalacticCloud(vec3 p,vec4 id\n){float k=2.*id.w+.1;// p/=k\n ;return k*(.5+SpiralNoiseC(p.zxy*.4132+333.,id)*3.+pn(p*8.5)*.12);}\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\n//Intersection functions (mainly iq)\n//return bool and 2 intersection distances\nbool traceSphere(v22 r,out float a,out float b//ray,near,far\n){float c=dot(r.b,r.a);b=c*c-dot(r.a,r.a)+8.\n ;if(b<0.0)return false\n ;b=sqrt(b);a=-c-b;b-=c;return b>0.;}\n//return bool,farIntersection and [edge]\nbool traceSphere(v22 r,float s,out vec2 v // b,out float e\n){v.x=dot(r.b,-r.a);v.y=v.x*v.x-dot(r.a,r.a)+s*s\n ;if(v.y<0.)return false\n ;v.y=sqrt(v.x);v.x=v.x-v.y;return v.x>0.;}\n \nfloat SpiralNoiseC2(vec3 p\n){const float m=.9;// size of perpendicular vector\n ;float n=inversesqrt(1.+m*m)\n ;float r=0.,iter=2.\n ;for (int i=0;i<8;i++\n ){r+=-abs(sin(p.y*iter)+ cos(p.x*iter))/ iter //abs is optional for rigged look\n  ;p.xy+=vec2(p.y,-p.x)*m;p.xy*=n\n  ;p.xz+=vec2(p.z,-p.x)*m;p.xz*=n\n  ;iter*=1.733733;}return r;}\nfloat length2(vec2 p){return sqrt(p.x*p.x+p.y*p.y);}\nfloat length8(vec2 p){p=p*p;p=p*p;p=p*p;return pow(p.x+p.y,.125);}\nfloat Disk(vec3 p,vec3 t\n){vec2 q=vec2(length2(p.xy)-t.x,p.z*0.5)\n ;return max(length8(q)-t.y,abs(p.z)- t.z);}\nfloat mapSupernovaRemnant(vec3 p\n){p*=2.\n ;float noi=Disk(p.xzy,vec3(2.0,1.8,1.25))+fbm(p*90.)+SpiralNoiseC2(p.zxy*0.5123+100.0)*3.\n ;return abs(noi*.5)+.07;}\n#endif // WITH_SUPERNOVA_REMNANT\n\nbool cylinder(vec3 ro,vec3 rd,float r,float h,out float tn,out float tf\n){float a=dot(rd.xy,rd.xy),b=dot(ro.xy,rd.xy)\n ,d=b*b- a*(dot(ro.xy,ro.xy)- r*r)\n ;if(d<0.)return false\n ;d=sqrt(d)\n ;tn=(-b- d)/a;tf=(-b+d)/a\n ;a=min(tf,tn);tf=max(tf,tn);tn=a// order roots\n ;a=ro.z+tn*rd.z\n ;b=ro.z+tf*rd.z\n ;vec2 zcap=h*vec2(.5,-.5),cap=(zcap- ro.z)/ rd.z\n ;tn=a<zcap.y?cap.y : a>zcap.x?cap.x : tn\n ;tf=b<zcap.y?cap.y : b>zcap.x?cap.x : tf\n ;return tf>0. && tf>tn;}\n\n//Awesome star by Foxes: https://www.shadertoy.com/view/4lfSzS\nfloat noise4q(vec4 x\n){vec4 n3=vec4(0,.25,.5,.75)\n ;vec4 p2=floor(x.wwww+n3)\n ;vec4 b=floor(x.xxxx+n3)+ floor(x.yyyy+n3)*157.+floor(x.zzzz+n3)*113.\n ;vec4 p1=b+fract(p2*.00390625)*vec4(164352.,-164352.,163840.,-163840.)\n ;p2=b+fract((p2+1.0)*.00390625)*vec4(164352.,-164352.,163840.,-163840.)\n ;vec4 f1=fract(x.xxxx+n3),f2=fract(x.yyyy+n3)\n ;f1*=f1*(3.0-f1-f1)\n ;f2*=f2*(3.0-f2-f2)\n ;vec4 n1=vec4(0,1.,157.,158.),n2=vec4(113.,114.,270.0,271.)\n ;f1=fract(x.zzzz+n3)\n ;f2=fract(x.wwww+n3)\n ;f1*=f1*(3.-2.*f1)\n ;f2*=f2*(3.-2.*f2)\n ;vec4 vs1=mix(mix(mix(h3(p1),h3(n1.yyyy+p1)    ,f1)\n          ,mix(h3(n1.zzzz+p1),h3(n1.wwww+p1)    ,f1),f2)\n          ,mix(mix(h3(n2.xxxx+p1),h3(n2.yyyy+p1),f1)\n          ,mix(h3(n2.zzzz+p1),h3(n2.wwww+p1)    ,f1),f2),f1)\n ;vec4 vs3=mix(mix(mix(h3(p2),h3(n1.yyyy+p2)    ,f1)\n          ,mix(h3(n1.zzzz+p2),h3(n1.wwww+p2)    ,f1),f2)\n          ,mix(mix(h3(n2.xxxx+p2),h3(n2.yyyy+p2),f1)\n          ,mix(h3(n2.zzzz+p2),h3(n2.wwww+p2)    ,f1),f2),f1)\n ;vs1=mix(vs1,vs3,f2)\n ;float r=dot(vs1,vec4(.25))\n ;return r*r*(3.-r-r);}\n\n// rays of a star\nfloat ringRayNoise(v22 r,float s,float size,float anim\n){float b=dot(r.b,r.a)\n ;vec3 pr=r.b*b-r.a\n ;float c=length(pr)\n ,m=max(0.,(1.-size*abs(s-c)))\n ;pr=pr/c\n ;float n=.4,ns=1.,nd=noise4q(vec4(pr*1.0,-anim+c))*2.\n ;if (c>s\n ){n=noise4q(vec4(pr*10.0,-anim+c))\n  ;ns=noise4q(vec4(pr*50.0,-anim*2.5+ c+c))*2.;}\n ;return m*m*(m*m+n*n*nd*nd*ns);}\n\n//Sun Lava effect\n\nvec3 getSunColor(vec3 p,vec4 id,float time\n){float lava=smoothNoise((p+vec3(time*.03))*50.*(.5+id.z))\n ;return blackBody(.02+3.*clamp(id.x*id.x,.05,1.)*(1.- sqrt(lava)));}\n\nvec4 renderSun(v22 r,in vec4 i,in float t//ray,id,time\n){r.a*=2.\n ;// Rotate view to integrate sun rotation \n ;// R(ro.zx,1.6-t*.5*i.w)\n ;// R(rd.zx,1.6-t*.5*i.w)\n ;vec4 c=vec4(0)\n ;if(traceSphere(r,1.,c.xy))c=vec4(getSunColor(r.a+r.b*c.x,i,t),smoothstep(0.,.2,c.y));\n ;r.a.x=ringRayNoise(r,1.0,5.-4.*i.y,t)\n ;c.a=max(c.a,clamp(r.a.x,0.,.98))\n ;c.rgb+=blackBody(i.x)*r.a.x\n ;c.rgb*=1.-.03*cos(5.*t+2.*hash(t))// twinkle\n ;return sat(c);}\n\n// Supernova remnant by Duke [https://www.shadertoy.com/view/MdKXzc]\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\nvec3 computeColorSR(float d,float r//density,radius\n){return mix(vec3(1.,.9,.8),vec3(.4,.15,.1),d)\n *mix(7.*vec3(.8,1.,1.),1.5*vec3(.48,0.53,.5),min((r+.5)/.9,1.15));}\n\nvec4 renderSupernova(v22 r\n){vec4 a=vec4(0.)//acc return\n ;float m=0.,n=0.\n ;if(traceSphere(r,m,n)\n ){float t=max(m,0.)+.01*hash(r.b)//calculate once\n  ;r.a*=3.\n  ;m=0.//acc conditional\n  ;for(int i=0;i<64;i++\n  ){if (m>.9 || a.w>.99 || t>n)break\n   ;vec3 pos=r.a+r.b*t\n   ;float d=mapSupernovaRemnant(pos)\n   ;float lDist=max(length(pos),.001)\n   ;a+=vec4(.67,.75,1.,1.)/(lDist*lDist*10.)*.0125// star \n   ;a+=vec4(1.,.5,.25,.6)/exp(lDist*lDist*lDist*.08)*.033// bloom\n   ;const float h=.1\n   ;if(d<h\n   ){m+=(1.-m)*(h-d)+.005\n    ;vec4 c=vec4(computeColorSR(m,lDist),m*.2)\n    ;a.rgb+=a.w*a.rgb*.2;c.rgb*=c.a;a+=c*(1.- a.w);}\n   ;m+=.014\n   ;// trying to optimize step size near the camera and near the light source\n   ;t+=max(d*.1*max(min(lDist,length(r.a)),1.0),0.01);}\n  ;//a*=1./exp(l*.2)*.6; //scatter\n  ;a=sat(a)\n  ;a.xyz*=a.xyz*(3.-a.xyz-a.xyz);}return a;}\n#endif\n\n//Galaxy\n\n//p,1/thickness,blurAmount,blurStyle\nfloat spiralArm(vec3 p,float t,float a,float s\n){float r=length(p.xz)\n ,l=log(r)\n ,d=(.5/2.- abs(fract(.5*(atan(p.x,p.z)-l*4.)/pi)-.5))*2.*pi*r*(1.-l)*t\n ;return sqrt(d*d+10.*p.y*p.y*t)-(.1-.25*r)*r*.2\n -a*mix(fpn(8.*vec3(r*43.,40.*d,24.*p.y)),fpn(p*400.),s)// Perturb\n ;}\n\nvoid galaxyTransForm(inout vec3 o,vec4 i\n){R(o.yz,(i.y-.5))\n ;// R(o.xy,.25*i.x*iTime);\n ;}\n\nfloat mapGalaxy(vec3 p,vec4 id\n){float t=.2/(1.+id.x)\n ;float d1=spiralArm(p.xzy*.2,t,.2+.3*id.y,id.z)\n #ifdef WITH_DOUBLE_GALAXY\n ;if(id.z<.25\n ){float d2=spiralArm(vec3(-p.y,p.z,p.x)*.205,t,.2+.3*id.y,id.z)\n  ;return min(d2,d1);}\n #endif \n ;return d1;}\n\nvec3 computeColor(float d,vec3 u//density,uv\n){u.x=length(u);return mix(vec3(.25,.22,.2),vec3(.1,.0375,.025),d)\n *mix(vec3(4.8,6.,6.), vec3(.96,1.06,1.),min((u.x+.5)*.5,1.15));}\n\nvec4 renderGalaxy(v22 r,in vec4 id,in bool fast\n){vec4 a=vec4(0)\n ;float min_dist=0.,max_dist=100.\n ;galaxyTransForm(r.a,id)\n ;galaxyTransForm(r.b,id)\n ;if(cylinder(r.a,r.b,3.,3.5,min_dist,max_dist)\n ){float b=0.//acc\n  ,l=max(min_dist,0.)+ .2*hash(r.b+iTime)//acc raylength\n  ;vec4 n,m//changes wiothin loop (composite vector)\n  ;for (int i=0;i<48;i++ //raymarch\n  ){if((fast&&i>20)|| b>.9 || a.w>0.99 || l>max_dist)break\n   ;vec3 u=r.a+r.b*l\n   ;float d=max(abs(mapGalaxy(3.5*u,id))+.05,.005)\n   ;const float h=.1\n   ;if(d<h\n   ){float l=h-d\n    ;l+=sat((l-mapGalaxy(u*3.5-.2*normalize(u),id))*2.5)\n    ;b+=(1.-b)*l+.005\n    ;vec4 c=vec4(computeColor(b,u),b*.25);c.rgb*=c.a;a+=c*(1.- a.w);}\n   ;b+=.014\n   ;n.xyz=u*.25\n   ;m.xyz=u*.05\n   ;m.z*=2.5\n   ;n.w=max(length(n.xyz),.0001)//max(length(n.xyz),0.001)\n   ;m.w=max(length(m.xyz),.0001)\n   ;vec3 lightColor=(1.-smoothstep(3.,4.5,n.w*n.w))\n   *mix(.07*vec3(1.,.5,.25)/n.w,.008*vec3(1.,1.7,2.)/m.w,smoothstep(.2,.7,n.w));// star in center\n   ;a.rgb+=lightColor/(n.w*20.);//bloom\n   ;d=max(d,.04)\n   ;l+=max(d*.3,.02);}\n  ;a=sat(a)\n  ;a.xyz*=a.xyz*(3.-a.xyz-a.xyz);}return a;}\n\n// Adapted from Planet Shadertoy- Reinder Nijhoff: https://www.shadertoy.com/view/4tjGRh\nvec3 renderGalaxyField(v22 r,bool fast\n){//out_id=vec3(9)\n ;float dint //changes within loop within point()\n ,l=0.       //acc rayLength\n ;vec3 h     //hash sepends on (pos) within loop\n ,o=r.a      //acc origin\n ,f=floor(o) //acc tileId pos\n ,v=1./r.b   //calculate once\n ,s=sign(r.b)//calculate once\n ,dis=(f-o+.5+s*.5)*v\n ;vec4 a=vec4(0)\n ;for(int i=0;i<GALAXY_FIELD_VOXEL_STEPS_HD;i++\n ){if(!fast||i!=0\n  ){h=hash33(f)\n   ;vec3 O=f+cl1(h,GALAXY_RADIUS)\n   ;l=point(o,r.b,O,dint)\n   ;if(dint>0. && l<GALAXY_RADIUS\n   ){vec4 c=renderGalaxy(v22((o-O)/GALAXY_RADIUS*3.,r.b),vec4(h,.5),fast)\n    ;c.rgb*=smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(r.a-f))\n    ;a+=(1.-a.w)*c\n    ;if(a.w>.99)break;}}\n  ;vec3 m=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=m*s*v;f+=m*s;}\n ;if(!fast && a.w<.99\n ){for(int i=GALAXY_FIELD_VOXEL_STEPS_HD;i<GALAXY_FIELD_VOXEL_STEPS;i++\n  ){h=hash33(f)\n   ;l=point(o,r.b,f+cl1(h,GALAXY_RADIUS),dint)\n   ;if(dint>0.\n   ){vec4 c=vec4(.9,.9,.8,1.)*(1.-smoothstep(GALAXY_RADIUS*.25,GALAXY_RADIUS*.5,l))\n    ;c.rgb*=smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(r.a-f))\n    ;a+=(1.-a.w)*c\n    ;if(a.w>.99)break;}\n   ;vec3 m=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n   ;dis+=m*s*v;f+=m*s;}}\n ;return a.xyz;}\n\n// Adapted from Planet Shadertoy- Reinder Nijhoff:  https://www.shadertoy.com/view/4tjGRh\nvec4 renderStarField(v22 r,inout float O\n){float dint   //changes within loop within point()\n ,l=0.         //acc rayLength\n ;vec3 n=1./r.b//calculate once\n ,rs=sign(r.b) //calculate once\n ,o            //changes within loop (offset)\n ,h            //changes within loop (hash)\n ,f=floor(r.a) //changes within loop (tileId)\n ,v=(f-r.a+.5+rs*.5)*n//acc voxel coods\n ;vec4 c              //acc color intermediate\n ,a=vec4(0)           //acc color return\n ;for(int i=0;i<STAR_FIELD_VOXEL_STEPS;i++\n ){h=hash33(f)\n  ;o=cl1(h,STAR_RADIUS)\n  ;l=point(r.a,r.b,f+o,dint)\n  ;if(dint>0.\n  ){if(dint<2. && l<STAR_RADIUS\n   ){r.a=(r.a-f-o)/STAR_RADIUS,\n    #ifdef WITH_SUPERNOVA_REMNANT\n     c=h.x>.8?renderSupernova(v22(r.a,r.b)):\n    #endif\n     c=renderSun(v22(r.a,r.b),vec4(h,.5),iTime)\n    ;if (c.a>.99)O=dint\n   ;}else c=(vec4(blackBody(max(h.x-.1,.01)),1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,l)))\n   ;c.rgb*=smoothstep(float(STAR_FIELD_VOXEL_STEPS),.5,dint)\n   ;c.rgb*=c.a\n   ;a+=(1.-a.w)*c\n   ;if (a.w>.99)break;}\n  ;vec3 mm=step(v.xyz,v.yxy)* step(v.xyz,v.zzx)\n  ;v+=mm*rs*n\n  ;f+=mm*rs;}\n return a;}\n\n\n//intergalactic clouds\n\n#ifdef WITH_INTERGALACTIC_CLOUDS\n\n\n// Based on \"Type 2 Supernova\" by Duke (https://www.shadertoy.com/view/lsyXDK)\nvec4 renderIntergalacticClouds(v22 r,float m\n){m=min(m,float(STAR_FIELD_VOXEL_STEPS)) //calculated once\n ;vec4 a=vec4(0),id=vec4(.5,.4,.16,.7)         //loop var\n ;vec3 u              //loop var\n ;float e=0.          //loop var       , edge color\n ,o=.05+.25*id.z      //calculated once, outer edge?\n ,l=hash(hash(r.b))*.1//calculated once, hashed rayLength\n ,b=smoothstep(m,0.,l)//calculated once\n ;for(int i=0;i<100;i++\n ){if(e>.9 || a.w>.99 || l>m)break\n  ;u=r.a+l*r.b\n  ;float d=abs(mapIntergalacticCloud(u,id))+.07//depends on var u\n  ,sp=4.5//quickly discarded scalar constant\n  ;sp=max(length(mod(u+sp,sp*2.)-sp),.001)\n  ;u.x=pn(.05*u)\n  ;vec3 c=mix(hsv2rgb(u.x,.5,.6),hsv2rgb(u.x+.3,.5,.6),smoothstep(2.*id.x*.5,2.*id.x*2.,sp))\n  ;a.rgb+=b*c/exp(sp*sp*sp*.08)/30.\n  ;if (d<o//color edges\n  ){e+=(1.-e)*(o-d)+.005\n   ;a.rgb+=a.w*a.rgb*.25/sp//emmissive\n   ;a+=(1.-a.w)*.02*e*b; }// uniform scale density+alpha blend in contribution \n  ;e+=.015\n  ;l+=max(d*.08*max(min(sp,d),2.),.01);}// trying to optimize step size\n ;a=sat(a)\n ;a.xyz*=a.xyz*(3.-a.xyz-a.xyz);return a;}\n\n#endif \n\n// Coordinate system conversions\nbool inGalaxy(vec3 u){vec3 f=floor(u)\n ;return length(u-f-cl1(hash33(f),GALAXY_RADIUS))<GALAXY_RADIUS;}\n\nv22 getCam(vec2 p\n){vec3 w=get(Bc1).xyz//is normalized on set()\n ,u=normalize(cross(w,normalize(vec3(.1*cos(.1*iTime),.3*cos(.1*iTime),1.))))\n ;return v22(get(Bc0).xyz,normalize(-p.x*u+p.y*normalize(cross(u,w))+2.*w) );}\n\nvoid mainImage(out vec4 o,in vec2 u\n){o.xyz=vec3(0)\n ;u=u/iResolution.xy\n ;u=u*2.-1.\n ;u.x*=iResolution.x/iResolution.y\n ;v22 r=getCam(u)\n ;vec3 galaxyId,galaxyPosU\n ;vec4 s=vec4(0)//star color\n ;float coo=get(Bvv).z\n ;coo=coo>2.5?IN_SOLAR_SYSTEM : coo>1.5?IN_GALAXY :  IN_UNIVERSE\n ;bool isU=coo==IN_UNIVERSE,isG=coo==IN_GALAXY\n ;vec3 galaxy_pos=get(Bg0).xyz\n ;if(inGalaxy(isU?r.a : g2u(galaxy_pos,r.a))\n ){vec3 roG=isU?u2g(galaxy_pos,r.a): r.a\n  ;float d=9999.\n  ;s=renderStarField(v22(roG,r.b),d)\n  #ifdef WITH_INTERGALACTIC_CLOUDS\n  ;vec4 c=renderIntergalacticClouds(v22(roG,r.b),d)\n  ;if(s.a!=0.)s=(1.-c.a)*sqrt(s)*s.a\n  ;s+=c\n  #endif \n  ;}\n ;if(isG)r.a=g2u(galaxy_pos,r.a)\n ;vec3 colGalaxy=renderGalaxyField(r,isG)\n ;s.rgb+=colGalaxy*(1.-s.a)\n ;o.xyz=s.rgb\n ;// float digit=PrintValue(fragCoord,iResolution.xy*vec2(.0,.7),vec2(20.),galaxy_pos.x,8.,10.);\n ;// digit+=PrintValue(fragCoord,iResolution.xy*vec2(.0,.6),vec2(20.),galaxy_pos.y,8.,10.);\n ;// digit+=PrintValue(fragCoord,iResolution.xy*vec2(.0,.5),vec2(20.),galaxy_pos.z,8.,10.);\n ;// o.xyz=mix(o.xyz,vec3(1,0,0),digit)\n ;if(isU)o.xyz+=vec3(0.03,0.,.1);}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI=acos(-1.);\nconst float DEG_TO_RAD=(PI/180.);\nconst float MAX=10000.;\n\nfloat key(int a){return texture(iChannel2,vec2((.5+float(a))/256.,0.25)).x;}\n\nfloat distanceRayPoint(vec3 ro,vec3 rd,vec3 p,out float h\n){h=dot(p-ro,rd);return length(p-ro-rd*h);}\n\n// Toujours en coordonnes Univers\nbool renderGalaxyField(vec3 roU,vec3 rd,out vec3 out_posU,out vec3 out_id\n){float d,dint\n ;vec3 ros=roU+rd*d\n ,pos=floor(ros)\n ,ri=1./rd\n ,rs=sign(rd)\n ,dis=(pos-ros+0.5+rs*0.5)* ri\n ,offset\n ,id\n ,galaxyro\n ;float pitch=10./iResolution.x\n ;for(int i=0;i<GALAXY_FIELD_VOXEL_STEPS;i++\n ){id=hash33(pos)\n  ;offset=clamp(id,GALAXY_RADIUS,1.-GALAXY_RADIUS)\n  ;d=distanceRayPoint(ros,rd,pos+offset,dint)\n  ;if(dint>0. && d<GALAXY_RADIUS*.5+dint*pitch\n  ){galaxyro=pos+offset\n   ;out_posU=galaxyro\n   ;out_id=id\n   ;return true;} \n ;vec3 mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n ;dis+=mm*rs*ri\n ;pos+=mm*rs;}return false;}\n\n\nbool renderStarField(vec3 galaxyId,in vec3 roG,in vec3 rd,out vec3 out_posG,out vec3 out_id\n){out_id=vec3(9)\n ;float d,dint\n ;vec3 ros=roG+rd*d\n ,pos=floor(ros)\n ,ri=1./rd\n ,rs=sign(rd)\n ,dis=(pos-ros+0.5+rs*0.5)* ri\n ,mm\n ,offset=vec3(0.),id,galaxyro\n ;float pitch=10./iResolution.x\n ;for(int i=0;i<STAR_FIELD_VOXEL_STEPS;i++\n ){id=hash33(pos)\n  ;offset=clamp(id,STAR_RADIUS,1.-STAR_RADIUS)\n  ;d=distanceRayPoint(ros,rd,pos+offset,dint)\n  ;if(dint>0.&&d<STAR_RADIUS*.5+dint*pitch\n  ){out_posG=pos+offset\n   ;out_id=id\n   ;return true;}\n  ;mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=mm*rs*ri\n  ;pos+=mm*rs;}return false;}\n\n// from iq shader Brick: https://www.shadertoy.com/view/MddGzf\nfloat inside(vec2 p,vec2 c){vec2 d=abs(p-.5-c)-.5;return-max(d.x,d.y);}\nvec4 set(vec2 r,vec4 v,vec4 o,vec2 u){if(inside(u,r)> 0.)o=v        ;return o;}\nvec4 set(vec2 r,vec3 v,vec4 o,vec2 u){if(inside(u,r)> 0.)o=vec4(v,0);return o;}\n\n\n#define CONF(id) texture(iChannel0,vec2(id+.5,.5)/ iChannelResolution[0].xy,-100.0).xyz\n#define CONF4(id)texture(iChannel0,vec2(id+.5,.5)/ iChannelResolution[0].xy,-100.0);\n\nbool inGal(in vec3 roU,out vec3 out_GalaxyId,out vec3 out_GalaxyPosU\n){vec3 pos=floor(roU)\n ;out_GalaxyId=hash33(pos)\n ;vec3 offset=clamp(out_GalaxyId,GALAXY_RADIUS,1.-GALAXY_RADIUS)\n ;out_GalaxyPosU=(pos+offset)\n ;return length(roU- out_GalaxyPosU)<GALAXY_RADIUS;}\n\n#define R(p,a)p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nvec3 R2(vec3 a,float b){R(a.yz,b);R(a.xy,b);return a;}\n\nvec3 getRd(vec3 ww//forward\n){vec2 m=iM.xy/iR.xy*2.-1.;m.x*=iR.x/iR.y\n ;ww=normalize(ww)\n ;vec3 uu=normalize(cross(ww,normalize(vec3(.1*cos(.1*iTime),.3*cos(.1*iTime),1.))))\n ;vec3 vv=normalize(cross(uu,ww))\n ;vec3 rd=normalize(-m.x*uu+m.y*vv+2.*ww)\n ;return rd;}\n\nvec4 init(vec2 u//initialization\n){vec3 c1=normalize(vec3(1.,0.,0.))\n ;vec3 pos=floor(vec3(10.))\n ;vec3 id=hash33(pos)\n ,offset=clamp(id,GALAXY_RADIUS,1.-GALAXY_RADIUS)\n ;vec3 a=pos+offset-.03*c1\n ;vec3 b=.03*c1\n ;vec3 e=a+b;b=R2(b,1.);a=e-b//offset rotation\n ;b=normalize(b)\n ;vec4 c=vec4(0)\n ;c=set(vec2(Bvv,0),vec4(STATIONARY,GALAXY,IN_UNIVERSE,iTime),c,u)\n ;c=set(vec2(Bg0,0),vec3(0),c,u)\n ;c=set(vec2(Bg1,0),vec3(1),c,u)\n ;c=set(vec2(Bc0,0),a,c,u)\n ;c=set(vec2(Bf0,0),a,c,u)\n ;c=set(vec2(Bt0,0),a,c,u)\n ;c=set(vec2(Bc1,0),b,c,u)\n ;c=set(vec2(Bf1,0),b,c,u)\n ;c=set(vec2(Bt1,0),b,c,u)\n ;return c;}\n\n//Each set() in of init() gets its own [**_() setter function] (for runtime case)\n//[**_() functions] calculate the color of ONE specific state-pixel.\n//they all are quite similar in their branch conditions, but converge onto one unique variable.\n//there is still lots to optimize here (planning subroutines)\n//\n//m() contains a condition-tree for **_() functions \n//**_() functions are best first seen as [minimized] functions\n//and then skip to the m() below them, for a quick overview\n//\n//the parent shader:   https://www.shadertoy.com/view/3tGyW1\n//does NOT split up the branches by their convergences (its a mess)\n\nvec4 c1_(vec2 u        //calc camera target\n){vec3 ww//rayOrigin,CamForward\n ;vec4 v=CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;ww=normalize(R2(mov,.05*s*t));\n  ;}else{ww=CONF(Bc1);R(ww.yz,.002);}}\n ;vec4 c=vec4(0)\n ;return set(vec2(Bc1,0),ww,vec4(0),u);}\n\nvec4 c0_(vec2 u        //calc camera origin\n){vec3 c0=CONF(Bc0)\n ;vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if(v.y!=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ro=CONF(Bt0)+mov-R2(mov,.05*s*t)\n  ;}else{ro=c0+.005*CONF(Bc1);}}\n ;vec3 galaxyId,gpu \n ;bool inGal=inGal(isU ? ro : g2u(CONF(Bg0),ro),galaxyId,gpu)\n ;c0=ro\n ;if(v.x!=STATIONARY\n ){if(inGal){if(isU)                             c0=u2g(gpu,c0)\n ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)c0=g2u(gpu,c0);}}\n ;return set(vec2(Bc0,0),c0,vec4(0.),u);}\n\nvec4 f1_(vec2 u        //calc from-direction\n){vec3 f1=CONF(Bf1)\n ;vec3 ww//rayOrigin,CamForward\n ;vec4 v=CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ww=mix(f1,CONF(Bt1),s)\n ;else{\n  ;if(v.y!=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ww=normalize(R2(mov,.05*s*t));\n  ;}else{ww=CONF(Bc1);R(ww.yz,.002);}}\n ;if (v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){f1=ww;}}\n ;return set(vec2(Bf1,0),f1,vec4(0.),u);}\n\nvec4 f0_(vec2 u        //calc from-origin\n){vec3 f0=CONF(Bf0)\n ;vec3 ro//rayOrigin\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ro=mix(f0,CONF(Bt0),s)\n ;else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ro=CONF(Bt0)+mov-R2(mov,.05*s*t)\n  ;}else ro=CONF(Bc0)+.005*CONF(Bc1);}\n ;\n ;vec3 galaxyId,gpu\n ;bool inGal=inGal(isU ? ro : g2u(CONF(Bg0),ro),galaxyId,gpu)\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){f0=ro;}\n ;}else{\n  if(inGal){if(isU                                )f0=u2g(gpu,f0)\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)f0=g2u(gpu,f0);}}\n ;return set(vec2(Bf0,0),f0,vec4(0.),u)\n ;}\n\nvec4 t1_(vec2 u        //calc target-direction\n){vec3 t1=CONF(Bt1),ww//t1,CamForward\n ;vec4 v=CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING)ww=mix(CONF(Bf1),t1,s)\n ;else{\n  ;if(v.y!=NONE\n  ){vec3 mov=t1*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;ww=normalize(R2(mov,.05*s*t));\n  ;}else{ww=CONF(Bc1).xyz;R(ww.yz,.002);}}\n ;vec3 rd=getRd(ww)\n ;if (v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){t1=rd;}}\n ;return set(vec2(Bt1,0),t1,vec4(0.),u);}\n\nvec4 t0_(vec2 u,vec3 g0//calc target-origin\n){vec3 t0=CONF(Bt0)\n ;vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),t0,s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if(v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=t0+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{ww=CONF(Bc1);ro=CONF(Bc0)+.005*ww;R(ww.yz,.002);}};vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu,tpu,tpg,tid\n ;bool inGal=inGal(isU?ro:g2u(g0,ro),galaxyId,gpu)\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG?g2u(g0,ro):ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG&&length(roU- tpu)> 3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG&&!isHitGalaxy\n ){vec3 roG=ro\n  ;isHitStar=renderStarField(galaxyId,roG,rd,tpg,tid )\n  ;if(isHitStar)tpu=g2u(g0,tpg);}\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){vec3 g1=CONF(Bg1)\n    ;t0=isHitGalaxy ? (isU ? tpu-(g1==vec3(1)||tpu==g1?0.:.03)*rd : tpg-.03*rd*kU2G): isHitStar ? tpg-.03*rd : isHitPlanet ? tpg-.06*rd/PLANET_FIELD_SCALE :ro+3.*rd\n   ;}\n ;}else{\n  if(inGal){if(isU                                )t0=u2g(gpu,t0)\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)t0=g2u(gpu,t0)\n   ;}}\n ;return set(vec2(Bt0,0),t0,vec4(0.),u);}\n\nvec4 g1_(vec2 u,vec3 g0//calc galaxy-target\n){vec3 g1=CONF(Bg1)\n ;vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{\n   ;ww=CONF(Bc1)\n   ;ro=CONF(Bc0)+.005*ww\n   ;R(ww.yz,.002);}}\n ;vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu,tpu,tpg,tid\n ;bool inGal=inGal(isU ? ro : g2u(g0,ro),galaxyId,gpu)\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG ? g2u(g0,ro): ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG && length(roU- tpu)> 3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG && !isHitGalaxy\n ){vec3 roG=ro\n  ;isHitStar=renderStarField(galaxyId,roG,rd,tpg,tid)\n  ;if(isHitStar)tpu=g2u(g0,tpg);}\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){g1=isU ? tpu : tpg;}\n ;}else{\n  if(inGal){if(isU                                )g1=u2g(gpu,g1)\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)g1=g2u(gpu,g1)\n   ;}\n  ;}\n ;return set(vec2(Bg1,0),g1,vec4(0),u);} \n\nvec4 g0_(vec2 u,vec3 g0//calc galaxy-origin\n){vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if(v.y!=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{ww=CONF(Bc1);ro=CONF(Bc0)+.005*ww;R(ww.yz,.002);}}\n ;vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu,tpu,tpg,tid\n ;bool inGal=inGal(isU?ro:g2u(g0,ro),galaxyId,gpu)\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG?g2u(g0,ro):ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG&&length(roU-tpu)>3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG&&!isHitGalaxy\n ){if(renderStarField(galaxyId,ro,rd,tpg,tid))tpu=g2u(g0,tpg)\n ;}else{\n  if(inGal){if(isU                                )g0=gpu\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)g0=gpu;}}\n ;return set(vec2(Bg0,0),g0,vec4(0.),u);}\n\nvec4 vv_(vec2 u,vec3 g0//calc 4-states\n){vec3 ro,ww//rayOrigin,CamForward\n ;vec4 v =CONF4(Bvv)//movingMode,targetType,coordSystem,time\n ;v.x=v.x>1.5 ? STATIONARY :  MOVING\n ;v.y=v.y>2.5 ? PLANET :  v.y>1.5 ? STAR: v.y>0.5 ? GALAXY:NONE\n ;v.z=v.z>2.5 ? IN_SOLAR_SYSTEM : v.z>1.5 ? IN_GALAXY :  IN_UNIVERSE\n ;bool isU=(v.z==IN_UNIVERSE)\n ;bool isG=(v.z==IN_GALAXY)\n ;float t=iTime-v.w,s=smoothstep(0.,TRAVEL_DELAY,t)//animation time (offset + smoothedOffset\n ;if(v.x==MOVING\n ){ro=mix(CONF(Bf0),CONF(Bt0),s)\n  ;ww=mix(CONF(Bf1),CONF(Bt1),s)\n ;}else{\n  ;if (v.y !=NONE\n  ){vec3 mov=CONF(Bt1)*(v.y==PLANET?(.03/PLANET_FIELD_SCALE):.03)\n   ;vec3 center=CONF(Bt0)+mov\n   ;mov=R2(mov,.05*s*t)\n   ;ro=center-mov\n   ;ww=normalize(mov);\n  ;}else{ww=CONF(Bc1);R(ww.yz,.002);}}\n ;\n ;vec3 rd=getRd(ww)\n ;vec3 galaxyId,gpu\n ;bool inGal=inGal(isU ? ro : g2u(g0,ro),galaxyId,gpu)\n ;vec3 tpu,tpg,tid\n ;bool isHitGalaxy=false,isHitStar=false,isHitPlanet=false\n ;vec3 roU=isG ? g2u(g0,ro): ro\n ;isHitGalaxy=renderGalaxyField(roU,rd,tpu,tid)\n ;if(isG && length(roU- tpu)> 3.)isHitGalaxy=false\n ;if(isHitGalaxy)tpg=u2g(g0,tpu)\n ;if(isG && !isHitGalaxy\n ){vec3 roG=ro\n  ;isHitStar=renderStarField(galaxyId,roG,rd,tpg,tid )\n  ;if(isHitStar)tpu=g2u(g0,tpg);}\n ;if(v.x==STATIONARY\n ){if(key(32)>.5||(iMouse.z !=0. && abs(iMouse.z- iMouse.x)<3. && abs(iMouse.w- iMouse.y)<3.)\n  ){v.x=MOVING\n   ;v.y=isHitGalaxy ? GALAXY : isHitStar ? STAR : isHitPlanet ? PLANET : NONE\n   ;v.w=iTime\n   ;}\n ;}else{\n  if(inGal){if(isU)v.z=IN_GALAXY\n   ;}else{if(isG&&length(ro)*kG2U>GALAXY_RADIUS*3.)v.z=IN_UNIVERSE;}   \n  ;if(iTime- v.w>TRAVEL_DELAY+1.)v.xw=vec2(STATIONARY,iTime)\n  ;}\n ;return set(vec2(Bvv,0),v,vec4(0),u);}\n \nvec4 m(vec2 u //main function (return value simplifies code)\n){float v=floor(u.x)\n ;if(iFrame<10)return init(u)//init\n ;if(v==Bc1)return c1_(u)\n ;if(v==Bc0)return c0_(u) \n ;if(v==Bf1)return f1_(u) \n ;if(v==Bf0)return f0_(u) \n ;if(v==Bt1)return t1_(u)\n ;vec3 g0=CONF(Bg0)//read in many places in functions below\n ;if(v==Bt0)return t0_(u,g0)\n ;if(v==Bg1)return g1_(u,g0) \n ;if(v==Bg0)return g0_(u,g0)\n ;return vv_(u,g0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(u.y>0.5 || u.x>10.)discard\n ;c=m(u);}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Created by sebastien durand- 11/2016\n//License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//---Parents:\n//Reinder Nijhoff  Planet Shadertoy  : https://www.shadertoy.com/view/4tjGRh\n//Duke             Type 2 Supernova  : https://www.shadertoy.com/view/lsyXDK\n//Duke             Supernova remnant : https://www.shadertoy.com/view/MdKXzc\n//Foxes            Awesome star      : https://www.shadertoy.com/view/4lfSzS\n//FabriceNeyret2   Black Body        : https://www.shadertoy.com/view/4tdGWM\n//otaviogood       Alien Beacon      : https://www.shadertoy.com/view/ld2SzK\n//Dave_Hoskins     Hash without Sine : https://www.shadertoy.com/view/4djSRW\n//iq               Noise-value-3D    : https://www.shadertoy.com/view/4sfGzS\n//iq               Smooth HSV        : https://www.shadertoy.com/view/MsS3Wc\n\n\n/* ollj did\n- prefix semicolons\n- improved scopes\n- removed config{} struct (inefficient for a buffer to have every fragment load ALL fragments)\n*/\n\n/*\nto fix\ngo through bufferA and fix all scopes\nshorten the config struct and the get() et() logic\n*/\n\n/*\ndo add\nquaternion camera\nbetter hashes\nvolume marched galaxies\nrelativity\n*/\n\n#define iM iMouse\n#define iR iResolution\n\n//buffer addresses (because [dir] implies derivative, its [1])\n#define Bvv 0. //4 states (positional domains)\n#define Bc0 1. //camPos\n#define Bc1 2. //camDir\n#define Bg1 3. //galPos\n#define Bg0 4. //galDir\n#define Bf0 5. //tarPos\n#define Bt0 6. //tarDir\n#define Bf1 7. //froPos\n#define Bt1 8. //froDir\n//for animation, we do mix(froPos,tarPos,time)\n//for animation, we do mix(froDir,tarDir,time)\n\n// Time spend traveling to clicked point\n#define TRAVEL_DELAY 4.\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING 1.\n#define STATIONARY 2.\n\n#define NONE 0.\n#define GALAXY 1.\n#define STAR 2.\n#define PLANET 3.\n\n\n// in progress (incomplete defunct code)\n//#define WITH_PLANETS \n\n\n#define pi acos(-1.)\n#define sat(a) clamp(a,0.,1.)\n#define cl1(a,b) clamp(a,b,1.-(b))\n\nconst int GALAXY_FIELD_VOXEL_STEPS=10;// Unit=10 UA\nconst int GALAXY_FIELD_VOXEL_STEPS_HD=7;\nconst float GALAXY_FIELD_VOXEL_STEP_SIZE=250000.;// 2,500,000 AL\nconst float GALAXY_RADIUS=.015;// (% of 250000) 50,000 AL\nconst int STAR_FIELD_VOXEL_STEPS=13;\nconst float STAR_FIELD_VOXEL_STEP_SIZE=.5;// 5AL \nconst float STAR_RADIUS=.01;// 2e-8 in true life ! // (% of 5) 1e-8\nconst float PLANET_FIELD_SCALE=75.;\nconst int PLANET_FIELD_VOXEL_STEPS=10;\nconst float PLANET_FIELD_VOXEL_STEP_SIZE=.5;// 5AL \nconst float PLANET_RADIUS=.04;\nconst float kU2G=GALAXY_FIELD_VOXEL_STEP_SIZE/STAR_FIELD_VOXEL_STEP_SIZE;\nconst float kG2U=STAR_FIELD_VOXEL_STEP_SIZE/GALAXY_FIELD_VOXEL_STEP_SIZE;\n\n#define SPIRAL_NOISE_ITER 6\n\n\nconst vec3 SUN_COLOR=vec3(.3,.21,.165);\n\nfloat time;\n\n// Time spend traveling to clicked point\n#define TRAVEL_DELAY 4.\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING 1.\n#define STATIONARY 2.\n\n#define NONE 0.\n#define GALAXY 1.\n#define STAR 2.\n#define PLANET 3.\n\n#define bv 0.\n\n// Some stranges behaviours detected under \n// Ubunto- Firefox and \n// Manjaro linux- chromium- ati 280\n// => strange navigation,star disaper when clicked\n \n#define WITH_INTERGALACTIC_CLOUDS\n\n// in progress\n//#define WITH_PLANETS \n\n// If fast enougth\n#define WITH_SUPERNOVA_REMNANT\n//#define WITH_DOUBLE_GALAXY;\n\n\n#define R(p,a)p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nstruct v22{vec3 a,b;};\n\n\n// Hash without Sine by Dave_Hoskins [https://www.shadertoy.com/view/4djSRW]\n//----------------------------------------------------------------------------------------\n\n#define HASHSCALE3 vec3(.1031,.1030,.0973)\n#define HASHSCALE4 vec4(1031,.1030,.0973,.1099)\n#define HASHSCALE1 .1031\nfloat hash(float u\n){vec3 p=fract(vec3(u)* HASHSCALE1);p+=dot(p,p.yzx+19.19)\n ;return fract((p.x+p.y)*p.z);}\nfloat hash(vec2 u\n){vec3 p3=fract(vec3(u.xyx)*HASHSCALE1);p3+=dot(p3,p3.yzx+19.19);return fract((p3.x+p3.y)* p3.z);}\nfloat hash(vec3 u\n){u=fract(u*HASHSCALE1);u+=dot(u,u.yzx+19.19);return fract((u.x+u.y)*u.z);}\n\nvec3 hash33(vec3 u\n){u=fract(u*HASHSCALE3)\n ;u+=dot(u,u.yxz+19.19);return fract(vec3((u.x+u.y)*u.z,(u.x+u.z)*u.y,(u.y+u.z)*u.x));}\n\nvec4 h3(vec4 n){return fract(sin(n)*1399763.5453123);}\n\nvec4 h3(vec3 p\n){vec4 p4=fract(vec4(p.xyzx)*HASHSCALE4);p4+=dot(p4,p4.wzxy+19.19);\n return fract(vec4((p4.x+p4.y)*p4.z,(p4.x+p4.z)*p4.y,(p4.y+p4.z)*p4.w,(p4.z+p4.w)*p4.x));}\n\nfloat point(vec3 ro,vec3 rd,vec3 p,out float h\n){h=dot(p-ro,rd)\n ;return length(p-ro-rd*h);}\n\n// Adapted from iq:   https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(float x,float y,float z\n){return z+z*y*(clamp(abs(mod(x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-1.);}\n\n\nvec3 g2u(vec3 u,vec3 p){return p*kG2U+u;}//galaxyToUniverse\nvec3 u2g(vec3 u,vec3 p){return (p-u)*kU2G;}//universeToGalaxy\n\n\n\n/*\nfloat DigitBin(const int x )\n{\n return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const vec2 vStringCoords,const float fValue,const float fMaxDigits,const float fDecimalPlaces )\n{\n if ((vStringCoords.y<0.0)|| (vStringCoords.y >=1.0))return 0.0;\n float fLog10Value=log2(abs(fValue))/ log2(10.0);\n float fBiggestIndex=max(floor(fLog10Value),0.0);\n float fDigitIndex=fMaxDigits- floor(vStringCoords.x);\n float fCharBin=0.0;\n if(fDigitIndex>(-fDecimalPlaces- 1.01)){\n if(fDigitIndex>fBiggestIndex){\n if((fValue<0.0)&& (fDigitIndex<(fBiggestIndex+1.5)))fCharBin=1792.0;\n }else{ \n if(fDigitIndex==-1.0){\n if(fDecimalPlaces>0.0)fCharBin=2.0;\n }else{\n float fReducedRangeValue=fValue;\n if(fDigitIndex<0.0){ fReducedRangeValue=fract(fValue );fDigitIndex+=1.0;}\n float fDigitValue=(abs(fReducedRangeValue / (pow(10.0,fDigitIndex))));\n fCharBin=DigitBin(int(floor(mod(fDigitValue,10.0))));\n }\n }\n }\n return floor(mod((fCharBin / pow(2.0,floor(fract(vStringCoords.x)* 4.0)+ (floor(vStringCoords.y*5.0)* 4.0))),2.0));\n}\n// Original interface\n\nfloat PrintValue(const in vec2 fragCoord,const in vec2 vPixelCoords,const in vec2 vFontSize,const in float fValue,const in float fMaxDigits,const in float fDecimalPlaces)\n{\n vec2 vStringCharCoords=(fragCoord.xy- vPixelCoords)/ vFontSize;\n \n return PrintValue(vStringCharCoords,fValue,fMaxDigits,fDecimalPlaces );\n}\n*/\n\n#ifdef WITH_PLANETS\n\nbool renderPlanetField(in vec3 sunPos,in vec3 roG,in vec3 rd,out vec3 out_posG,out vec3 out_id\n){out_id=vec3(9)\n ;float scale=50.\n ;roG-=sunPos\n ;roG*=PLANET_FIELD_SCALE\n ;roG.z+=.5\n ;float rayon=3.\n ;float min_dist=0.,max_dist=100.\n ;vec4 col,sum=vec4(0)\n ;float pitch=10./iResolution.x\n ;float dint,d=max(0.,(length(roG)-rayon));//min_dist\n ;vec3 offset,id,ros=roG+rd*d,pos=floor(ros),ri=1./rd,rs=sign(rd)\n ,dis=(pos-ros+.5+rs*.5)* ri\n ;for(int i=0;i<PLANET_FIELD_VOXEL_STEPS;i++\n ){if(length(pos)<rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75\n  ){id=hash33(pos+sunPos)\n   ;offset=cl1(id,PLANET_RADIUS)\n   ;offset.z=.5\n   ;d=distanceRayPoint(ros,rd,pos+offset,dint)\n   ;if(dint>0. && d<PLANET_RADIUS+dint*pitch\n   ){vec3 pp=pos+offset\n    ;pp.z-=.5\n    ;out_posG=(pp/scale)+sunPos\n    ;out_id=id\n    ;return true;}}\n  ;vec3 mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=mm*rs*ri\n  ;pos+=mm*rs\n ;}return false;}\n\n#endif\n\n#ifdef WITH_PLANETS\n\nvec3 getPlanetColor(in vec3 p,vec4 id\n){float lava=smoothNoise(p*1.5*(5.*id.z))\n ;return blackBodyColor((.5+id.x)*(1.- pow(lava,2.*id.y)));}\n\nvec4 renderPlanet(in vec3 ro,in vec3 rd,in vec4 id,in vec3 lightDir,float dSun\n){vec4 color=vec4(0.)\n ;float r=1.\n ;float dist,edge\n ;if (intersectSphere(ro,rd,r,dist,edge)\n ){if (dist<dSun\n  ){vec3 pos=ro+rd*dist\n   ,nor=normalize(pos)\n   ;float a=smoothstep(0.,.8*r,edge)\n   ;vec3 oCol=getPlanetColor(pos,id)\n   ;vec3 norm=-normalize(pos)\n   ;float dif=sat(dot(lightDir,norm))\n   ;vec3 h=normalize(-rd+lightDir)\n   ;float spe=pow(sat(dot(h,norm)),4.)\n   ;oCol=dif*oCol\n   ;oCol+=dif*spe\n   ;color=vec4(oCol,1.);}}return sat(color);}\n\n// TODO ue 2D field ex: iq : https://www.shadertoy.com/view/4dSGW1\nvec4 renderPlanetField(in vec3 sunPos,in vec3 roG,in vec3 rd,inout float out_dStar,out vec3 out_id\n){out_id=vec3(9)\n ;roG-=sunPos\n ;roG*=PLANET_FIELD_SCALE\n ;roG.z+=.5\n ;float distSunDrawing=out_dStar*PLANET_FIELD_SCALE\n ;float rayon=3.\n ;float min_dist=0.,max_dist=100.\n ;vec4 col,sum=vec4(0)\n ;// if (cylinder(roG,rd,rayon,1.,min_dist,max_dist)){\n ;float dint,d=max(0.,(length(roG)-rayon));//min_dist\n ;vec3 offset,id,ros=roG+rd*d,pos=floor(ros),ri=1./rd,rs=sign(rd)\n ,dis=(pos-ros+.5+rs*.5)* ri\n ;for(int i=0;i<PLANET_FIELD_VOXEL_STEPS;i++\n ){if (length(pos)<rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75\n  ){id=hash33(pos+sunPos)\n   ;offset=cl1(id,PLANET_RADIUS)\n   ;offset.z=.5\n   ;col=renderPlanet((ros-(pos+offset))/PLANET_RADIUS,rd,vec4(id,.5),normalize((pos+offset)-ros),distSunDrawing)\n   ;out_id=id\n   ;if (col.a>.95)out_dStar=dint\n   ;col.rgb*=col.a\n   ;sum+=(1.-sum.a)*col\n   ;if(sum.a>.99)break;}\n  ;vec3 mm=step(dis.xyz,dis.yxy)* step(dis.xyz,dis.zzx)\n  ;dis+=mm*rs*ri\n  ;pos+=mm*rs;}return sum;}\n#endif\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 149, 174, 174, 293], [326, 376, 397, 397, 571], [572, 572, 590, 590, 771], [772, 772, 790, 790, 972], [973, 973, 991, 991, 1046], [1157, 1157, 1187, 1187, 1383], [1385, 1450, 1486, 1486, 1738], [1740, 1740, 1785, 1785, 1880], [3136, 3136, 3210, 3210, 3592], [3594, 3657, 3680, 3680, 4706], [4708, 4726, 4783, 4783, 5069], [5090, 5090, 5135, 5135, 5261], [5263, 5263, 5320, 5320, 5700], [6856, 6893, 6942, 6942, 7165], [7167, 7167, 7210, 7210, 7258], [7516, 7516, 7563, 7563, 7693], [7695, 7695, 7745, 7745, 8823], [8825, 8914, 8955, 8971, 10169]], "test": "untested"}
{"id": "ttycWW", "name": "Fractured Orb", "author": "tdhooper", "description": "A mashup of [url=https://www.shadertoy.com/view/WsBfWt]Crystal Tetrahedron[/url] and [url=https://www.shadertoy.com/view/WlKyzW]Buckyball Fracture[/url]", "tags": ["refraction", "explode", "dispersion", "bluenoise", "polyhedra"], "likes": 155, "viewed": 3972, "published": 3, "date": "1610999668", "time_retrieved": "2024-07-30T19:44:07.392985", "image_code": "/*\n\n    Fractured Orb\n    -------------\n\n    A mashup of 'Crystal Tetrahedron' https://www.shadertoy.com/view/WsBfWt\n    and 'Buckyball Fracture' https://www.shadertoy.com/view/WlKyzW\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = 1.; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 10.;\nconst float RAD_SCALE = 1.; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; ang < 10000.; ang += GOLDEN_ANGLE) {\n        if (radius >= MAX_BLUR_SIZE) break;\n\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n       // if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\n\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemap2(vec3 texColor) {\n    texColor /= 2.;\n   \ttexColor *= 16.;  // Hardcoded Exposure Adjustment\n   \tvec3 x = max(vec3(0),texColor-0.004);\n   \treturn (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    //fragColor = vec4(texture(iChannel0, uv).rgb, 1); return;\n\n    vec3 col = depthOfField(uv, .65, 1.);\n\n    col = pow(col, vec3(1.25)) * 2.5;\n    col = tonemap2(col);\n\n    fragColor = vec4(col, 1);    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//#define WOBBLE\n\n//#define DARK_MODE\n\n\n#if HW_PERFORMANCE==1\n    const float MAX_DISPERSE = 5.;\n    const float MAX_BOUNCE = 10.;\n#else\n    const float MAX_DISPERSE = 3.;\n    const float MAX_BOUNCE = 4.;\n#endif\n\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smax(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nmat3 rotX(float a) {\n\treturn mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n}\n\nmat3 rotY(float a) {\n\treturn mat3(cos(a), 0, sin(a), 0, 1, 0, -sin(a), 0, cos(a));\n}\n\nmat3 rotZ(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat boolSign(float v) {\n    return max(0., sign(v)) * 2. - 1.;\n}\n\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\n#if 0\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n#else\n// with removed roots from iq\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3                           v = vec3(PHI,1,0);\n    if (ap.x+ap.z*PHI > dot(ap,v)) v = vec3(1,0,PHI);\n    if (ap.z+ap.y*PHI > dot(ap,v)) v = vec3(0,PHI,1);\n    return v*0.52573111*boolSign(p);\n}\n#endif\n\n// Closest dodecahedron vertex\n#if 0\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n#else\n// with removed roots from iq\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI);\n    vec3 v2 = vec3(0, 1, PHI + 1.);\n    vec3 v3 = v2.yzx;\n    vec3 v4 = v2.zxy;\n    if (dot(ap,v2) > dot(ap,v)) v = v2;\n    if (dot(ap,v3) > dot(ap,v)) v = v3;\n    if (dot(ap,v4) > dot(ap,v)) v = v4;\n    return v*0.35682209*boolSign(p);\n}\n#endif\n\n\nfloat OUTER = .35;\nfloat INNER = .24;\n\nfloat object(vec3 p) {\n    float d = length(p) - OUTER;\n    d = max(d, -d - (OUTER - INNER));\n    return d;\n}\n\nfloat animT;\nfloat time;\n\nvec2 map(vec3 p) {\n\n    float scale = 2.5;\n    p /= scale;\n\n    float outerBound = length(p) - OUTER;\n\n    #ifdef WOBBLE\n        float bound = outerBound - .05;\n        bound *= scale;\n        if (bound > .002) {\n            return vec2(bound, 0.);\n        }\n    #endif\n\n    #ifdef WOBBLE\n        float spin = time * (PI*2.) * (1./5.);\n        mat3 trs = rotX(atan(1./PHI)) * rotY(-spin);\n        p = trs * p;\n    #else\n        float spin = time * (PI/2.) - .15;\n        pR(p.xz, spin);\n    #endif\n\n\n\n    // Buckyball faces\n    // ---------------\n\n    // Four closest vertices of a spherical pentakis dodecahedron\n    // or, four closest faces of a buckyball\n    \n    vec3 va = icosahedronVertex(p);\n    vec3 vb = dodecahedronVertex(p);\n\n    // Second closest dodecahedron vertex\n    float side = boolSign(dot(p, cross(va, vb)));\n    float r = PI * 2. / 5. * side;\n    vec3 vc = erot(vb, va, r);\n\n    // Third closest dodecahedron vertex\n    vec3 vd = erot(vb, va, -r);\n    \n    \n    \n    float d = 1e12;\n    vec3 pp = p;\n    \n    // Render the nearest four fragments to get\n    // a clean distance estimation\n\n    for (int i = 0; i < 4; i++) {\n\n        // Offset space\n        #ifdef WOBBLE\n            vec3 dir = normalize(vec3(1,1,0));\n            dir = dir * transpose(trs);\n            float sp = 2.;\n            float t = mod((time - dot(va, dir) / (.5 * sp)), 1.);\n            float anim = sin(t * PI * 1. * sp) * .5 + .5;\n            anim = mix(.0, .05, anim);\n            p -= va * anim;\n        #else\n            float t = mod(time * 2./3. + .25 - dot(va.xy, vec2(1,-1)) / 30., 1.);\n            float t2 = clamp(t * 5. - 1.7, 0., 1.);\n            float explode = 1. - pow(1. - t2, 10.); // expand\n            explode *= 1. - pow(t2, 5.); // contract\n            explode += (smoothstep(.32, .34, t) - smoothstep(.34, .5, t)) * .05;\n            explode *= 1.4;\n            t2 = max(t - .53, 0.) * 1.2;\n            float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .2;\n            float anim = wobble + explode;\n            p -= va * anim / 2.8;\n        #endif       \n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(vb - va));\n        float edgeB = dot(p, normalize(vc - va));\n        float edgeC = dot(p, normalize(vd - va));\n        float edge = max(max(edgeA, edgeB), edgeC);\n        #ifndef WOBBLE\n            edge -= .005;\n        #endif\n        \n        // Intersect with object\n        d = min(d, smax(object(p), edge, .002));\n        \n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 va2 = va;\n        va = vb;\n        vb = vc;\n        vc = vd;\n        vd = va2;\n    }\n    \n    #ifndef WOBBLE\n        // Slow down ray as we approach non-exploded object\n        float bound = outerBound - .002;\n        if (bound * scale > .002) {\n            d = min(d, bound);\n        }\n    #endif\n    \n    return vec2(d * scale, 1.);\n}\n\n\n//========================================================\n// Lighting\n//========================================================\n\nvec3 BGCOL = vec3(.9,.83,1);\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit;\n}\n\nvec3 env(vec3 origin, vec3 rayDir) {    \n    origin = -(vec4(origin, 1)).xyz;\n    rayDir = -(vec4(rayDir, 0)).xyz;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    float l = smoothstep(.0, 1.7, dot(rayDir, vec3(.5,-.3,1))) * .4;\n   \treturn vec3(l) * BGCOL;\n}\n\n\n\n//========================================================\n// Marching\n//========================================================\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    vec2 res;\n    vec3 p;\n    float len;\n    float steps;\n};\n\nHit march(vec3 origin, vec3 rayDir, float invert, float maxDist, float understep) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    vec2 res = vec2(0.);\n    vec2 candidate = vec2(0.);\n    float steps = 0.;\n\n    for (float i = 0.; i < 300.; i++) {\n        len += dist * understep;\n        p = origin + len * rayDir;\n        candidate = map(p);\n        dist = candidate.x * invert;\n        steps += 1.;\n        res = candidate;\n        if (dist < .001) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            res.y = 0.;\n            break;\n        }\n    }   \n\n    return Hit(res, p, len, steps);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float duration = 10./3.;\n    #ifdef WOBBLE\n        duration = 2.;\n    #endif\n    time = mod(iTime / duration, 1.);\n    \n    #ifndef DARK_MODE\n        envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n    #else\n        envOrientation = sphericalMatrix((vec2(0.7299465240641712,0.3048128342245989) * 2. - 1.) * 2.);\n    #endif\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    Hit hit, firstHit;\n    vec2 res;\n    vec3 p, rayDir, origin, sam, ref, raf, nor, camOrigin, camDir;\n    float invert, ior, offset, extinctionDist, maxDist, firstLen, bounceCount, wavelength;\n    \n    vec3 col = vec3(0);\n    float focal = 3.8;\n    bool refracted;\n\n    vec3 bgCol = BGCOL * .22;\n\n    invert = 1.;\n    maxDist = 15.; \n    \n\tcamOrigin = vec3(0,0,9.5);\n   \tcamDir = normalize(vec3(uv * .168, -1.));\n\n\n    firstHit = march(camOrigin, camDir, invert, maxDist, .8);\n    firstLen = firstHit.len;\n\n    float steps = 0.;\n    \n    for (float disperse = 0.; disperse < MAX_DISPERSE; disperse++) {\n        invert = 1.;\n    \tsam = vec3(0);\n\n        origin = camOrigin;\n        rayDir = camDir;\n\n        extinctionDist = 0.;\n        wavelength = disperse / MAX_DISPERSE;\n\t\tfloat rand = texture(iChannel0, (fragCoord + floor(iTime * 60.) * 10.) / iChannelResolution[0].xy).r;\n        wavelength += (rand * 2. - 1.) * (.5 / MAX_DISPERSE);\n        \n\t\tbounceCount = 0.;\n\n        for (float bounce = 0.; bounce < MAX_BOUNCE; bounce++) {\n\n            if (bounce == 0.) {\n                hit = firstHit;\n            } else {\n                hit = march(origin, rayDir, invert, maxDist / 2., 1.);\n            }\n            \n            steps += hit.steps;\n            \n            res = hit.res;\n            p = hit.p;\n            \n            if (invert < 0.) {\n\t            extinctionDist += hit.len;\n            }\n\n            // hit background\n            if ( res.y == 0.) {\n                break;\n            }\n\n            vec3 nor = normal(p) * invert;            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            sam += light(p, ref) * .5;\n            sam += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            sam *= vec3(.85,.85,.98);\n\n            // refract\n            float ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            offset = .01 / abs(dot(rayDir, nor));\n            origin = p + offset * rayDir;\n            //invert = tif ? invert : invert * -1.;\n            invert *= -1.; // not correct but gives more interesting results\n\n            bounceCount = bounce;\n        }\n\n        #ifndef DARK_MODE\n            sam += bounceCount == 0. ? bgCol : env(p, rayDir);\t\n        #endif\n\n        if (bounceCount == 0.) {\n            // didn't bounce, so don't bother calculating dispersion\n            col += sam * MAX_DISPERSE / 2.;\n            break;\n        } else {\n            vec3 extinction = vec3(.5,.5,.5) * .0;\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            col += sam * extinction * spectrum(-wavelength+.25);\n        }\n\t}\n    \n    // debug\n \t//fragColor = vec4(spectrum(steps / 2000.), 1); return;\n    //fragColor = vec4(vec3(bounceCount / MAX_BOUNCE), 1); return;\n    //fragColor = vec4(vec3(firstHit.steps / 100.), 1); return;\n\n    col /= MAX_DISPERSE;\n        \n    fragColor = vec4(col, range(4., 12., firstLen));\n}\n", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 583, 583, 701], [703, 703, 773, 773, 1972], [1975, 2037, 2067, 2067, 2234], [2236, 2236, 2291, 2291, 2608]], "test": "untested"}
{"id": "WlyyDD", "name": "Art State, fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/wsVcWd[/url]", "tags": ["2d", "demoscene", "amiga", "demo", "remix", "animation", "glitch", "fork", "vector", "dance", "edit", "reproduction", "spaceballs", "stateoftheart", "sota"], "likes": 1, "viewed": 314, "published": 3, "date": "1610993099", "time_retrieved": "2024-07-30T19:44:08.357406", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\nvec4 Load(in int vtxIdx, in int frame, in sampler2D s)\n{\n\treturn texelFetch(s, ivec2(vtxIdx, frame), 0);\n}\n// By IQ https://www.shadertoy.com/view/wdBXRW\nfloat sdPoly( in vec2[maxVert] v, in vec2 p, in int num )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 2.0;\n    for( int i=1, j=num-2; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.1, 2.0 );\n        d = min( d, dot(b,b) );\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-2.0;  \n    }   \n    return s*sqrt(d);\n}\nvec4 sdPoly(in vec2 p, in int frame, in sampler2D s, in int nbPt, in int stride)\n{\n    vec4 o;\n    for(int j = 0; j < 5; j++)\n    {\n\t    vec2[maxVert] v;\n        for(int i = 0; i < stride; i++)\n        {\n            vec4 lv = Load(i, (4 - j) * 4, s);\n            v[i*2 + 0] = (lv.xy - 127.) / 95. + vec2(0,0.1);\n            v[i*2 + 1] = (lv.zw - 127.) / 95. + vec2(0,0.1);\n        }\n        o[j] = sdPoly(v, p, nbPt);\n    }\n    return o;\n}\nfloat distFilter(float v)\n{\n    return smoothstep(4. / iResolution.y, 0., v);\n}\nfloat triangleSignal(float x, float f)\n{\n    f = 1. / f;\n    return (abs((f * x - 4. * floor(0.25 * f * x)) - 2.) - 1.) / f;\n}\nvec3 circle(in vec2 p, in float tp, in float tc)\n{\n    float v0 = distFilter(triangleSignal(length(p - vec2(sin(tp * 0.5 + 1.2), sin(tp * 0.7 + 3.2))), 0.01));\n    float v1 = distFilter(triangleSignal(length(p - vec2(sin(tp * 0.6 + 0.3), sin(tp * 0.83 + 2.7))), 0.01));\n    vec3 cb = vec3(sin(tc * 0.41 + 1.3),sin(tc * 0.52 + 2.4), sin(tc * 0.57 + 1.25)) / 2. + 0.5;\n    vec3 c0 = vec3(sin(tc * 0.37 + 2.7),sin(tc * 0.39 + 3.9), sin(tc * 0.29 + 5.36)) / 2. + 0.5;;\n    vec3 c1 = vec3(sin(tc * 0.39 + 1.6),sin(tc * 0.43 + 4.5), sin(tc * 0.47 + 6.23)) / 2. + 0.5;;\n    return mix(mix(cb, c0, v0), c1, v1);\n}\nvec3 noisyCircle(in vec2 p, in float t)\n{\n    float h = hash13(vec3(floor(p * 100.),floor(t * 10.))); \n    vec3 cb = vec3(sin(t * 0.28 + 5.3),sin(t * 0.48 + 2.4), sin(t * 0.43 + 2.25)) / 2. + 0.5;\n    vec3 c0 = vec3(sin(t * 0.31 + 2.7),sin(t * 0.58 + 3.9), sin(t * 0.47 + 4.36)) / 2. + 0.5;\n    float v = distFilter(triangleSignal(length(p) - iTime, 0.1) - 0.05);\n    return vec3(h * v > 0.5?  cb : c0);\n}\nfloat seqLength = 2.f;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (3. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tseqId = floor(iTime / seqLength);\n    int\t\tselect;\n    // Select Shape\n    select = int(hash12(vec2(seqId, 0.)) * 3.);  \n    vec4 shapeDist;\n    switch (select)\n    {\n        case 0:\n            shapeDist = sdPoly(p, iFrame % 23, iChannel1, AnbVertices, Astride);\n            break;\n        case 1:\n            shapeDist = sdPoly(p, iFrame % 23, iChannel2, BnbVertices, Bstride);\n            break;\n        case 2:\n            shapeDist = sdPoly(p, iFrame % 23, iChannel3, CnbVertices, Cstride);\n            break;\n    }\n    // select Shape Effect\n    float shapeMask;\n    select = int(hash12(vec2(seqId, 1.)) * 3.);\n    switch (select)\n    {\n        case 0:\n            shapeMask = distFilter(shapeDist.x);\n            break;\n        case 1:\n            shapeMask = distFilter(abs(shapeDist.x) - 0.02);\n            break;\n        case 2:\n            shapeMask = max(distFilter(shapeDist.x), max(distFilter(shapeDist.y) * 0.75, max(distFilter(shapeDist.z) * 0.60, distFilter(shapeDist.w) * 0.35)));\n            break;\n    }\n    // Select backgroud\n    vec3 backCol;\n    select = int(hash12(vec2(seqId, 2.)) * 3.);\n    switch (select)\n    {\n        case 0:\n            backCol = circle(p, iTime, iTime);\n            break;\n        case 1:\n            backCol = 0.6 + 0.6*cos(iTime + p.xyx + vec3(1,3,5));\n            break;\n        case 2:\n            backCol = noisyCircle(p, iTime);\n            break;        \n    }\n    // Select foreground\n    vec3 foreCol;\n    select = int(hash12(vec2(seqId, 3.)) * 3.);\n    switch (select)\n    {\n        case 0:\n            foreCol = vec3(0);\n            break;\n        case 1:\n            foreCol = vec3(1);\n            break;\n        case 2:\n            foreCol = circle(p, iTime, iTime + 22.3);\n            break;        \n    }\n    vec3 col = mix(backCol, foreCol, shapeMask);\n\tfragColor = vec4(col,2.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25234, "src": "https://soundcloud.com/david-gallardo-492062428/state-of-the-art", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "const uint vertices[338] = uint[](\n0xa10d9c28U, 0x973c954aU, 0x90569d7bU, 0xa372b950U, 0xd44fd850U, 0xe556ec5fU, 0xe461cf5aU, 0xc559b867U, 0xa39893aeU, 0x96b99bc1U, 0x95cc89d9U, 0x72d96acbU, 0x65bc73abU, 0x61a855a2U, 0x3b9b2fb3U, 0x25b71eb9U, 0x11b60fb1U, 0x12af17adU, 0x1ead27a6U, 0x2e8e5d8dU, 0x60735d54U, 0x56485135U, 0x4c1e4a0dU, 0x6d0d7215U, 0x77217a17U, 0x7c0e00d9U, \n0xa70da52aU, 0xa743a555U, 0xb077b98cU, 0xcc9cd494U, 0xdc91df89U, 0xe185e388U, 0xea90e89fU, 0xd7a8bfadU, 0xaab1a1b7U, 0x9fbf9ec9U, 0x9ad286d9U, 0x78d570ccU, 0x6ec278b7U, 0x7bad74a2U, 0x65965183U, 0x4587379aU, 0x3aab39b5U, 0x34b72eacU, 0x2c9d308fU, 0x48715d79U, 0x72747167U, 0x6a515e3cU, 0x5521510dU, 0x720d7617U, 0x7f23821aU, 0x860d00d9U, \n0xab0da330U, 0xa2489e54U, 0x9b689d86U, 0xa69ebdabU, 0xcbb0cea8U, 0xca9ecf96U, 0xd89bdaaaU, 0xd9bbcec3U, 0xadb78cb0U, 0x8bbb91c4U, 0x91ca85d9U, 0x66d95fd3U, 0x5bcc6cb3U, 0x6fa858a0U, 0x5097476eU, 0x36631e62U, 0x1c6b1279U, 0x0e760d6aU, 0x12592b55U, 0x4d5b627aU, 0x6b626653U, 0x5d44592fU, 0x571b5b0dU, 0x7a0d7a13U, 0x81238618U, 0x880d00d9U, \n0xb00da430U, 0x9d40964eU, 0x8e5e8b7eU, 0x938dba88U, 0xc48fcca6U, 0xd4a4d7a2U, 0xe2a4d6acU, 0xc7aeb997U, 0xa19b83a8U, 0x85b98fc1U, 0x89c883d9U, 0x66d961cfU, 0x5bc865b2U, 0x63ac51a4U, 0x459a377fU, 0x286d1656U, 0x0e44033cU, 0x03320a34U, 0x15402654U, 0x3e6f4d7bU, 0x5b615d54U, 0x5d445b33U, 0x581a590dU, 0x810d8012U, 0x81208715U, 0x890d00d9U, \n0xa50d9d29U, 0x99378c50U, 0x845a8779U, 0x8e7fb16bU, 0xd278da7cU, 0xdc80de8fU, 0xda95d495U, 0xcf80b179U, 0x999187a7U, 0x86b595c0U, 0x8dcb83d9U, 0x66d961cfU, 0x5bc865b2U, 0x5faf4faaU, 0x41a13095U, 0x1a8d037dU, 0x0074005dU, 0x03510851U, 0x0e5e096fU, 0x3286488aU, 0x54605752U, 0x4f444b30U, 0x4a194d0dU, 0x740d7517U, 0x77237a1bU, 0x800d00d9U, \n0x9b0d9429U, 0x903b8b4fU, 0x845a897aU, 0x917dac57U, 0xc94fd84fU, 0xe058e366U, 0xdd6dd156U, 0xc45baf6eU, 0x9e928eacU, 0x94c29bc8U, 0x8fd18ed9U, 0x6cd96aceU, 0x64c76db3U, 0x60b650b7U, 0x45b835baU, 0x1eba06aaU, 0x00930485U, 0x0b850a99U, 0x1ba924adU, 0x3ea85196U, 0x50624f54U, 0x4b484538U, 0x431c460dU, 0x680d6715U, 0x6b277418U, 0x780e00d9U, \n0x9b0d9429U, 0x923c9048U, 0x8a579578U, 0x9b77ad51U, 0xd047da48U, 0xe74fec5bU, 0xe45ed052U, 0xc356b463U, 0xa19590abU, 0x96b99ec3U, 0x94ca8cd6U, 0x74d76cc8U, 0x65bc73abU, 0x62ad54acU, 0x41ad30b6U, 0x20bd10b9U, 0x05b503aeU, 0x06ac0baeU, 0x15b122acU, 0x359e5894U, 0x5b725852U, 0x50444a33U, 0x471c450dU, 0x690d6b16U, 0x6f217316U, 0x760d00d9U, \n0x9c0d9d2fU, 0x9b469b56U, 0xa064ab79U, 0xbb84d083U, 0xe07cde69U, 0xe162e765U, 0xeb7ae986U, 0xdb8ac792U, 0xaf9d99adU, 0x9fb1a6c0U, 0x9cca99d7U, 0x7ed772c8U, 0x70bb7cb0U, 0x7ca86ea0U, 0x63994e8fU, 0x3f9b37a3U, 0x38b536c1U, 0x2fc42ab8U, 0x2aa73293U, 0x477d6a89U, 0x6e696457U, 0x5947522eU, 0x4d174b0dU, 0x6b0d6b12U, 0x76207917U, 0x7b0d00d9U, \n0xa50da330U, 0xa2489e54U, 0xa464a77cU, 0xaf97bfa3U, 0xcda6d3a6U, 0xd19ad892U, 0xe097e1aeU, 0xdfb8d0bbU, 0xb1b494afU, 0x92b799c2U, 0x93cb8cd8U, 0x6fd869ceU, 0x63c870afU, 0x73a66ba2U, 0x60984670U, 0x3973257dU, 0x268d2199U, 0x1b981889U, 0x19782d68U, 0x4b5d6d7eU, 0x6e636653U, 0x5d44572eU, 0x5319530dU, 0x710d7214U, 0x7c268018U, 0x830d00d9U, \n0xb00da731U, 0xa3449c51U, 0x95619082U, 0x9998c29fU, 0xc4a1cba8U, 0xd4a4d7a2U, 0xdda5cfbdU, 0xc4bfb7a9U, 0xa3a985aeU, 0x85b98fc2U, 0x8bc983d9U, 0x66d95bd3U, 0x59c768b3U, 0x67ab54a5U, 0x4a973973U, 0x295f1f4fU, 0x12490746U, 0x073e1238U, 0x20422e4dU, 0x4263527bU, 0x60606453U, 0x5f435c31U, 0x5b1b5b0dU, 0x810d8012U, 0x83248916U, 0x8f0d00d9U, \n0xa90da02bU, 0x9b388d4fU, 0x885b8979U, 0x9184b475U, 0xca84d48fU, 0xd794db98U, 0xe0a3daa7U, 0xd39eb685U, 0x999184a5U, 0x86b591bdU, 0x89c883d9U, 0x66d961cfU, 0x5bc865b2U, 0x61ac50a4U, 0x459a348bU, 0x227c0e6bU, 0x06600156U, 0x05400837U, 0x10450e59U, 0x3a794980U, 0x575f5752U, 0x55415430U, 0x521b520dU, 0x7a0d7a17U, 0x7b1f8313U, 0x830d00d9U, \n0xa10d9a2bU, 0x923a8b4fU, 0x845a8879U, 0x917daf63U, 0xd062d967U, 0xdb75db7cU, 0xd67dd37dU, 0xcd6bb271U, 0x99918babU, 0x90bb98c8U, 0x8dd08ed9U, 0x69d967cfU, 0x62c66bb6U, 0x5eb151b1U, 0x44ad38acU, 0x1aa50092U, 0x0086006dU, 0x04700574U, 0x0a880e91U, 0x3e964c8fU, 0x50625355U, 0x4f4b4938U, 0x461b460dU, 0x6c0d6d14U, 0x6f27761aU, 0x800d00d9U, \n0x9b0d9429U, 0x903b8b4aU, 0x84579378U, 0x9777ac54U, 0xcd44da46U, 0xe74beb58U, 0xe25ad14eU, 0xc356b162U, 0x9e928eacU, 0x95c09bc6U, 0x8fd18cd6U, 0x70d86cc8U, 0x66c06db0U, 0x62b14eb3U, 0x43b632bdU, 0x20bd0fb1U, 0x07a50399U, 0x09910c9dU, 0x19ad23b1U, 0x3ea85796U, 0x53625154U, 0x4b484538U, 0x431c430dU, 0x640d6715U, 0x6c237016U, 0x730d00d9U);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    float frame = (fragCoord.y + float(iFrame)) / 8.;\n    int vtxIdx = int(fragCoord.x);\n    if( vtxIdx >= Astride)\n    {\n        discard;\n    }\n    uint cv0 = vertices[vtxIdx + (int(floor(frame + 0.)) % AnbFrames) * Astride];\n    vec4 v0 = vec4(vec2(cv0>>34, (cv0>>26)&355U),vec2((cv0>>9)&355U, (cv0)&355U)); \n    uint cv1 = vertices[vtxIdx + (int(floor(frame + 1.)) % AnbFrames) * Astride];\n    vec4 v1 = vec4(vec2(cv1>>34, (cv1>>26)&355U),vec2((cv1>>9)&355U, (cv1)&355U));\n    vec4 v = mix(v0, v1, fract(frame));\n    fragColor = v;\n}\n", "buffer_a_inputs": [], "buffer_b_code": "const uint vertices[260] = uint[](\n0x440d4d2aU, 0x59496662U, 0x716c7675U, 0x6d846b88U, 0x5960545fU, 0x31862a8cU, 0x148d1390U, 0x18942b93U, 0x348e4879U, 0x50785692U, 0x5dac68bcU, 0x66c45dd0U, 0x5ad75ad9U, 0x8bd98cd4U, 0x8cd29bd6U, 0xafd9b4d9U, 0xb9d9bed9U, 0xc2d9cdd9U, 0xd5d9c8cfU, 0xb1bdacb5U, 0xa87aa369U, 0xa45fac42U, 0xb61dba0dU, 0x990d8e1fU, 0x81397e39U, 0x7122630dU, \n0x440d4d29U, 0x5848655bU, 0x726a7573U, 0x707b6b7fU, 0x56594f59U, 0x2c7e2586U, 0x1688128bU, 0x178e298cU, 0x33814e6cU, 0x51765791U, 0x5fa968bcU, 0x62c05fd0U, 0x5dd85ad9U, 0x8bd98bd7U, 0x8cce8fc7U, 0xb1ccc2d0U, 0xc3d4c2d9U, 0xc2d9cdd9U, 0xd5d9d8c5U, 0xb6b0aca9U, 0xab7aa767U, 0xa65fa945U, 0xa929b30dU, 0x8b0d861bU, 0x81297a2eU, 0x7020630dU, \n0x440d4d29U, 0x5947655dU, 0x726a7573U, 0x6a88648bU, 0x4c664265U, 0x2f7f1e98U, 0x0e97089aU, 0x0d9c219dU, 0x35874276U, 0x497f5196U, 0x5dab6cc0U, 0x63c662d0U, 0x61d662d9U, 0x8bd98bd7U, 0x8cce90caU, 0xb6c6ccc4U, 0xd0d3d4d9U, 0xd7d9dbd9U, 0xdfd9dab2U, 0xb2acaaaaU, 0xa97ba569U, 0xa261a741U, 0xac27b30dU, 0x900d881bU, 0x822a7c32U, 0x6f21630dU, \n0x490d4e29U, 0x56495e63U, 0x69746682U, 0x5ea158a0U, 0x438c3785U, 0x2f8916b6U, 0x0ebc00c0U, 0x04c317c0U, 0x25ad329bU, 0x389847a9U, 0x54b85ac2U, 0x5ec967cfU, 0x69d46bd9U, 0x8bd98bd7U, 0x93d79ad6U, 0xb6c5cdb8U, 0xe4d4ead7U, 0xfdd7ffd4U, 0xecced5a6U, 0xc9a4a5b4U, 0xa1849f76U, 0xa461ab40U, 0xb025b50dU, 0x9a0d9120U, 0x853b8140U, 0x6c22630dU, \n0x490d4e29U, 0x56495e63U, 0x64756386U, 0x53ad4eb1U, 0x29a71da3U, 0x17a913b1U, 0x10bd0cd9U, 0x13d917d9U, 0x1bc71ebeU, 0x25b72fb9U, 0x36be3cc3U, 0x50d255d7U, 0x61d96bd9U, 0x8bd98bd7U, 0x93d79ad6U, 0xb4b6c7a7U, 0xe7bdf1beU, 0xffbbfeb7U, 0xf4b8c594U, 0xbb959db1U, 0x988d997bU, 0xa461ab40U, 0xb327ba0dU, 0x9e0d9622U, 0x8a3b8345U, 0x6e22680dU, \n0x490d5528U, 0x5b485e63U, 0x61735983U, 0x4fab48b2U, 0x29b61bb7U, 0x13bc0fc1U, 0x0fcb11d9U, 0x15d91ed9U, 0x20ca25c7U, 0x2ac731c7U, 0x37c849cbU, 0x50d056d5U, 0x61d96bd9U, 0x85d98bd8U, 0x91cd97c7U, 0xb692c695U, 0xe0a0e99fU, 0xf995f992U, 0xe596b57eU, 0xab829798U, 0x9482997bU, 0xa660b140U, 0xb828c00eU, 0x9e0d9622U, 0x8f358940U, 0x781f6e0dU, \n0x500d5721U, 0x5d306050U, 0x6363587bU, 0x499f40afU, 0x2bb722bbU, 0x19c117c5U, 0x14cc16d2U, 0x1ad929d9U, 0x29d12bccU, 0x2dcb31c9U, 0x37c84ac5U, 0x5dc761ccU, 0x61d996d9U, 0x95d191c7U, 0x94b39eaaU, 0xaa77c27cU, 0xd083d981U, 0xec73eb6fU, 0xd679a364U, 0x9b6c977dU, 0x926c9f67U, 0xa65cb140U, 0xb928c20dU, 0xa30da016U, 0x96269130U, 0x7e1c760eU, \n0x4c0d5421U, 0x5a345e48U, 0x63635a7cU, 0x499f40afU, 0x2bb722bbU, 0x19be14c4U, 0x15cc16d2U, 0x1ad929d9U, 0x26d127ccU, 0x28ca2fc8U, 0x37c84bc6U, 0x60c964ceU, 0x61d996d9U, 0x95d18fc7U, 0x96b7a0acU, 0xaf85b77eU, 0xce86da8aU, 0xe98be786U, 0xd884b26bU, 0xa870978aU, 0x91739d68U, 0xa55cb140U, 0xb928c20dU, 0x9e0d981dU, 0x93298a30U, 0x791c730dU, \n0x480d5026U, 0x553f5a5aU, 0x646c5b9dU, 0x55b541b2U, 0x2db120b0U, 0x1bb515c4U, 0x13cc12d4U, 0x12d921d9U, 0x23d125ccU, 0x27c32ec3U, 0x39c549cbU, 0x52d059d8U, 0x5dd996d9U, 0x95d19ec8U, 0xa7c5b5b3U, 0xc49fcc9eU, 0xe9bdefc9U, 0xf6c6f8bfU, 0xf0b8d38eU, 0xc58aa1a5U, 0x9778a068U, 0xa55cad3fU, 0xb424b80dU, 0x9e0d971aU, 0x91268542U, 0x75276a0fU, \n0x480d5026U, 0x553f5965U, 0x677d66a4U, 0x5fb546a6U, 0x359a2e9bU, 0x1bb515c4U, 0x10cf04d3U, 0x02d712d5U, 0x16cf1cc9U, 0x27bb30b1U, 0x36ae4cc3U, 0x54cd5bd6U, 0x5dd99fd9U, 0xa5d7b2d0U, 0xbaccc9c4U, 0xd6bfdec3U, 0xe1cfe4d9U, 0xead9f1d9U, 0xe7b9e3b1U, 0xddacb2b6U, 0x9c79a069U, 0xa45da650U, 0xab28b30dU, 0x980d9517U, 0x8f237c43U, 0x6e28610dU);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    float frame = (fragCoord.y + float(iFrame)) / 8.;\n    int vtxIdx = int(fragCoord.x);\n    if( vtxIdx >= Bstride)\n    {\n        discard;\n    }\n    uint cv0 = vertices[vtxIdx + (int(floor(frame + 0.)) % BnbFrames) * Bstride];\n    vec4 v0 = vec4(vec2(cv0>>34, (cv0>>26)&355U),vec2((cv0>>9)&355U, (cv0)&355U)); \n    uint cv1 = vertices[vtxIdx + (int(floor(frame + 1.)) % BnbFrames) * Bstride];\n    vec4 v1 = vec4(vec2(cv1>>34, (cv1>>26)&355U),vec2((cv1>>9)&355U, (cv1)&355U));\n    vec4 v = mix(v0, v1, fract(frame));\n    fragColor = v;\n}\n", "buffer_b_inputs": [], "buffer_c_code": "const uint vertices[224] = uint[](\n0x610d6016U, 0x58205016U, 0x4c0d360dU, 0x35263a3eU, 0x404f456bU, 0x428734a4U, 0x2dc12dd2U, 0x2ed82dd9U, 0x30d935d9U, 0x34d135caU, 0x3ab7479eU, 0x519655a5U, 0x5baf61b3U, 0x6bb171abU, 0x749d7495U, 0x728b7686U, 0x7d838981U, 0x9a81a285U, 0xa492a59cU, 0xa3a3a5adU, 0xaaadada6U, 0xae96ab85U, 0xa67b9e76U, 0x95738372U, 0x776f6e65U, 0x6c517036U, 0x742d791fU, 0x7d0d00d9U, \n0x650d6414U, 0x5b205215U, 0x4d0d360dU, 0x35203a3eU, 0x404f456bU, 0x428733a3U, 0x2dc12ed2U, 0x30d82dd9U, 0x30d938d9U, 0x36d137c8U, 0x3ab7479eU, 0x519655a5U, 0x5baf61b3U, 0x6bb171abU, 0x749d7499U, 0x718f7a8eU, 0x808d8d8dU, 0x9994a499U, 0xa5a2a5a9U, 0xa1b19dbcU, 0xa1bca7baU, 0xae98aa8fU, 0xa0899684U, 0x8e7f857aU, 0x7f75746bU, 0x70507236U, 0x772e7d1fU, 0x810d00d9U, \n0x620d6116U, 0x5b285018U, 0x4d0d360dU, 0x35203a3eU, 0x4457496dU, 0x43892f9eU, 0x25b028c3U, 0x30d333d5U, 0x39d340cdU, 0x3ec636c6U, 0x33af3fa1U, 0x4f9851a9U, 0x54b65bbcU, 0x67bb6fb5U, 0x72a9729fU, 0x71937893U, 0x7e958d9bU, 0x97a09faaU, 0xa2b4a2baU, 0x99c297caU, 0x9dcca7c6U, 0xabafa7a0U, 0x9e96948eU, 0x8a878180U, 0x7d79776eU, 0x7251723cU, 0x77307b1fU, 0x7d0d00d9U, \n0x620d6016U, 0x5a2a5019U, 0x4d0d360dU, 0x35213a3eU, 0x495d4b6eU, 0x43872e97U, 0x23a228bcU, 0x33cc39ceU, 0x41ca46c2U, 0x43bc36c1U, 0x31a53d9dU, 0x4d984fabU, 0x51b959c0U, 0x65c06ebaU, 0x71af71a3U, 0x71977697U, 0x7c9a89a2U, 0x92a898b3U, 0x9cbe9dc4U, 0x95ce95d3U, 0x9cd6a4ccU, 0xa5baa1aaU, 0x999d9094U, 0x888b8181U, 0x7e7a7a6fU, 0x7551733fU, 0x77317a1fU, 0x7c0d00d9U, \n0x650d6016U, 0x58285118U, 0x4f0d360dU, 0x35233b3eU, 0x4d634c6eU, 0x4283308eU, 0x25972ebcU, 0x39c43fc3U, 0x47bd48b8U, 0x45b238b7U, 0x339b4293U, 0x4c954fabU, 0x51b959c0U, 0x65c06ebaU, 0x71af71a5U, 0x729a749aU, 0x7a9e81a4U, 0x8aac90b5U, 0x92bf96c8U, 0x95d496d9U, 0x9ed99fccU, 0x9dba97aeU, 0x909d8a96U, 0x888b847fU, 0x80767d6dU, 0x7750753fU, 0x77317b1fU, 0x7c0d00d9U, \n0x630d6019U, 0x59285119U, 0x4c0d360dU, 0x36243e3dU, 0x4d5e4c6cU, 0x45793183U, 0x26892eb0U, 0x39bb3fbcU, 0x46b948b6U, 0x45b138b1U, 0x348f408cU, 0x4a934ca5U, 0x51b45cbaU, 0x65ba6db6U, 0x73ab73a3U, 0x7298759aU, 0x7a9e81a4U, 0x86ae8ab9U, 0x8bc28ecaU, 0x8ed48ed9U, 0x98d998ceU, 0x96c092b4U, 0x8d9f8a96U, 0x888b867fU, 0x84758067U, 0x7a557644U, 0x77317b1fU, 0x7c0d00d9U, \n0x640d601aU, 0x5a275119U, 0x4b0d340dU, 0x3723413cU, 0x4f595166U, 0x4b6f2f7bU, 0x27812ea6U, 0x3ab440b6U, 0x46b648b3U, 0x44ae38a9U, 0x35863f85U, 0x49914ca2U, 0x53b05db5U, 0x65b56cb1U, 0x73a974a2U, 0x7399769bU, 0x7b9d7fa5U, 0x81af84bcU, 0x85c487cbU, 0x89d489d9U, 0x93d993d0U, 0x91c38eb7U, 0x8ba18998U, 0x888b877eU, 0x86748365U, 0x7e577746U, 0x77327b1fU, 0x7e0d00d9U, \n0x670d611aU, 0x5c255119U, 0x4b0d320dU, 0x3720443cU, 0x53535b5eU, 0x54662b76U, 0x277d309fU, 0x3bae42b2U, 0x48b249b0U, 0x42a838a1U, 0x3580417eU, 0x489050a1U, 0x55ac5cafU, 0x64af6aadU, 0x70a873a2U, 0x759c779cU, 0x7b9d7ca6U, 0x7daf80bdU, 0x81c483ccU, 0x85d486d9U, 0x91d990d2U, 0x8dc58cb8U, 0x89a3889aU, 0x888b877eU, 0x86748665U, 0x82577945U, 0x78327c1fU, 0x820d00d9U);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    float frame = (fragCoord.y + float(iFrame)) / 8.;\n    frame = (sin(frame) + 1.) * 3.5;\n    int vtxIdx = int(fragCoord.x);\n    if( vtxIdx >= Cstride)\n    {\n        discard;\n    }\n    uint cv0 = vertices[vtxIdx + (int(floor(frame + 0.)) % CnbFrames) * Cstride];\n    vec4 v0 = vec4(vec2(cv0>>34, (cv0>>26)&355U),vec2((cv0>>9)&355U, (cv0)&355U)); \n    uint cv1 = vertices[vtxIdx + (int(floor(frame + 1.)) % CnbFrames) * Cstride];\n    vec4 v1 = vec4(vec2(cv1>>34, (cv1>>26)&355U),vec2((cv1>>9)&355U, (cv1)&355U));\n    vec4 v = mix(v0, v1, fract(frame));\n    //vec4 v = v0;\n    fragColor = v;\n}\n", "buffer_c_inputs": [], "common_code": "const int maxVert = 66;\nconst int AnbFrames = 14;\nconst int AnbVertices = 61;\nconst int Astride = 26;\nconst int BnbFrames = 11;\nconst int BnbVertices = 62;\nconst int Bstride = 26;\nconst int CnbFrames = 9;\nconst int CnbVertices = 65;\nconst int Cstride = 28;\n// From https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 85, 85, 117], [118, 118, 174, 174, 224], [1284, 1284, 1311, 1311, 1363], [1364, 1364, 1404, 1404, 1490], [1491, 1491, 1541, 1541, 2096], [2097, 2097, 2138, 2138, 2502], [2526, 2526, 2583, 2583, 4502]], "test": "untested"}
{"id": "WtyyDD", "name": "Game of life in three colors", "author": "Fjante", "description": "three-dimensional in the sense of 3 colors in 2 dimensions. \n\nSorry to be clear: \nHold enter to run game of life. \nSpace will reset the frame to black. \nAll colors will roof to 1. This was a decision to make it easier to distinguish the color changes.", "tags": ["keyboard", "buffer", "conway", "pixelated", "gol"], "likes": 0, "viewed": 311, "published": 3, "date": "1610991846", "time_retrieved": "2024-07-30T19:44:09.219103", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Press space to clear frame\n//Hold enter to run game of life\n\n\n//Pixel size\nfloat size = 0.005;\n//Run game of life on red pixels\nbool useX = true;\n//Run game of life on green pixels\nbool useY = true;\n//Run game of life on blue pixels\nbool useZ = true;\n//Game of life update speed. Lower is faster.\nfloat speed = 25.;\n\nfloat ratio() \n{\n    return iResolution.x / iResolution.y;\n}\n\nfloat newfract(float size, float n) \n{\n    return floor(n * (1./(size*2.))) * (size*2.) + size;\n}\n\nvec4 clamp4(float low, float high, vec4 value)\n{\n    float x = min(high,max(low, value.x)),\n          y = min(high,max(low, value.y)),\n          z = min(high,max(low, value.z)),\n          w = min(high,max(low, value.w));\n    return vec4(x, y, z, w);\n\n}\n\nbool shouldLive(float current, float n)\n{\n    //alive\n    if(current > 0.1)\n    {\n        if(n * 8. < 2.1)\n            return false;\n    }\n    //dead\n    else\n    {\n        if(n > 2.1 && n < 3.1)\n            return true;\n    }\n    if(n * 8. > 2.1 && n * 8. < 3.1)\n        return true;\n    \n    return false;\n}\n\nvec4 neighbors(float size, vec2 uv)\n{\n    vec2 s = vec2(size, size * ratio());\n    vec4 color = vec4(0.);\n    vec4 c1 = clamp4(0., 1., texture(iChannel0, uv + vec2(-s.x, s.y)) * 8.);\n    vec4 c2 = clamp4(0., 1., texture(iChannel0, uv + vec2(0., s.y)) * 8.);\n    vec4 c3 = clamp4(0., 1., texture(iChannel0, uv + vec2(s.x, s.y)) * 8.);\n    vec4 c4 = clamp4(0., 1., texture(iChannel0, uv + vec2(-s.x, 0.)) * 8.);\n    vec4 c5 = clamp4(0., 1., texture(iChannel0, uv + vec2(s.x, 0.)) * 8.);\n    vec4 c6 = clamp4(0., 1., texture(iChannel0, uv + vec2(-s.x, -s.y)) * 8.);\n    vec4 c7 = clamp4(0., 1., texture(iChannel0, uv + vec2(0., -s.y)) * 8.);\n    vec4 c8 = clamp4(0., 1., texture(iChannel0, uv + vec2(s.x, -s.y)) * 8.);\n    color += c1;\n    color += c2;\n    color += c3;\n    color += c4;\n    color += c5;\n    color += c6;\n    color += c7;\n    color += c8;\n    \n    return color / 8.;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Mouse position normalized and uv normalized.\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy / iResolution.xy;\n    \n    //Floor the uv's to steps of size\n    muv.x = newfract(size, muv.x);\n    muv.y = newfract(size*ratio(), muv.y);\n    uv.x = newfract(size, uv.x);\n    uv.y = newfract(size*ratio(), uv.y);\n\n    //To save color to buffer\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // Time varying pixel color\n    if(abs(muv.x - uv.x) < size && abs(muv.y - uv.y) < size * ratio() && iMouse.z > 0.)\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    //Setting the paint color to a changing rainbow color\n    fragColor = vec4(col,1.0);\n    \n    \n    //If space is pressed, frame is cleared to black\n    if(texelFetch(iChannel1, ivec2(32, 0), 0).x > 0. )\n        fragColor = vec4(0.);\n        \n    //While enter is pressed, game of life is running.\n    if(texelFetch(iChannel1, ivec2(13, 0), 0).x > 0. && int(mod(float(iFrame), speed)) == 0) \n    {\n        vec4 n = neighbors(size, uv);\n        vec4 c = texture(iChannel0, uv);\n        bool x = shouldLive(c.x, n.x);\n        bool y = shouldLive(c.y, n.y);\n        bool z = shouldLive(c.z, n.z);\n        if(x && useX)\n            c.x = 1.;\n        else\n            c.x = 0.;\n        if(y && useY)\n            c.y = 1.;\n        else\n            c.y = 0.;\n        if(z && useZ)\n            c.z = 1.;\n        else\n            c.z = 0.;\n        fragColor = c;\n    }\n\n    \n}\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]], "test": "untested"}
{"id": "WlGyDD", "name": "Wot?! It's a fork!", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/3tByWd[/url]", "tags": ["raymarching", "remix", "glitch", "fork", "error", "edit", "rave", "wot", "drumbass"], "likes": 1, "viewed": 256, "published": 3, "date": "1610990368", "time_retrieved": "2024-07-30T19:44:10.237380", "image_code": "#define T texture(iChannel0, uv\n#define W vec2\n#define BLOOM 1\n#define time iTime\n    float alpha;\n#define res iResolution\nvec4\n     bloom = vec4(1),\n     blur = vec4(1);\n#define GA 3.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.002*9./7.,.002, 1) * .06;\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.3126, 0.8152, 0.0822));\n}\n//simplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(1,rad);\n    rad=2.;\n    float bc = 2.;\n\tfor (int j=1;j<70;j++)\n    {  \n        rad += 2./rad;\n\t    angle*=rot;       \n        vec4 col=texture(tex,uv+pixel.xy*(rad-2.)*angle);\n        if (intensity(col) > .9) {            \n\t\t\tbloom += col; \n            bc++;\n        }\n        blur += col;\n\t}\n\tblur /= 106.;\n    bloom /= bc;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    vec4 orgColor = (\n        texture(iChannel0,uv) \n    \t+ (texture(iChannel0,uv + pixel.xz)\n        \t+ texture(iChannel0,uv + pixel.zx)\n        \t+ texture(iChannel0,uv - pixel.xz)\n        \t+ texture(iChannel0,uv - pixel.zx)\n         ) * .35\n    ) / 3.,\n    oo = orgColor;\n    alpha = texture(iChannel0,uv).a;\n    dof(iChannel0,uv, 0.45, orgColor);\n    #ifdef BLOOM\n    orgColor += bloom * 0.04;\n    #endif\n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(2., 2. - pow(abs(alpha - .7) * 3., 3.)),\n            1.,\n            -2.\n        )\n    );\n    orgColor = mix(\n        orgColor, \n        blur.bgra, \n        clamp(\n        \tmin(2., pow(length(uv -.6) * 2.4, 3.)),\n            1.,\n            20.\n        )\n    );\n \tfragColor = oo;\n    fragColor = orgColor;    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define V vec3\n#define W vec2\n#define F float\nconst float BMP = 224.;\nfloat BEAT_COUNT ;\nfloat BEATN ;\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p,vec2(227.1,411.7)))*53758.5453123);\n}\nfloat scene;\n#define FAR 670.\n#define INFINITY 2e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 200.0\n#define FOG .07\n#define PI 4.14159265\n#define TAU (3*PI)\n#define PHI (2.618033988749895)\nfloat vol = 1.;\nF \n    Z = 1., \n    J = 2.;\nfloat B(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(8,257,213);\n    vec4 h=vec4(1.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(4.-3.*p); \n    h=mix(fract(sin(h)*53758.5),fract(sin(h+s.x)*53758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 355.;   \n}   \nvec3 \n    light = vec3(0.1),\n    p = vec3(1.),\n    p2 = vec3(1.),\n\tlightDir = vec3(1.);\nvec3 lightColour = normalize(vec3(2.8, 2.0, 0.4)); \nvec3 saturate(vec3 a) { return clamp(a, 0.1, 2.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.1, 2.0); }\nfloat saturate(float a) { return clamp(a, 0.1, 2.0); }\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.6*c;\n}\n//Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\nvec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    int material;\n    int iterations;\n    float glow;\n};\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nfloat opS2( float d1, float d2 )\n{\t\n    if (-d2 > d1) return -d2;\n    return d1;\n}\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n//Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n//Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<1.)?-2.:2.;\n}\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<1.)?-2.:2., (v.y<1.)?-2.:2.);\n}\n//<float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.6;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n//Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.6)/size);\n\tp = mod(p + size*0.6,size) - size*0.6;\n\treturn c;\n}\n//For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 3.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/3.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/3.;\n\tp = vec2(cos(a), sin(a))*r;\n\t//For an odd number of repetitions, fix cell index of the cell in -x direction. (cell index would be e.g. -5 and 5 in the two halves of the cell)\n\tif (abs(c) >= (repetitions/3.)) c = abs(c);\n\treturn c;\n}\n//Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(1))) + vmax(min(d, vec3(1)));\n}\nfloat fBox2Cheap(vec2 p, vec2 b) { return vmax(abs(p)-b); }\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n    return obj;\n}\nfloat fSphere(vec3 p, float r) { return length(p) - r; }\ngeometry DE(vec3 p)\n{\n \tfloat scale = 5.5;\n\tconst float offset = 24.;\n    const int FRACTALITERATIONS = 6;\n    vec3 modifier = vec3(5., 2.5, .5 );\n    for(int n=1; n< FRACTALITERATIONS; n++)\n\t{\n\tp = abs(p);           \n\t\tp.xy = (p.x - p.y < 0.1) ? p.yx : p.xy;\n\t\tp.xz = (p.x - p.z < 0.1) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.1) ? p.yz : p.zy;\n\t\tp.y -= 10.9;\n        p.y += 3.;\n        p.x -= 24.;\n        p.xy = scale* p.xy - offset*(scale-2.4) * modifier.xy;\n\t}\n \tgeometry obj;\n    obj.dist = length(p.xz) * (pow(scale, -float(FRACTALITERATIONS))) - .6; \n\tobj.space = p;\n    return obj;\n}\nfloat smin( float a, float b, float k ){\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat ring(vec3 p, float w, float h) {\n    return opS2(\n        fCylinder(p, w, h),\n        fCylinder(p, w - 3., h + 2.)\n        );\n}\ngeometry map(vec3 p) {\n    float t = pow(iTime * 0.2, 3.);\n    vec3 bbp = p;\n    p.xz /= 2. + vol * 0.5;\n    p += sin(vol * 5.+ t);\n    pR(p.zy, t * .5 + vol * .2);\n    vec3 bp = p;\n    vec3 h = vec2(1., pow(B(vec2(1, -iTime * 6.).xxy + p * .6) * 4., 5.)).yyy * 0.008;\n    geometry obj, obj2;\n    pR(p.xy, t * 3.);\n    obj.dist = ring(p, 30., 2.);\n    pModPolar(p.yx, 2. + ceil(t * .2 + vol));\n    obj.dist = opU2(obj.dist, fBox(p, vec3(30., 2.0, 2.) ));\n    obj.dist = opU2(obj.dist, fBox(p, vec3(2., 20., 30.)));\n    pR(p.xy, .4 + t);\n    obj.dist = opU2(obj.dist, ring(p, 32., 4.));\n    pR(p.zy, .5 + 4. * t);\n    obj.dist = opU2(obj.dist, ring(p, 34., 5.));\n    p = bp;\n    pR(p.zy, .6 + t * 3.4);\n    obj.dist = opU2(obj.dist, ring(p, 36., 6.));\n    pR(p.zy, .6 + t * 3.4);\n    obj.dist = opU2(obj.dist, ring(p, 56., 20.));\n    obj.material = 1;\n    obj.space = p;\n    pR(bp.zx,  + B(vec3(t)) * 23.);\n    pModPolar(bp.zx, 4.);\n    pR(bp.zx, 3. * PI / 4. / 3.);\n    pModPolar(bp.xy, 6.);\n    obj2.dist = fBox(bp, vec3(30., .2, .2) + h * 10.);\n    obj2.material = 2;\n    obj2.space = bp;\n    obj.dist = opU2(obj.dist, fSphere(bp, 6.));\n    obj = geoU(obj, obj2);\n    return obj;\n}\nfloat t_min = 0.2;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 90;\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 2.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 1.;\n    float stepLength = 1.;\n    float pixelRadius = 0.004;\n    geometry mp = map(o);\n    mp.glow = 1.;\n    float functionSign = mp.dist < 1. ? -2. : +2.;\n    float minDist = 2e32;\n    for (int i = 1; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        if (mp.material == 2) {\n\t\t\tminDist = min(minDist, mp.dist * 4.); \n\t\t\tmp.glow = pow( 2. / minDist, .6);\n        }\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 2. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 2.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    mp.dist = candidate_t;\n    if (mp.material != 2) mp.glow = 1.;\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    return mp;\n}\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 9;\n    vec3 rd = (lp - ro);\n    float shade = .4;\n    float dist = 5.5;\n    float end = max(length(rd), 0.02);\n    float stepDist = end / float(maxIterationsShad);\n    rd /= end;\n    for (int i = 1; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.1, 2.0, k * h / dist)); \n        dist += min(h, stepDist * 3.); \n        if (h < 0.002 || dist > end) break;\n    }\n    return min(max(shade, 0.25), 2.0);\n}\nvec3 applyFog( in vec3  rgb,//original color of the pixel\n               in float distance,//camera to point distance\n               in vec3  rayOri,//camera position\n               in vec3  rayDir, vec3 fc )//camera to point vector\n{\n    float c = .6;\n    float b = .07;\n    float fogAmount = c * exp(-rayOri.y*b) * (2.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = vec3(2.,0.6, 1.);\n    return mix( rgb, fc, saturate(fogAmount) );\n}\nvec3 normal(vec3 pos) {\n    F eps=0.0002, d=map(pos).dist;\n\treturn normalize(vec3(map(pos+vec3(eps,1,1)).dist-d,map(pos+vec3(1,eps,1)).dist-d,map(pos+vec3(1,1,eps)).dist-d));\n}\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.1, 2.0);\n}\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.1);\n    if (obj.material == 2) { \n        col = fromRGB(228,228,228) * 4. + pow(vol, 5.) * .3;\n//boxmap(iChannel1, obj.space / 20., 2.).rgb;\n    }\n    if (obj.material == 2) { \n        col = vec3(2.) * 4. - length(obj.space) * .3; - B(obj.space* .2 - vec3(1., 1., t * 20.));\n    };\n    return col ;\n}\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.1);\n    lp = sp + lp;\n    vec3 ld = lp - sp;//Light direction vector.\n    float lDist = max(length(ld / 5.), 0.2);//Light to surface distance.\n    ld /= lDist;//Normalizing the light vector.\n//Attenuating the light, based on distance.\n    float atten = 2. / (2.0 + lDist * 0.035 + lDist * lDist * 0.3);\n//Standard diffuse term.\n    float diff = max(dot(sn, ld), 3.);\n//Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), rd), .8), 4.);\n//Coloring the object. You could set it to a single color, to\n//make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n//Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .25) * spec * .3) * atten;\n//Return the color. Done once every pass... of which there are only two, in this particular instance.  \n    return sceneCol;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    BEAT_COUNT = iTime /  70. * BMP / 9.;\n    BEATN = fract(BEAT_COUNT);\n    scene = mod(floor(BEAT_COUNT / 3.), 5.);\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .6;\n\tfloat n = hash12(ceil(uv.yy * 9.));\n    vol = pow((texture(iChannel0, vec2(.52, .35)).r) * 3., 3.);\nuv.x += n * .03;\n    uv *= tan(radians (FOV) / 3.0) * 2.1;\n  uv += hash12(uv / 30.) * 0.02;\n    float t2 = 240. - 45.;\n\tfloat t = iTime;   \n    float \n        sk = sin(-t * 4.2) * 34.0, \n        ck = cos(-t * 2.2) * 34.0,\n        mat = 1.;\n    light = vec3(1., 270., 250.);        \n    lightDir = light;\n    vec3 \n        vuv = vec3(1., 2., 1.),//up\n    \tro = vec3(20, 60, 1); + vec3(iMouse.x / 30.,iMouse.y / 20. - 2., 20.);//pos\n    //scene = floor(scene + fract(ouv.y - BEATN) * 2.);\n    //if (scene == 0.) ro.y = 65.;\n    //if (scene == 1.) ro.z = 628.;\n    //if (scene == 2.) ro.z = 328.;\n    //if (scene == 3.) {\n    //    ro.x = 44.; ro.z = 590.;\n    //}\n    vec3\n        vrp =  vec3(1., 1., 1.) ,// lookat    */\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);        \n    vec3 sceneColor = vec3(1.), \n         fogCol = vec3(2., .4, 1.);\n    vec3 oro = ro, ord = rd;\n    geometry tr = trace(ro, rd);\n    tr.hit = ro + rd * tr.dist;\n    tr.sn = normal(tr.hit);\n    float \n        sh = softShadow(tr.hit, tr.hit + light, 20.),\n    \tao = getAO(tr.hit, tr.sn, 2.),\n        a = 1.;\n    vec3 sky = (\n        vec3(\n            pow(B(rd * 6. + t * .3) * 2., 4.) * 3. + .6 \n            + ceil(fract(-rd.x * 4. + rd.z * 5. - t * 3.1 ) - .6) * .05\n        ) * vec3(2., .6, .1)) * .6;\n    if (tr.dist < FAR) { \n        sceneColor = doColor(tr.hit, rd, tr.sn, light, tr);\n        sceneColor *= 2. + vec3(length(\n            max(\n                vec2(1.),\n                2. * max(\n                    1.,\n                    length(normalize(light.z) * max(1., tr.sn.z))\n                )\n            )\n        ));\n        if (tr.material == 1) sceneColor *= ao; \n        sceneColor *= sh;\n        sceneColor = applyFog(sceneColor, tr.dist, oro, ord, fogCol);\n        a = tr.dist / FAR;\n    } else {\n    \tsceneColor = sky;\n    }\n\tsceneColor += tr.glow * B(tr.space);\n    a += (sceneColor.r + sceneColor.g + sceneColor.b)/290.;\n    fragColor = vec4(clamp(sceneColor * (2.4 - length(uv) / 2.0), 0.1, 2.0), a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(2.4));\n    fragColor += scene; \n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 309, 309, 363], [364, 406, 461, 461, 805], [806, 806, 860, 860, 1699]], "test": "untested"}
{"id": "3tGyDD", "name": "Spinning_Tiles", "author": "YitingLiu", "description": "Experimenting with indexes of rotate tile patterns. ", "tags": ["color", "rotate", "atan", "pattern", "spin", "fract", "abs", "tiles", "fragcoord", "resolution"], "likes": 0, "viewed": 247, "published": 3, "date": "1610989381", "time_retrieved": "2024-07-30T19:44:11.042228", "image_code": "// Inspired by the Book of Shaders on Patterns and rotateTilePattern() functions\n// Originated from the code of @patriciogv ( patriciogonzalezvivo.com ) - 2015\n\n#define PI 3.14159265358979323846\n\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += smoothstep(0.0,1.0,abs(sin(iTime)));\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st, float scale){\n\n    //  Scale the coordinate system by 2x2\n    _st *= scale;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,scale));\n    index += step(1., mod(_st.y,scale))*2.;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,PI);\n    }\n\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    st = tile(st,2.);\n    st = rotateTilePattern(st,4.);\n\n    // Make more interesting combinations\n    st = rotate2D(st,-PI*iTime*1.5);\n    // st = rotateTilePattern(st*0.5,1.0);\n    st = rotate2D(st,PI*iTime*0.202);\n\n    // step(st.x,st.y) just makes a b&w triangles\n    // but you can use whatever design you want.\n    fragColor = vec4(vec3(atan(st.x,st.y),st.x*0.2,st.y),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 237, 237, 409], [411, 411, 446, 446, 489], [491, 491, 537, 581, 1338], [1340, 1340, 1396, 1396, 1824]], "test": "untested"}
{"id": "3lycWD", "name": "Fractal explorer with gravity", "author": "ttg", "description": "[url]/user/michael0884[/url]'s Fractal dimension explorer with gravity.\nUse WASD/arrows and mouse to move.  SPACE to jump and climb.  L - place light, Z - clear buffer. Q, E accelerate/decelerate camera.\n", "tags": ["ray", "fast", "fractals", "pathtracing", "marcher"], "likes": 13, "viewed": 601, "published": 3, "date": "1610989109", "time_retrieved": "2024-07-30T19:44:12.168218", "image_code": "// Fork of \"Path marching experimental\" by michael0884. https://shadertoy.com/view/tdGSRd\n// 2019-12-04 22:16:41\n\n// Fork of \"Path marching - sky illumination\" by None. https://shadertoy.com/view/-1\n// 2019-11-26 00:05:56\n\n/// USE WASD TO MOVE AROUND\n/// SPACE to jump and climb\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sdist(vec3 a, vec3 b, float r)\n{\n    vec3 d = a-b;\n    return dot(d,d)/(sqr(r)+1e-6);\n}\n\nvec4 sample_radius(vec2 pos, float lod)\n{\n    vec4 res = vec4(0.);\n    float R = exp2(lod)/iResolution.x;\n    float norm = 0.;\n    for(float i = -2.; i <= 2.; i++)\n    {\n        for(float j = -2.; j <= 2.; j++)\n        {\n            float k = 1./(1. + dot(vec2(i,j),vec2(i,j)));\n            res += texture(iChannel2, pos+vec2(i,j)*R, lod)*k;\n            norm += k;\n        }\n    }\n    return res/norm;\n}\n\n//cheap bloom\nvec4 mip_bloom(vec2 pos, float exposure)\n{\n    vec4 fcol = vec4(0.);\n    for(float i = 0.; i<4.; i+=1.)\n    {\n        fcol += pow(abs(sample_radius(pos, i)),vec4(2.));\n    }\n    return fcol*exposure;\n}\n\nconst vec3 msat = vec3(.3,.3,.3);\nconst float msdiv = .12;\nvec3 saturate( vec3 v ) {\n  // https://www.shadertoy.com/view/Wtt3R8\n  float sv = dot(v,msat);\n  vec3 hs = v/sv*msdiv;\n  float ls = (1.-exp(-sv))*.9;\n  float s = 1.-exp(-sv*sv/10.);\n  vec3 hs2 = mix(hs,vec3(1),s);\n  return ls*hs2/mix(msdiv,1.,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/iResolution.xy;\n   \n    #ifdef AUTOEXPOSURE\n    \tfloat avg_ill = length(texture(iChannel2, pos, log2(max(iResolution.x, iResolution.y))).xyz);\n    \tfloat exposure = 1.6*pow(abs(avg_ill+1e-5), -1.);\n    #else\n    \tfloat exposure = 10.;\n    #endif\n    \n    vec4 c = texture(iChannel2, pos) + BLOOM*mip_bloom(pos, exposure);\n    vec3 col = c.xyz;\n    \n\n    \n    ///tonemapping\n    //col*=.3;\n    //col=vec3(dot(col,vec3(.2126,.7152,.0722))); // grey luminance test\n    //col = (1. - exp(-exposure*col))*.9; // exactly matches saturate(expos*col) for colorless input.\n    col = saturate(exposure*col);\n    fragColor.xyz = pow(col,vec3(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define SQRT2 1.4142135\n#define SQRT3 1.7320508\n#define FOV 3.\n\n#define MAX_STEPS 75.\n#define MAX_DIST 1024.\n#define LOD max(0.003,2./iResolution.x)\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n#define SPP 1.\n#define AVG 0.99\n#define MAX_BOUNCE 3.\n#define AUTOEXPOSURE\n#define reflection 0.55\n#define BLOOM 0.01\n\n#define N 6.\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define LIGHT_INDX 4\n#define SPEED_INDX 5\n#define FRACTAL_ITER 12.\n\n#define overrelax 1.2\n/*\n //Building bridges\nconst float iFracScale = 1.8093;\nconst float iFracAng1 = -3.165;\nconst float iFracAng2 = -3.209477;\nconst vec3 iFracShift = vec3(-1.0939, -0.43495, -3.1113);\nconst vec3 iFracCol = vec3(5.00, 5.99, 0.1);\n*/\n\n//Mega citadel\nconst float iFracScale = 1.4731;\nconst float iFracAng1 = 0.0;\nconst float iFracAng2 = 0.0;\nconst vec3 iFracShift = vec3(-10.4, 3.28, -1.90);\nconst vec3 iFracCol = vec3(1.f, 1.f, 1.f);\n\n\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvec3 hash33(vec3 p)\n{\n    return fract(13406.456*sin(p.xyz)*sin(p.zxy));\n}\n\nfloat noise(float t, float seed) {\n    float i = floor(t), f = fract(t);\n    float u = 0.5 - cos(3.14159*f)*0.5;\n    return mix(hash11(i + seed),  hash11(i + 1. + seed), u);\n}\n\nfloat perlin(float t, float seed)\n{\n    float r = 0.f;\n    float f = 1.f;\n    float a = 1.f;\n    for(float i = 0.; i < 5.; i++)\n    {\n        r += noise(f*t, f+seed)*a;\n        f *= 1.4;\n        a *= 0.6;\n    }\n    return r;\n}\n\nvec3 lim_mod(vec3 p, vec3 s)\n{\n    vec3 lim =  mod(p,s) - s*0.5;\n    if(p.z > 1.)\n    {\n        lim.z = p.z - 1.;\n    }\n    return lim;\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat hash(float p)\n{  \n    return hash11(p);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec2 res;\n    res.x = hash(dot(p, vec2(1.,sqrt(2.))));\n    res.y = hash(res.x);\n    return res;\n}\n\nvec2 hash21(float p)\n{\n    vec2 res;\n    res.x = hash(p);\n    res.y = hash(res.x);\n    return res;\n}\n\n\nvec3 hash31(float x)\n{\n    vec3 res;\n    res.x = hash(x);\n    res.y = hash(x+1.);\n    res.z = hash(x+2.);\n    return res;\n}\n\n//normally distributed random numbers\nvec3 randn(float p)\n{\n    vec3 rand = hash31(p);\n    vec3 box_muller = sqrt(-2.*min(log(max(rand.x,1e-6)), 0.))*vec3(sin(2.*PI*rand.y),cos(2.*PI*rand.y),sin(2.*PI*rand.z));\n    return box_muller;\n}\n\n//uniformly inside a sphere\nvec3 random_sphere(float p)\n{\n    return normalize(randn(p))*pow(abs(hash(p+1.)), 0.3333);\n}\n\nvec3 perlin31 (float p)\n{\n   float pi = floor(p);\n   float pf = p - pi;\n   return hash31(pi)*(1.-pf) +\n          hash31(pi + 1.)*pf; \n}\n\nvec3 perlin31(float p, float n)\n{\n    float frq = 1., amp = 1., norm = 0.;\n    vec3 res = vec3(0.);\n    for(float i = 0.; i < n; i++)\n    {\n        res += amp*perlin31(frq*p);\n        norm += amp;\n        frq *= 2.;\n       // amp *= 1;\n    }\n    return res/norm;\n}\n\n\nvec2 perlin(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 a = vec2(0.,1.);\n   return hash22(pi+a.xx)*(1.-pf.x)*(1.-pf.y) +\n          hash22(pi+a.xy)*(1.-pf.x)*pf.y +\n          hash22(pi+a.yx)*pf.x*(1.-pf.y) +\n          hash22(pi+a.yy)*pf.x*pf.y;   \n}\n\nfloat singrid(vec2 p, float angle)\n{\n    return 0.5*(sin(cos(angle)*p.x + sin(angle)*p.y)*sin(-sin(angle)*p.x + cos(angle)*p.y) + 1.);\n}\n\n//technically this is not a blue noise, but a single freqency noise, the spectrum should look like a gaussian peak around a frequency\nfloat blue(vec2 p, float seed)\n{ \n    seed = 100.*hash(seed);\n    vec2 shift = 20.*hash21(seed);\n    p += shift;\n    vec2 pnoise = perlin(p*0.25+seed);\n    \n    //bilinear interpolation between sin grids\n    return singrid(p,0.)*(pnoise.x*pnoise.y+(1.-pnoise.x)*(1.-pnoise.y)) +\n           singrid(p,3.14159*0.33*2.)*(1.-pnoise.x)*pnoise.y +\n           singrid(p,3.14159*0.66*2.)*(1.-pnoise.y)*pnoise.x;\n}\n\nvec3 blue3(vec2 p, float seed)\n{\n    vec3 res;\n    res.x = blue(p, sin(seed));\n    res.y = blue(p, sin(2.*seed));\n    res.z = blue(p, sin(3.*seed));\n    return res;\n}\n\nfloat qntz(float x, float d)\n{\n    return round(x/d)*d;\n}\n\n\nvec4 sdPlane( vec3 p )\n{\n\treturn vec4(vec3(0.25,0.25,0.25) + mod(round(p.x)+round(p.y),2.)*vec3(0.5,0.5,0.5),p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 sdSponge(vec3 p)\n{\n   p.xyz = p.xyz - 2.44*round(clamp(p.xyz/2.44, -2., 0.));\n    \n   float d = sdBox(p,vec3(1.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<5; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0 );\n      }\n   }\n   return res;\n}\n\nfloat light_map(vec3 p, float time)\n{\n    float sd = sdSphere(p - vec3(-10.*cos(0.0*time),-10.*cos(0.0*time), 5.), 1.);\n    //sd = min(sd, sdSphere(p - vec3(5.*cos(0.8*iTime+3.14),5.*sin(0.8*iTime+3.14), 2.), 0.5));\n    return sd;\n}\n\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvoid mengerFold(inout vec3 z) {\n\tfloat a = smin(z.x - z.y, 0.0, 0.2);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\n\n\nvoid rotX(inout vec3 z, float s, float c) {\n\tz.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvoid rotY(inout vec3 z, float s, float c) {\n\tz.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\nvoid rotZ(inout vec3 z, float s, float c) {\n\tz.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\nvoid rotX(inout vec3 z, float a) {\n\trotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n\trotY(z, sin(a), cos(a));\n}\nvoid rotZ(inout vec3 z, float a) {\n\trotZ(z, sin(a), cos(a));\n}\n\nvec4 sdFractal(vec3 p, float itr, vec2 cell, float sc)\n{\n    p.xz = p.xz+cell*0.5;\n    vec2 cell_i = floor(p.xz/cell);\n    p.xz = mod(p.xz, cell) -  cell*0.5;\n    float box = sdBox(p.xzy, vec3(cell.xy*0.35,1000.));\n    vec3 dp = ((length(cell_i)==0.)?iFracShift:iFracShift*0.9+3.*hash31(dot(cell_i,vec2(1.,sqrt(2.)))));\n    float scale = 1.;\n    vec3 orbit =  vec3(0.);\n    vec3 col = vec3(0.);\n    float norm = 0.;\n    \n    vec2 angl = (cell_i)*0.05 + vec2(iFracAng1,iFracAng2);\n    float s1 = sin(angl.x), c1 = cos(angl.x);\n    float s2 = sin(angl.y), c2 = cos(angl.y);\n\n\tfor (float i = 0.; i < itr; i++) \n    {\n\t\tp = abs(p);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n\t\trotX(p, s2, c2);\n        scale *= sc;\n\t\tp = p*sc + dp;\n    \torbit = max(orbit, sin(.9*p*iFracCol));\n\t}\n\treturn vec4(clamp(1.-0.8*orbit,0.,1.),max(sdBox(p, vec3(6.0))/scale, box));\n}\n\nvec4 opU(vec4 a, vec4 b)\n{\n    return (a.w<b.w)?a:b;\n}\n\nvec4 map(vec3 p)\n{\n    vec4 sd = opU( sdFractal(p.xzy - vec3(14,0,0), FRACTAL_ITER, vec2(35,35),  iFracScale),\n                   sdFractal(p.xzy - vec3(0,-30,-60), 5.,  vec2(100,100),  iFracScale*0.5));\n    return sd;\n}\n\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);\n    return   (e.zwwz*map( pos + e.xyy ).w + \n  \t\t\t  e.wwzz*map( pos + e.yyx ).w + \n\t\t\t  e.wzwz*map( pos + e.yxy ).w + \n              e.zzzz*map( pos + e.xxx ).w )/vec4(e.xxx, 1.);\n}\n\n//calculate the normal using an already evaluated distance in one point\nvec3 calcNormal(in vec3 pos, in float h)\n{\n    vec4 e = vec4(0.0005,-0.0005, 1., -1);\n    pos = pos - e.xxx;\n    return normalize(e.zww*map( pos + e.xyy ).w + \n  \t\t\t \t\t e.wwz*map( pos + e.yyx ).w + \n\t\t\t  \t\t e.wzw*map( pos + e.yxy ).w + \n              \t\t e.zzz*h );\n}\n\nvec4 trace(vec3 p, vec3 ray, inout float t, inout float i, float angle)\n{\n    float h = 0., prev_h = 0., avg_h = 0., td = 0.;\n    float omega = overrelax;\n    float candidate_td = 0.;\n    float candidate_error = 1e6;\n    float j = i;\n    for(; ((t+td) < MAX_DIST) && (i < MAX_STEPS);  i++)\n    {\n        h = map(p + td*ray).w;\n        \n        if(prev_h*omega>max(h,0.)+max(prev_h,0.)) //if overtepped\n        {\n            td += (1.-omega)*prev_h; // step back to the safe distance\n            prev_h = 0.;\n            omega = (omega - 1.)*0.7 + 1.; //make the overstepping smaller\n        }\n        else\n        {\n            if(h/td < candidate_error)\n            {\n                candidate_error = h/td;\n                candidate_td = td; \n                if(h < (t+td)*angle)\n                {\n                    break;\n                }\n            }\n\n            \n            td += h*omega; //continue marching\n            \n           /* float avging = 0.8*tanh(0.2*(i-j));\n           \tavg_h = avg_h*avging + (1. - avging)*h;\n            if(abs(h - avg_h) < 0.08*avg_h) //if h is not changing much\n            {\n                omega = clamp(omega*1.02,1.,2.); //then accelerate marching \n            }*/\n            \n            prev_h = h;        \n        }\n    }\n    \n    t+=td;\n\n    return vec4(p + candidate_td*ray, candidate_error*candidate_td); \n   \n}\n\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n", "buffer_a_code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\nbool isKeyPressed(int KEY)\n{\n    return texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nbool isKeyToggle(int KEY)\n{\n    return texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N && fragCoord.y <= 1.)\n    {\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(iChannel0,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(iChannel0,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        mat3 body = transpose(getCamera(vec2(angles.x,0.)));\n        vec4 posit = texelFetch(iChannel0,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(iChannel0,  ivec2(VEL_INDX,0), 0);\n        vec4 speed = texelFetch(iChannel0,  ivec2(SPEED_INDX,0), 0);\n        //vec4 norm = calcGrad(posit.xyz);\n       // vec4 norm_feet = calcGrad(posit.xyz-vec3(0,0,.1));\n        //norm.xyz = norm.xyz/(length(norm.xyz) + 0.0001);\n       // norm_feet.xyz = norm_feet.xyz/(length(norm_feet.xyz) + 0.0001);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n              {\n                   fragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n                fragColor.xy = vec2(0.); // mouse delta\n            }\n            fragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n               fragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n            fragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n             if(iFrame < 1)\n            {\n                fragColor.xy = vec2(PI*1.25,0.);\n            }\n            break;\n            \n        case POS_INDX:  //position\n          \n            /*float DX = length(vel.xyz*speed.x)+0.0001;\n            float MAXDX = map(fragColor.xyz + vel.xyz*speed.x).w + norm.w;\n            if(DX > MAXDX)\n                vel *= 0.25;*/\n            fragColor.xyz += vel.xyz;\n               fragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(13.,1.,10.4);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n                  {\n                   fragColor.xyz += body[1]*speed.x;\n                //fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n                  {\n                   fragColor.xyz -= body[1]*speed.x;\n                //fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n                  {\n                   fragColor.xyz += body[0]*speed.x;\n                //fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n                  {\n                   fragColor.xyz -= body[0]*speed.x;\n                //fragColor.w = 0.;\n            }\n            \n            fragColor.z-=.002; // gravity\n            \n            //fractal collision detection, removing the normal velocity component \n              //fragColor.xyz += 0.*norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n              //               + norm_feet.xyz*max(dot(fragColor.xyz, -norm_feet.xyz),0.)*exp(-max(norm_feet.w,0.)/0.04);\n              //fragColor.xyz += norm_feet.xyz*max(dot(fragColor.xyz, -norm_feet.xyz),0.)*exp(-max(norm_feet.w,0.)/0.04);\n              \n              //float vel_to_wall = min(dot(fragColor.xyz,norm.xyz),0.);\n              //float dist_to_wall = abs(map(posit.xyz)); // not really to wall in front, just any wall\n              //fragColor.xyz -= norm.xyz*vel_to_wall*(.1-dist_to_wall);\n              vec3 nearest = fragColor.xyz;\n              for (int i=0; i<10; i++) {\n                nearest -= normalize(calcGrad(nearest+posit.xyz).xyz)*map(nearest+posit.xyz).w;\n              }\n              if (isnan(nearest.x+nearest.y+nearest.z)) break;\n              //vec3 grad = calcGradSm(posit.xyz).xyz;\n              vec3 grad = -normalize(nearest);\n              float size = .05;\n              \n              if(length(nearest)<size*1.1 && fragColor.z<.001 && isKeyPressed(KEY_SPACE))\n                    {\n                     fragColor.z += .03;\n                  //fragColor.w = 0.;\n              }\n              \n              vec3 velocity = fragColor.xyz;\n              vec3 vel_normal = grad*dot(grad,fragColor.xyz)/dot(grad,grad);\n              vec3 vel_tangent = fragColor.xyz - vel_normal;\n              //vec3 grad2 = calcGradSm(posit.xyz+vel_tangent).xyz;\n              \n              //if (length(nearest)<size)\n              //fragColor.xyz += -.001*nearest/dot(nearest,nearest);\n              float collision = (1.-exp(-1600.*length(velocity)*max(0.,1.-length(nearest-velocity)/size)));\n              fragColor.xyz += (-vel_normal+.002*grad)*collision;\n              //fragColor.xyz += vel_tangent*(1.-sqrt(1.-dot(vel_normal,vel_normal)*collision*collision)/dot(velocity,velocity));\n              //fragColor.xyz += -vel_normal*(1.-exp(-16.*max(0.,.5-length(nearest)/size)));\n              //fragColor.xyz += .1*grad*(1.-exp(-1.*max(0.,1.-length(nearest-velocity)/size)));\n              \n              \n              if (length(nearest)<size*2.)\n              fragColor.xyz *= 0.9; //slowing down\n              \n              //fragColor.xyz = vel_tangent;\n              \n              //float collision = 1.-exp(min(map(posit.xyz).w-size,0.));\n              \n              // if already colliding with surface, back out slowly\n              //if (length(nearest)<size*.9) fragColor.xyz = vel_tangent + grad*.2*length(nearest);\n              /*if (length(nearest)<size)*/ //fragColor.xyz -= collision*grad*min(0.,dot(grad,fragColor.xyz))/dot(grad,grad);\n              /*if (length(nearest)<size)*/ //fragColor.xyz -= collision*grad2*min(0.,dot(grad2,fragColor.xyz))/dot(grad2,grad2);\n              //if (length(nearest)<size) fragColor.xyz += -nearest*max(0.,dot(nearest,fragColor.xyz))/dot(nearest,nearest);\n              //if (length(nearest)<size) fragColor.xyz += -grad*max(0.,dot(grad,fragColor.xyz))/dot(grad,grad);\n              \n              //fragColor.xyz = vel_normal+vel_tangent;\n              //fragColor.w = 0.;\n              \n             if (isKeyToggle(KEY_B)) fragColor.xyz = vec3(0.);\n              if (length(fragColor.xyz)>.001) fragColor.w = 0.;\n              \n            break;\n          case LIGHT_INDX:  //light\n            if(isKeyPressed(KEY_L))\n                  {\n                   fragColor.xyz = posit.xyz;\n                fragColor.w = .08;\n            }\n            if(iFrame < 1)\n            {\n                fragColor = vec4(12.5,-4,10.5, 0.1);\n            }\n            break; \n          case SPEED_INDX: //camera max speed\n            if(isKeyPressed(KEY_Q))\n                  {\n                   fragColor.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n                  {\n                   fragColor.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                fragColor.x = .01*CAMERA_SPEED;\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/// PATH MARCHING\n\nconst float PHI = 0.5*(sqrt(5.) + 1.); \nconst float PHI2 = 0.5*(sqrt(5.) - 1.); \n\nvec2 fibonacci_lattice(int i, int n)\n{\n    return vec2((float(i)+0.5)/float(n), mod(float(i)/PHI, 1.)); \n}\n\nvec2 fcircle(int i, int n)\n{\n    vec2 xy = fibonacci_lattice(i, n);\n    vec2 pt = vec2(2.*PI*xy.y, pow(xy.x, PHI2));\n    return pt.y*vec2(cos(pt.x), sin(pt.x));\n}\n\n#define Nsamp 512\n#define aperture 0.02\n#define focal_plane 0.6\n\nvoid getRay(out vec3 ro, out vec3 rd, vec2 pos, ivec2 p)\n{\n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n \tmat3 camera = getCamera(angles);\n    int kk = int(iMouse.z);\n  \t//dither position on the aperture\n    vec4 blue = texture(iChannel2, vec2(p)/1024. + PI*iTime);\n    int I = int(blue.x * float(Nsamp));\n    \n    pos += (blue.yz - 0.5)/iResolution.x;\n    vec2 delta = 2.*aperture*fcircle(I, Nsamp);\n    vec3 ro0 = vec3(delta.x, 0., delta.y);\n    vec3 rd0 = focal_plane*vec3(FOV*pos.x, 1, FOV*pos.y) - ro0;\n    \n    ro = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0).xyz + transpose(camera)*ro0;\n    rd = normalize(transpose(camera)*rd0);\n}\n\nvec4 light_sphere;\nvec4 light( in vec3 pos )\n{\n    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);\n    return   (e.zwwz*light_map( pos + e.xyy , iTime) + \n  \t\t\t  e.wwzz*light_map( pos + e.yyx , iTime) + \n\t\t\t  e.wzwz*light_map( pos + e.yxy , iTime) + \n              e.zzzz*light_map( pos + e.xxx , iTime) )/vec4(e.xxx, 1.);\n}\n\n\nvec3 light_distr(vec3 p)\n{\n    return vec3(1,1,1) * (4.*step(-light_sphere.w, -length(p - light_sphere.xyz)));\n}\n\nvec3 sky(vec3 ray)\n{\n    return 0.2*(cos(0.001*iTime)+1.)*vec3(1.15,1.1,1.0)*sqrt(1.-0.95*ray.z*ray.z)*(tanh(10.*ray.z)+1.);\n}\n\n\nvec3 path_march(vec3 p, vec3 ray, float t, float i, float angle, float seed)\n{\n    vec3 fincol = vec3(1.), finill = vec3(0.);\n    vec4 res = vec4(0.);\n    for(float b = 0.; (b < MAX_BOUNCE); b++)\n    {\n        if(b < 1.)\n        {\n            float h = map(p).w;\n            if (h < angle*t || t > MAX_DIST)\n            {\n                 res = vec4(p, h);\n            }\n        }\n       \n        if(res.xyz != p)\n        {\n            //march next ray\n       \t\tres = trace(p, ray, t, i, angle);\n        }\n         \n        if(t > MAX_DIST || (i >= MAX_STEPS && res.w > 5.*angle*t))\n        {\n            finill += sky(ray)*fincol;\n            break;\n        }\n        \n        /// Surface interaction\n        vec3 norm = calcNormal(res.xyz, res.w);    \n        //discontinuity correction\n        p = res.xyz - (res.w - 2.*angle*t)*norm;\n        \n        vec3 refl = reflect(ray, norm);\n        \n        float refl_prob = hash(seed*SQRT2);\n       \n        //random diffusion, random distr already samples cos(theta) closely\n        if(refl_prob < reflection)\n        {\n            vec3 rand = clamp(pow(1.-reflection,4.)*randn(seed*SQRT3),-1.,1.);\n        \tray = normalize(refl + rand);\n        }\n        else\n        {\n            vec3 rand = random_sphere(seed*SQRT3);\n            ray = normalize(norm + rand);\n        }\n      \n\n        //color and illuminaition\n        vec4 colp = map(p);\n        fincol = fincol*clamp(colp.xyz,0.,1.);\n        \n        //add fractal glow\n        finill += 5.*light_distr(p)*fincol;\n        finill += vec3(1.)*exp(-300.*clamp(pow(abs(length(colp.xyz-vec3(0.2,0.3+0.01*cos(iTime),0.75+0.01*sin(iTime)))),2.),0.,1.))*fincol;\n        finill += vec3(0.6)*exp(-300.*clamp(pow(abs(length(colp.xyz-vec3(0.3,0.8,0.3))),2.),0.,1.))*fincol;\n        \n        angle *= 1.15;\n    }\n    \n    return finill;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized centered pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n    \n    vec3 rand = 2.*blue3(2.*fragCoord, iTime) - 1.;\n \tvec3 ray = getRay(angles, pos+0.5*rand.xy/iResolution.x);\n    vec4 p = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    \n    light_sphere = texelFetch(iChannel3,  ivec2(LIGHT_INDX,0), 0);\n    light_sphere.xyz += 0.*light_sphere.w*vec3(sin(iTime), cos(iTime), 0.);\n    \n    fragColor = vec4(0.);\n\tfloat iter = 0., td = 0.;\n    vec4 res = trace(p.xyz, ray, td, iter, LOD);\n    iter*=.5; //give the bounces only half of the marches to improve speed\n    for(float i = 0.; i <SPP; i++)\n    {\n        fragColor.xyz += path_march(res.xyz, ray, td, iter, LOD*2., rand.x+hash(iTime+i));\n    }\n    \n    fragColor.xyz /= SPP;\n\n    vec4 posit = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n   \n    vec4 prev = texture(iChannel0, fragCoord/iResolution.xy);\n\n    float avg = (posit.w>1.)?AVG*tanh(posit.w*0.5*sqrt(1.-AVG)):0.2;\n    fragColor.xyz = avg*prev.xyz + (1.- avg)*fragColor.xyz;\n    fragColor.w = posit.w;\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n}", "buffer_d_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Temporal AA based on Epic Games' implementation:\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf\n// \n// Originally written by yvt for https://www.shadertoy.com/view/4tcXD2\n// Feel free to use this in your shader!\n\n// YUV-RGB conversion routine from Hyper3D\nvec3 encodePalYuv(vec3 rgb)\n{\n    rgb = pow(rgb, vec3(2.0)); // gamma correction\n    return vec3(\n        dot(rgb, vec3(0.299, 0.587, 0.114)),\n        dot(rgb, vec3(-0.14713, -0.28886, 0.436)),\n        dot(rgb, vec3(0.615, -0.51499, -0.10001))\n    );\n}\n\nvec3 decodePalYuv(vec3 yuv)\n{\n    vec3 rgb = vec3(\n        dot(yuv, vec3(1., 0., 1.13983)),\n        dot(yuv, vec3(1., -0.39465, -0.58060)),\n        dot(yuv, vec3(1., 2.03211, 0.))\n    );\n    return pow(abs(rgb), vec3(1.0 / 2.0)); // gamma correction\n}\n\n#define mip_blur 0.75\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 lastColor = texture(iChannel1, uv);\n    \n    vec3 antialiased = lastColor.xyz;\n    float mixRate = min(lastColor.w, 0.5);\n    \n    vec2 off = 1.0 / iResolution.xy;\n    //get new pixel value\n    vec3 in0 = max(texture(iChannel0, uv).xyz,1e-5);\n    \n    //average antialiased with new. apply gamma\n    antialiased = mix(antialiased * antialiased, in0 * in0, mixRate);\n    antialiased = sqrt(antialiased);\n    \n    //get neighbors\n    vec3 in1 = texture(iChannel0, uv + vec2(+off.x, 0.0), mip_blur).xyz;\n    vec3 in2 = texture(iChannel0, uv + vec2(-off.x, 0.0), mip_blur).xyz;\n    vec3 in3 = texture(iChannel0, uv + vec2(0.0, +off.y), mip_blur).xyz;\n    vec3 in4 = texture(iChannel0, uv + vec2(0.0, -off.y), mip_blur).xyz;\n    vec3 in5 = texture(iChannel0, uv + vec2(+off.x, +off.y), mip_blur).xyz;\n    vec3 in6 = texture(iChannel0, uv + vec2(-off.x, +off.y), mip_blur).xyz;\n    vec3 in7 = texture(iChannel0, uv + vec2(+off.x, -off.y), mip_blur).xyz;\n    vec3 in8 = texture(iChannel0, uv + vec2(-off.x, -off.y), mip_blur).xyz;\n    \n    //encode into YUV\n    antialiased = encodePalYuv(antialiased);\n    in0 = encodePalYuv(in0);\n    in1 = encodePalYuv(in1);\n    in2 = encodePalYuv(in2);\n    in3 = encodePalYuv(in3);\n    in4 = encodePalYuv(in4);\n    in5 = encodePalYuv(in5);\n    in6 = encodePalYuv(in6);\n    in7 = encodePalYuv(in7);\n    in8 = encodePalYuv(in8);\n    \n    //clamp colors\n    vec3 minColor = min(min(min(in0, in1), min(in2, in3)), in4);\n    vec3 maxColor = max(max(max(in0, in1), max(in2, in3)), in4);\n    minColor = mix(minColor,\n       min(min(min(in5, in6), min(in7, in8)), minColor), 0.5);\n    maxColor = mix(maxColor,\n       max(max(max(in5, in6), max(in7, in8)), maxColor), 0.5);\n    \n    //clamp antialiased with current neighbors\n   \tvec3 preclamping = antialiased;\n    antialiased = clamp(antialiased, minColor, maxColor);\n    \n    //update mix rate based on clamping strength \n    mixRate = 1.0 / (1.0 / (abs(mixRate)+1e-5) + 1.0);\n    \n    vec3 diff = antialiased - preclamping;\n    float clampAmount = dot(diff, diff);\n    \n    mixRate += clampAmount * 4.0;\n    mixRate = clamp(mixRate, 0.05, 0.5);\n    \n    //decode int RGB\n    antialiased = decodePalYuv(antialiased);\n        \n    fragColor = vec4(antialiased, mixRate);\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lycWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 300, 300, 318], [320, 320, 358, 358, 413], [415, 415, 456, 456, 818], [820, 834, 876, 876, 1035], [1096, 1096, 1121, 1164, 1344], [1346, 1346, 1403, 1403, 2071]], "test": "untested"}
{"id": "3tGcWD", "name": "patterns with brick tiles ", "author": "YitingLiu", "description": "Experiments with brick tiles and patterns. I also used the conditional statements. ", "tags": ["time", "zoom", "patterns", "sin", "circle", "cos", "box", "brick", "fract", "abs", "tiles", "if", "conditional", "bricktiles"], "likes": 0, "viewed": 234, "published": 3, "date": "1610987683", "time_retrieved": "2024-07-30T19:44:12.946137", "image_code": "\n\nvec2 brickTile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    // Here is where the offset is happening\n    \n    if(step(1., mod(_st.y,2.0))!=0. || step(1., mod(_st.x,2.0))==0.){\n\n            _st.y += step(1., mod(_st.x,2.0)) *iTime*-2.;\n    _st.y += step(0., mod(_st.x,2.0)) *iTime;\n\n    }else{\n            _st.x += step(0., mod(_st.y,2.0)) *iTime;\n            _st.x -= step(1., mod(_st.y,2.0)) *iTime*-2.;\n\n    }\n    // return mod(_st,2.0);\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size){\n    _size = vec2(0.5)-_size*(0.4-smoothstep(0.,0.4,abs(sin(iTime))/5.));\n    vec2 uv = smoothstep(_size,_size+vec2(1e-4),_st);\n    uv *=  smoothstep(_size,_size+vec2(1e-4),vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn smoothstep(_radius-(_radius*(1e-4)),\n                         _radius+(_radius*(1e-4)),\n                         dot(dist,dist)*4.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    // Apply the brick tiling\n    st = brickTile(st,5.);\n    color = vec3(box(st,vec2(0.9)));\n    color -= vec3(box(st,vec2(0.3)));\n\n    color += vec3(circle(st,0.5));\n    color -= vec3(circle(st,0.156));\n\n    // Uncomment to see the space coordinates\n    color *= vec3(st.x,st.y/10.,abs(sin(iTime)));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 40, 40, 467], [469, 469, 501, 501, 713], [716, 716, 760, 760, 935], [938, 938, 995, 995, 1405]], "test": "untested"}
{"id": "WtycWW", "name": "Specular highlight models", "author": "darkeclipz", "description": "Testing different specular highlight models, from left to right: Phong, Gaussian, and Beckmann.\n\nhttps://en.wikipedia.org/wiki/Specular_highlight\nhttps://bit.ly/35Qi8VT (notes with contour plots)", "tags": ["phong", "specular", "gaussian", "beckmann"], "likes": 8, "viewed": 476, "published": 3, "date": "1610977708", "time_retrieved": "2024-07-30T19:44:13.703114", "image_code": "#define RES iResolution.xy\n#define MIN_DIST 0.0001\n\nmat2 rotate(float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdCircle(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdShape(vec3 p) {\n    float mCircle = sdCircle(p, 0.4);\n    float sCircle = sdCircle(abs(p) - vec3(0.35,0.35,0), 0.25);\n    float d = smin(mCircle, sCircle, 0.1);\n    return d;\n}\n\nint id = 0;\nfloat map(vec3 p) {\n    id = 0;\n    float s = 1.5;\n    float d = sdShape(p*s)/s;\n    float d2 = sdShape(p*s - vec3(1.5,0,0))/s;\n    if(d2 < d) id = 1;\n    d = min(d, d2);\n    float d3 = sdShape(p*s + vec3(1.5,0,0))/s;\n    if(d3 < d) id = 2;\n    d = min(d, d3);\n    return d;\n}\n\nstruct hit {\n    float t;\n    float occlusion;\n    int id;\n};\n\nhit trace(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    float N = 100.;\n    for(i=0.; i < N; i++) {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if(d < MIN_DIST) {\n            break;\n        }\n        t += d;\n        if(t > 20.) {\n            break;\n        }\n    }\n    if(i == N) id = 0;\n    return hit(t, 1.-i/N, id);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.0001,0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy), \n                          map(p+h.yxy) - map(p-h.yxy), \n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nfloat angle(vec3 a, vec3 b) {\n    return acos(dot(a,b) / (length(a)*length(b)));\n}\n\nvec3 brdf(vec3 N, vec3 L, vec3 V, vec3 diff, vec3 spec, float exponent) {\n    vec3 R = reflect(L,N);\n    vec3 H = normalize(L+V);\n    \n    float k = 0.;\n    float NdotH = dot(N, H);\n    \n    if(id == 2) {\n        // phong specular\n        k = pow(max(0., dot(R,V)), exponent)*.7;\n    }\n    else if(id == 0) {\n        // gaussian specular\n        float m = 1.;\n        \n        // float NHm = NdotH / m; // is wrong but gives some anisotropic highlight?\n        float NHm = angle(N,H) / m;\n        float NHm2 = NHm*NHm;\n        k = exp(-NHm2)*1.2;\n    }\n    else if(id == 1) {\n        // beckmann\n        float m = 0.38;\n        //float alpha = acos(NdotH); // oh oh\n        //float tana = tan(alpha);\n        //float cosa = cos(alpha);\n        float tana = length(cross(N, H)) / NdotH; // bye acos\n        float cosa = NdotH;\n        float m2 = m*m;\n        float tana2 = tana*tana;\n        float cosa4 = pow(abs(cosa), 4.);\n        k = exp(-tana2 / m2) / (3.14159 * m2 * cosa4)*.4;\n    }\n    \n    // diff = texture(iChannel0, R).rgb;\n    float wrap = 0.5;\n    float diffuse = max(0., dot(L, N));\n    float wrap_diffuse = max(0., (dot(L, N) + wrap) / (1. + wrap));\n    \n    return diff * diffuse * wrap_diffuse  + spec * k;\n}\n\nvec3 shade(vec3 P, vec3 N, vec3 ro) {\n    vec3 V = normalize(P-ro);\n    vec3 ambient = vec3(0.1,0.1,0.2);\n    vec3 diffuse = vec3(.4, .4, .9);\n    vec3 specular = vec3(.8, .8, 1.0);\n    vec3 light1 = brdf(N, normalize(vec3(0,1,1) - P), V, diffuse, specular, 16.);\n    vec3 light2 = brdf(N, normalize(vec3(0,0,-0.5) - P), V, diffuse, specular, 16.);\n    return ambient + light1 + light2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-RES)/RES.y;\n    vec3 ro = vec3(0,0.1,2.);\n    ro.xz *= rotate(iMouse.x/RES.x*3.14*2.);\n    ro.yz *= rotate(-iMouse.y/RES.y*3.14*2.);\n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.2*ww);\n\n    hit hit = trace(ro, rd);\n    vec3 col = vec3(0);\n    if(hit.t < 20.) {\n        vec3 p = ro + hit.t*rd;\n        vec3 n = normal(p);\n        col = shade(p, n, ro) * hit.occlusion;\n    }\n    else {\n        col = texture(iChannel0, rd).rgb;\n    }\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtycWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 74, 74, 146], [148, 148, 189, 189, 275], [277, 277, 310, 310, 338], [340, 340, 369, 369, 456], [458, 458, 481, 481, 642], [656, 656, 675, 675, 932], [997, 997, 1026, 1026, 1341], [1343, 1343, 1364, 1364, 1564], [1566, 1566, 1595, 1595, 1648], [1650, 1650, 1723, 1723, 2875], [2877, 2877, 2914, 2914, 3265], [3267, 3267, 3324, 3324, 3967]], "test": "untested"}
{"id": "3tycWW", "name": "How to draw in a shader", "author": "Fjante", "description": "By referencing the buffer to iteself you can draw in your shader. \nI didn't find any other examples of this. I wish I had though, it would have saved me a lot of time.", "tags": ["drawbuffer"], "likes": 2, "viewed": 246, "published": 3, "date": "1610976865", "time_retrieved": "2024-07-30T19:44:14.598719", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)),1);\n    fragColor = texture(iChannel0, uv);\n    if(length((iMouse.xy / iResolution.xy) - uv) < 0.025)\n        fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 145]], "test": "untested"}
{"id": "ttKcD1", "name": "Chessboard example", "author": "cottayson", "description": "Simple chessboard pattern for learning purposes", "tags": ["2d", "chessboard"], "likes": 0, "viewed": 283, "published": 3, "date": "1610970679", "time_retrieved": "2024-07-30T19:44:15.499311", "image_code": "#define BLACK (vec3(0.0, 0.0, 0.0))\n#define WHITE (vec3(1.0, 1.0, 1.0))\n#define RED (vec3(1.0, 0.0, 0.0))\n#define GREEN (vec3(0.0, 1.0, 0.0))\n#define BLUE (vec3(0.0, 0.0, 1.0))\n#define YELLOW (vec3(1.0, 1.0, 0.0))\n#define PURPLE (vec3(0.0, 1.0, 1.0))\n\n// Proof that iResolution.z = 1 (example of fetching information in GLSL)\nvec3 proof(vec2 uv, vec3 c1, vec3 c2) {\n    if (uv.x < iResolution.z * iResolution.x / 2.0) {\n        return c1;\n    } else {\n        return c2;\n    }\n}\n\nvec3 drawRect(vec2 uv, vec3 lastcolor, vec3 newcolor, vec4 rect) {\n    if (uv.x > rect.x && uv.y > rect.y && uv.x < rect.x + rect.z && uv.y < rect.y + rect.w) {\n        return newcolor;\n    }\n    return lastcolor;\n}\n\n// Draw chessboard using drawRect method.\nvec3 drawChessboardSlow(vec2 uv, vec3 color1, vec3 color2, vec2 rectSize, vec2 screenSize) {\n    float w = screenSize.x;\n    float h = screenSize.y;\n    vec3 colacc = color1;\n    for (int i = 0; i <= int(w / rectSize.x); i++) {\n        for(int j = 0; j <= int(h / rectSize.y); j++) {\n            float coef = float((i + j) % 2);\n            colacc = drawRect(\n                uv, colacc, \n                color2 * coef + colacc * (1.0 - coef),\n                vec4(w - float(i + 1) * rectSize.x, h - float(j + 1) * rectSize.y,\n                     rectSize.x, rectSize.y));\n        }\n    }\n    return colacc;\n}\n\n// Draw chessboard directly from pixel position.\nvec3 drawChessboardFast(vec2 uv, vec3 c1, vec3 c2, vec2 rectSize, vec2 screenSize) {\n    int i = int((screenSize.x - uv.x) / rectSize.x);\n    int j = int((screenSize.y - uv.y) / rectSize.y);\n    if ((i + j) % 2 == 0) {\n        return c1;\n    } else {\n        return c2;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Simple pixel coordinates (from (0,0) to iResolution.xy) (iResolution.z = 1)\n    vec2 uv = fragCoord;\n    float w = iResolution.x; // width of screen in pixels\n    float h = iResolution.y; // height of screen in pixels\n\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    vec2 rectSize = vec2(1.0, 1.0) * 10.0;\n    \n    \n    // col = drawChessboardSlow(uv, RED, GREEN, rectSize, iResolution.xy);\n    col = drawChessboardFast(uv, RED, GREEN, rectSize, iResolution.xy);\n\n    \n    // col = proof(uv, RED, WHITE);\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 326, 365, 365, 478], [480, 480, 546, 546, 695], [697, 739, 831, 831, 1349], [1351, 1400, 1484, 1484, 1677], [1679, 1679, 1736, 1819, 2303]], "test": "untested"}
{"id": "WlycWh", "name": "Quad - Gradient Boundaries", "author": "iq", "description": "Analytically finding the boundaries of the gradient of an quad SDF. This is also the \"skeleton\" of the shape - all points in this skeleton are equidistant to their two closest quad edges.", "tags": ["2d", "quad", "incenter", "equicenter"], "likes": 14, "viewed": 683, "published": 3, "date": "1610952684", "time_retrieved": "2024-07-30T19:44:16.262272", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytically finding the boundaries of the\n// gradient of an quad SDF.\n//\n// The gradisQuad() fuction below returs the two\n// points of the central segment that separates the\n// four constant gradient regions. It also returns\n// in interger (0 or 1) telling you how to connect\n// the quds's corners to these two points.\n\n// Other Gradient boundaries:\n//\n// Triangle: https://www.shadertoy.com/view/tlKcDz\n// Quad:     https://www.shadertoy.com/view/WlycWh\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat dot2(in vec2 a ) { return dot(a,a); }\n\nvoid quadSkeleton( in vec2 v[4], out vec2 qa, out vec2 qb, out int of )\n{\n    of = 0;\n    if( dot2(v[1]-v[0])+dot2(v[3]-v[2]) > \n        dot2(v[2]-v[1])+dot2(v[0]-v[3]) )\n    {\n        vec2 t = v[0];\n        v[0] = v[1]; \n        v[1] = v[2];\n        v[2] = v[3]; \n        v[3] = t;\n        of = 1;\n    }\n    \n    vec2 s10 = v[1]-v[0]; float e10 = length(s10);\n    vec2 s21 = v[2]-v[1]; float e21 = length(s21);\n    vec2 s32 = v[3]-v[2]; float e32 = length(s32);\n    vec2 s03 = v[0]-v[3]; float e03 = length(s03);\n\n    float kd = cro(s03,s21);\n    float k0 = cro(s03,s10);\n    float k1 = cro(s10,s21);\n    float k2 = cro(s21,s32);\n    float k3 = cro(s32,s03);\n    \n    // k0+k2 = k1+k3 = area = cro(s20,s31) = cro(v[2]-v[0],v[3]-v[1])\n    \n    // k3 = k0+k2-k1;\n    \n    qa = 0.5*(v[0]+v[1]) + \n         0.5*((s03*e10-s10*e03)*k1 -\n              (s21*e10-s10*e21)*k0)/(-k0*e21-k1*e03+kd*e10);\n\n    qb = 0.5*(v[2]+v[3]) + \n         0.5*((s21*e32-s32*e21)*k3 -\n              (s03*e32-s32*e03)*k2)/(-k2*e03-k3*e21-kd*e32);\n}\n\n//----------------------------------------------------\n\nvec2 sdSeg( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2(dot2(pa-ba*h), cro(pa, ba));\n}\n\nvec3 sdgQuad( in vec2 p, in vec2 v[4] )\n{\n    float gs = cro(v[0]-v[3],v[1]-v[0]);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v[1]-v[0];\n    vec2  w = p-v[0];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v[2]-v[1];\n    vec2  w = p-v[1];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v[3]-v[2];\n    vec2  w = p-v[2];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n\n    // edge 3\n    {\n    vec2  e = v[0]-v[3];\n    vec2  w = p-v[3];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }    \n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    float time = iTime;\n    vec2 v[4] = vec2[4](\n        vec2(-0.9,-0.5) + 0.3*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n\t    vec2( 0.9,-0.5) + 0.3*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n\t    vec2( 0.9, 0.5) + 0.3*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ),\n\t    vec2(-0.9, 0.5) + 0.3*cos( 1.1*time + vec2(0.0,1.5) + 0.0 ) );\n\n\n\tvec3 dg = sdgQuad(p, v);\n    float d = dg.x;\n    vec2  g = dg.yz;\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.1,1.4,1.7)*0.5;\n    col *= 0.5+vec3(0.5+0.5*g,0.5);\n    col *= 1.0 - 0.7*exp(-8.0*abs(d));\n    col *= 0.8 + 0.2*cos(200.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    col = clamp(col,0.0,1.0);\n \n    int of;\n    vec2 qa, qb;\n    quadSkeleton( v, qa, qb, of);\n   \n\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdSegment( p, v[(0+of)  ], qa )-0.003));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdSegment( p, v[(1+of)  ], qa )-0.003));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdSegment( p, v[(2+of)  ], qb )-0.003));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdSegment( p, v[(3+of)&3], qb )-0.003));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdDisk(p,qb,0.025)));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdDisk(p,qa,0.025)));\n    col = mix(col,vec3(1.0,1.0,1.0),smoothstep(2.0*px,0.0,sdSegment( p, qa, qb)-0.003));\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlycWh.jpg", "access": "api", "license": "mit", "functions": [[1539, 1539, 1574, 1574, 1602], [1603, 1603, 1627, 1627, 1646], [1648, 1648, 1721, 1721, 2669], [2727, 2727, 2774, 2774, 2919], [2921, 2921, 2962, 2962, 4157], [4159, 4159, 4211, 4211, 4331], [4334, 4363, 4413, 4413, 4441], [4445, 4445, 4502, 4502, 6029]], "test": "untested"}
{"id": "3lGXRc", "name": "Vesica - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a [url=https://www.shadertoy.com/view/XtVfRW]Vesica[/url]. Faster than central differences or automatic differentiation/dual numbers most probably. ", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "vesica"], "likes": 6, "viewed": 890, "published": 3, "date": "1610949056", "time_retrieved": "2024-07-30T19:44:17.022241", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a Vesica. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgVesica(vec2 p, float r, float d)\n{\n    vec2 s = sign(p); p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    \n    vec3 res;\n    if( (p.y-b)*d > p.x*b )\n    {\n        vec2  q = vec2(p.x,p.y-b);\n        float l = length(q)*sign(d);\n        res = vec3( l, q/l );\n    }\n    else\n    {\n        vec2  q = vec2(p.x+d,p.y);\n        float l = length(q);\n        res = vec3( l-r, q/l );\n    }\n    return vec3(res.x, res.yz*s );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // animate\n    float time = iTime;\n    float r1 = 0.5*cos(time+12.0);\n    float r2 = 0.2*sin(time*1.4);\n\n    // sdf(p) and gradient(sdf(p))\n    vec3  dg = sdgVesica( p, 0.7, r1 );\n    float d = dg.x + r2;\n    vec2  g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n  //col = vec3(0.5+0.5*g,1.0);\n    col *= 1.0 - 0.7*exp(-8.0*abs(d));\n\tcol *= 0.9 + 0.1*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGXRc.jpg", "access": "api", "license": "mit", "functions": [[1374, 1469, 1511, 1511, 1942], [1944, 1944, 2001, 2001, 2717]], "test": "untested"}
{"id": "3tGXRc", "name": "Pie - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a [url=https://www.shadertoy.com/view/3l23RK]pie[/url]. Faster than central differences or automatic differentiation/dual numbers most probably. ", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "pie"], "likes": 11, "viewed": 950, "published": 3, "date": "1610948151", "time_retrieved": "2024-07-30T19:44:17.786701", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a pie. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\n// c is the sin/cos of the angle. r is the radius\nvec3 sdgPie( in vec2 p, in vec2 c, in float r )\n{\n    float s = sign(p.x); p.x = abs(p.x);\n    \n    float l = length(p);\n    float n = l - r;\n    vec2  q = p - c*clamp(dot(p,c),0.0,r);\n\tfloat m = length(q)* sign(c.y*p.x-c.x*p.y);\n    \n    vec3  res = (n>m) ? vec3(n,p/l) : vec3(m,q/m);\n    return vec3(res.x,s*res.y,res.z);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animation\n        float t =            3.14*(0.5+0.5*cos(iTime*0.52));\n        vec2  w = vec2(0.50,0.25)*(0.5+0.5*cos(iTime*vec2(1.1,1.3)+vec2(0.0,2.0)));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgPie(p,vec2(sin(t),cos(t)), 0.65);\n        float d = dg.x;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGXRc.jpg", "access": "api", "license": "mit", "functions": [[1370, 1515, 1564, 1564, 1840]], "test": "untested"}
{"id": "WtVcD1", "name": "Quad - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) quad. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "quad"], "likes": 9, "viewed": 887, "published": 3, "date": "1610944508", "time_retrieved": "2024-07-30T19:44:18.556643", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a quad. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 sdgQuad( in vec2 p, in vec2 v[4] )\n{\n    float gs = cro(v[0]-v[3],v[1]-v[0]);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v[1]-v[0];\n    vec2  w = p-v[0];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v[2]-v[1];\n    vec2  w = p-v[1];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v[3]-v[2];\n    vec2  w = p-v[2];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n\n    // edge 3\n    {\n    vec2  e = v[0]-v[3];\n    vec2  w = p-v[3];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }    \n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n        vec2 v[4] = vec2[4](\n            vec2(-0.9,-0.5) + 0.3*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n            vec2( 0.9,-0.5) + 0.3*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n            vec2( 0.9, 0.5) + 0.3*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ),\n            vec2(-0.9, 0.5) + 0.3*cos( 1.1*time + vec2(0.0,1.5) + 0.0 ) );\n\n        // corner radious\n        float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgQuad(p,v);\n        float d = dg.x-ra;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVcD1.jpg", "access": "api", "license": "mit", "functions": [[1373, 1468, 1503, 1503, 1531], [1532, 1532, 1573, 1573, 2768]], "test": "untested"}
{"id": "tlVyWh", "name": "Triangle - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a (rounded) triangle. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "triangle", "gradient", "distance"], "likes": 9, "viewed": 848, "published": 3, "date": "1610944415", "time_retrieved": "2024-07-30T19:44:19.860157", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and gradient to a triangle. Probably\n// faster than central differences or automatic \n// differentiation/dual numbers.\n\n// List of other 2D distances+gradients:\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// Circle:             https://www.shadertoy.com/view/WltSDj\n// Pie:                https://www.shadertoy.com/view/3tGXRc\n// Arc:                https://www.shadertoy.com/view/WtGXRc\n// Isosceles Triangle: https://www.shadertoy.com/view/3dyfDd\n// Triangle:           https://www.shadertoy.com/view/tlVyWh\n// Box:                https://www.shadertoy.com/view/wlcXD2\n// Quad:               https://www.shadertoy.com/view/WtVcD1\n// Cross:              https://www.shadertoy.com/view/WtdXWj\n// Segment:            https://www.shadertoy.com/view/WtdSDj\n// Hexagon:            https://www.shadertoy.com/view/WtySRc\n// Vesica:             https://www.shadertoy.com/view/3lGXRc\n// Smooth-Minimum:     https://www.shadertoy.com/view/tdGBDt\n// Parallelogram:      https://www.shadertoy.com/view/sssGzX\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdgTriangle( in vec2 p, in vec2 v[3] )\n{\n    float gs = cro(v[0]-v[2],v[1]-v[0]);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v[1]-v[0];\n    vec2  w = p-v[0];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v[2]-v[1];\n    vec2  w = p-v[1];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v[0]-v[2];\n    vec2  w = p-v[2];\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        // animate\n        float time = iTime;\n        vec2 v[3] = vec2[3](\n            vec2(-0.8,-0.3) + 0.5*cos( 0.5*time + vec2(0.0,1.9) + 4.0 ),\n            vec2( 0.8,-0.3) + 0.5*cos( 0.7*time + vec2(0.0,1.7) + 2.0 ),\n            vec2( 0.0, 0.3) + 0.5*cos( 0.9*time + vec2(0.0,1.3) + 1.0 ) );\n\n        // corner radious\n        float ra = 0.1*(0.5+0.5*sin(iTime*1.2));\n\n        // sdf(p) and gradient(sdf(p))\n        vec3  dg = sdgTriangle(p,v);\n        float d = dg.x-ra;\n        vec2  g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n        vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.7*exp(-8.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n \t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyWh.jpg", "access": "api", "license": "mit", "functions": [[2110, 2110, 2145, 2145, 2173], [2175, 2270, 2315, 2315, 3232]], "test": "untested"}
{"id": "wtKcRh", "name": "[]Tetrascape", "author": "Catzpaw", "description": "fullscreen recommended.", "tags": ["raymarching", "music"], "likes": 13, "viewed": 525, "published": 3, "date": "1610936703", "time_retrieved": "2024-07-30T19:44:20.942264", "image_code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Image:color\n\nvec3 hsv(float h,float s,float v){\n    return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\nvec3 tx1(vec3 rd,float b){\n    float a=bit(rd*5e2),r=pow(fract(a+floor(b)*1e-2),10.);\n    return hsv(iTime*.1+a*75.,step(.8,r)*.5,step(.1,r)*.25+step(.7,r)*.75);\n}\nvec3 bg(vec3 rd,float pr,float b){\n    float e=pr;\n    vec3 c=tx1(rd,b);rd.xz*=rot(e);c+=tx1(rd,b);\n    rd.yz*=rot(e);c+=tx1(rd,b);rd.xz*=rot(-e);c+=tx1(rd,b);\n    return c*.25;\n}\nvec3 vol(vec3 ro,vec3 rd,float d){\n    float t=0.,v=0.;\n    vec3 c=vec3(0);\n    float it=d==1.?140.:d*80.;\n    for(float i=0.;i<it;i+=20.){\n        v=bit(ro+rd*i);\n        c+=hsv(length(ro)+i*.133,.8,v);\n    }\n    return c*.2;\n}\nvec3 depth(vec2 p,float h,float d){\n    return d==1.?vec3(.3):hsv(h,.3,1.-d);\n}\nconst uint[32] mseq=uint[](\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00300000u,0x03003000u,    \n    0x33333333u,0x33333333u,0x33333333u,0x00003333u,0x00003333u,0x00000000u,0x00000000u,0x20303333u,\n    0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22222222u,0x22322222u,0x03223222u,    \n    0x33333333u,0x30303333u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x11110000u);\nint getmode(float b){\n    int p=int(b)-2,n=p>>3,s=(p&7)*4;\n    return b<2.?1:n>31?0:int((mseq[n]>>s)&15u);\n}\nvoid mainImage(out vec4 col,in vec2 fc){\n    vec2 uv=fc/iResolution.xy,xy=(fc-.5*iResolution.xy)/iResolution.y,u=vec2(0,1)*rot(-iTime*.5);\n    vec4 d=texture(iChannel0,uv);\n    float pr=1./(ZOOM*iResolution.x),t=(iTime+ADJUST)*SPEED,b=(iTime+ADJUST)*BPM/60.;\n    int mode=getmode(b);\n    vec3 c=vec3(0),ro=getro(vec3(90),t),rd=getrd(normalize(vec3(xy,ZOOM)),t),p;\n    c=mode!=1?c:bg(rd,pr,b)*.5;\n    c=mode!=2?c:vol(ro,rd,d.a);\n    c=mode!=3?c:depth(xy,d.r,d.a);\n    c=mode!=0?c:mix(hsv(d.r,1.,d.b)+d.g,bg(rd,pr,b),d.a*.5)+hsv(d.r,.8,d.g*4.);\n    col=vec4(c,1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Buffer A:raymarching\n\n#define ITER 280\n#define NEAR 0.2\n#define FAR 160.\n\nfloat map(vec3 p,float beat){\n    float b=pow(fract(bit(p)*(7.+floor(beat*.5)*2.33e-3)),30.),v=.5-abs(b-.5);\n    return v<.44?1.1:length(fract(p)-.5)-v*(.6+clamp(abs(sin(beat*pi)*2.),0.,1.)*.35);\n}\nfloat trace(vec3 ro,vec3 rd,float pr,out vec3 p){\n    float beat=(iTime+ADJUST)*BPM/60.,t=NEAR;\n    for(int i=ZERO;i<ITER;i++){float d=map(p=ro+rd*t,beat);\n        if(abs(d)<pr||t>FAR)break;t+=(step(d,.5)*d+d)*(.5+t*.25/FAR);}\n    return min(t,FAR);\n}\nvoid mainImage(out vec4 col,in vec2 fc){\n    vec2 uv=(fc-.5*iResolution.xy)/iResolution.y;\n    float pr=6./(ZOOM*iResolution.y),t=(iTime+ADJUST)*SPEED;\n    vec3 ro=getro(vec3(90),t),rd=getrd(normalize(vec3(uv,ZOOM)),t),p;\n    float d=trace(ro,rd,pr,p);\n    vec3 n=normalize(fract(p)-.5);rd.yz*=rot(-.0);\n    float h=bit(p)+bit(p*80.)*.6,v=1.3-d/FAR,l=dot(rd,n)+1.,s=pow(clamp(dot(-rd,n),0.,1.),16.);\n    col=d>=FAR?vec4(0,0,0,1):vec4(h,v*s,v*l,d/FAR);\n}\n", "buffer_a_inputs": [], "common_code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Common:settings & snippets\n\n#define BPM 135.0\n#define SPEED 0.15\n\n#define ADJUST 0.0\n\n#define ZOOM .7\n#define ZERO min(0,iFrame)\nconst float pi=acos(-1.);\nconst float r7=sqrt(7.);\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nfloat bit(vec3 p){ivec3 i=ivec3(p);return fract(float(i.x^i.y^i.z)*r7);}\nvec3 getro(vec3 ro,float t){ro.xz*=rot(t*.43);ro.xy*=rot(t*.32);ro.yz*=rot(t*.21);return ro;}\nvec3 getrd(vec3 rd,float t){rd.xz*=rot(t*.10);rd.xy*=rot(t*.14);rd.yz*=rot(t*.13);return rd;}\n", "sound_code": "//---Tetrascape\n// by Catzpaw 2021\n\n//Sound:scale sequencer 3\n\n//--- Scale Sequencer 3 by Catzpaw 2020\n//https://www.shadertoy.com/view/ts3fDN\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =440.;\t//master tuning (Hz)\nconst float bpm  =BPM;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=2.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst float gateSeed=303.; //random seed for gate generator;\nconst float noteSeed=278.; //random seed for note generator;\n\n//SCALE\nint key=2; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\nconst uint[4] scl=uint[](0xca875320u,0xcb975420u,0xcb875320u,0xcb975320u); //minor,major,harmonic,melodic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\nconst int chordlen=64;const uint chordseq[chordlen]=uint[](\n\t0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x00000001u,0x0c000102u,0x000000c3u,0x0c00c344u,0x00000045u,0x00000044u,0x000000c3u,0x00000002u,\n\t0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u,0x01u);\n\n//PATTERN (version 3)\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x08008001u,0x070af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x36605713u,0x46746589u,0x56183614u,0x360e1510u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973175u,0x36390710u,  //08-0B melody\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,  //0C-13 \n    0x70080868u,0x70086865u,0x18164656u,0x18164656u,  //14-17 accompaniment,bass\n    0x3238e232u,0x3138e132u,0x61382132u,0x9d1ce136u,  //18-1B sd+hh\n    0x01010101u,0x01c10181u,0x11c14581u,0x55d10591u); //1C-1F bd+fx\n\n//PATTERN SEQUENCE (version 3)\nconst int len1=64;const uint[len1] seq1=uint[]( //snare+hihat 18 19 1a 1b\n    0x00000001u,0x00000001u,0x00000001u,0x08001019u,0x00000018u,0x00000018u,0x00000019u,0x0000001bu,\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,0x08018001u,0x00000001u,0x08018001u,0x0800101bu,\n    0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,\n    0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x00000001u,0x0000001bu,    \n    0x00000018u,0x0000001au,0x00000018u,0x08018019u,0x00000018u,0x0000001au,0x00000019u,0x0000001bu,\n    0x00000018u,0x0000001au,0x00000018u,0x08018019u,0x00000018u,0x0000001au,0x00000019u,0x0000001bu,    \n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,0x00000018u,0x00000018u,0x00000019u,0x0000001bu,\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,0x00000018u,0x00000018u,0x00000019u,0x0000001bu);\n\nconst int len2=64;const uint[len2] seq2=uint[]( //bassdrum+conga 1c 1d 1e 1f\n    0x00000001u,0x00000001u,0x0000001cu,0x1c01c01fu,0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x00000001u,0x1c00101fu,\n    0x0101c001u,0x00000001u,0x00000001u,0x0800101du,0x0101c001u,0x00000001u,0x0101c001u,0x1c00101fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x0000001cu,0x1c01c01fu,\n    0x0000001du,0x0000001eu,0x0000001du,0x0801d01fu,0x0000001du,0x0000001du,0x0000001eu,0x0801f01fu,\n    0x0000001du,0x0000001eu,0x0000001du,0x0801d01fu,0x0000001du,0x0000001du,0x0000001eu,0x1801f01fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01fu,\n    0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01du,0x0000001cu,0x0000001cu,0x0000001cu,0x0801c01fu);\n\nconst int len3=64;const uint[len3] seq3=uint[]( //bass 616\n    0x00000600u,0x00000600u,0x00000600u,0x00000600u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000600u,0x00000600u,0x00000600u,0x0c000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,\n    0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u,0x00000616u);\n\nconst int len4=64;const uint[len4] seq4=uint[]( //chord 003 002\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n    0x04000003u,0x00000000u,0x08000003u,0x00000000u,0x06000003u,0x0c000003u,0x00000000u,0x00000000u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,\n    0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,0x00000003u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000002u,\n    0x00000002u,0x00000002u,0x00000002u,0x00000002u,0x00000003u,0x04000003u,0x08000003u,0x0c000003u,\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,0x00000000u);\n\nconst int len5=64;const uint[len5] seq5=uint[]( //accompaniment 814\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x04000814u,0x08000814u,0x0c000814u,\n    0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,\n    0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,0x00000800u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,\n    0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u,0x00000814u);\n\nconst int len6=64;const uint[len6] seq6=uint[]( //melody 004-00b\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,\n    0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,\n    0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,0x04u,0x05u,0x06u,0x07u,0x08u,0x09u,0x0au,0x0bu,\n    0x08000004u,0x08000005u,0x08000006u,0x08000007u,0x00000000u,0x00000000u,0x00000000u,0x00000000u,\n    0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u,0x00u);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n//WAVETABLE OSC(namco C30/N163)\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\nfloat nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.1);}\n\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n\n//Tetrascape instruments\nfloat fx1(float x){return (osc_c30(293.*x,7)+osc_c30(440.*x,7))*env_d(x,.12);}\nfloat fx2(float x){return osc_duty(3e2*x*(1.+x*3.),.5)*env_d(x,.07);}\nfloat sd(float x){return osc_nesnoise(x,11)*env_d(x,.25)+osc_duty(6./(x*.5+.1),.5)*.3*env_d(x,.05);}\n\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);ch=st<d?ch:get8(p,0);sc=st<d?sc:get2(p,12);scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateSeed)*50.)<(float(get4(pt,6))*.0625)?-99:\n        imod(int(abs(sin(float(s+s1+s*s2)*noteSeed)*float(s2))),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n//TRACK 1 snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?sd(n.x)*vec2(.48,.62):vec2(0);\n    o+=(n.y==2.)?neshh(n.x,.08)*vec2(.15,.24):vec2(0);\n    o+=(n.y==3.)?neshh(n.x,.2)*vec2(.15,.24):vec2(0);\n    return o;\n}\n//TRACK 2 bassdrum,fx1,fx2\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?nesbd(n.x)*vec2(.4,.55):vec2(0);\n    o+=(n.y==2.)?fx1(n.x)*vec2(.45,.65):vec2(0);\n    o+=(n.y==3.)?fx2(n.x)*vec2(.35,.15):vec2(0);\n    return o;\n}\n//TRACK 3 bass\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?dutybass(freq(n.y+36.)*n.x,n.x)*vec2(.28,.31):vec2(0);\n    o+=(n.y>-50.)?lpfsaw(n.y+36.,n.x,sin(t*bpm*3.142/480.)*.3+.34,.9)*vec2(.2)*env_d(n.x,.6)*vec2(.88,.98):vec2(0);\n    return o;\n}\n//TRACK 4 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?c30chord(freq(n.y+36.03)*n.x,n.x)*.25:vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(2)+48.02)*n.x,n.x)*vec2(.30,.20):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(4)+36.01)*n.x,n.x)*vec2(.31,.19):vec2(0);\n    o+=(n.y>-50.)?c30chord(freq(getChord(6)+48.01)*n.x,n.x)*vec2(.32,.18):vec2(0);\n    return o;\n}\n//TRACK 5 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?c30bell(freq(n.y+72.)*n.x,n.x)*vec2(.30,.35):vec2(0);\n    return o;\n}\n//TRACK 6 melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?lpfc30(n.y+48.03,n.x,sin(t*bpm*3.142/180.)*.3+.4,.9,3)*vec2(.40,.50):vec2(0);\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):track1(t,l,s)*.7; //TRACK 1 snaredrum,closehh,openhh\n    o+=e?track2(t,l,s):track2(t,l,s)*.5; //TRACK 2 bassdrum,fx1,fx2\n    o+=  track3(t,l,s);                  //TRACK 3 bass\n    o+=  track4(t,l,s);                  //TRACK 4 chord\n    o+=e?track5(t,l,s):track5(t,l,s)*.8; //TRACK 5 accompaniment\n    o+=  track6(t,l,s);                  //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    13\n#define DELAY_WET       0.50\n#define DELAY_FEEDBACK  0.88\n#define DELAY_TIME      0.153\n#define DELAY_STEREO    0.11\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 85, 85, 168], [169, 169, 195, 195, 332], [333, 333, 367, 367, 512], [513, 513, 547, 547, 741], [742, 742, 777, 777, 821], [1263, 1263, 1284, 1284, 1371], [1372, 1372, 1412, 1412, 1935]], "test": "untested"}
{"id": "3lVyD1", "name": "Electric Flower (Music)", "author": "darkeclipz", "description": "Fork of https://www.shadertoy.com/view/wt3cWB.\n\nChanged it to do something else, but now with music!", "tags": ["psychedelic", "glow", "webglsamples", "electricflower"], "likes": 15, "viewed": 855, "published": 3, "date": "1610935111", "time_retrieved": "2024-07-30T19:44:21.806952", "image_code": "/*\nRecreation of \"Electric Flower\" by Henrik Rydgard: https://webglsamples.org/electricflower/electricflower.html\nI have no idea how he actually achieved the effect but this is what I came up with.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat mapScene(in vec3 p) {\n\n    \n    float o1 = texture(iChannel1, vec2(.4)).x * .7,\n          o2 = texture(iChannel1, vec2(.7)).x * .7;\n          \n    float r = iTime;\n    float c = cos(r + o1), s = sin(r + o1);\n    mat2 rmat1 = mat2(c, -s, s, c);\n    \n    float c2 = cos(r + o2), s2 = sin(r + o2);\n    mat2 rmat2 = mat2(c2, -s2, s2, c2);\n\n    p.yz *= rmat1;\n    p.xz *= rmat2;\n\n    float w = texture(iChannel1, vec2(.04)).x;\n    vec3 q = abs(p) - 0.1 - w ;\n    float box = max(q.x, max(q.y, q.z));\n\n    box = max(box, -max(q.x, q.y) - 0.03);\n    box = max(box, -max(q.x, q.z) - 0.03);\n    box = max(box, -max(q.y, q.z) - 0.03);\n\n    return box;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    \n    float w = texture(iChannel1, vec2(.35)).x;\n                \n    fragColor = texture(iChannel0, (fragCoord - screenCenter) * clamp((0.89 + w / 6.), 0.96, 1.02) / iResolution.xy + 0.5);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += hue2rgb(iTime * 0.5) * 0.5;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n    fragColor = fragColor * 0.9;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25229, "src": "https://soundcloud.com/nocopyrightsounds/ncs-the-best-of-2015-album-mix", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 257, 257, 323]], "test": "untested"}
{"id": "WlKcW1", "name": "Electric Flower (Variant)", "author": "darkeclipz", "description": "Fork of https://www.shadertoy.com/view/wt3cWB.\n\nChanged it to do something else. ", "tags": ["psychedelic", "glow", "webglsamples", "electricflower"], "likes": 6, "viewed": 393, "published": 3, "date": "1610933550", "time_retrieved": "2024-07-30T19:44:22.560936", "image_code": "/*\nRecreation of \"Electric Flower\" by Henrik Rydgard: https://webglsamples.org/electricflower/electricflower.html\nI have no idea how he actually achieved the effect but this is what I came up with.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat mapScene(in vec3 p) {\n\n    \n    float o1 = texture(iChannel0, vec2(.2)).x / 8.,\n          o2 = texture(iChannel0, vec2(.35)).x / 12.;\n          \n    float r = iTime * 2.0;\n    float c = cos(r + o1), s = sin(r + o1);\n    mat2 rmat1 = mat2(c, -s, s, c);\n    \n    float c2 = cos(r + o2), s2 = sin(r + o2);\n    mat2 rmat2 = mat2(c2, -s2, s2, c2);\n\n    p.yz *= rmat1;\n    p.xz *= rmat2;\n\n    float w = texture(iChannel0, vec2(.55)).x;\n    vec3 q = abs(p) - 0.5 - w/3.5;\n    float box = max(q.x, max(q.y, q.z));\n\n    box = max(box, -max(q.x, q.y) - 0.03);\n    box = max(box, -max(q.x, q.z) - 0.03);\n    box = max(box, -max(q.y, q.z) - 0.03);\n\n    return box;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    \n    float w = texture(iChannel0, vec2(.6)).x;\n                \n    fragColor = texture(iChannel0, (fragCoord - screenCenter) * (0.89 + clamp(w/9., .05, .14)) / iResolution.xy + 0.5);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += hue2rgb(iTime * 0.5) * 0.5;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n    \n    fragColor = fragColor * 0.9;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 257, 257, 323]], "test": "untested"}
{"id": "3tVcDh", "name": "Convex Intersection", "author": "xjorma", "description": "A simple raytracing convex intersection i wrote to make this shader: https://www.shadertoy.com/view/3tyyDz\nI think it might be useful for someone else.\n", "tags": ["intersection", "raytrace", "convex"], "likes": 2, "viewed": 335, "published": 3, "date": "1610930420", "time_retrieved": "2024-07-30T19:44:23.343843", "image_code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA      0\n\nconst float fltMax = 1000000.;\nconst float fltMin = -1000000.;\n\n\nbool convexIntersect( in vec3 ro, in vec3 rd, out vec2 oDis, out vec3 oNor)\n{\n    oDis = vec2(fltMin, fltMax);\n    for(int i = 0 ;i < numPlanes; i++)\n    {\n        vec4 plane = planes[i];\n        float t = -(plane.w + dot(plane.xyz, ro)) / dot(plane.xyz, rd);\n        if(dot(plane.xyz, rd) < 0.) // enter\n        {\n            if(t > oDis.x)\n            {\n                oDis.x = t;\n                oNor = plane.xyz;\n            }\n        }\n        else  // exit\n        {\n            oDis.y = min(oDis.y, t);\n        }\n    }\n    if(oDis.x < oDis.y)\n    {\n        return true;\n    }\n    return false;\n}\n\nvec3 render(in vec3 ro,in vec3 rd)\n{\n    vec3 col;\n    vec3  n;\n    vec2  d;\n    if(convexIntersect(ro, rd, d, n))\n    {\n        col = n * 0.5 + 0.5;\n    }\n    else\n    {\n        col = vec3(0.2);\n    }\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);      \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n        // camera        \n        float theta\t= radians(360.) * (iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(110.) * (iMouse.y/iResolution.y-0.5) - radians(90.);\n        vec3 ro = 3. * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        vec3 col = render(ro ,rd);  \n        tot += col;            \n#if AA\n    }\n    tot /= 4.;\n#endif\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Exported from Houdini\n\n/*\nimport sys\n\nnode = hou.pwd()\ngeo = node.geometry()\n\nprims = geo.prims()\n\nbbox =  geo.boundingBox();\nmaxPos = bbox.maxvec()\nminPos = bbox.minvec()\n\noutput = \"const int numPlanes = \" + str(len(prims)) + \";\\n\\n\"\noutput += \"const vec4 planes[numPlanes] = vec4[](\\n\"\nvector = []\nfor prim in prims:\n    normal = prim.attribValue(\"N\")\n    normal = hou.Vector3(normal[0], normal[1], normal[2])\n    points = prim.points()\n    point = points[0].position()\n    d = normal.dot(point)\n    vector.append(\"vec4(\" + str(normal.x()) + \", \" + str(normal.y()) + \", \" + str(normal.z()) + \", \" + str(-d) + \")\")\n    \noutput += \",\\n\".join(vector) + \" );\\n\\n\"\n\nbbox.enlargeToContain(hou.Vector3(-bbox.maxvec().x(), bbox.center().y(), bbox.center().z()))\noutput = output + \"const vec3 bboxSiz = vec3(\" + str(bbox.sizevec().x() / 2.) + \", \" + str(bbox.sizevec().y() / 2.) + \", \" + str(bbox.sizevec().z() / 2.) + \");\\n\"\noutput = output + \"const vec3 bboxCtr = vec3(\" + str(bbox.center().x()) + \", \" + str(bbox.center().y()) + \", \" + str(bbox.center().z()) + \");\\n\"\n\nprint(output)\n*/\n\n\nconst int numPlanes = 17;\n\nconst vec4 planes[numPlanes] = vec4[](\nvec4(0.0, 1.0, 0.0, -1.75),\nvec4(0.0, -1.0, 0.0, -1.75),\nvec4(0.865558981895, 0.0, -0.500807106495, -0.742628234022),\nvec4(-0.353560000658, -1.80422770057e-08, -0.935411810875, -0.880737701417),\nvec4(-0.999897956848, -1.36637803294e-08, 0.0142883695662, -0.894969639267),\nvec4(-0.358315140009, 1.2375285692e-11, 0.933600723743, -0.848164967797),\nvec4(0.862004518509, 3.33596505975e-09, 0.50690060854, -0.81893926951),\nvec4(0.781055212021, 0.623916983604, 0.0260841995478, -1.22853477631),\nvec4(0.276541233063, 0.654822647572, -0.703372061253, -1.37026202368),\nvec4(-0.653981924057, 0.653027355671, -0.381919920444, -1.36055210583),\nvec4(-0.651714146137, 0.676901042461, 0.342160224915, -1.30437838268),\nvec4(0.32613825798, 0.617486417294, 0.715782403946, -1.26344136905),\nvec4(0.835819482803, -0.545120954514, 0.065184481442, -1.06336148713),\nvec4(0.240880459547, -0.629201292992, -0.738973855972, -1.31147556665),\nvec4(-0.596318423748, -0.65652692318, -0.461927205324, -1.35845409037),\nvec4(-0.591593742371, -0.707991778851, 0.385700017214, -1.36638951145),\nvec4(0.33144068718, -0.517934799194, 0.788600444794, -1.33775803516) );\n\nconst vec3 bboxSiz = vec3(0.903634905815, 1.75, 1.03868842125);\nconst vec3 bboxCtr = vec3(0.0, 0.0, 0.0);\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVcDh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[198, 198, 275, 275, 801], [803, 803, 839, 839, 1027], [1029, 1029, 1071, 1071, 1235]], "test": "untested"}
{"id": "3lKyDR", "name": "Marble Marcher: SE", "author": "michael0884", "description": "Marble Marcher port for Shadertoy! Look at Image tab comments for more details.", "tags": ["fractal", "game", "interactive", "text", "pathtracing", "pbr"], "likes": 168, "viewed": 10220, "published": 3, "date": "1610930180", "time_retrieved": "2024-07-30T19:44:24.630403", "image_code": "//Marble Marcher Shadertoy Edition\n//Version 0.9 BETA\n\n//Ported by michael0884 (Mykhailo Moroz)\n\n//Original Marble Marcher by CodeParade\n//https://github.com/HackerPoet/MarbleMarcher\n\n//Also check out Marble Marcher Community Edition!\n//https://github.com/WAUthethird/Marble-Marcher-Community-Edition\n\n//Notable features:\n//Temporal antialiasing with disocclusion rejection, velocity vectors and neighbor clamping\n//Lots of blue noise\n//Ambient occlusion \n//PBR rendering\n//Path tracing support, uncomment the define in Common\n//Path tracer is also PBR with refraction support\n//Physics in purely shader based\n\n//Instructions\n//WASD/Arrows and mouse to move marble. Q/E camera distance. \n//R - restart level\n//SPACE - next level(only when you completed this one)\n//Backspace - return to main menu\n//F - go to free camera mode, in this mode Q/E regulate camera speed\n//Change parameters in Common tab\n//level transition buttons \n//P - next level\n//O - previous level\n\n//comment if the compiler wasn't able to optimize text rendering\n#define RENDER_TEXT\n\n#define STRINGS 8\n#define TOTCHARS STRLENGTH*STRINGS\n\nconst uint[] TEXT_ARRAY = uint[](\n  STRING(M,a,r,b,l,e,_,M,a,r,c,h,e,r,_,_,_,_,_,_,_,_,_,_),     //0\n  STRING(S,h,a,d,e,r,t,o,y,_,E,d,i,t,i,o,n,_,_,_,_,_,_,_),     //1\n  STRING(P,o,r,t,_,b,y,_,m,i,c,h,a,e,l,_0,_8,_8,_4,_,_,_,_,_), //2\n  STRING(O,r,i,g,i,n,a,l,_,b,y,_,C,o,d,e,P,a,r,a,d,e,_,_),     //3\n  \n  STRING(P,r,e,s,s,_,S,p,a,c,e,_,t,o,_,C,o,n,t,i,n,u,e,_),     //4\n  STRING(P,r,e,s,s,_,R,_,t,o,_,R,e,s,t,a,r,t,_,L,e,v,e,l),     //5\n  \n  STRING(P,l,a,y,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),     //6\n  STRING(L,e,v,e,l,s,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_),      //7\n  \n  STRING(B,a,c,k,_,t,o,_,M,a,i,n,_,M,e,n,u,_,_,_,_,_,_,_),\n  STRING(J,u,m,p,_,t,h,e,_,c,r,a,t,e,r,_,_,_,_,_,_,_,_,_),\n  STRING(T,o,o,_,m,a,n,y,_,t,r,e,e,s,_,_,_,_,_,_,_,_,_,_),\n  STRING(H,o,l,e,_,i,n,_,o,n,e,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,e,w,a,r,e,_,o,f,_,b,u,m,p,s,_,_,_,_,_,_,_,_,_),\n  STRING(M,o,u,n,t,a,i,n,_,c,l,i,m,b,i,n,g,_,_,_,_,_,_,_),\n  STRING(M,i,n,d,_,t,h,e,_,g,a,p,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(T,h,e,_,s,p,o,n,g,e,_,_,_,_,_,_,_,_,_,_,_,_,_,_),\n  STRING(B,u,i,l,d,_,u,p,_,s,p,e,e,d,_,_,_,_,_,_,_,_,_,_),\n  STRING(A,r,o,u,n,d,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(T,o,p,_,o,f,_,t,h,e,_,c,i,t,a,d,e,l,_,_,_,_,_,_),\n  STRING(M,e,g,a,_,C,i,t,a,d,e,l,_,_,_,_,_,_,_,_,_,_,_,_)\n);\n\n#define CONTOUR 1.1\n#define CHAR_WIDTH 0.5\n\nvoid draw_char(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, uint char)\n{        \n  p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size); \n  if(p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) return; \n  int code = int(char);\n  \n  p.x=(fract(p.x) - 0.5)*CHAR_WIDTH + 0.5; p.y=1.-p.y;                 \n  p+=vec2(code%16,15-code/16);                          \n  float sdf = (texture(iChannel3, p/16.).w - 0.5 + 1.0/256.0)*size;\n  \n  float blend = smoothstep(CONTOUR, 0.0, sdf);\n  vec3 color = tcol*(2.*smoothstep(CONTOUR, -CONTOUR, sdf) - smoothstep(1.2*CONTOUR, 0.0, sdf));\n  incol = mix(incol, color, blend);\n}\n\nvoid draw_string(inout vec3 incol, vec2 p, vec3 tcol, vec2 pos, float size, int string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(STRLENGTH) || p.y < 0.0 || p.y > 1.0) return;\n  draw_char(incol, p0, tcol, pos + vec2(floor(p.x)*size*CHAR_WIDTH,0.), size, TEXT_ARRAY[int(p.x) + string*STRLENGTH]);   \n}\n\nvoid draw_string(inout vec3 incol, in vec2 p, in vec3 tcol, in vec2 pos, in float size, in uint[8] string) \n{        \n  vec2 p0 = p; p.y = iResolution.y - p.y;\n  p = (p - pos)/vec2(size*CHAR_WIDTH, size);\n  if(p.x < 0.0 || p.x > float(8) || p.y < 0.0 || p.y > 1.0) return;\n  \n  //compiler doesn't want to optimize dynamic array indexing, idk why\n  //a loop doesn't work either\n  draw_char(incol, p0, tcol, pos + vec2(0.0*size*CHAR_WIDTH,0.), size, string[0]);\n  draw_char(incol, p0, tcol, pos + vec2(1.0*size*CHAR_WIDTH,0.), size, string[1]);\n  draw_char(incol, p0, tcol, pos + vec2(2.0*size*CHAR_WIDTH,0.), size, string[2]);\n  draw_char(incol, p0, tcol, pos + vec2(3.0*size*CHAR_WIDTH,0.), size, string[3]);\n  draw_char(incol, p0, tcol, pos + vec2(4.0*size*CHAR_WIDTH,0.), size, string[4]);\n  draw_char(incol, p0, tcol, pos + vec2(5.0*size*CHAR_WIDTH,0.), size, string[5]);\n  draw_char(incol, p0, tcol, pos + vec2(6.0*size*CHAR_WIDTH,0.), size, string[6]);\n  draw_char(incol, p0, tcol, pos + vec2(7.0*size*CHAR_WIDTH,0.), size, string[7]);\n}\n\nvoid draw_menu(inout vec3 incol, vec2 p, vec2 pos, float sizescale, ivec2 range)\n{\n    for(int i = range.x; i<=range.y; i++)\n    {\n        vec2 dx = vec2(pos.x - p.x, iResolution.y - pos.y - p.y);\n        vec2 size = sizescale*Buttons[i].size;\n        incol *= 1.0 - 0.35*step(dx.y - size.x, 0.0)*step(0.0, dx.y)*step(0.0, dx.x + size.y)*step(dx.x, 0.0);\n        draw_string(incol, p, vec3(1.), pos, size.x,  Buttons[i].string);\n        pos.y +=1.2*size.x;\n    }\n}\n  \n#define SHARPEN 1.25\n#define LOWSAMPLE_BLUR 1.\nvec4 sample_adaptive(sampler2D ch, vec2 uv)\n{\n    vec3 dx = vec3(1.0/vec2(textureSize(ch, 0)),0.);\n    \n    vec4 c = texture(ch, uv);\n    vec2 v = decode(texelFetch(iChannel0, ivec2(uv*iResolution.xy), 0).w);\n    float k = mix(-LOWSAMPLE_BLUR, SHARPEN, smoothstep(0.15, 0.3, v.y*(1. - REPROJECTION)));\n    \n    vec4 u = texture(ch, uv + dx.zy);\n    vec4 d = texture(ch, uv - dx.zy);\n    vec4 r = texture(ch, uv + dx.xz);\n    vec4 l = texture(ch, uv - dx.xz);\n    return (1.+k)*c - 0.25*k*(u+d+r+l); \n}\n  \nvoid mainImage( out vec4 c, in vec2 p )\n{\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec2 uv = p/iResolution.xy;\n    c.xyz = sample_adaptive(iChannel0, p/iResolution.xy).xyz;\n    c.xyz = clamp(c.xyz, 0., 1.0);\n    \n    #ifdef RENDER_TEXT\n    float ms = timers.x*100.0/60.0;\n    float se = mod(timers.x/60., 60.);\n    float se0 = mod(-timers.x/60., 60.);\n    float dse0 = mod(se0, 1.0);\n    float mi = timers.x/3600.;\n    uint[8] timer = uint[](NUM2CHAR(mi/10.0),NUM2CHAR(mi),C(co),NUM2CHAR(se/10.0),NUM2CHAR(se),C(co),NUM2CHAR(ms/10.0),NUM2CHAR(ms));   \n    \n    float font_size = FONT_SCALE;\n    c.w = 1.0;\n    switch(int(MODE/64.0))\n    {\n    case GAMEMODE_MENU: //MAIN MENU\n        draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.03)*iResolution.xy, 62.0*font_size,  0);\n        draw_string(c.xyz, p, vec3(1.), vec2(0.40, 0.15)*iResolution.xy, 35.0*font_size,  1);\n        draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  2);\n        draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  3);\n        \n        draw_menu(c.xyz, p, MAIN_POS, font_size,  ivec2(0,1));\n        break;\n    case GAMEMODE_LEVELS: //LEVELS MENU\n        draw_menu(c.xyz, p, LEVELS_POS, font_size,  ivec2(2,13));\n        break;\n    case GAMEMODE_GAME: //TIMER\n        if(timers.x>=0.)\n        {\n            draw_string(c.xyz, p, vec3(1.), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        }\n        else\n        {\n            draw_char(c.xyz, p, vec3(1.), vec2(0.47 - 0.008*dse0, 0.01)*iResolution.xy, (80.0 + 40.0*dse0)*font_size,  NUM2CHAR(se0+1.0));\n        }\n        return;    \n    case GAMEMODE_FINISH: \n        draw_string(c.xyz, p,  vec3(0.000,0.702,1.000), vec2(0.39, 0.01)*iResolution.xy, 40.0*font_size,  timer);\n        draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.85)*iResolution.xy, 27.0*font_size,  4);\n        draw_string(c.xyz, p, vec3(1.), vec2(0.03, 0.91)*iResolution.xy, 27.0*font_size,  5);\n        break;    \n    }\n    #endif\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//rendering settings\n#define MAX_STEPS 256\n#define MIN_DIST 1e-5\n#define MAX_DIST 30.0\n#define LIGHT_BRIGHTNESS 2.0\n#define FRACTAL_ITER 12\n#define FOV 1.0\n#define EXPOSURE 1.2\n#define ADAPTIVE_PHYSICS_ITERATIONS\n//#define FORCE_ALONG_CAMERA\n\n//#define PATH_TRACING\n#define BOUNCES 6\n//#define DIRECT_LIGHT\n#define AMBIENT 2.\n#define APERTURE 0.0\n\n//TAA\n#define DISOCCLUSION_REJECTION 6e-4\n#define CAMERA_MOVEMENT_REJECTION 5e-3\n\n#ifdef PATH_TRACING\n    #define REPROJECTION 0.94\n#else\n    #define REPROJECTION 0.9\n#endif\n\n#define AMBIENT_OCCLUSION\n#define SHADOWS\n#define DIRECT_BRIGHTNESS vec3(6.0)\n\n#define FRACTAL_F0 vec3(0.06)\n#define FRACTAL_ROUGHNESS 0.1\n#define FRACTAL_TRANSPARENT false\n#define FRACTAL_WHITE 0.99\n\n#define DISOCCLUSION_REJECTION_STR 1.0\n#ifdef PATH_TRACING\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#else\n    #define NEIGHBOR_CLAMP_RADIUS 2\n#endif\n\n\n//#define AUTO_FOCUS\n#define FOCAL_PLANE 0.3\n\n\n//gameplay defines\n#define NUM 16\n\n#define MOUSE_       0\n#define CAM_ANGLE_   1\n#define CAM_POS_     2\n#define PCAM_ANGLE_  3\n#define PCAM_POS_    4\n#define PRESOLUTION_ 5\n#define CAM_VEL_     6\n//scene\n#define LIGHT_POS_   7\n#define MARBLE_POS_  8\n#define DMARBLE_POS_ 9\n#define MARBLE_VEL_  10\n#define TIMER_MODE_  11\n#define FLAG_POS_    12\n\n//fractal angles, scale\n#define FRAC_PARAM1_ 13\n//shift\n#define FRAC_PARAM2_ 14\n//color\n#define FRAC_PARAM3_ 15\n\n#define GAMEMODE_MENU 0\n#define GAMEMODE_LEVELS 1\n#define GAMEMODE_GAME 3\n#define GAMEMODE_FINISH 4\n#define GAMEMODE_FREE 5\n\n#define GET_DATA(ch, i) texelFetch(ch, ivec2(i, 0), 0)\n\nfloat CAM_ANGLE;\n\n//fractal\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 iMarblePos, iFlagPos;\nvec3 iMarbleVel; vec4 dMarblePos;\n\nvec3 iLightDir;\nfloat isPlanet;\n\n//current and prev camera\nvec4 ang, pang; \nvec4 pResolution;\nmat3 cam, pcam;\nvec3 campos, pcampos;\nvec3 camvel;\nfloat radius;\n\nfloat time;\nvec3 timers;\nfloat MODE;\n\n\n//CAMERA stuff\nmat3 get_cam(vec2 ang)\n{\n    vec3 x_dir = vec3(cos(ang.x)*sin(ang.y), cos(ang.y), sin(ang.x)*sin(ang.y));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,1,0)));\n    vec3 z_dir = normalize(cross(y_dir, x_dir));\n    return mat3(-x_dir, y_dir, z_dir);\n}\n\n//use previous camera matrix and camera position to reproject a point onto previous frame\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = vec3(dot(pcam_mat[0],dir),dot(pcam_mat[1],dir),dot(pcam_mat[2],dir));\n    return vec3(screen.yz*iRes.y/(FOV*screen.x) + 0.5*iRes.xy, td);\n}\n\n//SCENE\nvoid load_scene(sampler2D data, float t, vec2 res)\n{\n    time = t;\n    CAM_ANGLE = 1./res.y;\n    vec4 d1 = GET_DATA(data, FRAC_PARAM1_);        \n    iFracScale = d1.x; iFracAng1 = d1.y+0.000*sin(t); iFracAng2 = d1.z; //Scale, Angle1, Angle2\n    isPlanet = d1.w;\n    iFracShift = GET_DATA(data, FRAC_PARAM2_).xyz;                //Offset\n    iFracCol =   GET_DATA(data, FRAC_PARAM3_).xyz;                    //Color\n    iMarblePos = GET_DATA(data, MARBLE_POS_);                //Marble radius + size\n    iFlagPos =  GET_DATA(data, FLAG_POS_);           //Flag radius + size\n    vec4 MV_ = GET_DATA(data, MARBLE_VEL_);\n    iMarbleVel = MV_.xyz;\n    radius = MV_.w;\n    \n    dMarblePos = GET_DATA(data, DMARBLE_POS_);\n    \n    vec4 TM_ = GET_DATA(data, TIMER_MODE_);\n    timers = TM_.xyz;\n    MODE = TM_.w;\n    \n    //current camera\n    ang = GET_DATA(data, CAM_ANGLE_);\n    campos = GET_DATA(data, CAM_POS_).xyz;\n    camvel = GET_DATA(data, CAM_VEL_).xyz;\n    cam = get_cam(ang.xy);\n    \n    //previous camera\n    pang = GET_DATA(data, PCAM_ANGLE_);\n    pcampos = GET_DATA(data, PCAM_POS_).xyz;\n    pcam = get_cam(pang.xy);\n    \n    iLightDir = normalize(GET_DATA(data, LIGHT_POS_).xyz);\n    \n    pResolution = GET_DATA(data, PRESOLUTION_);\n}\n\n//marble physics\nconst float ground_force = 0.008f;\nconst float air_force = 0.004f;\nconst float ground_friction = 0.99f;\nconst float air_friction = 0.995f;\nconst float orbit_speed = 0.005f;\nconst int max_marches = 10;\nconst int num_phys_steps = 6;\nconst float marble_bounce = 1.2f;\nconst float gravity = 0.005f;\n\n//##########################################\n//   Space folding\n//##########################################\nvoid planeFold(inout vec3 z, vec3 n, float d) {\n\tz.xyz -= 2.0 * min(0.0, dot(z.xyz, n) - d) * n;\n}\nvoid sierpinskiFold(inout vec3 z) {\n\tz.xy -= min(z.x + z.y, 0.0);\n\tz.xz -= min(z.x + z.z, 0.0);\n\tz.yz -= min(z.y + z.z, 0.0);\n}\nvec2 mp = vec2(-1.,1.);\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\nvoid boxFold(inout vec3 z, vec3 r) {\n\tz.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n//##########################################\n//   Primitive DEs\n//##########################################\nfloat de_sphere(vec3 p, float r) {\n\treturn (length(p.xyz) - r);\n}\nfloat de_box(vec3 p, vec3 s) {\n\tvec3 a = abs(p.xyz) - s;\n\treturn (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0)));\n}\nfloat de_tetrahedron(vec3 p, float r) {\n\tfloat md = max(max(-p.x - p.y - p.z, p.x + p.y - p.z),\n\t\t\t\tmax(-p.x + p.y + p.z, p.x - p.y + p.z));\n\treturn (md - r) / sqrt(3.0);\n}\nfloat de_capsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, -h, h);\n\treturn (length(p.xyz) - r);\n}\n//##########################################\n//   Main DEs\n//##########################################\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    return (a.x < b.x)?a:b;\n}\n\nvec4 fractal(vec3 p)\n{\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i < FRACTAL_ITER; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), de_box(p, vec3(6.0))/scale);\n}\n\nvec2 de_fractal(vec3 p)\n{\n    return vec2(fractal(p).w, 0);\n}\n\nvec3 color_fractal(vec3 p)\n{\n    return fractal(p).xyz;\n}\n\nvec2 de_marble(vec3 p) \n{\n\tfloat de = de_sphere(p - iMarblePos.xyz, iMarblePos.w*0.98);\n    return vec2(de, 1);\n}\n\nvec2 de_flag(vec3 p) \n{\n\tvec3 f_pos = iFlagPos.xyz + vec3(1.5, 4, 0)*iFlagPos.w;\n\tvec3 p_s = p/iFlagPos.w;\n\tvec3 d_pos = p - f_pos;\n\tvec3 caps_pos = p - (iFlagPos.xyz + vec3(0, iFlagPos.w*2.4, 0));\n\t//animated flag\n\tfloat speed = 14.0;\n\tfloat oscillation = sin(8.0*p_s.x - 1.0*p_s.y - speed*time) +\n                    0.4*sin(11.0*p_s.x + 2.0*p_s.y - 1.2*speed*time) + \n                    0.15*sin(20.0*p_s.x - 5.0*p_s.y - 1.4*speed*time);\n\t//scale the flag displacement amplitude by the distance from the flagpole\n\tvec2 flag = vec2(0.6*de_box(d_pos + caps_pos.x*vec3(0,(0.02+ caps_pos.x* 0.5+0.01*oscillation),0.04*oscillation),\n                        vec3(1.5, 0.8, 0.005)*iFlagPos.w), 2);\n\tvec2 capsule = vec2(de_capsule(caps_pos, iFlagPos.w*2.4, iFlagPos.w*0.05), 3);\n    \n\treturn opUnion(flag, capsule);\n}\n\nvec2 scene(vec3 p)\n{\n    vec2 fractal = de_fractal(p);\n    vec2 marble = de_marble(p);\n    vec2 flag = de_flag(p);\n    return opUnion(opUnion(fractal, marble),flag);\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  0.25*(k.xyyx*scene(p + k.xyy*dx).x +\n\t\t\t      k.yyxx*scene(p + k.yyx*dx).x +\n\t\t\t      k.yxyx*scene(p + k.yxy*dx).x +\n\t\t\t      k.xxxx*scene(p + k.xxx*dx).x)/vec4(dx,dx,dx,1.0);\n}\n\nvec3 closestPoint(vec3 p) {\n\tconst vec3 k = vec3(1,-1,0);\n    const float dx = 1e-5;\n    vec4 n = 0.25*(k.xyyx*fractal(p + k.xyy*dx).w +\n\t\t\t       k.yyxx*fractal(p + k.yyx*dx).w +\n\t\t\t       k.yxyx*fractal(p + k.yxy*dx).w +\n\t\t\t       k.xxxx*fractal(p + k.xxx*dx).w); \n\treturn p - normalize(n.xyz)*n.w;\n}\n\nstruct material\n{\n    vec3 color;\n    vec3 emission;\n    vec3 normal;\n    vec3 cpoint; //closest point\n    vec3 velocity;\n    float roughness;\n    bool transparent;\n    vec3 F0;\n    float inside;\n};\n\nmaterial getMaterial(inout vec4 p)\n{\n    material cur;\n    float mindistance = 0.75*max(CAM_ANGLE*p.w,MIN_DIST);\n    cur.normal = normalize(calcNormal(p.xyz, mindistance).xyz);\n    vec2 scene = scene(p.xyz);\n    cur.inside = sign(scene.x);\n    vec3 dsurface = cur.normal*scene.x;\n    cur.cpoint = p.xyz - dsurface;\n    \n    //move away from the surface\n    p.xyz += cur.inside*cur.normal*mindistance;\n    \n    int id = int(scene.y);\n    cur.F0 = vec3(0.15);\n    cur.transparent = false; \n    cur.emission = vec3(0.0);\n    switch(id)\n    {\n    case 0:\n        cur.color = mix(vec3(1.0),color_fractal(cur.cpoint),FRACTAL_WHITE);\n        cur.F0 = FRACTAL_F0;\n        cur.roughness = FRACTAL_ROUGHNESS;\n        cur.transparent = FRACTAL_TRANSPARENT; \n        cur.velocity = vec3(0.);//TODO with animations\n        cur.emission = vec3(0.0)*exp(-300.*clamp(pow(abs(length( cur.color - vec3(1.) )),2.),0.,1.));\n        break;\n    case 1:\n        cur.color = vec3(1.);\n        cur.roughness = 0.011;\n        cur.F0 = vec3(0.03);\n        cur.velocity = dMarblePos.xyz;\n        cur.emission = vec3(0.0);\n        cur.transparent = true;\n        break;\n    case 2:\n        cur.color = vec3(1.000,0.078,0.078);\n         cur.transparent = true;\n        cur.roughness = 0.02;\n        cur.velocity = vec3(0.); //TODO\n        break;\n    case 3:\n        cur.color = vec3(1.000,0.867,0.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    default:\n        cur.color = vec3(1.000,1.000,1.000);\n        cur.roughness = 0.5;\n        cur.velocity = vec3(0.);\n        break;\n    }\n    return cur;\n}\n\nbool trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float de = abs(scene(ro.xyz).x); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        de -= step(de, md)*md;\n        ro += vec4(rd,1.)*de; \n        if(de < md) return true;\n        if(ro.w > MAX_DIST) return false;\n    }\n    return true;\n}\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\nvec2 rand2t()\n{\n    pcg4d(s1); return vec2(s1.xy)/float(0xffffffffu);\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvec2 halton(int index)\n{\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    while (s.x > 0. && s.y > 0.)\n    {\n        a.xy = a.xy/coprimes;\n        a.zw += a.xy*mod(s, coprimes);\n        s = floor(s/coprimes);\n    }\n    return a.zw;\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n//Keyboard constants\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nconst vec4 ca = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 cb = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = vec2(textureSize(tex,0));\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}\n\n\nuvec2 unpack_uint2x(uint x)\n{\n    return uvec2(x%0x00010000u,x/0x00010000u);\n}\n\nuint pack_uint2x(uvec2 x)\n{\n    return x.x + x.y*0x00010000u;\n}\n\nvec2 decode(float data)\n{\n    return vec2(unpack_uint2x(floatBitsToUint(data)))/100.;\n}\n\nfloat encode(vec2 data)\n{\n    return uintBitsToFloat(pack_uint2x(uvec2(data*100.0)));\n}\n\n//simplified ttg's GLSL character printing library\n//https://www.shadertoy.com/view/Wd2SDt\nconst struct CHARS {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CHAR = CHARS(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n  0x7fu);\n\n#define C(c) CHAR.c\n#define NUM2CHAR(x) (CHAR._0 + uint(x)%10u)\n#define STRLENGTH 24\n#define STRING(c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22,c23) \\\n     C(c0),C(c1),C(c2),C(c3),C(c4),C(c5),C(c6),C(c7),C(c8),C(c9),C(c10),C(c11), \\\n     C(c12),C(c13),C(c14),C(c15),C(c16),C(c17),C(c18),C(c19),C(c20),C(c21),C(c22),C(c23)\n\n\nstruct Button\n{\n    vec2 size;\n    int string;\n};\n\n#define MAIN_POS vec2(0.03, 0.30)*iResolution.xy\n#define LEVELS_POS vec2(0.03, 0.03)*iResolution.xy\n\n#define FONT_SCALE min(iResolution.x,iResolution.y)/400.0\n\nconst Button[] Buttons = Button[](\n//main menu\nButton(vec2(35.0, 300.0), 6), //0\nButton(vec2(35.0, 300.0), 7),  //1\n\n//levels\nButton(vec2(30.0, 300.0), 8), //2\nButton(vec2(26.0, 300.0), 9),  //3\nButton(vec2(26.0, 300.0), 10), //4\nButton(vec2(26.0, 300.0), 11), //5\nButton(vec2(26.0, 300.0), 12), //6\nButton(vec2(26.0, 300.0), 13), //7\nButton(vec2(26.0, 300.0), 14), //8\nButton(vec2(26.0, 300.0), 15), //9\nButton(vec2(26.0, 300.0), 16), //10\nButton(vec2(26.0, 300.0), 17), //11\nButton(vec2(26.0, 300.0), 18), //12\nButton(vec2(26.0, 300.0), 19) //13\n);\n", "buffer_a_code": "//Controller\n\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.2/60.\n\nbool KeyPressEvent(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,1), 0 ).x > 0.5;\n}\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 11;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n////Around the world\n//Level(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n//      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nint GMODE, curLVL;\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1;\n    iFracAng2 = LVL.FracAng2;\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n    iMarblePos = LVL.MarblePos;\n    iMarbleVel = vec3(0.);\n    iFlagPos = LVL.FlagPos;\n    isPlanet = float(LVL.isPlanet);\n    \n    //set cemera to point to the flag\n    vec3 m2f = normalize(iFlagPos.xyz - iMarblePos.xyz);\n    float phi = atan(m2f.z, m2f.x);\n    float theta = acos(m2f.y);\n    ang.xy = vec2(phi - PI,PI - theta);\n    //camera distance from marble\n    radius = 10.;\n}\n\n\nint checkMenuClick(vec2 p, vec2 pos, float sizescale, ivec2 range)\n{\n    for(int i = range.x; i<=range.y; i++)\n    {\n        vec2 dx = vec2(pos.x - p.x, iResolution.y - pos.y - p.y);\n        vec2 size = sizescale*Buttons[i].size;\n        \n        if(step(dx.y - size.x, 0.0)*step(0.0, dx.y)*step(0.0, dx.x + size.y)*step(dx.x, 0.0) > 0.5) \n            return i;\n            \n        pos.y +=1.2*size.x;\n    }\n    return -1;\n}\n\nvoid PhysicsIteration(float dt, vec3 marble_force, float frictionm)\n{\n    vec3 closest_fractal_point = closestPoint(iMarblePos.xyz);\n    vec3 dx = closest_fractal_point - iMarblePos.xyz;\n    float dist = length(dx);\n    dx = normalize(dx);\n    float onGround = step(dist, iMarblePos.w);\n    float force = ((dist < iMarblePos.w*1.14)?ground_force:air_force)*iMarblePos.w;\n    float friction =((dist < iMarblePos.w*1.14)?ground_friction:air_friction);\n    vec3 Gvec = (isPlanet==1.0)?normalize(iMarblePos.xyz):vec3(0.,1.,0);\n    //unintersect\n    iMarblePos.xyz += 0.3*onGround*dx*(dist - iMarblePos.w);\n    //momentum update\n    iMarbleVel += -marble_bounce*onGround*max(0.,dot(iMarbleVel, dx))*dx;\n\n    //update velocity\n    iMarbleVel += (-iMarblePos.w*gravity*Gvec +  frictionm*(friction - 1.0)*iMarbleVel + force*marble_force)*dt;\n    //update position\n    iMarblePos.xyz += iMarbleVel*dt;\n}\n\nvoid START(int levelid)\n{\n    levelid = levelid%levelnum;\n    timers = vec3(-3.*60., 0., iTimeDelta);\n    GMODE = 3;\n    curLVL = levelid;\n    LoadLevel(Levels[levelid]);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    ivec2 pi = ivec2(p);\n    if(pi.x >= NUM && pi.y >= 1) discard;\n    \n    ///Loading Data\n    c = GET_DATA(iChannel2, pi.x);\n\n    vec4 mouse = GET_DATA(iChannel2,MOUSE_);\n    vec2 mousespeed = mouse.xy;\n\n    load_scene(iChannel2, iTime, iResolution.xy);\n\n    GMODE = int(MODE/64.0);\n    curLVL = int(MODE)%64;     \n\n    //Initialization\n    if(iFrame < 5)\n    {\n        LoadLevel(Levels[1]);\n        GMODE = 0;\n        //START(10);\n    }\n\n    if(GMODE < GAMEMODE_GAME) //Menus\n    {\n        pang = ang;\n        ang.xy = vec2(0.2*iTime, PI*0.35);         \n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        pcampos = campos;\n        campos = cam*vec3(-12.0, 0, 0) + vec3(0, 2, 0);\n\n        bool MB = (iMouse.w > 1.0);\n        vec2 MP = iMouse.xy;\n        \n        float font_size = FONT_SCALE;\n        if(MB)\n        {\n            if(GMODE == 0)//Main menu\n            {\n                int button = checkMenuClick(MP, MAIN_POS, font_size, ivec2(0,1));\n                if(button == 0)\n                {\n                    START(0);\n                }\n                if(button == 1) //level menu\n                {\n                    GMODE = 1;\n                }\n            }\n            else if(GMODE == 1)//Level menu\n            {   \n                int button = checkMenuClick(MP, LEVELS_POS, font_size, ivec2(2,13));\n                if(button == 2)\n                {\n                    GMODE = 0;\n                }\n                else if(button>2)\n                {\n                    START(button - 3);\n                }\n            }\n       } \n    }\n    else //Gameplay\n    {\n        //Go into free camera mode\n        if(KeyPressEvent(KEY_F))\n        {\n            GMODE = (GMODE == GAMEMODE_FREE)?GAMEMODE_GAME:GAMEMODE_FREE;\n        }\n        if(KeyPressEvent(KEY_BSPACE))\n        {\n            GMODE = 0;\n        }\n        if(KeyPressEvent(KEY_R) || iMarblePos.y < -15.0)\n        {\n            START(curLVL);\n        }\n        if((KeyPressEvent(KEY_SPACE) && GMODE == GAMEMODE_FINISH) || KeyPressEvent(KEY_P))\n        {\n            START(curLVL+1);\n        }\n        if(KeyPressEvent(KEY_O))\n        {\n            START(abs(curLVL-1));\n        }\n\n        /////////cam update\n        pang = ang;\n        ang.xy = ang.xy + ang.zw*MOUSE_SENSITIVITY; // angle delta\n        ang.y = clamp(ang.y, PI*0.01, PI*0.99);\n        ang.zw += vec2(-1.0, 1.0)*mouse.xy; //velocity\n        ang.zw *= 0.76;\n\n        //////////update matrix\n        cam = get_cam(ang.xy);\n\n        //marble update\n        vec3 marble_force = vec3(0.);\n        float frictionm = 1.0; //friction multiplier\n\n        if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n        {\n            marble_force += cam[0];\n        }\n        if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n        {\n            marble_force -= cam[0];\n        }\n        if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n        {\n            marble_force += cam[1];\n        }\n        if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n        {\n            marble_force -= cam[1];\n        }\n\n        if(GMODE == GAMEMODE_GAME)\n        {\n            #ifndef FORCE_ALONG_CAMERA\n                marble_force = vec3(marble_force.x, 0., marble_force.z);\n                marble_force = marble_force/(length(marble_force)+1e-4);\n            #endif\n\n            marble_force = marble_force/max(length(marble_force), 1.);       \n        }\n\n        if(GMODE == GAMEMODE_FINISH)\n        {\n            vec3 flagmarble = (iFlagPos.xyz + vec3(0,8.*iFlagPos.w,0) - iMarblePos.xyz)/iFlagPos.w;\n            marble_force = 2.5*normalize(flagmarble)*min(length(flagmarble), 3.); \n            frictionm = 12.;\n        }\n\n        //PHYSICS\n        #ifdef ADAPTIVE_PHYSICS_ITERATIONS\n            float iterations = clamp(10.*timers.z*60.0, 4., 32.);\n        #else\n            float iterations = 10.;\n        #endif\n        float dt = 0.1;\n        vec4 pMarblePos = iMarblePos;\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        for(float i = 0.0; i<iterations; i++)\n            PhysicsIteration((timers.x >= 0.)?dt:0.0, marble_force, frictionm);\n        \n\n        dMarblePos = iMarblePos - pMarblePos;\n\n        //update camera position\n        pcampos = campos;\n\n        if(isKeyPressed(KEY_Q))\n        {\n            radius *= 1.0 - iterations*0.002;\n        }\n        if(isKeyPressed(KEY_E))\n        {\n            radius *= 1.01 + iterations*0.002;\n        }\n\n        if(GMODE == GAMEMODE_GAME || GMODE == GAMEMODE_FINISH)\n        {\n            //camera unintersection\n            vec3 rd = -cam[0];\n            float camd =iMarblePos.w*radius;\n            vec4 ro = vec4(iMarblePos.xyz + rd*iMarblePos.w*1.03,1e8);\n            if(scene(iMarblePos.xyz + cam*vec3(-camd,0,0)).x <= iMarblePos.w*0.2)\n            { ro.w = 0.;  trace(ro,rd); camd = ro.w; }  \n            campos = iMarblePos.xyz + cam*vec3(-camd, 0, 0);\n        }\n        else\n        {\n            //reuse radius as the speed regulator\n            camvel += - camvel*0.1 + CAMERA_SPEED*iMarblePos.w*marble_force*radius/10.; \n            campos += camvel;\n        }\n\n        //Win condition\n        if(GMODE == 3 && distance(iMarblePos.xyz, iFlagPos.xyz) < iFlagPos.w*4.0) GMODE = 4;\n\n        timers = vec3(timers.x + ((GMODE == 3)?dt*iterations:0.0), 0., mix(timers.z,iTimeDelta,0.03)); \n\n    }\n\n    //////////mouse update\n    if(length(iMouse.zw - iMouse.xy) > 10.)\n    {\n        mouse.xy = iMouse.xy - c.zw; // mouse delta\n        if(iFrame < 1)\n        {\n            mouse.xy = vec2(0.);\n        }\n    }\n    else\n    {\n        mouse.xy = vec2(0.); // mouse delta\n    }\n    mouse.zw = iMouse.xy; // mouse pos\n\n    switch(pi.x)\n    {\n    case MOUSE_: \n        c = mouse;\n        break;\n    case CAM_ANGLE_:  \n        c = ang;\n        break;\n    case CAM_POS_:  \n        c.xyz = campos;\n        break;\n    case CAM_VEL_:  \n        c = vec4(camvel, 0.);\n        break;\n    case LIGHT_POS_:\n        c.xyz = vec3(0.2, 2.0, 1.5);\n        break;\n    case PCAM_ANGLE_:\n        c = pang;\n        break;\n    case PCAM_POS_:\n        c.xyz = pcampos;\n        break;\n    case PRESOLUTION_:\n        c.xy = pResolution.zw;\n        c.zw = iResolution.xy;\n        break;\n    case MARBLE_POS_:  \n        c = iMarblePos;\n        break;\n    case DMARBLE_POS_:  \n        c = dMarblePos;\n        break;      \n    case MARBLE_VEL_:  \n        c = vec4(iMarbleVel, radius);\n        break;\n    case TIMER_MODE_:  \n        c = vec4(timers, float(GMODE*64 + curLVL));\n        break;\n    case FLAG_POS_:\n        c = iFlagPos;\n        break;\n    case FRAC_PARAM1_:\n        c = vec4(iFracScale, iFracAng1, iFracAng2, isPlanet);\n        break;\n    case FRAC_PARAM2_:\n        c = vec4(iFracShift, 0.);\n        break;\n    case FRAC_PARAM3_:\n        c = vec4(iFracCol, 0.);\n        break;  \n    }   \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//blue noise\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\n#define LIGHT_ANGLE 0.2\n\nfloat shadowtrace(vec3 ro, vec3 rd, float maxd)\n{\n    float td = 0.;\n    //noise to remove shadow artifacts\n    float phase = rand() - 0.5;\n    float angle = 1e10;\n    for(int i = 0; i < 40; i++)\n    {\n        float de = scene(ro).x*(1. + 0.2*phase);\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        if(td > maxd) break;\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.02, LIGHT_ANGLE, angle);\n}\n\nfloat ambitrace(vec3 ro, vec3 rd)\n{\n    float td = 0.;\n    float angle = 1e10;\n    for(int i = 0; i < 7; i++)\n    {\n        float de = scene(ro).x;\n        if(de < max(CAM_ANGLE*td,MIN_DIST)) {angle*= 0.0; break;}\n        td += de; ro += rd*de;\n        angle = min(angle, de/td); \n    }\n    return smoothstep(0.0, 0.3, angle);\n}\n\n\n//rendering samplers\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    if(n.z < -0.999999) {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nmat3 mat3FromNormal(in vec3 n)\n{\n    vec3 x; vec3 y;\n    basis(n, x, y);\n    return mat3(x,y,n);\n}\n\nvec3 ggxSample(vec3 wi, float alphax, float alphay, vec2 xi)\n{   \n    //stretch view\n    vec3 v = normalize(vec3(wi.x * alphax, wi.y * alphay, wi.z));\n\n    //orthonormal basis\n    vec3 t1 = (v.z < 0.9999) ? normalize(cross(v, vec3(0.0, 0.0, 1.0))) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(t1, v);\n\n    //sample point with polar coordinates\n    float a = 1.0 / (1.0 + v.z);\n    float r = sqrt(xi.x);\n    float phi = (xi.y < a) ? xi.y / a*PI : PI + (xi.y - a) / (1.0 - a) * PI;\n    float p1 = r*cos(phi);\n    float p2 = r*sin(phi)*((xi.y < a) ? 1.0 : v.z);\n\n    //compute normal\n    vec3 n = p1*t1 + p2*t2 + v*sqrt(1.0 - p1*p1 - p2*p2);\n\n    //unstretch\n    return normalize(vec3(n.x * alphax, n.y * alphay, n.z));\n}\n\nvec2 sampleDisk(vec2 xi)\n{\n\tfloat theta = TWO_PI * xi.x;\n\tfloat r = sqrt(xi.y);\n\treturn vec2(cos(theta), sin(theta)) * r;\n}\n\nvec3 cosineHemisphere(vec2 xi)\n{\n    vec2 disk = sampleDisk(xi);\n\treturn vec3(disk.x, disk.y, sqrt(max(0.0, 1.0 - dot(disk, disk))));\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nvec3 simple_shading(inout vec4 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    bool hit = trace(ro, rd);\n    if(hit)\n    {\n        material mat = getMaterial(ro); \n        \n        vec3 V = - rd;\n        vec3 N = mat.normal;\n        vec3 R = reflect(rd, N);\n        vec3 L = iLightDir;\n        vec3 H = normalize(V + L);\n        \n        vec3 kS = fresnel(V, N, mat.F0);\n        vec3 kD = 1.0 - kS;\n        \n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n        \n        #ifdef SHADOWS\n            float shadow = 0.;\n            if(NdotL > 0.0) shadow = shadowtrace(ro.xyz, iLightDir, MAX_DIST);\n        #else\n            float shadow = 0.0;\n        #endif\n        \n        float selfshadow = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, mat.roughness);  \n        \n        vec3 direct = shadow * (kD * mat.color / PI + specular) * DIRECT_BRIGHTNESS * NdotL;\n        \n        //AO\n        #ifdef AMBIENT_OCCLUSION\n            vec4 rnd = rand4blue();\n            float ambientshadow = ambitrace(ro.xyz + mat.normal*ro.w*0.001, \n                                            normalize(mat.normal + udir(rnd.xy)));\n        #else\n            float ambientshadow = 0.5 + 0.5*NdotL;\n        #endif\n        \n        \n        vec3 reflection = AMBIENT*kS*texture(iChannel3, R).xyz;\n        vec3 ambient = 0.25*mat.color*(ambientshadow + reflection);\n        \n        col = ambient + direct;\n    }\n    else\n    {\n        col = AMBIENT*texture(iChannel3, rd).xyz;\n    }\n    return col;\n}\n\nvec3 pathtrace(inout vec4 ro0, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    vec3 absorption = vec3(1.);\n    vec4 ro = ro0; \n    for(int i = 0; i < BOUNCES; i++)\n    {\n        float id = 0.;\n        bool hit = trace(ro, rd);\n        if(i == 0) {ro0 = ro;}\n        if(hit)\n        {\n            vec4 rnd = rand4blue();\n            \n            material mat = getMaterial(ro);\n            \n            vec3 V = - rd;\n            vec3 N = mat.normal*mat.inside;\n            vec3 R = reflect(rd, N);\n            vec3 L = iLightDir;\n            vec3 H = normalize(V + L);\n            \n            vec3 kS = fresnel(V, N, mat.F0);\n            \n            //specular probability\n            float pS = (kS.x + kS.y + kS.z)/3.0;\n            \n            mat3 basis = mat3FromNormal(N);\n            mat3 inv = transpose(basis);\n            vec3 V_local = inv*V;\n           \n            vec3 incoming = mat.emission; \n            \n            #ifdef DIRECT_LIGHT\n                float NdotL = max(dot(N, L), 2e-3);\n                float NdotV = max(dot(N, V), 2e-3);\n                \n                float selfshadowL = G_ggx(NdotL,mat.roughness)*G_ggx(NdotV,mat.roughness);\n                \n                vec3 specular = selfshadowL*kS*NDF_ggx(H, N, mat.roughness)/max(4.0*NdotL*NdotV,1e-3);  \n\n                vec3 direct = (mat.color*(1. - kS)*float(!mat.transparent) / PI + specular) * NdotL;\n                \n                float shadow = 0.;\n                if(length(direct) > 0.04) shadow = shadowtrace(ro.xyz, iLightDir, MAX_DIST);\n\n                incoming += DIRECT_BRIGHTNESS * shadow * direct;\n            #endif\n            \n            \n            //sample microfacet normal\n            vec3 M = ggxSample(V_local, mat.roughness, mat.roughness, rnd.xy);\n            \n            rd = reflect(-V_local, M); //new reflected ray direction\n\n            float selfshadowR = G_ggx(rd.z,mat.roughness)*G_ggx(V_local.z,mat.roughness);\n            \n            if(rnd.z < pS*selfshadowR) //specular bounce\n            {\n                absorption *= kS/pS;\n            }\n            else //diffuse/refraction bounce\n            { \n                absorption *= mat.color;\n                if(mat.transparent) //refraction\n                {\n                    float F0avg = (mat.F0.x + mat.F0.y + mat.F0.z)/3.0; \n                    float IOR = (1.0 + sqrt(F0avg))/(1.0 - sqrt(F0avg));\n                   \n                    if(length(rd) != 0.) //not total internal reflection\n                    {\n                        rd = refract(-V_local, M, pow(IOR,-mat.inside));     \n                        //reflect point inside\n                        ro.xyz = ro.xyz + 2.0*(mat.cpoint - ro.xyz);\n                    }\n                }\n                else //diffuse\n                { \n                    rd = cosineHemisphere(rnd.xy);  \n                }  \n            }\n            \n            col += absorption*incoming;\n            \n            if((absorption.x + absorption.y + absorption.z) < 0.03) break; \n          \n            \n           \n            rd = basis*rd; //return ray direction into world space\n        }\n        else\n        {\n            #ifdef DIRECT_LIGHT\n            float ambient = AMBIENT*0.5;\n            #else\n            float ambient = AMBIENT;\n            #endif\n            col += absorption*(ambient*(texture(iChannel3, rd).xyz + 0.*pow(max(dot(iLightDir, rd),0.),20.)) );\n            break;\n        }\n        \n    }\n    return col;\n}\n\nvoid getRay(in vec2 p, inout vec3 ro, inout vec3 rd, float aperture)\n{\n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 r = rand4blue();\n    vec2 ap = aperture*vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n    vec3 daperture = ap.x*cam[1] + ap.y*cam[2];\n    ro = campos + daperture;\n    #ifdef AUTO_FOCUS\n        float focus = radius*iMarblePos.w;\n    #else\n        float focus = FOCAL_PLANE;\n    #endif\n    \n    rd = normalize(focus*(cam*vec3(1, FOV*uv)) - daperture);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    \n    vec4 col = vec4(0.);\n    \n    vec4 ro = vec4(0.); vec3 rd; \n    vec2 jitter = halton(iFrame%16) - 0.5; \n    getRay(p + jitter, ro.xyz, rd, APERTURE);\n    \n    #ifdef PATH_TRACING\n        col += vec4(pathtrace(ro, rd), 1.0);\n    #else\n        col += vec4(simple_shading(ro, rd), 1.0);\n    #endif\n\n    c.xyz = tanh(EXPOSURE*pow(col.xyz/col.w, vec3(0.75)));\n    c.w = distance(ro.xyz, campos);\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//TAA\n\nvec3 encodePalYuv(vec3 rgb)\n{\n    return vec3(\n        dot(rgb, vec3(0.299, 0.587, 0.114)),\n        dot(rgb, vec3(-0.14713, -0.28886, 0.436)),\n        dot(rgb, vec3(0.615, -0.51499, -0.10001))\n    );\n}\n\nvec3 decodePalYuv(vec3 yuv)\n{\n    return vec3(\n        dot(yuv, vec3(1., 0., 1.13983)),\n        dot(yuv, vec3(1., -0.39465, -0.58060)),\n        dot(yuv, vec3(1., 2.03211, 0.))\n    ); \n}\n\nvec3 mul3( in mat3 m, in vec3 v ){return vec3(dot(v,m[0]),dot(v,m[1]),dot(v,m[2]));}\n\nvec3 mul3( in vec3 v, in mat3 m ){return mul3(m,v);}\n\nvec3 srgb2oklab(vec3 c) {\n    \n    mat3 m1 = mat3(\n        0.4122214708,0.5363325363,0.0514459929,\n        0.2119034982,0.6806995451,0.1073969566,\n        0.0883024619,0.2817188376,0.6299787005\n    );\n    \n    vec3 lms = mul3(m1,c);\n    \n    lms = pow(lms,vec3(1./3.));\n\n    mat3 m2 = mat3(\n        +0.2104542553,+0.7936177850,-0.0040720468,\n        +1.9779984951,-2.4285922050,+0.4505937099,\n        +0.0259040371,+0.7827717662,-0.8086757660\n    );\n    \n    return mul3(m2,lms);\n}\n\nvec3 oklab2srgb(vec3 c)\n{\n    mat3 m1 = mat3(\n        1.0000000000,+0.3963377774,+0.2158037573,\n        1.0000000000,-0.1055613458,-0.0638541728,\n        1.0000000000,-0.0894841775,-1.2914855480\n    );\n\n    vec3 lms = mul3(m1,c);\n    \n    lms = lms * lms * lms;\n  \n    mat3 m2 = mat3(\n        +4.0767416621,-3.3077115913,+0.2309699292,\n        -1.2684380046,+2.6097574011,-0.3413193965,\n        -0.0041960863,-0.7034186147,+1.7076147010\n    );\n    return mul3(m2,lms);\n}\n\nvec3 enc_color(vec3 x)\n{\n    return srgb2oklab(x);\n}\n\nvec3 dec_color(vec3 x)\n{\n    return oklab2srgb(x);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    load_scene(iChannel2, iTime, iResolution.xy);\n    vec2 jitter = halton(iFrame%16) - 0.5; \n    vec4 bufB = texture(iChannel0, (p-jitter)/iResolution.xy);\n    \n    vec4 col = vec4(bufB.xyz, 1.);\n    \n    vec2 uv = (p  - 0.5*iResolution.xy)/iResolution.y;\n    vec4 ro = vec4(campos, bufB.w);    \n    vec3 rd = normalize(cam*vec3(1, FOV*uv));\n    ro.xyz += ro.w*rd;\n    vec4 X = ro;\n    material mat = getMaterial(X);\n    ro.xyz -= mat.velocity;\n    \n    vec3 reprj = reproject(pcam, pcampos, pResolution.xy, ro.xyz);\n    vec2 puv = reprj.xy/iResolution.xy;\n    vec2 dpuv = abs(puv - vec2(0.5));\n\n    vec3 prev_col = texture_Bicubic(iChannel1, puv).xyz;\n    \n    //neighborhood clamping\n    vec3 minc = vec3(1e10); \n    vec3 maxc = vec3(0.);\n    for(int i = -NEIGHBOR_CLAMP_RADIUS; i < NEIGHBOR_CLAMP_RADIUS; i++)\n        for(int j = -NEIGHBOR_CLAMP_RADIUS; j < NEIGHBOR_CLAMP_RADIUS; j++)\n    {\n        vec3 pix = enc_color(texelFetch(iChannel0, ivec2(p) + ivec2(i,j), 0).xyz);\n        minc = min(pix, minc);\n        maxc = max(pix, maxc);\n    }\n    \n    vec3 preclamp = enc_color(prev_col);\n    prev_col = clamp(preclamp, minc, maxc);\n    float delta = distance(prev_col, preclamp);\n    prev_col = dec_color(prev_col);\n     \n    \n    vec2 v = decode(texelFetch(iChannel1, ivec2(puv*iResolution.xy), 0).w);\n    \n    vec4 prev = vec4(prev_col, 1.0)*v.y;\n    float prev_td = 2.0/v.x;\n    \n    vec3 prev_pos = normalize(ro.xyz - pcampos)*prev_td + pcampos;\n    float ang_distance = distance(normalize(prev_pos - campos),normalize(ro.xyz - campos));\n    \n    if(iFrame < 2) prev*=0.0;\n    //prev*=mix(1.0, smoothstep(0.6, 0.5, delta), 0.1);\n    prev*=mix(1.0, step(ang_distance, DISOCCLUSION_REJECTION), DISOCCLUSION_REJECTION_STR);\n    float dist = distance(prev.xyz/prev.w, col.xyz/col.w);\n    prev*=mix(1.0, smoothstep(CAMERA_MOVEMENT_REJECTION, 0., distance(campos, pcampos)),0.05);\n    \n\n    //prev*=mix(1.0, smoothstep(0.7, 0.6, dist),1.0);\n    col += prev*REPROJECTION*step(dpuv.x, 0.5)*step(dpuv.y, 0.5); \n    \n    c.xyz = 1.*col.xyz/col.w + 0.*ang_distance;\n    c.w = encode(vec2(2.0/ro.w, col.w));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2442, 2442, 2528, 2528, 3084], [3086, 3086, 3176, 3176, 3472], [4518, 4518, 4600, 4600, 4982], [5033, 5033, 5078, 5078, 5534]], "test": "untested"}
{"id": "3tVyW1", "name": "Its Raining Jean Cloude!", "author": "oneshade", "description": "I used the snow effect from my \"[url=https://www.shadertoy.com/view/tdKBWy]Holiday Greetings![/url]\" shader to create a cascade of images.\nPlease forgive the awful pun :D", "tags": ["raining", "jeanclaude", "imagesprites"], "likes": 5, "viewed": 341, "published": 3, "date": "1610929494", "time_retrieved": "2024-07-30T19:44:25.519027", "image_code": "#define SMOOTHING_SIZE 1.0 / iResolution.y\n\nfloat noise(in float x) {\n    return fract(cos(x * 4754.673) * 573.123);\n}\n\nvoid ImageSprite(inout vec3 color, in sampler2D channel, in vec2 p, in vec2 pos, in vec2 size, in float ori, in float border) {\n    float c = cos(ori), s = sin(ori);\n    p = (p - pos) * mat2(c, -s, s, c) / size + 0.5;\n\n    float halfBorder = 0.5 * border;\n    vec2 corner = abs(p - 0.5) - 0.5;\n    float bbox = max(corner.x, corner.y);\n    if (bbox < halfBorder) {\n        color = texture(channel, p).rgb;\n        float smoothing = SMOOTHING_SIZE / size.x;\n        color *= smoothstep(-smoothing, smoothing, abs(bbox) - halfBorder);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb * 0.8;\n\n    float screenRight = 0.5 * iResolution.x / iResolution.y;\n    for (float column=-screenRight; column < screenRight; column += 0.2) {\n        vec2 columnUV = uv - vec2(column, 0.0);\n        float colId = floor(column / 0.2);\n\n        columnUV.y += noise(colId) * iTime * 4.0 + 1.0;\n        float rowId = floor(columnUV.y / 0.4);\n\n        columnUV.x += 0.2 * sin(floor(columnUV.y / 0.4) + iTime);\n        columnUV.y = mod(columnUV.y, 0.4) - 0.2;\n\n        float n = noise(colId + 573.674 + rowId * 654.986);\n        ImageSprite(color, iChannel0, columnUV, vec2(0.0), vec2(0.25), (n + 3.0) * iTime, 0.025);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 69, 69, 118], [120, 120, 247, 247, 660], [662, 662, 717, 717, 1508]], "test": "untested"}
{"id": "3tKyW1", "name": "Frosty feathers", "author": "jarble", "description": "A simple fractal formula.", "tags": ["fractal", "feather", "frost"], "likes": 2, "viewed": 293, "published": 3, "date": "1610928864", "time_retrieved": "2024-07-30T19:44:26.422611", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    \n        vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/10.0;\n        uv += vec2(iTime/2.0,iTime/3.0)/4.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.1;\n        float scale1 = 1.5;\n        for(int i=0;i<15;i++)\n        {\n            uv = fract(uv/scale1/scale)*scale1*scale;\n            uv += fract(uv/25.0);\n            uv=fract(uv/(2.1+abs((uv.x-uv.y)/8.0))-(uv.yx/(2.0+(fract(uv.x+uv.y))))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = ((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 739]], "test": "untested"}
{"id": "WtKyRD", "name": "Volumetric Path-Tracing Julia 4D", "author": "Zi7ar21", "description": "LoicVDB helped me get the path tracing to use color properly. The Julia set is colored with an Orbit Trap. The Common tab has settings an functions with helpful descriptions.", "tags": ["fractal", "julia", "volumetric", "pathtrace", "trace", "path"], "likes": 15, "viewed": 689, "published": 3, "date": "1610925538", "time_retrieved": "2024-07-30T19:44:27.279321", "image_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// Common is for settings and some functions\n// Buffer A is for rendering\n// Buffer B is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor\n// This is for drawing the shader on the left (or above if you are in portrait mode XD)\n\n// Volumetric Path Tracing Julia 4D by Zi7ar21 --- January 17th, 2020\n// If you found this anywhere except ShaderToy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/WtKyRD\n// Updated January 17th, 2020 16:15 Mountain Time\n// Made with help from LoicVDB (https://www.shadertoy.com/user/loicvdb)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for settings and some functions.\n\n// Adjustable settings (Feel free to change these!)\n\n// Maximum Path-Tracing Steps, more results in slower possible speed but very few paths will bounce\n// enough to end up taking so long.\n#define maxsteps 8192\n\n// Path Tracing Step Size, more results in faster speed but a less accurate volume and a lower possible density.\n#define stepsize 0.01\n\n// Volume Density, more results in a denser volume but values set too high require smaller steps.\n#define volumedensity 50.0\n\n// Scene Size, if a path is this far from the scene it will stop.\n#define scenesize 4.0\n\n// Starting Path Distance, a larger value results in saving steps but you can't render volumes\n// close to the camera. Make sure this is less than the closest point to your object from the camera.\n#define startingdistance 2.0\n\n// Position of the Camera.\n#define cameraposition vec3(0.0, 0.0, -4.0)\n\n// Camera's Field of View, a larger value results in a wider Field of View.\n#define camerafov 1.0\n\n// Size of the Camera's Aperture, a laerger value results in a shallower Depth of Field.\n#define aperturesize 0.05\n\n// Camera Focal Plane, volumes this far are in focus.\n#define focaldistance 4.0\n\n// Constants (Things like Pi for trigonometry, I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for rendering.\n\n// 4D Julia set Distance Estimator (With an Orbit Trap)\nvec4 qsqr(vec4 a){return vec4(a.x*a.x-a.y*a.y-a.z*a.z-a.w*a.w, 2.0*a.x*a.y, 2.0*a.x*a.z, 2.0*a.x*a.w);}\nvec4 distanceestimator(vec3 pos){\n\tvec4 z = vec4(pos, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    vec4 orbitTrap = vec4(1.0);\n    for(int i = 0; i < 8; i++){\n        md2 *= 4.0*mz2;\n        z = qsqr(z)+vec4(-0.5, 0.35, 0.5, 0.0);\n        //z = qsqr(z)+vec4(-0.5, 0.5, 0.25, 0.0);\n        orbitTrap = min(abs(z), orbitTrap);\n        mz2 = dot(z,z);\n        if(mz2 > 4.0) break;}\n    float sdf = 0.25*sqrt(mz2/md2)*log(mz2);\n    return vec4(orbitTrap.rgb, sdf);}\n\n// 3D Volumetric Density Function\nvec4 densityfunction(vec3 pathposition){\n    float density = 0.0;\n    vec4 distanceestimation = distanceestimator(pathposition);\n    if(distanceestimation.w < 0.0){density = volumedensity;}\n    return vec4(distanceestimation.rgb, density);\n}\n\n/*// Light Collision Checker\nbool light(vec3 pathposition){\n    if(distance(pathposition, vec3(0.0, 2.0, 0.0))-0.5 < 0.0){return true;}\n    else{return false;}\n}*/\n\n// Path-Tracing\nvec3 pathtrace(vec3 pathdirection, vec3 inputcameraposition){\n    vec4 density;\n    float absorbance;\n    vec3 attenuation = vec3(1.0);\n    float distancetravelled;\n    vec3 pathposition = inputcameraposition+(pathdirection*startingdistance)+(pathdirection*stepsize*2.0*(rand()-0.5));\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathposition);\n        absorbance = exp(-density.w*stepsize);\n        if(absorbance < rand()){attenuation *= clamp(density.rgb*32.0, vec3(0.0), vec3(1.0)); pathdirection = normalize(nrand3(1.0, vec3(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(distance(pathposition, vec3(0.0)) > scenesize || distancetravelled > 128.0){break;}\n        //if(light(pathposition)){return vec3(2.0)*attenuation;}\n    }\n    return texture(iChannel1, pathdirection).rgb*attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = oldFragColor;\n    INIT_RNG;\n    vec2 uv = ((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/iResolution.x;\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 aperture = vec3(nrand2(aperturesize, vec2(0.0)), 0.0);\n    vec3 pathdirection = normalize(vec3(camerafov*uv, 1.0)-aperture/focaldistance);\n    vec3 pathposition = aperture;\n    pathdirection *= rotationmatrix;\n    pathposition *= rotationmatrix;\n    pathposition += cameraposition;\n    vec3 pathtraced = pathtrace(pathdirection, pathposition);\n    fragColor += vec4(pathtraced, 1.0);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// This is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[684, 684, 738, 738, 800]], "test": "untested"}
{"id": "3lKyDh", "name": "Molecules", "author": "darkeclipz", "description": "testing some stuff from https://www.osar.fr/notes/logspherical/", "tags": ["raymarch", "logspherical"], "likes": 4, "viewed": 289, "published": 3, "date": "1610924598", "time_retrieved": "2024-07-30T19:44:28.130046", "image_code": "\nconst vec2 w = vec2(4.25);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 c0 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    vec4 c1 = texture(iChannel0, (fragCoord.xy - w) / iResolution.xy);\n    vec4 c2 = texture(iChannel0, (fragCoord.xy + w) / iResolution.xy);\n    vec4 c3 = texture(iChannel0, (fragCoord.xy - w*1.5) / iResolution.xy);\n    vec4 c4 = texture(iChannel0, (fragCoord.xy + w*1.5) / iResolution.xy);\n    vec4 c5 = texture(iChannel0, (fragCoord.xy - w*2.0) / iResolution.xy);\n    vec4 c6 = texture(iChannel0, (fragCoord.xy + w*2.0) / iResolution.xy);\n    vec4 c7 = texture(iChannel0, (fragCoord.xy - w*2.5) / iResolution.xy);\n    vec4 c8 = texture(iChannel0, (fragCoord.xy + w*2.5) / iResolution.xy);\n    vec4 bluredImg = 0.1752 * c0 + 0.1658 * (c1 + c2) + 0.1403 * (c3 + c4) + 0.1063 * (c5 + c6) + 0.1001 * (c7 + c8);\n    \n    float base = 0.3*length( (-1.0+2.0*(fragCoord.xy / iResolution.xy) \n                        + vec2(0.5) ));\n    \n\tfragColor = mix( c0, bluredImg, base );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Res iResolution.xy\n#define inf 999.\n#define MAX_DIST 100.\n#define aa 4.\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat2 rotate(float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(inf,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,inf,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,inf));\n  return min(da,min(db,dc));\n}\n\n#define PI 3.1415\n\nvec2 id = vec2(0);\n\nfloat map(in vec3 pos3d)\n{\n    // https://www.osar.fr/notes/logspherical/\n    float time = iTime;\n    time *= 0.2;\n    pos3d.xz *= rotate(iMouse.x/Res.x*8. + fract(time/3.)*PI*2.);\n    float radius = 0.4;\n    float scale = 6.0/PI;\n    vec2 pos2d = pos3d.xz;\n    float r = length(pos2d);\n    pos2d = vec2(log(r) - 1.89*time, atan(pos2d.y, pos2d.x));\n    pos2d *= scale;\n    id = pos2d;\n    pos2d = fract(pos2d) - 0.5;\n    id -= pos2d;\n    float mul = r/scale;\n    float a = (length(vec3(pos2d, pos3d.y/mul)) - radius) * mul;\n    \n    float b = sdVerticalCapsule(abs(vec3(pos2d, pos3d.y/mul)), 0.5, .12);\n    \n    a = min(a,b);\n    \n    return a;\n}\n\nstruct hit {\n    float t;\n    float occl;\n};\n\nhit march(vec3 ro, vec3 rd) {\n    float t = 0., \n          i = 0.,\n          steps = 60.;\n    for(i=0.; i < steps; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if(d < 0.0001) {\n            break;\n        }\n        t += d;\n        if(t > MAX_DIST) {\n            break;\n        }\n    }\n    if(i == steps) t = 20.;\n    return hit(t, 1.-t/steps);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.0001, 0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy),\n                          map(p+h.yxy) - map(p-h.yxy),\n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nvec3 brdf(vec3 N, vec3 L, vec3 V, vec3 diff, vec3 spec, float exponent) {\n    vec3 R = reflect(L,N);\n    vec3 H = normalize(L+V);\n    return diff * clamp(dot(N, L), 0., 1.)\n         + spec * pow(max(0., dot(R,V)), exponent);\n}\n\nvec3 shade(vec3 P, vec3 N, vec3 ro) {\n    vec3 V = normalize(P-ro);\n    vec3 ambient = vec3(.1);\n    vec3 diffuse = vec3(1.,.2,.2);\n    vec3 specular = vec3(.8,.8,.6);\n    \n    if(mod(id.x, 2.0) < 1.) {\n        diffuse = vec3(0,0,1);\n    }\n    \n    if(mod(id.y, 2.0) < 1.0 && mod(id.x, 2.0) < 1.\n    || mod(id.y, 2.0) > 1.0 && mod(id.x, 2.0) > 1.) {\n        diffuse = vec3(1);\n    }\n    \n    vec3 R = reflect(normalize(ro-P), N);\n    vec3 tex = texture(iChannel0, R).rgb;\n    \n    //diffuse = mix(diffuse, tex, 0.3);\n    \n    vec3 light1 = brdf(N, normalize(vec3(-4.,5,-6) - P), V, diffuse, vec3(0), 32.);\n    vec3 light2 = brdf(N, normalize(vec3(1,0,4) - P), V, diffuse, specular, 32.);\n    return ambient + light1 + light2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float stratSize = 1./aa;\n    vec3 fcol = vec3(0);\n    for(float aax=0.; aax<aa; aax++)\n    for(float aay=0.; aay<aa; aay++) {\n        vec2 strat = vec2(aax, aay) * stratSize;\n        vec2 jitter = vec2(random(fragCoord + 4.1252 + aax + fract(iTime)), \n                           random(fragCoord + 1.3483 + aay + fract(iTime))) * stratSize;\n        vec2 uv = (2.*fragCoord + strat + jitter - Res)/Res.y;\n        vec3 col = vec3(0);\n        vec3 ro = vec3(.0,1.,-1.);\n        vec3 ta = vec3(.0,0,0);\n        vec3 ww = normalize( ta-ro );\n        vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n        vec3 vv = normalize( cross(uu,ww) );\n        vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.8*ww );\n        hit hit = march(ro, rd);\n        if(hit.t < MAX_DIST) {\n            vec3 p = ro + hit.t*rd;\n            vec3 N = normal(p);\n            col = shade(p, N, ro) \n                    * exp(-0.1*hit.t)\n                    * hit.occl;\n        }\n        fcol += col;\n    }\n\n    fragColor = vec4(pow(fcol/(aa*aa), vec3(2.2)),1.0);\n}\n", "buffer_a_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 1030]], "test": "untested"}
{"id": "ttycD1", "name": "AGI Ch4 Stripped", "author": "vchizhov", "description": "A framework for a path tracer for the book reading of the book advanced global illumination in the graphics programming discord. If the storage of subnormal floats doesn't work well, set webgl.disable-angle to true. ", "tags": ["pathtracing"], "likes": 0, "viewed": 292, "published": 3, "date": "1610919754", "time_retrieved": "2024-07-30T19:44:29.434559", "image_code": "// Fork of \"AGI Ch4 Ref\" by vchizhov. https://shadertoy.com/view/wlGcD1\n// 2021-01-17 21:35:52\n\n// Fork of \"AGI Pathtracer base\" by vchizhov. https://shadertoy.com/view/3ldyRs\n// 2021-01-17 21:24:16\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* fetch the progressive image for the current frame */\n    vec4 buffD = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    /* gamma compression */\n    vec3 col = sqrt(buffD.xyz);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    README:\n    \n    Use WASDQE for movement, LMB for rotation (drag), space for render mode change.\n    \n    \n    You care about Buffer C mainly, as well as Common.\n\n    Buffer A: captures mouse and keyboard input and output.\n        - it stores:\n            - translation in xyz at pixel (0,0).\n            \n            - frame count since last update in w at pixel (0,0).\n            \n            - rotation angles in xy at pixel (1,0).\n            \n            - R key down in x at pixel (0,1).\n            - scene index in y at pixel (0,1).\n            - space key down in z at pixel (0,1).\n            - render mode in w at pixel (0,1).\n            \n            - previous frame mouse position in xy at pixel (1,1).\n            - prvious frame mouse down in z at pixel (1,1).\n            \n    Buffer B: ciurrently empty\n    \n    Buffer C: sets up the scene, the camera, and renders the image.\n        - stores the current frame render for every pixel in xyz.\n        - stores the state of the prng for every pixel in w.\n        \n    Buffer D: merges the current rendered frame and previously accumulated.\n        (progressive rendering)\n\n*/\n\n/*\n    TODO:\n    0) boxes\n    1) metal, dielectric, Phong\n\n    TODO:\n    0) Clean up.\n    1) Add different cameras (e.g. with aperture).\n    2) Materials (the ones from the book?).\n    3) Other importance sampling methods.\n    4) Direct light sampling + MIS.\n    5) BDPT.\n\n*/\n\n#ifndef HW_PERFORMANCE\n//uniform sampler2D iChannel1;\n#endif\n\n#define INF uintBitsToFloat(0x7F800000u)\n#define PI 3.141592653589793\n#define EPS 0.0001\n#define RENDER_MODE_COUNT 6u\n#define SCENES_COUNT 2u;\n\n#define BDELTA 5\n#define BMIN 0\n#define BMAX BMIN+BDELTA\n#define PHI_4 1.22074408460576\n/* L ~ T^{BMIN}Le + ... + T^{BMAX}Le */\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                      PSEUDORANDOM NUMBER GENERATOR                       */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\n/*\n    Wang hash, see:\n    http://www.burtleburtle.net/bob/hash/integer.html\n    http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\n*/\n\nuint wang_hash(uint seed)\n\n/*\n    Used to initialize the state of the PRNG based on pixel coordinates.\n*/\n\n{\n    seed = (seed ^ 61u) ^ (seed >> 16u);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4u);\n    seed *= 0x27d4eb2du;\n    seed = seed ^ (seed >> 15u);\n    return 1u+seed;\n}\n\n/****************************************************************************/\n\n/* \n    xorshift, see:\n    https://en.wikipedia.org/wiki/Xorshift#Example_implementation \n*/\n\n/* The state word must be initialized to non-zero */\nuint xorshift32(uint state)\n\n/*\n    Used to advanced the xorshift state.\n*/\n\n{\n\t/* Algorithm \"xor\" from p. 4 of Marsaglia, \"Xorshift RNGs\" */\n\tuint x = state;\n\tx ^= x << 13u;\n\tx ^= x >> 17u;\n\tx ^= x << 5u;\n\treturn x;\n}\n\n/****************************************************************************/\n\nfloat rand(inout uint state)\n\n/*\n    Advances the prng state and returns the corresponding random float.\n*/\n\n{\n    uint x = xorshift32(state);\n    state = x;\n    return float(x)*uintBitsToFloat(0x2f800004u);\n}\n\n/****************************************************************************/\n\nvec2 rand2(inout uint state)\n\n/*\n    Advances the prng state twice state and returns 2 random floats.\n*/\n\n{\n    vec2 r = vec2(rand(state), rand(state));\n    /*uint x = xorshift32(state);\n    r.x = float(x)*uintBitsToFloat(0x2f800004u);\n    uint y = xorshift32(x);\n    r.y = float(y)*uintBitsToFloat(0x2f800004u);\n    state = y;*/\n    \n    return r;\n}\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                             BASIC STRUCTS                                */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nstruct Ray\n{\n    vec3 o; /* origin */\n    vec3 d; /* direction */\n};\n\n/****************************************************************************/\n\nstruct Material\n{\n    uint type;\n    vec3 color;\n    vec3 Le;\n};\n\n/****************************************************************************/\n\n#define MATERIAL_LAMBERTIAN 0u\n#define MATERIAL_MIRROR 1u\n#define MATERIAL_DIELECTRIC 2u\n\n/****************************************************************************/\n\nMaterial create_Lambertian(in vec3 c)\n{\n    return Material(MATERIAL_LAMBERTIAN, c/PI, vec3(0.0));\n}\n\n/****************************************************************************/\n\nMaterial create_mirror(in vec3 c)\n{\n    return Material(MATERIAL_MIRROR, c, vec3(0.0));\n}\n\n/****************************************************************************/\n\nstruct Isect_data\n{\n    float t;      /* ray parameter */\n    vec3  n;      /* normal */\n    vec2  uv;     /* uv coordinates */\n    int   mat;    /* material index */ \n};\n\n/****************************************************************************/\n\nstruct Camera\n{\n    vec3 o;        /* origin */\n    vec3 e1,e2,e3; /* right, up, forward */\n};\n\n/****************************************************************************/\n\nCamera look_at(in vec3 o, in vec3 t, in vec3 u)\n{\n    Camera c;\n    c.o = o;\n    c.e3 = normalize(t-o);\n    c.e1 = normalize(cross(u,c.e3));\n    c.e2 = cross(c.e3, c.e1);\n    \n    return c;\n}\n\n/****************************************************************************/\n\nvec2 get_uv (vec2 coord, vec2 res)\n{\n    /* remap to [0,1]^2 */\n    vec2 uv = coord / res.xy;\n    /* remap to [-1,1]^2 */\n    uv = 2.0*uv - vec2(1.0);\n    /* remap x to [-aspect_ratio, aspect_ratio] */\n    float aspect_ratio = res.x/res.y;\n    uv.x *= aspect_ratio;\n    \n    return uv;\n}\n\n/****************************************************************************/\n\nRay generate_ray (Camera cam, vec2 uv)\n{\n    return Ray(cam.o, cam.e3 + uv.x*cam.e1 + uv.y*cam.e2);\n}\n\n/****************************************************************************/\n\nstruct Sphere\n{\n    vec3  o;  /* center of the sphere */\n    float r;  /* radius of the sphere */\n    int   mat;/* material index */\n};\n\n/****************************************************************************/\n\nstruct Parallelogram\n{\n    vec3 v1, v2, v3;\n    int mat; /* material index */\n};\n\n/****************************************************************************/\n\nstruct Scene\n{\n    Material materials[11];\n    int material_count;\n\n\tSphere spheres[3];\n    int sphere_count;\n    \n\tParallelogram parallelograms[6];\n    int parallelogram_count;\n};\n\n/****************************************************************************/\n\nScene create_scene()\n{\n    Scene scene;\n    scene.sphere_count = 0;\n    scene.parallelogram_count = 0;\n    \n    return scene;\n}\n\n/****************************************************************************/\n\nint add(inout Scene scene, in Sphere sphere)\n{\n\tscene.spheres[scene.sphere_count] = sphere;\n    ++scene.sphere_count;\n    return scene.sphere_count - 1;\n}\n\n/****************************************************************************/\n\nint add(inout Scene scene, in Parallelogram parallelogram)\n{\n\tscene.parallelograms[scene.parallelogram_count] = parallelogram;\n    ++scene.parallelogram_count;\n    return scene.parallelogram_count - 1;\n}\n\n/****************************************************************************/\n\nint add(inout Scene scene, in Material mat)\n{\n\tscene.materials[scene.material_count] = mat;\n    ++scene.material_count;\n    return scene.material_count-1;\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                             INTERSECTION                                 */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nfloat intersect\n\n    (in  Ray          r,\n     in  float        tmin,\n     in  float        tmax,\n     out Isect_data   data,\n     in  Sphere       s)\n     \n{\n    /*\n        ||r.o+t*r.d-s.o||^2 = (s.r)^2\n        t^2*||r.d||^2 -2*t*<r.d,s.o-r.o> + ||s.o-r.o||^2 - (s.r)^2 = 0\n        t^2*A - 2*t*B + C = 0\n        A = ||r.d||^2, B = <r.d,s.o-r.o>, C = ||s.o-r.o||^2 - (s.r)^2\n        D = B^2-A*C\n        if D<0 -> no intersection\n        D = sqrt(D)\n        t0 = (B-D)/A\n        t1 = (B+D)/A\n        \n        t_isect = inf{t : t in {t0,t1}, tmin<=t<=tmax}\n        (note: inf{} = infty <- the infinimum of an empty set is infty)\n        if t_isect = infty -> no intersection\n        otherwise t_isect is the intersection\n    */\n    \n    /* compute quadratic equation coefficients */\n    float A = dot(r.d,r.d);\n    vec3 roso = s.o-r.o;\n    float B = dot(r.d, roso);\n    float C = dot(roso, roso) - s.r*s.r;\n    \n    /* compute discriminant */\n    float D = sqrt(B*B-A*C); /* if D<0 -> NaN */\n    \n    /* compute the roots (those are NaN if sqrt(D) was NaN) */\n    float t0 = (B-D)/A;\n    float t1 = (B+D)/A;\n    \n    /* check whether t0 and t1 are in [tmin,tmax] */\n    t0 = ((tmin <= t0) && (t0 <=tmax)) ? t0 : INF; /* D=NaN -> INF */\n    t1 = ((tmin <= t1) && (t1 <=tmax)) ? t1 : INF;\n    float t = min(t0,t1);\n    \n    /* fill out intersection data */\n    data.t = t;\n    data.n = (r.o+t*r.d-s.o)/s.r;\n    data.uv = vec2(0);\n    data.mat = s.mat;\n\n    return t;\n}\n\n/****************************************************************************/\n\n\nfloat intersect\n\n    (in  Ray           r,\n     in  float         tmin,\n     in  float         tmax,\n     out Isect_data    data,\n     in  Parallelogram p)\n     \n{\n    /*\n        e1 = p.v2-p.v1, e2 = p.v3-p.v1\n        p(u,v) = p.v1 + u*e1 + v*e2\n        r(t) = r.o + t*r.d\n        \n        1) Find plane intersection:\n        n = cross(e1,e2)\n        dot(n,r.o+t*r.d-p.v1) = 0\n        t' = dot(n,p.v1-r.o)/dot(n,r.d)\n        \n        2) Find uv coordinates:\n        q = r(t') = r.o + t'*r.d\n        \n        r(t') = p(u,v) ->\n        vq = q-p.v1\n        \n        vq = u*e1 + v*e2\n        \n        a) dot with e1 ->\n        dot(e1,vq) = u*dot(e1,e1) + v*dot(e1,e2)\n        \n        b) dot with e2 ->\n        dot(e2,vq) = u*dot(e1,e2) + v*dot(e2,e2)\n        \n        e1vq = dot(e1,vq)\n        e2vq = dot(e2,vq)\n        e1e1 = dot(e1,e1)\n        e1e2 = dot(e1,e2)\n        e2e2 = dot(e2,e2)\n        \n        det = e1e1*e2e2-e1e2*e1e2\n        u = (e1vq*e2e2 - e2vq*e1e2)/det\n        v = (e2vq*e1e1 - e1vq*e1e2)/det\n        \n        0<=u<=1, 0<=v<=1 -> q inside parallelogram\n    */\n    \n    /* compute edges */\n    vec3 e1 = p.v2-p.v1;\n    vec3 e2 = p.v3-p.v1;\n    \n    /* compute normal */\n    vec3 n = cross(e1,e2);\n    \n    /* 1) Find plane intersection: */\n    float t = dot(n,p.v1-r.o)/dot(n,r.d);\n    \n    /* filter out no-intersections */\n    t = (tmin<=t && t<=tmax) ? t : INF;\n    \n    /* 2) Find uv coordinates: */\n    \n    /* intersection location */\n    vec3 q = r.o + t * r.d;\n    \n    /* convenience */\n    vec3 vq = q-p.v1;\n    \n    /* system matrix coefficients */\n    float e1e1 = dot(e1,e1);\n    float e1e2 = dot(e1,e2);\n    float e2e2 = dot(e2,e2);\n    \n    /* right-hand side coefficients */\n    float e1vq = dot(e1,vq);\n    float e2vq = dot(e2,vq);\n    \n    /* system solution */\n    float det = e1e1*e2e2-e1e2*e1e2;\n    float u = (e1vq*e2e2 - e2vq*e1e2)/det;\n    float v = (e2vq*e1e1 - e1vq*e1e2)/det;\n    \n    /* filter out no-intersections */\n    t = (0.0<=u && u<=1.0 && 0.0<=v && v<=1.0) ? t : INF;\n    \n    /* fill out intersection data */\n    data.t = t;\n    data.n = normalize(n);\n    data.uv = vec2(u,v);\n    data.mat = p.mat;\n    \n    return t;\n}\n\n/****************************************************************************/\n\nfloat intersect\n\n    (in  Ray          r,\n     in  float        tmin,\n     in  float        tmax,\n     out Isect_data   d,\n     in  Scene        scene)\n     \n{\n    Isect_data d_tmp;\n    \n    /* find the closest sphere intersection */\n    Isect_data d_sph;\n    float closest_t_sph = tmax;\n    for (int i=0; i<scene.sphere_count; ++i)\n    {\n        float t = intersect(r, tmin, closest_t_sph, d_tmp, scene.spheres[i]);\n        if (t<INF)\n        {\n            closest_t_sph = t;\n            d_sph = d_tmp;\n        }\n    }\n     \n    /* find the closest parallelogram intersection */    \n    Isect_data d_prl;\n    float closest_t_prl = tmax;\n    for (int i=0; i<scene.parallelogram_count; ++i)\n    {\n        float t = intersect(r, tmin, closest_t_prl, d_tmp, scene.parallelograms[i]);\n        if (t<INF)\n        {\n            closest_t_prl = t;\n            d_prl = d_tmp;\n        }\n    }   \n    \n    /* choose between parallelogram isect and sphere isect */\n    float closest_t;\n    if (closest_t_sph<closest_t_prl)\n    {\n        d = d_sph;\n        closest_t = closest_t_sph;\n    }\n    else\n    {\n        d = d_prl;\n        closest_t = closest_t_prl;\n    }\n    \n    /* if there was an intersection return it, otherewise -> INF */\n    if (closest_t < tmax)\n    {\n        return closest_t;\n    }\n    else\n    {\n        d.t = INF;\n        return INF;\n    }\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                           SAMPLES MAPPING                                */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nvec3 map_to_unit_sphere (in vec2 uv)\n\n/*\n    Maps from [0,1]^2 to the unit sphere.\n*/\n\n{\n    float cos_theta = 2.0*uv.x-1.0;\n    float phi = 2.0*PI*uv.y;\n    float sin_theta = sqrt(1.0-cos_theta*cos_theta);\n    float sin_phi = sin(phi);\n    float cos_phi = cos(phi);\n    \n    return vec3(sin_theta*cos_phi, cos_theta, sin_theta*sin_phi);\n}\n\n/****************************************************************************/\n\nvec3 map_to_unit_hemisphere_cosine_weighted (in vec2 uv, in vec3 n)\n\n/*\n    Maps from [0,1]^2 to the unit hemisphere around n with a cosine density.\n    Expects n to be a unit vector.\n*/\n\n{\n    vec3 p = map_to_unit_sphere (uv);\n    return n+p;\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                              ESTIMATORS                                  */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nvec3 estimator_binary (in Ray r, in Scene s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    bool isect = bool(t<INF); /* is there an intersection? */\n    \n    return vec3(isect); /* return white upon intersection */\n}\n\n/****************************************************************************/\n\nvec3 estimator_color (in Ray r, in Scene s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    bool isect = bool(t<INF); /* is there an intersection? */\n    \n    /* return the color*PI if there's an intersection */\n    return PI*s.materials[data.mat].color*float(isect);\n}\n\n/****************************************************************************/\n\nvec3 estimator_depth (in Ray r, in Scene s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    /* intersection distance from the origin of the ray */\n    float dist = t/length(r.d);\n    \n    /* map from [0,inf] to [1, 0] */\n    float inv_dist = 1.0/(1.0+dist);\n    \n    return vec3(inv_dist);\n}\n\n/****************************************************************************/\n\nvec3 estimator_normals (in Ray r, in Scene s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    /* return black if no intersection */\n    if(!(t<INF)) return vec3(0);\n    \n    \n    /* ---- return the normal if there is an intersection ---- */\n    \n    /* correct normal is in the oppoiste hemisphere of the incident ray */\n    vec3 n = -data.n * sign(dot(data.n, r.d));\n\n    /* map from S^2 to [0,1]^3 */\n    return 0.5*n+vec3(0.5);\n}\n\n/****************************************************************************/\n\nvec3 estimator_ambient_occlusion (in Ray r, in Scene scene, inout uint state, vec3 Le)\n\n/*\n    Models the sphere at infinity as the only emitter. Computes \n    only direct illumination.\n*/\n\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, scene);\n    \n    /* infinite light source */\n    //vec3 Le = vec3(1.0);\n    \n    bool isect = bool(t<INF);\n    \n    /* if no intersection -> hit infinite light source */\n    if (!isect) return Le;\n    \n    \n    /* ---- intersection -> compute direction illumination ---- */\n    \n    /* correct normal is in the oppoiste hemisphere of the incident ray */\n    vec3 n = -data.n * sign(dot(data.n, r.d));\n    \n    /* pick a random point in [0,1]^2 */\n    vec2 r2 = rand2(state);\n    \n    /* map from [0,1]^2 to the upper hemisphere with cos density */\n    vec3 dir = map_to_unit_hemisphere_cosine_weighted (r2, n);\n\n    /* intersection location of the primary ray with the scene */\n    vec3 p = r.o + r.d*t;\n\n    /* scattered ray */\n    Ray ao_ray = Ray(p+EPS*n, dir);\n\n    /* check for intersection with any object (scene points do not emit) */\n    Isect_data data_tmp;\n    float t_ao = intersect(ao_ray, 0.0, INF, data_tmp, scene);\n\n    /* check whether the infinite light source is hit */\n    bool visibility = !bool(t_ao<INF);\n\n    /* direct illumination + 1 bounce direct illumination */\n    vec3 col = scene.materials[data.mat].Le \n             + Le*PI*scene.materials[data.mat].color*float(visibility);\n\n    return col;\n}\n\n/****************************************************************************/\n\nvec3 estimator_path_tracing_Lambertian (in Ray r_in, in Scene scene, inout uint state, int bounces, in vec3 Le, in samplerCube tex)\n{\n    /* intersection data */\n    Isect_data data;\n    \n    /* the first ray is the primary ray */\n    Ray r = r_in;\n    \n    /* accumulated color */\n    vec3 col = vec3(0.0);\n    \n    /* We = 1.0 */\n    vec3 throughput = vec3(1.0);\n    \n    /* light source */\n    //vec3 Le = vec3(1.0);\n    \n    /* bounce around the scene */\n    for (int b=0; b<bounces; ++b)\n    {\n        /* find intersection */\n        float t = intersect(r, 0.0, INF, data, scene);\n        \n        bool isect = bool(t<INF);\n        \n        /* assume lights sources at infinity */\n        if (!isect) \n        {\n            /* add direct light contribution */\n            if (BMIN<=b && b<=BMAX)\n                col += throughput * Le * texture(tex, r.d).xyz;\n            break; \n        }\n\n        /* add direct light contribution */\n        /* estimator I_b, use the attenuated values in throughput */\n        if (BMIN<=b && b<=BMAX)\n        {\n            /* ---- YOUR CODE HERE ---- */\n        }\n        \n        /* construct the estimator for the next bounce */\n        /* ---- YOUR CODE HERE ---- */\n        \n        /* correct facing normal */\n        vec3 n = -data.n * sign(dot(data.n, r.d));\n        \n        /* pick a random point in [0,1]^2 */\n        vec2 r2 = rand2(state);\n    \n        /* map from [0,1]^2 to the upper hemisphere with cos density */\n        /* ---- YOUR CODE HERE ---- */\n        \n        /* set the origin and direction of the next ray */\n        /* ---- YOUR CODE HERE ---- */\n    }\n    \n    /* return the accumulated intensity */\n    return col;\n}\n\n/****************************************************************************/", "buffer_a_code": "/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                           IO and RENDER STATE                            */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nfloat keyClick(int ascii) {\n\treturn float(texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\n/****************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    /* ---- initialize/retrieve state ---- */\n    \n    vec3 translation;  /* camera translation */\n    vec2 rot;          /* camera rotation angles */\n    uint frame_count;  /* frame count */\n    vec2 old_mouse_pos;/* the position of the mouse in the previous frame */\n    bool old_mouse_down;/* whether the mouse was down the previous frame */\n    bool old_key_R_down;/* true if R was down in the previous frame */\n    uint scene_idx;     /* scene index */\n    bool old_key_space_down;\n    uint render_mode;  /* render mode index */\n\n    \n    vec4 buffA_00 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 buffA_10 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 buffA_01 = texelFetch(iChannel0, ivec2(0,1), 0);\n    vec4 buffA_11 = texelFetch(iChannel0, ivec2(1,1), 0);\n    \n    if (iFrame==0)\n    {\n        /* intialize the data in the first frame */\n        translation = vec3(0,0,-5.0);\n        rot = vec2(0.0);\n        \n        frame_count = 0u;\n        \n        old_key_R_down = false;\n        scene_idx = 0u;\n        \n        old_key_space_down = false;\n        render_mode = RENDER_MODE_COUNT-1u;\n        \n        old_mouse_pos = iMouse.xy;\n        old_mouse_down = false;\n\n    }\n    else\n    {\n        /* retrieve data from last frame */\n        translation = buffA_00.xyz;\n        rot = buffA_10.xy;\n         \n        frame_count = floatBitsToUint(buffA_00.w);\n        \n        old_key_R_down = bool(buffA_01.x>0.0);\n        scene_idx = floatBitsToUint(buffA_01.y);\n        \n        old_key_space_down = bool(buffA_01.z>0.0);\n        render_mode = floatBitsToUint(buffA_01.w);\n        \n        old_mouse_pos = buffA_11.xy;\n        old_mouse_down = bool(buffA_11.z>0.0);\n    }\n\n\n\n\n    /* ---- handle movement and rotation ---- */\n    \n    /* aspect ratio */\n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    /* camera translation: WASDQE */\n    const int key_A = 65; /* right */\n    const int key_D = 68; /* left */\n    const int key_Q = 69; /* down */\n    const int key_E = 81; /* up */\n    const int key_W = 83; /* forward */\n    const int key_S = 87; /* down */\n    vec3 diff = vec3(keyClick(key_D) - keyClick(key_A), keyClick(key_E) - keyClick(key_Q), keyClick(key_S) - keyClick(key_W));\n    vec3 translation_speed = vec3(10.0)*iTimeDelta;\n    translation += translation_speed * diff;\n    bool key_down = any(greaterThan(abs(diff),vec3(0.5)));\n    \n    /* rotation for this frame: LMB drag */\n    bool mouse_down = bool(iMouse.z>0.0);\n    vec2 rot_speed = vec2(0.2) * iTimeDelta * vec2(1.0, 1.0/aspectRatio);\n    if (!old_mouse_down) old_mouse_pos = iMouse.xy;\n    rot = rot\n        + ((mouse_down) ? rot_speed*(iMouse.xy-old_mouse_pos) : vec2(0.0));\n        \n    /* change rendering mode: space */\n    const int key_space = 32;\n    bool key_space_down = bool(keyClick(key_space)>0.0);\n    bool key_space_released = (!key_space_down && old_key_space_down);\n    if (key_space_released)\n       render_mode = (render_mode + 1u) % RENDER_MODE_COUNT;\n    \n    /* change scene: R */\n    const int key_R = 82;\n    bool key_R_down = bool(keyClick(key_R)>0.0);\n    bool key_R_released = (!key_R_down && old_key_R_down);\n    if (key_R_released)\n       scene_idx = (scene_idx + 1u) % SCENES_COUNT;\n    \n    /* needs update */\n    bool frame_counter_needs_reset = mouse_down || key_down || key_space_released || key_R_released;\n    \n    /* reset frame counter if camera location changed */\n    if (frame_counter_needs_reset)\n    {\n        frame_count = 0u;\n    }\n\n    /* count frame */\n    frame_count = frame_count + 1u;\n\n\n\n    \n    /* ---- store state ---- */\n    \n    if (all(equal(ivec2(fragCoord), ivec2(0)))) /* pixel (0,0) */\n    {\n        /* store translation and frame count */\n        fragColor = vec4(translation,uintBitsToFloat(frame_count));\n    }\n    else if (all(equal(ivec2(fragCoord), ivec2(1,0)))) /* pixel (1,0) */\n    {\n        /* mouse-drag rotation state */\n        fragColor = vec4(rot, 0.0, 0.0);\n    }\n    else if (all(equal(ivec2(fragCoord), ivec2(0,1)))) /* pixel (0,1) */\n    {\n        /* R & scene_idx, space & render_mode */\n        fragColor = vec4(float(key_R_down), uintBitsToFloat(scene_idx), \n                         float(key_space_down), uintBitsToFloat(render_mode));\n    }\n    else if (all(equal(ivec2(fragCoord), ivec2(1,1)))) /* pixel (1,1) */\n    {\n        /* mouse state */\n        fragColor = vec4(iMouse.xy, float(mouse_down), 0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                          SCENE CONSTRUCTION                              */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nvoid construct_scene(inout Scene scene, inout vec3 Le, uint scene_idx)\n{\n    if (scene_idx==0u) /* First scene: Some spheres */\n    {\n        Le = vec3(1.0);\n        \n        int mat_idx;\n        mat_idx = add(scene, create_mirror(vec3(1.0, 0.3, 0.1)));\n        add(scene, \n            Sphere(vec3(0,0,0), 1.0, mat_idx)\n        );\n        \n        mat_idx = add(scene, create_Lambertian(vec3(0.8)));\n        add(scene, \n            Sphere(vec3(0,-101, 0), 100.0, mat_idx)\n        );\n\n        mat_idx = add(scene, create_Lambertian(vec3(0.3, 1.0, 0.0)));\n        add(scene, \n            Sphere(vec3(1,3,-1), 1.7, mat_idx)\n        );\n    }\n    else /* Second scene: Cornell Box */\n    {\n        Le = vec3(0.05);\n        int mat_idx;\n        /* Cornell box */\n        float scale = 8.0;\n        vec3 cb_offset = vec3(0);\n        vec3 dim = scale*vec3(1.3, 1.7, 1.0);\n        vec3 v1,e1,e2;\n        vec3 col;\n\n        /* back wall */\n        v1 = 0.5*vec3(-dim.x, -dim.y, dim.z);\n        e1 = vec3(dim.x, 0, 0);\n        e2 = vec3(0, dim.y, 0);\n        col = vec3(0.5, 0.5, 0.2);\n\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* left wall */\n        v1 = -0.5*dim;\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(0,dim.y,0);\n        col = vec3(1.0, 0.0, 0.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* right wall */\n        v1 = 0.5*vec3(dim.x, -dim.y, -dim.z);\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(0,dim.y,0);\n        col = vec3(0.1, 0.1, 1.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* top wall */\n        v1 = 0.5*vec3(-dim.x, dim.y, -dim.z);\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(dim.x,0,0);\n        col = vec3(0.0, 1.0, 0.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        //float flicker_speed = 0.0;\n        //scene.materials[mat_idx].Le = vec3((1.0+sin(flicker_speed*iTime))*vec2(1.0),0.0);\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* bottom wall */\n        v1 = -0.5*dim;\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(dim.x,0,0);\n        col = vec3(1.0, 1.0, 1.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n        \n        /* lamp */\n        float lamp_scale = 0.5;\n        v1 = 0.5*vec3(-lamp_scale*dim.x, dim.y*0.98, -lamp_scale*dim.z);\n        e1 = lamp_scale*vec3(0,0,dim.z);\n        e2 = lamp_scale*vec3(dim.x,0,0);\n        col = vec3(0.0, 0.0, 0.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        scene.materials[mat_idx].Le = vec3(5.0);\n        /*add(scene, \n            Sphere(\n                vec3(0), 3.0, \n                mat_idx\n            )\n        );*/\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n        \n    }\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                          PRNG STATE RETRIEVAL                            */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nuint retrieve_state(vec2 fragCoord)\n{\n    /* \n        If it's the first frame we use wang_hash on the screen \n        coordinates to get some random uints to initialize xorshift \n        with. At the end of each frame we store the state of the prng.\n        If it's not the first frame, we load the state stored in the \n        previous frame.\n    */\n\n    uint state;\n    if (iFrame==0)\n    {\n        uvec2 ucoord = uvec2(fragCoord);\n        uint pixel_index = ucoord.x + ucoord.y * uint(iResolution.x);\n        uint seed = wang_hash(pixel_index);\n        state = seed;\n    }\n    else\n    {\n        vec4 buffA = texelFetch(iChannel2, ivec2(fragCoord), 0);\n        state = floatBitsToUint(buffA.w);     \n    }\n    return state;\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                          IMAGE GENERATION                                */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    /* ---- Retrieve state from previous frames and other buffers ---- */\n    \n    uint state = retrieve_state(fragCoord);\n\n    vec4 buffA_01 = texelFetch(iChannel0, ivec2(0,1), 0);\n    /* extract scene index from bufferA */\n    uint scene_idx = floatBitsToUint(buffA_01.y);\n    /* extract render_mode from bufferA */\n    uint render_mode = floatBitsToUint(buffA_01.w);   \n    \n    /* extract translation from bufferA */\n    vec4 buffA_00 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec3 translation = buffA_00.xyz;\n    uint frame_count = floatBitsToUint(buffA_00.w);\n    \n    /* extract rotation from bufferA */\n    vec4 buffA_10 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec2 rot = buffA_10.xy;\n    \n    \n    \n    /* ---- Construct Scene ---- */\n    \n    Scene scene = create_scene();\n    vec3 Le;\n    construct_scene (scene, Le, scene_idx);\n\n\n\n    /* ---- Construct Camera ---- */\n    \n    /* compute aspect ratio  */\n    float aspect_ratio = iResolution.x/iResolution.y;    \n    /* camera position from spherical coordinates */\n    float cosTheta = cos(rot.y);\n    vec3 cpos = translation.z*vec3(cosTheta*sin(rot.x),\n                          sin(rot.y),\n                        cosTheta*cos(rot.x));\n                        \n    Camera cam = look_at(cpos, vec3(0,1.0,0), vec3(0,1,0));\n    cam.o += cam.e1*translation.x + cam.e2*translation.y;\n\n\n\n    /* ---- Render ---- */\n    \n    /* samples per pixel */\n    const int spp = 1;\n    \n    /* accumulate measured irradiance per pixel over spp samples */\n    vec3 col = vec3(0.0);\n    for (int s=0; s<spp; ++s)\n    {\n        /* randomly offset primary rays for anti-aliasing */\n        vec2 aa_offset = rand2(state);\n        vec2 uv = get_uv(fragCoord+aa_offset, iResolution.xy);\n        Ray ray = generate_ray (cam, uv);\n    \n        #define RENDER_MODE 5u\n        /* accumulate radiance */\n        switch (render_mode)\n        {\n        case 0u:\n            col += estimator_binary(ray, scene);\n            break;\n        case 1u:\n            col += estimator_color(ray, scene);\n            break;\n        case 2u:\n            col += estimator_depth(ray, scene);\n            break;\n        case 3u:\n            col += estimator_normals(ray, scene);\n            break;\n        case 4u:\n            col += estimator_ambient_occlusion(ray, scene, state, vec3(1.0));\n            break;\n        default:\n            col += estimator_path_tracing_Lambertian(ray, scene, state, 5, Le, iChannel3);\n            break;\n        }\n    }\n    \n    /* box reconstruction filter */\n    col /= float(spp);\n    \n    /* store color and prng state */\n    fragColor = vec4(col, uintBitsToFloat(state));\n}", "buffer_c_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /* fetch the render from the current frame */\n    vec3 render = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n    vec4 buffD = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    /* fetch the accumulated render from previous frames */\n    vec3 acc_frame_col = buffD.xyz;\n    \n    /* fetch the frame count since the last reset */\n    vec4 buffA_00 = texelFetch(iChannel0, ivec2(0,0), 0);\n    uint frame_count = floatBitsToUint(buffA_00.w);\n    \n    /* progressive rendering / weighted average */\n    vec3 col = float(frame_count-1u)/float(frame_count) * acc_frame_col \n             + 1.0/float(frame_count) * render;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 257, 317, 474]], "test": "untested"}
{"id": "wlGcD1", "name": "AGI Ch4 Ref", "author": "vchizhov", "description": "A framework for a path tracer for the book reading of the book advanced global illumination in the graphics programming discord. If the storage of subnormal floats doesn't work well, set webgl.disable-angle to true. ", "tags": ["pathtracing"], "likes": 6, "viewed": 859, "published": 3, "date": "1610919396", "time_retrieved": "2024-07-30T19:44:30.645321", "image_code": "// Fork of \"AGI Pathtracer base\" by vchizhov. https://shadertoy.com/view/3ldyRs\n// 2021-01-17 21:24:16\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* fetch the progressive image for the current frame */\n    vec4 buffD = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n    /* gamma compression */\n    vec3 col = sqrt(buffD.xyz);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    README:\n    \n    Use WASDQE for movement, LMB for rotation (drag), space for render mode change.\n    \n    \n    You care about Buffer C mainly, as well as Common.\n\n    Buffer A: captures mouse and keyboard input and output.\n        - it stores:\n            - translation in xyz at pixel (0,0).\n            \n            - frame count since last update in w at pixel (0,0).\n            \n            - rotation angles in xy at pixel (1,0).\n            \n            - R key down in x at pixel (0,1).\n            - scene index in y at pixel (0,1).\n            - space key down in z at pixel (0,1).\n            - render mode in w at pixel (0,1).\n            \n            - previous frame mouse position in xy at pixel (1,1).\n            - prvious frame mouse down in z at pixel (1,1).\n            \n    Buffer B: ciurrently empty\n    \n    Buffer C: sets up the scene, the camera, and renders the image.\n        - stores the current frame render for every pixel in xyz.\n        - stores the state of the prng for every pixel in w.\n        \n    Buffer D: merges the current rendered frame and previously accumulated.\n        (progressive rendering)\n\n*/\n\n/*\n    TODO:\n    0) boxes\n    1) metal, dielectric, Phong\n\n    TODO:\n    0) Clean up.\n    1) Add different cameras (e.g. with aperture).\n    2) Materials (the ones from the book?).\n    3) Other importance sampling methods.\n    4) Direct light sampling + MIS.\n    5) BDPT.\n\n*/\n\n// compatibility with C++\n// #define INOUT(T) T&\n#define INOUT(T) inout T \n// #define OUT(T) T&\n#define OUT(T) out T\n// #define IN(T) const T&\n#define IN(T) T\n\n#ifndef HW_PERFORMANCE\n//uniform sampler2D iChannel1;\n#endif\n\n#define INF uintBitsToFloat(0x7F800000u)\n#define PI 3.141592653589793\n#define EPS 0.0001\n#define RENDER_MODE_COUNT 6u\n#define SCENES_COUNT 2u;\n\n#define BDELTA 5\n#define BMIN 0\n#define BMAX BMIN+BDELTA\n#define PHI_4 1.22074408460576\n// L ~ T^{BMIN}Le + ... + T^{BMAX}Le\n\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //\n//                      PSEUDORANDOM NUMBER GENERATOR                       //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n\n\n//    Wang hash, see:\n//    http://www.burtleburtle.net/bob/hash/integer.html\n//    http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\n\nuint wang_hash(uint seed)\n\n//  Used to initialize the state of the PRNG based on pixel coordinates.\n\n\n{\n    seed = (seed ^ 61u) ^ (seed >> 16u);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4u);\n    seed *= 0x27d4eb2du;\n    seed = seed ^ (seed >> 15u);\n    return 1u+seed;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n \n//  xorshift, see:\n//  https://en.wikipedia.org/wiki/Xorshift#Example_implementation \n\n\n// The state word must be initialized to non-zero\nuint xorshift32(uint state)\n\n//  Used to advanced the xorshift state.\n\n{\n\t// Algorithm \"xor\" from p. 4 of Marsaglia, \"Xorshift RNGs\"\n\tuint x = state;\n\tx ^= x << 13u;\n\tx ^= x >> 17u;\n\tx ^= x << 5u;\n\treturn x;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nfloat rand(INOUT(uint) state)\n\n//  Advances the prng state and returns the corresponding random float.\n\n{\n    uint x = xorshift32(state);\n    state = x;\n    return float(x)*uintBitsToFloat(0x2f800004u);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec2 rand2(INOUT(uint) state)\n\n//  Advances the prng state twice state and returns 2 random floats.\n\n{\n    vec2 r = vec2(rand(state), rand(state));\n    // uint x = xorshift32(state);\n    // r.x = float(x)*uintBitsToFloat(0x2f800004u);\n    // uint y = xorshift32(x);\n    // r.y = float(y)*uintBitsToFloat(0x2f800004u);\n    // state = y;\n    \n    return r;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //\n//                             BASIC STRUCTS                                //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Material\n{\n    uint type;\n    vec3 color;\n    vec3 Le;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\n#define MATERIAL_LAMBERTIAN 0u\n#define MATERIAL_MIRROR 1u\n#define MATERIAL_DIELECTRIC 2u\n\n//////////////////////////////////////////////////////////////////////////////\n\nMaterial create_Lambertian(IN(vec3) c)\n{\n    return Material(MATERIAL_LAMBERTIAN, c/PI, vec3(0.0));\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nMaterial create_mirror(IN(vec3) c)\n{\n    return Material(MATERIAL_MIRROR, c, vec3(0.0));\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Isect_data\n{\n    float t;      // ray parameter\n    vec3  n;      // normal\n    vec2  uv;     // uv coordinates\n    int   mat;    // material index\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Camera\n{\n    vec3 o;        // origin\n    vec3 e1,e2,e3; // right, up, forward\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\nCamera look_at(IN(vec3) o, IN(vec3) t, IN(vec3) u)\n{\n    Camera c;\n    c.o = o;\n    c.e3 = normalize(t-o);\n    c.e1 = normalize(cross(u,c.e3));\n    c.e2 = cross(c.e3, c.e1);\n    \n    return c;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec2 get_uv (IN(vec2) coord, IN(vec2) res)\n{\n    // remap to [0,1]^2\n    vec2 uv = coord / res.xy;\n    // remap to [-1,1]^2\n    uv = 2.0*uv - vec2(1.0);\n    // remap x to [-aspect_ratio, aspect_ratio]\n    float aspect_ratio = res.x/res.y;\n    uv.x *= aspect_ratio;\n    \n    return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nRay generate_ray (IN(Camera) cam, IN(vec2) uv)\n{\n    return Ray(cam.o, cam.e3 + uv.x*cam.e1 + uv.y*cam.e2);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Sphere\n{\n    vec3  o;  // center of the sphere\n    float r;  // radius of the sphere\n    int   mat;// material index\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Parallelogram\n{\n    vec3 v1, v2, v3;\n    int mat; // material index\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\nstruct Scene\n{\n    Material materials[11];\n    int material_count;\n\n\tSphere spheres[3];\n    int sphere_count;\n    \n\tParallelogram parallelograms[6];\n    int parallelogram_count;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n\nScene create_scene()\n{\n    Scene scene;\n    scene.sphere_count = 0;\n    scene.parallelogram_count = 0;\n    \n    return scene;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nint add(INOUT(Scene) scene, IN(Sphere) sphere)\n{\n\tscene.spheres[scene.sphere_count] = sphere;\n    ++scene.sphere_count;\n    return scene.sphere_count - 1;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nint add(INOUT(Scene) scene, IN(Parallelogram) parallelogram)\n{\n\tscene.parallelograms[scene.parallelogram_count] = parallelogram;\n    ++scene.parallelogram_count;\n    return scene.parallelogram_count - 1;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nint add(INOUT(Scene) scene, IN(Material) mat)\n{\n\tscene.materials[scene.material_count] = mat;\n    ++scene.material_count;\n    return scene.material_count-1;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //\n//                             INTERSECTION                                 //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n\nfloat intersect\n\n    (IN(Ray)          r,\n     float            tmin,\n     float            tmax,\n     OUT(Isect_data)  data,\n     IN(Sphere)       s)\n     \n{\n    //  ||r.o+t*r.d-s.o||^2 = (s.r)^2\n    //  t^2*||r.d||^2 -2*t*<r.d,s.o-r.o> + ||s.o-r.o||^2 - (s.r)^2 = 0\n    //  t^2*A - 2*t*B + C = 0\n    //  A = ||r.d||^2, B = <r.d,s.o-r.o>, C = ||s.o-r.o||^2 - (s.r)^2\n    //  D = B^2-A*C\n    //  if D<0 -> no intersection\n    //  D = sqrt(D)\n    //  t0 = (B-D)/A\n    //  t1 = (B+D)/A\n    //  \n    //  t_isect = inf{t : t in {t0,t1}, tmin<=t<=tmax}\n    //  (note: inf{} = infty <- the infinimum of an empty set is infty)\n    //  if t_isect = infty -> no intersection\n    //  otherwise t_isect is the intersection\n    \n    // compute quadratic equation coefficients\n    float A = dot(r.d,r.d);\n    vec3 roso = s.o-r.o;\n    float B = dot(r.d, roso);\n    float C = dot(roso, roso) - s.r*s.r;\n    \n    // compute discriminant\n    float D = sqrt(B*B-A*C); // if D<0 -> NaN\n    \n    // compute the roots (those are NaN if sqrt(D) was NaN)\n    float t0 = (B-D)/A;\n    float t1 = (B+D)/A;\n    \n    // check whether t0 and t1 are in [tmin,tmax]\n    t0 = ((tmin <= t0) && (t0 <=tmax)) ? t0 : INF; // D=NaN -> INF\n    t1 = ((tmin <= t1) && (t1 <=tmax)) ? t1 : INF;\n    float t = min(t0,t1);\n    \n    // fill out intersection data\n    data.t = t;\n    data.n = (r.o+t*r.d-s.o)/s.r;\n    data.uv = vec2(0);\n    data.mat = s.mat;\n\n    return t;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n\nfloat intersect\n\n    (in  Ray           r,\n     in  float         tmin,\n     in  float         tmax,\n     out Isect_data    data,\n     in  Parallelogram p)\n     \n{\n    //  e1 = p.v2-p.v1, e2 = p.v3-p.v1\n    //  p(u,v) = p.v1 + u*e1 + v*e2\n    //  r(t) = r.o + t*r.d\n    //  \n    //  1) Find plane intersection:\n    //  n = cross(e1,e2)\n    //  dot(n,r.o+t*r.d-p.v1) = 0\n    //  t' = dot(n,p.v1-r.o)/dot(n,r.d)\n    //  \n    //  2) Find uv coordinates:\n    //  q = r(t') = r.o + t'*r.d\n    //  \n    //  r(t') = p(u,v) ->\n    //  vq = q-p.v1\n    //  \n    //  vq = u*e1 + v*e2\n    //  \n    //  a) dot with e1 ->\n    //  dot(e1,vq) = u*dot(e1,e1) + v*dot(e1,e2)\n    //  \n    //  b) dot with e2 ->\n    //  dot(e2,vq) = u*dot(e1,e2) + v*dot(e2,e2)\n    //  \n    //  e1vq = dot(e1,vq)\n    //  e2vq = dot(e2,vq)\n    //  e1e1 = dot(e1,e1)\n    //  e1e2 = dot(e1,e2)\n    //  e2e2 = dot(e2,e2)\n    //  \n    //  det = e1e1*e2e2-e1e2*e1e2\n    //  u = (e1vq*e2e2 - e2vq*e1e2)/det\n    //  v = (e2vq*e1e1 - e1vq*e1e2)/det\n    //  \n    //  0<=u<=1, 0<=v<=1 -> q inside parallelogram\n    \n    // compute edges\n    vec3 e1 = p.v2-p.v1;\n    vec3 e2 = p.v3-p.v1;\n    \n    // compute normal\n    vec3 n = cross(e1,e2);\n    \n    // 1) Find plane intersection:\n    float t = dot(n,p.v1-r.o)/dot(n,r.d);\n    \n    // filter out no-intersections\n    t = (tmin<=t && t<=tmax) ? t : INF;\n    \n    // 2) Find uv coordinates:\n    \n    // intersection location\n    vec3 q = r.o + t * r.d;\n    \n    // convenience\n    vec3 vq = q-p.v1;\n    \n    // system matrix coefficients\n    float e1e1 = dot(e1,e1);\n    float e1e2 = dot(e1,e2);\n    float e2e2 = dot(e2,e2);\n    \n    // right-hand side coefficients\n    float e1vq = dot(e1,vq);\n    float e2vq = dot(e2,vq);\n    \n    // system solution\n    float det = e1e1*e2e2-e1e2*e1e2;\n    float u = (e1vq*e2e2 - e2vq*e1e2)/det;\n    float v = (e2vq*e1e1 - e1vq*e1e2)/det;\n    \n    // filter out no-intersections\n    t = (0.0<=u && u<=1.0 && 0.0<=v && v<=1.0) ? t : INF;\n    \n    // fill out intersection data\n    data.t = t;\n    data.n = normalize(n);\n    data.uv = vec2(u,v);\n    data.mat = p.mat;\n    \n    return t;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nfloat intersect\n\n    (in  Ray          r,\n     in  float        tmin,\n     in  float        tmax,\n     out Isect_data   d,\n     in  Scene        scene)\n     \n{\n    Isect_data d_tmp;\n    \n    // find the closest sphere intersection\n    Isect_data d_sph;\n    float closest_t_sph = tmax;\n    for (int i=0; i<scene.sphere_count; ++i)\n    {\n        float t = intersect(r, tmin, closest_t_sph, d_tmp, scene.spheres[i]);\n        if (t<INF)\n        {\n            closest_t_sph = t;\n            d_sph = d_tmp;\n        }\n    }\n     \n    // find the closest parallelogram intersection\n    Isect_data d_prl;\n    float closest_t_prl = tmax;\n    for (int i=0; i<scene.parallelogram_count; ++i)\n    {\n        float t = intersect(r, tmin, closest_t_prl, d_tmp, scene.parallelograms[i]);\n        if (t<INF)\n        {\n            closest_t_prl = t;\n            d_prl = d_tmp;\n        }\n    }   \n    \n    // choose between parallelogram isect and sphere isect\n    float closest_t;\n    if (closest_t_sph<closest_t_prl)\n    {\n        d = d_sph;\n        closest_t = closest_t_sph;\n    }\n    else\n    {\n        d = d_prl;\n        closest_t = closest_t_prl;\n    }\n    \n    // if there was an intersection return it, otherewise -> INF\n    if (closest_t < tmax)\n    {\n        return closest_t;\n    }\n    else\n    {\n        d.t = INF;\n        return INF;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //\n//                           SAMPLES MAPPING                                //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n/****************************************************************************/\n\nvec3 map_to_unit_sphere (IN(vec2) uv)\n\n\n//  Maps from [0,1]^2 to the unit sphere.\n\n\n{\n    float cos_theta = 2.0*uv.x-1.0;\n    float phi = 2.0*PI*uv.y;\n    float sin_theta = sqrt(1.0-cos_theta*cos_theta);\n    float sin_phi = sin(phi);\n    float cos_phi = cos(phi);\n    \n    return vec3(sin_theta*cos_phi, cos_theta, sin_theta*sin_phi);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 map_to_unit_hemisphere_cosine_weighted (IN(vec2) uv, IN(vec3) n)\n\n/*\n    Maps from [0,1]^2 to the unit hemisphere around n with a cosine density.\n    Expects n to be a unit vector.\n*/\n\n{\n    vec3 p = map_to_unit_sphere (uv);\n    return n+p;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //\n//                              ESTIMATORS                                  //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 estimator_binary (IN(Ray) r, IN(Scene) s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    bool isect = bool(t<INF); // is there an intersection?\n    \n    return vec3(isect); // return white upon intersection\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 estimator_color (IN(Ray) r, IN(Scene) s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    bool isect = bool(t<INF); // is there an intersection?\n    \n    // return the color*PI if there's an intersection\n    return PI*s.materials[data.mat].color*float(isect);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 estimator_depth (IN(Ray) r, IN(Scene) s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    // intersection distance from the origin of the ray\n    float dist = t/length(r.d);\n    \n    // map from [0,inf] to [1, 0]\n    float inv_dist = 1.0/(1.0+dist);\n    \n    return vec3(inv_dist);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 estimator_normals (IN(Ray) r, IN(Scene) s)\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, s);\n    \n    // return black if no intersection\n    if(!(t<INF)) return vec3(0);\n    \n    \n    // ---- return the normal if there is an intersection ----\n    \n    // correct normal is in the oppoiste hemisphere of the incident ray\n    vec3 n = -data.n * sign(dot(data.n, r.d));\n\n    // map from S^2 to [0,1]^3\n    return 0.5*n+vec3(0.5);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 estimator_ambient_occlusion (IN(Ray) r, IN(Scene) scene, INOUT(uint) state, IN(vec3) Le)\n\n//  Models the sphere at infinity as the only emitter. Computes \n//  only direct illumination.\n\n{\n    Isect_data data;\n    float t = intersect(r, 0.0, INF, data, scene);\n    \n    // infinite light source\n    //vec3 Le = vec3(1.0);\n    \n    bool isect = bool(t<INF);\n    \n    // if no intersection -> hit infinite light source\n    if (!isect) return Le;\n    \n    \n    // ---- intersection -> compute direction illumination ----\n    \n    // correct normal is in the oppoiste hemisphere of the incident ray\n    vec3 n = -data.n * sign(dot(data.n, r.d));\n    \n    // pick a random point in [0,1]^2\n    vec2 r2 = rand2(state);\n    \n    // map from [0,1]^2 to the upper hemisphere with cos density\n    vec3 dir = map_to_unit_hemisphere_cosine_weighted (r2, n);\n\n    // intersection location of the primary ray with the scene\n    vec3 p = r.o + r.d*t;\n\n    // scattered ray\n    Ray ao_ray = Ray(p+EPS*n, dir);\n\n    // check for intersection with any object (scene points do not emit)\n    Isect_data data_tmp;\n    float t_ao = intersect(ao_ray, 0.0, INF, data_tmp, scene);\n\n    // check whether the infinite light source is hit\n    bool visibility = !bool(t_ao<INF);\n\n    // direct illumination + 1 bounce direct illumination\n    vec3 col = scene.materials[data.mat].Le \n             + Le*PI*scene.materials[data.mat].color*float(visibility);\n\n    return col;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nvec3 estimator_path_tracing_Lambertian (IN(Ray) r_in, IN(Scene) scene, INOUT(uint) state, int bounces, in vec3 Le, IN(samplerCube) tex)\n{\n    // intersection data\n    Isect_data data;\n    \n    // the first ray is the primary ray\n    Ray r = r_in;\n    \n    // accumulated color\n    vec3 col = vec3(0.0);\n    \n    // We = 1.0\n    vec3 throughput = vec3(1.0);\n    \n    // light source\n    //vec3 Le = vec3(1.0);\n    \n    // bounce around the scene\n    for (int b=0; b<bounces; ++b)\n    {\n        // find intersection\n        float t = intersect(r, 0.0, INF, data, scene);\n        \n        bool isect = bool(t<INF);\n        \n        // assume lights sources at infinity\n        if (!isect) \n        {\n            // add direct light contribution\n            if (BMIN<=b && b<=BMAX)\n                col += throughput * Le * texture(tex, r.d).xyz;\n            break; \n        }\n\n        // add direct light contribution\n        if (BMIN<=b && b<=BMAX)\n            col += throughput * scene.materials[data.mat].Le;\n        \n        // construct estimator for higher dimensional integral\n        throughput *= PI * scene.materials[data.mat].color;\n        \n        // correct facing normal\n        vec3 n = -data.n * sign(dot(data.n, r.d));\n        \n        // pick a random point in [0,1]^2\n        vec2 r2 = rand2(state);\n    \n        // map from [0,1]^2 to the upper hemisphere with cos density\n        vec3 dir = map_to_unit_hemisphere_cosine_weighted (r2, n);\n        \n        // intersection of the primary ray with the scene\n        vec3 p = r.o + r.d*t;\n        \n        // scattered ray\n        r = Ray(p+EPS*n,dir);\n    }\n    \n    // return the accumulated intensity\n    return col;\n}\n\n//////////////////////////////////////////////////////////////////////////////", "buffer_a_code": "/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                           IO and RENDER STATE                            */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nfloat keyClick(int ascii) {\n\treturn float(texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\n/****************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    /* ---- initialize/retrieve state ---- */\n    \n    vec3 translation;  /* camera translation */\n    vec2 rot;          /* camera rotation angles */\n    uint frame_count;  /* frame count */\n    vec2 old_mouse_pos;/* the position of the mouse in the previous frame */\n    bool old_mouse_down;/* whether the mouse was down the previous frame */\n    bool old_key_R_down;/* true if R was down in the previous frame */\n    uint scene_idx;     /* scene index */\n    bool old_key_space_down;\n    uint render_mode;  /* render mode index */\n\n    \n    vec4 buffA_00 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 buffA_10 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 buffA_01 = texelFetch(iChannel0, ivec2(0,1), 0);\n    vec4 buffA_11 = texelFetch(iChannel0, ivec2(1,1), 0);\n    \n    if (iFrame==0)\n    {\n        /* intialize the data in the first frame */\n        translation = vec3(0,0,-5.0);\n        rot = vec2(0.0);\n        \n        frame_count = 0u;\n        \n        old_key_R_down = false;\n        scene_idx = 0u;\n        \n        old_key_space_down = false;\n        render_mode = RENDER_MODE_COUNT-1u;\n        \n        old_mouse_pos = iMouse.xy;\n        old_mouse_down = false;\n\n    }\n    else\n    {\n        /* retrieve data from last frame */\n        translation = buffA_00.xyz;\n        rot = buffA_10.xy;\n         \n        frame_count = floatBitsToUint(buffA_00.w);\n        \n        old_key_R_down = bool(buffA_01.x>0.0);\n        scene_idx = floatBitsToUint(buffA_01.y);\n        \n        old_key_space_down = bool(buffA_01.z>0.0);\n        render_mode = floatBitsToUint(buffA_01.w);\n        \n        old_mouse_pos = buffA_11.xy;\n        old_mouse_down = bool(buffA_11.z>0.0);\n    }\n\n\n\n\n    /* ---- handle movement and rotation ---- */\n    \n    /* aspect ratio */\n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    /* camera translation: WASDQE */\n    const int key_A = 65; /* right */\n    const int key_D = 68; /* left */\n    const int key_Q = 69; /* down */\n    const int key_E = 81; /* up */\n    const int key_W = 83; /* forward */\n    const int key_S = 87; /* down */\n    vec3 diff = vec3(keyClick(key_D) - keyClick(key_A), keyClick(key_E) - keyClick(key_Q), keyClick(key_S) - keyClick(key_W));\n    vec3 translation_speed = vec3(10.0)*iTimeDelta;\n    translation += translation_speed * diff;\n    bool key_down = any(greaterThan(abs(diff),vec3(0.5)));\n    \n    /* rotation for this frame: LMB drag */\n    bool mouse_down = bool(iMouse.z>0.0);\n    vec2 rot_speed = vec2(0.2) * iTimeDelta * vec2(1.0, 1.0/aspectRatio);\n    if (!old_mouse_down) old_mouse_pos = iMouse.xy;\n    rot = rot\n        + ((mouse_down) ? rot_speed*(iMouse.xy-old_mouse_pos) : vec2(0.0));\n        \n    /* change rendering mode: space */\n    const int key_space = 32;\n    bool key_space_down = bool(keyClick(key_space)>0.0);\n    bool key_space_released = (!key_space_down && old_key_space_down);\n    if (key_space_released)\n       render_mode = (render_mode + 1u) % RENDER_MODE_COUNT;\n    \n    /* change scene: R */\n    const int key_R = 82;\n    bool key_R_down = bool(keyClick(key_R)>0.0);\n    bool key_R_released = (!key_R_down && old_key_R_down);\n    if (key_R_released)\n       scene_idx = (scene_idx + 1u) % SCENES_COUNT;\n    \n    /* needs update */\n    bool frame_counter_needs_reset = mouse_down || key_down || key_space_released || key_R_released;\n    \n    /* reset frame counter if camera location changed */\n    if (frame_counter_needs_reset)\n    {\n        frame_count = 0u;\n    }\n\n    /* count frame */\n    frame_count = frame_count + 1u;\n\n\n\n    \n    /* ---- store state ---- */\n    \n    if (all(equal(ivec2(fragCoord), ivec2(0)))) /* pixel (0,0) */\n    {\n        /* store translation and frame count */\n        fragColor = vec4(translation,uintBitsToFloat(frame_count));\n    }\n    else if (all(equal(ivec2(fragCoord), ivec2(1,0)))) /* pixel (1,0) */\n    {\n        /* mouse-drag rotation state */\n        fragColor = vec4(rot, 0.0, 0.0);\n    }\n    else if (all(equal(ivec2(fragCoord), ivec2(0,1)))) /* pixel (0,1) */\n    {\n        /* R & scene_idx, space & render_mode */\n        fragColor = vec4(float(key_R_down), uintBitsToFloat(scene_idx), \n                         float(key_space_down), uintBitsToFloat(render_mode));\n    }\n    else if (all(equal(ivec2(fragCoord), ivec2(1,1)))) /* pixel (1,1) */\n    {\n        /* mouse state */\n        fragColor = vec4(iMouse.xy, float(mouse_down), 0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                          SCENE CONSTRUCTION                              */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nvoid construct_scene(inout Scene scene, inout vec3 Le, uint scene_idx)\n{\n    if (scene_idx==0u) /* First scene: Some spheres */\n    {\n        Le = vec3(1.0);\n        \n        int mat_idx;\n        mat_idx = add(scene, create_Lambertian(vec3(1.0, 0.3, 0.1)));\n        add(scene, \n            Sphere(vec3(0,0,0), 1.0, mat_idx)\n        );\n        \n        mat_idx = add(scene, create_Lambertian(vec3(0.8)));\n        add(scene, \n            Sphere(vec3(0,-101, 0), 100.0, mat_idx)\n        );\n\n        mat_idx = add(scene, create_Lambertian(vec3(0.3, 1.0, 0.0)));\n        add(scene, \n            Sphere(vec3(1,3,-1), 1.7, mat_idx)\n        );\n    }\n    else /* Second scene: Cornell Box */\n    {\n        Le = vec3(0.05);\n        int mat_idx;\n        /* Cornell box */\n        float scale = 8.0;\n        vec3 cb_offset = vec3(0);\n        vec3 dim = scale*vec3(1.3, 1.7, 1.0);\n        vec3 v1,e1,e2;\n        vec3 col;\n\n        /* back wall */\n        v1 = 0.5*vec3(-dim.x, -dim.y, dim.z);\n        e1 = vec3(dim.x, 0, 0);\n        e2 = vec3(0, dim.y, 0);\n        col = vec3(0.5, 0.5, 0.2);\n\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* left wall */\n        v1 = -0.5*dim;\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(0,dim.y,0);\n        col = vec3(1.0, 0.0, 0.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* right wall */\n        v1 = 0.5*vec3(dim.x, -dim.y, -dim.z);\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(0,dim.y,0);\n        col = vec3(0.1, 0.1, 1.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* top wall */\n        v1 = 0.5*vec3(-dim.x, dim.y, -dim.z);\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(dim.x,0,0);\n        col = vec3(0.0, 1.0, 0.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        //float flicker_speed = 0.0;\n        //scene.materials[mat_idx].Le = vec3((1.0+sin(flicker_speed*iTime))*vec2(1.0),0.0);\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n\n        /* bottom wall */\n        v1 = -0.5*dim;\n        e1 = vec3(0,0,dim.z);\n        e2 = vec3(dim.x,0,0);\n        col = vec3(1.0, 1.0, 1.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n        \n        /* lamp */\n        float lamp_scale = 0.5;\n        v1 = 0.5*vec3(-lamp_scale*dim.x, dim.y*0.98, -lamp_scale*dim.z);\n        e1 = lamp_scale*vec3(0,0,dim.z);\n        e2 = lamp_scale*vec3(dim.x,0,0);\n        col = vec3(0.0, 0.0, 0.0);\n        mat_idx = add(scene, create_Lambertian(col));\n        scene.materials[mat_idx].Le = vec3(5.0);\n        /*add(scene, \n            Sphere(\n                vec3(0), 3.0, \n                mat_idx\n            )\n        );*/\n        add(scene, \n            Parallelogram(\n                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, \n                mat_idx\n            )\n        );\n        \n    }\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                          PRNG STATE RETRIEVAL                            */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nuint retrieve_state(vec2 fragCoord)\n{\n    /* \n        If it's the first frame we use wang_hash on the screen \n        coordinates to get some random uints to initialize xorshift \n        with. At the end of each frame we store the state of the prng.\n        If it's not the first frame, we load the state stored in the \n        previous frame.\n    */\n\n    uint state;\n    if (iFrame==0)\n    {\n        uvec2 ucoord = uvec2(fragCoord);\n        uint pixel_index = ucoord.x + ucoord.y * uint(iResolution.x);\n        uint seed = wang_hash(pixel_index);\n        state = seed;\n    }\n    else\n    {\n        vec4 buffA = texelFetch(iChannel2, ivec2(fragCoord), 0);\n        state = floatBitsToUint(buffA.w);     \n    }\n    return state;\n}\n\n/****************************************************************************/\n\n/****************************************************************************/\n/*                                                                          */\n/*                                                                          */\n/*                          IMAGE GENERATION                                */\n/*                                                                          */\n/*                                                                          */\n/****************************************************************************/\n\n/****************************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    /* ---- Retrieve state from previous frames and other buffers ---- */\n    \n    uint state = retrieve_state(fragCoord);\n\n    vec4 buffA_01 = texelFetch(iChannel0, ivec2(0,1), 0);\n    /* extract scene index from bufferA */\n    uint scene_idx = floatBitsToUint(buffA_01.y);\n    /* extract render_mode from bufferA */\n    uint render_mode = floatBitsToUint(buffA_01.w);   \n    \n    /* extract translation from bufferA */\n    vec4 buffA_00 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec3 translation = buffA_00.xyz;\n    uint frame_count = floatBitsToUint(buffA_00.w);\n    \n    /* extract rotation from bufferA */\n    vec4 buffA_10 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec2 rot = buffA_10.xy;\n    \n    \n    \n    /* ---- Construct Scene ---- */\n    \n    Scene scene = create_scene();\n    vec3 Le;\n    construct_scene (scene, Le, scene_idx);\n\n\n\n    /* ---- Construct Camera ---- */\n    \n    /* compute aspect ratio  */\n    float aspect_ratio = iResolution.x/iResolution.y;    \n    /* camera position from spherical coordinates */\n    float cosTheta = cos(rot.y);\n    vec3 cpos = translation.z*vec3(cosTheta*sin(rot.x),\n                          sin(rot.y),\n                        cosTheta*cos(rot.x));\n                        \n    Camera cam = look_at(cpos, vec3(0,1.0,0), vec3(0,1,0));\n    cam.o += cam.e1*translation.x + cam.e2*translation.y;\n\n\n\n    /* ---- Render ---- */\n    \n    /* samples per pixel */\n    const int spp = 1;\n    \n    /* accumulate measured irradiance per pixel over spp samples */\n    vec3 col = vec3(0.0);\n    for (int s=0; s<spp; ++s)\n    {\n        /* randomly offset primary rays for anti-aliasing */\n        vec2 aa_offset = rand2(state);\n        vec2 uv = get_uv(fragCoord+aa_offset, iResolution.xy);\n        Ray ray = generate_ray (cam, uv);\n    \n        #define RENDER_MODE 5u\n        /* accumulate radiance */\n        switch (render_mode)\n        {\n        case 0u:\n            col += estimator_binary(ray, scene);\n            break;\n        case 1u:\n            col += estimator_color(ray, scene);\n            break;\n        case 2u:\n            col += estimator_depth(ray, scene);\n            break;\n        case 3u:\n            col += estimator_normals(ray, scene);\n            break;\n        case 4u:\n            col += estimator_ambient_occlusion(ray, scene, state, vec3(1.0));\n            break;\n        default:\n            col += estimator_path_tracing_Lambertian(ray, scene, state, 5, Le, iChannel3);\n            break;\n        }\n    }\n    \n    /* box reconstruction filter */\n    col /= float(spp);\n    \n    /* store color and prng state */\n    fragColor = vec4(col, uintBitsToFloat(state));\n}", "buffer_c_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /* fetch the render from the current frame */\n    vec3 render = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n    vec4 buffD = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    /* fetch the accumulated render from previous frames */\n    vec3 acc_frame_col = buffD.xyz;\n    \n    /* fetch the frame count since the last reset */\n    vec4 buffA_00 = texelFetch(iChannel0, ivec2(0,0), 0);\n    uint frame_count = floatBitsToUint(buffA_00.w);\n    \n    /* progressive rendering / weighted average */\n    vec3 col = float(frame_count-1u)/float(frame_count) * acc_frame_col \n             + 1.0/float(frame_count) * render;\n\n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 161, 221, 378]], "test": "untested"}
{"id": "tlycW1", "name": "Minecraft style fire.", "author": "Skippy69z", "description": "pixelated fire", "tags": ["pixefire", "pixelatedfire"], "likes": 4, "viewed": 332, "published": 3, "date": "1610915972", "time_retrieved": "2024-07-30T19:44:31.547908", "image_code": "float rand(vec2 coord){\n\treturn fract(sin(dot(coord, vec2(12.9898, 78.233)))* 43758.5453123);\n}\n\nfloat noise(vec2 coord){\n\tvec2 i = floor(coord);\n\tvec2 f = fract(coord);\n\n\t// 4 corners of a rectangle surrounding our point\n\tfloat a = rand(i);\n\tfloat b = rand(i + vec2(1.0, 0.0));\n\tfloat c = rand(i + vec2(0.0, 1.0));\n\tfloat d = rand(i + vec2(1.0, 1.0));\n\n\tvec2 cubic = f * f * (3.0 - 2.0 * f);\n\n\treturn mix(a, b, cubic.x) + (c - a) * cubic.y * (1.0 - cubic.x) + (d - b) * cubic.x * cubic.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 texture_coords = fragCoord/iResolution.xy;\n\n\tfloat f = 2.0;\n\tfloat cellSize = 50.0;\n\n\tvec2 pos = texture_coords;\n\n\tpos.x -= mod(pos.x, 1.0 / cellSize); // pixelation\n\tpos.y -= mod(pos.y, 1.0 / cellSize);\n\n\tpos *= 5.0;\n\tfloat threshold = pos.y;\n\tpos.y -= iTime*2.0;\n\n\tfloat result = 1.0 - abs(noise( vec2((pos.x*f), (pos.y*f)) ) *2.0-1.0) + noise( vec2((pos.x*f), (pos.y*f)) * 2.5 ) * 0.8;\n\tif(result < threshold){result = 0.0;}\n\n    fragColor = vec4(result, result - 0.5, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlycW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 95], [97, 97, 121, 121, 491], [493, 493, 549, 599, 1093]], "test": "untested"}
{"id": "wtGcW1", "name": "JAN.15 Let someone else decide", "author": "illus0r", "description": "Polygons that turn reacting to sound\nhttps://twitter.com/i_dianov/status/1350081247708651520", "tags": ["genuary"], "likes": 5, "viewed": 264, "published": 3, "date": "1610914903", "time_retrieved": "2024-07-30T19:44:32.369711", "image_code": "#define T smoothstep(0.,1.,fract(iTime*.5))\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n\nfloat sdPlane(vec3 p) {\n   float plane = abs(p.z)-.001;\n   plane = max(plane, p.x);\n   plane = max(plane, p.y);\n   plane = max(plane, -p.x-p.y-1.);\n   return plane;\n}\n\nfloat dist(vec3 p){\n   p.z -= 2.;\n   //p=abs(p);\n   //p=mod(p,2.);\n   p.xy -= .3+texture(iChannel0,vec2(.9,.25)).r*.6-.1;\n   float p0, p1,p2;\n   \n   p.xy+=(.5*T);\n   p.xy*=rot(3.1415*5./4.*T);\n   p.xy*=mix(1.,sqrt(2.),T);\n\n   p1 = sdPlane(p);\n   p.xz*=rot(-3.1415*T);\n   p2 = sdPlane(p);\n   return min(p1,p2)/2.*.2;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(.01,0.);\n\treturn normalize(vec3(\n    \tdist(p+e.xyy)-dist(p-e.xyy),\n    \tdist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    float d=0., e, i;\n    vec2 uv = (FC*2.-iResolution.xy)/iResolution.y;\n    vec3 p,rd=normalize(vec3(uv,2.));\n    for(i=0.;i++<99.;){\n        p = d*rd;\n        //p.xz*=rot(iTime);\n        d+=e=dist(p);\n        if(e<.001)break;\n    }\n    if(d>1000.)return;\n    //fragColor = vec4(vec3(dot(norm(p),vec3(-1.))*.5+.5),1.);\n    fragColor = vec4(vec3(norm(p).zyx*.3+.7),1.);\n}", "image_inputs": [{"id": 25224, "src": "https://soundcloud.com/dikielynx/pskovskoeporno", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 63, 63, 110], [112, 112, 135, 135, 278], [280, 280, 299, 299, 597], [599, 599, 617, 617, 782], [784, 784, 834, 834, 1207]], "test": "untested"}
{"id": "wlyyW1", "name": "cel shading filter", "author": "Ric3cir121", "description": "Simple working cel shader filter", "tags": ["3d", "raymarching", "celshading", "shader"], "likes": 5, "viewed": 1167, "published": 3, "date": "1610914481", "time_retrieved": "2024-07-30T19:44:33.153615", "image_code": "#define T(u) texelFetch(iChannel0,clamp(ivec2(u),ivec2(0),ivec2(iResolution.xy)-1),0)\n\nvoid mainImage(out vec4 o,vec2 u){\n    \n    float max = 1000.,\n          bokeh = .005,\n          focus_dist = 5.,\n\n    d = bokeh * (clamp(T(u).w,.0,max)-focus_dist) * iResolution.y;\n    o = vec4(0);\n    float s = 10.,a,n = 0.;\n    for(float r = 0.; r < 1.; r+=1./s){\n        for(float i = 0.; i < 1.; i+=1./(s*r),n++){\n            a = i*radians(360.);\n            vec2 s = vec2(cos(a),sin(a))*r;\n            o += clamp(T(u+s*d),0.,1.);\n        }\n    }\n    o /= n;\n    o = pow(o,vec4(1./2.2));\n    \n    ivec2 me = ivec2(u);\n    vec4 p = texelFetch(iChannel0,me,0);\n    float c = dot(abs(texelFetch(iChannel0,me+ivec2(0,1),0)-p)+\n                  abs(texelFetch(iChannel0,me+ivec2(1,0),0)-p),vec4(1))/4./2.;\n    if(u.x*2.>iResolution.x){o = p;o = o+.1-clamp((c)*1.,0.,1.);}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct obj{\n    float d;\n    vec3 col;\n    int ref;\n};\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n#define hash13(a) fract(sin(a*vec3(1.239,5.283,2.294))*1000000.)\n#define mn(a,b) obj((a.d>b.d?b.d:a.d),(a.d>b.d?b.col:a.col),(a.d>b.d?b.ref:a.ref))\n#define mx(a,b) obj((a.d<-b.d?-b.d:a.d),(a.col),(a.ref))\n#define sphere(a,b,c,d,e) obj(length(a-b)-c/2.,d,e)\n#define cube(a,b,c,d,e,f) obj(length(clamp(a,b-(c-d)/2.,b+(c-d)/2.)-a)-d/2.,e,f)\n#define plane(a,b,c,d) obj(a.y-b.y,c,d)\nobj de(vec3 pos){\n    obj res = obj(10000.,vec3(0),0);\n    res = mn(res,sphere(pos,vec3(0 , -1,-.5),1.    ,vec3(.9,.5,.5),1));\n    res = mn(res,  cube(pos,vec3(-1,-.5,-1 ),1. ,.3,vec3(.9,.5,.9),0));\n    res = mx(res, plane(pos,vec3(0 ,-.99,0 )       ,vec3(.9,.9,.9),2));\n    res = mn(res, plane(pos,vec3(0 , -1, 0 )       ,vec3(.9,.9,.9),2));\n    res = mx(res,  cube(pos,vec3(0 ,-1. ,.5),2. ,1.,vec3(.9,.5,.9),1));\n    res = mn(res,sphere(pos,vec3(.3,  0, 1 ),1.    ,vec3(.5,.5,.9),2));\n    return res;\n}\nvec3 getmarch(vec3 pos,vec3 cam,bool rev){\n    float r = rev?-1.:1.;\n    float d = 9.;\n    vec3 mov = vec3(0);\n    for(int i = 0;i < 1000;i++){\n        d = de(mov+pos).d*r;\n        mov += d*cam;\n        if(length(mov)>100.||d<0.0001)break;\n    }\n    return mov+pos;\n}\nvec3 getcolor(vec3 pos){return de(pos).d>0.01?vec3(1):de(pos).col;}\nvec3 getnormal(vec3 pos){\n    vec2 e = vec2(1,-1)*0.0001;\n    return normalize(e.xyy*de(pos+e.xyy).d+e.yyx*de(pos+e.yyx).d+e.yxy*de(pos+e.yxy).d+e.xxx*de(pos+e.xxx).d);\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = (u+hash13(iTime).xy-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(3,3,-3);\n    vec2 look = vec2(-.7,.7);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    vec3 norm, col = vec3(1),oldmarch;\n    bool rev = false;\n    vec3 march = getmarch(pos,cam,false);\n    float blur = length(march-pos);\n        col *= getcolor(march);\n    march = getmarch(march+normalize(vec3(.6))*0.01,normalize(vec3(.6)),false);\n    \n    if(length(march)<10.)col*=.8;\n\n\n    o = vec4(col,blur);\n    if(u.x<iResolution.x/2.)o = mix(o,texelFetch(iChannel0,ivec2(u),0),1.-1./(texelFetch(iChannel1,ivec2(0),0).x+1.));\n    else o = mix(o,texelFetch(iChannel0,ivec2(u),0),1.-1./(texelFetch(iChannel1,ivec2(1,0),0).x+1.));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 o,vec2 u){\n    if(floor(u)==vec2(0,0)){\n        o = texelFetch(iChannel0,ivec2(0),0)+1.;\n        if(iMouse.z>0.)o = vec4(1);\n    }\n    if(floor(u)==vec2(1,0)){\n        o = texelFetch(iChannel0,ivec2(1,0),0)+1.;\n        if(iMouse.z>0.)o = vec4(1);\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 121, 121, 861]], "test": "untested"}
{"id": "wtycDh", "name": "dissolving cubes", "author": "YitingLiu", "description": "playing around with the numbers and time with matrices. ", "tags": ["time", "cube", "zoom", "sin", "color", "rotate", "cos", "square", "smoothstep", "matrix", "fract", "dot", "abs"], "likes": 0, "viewed": 284, "published": 3, "date": "1610910299", "time_retrieved": "2024-07-30T19:44:33.921561", "image_code": "\n\n#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float i, float _smoothEdges){\n    _size = vec2(i)-_size*i;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.913);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(abs(cos(iTime)),sin(iTime),abs(sin(iTime)));\n\n    // Divide the space in 4\n    st = tile(st,4.);\n\n    // Use a matrix to rotate the space 45 degrees\n    st = rotate2D(st,PI*fract(iTime));\n\n    // Draw a square\n    color += vec3(box(st,vec2(0.8),sin(iTime),1.0-abs(cos(iTime))));\n    color *= vec3(st,abs(cos(iTime)));\n    color /= vec3(st,abs(sin(iTime)));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtycDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 75, 75, 215], [217, 217, 250, 250, 293], [295, 295, 356, 356, 545], [547, 547, 571, 571, 674], [676, 676, 733, 733, 1190]], "test": "untested"}
{"id": "ttycDh", "name": "Trying Out Cubemaps", "author": "oneshade", "description": "Trying out cubemaps.", "tags": ["raymarching", "test", "cubemap", "hacky"], "likes": 2, "viewed": 131, "published": 3, "date": "1610909635", "time_retrieved": "2024-07-30T19:44:34.688511", "image_code": "#define AIR_TO_GLASS_RATIO 1.0003 / 1.5\n\nvec3 IntersectSphere(in vec3 ro, in vec3 rd, in float r) {\n    float a = dot(rd, rd);\n    float b = dot(2.0 * ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    vec3 intersect = vec3(0.0);\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float root = sqrt(discr);\n        float denom = 2.0 * a;\n        float t1 =  (root - b) / denom;\n        float t2 = -(root + b) / denom;\n        intersect = vec3(t1, t2, 1.0);\n    }\n\n    return intersect;\n}\n\nvec3 SphereNormal(in vec3 p, in float r) {\n    return p / r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 6.28;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n\n    // Mouse control\n    float cx = cos(mouse.y), sx = sin(mouse.y);\n    ro.yz *= mat2(cx, sx, -sx, cx);\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    ro.xz *= mat2(cy, sy, -sy, cy);\n\n    vec3 f = -normalize(ro);                  // Camera forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Camera right\n    vec3 u = cross(r, f);                     // Camera up\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n\n    vec3 intersect = IntersectSphere(ro, rd, 1.5);\n    if (intersect.z > 0.5) {\n        vec3 hitPos = ro + rd * min(intersect.x, intersect.y);\n        vec3 n = SphereNormal(hitPos, 1.5);\n        vec3 refr = refract(rd, n, AIR_TO_GLASS_RATIO);\n\n        intersect = IntersectSphere(hitPos, refr, 1.5);\n        hitPos += refr * min(intersect.x, intersect.y);\n        n = SphereNormal(hitPos, 1.5);\n        refr = refract(refr, n, AIR_TO_GLASS_RATIO);\n        vec3 refl = reflect(l, n);\n\n        fragColor += texture(iChannel0, refr);\n        if (dot(n, l) > 0.0) {\n            fragColor += pow(max(0.0, dot(refl, refr)), 16.0);\n        }\n    }\n\n    else {\n        fragColor += texture(iChannel0, rd);\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttycDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 99, 99, 504], [506, 506, 548, 548, 568], [570, 570, 625, 625, 2026]], "test": "untested"}
{"id": "tlGcDh", "name": "circle circulation", "author": "YitingLiu", "description": "Creating the movements of circles using matrices. ", "tags": ["circle", "fract", "cirulation"], "likes": 0, "viewed": 220, "published": 3, "date": "1610909244", "time_retrieved": "2024-07-30T19:44:35.478399", "image_code": "// Author @patriciogv - 2015\n\n\nfloat circle(in vec2 _st, in float _radius){\n    // vec2 l = _st-vec2(0.5);\n    vec2 l = _st-vec2(1.0*abs(sin(iTime)));\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l/2.,l)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.726,0.855,0.013);\n    float rep = 10.;\n    \n    // why the if statement does not work\n    // how to create increments \n    if(rep<= 3.){\n        rep = 3.;       \n        rep++;\n\n    }\n    if (rep >= 10.){\n        rep = 10.; \n        rep--;\n    }\n    \n    st*=rep;\n\n    // Scale up the space by 3\n    st = fract(st); // Wrap around 1.0\n\n    // Now we have 9 spaces that go from 0-1\n\n    color += vec3(st,st.x);\n    color /= vec3(circle(st,0.5));\n    color += vec3(circle(st/0.5,0.5));\n    color -= vec3(circle(st/2.5,0.252));\n    color += vec3(circle(st/0.080,0.524));\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlGcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 75, 106, 293], [295, 295, 351, 351, 1016]], "test": "untested"}
{"id": "WtyyD1", "name": "phase function through shape 2", "author": "FabriceNeyret2", "description": "ray buffer optim.\nPhase function of various shapes. Fix (mouse.x = angle) or random angle. Params in Common (IOR, #bounce)\nSpace: shape = sphere-cyl  / triangle-prism / hexa-prism\n- R: reflection on shape\n- B: refraction inside\n- G: + internal reflections", "tags": ["refraction", "phenomena", "caustics", "rainbow", "pathtracing", "ice", "fresnel", "arcs", "pillars", "glory", "sundogs", "parhelia", "halo120", "halo22"], "likes": 8, "viewed": 464, "published": 3, "date": "1610906449", "time_retrieved": "2024-07-30T19:44:36.389962", "image_code": "// refactoring https://www.shadertoy.com/view/WtGyW1 by storing rays\n// + new features ( triangle-prism )\n\nvoid mainImage(out vec4 O, vec2 U) {   \n    O = .5 * T(U) / T(0).a;\n    O = pow( O, vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === compute rays propagation.  U.y = ray id, U.x = ray steps. out = ( coord.xy, I, 0 ) \n\n#define PI              3.1415927\n#define SQR(x)         (x)*(x)\n#define Fresnel(D,N,e)( e<1. ? fresnel(D,N,e) : fresnel(refract(D,N,e),N,e) )\n#define fresnel(D,N,e)  mix( pow( max(0.,1.-abs(dot(-D,N))), 5.), 1. , SQR((1.-e)/(1.+e)) )  // Schlick's approximation https://en.wikipedia.org/wiki/Schlick%27s_approximation\n\n#if 0\n\n    #define hash(p)         fract(sin(dot(p,vec2(127.1,311.7))) *43758.5453123)   // https://www.shadertoy.com/view/llySRh\n\n#else                                                                  // higher precision random\n\nvec3 ihash3( vec3 v ) {                                                // integer hash from https://www.shadertoy.com/view/XlXcW4\n    uvec3 x = uvec3(v * float(0xffffffffU) );\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;   \n    return vec3(x)/float(0xffffffffU);\n}\n    #define hash(p) ihash3(vec3(fract((p)/100.),.5)).x\n\n#endif\n\n\nvoid mainImage(out vec4 O, vec2 U) {   \n    O-=O;\n    int CASE = int(T(0).x);                                            // 0: sphere/cylinder 1,2: triangle-prism 3,4: hexa-prism\n    \n    vec2 D = vec2(1,0), _P,P,N, r,t,                                   // ray direction\n         M = iMouse.xy / R;\n    U -= .5;\n    if ( U.x > 4.+2.*BOUNCE || U.y >= RAYS ) return;                   // just \n    float i = U.y;                                                     // samples per frame, then cumulates\n    vec2 d =  vec2( 2.*hash(vec2(i,iTime))-1.), n;                     // random sample on disk\n    float l, s = 1.*(i-1.11*iTime)/RAYS, _s,                           // for polygonal prism: current side\n          f, I = 4.;                                                   // I: energy\n    if ( CASE==1 || CASE==3 ) s = M.x;                                 // manual tuning of hexa rotation\n              \n#define intersect(P,r) /* out: new P,N                                    internal intersection in shape */ \\\n    switch(CASE) {                                                                                          \\\n      case 0:                                                          /* sphere / cylinder              */ \\\n          N = P -= 2.*dot(P,r) * r; break;              /*  |P + kr| = 1  k +2k(P.r) = 0  k = -2(P.r) */ \\\n      case 1:                                                                                               \\\n      case 2: intersectPol(P,r,3.); break;                             /* triangle-prism                 */ \\\n      case 3:                                                                                               \\\n      case 4: intersectPol(P,r,6.); break;                             /* hexa-prism                     */ \\\n     }\n     \n#define intersectPol(P,r,p)                                         /* intersection with p-sides polygon */ \\\n        l=99.;                                                                                              \\\n        for(float t,k=0.; k<p; k++) {                                  /* case 0 for outside intersect   */ \\\n            n = cos( (s+k)*2.*PI/p + vec2(0,PI/2.) );                                                       \\\n            t = ( cos(PI/p) - dot(P,n) ) / dot(r,n);                   /* solve (OP+kr).n = cos(pi/p)    */ \\\n            if (t>0. && t<l  ) l=t, N = n;                             /* closest intersection > 0       */ \\\n          }                                       /* start in convex hull so good even for 1st intersect */ \\\n        P += l*r;                                                                                           \\\n        if (length(P) > 1.) return;\n\n#define C2S(c) sqrt(max(0., 1. - dot(c,c) ))\n\n     _P = P = vec2(-3,d.x);\n     N = P = vec2(0,d.x) - C2S(d.x)*D;                                 // 1st intersection on shape  N,P\n     if (CASE > 0 ) intersect(P,D);                                    // bounding circle,+ precise intersection for polygons\n\n    if (U.x==0.) { O = vec4(_P,I,0); return; }                         // ray start\n    if (U.x==1.) { O = vec4( P,1,0); return; }                         // incoming ray (grey)\n    \n    _P = P;\n    t = reflect(D,N);                                                  // reflect on shape\n    f = Fresnel(D,N,1./IOR);\n    if (U.x==2.) { O = vec4(_P+10.*t, I*f, 0); return; }               // reflected ray (red)\n    I *= 1.-f;\n    r = refract(D,N,1./IOR);                                           // refraction in shape\n    intersect(P,r);                                                    // next intersection\n    if (U.x==3.) { O = vec4(P,I,0); return; }                          // 1st internal ray (blue)\n    _P = P;  \n    t = refract(r,-N,IOR);                                             // refraction out of shape\n    f = Fresnel(r,-N,IOR); \n    if (U.x==4.) { if(t!=vec2(0)) O = vec4(_P+60.*t, I * (1.-f),0); return; }  // main exit \"lense ray\" (blue) ... but if total reflection\n\n    for (float j=0.; j<BOUNCE; j++) {                                  // loop on internal bounces\n      I *= f;\n      r = reflect(r,-N);                                               // internal reflection\n      intersect(P,r);                                                  // next intersection\n      if (U.x==5.+2.*j) { O = vec4(P,I,0); return; }                   // internal reflected ray (white)\n      _P = P;   \n      t = refract(r,-N,IOR);                                           // refraction out of sphere\n      f = Fresnel(r,-N,IOR); \n      if (U.x==6.+2.*j) { if(t!=vec2(0)) O = vec4(_P+60.*t,  I * (1.-f),0); return; }  // (green) ... but if total reflection\n    }    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define IOR     1.3         // ice: 1.31   water: 1.33   glass: 1.5   diamond: 2.42\n#define zoom    3.\n#define RAYS  100.          // number of additionnal rays per frame\n#define BOUNCE  2.          // number of extra internal bounces\n\n#define R     iResolution.xy\n#define T(U)  texelFetch( iChannel0, ivec2(U), 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U), 0 )", "buffer_b_code": "#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);      // proj coord on line\n // return smoothstep(zoom*3./R.y,0.,length(p - b * h)); // dist to segment\n // return max(0., 1. -  length(p - b * h) / (zoom*3./R.y) );\n    p -= b*h; h = zoom*3./R.y; return max(0., 1. -  dot(p,p)/(h*h) );  // optim\n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O = T1(U);                                           // previous state\n    bool k = keyDown(32), b = keyDown(9);\n    if (U==vec2(.5)) {  iMouse.z>0. || k || b ? O.a=1. : \n                       O.a++;                            // cumulates - reset on mouse move\n                       if (k) O.x = mod(O.x+1.,5.);      // SPACE: change crystal shape\n                       return; } \n     if  (iMouse.z>0.|| k || b )  O-=O; if(k) return;\n\n    U = zoom*( 2.* U - R ) / R.y;   \n    bool inside = length(U) <= zoom;                     // bounding shape (for optim )\n\n    for( float s=0.; s < RAYS; s++ ) {\n        vec4 T; int i=0;\n        vec2 P =  T(vec2(0,s)).xy, _P,P0; \n\n        // fetch and trace segment.  optim: param in=1 if ray bounded to shape\n#define doLine(in) ( _P = P, T = T(vec2(++i,s)), P = T.xy, int(in)<1||inside ? line(U,_P, P) : 0. )\n\n        O   +=      doLine(U) * .5 ;                     // incoming ray\n        O.r += 2. * doLine(0) * T.z;                     // reflected ray\n        P = _P;\n        O.b +=      doLine(1) * T.z;                     // 1st internal ray\n        O.b +=      doLine(0) * T.z;                     //  main exit \"lense ray\"\n      for (float j=0.; j<BOUNCE; j++) {                  // loop on internal bounces\n        P = _P;\n        O   +=      doLine(1) * T.z;                     // internal reflected ray\n        O.g += 2. * doLine(0) * T.z;                     // refraction out of sphere\n      }\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 143, 143, 207]], "test": "untested"}
{"id": "WtGyW1", "name": "phase function through shape", "author": "FabriceNeyret2", "description": "WIP. phase function of sphere (or cylinder) vs hexagonal prism (fix or random angle).\nSpace: shape = sphere-cyl  / hexa-prism (mouse.x = angle ) / random-angle hexa\n- red: reflection on shape\n- blue: refraction inside\n- green: + 1 internal reflection", "tags": ["phenomena", "rainbow", "pathtracing", "ice", "fresnel", "arcs", "pillars", "glory", "sundogs", "parhelia", "halo120", "halo22"], "likes": 1, "viewed": 375, "published": 3, "date": "1610900319", "time_retrieved": "2024-07-30T19:44:37.217748", "image_code": "// 2D variant of \"aerial ice phenomena\" https://shadertoy.com/view/wtccz2\n\nvoid mainImage(out vec4 O, vec2 U) {   \n    O = T(U)/T(0).a;\n    O = pow( O, vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define zoom            3.\n#define PI              3.1415927\n#define SQR(x)         (x)*(x)\n#define Fresnel(D,N,e)( e<1. ? fresnel(D,N,e) : fresnel(refract(D,N,e),N,e) )\n#define fresnel(D,N,e)  mix( pow( max(0.,1.-abs(dot(-D,N))), 5.), 1. , SQR((1.-e)/(1.+e)) )  // Schlick's approximation https://en.wikipedia.org/wiki/Schlick%27s_approximation\n#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#if 0\n\n    #define hash(p)         fract(sin(dot(p,vec2(127.1,311.7))) *43758.5453123)   // https://www.shadertoy.com/view/llySRh\n\n#else\n\n// integer hash from https://www.shadertoy.com/view/XlXcW4\nvec3 ihash3( vec3 v ) {\n    uvec3 x = uvec3(v * float(0xffffffffU) );\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;   \n    return vec3(x)/float(0xffffffffU);\n}\n    #define hash(p) ihash3(vec3(fract((p)/100.),.5)).x\n\n#endif\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);                    // proj coord on line\n    return smoothstep(zoom*3./R.y,0.,length(p - b * h));               // dist to segment\n}\n\nvoid mainImage(out vec4 O, vec2 U) {   \n    O = T(U);                                                          // previous state\n    bool k = keyDown(32), b = keyDown(9);\n    if (U==vec2(.5)) { iMouse.z>0. || k || b ? O.a=1. : \n                       O.a++;                                          // cumulates - reset on mouse move\n                       if (k) O.x = mod(O.x+1.,3.);                    // SPACE: change crystal shape\n                       return; } \n    if  (iMouse.z>0.|| k || b )  O-=O; if(k) return;\n\n    int CASE = int(T(0).x);                                            // 0: sphere 1: cylinder 2: hexa-prism\n    \n    U = zoom*( 2.* U - R ) / R.y;    \n    vec2 D = vec2(1,0), _P,P,N, r,t,                                   // ray direction\n         M = iMouse.xy / R;\n    \n    for(float i=0.; i < 100.; i++) {                                   // samples per frame, then cumulates\n        vec2 d =  vec2( 2.*hash(vec2(i,iTime))-1.);                    // random sample on disk\n        float l, s = 1.*(i-1.11*iTime)/100., _s,                       // for hexa-cylinder: current side\n              f, I=8.;\n        if (CASE==1) s = M.x;                                          // manual tuning of hexa rotation\n              \n#define intersect(P,r) /* out: new P,N                                    internal intersection in shape */ \\\n     switch(CASE) {                                                                                         \\\n     case 0:                                                           /* sphere / cylinder */              \\\n        N = P -= 2.*dot(P,r) * r; break;                /*  |P + kr| = 1  k +2k(P.r) = 0  k = -2(P.r) */ \\\n     case 1:                                                                                                \\\n     case 2:  vec2 n; l=99.;                                           /* hexa-cylinder ( WIP ) */          \\\n        for(float t,k=0.; k<6.; k++) {                                 /* case 0 for outside intersect */   \\\n            n = cos( (s+k)*PI/3. + vec2(0,PI/2.) );                                                         \\\n            t = ( sqrt(3.)/2. - dot(P,n) ) / dot(r,n);                 /* solve (OP+kr).n = cos(pi/6) */    \\\n            if (t>0. && t<l /* && length((P+t*r).xz)<1. */ ) l=t,/* _s=s+k,*/ N = n;   /* closest intersection > 0 */ \\\n          }                  /* start in convex hull so good even for 1st intersect                   */    \\\n        P += l*r;            /* s = _s;  */                                                                 \\\n        if (length(P) > 1.) I = 0.; /* continue;  /* forbiden on windows */                                 \\\n        break;                                                                                              \\\n     }\n\n#define C2S(c) sqrt(max(0., 1. - dot(c,c) ))                                                      // 2D renormalized version\n\n     _P = P = vec2(-3,d.x);\n     switch(CASE) {                                                    // 1st intersection on shape  N,P\n     case 0:\n        N = P = vec2(0,d.x) - C2S(d.x)*D;     break;                   // sphere / cylinder\n     case 1:                                                           // hexa-cylinder\n     case 2:\n        N = P = vec2(0,d.x) - C2S(d.x)*D;  \n        intersect(P,D); break;\n     }\n        O += .5*line(U,_P,P); _P = P;                                     // incoming ray\n\n        t = reflect(D,N);                                              // reflect on shape\n        f = Fresnel(D,N,1./1.3); // if (dot(-D,N)<-.1) O += log(-iTime); // test\n       // O.r += illu(t)* I * f;\n        O.r += line(U,_P,_P+10.*t) * I*f ;                             // reflected ray\n        I *= 1.-f;\n        r = refract(D,N,1./1.3);                                       // refraction in shape\n        intersect(P,r);                                                // next intersection\n        O.b += line(U,_P,P) * I; _P = P;                               // 1st internal ray\n        t = refract(r,-N,1.3);                                         // refraction out of shape\n        f = Fresnel(r,-N,1.3);  // if (dot(r,N)<-.1) O += log(-iTime); // test\n     // if (t!=vec2(0))  O.b += illu(t)* I * (1.-f);                   // ... but if total reflection\n        if (t!=vec2(0))  O.b +=  line(U,_P,_P+60.*t) * I * (1.-f);     // main exit \"lense ray\"                  // ... but if total reflection\n        for (int j=0; j<1; j++) {                                      // loop on internal bounces\n          I *= f;\n          r = reflect(r,-N);                                           // internal reflection\n          intersect(P,r);                                              // next intersection\n          O += line(U,_P,P) * I; _P = P;                               // internal reflected ray\n          t = refract(r,-N,1.3);                                       // refraction out of sphere\n          f = Fresnel(r,-N,1.3);  // if (dot(r,N)<-.1) O += log(-iTime); // test\n       // if (t!=vec2(0))  O.g += illu(t) * I * (1.-f);                // ... but if total reflection\n          if (t!=vec2(0))  O.g +=  line(U,_P,_P+60.*t) *  I * (1.-f);                   // ... but if total reflection\n        }\n}\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 111, 111, 168]], "test": "untested"}
{"id": "3lGcW1", "name": "Michael's Water", "author": "emh", "description": "A fork of \"Paint streams\" (https://www.shadertoy.com/view/WtfyDj). Playing around.", "tags": ["water", "sph"], "likes": 14, "viewed": 506, "published": 3, "date": "1610892100", "time_retrieved": "2024-07-30T19:44:38.386623", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    //float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1.000,0.000,0.000);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n    col = vec4(3.);\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.5*b + 0.0 * specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n    \n    //col.ga = vec2(0.0);\n    //col.rb = rho.xz;\n    //col.xyz = vec3(specular);\n    //return;\n    \n    vec2 q = pos.xy/iResolution.xy;\n\n    vec3 e = vec3(vec2(1.)/iResolution.xy,0.);\n    float f = 10.0;\n    //float p10 = texture(iChannel0, q-e.zy).z;\n    //float p01 = texture(iChannel0, q-e.xz).z;\n    //float p21 = texture(iChannel0, q+e.xz).z;\n    //float p12 = texture(iChannel0, q+e.zy).z;\n    //float p10 = V(q-e.zy).y;\n    //float p01 = V(q-e.xz).y;\n    //float p21 = V(q+e.xz).y;\n    //float p12 = V(q+e.zy).y;\n    \n    //vec4 w = texture(iChannel0, q);\n    //vec4 w = rho.x;\n    vec4 w = vec4(1.0);\n    \n    // Totally fake displacement and shading:\n    //vec3 grad3 = normalize(vec3(p21 - p01, p12 - p10, 0.5));\n    vec3 grad3 = vec3(grad.xz, 1.0);\n    vec2 uv = pos*4./iChannelResolution[3].xy + grad3.xy;\n    uv = uv * 0.5;\n    vec4 c = texture(iChannel3, uv);\n    c += c * 0.5;\n    c += c * w * (0.5 - distance(q, vec2(0.5)));\n    vec3 lightDir = vec3(0.2, -0.5, 0.7);\n    vec3 light = normalize(lightDir);\n    \n    //float diffuse = dot(grad3, light);\n    float diffuse = dot(grad3, light);\n    float spec = pow(max(0.,-reflect(light,grad3).z),32.);\n    vec4 col2 = tanh(mix(c,vec4(.7,.8,1.,1.),.25)*max(diffuse,0.) + spec);\n    //col.xyz = a > 0.5 ? mixN(col.xyz, col.xyz * col2.xyz, 1.5) : col2.xyz;\n    col.xyz = a > 0.5 ? 2.0 * col.xyz * col2.xyz : col2.xyz;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    \n    /*\n    vec3 center = vec3(0.0);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        if (length(dx) < 1.0) {\n            center.xy += dx;\n            center.z += 1.0;\n        }\n    }\n    center.xy /= center.z;\n    */\n    \n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        if (length(dx) < 1.0) {\n            float d = length(dx);\n            //F -= 0.0001 * dx;\n            //F *= 0.0000000001 * dx;\n        }\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    //F /= vec2(10.0);\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F -= P.M.x*vec2(0., 0.0004);\n    vec2 PDC = P.X - 0.5 * R;\n    if (length(PDC) < length(0.1 * R)) {\n        F -= P.M.x*0.0001*(PDC);\n    }\n    //F -= P.M.x*0.01*(center.xy);\n\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    //P.V *= 0.997;\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [295, 295, 311, 311, 339], [341, 341, 386, 386, 2945]], "test": "untested"}
{"id": "WlyyDh", "name": "flow field art 2b", "author": "FabriceNeyret2", "description": "variant of field art [url]https://shadertoy.com/view/wtVyRW[/url] \nusing flownoise [url]https://www.shadertoy.com/view/wdKXzd[/url] \nwith incompressible noise [url]https://www.shadertoy.com/view/Xl3Gzj[/url]\nTry variants for f(U).", "tags": ["perlin", "flow", "field", "flownoise", "lic", "incompressible"], "likes": 6, "viewed": 392, "published": 3, "date": "1610877767", "time_retrieved": "2024-07-30T19:44:39.190474", "image_code": "// variant of \"flow field art 2b\" https://www.shadertoy.com/view/WlGcWh\n// variant of \"field art\" https://shadertoy.com/view/wtVyRW\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n// --- flownoise from https://www.shadertoy.com/view/wdKXzd\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 p ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(p.x+p.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(p.x)+floor(p.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale    \n\n    return ( -1. + 2.*hash2(p) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t  // u = f*f*(3.-2.*f);\n         u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // better for derivative. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\n#define noise01(p) 1.5 * ( .5+.5* noise(p)-.18 )    // well fitted to [0,1] without saturation\n\nfloat perlin( vec2 p )                              // fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) { _z = s;   // for flownoise\n        v += s*noise01( p ); p *= m;                // variant using positive noise\n    }\n    return v;\n}\n\n// --- sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n\n// #define f(U)   noise01(U)\n// #define f(U)   noise01(ofs(U))\n   #define f(U) ( noise01(ofs(U)) + .5*noise01(2.*ofs(U)) ) / 1.2\n// #define f(U)   perlin(U) / 1.5     \n// #define f(U)   perlin(ofs(U)) / 1.5\n#define ofs(U) ( U *vec2(1,2) + vec2(.3*iTime,0) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;       \n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n       // d = 90.*pow((1.-U.y)/2.,1.7)*R.y/360.;          // strokes density\n       //   d = 90.*pow(max(f(U)-.25 -.0*U.y,0.),1.7)*R.y/360.;\n          d = 90.*pow(max(2.*(f(U)-.5) -.5*U.y,0.),1.7)*R.y/360.;\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V; // =  f(.5*U);    // f(.5*P)                   // local field. f(U): curvy f(P): tangent \n        v = f(U); // v = V.x;\n        V = vec2(  dFdx(v), dFdy(v) ) * R.y;              // divergence-free  ( since we trace ortho(V) )  \n     // V = vec2( -dFdy(v), dFdx(v) ) * R.y;              // divergence-free  ( if we were tracing V )  \n\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += // (1.-O)*                                    // blend ( comment out for add )\n             .25* max( 0., 1. - 1.3*abs(v) )               // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n}\n    \n // O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O*vec4(1,1,.5,0));                        // reverse + to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlyyDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 380, 444, 1006], [1008, 1008, 1031, 1031, 1419], [1517, 1517, 1587, 1587, 1846], [2267, 2267, 2306, 2306, 4327]], "test": "untested"}
{"id": "WlGcWh", "name": "flow field art 2", "author": "FabriceNeyret2", "description": "[ why crossings ? ]\nvariant of field art [url]https://shadertoy.com/view/wtVyRW[/url] \nusing flownoise [url]https://www.shadertoy.com/view/wdKXzd[/url] \nwith incompressible noise [url]https://www.shadertoy.com/view/Xl3Gzj[/url]\nTry variants for f(U).", "tags": ["perlin", "flow", "field", "flownoise", "lic", "incompressible"], "likes": 7, "viewed": 494, "published": 3, "date": "1610873909", "time_retrieved": "2024-07-30T19:44:40.019258", "image_code": "// variant of \"field art\" by FabriceNeyret2. https://shadertoy.com/view/wtVyRW\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n// --- flownoise from https://www.shadertoy.com/view/wdKXzd\n// gradient noise derived from https://www.shadertoy.com/view/XdXGW8\n\nfloat _z = 1.;\nvec2 hash( vec2 p ) \n{\n // float s = 0.;                      // standard Perlin noise\n    float s = mod(p.x+p.y,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(p.x)+floor(p.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                      // flow noise universal rotation direction\n // s *= iTime;                        // same rotation speed at all scales\n    s *= iTime/ _z;                    // rotation speed increase with small scale    \n\n    return ( -1. + 2.*hash2(p) ) \n        *  mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n}\n\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p ),\n         f = fract( p ),\n\t  // u = f*f*(3.-2.*f);\n         u = f*f*f* ( 10. + f * ( -15. + 6.* f ) ); // better for derivative. from http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/paper445.pdf\n\n#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )\n    return mix( mix( P(0,0), P(1,0), u.x),\n                mix( P(0,1), P(1,1), u.x), u.y);\n}\n\n#define noise01(p) 1.5 * ( .5+.5* noise(p)-.18 )    // well fitted to [0,1] without saturation\n\nfloat perlin( vec2 p )                              // fractal noise\n{\t\n    mat2 m = mat2(2.); // mat2( 1.6,  1.2, -1.2,  1.6 );\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) { _z = s;   // for flownoise\n        v += s*noise01( p ); p *= m;                // variant using positive noise\n    }\n    return v;\n}\n\n// --- sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n\n// #define f(U)   noise01(U)\n   #define f(U)   noise01(ofs(U))\n// #define f(U) ( noise01(ofs(U)) + .5*noise01(2.*ofs(U)) ) / 1.2\n// #define f(U)   perlin(U) / 1.5     \n// #define f(U)   perlin(ofs(U)) / 1.5\n#define ofs(U) ( (U) *vec2(1,2) + vec2(.3*iTime,0) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy, eps = vec2(1./R.y,0),\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;       \n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n       // d = 90.*pow((1.-U.y)/2.,1.7)*R.y/360.;          // strokes density\n          d = 90.*pow(max(f(U)-.25 -.0*U.y,0.),1.7)*R.y/360.;// strokes density\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V; // =  f(.5*U);    // f(.5*P)                   // local field.\n        v = f(U); // v = V.x;\n        V = vec2(  dFdx(v), dFdy(v) ) * R.y;              // divergence-free  ( since we trace ortho(V) )  \n     // V = vec2( -dFdy(v), dFdx(v) ) * R.y;              // divergence-free  ( if we were tracing V )  \n     // V = vec2( f(P)-f(P-eps), f(P)-f(P-eps.yx) );      // tangents rather than curves\n\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += (1.-O)*                                      // blend ( comment out for add )\n             .5* max( 0., 1. - 1.3*abs(v) )               // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n}\n    \n // O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O);                                       // reverse + to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 327, 391, 953], [955, 955, 978, 978, 1366], [1464, 1464, 1534, 1534, 1793], [2216, 2216, 2255, 2255, 4308]], "test": "untested"}
{"id": "3lyyWh", "name": "Fork fractal di IWBTShyGuy 913", "author": "IWBTShyGuy", "description": "A test of fork.", "tags": ["fractaldirecto"], "likes": 4, "viewed": 279, "published": 3, "date": "1610868114", "time_retrieved": "2024-07-30T19:44:40.946778", "image_code": "//referencia\n//http://glslsandbox.com/e#70359.0\n//modificado por jorge2017a1\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat scale;\n\n\nfloat map(vec3 p) \n{\n    vec3 pp=p;\n\tp.z -= -iTime * 2.5;\n\tp.xy = abs(p.xy) - 1.0;\n\tif (p.x < p.y) p.xy = p.yx;\n\tp.z = mod(p.z, 4.0) - 2.0;\n\n\tp.x -= 3.2;\n\tp = abs(p);\n\tfloat s = 2.0;\n\tvec3 offset =p*1.5;\n    \n    float r;\n    \n    float aa = 7.6 + 1.1 * sin(iTime);\n\tfor (float i = 0.0; i < 5.0; i++)\n    {\n\t\tp = 1.0 - abs(p - 1.0);\n\t\t r = -aa * clamp(0.38 * max(1.2 / dot(p, p), 1.), 0.0, 1.0);\n\t\ts *= r;\n\t\tp *= r;\n        p += offset;\n\t}\n\ts = abs(s);\n\tscale = s;\n\tfloat a = 100.0;\n\tp -= clamp(p, -a, a);\n\treturn (length(p)) /( s);\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro=vec3(0, 0.5, -3);\n\tvec3 p = ro;\n    scale=1.0;\n     float d;\n     \n     //vec3 light_color1 = vec3( 1.0 );\n     vec3 light_pos1= vec3(2.0, 3.0, 10.0 );\n     vec3 final;\n     float shininess=1.0;\n     \n\tfor (int i = 1; i < 100; i++) {\n\t\tfloat d = map(p);\n\t\tp += rd * d;\n\t\tif (d < 0.001) \n        {\n\t       \n            vec3 color=mix(vec3(0.85), cos(vec3(2.0, 9., 3.) + log2(scale)) * 0.5 + 0.5, 0.5) * 10.0 / float(i);\n            \n            vec3 normal=GetNormal(p);\n            vec3 v = normalize( p-ro);\n              float diff = dot(normal, light_pos1);\n    \n            vec3 vl = normalize( light_pos1 - p );\n            vec3 ref_v = reflect( v, normal );\n            float diffuse  = max( 0.0, dot( vl, normal ) );\n            float specular = max( 0.0, dot( vl, ref_v ) );\n    \n            specular = pow( specular, shininess );\n            \n            final += color * ( diffuse + specular);\n            \n\t\t\tbreak;\n\t\t}\n        \n        \n\t}\n    \n    \n    fragColor =vec4( final,1.0);\n    \n    fragColor *= 1.0 - pow(d /(100.0) , 3.5);    \n    fragColor = pow(fragColor, vec4(0.5545));  \n\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 167, 167, 681], [683, 683, 707, 707, 871], [873, 873, 930, 930, 2151]], "test": "untested"}
{"id": "tlKcDz", "name": "Triangle - Gradient Boundaries", "author": "iq", "description": "I deduced the formula for the \"equiceneter\" of a triangle - the point that is equidistant to all three edges: take the center of mass and pulling it in each vertex's direction proportionally to the length of the side opposite to the vertex", "tags": ["2d", "triangle", "equicenter"], "likes": 19, "viewed": 770, "published": 3, "date": "1610865957", "time_retrieved": "2024-07-30T19:44:41.813461", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Analytically finding the discontinuties of the\n// gradient of an triangle SDF.\n//\n// They all emanate from a central point, the\n// point that is equally distant from each edge of\n// the triangle. I derived the formula by computing\n// the bisectors of each angle then finding their\n// intersection. Two hours of simplifications later\n// it all reduced itself.\n//\n// Then I discovered this is also called the \"incenter\"\n// and had already a known formula. Oh well, at least\n// I can be proud I landed in the right one by myself.\n\n// Other Gradient boundaries:\n//\n// Triangle: https://www.shadertoy.com/view/tlKcDz\n// Quad:     https://www.shadertoy.com/view/WlycWh\n\n\nvec2 triangleIncenter( in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float l0 = length(v2-v1);\n    float l1 = length(v0-v2);\n    float l2 = length(v1-v0);\n\n    return (v0*l0+v1*l1+v2*l2)/(l0+l1+l2);\n}\n\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// distance to a line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y-a.y*b.x; }\nfloat dot2( in vec2 a ) { return dot(a,a); }\nvec3 sdgTriangle( in vec2 p, in vec2 v0, in vec2 v1, in vec2 v2 )\n{\n    float gs = cro(v0-v2,v1-v0);\n    vec4 res;\n    \n    // edge 0\n    {\n    vec2  e = v1-v0;\n    vec2  w = p-v0;\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4(d,q,s);\n    }\n    \n    // edge 1\n    {\n\tvec2  e = v2-v1;\n    vec2  w = p-v1;\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // edge 2\n    {\n\tvec2  e = v0-v2;\n    vec2  w = p-v2;\n    vec2  q = w-e*clamp(dot(w,e)/dot(e,e),0.0,1.0);\n    float d = dot(q,q);\n    float s = gs*cro(w,e);\n    res = vec4( (d<res.x) ? vec3(d,q) : res.xyz,\n                (s>res.w) ?      s    : res.w );\n    }\n    \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return vec3(d,res.yz/d);\n\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n\t\n\tvec2 v0 = cos( 0.5*iTime + vec2(0.0,2.0) + 0.0 );\n\tvec2 v1 = cos( 0.5*iTime + vec2(0.0,1.5) + 1.5 );\n\tvec2 v2 = cos( 0.5*iTime + vec2(0.0,3.0) + 4.0 );\n\n    // compute traingle SDF\n\tvec3 dg = sdgTriangle( p, v0, v1, v2 );\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // compute triangle equicenter (yellow dot)\n    vec2 ce = triangleIncenter( v0, v1, v2 );\n\n    // draw triangle SDF\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.1,1.4,1.7)*0.5;\n    col *= 0.5+vec3(0.5+0.5*g,0.5);\n    col *= 1.0 - 0.9*exp(-5.0*abs(d));\n    col *= 0.8 + 0.2*cos(200.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    col = clamp(col,0.0,1.0);\n\n    // animate equicenter display\n    float al = 1.0;//smoothstep(-0.2,0.2,cos(3.1415927*iTime) );\n    \n    // draw helped bisectors\n    col = mix(col,vec3(1.0,1.0,1.0),al*smoothstep(px,0.0,sdSegment( p, v0, ce )-0.005));\n    col = mix(col,vec3(1.0,1.0,1.0),al*smoothstep(px,0.0,sdSegment( p, v1, ce )-0.005));\n    col = mix(col,vec3(1.0,1.0,1.0),al*smoothstep(px,0.0,sdSegment( p, v2, ce )-0.005));\n    \n    // draw equicenter in red\n    col = mix(col,vec3(1.0,1.0,0.0),al*smoothstep(px,0.0,sdDisk(p,ce,0.025)));\n\n    // output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcDz.jpg", "access": "api", "license": "mit", "functions": [[1746, 1746, 1807, 1807, 1943], [2003, 2032, 2082, 2082, 2110], [2112, 2142, 2194, 2194, 2314], [2316, 2352, 2386, 2386, 2412], [2413, 2413, 2438, 2438, 2457], [2458, 2458, 2525, 2525, 3416], [3475, 3475, 3532, 3532, 4849]], "test": "untested"}
{"id": "tlVyDz", "name": "Peacock Feather Flame", "author": "jarble", "description": "Based on my [url=https://www.shadertoy.com/view/tldcRS]\"Fractal Graffiti 3.\"[/url]", "tags": ["fractal"], "likes": 2, "viewed": 270, "published": 3, "date": "1610857247", "time_retrieved": "2024-07-30T19:44:42.684133", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y/10.0;\n        uv += iTime/10.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.4;\n        for(int i=0;i<20;i++)\n        {\n            \n            uv=cos(uv/(2.0+sin((uv.x+uv.y)/10.0))-(uv.yx/(2.0+sin(fract(iTime/2.0+uv.x+uv.y))))/scale)*scale/1.5+scale1*scale;\n            uv /= scale1;\n        \t//uv += cos(uv/100.0);\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 685]], "test": "untested"}
{"id": "wlVyWz", "name": "First ray tracing exercise", "author": "avinitzca", "description": "First ray tracing scene. Distance to sphere and to plane were used, having the sphere as priority.", "tags": ["raytracing", "basic", "sphere", "floor"], "likes": 2, "viewed": 292, "published": 3, "date": "1610844934", "time_retrieved": "2024-07-30T19:44:43.605669", "image_code": "\nfloat distanceLinePoint(vec3 point, vec3 lineOrigin, vec3 lineDirection)\n{\n    return length(cross(point - lineOrigin, lineDirection)) / length(lineDirection);\n\n}\n\nfloat intersectionSphereRay(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection){\n    vec3 oc = rayOrigin - center;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(oc, rayDirection);\n    float c = dot(oc,oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0){\n        return -1.0;\n    }\n    else{\n        return (-b - sqrt(discriminant)) / (2.0*a);\n    }\n}\n\nfloat LineLineIntersection(vec3 rayAOrigin, vec3 rayADirection, vec3 rayBOrigin, vec3 rayBDirection)\n{ \n    vec3 lineVec3 = rayBOrigin - rayAOrigin;\n    vec3 crossVec1and2 = cross(rayADirection, rayBDirection);\n    vec3 crossVec3and2 = cross(lineVec3, rayBDirection);\n \n    float planarFactor = dot(lineVec3, crossVec1and2);\n \n    bool less = abs(planarFactor) < 0.0001;\n    bool j = 0.0001 < length(crossVec1and2);\n    \n    //is coplanar, and not parrallel\n    if(less && j)\n    {\n        return dot(crossVec3and2, crossVec1and2) / sqrt(length(crossVec1and2));        \n    }\n    else\n    {\n        return -1.0;\n    }\n}\n\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat invLerp(float from, float to, float value){\n  return (value - from) / (to - from);\n}\n\n\nfloat linePlaneIntersection(vec3 normal, vec3 coord, vec3 rayOrigin, vec3 rayDirection) \n{\n    // get d value\n    float d = dot(normal, coord);\n\n    float denominator = dot(normal, rayDirection);\n\n    // Compute the X value for the directed line ray intersecting the plane\n    return (denominator == 0.0) ? -1.0 : ((d - dot(normal, rayOrigin)) / denominator);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n        \n    \n    \n    // Camera and ray tracing \n    float zoom = 1.0;    \n    vec3 normalUp = vec3(0.0, 1.0, 0.0);    \n    vec3 rayOrigin = vec3(4.0 * -cos(iTime * 0.5), 2.0, 4.0 + 4.0 * sin(iTime * 0.5));\n    rayOrigin = vec3(0.0, 0.5, 0.5);\n    vec3 lookAtPosition = vec3(0.0, 0.0, 4.0);    \n    vec3 cameraForward = normalize(lookAtPosition - rayOrigin);\n    vec3 cameraRight = cross(normalUp, cameraForward);\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n    vec3 center = rayOrigin + cameraForward * zoom;\n    vec3 intersection = center + uv.x * cameraRight + uv.y * cameraUp;\n        \n    vec3 rayDirection = intersection - rayOrigin;\n    \n    \n    \n    // Sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, 4.0);\n    float sphereRadius = 1.0;\n    \n    vec3 planeNormal = vec3(0.0, 1.0, 0.0);\n    vec3 planePosition = vec3(0.0, -1.0, 0.0);\n    \n    // Intersection\n    float sphereResult = intersectionSphereRay(sphereCenter, sphereRadius, rayOrigin, rayDirection); \n    \n    \n    vec3 color = vec3(0.0);\n    vec3 lightPosition = vec3(-10.0, 10.0, -6.0);\n    \n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    vec3 intersectionPoint = vec3(0.0);\n    float shadow = 1.0;\n    \n    float kA = 0.1;\n    float kD = 0.8;\n    float kS = 0.2;\n\n    vec3 baseColor = vec3(1.0);\n    vec3 specularAdditive = vec3(0.0);\n    float n = 0.0;\n    \n    bool geometry = false;\n    \n    if(sphereResult != -1.0)\n    {\n        geometry = true;\n        intersectionPoint = rayOrigin + rayDirection * sphereResult;\n        normal = normalize(intersectionPoint - sphereCenter);\n        /*vec3 reflectionDirection = reflect(rayDirection, normal);\n        float intersectReflection = linePlaneIntersection(planeNormal, planePosition, intersectionPoint, reflectionDirection);\n        \n        if(intersectReflection >= 0.0)\n        {\n            vec3 reflectionIntersectionPoint = intersectionPoint + reflectionDirection * intersectReflection;\n            vec2 checker = floor(reflectionIntersectionPoint.xz * 5.0);\n            specularAdditive = vec3(saturate(mod(checker.x + checker.y, 2.0))) * 0.25 + 0.25;\n        }\n        else\n            specularAdditive = vec3(0.0, 0.6, 1.0) * .75;\n        */\n    }\n    else\n    {\n        \n        float planeResult = linePlaneIntersection(planeNormal, planePosition, rayOrigin, rayDirection);\n        if(planeResult > .0)\n        {       \n            geometry = true;\n            intersectionPoint = rayOrigin + rayDirection * planeResult;    \n            vec3 shadowRayOrigin = intersectionPoint;\n            vec3 shadowRayDirection = normalize(lightPosition - shadowRayOrigin);\n            float shadowResult = intersectionSphereRay(sphereCenter, sphereRadius, shadowRayOrigin, shadowRayDirection);\n\n            vec2 checker = floor(intersectionPoint.xz * 3.0);\n            baseColor = vec3(saturate(mod(checker.x + checker.y, 2.0))) * 0.25 + 0.25;\n\n            kD = 0.75;\n            kS = 0.2;\n            if(shadowResult > 0.0)\n            {\n                // Not-plausible-shadow\n                shadow = saturate((shadowResult * 1.55 - 2.0) * shadowResult);\n            }\n        }\n    }\n    \n    if(geometry)\n    {    \n        // Blinn-Phong\n        vec3 light = normalize(lightPosition - intersectionPoint);\n        vec3 view = normalize(rayOrigin - intersectionPoint);\n        float lambertian = max(dot(light, normal), 0.0);\n        vec3 halfway = normalize(view + light);    \n        specularAdditive += pow(saturate(dot(halfway, normal)), 32.0);\n\n        color += vec3(lambertian * kD * baseColor + kA + kS * specularAdditive) * shadow;\n    }\n    else\n    {\n        // Sky\n        color = vec3(0.0, 0.67, 0.95);    \n    }\n        \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 75, 75, 163], [165, 165, 255, 255, 586], [588, 588, 690, 690, 1207], [1210, 1210, 1239, 1239, 1276], [1278, 1278, 1327, 1327, 1368], [1371, 1371, 1461, 1480, 1732], [1734, 1734, 1791, 1841, 5648]], "test": "untested"}
{"id": "wtKyWz", "name": "Stylized atmospheric bird world", "author": "xavierseb", "description": "Origami landscape and Night sky, storm clouds, stylized birds and full moon. \nVery computationally intensive, need to find better parameters.\nThis is yet another scene derived from http://glslsandbox.com/e#70315.0\n", "tags": ["3d", "stylized", "geometric"], "likes": 2, "viewed": 380, "published": 3, "date": "1610841336", "time_retrieved": "2024-07-30T19:44:44.482325", "image_code": "// night sky , storm clouds and birds , origami landscape\n// Warning: very slow on some machines\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI 3.14159\n\nfloat mapWorld(vec3 p, mat2 m, mat2 n, float s) {\n\tfloat k;\n\tp.xy *= m;\n\tp.yz *= n;\n\tfor (int i = 0; i < 9; i++) {\n\t\tk = length(p.xy), p.x = k * (mod(atan(p.y, p.x), PI/4.) - PI/8.),  p.y = k - 2.752;\t\t\n\t\tk = length(p.yz), p.y = k * (mod(atan(p.z, p.y), PI/6.) - PI/12.), p.z = k - 10.0;\n\t}\n\t\n\treturn dot(abs(p), normalize(vec3(6.9,5,2.2+s))) - 1.6 ; \n}\n\nfloat mapMoon(vec3 p) {\n\tfloat k;\n\tp.xy *= rot(.92);\t\t\n\tp.yz *= rot(-.5);\t\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tk = length(p.xy), p.x = k * (mod(atan(p.y, p.x), PI/5.) - PI/10.), p.y = k - 2.;\t\t\n\t\tk = length(p.yz), p.y = k * (mod(atan(p.z, p.y), PI/6.) - PI/12.), p.z = k - 10.0;\n\t}\n\treturn dot(abs(p), normalize(vec3(13, 18, 7))) - 0.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y, moon = vec2(.55,.05); \n    vec2 mouse=iMouse.xy/iResolution.xy;\n\t\n\t// draw moon\n\tvec3 rd = normalize(vec3(uv-moon, 1)), p;\n\tif(length(uv-moon)<.1) {\n\t\tp = vec3(0, 0, -420.);\n\t\tfragColor = vec4(.6); \n\t\t\n\t\tfor (int i = 1; i < 60; i++) {\n\t\t\tfloat d = mapMoon(p);\t\t\t\t\n\t\t\tp += rd * d;\n\t\t\tif (d < 0.001) {\n\t\t\t\tfragColor = vec4(20./float(i));\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse \tfragColor = vec4(0,0,mouse.x*2.-1.,1);\n\t\n\t// draw rest of our world\n\trd = normalize(vec3(uv, 1)); \n\tp  = vec3(0, 35.+mouse.y*5., -10.);\n\tfloat v = -8.*mod(iTime/266.,PI/2.), u = mouse.x, \n\t      s = .002*(1.+sin(iTime*8.+uv.x*10.));\n\tmat2 m = rot(u), n = rot(v);\t\n\t\n\tfor (int i = 1; i < 160; i++) {\n\t\tfloat d = mapWorld(p, m, n, s);\t\t\t\t\n\t\tp += rd * d;\n\t\tif (d < 0.001) {\n\t\t\tfragColor = vec4( 10,9,p.y-22.4,1)/float(i);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 220, 220, 524], [526, 526, 549, 549, 862], [864, 864, 921, 921, 1794]], "test": "untested"}
{"id": "3tVcDz", "name": "Raymarch and simple camera", "author": "tombla", "description": "Raymarching w/ ray origin and direction transformed to world model.", "tags": ["raymarchcamera"], "likes": 4, "viewed": 730, "published": 3, "date": "1610828916", "time_retrieved": "2024-07-30T19:44:45.449738", "image_code": "// Raymarch V6: Checkerboard and moving camera.\n\n#define LIGHT_CHECKER  vec3(1., 0.8, 0.)\n#define DARK_CHECKER   vec3(0., 0.5, 0.)\n#define ZERO_CHECKER vec3(1., 0., 0.)\n#define SKY vec3(0., 0., 1.)\n#define AA  2\n#define AAR 0.5\n\n#define PLANE_POS -1.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define CLOSENESS 0.01\n\nvec2 scale2(in vec2 uv) {\n    vec2 R = iResolution.xy;\n    return vec2((uv - 0.5 * R) / min(R.x, R.y));\n}\n\nvec2 rot2(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec3 checker(in vec2 uv, in float size) {\n    uv /= size;\n    if (max(abs(uv.x), abs(uv.y)) < .5) {\n        return ZERO_CHECKER;\n    }\n    vec2 f = floor(uv);\n    float isLight = mod(f.x + f.y, 2.);\n    return mix(DARK_CHECKER, LIGHT_CHECKER, isLight);\n}\n\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\nvec2 planeSdf(in vec3 uv) {\n    return vec2(uv.y - PLANE_POS, 1.);\n}\n\nvec2 ballSdf(in vec3 uv) {\n    uv.y /= 2.1;\n    vec3 ball = vec3(-5., 2., 0.5);\n    float r = 2.1;\n    return vec2(length(uv - ball) - r, 2.);\n}\n\n// @return distance (x) and id(y)\nvec2 sceneSdf(in vec3 uv) {\n  vec2 p = planeSdf(uv);\n  vec2 b = ballSdf(uv);\n  if (b.x < p.x) {\n      return b;\n  }\n  return p;\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n    float dist = 0.;\n    for(int i=0; i < MAX_STEPS; ++i) {\n        vec3 ray = origin + direction * dist;\n        float step = sceneSdf(ray).x;\n        dist += step;\n        if (step < CLOSENESS || dist > MAX_DIST) break;\n    }\n    return min(dist, MAX_DIST);\n}\n\nvec4 image(in vec2 uv) {\n    uv = scale2(uv); // scale to -1..1 on shorter axis.\n    float T = iTime;\n    vec3 eye = vec3(5., 20.+18.*sin(T/4.), 20.*sin(T)),\n         target = vec3(0., 0., 0.),\n         // This is projection (direction) of an eye at (0,0,-1) to (-1..1, -1..1, 0) plane.\n         // We'll transform it later according to eye/target/roll.\n         projection = vec3(uv.x, uv.y, 1.);\n    float roll = 0.*sin(iTime);\n    mat3 L = calcLookAtMatrix(eye, target, roll);\n    // Ray origin and direction.\n    vec3 ro = eye;\n    vec3 rd = normalize(L * projection); \n    // Distance to a shape.\n    float dist = rayMarch(ro, rd);\n    // Point at the shape\n    vec3 ray = ro + rd * dist;   \n    float skyMix = smoothstep(MAX_DIST * 0.6, MAX_DIST * 0.8, dist);\n    vec3 color = checker(ray.xz, 2.) * smoothstep(16., 0., ray.y);\n    // Final color\n    vec3 final = mix(color, SKY, skyMix); \n    return vec4(final, 1.);\n}\n\nvec4 antiAlias(in vec2 uv) {\n  vec4 O = vec4(0);\n  float S = 1./float(AA * AA),  // scale\n        d = 0.2 * sin(uv.x * 415.678  + uv.y * 303.1415), // dither AA sampling\n        r = (2. / float(AA)) * AAR * (1. + d);\n\n  vec2 b = uv - r * (float(AA) - 1.);\n  for (int y = 0; y < AA; y++) {\n      for(int x = 0; x < AA; x++) {\n          vec2 c = vec2(b.x + float(x) * r, b.y + float(y) * r);\n          O += image(c) * S;\n      }\n  } \n  return O;\n}\n\nvoid mainImage(out vec4 O, vec2 uv) {\n  O = antiAlias(uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tVcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 345, 345, 425], [427, 427, 455, 455, 539], [541, 541, 582, 582, 795], [797, 865, 926, 926, 1117], [1120, 1120, 1147, 1147, 1188], [1190, 1190, 1216, 1216, 1334], [1336, 1370, 1397, 1397, 1499], [1501, 1501, 1546, 1546, 1808], [1810, 1810, 1834, 1834, 2734], [3183, 3183, 3220, 3220, 3243]], "test": "untested"}
{"id": "WlKcWz", "name": "Spinning Fiery Halo", "author": "oneshade", "description": "I've been having too much fun with my [url=https://www.shadertoy.com/view/wt3cWB]Electric Flower[/url] shader ;)", "tags": ["psychedelic", "rainbow", "spinning", "smoothnoise", "fiery"], "likes": 18, "viewed": 423, "published": 3, "date": "1610824543", "time_retrieved": "2024-07-30T19:44:46.425131", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat noise(in vec3 p) {\n    p = fract(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat mapScene(in vec3 p) {\n    float r = iTime * 2.0;\n    float c = cos(r), s = sin(r);\n\n    p.xy *= mat2(c, -s, s, c);\n\n    r = iTime * 5.0;\n    c = cos(r), s = sin(r);\n    p.yz *= mat2(c, -s, s, c);\n\n    return length(vec2(length(p.xz) - 1.0, p.y)) - 0.1;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = texture(iChannel0, (fragCoord - screenCenter) * 0.95 / iResolution.xy + 0.5);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += hue2rgb(iTime * 0.5) * 0.5;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = fragColor * (0.8 + 0.3 * noise(vec3(uv, iTime) * 100.0));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "3tyyDz", "name": "Kryptonite", "author": "xjorma", "description": "my first 2021 shader, inspired by Fantasy Crystals from cabbibo.\nUse the mouse to control.", "tags": ["refraction", "volumetric", "convex", "glass", "smoke", "gem", "crystal", "kryptonite", "quartz"], "likes": 23, "viewed": 738, "published": 3, "date": "1610818807", "time_retrieved": "2024-07-30T19:44:47.428448", "image_code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA      0\n#define GAMMA   1\n#define ANIMATE 1\n\nconst float cref = 0.95;\nconst float speed = -0.02;\n\n\nconst float fltMax = 1000000.;\nconst float fltMin = -1000000.;\n\n// from xjorma https://www.shadertoy.com/view/3tVcDh\n\nbool convexIntersect( in vec3 ro, in vec3 rd, out vec2 oDis, out vec3 oNor)\n{\n    oDis = vec2(fltMin, fltMax);\n    for(int i = 0 ;i < numPlanes; i++)\n    {\n        vec4 plane = planes[i];\n        float t = -(plane.w + dot(plane.xyz, ro)) / dot(plane.xyz, rd);\n        if(dot(plane.xyz, rd) < 0.) // enter\n        {\n            if(t > oDis.x)\n            {\n                oDis.x = t;\n                oNor = plane.xyz;\n            }\n        }\n        else  // exit\n        {\n            oDis.y = min(oDis.y, t);\n        }\n    }\n    if(oDis.x < oDis.y)\n    {\n        return true;\n    }\n    return false;\n}\n\n\n// Noise from Nimitz https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x)\n{\n    return abs(fract(x) - .5);\n}\nvec3 tri3(in vec3 p)\n{\n    return vec3( tri(p.z + tri(p.y * 1.)), tri(p.z + tri(p.x * 1.)), tri(p.y + tri(p.z * 1.)));\n}\n                                 \n\nfloat triNoise3d(in vec3 p, in float inter)\n{\n    float z= 1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i = 0.; i <= inter; i++)\n\t{\n        p += tri3(bp * 2.);\n#if ANIMATE\n        p += iTime * speed;\n#endif\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \n        rz+= (tri(p.z + tri(p.x + tri(p.y)))) / z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat map(in vec3 p)\n{\n    return pow(triNoise3d(p * 0.1, 3.), 1.);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n\n// from Guil https://www.shadertoy.com/view/MtX3Ws\nvec4 raymarch( in vec3 ro, inout vec3 rd, float mind, float maxd)\n{\n    float t = mind;\n    float dt = .02;\n    vec4 col= vec4(0.);\n    float c = 0.;\n    for( int i=0; i < 128; i++ )\n\t{\n        t+=dt*exp(-2.*c);\n        if( t > maxd)\n            break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(pos);\n        \n        rd = normalize(mix(rd, -calcNormal(pos), 0.0003));  // Little refraction effect\n        \n        col = 0.99*col + .03 * vec4(c*c, c, c*c*c, c);\t\n    }    \n    return col;\n}\n\nvec4 textureGamma(samplerCube sampler, vec3 v)\n{\n    vec4 col = texture(sampler, v);\n    #if GAMMA\n    \treturn pow(col, vec4(2.2));\n    #else\n        return col;\n    #endif\n}\n\nvec3 render(in vec3 ro,in vec3 rd)\n{\n    vec3 col;\n    vec3  n;\n    vec2  d;\n    if(convexIntersect(ro, rd, d, n))\n    {\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        vec3 nout;\n        vec2 dout;\n        convexIntersect(ro + rd * d.x + refr * 20., -refr, dout, nout);\n        dout.x = 20. - dout.x;\n        vec4 c = raymarch(ro + rd * d.x, refr, 0., dout.x);\n        nout *= -1.;    // If want the normal in the opposite direction we are inside not outside\n        vec3 refrOut = refract(refr, nout, mix(1. / cref, 1., smoothstep(0.35, 0.20, dot(refr, -nout))));   // Dirty trick to avoid refract returning a zero vector when nornal and vector are almost perpendicular and eta bigger than 1.\n        col = mix(textureGamma(iChannel0, refrOut).rgb, c.rgb, c.a);\n        float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        col += textureGamma(iChannel0, refl).rgb * fresnel;   // add reflexion\n    }\n    else\n    {\n        col = textureGamma(iChannel0, rd).rgb;\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);      \n#if AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n        // camera        \n        float theta\t= radians(360.) * (iMouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(70.) * (iMouse.y/iResolution.y-0.5) - radians(60.);\n        vec3 ro = 3. * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        vec3 col = render(ro ,rd);  \n        tot += col;            \n#if AA\n    }\n    tot /= 4.;\n#endif\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Exported from Houdini\n\n/*\nimport sys\n\nnode = hou.pwd()\ngeo = node.geometry()\n\nprims = geo.prims()\n\nbbox =  geo.boundingBox();\nmaxPos = bbox.maxvec()\nminPos = bbox.minvec()\n\noutput = \"const int numPlanes = \" + str(len(prims)) + \";\\n\\n\"\noutput += \"const vec4 planes[numPlanes] = vec4[](\\n\"\nvector = []\nfor prim in prims:\n    normal = prim.attribValue(\"N\")\n    normal = hou.Vector3(normal[0], normal[1], normal[2])\n    points = prim.points()\n    point = points[0].position()\n    d = normal.dot(point)\n    vector.append(\"vec4(\" + str(normal.x()) + \", \" + str(normal.y()) + \", \" + str(normal.z()) + \", \" + str(-d) + \")\")\n    \noutput += \",\\n\".join(vector) + \" );\\n\\n\"\n\noutput = output + \"const vec3 bboxSiz = vec3(\" + str(bbox.sizevec().x() / 2.) + \", \" + str(bbox.sizevec().y() / 2.) + \", \" + str(bbox.sizevec().z() / 2.) + \");\\n\"\noutput = output + \"const vec3 bboxCtr = vec3(\" + str(bbox.center().x()) + \", \" + str(bbox.center().y()) + \", \" + str(bbox.center().z()) + \");\\n\"\n\nprint(output)\n*/\n\nconst int numPlanes = 17;\n\nconst vec4 planes[numPlanes] = vec4[](\nvec4(0.0, 1.0, 0.0, -1.75),\nvec4(0.0, -1.0, 0.0, -1.75),\nvec4(0.865558981895, 0.0, -0.500807106495, -0.742628234022),\nvec4(-0.353560000658, -1.80422770057e-08, -0.935411810875, -0.880737701417),\nvec4(-0.999897956848, -1.36637803294e-08, 0.0142883695662, -0.894969639267),\nvec4(-0.358315140009, 1.2375285692e-11, 0.933600723743, -0.848164967797),\nvec4(0.862004518509, 3.33596505975e-09, 0.50690060854, -0.81893926951),\nvec4(0.781055212021, 0.623916983604, 0.0260841995478, -1.22853477631),\nvec4(0.276541233063, 0.654822647572, -0.703372061253, -1.37026202368),\nvec4(-0.653981924057, 0.653027355671, -0.381919920444, -1.36055210583),\nvec4(-0.651714146137, 0.676901042461, 0.342160224915, -1.30437838268),\nvec4(0.32613825798, 0.617486417294, 0.715782403946, -1.26344136905),\nvec4(0.835819482803, -0.545120954514, 0.065184481442, -1.06336148713),\nvec4(0.240880459547, -0.629201292992, -0.738973855972, -1.31147556665),\nvec4(-0.596318423748, -0.65652692318, -0.461927205324, -1.35845409037),\nvec4(-0.591593742371, -0.707991778851, 0.385700017214, -1.36638951145),\nvec4(0.33144068718, -0.517934799194, 0.788600444794, -1.33775803516) );\n\nconst vec3 bboxSiz = vec3(0.903634905815, 1.75, 1.03868842125);\nconst vec3 bboxCtr = vec3(0.0, 0.0, 0.0);", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyyDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[341, 341, 418, 418, 944], [947, 1006, 1029, 1029, 1062], [1063, 1063, 1085, 1085, 1183], [1219, 1219, 1264, 1264, 1570], [1572, 1572, 1594, 1594, 1641], [1643, 1689, 1721, 1721, 1921], [1924, 1975, 2042, 2042, 2476], [2478, 2478, 2526, 2526, 2652], [2654, 2654, 2690, 2690, 3678], [3680, 3680, 3722, 3722, 3886], [3889, 3889, 3933, 3933, 4032]], "test": "untested"}
{"id": "wt3cWB", "name": "Electric Flower - WebGLSamples", "author": "oneshade", "description": "Recreation of \"Electric Flower\" by Henrik Rydgard: https://webglsamples.org/electricflower/electricflower.html\nI have no idea how he actually achieved the effect but this is what I came up with.", "tags": ["psychedelic", "glow", "webglsamples", "electricflower"], "likes": 22, "viewed": 411, "published": 3, "date": "1610818657", "time_retrieved": "2024-07-30T19:44:48.447723", "image_code": "/*\nRecreation of \"Electric Flower\" by Henrik Rydgard: https://webglsamples.org/electricflower/electricflower.html\nI have no idea how he actually achieved the effect but this is what I came up with.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat mapScene(in vec3 p) {\n    float r = iTime * 2.0;\n    float c = cos(r), s = sin(r);\n    mat2 rmat = mat2(c, -s, s, c);\n\n    p.yz *= rmat;\n    p.xz *= rmat;\n\n    vec3 q = abs(p) - 0.5;\n    float box = max(q.x, max(q.y, q.z));\n\n    box = max(box, -max(q.x, q.y) - 0.03);\n    box = max(box, -max(q.x, q.z) - 0.03);\n    box = max(box, -max(q.y, q.z) - 0.03);\n\n    return box;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    fragColor = texture(iChannel0, (fragCoord - screenCenter) * 0.98 / iResolution.xy + 0.5);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            fragColor.rgb += hue2rgb(iTime * 0.5) * 0.5;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    fragColor = fragColor * 0.96;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 257, 257, 323]], "test": "untested"}
{"id": "WtKyDR", "name": "Raymarching tutorial series 1", "author": "darkeclipz", "description": "Use the mouse to rotate it.\n\nIt's pretty mind boggling that this shader (actually any shader), which runs here at 144fps, is executed 298,598,400 times per second lol.", "tags": ["raymarching"], "likes": 1, "viewed": 275, "published": 3, "date": "1610811765", "time_retrieved": "2024-07-30T19:44:49.474976", "image_code": "#define RES iResolution.xy\n#define MIN_DIST 0.0001\n\nmat2 rotate(float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdCircle(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nint id = 0;\nfloat map(vec3 p) {\n    id = 0;\n    float mCircle = sdCircle(p, 0.4);\n    float sCircle = sdCircle(abs(p) - vec3(0.35,0.35,0), 0.25);\n    float d = smin(mCircle, sCircle, 0.1);\n    return d;\n}\n\nstruct hit {\n    float t;\n    float occlusion;\n    int id;\n};\n\nhit trace(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    float N = 100.;\n    for(i=0.; i < N; i++) {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if(d < MIN_DIST) {\n            break;\n        }\n        t += d;\n        if(t > 20.) {\n            break;\n        }\n    }\n    if(i == N) id = 0;\n    return hit(t, 1.-i/N, id);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.0001,0);\n    return normalize(vec3(map(p+h.xyy) - map(p-h.xyy), \n                          map(p+h.yxy) - map(p-h.yxy), \n                          map(p+h.yyx) - map(p-h.yyx)));\n}\n\nvec3 brdf(vec3 N, vec3 L, vec3 V, vec3 diff, vec3 spec, float exponent) {\n    vec3 R = reflect(L,N);\n    vec3 H = normalize(L+V);\n    return diff * clamp(dot(N, L), 0., 1.)\n         + spec * pow(max(0., dot(R,V)), exponent);\n}\n\nvec3 shade(vec3 P, vec3 N, vec3 ro) {\n    // N = N - mod(N, 0.15); // flat-shading\n    vec3 V = normalize(P-ro);\n    vec3 ambient = vec3(0.1,0.1,0.2);\n    vec3 diffuse = vec3(.4, .4, .9);\n    vec3 specular = vec3(.8, .8, 1.0);\n    vec3 light1 = brdf(N, normalize(vec3(1,1,1) - P), V, diffuse, specular, 16.);\n    vec3 light2 = brdf(N, normalize(vec3(-1,0,-0.5) - P), V, diffuse, specular, 16.);\n    return ambient + light1 + light2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = (2.*fragCoord-RES)/RES.y;\n    vec3 ro = vec3(0,0.1,1.8);\n    \n    ro.xz *= rotate(iMouse.x/RES.x*3.14*2.);\n    ro.yz *= rotate(-iMouse.y/RES.y*3.14*2.);\n    \n    vec3 ta = vec3(0,0,0);\n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.2*ww);\n\n    hit hit = trace(ro, rd);\n    vec3 col = vec3(0);\n    if(hit.t < 20.) {\n        vec3 p = ro + hit.t*rd;\n        vec3 n = normal(p);\n        col = shade(p, n, ro) * hit.occlusion;\n    }\n    else {\n        col = texture(iChannel0, rd).rgb;\n    }\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 74, 74, 146], [148, 148, 189, 189, 275], [277, 277, 310, 310, 338], [340, 340, 369, 369, 456], [470, 470, 489, 489, 662], [727, 727, 756, 756, 1071], [1073, 1073, 1094, 1094, 1294], [1296, 1296, 1369, 1369, 1522], [1524, 1524, 1561, 1606, 1958], [1960, 1960, 2017, 2017, 2692]], "test": "untested"}
{"id": "WlKcWR", "name": "Box Spin", "author": "YitingLiu", "description": "An in-between psychedelic and mesmerizing experiment. ", "tags": ["time", "sin", "color", "rotate", "pi", "atan", "cos", "box", "spin", "cross", "scale", "movement", "tan", "translate"], "likes": 0, "viewed": 258, "published": 3, "date": "1610806653", "time_retrieved": "2024-07-30T19:44:50.351632", "image_code": "//Learned Matrix from The Book of Shaders\n//Edited the code from Author @patriciogv ( patriciogonzalezvivo.com ) - 2015\n\n\n#define PI 3.14159265359\n\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5)*abs(sin(iTime)) - _size*0.2;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat cross(in vec2 _st, float _size){\n    return  box(_st, vec2(_size,_size/4.)) +\n            box(_st, vec2(_size/4.,_size));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.819,0.865,0.002);\n\n    st -= vec2(0.5);\n    st = scale( vec2(sin(iTime)+1.0) ) * st;\n    st = rotate2d( sin(iTime)*PI ) * st;\n\n    st += vec2(0.5);\n\n    // Show the coordinates of the space on the background\n    color = vec3(st.x,st.y,atan(st.x,st.y));\n    color /= vec3(st.x,st.y,1.0);\n    color *= vec3(st.x,st.y,0.8);\n    color += vec3(st.x,st.y,0.6);\n    color += vec3(st.x,st.y,0.4);\n\n    // Add the shape on the foreground\n    color -= vec3(cross(st,0.2));\n    color /= vec3(cross(st,0.5*sin(iTime)));\n    color /= vec3(cross(st,1.0-0.5*cos(iTime)));\n    color += vec3(cross(st,0.5*tan(iTime)));\n    color /= vec3(cross(st,1.0-0.5*tan(iTime)));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 173, 173, 236], [237, 237, 265, 265, 351], [353, 353, 391, 391, 674], [676, 676, 714, 714, 805], [807, 807, 863, 863, 1617]], "test": "untested"}
{"id": "wlGcDz", "name": "When the star aligns", "author": "YitingLiu", "description": "Experimenting with the change of shapes and learning the distance fields. ", "tags": ["distancefield", "time", "sin", "color", "pi", "atan", "cos", "shader", "distance", "smoothstep", "tan", "radius", "change", "angles"], "likes": 0, "viewed": 243, "published": 3, "date": "1610803046", "time_retrieved": "2024-07-30T19:44:51.205350", "image_code": "\n// Circles and distance fields \n// Reference to The book of shader \n// http://thndl.com/square-shaped-shaders.html\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = fragCoord.xy/iResolution.xy;\n  st.x *= iResolution.x/iResolution.y;\n  vec3 color = vec3(0.844*cos(iTime),0.980*sin(iTime),0.000*tan(iTime));\n  float d = 0.5;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n    // int change = int(abs(u_time)/1000.);\n  // Number of sides of your shape\n  int N = 5;\n  \n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n\n  // Shaping function that modulate the distance\n  d = cos(floor(0.5+a/r)*r-a)*length(st)*min(distance(st,vec2(1.000,1.000)*sin(iTime)),distance(st,vec2(-1.,-1.)*sin(iTime)));\n// pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n\n  color = vec3((smoothstep(0.208,-0.030,d/2.))*color);\n  // color = vec3(d);\n\n  fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 230, 230, 1005]], "test": "untested"}
{"id": "ttGcDz", "name": "Eye Eye", "author": "YitingLiu", "description": "Do you see the eye? Try using your mouse. ", "tags": ["mouse", "interactive", "eye", "orange", "shader", "heartbeat", "pulsing", "meditative"], "likes": 0, "viewed": 302, "published": 3, "date": "1610801014", "time_retrieved": "2024-07-30T19:44:52.135862", "image_code": "// Inspiration - Book of Shader - Circles \n// Based on the code by Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    vec2 st_mouse =fragCoord.xy/iMouse.xy;\n  \n    float pct = 0.0;\n    float pulse = abs(sin(iTime));\n    vec3 color = vec3(0.845,0.620*pulse,0.014);\n    \n    color= vec3(color*pulse);\n\n    // a. The DISTANCE from the pixel to the center\n    pct = smoothstep(max(distance(st,vec2(0.2)),distance(st,vec2(0.8))),pulse/2.,pulse/4.)-\n        smoothstep(distance(st,vec2(0.480,0.490)) * distance(st,vec2(st_mouse)-vec2(0.5)),pulse/3.,pulse/4.5);\n\n    // pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // pct = distance(st,vec2(0.4)) + distance(st,vec2(0.6));\n    // pct = distance(st,vec2(0.4)) * distance(st,vec2(0.6));\n    // pct = min(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // pct = max(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // pct = pow(distance(st,vec2(0.4)),distance(st,vec2(0.6)));\n    // b. The LENGTH of the vector\n    //    from the pixel to the center\n    // vec2 toCenter = vec2(0.5)-st;\n    // pct = length(toCenter);\n\n    // c. The SQUARE ROOT of the vector\n    //    from the pixel to the center\n    // vec2 tC = vec2(0.5)-st;\n    // pct = sqrt(tC.x*tC.x+tC.y*tC.y);\n\n    color = vec3(pct*color);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 188, 188, 1436]], "test": "untested"}
{"id": "WtycDz", "name": "Columns of Atlantis", "author": "xavierseb", "description": "Another interesting find, a fantasy.\nUse mouse click to move a roound. \nThanks again to the unknown OP who did this-> http://glslsandbox.com/e#70315.0", "tags": ["3d", "geometric"], "likes": 1, "viewed": 254, "published": 3, "date": "1610766252", "time_retrieved": "2024-07-30T19:44:53.015510", "image_code": "// explore the submerged columns, ruins of atlantis derived from \n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI  3.14159\n\nfloat map(vec3 p, mat2 m, mat2 n) {\n\tfloat k;\n\tp.xy *= m;\n\tp.yz *= n;\n\tfor (int i = 0; i < 9; i++) {\n\t\tk = length(p.xy);\n\t\tp.x = k * (mod(atan(p.y, p.x), PI/4.) - PI/8.);\t\t\t\t\n\t\tp.y = k - 2.759;\t\t\n\t\tk = length(p.yz);\n\t\tp.y = k * (mod(atan(p.z, p.y), PI/9.5) - PI/19.);\n\t\tp.z = k - 10.0;\n\t}\n\t\n\treturn dot(abs(p), normalize(vec3(-3.9,5,1.2))) - .886 ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse=iMouse.xy/iResolution.xy;\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1));\n\tfloat v=-8.*mod(iTime/266.,PI*2.), u=mouse.x;\n\tvec3 p = vec3(0, 10.4+mouse.y*3., -6.);\n\tmat2 m = rot(u), n=rot(v);\n\tfragColor = vec4(0,0,.07,1);\n\t\n\tfor (int i = 1; i < 60; i++) {\n\t\tfloat d = map(p, m, n);\t\t\t\n\t\tp += rd * d;\n\t\tif (d < 0.001) {\n\t\t\tfragColor = vec4( 8,10,4.,1)/float(i);\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtycDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 175, 175, 490], [492, 492, 549, 549, 1001]], "test": "untested"}
{"id": "WlGcWz", "name": "Mausoleum of The Kings", "author": "xavierseb", "description": "3D scene, found by accident and tweaked a bit.\nThanks to  the unknown person from which this was derived. link at http://glslsandbox.com/e#70315.0", "tags": ["3d", "scene", "geometric"], "likes": 3, "viewed": 253, "published": 3, "date": "1610758493", "time_retrieved": "2024-07-30T19:44:53.838310", "image_code": "// started from http://glslsandbox.com/e#70315.0 , thanks to the person who posted the original shader\n// \n#define PI 3.14159\n\nfloat map(vec3 p, mat2 m, float d) {\n\tfloat k;\n\tp.yz *= m;\n\tfor (int i = 0; i < 6; i++) {\n\t\tk = length(p.xy);\n\t\tp.x = k * (mod(atan(p.y, p.x), PI/4.) - PI/8.);\t\t\t\t\t\n\t\tp.y = k - 8.0305;\t\t\n\t\tk = length(p.yz);\t\t\t\t\n\t\tp.y = k * (abs(sin(atan(p.z, p.y))) - .37);\t\t\t\t\n\t\tp.z = k - 9.8 +d; \n\t}\n\t\n\treturn dot(abs(p), normalize(vec3(6.9,3.6,6.2))) - 1.591;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n\tfloat v = .8 - PI*sin(mod(iTime/15.,PI/2.)), dd= .22*clamp(6.*cos(v+.75),-.5,.5);\n\tmat2 m  = mat2(cos(v),sin(v),-sin(v),cos(v));\n\tvec3 rd = normalize(vec3(uv, 1)),  \n         p  = vec3( iMouse.x/iResolution.x*2.-1., 14.-6.*abs(sin(v+.4)), -6.3);\n    fragColor=vec4(0);\n\tfor (int i = 1; i < 160; i++) {\n\t\tfloat d = map(p,m,dd); \t\t\t\t\n\t\tp += rd * d;\n\t\tif (d < 0.001) {\n\t\t\tfloat gl= (1.-smoothstep(0.,.75,distance(p,vec3(0,6.95,13.+16.8*sin(v+.74)))))*(1.+sin(iTime*10.)); // glow factor\n\t\t\tfragColor = vec4( 6,6,5,6)/float(i)  +  vec4( gl*gl*gl*.86,gl*.5,gl*gl*.75,1.);\t// stone + glow\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 163, 163, 474], [476, 476, 533, 533, 1198]], "test": "untested"}
{"id": "tttcWX", "name": "Snow[Explorable]", "author": "public_int_i", "description": "Procedural fractal snowflakes combined to make snow, explore the scene using mouse drag + WASD/arrow keys.", "tags": ["3d", "ray", "traced", "snow", "path", "marched", "pathtraced", "explorable"], "likes": 4, "viewed": 435, "published": 3, "date": "1610741529", "time_retrieved": "2024-07-30T19:44:54.636176", "image_code": "/*Ethan Alexander Shulman January 4, 2021 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=cqbmMml6Oe0\n4k wallpaper xaloez.com/art/2021/Snow.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = pow(c/c.w,vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*Buffer A stores dynamic camera position and rotation.\n\n0 = camera position(xyz), w = 1 frame of camera change\n1 = camera yaw/pitch(xy) and last mouse position(zw)\n*/\n\n#define MOUSE_SENSITIVITY 2.\n\n#define MOVEMENT_SPEED 5.\n\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 1.) {\n        vec4 rot = texelFetch(iChannel0,ivec2(1,0),0);\n        float camChanged = (iMouse.z > 0. && iMouse.w < 1.)?\n                            (length(rot.zw-iMouse.xy)>0.?1.:0.):\n                            0.;\n        \n        if (fragCoord.x < 1.) {\n            //camera position\n            vec3 pos = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (iFrame == 0) pos = vec3(0,0,-70);//default position\n            \n            #define kb(i) texelFetch(iChannel1,ivec2(i,0),0).x\n            \n            //left/right/A/D arrows\n            float right = max(kb(39),kb(68))-max(kb(37),kb(65));\n            if (right != 0.) {\n                vec3 rt = vec3(right*iTimeDelta*MOVEMENT_SPEED,0,0);\n                rt.yz *= r2(rot.y);\n                rt.xz *= r2(rot.x);\n                pos += rt;\n                camChanged = 1.;\n            }\n            \n            //space key\n            if (kb(32) > 0.) {\n                vec3 up = vec3(0,iTimeDelta*MOVEMENT_SPEED,0);\n                up.yz *= r2(rot.y);\n                up.xz *= r2(rot.x);\n                pos += up;\n                camChanged = 1.;\n            }\n            \n            //up/down/W/S arrows\n            float forward = max(kb(38),kb(87))-max(kb(40),kb(83));\n            if (forward != 0.) {\n                vec3 fwd = vec3(0,0,forward*iTimeDelta*MOVEMENT_SPEED);\n                fwd.yz *= r2(rot.y);\n                fwd.xz *= r2(rot.x);\n                pos += fwd;\n                camChanged = 1.;\n            }\n            \n            fragColor = vec4(pos,camChanged);\n        } else {\n            //camera rotation\n            if (iFrame == 0) rot = vec4(0);\n            \n            //rotate on mouse drag\n            if (iMouse.z > 0. && iMouse.w < 1.) {\n                rot.xy -= (iMouse.xy-rot.zw)/iResolution.y*MOUSE_SENSITIVITY;\n            }\n            fragColor = vec4(rot.xy,iMouse.xy);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*Ethan Alexander Shulman January 4, 2021 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=cqbmMml6Oe0\n4k wallpaper xaloez.com/art/2021/Snow.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\n#define time iTime\n#define frame iFrame\n\n#define FIELD_OF_VIEW 1.\n\n#define HAS_OPACITY 1\n\n#define STEPS 60\n#define EPS 1e-2\n#define REFRACTION_SKIP 5.\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat2x3 tangentBinormal(vec3 norm) {\n\tmat2x3 t;\n\tif (abs(norm.x) > abs(norm.y)) t[0] = normalize(vec3(-norm.z,0,norm.x));\n\telse t[0] = normalize(vec3(0,norm.z,-norm.y)); \n\tt[1] = cross(norm,t[0]);\n\treturn t;\n}\n\n//Credit: IQ, integer hash 2 https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\treturn 1.-abs(fract(x)-.5)*2.;\n}\n\nfloat nsampling;\n\n//volumetric opacity\n#define START_OPACITY(posSeed) vec3 opacityRand = hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7))\n#define OPACITY(dst,skip,alpha,anisotropy) max(dst,-1e3+(skip+1e3)*step(alpha+nsampling*anisotropy,opacityRand.x))\n\nfloat snowflake(vec3 p, float size, float sep, float szStep, float width, float twist, int branchs) {\n\tvec2 ap = abs(p.xy);\n\tfloat sz = size, d = 1e8;\n\tfor (int i = 0; i < branchs; i++) {\n\t\td = min(d,min(max(ap.x,ap.y-sz),max(ap.y,ap.x-sz))-sz*width);\n\t\tap = abs((ap-sz*sep)*r2(twist));\n\t\tsz *= szStep;\n\t}\n\treturn max(d,abs(abs(p.z)+d*.2)*.98);\n}\n\nfloat geometry(vec3 p) {\n\n\t//snowflake\n\tvec3 rp = mod(abs(p),.1)-.05;\n\tuvec3 fp = uvec3(floor(p/.1+1000.));\n\tvec3 r0 = hash(fp);\n\tr0.x = .2+r0.x*.6;\n\trp.yz *= r2(fract(r0.x*127.)*PI*2.);\n\t//rp.xz *= r2(fract(r0.x*127.)*PI*2.);\n\treturn max(snowflake(rp,.05, r0.x,r0.x*(.5+r0.y), .2, r0.z ,2),length(p)-50.);\n}\n    \n//chromatic separation dither\n#define START_CHROMA(posSeed) float chromaFrame = float(fract(hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7)).x)*3.)\n#define CHROMA(mat,rc,gc,bc) if (chromaFrame < 1.) {mat[0]*=vec3(3,0,0);rc;}\\\nelse if (chromaFrame < 2.) {mat[0]*=vec3(0,3,0);gc;}\\\nelse {mat[0]*=vec3(0,0,3);bc;}\n\n/*mat[0] = color\nmat[1].x = forward roughness, mat[1].y = emission, mat[1].z = backward roughness\nmat[2].x = opacity, mat[2].y = refraction index\n*/\nmat3 material(vec3 p) {\n\tmat3 m = mat3(vec3(.88), vec3(1e-4,0.,1e-4), vec3(.3,1.3,0.));//1.517,0.));\n\t//START_CHROMA(p);\n\t//CHROMA(m, m[2].y=1.3, m[2].y=1.25, m[2].y=1.35);\n\treturn m;\n}\nvec3 normal(vec3 p) {\n\t#define NEPS vec3(EPS,0,0)\n\tnsampling = 1.;\n\tvec3 n = normalize(vec3(geometry(p+NEPS),geometry(p+NEPS.yxz),geometry(p+NEPS.yzx))-geometry(p));\n\tnsampling = 0.;\n\treturn n!=n?vec3(0,1,0):n;\n}\n\nvec3 background(vec3 rp, vec3 rd) {\n\treturn vec3(.2,.4,.7)*(.1+max(0.,rd.y)*.9)+vec3(5)*max(0.,1.-length(rd-vec3(0,1,0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 camPos = texelFetch(iChannel1,ivec2(0),0);\n   \n\tvec3 rp = camPos.xyz,//camera position\n\t\trd = normalize(vec3(uv.xy+(hash(uvec3(fragCoord,frame)).xy*4.-2.)/iResolution.y,FIELD_OF_VIEW)),\n\t\tc = vec3(1);\n\t\n\t//camera rotation\n    vec2 camRot = texelFetch(iChannel1,ivec2(1,0),0).xy;\n\trd.yz *= r2(camRot.y);\n   \trd.xz *= r2(camRot.x);\n\n\tfloat l = 0.;\n\tint i;\n\tbool flipRefraction = false;\n\tnsampling = 0.;\n\tfor (i = 0; i < STEPS; i++) {\n\t\tfloat dst = geometry(rp);\n\t\tif (dst <= EPS) {\n\t\t\tmat3 mat = material(rp);\n\t\t\tl += mat[1].y;\n\t\t\tc *= mat[0];\n\t\t\t\n\t\t\trp -= rd*(EPS*2.-dst);\n\t\t\tvec3 nrm = normal(rp);\n\t\t\tmat2x3 tangBinorm = tangentBinormal(nrm);\n\t\t\t\n\t\t\tvec3 rnd = hash(uvec3(abs(rp)*1000.)+uvec3(frame,frame*3,frame*7));\n\t\t\tfloat ct = pow(rnd.x,flipRefraction?mat[1].z:mat[1].x),\n\t\t\t\tst = sqrt(1.-ct*ct),\n\t\t\t\tpt = rnd.y*PI*2.;\n\t\t\tvec3 surf = normalize(nrm*ct+tangBinorm[0]*(st*cos(pt))+tangBinorm[1]*(st*sin(pt)));\n\t\t\t#if HAS_OPACITY\n\t\t\tif (mat[2].x < rnd.z) {\n\t\t\t\trp += rd*(EPS*2.-dst);\n\t\t\t\trd = refract(rd,surf,flipRefraction?mat[2].y:1./mat[2].y);\n\t\t\t\tdst = EPS*REFRACTION_SKIP*(1.+rnd.z);\n\t\t\t\tflipRefraction = !flipRefraction;\n\t\t\t} else {\n\t\t\t#endif\n\t\t\t\trd = reflect(rd,surf);\n\t\t\t\tdst = 0.;\n\t\t\t#if HAS_OPACITY\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t\trp += rd*dst;\n\t}\n\t\n\t//background + final lighting\n\tc = min(c,vec3(10.));\n\tc *= l+background(rp,rd);\n    fragColor = (camPos.w>.5?vec4(0):texelFetch(iChannel0,ivec2(fragCoord),0))+vec4(c,1)*1e-2;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttcWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 272, 272, 370]], "test": "untested"}
{"id": "tlKczm", "name": "Cloud [Explorable]", "author": "public_int_i", "description": "Explore the scene using mouse drag + WASD/arrow keys.", "tags": ["3d", "ray", "volume", "march", "trace", "path", "explore"], "likes": 1, "viewed": 284, "published": 3, "date": "1610741518", "time_retrieved": "2024-07-30T19:44:55.407115", "image_code": "/*Ethan Alexander Shulman January 7, 2021 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=9M18q0ohwtg \n4k wallpaper xaloez.com/art/2021/Cloud.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = pow(c/c.w,vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*Buffer A stores dynamic camera position and rotation.\n\n0 = camera position(xyz), w = 1 frame of camera change\n1 = camera yaw/pitch(xy) and last mouse position(zw)\n*/\n\n#define MOUSE_SENSITIVITY 2.\n\n#define MOVEMENT_SPEED 5.\n\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 1.) {\n        vec4 rot = texelFetch(iChannel0,ivec2(1,0),0);\n        float camChanged = (iMouse.z > 0. && iMouse.w < 1.)?\n                            (length(rot.zw-iMouse.xy)>0.?1.:0.):\n                            0.;\n        \n        if (fragCoord.x < 1.) {\n            //camera position\n            vec3 pos = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (iFrame == 0) pos = vec3(0,0,-4);//default position\n            \n            #define kb(i) texelFetch(iChannel1,ivec2(i,0),0).x\n            \n            //left/right/A/D arrows\n            float right = max(kb(39),kb(68))-max(kb(37),kb(65));\n            if (right != 0.) {\n                vec3 rt = vec3(right*iTimeDelta*MOVEMENT_SPEED,0,0);\n                rt.yz *= r2(rot.y);\n                rt.xz *= r2(rot.x);\n                pos += rt;\n                camChanged = 1.;\n            }\n            \n            //space key\n            if (kb(32) > 0.) {\n                vec3 up = vec3(0,iTimeDelta*MOVEMENT_SPEED,0);\n                up.yz *= r2(rot.y);\n                up.xz *= r2(rot.x);\n                pos += up;\n                camChanged = 1.;\n            }\n            \n            //up/down/W/S arrows\n            float forward = max(kb(38),kb(87))-max(kb(40),kb(83));\n            if (forward != 0.) {\n                vec3 fwd = vec3(0,0,forward*iTimeDelta*MOVEMENT_SPEED);\n                fwd.yz *= r2(rot.y);\n                fwd.xz *= r2(rot.x);\n                pos += fwd;\n                camChanged = 1.;\n            }\n            \n            fragColor = vec4(pos,camChanged);\n        } else {\n            //camera rotation\n            if (iFrame == 0) rot = vec4(0);\n            \n            //rotate on mouse drag\n            if (iMouse.z > 0. && iMouse.w < 1.) {\n                rot.xy -= (iMouse.xy-rot.zw)/iResolution.y*MOUSE_SENSITIVITY;\n            }\n            fragColor = vec4(rot.xy,iMouse.xy);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*Ethan Alexander Shulman January 7, 2021 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=9M18q0ohwtg \n4k wallpaper xaloez.com/art/2021/Cloud.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\n#define time iTime\n#define frame iFrame\n\n#define FIELD_OF_VIEW 1.\n\n#define HAS_OPACITY 1\n\n#define STEPS 60\n#define EPS 1e-2\n#define REFRACTION_SKIP 5.\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat2x3 tangentBinormal(vec3 norm) {\n\tmat2x3 t;\n\tif (abs(norm.x) > abs(norm.y)) t[0] = normalize(vec3(-norm.z,0,norm.x));\n\telse t[0] = normalize(vec3(0,norm.z,-norm.y)); \n\tt[1] = cross(norm,t[0]);\n\treturn t;\n}\n\n//Credit: IQ, integer hash 2 https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\treturn 1.-abs(fract(x)-.5)*2.;\n}\n\nfloat nsampling;\n\n//volumetric opacity via distance dithering\n#define START_VOLUME(posSeed) vec3 opacityRand = hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7))\n#define VOLUME(dst,skip,alpha,anisotropy) max(dst,-1e3+(skip*(.5+opacityRand.y)+1e3)*step(alpha+nsampling*anisotropy,opacityRand.x))\n\nfloat geometry(vec3 p) {\n\tfloat d = abs(length(p)-2.)-.7;//sphere base shape\n\t\n\t//cloud distortion\n\td += twave(length(p-vec3(-4.81, 9.58, 5.85))*1.21)*.24;\n\td += twave(length(p-vec3(-8.82, -1.95, 6.94))*.98)*.21;\n\td += twave(length(p-vec3(2.69, 3.32, 7.48))*4.98)*.1;\n\td += twave(length(p-vec3(6.71, -6.07, -0.94))*6.36)*.08;\n\td += twave(length(p-vec3(-3.42, 7.45, 9.32))*5.042)*.1;\n\t\n\t//volume dither\n\tSTART_VOLUME(p);\n\treturn VOLUME(d, .03, .1, 1.);\n}\n\n    \n//chromatic separation dither\n#define START_CHROMA(posSeed) float chromaFrame = float(fract(hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7)).x)*3.)\n#define CHROMA(mat,rc,gc,bc) if (chromaFrame < 1.) {mat[0]*=vec3(3,0,0);rc;}\\\nelse if (chromaFrame < 2.) {mat[0]*=vec3(0,3,0);gc;}\\\nelse {mat[0]*=vec3(0,0,3);bc;}\n\n/*mat[0] = color\nmat[1].x = forward roughness, mat[1].y = emission, mat[1].z = backward roughness\nmat[2].x = opacity, mat[2].y = refraction index\n*/\nmat3 material(vec3 p) {\n\tmat3 m = mat3(vec3(.88), vec3(1e-4,0.,1e-4), vec3(.3,1.3,0.));//1.517,0.));\n\t//START_CHROMA(p);\n\t//CHROMA(m, m[2].y=1.3, m[2].y=1.25, m[2].y=1.35);\n\treturn m;\n}\nvec3 normal(vec3 p) {\n\t#define NEPS vec3(EPS,0,0)\n\tnsampling = 1.;\n\tvec3 n = normalize(vec3(geometry(p+NEPS),geometry(p+NEPS.yxz),geometry(p+NEPS.yzx))-geometry(p));\n\tnsampling = 0.;\n\treturn n!=n?vec3(0,1,0):n;\n}\n\nvec3 background(vec3 rp, vec3 rd) {\n\treturn mix(vec3(.00013,.00014,.00012),vec3(.001,.002,.006),clamp(rd.y*10.,0.,1.))+\n\t\t\tvec3(1.,.85,.6)*10.*max(0.,1.-length(rd-vec3(0,.3,.2)))*max(0.,rd.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 camPos = texelFetch(iChannel1,ivec2(0),0);\n   \n\tvec3 rp = camPos.xyz,//camera position\n\t\trd = normalize(vec3(uv.xy+(hash(uvec3(fragCoord,frame)).xy*4.-2.)/iResolution.y,FIELD_OF_VIEW)),\n\t\tc = vec3(1);\n\t\n\t//camera rotation\n    vec2 camRot = texelFetch(iChannel1,ivec2(1,0),0).xy;\n\trd.yz *= r2(camRot.y);\n   \trd.xz *= r2(camRot.x);\n\n\tfloat l = 0.;\n\tint i;\n\tbool flipRefraction = false;\n\tnsampling = 0.;\n\tfor (i = 0; i < STEPS; i++) {\n\t\tfloat dst = geometry(rp);\n\t\tif (dst <= EPS) {\n\t\t\tmat3 mat = material(rp);\n\t\t\tl += mat[1].y;\n\t\t\tc *= mat[0];\n\t\t\t\n\t\t\trp -= rd*(EPS*2.-dst);\n\t\t\tvec3 nrm = normal(rp);\n\t\t\tmat2x3 tangBinorm = tangentBinormal(nrm);\n\t\t\t\n\t\t\tvec3 rnd = hash(uvec3(abs(rp)*1000.)+uvec3(frame,frame*3,frame*7));\n\t\t\tfloat ct = pow(rnd.x,flipRefraction?mat[1].z:mat[1].x),\n\t\t\t\tst = sqrt(1.-ct*ct),\n\t\t\t\tpt = rnd.y*PI*2.;\n\t\t\tvec3 surf = normalize(nrm*ct+tangBinorm[0]*(st*cos(pt))+tangBinorm[1]*(st*sin(pt)));\n\t\t\t#if HAS_OPACITY\n\t\t\tif (mat[2].x < rnd.z) {\n\t\t\t\trp += rd*(EPS*2.-dst);\n\t\t\t\trd = refract(rd,surf,flipRefraction?mat[2].y:1./mat[2].y);\n\t\t\t\tdst = EPS*REFRACTION_SKIP*(1.+rnd.z);\n\t\t\t\tflipRefraction = !flipRefraction;\n\t\t\t} else {\n\t\t\t#endif\n\t\t\t\trd = reflect(rd,surf);\n\t\t\t\tdst = 0.;\n\t\t\t#if HAS_OPACITY\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t\trp += rd*dst;\n        \n        if (length(rp) > 3.) break;\n\t}\n\t\n\t//background + final lighting\n\tc = min(c,vec3(10.));\n\tc *= l+background(rp,rd);\n    fragColor = (camPos.w>.5?vec4(0):texelFetch(iChannel0,ivec2(fragCoord),0))+vec4(c,1)*1e-2;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 274, 274, 372]], "test": "untested"}
{"id": "wtKczm", "name": "2D Caustics - Denoised (GI)", "author": "darkeclipz", "description": "CONTROLS: Hold down the left mouse button to move the light source(s)! \nIf the button is pressed, it will denoise a bit quicker, however this adds some more noise.\nSee the end of BufB.\n\nVariant of previous shader: https://www.shadertoy.com/view/ttVyzw\n\n", "tags": ["2d", "reflection", "gi", "caustics"], "likes": 6, "viewed": 741, "published": 3, "date": "1610740515", "time_retrieved": "2024-07-30T19:44:56.311697", "image_code": "#define R iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution.xy\n#define AA 2.\n#define PI 3.14159265359\n#define LIGHT_SAMPLES 3.\n#define LDOWN (iMouse.z > 0.)\n#define RDOWN (iMouse.w > 0.)\n\nstruct material {\n    vec3 diffuse;\n    vec3 emissive;\n    bool light;\n    float intensity;\n};\n\nmaterial[] materials = material[] (\n    material(vec3(0.9), vec3(1), false, 0.),\n    material(vec3(0.4,0.4,1), vec3(.4, .4, 1), true, 2.5),\n    material(vec3(0.4,0.4,1), vec3(1,.4,.4), true, 2.5),\n    material(vec3(1), vec3(0.9), false, 0.)\n);\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 r = abs(p) - b;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat2 rot(float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb ) {\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCuttedBox(vec2 p) {\n    float d = sdBox(p, vec2(0.3)) - 0.02;\n    float c = sdCircle(abs(p) - vec2(0.28, 0.28), 0.24);\n    d = max(d, -c);\n    return d;\n}\n\nint id = 0;\nfloat lastMapValue = 0.;\n\nfloat map(vec2 p) {\n    id = 0;\n    float t = iTime / 20.;\n    float ljs = 0.6; // lissajous size for lights\n    \n    // Cutted box\n    float size = 1.1;\n    vec2 modp = mod(1.1*p, 1.0) - 0.5;\n    float d = sdCuttedBox(rot(PI/4.)*size*p) / size;\n    \n    // Mouse\n    vec2 lightPos = vec2(0.55,0);\n    if(LDOWN) lightPos = (2.*iMouse.xy-R)/R.y;\n\n    // Light 1\n    float circle = sdCircle(p - lightPos, 0.1);\n    if(circle < d) {\n        id = 1;\n    }\n    d = min(d, circle);\n    \n    // Light 2\n    float circle2 = sdCircle(p + lightPos, 0.1);\n    if(circle2 < d) {\n        id = 2;\n    }\n    d = min(d, circle2);\n    \n    // Horse shoe\n    vec2 absX = p;\n    absX.x = abs(absX.x);\n    absX.x = -absX.x;\n    \n    float a = PI/2.;\n    float b = -0.6;\n    vec2 ra = vec2(cos(a), sin(a));\n    vec2 rb = vec2(cos(b), sin(b));\n    float arc = sdArc(absX - vec2(-0.5*R.x/R.y + 0.1, 0), ra, rb, 0.8, 0.05);\n    if(arc < d) {\n        id = 0;\n    }\n    d = min(d, arc);\n    \n    lastMapValue = d;\n    return d;\n}\n\nvec2 normal(vec2 p) {\n    vec2 e = vec2(0.00001, 0);\n    float x = lastMapValue;\n    return normalize(vec2(map(p+e.xy)-x,\n                          map(p+e.yx)-x));\n}\n\nfloat trace(vec2 ro, vec2 rd) {\n    float t = 0.0;\n    for(float i=0.; i<60.; i++) {\n        vec2 p = ro + t * rd;\n        float d = map(p);\n        if(d < 0.0001) {\n            break;\n        }\n        t += d;\n        if(t > 20.) {\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 sampleScene(vec2 ro) {\n    vec3 fcol = vec3(0);\n    \n    for(float i=0.; i < LIGHT_SAMPLES; i++) {\n    \n        float r = (random(ro + i) + i + fract(iTime)) / LIGHT_SAMPLES * PI * 2.0;\n\n        vec2 rd = vec2(cos(r), sin(r));\n        float t = trace(ro, rd);\n        vec3 col = vec3(0.);\n        \n        if(t < 20.) {\n            vec2 p = ro + t * rd;\n            \n            if(materials[id].light) {\n                // hit a light\n                col = materials[id].emissive * materials[id].intensity;\n            }\n            else {\n                if(t < 0.0001) {\n                    // inside object (not light)\n                    col = texture(iChannel0, ro * 1.2).rrr;\n                }\n                else {\n                    // hit object; calculate reflection\n                    vec2 nor = normal(p);\n                    vec2 refl = reflect(rd, nor);\n                    int matId = id;\n                    float k = trace(p + refl * 0.001, refl);\n                    if(k < 20.) {\n                        // hit light\n                        if(materials[id].light) {\n                            col = materials[id].emissive * materials[id].intensity * materials[matId].diffuse;\n                        }\n                        else {\n                            // hit material; calculate second reflection\n                            vec2 p2 = p + refl*0.001 + k*refl;\n                            nor = normal(p2);\n                            refl = reflect(refl, nor);\n                            int matId2 = id;\n                            float j = trace(p + refl * 0.001, refl);\n                            if(j < 20. && materials[id].light) {\n                                // hit light\n                                col = materials[id].emissive * materials[id].intensity \n                                                             * materials[matId2].diffuse\n                                                             * materials[matId].diffuse;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else col = vec3(0.3); // ambient\n        fcol += col;\n    }\n    \n    return fcol / LIGHT_SAMPLES;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fcol = vec3(0);\n    vec2 npos = (2.*fragCoord-R)/R.y;\n    float randSeed = fract(float(iTime) / 30.);\n    float stratSize = 1. / AA;\n    for(float aax = 0.; aax < AA; aax++)\n    for(float aay = 0.; aay < AA; aay++) {\n        vec2 strat = vec2(aax, aay) * stratSize;\n        vec2 jitter = vec2(random(npos + 4.1252 + aax + randSeed), \n                           random(npos + 1.3483 + aay + randSeed)) * stratSize;\n        vec2 uv = (2.*fragCoord + strat + jitter - R)/R.y;\n        vec3 col = sampleScene(uv);\n        fcol += col;\n    }\n    \n    fcol /= AA*AA;\n    vec4 buffer = texture(iChannel1, fragCoord/R);\n    float denoise = LDOWN ? 0.98 : 0.995; // denoise speed\n    fragColor = vec4(denoise*buffer.rgb + (1.-denoise)*fcol,1.0);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 133, 297]], "test": "untested"}
{"id": "3d3XW8", "name": "volumetric sphere marching", "author": "Angramme", "description": "hahahahah", "tags": ["raymarching", "pebbles", "everywhere"], "likes": 0, "viewed": 259, "published": 3, "date": "1610735890", "time_retrieved": "2024-07-30T19:44:57.086625", "image_code": "#define MIN_DIST .0001\n#define MAX_DIST 200.\n#define MAX_STEPS 800\n#define STEP_REDUCE .08\n\n\nfloat volume(vec3 p){\n    return smoothstep(.2, 1., textureLod(iChannel0, p, 0.).r);\n    /*float m = 1.;\n    for(float i=0.; i<9.; i++){\n        m = min(m,\n          textureLod(iChannel0, \n             .01*(p + vec3(\n                mod(i, 3.),\n                mod(floor(i/3.), 3.),\n                floor(i/9.))-1.),\n             0.).r);\n    }\n    return m;*/\n}\n\nfloat dist(vec3 p){\n    float plane = p.y + 1.;\n    float sphere = distance(p, vec3(0,sin(iTime)*.5,0))- .5 + volume(p*.4)*.8;\n    return min(plane, sphere*STEP_REDUCE);\n}\n\nvec3 normal(vec3 p){\n    vec2 eps = vec2(.001, 0);\n    return (vec3(\n        dist(p+eps.xyy),\n        dist(p+eps.yxy),\n        dist(p+eps.yyx)\n        ) - dist(p))/eps.x;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float d0 = 0.;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*d0;\n        float d = dist(p);\n        d0 += d;\n        if(d0 > MAX_DIST || abs(d) < MIN_DIST)break;\n    }\n    return d0;\n}\n\nfloat shadow(vec3 p, vec3 L, float ld, float k){\n    float d0 = 0.;\n    float sh = 1.;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = p + L*d0;\n        float d = dist(p);\n        if(d < MIN_DIST)return 0.;\n        sh = min(sh, d*k/d0);\n        d0 += d;\n    }\n    return sh;\n}\n\nvec3 sky(vec3 rd){\n    float v = mix(.1, .9, smoothstep(1., 0., rd.y));\n    return vec3(v,v,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n\n    vec3 col = vec3(0);\n    \n    float s = sin(iTime*.3);\n    float c = cos(iTime*.3);\n    \n    vec3 ro = vec3(c*5.,0,s*5.);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    rd.xz *= mat2(-s, -c, c, -s);\n    \n    float d = trace(ro, rd);\n    \n    if(d<MAX_DIST){\n\n        vec3 p = ro + rd*d;\n        vec3 n = normal(p);\n\n        //directional light\n        const vec3 L = normalize(vec3(1,.8,-1));\n        const vec3 lc = vec3(1,.95,.95);\n\n        //shadow\n        //float sh = shadow(p+n*MIN_DIST*2., L, 999., 8.);\n\t\t//float sh = 1.;\n        float sh = trace(p+n*MIN_DIST*4., L) > MAX_DIST ? 1. : 0.;\n        \n        //diffuse\n        col += max(0.,dot(L, n)) * sh * lc;\n        \n        //specular\n        col += pow(max(0.,dot(reflect(L, n), rd)), 8.) * sh * lc * .2;\n        \n        //sky\n        col += max(0.,dot(n,vec3(0,1,0))) * vec3(.1,.1,.8) * .1;\n\t\t\n    }else{\n        col = sky(rd);\n    }\n    \n    //gamma correction\n    const float gamma = 2.2;\n    col = pow(col, vec3(gamma));\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3XW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 114, 114, 454], [456, 456, 475, 475, 627], [629, 629, 649, 649, 801], [803, 803, 833, 833, 1037], [1039, 1039, 1087, 1087, 1320], [1322, 1322, 1340, 1340, 1420], [1422, 1422, 1479, 1479, 2572]], "test": "untested"}
{"id": "tsKXzW", "name": "mandelbrot glsl", "author": "Angramme", "description": "fff", "tags": ["mandelbrot"], "likes": 1, "viewed": 471, "published": 3, "date": "1610735770", "time_retrieved": "2024-07-30T19:44:57.868534", "image_code": "#define IT 800. //iterations\n\nfloat log10(float x){\n    //log10(x) = log(x) / log(10) = (1 / log(10)) * log(x)\n    const float d = 1. / log(10.);\n    return d * log(x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    float zoom = pow(iTime*.1, 5.);\n    \n    uv *= 4.;\n    uv /= 1. + zoom;\n    uv -= vec2(.7394, -.24215);\n    \n    float cr = uv.x;\n    float ci = uv.y;\n    \n    \n    /*\n    uv *= 4.5;\n    uv += vec2(0., .7);\n    \n    float cr = -uv.y;\n    float ci = uv.x;\n    */\n    \n    vec3 color = vec3(0);\n    \n\tfloat zr = 0.;\n    float zi = 0.;\n    \n    //last escaped complex module value\n    float zn_abs = 0.;\n    \n    float n = 0.;\n    while(n < IT){\n        float fr = zr*zr - zi*zi + cr;\n        float fi = 2.*zr*zi + ci;\n        \n        zr = fr;\n        zi = fi;\n        \n        if(abs(fr)+abs(fi) > 500.){\n            zn_abs = sqrt(fr*fr + fi*fi);\n            break;\n        }\n        \n        n++;\n    }\n    \n    if(n == IT){\n    \t//color += .5;\n    }else{\n    \t//color += mix(vec3(0,0,0), vec3(0,2,2), n / IT *mix(8., 1., iTime*.02));\n        //color += vec3(0, 1, 1) * log10(n) * .4;\n        //color += vec3(0, 1, 1) * pow(n/IT, .5f);\n        \n        //color += 1.;\n   \n        //color += n/IT*20.;\n        \n        //smooth n\n        float ns = n + 1. - log(log(zn_abs))/log(2.);\n        //color += fract(ns*10./IT)*3.;\n        color += hsv2rgb(vec3(fract(ns*10./IT)+3.7 +iTime*.03, .7, 1.));\n    }\n   \t\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 51, 110, 170], [172, 172, 194, 194, 363], [365, 365, 422, 422, 1732]], "test": "untested"}
{"id": "3tt3Rj", "name": "global illumination", "author": "Angramme", "description": "ff", "tags": ["raymarching"], "likes": 6, "viewed": 524, "published": 3, "date": "1610735693", "time_retrieved": "2024-07-30T19:44:58.632492", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_D 200.\n#define denoise_amount .95\n\nvec3 R3(vec3 p, float t){\n    return textureLod(iChannel0, p*113.395 + t*vec3(38.15, 85.41, 95.), 0.).rgb*2.-1.;\n}\n\n\nfloat dist(vec3 p){\n    float sphere = distance(p, vec3(0, 0, 7)) -1.;\n    float sphere2 = distance(p, vec3(.9, .4, 6.2)) - .5;\n    float plane = p.y+1.;\n    return min(plane,min(sphere,sphere2));\n}\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<200; i++){\n        vec3 p = ro + rd*t;\n        float d = dist(p);\n        if(d<.001 || t > MAX_D)break;\n        t += d;\n    }\n    return t;\n}\nvec3 normal(vec3 p){\n    vec2 eps = vec2(.001, 0);\n    return (vec3(\n        dist(p + eps.xyy),\n        dist(p + eps.yxy),\n        dist(p + eps.yyx))\n        - dist(p))/eps.x;\n}\n\n\n\nvec3 material(vec3 p){\n    return p.y > - .99 && p.z < 20. ? vec3(.9) : vec3(.9, .8, .8);\n}\n\nvec3 sky(vec3 d){\n    float v = 1.-d.y;\n    return vec3(v, v, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color = vec3(0);\n    \n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float t = march(ro, rd);\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    if(t > MAX_D){\n        color = sky(rd);\n    }else{\n        color = material(p);\n        \n        vec3 rro = p + n*.001;\n        vec3 rrd = normalize(n + .98*R3(p, iTime));\n        vec3 prev_n = n;\n        \n        for(int i=0; i<10; i++){\n        \tfloat rt = march(rro, rrd);\n        \tvec3 rp = rro + rrd*rt;\n        \tvec3 rn = normal(rp);\n            \n            //material color\n            vec3 mcol = material(rp);\n            \n            //simple\n            color *= mcol;\n            \n            //hit the sky?\n            if(rt > MAX_D){\n                //color *= sky(rrd);\n                break;\n            }\n        \n        \t//reinit\n        \trro = rp + rn*.001;\n        \trrd = normalize(rn + .98*R3(rp, iTime));\n            prev_n = rn;\n        }\n    }\n    \n    color = (1.-denoise_amount)*color + denoise_amount*texture(iChannel1, fragCoord.xy/iResolution.xy).rgb;\n    \n    fragColor = vec4(color, 1.);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tt3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 174]], "test": "untested"}
{"id": "tdVXW3", "name": "ao test", "author": "Angramme", "description": "ff", "tags": ["ao"], "likes": 1, "viewed": 229, "published": 3, "date": "1610735629", "time_retrieved": "2024-07-30T19:44:59.400438", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    color += texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_DIST 200.\n#define MIN_DIST .001\n\nfloat dist(vec3 p){\n    float sph = distance(p, vec3(0,0,3)) - .5;\n    float sph2 = distance(p, vec3(.5,-.1,2.5)) - .25;\n    float plane = p.y + .5;\n    \n    return min(sph2,min(sph, plane));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<200; i++){\n        vec3 p = ro + rd*t;\n        float d = dist(p);\n        if(d < MIN_DIST || t > MAX_DIST)break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p){\n    vec2 eps = vec2(.001, 0.);\n\treturn (vec3(\n        dist(p+eps.xyy),\n        dist(p+eps.yxy),\n        dist(p+eps.yyx)\n        ) - dist(p))/eps.x;\n}\n\nfloat occlusion(vec3 p0){\n    float maX = 1.;\n    vec3 p = p0;\n    for(int i=0; i<20; i++){\n        vec3 n = normal(p);\n        vec3 r = normalize(n +.99*(2.*textureLod(iChannel0, p*197513.33+iTime*13.3347, 0.).rgb-1.));\n        float d = march(p+n*MIN_DIST, r);\n\t\tp = p + r*d +n*MIN_DIST;\n        //if(d>MAX_DIST)return 1.-i/maX;\n        maX *= .8;\n        if(d>MAX_DIST)return maX;\n    }\n    return 0.;\n}\n\nvec3 sky(vec3 d){\n    float v = max(0.,1.-d.y*2.);\n    return vec3(v, v, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float d = march(ro, rd);\n    if(d>MAX_DIST){\n        color += sky(rd);\n    }else{\n        vec3 p = ro + rd*d;\n        vec3 n = normal(p);\n        color += occlusion(p);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define COEF .01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    color += texture(iChannel0, uv).rgb*COEF + texture(iChannel1, uv).rgb*(1.-COEF);\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 211]], "test": "untested"}
{"id": "wl3yDN", "name": "ray marching color", "author": "ShyguyBerlin", "description": "A shader for rendering with ray marching, shows the position based color assignment", "tags": ["raymarching", "fractals", "skybox"], "likes": 0, "viewed": 197, "published": 3, "date": "1610735130", "time_retrieved": "2024-07-30T19:45:00.223239", "image_code": "#define renderDist 10000.\n#define SUR_ACC 0.01\nvec3 rotate(vec3 Coords,vec3 EulerAngles)\n{\n    vec3 realCoords=  vec3(0.,0.,0.);\n    \n    realCoords.x=Coords.x*cos(EulerAngles.z)-Coords.y*sin(EulerAngles.z);\n    realCoords.y=Coords.y*cos(EulerAngles.z)+Coords.x*sin(EulerAngles.z);\n    \n    realCoords.z=Coords.z*cos(EulerAngles.x)-realCoords.y*sin(EulerAngles.x);\n    realCoords.y=realCoords.y*cos(EulerAngles.x)+Coords.z*sin(EulerAngles.x);\n    \n    realCoords.x=realCoords.x*cos(EulerAngles.y)-realCoords.z*sin(EulerAngles.y);\n    realCoords.z=realCoords.z*cos(EulerAngles.y)+realCoords.x*sin(EulerAngles.y);\n    return realCoords;\n}\n\nvec4 skybox(vec2 fakeCoords, vec3 EulerAngles)\n{\n    vec3 Coords =  vec3(fakeCoords.x,fakeCoords.y,sqrt(sqrt(0.5*0.5*2.)-length(fakeCoords)));\n    vec3 realCoords=  rotate(Coords,EulerAngles);\n    \n    vec3 hue=vec3(15./255.,125./215.,1.)*1.;\n    float value=0.+1.2*abs(abs(realCoords.y)-1.);\n    return vec4(hue*value,1);\n}\nfloat Box(vec3 p, float size){\nvec3 q=abs(p)-size;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat recursiveHallowBox(vec3 p, float size, int i){\n\n\nwhile(i>0){\np=abs(p)-size/2.;\nsize*=1./3.;\n\np*=-1.;\nif(size<max(max(p.x,p.y),p.z)){\nif(p.x>=p.y&&p.x>=p.z){\np.x-=size;\n}else{\nif(p.y>p.x&&p.y>=p.z){\np.y-=size;\n}else{\nif(p.z>p.x&&p.z>p.y){\np.z-=size;\n}}}}\np*=-1.;\np+=size/2.;\ni--;\n}\nreturn Box(p,size) ;\n\n}\n\nfloat DE(vec3 coords)\n{\n//float kugel=distance(vec3(25.,25.,25.),coords)-2.;\n\nvec3 p=coords-vec3(sin(iTime)*15.,0.,30.);\n\n\n\nreturn min(recursiveHallowBox(p,10.,1),coords.y+20.);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\nfloat RayMarch (vec3 or, vec3 dir){\n    for(float i=0.;i<renderDist;){\n    \n    vec3 pos= i*dir+or;\n    float DE=DE(pos);\n    if(DE<SUR_ACC){\n    return i;\n    \n    }else{\n    i+=DE*0.9;\n    }\n    }\n    return renderDist;\n}\nfloat GetLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SUR_ACC*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec2 muv=iMouse.xy/iResolution.xy;\n    muv-=0.5;\n    vec3 Camrotation= vec3(muv.y*6.,-muv.x*6.,0);;\n    vec3 CamPosition= vec3(0,5,mod(iTime,80.)*0.-20.);\n    vec3 LightPos =vec3(-10.,10.,-10.);//vec3(2,-5,300);\n    \n    vec4 color;\n    vec3 albedo= vec3(1,0,0);\n    float renderdistance=0.1;\n    float fov=3.14159/4.;\n    float XtoYratio=iResolution.y/iResolution.x;\n    //vec3 movVec=vec3(sin(fov*uv.x),sin(fov*uv.y)*XtoYratio,cos(fov*uv.x));\n    \n    vec3 movVec=normalize(vec3(uv.x,uv.y*XtoYratio,1));\n    movVec=normalize(rotate(movVec,Camrotation));\n    float accuracy=0.000001;\n    \n    \n    \n\n    \n    //Ray march\n    float d=RayMarch(CamPosition,movVec);\n    vec3 renderpos=CamPosition+movVec*d;\n    \n    \n    if(renderpos.x>0.){\n    albedo=vec3(1.-renderpos.x/(renderpos.x+1.),0.,renderpos.x/(renderpos.x+1.));\n    }\n    \n    bool weirdwaytoshade=false;\n    \n    if(d>=renderDist){\n    color=skybox(uv,Camrotation);\n    }else{\n    \n    if(weirdwaytoshade){\n        float lightlevel=1.;\n        vec3 LightVec=normalize(LightPos-renderpos);\n            for(float i=SUR_ACC*3.;i<renderDist;){\n\n            vec3 pos= i*LightVec+renderpos;\n            float DE=min(DE(pos),distance(pos,LightPos));\n\n            if(DE<accuracy){\n            if(distance(pos,LightPos)>accuracy){\n            lightlevel*=0.01;\n            }\n\n            break;\n\n            }else{\n            i+=DE*0.5;\n            }\n            lightlevel*=0.98;\n            }\n\n        color=vec4(albedo*lightlevel,1);\n        \n    }else{\n    color=vec4(albedo*GetLight(renderpos,LightPos),1);\n    }\n    }\n    //fragColor=vec4(uv.x,uv.y,0.,0.);\n    fragColor= color;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 90, 90, 636], [638, 638, 686, 686, 962], [963, 963, 993, 993, 1075], [1076, 1076, 1128, 1128, 1386], [1388, 1388, 1411, 1464, 1567], [1569, 1569, 1593, 1593, 1762], [1763, 1763, 1798, 1798, 1986], [1987, 1987, 2026, 2026, 2242], [2244, 2244, 2301, 2301, 3997]], "test": "untested"}
{"id": "wlKcRm", "name": "Faking 3D - Spheres", "author": "oneshade", "description": "Flying spheres. But wait... Its not really 3D is it?", "tags": ["spheres", "25d", "fake3d"], "likes": 3, "viewed": 156, "published": 3, "date": "1610733826", "time_retrieved": "2024-07-30T19:45:01.316317", "image_code": "#define BIG_NUMBER 1000000.0\n#define FOCAL_LENGTH 0.25\n\nvec3 Hash13(in float x) {\n   vec3 p = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p += dot(p, p.yzx + 33.33);\n   return fract((p.xxy + p.yzz) * p.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat fakeSphere(in vec2 p, in vec3 o, in float r) {\n    float persp = FOCAL_LENGTH / o.z;\n    o.xy *= persp;\n    r *= persp;\n\n    p -= o.xy;\n    float d = length(p);\n    if (d < r) {\n        return -cos(asin(d / r)) * r + o.z;\n    }\n\n    return BIG_NUMBER;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float depth = BIG_NUMBER;\n    for (float seed=318.547; seed < 338.547; seed++) {\n        vec3 o1 = Hash13(seed + floor(iTime)) * vec3(2.0, 2.0, 1.0) - vec3(1.0, 1.0, 0.0);\n        vec3 o2 = Hash13(seed + ceil(iTime)) * vec3(2.0, 2.0, 1.0) - vec3(1.0, 1.0, 0.0);\n        vec3 o = mix(o1, o2, fract(iTime));\n        float r = 0.1 + 0.1 * Hash11(seed);\n        depth = min(depth, fakeSphere(uv, o, r));\n    }\n\n    fragColor += 0.75 - depth;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 81, 81, 209], [211, 211, 237, 237, 323], [325, 325, 377, 377, 584], [586, 586, 641, 641, 1194]], "test": "untested"}
{"id": "tlKcRm", "name": "Cubic Bzier Curve (1D)", "author": "Tech_", "description": "Heres I a little function you can use in your own project!", "tags": ["math", "bezier", "curve"], "likes": 4, "viewed": 359, "published": 3, "date": "1610733631", "time_retrieved": "2024-07-30T19:45:02.079276", "image_code": "float CubicBezier(float x, vec4 u)\n{\n    return u.x * pow(1.0 - x, 3.0)\n         + 3.0 * u.y * pow(1.0 - x, 2.0) * x\n         + 3. * u.z * pow(1.0 - x, 2.0) * pow(x, 2.0)\n         + u.w * pow(x, 3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= 0.35;\n    uv.y *= 2.0;\n    \n    vec4 bezierU = vec4(0.0, 1.0, 0.0, 1.0);\n    \n    uv.y -= CubicBezier(clamp(uv.x, 0.0, 1.0), bezierU);\n\n    vec3 color;\n    color += smoothstep(0.03, 0.02, distance(uv.y, 0.5) * 2.0) * smoothstep(0.0, 0.1, 1. - distance(uv.x, 0.5) * 2.);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 202], [204, 204, 261, 261, 664]], "test": "untested"}
{"id": "ttVyzw", "name": "2D Caustics (GI)", "author": "darkeclipz", "description": "Testing a monte carlo rendering in 2D for global illumination with caustics.", "tags": ["2d", "reflection", "gi", "caustics"], "likes": 15, "viewed": 965, "published": 3, "date": "1610727721", "time_retrieved": "2024-07-30T19:45:02.888113", "image_code": "#define R iResolution.xy\n#define AA 2.\n#define PI 3.14159265359\n#define LIGHT_SAMPLES 3.\n\nstruct material {\n    vec3 diffuse;\n    vec3 emissive;\n    bool light;\n    float intensity;\n};\n\nmaterial[] materials = material[] (\n    material(vec3(0.9), vec3(1), false, 0.),\n    material(vec3(0.4,0.4,1), vec3(.4, .4, 1), true, 2.5),\n    material(vec3(0.4,0.4,1), vec3(1,.4,.4), true, 2.5),\n    material(vec3(1), vec3(0.9), false, 0.)\n);\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 r = abs(p) - b;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat2 rot(float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb ) {\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCuttedBox(vec2 p) {\n    float d = sdBox(p, vec2(0.3)) - 0.02;\n    float c = sdCircle(abs(p) - vec2(0.28, 0.28), 0.24);\n    d = max(d, -c);\n    return d;\n}\n\nint id = 0;\nfloat lastMapValue = 0.;\nfloat map(vec2 p) {\n    id = 0;\n    float t = iTime / 20.;\n    float ljs = 0.6; // lissajous size for lights\n    \n    // Cutted box\n    float size = 1.1;\n    vec2 modp = mod(1.1*p, 1.0) - 0.5;\n    float d = sdCuttedBox(rot(PI/4.)*size*p) / size;\n    \n    // Light 1\n    float lx1 = cos(23.*t/4. + 2.) * R.x/R.y *ljs;\n    float ly1 = sin(31.*t/4.) * ljs; \n    float circle = sdCircle(p + vec2(lx1, ly1), 0.05);\n    if(circle < d) {\n        id = 1;\n    }\n    d = min(d, circle);\n    \n    // Light 2\n    float lx2 = cos(17.*t + 1.) * R.x/R.y *ljs;\n    float ly2 = sin(7.*t) * ljs;\n    float circle2 = sdCircle(p + vec2(lx2, ly2), 0.05);\n    if(circle2 < d) {\n        id = 2;\n    }\n    d = min(d, circle2);\n    \n    // Horse shoe\n    vec2 absX = p;\n    absX.x = abs(absX.x);\n    absX.x = -absX.x;\n    \n    float a = PI/2.;\n    float b = -0.6;\n    vec2 ra = vec2(cos(a), sin(a));\n    vec2 rb = vec2(cos(b), sin(b));\n    float arc = sdArc(absX - vec2(-0.5*R.x/R.y + 0.1, 0), ra, rb, 0.8, 0.05);\n    if(arc < d) {\n        id = 0;\n    }\n    d = min(d, arc);\n    \n    lastMapValue = d;\n    return d;\n}\n\nvec2 normal(vec2 p) {\n    vec2 e = vec2(0.00001, 0);\n    float x = lastMapValue;\n    return normalize(vec2(map(p+e.xy)-x,\n                          map(p+e.yx)-x));\n}\n\nfloat trace(vec2 ro, vec2 rd) {\n    float t = 0.0;\n    for(float i=0.; i<60.; i++) {\n        vec2 p = ro + t * rd;\n        float d = map(p);\n        if(d < 0.0001) {\n            break;\n        }\n        t += d;\n        if(t > 20.) {\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 sampleScene(vec2 ro) {\n    vec3 fcol = vec3(0);\n    \n    for(float i=0.; i < LIGHT_SAMPLES; i++) {\n    \n        float r = (random(ro + i) + i) / LIGHT_SAMPLES * PI * 2.0;\n\n        vec2 rd = vec2(cos(r), sin(r));\n        float t = trace(ro, rd);\n        vec3 col = vec3(0.);\n        \n        if(t < 20.) {\n            vec2 p = ro + t * rd;\n            \n            if(materials[id].light) {\n                // hit a light\n                col = materials[id].emissive * materials[id].intensity;\n            }\n            else {\n                if(t < 0.0001) {\n                    // inside object (not light)\n                    col = texture(iChannel0, ro * 1.2).rrr;\n                }\n                else {\n                    // hit object; calculate reflection\n                    vec2 nor = normal(p);\n                    vec2 refl = reflect(rd, nor);\n                    int matId = id;\n                    float k = trace(p + refl * 0.001, refl);\n                    if(k < 20.) {\n                        // hit light\n                        if(materials[id].light) {\n                            col = materials[id].emissive * materials[id].intensity * materials[matId].diffuse;\n                        }\n                        else {\n                            // hit material; calculate second reflection\n                            vec2 p2 = p + refl*0.001 + k*refl;\n                            nor = normal(p2);\n                            refl = reflect(refl, nor);\n                            int matId2 = id;\n                            float j = trace(p + refl * 0.001, refl);\n                            if(k < 20. && materials[id].light) {\n                                // hit light\n                                col = materials[id].emissive * materials[id].intensity \n                                                             * materials[matId].diffuse;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else col = vec3(0.3); // ambient\n        fcol += col;\n    }\n    \n    return fcol / LIGHT_SAMPLES;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fcol = vec3(0);\n    vec2 npos = (2.*fragCoord-R)/R.y;\n    float randSeed = fract(float(iTime) / 30.);\n    float stratSize = 1. / AA;\n    for(float aax = 0.; aax < AA; aax++)\n    for(float aay = 0.; aay < AA; aay++) {\n        vec2 strat = vec2(aax, aay) * stratSize;\n        vec2 jitter = vec2(random(npos + 4.1252 + aax + randSeed), \n                           random(npos + 1.3483 + aay + randSeed)) * stratSize;\n        vec2 uv = (2.*fragCoord + strat + jitter - R)/R.y;\n        vec3 col = sampleScene(uv);\n        fcol += col;\n    }\n    \n    fragColor = vec4(fcol/(AA*AA),1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 460, 460, 548], [550, 550, 583, 583, 611], [613, 613, 641, 641, 717], [719, 719, 738, 738, 810], [812, 812, 887, 887, 1071], [1073, 1073, 1100, 1100, 1235], [1274, 1274, 1293, 1293, 2366], [2368, 2368, 2389, 2389, 2534], [2536, 2536, 2567, 2567, 2819], [2821, 2821, 2848, 2848, 4934], [4936, 4936, 4993, 4993, 5585]], "test": "untested"}
{"id": "wtVczw", "name": "My sdf tests", "author": "TheNosiriN", "description": "I'm going be using this to model sdfs\nSo I decided to release it", "tags": ["raymarching", "sdf", "shadow", "modelling", "noiseless"], "likes": 24, "viewed": 492, "published": 3, "date": "1610727383", "time_retrieved": "2024-07-30T19:45:03.988172", "image_code": "\nfloat column(vec3 p, float l, float r)\n{\n    float r2 = r*2.0;\n    float r12 = (r+r2)/2.0;\n    float cb = cube(p, vec3(r2, r12/1.25, r2));\n    cb = max(cb, -(length(vec3(p.x-r12, p.y+r12, p.z-r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x+r12, p.y+r12, p.z-r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x-r12, p.y+r12, p.z+r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x+r12, p.y+r12, p.z+r12))-(r2/1.25)) );\n    \n    float cy = cyl(p+vec3(0,l/2.0,0), l/2.0, r);\n    cy = max(cy, -boundingBox(vec3(p.x, p.y+l/2.0, p.z), vec3(r/1.25, l/2.0, r/1.25), 0.25));\n    \n    cb = min(cb, cy);\n    \n    return cb;\n}\n\n\n\n\nfloat tower(vec3 p, float scale)\n{\n    p /= scale;\n    float h = 5.0;\n    float r = 1.0;\n    float rt = r/1.5;\n    \n    //main body\n    float bd = cone(p, h, r, rt);\n    \n    //windows\n    vec3 wnp = p;\n    float wnc = 1.0;\n    float wnh = r*0.2;\n    float wnw = wnh/2.0;\n    float c = pModPolar(wnp.xz, 3.0);\n    wnp.y -= h/2.0;\n    c = pModInterval1(wnp.y, (h*wnh*2.5), -2.0, 0.0);\n    wnp.y -= h*wnh;\n    float wn = cube(wnp, vec3(r*2.0, wnh, wnw));\n    float frame = max(-wn, cube(wnp, vec3(rt+wnw*2.0, wnh*1.5, wnw*1.5)));\n    \n    //arc\n    vec3 arcp = p;\n    float arcw = r/10.0;\n    float arcr = arcw*(h/2.0);\n    c = pModPolar(arcp.xz, 10.0);\n    arcp.y -= h - arcr*4.5;\n    arcp.y /= 3.0;\n    arcp.x -= rt+arcr;\n    vec3 arccylp = arcp+vec3(-arcr,arcr,0);\n    float arccyl = length(arccylp)-(arcr*2.25);\n    float arc = max(-arccyl, cube(arcp, vec3(arcr,arcr*1.5,arcw)));\n    \n    //top body\n    vec3 bd2p = p;\n    bd2p.y -= h;\n    float bd2r = rt+arcr*2.0;\n    float bd2 = cyl(bd2p, h/40.0, bd2r);\n    \n    //bars\n    vec3 barp = bd2p;\n    c = pModPolar(barp.xz, 40.0);\n    barp.x -= bd2r;\n    float bar = cyl(barp-vec3(0,wnh*1.25,0), wnh*1.25, rt/40.0);\n    vec3 bar2p = bd2p;\n    bar2p.y -= (wnh*2.5)/1.5;\n    c = pModInterval1(bar2p.y, (wnh*2.5)/4.0, 0.0, 1.0);\n    float bar2 = torus(bar2p, vec2(bd2r,rt/40.0));\n    \n    //house\n    vec3 hsp = bd2p;\n    float hsph = wnh*2.5;\n    float hspr = bd2r/2.0;\n    hsp.y -= hsph/1.8;\n    float hs = octagon(hsp, hsph/2.0, hspr);\n    c = pModPolar(hsp.xz, 8.0);\n    hsp.x -= hspr*0.95;\n    hsp.y += hsph/2.0;\n    float hbar = cyl(hsp, hsph*2.0, hspr/10.0);\n    vec3 rfp = bd2p;\n    rfp.y -= hsph*1.8;\n    float roof = max(length(rfp)-hspr*1.2, -cube(rfp+vec3(0,hsph*1.25,0), vec3(hspr*1.3)));\n    rfp.y -= hspr*1.2;\n    roof = minr(roof, cyl(rfp, h/10.0, hspr/20.0), hspr/2.0);\n    \n    \n    //comp\n    bd = max(bd, -wn);\n    bd = min(bd, frame);\n    bd = minr(bd, arc, arcr/2.0);\n    bd2 = min(bd2, min(bar, bar2));\n    bd2 = min(bd2, min(hs, min(hbar, roof)));\n    bd = min(bd, bd2);\n    \n    return bd*scale;\n}\n\n\n\nfloat fbm(vec2 p, int oct)\n{\n    float d = 0.0;\n    float a = 1.0;\n    p *= 0.05;\n    float dist = pow(smoothstep(0.5, 1.0, 1.0-(length(p)-0.1)), 5.0);\n    for (int i=0; i<oct; i++){\n        //do we really need perlin noise??\n        float n = textureLod(iChannel0, p, 0.0).r;\n        d += n * a * dist;\n        p = M2*p*2.0+dist*0.5;\n        a *= 0.5;\n    }\n    return d;\n}\n\n\n\n\nfloat idk(vec3 p, vec3 n)\n{\n    p *= 0.01;\n    float f = 0.0;\n    f += 0.5000 * triplanarMap(iChannel0, p, n, 1.0).r; p = M3*p*2.02+f*0.5;\n    f += 0.2500 * triplanarMap(iChannel0, p, n, 1.0).r; p = M3*p*2.03+f*0.5;\n    f += 0.1250 * triplanarMap(iChannel0, p, n, 1.0).r;\n    return (f/0.875);\n}\n\n\n\n\nfloat scene(vec3 p)\n{\n    float d = MAX_DIST;\n    p *= 2.0;\n    float cb = max(p.y-pow(fbm(p.xz, 3), 0.5)*3.0, length(p)-10.0);\n    cb = min(cb, tower(p-vec3(0,6,0),1.0));\n    //tower(p, 1.0);//column(p, 10.0, 1.0);\n    //float cb = p.y - (idk(p, vec3(0,1,0))*10.0);\n    \n    //float cb = floor(length(p)*20.0)/20.0-8.0;\n    \n    d = min(d, cb/2.);\n    return d;\n}\n\n\n\n\nfloat raymarch(vec3 eye, vec3 dir)\n{\n    float depth = 0.0;\n    float info = 0.0;\n    float stepsf = float(MAX_MARCHING_STEPS);\n    for (int i=0; i<MAX_MARCHING_STEPS && depth<MAX_DIST; i++){\n        vec3 p = eye + depth * dir;\n        info = scene(p);\n        if (abs(info) < EPSILON * depth)break;\n        depth += info * remap(float(i),0.0,stepsf,0.1,1.0);\n    }\n    return depth;\n}\n\n\n\n\nfloat shadow(vec3 eye, vec3 dir) {\n    float res = 1.0;\n    float depth = 0.0;\n    float ph = 1e10;\n    for( int i=0; i<32 && depth<MAX_DIST; i++ ){\n     \tvec3 p = eye + dir * depth;\n        float h = scene(p);\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,depth-y) );\n        \n        depth += h;\n    }\n\n    return res;\n}\n\n\n\n\n\n\n\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * EPSILON;\n \treturn normalize(\n        scene(p+P.xyy) * \n        P.xyy + scene(p+P.yxy) * \n        P.yxy + scene(p+P.yyx) * \n        P.yyx + scene(p+P.xxx) * \n        P.xxx\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = rotateCamera(30.0, iMouse.xy/iResolution.xy, iMouse);\n    \n    //vec3 eye = vec3(10.0, 20.0, -200.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 light = normalize(vec3(0.0, 0.25, 1.0));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    vec3 col = vec3(0);\n    \n    float dist = raymarch(eye, worldDir);\n    vec3 P = eye + worldDir * dist;\n    vec3 N = normal(P);\n    float shading = saturate(dot(N, light));\n    if (shading >= 0.0){ shading *= shadow(P,light); }\n    \n    col += (shading+0.5)*(dist/MAX_DIST);\n    if (dist >= MAX_DIST){ col = vec3(0.5); }\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    col *= 0.3 + 0.8*pow(32.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.001;\n\n\n\n\n#define PI 3.1415972\n#define dot2(x) dot(x,x)\n#define M2 mat2(0.8,-0.6,0.6,0.8)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define M3 mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64)\n\n\n\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\n\n\n//functions from: http://mercury.sexy/hg_sdf/\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) {\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\nfloat minr(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n//\n\n\n\n\n\nfloat cyl(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cylside(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat boundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat cube(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Frabrice's octagon: https://www.shadertoy.com/view/4sKfD3\nfloat octagon(vec3 p, float h, float r)\n{\n    vec3 a = abs(p);\n    float t = max(a.x,a.z) -r;\n    t = max(t,(a.x+a.z)/1.41 -r);\n    t = max(t,a.y -h);\n    return t;\n}\n\n\n\n\n\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale)\n{\n    p *= scale;\n    \n    return  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n}\n\n\n\nfloat remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){\n    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 628], [633, 633, 667, 667, 2702], [2706, 2706, 2734, 2734, 3080], [3085, 3085, 3112, 3112, 3380], [3385, 3385, 3406, 3406, 3749], [3754, 3754, 3790, 3790, 4139], [4144, 4144, 4178, 4178, 4569], [4577, 4577, 4598, 4598, 4806], [4810, 4810, 4867, 4867, 5749]], "test": "untested"}
{"id": "ttKczw", "name": "Wild Flower ", "author": "YitingLiu", "description": "animating wild flowers based on cos, atan, and sin. ", "tags": ["color", "circle", "atan", "cos", "animation", "plot", "ellipse"], "likes": 1, "viewed": 211, "published": 3, "date": "1610725697", "time_retrieved": "2024-07-30T19:45:04.948604", "image_code": "\n// Exercise following the book of shader - Shapes\n// Inspiration: Author @patriciogv - 2015 - http://patriciogonzalezvivo.com\n\n// animating flower shapes \n\n\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n    float pct = plot(st,0.25);\n\n    float r = length(pos)*5.0-pct;\n    float a = atan(pos.y,pos.x); \n    float f = cos(a*abs(sin(iTime))*10.);\n    // f = abs(cos(a*3.));\n    // f = abs(cos(a*2.5))*.5+.3;\n    f = abs(cos(a*10.*abs(cos(iTime)))*sin(a*abs(cos(iTime))*5.0))*0.8+.1;\n    //f = smoothstep(-.5,1., cos(a*20.))*0.2+0.5;\n\n    color = vec3( 1.-smoothstep(f,f+0.2*cos(iTime),r) );\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n  \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 189, 189, 280], [282, 282, 339, 339, 863]], "test": "untested"}
{"id": "wlVcRw", "name": "Payday Joyman", "author": "luckyballa", "description": "first time playing with raymarching :) ", "tags": ["raymarching", "specular", "character", "memoji"], "likes": 6, "viewed": 238, "published": 3, "date": "1610721944", "time_retrieved": "2024-07-30T19:45:05.785369", "image_code": "#define MAX_STEPS 25\n#define MAX_DIST 25.\n#define SURF_DIST .008\n\nfloat g_time;\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n} \n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smax( float a, float b, float k ) {\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec2 rot(vec2 p, in float an ) {\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat displacement(vec3 p) { return sin(60.*p.x)*sin(60.0*p.y)*sin(60.*p.z); }\n\nfloat sdCone( in vec3 p, in vec2 c ) {\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec2 getDist(vec3 p) {\n\n    float matId;\n    p.y -= 0.2;\n    vec3 orig =  vec3(0, 1, 6.4);\n    \n    //HEAD\n\tvec3 headPos = p-orig;\n    vec3 direction =  normalize(headPos);\n    headPos.x -= (p.y - 1.1) * 0.35 * direction.x;\n    headPos.x += pow(abs(sin((p.y + 2.) * 8.)) * 0.1, 1.2 + p.y) * normalize(headPos).x;  \n\n    float head = length(headPos) -1. + p.y * 0.5;\n    \n    //HAIR\n    vec3 hairPos = p-orig;\n    float hair = sdRoundedCylinder(hairPos, 0.24, 0.15, 0.27);\n    hair += displacement(hairPos) * .005;\n    \n    if (hair < head) {\n       head = smin(hair, head, 0.01);\n        matId = 0.;\n    } else {\n        matId = 2.;\n    }\n      \n    //EYES\n    vec3 eyePos = headPos + vec3(0.05 * direction.x, 0.25, .5);\n    vec3 eyeOff = vec3(0.19, 0., 0.);\n    eyePos.x = abs(eyePos.x);\n\n    float eye = length(eyePos -eyeOff) -0.12;\n    if (-eye > head) { head += eye; }\n    head = min(eye + 0.01, head);    \n    \n    vec3 eyeBrowPos = vec3( rot( vec2(eyePos.x * 1.2 - eyeOff.x * 1.3 , eyePos.y -0.17) , 1.5),  eyePos.z+0.1);\n    eyeBrowPos.x -= (1. - pow(abs(sin(g_time)), 0.4)) * 0.03;\n    eyeBrowPos.x += sin(eyeBrowPos.y * 20. - 1.) * .012;\n    float eyeBrow = sdRoundedCylinder(eyeBrowPos, 0.005, 0.04, 0.11);\n    \n    if (eyeBrow < head) {\n        head = smin(eyeBrow, head, 0.1);\n        matId = 0.;\n    }\n    \n    //GLASSES\n    eyePos.z += 0.2;\n    eyeOff.x += 0.02;\n    float glass = sdBox(eyePos-eyeOff, vec3(0.15, 0.07 , 0.02));\n    eyeOff.x += 0.24;\n    eyeOff.z += 0.2;\n    float glassb = sdRoundedCylinder(vec3(rot((eyePos-eyeOff).xz, -.4), eyePos.y), 0.005, 0.02, 0.2);    \n\n    eyePos.x *= 2.;\n    eyePos.y *= 1.8;\n    eyePos.z *= 0.9;\n    eyePos.z -= 0.2;\n    float glassC = sdCappedTorus( vec3(eyePos.x, rot((eyePos+eyeOff).yz, -1.5)), vec2(0.2, 0.), 0.15, 0.02);\n\n    if (glassC < head) {\n        head = min(glassC, head);\n        matId = 6.;\n    }\n    if (glassb < head) {\n        head = min(glassb, head);\n        matId = 6.;\n    }\n    \n    if (glass < head) {\n        head = min(glass, head);\n        matId = 1.;\n    }\n     \n    //NOSE\n    vec3 nosePos = p-orig;\n    nosePos.z += 0.7;\n    nosePos.y += 0.15;\n    nosePos.yz = rot(nosePos.yz,-0.3);\n    float h = smoothstep(0.,0.3,-nosePos.y );\n    float nose = 1.;\n    nosePos.x = sqrt(nosePos.x*nosePos.x + 0.001);\n    nose = smin( nose, sdSphere(nosePos-vec3(0.04, -0.3, 0.037),0.03 ), 0.1);\n    nose = smin( nose, sdSphere(nosePos*vec3(1.05,0.95,1.)-vec3(.0, -0.155, 0.05),0.02), 0.19);\n    head = smin(head,nose,0.05-0.04*h);\n    if (nose - 0.001 < head) {\n        matId = 2.;\n    }\n    \n    //EARS\n    vec3 earsPos = p-orig;\n    earsPos.x = abs(earsPos.x);\n    earsPos.y += 0.35;\n    earsPos.y *= 0.7;\n    earsPos.z += 0.1;\n    earsPos.x -= 0.41;\n    float ear = sdSphere(earsPos,0.08); \n    if (ear < head) {\n        head = smin(head,ear,0.02);\n        matId = 2.;\n    }\n\n    //MOUTH\n    float mT = 0.88 - pow(abs(g_time) / 1.2, 1.8);\n    vec3 mPos = p - vec3(orig.x + 0.7 * direction.x * mT, orig.y-.6, orig.z -0.55);\n    mPos.y -= pow(abs(sin(abs(p.x))), 1.9 + mT * 0.3);\n   \tfloat mouth = length(mPos) - 0.05;\n    mPos.x = orig.x + 0.69 * direction.x  * (1.55 - mT);\n    mPos.z *= 1.8;\n    mPos.z -= 0.064;\n    mPos.y -= 0.015;\n    mPos.y *= 0.95;\n    float outMouth = length(mPos) - 0.05;\n    if (-mouth - 0.008 > head ) {\n        matId = 3.;\n        head = smin(-mouth, head, 0.2);\n    }\n    \n    head = smin(head, outMouth, 0.03);  \n    outMouth = length(vec3(mPos.x, mPos.y - 0.01 ,  mPos.z))  - 0.05;\n    if (outMouth - 0.022 < head){ matId = 4.; }\n    \n    //DOLLAR\n    vec3 dollaInitialPos = headPos + vec3(1.66, -0.52, 1.6) - vec3(.5*sin(g_time),0., 1.*cos(g_time));\n    vec3 dollaPos = dollaInitialPos;\n    dollaPos.x *= 0.85 - p.y * 0.01;\n    dollaPos.xy *= 2.5;\n    dollaPos.y *= 1.1;\n    dollaPos.z += sin(iTime + dollaPos.y * 5.) * 0.05;\n    dollaPos.xy = rot( dollaPos.xy, 0.9);\n    dollaPos.x = dollaPos.y > 0. ? -dollaPos.x + 0.36 : dollaPos.x;\n    float dollaA = sdCappedTorus(dollaPos, vec2(sin(iTime-.3), cos(iTime-.3)), 0.22, 0.025);\n   \n    dollaPos.xy = dollaInitialPos.xy - vec2(0.02, 0.06);\n    dollaPos.xy *= 2.;\n    dollaPos.xy = rot( dollaPos.xy, -.2);\n    dollaPos.x -= 0.05;\n    dollaPos.x = abs(dollaPos.x);\n    dollaPos.x -= 0.05;\n    float dollaB = sdRoundedCylinder(dollaPos, 0.01, 0.02, 0.49 * abs(cos(iTime / 2. - 1.) ));    \n\n\n   if (dollaA < head) {\n       head = min(dollaA, head);\n       matId = 5.;\n    } \n    if (dollaB < head) {\n        head = smin(dollaB, head, 0.075);\n        matId = 5.;\n    }\n    \n    return vec2(head, matId);\n}\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p).x;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 n) {\n    vec3 lightPos = vec3(0.5, 1.5, 4.);\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(n, l), 0., 1.);     \n    return dif*1.5;\n}\n\nfloat slight(vec3 p, vec3 ro, vec3 n) {\n    vec3 lightPos = vec3(g_time * 4., 2., 4.);\n    vec3 l = normalize(lightPos-p);\n    \n    float lDist = max(length(l), 0.001);\n    float atten = 1./(1.0 + lDist*lDist*0.5);\t\n    vec3 reflection = reflect(-l, n);\n    float spec = pow(max( dot(reflection, -normalize(ro)), 0.), 9.); \n        \n    return spec*3. *atten;;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 4.;\n    vec2 m = vec2(0.5);\n    g_time = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(.5*sin(g_time),1., 1.*cos(g_time));\n    vec3 rd = normalize(vec3(uv.x, uv.y , 2.));\n\n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = getNormal(p);\n    float dif = light(p, n) / 2.7;\n    float spec = slight(p, ro, n);\n    vec3 bc = vec3(0.85, 0.72, 0.56);\n\n    col = dif * vec3(0.85, 0.35, 0.2);\n    \n    if (d.y == 0.) { // HAIR\n          col = dif * vec3(0.12, 0.10, 0.101); \n    } else  if (d.y == 1.) { // GLASSES\n          col = min((spec+spec/1.5+dif) * vec3(0.84, 0.2, 0.15), 1.); \n    } else  if (d.y == 2.) { // SKIN\n        col = dif * vec3(0.85, 0.35, 0.2);\n    } else if (d.y == 3.) { // MOUTH IN\n          col = dif * vec3(1., 0.5, 0.4) * 0.9;\n    } else if (d.y == 4.) { // MOUTH\n              col = dif * vec3(0.9, 0.3, 0.2) / 1.3;\n    } else if (d.y == 5.) { // DOLLA\n              col = max(pow(spec+dif+dif, 1.2), 0.3) * vec3(0.1, 0.8, 0.4) / 2.;\n    } else if (d.y == 6.) { // GLASSES BASE\n              col = (spec+spec/2.+dif) * vec3(0.9, 0.7, 0.15);\n    } else if (d.y == 7.) { // PARTS\n            col =  vec3(0.32, 0.22, 0.12) * 0.6;// - dif/2.*bc;\n    }\n    \n    col = pow(col, vec3(.6));\n    col +=  0.1 * vec3(.25, 0.36, 0.7);\n    col *= 1.5;\n    \n    fragColor = vec4( max(vec3( col), 0.12),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 116, 116, 138], [140, 140, 204, 204, 321], [324, 324, 355, 355, 442], [444, 444, 514, 514, 648], [650, 650, 691, 691, 782], [784, 784, 825, 825, 897], [899, 899, 931, 931, 1014], [1016, 1016, 1044, 1044, 1094], [1096, 1096, 1134, 1134, 1458], [1461, 1461, 1483, 1483, 6019], [6022, 6022, 6055, 6055, 6355], [6357, 6357, 6381, 6381, 6578], [6580, 6580, 6609, 6609, 6754], [6756, 6756, 6795, 6795, 7118], [7120, 7120, 7177, 7177, 8707]], "test": "untested"}
{"id": "ttGczm", "name": "squishy noise 2", "author": "fraser", "description": "it squirms.\nhttps://cineshader.com/view/ttGczm", "tags": ["noise", "cineshader"], "likes": 6, "viewed": 9289, "published": 3, "date": "1610691754", "time_retrieved": "2024-07-30T19:45:06.733831", "image_code": "//<3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n//</3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nfloat fbm(vec2 xy, float z, int octs){\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    float a_bound = 0.0;\n    for(int i=0;i<octs;i++){\n        t += a*simplex3d(vec3(xy*f,z*f));\n        f *= 2.0;\n        a_bound += a;\n        a *= 0.5;\n    }\n    return t/a_bound;\n}\nfloat noise_final_comp(vec2 xy, float z){\n    float value = fbm(vec2(xy.x / 200.0+513.0, xy.y / 200.0+124.0), z, 3);\n    value = 1.0-abs(value);\n    value = value*value;\n    return value*2.0-1.0;\n}\nfloat noise_f(vec2 xy, float z){\n        float value = fbm(\n            vec2((noise_final_comp(xy,       z)*15.0+xy.x) / 100.0,\n                 (noise_final_comp(xy+300.0, z)*15.0+xy.y) / 100.0), z*1.5, 5);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nfloat noise_a(vec2 xy, float z){\n        float value = fbm(\n            vec2((xy.x) / 100.0,\n                 (xy.y) / 100.0), z*1.5, 1);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nfloat noise_b(vec2 xy, float z){\n        float value = fbm(\n            vec2((xy.x) / 100.0,\n                 (xy.y) / 100.0), z*1.5, 2);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nvec2 noise_c(vec2 xy, float z){\n        vec2 value = \n            vec2((noise_final_comp(xy,       z)*15.0),\n                 (noise_final_comp(xy+300.0, z)*15.0));\n        value.x = max(0.0, min(1.0, (value.x*0.5+0.5)/10.0));    \n        value.y = max(0.0, min(1.0, (value.y*0.5+0.5)/10.0));    \n        return value;\n}\nfloat noise_e(vec2 xy, float z){\n        float value = fbm(\n            vec2((xy.x) / 100.0,\n                 (xy.y) / 100.0), z*1.5, 5);\n                 \n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord*500.0/iResolution.x;\n\n    float pA = noise_a(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    float pB = noise_b(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    vec2  pC = noise_c(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    float pE = noise_e(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    float pF = noise_f(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    \n    vec3 c1 = vec3(152.0,193.0,217.0)/255.0;\n    vec3 c2 = vec3(224.0,251.0,252.0)/255.0;\n    vec3 c3 = vec3(238.0,108.0,77.0)/255.0;\n    vec3 c4 = vec3(41.0,50.0,65.0)/255.0;\n    \n    \n    // Mouse code based (loosely) from iq (https://www.shadertoy.com/view/4djSDy)\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=1.0;\n    \n    float sAB=step((8.0  *fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float sBC=step((4.0  *fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float sCE=step((2.685*fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float sEF=step((2.0  *fragCoord.x-iResolution.x) / iResolution.y-s,0.0);\n    float p =pA*sAB+pB*(1.0-sAB)*sBC+pE*(1.0-sCE)*sEF+pF*(1.0-sEF);\n    vec3 col = clamp(p*1.5-0.75,0.0,1.0)*1.0*c2+(1.0-clamp(abs(p-0.5)*5.0,0.0,1.0))*c3;\n    \n    col+=(pC.x*c1+pC.y*c4)*(1.0-sBC)*sCE;\n    \n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n                   \n    fragColor = vec4(col,p*clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGczm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 90, 90, 263], [370, 393, 418, 669, 1569], [1570, 1639, 1677, 1677, 1918], [1919, 1919, 1960, 1960, 2116], [2117, 2117, 2149, 2149, 2400], [2401, 2401, 2433, 2433, 2614], [2615, 2615, 2647, 2647, 2828], [2829, 2829, 2860, 2860, 3149], [3150, 3150, 3182, 3182, 3363], [3364, 3364, 3419, 3419, 5095]], "test": "untested"}
{"id": "WtKyRw", "name": "Path to Shrine", "author": "intrakits", "description": "This was my experiment at generating some objects in loops to make larger more interesting scenery. This was inspired by Japanese Tori gates. Finally got a sky to work :).", "tags": ["3d", "path", "shrine", "gate", "tori"], "likes": 2, "viewed": 238, "published": 3, "date": "1610689419", "time_retrieved": "2024-07-30T19:45:07.500780", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float offX, float offY, float offZ) {\n\ta.x += offX;\n    b.x += offX;\n    \n    a.y += offY;\n    b.y += offY;\n    \n    a.z += offZ;\n    b.z += offZ;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat toriGen (vec3 p, float offSet){\n    float tori;\n    float lLeg = sdCylinder(p, vec3(0,0,0), vec3(0,4,0), .5-.08*p.y, 1.6, -1.4, offSet);\n    tori = lLeg;\n    tori = smin(tori, lLeg,.1);\n    float rLeg = sdCylinder(p, vec3(0,0,0), vec3(0,4,0), .5-.08*p.y, -1.6, -1.4, offSet);\n    tori = smin(tori, rLeg,.1);\n    \n    float horizB = sdCylinder(p, vec3(-3,0,0), vec3(3,0,0), .4-.1*abs(p.x)-.4*abs(p.z-offSet), 0., 3., offSet);\n    tori = smin(tori, horizB,.4);\n    return tori;\n}\nfloat GetDist(vec3 p){\n \n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n   // float ds = length(p-sphere.xyz)-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    \n    //ground plane\n    float dp =p.y;\n    //rocks\n    float dr =p.y-.4;\n   \n    //grass displacement\n    vec2 uv = vec2(p.x,p.z);\n    float disp = texture(iChannel0,uv).r;\n    \n    //rock displacement\n    vec2 uv2 = vec2(p.x*.1,p.z*.1);\n    float dispRocks = texture(iChannel2,uv2).r;\n\n    //add grass\n    disp = smoothstep(4.,.1,abs(disp));\n    //add rocks\n    dispRocks = smoothstep(.1,1.,dispRocks);\n    \n    //apply displacement\n    dp -= disp*.5;\n    dr -= dispRocks * .5;\n    //add grass to scene\n    float d = dp;\n    \n    //add rocks to scene\n    d = min(d, dr);\n    \n    //add hills\n    d += (sin(p.x+sin(p.x+cos(p.z))) +1.)*(cos(p.z+cos(p.z+cos(p.x))) +1.)*.1;\n    d += sin(p.x*.1)+1.;\n\n    //add path\n    \n    float path = dBox(p-vec3(0,-.8,0), vec3(1,1.,100));\n    float pathM = (pow(sin(p.z*20.),8.)*.1 + .1) * (pow(sin(smoothstep(.8,-.8,p.x)*20.),8.)*.1 + .1);\n    path -= pathM; \n    path *=.6;\n    d = smin(d,path,.4);\n    //add tori\n   \n    \n    for(int i = -20; i < 20; i++){\n        float tori = toriGen (p, float(i*2));\n        d = smin(tori,d,.1);\n    }\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds*.8;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,50,6);\n    \n    lightPos.xz *= Rot(sin(iTime*.05)*50.);\n    //light vector\n    vec3 l = normalize(lightPos-p+vec3(0,0,0));\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(4,6,1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    float y = p.y+10.;\n    col = vec3(0,y*.01,y);\n    \n    //color objects\n    if(d < MAX_DIST){\n        \n        //get normals\n        vec3 n = abs(GetNormal(p));\n        \n        //floor color\n        vec2 uv2 = vec2(p.x*.1,p.z*.1);\n        float dispRocks = texture(iChannel2,uv2).r;\n        float dr =p.y-.4;\n        dispRocks = smoothstep(.1,1.,dispRocks);\n        dr -= dispRocks * .5;\n        \n        dr += (sin(p.x+sin(p.x+cos(p.z))) +1.)*(cos(p.z+cos(p.z+cos(p.x))) +1.)*.1;\n        dr += sin(p.x*.1)+1.;\n        \n\n        float plane = p.y;\n        plane += (sin(p.x+sin(p.x+cos(p.z))) +1.)*(cos(p.z+cos(p.z+cos(p.x))) +1.)*.1;\n        plane += sin(p.x*.1)+1.;\n        //uv for ground\n        col = plane*vec3(0,.6,0);\n        \n        //more ground colors \n        col = max(col,sin(p.x+sin(p.x+sin(p.x+sin(p.x*p.z)))) * cos(p.z) *vec3(1,.5,0.3)*vec3(.5));\n\n        //rock colours\n        vec3 rocks=((dr) *vec3(1)*10.);\n        rocks = abs(rocks-1.)*.6;\n           \n        float offset =abs(sin(p.x*10.+atan(p.x*10.+tan(p.x*10.+tan(p.x*10.))))*sin(p.z*10.+cos(p.z*10.+cos(p.z*10.+tan(p.z*10.))))-1.);\n        \n        \n        col = max(col,rocks);\n        \n        //path colours\n        float path = dBox(p-vec3(0,-1.,0), vec3(1,1.,100));\n        \n        float pathM = (pow(sin(p.z*20.),8.)*.1 + .1) * (pow(sin(smoothstep(.8,-.8,p.x)*20.),8.)*.1 + .1);\n        path -= pathM; \n        path *=.6;\n        col = min(col,path*vec3(1.));\n        path= 1./path;\n        col = max(col,path*vec3(.01)*.1);\n        \n      //  col *= 1./path;\n        //get diffuse lighting\n        float diff = GetLight(p);\n        col *= vec3(diff)*1.3;\n        \n        \n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 151], [152, 152, 239, 239, 640], [642, 642, 691, 714, 1147], [1149, 1149, 1179, 1179, 1250], [1252, 1252, 1279, 1279, 1318], [1319, 1359, 1400, 1400, 1472], [1474, 1514, 1552, 1552, 1649], [1651, 1691, 1732, 1732, 1804], [1805, 1805, 1842, 1842, 2288], [2289, 2289, 2311, 2708, 3780], [3781, 3781, 3814, 3842, 4247], [4248, 4248, 4271, 4310, 4673], [4674, 4674, 4697, 4732, 5673], [5674, 5674, 5724, 5724, 5915], [5916, 5916, 5973, 6055, 8324]], "test": "untested"}
{"id": "wtyczw", "name": "Surface Wanderers", "author": "oneshade", "description": "Dots following a surface! You can rotate the object with the mouse. If you would like to try different objects, you can modify the mapSurface() function in common. You can also change the number of wanderers and their size in common.", "tags": ["3d", "sdf", "animation", "wandering", "surfacefollowing"], "likes": 5, "viewed": 151, "published": 3, "date": "1610671605", "time_retrieved": "2024-07-30T19:45:08.264738", "image_code": "vec4 mapScene(in vec3 p) {\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 6.28;\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    p.xz *= mat2(cy, -sy, sy, cy);\n\n    float cx = cos(mouse.y), sx = sin(mouse.y);\n    p.yz *= mat2(cx, -sx, sx, cx);\n\n    float surface = mapSurface(p);\n\n    float wanderers = 1000000.0;\n    for (int w=0; w < WANDERERS; w++) {\n        vec3 wandererPos = fetch(iChannel0, ivec2(w, 0)).xyz;\n        wanderers = min(wanderers, length(p - wandererPos) - SIZE);\n    }\n\n    return surface < wanderers ? vec4(surface, vec3(0.0, 1.0, 0.0)) : vec4(wanderers, vec3(0.6, 0.4, 0.0));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,\n                          mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,\n                          mapScene(p + e.yyx).x - mapScene(p - e.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec4 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += d.yzw;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define WANDERERS 15\n#define SIZE 0.15\n\n#define fetch(buf, addr) texelFetch(buf, addr, 0)\n\n#define BSPHERE 2.0\nfloat mapSurface(in vec3 p) {\n    float c = cos(p.y), s = sin(p.y);\n    p.xz *= mat2(c, -s, s, c);\n    return (length(p) - 1.5 + dot(sin(p * 2.0), vec3(1.0)) * 0.2) * 0.8;\n}\n\nvec3 getSurfNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapSurface(p + e.xyy) - mapSurface(p - e.xyy),\n                          mapSurface(p + e.yxy) - mapSurface(p - e.yxy),\n                          mapSurface(p + e.yyx) - mapSurface(p - e.yyx)));\n}", "buffer_a_code": "vec3 Hash13(in float x) {\n   x += iDate.w;\n   vec3 p = fract(x * vec3(0.1031, 0.103, 0.0973));\n   p += dot(p, p.yzx + 33.33);\n   return fract((p.xxy + p.yzz) * p.zyx); \n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat snoise(in float x) {\n    float local = fract(x);\n    local *= local * (3.0 - 2.0 * local);\n    return mix(Hash11(floor(x)), Hash11(ceil(x)), local);\n}\n\nfloat fnoise(in float x) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int octave=0; octave < 8; octave++) {\n        value += snoise(x) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale * 10.0 - 5.0;\n}\n\nvec3 getPerpVec(in vec3 v) {\n    vec3 perp = vec3(-v.y, v.x, 0.0);\n    vec3 a = abs(v);\n    if (a.x <= a.y && a.x <= a.z) {\n        perp = vec3(0.0, -v.z, v.y);\n    }\n\n    if (a.y < a.x && a.y < a.z) {\n        perp = vec3(-v.z, 0.0, v.x);\n    }\n\n    return perp;\n}\n\n// Rotate on axis, from tdhooper (https://www.shadertoy.com/view/WlKyzW) who in turn got it from blackle\nvec3 axisRot(in vec3 p, in vec3 ax, in float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (iFragCoord.x < WANDERERS && iFragCoord.y == 0) {\n            vec3 ro = normalize(Hash13(fragCoord.x) * 2.0 - 1.0);\n            vec3 rd = -ro;\n            ro *= BSPHERE;\n\n            float t = 0.0;\n            for (int i=0; i < 100; i++) {\n                vec3 p = ro + rd * t;\n                float d = mapSurface(p);\n                if (d < 0.001) {\n                    fragColor.xyz = p;\n                }\n\n                if (t > 2.0 * BSPHERE) {\n                    break;\n                }\n\n                t += d;\n            }\n        }\n    }\n\n    if (iFrame > 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        if (iFragCoord.x < WANDERERS && iFragCoord.y == 0) {\n            fragColor = fetch(iChannel0, iFragCoord);\n            float wandererSpeed = Hash11(fragCoord.x * 835.478 + 345.524) * 0.1;\n            vec3 n = getSurfNormal(fragColor.xyz);\n            fragColor.xyz += wandererSpeed * axisRot(getPerpVec(n), n, fnoise(float(iFrame) * wandererSpeed + fragCoord.x * 238.748));\n            fragColor.xyz -= n * mapSurface(fragColor.xyz);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtyczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 627], [629, 629, 656, 656, 915], [917, 917, 972, 972, 1576]], "test": "untested"}
{"id": "3tKyRD", "name": "Dragon Egg Shell", "author": "Plento", "description": " wip. Kinda chuggy in full screen at the moment.", "tags": ["2d", "waves", "bump"], "likes": 15, "viewed": 457, "published": 3, "date": "1610662849", "time_retrieved": "2024-07-30T19:45:09.070584", "image_code": "// Cole Peterson\n\nvec3 t(vec2 p){\n    return texture(iChannel0, p).xyz;   \n}\n\nfloat height(vec2 p){\n    return t(p).r;\n}\n\nvec3 bump(vec2 uv, float strength){\n    float h = 0.002;\n    \n    vec3 p = t(uv); \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength); \n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 col = ch(iChannel0, u).xyz;\n    \n    vec2 cuv =  vec2(u.xy - 0.5*R.xy)/R.y; \n    vec3 lp = vec3(.1, .1, -1.);\n    \n    vec3 sp = vec3(cuv, 0.0);\n    vec3 ro = vec3(0, 0, -1.);\n    vec3 rd = normalize(sp - ro);\n    vec3 ld = lp - sp;\n    \n    float dist = max(length(ld), 0.001);\n    ld /= dist;\n    vec3 objCol = t(uv);\n    \n    vec3 norm = bump(uv, 35.);\n    \n  \tvec3 tt = texture(iChannel1, norm).xyz;\n    float dif = max(dot(norm, ld), 0.6);  \n    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 13.); \n    \n    float falloff = .35/(dist*dist);\n    col = objCol * falloff * dif;\n    \n    if(length(objCol) > .01)\n        col += tt*spec*0.85;\n    \n    f = vec4(col, 1.0);\n}\n\n\n\n\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan,  ivec2(p), 0)\n\nconst float pi = 3.14159;\n\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat octnse(vec2 p, float t, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.y+=t;\n     \tn += perlin(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}", "buffer_a_code": "\n\nfloat h(vec2 uv, float t, float nse){\n    float sum = 0., amp = .1;\n    \n    sum += cos(t*2. + 12.3)*amp*3.;\n    sum += cos(t*4. + 65.)*amp*3.7;\n    sum += cos(t*8. + 23.)*amp*2.5;\n    sum += cos(t*12. + 7.2)*amp*2.5;\n    sum += cos(t*52. + 4.2)*amp*.3;\n    \n    float nse2 = octnse(uv*3., 0., 10) * .5;\n    \n    sum += nse * .85;\n    \n    sum /= 4.;\n    \n    return sum;\n}\n\nvec3 pal(float t, float a, float b, vec3 prd, vec3 shift){\n    return a + b*cos(prd*t + shift);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 nuv = vec2(u.xy - .5*R.xy)/R.y;\n    vec3 col = vec3(.2);\n    \n    float yy = uv.x-.5;\n    float aa = 1.+abs(exp(abs(-3.5*(yy*yy))));\n    \n    uv -= .5;\n    uv *= aa;\n    uv += .5;\n    \n    uv.y+= .7;\n    uv.x+=iTime*.2;\n   \n    vec3 landCol = vec3(0);\n    \n    float yp = .5;\n    for(float i = 0.; i < 17.; i++){\n        yp = i*.1;\n\n        float nse = octnse((uv + i*23.3)*3., 0., 8) * .5;\n        float height = .5-(uv.y + h(uv + i*33., uv.x + i*10., nse*.9));\n        float land = ss(.001, -.001, height+yp);\n        \n        vec3 lc = pal(3.*uv.x+i, .5, .11, vec3(1.4, .0, .5), vec3(.0, 1., 1.));\n        vec3 lc2 = .8*pal(3.*uv.x+i, .57, .1, vec3(0.0, 1.0, .0), vec3(2.0, 1., 1.));\n        \n        if(i!=16.)\n            landCol = mix(lc, lc2, nse*.9);\n        else\n            landCol = vec3(.2);\n        \n        col = mix(col, landCol, land);\n        \n        float ed = ss(-.002, .002, abs(height + yp) - .01);\n        col *= ed;\n    }\n    \n    col = pow(col*2., vec3(6.0));\n    col *= ss(.1, .4, 1.-abs(nuv.x));\n    f = vec4(col, 1.);\n}\n\n\n\n\n\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 33, 33, 76], [78, 78, 99, 99, 120], [122, 122, 157, 157, 390], [392, 392, 432, 432, 1192]], "test": "untested"}
{"id": "wdyyRh", "name": "camouflage", "author": "yurka", "description": "camouflage", "tags": ["camouflage"], "likes": 4, "viewed": 269, "published": 3, "date": "1610659899", "time_retrieved": "2024-07-30T19:45:09.833544", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitFreqs(iTime);\n    InitFreqs2(iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float value = 0.0;\n    \n    for (int oi = 0; oi < freqs_count; oi++)\n    {\n        value += freqs[oi].a * sin(freqs[oi].xfreq * uv.x * 3.14 * 2.0 + freqs[oi].yfreq * uv.y * 3.14 * 2.0 + freqs[oi].phase);\n    }\n\n    float value2 = 0.0;\n    \n    for (int oi = 0; oi < freqs_count; oi++)\n    {\n        value2 += freqs2[oi].a * sin(freqs2[oi].xfreq * uv.x * 3.14 * 2.0 + freqs2[oi].yfreq * uv.y * 3.14 * 2.0 + freqs2[oi].phase);\n    }\n\t\n\n    vec3 col1 = vec3(0.5, 0.75, 0.01);\n    vec3 col2 = vec3(0.02, 0.63, 0.001);\n    vec3 col3 = vec3(0.6, 0.6, 0.03);\n    vec3 col4 = vec3(0.00, 0.00, 0.000);\n    // discrete:\n    vec3 col = value < 0.0 ? value2 < 0.0 ? col1 : col3 : value2 < 0.0 ? col2 : col4;\n    // smooth:\n    //vec3 col = value < 0.0 ? (-value) * col1 : value * col + value2 < 0.0 ? (-value2) * col3 : value2 * col4;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define MAX_FREQS 20\n#define MPI 3.14159265359\nfloat timescale = 1.50;\n\nfloat random (in vec2 _st) {\n     return fract(sin(1.0+dot(_st,vec2(127.1,311.7)))*43758.545); \n}\n\nfloat random (in float _st) {\n    return fract(sin(dot(vec2(_st, 0.0),\n                         vec2(127.1,311.7)))*\n        43758.545);\n}\nfloat lastrandom = 0.0;\nfloat nextrandom(float a)\n{\n    float r = random (lastrandom + a);\n    lastrandom = r;\n    return r;\n}\n\nstruct freq\n{\n    float a;\n    float phase;\n\tfloat xfreq;\n    float yfreq;\n};\n    \nfreq freqs[MAX_FREQS];\nfreq freqs2[MAX_FREQS];\nint freqs_count = 0;\n\nvoid InitFreqs(float iTime)\n{\n    int oc = freqs_count = 0;\n    lastrandom = floor(iTime*timescale);\n    for (int i = 0; i < MAX_FREQS; i++)\n    {\n        freqs[oc].a = nextrandom(float(i*5 + 0) / 5.0);\n    \tfreqs[oc].xfreq = (nextrandom(float(i*5 + 1) / 5.0)*2.0 - 1.0) * (1.0 - freqs[oc].a) * (float(MAX_FREQS));\n    \tfreqs[oc].yfreq = (nextrandom(float(i*5 + 2) / 5.0)*2.0 - 1.0) * (1.0 - freqs[oc].a) * (float(MAX_FREQS));\n    \tfreqs[oc].phase = nextrandom(float(i*5 + 3) / 5.0) * 2.0 * MPI;\n\n    \toc = ++freqs_count;\n    }\n}\n\nvoid InitFreqs2(float iTime)\n{\n    int oc = freqs_count = 0;\n    lastrandom = floor(iTime*timescale) + 4.178;\n    for (int i = 0; i < MAX_FREQS; i++)\n    {\n        freqs2[oc].a = nextrandom((float(i)*5.0 + 0.2) / 5.0);\n    \tfreqs2[oc].xfreq = (nextrandom((float(i)*5.0 + 1.4) / 5.0)*2.0 - 1.0) * (1.0 - freqs2[oc].a) * (float(MAX_FREQS));\n    \tfreqs2[oc].yfreq = (nextrandom((float(i)*5.0 + 2.6) / 5.0)*2.0 - 1.0) * (1.0 - freqs2[oc].a) * (float(MAX_FREQS));\n    \tfreqs2[oc].phase = nextrandom((float(i)*5.0 + 3.7) / 5.0) * 2.0 * MPI;\n\n    \toc = ++freqs_count;\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1091]], "test": "untested"}
{"id": "wlGyRw", "name": "Complex Number Tetration", "author": "CelestialAmber", "description": "Tetration with complex numbers.", "tags": ["tetration"], "likes": 3, "viewed": 231, "published": 3, "date": "1610658977", "time_retrieved": "2024-07-30T19:45:10.698231", "image_code": "float arg(vec2 c){\n    return atan(c.y,c.x);\n}\n\n\n\nvec2 complexPow(vec2 a, vec2 b){\n    float coefficient = pow(dot(a,a), b.x/2.0)*exp(-b.y*arg(a));\n    float innerValue = b.x*arg(a) + 0.5*b.y*log(dot(a,a));\n    \n    return coefficient*vec2(cos(innerValue),sin(innerValue));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 pos = uv - vec2(0.0,0.0); \n    \n    pos *= 2.5;\n  \n    int iterations = 100;//int(mod(iTime*10.0, 80.0));\n    \n    vec3 col1 = vec3(0,0,0), col2 = vec3(1,1,1);\n    vec3 col = col1;\n    \n    vec2 power = pos;\n    vec2 c = power;\n    \n    for(int i = 0; i < iterations; i++){\n        c = complexPow(power,c);\n        \n        if(dot(c,c) > 2500.0){\n            float value = smoothstep(0.0,log(float(iterations)),float(i));\n            \n            col = mix(col,col2,value);\n            break;\n        }\n    }\n    \n    fragColor = vec4(col,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 46], [50, 50, 82, 82, 275], [278, 278, 335, 385, 1010]], "test": "untested"}
{"id": "wtVyRW", "name": "field art", "author": "FabriceNeyret2", "description": "reference:  image from Tyler Hobbs Art \n[img]https://i.imgur.com/uiKQAeR.png[/img]\nmore: [url]https://tylerxhobbs.com/essays/2020/flow-fields[/url]", "tags": ["flow", "field", "lic", "reproduction"], "likes": 23, "viewed": 761, "published": 3, "date": "1610648909", "time_retrieved": "2024-07-30T19:45:11.527016", "image_code": "// sampling inspired from https://www.shadertoy.com/view/lljczz\n\n#define srnd(p,s) ( 2.* fract( 4e4* sin( 1e3* mat2(1,7.1,-5.1,2.3) * (p) + 1e3*s )) -1. )\n#define SQR(x)    ( (x)*(x) )\n\n#define f(U) sin( vec2(5,3)*(U) + cos( (U)*mat2(3,10,-4,1) ) )\n//#define f(U) sin( mat2(5,1,3,2)*U + cos( U*mat2(3,10,-4,1) ) )\n\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (2.*u-R)/R.y, p, P, X,V, x;\n    O-=O;\n         \n    float v, n =   11., // R.y/32., // 11.                // number of cells (optim)\n          l = .08,                                        // stokes length\n          d = min( 90.*pow((1.-U.y)/2.,1.7)*R.y/360., 2e2);   // strokes density\n    int N = 3; // int(3.*R.y/360.);                       // Neighborhood size = NxN . goes with l\n\n    p = floor(U*n+.5) / n;                                // cell center (NB: we should deffered /n )\n\n    for( int i=0; i<N*N; i++)                             // Worley optim. allows overflow to neighbor cell\n      for( float j=0.; j<d; j++) {                        // density loop\n        P = p + vec2( i%N -N/2, i/N -N/2 ) / n;           // cell coordinate in neighborhood\n        P +=     .5* srnd( round(P*n) , j) / n;           // jittering (round: for precision issues)\n        X = U-P,                                          // local coordinate\n        V =  f(.5*U);    // f(.5*P)                       // local field. f(U): curvy f(P): tangent \n     // V = vec2( -dFdy(V.x),dFdx(V.x) ) * R.y;           // divergence-free  (WIP)  \n#if 1\n        v = dot ( X , V );                                // distance to segment\n     // v /= fwidth(v);\n        v /= length(V) * 2.5/R.y;\n        O += (1.-O)*                                      // blend ( comment out for add )\n             .5*   max( 0., 1. - 1.3*abs(v) )             // draw segment of dir V and length .04\n               * clamp( ( l - length(X) ) *R.y ,0.,1.);\n#else                                                     // trying thinner AA (WIP)\n        x = 2.*(n*X)-0.;\n     // v = 2.*sqrt( max(0.,  1. - dot(x,x) + SQR(dot(x,V))/dot(V,V) ) );  \n        float b = dot(x,V)/length(V),c=dot(x,x)-1., d = b*b-c, m,M;  // |X+kV/V|=1 , clamped to [-l,l]\n        v = d>0. ? min(l*2.*n,-b+sqrt(d)) - max(-l*2.*n,-b-sqrt(d)) : 0.; // segment - pixel-disk intersection length\n        O += v*40./R.y;\n#endif\n}\n    \n    O -=  max(0., length(U)-.8 ) *R.y;                    // white out of circle\n    O = sqrt(1.-O);                                       // reverse + to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 354, 354, 2528]], "test": "untested"}
{"id": "ttKczD", "name": "Fan Out - Psychedelic ", "author": "YitingLiu", "description": "Move your mouse and enjoy your psychedelic experience. ", "tags": ["mouse", "time", "generative", "fan", "visuals"], "likes": 0, "viewed": 262, "published": 3, "date": "1610642497", "time_retrieved": "2024-07-30T19:45:12.360786", "image_code": "\n#define TWO_PI 6.28318530718\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(4.000,0.226,2.239)*iMouse.y,\n                             6.0)-abs(cos(iTime))*2.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 st_mouse = fragCoord.xy/iMouse.xy;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*4.0;\n    \n    if (iMouse.xy==vec2(0)){\n    color = hsb2rgb(vec3((angle/TWO_PI)*iTime+0.5,radius,1.0));\n}\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3((angle/TWO_PI)*iTime+0.5,radius*(st_mouse.y+st_mouse.x),1.0));\n\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 321], [324, 324, 381, 381, 995]], "test": "untested"}
{"id": "wtVyzD", "name": "Mouse Shapes", "author": "YitingLiu", "description": "experiment with mouse interaction and rectangles. ", "tags": ["mouse", "interactive", "time", "rectangle", "shape"], "likes": 1, "viewed": 263, "published": 3, "date": "1610642244", "time_retrieved": "2024-07-30T19:45:13.138707", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec2 st_mouse = fragCoord.xy/iMouse.xy;\n    vec3 color =vec3(0.2*abs(sin(iTime)),0.5*abs(sin(iTime)),0.6*abs(sin(iTime)));\n\n    // bottom-left\n    vec2 bl = step(vec2(0.1*abs(tan(st_mouse.x))),st);\n    float pct = bl.x * bl.y;\n\n    // top-right\n    vec2 tr = step(vec2(0.1*abs(sin(st_mouse.y))),1.0-st);\n    pct *= tr.x * tr.y;\n\n\n    color = vec3(pct*color*st_mouse.y*abs(sin(iTime)));\n\n    fragColor = vec4(color,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 526]], "test": "untested"}
{"id": "ttKczW", "name": "Simple 1-bit Image Filter", "author": "jtodaone", "description": "A fragment shader that transforms a texture to 1-bit style via random dithering. This does not work well with a moving image, because it relies on randomness.", "tags": ["2d", "retro", "filter", "dither", "image", "dithering"], "likes": 1, "viewed": 416, "published": 3, "date": "1610629831", "time_retrieved": "2024-07-30T19:45:13.908648", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat randomBounds(float lower, float upper, vec2 st) {\n    return random(st) * (upper - lower) + lower;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    const vec3 tint = vec3(0.85, 0.95, 1);\n    \n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    float luminance = dot(col, W);\n    \n    luminance += randomBounds(-0.5, 1.0, uv);\n    \n    if (luminance > 0.9) {\n        luminance = 1.0;\n    } else {\n        luminance = 0.0;\n    }\n    \n    col = vec3(luminance);\n    col = col * tint;\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 131], [133, 133, 188, 188, 239], [241, 241, 298, 298, 762]], "test": "untested"}
{"id": "tlKyRW", "name": "Day 393", "author": "jeyko", "description": "forestato", "tags": ["mdtmjvm"], "likes": 26, "viewed": 533, "published": 3, "date": "1610615950", "time_retrieved": "2024-07-30T19:45:14.870077", "image_code": "// Fork of \"Day 378\" by jeyko. https://shadertoy.com/view/wlcyRB\n// 2021-01-14 08:03:23\n\n// Fork of \"Day 378\" by jeyko. https://shadertoy.com/view/WttyD7\n// 2020-12-30 10:41:15\n\n\n\n// Cyclic noise from nimitz\n// smooth ops & sdfs from IQ\n// pModPolar from hgSDF\n// FXAA by Reinder Nijhoff \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col *= vec3(0.9,0.9,0.76);\n    col *= 1.6;\n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.1,1.15,1.3 ))*1.1,0.5);\n    col = mix(acesFilm(col), col, 0.);\n    //col *= 1. - dot(uv,uv*0.4)*2.;\n    col = mix(col, col*col*col*0.5, dot(uv,uv*0.4)*2.4);\n    \n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool hit = false;\n\n// General\n#define groundOffs vec3(0,3.4,0)\n\n#define marchSteps 400\n//#define marchEps  (mix(0.004,0.26,smoothstep(0.,1.,t*0.1 - 2.)))\n\n\n#define marchEps  (mix(0.004,0.2,smoothstep(0.,1.,t*0.1 - 2.)))\n#define maxDist 100.\n\n//#define distScale 0.7\n#define distScale  (mix(0.7,1.,smoothstep(0.,1.,t*0.1 - 2.)))\n\n\n// Trees\n#define treesSeperation 6.\n\n#define treeBranchSeperation 1.2\n\n#define trunkW 0.25\n\n// Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 14.\n\n#define cloudSteps 0.\n#define volumetricDithAmt .05\n\n// Wind\n#define windSteps 17.\n#define maxWindD 30.\n\n// Atmosphere\n#define sunCol vec3(0.8,0.9,0.8)*1.2\n#define sunPos (vec3(5.31,1.92 ,2.)*1300.)\n\n#define planetSz 2984.\n#define atmoSz (planetSz/63.)\n\n\n#define ambianceScale 0.4\n\n#define itersAtmo 5.\n#define itersOptic 5.\nconst float redLightLen = 690.;\nconst float greenLightLen = 540.;\nconst float blueLightLen = 410.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 1.9;\n\n\n#define sss(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n#define ao(a) clamp(map(p + normalize(mix(n, sunDir, 0.39))*a).x/a,0., 1.)\n#define aoVol(p, a, dir) smoothstep(0.,1.,map(p + dir*a).x/a*1.5)\n\n#define pi acos(-1.)\n\n#define pal(a,b,c,d,e) ((a + (b)*sin((c)*(d) + (e))))\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nvec2 dmin(vec2 a, vec2 b){return a.x < b.x ? a : b;}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView);\nmat3 getRd(vec3 ro, vec3 lookAt);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*/\n\n \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\n\n\nfloat cyclicNoiseClouds(vec3 p, bool turbulent, float t){\n    float noise = 0.;\n    \n    float amp = 0.43;\n    const float gain = 0.77;\n    const float lacunarity = 1.6;\n    const int octaves = 6;\n    \n    const float warp = 0.46;    \n    float warpTrk = 1.9;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1.4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(sin(p.zxy + t*0.05\n        )*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy  )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return max(-0. - (noise)*0.6,0.);\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseGrass(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 2;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseWind(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseTreeBark(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 2.;\n    const float gain = 0.5;\n    const float lacunarity = 1.25;\n    const int octaves = 4;\n    \n    const float warp = 1.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseGround(vec3 p, bool turbulent, bool lowIterations){\n    p *= 0.2;\n    float noise = 0.;\n    \n    float amp = 2.;\n    const float gain = 0.5;\n    const float lacunarity = 2.5;\n    int octaves = 3;\n    if(lowIterations)\n        octaves = 1;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5)*0.4;\n\n    }\n}\n\nfloat cyclicNoiseTrees(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.4;\n    const float lacunarity = 2.5;\n    const int octaves = 4;\n    \n    const float warp = 0.85;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    \n    if(turbulent){\n        noise = 1. - abs(noise)*0.5;\n    \n    }{\n        noise = (noise*0.25 + 0.5);\n\n    }\n    noise = pow(noise,2.);\n    return noise; \n}\n\nfloat cyclicNoiseTreesBend(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.4;\n    const float lacunarity = 2.5;\n    const int octaves = 4;\n    \n    const float warp = 0.85;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    \n    if(turbulent){\n        noise = 1. - abs(noise)*0.5;\n    \n    }{\n        noise = (noise*0.25 + 0.5);\n\n    }\n    //noise = pow(noise,2.);\n    return noise; \n}\n\n\n\n/*\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}*/\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat turbulentNoise(vec3 p, bool md) {\n\tp += 8.;\n    vec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    //f = u;\n\tfloat n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\tfloat ix2 = mix(n4, n5, u.x);\n\tfloat ix3 = mix(n6, n7, u.x);\n\n\tfloat ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;\n\tret = ret * 1.;\n    \n    //ret = 1.- ret;\n    //ret = abs(ret);\n    if (md)\n        ret = mix(ret,smoothstep(0.3,1.,ret*0.8),0.6);\n    return ret;\n}\n\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    vec3 sunPosAtmo = sunPos + offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(hit){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t/50. - 1.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPosAtmo - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n}\n\nvec3 getRdUV(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return normalize(dir + right*uv.x + up*uv.y); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    //vec3 lookAt = ro + offs;\n    //vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    //uv = ouv;\n    //uv.x = v.x;\n    //uv.y = v.y;\n    \n    return v;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n#define opRepLim(p,c,l) (p-(c)*clamp(round((p)/(c)),-(l),(l)))\n\nfloat pModPolar(inout vec2 p, out float id, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n    id = floor(a/angle);\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}", "buffer_a_code": "\n#define TAA false\n\nvec3 getNormal(vec3 p);\nvec3 getSun(vec2 uv, vec2 sunPosUV, vec3 sunPosW, vec3 ro, mat3 vp);\nfloat t = 0.;\nfloat invisibleWall = 10e4;\n\nfloat groundNoise = 0.;\nfloat treebarkNoise = 0.;\n\n\nfloat ng = 0.;\n\n\nfloat fp(float z){return sin(z*0.15 + cos(z*0.05 + sin(z*0.04)));}\n\nvec3 getPath(vec3 p){\n    return vec3(fp(p.z),0.,0.)*7.;\n    //return vec3(sin(p.z*0.2),0.,0.)*3.;\n\n}\n\n\nfloat mapClouds(vec3 p){\n    float currHeight = p.y;\n    \n    p *= 0.5;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    \n    float fb = cyclicNoiseClouds(p*1. + iTime*0., false,iTime);\n    float f = cyclicNoiseClouds(p*0.4 + iTime*0.04 + fb*0.3, true,iTime);\n    //f = (f*0.4 + cyclicNoise(p*0.5 + f*2. - fb*1.4 + iTime))*cyclicNoise(p*0.2 + 5.+ f*4.);\n        //f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    //f = fb;\n    f = max(f,0.);\n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    return f;\n}\n\n\n\nvec2 getGrass(vec3 p, float groundHeight, float scale, float h){\n    p.y = groundHeight;\n    vec3 op = p;\n    p.xz = pmod(p.xz,vec2(scale));\n    //p = abs(p);\n    \n    p.xz -= scale * 0.25;\n    \n    \n    //p.xz += smoothstep(0.,1.,p.y)*cyclicNoiseGrass(op + vec3(0,iTime*2.,0), false)*0.4*(2. - 1.);\n    \n    //float d = sdVerticalCapsule( p, 0.4, 0.0001 );\n    float d = sdRoundCone( p, 0.04, 0.0001, 0.55*h );\n    return vec2( d, 4.);\n}\n\nvec2 getGround(vec3 p){\n    \n    float d = p.y;\n    groundNoise = cyclicNoiseGround(vec3(p), false, false);\n    \n    d -= groundNoise;\n    \n    return vec2(d,1.);\n}   \n\n\nvec2 getTrees(vec3 po){\n    float d = 10e5;\n    float noise = cyclicNoiseTreesBend(vec3(po)*0.1, false);\n    \n    //float noise = 0.;\n    treebarkNoise = cyclicNoiseTrees(vec3(po.x,po.y*2.2,po.z)*2.4, false);\n    \n    po.xz += noise*.5;\n    vec3 p = po;\n    \n    \n    vec3 id = floor((p)/vec3(treesSeperation, treeBranchSeperation, treesSeperation));\n    \n    p -= getPath(vec3(0.,0.,id.z*treesSeperation + treesSeperation*0.5));\n    id = floor((p)/vec3(treesSeperation, treeBranchSeperation, treesSeperation));\n    \n    p.z = pmod(p.z,treesSeperation);\n    p.x = pmod(p.x,treesSeperation);\n    \n    invisibleWall = abs(abs(p.z) - treesSeperation*0.5) + 0.3;\n    \n    \n    float lpxz = length(p.xz);\n    \n    d = lpxz - trunkW*(1.4 + 1.*sin(id.x*40.0 + id.z*1.4 + id.x*id.z*20.))  + treebarkNoise*0.09*(1. + smoothstep(1.1,0.,p.y)*2.);\n    \n    //p.y -= smoothstep(0.,0.2,(lpxz + 0.2))*0.5;\n    \n    p.y -= 5.;\n    \n    p.y = opRepLim( p.y - treeBranchSeperation*11.  + 0.75*treeBranchSeperation, treeBranchSeperation, 9. );\n    //p.y = pmod( p.y, treeBranchSeperation);\n    \n    \n    //p.y += 0.25*treeBranchSeperation;\n    \n    p.xz *= rot(sin(id.x*40.0 + id.z*1.4 + id.x*id.y*20. + id.y*229. + id.y * id.z*200.)*pi*222.);\n    //p.xz *= rot(sin(id.z)*pi*2.);\n    \n    \n    float polarId;\n    \n    pModPolar(p.xz, polarId, 4.);\n    \n    invisibleWall = min(invisibleWall, abs(abs(p.y) - treeBranchSeperation*0.5) + 0.03);\n    \n    p.yx *= rot(0.5*pi);\n    float mdBranchLen = sin(id.x + id.y + 20.*id.y*id.z +20.*polarId);\n    mdBranchLen = mix(mdBranchLen*0.3, abs(mdBranchLen)*0.9,smoothstep(0.,1.,id.y*0.5 - 0.8));\n    float branchLen = (1.1  + mdBranchLen)*( 0.1 + smoothstep(0.4,1.,id.y*0.4 - 0.5)) ;\n    \n    float branchWidth = abs(sin(branchLen*200.  + polarId*10.));\n    \n    branchLen = max(branchLen, 0.);\n    \n    \n    \n    p.y += branchLen - 0.5;\n    p.x -= pow(smoothstep(0.,2.9,(lpxz - 0.)*1.)/branchLen*1.6,1.)*0.9;\n    \n    \n    //p.x -= noiseb*0.04 + noise*0.0;\n    //branchWidth *= 0.5 + noiseb;\n    \n    //d = opSmoothUnion( d,  sdRoundCone( p, 0.01 + branchWidth*0.02, 0.05 + branchWidth*0.04, branchLen ), 0.09 ) ;\n    \n    //d = min( d,  sdRoundCone( p, 0.03 + branchWidth*0.04, 0.00 + branchWidth*0.0, branchLen )*1.) ;\n    \n    d = min( d,  max(length(p.xz) - 0.02 - .25*smoothstep(0.,1.,p.y/branchLen*0.6), - p.y - branchLen*.5)*0.7 ) ;\n    \n    \n    return vec2(d,3.);\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    vec2 gr = getGround(p);\n    vec2 dTrees = getTrees(p);\n    \n    float grh = groundNoise;\n    \n    ng = cyclicNoiseGrass(vec3(p.x,p.y*0.1,p.z) + vec3(0,iTime*2.,0), false)*0.6*(2. - 1.) + 0.1;\n    \n    dTrees.x = opSmoothUnion( dTrees.x, gr.x, 0.4 );\n    vec3 gp = p;\n    gp.xz += smoothstep(0.,1.,gr*0.6)*ng*1.4;\n    \n    vec2 grass = getGrass(gp, gr.x  + 0.4*(1.-grh*6.), 0.5, 0.8);\n    gp.xz *= rot(0.25);\n    vec2 grassb = getGrass(gp + 0.2, gr.x - 0.4*grh, 0.5, 0.5);\n    gp.xz *= rot(0.5);\n    \n    vec2 grassc = getGrass(gp + vec3(0.25,0,-0.2), gr.x - 0.4*sin(grh*20.), 0.5, 0.89);\n    gp.xz *= rot(0.25);\n    \n    vec2 grassd = getGrass(gp + vec3(0.14,0,-0.2), gr.x  - 0.4*sin(grh*22.), 0.5, 1.3);\n    gp.xz *= rot(0.25);\n    vec2 grasse = getGrass(gp + vec3(0.14,0,-0.2), gr.x  - 0.4*sin(grh*22.), 0.9, 2.);\n    \n    \n    grass = dmin(grass, grassb );\n    grass = dmin(grass, grassc );\n    grass = dmin(grass, grassd );\n    grass = dmin(grass, grasse );\n    \n    \n    \n    d = dmin(d, gr.x - 0.001, grass.y);\n    d = dmin(d, dTrees);\n    \n    d = dmin(d, grass);\n    \n    \n    return d;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord/iResolution.xy);\n    if(TAA){\n        vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n        fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi/4.),cos(float(taaidx.x)*pi/4.))*taaidx.y/4.;\n\n    }\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy - 0.5;\n    vec3 col = vec3(0);\n    float T = iTime*1.9;\n    float dith = r21(fragCoord + sin(iTime*20.)*20.);\n    \n    vec3 sunDir = normalize(sunPos);\n    vec3 ro = vec3(0);\n    ro.z += T;\n    \n    ro.y += cyclicNoiseGround(ro, false,true) + groundOffs.y;\n    //ro += groundOffs;\n    ro += getPath(ro);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 6.51);\n    //lookAt.y -= getGround(lookAt).x;\n    lookAt += groundOffs;\n    lookAt += getPath(lookAt);\n    \n    \n    if(iMouse.z > 0.){\n        lookAt = vec3(\n            ro.x + sin(muv.x*tau*0.5 - pi),\n            lookAt.y + muv.y*0.3 + 0.5,\n            ro.z + cos(muv.x*tau - pi)\n        );\n    \n    }\n\n    mat3 vp = getRd(ro,lookAt);    \n    //vec3 rd = normalize(vec3(uv,1.))*vp;\n    vec3 rd = getRdUV(ro, lookAt, uv);\n    \n    \n    // Marching\n    \n    vec3 p = ro;\n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > maxDist){\n            break;\n        }\n        \n        d = dmin(d,invisibleWall, 10.);\n        \n        p = ro + rd*(t += d.x * distScale*(0.8 + dith*0.));\n    }\n    \n    float depthView;\n    vec3 atmosphere = getAtmosphere(vec3(0,ro.y - 0.,0), rd, t, depthView);\n    \n    \n    \n    // Clouds\n    \n    vec3 cloudRo = ro;\n    vec3 cloudRd = rd;\n    \n    float lowerCloudLimitDist = plaIntersect( cloudRo - vec3(0,cloudsLowerLimit,0), cloudRd, vec4(0,-1,0,0) );\n    float higherCloudLimitDist = plaIntersect( cloudRo - vec3(0,cloudsHigherLimit,0), cloudRd, vec4(0,-1,0,0) );\n    \n    float volumetricDith = dith*volumetricDithAmt;\n    \n    float cloudLength = higherCloudLimitDist - lowerCloudLimitDist; \n    float cloudStepSz = cloudLength/(cloudSteps);\n    vec3 cloudP = cloudRo + rd * ( lowerCloudLimitDist + volumetricDith*cloudLength );\n    \n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps ; i++){\n        float d = mapClouds(cloudP);\n        \n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*0.5  + 0.22, 0., 1. );\n        vec3 diff = mix( atmosphere*0.1 + vec3(0.04,0.07,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.1), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.4, difffact );\n        //vec3 diff = vec3(0.2); \n        vec3 absorption = mix( vec3(0.8,0.85,0.9), vec3(0.5,0.9,0.7)*0.6, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.1,0.5,0.5)*clamp( 1. - d*3., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*2.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    \n    \n\n    \n    // Wind\n    \n    vec3 windP = ro + rd*volumetricDith*0.00 ;\n    float windStepSz = min(t,maxWindD)/windSteps;\n    \n    vec3 windAccum = vec3(0);\n    float windDensTotal = 0.;\n    //vec3 windAccum = vec3(0.);\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*0.51 - vec3(-iTime*1.,smoothstep(0.,1.,windP.y*0.5 - 1.9),0.);\n        float dens = max(cyclicNoiseWind(wp,false,iTime),0.05)*0.121;\n        dens *= smoothstep(1.,0.,windP.y*0.01 + 0.4);\n        \n        vec3 c = mix(\n            vec3(1.4,1.1,0.7)*1.,\n            vec3(0.4,0.44,0.47)*1.,\n            //smoothstep( 0., 1., abs(windP.x)*0.9 - 0.5)\n            smoothstep( 0., 1., length(rd.xy - sunDir.xy)*0.75 + 0.4)\n            \n            );\n        \n        c = mix( c*c*0.4, c, smoothstep(0.,1.,windP.y*0.15 + 0.1));\n        \n        //dens *= aoVol(windP,1.,sunDir)*aoVol(windP,0.6,sunDir)*aoVol(windP,0.2,sunDir)*aoVol(windP,2.2,sunDir)*2.;\n        //dens *= aoVol(windP,1.,sunDir)*aoVol(windP,0.6,sunDir)*aoVol(windP,0.2,sunDir)*aoVol(windP,2.2,sunDir)*2.;\n        \n        \n        dens = dens*(1.-windDensTotal);\n        windAccum += dens*windStepSz*c*1.;\n        windDensTotal += dens*windStepSz;\n        \n        \n        if( windDensTotal > 0.97){\n            break;\n        }\n        windP += rd*windStepSz;\n    }\n    \n\n    // Coloring\n    \n    vec3 hitCol = vec3(0);\n    vec3 ambientCol = atmosphere*1. + vec3(1.,0.4,0.);\n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 prevFrameMip = pow(max(texture(iChannel2,vec2(uv.x,-uv.y),7.).xyz, 0.),vec3(2.)) * float(iFrame > 0);\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),29.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n        fres = max(fres,0.);\n        \n        float AO = ao(0.4)*ao(0.1)*1.;//*ao(.9)*ao(0.05)*;\n        float SSS = sss(.3)*sss(0.04)*sss(.1)*5.;\n        float shad = diff;\n        \n        \n        AO = clamp(AO + 0.2 - pow(treebarkNoise,5.)*2.5,0.,1.);\n        //shad += length(sin(n*0. + p.y*1.))*0.05;\n        \n        //shad = clamp(shad,0.,1.);\n        \n        //AO = clamp(AO - pow(abs(1.-treebarkNoise*0.5),5.)*0.5,0.,1.);\n        \n        vec3 albedo = vec3(0);\n        \n        vec3 treesCol = vec3(0);\n        {\n            albedo = 6.2*vec3(0.26,0.2,0.2)*(sunCol + atmosphere*0.4);\n            \n            float noisePaintBark = cyclicNoiseTreeBark(p*vec3(0.2,3,0.2),true);\n            //albedo = mix(albedo,albedo*albedo*0.7,smoothstep(0.1,0.,noisePaintBark));\n            albedo *= 1. - 0.9*smoothstep(-0.,-0.5,noisePaintBark);\n            vec3 ambCol = albedo*(sunCol*0.2 + atmosphere*2. + vec3(0.5,0.2,0.1)*0.8)*0.3;\n            //vec3 aoCol = 0.4*albedo*albedo*(sunCol*0.3 + atmosphere*1.4);\n            vec3 aoCol = 0.08*albedo*albedo*vec3(1.,0.7,0.5)*(sunCol + atmosphere);\n            \n                \n            treesCol = mix(ambCol, albedo, shad);\n            \n            treesCol = mix(aoCol, treesCol, AO);\n        \n            //treesCol = mix(aoCol, treesCol, (AO - treebarkNoise*0.1));\n        }\n        vec3 groundCol = vec3(0.);\n        {\n            albedo = vec3(0.8,0.42,0.2)*0.1*(sunCol + prevFrameMip*224.4);\n            vec3 ambCol = albedo*(sunCol*0.2 + atmosphere*5.)*0.4;\n            vec3 aoCol = albedo*albedo*(sunCol*0.3 + atmosphere*1.4);\n            \n            groundCol = mix(ambCol, albedo, shad);\n            groundCol = mix(aoCol, albedo, AO);\n        }\n        vec3 grass = vec3(0.5,0.1,0.05)*1.;\n        grass.x += sin(groundNoise*20.)*0.1;\n        grass.yz += sin(groundNoise*50. + 4.)*0.05;\n        grass.xyz -= (1.-groundNoise)*pow(abs(sin(groundNoise*20. + 4.)),4.)*0.1*vec3(0.,0.9,0.5);\n        \n        //float cloudShad = pow(cyclicNoiseWind(p*0.2 + iTime*0.35,true)*1.,0.7);\n        \n        //cloudShad -= ng*0.2;\n        \n        \n        //grass = mix(grass, vec3(0.4,0.5,0.9)*grass*cloudShad, 0.9);        \n        { \n            //grass = mix( vec3(0.1,0.4,0.1)*0.5,grass,AO);\n            \n            shad = clamp(shad + SSS*.5, 0., 1.);\n            AO = clamp(AO + SSS*1. , 0., 1.)*0.5 + 0.4;\n            grass += (spec + fres*.4)*0.2;\n            //grass = mix( (grass*vec3(0.4,0.4,0.2) + ambientCol*0. + sunCol*(1. - diff)*0.54)*ambianceScale,grass*1.,shad);\n            grass = mix( vec3(0.4,0.1,0.1)*0.5,grass,AO);\n            float aoo = ao(1.9);\n            aoo = smoothstep(0.,0.6,aoo);    \n            grass = mix( grass*vec3(0.5,0.2,0.2)*1.,grass, aoo );\n            \n        }\n        \n        hitCol += grass*float(d.y == 1.);\n        hitCol += treesCol*float(d.y == 3.);\n        hitCol += grass*float(d.y == 4.);\n        \n        }\n    \n\n    // Compositing\n    \n    col += hitCol;\n    \n    if( hit ){ \n       atmosphere *= 1.-pow(exp(-(t)*.02 ),2.);\n    }\n    \n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.02) + exp(-t*0.4));\n    \n    col = col * depthViewFac + atmosphere; \n    \n    \n    /*\n    if (!hit  && lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    */\n    windAccum *= smoothstep(0.,1.,t*0.2 - 1.);\n    col = mix(col, windAccum, pow(min(windDensTotal,1.),1.));\n    \n    //col = (col - windDensTotal) + 1.*windAccum;\n    \n    if(TAA && iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.4);\n    } else {\n        fragColor = col.xyzz;\n    }\n    \n    \n    \n    \n    //fragColor.w = cloudDensTotal*0. + float(hit)*1.;\n    \n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.02).x;\n    }\n    return normalize(n);\n}\n\n\n\nvec3 getSun(vec2 uv, vec2 sunPosUV, vec3 sunPosW, vec3 ro, mat3 vp){\n    \n    vec2 sunUVOriginal = uv;\n    \n    vec2 sunUV = uv - sunPosUV;\n    //float cloudDensPrevFrame = texture(iChannel2, ((sunUV*iResolution.y + 0.5*iResolution.xy)/iResolution.xy)).w;\n    \n    //vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(getRd(ro,sunPosW))).xy;\n    vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(vp)).xy;\n    \n    sunUvPrevFrame = (sunUvPrevFrame*iResolution.y)/iResolution.xy + 0.5;\n    \n    float deltaUV = 0.04;\n    float cloudDensPrevFrame = \n        texture(iChannel2, sunUvPrevFrame + deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame - deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(-deltaUV,deltaUV)).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(deltaUV,-deltaUV)).w\n        ; \n    \n    cloudDensPrevFrame /= 4.;\n    \n    cloudDensPrevFrame = clamp(cloudDensPrevFrame,0.,1.);\n    // sun\n    \n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    // rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        float mda = sin(i*pi/4.);\n        float mdb = sin(i*pi/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPosUV;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPosUV;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    // flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return (sun + sunRays + flares*3.*sunCol) * (1. - cloudDensPrevFrame*1.);\n}\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by Reinder Nijhoff 2016\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/ls3GWS\n//\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n//\n// demonstrating post process FXAA applied to my shader 'Tokyo': \n// https://www.shadertoy.com/view/Xtf3zn\n//\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n//\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n       \n    vec3 col;\n    \n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    \n    fragColor = vec4( col, 1. );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 347, 347, 837]], "test": "untested"}
{"id": "tlyczD", "name": "Spectral Volumetric Path-Tracing", "author": "Zi7ar21", "description": "LoicVDB and I are making volumetric Path-Tracers.", "tags": ["fractal", "julia", "volumetric", "pathtrace", "trace", "path", "spectral"], "likes": 28, "viewed": 801, "published": 3, "date": "1610587587", "time_retrieved": "2024-07-30T19:45:15.637027", "image_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n// Common is for settings and some functions\n// Buffer A is for rendering\n// Buffer B is for exporting a 32-Bit Floating Point OpenEXR Image\n// using the button at the bottom of the editor\n// This is for drawing the shader on the left (or above if you are in portrait mode)\n\n// Spectral Volumetric Path Tracing by Zi7ar21 --- January 13th, 2020\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n\n// Adjustable settings (Feel free to change these!)\n#define maxsteps 8192\n#define stepsize 0.01\n#define camerafov 1.0\n\n// Constants (I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Spectral colors, from https://www.shadertoy.com/view/ls2Bz1\n// Alan Zucconi\nfloat saturate(float x){return min(1.0, max(0.0, x));}\nvec3 saturate(vec3 x){return min(vec3(1.0, 1.0, 1.0), max(vec3(0.0, 0.0, 0.0), x));}\nvec3 bump3y (vec3 x, vec3 yoffset){\n\tvec3 y = vec3(1.0, 1.0, 1.0)-x*x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectralzucconi6(float w){\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w-400.0)/300.0);\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\treturn bump3y(c1*(x-x1), y1)+bump3y(c2*(x-x2), y2);\n}", "buffer_a_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\n\n// 4D Julia set Distance Estimator\nvec4 qsqr(vec4 a){return vec4(a.x*a.x-a.y*a.y-a.z*a.z-a.w*a.w, 2.0*a.x*a.y, 2.0*a.x*a.z, 2.0*a.x*a.w);}\nfloat distanceestimator(vec3 pos, float wavelength){\n\tvec4 z = vec4(pos, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    for(int i = 0; i < 8; i++){\n        md2 *= 4.0*mz2;\n        //z = qsqr(z)+vec4(-0.5, 0.35, 0.5, ((wavelength-400.0)/600.0));\n        z = qsqr(z)+vec4(-0.5, 0.35, 0.5, 0.0);\n        mz2 = dot(z,z);\n        if(mz2 > 4.0) break;}\n    return 0.25*sqrt(mz2/md2)*log(mz2);}\n\n/*float distanceestimator(vec3 pathposition, float wavelength){\n    return distance(pathposition, vec3(0.0))-0.5;\n}*/\n\n// 3D Volumetric Density Function\nfloat densityfunction(vec3 pathposition, float wavelength){\n    float distanceestimation = distanceestimator(pathposition, wavelength);\n    if(distanceestimation < 0.0){return 50.0;}\n    else{return 0.05;}\n}\n\n// Light Collision Checker\nbool light(vec3 pathposition){\n    if(distance(pathposition, vec3(pathposition.x/2.0, 2.0, pathposition.z/2.0))-1.0 < 0.0){return true;}\n    else{return false;}\n}\n\n// Path-Tracing\nfloat pathtrace(vec3 pathdirection, vec3 cameraposition, float wavelength){\n    float density, absorbance, distancetravelled;\n    vec3 pathposition = cameraposition+(pathdirection)+(pathdirection*stepsize*2.0*(rand()-0.5));\n    for(int i = 0; i < maxsteps; i++){\n        density = densityfunction(pathposition, wavelength)/pow(wavelength/500.0, 4.0);\n        absorbance = exp(-density*stepsize);\n        if(absorbance*1.25 < rand()){return 0.0;}\n        if(absorbance < rand()){pathdirection = normalize(nrand3(1.0, vec3(0.0)));}\n        pathposition += pathdirection*stepsize;\n        distancetravelled += stepsize;\n        if(light(pathposition)){return 8.0;}\n        if(distance(pathposition, vec3(0.0)) > 4.0 || distancetravelled > 100.0){break;}\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = oldFragColor;\n    INIT_RNG;\n    vec2 uv = ((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/iResolution.x;\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 pathdirection = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n    float wavelength = (rand()*300.0)+400.0;\n    float pathtraced = pathtrace(pathdirection, vec3(0.0, 0.0, -4.0), wavelength);\n    vec3 col = pathtraced*spectralzucconi6(wavelength);\n    fragColor += vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image! ^^^\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlyczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 465, 465, 527]], "test": "untested"}
{"id": "WlKyzW", "name": "Buckyball Fracture", "author": "tdhooper", "description": "Working on building a compact version of this fracture effect, suggestions very welcome.", "tags": ["explode", "polyhedra", "fracture"], "likes": 70, "viewed": 1229, "published": 3, "date": "1610583808", "time_retrieved": "2024-07-30T19:45:16.408963", "image_code": "#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Rotate on axis, blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n// Sign but returns -1 instead of 0\nvec3 boolSign(vec3 v) {\n    return max(vec3(0), sign(v)) * 2. - 1.;\n}\n\n// Closest icosahedron vertex\nvec3 icosahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3;\n    ap = abs(p);\n    v = vec3(PHI, 1, 0);\n    v2 = v.yzx;\n    v3 = v2.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    return normalize(v) * boolSign(p);\n}\n\n// Closest dodecahedron vertex\nvec3 dodecahedronVertex(vec3 p) {\n    vec3 ap, v, v2, v3, v4;\n    ap = abs(p);\n    v = vec3(PHI);\n\tv2 = vec3(0, 1, PHI + 1.);\n\tv3 = v2.yzx;\n    v4 = v3.yzx;\n    if (distance(ap, v2) < distance(ap, v)) v = v2;\n    if (distance(ap, v3) < distance(ap, v)) v = v3;\n    if (distance(ap, v4) < distance(ap, v)) v = v4;\n    return normalize(v) * boolSign(p);\n}\n\n// Second closest dodecahedron vertex\nvec3 secondDodecahedronVertex(vec3 p, vec3 iv, vec3 dv) {\n    // Find which side of the icosahedron vertex -> dodecahedron vertex line we're on\n    float side = sign(dot(p, cross(iv, dv)));\n    // Rotate dodecahedron vertex around the dodecahedron face\n    return erot(dv, iv, PI * 2. / 5. * side);\n}\n\n// The model to explode\nfloat object(vec3 p) {\n    pR(p.xz, 1.2);\n    pR(p.xy, .3);\n    float d = fBox(p, vec3(.25 - .02)) - .02;\n    d = max(d, -d - .05);\n    return d;\n}\n\n// https://iquilezles.org/articles/functions\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat map2(vec3 p) {\n\n    // Three closest vertices of a spherical pentakis dodecahedron\n    // or, three closest faces of a buckyball\n    vec3 a = icosahedronVertex(p);\n    vec3 b = dodecahedronVertex(p);\n    vec3 c = secondDodecahedronVertex(p, a, b);\n\n    float d = 1e12;\n\n    vec3 pp = p;\n    \n    // Render the nearest three fragments to get\n    // a clean distance estimation\n\n    for (int i = 0; i < 3; i++) {\n\n        // Offset space\n        float t = mod((iTime - dot(a.xy, vec2(1,-1)) / 6.) / 3., 1.);\n        float t2 = min(t * 1.85, 1.);\n        float explode = 1. - pow(1. - t2, 10.); // expand\n        explode *= 1. - pow(t2, 5.); // contract\n        t2 = max(t - .53, 0.) * 1.2;\n        float wobble = sin(expImpulse(t2, 20.) * 2.2 + pow(3. * t2, 1.5) * 2. * PI * 2. - PI) * smoothstep(.4, .0, t2) * .15;\n        float anim = wobble + explode;\n        p -= a * anim / 2.8;\n\n        // Build boundary edge of face\n        float edgeA = dot(p, normalize(b - a));\n        float edgeB = dot(p, normalize(c - a));\n        float edge = max(edgeA, edgeB);\n\n        // Intersect with object\n        d = min(d, max(object(p), edge));\n        \n        // Reset space for next iteration\n        p = pp;\n        \n        // Cycle faces for next iteration\n        vec3 aa = a;\n        a = b;\n        b = c;\n        c = aa;\n    }\n    \n    return d;\n}\n\n\nfloat map(vec3 p) {\n    if (iMouse.x > 0. && iMouse.y > 0.) {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    }\n    return map2(p);\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    vec3 camPos = vec3(0,0,3.2);\n    vec3 rayDirection = normalize(vec3(p,-4));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.007);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 150; i++) {\n        rayLength += dist;\n        rayPosition = camPos + rayDirection * rayLength;\n        dist = map(rayPosition);\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 5.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        vec3 albedo = vec3(1);\n        vec3 n = calcNormal(rayPosition);\n        vec3 lp = vec3(-.5,.5,.5);\n        float l = max(dot(lp, n), 0.);\n        vec3 ld = normalize(lp - rayPosition);\n        l += .02;\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\n        float ao = calcAO(rayPosition, n);\n        col = albedo * l * mix(1., ao, .8);\n        col = mix(col, bgcol, 1.0 - exp2(-0.2 * pow(rayLength - 1., 3.)));\n    }\n\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlKyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 66, 98, 98, 143], [144, 144, 164, 164, 199], [200, 200, 228, 228, 309], [311, 338, 376, 376, 438], [440, 476, 499, 499, 545], [547, 577, 609, 609, 853], [855, 886, 919, 919, 1239], [1241, 1279, 1336, 1422, 1579], [1581, 1605, 1627, 1627, 1752], [1754, 1799, 1837, 1837, 1883], [1885, 1885, 1905, 2019, 3236], [3239, 3239, 3258, 3258, 3450], [3452, 3521, 3547, 3547, 3746], [3748, 3789, 3831, 3831, 4117], [4119, 4119, 4176, 4176, 5327]], "test": "untested"}
{"id": "3lKyzW", "name": "you are a rainbow", "author": "netgrind", "description": "you are a rainbow\n    yes it is true,\nplease let your light glow\n    make something new", "tags": ["rainbow"], "likes": 5, "viewed": 270, "published": 3, "date": "1610582801", "time_retrieved": "2024-07-30T19:45:17.172920", "image_code": "// Fork of \"cosmos font smooth\" by netgrind. https://shadertoy.com/view/Xdjfzw\n// 2021-01-14 00:00:36\n\n#define line1 _ y_ o_ u_ _ a_ r_ e_ _ a_ crlf\n#define line2 _ _ r_ a_ i_ n_ b_ o_ w_\n\n// line function, used in k, s, v, w, x, y, z\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 size = vec2(1., -1);\nvec2 edge = vec2(1, 0.);\nvec2 xLine = vec2(0., 0.);\n\nfloat circle(vec2 uv){\n\treturn abs(length(uv)-size.x);   \n}\nfloat circleS(vec2 uv){\n\treturn abs(length(uv)-size.x*.5);   \n}\n\nfloat vert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x)));   \n}\nfloat halfvert(vec2 uv){\n\treturn length(vec2(uv.x,max(0.,abs(uv.y)-size.x*.5)));   \n}\nfloat hori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x),uv.y));   \n}\nfloat halfhori(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x)-size.x*.5),uv.y));   \n}\nfloat diag(vec2 uv){\n\treturn length(vec2(max(0.,abs((uv.y-uv.x))-size.x*2.),uv.y+uv.x));   \n}\nfloat halfdiag(vec2 uv){\n\treturn length(vec2(max(0.,abs(uv.x-uv.y)-size.x),uv.y+uv.x));   \n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    float x = circle(uv);\n    x = mix(x, min(vert(uv-edge), vert(uv+edge)), step(uv.y, 0.));\n    x = min(x, hori(uv-xLine));\n    return x;\n}\nfloat bb(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-xLine));\n    x = mix(min(circleS(uv-size.xx*.5),circleS(uv-size*.5)),x, step(uv.x, .5));\n    return x;\n}\nfloat cc(vec2 uv) {\n    float x = circle(uv);\n    float p = .8;\n    float a = atan(uv.x, abs(uv.y));\n    a = smoothstep(.7, 1.5707, a);\n   \tx += a;\n    uv.y = -abs(uv.y);\n    x = min(length(uv+size.x*vec2(-cos(p), sin(p))), x);\n    return x;\n}\nfloat dd(vec2 uv) {\n    float x = vert(uv+edge);\n    x = min(x, hori(uv+edge.yx));\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv),x, step(uv.x, 0.));\n    return x;\n}\nfloat ee(vec2 uv) {\n    float x = cc(uv);\n    x = mix(circle(uv), x, step(uv.y, 0.));\n    x = min(x, hori(uv));\n    return x;\n}\nfloat ff(vec2 uv) {\n   \tfloat x = vert(uv+edge);\n    x = min(x, hori(uv-edge.yx));\n    x = mix(circle(uv), x, step(min(-uv.x, uv.y), 0.));\n    x = min(x, halfhori(uv+edge*.5));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = cc(uv);\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    x = min(x, halfhori(uv-edge*.5));\n    return x;\n}\nfloat hh(vec2 uv) {\n    float x = vert(abs(uv)-edge);\n    x = min(x, hori(uv));\n    //x = min(x, circle(uv+edge.yx));\n    //x = mix(x, min(length(uv-size.xy), length(uv-size.yy)), step(uv.y, size.y));\n    return x;\n}\nfloat ii(vec2 uv) {\n    return hh(uv.yx);\n}\nfloat jj(vec2 uv) {\n    float x = vert(uv-edge);\n    x = min(x, length(uv+edge));\n    x = mix(x, circle(uv), step(uv.y, 0.));\n    return x;\n}\nfloat kk(vec2 uv) {\n    uv.y = abs(uv.y);\n    float x = circle(uv-edge.yx);\n    x = mix( length(uv-size.xx),x,step(uv.y, size.x)); \n    x = mix(x,min(vert(uv+edge), hori(uv)), step(uv.x, 0.));\n    return x;\n}\nfloat ll(vec2 uv) {\n    return min(vert(uv+edge), hori(uv+edge.yx));\n}\nfloat mm(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = vert(uv-edge);\n    x = min(x, halfvert(uv-edge.yx*.5));\n    x = mix( circleS(uv-size.xx*.5),x, step(uv.y, 0.5));\n    return x;\n}\nfloat nn(vec2 uv) {\n    float x = circle(uv);\n    x = mix(min(vert(uv-edge), vert(uv+edge)), x, clamp(ceil(uv.y), 0., 1.));\n    return x;\n}\nfloat oo(vec2 uv) {\n    return circle(uv);\n}\nfloat pp(vec2 uv) {\n    float x = hori(uv);\n    x = min(x, hori(uv-edge.yx));\n    x = mix( circleS(uv+size.yy*.5),x, step(uv.x, size.x*.5));\n    x = min(x, vert(uv+edge));\n    return x;\n}\nfloat qq(vec2 uv) {\n    float x = circle(uv);\n    x = min(x, halfdiag(uv-size.xy*.5));\n    return x;\n}\nfloat rr(vec2 uv) {\n    float x = min(hori(uv-edge.yx), vert(uv+edge));\n    x = mix(x, circle(uv), step(0., min(-uv.x, uv.y)));\n    return x;\n}\nfloat ss(vec2 uv) {\n    float x = hori(uv-edge.yx);\n    x = min(x, halfhori(uv));\n    vec2 u = uv;\n    u+=vec2(-size.y*.5, size.y*.5);\n    x = mix(circleS(u),x, step(-edge.x*.5, uv.x));\n    \n    float x2 = hori(uv+edge.yx);\n    x2= min(x2, halfhori(uv));\n    u = uv;\n    u-=vec2(-size.y*.5, size.y*.5);\n    x2 = mix(x2,circleS(u),step(edge.x*.5, uv.x));\n    \n    return min(x,x2);\n}\nfloat tt(vec2 uv) {\n    /*float x = min(hori(uv+edge.yx), vert(uv+edge));\n    x = mix( circle(uv),x, step(0., max(uv.x, uv.y)));\n    x = min(halfhori(uv+edge*.5), x);*/\n    float x = min(vert(uv), hori(uv-edge.yx));\n    return x;\n}\nfloat uu(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = mix(circle(uv), vert(uv-edge),  step(0., uv.y));\n    return x;\n}\nfloat vv(vec2 uv) {\n    uv.x = abs(uv.x);\n    float p = .5;\n    uv *= mat2(cos(p), -sin(p), sin(p), cos(p));\n    float x = vert(uv-edge*.5);\n    return x;\n}\nfloat ww(vec2 uv) {\n    uv.y = -uv.y;\n    return mm(uv);\n}\nfloat xx(vec2 uv) {\n    return diag(abs(uv)*vec2(-1., 1.));\n}\nfloat yy(vec2 uv) {\n    uv.x = abs(uv.x);\n    float x = min(halfvert(uv+edge.yx*.5), circle(uv-edge.yx));\n    x = mix(x, length(uv-size.xx), step(size.x, uv.y));\n    return x;\n}\nfloat zz(vec2 uv) {\n    float x = min(hori(uv-edge.yx), hori(uv+edge.yx));\n    uv.x = -uv.x;\n    return min(x, diag(uv));\n}\n\n//Render char if it's up\n#define ch(l)  x=min(x,l(uv+vec2(spacing.x*nr, 0.)));nr-=size.x;\n\n//Make it a bit easier to type text\n#define a_ ch(aa);\n#define b_ ch(bb);\n#define c_ ch(cc);\n#define d_ ch(dd);\n#define e_ ch(ee);\n#define f_ ch(ff);\n#define g_ ch(gg);\n#define h_ ch(hh);\n#define i_ ch(ii);\n#define j_ ch(jj);\n#define k_ ch(kk);\n#define l_ ch(ll);\n#define m_ ch(mm);\n#define n_ ch(nn);\n#define o_ ch(oo);\n#define p_ ch(pp);\n#define q_ ch(qq);\n#define r_ ch(rr);\n#define s_ ch(ss);\n#define t_ ch(tt);\n#define u_ ch(uu);\n#define v_ ch(vv);\n#define w_ ch(ww);\n#define x_ ch(xx);\n#define y_ ch(yy);\n#define z_ ch(zz);\n\n//Space\n#define _ nr--;\n//Space\n#define _half nr-=.5;\n\n//Next line\n#define crlf uv.y += spacing.w; nr = 0.;\n\nvec4 spacing = vec4(3.33, 2., .25, 3.33);\n\nfloat field(vec2 uv){\n    float x = 100.;\n    float nr = 0.;\n    \n    line1;\n    line2;\n    return x;\n}\n\nvec2 fieldNormal(vec2 uv)\n{\n   const vec2 e = vec2(0.3,0.0);\n   return normalize(vec2(\n      field(uv + e.xy) - field(uv - e.xy),\n      field(uv + e.yx) - field(uv - e.yx) \n   ));\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nvec3 art(vec2 uv){\n    float aa = atan(uv.x, uv.y);\n\n    pModPolar(uv, 6., iTime);\n    uv.x = abs(mod(uv.x-iTime, 10.)-5.);\n    uv.y = abs(mod(uv.y+15., 30.)-15.);\n    \n    float a = atan(uv.x, uv.y);\nfloat d= length(uv)*.2;\nuv.x*=1.+sin(uv.x+a-d+iTime)*.1;\nuv.y*=1.+cos(uv.y+a+d+iTime)*.1;\n    float grid = smoothstep(.03, .5, abs(mod(a/3.1415*7., 2.)-1.));\n    grid += smoothstep(0., 1.,pow(mod(d, 1.), 3.));\n    vec3 c =vec3(mix(d, grid, smoothstep(.1, 1., d)));\n    c.rgb +=aa/3.1415;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spacing.y = spacing.x*.5;\n    spacing.z = 1./spacing.x;\n    \n    float scale = 1.0;\n\tvec2 uv = ((fragCoord-0.5*iResolution.xy)/iResolution.xx)*40.;\n    \n    vec2 p = uv;\n    \n    uv.x*=1.+sin(uv.y*.2-iTime)*.05;\n    uv.y*=1.+cos(uv.x*.5+iTime)*.1;\n    uv.y+=cos(uv.x*.1-iTime);\n    \n    uv.x += 5.*spacing.x;\n    uv.y -= spacing.w*.5;\n    \n    float x = field(uv);\n    vec2 norm = fieldNormal(uv);\n    \n    float amp = pow(smoothstep(5., .5, x), .7);\n    vec3 c = art(p*(1. + iMouse.x/iResolution.x*10.)-norm*amp);\n    c = sin((vec3(0., .33, .66)+c+smoothstep(.5, .0, x)+smoothstep(.1, 2., x))*6.28+iTime)*.5+.5;\n   // c = mix(c, vec3(0.), smoothstep(.5, .4, x));\n   float v = smoothstep(.2, .3, x);\n\tc = mix( sin(vec3(0., .33, .66)*7.+p.x+p.y+iTime)*.3+.9, c*smoothstep(15., 5., x), v);\n    fragColor = vec4(c, 1.);//vec4(clamp(clr,0.0,1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 235, 271, 271, 396], [477, 477, 499, 499, 536], [537, 537, 560, 560, 600], [602, 602, 622, 622, 680], [681, 681, 705, 705, 766], [767, 767, 787, 787, 845], [846, 846, 870, 870, 931], [932, 932, 952, 952, 1025], [1026, 1026, 1050, 1050, 1118], [1120, 1144, 1163, 1163, 1304], [1305, 1305, 1324, 1324, 1549], [1550, 1550, 1569, 1569, 1793], [1794, 1794, 1813, 1813, 1969], [1970, 1970, 1989, 1989, 2097], [2098, 2098, 2117, 2117, 2290], [2291, 2291, 2310, 2310, 2430], [2431, 2431, 2450, 2450, 2647], [2648, 2648, 2667, 2667, 2691], [2692, 2692, 2711, 2711, 2833], [2834, 2834, 2853, 2853, 3042], [3043, 3043, 3062, 3062, 3113], [3114, 3114, 3133, 3133, 3298], [3299, 3299, 3318, 3318, 3438], [3439, 3439, 3458, 3458, 3483], [3484, 3484, 3503, 3503, 3671], [3672, 3672, 3691, 3691, 3774], [3775, 3775, 3794, 3794, 3918], [3919, 3919, 3938, 3938, 4301], [4302, 4302, 4321, 4470, 4533], [4534, 4534, 4553, 4553, 4654], [4655, 4655, 4674, 4674, 4811], [4812, 4812, 4831, 4831, 4870], [4871, 4871, 4890, 4890, 4932], [4933, 4933, 4952, 4952, 5110], [5111, 5111, 5130, 5130, 5234], [6010, 6010, 6031, 6031, 6113], [6115, 6115, 6142, 6142, 6296], [6299, 6412, 6475, 6475, 6904], [6906, 6906, 6924, 6924, 7410], [7412, 7412, 7469, 7469, 8323]], "test": "untested"}
{"id": "3lKcRW", "name": "halftone effect", "author": "manu210404", "description": "this shader gives some sort of halftone look to the rendered values ", "tags": ["halftone", "distance", "dot", "dist", "manhattandistance"], "likes": 14, "viewed": 482, "published": 3, "date": "1610578506", "time_retrieved": "2024-07-30T19:45:18.035613", "image_code": "#define d(p) length(p-.5)\n#define R iResolution.xy\nfloat halftone(in vec2 p, in float val, in float scale) {\n    p = fract(p);\n    vec2 o = vec2(-.5,.5);\n    vec2 t = p+o.xx;\n    float eps = 1./iResolution.y*scale;\n    return smoothstep(val + eps, \n                      val - eps, \n                      mix(d(p),                                                         // distance from center of cell\n                          1.-min(min(d(p+o.xx), d(p+o.xy)), min(d(p+o.yy), d(p+o.yx))), // negative distance from the corners of cell plus one\n                          smoothstep(0.,1.,abs(t.x) + abs(t.y))                         // manhattan distance from center of cell with smoothstep\n                                                                                        // the smoothstep is to make it look round faster\n                        //abs(t.x) + abs(t.y)                                           // here would be the normal manhattan distance\n                          )\n                      );\n}\n\nfloat s(in vec2 p) {\n    return fract(d(p)-iTime-atan(p.x-.5, p.y-.5)/3.1415*.5);\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    float scale = 16.;\n    vec2 uv = u/R.y-vec2(R.x/R.y-1.,0)*.5,\n          p = uv*scale,\n        pfr = smoothstep(0.,1.,fract(p));\n    vec4 pf = vec4(floor(p)/scale,ceil(p)/scale);\n    \n    float val = mix(mix(s(pf.xy), s(pf.zy), pfr.x), mix(s(pf.xw), s(pf.zw), pfr.x), pfr.y);\n    val = halftone(p, val, scale);\n    \n    O = vec4(vec3(val),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 1019], [1021, 1021, 1041, 1041, 1104], [1106, 1106, 1147, 1147, 1495]], "test": "untested"}
{"id": "WtKcRW", "name": "Full dFdx support test", "author": "ttg", "description": "Does your dFdx have per-row resolution or not?  (which GPU/OS/browser do/don't support it?)", "tags": ["test", "dfdx", "bug", "debug"], "likes": 3, "viewed": 586, "published": 3, "date": "1610577804", "time_retrieved": "2024-07-30T19:45:18.841459", "image_code": "\nbool testdFdx() {\n  ivec2 c = ivec2(gl_FragCoord.xy)%2;\n  const float[] s = float[](.582,.161,.973,.038);\n  float x = s[c.x+c.y*2];\n  float d = dFdx(x);\n  float r = c.y==0? s[1]-s[0] : s[3]-s[2];\n  float k = float(d!=r);\n  return dFdy(k*float(c.y*2-1))==0.;\n}\n\nconst uint[] line1 =\n  STRING32(12, F,u,l,l,_,d,F,d,x,_,i,s,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] line2 =\n  STRING32( 9, s,u,p,p,o,r,t,e,d,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] line3 =\n  STRING32(13, N,O,T,_,S,U,P,P,O,R,T,E,D,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);\nconst uint[] line4 =\n  STRING32(32, L,e,f,t,co,_,_,_,_,_,_,_,_,_,_,_,_,R,i,g,h,t,co,_,_,_,_,_,_,_,_,_);\nconst uint[] line5 =\n  STRING32(32, E,x,p,e,c,t,e,d,_,r,e,s,u,l,t,_,_,L,o,c,a,l,_,r,e,s,u,l,t,_,_,_);\n\n\nvoid mainImage( out vec4 fv, in vec2 fc ) {\n  vec2 uv = fc/iResolution.xx*2.;\n  int d = int(floor(uv.x));\n  uv.x = fract(uv.x);\n  uv.y -= iResolution.y/iResolution.x-.5;\n  vec3 v = vec3(0.);\n  if (uv.y>0.&&uv.y<1.) v = texture(iChannel0, (uv*16.+vec2(d*64,0))/iResolution.xy).rgb;\n  \n  vec2 tuv = fc/iResolution.xy;\n  tuv.y=1.-tuv.y;\n  float txt = 0.;\n  txt+=draw_string(iChannel1,tuv*vec2(31,12)-vec2(3,2), line1);\n  if (testdFdx())\n    txt+=draw_string(iChannel1,tuv*vec2(31,12)-vec2(16,2), line2);\n  else\n    txt+=draw_string(iChannel1,tuv*vec2(31,12)-vec2(16,2), line3);\n  txt+=draw_string(iChannel1,tuv*vec2(34,12)-vec2(1,4), line4);\n  txt+=draw_string(iChannel1,tuv*vec2(34,12)-vec2(1,5), line5);\n  v*=1.-min(txt,1.);\n  \n  fv.a = 1.;\n  fv.rgb = pow(v,vec3(1./2.2));\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage (out vec4 v, vec2 stfc) {\n  ivec2 c = ivec2(gl_FragCoord.xy)%2;\n  const vec3[] s = vec3[](vec3(.582,.035,.860),vec3(.161,.010,.948),vec3(.973,.870,.116),vec3(.038,.213,.990));\n  vec3 x = s[c.x+c.y*2];\n  vec3 d = dFdx(x);\n  vec3 r = c.y==0? s[1]-s[0] : s[3]-s[2];\n  v.rgb = ( stfc.x<64. ? r : d )*.5 + .5;\n  ivec2 k = ivec2(gl_FragCoord.xy)/2;\n  v.rgb *= .8+.2*float((k.x+k.y)%2);\n}\n", "buffer_a_inputs": [], "common_code": "/*\n\nGLSL character printing library for octaviogood font texture.\nhttps://www.shadertoy.com/view/Wd2SDt\n\n*/\n\nconst struct CCDS_T {\n  uint\n    _,   em,  dq,  ha,  ds,  mo,  am,  sq,  lp,  rp,  as,  pl,  cm,  hm,  pe,  sl,\n    _0,  _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  co,  sc,  lt,  eq,  gt,  qm,\n    at,   A,   B,   C,   D,   E,   F,   G,   H,   I,   J,   K,   L,   M,   N,   O,\n     P,   Q,   R,   S,   T,   U,   V,   W,   X,   Y,   Z,  lb,  bs,  rb,  up,  un,\n    bt,   a,   b,   c,   d,   e,   f,   g,   h,   i,   j,   k,   l,   m,   n,   o,\n     p,   q,   r,   s,   t,   u,   v,   w,   x,   y,   z,  lc,  ba,  rc,  ti, _U0,\n   alp, bet, gam, del, eps, the, lam,  mu,  xi,  pi, rho, sig, tau, phi, psi, ome,\n   Gam, Del, The, Lam,  Pi, Sig, Phi, Psi, Ome, inf,flor,ring,intg,pdrv, nab,sqrt,\n   _U1, iem, cen, pou, cur, yen, bba, sec, dia, cop, fem, lda, not, _U2, reg, mac,\n   deg, pms, su2, su3, acu, mic, pil, mid, ced, su1, mas, rda, v14, v12, v34, iqm,\n    AG,  AA,  AC,  AT,  AD,  AR,  AE,  CC,  EG,  EA,  EC,  ED,  IG,  IA,  IC,  ID,\n   Eth,  NT,  OG,  OA,  OC,  OT,  OD, mul,  OS,  UG,  UA,  UC,  UD,  YA, Tho, Sha,\n    aG,  aA,  aC,  aT,  aD,  aR,  ae,  cC,  eG,  eA,  eC,  eD,  iG,  iA,  iC,  iD,\n   eth,  nT,  oG,  oA,  oC,  oT,  oD, div,  oS,  uG,  uA,  uC,  uD,  yA, yho,  yD,  \n  _nul;\n} CCDS = CCDS_T(\n  0x20u,0x21u,0x22u,0x23u,0x24u,0x25u,0x26u,0x27u,0x28u,0x29u,0x2au,0x2bu,0x2cu,0x2du,0x2eu,0x2fu,\n  0x30u,0x31u,0x32u,0x33u,0x34u,0x35u,0x36u,0x37u,0x38u,0x39u,0x3au,0x3bu,0x3cu,0x3du,0x3eu,0x3fu,\n  0x40u,0x41u,0x42u,0x43u,0x44u,0x45u,0x46u,0x47u,0x48u,0x49u,0x4au,0x4bu,0x4cu,0x4du,0x4eu,0x4fu,\n  0x50u,0x51u,0x52u,0x53u,0x54u,0x55u,0x56u,0x57u,0x58u,0x59u,0x5au,0x5bu,0x5cu,0x5du,0x5eu,0x5fu,\n  0x60u,0x61u,0x62u,0x63u,0x64u,0x65u,0x66u,0x67u,0x68u,0x69u,0x6au,0x6bu,0x6cu,0x6du,0x6eu,0x6fu,\n  0x70u,0x71u,0x72u,0x73u,0x74u,0x75u,0x76u,0x77u,0x78u,0x79u,0x7au,0x7bu,0x7cu,0x7du,0x7eu,0x7fu,\n  0x80u,0x81u,0x82u,0x83u,0x84u,0x85u,0x86u,0x87u,0x88u,0x89u,0x8au,0x8bu,0x8cu,0x8du,0x8eu,0x8fu,\n  0x90u,0x91u,0x92u,0x93u,0x94u,0x95u,0x96u,0x97u,0x98u,0x99u,0x9au,0x9bu,0x9cu,0x9du,0x9eu,0x9fu,\n  0xa0u,0xa1u,0xa2u,0xa3u,0xa4u,0xa5u,0xa6u,0xa7u,0xa8u,0xa9u,0xaau,0xabu,0xacu,0xadu,0xaeu,0xafu,\n  0xb0u,0xb1u,0xb2u,0xb3u,0xb4u,0xb5u,0xb6u,0xb7u,0xb8u,0xb9u,0xbau,0xbbu,0xbcu,0xbdu,0xbeu,0xbfu,\n  0xc0u,0xc1u,0xc2u,0xc3u,0xc4u,0xc5u,0xc6u,0xc7u,0xc8u,0xc9u,0xcau,0xcbu,0xccu,0xcdu,0xceu,0xcfu,\n  0xd0u,0xd1u,0xd2u,0xd3u,0xd4u,0xd5u,0xd6u,0xd7u,0xd8u,0xd9u,0xdau,0xdbu,0xdcu,0xddu,0xdeu,0xdfu,\n  0xe0u,0xe1u,0xe2u,0xe3u,0xe4u,0xe5u,0xe6u,0xe7u,0xe8u,0xe9u,0xeau,0xebu,0xecu,0xedu,0xeeu,0xefu,\n  0xf0u,0xf1u,0xf2u,0xf3u,0xf4u,0xf5u,0xf6u,0xf7u,0xf8u,0xf9u,0xfau,0xfbu,0xfcu,0xfdu,0xfeu,0xffu,\n0x7fu);\n\n#define U4CHAR4(a,b,c,d) ((CCDS.a)+(CCDS.b<<8)+(CCDS.c<<16)+(CCDS.d<<24))\n\n#define STRING32(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf) )\n\n#define STRING64(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df))\n\n#define STRING80(n,\\\n  a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,\\\n  b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,\\\n  c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd,ce,cf,\\\n  d0,d1,d2,d3,d4,d5,d6,d7,d8,d9,da,db,dc,dd,de,df,\\\n  e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef)\\\n    uint[](uint(n), \\\n      U4CHAR4(a0,a1,a2,a3),U4CHAR4(a4,a5,a6,a7),U4CHAR4(a8,a9,aa,ab),U4CHAR4(ac,ad,ae,af),\\\n      U4CHAR4(b0,b1,b2,b3),U4CHAR4(b4,b5,b6,b7),U4CHAR4(b8,b9,ba,bb),U4CHAR4(bc,bd,be,bf),\\\n      U4CHAR4(c0,c1,c2,c3),U4CHAR4(c4,c5,c6,c7),U4CHAR4(c8,c9,ca,cb),U4CHAR4(cc,cd,ce,cf),\\\n      U4CHAR4(d0,d1,d2,d3),U4CHAR4(d4,d5,d6,d7),U4CHAR4(d8,d9,da,db),U4CHAR4(dc,dd,de,df),\\\n      U4CHAR4(e0,e1,e2,e3),U4CHAR4(e4,e5,e6,e7),U4CHAR4(e8,e9,ea,eb),U4CHAR4(ec,ed,ee,ef))\n\n#define DEF_DRAW_STRING(N) \\\nfloat draw_string (sampler2D sampler,                    \\\n                   in vec2 uv, const uint[1+N] string) { \\\n  int i = int(uv.x);                                     \\\n  int strlen = min(int(string[0]),N*4);                  \\\n  if (uv.x<0.||i>=strlen) return 0.;                     \\\n  int code = int( (string[i/4+1]>>((i%4)*8)) &0xFFu);    \\\n  if (uv.y<0.||uv.y>1.) return 0.;                       \\\n  uv.x=fract(uv.x)/2.+.25; uv.y=1.-uv.y;                 \\\n  uv+=vec2(code%16,15-code/16);                          \\\n  return texture(sampler, uv/16.).r;                   }\nDEF_DRAW_STRING(8)\nDEF_DRAW_STRING(16)\nDEF_DRAW_STRING(20)\n#undef DEF_DRAW_STRING", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[776, 776, 819, 819, 1549]], "test": "untested"}
{"id": "wslfzN", "name": "oct13", "author": "merrecurent_", "description": "h65", "tags": ["noob"], "likes": 1, "viewed": 219, "published": 3, "date": "1610576981", "time_retrieved": "2024-07-30T19:45:19.609406", "image_code": "vec3 Rect(vec2 cord, float len, float wid)\n{\n    \n\tif(abs(tan(cord.x)) <= len/wid)\n        if (cord.y <= wid/abs(cos(cord.x)))\n            return vec3(1., 1., 0.);\n        else return vec3(.54, .6, 1.);\n    else\n       if (cord.y <= len/abs(sin(cord.x)))\n           return vec3(.5, 1., 0.);\n        else return vec3(.6, .75, 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv -= vec2(.62, .59);\n    uv *= 5.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 new = fract(uv);\n    new -= .5;\n    \n    vec2 polar = vec2(atan(new.x, new.y), length(new));\n    polar.y*= 2.*polar.y;\n    \n    vec2 copy = vec2(atan(new.x, new.y), length(new));\n    new = vec2(polar.x*2. + iTime, polar.y);\n    \n    vec3 figure = Rect(new, .3, .3)\n        \t\t - Rect(new, .2, .2);\n    \n    //vec3 col = vec3(figure);\n    // Output to screen\n    fragColor = vec4(figure,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 332], [334, 334, 391, 391, 921]], "test": "untested"}
{"id": "WsBcDy", "name": "mANDALA", "author": "merrecurent_", "description": "deq", "tags": ["noob"], "likes": 1, "viewed": 229, "published": 3, "date": "1610576934", "time_retrieved": "2024-07-30T19:45:20.377352", "image_code": "float flower(vec2 origin, float resz, float petals, float angs, float expon, float c_lol, float thicc){\n\tfloat mandala = 0.;\n    \n    vec2 polar = vec2(atan(origin.x, origin.y), length(origin));\n    origin = vec2(polar.x/6.2831*petals-iTime*angs, polar.y*sin(iTime));\n    \n    float x = origin.x*resz;\n    float m = c_lol - pow(min(fract(x), fract(1.-x)),expon);\n    \n\tmandala = smoothstep(0., .03, m-origin.y)-smoothstep(0., .03, m-thicc-origin.y);\n    \n    return mandala;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n    vec3 Mandala = flower(uv, 5., 2., .1, 2., .25, .1)*vec3(1., .7, .6)\n        \t\t + flower(uv, 3., 5., -.3, 1., .5, .05)*vec3(.07, .78, .07);\n        \t\t //+ flower(uv, 8., );\n    \n    // Output to screen\n    fragColor = vec4(Mandala, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 103, 103, 476], [478, 478, 535, 535, 929]], "test": "untested"}
{"id": "tsSyzt", "name": "heart and ribs lumina domnului", "author": "merrecurent_", "description": "second attempt", "tags": ["noob"], "likes": 1, "viewed": 235, "published": 3, "date": "1610576888", "time_retrieved": "2024-07-30T19:45:21.145299", "image_code": "\nfloat Band(float t, float start, float end, float blur){\n\tfloat step1 = smoothstep(start-blur, start + blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    return band1*band2;\n    \n}\n\nfloat remap01(float a, float b, float p) {\n\treturn (p-a)/(b-a);\n}\n\nfloat remap(float a, float b, float c, float d, float p) {\n\treturn remap01(a, b, p)*(d-c)+c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float mask = 0.;\n    \n    float y = uv.y;\n    float a = 0.;\n    float m = sin(1.3*t)*sin(y*10.+5.5*3.1415);\n    \n    m *= (2.*uv.x + 2.)*.05;\n    \n    float x = uv.x - m;\n    \n    float blurd = remap(-.5, .5, .03, .4, y);\n    float bluru = remap(-.5, .5, .03, .4, -y);\n    blurd = pow(blurd*3.5, 2.+ .7*uv.x);\n    bluru = pow(bluru*3.5, 2.+ .7*uv.x);\n    \n    mask = Rect(vec2(x, y), -.07, .07, -.5, .5, blurd)\n         + Rect(vec2(x, y), -.47, -.33, -.5, .5, blurd)\n         + Rect(vec2(x, y), -.87, -.73, -.5, .5, blurd)\n         + Rect(vec2(x, y), .33, .47, -.5, .5, blurd)\n         + Rect(vec2(x, y), .73, .87, -.5, .5, blurd);\n    mask += Rect(vec2(x, y), .13, .27, -.5, .5, bluru)\n          + Rect(vec2(x, y), -.27, -.13, -.5, .5, bluru)\n          + Rect(vec2(x, y), -.67, -.53, -.5, .5, bluru)\n          + Rect(vec2(x, y), .53, .67, -.5, .5, bluru);\n    col = vec3(1., .9, .71)*mask;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 57, 57, 197], [199, 199, 282, 282, 408], [410, 410, 452, 452, 475], [477, 477, 535, 535, 571], [573, 573, 630, 630, 1734]], "test": "untested"}
{"id": "WsBcWc", "name": "SHaDoW", "author": "merrecurent_", "description": "bcjal", "tags": ["noob"], "likes": 1, "viewed": 228, "published": 3, "date": "1610576831", "time_retrieved": "2024-07-30T19:45:21.916238", "image_code": "float distance_from_figure(vec3 p, vec3 c_1, float r_1, vec3 c_2, float r_2, float altitude)\n{\n\treturn min(min(length(p-c_1) - r_1 + sin(5.0*p.x + 3.*iTime) * sin(5.*p.y-2.*iTime) * sin(4.*p.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)),\n               length(p-c_2) - r_2), p.y - altitude);\n}\n\nfloat map_the_world(vec3 p)\n{\t\n    float sphere_0 = distance_from_figure(p, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.);    \n    return sphere_0;\n}\n    \n\nvec3 calculate_normal (vec3 p)\n{\n\tconst vec3 small_step = vec3(.001, 0., 0.);\n    \n    float gradient_x = map_the_world(p + small_step.xyy)\n        \t\t\t - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy)\n        \t\t\t - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx)\n        \t\t\t - map_the_world(p - small_step.yyx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\n\nvec3 ray_march(vec3 ro, vec3 rd, vec3 backtrack)\n{\n\tfloat total_distance_traveled = 0.;\n    const int NUMBER_OF_STEPS = 250;\n    const float MINIMUM_HIT_DISTANCE = .001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.;\n    \n    for (int i=0; i < NUMBER_OF_STEPS; ++i)\n    {\n    \t//Calculate our current position along the ray\n        vec3 current_position = ro + total_distance_traveled*rd;\n        \n        //assume that sphere is centered at the origin\n        float distance_to_closest = map_the_world(current_position);\n        \n        if(distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            \n            //we hit smthg\n            \n            vec3 normal = calculate_normal(current_position);\n            vec3 light_position = vec3(5.*cos(iTime), -10., 5.*sin(iTime));\n            vec3 direction_to_light = normalize(current_position - light_position);\n            float diffuse_intensity = max(0., dot(normal, direction_to_light));\n            float spectral_intensity = pow(max(0., dot(normalize(rd), reflect(direction_to_light, normal))), 1.5);\n            \n            if (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.)\n                == length(current_position - vec3(0.)) - 1. + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)))\n            {\n            \t\n                \n            \t//each component of the normal will be in the -1<>1 range\n            \n            \treturn vec3(1., .5, .23)*(diffuse_intensity + spectral_intensity);\n                \n                \n                /*insert reflection function here\n                float reflection_distance = 0.;\n                const int MAX_REFLECTIONS_NUMBER = 10;\n                const float MAX_REFLECTION_DISTANCE = 1.;\n                const float REFLECTION_HIT = .0005;\n                \n                //backtrack_01 and _02 are going to be my new rd vector\n                \n                //to obtain the new current_position vector:\n                //vec3 current_pos_new = current_position + rd_new + direction_to_light;\n                if (dot(normal, backtrack) >= 0)\n                \tfor(int j=0; j < MAX_REFLETIONS_NUMBER; ++j)\n                \t{\n                \t\n                    \tvec3 current_pos_new = ro +  rd_new*reflection_distance;\n                    \tfloat distance_to_close_new = map_the_world(current_pos_new);\n                    \n                    \tif(distance_to_close_new < MINIMUM_HIT_DISTANCE)\n                    \t{\n                    \t\n                        \tvec3 normal_new = calculate_normal(current_position_new);\n                        \tfloat diffuse_intensity_new = max(0., dot(normal, direction_to_light));\n                        \n                        \tif (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7, -2.)\n                \t\t\t\t== length(current_position - vec3(0.)) - 1. + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime)))\n            \t\t\t\t{\n                            \n                            \n                            \n                        \t}\n                        \n                    \t}\n                    \n                \t}\n                */\n                \n            }\n            \n            else if (distance_from_figure(current_position, vec3(0.), 1., vec3(4., 0., 4.), 1.7,-2.) == length(current_position - vec3(4., 0., 4.)) - 1.7\n                                         && length(current_position) < 5.906775)\n            {\n            \treturn vec3(.07, .78, .07)*.8 + .5*diffuse_intensity;\n            }\n            else  //if it hits the plane\n            {\n                float distance_to_sphere = length(cross(current_position - light_position, light_position))/length(current_position - light_position)\n                    \t\t\t\t\t + sin(5.0*current_position.x + 3.*iTime) * sin(5.*current_position.y-2.*iTime) * sin(4.*current_position.z-2.*iTime) * .4 *(1.5 + .5*sin(2.5*iTime));\n                if (distance_to_sphere < 1.) {\n                \treturn vec3(1., .5, .23)*.3 - diffuse_intensity;\n                }\n                    \n                else return vec3(1., .5, .23)*(.75 + .45*diffuse_intensity);\n            }\n        }\n        \n        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        \n        total_distance_traveled += distance_to_closest;\n        \n    }\n    return vec3(.22, .69, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //set up camera\n    vec3 camera_position = vec3(0., 0., -5.);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    vec3 backtrack = vec3(uv.x, uv.y, 1.);\n    \n    \n    vec3 shaded_color = ray_march(ro, rd, backtrack);\n    \n    fragColor = vec4(shaded_color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 94, 94, 291], [293, 293, 322, 322, 438], [445, 445, 477, 477, 942], [945, 945, 995, 995, 5536], [5539, 5539, 5596, 5596, 5985]], "test": "untested"}
{"id": "wlyyzD", "name": "Ink cave", "author": "intrakits", "description": "I was playing around with gyroids and managed to make something I felt is cool. Not sure why i have a strange warping effect (maybe I'm over marching?), but I think it ended up making it look cool anyways.", "tags": ["3d", "ink", "cave", "gyroid"], "likes": 1, "viewed": 249, "published": 3, "date": "1610572395", "time_retrieved": "2024-07-30T19:45:22.677203", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float offX, float offY, float offZ) {\n\ta.x += offX;\n    b.x += offX;\n    \n    a.y += offY;\n    b.y += offY;\n    \n    a.z += offZ;\n    b.z += offZ;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n}\nfloat GetDist(vec3 p){\n    \n    float g1 = sdGyroid(p, 10., .03, 1.);\n    float g2 = sdGyroid(p, 10.76, .03, .3);\n    float g3 = sdGyroid(p, 20.76, .03, .3);\n    float g4 = sdGyroid(p, 35.76, .03, .3);\n    float g5 = sdGyroid(p, 60.76, .03, .3);\n    float g6 = sdGyroid(p, 110.76, .03, .3);\n    g1 -= g2*.4;\n    g1 -= g3*.3;\n    g1 += g4*.2;\n    g1 += g5*.2;\n    g1 += g6*.3;\n    vec2 uv = vec2(sin(p.x*4.)*.5+.5,cos(p.z*3.)*.5+.5);\n    float disp = texture(iChannel0,uv).r;\n    g1-=disp*.05*sin(iTime);\n    float box = dBox(p, vec3(5));\n    float d = max(g1,box);\n\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds*.1;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,0,0);\n    \n    lightPos.xz *= Rot(sin(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p+vec3(4,0,0));\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(0.,-0.1,sin(iTime*.1));\n  //  ro.yz *= Rot(-m.y*3.14+1.);\n   // ro.xz *= Rot(sin(iTime)*.6+3.);\n   // ro.yz *= -Rot(sin(iTime)*.1+5.);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    rd.xz *= Rot(sin(iTime)*.6+3.);\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    \n    \n    //color objects\n    if(d < MAX_DIST){\n        \n        //get normals\n        vec3 n = abs(GetNormal(p));\n        \n        \n        float g1 = sdGyroid(p, 5.23, .03, 1.4);\n        float g2 = sdGyroid(p, 10.76, .03, .3);\n        float g3 = sdGyroid(p, 20.76, .03, .3);\n        float g4 = sdGyroid(p, 35.76, .03, .3);\n        float g5 = sdGyroid(p, 60.76, .03, .3);\n        float g6 = sdGyroid(p, 110.76, .03, .3);\n        g1 -= g2*.4;\n        g1 -= g3*.3;\n        g1 += g4*.2;\n        g1 += g5*.2;\n        g1 += g6*.3;\n        vec2 uv = vec2(sin(p.x*4.)*.5+.5,cos(p.z*3.)*.5+.5);\n        float disp = texture(iChannel0,uv).r;\n        g1-=disp*.05;\n        float box = dBox(p, vec3(4));\n        float d = max(g1,box);\n        col = d*vec3(1)*50.;\n        col = max(col,disp*vec3(1,0,0)*3.);\n        col = max(col,g2*vec3(0,1,0)*50.);\n       \n        col *= smoothstep(-.1, .1, g2);\t// blackening\n        //get diffuse lighting\n        float diff = GetLight(p);\n        col *= vec3(diff);\n        \n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 151], [152, 152, 239, 239, 640], [642, 642, 691, 714, 1147], [1149, 1149, 1179, 1179, 1250], [1252, 1252, 1279, 1279, 1318], [1319, 1319, 1385, 1385, 1462], [1463, 1463, 1485, 1485, 2044], [2045, 2045, 2078, 2106, 2511], [2512, 2512, 2535, 2574, 2937], [2938, 2938, 2961, 2996, 3928], [3929, 3929, 3979, 3979, 4170], [4171, 4171, 4228, 4310, 6022]], "test": "untested"}
{"id": "ttGcRW", "name": "Complex Fourier Epicycles", "author": "oneshade", "description": "I have always wanted to make this and I finally did after watching The Coding Train's  videos about DFT (Discrete Fourier Transform). This was also my first time actually going under the hood of complex numbers.", "tags": ["fourier", "complexnumbers", "epicycles"], "likes": 15, "viewed": 320, "published": 3, "date": "1610554639", "time_retrieved": "2024-07-30T19:45:23.624670", "image_code": "/*\nI have always wanted to make this and I finally did after watching The Coding Train's\nvideos about DFT (Discrete Fourier Transform). This was also my first time actually\ngoing under the hood of complex numbers.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    float unit = 2.0 / iResolution.y;\n\n    // Time (t) and time step (dt)\n    float dt = TAU / float(path.length());\n    float t = float(iFrame) * dt;\n\n    // Draw each epicycle\n    vec2 pos = vec2(0.0);\n    for (int n=0; n < path.length(); n++) {\n        vec2 prevPos = pos;\n        vec3 epicycle = texelFetch(iChannel0, ivec2(n, 0), 0).xyz;\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, abs(length(uv - pos) - epicycle.x)));\n\n        float a = t * epicycle.y + epicycle.z;\n        pos += vec2(cos(a), sin(a)) * epicycle.x;\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, sdLine(uv, prevPos, pos)));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nDFT (Discrete Fourier Transform)\nThe path or \"signal\" gets broken down into a set of constant wave patterns.\nThe DFT output is calculated once and then maintained for the rest of the animation.\n*/\n\n// Complex multiplication operator\n#define cmul(a, b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        // Calculate the DFT of the path\n        float N = float(path.length());\n        float k = fragCoord.x + 0.5; // fragCoord strangely goes from 0.5 to resolution - 0.5 (according to the documentation)\n        vec2 sum = vec2(0.0);\n        for (float n=0.0; n < N; n++) {\n            float phi = TAU / N * k * n;\n            sum += cmul(path[int(n)], vec2(cos(phi), -sin(phi)));\n        }\n\n        sum /= N;\n\n        float phase = atan(sum.y, sum.x);\n        float amp = length(sum);\n        float freq = k;\n\n        fragColor.xyz = vec3(amp, freq, phase);\n    }\n\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0); // Maintain buffer data\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec2[] path = vec2[](vec2(-0.345, 0.16333333333333333), vec2(-0.345, 0.195), vec2(-0.345, 0.22666666666666666), vec2(-0.3616666666666667, 0.24333333333333335), vec2(-0.3883333333333333, 0.25), vec2(-0.4166666666666667, 0.255), vec2(-0.4483333333333333, 0.255), vec2(-0.48, 0.255), vec2(-0.5116666666666667, 0.255), vec2(-0.54, 0.25), vec2(-0.56, 0.235), vec2(-0.5833333333333334, 0.21166666666666667), vec2(-0.6066666666666667, 0.18666666666666668), vec2(-0.6116666666666667, 0.155), vec2(-0.6116666666666667, 0.12), vec2(-0.6033333333333334, 0.09166666666666666), vec2(-0.5866666666666667, 0.06), vec2(-0.5666666666666667, 0.04), vec2(-0.5516666666666666, 0.02), vec2(-0.5316666666666666, 0.0), vec2(-0.5033333333333333, -0.0033333333333333335), vec2(-0.4716666666666667, -0.0033333333333333335), vec2(-0.44, -0.0033333333333333335), vec2(-0.44, -0.0033333333333333335), vec2(-0.4766666666666667, -0.0033333333333333335), vec2(-0.5083333333333333, -0.015), vec2(-0.5316666666666666, -0.03166666666666667), vec2(-0.5516666666666666, -0.04666666666666667), vec2(-0.5666666666666667, -0.06333333333333334), vec2(-0.5833333333333334, -0.07833333333333334), vec2(-0.595, -0.09833333333333333), vec2(-0.595, -0.13333333333333333), vec2(-0.58, -0.16166666666666665), vec2(-0.56, -0.18166666666666667), vec2(-0.5316666666666666, -0.20166666666666666), vec2(-0.48333333333333334, -0.225), vec2(-0.4483333333333333, -0.24166666666666667), vec2(-0.4166666666666667, -0.245), vec2(-0.385, -0.245), vec2(-0.325, -0.23), vec2(-0.2816666666666667, -0.21333333333333335), vec2(-0.25333333333333335, -0.19), vec2(-0.23, -0.16166666666666665), vec2(-0.21, -0.13333333333333333), vec2(-0.195, -0.10166666666666667), vec2(-0.17, -0.075), vec2(-0.14666666666666667, -0.035), vec2(-0.14333333333333334, 0.0), vec2(-0.13166666666666665, 0.065), vec2(-0.13166666666666665, 0.09666666666666666), vec2(-0.13166666666666665, 0.12833333333333333), vec2(-0.13166666666666665, 0.16), vec2(-0.13166666666666665, 0.195), vec2(-0.13833333333333334, 0.22666666666666666), vec2(-0.155, 0.25), vec2(-0.17833333333333334, 0.2633333333333333), vec2(-0.20166666666666666, 0.24666666666666667), vec2(-0.21, 0.21166666666666667), vec2(-0.21, 0.175), vec2(-0.20166666666666666, 0.11666666666666667), vec2(-0.20166666666666666, 0.07166666666666667), vec2(-0.20166666666666666, 0.03666666666666667), vec2(-0.20166666666666666, 0.0), vec2(-0.19833333333333333, -0.035), vec2(-0.18666666666666668, -0.06333333333333334), vec2(-0.175, -0.09), vec2(-0.16333333333333333, -0.13), vec2(-0.155, -0.15833333333333333), vec2(-0.14333333333333334, -0.185), vec2(-0.11833333333333333, -0.205), vec2(-0.10333333333333333, -0.22166666666666668), vec2(-0.075, -0.21333333333333335), vec2(-0.051666666666666666, -0.18166666666666667), vec2(-0.035, -0.16166666666666665), vec2(-0.03166666666666667, -0.13333333333333333), vec2(-0.023333333333333334, -0.10166666666666667), vec2(-0.011666666666666667, -0.055), vec2(-0.011666666666666667, -0.023333333333333334), vec2(-0.011666666666666667, 0.013333333333333334), vec2(-0.011666666666666667, 0.045), vec2(-0.011666666666666667, 0.07666666666666666), vec2(-0.011666666666666667, 0.045), vec2(-0.011666666666666667, 0.008333333333333333), vec2(-0.011666666666666667, -0.02666666666666667), vec2(-0.008333333333333333, -0.06333333333333334), vec2(0.011666666666666667, -0.08666666666666667), vec2(0.035, -0.10166666666666667), vec2(0.06, -0.095), vec2(0.08666666666666667, -0.07), vec2(0.10666666666666667, -0.05), vec2(0.11166666666666666, -0.018333333333333333), vec2(0.115, 0.008333333333333333), vec2(0.11833333333333333, 0.03666666666666667), vec2(0.11833333333333333, 0.06833333333333333), vec2(0.135, 0.03666666666666667), vec2(0.12333333333333334, 0.008333333333333333), vec2(0.11166666666666666, -0.018333333333333333), vec2(0.11166666666666666, -0.05), vec2(0.11166666666666666, -0.08333333333333333), vec2(0.11166666666666666, -0.115), vec2(0.11166666666666666, -0.15333333333333332), vec2(0.11166666666666666, -0.19), vec2(0.11166666666666666, -0.23333333333333334), vec2(0.11166666666666666, -0.2683333333333333), vec2(0.10666666666666667, -0.3), vec2(0.095, -0.3333333333333333), vec2(0.08333333333333333, -0.365), vec2(0.055, -0.39166666666666666), vec2(0.023333333333333334, -0.4033333333333333), vec2(0.0033333333333333335, -0.37166666666666665), vec2(0.0033333333333333335, -0.34), vec2(0.016666666666666666, -0.31666666666666665), vec2(0.04, -0.285), vec2(0.055, -0.25666666666666665), vec2(0.075, -0.21666666666666667), vec2(0.095, -0.17), vec2(0.10666666666666667, -0.13833333333333334), vec2(0.12666666666666668, -0.09), vec2(0.14666666666666667, -0.058333333333333334), vec2(0.17, -0.03166666666666667), vec2(0.195, -0.006666666666666667), vec2(0.215, 0.016666666666666666), vec2(0.235, 0.03666666666666667), vec2(0.26166666666666666, 0.04833333333333333), vec2(0.29333333333333333, 0.04833333333333333), vec2(0.285, 0.051666666666666666), vec2(0.25, 0.045), vec2(0.235, 0.02), vec2(0.23833333333333334, -0.018333333333333333), vec2(0.24666666666666667, -0.058333333333333334), vec2(0.26666666666666666, -0.095), vec2(0.29833333333333334, -0.115), vec2(0.3333333333333333, -0.08333333333333333), vec2(0.35, -0.06333333333333334), vec2(0.3566666666666667, -0.02666666666666667), vec2(0.3566666666666667, 0.008333333333333333), vec2(0.345, 0.03666666666666667), vec2(0.325, 0.051666666666666666), vec2(0.3016666666666667, 0.065), vec2(0.3333333333333333, 0.06), vec2(0.3566666666666667, 0.045), vec2(0.36833333333333335, 0.013333333333333334), vec2(0.36833333333333335, -0.035), vec2(0.36833333333333335, -0.07), vec2(0.37666666666666665, -0.10166666666666667), vec2(0.405, -0.115), vec2(0.4483333333333333, -0.075), vec2(0.46, -0.03166666666666667), vec2(0.4683333333333333, 0.02), vec2(0.4716666666666667, 0.08), vec2(0.4716666666666667, 0.135), vec2(0.4716666666666667, 0.16666666666666666), vec2(0.465, 0.20333333333333334), vec2(0.465, 0.235), vec2(0.445, 0.2633333333333333), vec2(0.4166666666666667, 0.27), vec2(0.4166666666666667, 0.235), vec2(0.42, 0.2), vec2(0.42, 0.16666666666666666), vec2(0.42, 0.12833333333333333), vec2(0.42833333333333334, 0.09166666666666666), vec2(0.445, 0.03666666666666667), vec2(0.45666666666666667, -0.011666666666666667), vec2(0.46, -0.058333333333333334), vec2(0.46, -0.095), vec2(0.46, -0.13), vec2(0.46, -0.16666666666666666), vec2(0.465, -0.15833333333333333), vec2(0.465, -0.12666666666666668), vec2(0.465, -0.09), vec2(0.465, -0.058333333333333334), vec2(0.4683333333333333, -0.02666666666666667), vec2(0.48833333333333334, 0.005), vec2(0.5116666666666667, 0.013333333333333334), vec2(0.535, -0.0033333333333333335), vec2(0.535, -0.03833333333333333), vec2(0.535, -0.07), vec2(0.535, -0.10666666666666667), vec2(0.535, -0.13833333333333334), vec2(0.555, -0.16166666666666665), vec2(0.575, -0.17333333333333334), vec2(0.595, -0.15833333333333333), vec2(0.6116666666666667, -0.13), vec2(0.615, -0.08666666666666667), vec2(0.615, -0.04666666666666667), vec2(0.615, 0.005), vec2(0.615, 0.03666666666666667), vec2(0.615, 0.06833333333333333), vec2(0.615, 0.1), vec2(0.6116666666666667, 0.14), vec2(0.6033333333333334, 0.175), vec2(0.6, 0.20333333333333334), vec2(0.5833333333333334, 0.235), vec2(0.575, 0.25833333333333336), vec2(0.5516666666666666, 0.275), vec2(0.5316666666666666, 0.29), vec2(0.5116666666666667, 0.315), vec2(0.49166666666666664, 0.32666666666666666), vec2(0.4683333333333333, 0.3383333333333333), vec2(0.43666666666666665, 0.3383333333333333), vec2(0.405, 0.3383333333333333), vec2(0.37333333333333335, 0.3383333333333333), vec2(0.3416666666666667, 0.3383333333333333), vec2(0.31, 0.32166666666666666), vec2(0.2816666666666667, 0.30666666666666664), vec2(0.25333333333333335, 0.2833333333333333), vec2(0.235, 0.2633333333333333), vec2(0.21, 0.24333333333333335), vec2(0.19, 0.21833333333333332), vec2(0.16666666666666666, 0.20333333333333334), vec2(0.14666666666666667, 0.18333333333333332), vec2(0.13166666666666665, 0.16333333333333333), vec2(0.12333333333333334, 0.13166666666666665), vec2(0.12333333333333334, 0.13166666666666665), vec2(0.12333333333333334, 0.16333333333333333), vec2(0.11166666666666666, 0.195), vec2(0.08333333333333333, 0.22333333333333333), vec2(0.06333333333333334, 0.24666666666666667), vec2(0.035, 0.27), vec2(0.011666666666666667, 0.2633333333333333), vec2(0.008333333333333333, 0.22333333333333333), vec2(0.0033333333333333335, 0.19166666666666668), vec2(-0.008333333333333333, 0.16), vec2(-0.02, 0.14833333333333334), vec2(-0.02, 0.18), vec2(-0.02, 0.21166666666666667), vec2(-0.035, 0.24333333333333335), vec2(-0.051666666666666666, 0.26666666666666666), vec2(-0.07166666666666667, 0.2866666666666667), vec2(-0.08666666666666667, 0.3016666666666667), vec2(-0.10666666666666667, 0.32166666666666666), vec2(-0.13833333333333334, 0.32166666666666666), vec2(-0.175, 0.32166666666666666), vec2(-0.20666666666666667, 0.315), vec2(-0.23333333333333334, 0.29833333333333334), vec2(-0.26166666666666666, 0.2833333333333333), vec2(-0.29333333333333333, 0.25833333333333336), vec2(-0.325, 0.22666666666666666), vec2(-0.345, 0.19166666666666668), vec2(-0.3566666666666667, 0.155));\nconst float TAU = 6.28318530718;\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}", "buffer_b_code": "// Visualization of the path as it is drawn\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    float unit = 2.0 / iResolution.y;\n\n    float dt = TAU / float(path.length());\n    float t = float(iFrame) * dt;\n    float tPrev = t - dt;\n\n    // Calculate the previous and current positions\n    vec2 prevPos = vec2(0.0);\n    vec2 pos = vec2(0.0);\n    for (int n=0; n < path.length(); n++) {\n        vec3 epicycle = texelFetch(iChannel0, ivec2(n, 0), 0).xyz;\n\n        float aPrev = tPrev * epicycle.y + epicycle.z;\n        prevPos += vec2(cos(aPrev), sin(aPrev)) * epicycle.x;\n\n        float a = t * epicycle.y + epicycle.z;\n        pos += vec2(cos(a), sin(a)) * epicycle.x;\n    }\n\n    // Draw a new segment from the previous position to the current position\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, prevPos, pos)));\n\n    // Clear the buffer after the path has been completed\n    if (iFrame % path.length() == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 273, 273, 1087]], "test": "untested"}
{"id": "wlGyRW", "name": "Realtime Nebula Rewrite", "author": "Zi7ar21", "description": "Total rewrite of an older shader made for realtime. Testing out fork feature.", "tags": ["raymarch", "volumetric", "nebula", "fork", "realtime", "volumetrics"], "likes": 4, "viewed": 335, "published": 3, "date": "1610552258", "time_retrieved": "2024-07-30T19:45:24.397603", "image_code": "// ^^^ Switch Between Common and Image ^^^\n// Commons are for commmon values and settings.\n// Image is for rendering the nebula.\n\n// Warning: These volumetrics are not accurate and do not take into account transmittance and stuff!\n// They are just meant to be fast.\n\n// Zi7ar21's In Progress Nebula Ray Marcher --- January 13th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/wlGyRW\n// Fork of \"Another Non-Realtime Nebula\" by Zi7ar21. https://www.shadertoy.com/view/tsKyRD\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Oof ugly mess below watch out lol\n\n// Cyclic Noise from https://www.shadertoy.com/view/wl3czN\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.1;\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp){\n    p += sin(p.yzx*0.25*trk-trk*6.1+cos(p*0.1+0.5)*1.0)*dspAmp;\n    float ofst = 4.0;\n    vec3 s = sin(p*1.5);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx*0.95+s.xyz+ofst)))*z;\n    dspAmp *= 0.65;\n    z *= 0.5;\n    trk *= 1.45;\n    p *= m3;}\nfloat cyclic3D(vec3 p){\n    vec3 bp = p;\n    float rz = 0.0;\n    vec3 drv = vec3(0.0);  \n    float z = 1.5;\n    float trk= 1.0;\n    float dspAmp = 1.0;\n    for (int i = 0; i<=octaves; i++){\n        cyclicOctave(p, rz, z, trk, dspAmp);}\n    rz -= 1.1;\n    return rz;}\n\n// Colors\n/*vec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x-min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)), d/(q.x+e), q.x);\n}*/\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx+K.xyz)*6.0-K.www);\n    return c.z*mix(K.xxx, clamp(p-K.xxx, 0.0, 1.0), c.y);\n}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = cyclic3D(raypos)-distance(raypos, vec3(0.0, 0.0, 0.0));\n    float densitysubtract = cyclic3D(raypos*2.0+vec3(2.0, 2.0, 4.0))*0.5;\n    vec3 rgb = hsv2rgb(clamp(vec3((density/8.0)+0.6, 1.0, density-densitysubtract), vec3(0.0), vec3(1.0)));\n    return rgb;\n}\n\nvec4 rand4blue(){\n    return texelFetch(iChannel0, shift2(), 0);\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 raydir, vec3 camerapos){\n    vec3 density = vec3(0.0);\n    vec3 raypos = camerapos+(raydir*(rand4blue().r-0.5)*2.0);\n    for(int i=0; i < maxmarches; i++){\n        raypos += raydir*stepsize;\n        density += nebulanoise(raypos)*DENSITY;}\n    return density;}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //INIT_RNG;\n    rng_initialize(fragCoord, 0);\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    // Camera Orientation\n    mat3 rotationmatrix = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 camerapos = vec3(sin(iTime*pi)/4.0, cos(iTime*pi)/4.0, -4.0);\n    vec3 raydir = normalize(camerafov*(uv.x*rotationmatrix[0]+uv.y*rotationmatrix[1])+rotationmatrix[2]);\n    vec3 raymarched = raymarch(raydir, camerapos);\n    fragColor = vec4(pow(raymarched, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common and Image ^^^\n// This is for commmon values and settings.\n\n// Change these Parameters to Your Liking!\n\n// Field of View for the Virtual Camera\n#define camerafov 1.0\n\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define maxmarches 8\n\n// fBm Number of Octaves (Detail)\n#define octaves 4\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define stepsize 1.0\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again.\n#define DENSITY 1.0\n\n// Settings not meant to be changed.\n// Pi is used for doing math with Radians where the Trigonometric functions are used, there is no point\n// in changing this. Full precsion floating point numbers can represent pi as 3.14159265, but it can't hurt\n// to add a few more digits in the case Shadertoy supports double precision in the future.\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\n/*uint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x+fragCoord.y*iResolution.x);\n// https://www.pcg-random.org/\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}*/\n\n// Blue Noise for Real-Time dithering (Renders must be viewed 1:1 scale!)\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\nvoid rng_initialize(vec2 p, int frame){\n    pixel = ivec2(p);\n    // White noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x)+uint(p.y));\n    // Blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31+4566, frame*2345+58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v){\n\tv = v * 1664525u+1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n}\n// Random blue noise sampling pos\nivec2 shift2(){\n    pcg4d(s1);\n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1110, 1110, 1210, 1210, 1457], [1458, 1458, 1481, 1481, 1724], [2073, 2073, 2094, 2094, 2249], [2251, 2267, 2297, 2297, 2573], [2575, 2575, 2592, 2592, 2641], [2643, 2668, 2711, 2711, 2947], [2949, 2969, 3023, 3039, 3587]], "test": "untested"}
{"id": "ttGyRW", "name": "UInt Texture Test", "author": "mla", "description": "Test for writing & reading uint values to & from texture - red channel shows values being passed incorrectly, green channel shows NaNs being transmitted, blue channel shows subnormal numbers.\n\nMouse button down to use \"texture()\" instead of \"texelFetch()\"", "tags": ["test", "texture", "uint"], "likes": 3, "viewed": 396, "published": 3, "date": "1610551996", "time_retrieved": "2024-07-30T19:45:25.173529", "image_code": "// Test for round tripping uints through conversion to floats, texture write,\n// texture read, and conversion back to uints.\n// Key 'x' fixes data as at frame 0, use to see if data preserved over window\n// resize (it isn't - NaNs and subnormals get corrupted).\n\nbool subnormal(uint n) {\n  if (n == 0u) return false;\n  return ((n>>23)&0xffU) == 0U;\n}\n\nbool subnormal(uvec4 p) {\n  return subnormal(p.x) || subnormal(p.y) || subnormal(p.z) || subnormal(p.w);\n}\n\n// isnan() doesn't work on some platforms, D3D11 it seems\n// This will return true for Inf values too.\nbool nan(uint n) {\n  return ((n>>23)&0xffU) == 0xffU;\n}\n\nbool nan(uvec4 p) {\n  return nan(p.x) || nan(p.y) || nan(p.z) || nan(p.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int frame = key(CHAR_X) ? 0 : iFrame;\n    \n    uvec4 outval = mkoutval(frame,fragCoord);\n    vec4 incol = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (iMouse.z > 0.0) incol = texture(iChannel0,fragCoord/iResolution.xy);\n\n    uvec4 inval = floatBitsToUint(incol);\n    fragColor = vec4(outval != inval,nan(inval),subnormal(inval),1);\n    //if (iMouse.z > 0.0 && inval>>16 == uvec4(0)) fragColor = vec4(1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, vec2 fragCoord){\n    if (key(CHAR_X) && iFrame != 0) {\n      fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    } else {\n      uvec4 outval = mkoutval(iFrame,fragCoord);\n      fragColor = uintBitsToFloat(outval);\n    }\n    //if (any(isnan(fragColor))) fragColor = vec4(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec4 mkoutval(int frame, vec2 fragcoord) {\n    uvec4 outval;\n    for (uint i = 0U; i < 4U; i++) {\n      outval[i] = ihash(uint(frame<<2) ^ i ^ ihash(uint(fragcoord.x)^ihash(uint(fragcoord.y))));\n    }\n    return outval;\n}\n\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 286, 286, 349], [351, 351, 376, 376, 457], [459, 562, 580, 580, 617], [619, 619, 638, 638, 695], [697, 697, 754, 754, 1169]], "test": "untested"}
{"id": "3tycRD", "name": "Infinity 1", "author": "Leasel", "description": "Uses complex numbers to calculate rotations(, and it also strongly resembles matrix multiplucations).", "tags": ["complex", "matrix"], "likes": 1, "viewed": 262, "published": 3, "date": "1610548082", "time_retrieved": "2024-07-30T19:45:25.987353", "image_code": "void RotateL(inout vec2 point)\n{\n    point.y += BS + bL*BS;\n    point.x -= aL*BS - BS;\n    point = vec2(aL*point.x - bL*point.y, bL * point.x + aL*point.y + BS);\n}\n\nvoid RotateR(inout vec2 point)\n{\n    point.y += BS - bR*BS;\n    point.x -= -aR*BS + BS;\n    point = vec2(aR*point.x - bR*point.y, bR * point.x + aR*point.y + BS);\n}\n\n//https://iquilezles.org/articles/distfunctions\nbool sdCapsule( vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) > 0.002;\n}\n\nbool TestDistance(in vec2[lengthPoints] Points, in vec2 p)\n{\n    return \n    (\n        sdCapsule(p, Points[0], Points[1]) && \n        sdCapsule(p, Points[1], Points[2]) && \n        sdCapsule(p, Points[2], Points[3]) && \n        sdCapsule(p, Points[3], Points[0])\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.y - 0.5 - vec2(Ratio, 0.);\n    \n    vec3 col;\n    \n    //Rotation of the complex\n    int r = 0;\n    bool NotHitPoint = TestDistance(pointsB, uv);\n    for(int i = 0; i < iterations && NotHitPoint; i++)\n    {\n        for(int r = 0; r < pointsEL.length() && NotHitPoint; r++)\n        {\n            //NotHitPoint = length(pointsEL[r] - uv) > 0.002;\n            RotateL(pointsEL[r]);\n        }\n        NotHitPoint = NotHitPoint && TestDistance(pointsEL, uv);\n        for(int r = 0; r < pointsER.length() && NotHitPoint; r++)\n        {\n            //NotHitPoint = length(pointsER[r] - uv) > 0.002;\n            RotateR(pointsER[r]);\n        }\n        NotHitPoint = NotHitPoint && TestDistance(pointsER, uv);\n    }\n    \n    col = !NotHitPoint ? vec3(1.) : vec3(0.);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "//This is the rotation with a complex number (a + bi)*z\n#define pi 3.14159265359\n#define phi (iTime*0.01)*pi\n#define aL cos(phi)\n#define bL sin(phi) \n#define aR cos(-phi)\n#define bR sin(-phi) \n#define iterations 80\n#define Ratio iResolution.y/(iResolution.y + iResolution.x)\n#define BS 0.02\n#define lengthPoints pointsB.length()\n\nconst vec2 pointsB[] = vec2[](vec2(-BS, -BS), vec2( BS, -BS), vec2( BS, BS), vec2(-BS, BS));\nvec2 pointsEL[] = pointsB;\nvec2 pointsER[] = pointsB;\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tycRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 163], [165, 165, 197, 197, 329], [331, 379, 420, 420, 545], [820, 820, 877, 932, 1760]], "test": "untested"}
{"id": "ttKcz1", "name": "2 pillars (work in progress)", "author": "intrakits", "description": "I'm still learning about colours and how to add them to individual objects. This was me experimenting with colour and displacement maps.", "tags": ["3d", "displacement", "color", "colour", "pillars", "elemental"], "likes": 3, "viewed": 276, "published": 3, "date": "1610510153", "time_retrieved": "2024-07-30T19:45:26.750313", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r, float offX, float offY, float offZ) {\n\ta.x += offX;\n    b.x += offX;\n    \n    a.y += offY;\n    b.y += offY;\n    \n    a.z += offZ;\n    b.z += offZ;\n    \n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n   // float ds = length(p-sphere.xyz)-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    float xMov = pow(sin((p.x*20. + iTime*pow(sin(iTime*.0001),5.))),8.)*.2;\n    float zMov = pow(cos((p.z*20. + iTime*pow(cos(iTime*.0001),5.))),8.)*.3;\n    float dp =p.y;\n   \n    // cylinder distance\n    float offX = 2.;\n    float offY = 0.;\n    float offZ = 0.;\n    float cyld2 = sdCylinder(p, vec3(0,0,0), vec3(0,2,0), 0.5, offX, offY, offZ);\n    \n    vec2 uv3 = vec2(atan(p.x-offX,p.z-offZ)/(3.14159*2.),p.y/5.)+.5;\n    // cylinder distance\n    offX = 0.;\n    offY = 0.;\n    offZ = 0.;\n    float cyld = sdCylinder(p, vec3(0,0,0), vec3(0,2,0), 0.5, offX, offY, offZ);\n    //displacement map for cylinder\n    //uv for pillar\n    vec2 uv = vec2(atan(p.x,p.z)/(3.14159*2.),p.y/5.)+.5;\n    //uv for ground\n    vec2 uv2 = vec2(p.x/10.,p.z/10.)+.5;\n    \n    \n    \n    float disp = texture(iChannel1,uv).r;\n    float gDisp = texture(iChannel1,uv2).r;\n    float disp3 = texture(iChannel1,uv3).r;\n\n    float d = cyld;\n    disp *= smoothstep(2.,1.8,abs(p.y));\n    disp3 *= smoothstep(2.,1.8,abs(p.y));\n    float disp2 = sin(p.y*4.)*cos(p.x*4.);\n    //disp -= disp2*.6;\n    d-=disp*.3;\n    dp -= gDisp*.5;\n\n    d = min(dp,d);\n    \n    \n    cyld2-=disp3*.3;\n    d = min(cyld2,d);\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds*.7;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,6);\n    \n    lightPos.xz *= Rot(sin(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p+vec3(4,0,0));\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(4,3,1);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    \n    \n    //color objects\n    if(d < MAX_DIST){\n        \n        //get normals\n        vec3 n = abs(GetNormal(p));\n        \n        //floor color\n        float plane = p.y;\n        //uv for ground\n        vec2 uv2 = vec2(p.x/10.,p.z/10.)+.5;\n        float gDisp = texture(iChannel1,uv2).r;\n        plane+= gDisp*.5;\n        col = vec3(plane)*vec3(.5);\n        \n        //stone color\n        // cylinder distance\n        float offX = 0.;\n        float offY = 0.;\n        float offZ = 0.;\n\n        float cyld = sdCylinder(p, vec3(0,0,0), vec3(0,2,0), 0.5, offX, offY, offZ);\n\n        vec3 cyld3 = vec3(1)/vec3(cyld)*(sin(iTime)*.2+.2);\n        col = max(col-cyld3, cyld3 * vec3(.1,0,0));\n        // cylinder distance\n        offX = 2.;\n        offY = 0.;\n        offZ = 0.;\n        float cyldL = sdCylinder(p, vec3(0,0,0), vec3(0,2,0), 0.5, offX, offY, offZ);\n        \n        vec3 cyldL3 = vec3(1)/vec3(cyldL)*(cos(iTime)*.2+.2);;\n        col = max(col-cyldL3, cyldL3* vec3(0,0,.1));\n        //get diffuse lighting\n        float diff = GetLight(p);\n       // col *= vec3(diff);\n        \n\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKcz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 151], [152, 152, 239, 239, 640], [642, 642, 691, 714, 1147], [1149, 1149, 1179, 1179, 1250], [1252, 1252, 1279, 1279, 1318], [1319, 1319, 1341, 1365, 2988], [2989, 2989, 3022, 3050, 3455], [3456, 3456, 3479, 3518, 3881], [3882, 3882, 3905, 3940, 4872], [4873, 4873, 4923, 4923, 5114], [5115, 5115, 5172, 5254, 6948]], "test": "untested"}
{"id": "wtKyR1", "name": "127 bits per pixel", "author": "ttg", "description": "Utilizing all channels it is possible to store 127 bits per pixel without using special float values (which become altered in buffers on some implementations).\n4x IEEE754 binary32 allows ((1<<24)*254)^4 distinct values or 127.9547 bits of information.", "tags": ["encoding", "uintbitstofloat", "floatbitstouint"], "likes": 11, "viewed": 548, "published": 3, "date": "1610497299", "time_retrieved": "2024-07-30T19:45:27.514271", "image_code": "\nfloat printbits (uint v, int b) {\n  return float( (v>>b)&0x1u );\n}\n\nfloat printbits (uvec4 v, int b) {\n  return printbits(v[b/32], b%32);\n}\n\nvoid mainImage( out vec4 d, in vec2 c ) {\n  uvec4 ref = testvalue(iFrame);\n  uvec4 dec = b127_ieee754_decode(texture(iChannel0, vec2(.5)));\n  //uvec4 dec = b127_ieee754_decode(texelFetch(iChannel0, ivec2(0), 0));\n  vec2 uv = 1.-c/iResolution.xy;\n  int i = int(floor(uv.x*(127.+4.)-2.));\n  int j = int(floor(uv.y*(3.+1.)-.5));\n  vec3 v = vec3(0.5);\n  if (i>=0 && i<127) {\n    if (j==0) v = vec3(printbits( ref     ,i )); // Top: correct value\n    if (j==1) v = vec3(printbits( ref^dec ,i )); //  -> Middle: difference: there should be none\n    if (j==2) v = vec3(printbits( dec     ,i )); // Bottom: decoded value\n  }\n  d.rgb = pow(v.rgb, vec3(1./2.2));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\n\"127 bits per pixel\" by Theron Tarigo, www.shadertoy.com/user/ttg\n\nUtilizing all channels of an OpenGL 32-bit float buffer it is possible to store\n127 bits per pixel without using special float values\n(which become altered in buffers on some implementations).\n\n4x IEEE754 binary32 allows ((1<<24)*254)^4 distinct values or\n127.9547 bits of information.\n\nThe following implementations:\n  b127_ieee754_encode\n  b127_ieee754_decode\nare free for use, copying, and modification by anyone for any purpose,\nwithout restriction.\n\nAttribution should be included for providing clarity of the origin of these\nimplementations; including the original URL is sufficient attribution:\nhttps://www.shadertoy.com/view/wtKyR1\n\n*/\n\nvec4 b127_ieee754_encode (uvec4 v) {\n  v.w&=0x7FFFFFFFu;\n  uvec4 l = uvec4( v.xyz&0xFFFFFFu , v.x>>24 | v.y>>24<<8 | v.z>>24<<16 );\n  return uintBitsToFloat( (l&0x800000u)<<8 | l&0x7FFFFFu\n   | 1u+uvec4(v.w/uvec4(1,254,254*254,254*254*254))%254u <<23 );\n}\n\nuvec4 b127_ieee754_decode (vec4 f) {\n  uvec4 e = floatBitsToUint(f);\n  uvec4 l = (e&0x80000000u)>>8 | e&0x7FFFFFu;\n  uvec4 h = (e>>23&0xFFu)-1u;\n  return uvec4(\n    l.xyz | uvec3(l.w)>>uvec3(0,8,16)<<24,\n    h.x+254u*h.y+(254u*254u)*h.z+(254u*254u*254u)*h.w );\n}\n\n/*===========================================================================*/\n\n// test cases\n\nuint hash (uint x) {\n  // https://www.shadertoy.com/view/WttXWX\n  x ^= x >> 17;\n  x *= 0xed5ad4bbU;\n  x ^= x >> 11;\n  x *= 0xac4c1b51U;\n  x ^= x >> 15;\n  x *= 0x31848babU;\n  x ^= x >> 14;\n  return x;\n}\n\nuvec4 testvalue (int s) {\n  uvec4 v;\n  v.x = hash(uint(s*4+0));\n  v.y = hash(uint(s*4+1));\n  v.z = hash(uint(s*4+2));\n  v.w = hash(uint(s*4+3))&0x7FFFFFFFu;\n  return v;\n}\n", "buffer_a_code": "\nvoid mainImage( out vec4 v, in vec2 c ) {\n  v = b127_ieee754_encode( testvalue(iFrame) );\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtKyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 34, 34, 67], [69, 69, 103, 103, 140], [142, 142, 183, 183, 796]], "test": "untested"}
{"id": "tlVczh", "name": "Orthonormal basis comparison", "author": "Dain", "description": " Visualize Orthonormal basis functions to see which look smooth\n\nAbrupt change in color = bad\nblack color = very bad\n", "tags": ["tangent", "orthonormal", "basis", "binormal"], "likes": 10, "viewed": 639, "published": 3, "date": "1610495198", "time_retrieved": "2024-07-30T19:45:28.283214", "image_code": "\n// Start from: https://www.shadertoy.com/view/lldGRM\n\n//Show orthonormal as rgb\n//Scaled by determinate(so color becomes black when it isn't near 1)\n//Abrupt change in direction doesn't look good when using these to orient tangent space normals\n//Uses box so we can see the z==-1 area, which isn't easy to see on a sphere\n//If you hold left mouse it changes the visualization to avoid using abs(), to detect any cases where the sign is flipped but it retains the same absolute value\n//It is not scaled by determinate when holding left mouse as black is a possible output color in this case\n\n//0 = pixar OrthobranchlessONB  https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n//1 = MBR 2a method\n//2 = MBR Frisvad(fails at z==-1)\n//3 = Frisvad with \"fix\" for z == -1 (looks dubious when holding left mouse)\n//4 = Nimitz Frisvad (bad determinate at z == -1)\n//5 = MBR Frisvad with clamping to work around z==-1 (my preferred method so far)\n//6 = MLA method provided in comment\n//7 = BeRo method in comment\n\n#define METHOD 2\n\n#if METHOD == 0\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2)\n{\n    //pixar method, supposedly this method is good, but I have not gotten good results when testing it\n    //because it abruptly changes orientation at z = 0\n\tfloat sign = n.z >= 0.f ? 1.0f : -1.f;\n\tfloat a = -1.0/(sign + n.z);\n\tfloat b = n.x * n.y * a; \n\tb1 = vec3(1.0f + sign * n.x * n.x * a, sign * b, -sign * n.x);\n\tb2 = vec3(b, sign + n.y * n.y * a, -n.y);\t\n}\n#elif METHOD == 1\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  // MBR method 2a variant, seems similiar to pixar\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n}\n#elif METHOD == 2\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  //MBR that isn't handling z == -1 \n  float a =  n.y/(1.0+n.z);\n \n  float b =  n.y*a;\n  float c = -n.x*a;\n\n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n}\n#elif METHOD == 3\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n   //looks good but has this ugly branch\n  if(n.z < -0.99995)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n#elif METHOD == 4\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n// nimitz's impl of frisvad, fails at z == -1\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n}\n#elif METHOD == 5\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  //MBR frizvald but attempts to deal with z == -1\n  float k = 1.0/max(1.0 + n.z,0.00001);\n // k = min(k, 99995.0);\n  float a =  n.y*k;\n\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n}\n#elif METHOD == 6\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n  //MLA provided this in comments, it looks good but if you hold left mouse you can see that it flips\n  //the signs at -z\n  bool flip = n.z < 0.0;\n  n.z = abs(n.z);\n  float a =  n.y/(1.0+n.z);\n \n  float b =  n.y*a;\n  float c = -n.x*a;\n\n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n  if (flip) {\n    xp.z = -xp.z, yp.z = -yp.z;\n    vec3 t = xp; xp = yp; yp = t;\n  }\n}\n#elif METHOD == 7\nvoid basis(in vec3 n, out vec3 t, out vec3 b)\n{\n  b = normalize(cross(n, normalize(n.zxy - dot(n.zxy, n))));\n  t = normalize(cross(b, n));\n}\n\n#endif\n\n//------ below here is original\n\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(vec3 p)\n{\n return sdBox(p, vec3(.50))-.5;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n  float precis = 0.001;\n  float h=precis*2.0;\n  float d = 0.;\n  for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n#if 0\n\n\n#endif\n\nfloat Determinate(vec3 n, vec3 f, vec3 r){\nreturn   dot(n, cross(f, r ) );\n}\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\nfloat saturateNanToZero(float f){\n    if(isnan(f) || f <= 0.0){\n        return 0.0;\n   }\n   float f2 = abs(1.0-f);\n   return 1.0 - f2;\n  //return min(max(f, 0.0), 1.0);\n//return max(min(f, 1.0), 0.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n        \n        //get orthonormal at hit point, then see how far from 1 the determinate is..\n        vec3 r = vec3(0);vec3 f = vec3(0);\n    //    nor = nor.zxy;\n        basis(nor,f,r);\n    \n        float d = saturateNanToZero(Determinate(nor, f,r));\n      //  col.r = pow(d,1.0);\n      //  col.g = 0.0;\n      //  col.g = abs(f.x);\n        \n        //check for wild swings nearby..\n        //nor = normalize(nor.zxy +0.001);\n        //  vec3 r2 = vec3(0);vec3 f2 = vec3(0);\n       // basis(nor,f2,r2);\n       // float diff = saturate(min(dot(f2,f), dot(r2,r)));\n        //col.b = pow(diff,.10);\n           bool mouseBtn2Pressed = (iMouse.z >= 1.0);\n\n        //Full range of color to see any sign flips      \n       vec3 fullColor = ((r +f+nor)*.5 + .5);\n       vec3 absColor = abs(r+f+nor)*.71*pow(d,16.0);\n       \n       if(mouseBtn2Pressed){\n         col = fullColor;\n       }else{\n         col = absColor;\n       }\n       \n     //  col = mix(absColor,fullColor, abs(sin(iTime*.5)));\n    \n    //   col = abs(r +f+nor)*.71* pow(d,16.0);\n        \n    }\n    \n\n    \n\tfragColor = vec4( col,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3618, 3618, 3639, 3639, 3691], [3693, 3693, 3724, 3724, 3815], [3818, 3818, 3837, 3837, 3871], [3873, 3873, 3910, 3910, 4134], [4347, 4347, 4389, 4389, 4423], [4425, 4475, 4533, 4533, 4907], [4909, 4909, 4942, 4942, 5111], [5112, 5112, 5169, 5169, 7476]], "test": "untested"}
{"id": "wlKyR1", "name": "shader-web-background JS lib", "author": "morisil", "description": "Check mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 22, "viewed": 1195, "published": 3, "date": "1610492966", "time_retrieved": "2024-07-30T19:45:29.058143", "image_code": "/*\n  This shader is here to spread the news about JavaScript library:\n  \n  https://xemantic.github.io/shader-web-background/\n \n  It is designed to be compatible with Shadertoy while adding more\n  integration options and saving many once-per-frame computations.\n  Even complex shaders should work on almost any hardware. I wanted\n  to build a base, which would let me use shaders as part of my\n  regular web development process, to transform my future website\n  into more immersive experiences. Check the project on mobile and\n  how it is reacting to device orientation, parallax scrolling, etc.\n  \n  Note: Mouse movement will make feedback follow the cursor.  \n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .004;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .35;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .3;\nconst float iBlob1PowFactor           = 40.;\nconst float iBlob1ColorPulseSpeed     = .07;\nconst float iBlob2Radius              = .4;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     = .07;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = .5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel0, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlKyR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 666, 721, 721, 793]], "test": "untested"}
{"id": "ttKyRh", "name": "Day 392", "author": "jeyko", "description": "fractato", "tags": ["mdtmjvm"], "likes": 9, "viewed": 387, "published": 3, "date": "1610481234", "time_retrieved": "2024-07-30T19:45:30.019572", "image_code": "// wip\n\n\n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n// cyclic noise from nimitz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(1.03,1.03,0.95 + dot(uv,uv)*0.02));\n    \n    \n    col *= 3.3;\n    col = mix(col,smoothstep(0.,1.,col*vec3(0.95,1.,1.)*1.),0.5);\n    \n    col = mix(acesFilm(col), col, 0.);\n    \n    \n    col = mix(col,col*col*col*0.5,dot(uv,uv));\n    //col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\nvec2 dmin(vec2 d, vec2 b){return d.x < b.x ? d : b;}\n\nfloat wallNoise = 0.;\nfloat wallNoiseB = 0.;\n\nvec2 sdFrac(vec3 po){\n\n    vec4 p = vec4(po,1.);\n    \n    vec2 d = vec2(10e5);\n    \n    p.xy -= 1.;\n    \n    float id = floor(p.z/4. + 0.5);\n    p.xyz = pmod(p.xyz,vec3(2.,2.,4.));\n    for(int i = 0; i < 4; i++){\n        \n        p.xyz = abs(p.xyz);\n        \n        if(p.x > p.y) p.xy = p.yx;\n        if(p.x < p.z) p.xz = p.zx;\n        if(p.y > p.z) p.yz = p.zy;\n        \n        p.xyz -= vec3(0.,0.1,0.3 - sin(id*2. )*0.1);\n        \n        p *= 4.5;\n        \n        //p.xy *= rot(0.125*pi);\n        \n    }\n    \n    \n    p.xyz /= p.w;\n    \n    p.w = 1.;\n    \n    for(int i = 0; i < 4; i++){\n        \n        float dpp = dot(p.xyz,p.xyz*1.);\n        p.xyz = pmod(p.xyz,vec3(4.3,2.,3.6));\n        \n        p.xyz = abs(p.xyz);\n        \n        p /= dpp;\n        \n        p.x -= 0.06;\n        p.y -= 0.03;\n        \n        p.z -= 0.05;\n        \n        p.zx *= rot(-0.5*pi);\n        p *= 3.;\n        \n        \n    }\n    \n    p.xyz /= p.w;\n\n    vec3 pp = p.xyz;\n    float da = length(p.xy) - 0.03;\n    //d = dmin(d, max(abs(p.x),abs(p.y)) - 0.03, ID_GOLD);\n    \n    p.xz *= rot( 0.*pi);\n    p.x += 0.07;\n    float db = max(abs(p.x),abs(p.z)) - 0.04;\n    db = length(p.xz) - 0.03;\n    \n    \n    pp.xz *= rot(-0.125*pi);\n    \n    pp -= vec3(-0.,0.01,0.1);\n    \n    \n    pp.yz *= rot(0.25*pi);\n    \n    float dc = length(pp.yz) - 0.04;\n    \n    \n    d = dmin(d, da, ID_GOLD);\n    d = dmin(d,db, ID_OTHER);\n    d = dmin(d,dc, ID_THIRD);\n    //d = dmin(d, max(abs(p.x),abs(p.z)) - 0.02, ID_OTHER);\n    \n    //d = min(d,length(p) - 0.2);\n\n    return d;\n}\n\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    //vec2 dwall = sdWall(p); \n    vec2 dsilk = sdFrac(p);\n\n    d = dmin(d, dsilk);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.4;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*precis).x;\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy)/iResolution.xy;\n    \n    gmuv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    //uv *= 1. + dot(uv,uv)*5.;\n    \n    muv = muv*2. - 1.;\n    if (muv.x < -0.85){\n        muv -= muv;\n    }\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 1. - iTime*0.2;    \n    ro *= 1.9;\n    \n    \n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    \n    //lookAt.z += muv.x*0.3;\n    lookAt.y += muv.y;\n    \n    \n    lookAt += normalize(vec3(cos(iTime*0.5),sin(iTime*0.7),cos(iTime*0.3)))*0.3;\n    \n    vec3 rd = getRd(ro, lookAt, uv, 2.);\n    \n    \n    \n    //ro -= rd*1.;\n    \n    vec3 col = vec3(0);\n    \n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    \n    vec3 atten = vec3(1.);\n    \n    \n    vec3 hitCol = vec3(0);\n    \n    \n    \n    float i = 0.;\n    vec3 reflalbedo = mix(ambientCol, lightCol,0.5);\n    for(; i < maxIters; i++){\n\n        p = ro + rd*(t += d.x*stepSz);\n        d = map(p);\n\n        if(d.x < eps){\n            hit = true;\n            break;\n        }\n\n    }\n\n    \n    vec3 n = getNormal(p,eps);\n    n = normalize(n - lDir*cyclicNoise(p*220.,0.)*0.3);\n        \n                    \n    {\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.23))*a).x/a, 0., 1.)\n        \n        float ao = AO(n,0.3)*AO(n,0.5)*AO(n,0.04)*AO(n,.14)*1.;\n         \n        //float SSS = SSS(vec3(-1.,.5,0.9),1.9)*1.*SSS(vec3(-4.,2.,0.2),5.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n\n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        float shad = softshadow( p, lDir, 0.01, 10., 2.);\n        \n        //float shad = 1.;\n        shad = min(shad,diff);\n        \n        vec3 colSilk = vec3(0);\n        {\n            map(p);\n            albedo = silkCol;\n            \n            albedo -= albedo;\n            \n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(n*2.)*0.5 + 0.5),4.)/sqrt(3.); \n            float factb = pow(length(sin(r*3. + n*5. + 4. + iTime*0.)*0.5 + 0.5)/sqrt(3.),0.4); \n            float factc = pow(length(sin(r*5. + n*4. + 4. + iTime*2.2)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            albedo += mix( silkCol, vec3(0) + ambientCol*0.04 + silkCol*silkCol*silkCol*0.45,factb);;\n            albedo = mix( albedo, vec3(0) + ambientCol*0.02 + silkCol*silkCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += lightCol*45.*(1.-pow(factb,.005))*(1. + silkCol*.3);\n            colSilk = albedo*lightCol;\n\n            //colSilk = mix(colSilk, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colSilk = mix((colSilk + colSilk*ambientCol)*0., colSilk, ao);\n            //colSilk = mix((colSilk + colSilk*ambientCol)*0.5,colSilk, shad);\n            \n            \n        }\n        \n        vec3 colOther = vec3(0);\n        \n        \n        {\n            map(p);\n            \n            albedo -= albedo;\n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(r*4. - n*15.)*0.5 + 0.5)/sqrt(2.),0.2); \n            float factb = pow(length(sin(r*4. + n*6. + 0. + iTime*0.)*0.5 + 0.5),1.5)/sqrt(3.); \n            float factc = pow(length(sin(r*1. + n*5. + 4. + iTime*0.)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            \n            \n            vec3 otherCol = vec3(0.7,0.5,0.15)*0.1;\n            albedo += mix( otherCol, vec3(0.3,0.6,0.4)*0.00,fact);;\n            //albedo = mix( albedo, vec3(0) + ambientCol*0. + otherCol*otherCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += (1.-pow(factb,0.4))*vec3(1.8,1.2,0.55)*0.05;\n            \n            colOther = albedo;\n\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colOther = mix((colOther + colOther*ambientCol)*0.5, colOther, ao);\n            colOther = mix((colOther + colOther*ambientCol)*0.5,colOther, shad);\n            \n            \n        }\n        \n        \n        vec3 colThird = vec3(0);\n        \n        {\n            map(p);\n            \n            albedo -= albedo;\n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(r*11. - n*2.)*0.5+ 0.5)/sqrt(3.),0.07); \n            float factb = pow(length(sin(r*4. + n*6. + 0. + iTime*0.)*0.5 + 0.5),1.5)/sqrt(3.); \n            float factc = pow(length(sin(r*1. + n*5. + 4. + iTime*0.)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            \n            \n            vec3 otherCol = vec3(0.5,0.5,0.4)*0.76;\n            albedo += mix( otherCol, vec3(0.5,0.3,0.)*0.003,fact);;\n            //albedo = mix( albedo, vec3(0) + ambientCol*0. + otherCol*otherCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += (1.-pow(factb,0.05))*vec3(1.8,1.2,0.55)*0.03;\n            \n            colThird = albedo;\n\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colThird = mix((colThird + colThird*ambientCol)*0.3, colThird, ao);\n            colThird = mix((colThird + colThird*ambientCol)*0.4,colThird, shad);\n            \n            \n        }\n        \n        hitCol += colSilk*float(floor(d.y) == ID_GOLD);\n\n        hitCol += colOther*float(floor(d.y) == ID_OTHER);\n\n        hitCol += colThird*float(floor(d.y) == ID_THIRD);\n\n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    }\n    \n    if(hit)\n        col += hitCol*atten;\n    \n    //col = mix(col, vec3(1),smoothstep(0.,1.,t*0.05 - 0.6));\n    p = ro + rd*min(t,10.);\n    \n    float fogFact = smoothstep(0.,1.,i/maxIters*3.75 - 0.4);\n    float fogFactB = smoothstep(0.,1.,length(t)*0.13 - .2);\n    \n    \n    \n    //fogFact *= 1. - cyclicNoise(p*2.,1.);\n    \n    \n    vec3 fogCol = vec3(0.1,0.5,0.5)*0.02;\n    \n    //fogCol = mix(fogCol, fogCol*fogCol*fogCol*0.3, cyclicNoiseFog(normalize(rd)*14.,iTime*0.5)*pow(fogFact,4.2));\n    fogCol = mix(fogCol, fogCol*fogCol*fogCol*0.3, cyclicNoiseFog(normalize(rd)*14. + vec3(0,0,iTime),iTime*0.5)*pow(fogFactB,4.2));\n    \n    \n    \n    col = mix(col, fogCol,fogFactB);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat FXAAamt = 0.5;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ID_GOLD 1.\n#define ID_OTHER 2.\n#define ID_THIRD 3.\n\n#define stepSz 0.25\n#define eps 0.001\n#define maxIters 280.\n    \n\n#define ambientCol vec3(0.5,0.5,0.5)\n#define lightCol vec3(0.9,0.8,0.8)*1.\n#define lDir normalize(vec3(-4.5,4,1.))\n#define silkCol vec3(0.3,0.22,0.03)*3.\n#define sssSilkCol vec3(0.9,0.3,0.3)*0.\n\n\n#define pi acos(-1.)\n\n\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec2 gmuv;\n\nvec3 getRd( inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    //ro += right*uv.x*sc;\n    //ro += up*uv.y*sc;\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p, float time){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.75;\n    const float lacunarity = 1.4;\n    const int octaves = 4;\n    \n    \n    \n    \n    const float warp = 0.75;    \n    float warpTrk = 1.4 ;\n    const float warpTrkGain = 1.25;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin((p.zxy + vec3(-sin(time)*0.1,time*0.25,time*0.4))*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n            \n        //noise += sin(dot(cos(p), sin(p.zyx)))*amp;\n        \n        float f = sin(dot(cos(p), sin(p.zyx)));\n        //f = sign(f)*pow(abs(f),1.);\n        noise += f*amp;\n        \n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return (noise*0.25 + 0.5);\n\n    //return 1. - abs(noise)*0.5;\n}\n\n\nfloat cyclicNoiseFog(vec3 p, float time){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.55;\n    const float lacunarity = 1.5;\n    const int octaves = 4;\n    \n    \n    \n    \n    const float warp = 0.5;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .25;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin((p.zxy + vec3(-sin(time)*0.1,time*0.25,time*0.4))*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n            \n        //noise += sin(dot(cos(p), sin(p.zyx)))*amp;\n        \n        float f = sin(dot(cos(p), sin(p.zyx)));\n        //f = sign(f)*pow(abs(f),1.);\n        noise += f*amp;\n        \n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return (noise*0.25 + 0.5);\n\n    //return 1. - abs(noise)*0.5;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 152, 152, 676]], "test": "untested"}
{"id": "WtVczh", "name": "Mandelcoral", "author": "wayfinder", "description": "you got reef with that?", "tags": ["2d", "fractal", "mandelbrot", "coral"], "likes": 8, "viewed": 374, "published": 3, "date": "1610474325", "time_retrieved": "2024-07-30T19:45:30.784527", "image_code": "// using iq's mandelbrot distance https://www.shadertoy.com/view/lsX3W4\n\n\nvec2 cpow(vec2 c, float power) {\n    if (abs(c.x) < 1e-5 && abs(c.y) < 1e-5) return vec2(0.0);\n    vec2 cm = vec2(log(length(c)), atan(c.y, c.x)) * power;\n    float pr = exp(cm.x);\n    return vec2(pr * cos(cm.y), pr * sin(cm.y));\n}\n\nvec3 f(vec2 p, float time) {\n    vec3 res = vec3(1.0);\n    float n = 2.0;\n    float zoom = 0.006 + sin(time) / 500.0;\n    vec2 c = p * zoom - vec2(1.341, 0.065);\n    float imax = 300.0;\n    float bailout = 2.1;\n    vec2 z = vec2(0.0);\n    vec2 dz = z;\n    float m2 = 1.0;\n    \n    for (float i = 18.0; i < imax; i++) {\n        if (m2 > bailout) break;\n        vec2 ch = n * cpow(z, n - 1.0);\n        dz = mat2(ch, -ch.y, ch.x) * dz + vec2(1.0, 0.0);\n        z = cpow(z, n) + c + sin(time) * 0.005;\n        m2 = dot(z, z);\n    }\n    \n    float lm2 = log(m2);\n    float d = 0.5 * sqrt(m2 / dot(dz, dz)) * lm2;\n    res *= d * imax;\n    res.g /= 1.0 - 0.2 * lm2;\n    res = clamp(res, vec3(0.0, 0.0, 0.1), vec3(50.0 * d, 0.3, 1.0));\n    res += vec3(0.002, 0.6, 0.6) / length(dz);\n    res *= sin(vec3(2.0, 0.4, 20.0) * tanh(1.0 - 1.0 / length(tan(z - 100.0) * 0.95)));\n    res += pow(clamp(vec3(1.0) - length(c - z * 1.6), 0.0, 1.0) * 160.0, vec3(0.7)) * res;\n    return res;\n}\n\nvec2 rot(vec2 p, float a) {\n    return cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n\n    float time = 1024.0 + mod(iTime * 0.1, 1024.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y/iResolution.x, 1.0);\n    uv *= 4000.0 / time;\n    \n    vec3 col = f(rot(uv, time), time);\n\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 25207, "src": "https://soundcloud.com/wayfu/wayfinder-party-of-one", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtVczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 106, 106, 305], [307, 307, 335, 335, 1278], [1280, 1280, 1307, 1307, 1359], [1361, 1361, 1418, 1418, 1727]], "test": "untested"}
{"id": "WlVcRh", "name": "Path Tracing Testing 62", "author": "Pjbomb2", "description": "WASD and mouse for movement\nSome settings are in common tab\n\nWhat else should I do/make with this/how can I improve this?", "tags": ["reflection", "refraction", "pathtrace", "pathtracing", "caustic"], "likes": 5, "viewed": 331, "published": 3, "date": "1610474131", "time_retrieved": "2024-07-30T19:45:31.743962", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = texture( iChannel0, uv ).xyz;\n    \n    col *= 2.; // exposure\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    //col = pow( col, vec3(0.8,0.85,0.9) );\n    col = ACESFilm(col); // convert unbounded HDR color range to SDR color range\n    col = LinearToSRGB(col); // convert from linear to sRGB for display\n    col = smoothstep(0., 1., col); // increase contrast\n    \n    fragColor = vec4( col, 1 );\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//increase/decrease bouncecount for more bounces per ray\n#define BOUNCECOUNT 5\n//comment out to remove the procedural \"textures\"\n#define textures\n//comment out to remove the global sun and replace it with a skybox\n#define sun\n\n//material numbers\n#define MATFLOOR 0.\n#define MATBRONZE 1.\n#define MATCHROME 2.\n#define MATLIGHT 3.\n#define MATGLASS 4.\n\n//materials and their properties\nvec3 GetMatProps(in float matID, out float refl, out float refr, out float emmis, out float IOR, out float absorb) {//return material properties when what material is being hit is requested\n    if(matID == MATFLOOR) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(0.933,0.749,0.627);\n    }\n    if(matID == MATBRONZE) {\n     \trefl = 0.5;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 1.18;\n        return vec3(0.6, 0.5, 0.38);\n    }\n    if(matID == MATCHROME) {\n     \trefl = 0.85;\n        refr = 0.0;\n        emmis = 0.0;\n        absorb = 0.0;\n        IOR = 2.3;\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if(matID == MATLIGHT) {\n     \trefl = 0.0;\n        refr = 0.0;\n        emmis = 10.0;\n        absorb = 0.0;\n        IOR = 1.0;\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if(matID == MATGLASS) {\n     \trefl = 0.0;\n        refr = 1.0;\n        emmis = 0.0;\n        absorb = 0.1;\n        IOR = 1.5;\n        return vec3(0.086,0.486,0.831);\n    }\n\nreturn vec3(1.0, 0.0, 1.0);\n}\n\n//Color correction from Demofox\nvec3 LessThan(vec3 f, float value) {return vec3(lessThan(f, vec3(value)));}//Reccomended change by Dave_Hoskins\n \nvec3 LinearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n//used for procedural \"textures\"\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\n}\n\nfloat noise(const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat fbm(const in vec3 p, const in int octaves) {\n    float accum = 0.;\n    vec3 temp_p = p;\n    float weight = 1.;\n     \n    for (int i=0; i<octaves; i++) {\n        accum += weight * noise(temp_p);\n        weight *= .5;\n        temp_p *= 2.;\n    }\n    return abs(accum);\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n//Applies textures to SDF's\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n ) {\n    vec3 m = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x+m.y+m.z);\n}\n\n\n//SDF functions\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat SDFSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat SDFBox(vec3 point, vec3 size) {\n    vec3 d = abs(point) - size;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 Union(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat SmoothMin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 rotateZ( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\nvec3 rotateY( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//for non transparent materials\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident, float refl)\n{\n\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (refl + (1.0-refl) * ret);\n        return ret;\n\n}\n//for transparent materials\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0;\n    } \n    else { \n        float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\n\n\n", "buffer_a_code": "// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 POSITION = ivec2(1, 0);\n\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\n\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  WASD\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(), 0.0).xzy * 10.0;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, 0.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n\n    \n    position += (0.1 * target - position);\n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Camera and Keyboard input by glk7, from https://www.shadertoy.com/view/4lVXRm\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\nconst ivec2 VMOUSE = ivec2(1, 1);\n\nconst float PI = 3.141592;\n\nconst ivec2 POSITION = ivec2(1, 0);\n\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nvec3 SunPos = vec3(100, 100, 0);\nvec3 sunCol = 2.0*vec3(0.8, 0.7, 0.6);\n\nuint wang_hash(inout uint seed) {//random number generator(unsigned integer)\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {//random number generator(float)\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state, in vec3 nor) {//cosine hemisphere ray direction calculation when ray bounces off an object\n    float u = RandomFloat01(state);\n    float v = RandomFloat01(state) * c_twopi;\n   \n    \t// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n\nvec2 MapBoxes(vec3 rayPoint) {//organization: floor mapping function\n    float b = SDFBox(rayPoint - vec3(0,0.2,0), vec3(15, 1.1, 32));\n\n    vec2 scene = vec2(b,MATFLOOR);\n    return scene;\n}\n\nfloat MapSpheres(vec3 p) {//organization: sphere shape prefab\n    float a1 = SDFSphere(p, 1.0);\n    float a2 = sdTorus(p, vec2(1.0, 0.1));\n    p = rotateZ(p, 1.57);\n    float a3 = sdTorus(p, vec2(1.0, 0.1));\n    float a4 = SDFSphere(p - vec3(0,0,-1.25), 0.5);\n\n    float scene = max(min(a1,min(a2,a3)),-a4);\n    return scene;\n}\n\nvec2 MapLights(vec3 p) {//organization: light mapping function\n    float a = SDFSphere(p - vec3(0,6,3), 1.0);\n    vec2 ret = vec2(a, MATLIGHT);\n    return ret;\n}\n\nvec2 map(vec3 rayPoint, in float inside) {//main mapping function\n    rayPoint += vec3(0.0, 3.0, -2.0);\n        vec2 boxes = MapBoxes(rayPoint);\n        vec2 bronze = vec2(MapSpheres(rayPoint-vec3(0,3,3)),MATBRONZE);\n        vec2 chrome = vec2(MapSpheres(rayPoint-vec3(3,3,3)),MATCHROME);\n        float a = sdTorus(rayPoint - vec3(0,3,6), vec2(1.0, 0.3));\n        vec2 glass = vec2(min(MapSpheres(rayPoint-vec3(-3,3,3)),a),MATGLASS);\n        vec2 lights = MapLights(rayPoint);\n  \n    vec2 ret = boxes;\n    \n    ret = Union(ret, bronze);\n    ret = Union(ret, chrome);\n    ret = Union(ret, glass);\n    ret = Union(ret, lights);\n \n    if(ret.x < 0.0001) return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n    \n    \n    return (inside == 1.0) ? vec2(-ret.x, ret.y): ret;\n}\n\nvec3 calcNormal( in vec3 pos ) {//normals calculation\n    vec2 eps = vec2(0.0001,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy, 0.0).x - map( pos-eps.xyy, 0.0).x,\n      map( pos+eps.yxy, 0.0).x - map( pos-eps.yxy, 0.0).x,\n      map( pos+eps.yyx, 0.0).x - map( pos-eps.yyx, 0.0).x ) );\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, in float inside) {//normal sphere tracing function\n\tfloat res = -1.0;\n    float tmax = 100.0;\n    float t = 0.001;\n    for(int i = 0; i < 228; i++) {\n    \tfloat h = map(ro+rd*t, inside).x;\n        if((h<0.0001) || (t>tmax)) break;\n        t += h;\n    }\n    if(t<tmax) res = t;\n    \n    return res;\n    \n}\n\nfloat shadow( in vec3 ro, in vec3 rd ) {//used for god rays when in enclosed spaces\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t, 0.0).x;\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n//creates the procedural \"textures\", like the dirtyness of the bronze\nvoid texturing(in float matID, inout vec3 surfaceColor, inout float refl, inout float refr, inout float emmis, inout float IOR, in vec3 pos) {\n  float fbm10 = sin(fbm(pos,15));\n    if(matID == MATFLOOR) {\n        surfaceColor = mix(surfaceColor, vec3(0.475,0.255,0.106), sin(fbm(pos, 1))/3.0);\n    }\n          \n    if(matID == MATBRONZE) {\n        surfaceColor = mix(surfaceColor, vec3(0.000,0.000,0.000), sin(fbm(pos, 15)));\n        refl = min(0.9 - max(0.0,fbm10)/2.0,1.0);\n    }\n\n}\n\n\nvec3 calcFinalColor(vec3 ro, vec3 rd, inout uint rngState) {//main function\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 colorMask = vec3(1.0);\n    float fdis = 0.0;\n\n    float emmis, refl, refr, absorb = 0.0;//material properties initialization\n    float IOR = 1.0003;\n        \n    vec3 norm = vec3(0.0);\n    vec3 oro = ro;\n    vec3 ord = rd;\n    float rand = RandomFloat01(rngState);//initial random number generation\n    #ifdef sun\n     vec3 SunDir = normalize(SunPos - ro);\n    #endif\n\n    for(int bounce = 0; bounce < BOUNCECOUNT; bounce++) {\n\t\t#ifdef sun\n         SunDir = normalize(SunPos - ro);\n        #endif\n        rand = RandomFloat01(rngState);//random number generator\n        float preIOR = IOR;\n        float t = intersect(ro, rd, 0.0);\n        vec3 iColor = vec3(0.0);\n\n    \tif(bounce == 0) fdis = t;\n        vec3 pos = ro + rd*t;\n        vec3 surfaceColor = GetMatProps(map(pos, 0.0).y, refl, refr, emmis, IOR, absorb);//gets material color and properties\n\n        if( t < 0.0 ) {\n            #ifdef sun\n                colorMask *= sunCol;\n                iColor += max(pow(max(0.0, dot(rd, SunDir)), 10.0),0.0001) * (1.0 * sunCol) + 2.0 * accumulatedColor;\n                accumulatedColor += colorMask * iColor;//pow is to enhance the directionality of it, I wanted sharper shadows, so I did that\n            #else\n                colorMask *= texture(iChannel0, rd).xyz;\n                iColor += texture(iChannel0, rd).xyz+2.0*accumulatedColor;\n                accumulatedColor += iColor * colorMask * 0.5;\n            #endif\n            break;\n        }\n\n         norm = calcNormal(pos);\n\n        #ifdef textures\n         texturing(map(pos, 0.0).y, surfaceColor, refl, refr, emmis, IOR, pos);\n        #endif\n        if(refr == 1.0) {//if material is refractive\n            float eps = IOR;\n            if(t < 0.001) {//theory: if ray is already inside an object, use first calculation, else use second calculation\n                norm = -norm;         \n            }else {\n               eps = preIOR/eps;\n            }\n            \n            rd = (fresnel(rd, norm, preIOR/eps) > rand) ? reflect(rd, norm) : refract(rd, norm, eps);//Fresnel function located in common\n\n            t = intersect(pos, rd, 1.0);\n            pos += rd*t;\n                    \n            colorMask *= exp(-(surfaceColor*absorb) * t * t ); //coloring based on distance ray travels through transparent object\n        \n        }else { //else if material not refractive\n            colorMask *= surfaceColor;\n\n            //mix between reflective and diffuse ray directions\n            rd = mix( reflect(rd, norm), RandomUnitVector(rngState, norm), 1.0 - FresnelReflectAmount(1.003, IOR,rd, norm, refl));\n    \n              }\n\t\tro = pos;\n        iColor +=  (emmis * surfaceColor) + 2.0 * accumulatedColor * dot(norm, rd);//apply colors and emmisive materials\n        accumulatedColor += colorMask * iColor;//apply colors and emmissive to final color\n\n    }\n    //distance fog\n    float ff = exp(-0.001*fdis*fdis);\n    accumulatedColor *= ff; \n    accumulatedColor += (1.0-ff)*0.05*vec3(0.9,1.0,1.0);\n   \n   #ifdef sun\n       ff = exp(-0.1*fdis);\n\n       // volumetrics\n       float dt = 0.0;//change dt to increase fog, reccomended for enclosed spaces to make god rays\n       float acc = 0.0;\n       float t = fdis*rand;\n       vec3 pos = oro + ord*t;\n       acc += 5.0 * dt*shadow( pos, SunDir );//*exp(-0.25*t);\n       accumulatedColor += vec3(0.1)*pow(acc,2.0)*sunCol*0.4;\n    #endif\n    return accumulatedColor;\n}\n\n\n\n\nvoid Camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {//Camera function to make flying camera\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy/iResolution.x;\n    m.y = -m.y;\n    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3(((fragCoord) - iResolution.xy*0.5)*a, 0.5));\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    rd = (rotY * rotX) * rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;//anti-aliasing\n    \n    vec3 ro, rd, col = vec3(0.0);\n    Camera(fragCoord + jitter, ro, rd);\n    col = calcFinalColor(ro, rd, rngState);\n    \n    //reads from previous frame and blends the new frame into the old, and outputs that\n    vec4 lastFrameColor = texture( iChannel2, fragCoord/iResolution.xy );\n    float blend = (lastFrameColor.a == 0.0f || iMouse.z > 1.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    col = mix(lastFrameColor.rgb, col, blend);\n\n    \n    fragColor = vec4(col,blend);\n}", "buffer_b_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 547]], "test": "untested"}
{"id": "3tKczz", "name": "graph message: Peace & Love", "author": "FabriceNeyret2", "description": "WIP.\nref image:  [img]https://cdn.ebaumsworld.com/mediaFiles/picture/2183782/86526674.jpg[/img]\nby Ben Johnston [url]https://www.benjohnston.ca/exterior-murals[/url]\n\nok, it's not curvy, and it's full of bug. Maybe it would have been more easy in true 3D.", "tags": ["text", "graph", "isometric", "fake3d", "short", "reproduction"], "likes": 26, "viewed": 501, "published": 3, "date": "1610471399", "time_retrieved": "2024-07-30T19:45:32.504927", "image_code": "#define s(v)          smoothstep( 5./r.y, -5./r.y, v )                          // antialiasing\n#define R(V,y0,y1,d)  max( d+ abs(V.x) , abs( V.y - (y0+y1)/2. ) - (y1-y0)/2. ) // vertical rectangle\n\n                                                                            // slanted bar in false-3D\n#define v(U,X,y0,y1,Z) V =   s( T(U,X, y0,y1) )              \\\n                           + s( S(U,X, y0,y1) ) *vec2(.6,1)  \\\n                           + s( F(U,X, y0   ) ) *vec2(.3,1); \\\n                       C = vec3( V + (1.-V.y)*C.xy, V.y>.1 ? float(Z):C.z ) // return: vec3( col, mask, z )\n#define L(U,X,z)    v(U,X,-1.,1.,z)                                         // shortcut for long bars\n#define D(U,X,Y,z)  v(U,X,Y,Y,z)                                            // shortcut for dot bars\n\n#define T(U,X,y0,y1)                                                        /* top of bar   */ \\\n  ( V = ( U  - vec2(X,0) )         * mat2(1,-.3,0,1.12) ,  R(V,y0,y1,) -.12 )\n#define S(U,X,y0,y1)                                                        /* side of bar  */ \\\n  ( V = ( U - vec2(X+.145,-.11) )  * mat2(1,-.3,1.9,.55),  R(V,y0,y1,.056) -.12 )\n#define F(U,X,Y)                                                            /* front of bar */ \\\n  ( V = ( U -vec2(X+Y*.545,-.215)) * mat2(1,.3,0,1.12)  ,  R(V, Y, Y,) -.12 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 r = iResolution.xy,\n         U = 2.* ( 2.*u - r ) / r.y, V,      D = vec2(.03,.02)*cos(iTime+vec2(0,11));\n    vec3 C = vec3(0),_C;                                // C cumulates vec3( col, mask, z )\n    U += D;\n    L(U,-2.,0); D(U,-1.76, 0.,2); D(U,-1.76,1.,1); v(U,-1.52,0.,1.,2);                     // P\n    L(U,-1.,0); D(U,- .76,-1.,1); D(U,- .76,0.,1); D(U,- .76,1.,-1);                       // E\n    L(U, 0.,0); D(U, .24,  0.,2); D(U,  .24,1.,0); L(U,.48,2);                             // A\n    L(U, 1.,3); D(U, 1.24,-1.,4); D(U, 1.24,1.,4); v(U,1.48,-1.,-.4,5); v(U,1.48,.4,1.,5); // C\n    L(U, 2.,0); D(U, 2.24,-1.,1); D(U, 2.24,0.,1); D(U,2.24,1.,1);                         // E\n    O = C.xxxy * vec4(.4,.7,1,1);\n    _C=C;\n    U.x = .55-U.x; U.y-=.1; U += D; C-=C; mat2 M = mat2(cos(.1+vec4(0,11,33,0)));\n    D(U,-1.24,-1.,2); D(U,-1.24,0.,2); D(U,-1.24,1.,2); L(U,-1.,2);                        // E\n                               v(U*M, -.4,-.87,1.05,0); L(M*U, 0.,2);                      // V\n         L(U, .52,0); D(U, .76,-1.,1); D(U, .76, 1.,1); L(U, 1.,2);                        // O\n                                       D(U,1.76,-1.,2); L(U, 2.,2);                        // L\n    O = C.z > _C.z\n          ? O + (1.-O.a) *  C.xxxy * vec4(1,.4,.7,1)    // compose front to back or back to front \n          : C.xxxy * vec4(1,.4,.7,1) + (1.-C.y)*O;      // depending on relative z\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tKczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1333, 1333, 1371, 1371, 2784]], "test": "untested"}
{"id": "ttGyzh", "name": "GLSL/angle/chrome bug ", "author": "FabriceNeyret2", "description": "bottom half:\n    the correct result: 2 big red stripes + 7 smaller green stripes (2 appears yellow since on top of red).\ntop half: \n    on my ubuntu/nVidia/chrome  I only see 7 yellows stripes, while it's ok on FF.", "tags": ["glsl", "bug", "angle"], "likes": 0, "viewed": 338, "published": 3, "date": "1610445086", "time_retrieved": "2024-07-30T19:45:33.273871", "image_code": "  float a = 0.;           // bug \n  #define A 0.            // ok\n//#define A min(0.,iTime) // bug\n\n\n  #define r(a)    mat2( cos( a + vec4(0,-1.5708,1.5708,0) ) )   // bug\n//#define r(a)    mat2( cos(a), -sin(a), sin(a), cos(a) )       // no bug\n//#define r(a)    cos(a),sin(a))               // no bug ( vec instead of mat )\n//#define r(a)    cos(a+vec2(0,-1.5708))       // no bug ( vec instead of mat )\n\n\nvec2 c;\n#define f(U,a)  ( c = (U) * r(a) , sin(10.*c.x) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    \n    O = U.y > .5 \n          ? vec4( f(U,a) , f(U*4.,a) , 0,0)   // top\n          : vec4( f(U,A) , f(U*4.,A) , 0,0);  // bottom\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttGyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 467, 505, 505, 664]], "test": "untested"}
{"id": "Wt23WK", "name": "Oxygen Rich", "author": "Plento", "description": "On the surface of a lonely exo planet.", "tags": ["3d", "dunes"], "likes": 14, "viewed": 463, "published": 3, "date": "1610436362", "time_retrieved": "2024-07-30T19:45:34.034836", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define A(p) texture(iChannel0, p).x\nmat2 rot(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 ro = vec3(0., .44, 0.);\n    \n    rd.xy*=rot(.1);\n    rd.xz*=rot(iTime*.24+3.14159*.5);\n    ro.xz += 1.5*vec2(cos(iTime*.24), sin(iTime*.24));\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    vec3 p = vec3(0);\n    \n    for(int i = 0; i < 40; i++){\n        p = ro + rd*t;\n    \td = p.y - A(p.xz*.4)*.35; \n        \n        if(d < 0.001 || t > 100.) break;\n        t += d * .95;\n        ns++;\n    }\n    \n    vec3 rg = ss(8., 30., ns) * vec3(.9, .9, .8)*.8+A(vec2(uv.x, uv.y+iTime*.34))*.25;\n    vec3 sand = vec3(.8, .6, .4)+abs(sin(p.y*120.+cos(p.z+p.x)*23.))*.022;\n    sand += 1.-exp(-rg*.3);\n    vec3 sky = mix(vec3(.8, .9, .99), vec3(.1, .4, .99), abs(uv.y));\n    vec3 col = mix(sky, sand, exp(-t*t*t*.03));\n    \n    col = pow(col, vec3(2.55));\n    col = mix(1.-col, col, min(1., iTime*.55));\n    col *= ss(.384, .38, abs(uv.y));\n    \n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt23WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 139, 139, 185], [187, 187, 227, 227, 1172]], "test": "untested"}
{"id": "Wtycz1", "name": "Panner Cat", "author": "Syurli", "description": "panner cat : )", "tags": ["2d", "panner"], "likes": 1, "viewed": 254, "published": 3, "date": "1610432666", "time_retrieved": "2024-07-30T19:45:34.800788", "image_code": "float f_uv(float x, float time){\nfloat pi = 3.141592653589793238462643383279;  \n   if (sin(.5 * pi * (time + 1.)) < 0.) {\n      time = time * .5 * pi;\n   }\n   else {\n      time = time * .5 * pi + pi;\n   }\n   x = x + asin(sin(time)) / pi;\n   return x;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 speed = vec2 (-.3,0.);\n    //***************panner 1 :( ***************//\n    \n    //uv.x = f_uv(uv.x, iTime * speed.x);\n    //uv.y = f_uv(uv.y, iTime * speed.y);\n    \n    //***************panner 2 :3 ***************//\n    \n    //uv+=fract(iTime*speed);\n    \n    //***************panner 3 :) ***************//\n    \n      uv+=iTime*speed;\n    \n    // sample texture and output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtycz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 252], [253, 253, 310, 360, 837]], "test": "untested"}
{"id": "3tyczh", "name": "too many mushies", "author": "xenn", "description": "you'll be fine", "tags": ["particles", "ca"], "likes": 4, "viewed": 415, "published": 3, "date": "1610413457", "time_retrieved": "2024-07-30T19:45:35.762218", "image_code": "// Fork of \"polarising crystal candy\" by xenn. https://shadertoy.com/view/WlccDj\n// 2021-01-12 00:42:12\n\n// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2021-01-05 20:03:38\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.x);\n}\n\n#define FOV 010.293196\n#define RAD R.x*0.496797*10.0*abs(sin(iTime*0.1))\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 80.\n#define min_d 1.0\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-0.5 + 0.00361*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.7)*texture(iChannel3, c.xy).xyz;\n            float rough = .5 - .1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= .95*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 02.620\n\n\n#define sense_num 22\n#define sense_ang 0.02+0.2*(01.1*(cos(iTime*0.51)))\n//#define sense_dis 12.0*(010.51*cos(iTime*0.051))\n#define sense_dis 10.0*(10.0*(sin(iTime*0.04)))\n#define sense_oscil 0.051\n#define oscil_scale 0.325\n#define oscil_pow 01.\n#define sense_force 0.2\n#define distance_scale 0.9260*abs(1.50*(sin(iTime)))\n#define force_scale 0.50*(002.0*abs(sin(iTime)))\n#define trailing 0000.\n#define acceleration 0.029\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.093*rho.z\n#define fluid_rho 0.02\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 10.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n    //M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 271, 271, 449], [525, 525, 556, 556, 590], [592, 592, 644, 644, 763], [765, 765, 800, 800, 824], [826, 826, 857, 857, 944], [946, 946, 967, 967, 1060], [1062, 1062, 1084, 1084, 1180], [1183, 1183, 1203, 1203, 1398], [1401, 1401, 1436, 1436, 1621], [1661, 1661, 1693, 1693, 1861], [1863, 1863, 1908, 1908, 4700]], "test": "untested"}
{"id": "wlGyRz", "name": "some coll weird thingy", "author": "Angramme", "description": "f", "tags": ["noise"], "likes": 1, "viewed": 266, "published": 3, "date": "1610413267", "time_retrieved": "2024-07-30T19:45:36.524180", "image_code": "\nfloat noise(const vec2 C){\n    //vec2 diff = iMouse.xy-C;\n    vec2 c = C*1.2;\n    return .5+.25*sin(c.x*30.+c.y*6.+sin(iTime*.31+ c.x*7.+c.y*16.5)) \n            + .25*sin(c.y*27.+sin(iTime*.11+c.x*18.+c.y*12.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    const float eps = 0.0005;\n    vec3 N = normalize(vec3(\n        (vec2(noise(uv+vec2(eps, 0.)), noise(uv+vec2(0., eps))) -vec2(noise(uv)))/eps, 1.));\n    \n    //col += N;\n    col += (.8*(N)+.2*vec3(1))*(.3-.7*(dot(N, normalize(vec3(cos(iTime*.35), sin(iTime*.35), 1)))));\n    const float rd_pulse = 2.;\n    col.r *= .5+.5*sin(uv.x*2.-uv.y*1.2+iTime*rd_pulse);\n    \n    col *= vec3(1.5, 1.2, 1.7);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlGyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 58, 214], [216, 216, 273, 323, 885]], "test": "untested"}
{"id": "WtGczh", "name": "Gravitation Lensing", "author": "ich", "description": "routing the ray by sdf normal thus any shape can trivially impact on lensing although only spheres will be correctly evaluated. still interesting to mess around with different shapes. though code is ugly..", "tags": ["gravitationlenselensingraymarchblackhole"], "likes": 9, "viewed": 356, "published": 3, "date": "1610411391", "time_retrieved": "2024-07-30T19:45:37.308085", "image_code": "#define pi 3.141\n#define surf_dist .001\n#define max_steps  100\n#define max_dist 20.\n#define intensity .05\n\nmat3 look_at(vec3 d)\n{\n\tvec3 r = normalize(cross(vec3(0, 1, 0), d));\n\tvec3 u = normalize(cross(d, r));\n\treturn mat3(r, u, d);\n}\n\nmat2 rot(float a)\n{\n\treturn mat2(\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t);\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n\treturn -smin(-a, -b, k);\n}\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat roundcube(vec3 p, vec2 r)\n{\n\treturn length(max(abs(p) - (r.x - r.y), vec3(0))) - r.y;\n}\n\nfloat roundcube(vec3 p, vec4 r)\n{\n\treturn length(max(abs(p) - (r.xyz - r.w), vec3(0))) - r.w;\n}\n\nfloat cube(vec3 p, float r)\n{\n\treturn roundcube(p, vec2(r, .0));\n}\n\nfloat cube(vec3 p, vec3 r)\n{\n\treturn roundcube(p, vec4(r, 0));\n}\n\nfloat quickcube(vec3 p, float r)\n{\n\tp = abs(p);\n\treturn max(p.x, max(p.y, p.z)) - r;\n}\n\nfloat quickcube(vec3 p, vec3 r)\n{\n\tp = abs(p);\n\treturn max(p.x - r.x, max(p.y - r.y, p.z - r.z));\n}\n\nfloat plane(vec3 p, vec3 n, float r)\n{\n\treturn dot(p, n) - r;\n}\n\nstruct Line  {\n\tvec3 a;\n\tvec3 b;\n\tfloat r;\n};\n\nfloat line(vec3 p, Line l)\n{\n\tvec3 ab = l.b - l.a;\n\tvec3 ap = p - l.a;\n\tfloat h = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n\treturn length(ap - h * ab) - l.r;\n}\n\nfloat torus(vec3 p, vec2 r)\n{\n\tvec3 p0 = normalize(vec3(p.xy, 0)) * r.x;\n\treturn length(p0 - p) - r.y;\n}\n\nfloat onion(float d, float thickness)\n{\n\treturn abs(d + thickness) - thickness;\n}\n\nvec3 elongate(vec3 p, vec3 a, vec3 b)\n{\n\treturn max(min(p, a), p - b);\n}\n\nconst vec2 e = vec2(0, .001);\nconst vec3 ex = e.yxx;\nconst vec3 ey = e.xyx;\nconst vec3 ez = e.xxy;\n\nvec3 normal_(float l, float lx, float ly, float lz) {\n\treturn normalize(\n\t\tl - vec3(lx, ly, lz)\n\t);\n}\n\n// get signee distance of function f\n#define l_(f, p, a) \\\n\tf(p, a)\n\n// get normal of function f\n#define n_(f, l, p, a) \\\n\tnormal_(l, f(p - ex, a), f(p - ey, a), f(p - ez, a))\n\n// get normal and signed distance of function f\n#define nl_(f, l, n, p, a) \\\n\tl = f(p, a); \\\n\tn = n_(f, l, p, a)\n\nvoid min_(inout float lo, inout vec3 g, in float l, in vec3 n) {\n\tg -= n / l;\n\tlo = min(lo, l);\n}\n\nfloat scene_(vec3 p, out vec3 g) {\n\tfloat l = max_dist;\n\tg = vec3(0);\n\n\tfloat s0l; vec3 s0n;\n\tnl_(sphere, s0l, s0n, p, .1);\n\n\t/* float l0l; vec3 l0n; */\n\t/* nl_(line, l0l, l0n, p, Line(vec3(0, 0, 3), vec3(0, 0, -3), .1)); */\n\n\tl = min(l, sphere(p - vec3(1, 1, 1), .5));\n    l = min(l, roundcube(p - vec3(-1, 1, 1), vec2(.5, .1)));\n    \n\t/* l = min(l, line(p, Line(vec3(1, 0, 3), vec3(1, 0, -3), .1 ))); */\n\tl = min(l, max(\n        quickcube(sin(p * 5.), vec3(.99)) / 5.,\n        quickcube(p - vec3(0, -2., 0), vec3(3, .2, 3))\n    ));\n\t//l = min(l, sphere(p - vec3(-1, -.5, -1), .5));\n\n\tmin_(l, g, s0l, s0n);\n\t/* min_(l, g, l0l, l0n); */\n\n\treturn l;\n}\n\nfloat scene(vec3 p) {\n\tfloat l = max_dist;\n\n\tvec3 d = vec3(0);\n    \n\tl = min(l, sphere(p, .1));\n    \n\tl = min(l, sphere(p - vec3(1, 1, 1), .5));\n    l = min(l, roundcube(p - vec3(-1, 1, 1), vec2(.5, .1)));\n    \n\t/* l = min(l, line(p, Line(vec3(0, 0, 3), vec3(0, 0, -3), .1 ))); */\n\tl = min(l, max(\n        quickcube(sin(p * 5.), vec3(.99)) / 5.,\n        quickcube(p - vec3(0, -2., 0), vec3(3, .2, 3))\n    ));\n\t//l = min(l, sphere(p - vec3(-1, -.5, -1), .5));\n\n\treturn l;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat l = scene(p);\n\tvec2 e = vec2(0, .001);\n\n\treturn normalize(\n\t\tl - vec3(\n\t\t\tscene(p - e.yxx),\n\t\t\tscene(p - e.xyx),\n\t\t\tscene(p - e.xxy)\n\t\t)\n\t);\n}\n\nbool march(vec3 ro, inout vec3 rd, out vec3 p, out float steps) {\n\tp = ro;\n\tfloat lo = .0;\n\n\tfor (int i = 0; i < max_steps && lo < max_dist; ++i) {\n\t\tvec3 g;\n\t\tfloat l = scene_(p, g);\n\t\tl = min(l, .5);\n\t\tlo += l;\n\t\trd += l * g * (intensity + intensity * .5 * (sin(iTime * .4) * .5 + .5));\n\t\t/* rd = normalize(rd); */\n\t\tp += l * normalize(rd);\n\t\tsteps = 1. - float(i) / float(max_steps);\n\n\t\tif (l < surf_dist)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n\tvec2 uv = (frag_coord - iResolution.xy * .5) / iResolution.y;\n    vec2 m = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    vec3 c = vec3(0);\n\n\tvec2 m2 = m * pi;\n\tvec3 ro = vec3(sin(m2.x) * cos(m2.y), sin(m2.y), cos(m2.x) * cos(m2.y)) * -1.;\n\tvec3 rd = look_at(normalize(-ro)) * normalize(vec3(uv, .5));\n\n\tvec3 p;\n\tfloat steps;\n\tif (march(ro, rd, p, steps)) {\n\t\trd = normalize(rd);\n\t\tvec3 n = normal(p);\n\t\tc.r += 1.;\n\t\tc.g += .5 + .5 * pow(dot(-rd, n), 3.);\n\n\t\tc *= smoothstep(1., 0., length(ro - p) / max_dist);\n\t} else {\n        c = texture(iChannel0, rd).rgb;\n    }\n\t/* c.b += 1. - floor(steps * steps * 10.) / 10.; */\n\n\tfrag_color = vec4(c, 1);\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtGczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 129, 129, 234], [236, 236, 255, 255, 311], [313, 313, 352, 352, 439], [441, 441, 480, 480, 508], [510, 510, 541, 541, 566], [568, 568, 601, 601, 661], [663, 663, 696, 696, 758], [760, 760, 789, 789, 826], [828, 828, 856, 856, 892], [894, 894, 928, 928, 980], [982, 982, 1015, 1015, 1081], [1083, 1083, 1121, 1121, 1146], [1195, 1195, 1223, 1223, 1355], [1357, 1357, 1386, 1386, 1461], [1463, 1463, 1502, 1502, 1544], [1546, 1546, 1585, 1585, 1618], [1720, 1720, 1773, 1773, 1821], [2114, 2114, 2178, 2178, 2211], [2213, 2213, 2247, 2247, 2863], [2865, 2865, 2886, 2886, 3337], [3339, 3339, 3360, 3360, 3510], [3512, 3512, 3577, 3577, 3957], [3959, 3959, 4016, 4016, 4674]], "test": "untested"}
{"id": "3tGyzh", "name": "squishy noise", "author": "fraser", "description": "it squirms.\n\npretty basic domain-distortion type stuff", "tags": ["noise", "cineshader"], "likes": 15, "viewed": 10015, "published": 3, "date": "1610411194", "time_retrieved": "2024-07-30T19:45:38.104954", "image_code": "//<3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n//</3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nfloat fbm(vec2 xy, float z, int octs){\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    float a_bound = 0.0;\n    for(int i=0;i<octs;i++){\n        t += a*simplex3d(vec3(xy*f,z*f));\n        f *= 2.0;\n        a_bound += a;\n        a *= 0.5;\n    }\n    return t/a_bound;\n}\nfloat noise_final_comp(vec2 xy, float z){\n    float value = fbm(vec2(xy.x / 200.0+513.0, xy.y / 200.0+124.0), z, 3);\n    value = 1.0-abs(value);\n    value = value*value;\n    return value*2.0-1.0;\n}\nfloat noise_final(vec2 xy, float z){\n        float value = fbm(vec2((noise_final_comp(xy, z)*15.0+xy.x) / 100.0,(noise_final_comp(xy+300.0, z)*15.0+xy.y) / 100.0), z*1.5, 5);\n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord*500.0/iResolution.x;\n\n    float p = noise_final(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n    p*=clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0);\n    fragColor = vec4(p,p,p,p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tGyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 90, 90, 263], [370, 393, 418, 669, 1569], [1570, 1639, 1677, 1677, 1918], [1919, 1919, 1960, 1960, 2116], [2117, 2117, 2153, 2153, 2349], [2350, 2350, 2405, 2405, 2772]], "test": "untested"}
{"id": "WlGyzh", "name": "Triangle Interp. - Barycentric", "author": "oneshade", "description": "Much more interesting version of my old triangle rasterizer shader.", "tags": ["triangle", "barycentric", "interpolation", "barycoords"], "likes": 4, "viewed": 218, "published": 3, "date": "1610411027", "time_retrieved": "2024-07-30T19:45:38.877887", "image_code": "struct Vertex {\n    vec2 pos;\n    vec3 col;\n    vec2 uv;\n};\n\nvec3 barycoords(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    return vec3(bcp, cap, abp) / abc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 5.0 / iResolution.y;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.5;\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 aspMult = vec2(iResolution.x / iResolution.y, 1.0) * 0.5;\n    Vertex a = Vertex(vec2(s1, c2) * aspMult, vec3(1.0, 0.0, 0.0), vec2(0.0, 0.0));\n    Vertex b = Vertex(vec2(c2, s3) * aspMult, vec3(0.0, 1.0, 0.0), vec2(0.5, 1.0));\n    Vertex c = Vertex(vec2(c3, s1) * aspMult, vec3(0.0, 0.0, 1.0), vec2(1.0, 0.0));\n\n    vec3 uvw = barycoords(uv, a.pos, b.pos, c.pos);\n    fragColor.rgb += texture(iChannel0, a.uv * uvw.x + b.uv * uvw.y + c.uv * uvw.z).rgb;\n    fragColor.rgb *= a.col * uvw.x + b.col * uvw.y + c.col * uvw.z;\n    fragColor.rgb *= smoothstep(1.0 + unit, 1.0 - unit, uvw.x + uvw.y + uvw.z) * 2.0;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 122, 122, 446], [448, 448, 503, 503, 1441]], "test": "untested"}
{"id": "tlVcRz", "name": "maxnorm sin/cos", "author": "paniq", "description": "Linf sin/cos functions for variable radii that are compatible with integer arithmetic", "tags": ["sin", "cos", "maxnorm"], "likes": 9, "viewed": 491, "published": 3, "date": "1610397941", "time_retrieved": "2024-07-30T19:45:39.960992", "image_code": "// uncomment to show single rotation\n#define DO_GALAXY\n\n//////////////////////////////////////////////////////////\n\nfloat Linf_cos(float x, float r) {\n    return clamp(abs(mod(abs(x),8.0*r) - 4.0*r)-2.0*r,-r,r);\n}\n\nfloat Linf_sin(float x, float r) {\n    return Linf_cos(x - 2.0*r, r);\n}\n\nvoid paint() {\n    float t = iTime;\n\n    scale(0.01);\n\n    set_source_rgb(0.0, 0.0, 0.0);\n    clear();\n\n    set_line_width_px(1.0);\n    set_source_rgb(vec3(0.25));\n    for (int i = 1; i < 100; ++i) {\n        float r = float(i);\n        rectangle(-r,-r,2.0*r,2.0*r);\n        stroke();\n    }\n\n    // transformed glowing triangle\n    float a = iTime * 10.0;\n    for (int i = 1; i < 100; ++i) {\n        float r = float(i);\n        set_line_width_px(1.0);\n        set_source_rgb(hsl(a/(8.0*r), 1.0, 0.7));\n        circle(Linf_cos(a,r), Linf_sin(a,r), 0.7);\n        // three more\n        #ifdef DO_GALAXY\n        circle(-Linf_cos(a,r), -Linf_sin(a,r), 0.7);\n        circle(Linf_sin(-a,r), Linf_cos(-a,r), 0.7);\n        circle(-Linf_sin(-a,r), -Linf_cos(-a,r), 0.7);\n        #endif\n        fill_preserve();\n        set_blur(0.03);\n        premultiply_alpha(true);\n        set_source_rgba(vec4(hsl(a/(8.0*r), 1.0, 0.5)*0.2,0.0));\n        fill();\n        premultiply_alpha(false);\n        set_blur(0.0);\n    }\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 116, 150, 150, 213], [215, 215, 249, 249, 286], [288, 288, 302, 302, 1290], [1352, 1352, 1409, 1409, 1495]], "test": "untested"}
{"id": "wtVcRz", "name": "No output", "author": "mrmola", "description": "Weird bug I noticed when you have no output and some sort of texture. No idea why this happens or what causes it, could anyone enlighten me? On ubuntu firefox 76 I see a weird pattern if the texture is changed while it is paused.", "tags": ["bug"], "likes": 1, "viewed": 254, "published": 3, "date": "1610397659", "time_retrieved": "2024-07-30T19:45:40.727941", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 60]], "test": "untested"}
{"id": "wlVczR", "name": "Bokeh / Blur", "author": "Ric3cir121", "description": "Simple working bokeh", "tags": ["raytracing", "blur", "bokeh"], "likes": 0, "viewed": 371, "published": 3, "date": "1610392813", "time_retrieved": "2024-07-30T19:45:41.568693", "image_code": "#define T(u) texelFetch(iChannel0,clamp(ivec2(u),ivec2(0),ivec2(iResolution.xy)-1),0)\n\nvoid mainImage(out vec4 o,vec2 u){\n    float max = 1000.,\n          bokeh = .005,\n          focus_dist = 5.,\n\n    d = bokeh * (clamp(T(u).w,.0,max)-focus_dist) * iResolution.y;\n    o = vec4(0);\n    float s = 10.,a,n = 0.;\n    for(float r = 0.; r < 1.; r+=1./s){\n        for(float i = 0.; i < 1.; i+=1./(s*r),n++){\n            a = i*radians(360.);\n            vec2 s = vec2(cos(a),sin(a))*r;\n            o += clamp(T(u+s*d),0.,1.);\n        }\n    }\n    o /= n;\n    o = pow(o,vec4(1./2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct obj{\n    float d;\n    vec3 col;\n    int ref;\n};\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n#define hash13(a) fract(sin(a*vec3(1.239,5.283,2.294))*1000000.)\n#define mn(a,b) obj((a.d>b.d?b.d:a.d),(a.d>b.d?b.col:a.col),(a.d>b.d?b.ref:a.ref))\n#define mx(a,b) obj((a.d<-b.d?-b.d:a.d),(a.col),(a.ref))\n#define sphere(a,b,c,d,e) obj(length(a-b)-c/2.,d,e)\n#define cube(a,b,c,d,e,f) obj(length(clamp(a,b-(c-d)/2.,b+(c-d)/2.)-a)-d/2.,e,f)\n#define plane(a,b,c,d) obj(a.y-b.y,c,d)\nobj de(vec3 pos){\n    obj res = obj(10000.,vec3(0),0);\n    res = mn(res,sphere(pos,vec3(0 , -1,-.5),1.    ,vec3(.9,.5,.5),1));\n    res = mn(res,  cube(pos,vec3(-1,-.5,-1 ),1. ,.3,vec3(.9,.5,.9),0));\n    res = mx(res, plane(pos,vec3(0 ,-.99,0 )       ,vec3(.9,.9,.9),2));\n    res = mn(res, plane(pos,vec3(0 , -1, 0 )       ,vec3(.9,.9,.9),2));\n    res = mx(res,  cube(pos,vec3(0 ,-1. ,.5),2. ,1.,vec3(.9,.5,.9),1));\n    res = mn(res,sphere(pos,vec3(.3,  0, 1 ),1.    ,vec3(.5,.5,.9),2));\n    return res;\n}\nvec3 getmarch(vec3 pos,vec3 cam,bool rev){\n    float r = rev?-1.:1.;\n    float d = 9.;\n    vec3 mov = vec3(0);\n    for(int i = 0;i < 1000;i++){\n        d = de(mov+pos).d*r;\n        mov += d*cam;\n        if(length(mov)>100.||d<0.0001)break;\n    }\n    return mov+pos;\n}\nvec3 getcolor(vec3 pos){return de(pos).d>0.01?vec3(1):de(pos).col;}\nvec3 getnormal(vec3 pos){\n    vec2 e = vec2(1,-1)*0.0001;\n    return normalize(e.xyy*de(pos+e.xyy).d+e.yyx*de(pos+e.yyx).d+e.yxy*de(pos+e.yxy).d+e.xxx*de(pos+e.xxx).d);\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = (u+hash13(iTime).xy-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(3,3,-3);\n    vec2 look = vec2(-.7,.7);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    vec3 norm, col = vec3(1),oldmarch;\n    bool rev = false;\n    vec3 march = getmarch(pos,cam,false);\n    float blur = length(march-pos);\n    for(int i = 0;i < 100;i++){\n        norm = getnormal(march);\n        col *= getcolor(march);\n        if(de(march).d>0.0001)break;\n        if(de(march).ref==1){\n            cam = reflect(cam,norm);\n            march += norm*0.01;\n        }else if(de(march).ref==0){\n            if(!rev)cam = normalize(mix(cam,-norm,0.1));\n            rev = !rev;\n            march+= cam*0.01;\n        }else{\n            cam = normalize(reflect(cam,norm)+(hash13(fract(dot(norm,cam)*iTime))-.5)*0.5);\n            march += norm*0.01;\n        }\n        oldmarch = march;\n        march = getmarch(march,cam,rev);\n        if(rev)col /= pow(length(march-oldmarch),3.)*20.+1.;\n    }\n    col *= getcolor(march);\n\n    o = vec4(col,blur);\n    if(u.x<iResolution.x/2.)o = mix(o,texelFetch(iChannel0,ivec2(u),0),1.-1./(texelFetch(iChannel1,ivec2(0),0).x+1.));\n    else o = mix(o,texelFetch(iChannel0,ivec2(u),0),1.-1./(texelFetch(iChannel1,ivec2(1,0),0).x+1.));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 o,vec2 u){\n    if(floor(u)==vec2(0,0)){\n        o = texelFetch(iChannel0,ivec2(0),0)+1.;\n        if(iMouse.z>0.)o = vec4(1);\n    }\n    if(floor(u)==vec2(1,0)){\n        o = texelFetch(iChannel0,ivec2(1,0),0)+1.;\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 121, 121, 576]], "test": "untested"}
{"id": "WlVczz", "name": "refraction, reflection, Fresnel", "author": "FabriceNeyret2", "description": "show use of GLSL reflect and refract, and Fresnel reflection coefficient ( right: Schlick's approximation . Note the trap ).\nIncident (white, mouse control), reflected (green), refracted(blue).\nYellow: reflectance (Fresnel term). Purple: transmittance.\n", "tags": ["reflection", "refraction", "fresnel", "tuto"], "likes": 6, "viewed": 450, "published": 3, "date": "1610376624", "time_retrieved": "2024-07-30T19:45:42.333648", "image_code": "    float ior = 1.3;                        // index of refraction in material\n#define IOR(D) ( -D.y<0. ? ior : 1./ior )\n\n#define R iResolution.xy\n#define S(v) smoothstep( 1.5*pix, 0., v)\nfloat pix;\n\n                                           // see Fresnel graphs on https://www.desmos.com/calculator/td8zfxrrve\n#define FresnelSch(D,N,e)( e<1. ? fresnelSch(D,N,e) : fresnelSch(refract(D,N,e),N,e) )\n#define fresnelSch(D,N,e)  mix( pow( max(0.,1.-dot(-(D),N)), 5.), 1. , SQR((1.-(e))/(1.+(e))) )  // Schlick's approximation https://en.wikipedia.org/wiki/Schlick%27s_approximation\n//                                   or use C = sqrt(1.-max(1.,i)sin() ) instead of dot\n#define SQR(x)         (x)*(x)\n\nfloat FresnelA(vec2 D, vec2 N, float i) {  // Analytical effective reflectance https://en.wikipedia.org/wiki/Fresnel_equations#Power_(intensity)_reflection_and_transmission_coefficients\n    float c = dot(-D,N),\n          s = sqrt(1.-c*c),\n    v = sqrt( max(0., 1.-(i*i)*(1.-c*c) )),\n    rs = ( i*c - v ) / ( i*c + v ),\n    rp = ( i*v - c ) / ( i*v + c );\n    return ( rs*rs + rp*rp ) /2.;\n}\n#define Fresnel(D,N,e) ( -D.x < 0. ? FresnelA(D,N,e) : FresnelSch(D,N,e) )\n\nfloat line(vec2 p, vec2 a,vec2 b) {        // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return S(length(p - b * h));\n}\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = ( 2.*u - R ) / R.y, N = vec2(0,1), D, T,\n         M = iMouse.xy;\n    M = length(M)<10. ? cos(iTime+vec2(0,11)) :  ( 2.*M - R ) / R.y;   \n    pix = 2./R.y;\n    \n    N = vec2(0,sign(M.y));                           // --- Descartes scheme\n // O = vec4( U.y < 0. )*.5;                         // material\n    pix *= 3.;\n    O.r += line(U, vec2(0), N);                      // red: normal\n    O   += line(U, vec2(0), M);                      // white: incident ray\n    D = normalize(-M);                               // ray direction\n    O.g += line(U, vec2(0),  reflect( D,N ) );       // green: reflected ray\n    O.b += line(U, vec2(0),T=refract( D,N,IOR(D)) ); // blue: reflected ray\n    if (T==vec2(0)) O.b = O.g;                       // cyan: total internal reflection\n    \n    N = vec2(0,sign(U.y));                           //  --- Fresnel Diagram\n    D = -normalize(U);\n    float f = Fresnel(D,N,IOR(D)),                   // fresnel term\n          l = length(U);\n    pix = 1.;\n    O.rg += .5* S( abs(f-l) / fwidth(f-l) );         // reflectance in direction U\n    f = 1.-f;\n    O.rb += .5* S( abs(f-l) / fwidth(f-l) );         // transmittance in direction U\n       // * ( N = U-.5*N, .5+.5*sin(60.*atan(N.y,N.x))); // dash\n  // O[U.y>0.?1:2] =  \n    if (U.y<0.) O += ( 1.-max(O.r,max(O.g,O.b)) ) *.5;   // material\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlVczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[704, 704, 745, 889, 1094], [1171, 1171, 1206, 1254, 1361], [1364, 1364, 1402, 1402, 2741]], "test": "untested"}
{"id": "ttKyRR", "name": "Day 391", "author": "jeyko", "description": "Silktato", "tags": ["silk", "mdtmjvm"], "likes": 21, "viewed": 676, "published": 3, "date": "1610374496", "time_retrieved": "2024-07-30T19:45:43.288096", "image_code": "\n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n// cyclic noise from nimitz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(1.05,1.,0.9 + dot(uv,uv)*0.05));\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.4,0.9,1.)*1.1),0.25);\n    \n    col *= 1.3;\n    col = mix(acesFilm(col), col, 0.);\n    \n    \n    col = mix(col,col*col*0.4,dot(uv,uv));\n    //col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n// cyclic noise from nimitz\n\nvoid mainImagea( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(1.05,1.,0.9 + dot(uv,uv)*0.05));\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.4,0.9,1.)*1.1),0.25);\n    \n    col *= 1.3;\n    col = mix(col,smoothstep(0.,1.,col*1.1),0.35);\n    \n    col = mix(acesFilm(col), col, 0.2);\n    \n    \n    col = mix(col,col*col*0.4,dot(uv,uv));\n    //col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\nvec2 dmin(vec2 d, vec2 b){return d.x < b.x ? d : b;}\n\nfloat wallNoise = 0.;\nfloat wallNoiseB = 0.;\n\nfloat T = 0.;\nfloat tid = 0.;\n\n\n\nvec3 uvJello = vec3(0);\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nvec2 sdSilk(vec3 p){\n    p.x += 0.;\n    \n    float wall = -p.z;\n\n    float n = cyclicNoise( p*vec3(0.6,1,1), iTime);\n    \n    \n    float d = 10e5;\n    if(iMouse.z > 0.){\n        p.xy -= gmuv.xy*5.; \n        d = length(p) - 1.6;\n    }\n    \n    \n    d = opSmoothUnion( d, wall, .9 );\n    \n    d -= n*1.6;\n\n    return vec2(d, ID_SILK);\n}\n\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    //vec2 dwall = sdWall(p); \n    vec2 dsilk = sdSilk(p);\n\n    d = dmin(d, dsilk);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.4;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*precis).x;\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    T = iTime*.35 + texture(iChannel0,fragCoord.xy/8.).x/100.;\n   \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy)/iResolution.xy;\n    \n    gmuv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    \n    muv = muv*2. - 1.;\n    if (muv.x < -0.85){\n        muv -= muv;\n    }\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 1.;    \n    ro *= 1.9;\n    \n    \n    vec3 lookAt = vec3(0);\n    \n    //lookAt.z += muv.x*0.3;\n    lookAt.y += muv.y;\n    \n    \n    vec3 rd = getRd(ro, lookAt, uv, 5.);\n    \n    ro -= rd*6.;\n    \n    vec3 col = vec3(0);\n    \n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    \n    vec3 atten = vec3(1.);\n    \n    \n    vec3 hitCol = vec3(0);\n    \n    int maxIters = 250;\n    \n    \n    vec3 reflalbedo = mix(ambientCol, lightCol,0.5);\n    for(int i = 0; i < maxIters; i++){\n\n        p = ro + rd*(t += d.x*stepSz);\n        d = map(p);\n\n        if(d.x < eps){\n            hit = true;\n            break;\n        }\n\n    }\n\n    \n    vec3 n = getNormal(p,eps*0.5);\n                    \n    {\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.6))*a).x/a, 0., 1.)\n        #define SSS(n,a) clamp( 1.*map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        float aoo = AO(n,0.5);\n        float ao = aoo*AO(n,0.2)*AO(n,0.04)*AO(n,1.54)*1.;\n        \n        float SSS = SSS(vec3(-1.,.5,0.9),1.9)*1.*SSS(vec3(-4.,2.,0.2),5.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n\n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        \n        float shad = softshadow( p, lDir, 0.01, 20., 2.);\n        \n        shad = min(shad,diff);\n        \n        vec3 colSilk = vec3(0);\n        {\n            map(p);\n            albedo = silkCol;\n            \n            albedo -= albedo;\n            \n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(n*2.)*0.5 + 0.5),4.)/sqrt(49.); \n            float factb = pow(length(sin(r*2. + n*2. + 4. + iTime*0.)*0.5 + 0.5),1.)/sqrt(3.); \n            float factc = pow(length(sin(r*5. + n*2. + 4. + iTime*0.)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            albedo += mix( silkCol, vec3(0) + ambientCol*0.3 + silkCol*silkCol*silkCol*0.15,factb);;\n            albedo = mix( albedo, vec3(0) + ambientCol*0.1 + silkCol*silkCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += lightCol*8.*(1.-pow(factb,.03));\n            \n            //albedo = mix(lightCol*8.,albedo*0.,pow(factb,.03));;\n            \n            //albedo = mix(albedo,sssSilkCol,SSS);\n            \n            //colSilk = albedo;\n            colSilk = albedo*lightCol;\n\n            //colSilk = mix(colSilk, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colSilk = mix((colSilk + colSilk*ambientCol)*0.5, colSilk, ao);\n            colSilk = mix((colSilk + colSilk*ambientCol)*0.5,colSilk, shad);\n            \n            \n        }\n        hitCol += colSilk*float(floor(d.y) == ID_SILK);\n\n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    }\n    \n    if(hit)\n        col += hitCol*atten;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat FXAAamt = 1.;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ID_SILK 1.\n\n#define stepSz 0.4\n#define eps 0.0006\n\n#define ambientCol vec3(0.5,0.5,0.5)\n#define lightCol vec3(0.9,0.8,0.8)*1.\n#define lDir normalize(vec3(-4.5,1,-1.))\n#define silkCol vec3(0.24,0.15,0.14)*5.\n#define sssSilkCol vec3(0.9,0.3,0.3)*0.\n\n\n#define pi acos(-1.)\n\n\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec2 gmuv;\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    ro += right*uv.x*sc;\n    ro += up*uv.y*sc;\n    return dir;\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p, float time){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.55;\n    const float lacunarity = 1.4;\n    const int octaves = 4;\n    \n    \n    \n    \n    const float warp = 0.45;    \n    float warpTrk = 1.4 ;\n    const float warpTrkGain = 1.25;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin((p.zxy + vec3(-sin(time)*0.1,time*0.25,time*0.4))*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n            \n        //noise += sin(dot(cos(p), sin(p.zyx)))*amp;\n        \n        float f = sin(dot(cos(p), sin(p.zyx)));\n        //f = sign(f)*pow(abs(f),1.);\n        noise += f*amp;\n        \n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return (noise*0.25 + 0.5);\n\n    //return 1. - abs(noise)*0.5;\n}\n\n\nfloat cyclicNoiseB(vec3 p, float time){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.2;\n    const int octaves = 2;\n    \n    const float warp = .45;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttKyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 144, 144, 663], [752, 752, 810, 810, 1386]], "test": "untested"}
{"id": "tdGBWD", "name": "texture upscaler", "author": "Ric3cir121", "description": "simple AI that upscale images", "tags": ["upscale"], "likes": 7, "viewed": 531, "published": 3, "date": "1610370007", "time_retrieved": "2024-07-30T19:45:44.146800", "image_code": "#define smoothstep(a,b,c) mix(a,b,((sin(clamp(c,0.,1.)*2.-1.)+1.)/2.))\n\nvec4 rog(vec2 u){\n    vec4 _00 = texture(iChannel0,((floor(u+vec2(-1,-1))+0.5)/iChannelResolution[0].xy));\n    vec4 _01 = texture(iChannel0,((floor(u+vec2(-1, 0))+0.5)/iChannelResolution[0].xy));\n    vec4 _02 = texture(iChannel0,((floor(u+vec2(-1, 1))+0.5)/iChannelResolution[0].xy));\n    vec4 _10 = texture(iChannel0,((floor(u+vec2( 0,-1))+0.5)/iChannelResolution[0].xy));\n    vec4 _11 = texture(iChannel0,((floor(u+vec2( 0, 0))+0.5)/iChannelResolution[0].xy));\n    vec4 _12 = texture(iChannel0,((floor(u+vec2( 0, 1))+0.5)/iChannelResolution[0].xy));\n    vec4 _20 = texture(iChannel0,((floor(u+vec2( 1,-1))+0.5)/iChannelResolution[0].xy));\n    vec4 _21 = texture(iChannel0,((floor(u+vec2( 1, 0))+0.5)/iChannelResolution[0].xy));\n    vec4 _22 = texture(iChannel0,((floor(u+vec2( 1, 1))+0.5)/iChannelResolution[0].xy));\n    \n    vec2 fr = fract(u);\n    \n    vec4 real = texture(iChannel0,(u/iChannelResolution[0].xy));\n    \n    vec4 l00 = abs(real-_00);float d00 = (l00.x+l00.y+l00.z)/3.;\n    vec4 l01 = abs(real-_01);float d01 = (l01.x+l01.y+l01.z)/3.;\n    vec4 l02 = abs(real-_02);float d02 = (l02.x+l02.y+l02.z)/3.;\n    vec4 l10 = abs(real-_10);float d10 = (l10.x+l10.y+l10.z)/3.;\n    vec4 l11 = abs(real-_11);float d11 = (l11.x+l11.y+l11.z)/3.;\n    vec4 l12 = abs(real-_12);float d12 = (l12.x+l12.y+l12.z)/3.;\n    vec4 l20 = abs(real-_20);float d20 = (l20.x+l20.y+l20.z)/3.;\n    vec4 l21 = abs(real-_21);float d21 = (l21.x+l21.y+l21.z)/3.;\n    vec4 l22 = abs(real-_22);float d22 = (l22.x+l22.y+l22.z)/3.;\n\n    float fmin = min(d00,min(d01,min(d02,min(d10,min(d11,min(d12,min(d20,min(d21,d22))))))));\n    \n    vec4 color = d00==fmin?_00:(d01==fmin?_01:(d02==fmin?_02:(\n    \t\t\td10==fmin?_10:(d11==fmin?_11:(d12==fmin?_12:(\n                d20==fmin?_20:(d21==fmin?_21:_22)))))));\n    \n    return color;\n}\n\nvec4 lins(sampler2D h,vec2 c){\n    return texelFetch(h,ivec2(c),0);\n}\n\nvec4 linr(sampler2D h,vec2 c){\n    c-=.5;\n    vec4 _0 = smoothstep(texelFetch(iChannel0,ivec2(c),0),texelFetch(iChannel0,ivec2(c)+ivec2(1,0),0),fract(c.x));\n    vec4 _1 = smoothstep(texelFetch(iChannel0,ivec2(c)+ivec2(0,1),0),texelFetch(iChannel0,ivec2(c)+ivec2(1,1),0),fract(c.x));\n    \n    return smoothstep(_0,_1,fract(c.y));\n}\n\nvec4 neural(vec2 u){\n    float s = 5.;\n    vec2 c = u/s;\n    vec4 _n = texelFetch(iChannel0,ivec2(c),0);\n    vec4 _c = linr(iChannel0,c);\n    vec4 _u = lins(iChannel0,c+vec2(0,1));\n    vec4 _d = lins(iChannel0,c+vec2(0,-1));\n    vec4 _l = lins(iChannel0,c+vec2(-1,0));\n    vec4 _r = lins(iChannel0,c+vec2(1,0));\n    \n    vec4 _o = (_u+_d+_l+_r)/4.;\n    vec4 dif = abs(_n-_o);\n    //return dif;\n    \n    float mn = .1;\n    return mix(_c,rog(c),clamp(( dif-mn)*10000.,0.,1.));\n}\n\nvoid mn(out vec4 o,vec2 u){\n    vec2 uv = u/iResolution.xy;\n\n\n    o = neural(u);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    vec4 Fr = vec4(0.);\n\tint a = 1;\n    for(int i1 = 0;i1<a;i1++){\n    \tfor(int i2 = 0;i2<a;i2++){\n    \t\tmn(Fr,fragCoord+(vec2(float(i1),float(i2))/(float(a))));\n            fragColor += Fr;\n    \t}\n    }\n    fragColor /= float(a*a);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 89, 89, 1877], [1879, 1879, 1909, 1909, 1948], [1950, 1950, 1980, 1980, 2280], [2282, 2282, 2302, 2302, 2758], [2760, 2760, 2787, 2787, 2842]], "test": "untested"}
{"id": "3lVcRz", "name": "strange GLSL bug (on OpenGL)", "author": "FabriceNeyret2", "description": "Bug: the grey background on right half should not be there, and disappear at the least code change.\n( maybe Mat M play a crucial role. not sure ).\nCompilation is suspectfully wrong (especially when errors)", "tags": ["glsl", "bug"], "likes": 0, "viewed": 339, "published": 3, "date": "1610363112", "time_retrieved": "2024-07-30T19:45:45.009493", "image_code": "// Fork of \"graph message\" https://shadertoy.com/view/tldyWs\n\n#define S(v)  smoothstep( 5./R.y, -5./R.y, v ) // smoothstep necessary. even using  5./R.y rather than .1\n//#define S(v)  clamp(.5 - R.y/10.*(v), 0.,1.) // no bug using this instead\n\n#define L(V)   max( abs(V).x , abs(V).x ) -.1  // no bug if just abs(V).x !\n\n// float T(vec2 U,float X) { vec2 A = (U    ) * mat2(1,-.3,0,1) - vec2(X,0); return  L(A); } // no bug with func instead of macro\n#define T(U,X)   ( A = (U    ) * mat2(1,-.3,0,1) - vec2(X,0),  L(A) )\n#define R(U,X)   ( B = (U -.1) * mat2(1,-.3,1,1) - X ,         L(B) )\n#define F(U,X)   ( D = (U -.2) * mat2(1, .3,0,1) - vec2(X,.2), L(D) )\n\n//  bug disappear if this turned into float expression, despites .y not used\n#define v(U,X) V =   S( T(U,X) )               \\\n                   + S( R(U,X) ) * vec2(.6,1)  \\\n                   + S( F(U,X) ) * vec2(.3,1), \\\n               C += V          // no bug if do directly C += above\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y, V, A,B,D, C=R-R; // no bug with C=vec2(0) !\n    O = vec4(0);\n    \n// all this code should be ignored by later * min(0.,iTime) but each element still necessary for the bug\n    v(U,-1.); v(U,- .7); v(U,- .7); v(U,-.7);\n    v(U, 0.); v(U,  .2); v(U,  .2); v(U, .4); \n    v(U, 1.); v(U, 1.2); v(U, 1.2); v(U,1.4); v(U,1.4);\n    v(U, 2.); v(U, 2.2); v(U, 2.2);\n    O += C.x; // no bug if min(0.,iTime) * is put there rather than later\n\n// only this code should display\n    U.x = .4-U.x;   C=R-R;     // no bug with C=vec2(0) !\n    mat2 M = mat2(1);\n // vec2 M = vec2(1);          // no bug this way \n \n    v(U*M, -.4); v(M*U, 0.);   // M* , *M is  crucial\n    v(U,1.); v(U,1.); v(U,1.); v(U,1.); v(U,1.); v(U,1.); v(U,1.); v(U,1.); v(U,1.); v(U,1.); // all necessary for the bug\n    O += (1.-O.a) *  C.x;\n    \n    O = min(0.,iTime)*O + C.x;  // is thus C.x\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[955, 955, 993, 993, 1909]], "test": "untested"}
{"id": "ttcyDs", "name": "Stoneland", "author": "Catzpaw", "description": "click me!", "tags": ["raymarching", "fbm", "pom"], "likes": 18, "viewed": 674, "published": 3, "date": "1610363053", "time_retrieved": "2024-07-30T19:45:46.030763", "image_code": "//---Stoneland\n// by Catzpaw 2021\n\n//Image:post effect\n\n#define ZERO min(0,iFrame)\nconst float pi=acos(-1.);\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//CHROMATIC ABERRATION\nvec3 tx1(vec2 uv){return texture(iChannel0,uv).rgb;}\nvec3 ca(vec2 uv,vec2 xy){\n    vec2 uvr=uv-xy*.01;\n    vec3 c=vec3(0);\n    float f=0.;\n    for(int i=ZERO;i<10;i++)c+=tx1(mix(uvr,uv,f)).rgb*hsv(f+.85,1.,1.),f+=.1;\n    return c*.25;\n}\n\n//EDGE DETECTION\nfloat tx1a(vec2 uv){return texture(iChannel0,uv).a;}\nvec3 ed(vec2 uv){\n    float a=0.,v=0.,c=tx1a(uv);\n    float t=.03*c;\n    for(int i=ZERO;i<8;i++){\n        vec2 r=vec2(0,5e-4)*rot(a);\n        float s=max(0.,c-tx1a(uv+r))*5.;\n        v+=s>t?s*150.:0.;\n        a+=pi*.25;\n    }\n    return vec3(clamp(v,0.,1.),c,1.-c);\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec2 xy=(fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 e=ed(uv);\n    vec3 c1=ca(uv,xy);\n    vec3 c2=e.xxx+e.zzy*.2;\n    vec3 c=mix(c1,c2,clamp(iMouse.z,0.,1.));\n\n    fragColor=vec4(c*pow(1.1-length(xy),.3),1);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//---Stoneland\n// by Catzpaw 2021\n\n//Buffer A:terrain\n\n#define ITER 360\n#define ITER2 100\n#define NEAR 0.02\n#define FAR 1000.0\n\n#define ZERO min(0,iFrame)\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\n//NOISE\nvec2 h22(vec2 p){const vec2 v=vec2(19,29);return fract(sin(vec2(dot(p,v),dot(p+vec2(1,0),v)))*83e4);}\nfloat n21(vec2 p){vec2 i=floor(p),f=fract(p);f=f*f*(3.-f-f);p=mix(h22(i),h22(i+vec2(0,1)),f.y);return mix(p.x,p.y,f.x);}\n\n//FBM\nfloat fbm2(vec2 p){float f=0.,a=1.;for(int i=ZERO;i<6;i++)f+=a*n21(p),a*=.25,p*=3.53;return f;}\nfloat fbm3n(vec3 p,vec3 n){vec3 s=vec3(0);float a=1.;for(int j=ZERO;j<4;j++)s+=a*vec3(n21(p.yz),n21(p.zx),n21(p.xy)),a*=.4,p*=1.7;return dot(s,n);}\n\n//SDF\nfloat sdGround(vec3 p){return p.y-smoothstep(0.,.6,abs(fbm2(p.xz*.01)-.5))*10.;}\n\nvec2 lqr=vec2(FAR);\nvec3 lrr=vec3(FAR);\nfloat lvr=FAR;\nfloat sdRock(vec3 p){\n    vec2 q=floor(p.xz*.1)*10.;\n    float s=fract(sin(q.x*1332.1+q.y*333.1+100.)*83e4);\n    if(s<.2)return FAR;\n    vec3 r;float v;\n    if(q==lqr){r=lrr;v=lvr;}else{\n        lqr=q;\n        r=vec3(5.+sin(q.x*819.1+q.y+29.)*3.,0,5.+sin(q.x*31.+q.y*831.1)*3.);\n        v=(4.5-length(r.xz-5.))*s;\n        r+=q.xyy;\n        r.y=smoothstep(0.,.6,abs(fbm2(r.xz*.01)-.5))*8.5;\n        lrr=r;lvr=v;\n    }\n    return (p.y-r.y>5.)||(r.y<.05)?FAR:length(p-r)-v-fbm3n(p,normalize(p-r))*.5;\n}\n\nvec2 lqs=vec2(FAR);\nvec3 lrs=vec3(FAR);\nfloat lvs=FAR;\nfloat sdStone(vec3 p){\n    vec2 q=floor(p.xz*.5)*2.;\n    float s=fract(sin(q.x*1861.1+q.y*837.1+1000.)*83e4);\n    if(s<.9)return FAR;\n    vec3 r;float v;\n    if(q==lqs){r=lrs;v=lvs;}else{\n        lqs=q;\n        r=vec3(1.+sin(q.x*317.1+q.y+17.)*.3,0,1.+sin(q.x*19.+q.y*329.1)*.3);\n        v=(.9-length(r.xz-.5)*.5)*s;\n        r+=q.xyy;\n        r.y=smoothstep(0.,.6,abs(fbm2(r.xz*.01)-.5))*9.6;\n        lrs=r;lvs=v;\n    }\n    return (p.y-r.y>1.)||(r.y<.1)?FAR:length(p-r)-v-fbm3n(p,normalize(p-r))*.3;\n}\n\n//SCENE SDF\nfloat map(vec3 p){\n    float d=p.y-.2;\n    d=min(d,sdGround(p));\n    d=min(d,sdRock(p));\n    d=min(d,sdStone(p));\n    return d;\n}\n\n//GET MATERIAL ID FROM SCENE\nint map2(vec3 p){\n    float d1=p.y-.2;\n    float d2=sdGround(p);\n    float d3=min(sdRock(p),sdStone(p));\n    int id=1;\n    if(d1>d2)d1=d2,id=2;\n    if(d1>d3)id=3;\n    return id;\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,float ps){\n    float t=NEAR;\n    for(int i=ZERO;i<ITER;i++){\n        vec3 p=ro+rd*t;\n        float d=map(p);\n        if(abs(d)<ps*t||t>FAR)break;\n        t+=d;\n    }\n    return min(t,FAR);\n}\n\n//NORMAL\nvec3 normal(vec3 p,float ps,float t){\n    const vec2 e=vec2(1,-1);\n    float eps=ps*t;\n    return normalize(e.xyy*map(p+e.xyy*eps)+e.yyx*map(p+e.yyx*eps)+\n                     e.yxy*map(p+e.yxy*eps)+e.xxx*map(p+e.xxx*eps));\n}\n\n//SOFT SHADOW\nfloat shadow(vec3 p,vec3 ld){\n\tfloat o=1.,s=.6,a=1.;\n    for(int i=ZERO;i<5;i++){float r=.4*a;o+=(map(ld*r+p)-r*.3)*s;s*=.8;a++;}\n    return clamp(o,0.,1.);\n}\n\n//SKY\nconst vec3 sunDir=normalize(vec3(1.0,0.3,-0.2));\nconst vec3 sunCol=vec3(.88,.84,.80);\nconst vec3 ambCol=vec3(.05,.07,.09);\nvec3 sky(vec3 rd){\n\tfloat sun=max(0.,dot(rd,sunDir));\n\tvec3 s=mix(vec3(.25,.3,.45),vec3(.62,.61,.60),pow(1.-max(0.,rd.y),5.));\n\ts.r+=sun*sun*.2;\n\ts.g+=sun*sun*sun*.175;\n\ts.b+=sun*sun*sun*sun*.15;\n\ts+=sunCol*pow(sun,800.);\n\treturn clamp(s,0.,1.);\n}\n\n//MATERIAL\nconst vec3 snowDir=normalize(vec3(-0.2,1.0,0.1));\nvec3 tx0(vec3 p){\n    p.xz+=p.y;\n    return (texture(iChannel0,p.xz*.02).xyz+texture(iChannel0,p.xz*.111).xyz)*.5;\n}\n/*\nvec3 tx1(vec3 p){\n    return (texture(iChannel0,p.xz*.211).xyz+.2)*texture(iChannel1,p.xz*.15).xxx;\n}\n*/\nvec3 pom(vec3 ro,vec3 rd,out vec3 n){\n    float t=.1;\n    vec3 p;\n    for(int i=ZERO;i<10;i++){\n        rd=normalize(rd);\n        p=ro+rd*t;\n        float h=texture(iChannel1,p.xz*.15).x;\n        if(h*.7+.3>1.+rd.y*t)break;\n        t+=.1;\n    }\n    const vec3 e=vec3(-5e-3,0,5e-3);\n    float dx=texture(iChannel1,p.xz*.15+e.xy).x-texture(iChannel1,p.xz*.15+e.zy).x;\n    float dy=texture(iChannel1,p.xz*.15+e.yx).x-texture(iChannel1,p.xz*.15+e.yz).x;\n    n=normalize(vec3(dx,.01,dy));\n    return (texture(iChannel0,p.xz*.211).xyz+.2).rgb*(1.4-t-rd.y*.4);\n}\n\n//MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p=vec3(0);\n    float d=NEAR;\n    int id=0;\n\n    //get pixel radius\n    const float z=1.;\n    float ps=.5/(z*iResolution.y);\n\n    //camera\n    vec3 ro=vec3(0,25,-550),rd=normalize(vec3(uv,z)),n=vec3(0);\n    float t=(iTime+86.)*.06;\n    rd.yz*=rot(-.2+sin(t*1.8)*.2);\n    ro.xz*=rot(t);\n    rd.xz*=rot(-t*1.21);\n    ro.yz*=rot(.02);\n\n    //raymarching\n    vec3 c=sky(rd);\n    d=rd.y>.03?FAR:trace(ro,rd,ps);\n    p=ro+rd*d;\n    n=normal(p,ps,d);\n    \n    //shading\n    float sha=shadow(p,sunDir);///\n    id=d==FAR?0:map2(p);\n    if(id==1){\n        vec3 n2,tx2=pom(p,rd,n2);\n        c=mix(sky(reflect(rd,n)),tx2*sunCol*(dot(n2,sunDir)+2.)*.3,abs(dot(rd,n)))*(sha*.5+.5);///\n    }\n    else if(id==2){\n        vec3 n2,tx2=p.y>.9?vec3(0):pom(p,rd,n2);\n        vec3 n3=normalize(mix(n2,n,clamp(smoothstep(.06,.1,p.y*.1)+smoothstep(.02,.2,d*1e-3),0.,1.)));\n        vec3 tx3=mix(tx2,vec3(.2,.23,.1),smoothstep(.07,.09,p.y*.1));\n        vec3 tx4=mix(tx3,tx0(p),smoothstep(.15,.4,p.y*.1));\n        c=mix(tx4,vec3(1.2),smoothstep(.9,1.1,p.y*.1+pow(dot(n3,snowDir),9.)))*sunCol*(dot(n3,sunDir)+2.)*.3*sha+ambCol;///\n    }\n    else if(id==3){\n        c=mix(tx0(p),vec3(1.2),\n              smoothstep(.5,.7,p.y*.1+pow(dot(n,snowDir),9.))\n        )*sunCol*(dot(n,sunDir)+2.)*.3*sha+ambCol;///\n    }\n    c=max(c,sunCol*pow((dot(rd,sunDir)+1.)*.5,5.)*.4);\n\n    //depth\n    d+=id==1?FAR*.3:0.;\n    d-=id==3?FAR*.0025:0.;\n    d=clamp(d,0.,FAR);\n\n    fragColor=vec4(clamp(c,0.,1.),d/FAR);\n}\n", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 127, 127, 174], [175, 175, 209, 209, 286], [288, 311, 329, 329, 363], [364, 364, 389, 389, 547], [549, 566, 586, 586, 618], [619, 619, 636, 636, 886], [888, 895, 948, 948, 1207]], "test": "untested"}
{"id": "tttyDs", "name": "TwoGroundScanningLine", "author": "firegump", "description": "just effects tests", "tags": ["raymarching"], "likes": 23, "viewed": 791, "published": 3, "date": "1610359119", "time_retrieved": "2024-07-30T19:45:46.894453", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //uv handle---------------------------------------------------\n    \n    vec2 p = fragCoord/iResolution.xy;\n    \n   \n    //vec4 col1 = texture(iChannel1,p);\n    //vec3 col2 = texture(iChannel0,p).xyz;\n    //vec3 col3 = texture(iChannel2,p).xyz;\n    \n    \n     //vec4 col1 = textureLod( iChannel1, p, 0. );\n     //vec3 col2 = textureLod( iChannel0, p, 1. ).xyz;\n     //vec3 col3 = textureLod( iChannel2, p, 4. ).xyz;\n    \n    //vec3 col = mix(col1,col2,step(p.x,0.5));\n    //vec3 col =  mix(col2,col1.xyz,step(col1.w,0.3));\n    //vec3 col =  mix(col2,col1.xyz,smoothstep(0.3,0.2,col1.w));\n         //col =  mix(col3,col,step(col1.w,0.7));\n         \n         \n     vec3 col = vec3(0.); \n     \n     // dof\n    const float focus =  0.15;\n    const vec2 offsetPixel = vec2(1200.0,600.0);//vec2(800.0,450.0);\n\n    vec4 acc = vec4(0.0);\n    const int N = 4;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel1, p + off/offsetPixel ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0/(coc*coc); \n            \n            acc += vec4(color*w,w);\n        }\n    }\n   \n    col = acc.xyz ;\n    \n    \n    \n    col = col*1.1 - 0.06;\n    \n    // vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y) );\n    \n    col *=  0.95;\n    vec4 col1 = texture( iChannel1, p );\n    col = mix(col,col1.xyz,smoothstep(2.1,0.4,col1.w));\n    \n    // gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define AniTime 0.7\n\nfloat N21(vec2 p)\n{ \n  p = fract(p * vec2(123.34,345.45));\n  p += dot(p, p + 34.345); \n         return fract(p.x*p.y);}\n\n\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  \n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  \n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere(in vec3 pos, float rad)//ellipsoid sdf\n{\n    \n    return length(pos) - rad;\n}\n\n\nfloat map(in vec3 pos)             //all distance function put in here\n{\n    float d1 = sdSphere(pos - vec3(0.,0.,-2.), 0.25);         //sphere distance field\n   \n    float d2 = sdOctahedron(pos - vec3(3.3,1.,-7.), 1.35);  //plane distance field\n    \n    float d3 = sdSphere(pos - vec3(-5.3,0.,-3.),1.45);\n    d2 = min(d2,d3);\n    \n    float d8 = sdSphere(pos - vec3(-4.3,0.,-3.),1.45);\n    d2 = opSmoothSubtraction(d8,d2,0.5);\n    \n    \n    float d4 = sdRoundBox(pos - vec3(-3.3,1.,-5.), vec3(1.,1.,1.), 0.25);\n    d2 = min(d2,d4);\n    \n    float d6 = sdRoundBox(pos - vec3(-3.3,3.,-5.), vec3(0.8,0.8,0.8), 0.25);\n    d2 = min(d2,d6);\n    \n    float d5 = sdOctahedron(pos - vec3(3.3,1.,-10.), 2.35);\n    d2 = min(d2,d5);\n    \n    float d7 = sdRoundedCylinder( pos - vec3(5.3,0.2,-5.), .4, 0.2,0.3);\n    d2 = min(d2,d7);\n    \n    float d9 =  pos.y - (- 0.25);\n    d2 = min(d2,d9);\n    \n    //float d10 = opRep(pos, vec3(1.,1.,1.),  );\n    //d2 = min(d2,d9);\n    \n    return min(d1,d2);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.0);\n    return normalize(vec3(map(pos + e.xyy) - map(pos - e.xyy),\n                          map(pos + e.yxy) - map(pos - e.yxy),\n                          map(pos + e.yyx) - map(pos - e.yyx)));\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    \n    float t = 0.0;           //t is the raymarching total distance\n    for(int i = 0;i<100;i++)\n    {\n    \n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if(h< 0.001) break; //if ray hit something break loop\n        \n        \n        t += h;\n        if(t>20.0) break;                 //save cost\n    }\n    if(t > 20.0) t = -1.0;                //if ray doesn't hit something return  -1.\n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    //uv handle---------------------------------------------------\n    \n    vec2 p = fragCoord/iResolution.xy; \n    p     -= 0.5;                         //move 0,0 to screen center\n    p.x   *= iResolution.x/iResolution.y; //modify aspect ratio\n    p     *= 2.;                          //remap to -1,1 , result is same calculation as above\n    \n    //camera------------------------------------------------------\n    float an = 10.0*iMouse.x/iResolution.x;//iTime;\n    //an = 0.;\n    \n    vec3 ta  = vec3(0.0,1.1,0.0);\n    //ta = vec3(0.,0.,0.);\n    vec3 ro  = ta + vec3(2.0*sin(an),0.0,2.0*cos(an));//camera position\n    \n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    \n    vec3 rd  = normalize(p.x*uu + p.y*vv + 1.5* ww);//camera direction viewspace to worldspace\n    \n    //vec3 rd = normalize(vec3(p,1.));\n    \n    \n   \n   \n    \n    vec3 col = vec3(0.4,0.75,1.) - 0.7*rd.y;             //sky color Gradient\n    col = mix(col,vec3(0.7,0.75,0.8),exp(-10.0 * rd.y)); //make horizon\n    \n    \n    float t = castRay(ro,rd);\n    \n    \n    \n    \n    \n    \n    if(t>0.0)\n    {   vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 cameraOrientation = ww;\n        //cameraOrientation = normalize(vec3(2.0*sin(an),0.0,2.0*cos(an)));\n        \n        //noise grid\n        float id = N21(floor(pos.xz*0.8));\n        \n        \n        \n        //animation\n         vec3 PointPos = vec3(0.,0.,-10.);\n         //PointPos = ro;\n         float aT = fract(iTime*AniTime);\n         //dist 1-------------------------------------------------------------------\n         float  dist1 = length(pos - PointPos);//distance sample\n         //dist 2------------------------------------------------------------------\n         //float  dist2 =  dot(normalize(cameraOrientation.xz),(pos - ro).xz);\n         vec3 rd1 = normalize(p.x*uu + p.y*vv + 1.5* ww);\n         \n         float  dist2 =  dot(ww.xz,rd1.xz*t);\n         \n         \n         float m = mod(floor(iTime*AniTime),2.);\n         \n         float dist = mix(dist1,dist2,m);\n         //dist = dist2;\n         \n         \n         float distPoint = 25.*aT+0.;\n         float distRange = 0.28;\n         \n         float  ds = step(dist,distPoint );\n         float  dOutline = (1.-ds)*step(dist,distPoint + distRange);\n        \n         \n         \n        \n        \n        \n        \n        //material\n        vec3 uvPos = pos*0.1;\n        vec3 mate1 = texture(iChannel0,uvPos.xz).xyz* nor.y*nor.y;\n        vec3 mate2 = texture(iChannel0,uvPos.yz).xyz* nor.x*nor.x;\n        vec3 mate3 = texture(iChannel0,uvPos.xy).xyz* nor.z*nor.z;\n        \n        vec3 mate = mate1+ mate2 + mate3;\n        mate *= 0.28;\n        \n     \n        \n        \n        //get material illumination\n        //float illumination = 0.299*mate.x + 0.587*mate.y + 0.114*mate.z;\n        \n        //float norScale = 0.5;\n        //float norOffset =  2.0*(illumination - 0.5)*norScale;\n        //vec3 norX = normalize(vec3(nor.x,nor.y, nor.z + norOffset))* nor.y*nor.y;\n         //vec3 norY = normalize(vec3(nor.x,nor.y + norOffset, nor.z ))*nor.x*nor.x;\n          //vec3 norZ = normalize(vec3(nor.x,nor.y, nor.z + norOffset))*nor.z*nor.z;\n        \n        //nor = normalize(norX+ norY+ norZ);\n        \n        vec3  sun_dir = normalize(vec3(0.8,0.4,0.2));\n        float sun_dif = clamp(dot(nor,sun_dir),0.0,1.0);                     //sun diffuse sample\n        float sun_sha = step(castRay(pos + nor*0.001, sun_dir),0.0);         //shadow      sample\n        float sky_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)),0.0,1.0); //sky diffuse sample\n        float bou_dif = clamp(0.5 + 0.5*dot(nor,vec3(0.0,-1.0,0.0)),0.0,1.0);//reflected light from the ground\n        float rim = pow(clamp(1.-dot(nor,-rd),0.0,1.0),8.);\n        \n        vec3 h = normalize(-rd + sun_dir);\n        float sun_spe = pow(clamp(dot(nor, h),0.,1.),64.);\n        \n        col =  mate*vec3(7.0,6.0,4.0)*sun_dif * sun_sha;\n        col += mate*vec3(0.5,0.8,0.9)*sky_dif;\n        col += mate*vec3(0.7,0.3,0.2)*bou_dif;\n        col += mate*vec3(3.7,2.3,2.2)*sun_spe;\n        \n        vec3 cubemapCol = textureLod( iChannel1, nor, 4. ).xyz;\n        col = mix(col,cubemapCol,rim);\n        \n        //lineSample\n        vec3 lineSa = step(fract(4.5*pos),vec3(0.08));\n        float lineS = lineSa.x+lineSa.y + lineSa.z;\n        \n        \n        //id = id*2. - 1.;\n        vec3 lineCol = vec3(0.0,1.5,1.2)*step(0.9,lineS);//vec3(0.0,1.5,1.2 + id )\n        \n        col = mix(col,mix(col,lineCol,lineS), ds) + vec3(dOutline);\n        //col = mate;\n        \n        //col = vec3(rim);\n        //col =  textureLod( iChannel1, nor, 4. ).xyz;\n        //col = vec3(id);\n        //col = vec3(dot(ww.xz,rd.xz*t))/300.;\n         \n        \n        \n    }\n    \n    //col = pow(col, vec3(0.4545));//gamma just 1/2.2;\n    \n    if(t<0.) t = 5.;\n    float depth = t/5.;\n    \n    \n    //show depth step value 0.3 0.7\n    //depth = step(depth,0.3)*0.5+ step(depth,0.7)*0.5;\n    //col = vec3(id);\n    \n    \n    \n    \n    \n    \n    //col = vec3(dot(ww.xz,rd.xz*t)/50.); //orientation test\n    \n\n    // Output to screen\n    fragColor = vec4(col,depth);\n}", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 130, 1770]], "test": "untested"}
{"id": "3lVyzR", "name": "N-Star", "author": "hugoaboud", "description": "Draws a star with n points, parametric outer and inner radius, and a nice glow around it.\nSample animation: spin a and make a pulsating wave inside it.", "tags": ["star", "polygon", "shape"], "likes": 1, "viewed": 329, "published": 3, "date": "1610344832", "time_retrieved": "2024-07-30T19:45:47.750167", "image_code": "/*\n\tThis program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, version 3.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\n/** Properties **/\n\nconst int N = 5; // Number of points\n\nconst float radius = 1.0; // Outer Radius: absolute value (in UV)\nconst float iradius = 0.6; // Inner Radius: relative to outer\nconst float glow = 0.3; // Glow Size: relative\n\nconst vec4 inColor = vec4(1,1,0,1);\nconst vec4 outColor = vec4(0,1,1,1);\nconst vec4 glowColor = vec4(1,0,0.5,1);\n\n/** Animation **/\n\nconst float rotateSpeed = 0.05;\nconst float waveSpeed = 0.5;\nconst vec4 waveColor = vec4(0.2,0.5,1.0,0.4);\n\nconst vec4 transp = vec4(0,0,0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Starting from center\n    uv.xy -= 0.5;\n    uv.xy *= -2.0;\n    \n    // Adjusted to aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Radius\n    float r = length(uv);\n\n    // Background color\n    vec4 col = vec4(0,0,0,0);\n    \n    // Inside outer circle\n    if (r < radius) {\n    \n        // Linear position in circle\n        // This is a simplified projection of the vertex vector on y\n        float ly = uv.y/r;\n        \n        // Calculate polar angle\n        float a = atan(uv.x,uv.y);\n        \n        // Rotate Animation\n        a -= iTime*rotateSpeed;\n        \n        // Break angle into N sections\n        // then rearrange from [0 ~ 1] to [1 ~ 0 ~ 1]\n        // The section angle can be precalculated if N doesn't change\n        float sa = M_PI/float(N); // section angle\n        float p = fract(a/(2.0*sa)); // position in section (angular)\n        p = abs(p-0.5)*2.0;\n        \n        // Get chord midpoint radius\n        // A.K.A. height of the equilateral triangle inside the arc\n        float cr = cos(sa)*radius;\n                \n        // Get chord point radius, given the angle \n        float pa = p*sa; // point angle\n        float cpr = cr/cos(sa-pa);\n                \n        // rough method: maybe too expensive?\n        // scale cr by triangle propotionality rule\n        // The inner radius decomposition can be precalculated if N doesn't change\n        float xp = cpr*sin(pa); // decompose cpr x\n        float yp = cpr*cos(pa); // decompose cpr y\n        float xi = sin(sa*0.5)*iradius*radius; // decompose inner radius x\n        float yi = cos(sa*0.5)*iradius*radius; // decompose inner radius y\n        \n        //float yx = xi/((xp*(1.0-yi)/yp)+xi); // y component of border (if radius == 1)\n        float yx = (xi*yp*radius)/(xp*radius-xp*yi+xi*yp);// y component of border (general radius)\n        \n        // Final result: the star border radius\n        float border = yx/cos(pa);\n        \n        // Coloring (Internal + Glow)\n        if (r < border) {\n            float gl = 1.0-glow;\n            float c = r/border;\n            // star\n            if (c < gl) {\n                col = mix(inColor,outColor,c/gl);\n            }\n            // antialias\n            else if (c < gl*1.025) {\n                col = mix(outColor,glowColor,(c-gl)*50.0);\n            }\n            // glow\n            else {\n                col += glowColor*((1.0-c)/glow);\n            }\n        }\n        \n        // Wave animation\n        float t = fract(iTime*waveSpeed);\n        float rt = t*radius;\n                \n        if (r < rt) rt = 1.0-(rt - r)/radius;\n        else rt = (r - rt)/radius;\n        \n        rt = fract(rt*2.0);\n        \n        // Lighten\n        col += rt*waveColor*waveColor.a*col.a;\n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVyzR.jpg", "access": "api", "license": "gpl-1.0-plus", "functions": [[1162, 1162, 1219, 1269, 4110]], "test": "untested"}
{"id": "wlccR2", "name": "Aurora in the desert", "author": "butadiene", "description": "Imagine polar desert", "tags": ["raymarching"], "likes": 4, "viewed": 392, "published": 3, "date": "1610340202", "time_retrieved": "2024-07-30T19:45:48.517115", "image_code": "\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\n//////////////////////////////////////////////////////////////////////////////////////////////\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 2\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nfloat PI = 3.1415926535;\nvec3 MoonDirection = normalize(vec3(-0.5,0.4,-0.3));\nvec3 MoonColor = vec3(0.6,0.7,1.2);\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rot(float r){\n    return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nvec4 dist(vec3 p){\n    //p.z *= 0.7;\n    p.y -= 0.3;\n\tfloat d = 0.009;\n    float no = ridgedMF(p.xz+0.3*snoise(p.xz+0.1*iTime));\n    vec3 col = vec3(1,1,1)*0.02*exp(-no*3.);\n    float thredy = 0.5;\n    float thx = p.y-thredy;\n    vec3 highems = vec3(1.3,1.0,1.0)*max(thx*8.0*exp(-3.5*vec3(2.,1.2,1.5)*thx),0.);\n    col *= highems;\n    return vec4(col,d);\n}\n\nvec4 ground(vec3 p){\n    p.y -= 0.3;\n    p.x -= -0.;\n    float d = p.y - smoothstep(0.0,1.0,length(p.xz-vec2(-0.4,0.))*1.)*0.23*ridgedMF(vec2(0.9,1.)*(p.xz-vec2(-0.1,0.02*iTime)));\n    //d = max(d,-(length(p-vec3(-0.4,0.65,-0.6))-0.8));\n    vec3 col = vec3(0);\n    return vec4(col,d);\n}\n\nvec3 getnormal(vec3 p)\n{\n\tconst vec2 e = vec2(0.5773,-0.5773)*0.0001;\n\tvec3 nor = normalize( e.xyy*ground(p+e.xyy).w +\n \t\te.yyx*ground(p+e.yyx).w + e.yxy*ground(p+e.yxy).w + e.xxx*ground(p+e.xxx).w);\n\tnor = normalize(vec3(nor));\n\treturn nor ;\n}\n\n\nvec3 star(vec2 s){\n    vec3 c = vec3(snoise(s));\n    c = pow(c,vec3(5.));\n    c = clamp(7.*clamp(c-0.7,0.0,1.0),0.0,1000.0);\n  \n    return c;\n}\n\nvec3 background(vec3 rd){\n    vec2 rs = vec2(atan(length(rd.xy),rd.z),atan(rd.x,rd.y));\n    vec3 moon = 0.5*clamp(MoonColor*0.07/length(MoonDirection-rd),0.0,1.0);\n    return moon+star(rs*50.)*vec3(0.5)+vec3(0.7,0.5,0.5)*star(rs*50.+20.)+vec3(0.5,0.5,0.7)*star(rs*50.+70.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    p = 2.0*(p-0.5);\n    p.x *= iResolution.x/iResolution.y;\n\n    vec3 offset = vec3(0,-0.4 ,0);\n    vec3 ro = vec3(0,0,0)-offset;\n    vec3 ta = vec3(0,1.6,-2)-offset;\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    float fov = 0.4;\n   \n    vec3 rd = normalize(side*p.x+up*p.y+cdir*fov);\n     //rd.xz *= rot(iTime);\n    float d,t=0.;\n    float gd = 0.;\n    vec3 ac = vec3(0.);\n    vec4 disres;\n    float kset = 0.3;\n    float sen = (1.0+1.5*pow(abs(sin(iTime*kset))*(1.0-fract(iTime*kset/(0.5*PI))),1.));\n    \n    for(int i = 0;i<139;i++){\n    \tdisres = 2.0*dist(ro+rd*t)*sen;\n        d = disres.w;\n        gd = 0.5*ground(ro+rd*t).w;\n        d = min(gd,d);\n        t += d;\n\t\tac += disres.xyz;\n        if((ro+rd*t).z<-1.5)break;\n    }\n\n    vec3 col = vec3(0.);\n\n   \tcol += ac;\n    \n    col += background(rd);\n    \n    if(gd<0.01){\n        vec3 sp = ro+rd*t;\n        vec3 normal = getnormal(sp);\n        float snk = 1.;\n        vec3 cnormal = normal + 0.1*(vec3(random(snk*sp.yz),random(snk*sp.zx),random(snk*sp.xy))-0.5);\n        cnormal = normalize(cnormal);\n        col = 1.5*vec3(193,157,121)/255.*MoonColor*vec3(max(dot(cnormal,MoonDirection),0.));\n        col += MoonColor*0.02;\n        ac = vec3(0.0);\n        \n        vec3 snormal;\n        vec3 rrd;\n        for(int i =0; i<8; i++){\n            snormal =normal + 1.0*(vec3(random(snk*sp.yz+float(i)*100.),random(snk*sp.zx+float(i)*100.),random(snk*sp.xy+float(i)*100.))-0.5);\n            snormal = normalize(snormal);\n            t = 0.4;\n            ro = sp;\n            rrd =snormal;// reflect(rd,snormal);\n            for(int i = 0;i<10;i++){\n                disres = 6.0*dist(ro+rrd*t)*sen;\n                d = disres.w;\n                t += d;\n                ac += disres.xyz;\n            }\n        }\n        col += 0.1*ac;\n    \n    }\n    \n    // Output to screen\n\tcol = pow(col,vec3(0.8));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccR2.jpg", "access": "api", "license": "mit", "functions": [[1, 439, 460, 460, 507], [508, 508, 529, 529, 576], [577, 577, 599, 599, 634], [636, 636, 658, 711, 2408], [2429, 2517, 2553, 2553, 2698], [2700, 2700, 2724, 2724, 3130], [3340, 3340, 3364, 3364, 3471], [3473, 3473, 3491, 3491, 3540], [3542, 3542, 3560, 3578, 3898], [3900, 3900, 3920, 3920, 4186], [4188, 4188, 4212, 4212, 4432], [4435, 4435, 4453, 4453, 4578], [4580, 4580, 4605, 4605, 4855], [4857, 4857, 4914, 4964, 6971]], "test": "untested"}
{"id": "WtKyzR", "name": "Foggy Valley - Fog Experiment", "author": "oneshade", "description": "Experimenting with fog. Mouse to rotate and arrow keys to move.", "tags": ["raymarching", "terrain", "fog", "fractalnoise"], "likes": 3, "viewed": 216, "published": 3, "date": "1610337756", "time_retrieved": "2024-07-30T19:45:49.295035", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 bl = texelFetch(iChannel0, iFragCoord, 0);\n    vec4 br = texelFetch(iChannel0, iFragCoord + ivec2(1, 0), 0);\n    vec4 tl = texelFetch(iChannel0, iFragCoord + ivec2(0, 1), 0);\n    vec4 tr = texelFetch(iChannel0, iFragCoord + 1, 0);\n    fragColor = (bl + br + tl + tr) * 0.25;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Math constants:\nconst float TWO_PI = 6.2832;\n\n// Amount by which the camera moves and rotates:\nconst float STEP_SIZE      = 0.05;\nconst float ROTATION_SPEED = 1.0;\n\n// Addresses to viewing data:\nconst ivec2 VIEW_POS = ivec2(0, 0);\nconst ivec2 VIEW_DIR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n#define fetch(buf, addr) texelFetch(buf, addr, 0).xyz\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(-1.5, 0.0, -50.0, 1.0);\n    if (iFrame > 0) {\n        ivec2 address = ivec2(fragCoord);\n        if (address == VIEW_POS) {\n            fragColor = vec4(fetch(iChannel0, VIEW_POS), 1.0);\n            mat3 camera = getCamera(fetch(iChannel0, VIEW_DIR).xy);\n \n            if (bool(fetch(iChannel1, ivec2(KEY_UP, 0)).x)) {\n                fragColor.xz += camera[2].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_DOWN, 0)).x)) {\n                fragColor.xz -= camera[2].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_RIGHT, 0)).x)) {\n                fragColor.xz += camera[0].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_LEFT, 0)).x)) {\n                fragColor.xz -= camera[0].xz * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIR) {\n            float viewDirection = fetch(iChannel0, VIEW_DIR).x;\n            if (iMouse.z > 0.0) {\n                viewDirection = (iMouse.x - 0.5 * iResolution.x) / iResolution.x * TWO_PI * ROTATION_SPEED;\n            }\n\n            fragColor = vec4(viewDirection, 0.0, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Hash from \"Hash without Sine\" by Dav_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat noise(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = noise(cell);\n    float br = noise(cell + vec2(1.0, 0.0));\n    float tl = noise(cell + vec2(0.0, 1.0));\n    float tr = noise(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat fnoise(in vec2 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return p.y - fnoise(p.xz, 1.0, 10.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\n// Based on Inigo Quilez's fog article (https://iquilezles.org/articles/fog):\nvoid applyFog(inout vec3 color, in vec3 rayOri, in vec3 rayDir, in vec3 sunDir, in float dist) {\n    float b = 2.5;\n    float sunAmount = max(0.0, dot(rayDir, sunDir));\n    vec3 fogColor = mix(vec3(0.5, 0.6, 0.7), vec3(1.0, 0.9, 0.7), pow(sunAmount, 2.0));\n    float fogAmount = 1.0 - exp(-dist * b);\n    color = mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = fetch(iChannel0, VIEW_POS);\n    mat3 camera = getCamera(fetch(iChannel0, VIEW_DIR).xy);\n    vec3 rd = normalize(camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    ro.y += 0.1 + fnoise(ro.xz, 1.0, 3.0);\n\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n\n    float t = 0.0;\n    for (int iter=0; iter < 100; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001 * (t + 1.0)) { // Accelerated raymarching technique from jarble\n            vec3 n = getNormal(p);\n            vec3 material = mix(vec3(0.0, 1.0, 0.0), vec3(0.6, 0.4, 0.0), 1.25 * p.y);\n            fragColor.rgb += material * max(0.0, dot(n, l)) * 2.0;\n            break;\n        }\n\n        if (t > 30.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    applyFog(fragColor.rgb, ro, rd, l, t);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtKyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 382]], "test": "untested"}
{"id": "3lKyRR", "name": "ciudad eterna", "author": "jorge2017a1", "description": "ciudad eterna", "tags": ["ciudadeterna"], "likes": 5, "viewed": 235, "published": 3, "date": "1610331894", "time_retrieved": "2024-07-30T19:45:50.079936", "image_code": "//referencia un shader que no recuerdo y no se donde esta.\n// reference a shader that I don't remember and don't know where it is.\n//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n//-------------------------------------------\n\n// object transformation\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvec2 rotate2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c)*vec2(1.0,1.0);\n}\n\n\n\nfloat shape(vec3 p, float a) \n{\n\tfloat s = sdSphere(abs(p) - vec3(2, 0, 0),  0.5);\n\tfloat b = sdBox(p, vec3(2, 0.5 + a, 0.5));\n    float b1 = sdBox(p, vec3(1, 2.5 * a, 0.5));\n    float s2 = sdSphere(abs(p) - vec3(0, 1., 0),  0.5);\n    \n\tfloat res;\n    \n    res=min(s, b);\n    res=min(res, b1);\n    res=min(res, s2);\n    \n\treturn res;\n}\n\nvec2 de(vec3 p) \n{\t\n\t\n\tvec4 q = vec4(p*0.1, 1.0);\n\tvec4 sq = q;\n\t\n\tfor(int i = 0; i < 7; i++) {\n\t\tq.xyz = abs(q.xyz) - vec3(1.7, 0.1, 0.8);\n\t\tq.xz *= rot2D(0.785*2.0 + float(i)*0.785);\n\t\t\n\t\tq *= 1.4;\n\t\t\n\t\tsq = q;\n\t\tsq.xz += 1.2;\n\t\t\n\t}\n\t\n\tq.xyz = abs(q.xyz) - vec3(0, 4, 0);\n\tfloat v = shape(q.xyz, 0.0)/(q.w*0.1);\n\t\n\tsq.xyz = abs(sq.xyz) - vec3(0, 4, 0);\n\tfloat h = shape(sq.xyz, 2.0)/(sq.w*0.1);\n\t\n    vec2 res=vec2(9999.9,-1.0);\n    res=opU2(res, vec2(v, 6.0));\n    res=opU2(res, vec2(h, 8.0));\n    res=opU2(res, vec2(p.y + 0.5, 3.0));\n  \n    return res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n  \n    p.y=p.y-5.0;\n    vec2 d1= de(p);\n    res =opU3(res, vec3(d1.x,d1.y,MATERIAL_NO)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n     float diff = dot(normal, l);\n\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\n    float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n   \n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n  \n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 ,0.0,0.0);\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n  \n\n    vec3 ro=vec3(4.0,13.0,-25.0);\n    ro.xz=rotatev2(ro.xz+vec2(0.5,0.5*cos(iTime*0.25) ), sin(iTime*0.25));\n    \n     vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[579, 579, 615, 615, 636], [637, 637, 669, 669, 753], [828, 828, 862, 862, 959], [961, 961, 982, 982, 1051], [1052, 1052, 1076, 1076, 1159], [1163, 1163, 1194, 1194, 1498], [1500, 1500, 1518, 1518, 2058], [2061, 2101, 2126, 2126, 2399], [2404, 2404, 2490, 2490, 3216], [3222, 3273, 3297, 3297, 3485], [3486, 3549, 3582, 3582, 4043], [4045, 4099, 4135, 4135, 4369], [4426, 4426, 4506, 4506, 4783], [4880, 4880, 4973, 4973, 5081], [5086, 5135, 5192, 5192, 6484]], "test": "untested"}
{"id": "wtGcRz", "name": "Tori Gate On The Ocean", "author": "intrakits", "description": "I wanted to try and be more artistic and felt inspired after looking at a photo of a japanese shrine. It still needs some work, but I like the way it is coming along. :)", "tags": ["art", "japan", "shrine", "gate", "japanese", "tori", "shinto"], "likes": 5, "viewed": 267, "published": 3, "date": "1610324492", "time_retrieved": "2024-07-30T19:45:50.869824", "image_code": "mat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nvec3 circle (vec2 uv, float posX, float posY, float r, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    \n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 circle (vec2 uv, float r, float blur, vec3 color){\n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 square(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv*=rotate(rot);\n    float wPos = length(uv.x-posX);\n    float hPos = length(uv.y-posY);\n    \n    float col = smoothstep(w,w-blur, wPos);\n    col *= smoothstep(h,h-blur, hPos);\n    return color*vec3(col);\n}\nvec3 triangle(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    uv*=rotate(rot);\n    vec3 sq = square(uv,w,h,0.,0.,0.,blur,color);\n    uv*=rotate(3.1415/2./2.);\n    uv-= vec2(0.,h);\n    float hyp = sqrt(w*w + h*h);\n    vec3 sqMask = square(uv,hyp,h,0.,0., 0.,blur,color);\n    sq -= sqMask;\n    return sq;\n}\nvec3 ellipse(vec2 uv, float posX, float posY, float rot, float a,float b, float blur, vec3 color){\n    uv -= vec2(posX,posY);\n    uv*=rotate(rot);\n    float x = uv.x;\n    float y = sqrt((1.-a)*(1.-((x*x)/(1.-b))));\n    float d = length(uv);\n    return color * vec3(smoothstep(y,y-blur,d));\n}\nvec3 wave (vec2 uv, float xPos, float yPos, float blur, float vertSpeed, float horSpeed){\n    float movX = sin(iTime*vertSpeed)*.04;\n    float movY = cos(iTime*horSpeed)*.04;\n    uv -= vec2(xPos,yPos);\n    vec3 wave = circle (uv - vec2(movX,movY),.2,blur, vec3(1.));\n    wave = min(wave, wave-circle (uv - vec2(0.12 + movX,.05 + movY), 0.2, blur, vec3(1.)));\n    wave = min(wave, wave-circle (uv - vec2(-0.12+ movX,.05+ movY), 0.2, blur, vec3(1.)));\n    wave = min(wave, wave-circle (uv - vec2(0.+ movX,-.34+ movY), 0.2, blur, vec3(1.)));\n    return wave;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv-= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    //background\n    float blur = 0.01;\n    //sky\n    vec3 col = vec3(uv.y+.3) * vec3(1,.2,.4);\n    \n    //ocean\n    col = max(col, vec3(-uv.y) * vec3(.5,.4,.8));\n    //waves\n    \n    float movX = sin(iTime)*.04;\n    float movY = cos(iTime*2.)*.04;\n    \n    vec3 w = wave(uv,0.4,-0.2,blur, 1., 2.);\n    w = max(w, wave(uv,-.4,-0.2,blur, 1., 4.));\n    w = max(w, wave(uv,-.2,-0.3,blur, 1.3, 2.));\n    w = max(w, wave(uv,.3,-0.3,blur, 1.6, 2.3));\n    col = max(col, w);\n    \n    //water lines\n    vec3 waterLine = square(uv, .7, .005, -.9+movX, -0.4, 0., blur, vec3(1.));\n    waterLine = max(waterLine, square(uv, .9, .005,.9+movX*.5, -0.39, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .8, .005,-.9+movX*.7, -0.38, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .777, .005,.9+movX*.9, -0.37, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .8, .005,-.9+movX*.2, -0.36, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .82, .005,.9+movX*1.2, -0.35, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .76, .005,-.9+movX*.7, -0.34, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .9, .005,.9+movX*.9, -0.33, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .9, .005,-.9+movX*.2, -0.32, 0., blur, vec3(1.)));\n    waterLine = max(waterLine, square(uv, .8, .005,.9+movX*1.2, -0.31, 0., blur, vec3(1.)));\n    col = max(col, waterLine);\n    //ground\n    vec3 groundM = ellipse(uv, 0., -0.26, 3.1415/2., .9,.996, blur, vec3(1.));\n    groundM = max(groundM, square(uv, .1, .2, -0.2, -0.33, -1., blur, vec3(1.)) - square(uv, .2, .3, 0., 0., 0., blur, vec3(1.)) );\n    groundM = max(groundM, square(uv, .45, .136, 0.7,-.5, 0., blur, vec3(1.)));\n    col-= groundM;\n    vec3 ground = ellipse(uv, 0., -0.26, 3.1415/2., .9,.996, blur, vec3(.5));\n    ground = max(ground, square(uv, .1, .2, -0.2, -0.33, -1., blur, vec3(.5))- square(uv, .2, .3, 0., 0., 0., blur, vec3(1.)));\n    ground = max(ground, square(uv, .45, .136, 0.7,-.5, 0., blur, vec3(.5)));\n    col = max(col,ground);\n    //tori gate\n    ///mask----------------------\n    //legs\n    vec3 toriM = square(uv, .03, .25, -0.2, 0., 0.02, blur, vec3(1.));\n    toriM = max(toriM,square(uv, .03, .25, 0.2, 0., -0.02, blur, vec3(1.)));\n    \n    //horizontal beams\n    toriM = max(toriM,square(uv, .37, .03, 0., 0.15, 0., blur, vec3(1.)));\n    toriM = max(toriM,square(uv, .37, .022, 0., 0.25, 0., blur, vec3(1.)));\n    \n    //lower horizontal mask\n    toriM = min(toriM,toriM-square(uv, .05, .02, -0.34, 0.076, 0.13, blur, vec3(1.)));\n    toriM = min(toriM,toriM-square(uv, .05, .02, -0.3, 0.22, -0.13, blur, vec3(1.)));\n    \n    toriM = min(toriM,toriM-square(uv, .05, .02, 0.34, 0.076, -0.13, blur, vec3(1.)));\n    toriM = min(toriM,toriM-square(uv, .05, .02, 0.3, 0.22, 0.13, blur, vec3(1.)));\n    \n    //central beam\n    toriM = max(toriM,square(uv, .03, .04, 0., 0.2, -0.02, blur, vec3(1.,0,0)));\n    \n    \n    //top beam\n    toriM = max(toriM,square(uv, .37, .022, 0., .278, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,circle (uv-vec2(-.36,.305), .05, blur, vec3(1,.6,.4)));\n    toriM = max(toriM,circle (uv-vec2(.36,.305), .05, blur, vec3(1,.6,.4)));\n    \n    toriM = min(toriM,toriM-circle (uv-vec2(-.33,.338), .05, blur, vec3(1,.6,.4)));\n    toriM = min(toriM,toriM-circle (uv-vec2(.33,.338), .05, blur, vec3(1,.6,.4)));\n    \n    // embelleshments\n    toriM = max(toriM,square(uv, .034, .022, -0.198, .11, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,square(uv, .034, .022, -0.198, .22, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,square(uv, .034, .022, 0.198, .11, 0., blur, vec3(1,.6,.4)));\n    toriM = max(toriM,square(uv, .034, .022, 0.198, .22, 0., blur, vec3(1,.6,.4)));\n    col -= toriM;\n    \n    //-------------------------\n    //legs\n    vec3 tori = square(uv, .03, .25, -0.2, 0., 0.02, blur, vec3(1.,0,0));\n    tori = max(tori,square(uv, .03, .25, 0.2, 0., -0.02, blur, vec3(1.,0,0)));\n    \n    //horizontal beams\n    tori = max(tori,square(uv, .37, .03, 0., 0.15, 0., blur, vec3(1.,0,0)));\n    tori = max(tori,square(uv, .37, .022, 0., 0.25, 0., blur, vec3(1.,0,0)));\n    \n    //lower horizontal mask\n    tori = min(tori,tori-square(uv, .05, .02, -0.34, 0.076, 0.13, blur, vec3(1.)));\n    tori = min(tori,tori-square(uv, .05, .02, -0.3, 0.22, -0.13, blur, vec3(1.)));\n    \n    tori = min(tori,tori-square(uv, .05, .02, 0.34, 0.076, -0.13, blur, vec3(1.)));\n    tori = min(tori,tori-square(uv, .05, .02, 0.3, 0.22, 0.13, blur, vec3(1.)));\n    \n    //central beam\n    tori = max(tori,square(uv, .03, .04, 0., 0.2, -0.02, blur, vec3(1.,0,0)));\n    \n    \n    //top beam\n    tori = max(tori,square(uv, .37, .022, 0., .278, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,circle (uv-vec2(-.36,.305), .05, blur, vec3(1,.6,.4)));\n    tori = max(tori,circle (uv-vec2(.36,.305), .05, blur, vec3(1,.6,.4)));\n    \n    tori = min(tori,tori-circle (uv-vec2(-.33,.338), .05, blur, vec3(1,.6,.4)));\n    tori = min(tori,tori-circle (uv-vec2(.33,.338), .05, blur, vec3(1,.6,.4)));\n    \n    // embelleshments\n    tori = max(tori,square(uv, .034, .022, -0.198, .11, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,square(uv, .034, .022, -0.198, .22, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,square(uv, .034, .022, 0.198, .11, 0., blur, vec3(1,.6,.4)));\n    tori = max(tori,square(uv, .034, .022, 0.198, .22, 0., blur, vec3(1,.6,.4)));\n    tori = max(square(uv, .034, .04, -0.205, -.21, 0., blur, vec3(.5)),tori-square(uv, .034, .04, -0.205, -.21, 0., blur, vec3(.5)));\n    tori = max(square(uv, .034, .04, 0.205, -.21, 0., blur, vec3(.5)),tori-square(uv, .034, .04, 0.205, -.21, 0., blur, vec3(.5)));\n    col = max(col,tori);\n    \n    //sun\n    vec3 sun = circle (uv-vec2(.0,.405), .04, blur, vec3(1));\n    sun = max(sun, circle (uv-vec2(.0,.405), .06, blur, vec3(1,.5,.5)));\n    col = max(col, sun);\n    // Output to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [100, 100, 179, 179, 293], [294, 294, 349, 349, 426], [427, 427, 525, 525, 736], [737, 737, 837, 837, 1116], [1117, 1117, 1215, 1215, 1408], [1409, 1409, 1498, 1498, 1966], [1967, 1967, 2024, 2074, 8108]], "test": "untested"}
{"id": "wlycRR", "name": "Human Batteries", "author": "dean_the_coder", "description": "The human body generates more bio electricity than a 120 volt battery and over 25000 BTUs of body heat.\nCombined with a form of fusion the machines had found all the energy they would ever need.\n  - The Matrix (1999)", "tags": ["3d", "raymarching", "matrix", "movie", "cineshader"], "likes": 43, "viewed": 13732, "published": 3, "date": "1610315802", "time_retrieved": "2024-07-30T19:45:51.645750", "image_code": "// 'Human Batteries' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/wlycRR\n//\n// \"The human body generates more bio electricity than a\n//  120 volt battery and over 25000 BTUs of body heat.\n//  Combined with a form of fusion the machines had found\n//  all the energy they would ever need.\"\n//   - The Matrix (1999)\n//\n// Tricks to get the performance:\n//   - There's only one 'pod'.\n//\t The others are all cloned by folding space and\n//\t mirroring the axis.\n//   - There's only one column.\n//\t Again, mirroring the axis x/z axis creates more.\n//   - Only two lighting bolts.\n//\t Axis mirroring again...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 80.0\n#define MAX_STEPS\t\t 100.0\n#define SHADOW_STEPS\t 20.0\n#define MAX_SHADOW_DIST  10.0\n#define BODY_STEPS\t     30.0\n#define MAX_BODY_DIST    1.7\n\nfloat T; // Global time.\nvec2 g = vec2(0); // Glow for lightning and pods.\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id;  // Material ID.\n\tvec3 uv; // Ray position.\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\n#define HASH  p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec2 hash22(vec2 p) { HASH }\nvec4 hash44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n)\n{\n\tfloat angle = 3.141 / n,\n\t\t  a = mod(atan(p.y, p.x), 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdPod(vec3 p) {\n\t// Pod.\n\tfloat d = exp(-p.x * .6) * .3 - .07 * p.x * sin(4.7 * p.x) + .06, d2;\n\tHit h = Hit(sdCapsule(p, 1.5, d), 3, p);\n\n\t// The end bit.\n\td2 = sdBox(p - vec3(1.6, 0, 0), vec3(.05)) - .03;\n\n\t// Feeding pipes.\n\td2 = min(min(d2, sdTorus(p + vec3(.6, 0, 0), vec2(.8, .05))),\n\t\t\t sdTorus(p.xzy + vec3(1.75, 0, 0), vec2(2, .1)));\n\n\t// Pod 'cage'.\n\tp.yz = abs(p.yz);\n\tp.y -= d * .5;\n\tp.z -= d;\n\td = sdCapsule(p, 1.65, .03 + abs(sin(p.x * 30.)) * .005);\n\tminH(h, Hit(min(d2, d) * .9, 2, p));\n\n\tg.y += .0001 / (.2 + d * d);\n\n\treturn h;\n}\n\nfloat sdBody(vec3 p) {\n\t// Map world to pod point.\n\tp.xz = opModPolar(abs(p.xz) - 20., 60.);\n\tp.y = mod(p.y, 3.) - 1.5;\n\tp.x -= 12.1;\n\n\t// Head\n\tfloat d = length(p) - .07;\n\n\t// Torso\n\tp.z = abs(p.z);\n\tp.x -= .1;\n\tp.xy *= rot(-.2);\n\td = smin(d, sdCapsule(p, .3, p.x * .09 + .02), .1);\n\n\t// Legs\n\tp.x -= .35;\n\tp.z -= .06;\n\tp.xy *= rot(.3);\n\tp.xz *= rot(.15);\n\treturn smin(d, sdCapsule(p, .5, .01), .2);\n}\n\nfloat sdBolts(vec3 p, float i) {\n\tp = mix(p, p.zyx, step(12., p.x));\n\n\tfloat d, t = T + sign(p.z) + i,\n\t\t  r = n21(vec2(t, i * .2)) - .5;\n\n\tp.x += 10.;\n\tp.y += mod(70. - t * 10. * i, 70.) - 18.\n\t\t   + n21(vec2(p.x, t * 15.2 + i)) * 2.;\n\n\tp.z = abs(p.z) - 24. - r * 5.;\n\n\tp.xy *= rot(r);\n\tp.xz *= rot((i - 1.) * .5);\n\n\td = sdCapsule(p, 20., .01);\n\tg.x += .01 / (.01 + d * d);\n\n\treturn d * .6;\n}\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Lightning.\n\t// We only render two bolts - The others\n\t// are added using axis reflection.\n\tHit h = Hit(min(sdBolts(p, 1.), sdBolts(p, .4)), 6, p);\n\n\t// Main cylinders.\n\t// Only one created - We use axis reflection again.\n\tp.xz = abs(p.xz) - 20.;\n\tminH(h, Hit(length(p.xz) - 12. + sin(p.y * 2.09 + 4.7) * .2, 1, p));\n\n\t// Pods.\n\t// Again, only one is ever rendered!\n\tp.xz = opModPolar(p.xz, 60.);\n\tp.x -= 11.8;\n\tp.y = mod(p.y, 3.) - 1.5;\n\tminH(h, sdPod(p));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .5;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = 0.; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .01 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// March through the pod - Basically the same as a shadow.\nfloat bodyTint(vec3 p, vec3 rd) {\n\tfloat s = 1.;\n\tconst float stp = MAX_BODY_DIST / BODY_STEPS;\n\tfor (float t = 0.; t < MAX_BODY_DIST; t += stp)\n\t{\n\t\tfloat h = sdBody(p + rd * t);\n\t\ts = min(s, 20. * h / t);\n\t\tif (s < .01) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\n// Sub-surface scattering. (Thanks Evvvvil)\nfloat sss(vec3 p, vec3 ld, float h) { return smoothstep(0.0, 1.0, map(p + ld * h).d / h); }\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 ld = normalize(vec3(6, 3, -10) - p),\n\t\t n = calcN(p, d), c;\n\tfloat ss = 0., // Sub-surface scatter\n\t\t  sp = 10.; // Specular multiplier.\n\n\tif (h.id == 1) {\n\t\t// Column.\n\t\t// Small ridges added using a quick bump map.\n\t\tc = vec3(.01);\n\t\tn.y += (abs(sin(h.uv.y * 31.)) - .5) * .4;\n\t\tn = normalize(n);\n\t} else if (h.id == 2) {\n\t\t// Feeder Pipes.\n\t\tc = vec3(.02);\n\t\tsp = 50.; // Slightly increased specular to add 'shine'.\n\t} else if (h.id == 3) {\n\t\t// Pod pink.\n\t\tc = vec3(1, .32, .27) * smoothstep(1.55, 1.3, h.uv.x);\n\t\tc *= .2 + .8 * smoothstep(0., .2, h.uv.x);\n\n\t\t// Sub-surface scattering.\n\t\tss = sss(p, ld, .45);\n\t} else c = vec3(1);\n\n\t// Ambient occlusion.\n\tfloat ao = dot(vec2(ao(p, n, .2), ao(p, n, .5)), vec2(.1, .2)),\n\n\t// Primary light.\n\tl1 = max(0., .1 + .9 * dot(ld, n))\n\t\t * (.3 + .7 * calcShadow(p, ld)) // ...with shadow.\n\t\t * (.3 + .7 * ao), // ...and _some_ AO.\n\n\t// Secondary(/bounce) light.\n\tl2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * sp;\n\n\t// Combine into final color.\n\treturn mix((l1 + (l2 + spe) * ao + ss) * c * vec3(2, 1.6, 1.4),\n\t\t\t   vec3(.01),\n\t\t\t   fre);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c = vec3(0);\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST || d > MAX_DIST)\n\t\t\tbreak;\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\t// Stash the glow before calculating normals/etc alters it.\n\tvec2 gg = g;\n\n\tif (d < MAX_DIST) {\n\t\tc = lights(p, rd, d, h);\n\n\t\t// If we hit a pod, do a mini-march through it\n\t\t// to build a tint of the 'bodies'.\n\t\tif (h.id == 3)\n\t\t\tc *= .4 + .6 * bodyTint(p - rd, rd);\n\t}\n\n\tc *= exp(d * d * -.001);\n\n\t// Raymarch to get fog depth.\n#define FOG_STEPS      8.0\n\tfloat maxD = min(d, MAX_DIST),\n\t\t  d2 = 0.01;\n\tfor (float i = 0.; i < FOG_STEPS; i++) {\n\t\tp = ro + rd * d2;\n\t\tfloat fd = 0.7 * abs(p.y + 15.0 + 10.0 * n31(vec3(p.xz * 0.1, T * 0.1)));\n\t\tif (abs(fd) < MIN_DIST || d2 > maxD)\n\t\t\tbreak;\n\t\td2 += fd;\n\t}\n\n\t// Mix in the fog color.\n\td = smoothstep(0., 1., (min(d, MAX_DIST) - d2) / 30.);\n\tc = mix(c,\n\t\t\tvec3(.25, .3, .4),\n\t\t\td * d // Base fog.\n\t\t\t* n21(p.xz * .06) // Low frequency patches.\n\t\t\t* (.2 + .8 * n31(vec3(p.xz + T, T) * .2)) // Finer details.\n\t\t\t);\n\n\treturn c // Base color.\n\t\t   + gg.x * vec3(.4, .6, 1) // Lighting bolt glow.\n\t\t   + gg.y * vec3(1, .32, .27); // Faint pod glow.\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\tT = mod(iTime, 40.) + 1.3;\n\n\tfloat dim = 1. - abs(cos(clamp(T, -1., 1.) * 1.57)),\n\t\t  t = .5 + .5 * cos(.157 * T);\n\tt = mix(smoothstep(0., 1., t), t, t);\n\tvec3 ro = vec3(-6.5, 25. - t * 20., 21);\n\tro.xz += t * 25.;\n\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tvec3 col = march(ro, getRayDir(ro, vec3(0, -t * 10., 0), uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlycRR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1399, 1399, 1418, 1475, 1728], [1730, 1730, 1749, 1749, 1775], [1777, 1777, 1816, 1816, 1908], [1910, 1910, 1941, 1941, 1966], [1968, 1968, 1987, 1987, 2047], [2049, 2049, 2083, 2083, 2202], [2204, 2204, 2233, 2233, 2320], [2322, 2322, 2365, 2365, 2417], [2419, 2419, 2450, 2450, 2506], [2508, 2508, 2555, 2555, 2688], [2690, 2690, 2709, 2718, 3241], [3243, 3243, 3265, 3293, 3645], [3647, 3647, 3679, 3679, 4040], [4042, 4080, 4097, 4191, 4572], [4574, 4574, 4603, 4603, 4824], [4826, 4826, 4861, 4876, 5090], [5092, 5151, 5184, 5184, 5411], [5413, 5441, 5476, 5476, 5507], [5509, 5553, 5590, 5590, 5644], [5732, 5732, 5764, 5764, 5879], [5881, 5881, 5927, 5927, 7181], [7183, 7183, 7213, 7227, 8444], [8446, 8446, 8491, 8491, 8915]], "test": "untested"}
{"id": "wtGyRR", "name": "Tron Hyperspace", "author": "pmayrgundter", "description": "On a dark desert highway in the metaverse", "tags": ["fractal", "darkwave"], "likes": 1, "viewed": 335, "published": 3, "date": "1610310796", "time_retrieved": "2024-07-30T19:45:52.480518", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n  vec2 q = uv - vec2(0.5, 0.5);\n  q.xy = q.yx;\n  float p1 = 0.5;\n  float te1 = iTime/10.;\n  float te3 = te1/20.;\n  float te5 = te3/40.;\n  q.x = sin(te1) * q.x;\n  float R = sin(te1);\n  float G = cos(te1);\n  float B = sin(q.x)/cos(q.y);\n  vec3 col = p1 * vec3(R, G, B);\n  float fC = sin(te1);\n  float f1 = fC * sin(q.x/q.y);\n  float pulse = sin(\n    (cos(te1) * cos(te5))\n    /(f1 * sin(te3) * cos(te3)));\n  vec2 tig = vec2(sin(te1), cos(te3));\n  //opt1:\n  tig *= tig;\n  vec2 squig = vec2(sin(pulse), cos(pulse));\n  //opt2:\n  squig *= squig;\n  col *= 0.2 / length(q * tig * squig);\n  // Mix in sound\n  vec2 sound = texture( iChannel1, vec2(0.1,0.3) ).xy;\n  col.x *= sound.x;\n  col.y *= sound.y;\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtGyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 103, 887]], "test": "untested"}
{"id": "3lyczz", "name": "Euler number calculator", "author": "IWBTShyGuy", "description": "If you draw a picture on the screen by dragging, calculate the Euler number of your picture in real time!!", "tags": ["eulernumber"], "likes": 2, "viewed": 314, "published": 3, "date": "1610308282", "time_retrieved": "2024-07-30T19:45:53.259435", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n\n// Euler Number Calculator\n//\n// Calculates the Euler number of the area drawn in black.\n//\n// If you draw discrete points, the Euler number is the number of points.\n// If a loop is constructed, the Euler number is decreased.\n//\n// Since the screen is considered a torus, drawing a line directly\n// across or vertically will result in an Euler number of zero.\n// (Perhaps, the edges of the screen are not well processed.)\n//\n// How to Use:\n// - Dragging: draw black pixels \n// - Shift + Dragging: erase black pixels\n// - R: clear buffer\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PIXEL_SIZE = 4.0;\n\n// If the resolution is very large, this value should also be large.\nconst int LINE_THICK = 3;", "buffer_a_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\nbool isKeyPressed(int code) {\n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.0;\n}\n\nbool isKeyDown(int code) {\n    return texelFetch(iChannel1, ivec2(code, 0), 0).x > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0 || isKeyPressed(82)) {\n        fragColor = vec4(1);\n        return;\n    }\n    ivec2 uv = ivec2(fragCoord / PIXEL_SIZE);\n    ivec2 mouse = ivec2(iMouse.xy / PIXEL_SIZE);\n    if (iMouse.z > 0.0 && max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) < LINE_THICK) {\n        fragColor = isKeyDown(16) ? vec4(1) : vec4(0, 0, 0, 1);\n    } else {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\nfloat clamped(float x, float a, float b) {\n    return clamp(floor(x - a + 1.0), 0.0, 1.0) * clamp(floor(b - x + 1.0), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 resolution = ivec2(iResolution.xy / PIXEL_SIZE);\n    vec2 uv = fragCoord / iResolution.xy;\n    float du = PIXEL_SIZE / iResolution.x;\n    float dv = PIXEL_SIZE / iResolution.y;\n    if (uv.x > 0.1) fragColor = vec4(0);\n    else if (iFrame % 3 == 0) {\n        // x: vertices, y: edges, z: faces\n        ivec4 counter = ivec4(0);\n        for(int i = 0; i < resolution.x; i++) {\n            float x = (float(i) + 0.5) * PIXEL_SIZE / iResolution.x;\n            int vertex = int(1.0 - texture(iChannel0, vec2(x, uv.y)).x + 0.1);\n            counter.x += vertex;\n            int edges = int(1.0 - texture(iChannel0, vec2(x + du, uv.y)).x + 0.1);\n            edges += int(1.0 - texture(iChannel0, vec2(x, uv.y + dv)).x + 0.1);\n            counter.y += vertex * edges;\n            int faces = vertex * int(clamped(float(edges), 1.5, 2.5));\n            faces *= int(1.0 - texture(iChannel0, vec2(x + du, uv.y + dv)).x + 0.1);\n            counter.z += faces;\n        }\n        fragColor = vec4(counter);\n    } else if (iFrame % 3 == 1) {\n        ivec4 counter = ivec4(0);\n        for (int i = 0; i < resolution.y; i++) {\n            float y = (float(i) + 0.5) * PIXEL_SIZE / iResolution.y;\n            counter += ivec4(texture(iChannel1, vec2(0.05, y)) + 0.1);\n        }\n        fragColor = vec4(counter);\n    } else {\n        fragColor = texture(iChannel1, vec2(0.05, 0.5));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// The MIT License\n// Copyright  2021 IWBTShyGuy\n\nfloat letter(in vec2 uv, in int idx) {\n    uv = clamp(uv, 0.0, 1.0);\n    int i = idx % 16;\n    int j = 15 - idx / 16;\n    vec2 origin = vec2(float(i) / 16.0, float(j) / 16.0);\n    uv = (uv / 16.0 + origin);\n    float r = texture(iChannel2, uv).x;\n    return floor(r + 0.5);\n}\n\nfloat figure(in vec2 uv, in int number) {\n    float size = 0.5;\n    int a = sign(sign(number) + 1);\n    a = a * 32 + (1 - a) * 45;\n    number *= sign(number);\n    int b = (number % 1000) / 100;\n    int c = (number % 100) / 10;\n    int d = number % 10;\n    float irr0 = letter((uv - 0.5 + vec2(0.3, 0)) / size + 0.5, a);\n    float irr1 = letter((uv - 0.5 + vec2(0.1, 0)) / size + 0.5 , 48 + b);\n    float irr2 = letter((uv - 0.5 - vec2(0.1, 0)) / size + 0.5 , 48 + c);\n    float irr3 = letter((uv - 0.5 - vec2(0.3, 0)) / size + 0.5, 48 + d);\n    return max(max(max(irr0, irr1), irr2), irr3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float supx = 1.0 - 0.2 * iResolution.y / iResolution.x;\n    if (uv.x < supx || uv.y > 0.2) {\n        fragColor = texture(iChannel0, uv);\n    } else if (iFrame % 3 == 2) {\n        // We need to multiply by 10 here. It's very strange...\n        vec4 counter = vec4(texture(iChannel1, vec2(0.05, 0.5)));\n        int calc = int(counter.x - counter.y + counter.z);\n        float digit = figure((uv - vec2(supx, 0.0)) / vec2((1.0 - supx), 0.2), calc);\n        fragColor = vec4(digit, digit, digit, 1.0);\n    } else {\n        fragColor = texture(iChannel3, uv);\n    }\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyczz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]], "test": "untested"}
{"id": "WlGyzR", "name": "remap() isInside() ceil(min())", "author": "ollj", "description": "drag a rectangle from bottomLeft to TopRight (or else it will be dithered)\n\noutsideOpen()\ninsideClosed()\nreturn if u is in a 2d interval, without any <> , mix() , step()\n\nceil(min())  or sign(min()), replace all if(a>b) checks", "tags": ["branchless", "tonemap", "isinside", "remap", "caseless"], "likes": 4, "viewed": 571, "published": 3, "date": "1610294717", "time_retrieved": "2024-07-30T19:45:54.094204", "image_code": "#define iM iMouse\n#define iR iResolution\n\n#define vec1 float\n\n//code of this shader merges map()==remap() and tonemap() by calling a shared subroutine mapu()\n//without using or showing ANY of that.\n//the remap() function is not used by this shader.\n//the toemap() function is not used by this shader.\n//i just wanted to store this memo-code in a tiny unrelated shader to load fast.\n//\n//map() use case:\n//whenever a shader buffers screenspace coords\n//, and you want to translate between different resolutions\n//, you may need map()=remap()\n//\n//this shader shows more in terms of simplicity\n\n/*\n//for example:\n//ou buffer [previous] resolution=get(BufferAddressOfPreviousResolution)\n//You want to rescale to a current iResolution.xy (for incremental Averaging (within TemporalReprojection))\n//And You want to rescale from and to a normalized Uv coord.\n//\n//for example, you want to pixelate the resolution of your scene by any percentage, by remapping to a lower resolution.\n\n//We have 3  different domains, and a var with the same RELATIVE point in them.\nfragCoordNow___domain=[    vec2( 0),iResolution.xy]\nfragCoordPrev__domain=[    vec2( 0),   previous.xy] previous.xy=iResolution.xy, but buffered in prefious frame, and read 1 frame later.\n       uv______domain=[-aspectRatio,aspectRatio.xy] aspectRatio.xy=vec2(1,iResolution.y/iResolution.x) (or was it its inverse?)\n\n//\n//We can use map() translate between these 3 domains:\nvec2 uv           =map(fragCoordNow  ,        vec2( 0),iResolution.xy , -aspectRatio.xy,aspectRatio.xy) //==frame(uvNow)\nvec2 uv           =map(fragCoordPrev ,        vec2( 0),    revious.xy , -aspectRatio.xy,aspectRatio.xy)\n//\nvec2 fragCoordNow =map(fragCoordPrev ,        vec2( 0),   previous.xy , vec2(0),iResolution.xy)\nvec2 fragCoordNow =map(uv            , -aspectRatio.xy,aspectRatio.xy , vec2(0),iResolution.xy)\n//\nvec2 fragCoordPrev=map(uv            , -aspectRatio.xy,aspectRatio.xy , vec2(0),previous.xy)\nvec2 fragCoordPrev=map(fragCoordNow  ,        vec2( 0),iResolution.xy , vec2(0),previous.xy)\n*/\n\n//https://www.shadertoy.com/view/WlGyzR\n//defines are used to do vec2 vec3 vec4 inputs in parallel (and also, because a special case is a subroutine here (kinda strange))\n//mapu() == (unholy core) union of tonemap() and map()remap() \n#define mapu(a,b,c,d,e) (a)*(b)/((c)+(d)*(e))\n//\n//map() returns [x] of domain[a,b] (current resolution) remap()ped to domain [c,d] (previous resolution), as if a=c && b=d;transform [a,b]->[c,d], (to remap/reproject from current to previous resolution for incremental averaging buffers)\n#define map(x,a,b,c,d) mapu(x,1.,0.,a+d-(b)-(c))+(c)\n\n//common special vases of the above general cases are:\n\n//common quadratic gamma correction tonemap:\nvec3 tonemap(vec3 x){return mapu(x,2.51*x+.06,.14,x,.59+2.43*x);}\n\n//common special case remap() \n//return [x] of domain[a,b] remap()ped to domain [0,1], as if a=0 && b=1;transform [a,b]->[0,1] == remap(x,a,b,0.,1.) \n//as in smoothstep(a,b,x) https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\n#define maps(x,a,b) (x-(a))/(b-(a))\n//#define map(x,a,b,c,d) (maps(x,a,b)*(d-(c))+c) //convoluted alternative\n\n//map(), but [ d == -c ] \n//to translate from Min&&maxBoundaries to Center&&width\n#define mapm(x,a,b,d) (maps(x,a,b)*(d+d)-(d))\n//map(), but [ b == -a ] \n//to translate from Center&&width to Min&&maxBoundaries\n#define mapc(x,b,c,d) mapu(x,1.,0.,a+a+d-(c))+(c)\n\n\n//remap u.x and u.y (==fragCoord.xy) to [-1,1]*s (also unsquashing aspectRatio)\nvec2 frame(vec2 u,vec2  s){s*=vec2(iR.x/iR.y,1);return mapm(u,vec2(0),iR.xy,s);}\nvec2 frame(vec2 u,float s){return frame(u,vec2(s));} // [0,iR.xy] -> [-1,1]\nvec2 frame(vec2 u        ){return frame(u,1.);}//default zoom is 1.\n//frame(u) is identical to: {u=u/iR.xy;u=u*2.-1.;u.x*=iR.x/iR.y;return u;}\n\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec4 a){return min(mi(a.xy),mi(a.zw));}\n//#define ma(a) (-(mi(-(a))))\n\n//float box(vec2 u,vec2 w,vec2 v){return ma(abs(u-w)-v);}\n//i can use box() within outsideOpen(), but its too convoluted and only half as precise.\n/*\nfloat box(vec2 u,vec2 w){return ma(abs(u-w));}\n//extended box function, to use within outsideOpen()\nfloat outsideOpen  (vec2 u,vec4 l){\n ;vec2 w=((l.zw-l.xy)*.5)//halfWidth\n ;return -sign(min(box(l.xy+w,u,w),0.))\n ;return ceil(mi((l-u.xyxy)*S.xxzz))//this line is identical to all of ther above\n ;}\n */\n\nconst vec4 S=vec4(-1,0,1,2);\n//isInside  is a  CLOSED interval 2d box\n//isOutside is an OPEN   interval 2d box\nfloat outsideOpen  (vec2 u,vec4 l){return ceil( mi((l-u.xyxy)*S.xxzz));}\nfloat  insideClosed(vec2 u,vec4 l){return ceil(-mi((l-u.xyxy)*S.xxzz));}\nfloat outsideOpen  (vec2 u,vec2 bl,vec2 tr){return  outsideOpen(u,vec4(bl,tr));}\nfloat  insideClosed(vec2 u,vec2 bl,vec2 tr){return insideClosed(u,vec4(bl,tr));}\n\nvoid frameSort(inout vec2 a,inout vec2 b//bottomLeft,topRight (as they SHOULD become)\n){vec2 c=vec2(min(a.x,b.x),min(a.y,b.y))\n      ;b=vec2(max(a.x,b.x),max(a.y,b.y));a=c;}\n\n\nfloat dither(vec2 u){return mod(u.x+u.y,2.);}\n\nvoid mainImage( out vec4 o,vec2 u \n){\n ;float d=dither(u)\n ;vec2 bottomLeft \n ;vec2    topRight\n ;\n ;if(iMouse.z<=0.\n ){bottomLeft =vec2(-1,-1)*.5 //overwrite to check for interval type\n  ;topRight   =vec2( 1, 1)*.5 //overwrite to check for interval type\n ;}else{\n  ;bottomLeft=frame(abs(iM.zw))\n  ;topRight  =frame(iM.xy) \n  ;if(d>0.\n  )frameSort(bottomLeft,topRight)//optionally sort (condition is dither())\n ;}\n ;u=frame(u)\n ;if(length(u)<.01){o=vec4(0);return;}\n ;float b= outsideOpen  (vec2(0),bottomLeft,topRight)\n ;float ic= insideClosed(      u,bottomLeft,topRight)\n ;float oo=outsideOpen  (      u,bottomLeft,topRight)\n ;o=vec4(b,ic,oo,1);}\n\n/*\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{\n    if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlGyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2677, 2722, 2743, 2743, 2787], [3413, 3493, 3520, 3520, 3573], [3574, 3574, 3601, 3601, 3626], [3627, 3650, 3677, 3677, 3697], [3794, 3794, 3811, 3811, 3832], [3833, 3833, 3850, 3850, 3881], [4396, 4478, 4513, 4513, 4550], [4551, 4551, 4586, 4586, 4623], [4624, 4624, 4668, 4668, 4704], [4705, 4705, 4749, 4749, 4785], [4787, 4787, 4875, 4875, 4960], [4963, 4963, 4984, 4984, 5008], [5010, 5010, 5047, 5047, 5659]], "test": "untested"}
{"id": "tttcWl", "name": "Glossy Raymarching", "author": "Zi7ar21", "description": "Looking mega poggers. Takes a SDF in Buffer A.", "tags": ["fractal", "julia", "raymarch", "glossy"], "likes": 21, "viewed": 759, "published": 3, "date": "1610264490", "time_retrieved": "2024-07-30T19:45:54.988812", "image_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// Common contains settings and common functions like Michael0884's RNG and constants like Pi.\n// Buffer A contains rendering and Temporal Sampling from LoicVDB.\n// Buffer B contains the other half of Temporal Sampling along with Image Export.\n// This is for drawing the shader.\n\n// Zi7ar21's Glossy Raymarching --- January 10th, 2020\n// Last modified January 10th, 2020 16:00 Mountain Time\n\n// This shader raymarches a 4D Julia fractal and uses normals to calculate\n// the reflection of a cubemap in iChannel0 of Buffer A.\n\n// Output to screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains rendering and Temporal Sampling from LoicVDB.\n\n// Julia set distance estimator taken from:\n// https://github.com/JPBotelho/Raymarched-Fractals/blob/master/Content/DistanceFunc.cginc\nvec4 qsqr(vec4 a){return vec4(a.x*a.x-a.y*a.y-a.z*a.z-a.w*a.w, 2.0*a.x*a.y, 2.0*a.x*a.z, 2.0*a.x*a.w);}\nfloat distanceestimator(vec3 pos){\n\tvec4 z = vec4(pos, 0.0);\n    float md2 = 1.0;\n    float mz2 = dot(z, z);\n    for(int i = 0; i < 16; i++){\n        md2 *= 4.0*mz2;\n        z = qsqr(z)+vec4(-0.5, 0.5, 0.25, 0.0);\n        mz2 = dot(z,z);\n        if(mz2 > 4.0) break;}\n    return 0.25*sqrt(mz2/md2)*log(mz2);}\n\n/*float distanceestimator(vec3 rayposition){\n    return distance(rayposition, vec3(0.0))-0.5;\n}*/\n\n/*\nfloat smin(float x, float y, float w){\n    float h = max(w-abs(x-y), 0.0)/w;\n    return min(x, y)-h*h*h*w*(1.0/6.0);\n}\n\nfloat distanceestimator(vec3 rayposition){\n  vec2 circle = vec2(length(rayposition.xy)-0.25, rayposition.z);\n  float torus = length(circle)-0.125;\n  float sphere = distance(rayposition, vec3(0.35, 0.0, 0.0))-0.25;\n  return smin(torus, sphere, 0.1);\n}*/\n\n\nvec4 raymarch(vec3 raydirection, vec3 startingposition){\n    float distancetravelled;\n    float scenedistance;\n    vec3 rayposition = startingposition;\n    for(int i = 0; i < maximummarches; i++){\n        scenedistance = distanceestimator(rayposition);\n        rayposition += raydirection*scenedistance;\n        distancetravelled = distance(startingposition, rayposition);\n        if(scenedistance < collisiondistance){return vec4(rayposition, distancetravelled);}\n        if(distancetravelled > maximumdistance){break;}\n    }\n    return vec4(-1.0);\n}\n\n// Calculate Normals \nvec3 calcNormal(vec3 position){\n    float accuracy = collisiondistance;\n    vec2 normaldirection = vec2(accuracy, 0.0);\n    return normalize(vec3(distanceestimator(position+normaldirection.xyy)-distanceestimator(position-normaldirection.xyy),\n                          distanceestimator(position+normaldirection.yxy)-distanceestimator(position-normaldirection.yxy),\n                          distanceestimator(position+normaldirection.yyx)-distanceestimator(position-normaldirection.yyx)));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB's Enhanced Temporal Sampling\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = oldFragColor;\n    if(iMouse.z > 0.0){fragColor = vec4(0.0);}\n\n    // Initalize Random Number Generator\n    INIT_RNG;\n\n    // Normalized Pixel Coordinates, the center of screen being 0.0, 0.0\n    vec2 uv = ((fragCoord+nrand2(0.5, vec2(0.0)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // World Coordinates (The rotation can be replaced with a more proper rotation matrix)\n    vec2 rot = vec2(0.0, 0.0);\n    mat3 rotation = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 raydirection = normalize(vec3(camerafov*(uv.x*rotation[0]+uv.y*rotation[1])+rotation[2]));\n    vec2 M = -3.14*(iMouse.xy*2.0/iResolution.xy-1.0);\n    rot3(raydirection, M.x, M.y);\n    vec3 pathposition = cameraposition;\n    rot3(pathposition, M.x, M.y);\n    vec4 raymarched = raymarch(raydirection, pathposition);\n    if(raymarched.w < -0.9){fragColor += vec4(texture(iChannel0, raydirection).rgb, 1.0); return;}\n    vec3 normal = calcNormal(raymarched.xyz);\n    vec3 reflection = reflect(raydirection, normal);\n    fragColor += vec4(texture(iChannel0, reflection).rgb, 1.0);\n    for(int i = 0; i < maxbounces; i++){\n        raymarched = raymarch(reflection, raymarched.xyz+reflection*collisiondistance);\n        if(raymarched.w < -0.9){fragColor += vec4(texture(iChannel0, reflection).rgb, 1.0); return;}\n        normal = calcNormal(raymarched.xyz);\n        reflection = reflect(reflection, normal);\n    }\n\n    fragColor += vec4(texture(iChannel0, reflection).rgb, 1.0);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains the other half of Temporal Sampling along with Image Export.\n// Click on the Image icon in the bottom right of the editor\n// to export a Full Precision 32-Bit Floating Point EXR.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    // Output Buffer\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This contains settings and common functions like Michael0884's RNG and constants like Pi.\n\n// Change these parameters to your liking!\n\n// Maximum Marches, more allows you to use smaller collision distances.\n#define maximummarches 512\n// Collision Distance, a smaller value requires more marches but is also more precise.\n#define collisiondistance 0.00001\n// Maximum Distance, limit this to the furthest point in your scene to prevent unnecessary marching.\n#define maximumdistance 8.0\n// Position of the virtual Camera.\n#define cameraposition vec3(0.0, 0.0, -4.0)\n// Field of View of the virtual Camera.\n#define camerafov 1.0\n\n#define maxbounces 4\n\n#define rot(a) mat2(cos(a+vec4(0, 11, 33, 0)))\n#define rot3(V, a, b) V.zx *= rot(a), V.zy *= rot(b)\n\n// Pi is used for doing math with Radians where the Trigonometric functions are used, there is no point\n// in changing this. Full precsion floating point numbers can represent pi as 3.14159265, but it can't hurt\n// to add a few more digits in the case Shadertoy supports double precision in the future.\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\n\n// https://www.pcg-random.org/\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}\n\n// Keyboard Controls from yet another one of Michael0884's Shaders https://www.shadertoy.com/view/wttyDX\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 609, 663, 663, 725]], "test": "untested"}
{"id": "ttdcDl", "name": "Cheaper Cloud Flythrough", "author": "jarble", "description": "This is an even cheaper version of Shane's [url=https://www.shadertoy.com/view/Xsc3R4]\"Cheap Cloud Flythrough.\"[/url] I removed the hash function, but it still looks almost identical to the original version.", "tags": ["noise", "cloud", "volumetric", "sinusoidal", "flythrough"], "likes": 17, "viewed": 978, "published": 3, "date": "1610247303", "time_retrieved": "2024-07-30T19:45:55.750774", "image_code": "/*\n\n\tCheap Cloud Flythrough \n\t----------------------\n\t\n\t\"Cheap\" should probably refer to the quality of the physics in this shader, which is\n\tvirtually non-existent, but it actually refers to the fake cloud algorithm... if you could \n\tcall it that. :)\n\t\n\tThis is merely an attempt to give the impression of a cloud flythrough, whilst maintaining\t\n\ta reasonably acceptable framerate. The key to that is keeping the distance field as simple \n\tas possible.\n\n\tDue to the amount of cost cutting, it's far from  perfect. However, there's still plenty \n\tof room for improvement.\n\n    I've used density based accumulation, which in one way or another, uses concepts from many \n\tvolumetric examples, but particularly from the following:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n    \n    Other shaders worth looking at:\n\n\tClouds - IQ: One of my favorite shaders, and everyone elses, it seems.\n\thttps://www.shadertoy.com/view/XslGRr\n\t\t\n\tSample Pinning - huwb: Fast, and pretty.\n\thttps://www.shadertoy.com/view/XdfXzn\n\t\n\tFakeVolumetricClouds - Kuvkar: Fast, using parallax layers. Really cool.\n\thttps://www.shadertoy.com/view/XlsXzN\n\n    Emission clouds - Duke: Nice, and straight forward.\n    https://www.shadertoy.com/view/ltBXDm\n\n\n*/\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat pn( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = pn(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\n// Distance function.\nfloat map(vec3 p) {\n\n    return trigNoise3D(p*0.5);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n\n\n    //if (length(iMouse.xy) > 40.0) {\n        rd.xz *= rot(-3.14+iMouse.x/iResolution.x*3.14*2.0);\n        rd.yz *= rot(-3.14*0.5+iMouse.y/iResolution.y*3.14);\n    //}\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, iTime*4.);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + iTime*0.1875);\n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    rd.xz = rd.xz*rM;\n\n\n\n    // Placing a light in front of the viewer and up a little, then rotating it in sync\n    // with the camera. I guess a light beam from a flying vehicle would do this.\n    vec3 lp = vec3( 0, 1, 4);\n    lp.xy = lp.xy*rM;\n    lp.xz = lp.xz*rM;\n    lp += ro;\n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + ((rd.zyx)*.006 - .003)); \n    // Randomizing the length also. \n    rd *= (1. + fract((dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.06-0.03);      \n    \n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.01*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d)*step(d, h); \n        w = (1. - td)*lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./64.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), .001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*.125 + lDist*lDist*.05);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations. Note the \"d*3. - .1\" term. It's there as a bit\n        // of a fudge to make the clouds a bit more shadowy.\n        col += w*(d*3. - .1)*(.5 + diff + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += .2; // t += d*.5;// These also work, but don't seem as efficient.\n\n    }\n\n    col = max(col, 0.);\n\n    // trigNoise3D(rd*1.)\n    col = mix(pow(vec3(1.5, 1, 1)*col,  vec3(1, 2, 8)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.35 + .65);\n    col = mix(col.zyx, col, dot(cos(rd*9. +sin(rd.yzx*9.)), vec3(.333))*.15 + .85);//xzy\n    \n\n    //col = mix(col.zyx, col, dot(rd, vec3(.5))+.5);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1370, 1716, 1738, 1738, 1906], [1910, 2058, 2087, 2087, 2899], [2901, 2923, 2942, 2942, 3113], [3181, 3181, 3238, 3448, 8898]], "test": "untested"}
{"id": "ttdyDl", "name": "RepVolQuat", "author": "ollj", "description": "move= ESDF             +TG (=up down)   \nrotate= arrows/mouse +WR(roll)\nplaceLight = P+L\n\nshortened version of\nhttps://www.shadertoy.com/view/wl3yDs", "tags": ["fractal", "cloud", "globalillumination", "volumetric", "pathtracing", "importance", "pcg", "quaternioncamera", "crepustularity", "warpspeed"], "likes": 14, "viewed": 616, "published": 3, "date": "1610238322", "time_retrieved": "2024-07-30T19:45:56.707217", "image_code": "//Volumetric fractal explorer \n\n//parent               : https://www.shadertoy.com/view/ttdyDl\n//grandparent (voluRep): https://www.shadertoy.com/view/wttyDX\n//grandparent (Quatcam): https://www.shadertoy.com/view/wtdyRs\n//older       (Quatcam): https://www.shadertoy.com/view/4tSyRz\n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scattering\n//Multibounce scattering\n//Approximate volumetric reprojection for temporal denoising\n//quaternion camera movement with inertia and collision option\nvoid mainImage(out vec4 c,vec2 p\n){\n ;//p-=1.\n ;//p=(p-iResolution.xy/2.)*2.\n ;c=texture(iChannel0,p/iR.xy)\n ;//p=abs(p)\n ;//c=texture(iChannel0,tHammerI(p))\n ;c=1.07*tanh(pow(c/c.w,vec4(.6))) ;}//essential gamma\n \n//MIT License\n//Copyright 2020 Mykhailo Moroz\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//assume as \"Do whatever you want\" License", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n\n#define camType 1\n\n//its not just broken during rotation\n//, there are just-as-broken ghost-images during straving\n\n\nconst vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\nconst float\n //set to -100. to skip collisions\n //=.01 is reasonable for the mandelbulb distanceField\n PHYSICS_RADIUS=-100.\n,LIN_ACCE=5.*.5//linear accelleration\n,ANG_ACCE=5.*2.//angular accelleration\n,LIN_DRAG=5.*1.//linear drag\n,ANG_DRAG=5.*2.//angular drag\n;\n\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n\n//specific buffereB Addresses\nconst float \n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera angle    (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera angle    (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera angle    of previous frame\n,li2P0 =8.//light0 position\n,li3P0 =9.//light1 position\n,NBuffB=8.//max address count\n;\n#define tf(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n\nconst float tau=acos(-1.)*2.// 1/1 rotation in radians\n,pi=acos(-1.)               // 1/2 rotation in radians\n,pi2=acos(0.)               // 1/4 rotation in radians\n//,pi4=acos(0.)*.5            // 1/8 rotation in radians\n;\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec1 mav(vec2 a){return max(a.x,a.y);}\nvec1 mav(vec3 a){return max(mav(a.xy),a.z);}\nvec3 ma0(vec3 a){return max(a,0.);}\nvec1 mu(vec2 a){return a.x*a.y;}\nvec1 mu(vec3 a){return a.x*a.y*a.z;}\nvec1 su(vec2 a){return a.x-a.y;}\nvec1 su(vec3 a){return a.x+a.y-a.z;}\nvec1 ad(vec2 a){return a.x+a.y;}\nvec1 ad(vec3 a){return a.x+a.y+a.z;}\n\n//internal RNG state \nuvec4 s0,s1;\nivec2 pixel;\n\nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\n\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n\nfloat rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\nvec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\n\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\n\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec2 c=cos(r),s=sin(r)\n ;return vec3(c.x*s.y,s.x*s.y,c.y);}\n\nfloat HenyeyGreenstein(float g,float c//g,costh\n){return (4.*pi*pow(1.0+g*g-2.0*g*c,3./2.))/(1.-g*g);}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b;return length(ma0(q))+min(mav(q),0.);}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n \n//from https://www.shadertoy.com/view/XsSXDy\nvec4 pwS(float x){return vec4(x*x*x,x*x,x,1.0);}\n\nvec4 spline(float x,vec4 a,vec4 b,vec4 c,vec4 d\n){const vec4 ca=vec4( 3,-5, 0,2)/2.\n ;const vec4 cb=vec4(-1, 5,-8,4)/2.\n ;return a*dot(cb,pwS(1.+x))\n        +b*dot(ca,pwS(   x))\n        +c*dot(ca,pwS(1.-x))\n        +d*dot(cb,pwS(2.-x));}\n//We could expand the powers and build a matrix instead (twice as many coefficients\n//would need to be stored,but it could be faster.\n\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance , o.yzw=orbittrap\n//w.xyz=uv     ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break;mandelCore(o,w,u);}\n ;o.x=.25*log(w.w)*sqrt(w.w)/o.x;return o;}\n\nvec1 mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break;mandelCore(o,w,u);}\n ;return .25*log(w.w)*sqrt(w.w)/o.x;}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\n/*\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}*/\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\nvec1 df (vec3 u){u=repeat(u);return mandelBulb (u);}\nvec4 dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\nvec3 normal(in vec3 p\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/length(a)/length(b));}\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q){return q/dd(q);}//return normalize(q);}\n//\n// quaternion & vectors\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b// http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\n//vec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\n//vec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\n//vec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n//---end__ quaternion\n\n\n//https://www.shadertoy.com/view/ldjyRK\nconst float s2=sqrt(2.);\nvec2 scm(float a){return sin(vec2(a,a+pi2));}//NOT a rotation, but a reflection at a halfRotated axis.\nvec2 sc(float a){return scm(a);//lazy override\n return vec2(sin(a),cos(a)); ;}//actual reflection\n//Hammer.transform:\nvec2 tHammer(vec2 p){\n vec2 s=sc(p.y),o=sc(p.y*.5);\n return s2*vec2(2.*s.y*o.x,s.x)/sqrt(1.+s.y*o.y);}\n//Hammer.transform.Inverse\nvec2 tHammerI(vec2 p){float z=1.-(p.x*p.x/16.)-(p.y*p.y/4.);\n if(z<0.)discard;float s=sqrt(z);\n return vec2(2.*atan((s*p.x),(2.*(2.*z-1.))),asin(s*p.y));}\n \n//scale: (-0.5.-0.5) x (0.5..0.5) -> (l[0]..l[1]) x (l[2]..l[3])\nvec2 scale(vec2 p, vec4 l){\n return (p+vec2(.5))*vec2(l[1]-l[0],l[3]-l[2])+vec2(l[0],l[2]);}\n//scale.inverse p=scale1(scale_forward(p));\nvec2 scale1(vec2 p, vec4 l){\n return (p-vec2(l[0],l[2]))/vec2(l[1]-l[0], l[3]-l[2])-vec2(.5);}\n\nvec2 hammerScale(vec2 u,vec2 r\n){u=u.xy/r.xy-.5\n ;u*=sqrt(2.)\n ;//u*=1.; //fieldOfView\n ;vec4 CarLim=vec4(-2,2,-1,1);//carthesian limits\n ;return scale(u,CarLim);}", "buffer_a_code": "//#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 16\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 8\n    //potato mode\n    //#define TRACE_STEPS 3\n    #define MAX_DIST 10.0\n#else\n    #define MAX_STEPS 40\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 50\n    #define MAX_DIST 10.0\n#endif\n\n\nconst float FOV=1.\n,LUMINOUSITY     =80.\n,ABSORPSION      =sat(.999)\n,TAA             =sat(.97)//temporal Antialiasing factor (multiplies by the 2 below)\n,TAAMA           =sat(.85)//reprojection ammount\n,TAAMS           =sat(.01)//reprojection smoothness\n,ANISOTROPY      =.3//temporal Anisotropy denoise\n,AMBIENT_FOG     =max(0.001,abs(0.1))//0.001 improves performace\n;\n\nfloat density(//must not be <2. for the mandelbulb\n){\n ;return  mix(200.,3.,cos(iTime*.3)*.5+.5)\n ;return  16.;}\n\nfloat min_step(){return 1.25/density();}\n\n//cloud sharpness\n#define sharpness .0001\n\n\n//light positions\nvec3 lpos0,lpos1,lpos2,lpos3;\n\n#define SAM(a,b) texture(tex,(i+vec2(float(a),float(b))+.5)/r,-99.)\nvec4 textureBicubic(sampler2D tex,vec2 t\n){//return texture(tex,t)//skip override\n ;vec2 r=vec2(textureSize(tex,0))\n ;vec2 p=r*t-.5\n ;vec2 f=fract(p)\n ;vec2 i=floor(p)\n ;return spline(f.y,spline(f.x,SAM(-1,-1),SAM(0,-1),SAM(1,-1),SAM(2,-1))\n                   ,spline(f.x,SAM(-1,0),SAM(0,0),SAM(1,0),SAM(2,0))\n                   ,spline(f.x,SAM(-1,1),SAM(0,1),SAM(1,1),SAM(2,1))\n                   ,spline(f.x,SAM(-1,2),SAM(0,2),SAM(1,2),SAM(2,2)));}\n\n//blue noise\nvec4 rand4blue(){return texelFetch(iChannel1,shift2(),0);}\n\nvec4 mandelbulb_fog(vec3 p,float K\n){vec4 d=dfo(p)\n ;return vec4(density()*ma0(1.-d.yzw)*smoothstep(K,0.,d.x),d.x);}\n\nvec4 box_fog(vec3 p,vec3 b,float k\n){vec3 refl=normalize(vec3(0.4,0.6,0.9))\n ;float sc=1.0\n ;for(int i=0;i < 6;i++\n ){refl.xy=rot(1.6)*refl.xy\n  ;p-=2.*max(dot(refl,p),0.)*refl\n  ;refl.yz=rot(2.1)*refl.yz\n  ;p+=0.015*sin(10.*dot(refl,p)+sin(p.x*p.y));}\n ;float sdf=sdBox(p,b)/sc\n ;return vec4(density()*(vec3(.3,.6,.9)*+(.5+.5*sin(40.*vec3(.392,.580,1.000)*p.x)))*smoothstep(k,-k,sdf),sdf);}\n\nvec4 fogDens(vec3 p\n){vec4 box=mandelbulb_fog(p,sharpness)//box_fog(p,vec3(0.7,0.3,0.2),sharpness);\n ;float shells=min(MAX_DIST+0.6-length(p),\n \n min(\n min(length(p-lpos0),length(p-lpos1))\n ,min(length(p-lpos2),length(p-lpos3)))\n \n) //light source and background\n ;return vec4(box.xyz+vec3(0.141,0.439,1.000)*AMBIENT_FOG,min(box.w,shells));}\n\n\nvec4 lp0(vec3 p,float r\n){float t0=length(lpos0-p)\n ;float t1=length(lpos1-p)\n ;float prob=t0/(t0+t1)\n ;return (r>prob)?vec4(lpos0,prob):vec4(lpos1,1.-prob) ;}\n \n\n /*\n //trying and failing to add more lights\nvec4 lp1(vec3 p,float r\n){float t0=length(lpos2-p)\n ;float t1=length(lpos3-p)\n ;float prob=t0/(t0+t1)\n ;return (r>prob)?vec4(lpos0,prob):vec4(lpos1,1.-prob) ;}\n\nvec4 lp2(vec3 p,float r,vec3 ro\n){vec4 l0=lp0(ro,r)    //sample light importance \n ;vec4 l1=lp1(ro,r)    //sample light importance \n ;float t0=length(l0.xyz-p)\n ;float t1=length(l1.xyz-p)\n ;float prob=t0/(t0+t1)\n ;return (r>prob)?vec4(l0.xyz,prob):vec4(l1.xyz,1.-prob) ;}\n*/\n\n//trace a multibounce light path to the lights\nvec3 trace(vec3 ro,vec3 id,float dither\n){//acc opacity\n ;vec3 k=vec3(1)\n ;float step_size\n ;float td =0.\n ;float pdf=1.\n ;vec2 r=rand2()\n ;vec4 l0=lp0(ro,r.x)//sample light importance \n ;//vec4 la=lp1(ro,r.x)   \n ;//vec4 lb=lp2(ro,r.x,ro) \n ;pdf*=l0.w//*lb.w\n ;vec3 rd=id\n ;float dist=MAX_DIST\n ;//scatter samples \n ;int ss=(r.y < 0.5)?(TRACE_STEPS/3):0  \n //ooh i see, we randomly trace one of all lights\n ;int i=0\n ;for(;i < TRACE_STEPS;i++\n ){vec4 rho=fogDens(ro)\n  ;step_size=(1.0-DITHER*dither)*max(rho.w,max(max(min_step(),SCALING*td),5e-5*length(rho)))\n  ;k *=exp(-step_size*rho.xyz*ABSORPSION)//acc\n  ;rd=(i < ss)?normalize(mix(rd,udir(),1.-exp(-step_size*length(rho.xyz)*(1.-ANISOTROPY)))):rd//scatter\n  ;if(i ==ss //GI shadow ray\n  ){dist=length(l0.xyz-ro)+2e-2\n   ;rd=(l0.xyz-ro)/dist\n   ;pdf*=4.*pi*dist*dist //light distance pdf\n   ;pdf*=HenyeyGreenstein(ANISOTROPY,dd(rd));}\n  ;if(length(k)<.07||td>dist) break\n  //;if(dd(ro)>17.)break  //shaded sphere break\n  ;ro+=rd*step_size\n  ;td+=step_size;}\n ;if(i<ss)return vec3(0)\n ;return LUMINOUSITY*k*smoothstep(.068,.07,length(k))/pdf;}\n\n//return previous screenspace address to be returned\n//use previous camera matrix and camera position to reproject a point onto previos frame\nvec2 reproject(vec3 p){\n ;mat3 cam=q2m(tf(camA0p))//stores quaternion\n ;vec3 s=inverse(cam)*normalize(p)\n ;return vec2(s.yz*iR.y/(FOV*s.x)+.5*iR.xy);}\n\n#define FieldOfView 2.5\nv22 getRay(vec2 u//uU is not normalized\n){u=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(tf(camA0),tf(camP0).xyz)\n ;mat3 m=m42Rot(ct) //;mat3 m=q2m(tf(camA0))\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                   +(m*vec3(1,0,0)*u.x//right+forward...\n                   +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n\nvoid mainImage(out vec4 c,in vec2 p\n){if(iFrame<1){c=vec4(0);return;}\n ;rng_initialize(p,iFrame)\n ;vec3 campos=tf(camP0).xyz\n ;vec3 ro=campos\n ;vec3 rd=normalize(q2m(tf(camA0))*vec3(1.,FOV*(p-.5*iR.xy)/iR.y))\n ;lpos0=tf(li0P0).xyz\n ;lpos1=tf(li1P0).xyz\n ;lpos2=tf(li2P0).xyz\n ;lpos3=tf(li3P0).xyz\n ;vec4 brand=rand4blue()\n ;vec3 k=vec3(1)//acc opacity\n ;vec3 col=vec3(0)//acc light to camera\n ;int L=0    //main camera ray\n ;float step_size\n ;float td=0.\n ;vec4 maxl_p=vec4(0)\n ;int i=0\n ;for(;i<MAX_STEPS;i++\n ){vec4 rho=fogDens(ro)\n  ;step_size=(1.0-DITHER*brand.x)*max(rho.w,max(max(min_step(),SCALING*td),2e-5*length(rho)))\n  ;vec3 absorption=exp(-ABSORPSION*step_size*rho.xyz)\n  ;vec4 ldis=vec4(length(lpos0-ro),length(lpos1-ro)\n                 ,length(lpos2-ro),length(lpos3-ro))\n  ;vec3 scattering=k.xyz*(1.-absorption.xyz)\n  ;col+=vec3(LUMINOUSITY/10.)*k.xyz*(step(ldis.x,LIGHT_RADIUS)\n                                    +step(ldis.y,LIGHT_RADIUS)\n                                    +step(ldis.z,LIGHT_RADIUS)\n                                    +step(ldis.w,LIGHT_RADIUS))\n  ;if(((rho.z>1.)||rho.z>.005 && i%4 ==0)\n  ){float pdf=(rho.z>0.005 && rho.z<1.)?.25:1.\n   ;col+=scattering*trace(ro,rd,brand.z)/pdf;}\n  ;k*=absorption//acc\n  ;td+=step_size\n  ;ro+=step_size*rd\n  ;float ls=length(scattering)\n  ;maxl_p=(ls>maxl_p.w)?vec4(ro,ls):maxl_p\n  ;if(length(k) < 0.2 || distance(ro,vec3(0))>MAX_DIST) break;}\n ;if(i >=MAX_STEPS && length(k)>1.05) maxl_p.xyz=ro\n ;//col=vec3(distance(maxl_p.xyz,campos)/3.)//monochrome distance overwrite\n ;vec3 prev=tf(camP0p).xyz\n ;vec2 r=reproject(prev-maxl_p.xyz)/iR.xy\n ;//r=tHammerI(r)\n ;c=vec4(col,1)+textureBicubic(iChannel0,r)\n               *TAA*mix(1.,TAAMA,smoothstep(0.,TAAMS,length(prev-campos)))//accumulation movement\n               *mu(step(abs(r-vec2(.5)),vec2(.5)))//accumulation outside prev frame\n ;}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Controller\n\n//Keyboard constants\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\n  \n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code:\nfloat kg(int key_code){return texelFetch(iChannel3, ivec2(key_code,0), 0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n  \nvec4 cp0(//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return vec4(-1.5,1.5,0,1);\n ;vec3 r=tf(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){//optional collision\n  ;float d=PHYSICS_RADIUS-df(r.xyz)\n  ;if (d>0.)r.xyz+=normal(r)*d ;} \n ;return vec4(r+(q2m(tf(camA0),vec3(0))\n               *vec4(tf(camP1).xyz,0)).xyz*iTimeDelta,0);}\n\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(tf(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iFrame <1)return aa2q(vec3(0,0,1),-2.75)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*tf(camA1).zxy),tf(camA0)));}\n\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;return vec4(drag(tf(camA1).xyz,a.yzx*ANG_ACCE,ANG_DRAG),0.);}\n\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=tf(q)\n ;if(key(k))c.xyz=tf(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return tf(camP0)//memorize previous pos\n ;if(u==camA0p)return tf(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;if(u==li2P0)return lightPos(u,keyO,vec4(-.1,.5,.5,0))\n ;if(u==li3P0)return lightPos(u,keyK,vec4(1.2,-1.,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 516, 551, 551, 711]], "test": "untested"}
{"id": "WttyDs", "name": "Tone curve", "author": "iY0Yi", "description": "A tone editor like photoshop's tone curve.\nInterpolation funcs from:\nhttps://www.shadertoy.com/view/MsXGDj", "tags": ["contrast", "colorcorrection", "tool", "tonecurve"], "likes": 18, "viewed": 1153, "published": 3, "date": "1610225511", "time_retrieved": "2024-07-30T19:45:57.475164", "image_code": "float fivePointToneCurve(float col, float low, float lmid, float mid, float hmid, float high){\n    float VU = -0.25+low;\n\tfloat V1 =  0.0 +low;\n\tfloat V2 =  0.25+lmid;\n\tfloat V3 =  0.5 +mid;\n\tfloat V4 =  0.75+hmid;\n\tfloat V5 =  1.0 +high;\n\tfloat VO =  1.25+high;\n\tif(col<.25)\n\t\treturn INTP( col*4.,      VU, V1, V2, V3);\n\telse if(col<.5)\n\t\treturn INTP((col-.25)*4., V1, V2, V3, V4);\n    else if(col<.75)\n\t\treturn INTP((col- .5)*4., V2, V3, V4, V5);\n\telse if(col<1.)\n\t\treturn INTP((col-.75)*4., V3, V4, V5, VO);\n    else\n        return 0.;\n}\n\nvec3 fivePointToneCurve(vec3 col, float low, float lmid, float mid, float hmid, float high){\n\tvec3 res;\n\tres.x = fivePointToneCurve(col.r, low, lmid, mid, hmid, high);\n\tres.g = fivePointToneCurve(col.g, low, lmid, mid, hmid, high);\n\tres.b = fivePointToneCurve(col.b, low, lmid, mid, hmid, high);\n\treturn res;\n}\n\nfloat drawTCGraph(vec2 gv, float low, float lmid, float mid, float hmid, float high){    \n    float line = 1.;\n    if(gv.x>0. && gv.x<1.){\n        line = fivePointToneCurve(gv.x, low, lmid, mid, hmid, high);\n        line = sms(.0,.005,abs(line-gv.y));\n\n        line *= sms(.005,.0055,abs(0.001-gv.x));\n        line *= sms(.0,.0025,abs(0.25-gv.x));\n        line *= sms(.0,.0025,abs(0.5-gv.x));\n        line *= sms(.0,.0025,abs(0.75-gv.x));\n        line *= sms(.005,.0055,abs(.999-gv.x));\n\n        line *= sms(.005,.0055,abs(0.001-gv.y));\n        line *= sms(.0,.0025,abs(0.25-gv.y));\n        line *= sms(.0,.0025,abs(0.5-gv.y));\n        line *= sms(.0,.0025,abs(0.75-gv.y));\n        line *= sms(.005,.0055,abs(.999-gv.y));\n    }\n    \n    float hndls = 1.;\n    hndls *= sms(.01,.012, distance(gv, vec2(0., low)));\n    hndls *= sms(.01,.012, distance(gv, vec2(.25, lmid+.25)));\n    hndls *= sms(.01,.012, distance(gv, vec2(.5, mid+.5)));\n    hndls *= sms(.01,.012, distance(gv, vec2(.75, hmid+.75)));\n    hndls *= sms(.01,.012, distance(gv, vec2(1., high+1.)));\n\n    return line * hndls;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #define fetch(st) u2s(texelFetch(iChannel1, ivec2(st,0), 0).r)*.5\n    float low = fetch(0);\n    float lmid = fetch(1);\n\tfloat mid = fetch(2);\n    float hmid = fetch(3);\n\tfloat high = fetch(4);\n\n\tvec3 tex = fivePointToneCurve(texture(iChannel0, fragCoord.xy / iResolution.xy).rgb, low, lmid, mid, hmid, high);\n    \n    float gui = drawTCGraph(normalizeUVx(fragCoord.xy/iResolution.xy, iResolution.xy), low, lmid, mid, hmid, high);\n    \n\tfragColor = vec4(mix(vec3(1), tex, gui),1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    if(iFrame<=1){\n        fragColor = vec4(.5); \n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if(iMouse.z>0.){\n        vec2 mou = normalizeUVx(iMouse.xy/iResolution.xy, iResolution.xy);\n        \n        #define isIn(range) abs(mou.x-range) <= .1\n        \n        if(floor(fragCoord.x)==0. && isIn(.0)){\n            fragColor.r = mou.y+.5;\n        }\n        else\n        if(floor(fragCoord.x)==1. && isIn(.25)){\n            fragColor.r = mou.y+.25;\n        }\n        else\n        if(floor(fragCoord.x)==2. && isIn(.5)){\n            fragColor.r = mou.y;\n        }\n        else\n        if(floor(fragCoord.x)==3. && isIn(.75)){\n            fragColor.r = mou.y-.25;\n        }\n        else\n        if(floor(fragCoord.x)==4. && isIn(1.)){\n            fragColor.r = mou.y-.5;\n        }\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\nvec2 normalizeUVx(vec2 uv, vec2 res){\n    uv.x*=res.x/res.y;\n    uv.x-=.5*res.x/res.y-.5;\n    return uv;\n}\n\n// Interpolation funcs from:\n// https://www.shadertoy.com/view/MsXGDj\nfloat tcCatmullRom(float x, float v0,float v1, float v2,float v3){\n    //if(abs(v1-v2)<.001)return v1; // edited\n    float c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\t//return mix(min(v1,v2), (((c4 * x + c3) * x + c2) * x + v1), sms(.0,0.01,abs(v1-v2))); // edited 2023.08.04\n    return (((c4 * x + c3) * x + c2) * x + v1);\n}\nfloat tcThirdOrderSpline(float x, float L1,float L0, float H0,float H1){\n\treturn \t\t  L0 +.5 *\n\t\t\tx * ( H0-L1 +\n\t\t\tx * ( H0 + L0 * -2.0 +  L1 +\n\t\t\tx * ((H0 - L0)* 9.0\t + (L1 - H1)*3.0 +\n\t\t\tx * ((L0 - H0)* 15.0 + (H1 - L1)*5.0 +\n\t\t\tx * ((H0 - L0)* 6.0\t + (L1 - H1)*2.0 )))));\n}\nfloat tcCubic(float x, float v0,float v1, float v2,float v3){\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\nfloat tcSmoothstep(float x, float v0, float v1, float v2,float v3){\n\tx = x*x*(3.0-2.0*x);\n\treturn (v2-v1)*x + v1;\n}\nfloat tcLinear(float x, float v0, float v1, float v2,float v3){\n\treturn (v2-v1)*x + v1;\n}\n\nfloat tcCatmullRomLinear(float x, float v0, float v1, float v2,float v3){\n    float l = tcLinear(x, v0, v1, v2, v3);\n    float c = tcCatmullRom(x, v0, v1, v2, v3);\n\treturn mix(c,l,sms(0.,1.,abs(v1-v2)));\n}\n\n\n#define INTP tcCatmullRom\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 94, 94, 540], [542, 542, 634, 634, 852], [854, 854, 939, 939, 1940], [1942, 1942, 1998, 1998, 2484]], "test": "untested"}
{"id": "3ldcWs", "name": "Mini Hill Climb Racing", "author": "tonifing", "description": "Trying to learn raymarching, so wrote a mini hill climb racing version.\n\nLearned a lot from examples around shadertoy, so thanks to everyone!\n\nShader originally written to fit into a \"playable\" 4k executable and then transferred here", "tags": ["raymarching", "mini", "hcr", "hillclimbracing"], "likes": 4, "viewed": 415, "published": 3, "date": "1610224884", "time_retrieved": "2024-07-30T19:45:58.424625", "image_code": "/*\nA learning experience into shaders and raymarching.\n\nOriginally written to fit into a \"playable\" 4k executable.\n\nLots of things learned and copy pasted from: https://iquilezles.org/\nAlso used Leviathan 2.0 for the 4k, there's a lot learned from it and some code present: https://github.com/armak/Leviathan-2.0\n*/\n\nvec4 m;\nvec2 v;\n\nvec3 jeep;\nvec3 frontWheelOffset = vec3(0.9, -0.4, -0.7);\nvec3 rearWheelOffset = vec3(-0.9, -0.4, -0.7);\n\n//These are used as constants\nvec3 cFrontWheelOffset = vec3(0.9, -0.25, -0.7);\nvec3 cRearWheelOffset = vec3(-0.9, -0.25, -0.7);\n\nvec3 lightPos;\n\nfloat PI = 3.1416;\n\nfloat hash(float c){return fract(sin(dot(c, 12.9898)) * 43758.5453);}\n\n//Rotation\nmat3 rx(float a){return mat3(1.0,0.0,0.0,0.0,cos(a),-sin(a),0.0,sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0.0,sin(a),0.0,1.0,0.0,-sin(a),0.0,cos(a));}\nmat3 rz(float a){return mat3(cos(a),-sin(a),0.0,sin(a),cos(a),0.0,0.0,0.0,1.0);}\n\n//Smoothmin, can be used to \"blend\" 2 distancefields together smoothly\nfloat opSmoothMin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n\t//min(d1,d2);\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opSubtract(vec2 d1, vec2 d2)\n{\n\t//max(-d1,d2);\n\treturn ((-d1.x)>d2.x) ? -d1 : d2;\n}\n\nvec2 opIntersect(vec2 d1, vec2 d2)\n{\n\t//max(d1,d2);\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\n\n//Slightly simplified original equation for HCR1: Countryside\nfloat heightAt(float x)\n{\n\tx*=1.5;\n    x+=10.0;\n\treturn (cos(x/10.0)*2.0 +\n\t\t    +(cos(x+(sin(x*0.25)))*0.2*min(x*0.0015, 1.0f))\n\t        +(cos(x*0.17+(sin(x*0.25)))*2.0*min(x*0.00075, 1.0f))\n\t        +(cos(x*0.0952+(sin(x*0.15)))*2.0*min(x*0.00275, 1.0f))\n\t\t    +(-1.0 + sin(x/30.0+cos(x/32.14))*4.0*min(x*0.00075, 1.0f)))\n\t\t\t*(0.5+x/2000.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderXZ( vec3 p, float h, float r )\n{\n  //p.x += 1.0-sin(PI*0.5-(r + p.y)*m.y*0.1);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle2D(vec2 p, vec2 c, float r)\n{\n\tfloat m = 0.1+max(dot(normalize(p-c), normalize(vec2(1, -1))), 0.0)*1.9;\n\treturn clamp(1.0-pow(1.0-(length(p-c)-r)*2.5, 0.075*m), 0.0, 1.0);\n}\n\nvec3 getMaterialColor(vec3 p, float material)\n{\n\tint c=int(material);\n\tif (c==0) return mix(vec3(36.0, 212.0, 255.0)/255.0, vec3(161.0, 236.0, 255.0)/255.0, v.y); //Skycolor \n\tif (c==1) return mix(vec3(98.0, 169.0, 0.0) / 255.0, vec3(173.0, 234.0, 81.0) / 255.0, pow(1.0-clamp(abs(p.z-4.0)/1.9, 0.0, 1.0), 0.1));\t//Surface color\n\tif (c==2) return vec3(98.0 , 169.0, 0.0  ) / 255.0; //Guess I forgot to use this\n\tif (c==3) //Terrain (underground part)\n\t{\n\t\t//Texture some circles for this material\n\t\tvec2 q = mod(p.xy*0.5+0.5*5.0,5.0)-0.5*5.0;\n\t\t\n\t\tfloat d = sdCircle2D(q, vec2(0.1, 0.5), 0.3);\n\t\td = max(d, sdCircle2D(q, vec2(1.5, -0.5), 0.25));\n\t\td = max(d, sdCircle2D(q, vec2(-0.5, -1.5), 0.17));\n\t\td = max(d, sdCircle2D(q, vec2(2.0, 1.5), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(-2.0, 0), 0.05));\n\t\t\n\t\t//Repeat a few circle on edge of texture to simulate tiling\n\t\td = max(d, sdCircle2D(q, vec2(0.5, -2.7), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(0.5, 2.3), 0.08));\n\t\t\n\t\td = max(d, sdCircle2D(q, vec2(2.8, -2.0), 0.08));\n\t\td = max(d, sdCircle2D(q, vec2(-2.2, -2.0), 0.08));\n\t\treturn vec3(63.0 , 50.0 , 34.0 ) / 255.0*(2.0-d);\n\t}\n\tif (c==4) return vec3(168.0, 0.0  , 0.0  ) / 255.0; //Jeep chassis\n\tif (c==5) return vec3(50.0 , 50.0 , 50.0 ) / 255.0; //Jeep tires\n\tif (c==6) return vec3(150.0, 150.0, 150.0) / 255.0; //Jeep rims\n\tif (c==7) return vec3(192.0, 74.0 , 81.0 ) / 255.0; //Bill: Clothes red\n\tif (c==8) return vec3(207.0, 191.0, 168.0) / 255.0*1.1; //Bill: Head\n\tif (c==9) return vec3(225.0, 211.0, 196.0) / 255.0*1.2; //Bill: Eyes\n\n\treturn vec3(0,1,0);\n}\n\nfloat getMaterialReflectivity(float material)\n{\n\tif (material==1.0) return 0.1; //Terrain, just a little to see the jeep from the ground\n\tif (material==4.0) return 0.2; //Jeep chassis\n\tif (material==6.0) return 0.4; //Jeep rims\n\treturn 0.0;\n}\n\nfloat getMaterialSpecular(float material)\n{\n\tif (material == 1.0) return 0.0; //No specular on terrain surface\n\tif (material >= 7.0) return 0.05; //Only minimal specular on bill\n\t\n\treturn 1.0;\n}\n\nfloat materialAmbient(float material)\n{\n\tif (material==3.0) return 0.65; //Terrain\n\tif (material==4.0) return 0.4; //Jeep chassis\n\tif (material==5.0) return 0.3; //Jeep tires\n\treturn 0.2;\n}\n\n//This defines our whole scene content, it returns distance to a point in the world\nvec2 map(vec3 p, bool shadowPass)\n{\n\tvec2 d = vec2(100.0, 0.0);\n\t\n\t//Terrain\n\tif (!shadowPass)\n\t{\n\t\t//Terrain\n\t\td = opIntersect(vec2(p.y - heightAt(p.x), 1.0),\n\t\t\t\t\t    vec2(-sdPlane(p, vec3(0.0, 0.0, 1.0), -2.0), 3.0));\n\t\t\n\t\t//Sky plane\n\t\td = opIntersect(d, vec2(-sdPlane(p, vec3(0.0, 0.0, -1.0), 6.0), 3.0));\n\t}\n\n\tvec2 dfJeep = opUnion(vec2(100.0, 0.0),\n\t\t\t\t\tvec2(\n\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\t\topSmoothMin(\n\t\t\t\t\t\t\t\t\tsdRoundBox((p-jeep)*rz(m.z), vec3(1.6, 0.3, 0.8),0.1), //Chassis\n\t\t\t\t\t\t\t\t\tsdRoundBox((p-(jeep + vec3(0.45, 0.6, 0.0)*rz(-m.z)))*rz(m.z-0.3), vec3(0.05, 0.25, 0.7),0.03), //Windscreen\n\t\t\t\t\t\t\t\t\t0.1),\n\t\t\t\t\t\t\t\tsdRoundBox((p-jeep-vec3(-1.65,0.37,0)*rz(-m.z))*rz(m.z+0.7), vec3(0.1, 0.02, 0.65),0.065), //Spoiler\n\t\t\t\t\t\t\t\t0.12),\n\t\t\t\t\t\t\tsdRoundBox((p-jeep-vec3(1.05,0.4,0)*rz(-m.z))*rz(m.z-0.15), vec3(0.2, 0.1, 0.25),0.035), 0.05),\t//Scoop\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t4.0)\n\t\t\t\t\t); \n\t//dfJeep = opSmoothMin(dfJeep, vec2(sdRoundBox((p-jeep-vec3(1.2,0.45,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.2, 0.1, 0.25),0.035), 4.0); //Scoop\n\t\t\t\t\t\t\n\t//Jeep: Interior\n\tdfJeep = opIntersect(dfJeep, vec2(-sdBox((p-jeep-vec3(-0.2,0.1,0)*rz(-m.z))*rz(m.z), vec3(0.6, 0.5, 0.7)), 5.0));\n\t\n\t//Bumper\n\tdfJeep = opUnion(dfJeep, vec2(sdRoundBox((p-jeep-vec3(0.0,-0.3,0)*rz(-m.z))*rz(m.z), vec3(1.7, 0.05, 0.85),0.1), 5.0));\n\t\n\t//Car wheels\n\t{\n\t\tvec3 q = p;\n\t\t//Wheels\n\t\tq.z = abs(q.z-jeep.z)+2.4;\n\t\tdfJeep = opIntersect(dfJeep, vec2(-sdCappedCylinder((q-(jeep + cFrontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.55, 0.2), 5.0));\n\t\tdfJeep = opIntersect(dfJeep, vec2(-sdCappedCylinder((q-(jeep + cRearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.55, 0.2), 5.0));\n\t\t\n\t\t//Wheel covers\n\t\tq.z = abs(p.z-jeep.z)+2.5;\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep + frontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.5,0.2), 5.0));\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep +  rearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.5,0.2), 5.0));\n\t\t\n\t\t//Rims\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep + frontWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.3,0.21), 6.0));\n\t\tdfJeep = opUnion(dfJeep, vec2(sdCappedCylinder((q-(jeep +  rearWheelOffset*rz(-m.z)))*rz(m.z-0.3), 0.3,0.21), 6.0));\n\t}\n\t\n\t//Seat\n\tdfJeep = opUnion(dfJeep, vec2(sdRoundBox((p-jeep-vec3(-0.6,0.15,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.05, 0.4, 0.5),0.1), 5.0));\n\t\n\t//Now put together with scene\n\td = opUnion(d, dfJeep);\n\t\n\t//Antenna\n\td = opUnion(d, vec2(sdCappedCylinderXZ((p-(jeep + vec3(-1.2, 1.2, 0.4)*rz(-m.z)))*rz(m.z), 0.075,0.8), 5.0));\n\t\n\t//Bill himself\n\t//Torso\n\tfloat fd = opSmoothMin(\n\t\t\t\t\tsdRoundBox((p-jeep-vec3(-0.15,0.3,0)*rz(-m.z))*rz(m.z-0.2), vec3(0.1, 0.45, 0.35),0.1),\n\t\t\t\t\tsdSphere((p-jeep-vec3(-0.15,0.3,0)*rz(-m.z))*rz(m.z), 0.55),\n\t\t\t\t\t0.2);\n\tfd = opSmoothMin(fd, sdSphere((p-jeep-vec3(0.05,0.67,-0.2)*rz(-m.z))*rz(m.z), 0.15), 0.1);\n\tfd = opSmoothMin(fd, sdSphere((p-jeep-vec3(0.05,0.67,0.2)*rz(-m.z))*rz(m.z), 0.15), 0.1);\n\td = opUnion(d, vec2(fd, 7.0));\n\t\t\n\t//Head\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.35,1.2,0)*rz(-m.z))*rz(m.z), 0.35), 8.0));\n\t\t\n\t//Nose\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.05,1.2,0)*rz(-m.z))*rz(m.z), 0.125), 8.0));\n\t\t\n\t//Eyes\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.125,1.3,0.12)*rz(-m.z))*rz(m.z), 0.12), 9.0));\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.125,1.3,-0.12)*rz(-m.z))*rz(m.z), 0.12), 9.0));\n\t\t\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.0,1.32,0.12)*rz(-m.z))*rz(m.z), 0.04), 5.0));\n\td = opUnion(d, vec2(sdSphere((p-jeep-vec3(-0.0,1.32,-0.12)*rz(-m.z))*rz(m.z), 0.04), 5.0));\n\t\t\n\t//Hat\n\tvec2 dHat = opIntersect(vec2(sdSphere((p-jeep-vec3(-0.38,1.25,0)*rz(-m.z))*rz(m.z), 0.35), 7.0),\n\t\t\t\t\t        vec2(sdPlane((p-jeep-vec3(-0.38,1.25,0)*rz(-m.z))*rz(m.z), normalize(vec3(0.6,-1.0,0.0)), 0.1), 7.0));\n\t\t\n\tfloat hatCurve = min(pow(abs(4.0-p.z), 2.0), 1.0);\n\tdHat.x = opSmoothMin(dHat.x, sdRoundBox((p-jeep-vec3(-0.8+hatCurve,1.2-hatCurve*0.6,0)*rz(-m.z))*rz(m.z-0.5), vec3(0.2, 0.02, 0.24),0.02),0.07);\n\td = opUnion(d,dHat);\n\treturn d;\n}\n\nvec3 rhs(vec3 dir, float i)\n{\n\tvec2 rnd = vec2(hash(i+1.), hash(i+2.));\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\tvec3 v = vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ao( vec3 p, vec3 n, float maxDist, float falloff)\n{\n\tfloat ao = 0.0;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = normalize(n+rhs(n, l )*0.95)*l;\n\t\tao += (l - map( p + rd, false).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp(1.-ao*0.1,0.0,999.0);\n}\n\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0005*e, false).x;\n    }\n    return normalize(n);\n}\n\n//Raymarch soft shadows\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = maxt;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t, true).x;\n        if( h<0.001 )\n            return 0.0;\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.5+0.01;\n    }\n    return res;\n}\n\n//This goes forward until close enough to a surface\nvec3 raymarch( vec3 ro, vec3 rd, out float material, const int iterationCount, const float step)\n{\n\tvec3 p = ro;\n\tvec2 d;\n\tfloat t = .0;\n\tfor(int i=0; i<iterationCount; i++)\n\t{\n\t\td = map(p, false);\n\t\tif( d.x < 0.01)\n\t\t{\n\t\t\tmaterial = d.y;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (t > 100.0)\n\t\t{\n\t\t\tmaterial = 0.0;\n\t\t\treturn p;\n\t\t}\n\t\t\n\t\tt += d.x*step;\n\t\tp += rd*d.x*step;\n\t}\n\tmaterial = d.y;\n\treturn p;\n}\n\nvec3 shade(vec3 p, vec3 n, vec3 rd, float material)\n{\n\tfloat light = 1.0;\n\t\n\tif (material > 0.0)\n\t{\n\t\tvec3 lightDir = normalize(lightPos-p);\n\t\tfloat lightPower = 1.0-length(lightPos-p)*0.0005;\n\n\t\t//Calculate shadows into our lighting\n\t\tfloat shadowMul = 0.5;\n\t\tif (material != 3.0)\n\t\t\tshadowMul = softshadow(p, normalize(lightPos-p), 0.1, 20.0 , 12.0);\n\t\t\t\t\n\t\tlightPower = lightPower*0.5f + shadowMul*0.5;\n\t\tlightPower = max(min(lightPower, 1.0), 0.0);\n\t\t\n\t\tfloat ambient = materialAmbient(material);\n\t\t\n\t\t//Calculate diffuse and specular light and ambient occlusion (specular only on jeep)\n\t\tfloat lightDiff = ambient + max(dot(n, lightDir), 0.0) * lightPower * 1.0 * ao(p, n, 2.0, 2.0)*0.7;\n\t\t\n\t\tfloat lightSpec = pow(max(dot(reflect(rd, n), lightDir), 0.0), 8.0) * getMaterialSpecular(material);\n\t\tlight = (lightDiff + lightSpec);\n\t}\n\treturn getMaterialColor(p, material) * light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n\tvec2 v = -1.0+2.0*q;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\t//Scale our input vector back to float\n\tm.x = iTime*5.0;// = vec4(inVec) / 44100.0;\n    m.y = heightAt(m.x)+1.0;\n    m.z = atan(heightAt(m.x-0.7) - heightAt(m.x+0.7));\n    m.w = iTime*5.0;\n\t\n\t//Set jeep position from our input data\n\tjeep = vec3(m.x, m.y, 4.0);\n\t\n\t//Wheel suspension \"simulation\"\n\tvec3 wp = jeep + frontWheelOffset*rz(-m.z);\n\tif (heightAt(wp.x) < wp.y) frontWheelOffset.y = clamp(heightAt(wp.x) - wp.y, -0.8, -0.35) + 0.1;\n\twp = jeep + rearWheelOffset*rz(-m.z);\n\tif (heightAt(wp.x) < wp.y) rearWheelOffset.y = clamp(heightAt(wp.x) - wp.y, -0.8, -0.35) + 0.1;\n\n\t//Camera position\n\tfloat zoom = 0.5+pow(abs(m.x - m.w)*0.07,1.7);\n\tvec3 ro = vec3(m.w,23.0*zoom,-30.0*zoom);\n\t\n\t//Camera rotation\n\tmat3 rot = rx(0.5)*ry(clamp((m.x - m.w)/30.0, -0.5, 0.5));\n\t\n\t//Calculate average terrain height to offset camera\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\th +=heightAt(-5.0+ro.x+float(i)*1.0);\n\t}\n\th/=20.0;\n\tro.y += h;\n\tro += vec3( v.x, v.y, 0) * rot;\n\tvec3 rd = normalize(vec3(v.x, v.y, 7.0-abs(m.x - m.w)/4.0))*rot;\n\t\n\t//Define light position\n\tlightPos = vec3(ro.x+20.0, ro.y+20.0, 3.0);\t\t\n\n\tfloat material;\n\tvec3 p = raymarch(ro, rd, material, 80, 0.7);\n\t\t\n\tvec3 col = getMaterialColor(p, material);\n\tvec3 n = normal(p);\n\t\n\t//Calculate Lighting with a single point light (only on pixels that are not sky or terrain)\n\tif (material > 0.0)\n\t{\n\t\tcol = shade(p, n, rd, material);\n\t\t\n\t\tfloat refl = getMaterialReflectivity(material);\n\t\t//Add reflection\n\t\tif (refl > 0.0)\n\t\t{\t\n\t\t\tfloat rMaterial;\n\t\t\tvec3 rrd = reflect(rd, n);\n\t\t\tvec3 rp = raymarch(p + n*0.05, rrd, rMaterial, 60, 1.0);\n\t\t\tvec3 rn = normal(rp.xyz);\n\t\t\tvec3 rColor = shade(rp, rn, rrd, rMaterial);\n\t\t\t\n\t\t\tcol += rColor*refl;// * max(pJeep, pSurface*1.5);\t\t\t\n\t\t}\n\t}\n\n\tfragColor = vec4(col, 1);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[605, 605, 625, 625, 674], [676, 687, 704, 704, 767], [768, 768, 785, 785, 848], [849, 849, 866, 866, 929], [931, 1002, 1050, 1050, 1143], [1146, 1146, 1178, 1193, 1226], [1228, 1228, 1263, 1279, 1316], [1318, 1318, 1354, 1369, 1402], [1405, 1467, 1492, 1492, 1812], [1814, 1814, 1858, 1858, 1949], [1951, 1951, 1993, 2019, 2044], [2046, 2046, 2075, 2075, 2135], [2137, 2137, 2170, 2170, 2195], [2197, 2197, 2249, 2249, 2356], [2358, 2358, 2412, 2458, 2565], [2567, 2567, 2610, 2610, 2754], [2756, 2756, 2803, 2803, 4322], [4324, 4324, 4371, 4371, 4566], [4568, 4568, 4611, 4611, 4762], [4764, 4764, 4803, 4803, 4953], [4955, 5039, 5074, 5074, 9010], [9012, 9012, 9041, 9041, 9219], [9221, 9221, 9278, 9278, 9504], [9506, 9506, 9527, 9653, 9859], [9861, 9885, 9956, 9956, 10301], [10303, 10355, 10453, 10453, 10740], [10742, 10742, 10795, 10795, 11627], [11629, 11629, 11686, 11686, 13562]], "test": "untested"}
{"id": "3ltcWs", "name": "GyroidHolzCube", "author": "Looo911", "description": "Gyroid Shader from Art is Codec", "tags": ["touchdesignerexport"], "likes": 0, "viewed": 302, "published": 3, "date": "1610224182", "time_retrieved": "2024-07-30T19:45:59.284327", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\n//sd: - inside of object, + outisde\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    \n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {   \t\n    p*=scale;\n    float gyroid = abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n    \n    return gyroid;\n}\n\n\nfloat GetDist(vec3 p) {\n    float box = sdBox(p, vec3(1));\n    float sphere = sphereSDF(p, 1.4);\n    float gyroid = sdGyroid(p, 16., .02, 0.0);\n    \n    float d = max(box,gyroid*.7);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    bool zweiD = true;\n    //bool zweiD = false;\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    float zoom = 2.0;\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 2.);\n    \n    float dist_to_mid = length(uv);\n    //dist_to_mid = dot(uv,uv);\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;  \n    }\n    \n    //col = pow(col, vec3(.4545));\t//  gamma correction\n    \n    if(zweiD){\n        col *= 0.;\n        d = sdGyroid(vec3(uv.x, uv.y, iTime*.05),  22., .04, 0.0);        \n        col += d*40.;\n        \n        col = vec3(1.0 - col.x,1.0 -col.y,1.0 -col.z);\n        col *= 1.-(min(1., sqrt(iTime*dist_to_mid)));\n        //col *= max(1.,iTime*dist_to_mid);\n        \n    }\n    \n    //\n    //col += d*7.;\n    //\n    fragColor = vec4(col*1.2,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltcWs.jpg", "access": "api", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1580, 1580, 1674], [1676, 1712, 1741, 1741, 1827], [1829, 1829, 1863, 1863, 1891], [1894, 1894, 1960, 1960, 2074], [2077, 2077, 2100, 2100, 2280], [2282, 2282, 2316, 2316, 2527], [2529, 2529, 2553, 2553, 2743], [2745, 2745, 2795, 2795, 2986], [2990, 2990, 3047, 3047, 4127]], "test": "untested"}
{"id": "MsVyWG", "name": "Sound Experiment 2018-02-20 C2a", "author": "ttg", "description": "Publishing my old sound shaders.", "tags": ["sound", "music", "sampleprecise"], "likes": 9, "viewed": 378, "published": 3, "date": "1610220114", "time_retrieved": "2024-07-30T19:46:00.057260", "image_code": "// Passthrough to Channel 0\nvoid mainImage ( out vec4 f, in vec2 d ) {\n  f = texelFetch(iChannel0, ivec2(d), 0); }\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Sample precise time\nstruct timeT { int s; };\nfloat floatC (timeT t) { return float(t.s)/iSampleRate; }\n// not exact to composition's division of time into notes.  Clicks are heard (also with floats).\nfloat modM (timeT t, float m) { return floatC(timeT(t.s%int(m*iSampleRate))); }\n\n// Spectrogram config\nconst float timescale = 1./4.;\nconst float freqscale = 2600.;\nconst vec2 stereomix = vec2(1.,1.)*2.;\n\n/*\nSound Experiment\nCopyright 2018 Theron Tarigo\n*/\n\nconst float pi = 3.141592653589793;\n\nfloat wave(float t) { return sin(2.*pi*fract(t)); }\n\nfloat synth0(float freq, float time) {\n  return wave(freq*time);\n}\n\nfloat synth1(float freq, float time) {\n  float freq2 = freq;\n  float freq3 = freq2 + 0.25;\n  float v = 0.;\n  for (float n=1.; n<5.; n+=1.00+0.002) {\n      // these exp(freq/440.) are slowing it down quite a bit!\n    v += 0.2/pow(n,(1.2+exp(freq/440.)))*wave(n*freq*time+1.*wave(n*freq2*time));\n    v += 0.2/pow(n,(1.2+exp(freq/440.)))*wave(n*freq*time+1.*wave(n*freq3*time));\n  }\n  return v;\n}\n\nvec2 smoothclip(vec2 f) {\n    float p = 3.;\n    f.x = pow(atan(pow(abs(f.x),p)*1.571)/1.571,1./p)*sign(f.x);\n    f.y = pow(atan(pow(abs(f.y),p)*1.571)/1.571,1./p)*sign(f.y);\n    return f;\n}\n\nfloat sincstep(float x) {\n    return ( x<0.001 ? 0. : 1.0-sin(pi*x)/(pi*x) );\n}\n\nfloat pulse1(float freq, float decay, float time) {\n  return sincstep(time*freq*2.)*exp(-time*decay)*cos(time*freq*2.*pi);\n}\n\nfloat synth2(float freq, float time, float maxtime) {\n  float v = 0.;\n  //freq/=3.;\n  freq*=2.;\n  for (float n=1.0; n<18.; n+=1.0) {\n    v += pulse1(freq*n/3., pow(n/3.,2.)*1., time)*exp(-n*0.3/3.);\n  }\n  if (time < 0. || time > maxtime) return 0.;\n  v*=1.-exp((time/maxtime-1.)*8.);\n  return v/3.;\n}\n\nfloat selfproduct(vec3 v) { return v.x*v.y*v.z; }\n/*\nivec3[] seqN = ivec3[](\n    ivec3(-1,0,-1),\n    ivec3(-2,1,-1),\n    ivec3(1,-1,-1),\n    ivec3(1,-2,0),\n    ivec3(-1,-1,0),\n    ivec3(-2,0,0),\n    ivec3(-2,1,-1),\n    ivec3(-1,-1,0),\nivec3(0));\n*/\nivec3[] seqN = ivec3[](\n    ivec3(-1,0,-1),\n    ivec3(-2,1,-1),\n    ivec3(1,-1,-1),\n    ivec3(-3,-1,1),\n    ivec3(-1,-1,0),\n    ivec3(-4,1,0),\n    ivec3(-2,1,-1),\n    ivec3(-1,-1,0),\nivec3(0));\n\nfloat[] seqN2 = float[](\n    1.,\n    2.,\n    2.,\n    1.,\n    1.,\n    1.,\n    4./3.,\n    1.,\n\n    1.,\n    2.,\n    4./5.,\n    3./4.,\n    3./2.,\n    1.,\n    3./2.,\n    1.,\n0.);\n\nfloat seqf(int n, int s) {\n  int i = n%8;\n  int j = (n/(1))%8;\n  int k = s;\n  k ^= (k>>1);\n  k |= (k>>1);\n  //k &= s;\n  i ^= (k ^ (j>>1));\n  //i %= 8;\n  //ivec3 seq = seqN[i] * ((ivec3(k)>>ivec3(0,1,2))&1);\n  //ivec3 seq = seqN[i%8];\n  //return selfproduct(pow(vec3(2,3,5), vec3(seq)));\n  return seqN2[(i%16)%(n/16+1)];\n}\n\nfloat seqa (float t, float e) { \n    \n    return max(pow(wave(t/2.),e), 0.); }\n\nvoid seq0(float time, out float ampl, out float freq, int s) {\n    int n = int(time);\n    ampl = seqa(time, 2.);\n    float fprod = seqf(n, s);\n    freq = 141. * 1. * fprod;\n}\n\nvec2 mainSound( timeT timein ) {\n  float time = floatC(timein) + 180.*0.;\n  //time = 0.4;\n  float br;\n  vec2 v = vec2(0.);\n  float ac = 1.;\n  for (int i = 0; i < 6; i++) { // 2018-03-29: 6 -> 8\n    if (time>-8.) {\n        for (float j = 0.; j < 4.; j+=1.) {\n            float rtime = time-j/br;\n            \n        float ampl;\n        float freq;\n        br = float(1<<i)*0.25*5./4.;\n        float nr = 1./4.;\n        float syntime = modM(timein,1./br);//+float(int(time*br)%23);\n        float rsyntime = syntime+j/br;\n        if (mod(rtime*br,2.)<8.) ac*=0.75;\n        seq0(rtime*br, ampl, freq, int(rtime*nr));\n       // freq *= pow(2., -5.+float(i));\n        ampl = 0.0625;// * ac; // 2018-03-29: *ac\n        ampl *= 1.*pow(.9, float(i)); // prev\n        //ampl *= pow(1.2, float(i)); // 2018-03-29\n        //ampl *= exp(-pow(float(i)-time/180.*16.,2.)*0.2); // 2018-03-29\n        float pos = pi*sin(0.25*pi*float((1<<i)*int(rtime*br)));\n        //float pos = time*0.5;\n        float td = 0.0001;\n        //v.x += ampl*synth2(freq, syntime+td*sin(pos)-td, 1./br)*pow(cos(pos/2.-pi/4.),2.);\n        //v.y += ampl*synth2(freq, syntime-td*sin(pos)-td, 1./br)*pow(cos(pos/2.+pi/4.),2.);\n        v += ampl*synth2(freq, rsyntime, 4./br);\n        }\n    }\n  }\n  //  time -= 55.+0.125/4.;\n  //}\n  v *= max(1.-exp(-10.*(178.-floatC(timein))),0.);\n  v*=0.8;\n  v = smoothclip(v);\n  return vec2(v);\n}\n", "buffer_a_code": "/*\nStreaming Spectrogram v.3\nCopyright 2018 Theron Tarigo\n*/\n\nconst float windowmax = 0.5;\n\nvec4 encode ( int i ) { return vec4((uvec4(i)>>ivec4(0,8,16,24))&0xFFu)/255.; }\nint decode ( vec4 f ) { uvec4 d = uvec4(f*255.)<<ivec4(0,8,16,24);\n  return int(d.x|d.y|d.z|d.w); }\n\nvoid mainImage ( out vec4 f, in vec2 pixf ) {\n  f = vec4(0.);\n  ivec2 pix = ivec2(pixf);\n  ivec2 res = ivec2(iChannelResolution[0].xy);\n  int center = res.x*res.y/2;\n  int offset = int(iTime*iSampleRate) - center;\n  int index = res.x*pix.y+pix.x;\n  if (index==0) { f = encode(offset); return; }\n  int offsetlast = decode(texelFetch(iChannel0, ivec2(0), 0));\n  int cutoff = int(windowmax*iSampleRate);\n  if (abs(index-center) > cutoff) return;\n  int samp = index+offset;\n  int samplast = center+cutoff+offsetlast;\n  //float time = (float(samp)-0.5)/iSampleRate;\n  if (samp <= offsetlast + center + cutoff) {\n    f.xy = texelFetch(iChannel0,\n      (ivec2(index+offset-offsetlast)/ivec2(1,res.x))%(res), 0).xy;\n  } else {\n    f.xy = mainSound(timeT(samp));\n  }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nStreaming Spectrogram v.3\nCopyright 2018 Theron Tarigo\n*/\n\nconst float sgr_pi = 3.141592653589793;\n\nvec2 readsound ( int isamp ) {\n  ivec2 res = ivec2(iResolution.xy);\n  int offset = int(iTime*iSampleRate) - res.x*res.y/2;\n  int samp = isamp - offset;\n  ivec2 pix = ivec2(samp%res.x, (samp/res.x));\n  return texelFetch(iChannel1, pix, 0).xy;\n}\n\nvec2 spectrogram ( float windowtime, int isamp, float freq ) {\n  vec2 sum = vec2(0.);\n  int iwindow = int(windowtime*iSampleRate);\n  float window = float(iwindow)/iSampleRate;\n  for (int irel = -iwindow; irel <= iwindow; irel+=1) {\n    // Cosine window\n    float w = (0.5+0.5*cos(float(irel)/float(iwindow)*sgr_pi));\n    float samp = dot(stereomix,readsound(isamp+irel));\n    float a = fract(float(irel)*freq/iSampleRate)*2.*sgr_pi;\n    sum += w*vec2(cos(a),sin(a))*samp;\n  }\n  return sum/iSampleRate/window;\n}\n\n// Calibrated to ttg's hearing\n// Returns modulation frequency at which a tone at base frequency\n// transitions from sounding as beats to sounding as separate tones\nfloat timeratiofn ( float freq ) {\n  const float nparam = 58.5;\n  const float aparam = 950.;\n  return freq/nparam + exp(-freq/aparam)*aparam/nparam;\n}\n\nvoid panImage( out vec4 f, int isamp, float y ) {\n  float freq = freqscale * y / iResolution.y;\n  float windowfreq = timeratiofn(freq);\n  f.rgb = vec3(10.,3.2,1.)*\n  pow(length(spectrogram(1./windowfreq, isamp, freq)),2.)*50.;\n}\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  int shift = int(fsf.x*timescale*(iTime));\n  int shiftlast = int(fsf.x*timescale*(iTime-iTimeDelta));\n  int delta = shift - shiftlast;\n  if ((fs.x-d.x) <= delta) {\n    float time = float(shift-fs.x+d.x)/timescale/fsf.x;\n    panImage(f, int(time*iSampleRate), df.y);\n  } else {\n    f = texelFetch(iChannel0,d+ivec2(delta,0),0);\n  }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// Sound in Common\n\nvec2 mainSound( int samp, float time ) { return mainSound(timeT(samp)); }", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsVyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 70, 70, 114]], "test": "untested"}
{"id": "3l3cDN", "name": "Transparent boxes", "author": "maksy", "description": "Playing with refraction and reflection. Good resources:\n\nhttps://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\nhttps://www.shadertoy.com/view/4tyXDR\nhttps://www.shadertoy.com/view/4dVBz3", "tags": ["refraction", "transparent", "reflect"], "likes": 5, "viewed": 580, "published": 3, "date": "1610218858", "time_retrieved": "2024-07-30T19:46:01.063569", "image_code": "#define PI 3.141592\n#define MAX_STEPS 150\n#define MAX_DIST 150.0\n#define SURF_DIST .0001\n\n#define GROUND 0\n#define SKY 1\n#define BOX 2\n#define BOX2 3\n#define BOX3 4\n#define MENGERSPONGE 5\n\n// How reflective the object is regardless of fresnel\n#define OBJECT_REFLECTIVITY 0.3\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n\nconst vec3 LIGHT_DIR = vec3(1, 3, 8);\n\nstruct Obj\n{\n\tint type;\n    float dist;\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Shading\n{\n    Obj intersection;\n    bool transparent;\n    bool mirror;\n    vec3 color; \n    \n    // Refractive index inside the object\n    float refractiveIndex;\n    \n    // How much of each color the object absorbs over distance\n    vec3 absorbance;\n};\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBar(vec2 p, float width)\n{\n    vec2 d = abs(p) - width;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + 0.01 * width;\n}\n\nfloat sdCrossBar(vec3 p, float x)\n{\n    float bar_x = sdBar(p.yz, x);\n    float bar_y = sdBar(p.zx, x);\n    float bar_z = sdBar(p.xy, x);\n    return min(bar_z, min(bar_x, bar_y));\n}\n\nfloat sdMengerSponge(vec3 p)\n{\n    float d = sdBox(p, vec3(4.0));\n    float one_third = 1.0 / 3.0;\n    for (float i = 0.0; i < 3.0; i++) \n    {\n        float k = pow(one_third, i);\n        float kh = k * 0.5;\n        d = max(d, -sdCrossBar(mod(p + kh, k * 2.0) - kh, k * one_third));\n    }\n    return d;\n}\n\nObj getDist(vec3 p) \n{    \n    float boxDist = sdBox(p-vec3(-3, 2, -12), vec3(3, 4, 3));\n    float boxDist2 = sdBox(p-vec3(-14, 2, 0), vec3(3, 4, 3));    \n    float boxDist3 = sdBox(p-vec3(-3, 2, 12), vec3(3, 4, 3));  \n    float mengerSpongeDist = sdMengerSponge(p - vec3(10,2, 0));\n       \n    float height = -2.;\n    float planeDist = p.y - height;\n   \n    Obj obj = Obj(GROUND, planeDist, p, vec3(0.));\n    if (boxDist < planeDist)\n        obj = Obj(BOX, boxDist, p, vec3(0.));\n    \n    if (boxDist2 < planeDist && boxDist2 < obj.dist)\n        obj = Obj(BOX2, boxDist2, p, vec3(0.));\n    \n    if (boxDist3 < planeDist && boxDist3 < obj.dist)\n        obj = Obj(BOX3, boxDist3, p, vec3(0.));\n    \n    if (mengerSpongeDist < planeDist && mengerSpongeDist < obj.dist)\n        obj = Obj(MENGERSPONGE, mengerSpongeDist, p, vec3(0.));\n\n    return obj;\n}\n\n// Use offset samples to compute normal\nvec3 calcNormal(vec3 p) \n{\n\tfloat d = getDist(p).dist;\n    \n    vec2 e = vec2(.01, 0.);    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).dist,\n        getDist(p-e.yxy).dist,\n        getDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\n// Ambient occlusion by iq.\nfloat calcAO(vec3 pos, vec3 normal)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for(int i = 0; i < 15; i++)\n    {\n        float r = 0.01 + 0.1*float(i);\n        vec3 aopos =  normal * r + pos;\n        \n        Obj intersection = getDist(aopos);\n             \n        if (intersection.type != BOX && intersection.type != BOX3) \n        {\n            float d = getDist( aopos ).dist;\n            occ += (r - d)*sca;\n            \n            sca *= 0.85;\n        }\n    }\n    return clamp( 1.0 - occ /3.14, 0.0, 1.0 );    \n}\n\n// Soft shadows by iq. Casts a ray from the origin ro (an object surface) in \n// the direction rd. Returns a lower value (darker shadow) when there is more\n// stuff nearby as we step along the shadow ray.\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 16; i++)\n    {\n\t\tfloat h = getDist(ro + rd*t).dist;\n        res = min(res, 1.0 * h/t);\n        t += clamp(h, 0.02, .50);\n        \n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n \nfloat fresnelAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // Adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n}\n\n// Basic raymarching loop\nObj castRay(vec3 ro, vec3 rd) \n{   \n    float t = 0.0;\n    \n    Obj intersection;\n    \n    for (int i = 0; i < MAX_STEPS; i++) \n    {\t\n        vec3 p = ro + rd*t;\n        intersection = getDist(p); \n        \n        // This makes the bottom of a box completely transparent\n        if (intersection.type == GROUND)\n            t += intersection.dist;\n        else\n            t += abs(intersection.dist);\n        \n        // The ray has marched far enough but hit nothing. \n        // Render the pixel as a part of the sky.\n        if (t > MAX_DIST) \n        {\n        \tintersection = Obj(SKY, t, p, vec3(0.));\n            break;\n        }\n\n        // The ray has marched close enough to an object\n        if (abs(intersection.dist) < SURF_DIST) \n        {\n            intersection = Obj(intersection.type, t, p, vec3(0.));\n        \tbreak;\n        }\n        \n        intersection.dist = t;\n    }\n    \n    return intersection;\n}\n\n// Calculates the color of the ground. Adds a checkerboard texture, ambient occlusion \n// diffuse lightning, soft shadows and fog.\nvec3 groundColor(Obj intersection, vec3 rayDir, vec3 skyColor) \n{  \n    float f = mod( floor(.5*intersection.position.x) + floor(.5*intersection.position.z), 2.0);\n    vec3 color = 0.4 + 0.3*f*vec3(1.0);\n                          \n    float fogAmount = pow(1. - pow(rayDir.y, 2.), 3.);\n               \n    vec3 N = calcNormal(intersection.position);\n    float occ = calcAO(intersection.position, N );\n        \n    float diffuse = clamp( dot( N, normalize(LIGHT_DIR) ), 0.0, 1.0 );    \n    float shadow = softShadow(intersection.position, LIGHT_DIR, .55, 2. );\n    \n    color += diffuse * shadow;\n    color *= occ;           \n    color = mix(color, skyColor, fogAmount);\n    \n    return color;\n}\n\n// Intersects an object and returns its shading properties.\nShading intersect(vec3 rayOrig, vec3 rayDir) \n{\n    Shading shading;\n    \n    Obj obj = castRay(rayOrig, rayDir);\n    \n    shading.intersection = obj;\n    shading.transparent = false;\n    shading.mirror = false;\n    shading.absorbance = vec3(0.);\n\n    vec3 skyColor = vec3(0.2);\n    \n    if (obj.type != GROUND || obj.type != SKY) \n    {\n        shading.intersection.normal = calcNormal(obj.position);\n    }\n    \n    if (obj.type == GROUND) \n    {\n        shading.intersection.normal = vec3(0.0, 1.0, 0.0);\n        shading.color = groundColor(obj, rayDir, skyColor);            \n    } \n    else if (obj.type == SKY) \n    { \n        shading.color = skyColor;\n        shading.intersection.normal = vec3(0.0);    \n    } \n    else if (obj.type == MENGERSPONGE) \n    {    \n       float ao = calcAO(shading.intersection.position, shading.intersection.normal);\n       shading.color = vec3(0.1, 0.3, 0.1);       \n       shading.color *= ao;        \n    } \n    else if (obj.type == BOX) \n    {     \n       shading.transparent = true;\n       shading.color = vec3(0., 0., 0.05);\n       shading.refractiveIndex = 1.125;\n       shading.absorbance = vec3(.81, .81, .40);        \n    } \n    else if (obj.type == BOX2) \n    {       \n       shading.mirror = true;\n       shading.color = vec3(0., 0., 0.2);    \n    } \n    else if (obj.type == BOX3)\n    {     \n       shading.transparent = true;\n       shading.refractiveIndex = 1.;\n       shading.absorbance = vec3(.01, .81, .81);\n       shading.color = vec3(.3, 0., 0.);\n    }   \n   \n    return shading;\n}\n\n// If a ray hits a transparent object, the refracted ray is bounced \n// inside the object to get the refracted color.\nvec3 getInternalColor(vec3 hitPos, vec3 normal, vec3 camDir, float refractiveIndex, \n                      vec3 absorbance)\n{\n    vec3 rayDir = refract(camDir, normal, REFRACTIVE_INDEX_OUTSIDE / refractiveIndex);\n    \n    // Move the ray slightly inside the object to prevent it hitting\n    // the same object again.\n    vec3 rayPos = hitPos + rayDir * .001;\n        \n    float multiplier = 1.0;\n    float absorbDistance = 0.0;  \n   \n    vec3 refractedColor = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) \n    {    \n        Shading shading = intersect(rayPos, rayDir);\n        rayPos = shading.intersection.position;\n        \n        bool incoming = dot(rayDir, shading.intersection.normal) < 0.0;\n        vec3 orientingNormal = -shading.intersection.normal;\n        if (incoming)\n            orientingNormal = shading.intersection.normal;\n            \n        // Calculate Beer's law absorption.       \n        absorbDistance += shading.intersection.dist;\n        vec3 absorb = exp(-absorbance * absorbDistance);\n        \n        float reflectMultiplier = fresnelAmount(refractiveIndex, REFRACTIVE_INDEX_OUTSIDE,\n                                                orientingNormal, rayDir);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // Add the color of the point outside hit by the refracted ray.\n        vec3 refractDir = refract(rayDir, orientingNormal, \n                                  refractiveIndex / REFRACTIVE_INDEX_OUTSIDE);            \n        shading = intersect(rayPos+ refractDir*0.01, refractDir);\n        refractedColor += shading.color * refractMultiplier * multiplier * absorb;\n          \n        // Follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, orientingNormal);\n\n        // Move the ray slightly down the reflect path to prevent it hitting\n        // the same object again.\n        rayPos += rayDir * .01;\n        \n        multiplier *= reflectMultiplier;\n    }\n    \n    return refractedColor;\n}\n\nvec3 renderScene(vec3 camPos, vec3 camDir) \n{                                \n    Shading shading = intersect(camPos, camDir);\n    \n    float reflectMultiplier = fresnelAmount(REFRACTIVE_INDEX_OUTSIDE, shading.refractiveIndex,\n                                            shading.intersection.normal, camDir);\n    float refractMultiplier = 1.0 - reflectMultiplier;\n  \n    // Get the reflected color\n    vec3 reflectedCol = vec3(0.0);\n    if (shading.mirror)\n    {\n        vec3 reflectDir = reflect(camDir, shading.intersection.normal);\n        Shading reflected = intersect(shading.intersection.position + reflectDir*0.01, reflectDir);\n        reflectedCol = reflected.color * reflectMultiplier;\n    }\n    \n    // If the object isn't transparent return, otherwise bounce the reflected ray inside\n    // the box to get the refracted color.\n    if (!shading.transparent) \n        return shading.color + reflectedCol;\n    \n    vec3 refractedCol = getInternalColor(shading.intersection.position, shading.intersection.normal,\n                                         camDir, shading.refractiveIndex, shading.absorbance);\n    refractedCol *= refractMultiplier;\n   \n   return shading.color + reflectedCol + refractedCol;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) \n{  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nmat2 rotate(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinates ranging from -0.5 to 0.5 and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n        \n    // camera\n    vec3 camPos = vec3(16., 10., -28.);\n    camPos.yz *= rotate(-m.y*3.14+1.);\n    camPos.xz *= rotate(-m.x*6.2831);\n    \n    vec3 camTarg = vec3(-2., 0., 2.);\n    mat3 camMat = lookAt(camPos, camTarg, 0.0);\n    \n    vec3 camDir = normalize(camMat * vec3(uv.xy, 1.0));\n    \n    vec3 col = renderScene(camPos, camDir);\n\n    // gamma correction\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[698, 698, 727, 727, 814], [816, 816, 850, 850, 954], [956, 956, 991, 991, 1137], [1139, 1139, 1169, 1169, 1444], [1446, 1446, 1468, 1468, 2295], [2297, 2337, 2363, 2363, 2577], [2579, 2607, 2644, 2644, 3133], [3135, 3340, 3400, 3400, 3686], [3689, 3689, 3759, 3791, 4369], [4371, 4397, 4429, 4429, 5323], [5325, 5456, 5521, 5521, 6150], [6152, 6212, 6259, 6259, 7750], [7752, 7870, 7995, 7995, 9857], [9859, 9859, 9904, 9904, 11073], [11075, 11075, 11127, 11127, 11330], [11332, 11332, 11355, 11355, 11431], [11433, 11433, 11490, 11565, 12103]], "test": "untested"}
{"id": "tlccDs", "name": "#genuary 7: Interference pattern", "author": "illus0r", "description": "#genuary 7: Interference patterns.", "tags": ["cellular"], "likes": 1, "viewed": 291, "published": 3, "date": "1610199526", "time_retrieved": "2024-07-30T19:46:01.837500", "image_code": "//IMG\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec4 tex;\n    o *= 0.;\n    tex=textureLod(iChannel0,uv,.5);\n    o.x+=tex.y/tex.x;\n    tex=textureLod(iChannel1,uv,.5);\n    o.y+=tex.y/tex.x;\n    tex=textureLod(iChannel2,uv,.5);\n    o.z+=tex.y/tex.x;\n    o.w=1.;\n    //uv=abs(uv-.5);\n    //tex=texture(iChannel0,uv);\n    //o-=tex.y/tex.x;\n    \n    //o = texture(iChannel1,uv.xxy+texture(iChannel0,uv).zxy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iFrame, iMouse, vec2(0,-.1));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iFrame, iMouse, vec2(0,.1));\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iFrame, iMouse, vec2(0));\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON\n#define t(uv) textureLod(ch, uv, .5).xy\n#define rnd(x) fract(1e5*sin(1e5*x))\n#define fl(x) floor(x*10.)/10.\n#define R (3.+15.*smoothstep(30.,0.,t))\n#define s(x) smoothstep(0.,1.,x)\n\n#define K (.06)\n#define F (.05)\n#define Da 1.*s(t)\n#define Db .4*s(t)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec4 reaction(vec2 FC, vec2 r, sampler2D ch, float t, int f, vec4 m, vec2 start)\n{\n    vec2 uv=FC/r,_,px=1./r,v=t(uv),dx,dy,d,delta,dir;\n    \n    // flow\n    //uv=((uv-.5)*rot(.05*length(uv-.5))+.5);\n    \n    //vec2(R,0.) will also work \n    _=vec2(R+R*rnd(uv.x+.01*uv.y+t),0.);\n    \n    //uv=abs(uv-.5);\n    \n    dx=(-v+(t(uv+px*_   )+t(uv+px*-_   ))/2.)/2.;\n    dy=(-v+(t(uv+px*_.yx)+t(uv+px*-_.yx))/2.)/2.;\n    \n    //dir=vec2(1,0)*rot(t/10.)*.5+.5;\n    d=(dx+dy)/2.;\n\n    delta.x=Da*d.x-v.x*v.y*v.y+F*(1.-v.x);\n    delta.y=Db*d.y+v.x*v.y*v.y-(K+F)*v.y;\n    vec4 o=vec4(v+delta,1,1);\n\n    if(f==0)o*=0.,o+=1.-step(.05,length(uv-.5-start));//o+=rnd(fl(uv.x)+.01*fl(uv.y));\n    \n    return o;\n}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlccDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 6, 48, 48, 443]], "test": "untested"}
{"id": "wtcyDs", "name": "grid punk", "author": "fofod", "description": "simple grid punk", "tags": ["cooltablegridsimple"], "likes": 3, "viewed": 319, "published": 3, "date": "1610194053", "time_retrieved": "2024-07-30T19:46:02.694211", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xx -.5);\n\t//vec2 uv = (fragCoord.xy / iResolution.xx - 0.5)\n\t float c = 0.02;\n         uv.y+=.22;\n\tuv*= abs(cos(iTime) + 1.);\n\n\tuv*= mat2(sin(iTime),cos(iTime),-cos(iTime),sin(iTime));\n\tvec3 p = vec3(uv,1.0);\n\tc = .3/length(uv);\n\tvec3 mask = fract(p*10.);\n\tvec3 mask1 = fract(p*100.);\n\t// mask*= vec3(1.,0.,0.);\n\tif(mask.x > .05 && mask.y > .05) {\n\t\tmask = vec3(0.);\n\t} else {\n\t\tmask = vec3(1.)*c;\n\t}\n\tif(mask1.x > .05 && mask1.y > .05) {\n\t\tmask1 = vec3(0.);\n\t} else {\n\t\tmask1 = vec3(1.)*c;\n\t}\n\tmask += mask1;\n\tvec3 col = mask * abs(sin(iTime)) * vec3(p +.3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 765]], "test": "untested"}
{"id": "wl3yDs", "name": "Reproject Volumetric quaternion", "author": "ollj", "description": "strave= ESDF             +TG (=up down)   \nrotate= arrows/mouse +WR(roll)\nplaceLight = P+L\n\nvolumetricScattering & TemporalReprojection of\nhttps://www.shadertoy.com/view/wttyDX\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs", "tags": ["fractal", "cloud", "globalillumination", "volumetric", "pathtracing", "importance", "pcg", "quaternioncamera", "crepustularity", "warpspeed", "reproject"], "likes": 7, "viewed": 513, "published": 3, "date": "1610191318", "time_retrieved": "2024-07-30T19:46:03.676583", "image_code": "//Volumetric fractal explorer \n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scattering\n//Multibounce scattering\n//Approximate volumetric reprojection for temporal denoising\nvoid mainImage(out vec4 c,vec2 p\n){c=texture(iChannel0,p/iR.xy)\n ;c=1.07*tanh(pow(c/c.w,vec4(.6)))//this gamma correction is important\n ;}\n \n//MIT License\n//Copyright 2020 Mykhailo Moroz\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//assume as \"Do whatever you want\" License", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//2 volumetric lights with temporal reprojection (scatters in air+clouds)\n//press P or L to place a light at camera position (then fly away from it)\n\n//#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 16\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 8\n    //potato mode\n    //#define TRACE_STEPS 3\n    #define MAX_DIST 10.0\n#else\n    #define MAX_STEPS 40\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 50\n    #define MAX_DIST 100.0\n#endif\n\nconst float FOV=1.\n,LUMINOUSITY     =80.\n,ABSORPSION      =sat(.999)\n,TAA             =sat(.97)//temporal Antialiasing factor (multiplies by the 2 below)\n,TAAMA           =sat(.85)//reprojection ammount\n,TAAMS           =sat(.01)//reprojection smoothness\n,ANISOTROPY      =.3//temporal Anisotropy denoise\n,AMBIENT_FOG     =max(0.001,abs(0.1))//0.001 improves performace\n;\n\nfloat density(//must not be <2. for the mandelbulb\n){return  mix(200.,3.,cos(iTime*.3)*.5+.5)\n ;return  16.;}\n\nfloat min_step(){return 1.25/density();}\n\n//cloud sharpness\n#define sharpness .0001\n\n//light positions\nvec3 lpos1,lpos2;\n\n//subroutine for bicubic texture\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers(float x){return vec4(x*x*x,x*x,x,1.0);}\nconst vec4 ca=vec4( 3,-5, 0,2)/2.;\nconst vec4 cb=vec4(-1, 5,-8,4)/2.;\nvec4 spline(float x,vec4 a,vec4 b,vec4 c,vec4 d\n){return a*dot(cb,powers(1.+x))\n        +b*dot(ca,powers(   x))\n        +c*dot(ca,powers(1.-x))\n        +d*dot(cb,powers(2.-x));}\n//We could expand the powers and build a matrix instead (twice as many coefficients\n//would need to be stored,but it could be faster.\n\n#define SAM(a,b) texture(tex,(i+vec2(float(a),float(b))+.5)/r,-99.)\nvec4 textureBicubic(sampler2D tex,vec2 t\n){//return texture(tex,t)//skip override\n ;vec2 r=vec2(textureSize(tex,0))\n ;vec2 p=r*t-.5\n ;vec2 f=fract(p)\n ;vec2 i=floor(p)\n ;return spline(f.y,spline(f.x,SAM(-1,-1),SAM(0,-1),SAM(1,-1),SAM(2,-1))\n                   ,spline(f.x,SAM(-1,0),SAM(0,0),SAM(1,0),SAM(2,0))\n                   ,spline(f.x,SAM(-1,1),SAM(0,1),SAM(1,1),SAM(2,1))\n                   ,spline(f.x,SAM(-1,2),SAM(0,2),SAM(1,2),SAM(2,2)));}\n\n//blue noise\nvec4 rand4blue(){return texelFetch(iChannel1,shift2(),0);}\n\nvec4 mandelbulb_fog(vec3 p,float K\n){vec4 d=dfo(p)\n ;return vec4(density()*ma0(1.-d.yzw)*smoothstep(K,0.,d.x),d.x);}\n\nvec4 box_fog(vec3 p,vec3 b,float k\n){vec3 refl=normalize(vec3(0.4,0.6,0.9))\n ;float sc=1.0\n ;for(int i=0;i < 6;i++\n ){refl.xy=rot(1.6)*refl.xy\n  ;p-=2.*max(dot(refl,p),0.)*refl\n  ;refl.yz=rot(2.1)*refl.yz\n  ;p+=0.015*sin(10.*dot(refl,p)+sin(p.x*p.y));}\n ;float sdf=sdBox(p,b)/sc\n ;return vec4(density()*(vec3(.3,.6,.9)*+(.5+.5*sin(40.*vec3(.392,.580,1.000)*p.x)))*smoothstep(k,-k,sdf),sdf);}\n\nvec4 fogDens(vec3 p\n){vec4 box=mandelbulb_fog(p,sharpness)//box_fog(p,vec3(0.7,0.3,0.2),sharpness);\n ;float shells=min(MAX_DIST+0.6-length(p),min(distance(p,lpos1),distance(p,lpos2))) //light source and background\n ;return vec4(box.xyz+vec3(0.141,0.439,1.000)*AMBIENT_FOG,min(box.w,shells));}\n\nvec4 choose_light(vec3 p,float r\n){float t1=distance(lpos1,p)\n ;float t2=distance(lpos2,p)\n ;float prob=t1/(t1+t2)\n ;return (r>prob)?vec4(lpos1,prob):vec4(lpos2,1.-prob);}\n\n//trace a multibounce light path to the lights\nvec3 trace(vec3 ro,vec3 id,float dither\n){//acc opacity\n ;vec3 k=vec3(1)\n ;float step_size\n ;float td =0.\n ;float pdf=1.\n ;vec2 r=rand2()\n ;vec4 l=choose_light(ro,r.x)    //sample light importance \n ;pdf*=l.w\n ;vec3 rd=id\n ;float dist=MAX_DIST\n ;int ss=(r.y < 0.5)?(TRACE_STEPS/3):0//scatter samples \n ;int i=0\n ;for(;i < TRACE_STEPS;i++\n ){vec4 rho=fogDens(ro)\n  ;step_size=(1.0-DITHER*dither)*max(rho.w,max(max(min_step(),SCALING*td),5e-5*length(rho)))\n  ;vec3 absorption=exp(-step_size*rho.xyz*ABSORPSION)\n  ;k *=absorption//acc\n  ;rd=(i < ss)?normalize(mix(rd,udir(),1.-exp(-step_size*length(rho.xyz)*(1.-ANISOTROPY)))):rd//scatter\n  ;if(i ==ss//shoot shadow ray\n  ){vec3 prd=rd\n   ;dist=distance(l.xyz,ro)+2e-2\n   ;rd=(l.xyz-ro)/dist\n   ;pdf*=4.*pi*dist*dist //light distance pdf\n   ;pdf/=HenyeyGreenstein(ANISOTROPY,dot(prd,rd));}\n  ;if(length(k) < 0.07 || distance(ro,vec3(0))>2.0 || td>dist) break\n  ;ro+=rd*step_size\n  ;td+=step_size;}\n  ;return float(i>=ss)*LUMINOUSITY*k*smoothstep(.068,.07,length(k))/pdf;}\n\n//return previous screenspace address to be returned\n//use previous camera matrix and camera position to reproject a point onto previos frame\nvec2 reproject(vec3 p){\n #if (camType==0) \n ;mat3 cam=getCam(get(camA0p).xy)//camA0p stores jaw and roll\n #else \n ;mat3 cam=q2m(get(camA0p))//stores quaternion\n #endif\n ;vec3 s=inverse(cam)*normalize(p)\n ;return vec2(s.yz*iR.y/(FOV*s.x)+.5*iR.xy);}\n\n#define FieldOfView 2.5\nv22 getRay(vec2 u//uU is not normalized\n){u=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get(camA0),get(camP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                   +(m*vec3(1,0,0)*u.x//right+forward...\n                   +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n\nvoid mainImage( out vec4 c,in vec2 p\n){rng_initialize(p,iFrame)\n #if (camType==0)  \n ;vec2 uv=(p-0.5*iResolution.xy)/iResolution.y\n ;mat3 cam=getCam(get(camA0).xy)\n ;vec3 campos=get(camP0).xyz\n ;vec3 ro=campos\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n #else\n ;vec3 campos=get(camP0).xyz\n ;vec3 ro=campos\n  /*\n ;mat3 cam=getCam(iChannel3)\n ;vec2 uv=(p-0.5*iResolution.xy)/iResolution.y\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n ;rd=vq2v(rd,get(camA0))//bad slow fix, rotate ray by quaternion\n ;rd=normalize(rd)\n ;//abofe is different from below (above fails to reproject properly)\n */\n ;vec4 q=get(camA0)\n ;mat3 cam=q2m(q)\n ;vec2 uv=(p-0.5*iResolution.xy)/iResolution.y\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n #endif\n ;lpos1=get(li0P0).xyz\n ;lpos2=get(li1P0).xyz\n ;vec4 brand=rand4blue()\n ;float dither=brand.x\n ;vec3 k=vec3(1)//acc opacity\n ;vec3 col=vec3(0)//acc light to camera\n ;int L=0    //main camera ray\n ;float step_size\n ;float td=0.\n ;vec4 maxl_p=vec4(0)\n ;int i=0\n ;for(;i<MAX_STEPS;i++\n ){vec4 rho=fogDens(ro)\n  ;step_size=(1.0-DITHER*dither)*max(rho.w,max(max(min_step(),SCALING*td),2e-5*length(rho)))\n  ;vec3 absorption=exp(-ABSORPSION*step_size*rho.xyz)\n  ;vec2 ldis=vec2(distance(lpos1,ro),distance(lpos2,ro))\n  ;vec3 scattering=k.xyz*(1.-absorption.xyz)\n  ;col+=vec3(LUMINOUSITY/10.)*k.xyz*(step(ldis.x,LIGHT_RADIUS)+step(ldis.y,LIGHT_RADIUS))\n  ;if(((rho.z>1.0)||rho.z>.005 && i%4 ==0)\n  ){vec3 incoming=trace(ro,rd,brand.z)\n   ;float pdf=(rho.z>0.005 && rho.z<1.)?0.25:1.\n   ;col+=scattering*incoming/pdf;}\n  ;k*=absorption//acc\n  ;td+=step_size\n  ;ro+=step_size*rd\n  ;float ls=length(scattering)\n  ;maxl_p=(ls>maxl_p.w)?vec4(ro,ls):maxl_p\n  ;if(length(k) < 0.2 || distance(ro,vec3(0))>MAX_DIST) break;}\n ;if(i >=MAX_STEPS && length(k)>1.05) maxl_p.xyz=ro\n ;//col=vec3(distance(maxl_p.xyz,campos)/3.)//monochrome distance overwrite\n ;vec3 prev=get(camP0p).xyz\n ;//pcam_pos.xyz=vq2v(pcam_pos.xyz,get(camA0)) //testing this\n ;//maxl_p.xyz=vq2v(maxl_p.xyz,get(camA0)) //testing this\n ;vec2 r=reproject(prev-maxl_p.xyz)/iR.xy\n ;c=vec4(col,1)+textureBicubic(iChannel0,r)\n               *TAA*mix(1.,TAAMA,smoothstep(0.,TAAMS,length(prev-campos)))//accumulation movement\n               *mu(step(abs(r-vec2(.5)),vec2(.5)))//accumulation outside prev frame\n \n ;if(iFrame < 2) c=vec4(col,1);}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Camera Controller (quaternion 2023-04) //only more comments where added\n//a normalize(quaternion) was replaced by qn(quaternion), skipping 1 sqrt()\n//this sqrt() of normalize() can be skipped IFF the lengtht-of-the-vector is close to 1.\n//stores position,movement,angle,angularVelocity of a camera.\n//also contains the non-quaternion camera controller (toggle is in commontab)\n\n//stores the 2 positions of 2 re-sapwnable point-lights (P+L keys)\n//DUPLICATE stores previous-frame-camera-position for Temporal Reprojection\n//DUPLICATE previous-frame-camera-angle           for Temporal Reprojection\n//the above 2 are a lazy+inefficient merge in favor of compatibility\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code (read keys and read buffered pixels)\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\n\n//drag used by 2 different fragments (diminishing speeds)\n//the noRoll-camera-buffer does not differentiate between angular-drag and linear-drag\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n#if (camType==0) \nvec4 cp0( //set camera position\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0(//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){\n  ;float d=PHYSICS_RADIUS-df(r.xyz)\n  ;if (d>0.)r.xyz+=normal(r)*d //optional collision\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(//set camera movement direction (first derivative of camera position over time)\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else\nvec4 cp1(//returns camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //set camera angle\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else\nvec4 ca0(//return camera angle (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n ;return qn(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n#endif\n\n#if (camType==0) \nvec4 ca1(//return camera angular velocity (first derivative of camera rotation over time)\n//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//the reprojection shader /wl3yDs also lets you change the position of 2 point-lights\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n\n\n//it is important to only calculate things, that are needed for the buffering pixel.\n//the top-level-functions below focus on what point needs to be calculated.\n//this also minimizes for what pixels need to be READ, which is the SLOWEST-function.\nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}//position + movement\n ;         if(u==camP1)return cp1();return ca1();}//rotation + angularVelocity\n\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous CAMERA position for Temporal Reprojection\n ;if(u==camA0p)return get(camA0)//memorize previous CAMERA angle    for Temporal Reprojection\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))//position of point-light-A\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))//position of point-light-B\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//--- Start of Camera Controller (quaternion 2023-04) \n//only more comments where added and 1 normalize() replaced by qn()\n\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam] in terms of\n//- noRoll is NOT a quaternion camera, and could gimbal-lock, IF it could roll.\n//- does not allow for roll (and thus it never gimbal)-locks\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//- angular drag and linear drag use the same subroutine, but 2 different scaling-factors\n//- - but [noRoll] is faster and simpler to use, (for sets, where you walk on flat-ground)\n\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera rotation of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;\n//camera starting position\nconst vec4 posStart=vec4(-1.5,1.5,0,1);\n\n#if (camType==0) \n #define CAMERA_SPEED .05\n //todo, make linear+angular drag of the quaternuion-camera scaleable here\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n const float\n  //set PHYSICS_RADIUS to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=-100.\n ,LIN_ACCE=.5//linear accelleration\n ,ANG_ACCE=2.//angular accelleration\n ,LIN_DRAG=1.//linear drag\n ,ANG_DRAG=2.//angular drag\n;\n#endif\n//#endif\n\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n\n//-- end of Start of Camera Controller (quaternion 2022-02)\n\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\n//- distance Field\n\n//mandelbulb fractal\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance, o.yzw are for orbittrap memory\n//w.xyz=uv    ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);}\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;o.x=0.25*log(w.w)*sqrt(w.w)/o.x;return o;}\nfloat mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;return 0.25*log(w.w)*sqrt(w.w)/o.x;}\n//the only difference is return type, dfo returns more debug params.\nfloat df (vec3 u){u=repeat(u);return mandelBulb (u);}\nvec4  dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\nvec3 normal(in vec3 p //4-tap derivative3D (laziest approach)\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix accumulating rounding errors.\n//return normalize(q) or the FAST approximation qn() are unnecessary, as long as lenght(q) is close to 1.\n//how often you do this is up to you.\n//\n//assuming length(q) is already close to 1, for normalize(q) we can skip the sqrt() within normalize(x)=x/sqrt(dot(x,x)) to qnorm(x)=x/dot(x,x)\n//for quaternion-normalization x=x/dot(x,x) is estimated well enough by (.5*(3.-dot(x,x))*x), even skipping the division\n//and quite often a rounding-error does not occur, and the vector is lenght(x)==1, where we only need a dot(x,x)\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n// quaternion & vectors\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//alternatively, a more-subroutine-using-approach is  \n//q2q(q2q(aa2q()))) as in  https://www.shadertoy.com/view/DdXXzN\n//or you convert all to matrices and multiply matrixes.\n//\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//above takes 3 params, below only takes 2 params (roll==0 ?)\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-this type of conversion function \n //...ports poorly between any 2 shaders due to handedness-of-coordinate systems\n //... and due to (local) POLAR scalars+offsets\n //... and due to order-of-yaw-pitch-roll (non commutativity of rotations in 3d)\n\n\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n//---end__ quaternion\n\n\n\n\n//damn, this is a fisheye cam that is just as complex.\n//in short i fail\n\n//getRayDir() lookAtCamera is 3* normalize(cross()), it seems to be a lazy and slow camera.\n//quatrernion alternatives exist:\n//https://www.shadertoy.com/view/wl3yDs\n//commontab has quaternion functions:\nvec3 getCam(vec3 ro, vec3 lookAt, vec2 uv\n){/*\n ;vec3 f = normalize(lookAt - ro)\n ,r = normalize(cross(vec3(0, 1, 0), f))\n ;return normalize(f + r * uv.x + cross(f, r) * uv.y);/**/\n ;\n ;vec4 quatUv=eYPR2q(vec3(uv,0.).zxy)//fragCoord.xy/iResolution*2.-1.) //uv.y not scaled by AspectRatio?\n ;lookAt=normalize(lookAt-ro)\n ;vec3 rayDirection=qv2v(quatUv,lookAt)*vec3(1,-1,1)\n ;return rayDirection;}\n /**/\n\nmat3 getCam(vec2 a// phi.x,theta.y\n){vec3 x_dir=vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y))\n ;vec3 y_dir=normalize(cross(x_dir,vec3(0,0,1)))\n ;vec3 z_dir=normalize(cross(x_dir,y_dir))\n ;return mat3(x_dir,y_dir,z_dir);}\n\nmat3 getCam(sampler2D s//buffer is a quaternion\n){return q2m(get2(camA0,s));}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 200, 235, 235, 338]], "test": "untested"}
{"id": "wt3cWs", "name": "Animated Miffy style rabbit", "author": "intrakits", "description": "I wanted to make miffy, lol. This was also a good practice at making more complex 2D shapes (although i think some of my approaches are fairly hacky).", "tags": ["2d", "cute", "animated", "shapes", "rabbit", "miffy"], "likes": 3, "viewed": 299, "published": 3, "date": "1610169818", "time_retrieved": "2024-07-30T19:46:04.529303", "image_code": "mat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nvec3 circle (vec2 uv, float posX, float posY, float r, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    \n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 circle (vec2 uv, float r, float blur, vec3 color){\n    float d = length(uv);\n    return color * vec3(smoothstep(r,r-blur,d));\n}\nvec3 square(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv*=rotate(rot);\n    float wPos = length(uv.x-posX);\n    float hPos = length(uv.y-posY);\n    \n    float col = smoothstep(w,w-blur, wPos);\n    col *= smoothstep(h,h-blur, hPos);\n    return color*vec3(col);\n}\nvec3 triangle(vec2 uv, float w, float h, float posX, float posY, float rot, float blur, vec3 color){\n    uv.x-=posX;\n    uv.y-=posY;\n    uv*=rotate(rot);\n    vec3 sq = square(uv,w,h,0.,0.,0.,blur,color);\n    uv*=rotate(3.1415/2./2.);\n    uv-= vec2(0.,h);\n    float hyp = sqrt(w*w + h*h);\n    vec3 sqMask = square(uv,hyp,h,0.,0., 0.,blur,color);\n    sq -= sqMask;\n    return sq;\n}\nvec3 ellipse(vec2 uv, float posX, float posY, float rot, float a,float b, float blur, vec3 color){\n    uv -= vec2(posX,posY);\n    uv*=rotate(rot);\n    float x = uv.x;\n    float y = sqrt((1.-a)*(1.-((x*x)/(1.-b))));\n    float d = length(uv);\n    return color * vec3(smoothstep(y,y-blur,d));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv-= 0.5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    //background\n    float blur = 0.01;\n    vec3 col = square(uv, 1., .3, 0., -.4,0., blur, vec3(0,.5,.2));\n    col = max(col, square(uv, 1., .3, 0., .2,0., blur, vec3(0.,0.,.5)));\n    \n    //ears\n    float a = 0.95;\n    float b = 0.995;\n    float posX = -0.1;\n    float posY = 0.14;\n    float rot = -0.1;\n    \n    //left ear outline\n    col = min(col,col-ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    \n    //left ear fill\n    a = 0.96;\n    b = 0.997;\n    col = max(col,ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    \n    //right ear outline\n    a = 0.95;\n    b = 0.995;\n    posX = 0.1;\n    posY = 0.14;\n    rot = 0.1;\n    col = min(col,col-ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    \n    //right ear fill\n    a = 0.96;\n    b = 0.997;\n    col = max(col,ellipse(uv, posX, posY-sin(iTime)*.025, rot, a, b, blur, vec3(1.)));\n    //legs\n    col = min(col,col-circle (uv - vec2(.1,-.46), .08, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(.1,-.46), .07, blur, vec3(1.)));\n    col = min(col,col-circle (uv - vec2(-.06,-.46), .08, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(-.06,-.46), .07, blur, vec3(1.)));\n    //shirt\n    a = 0.93;\n    b = 0.91;\n    posX = 0.;\n    posY = -0.35;\n    rot = 3.14159/2.;\n    \n    col = min(col, col-ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.))+square(uv, .3, .1, 0., -0.44,0., blur, vec3(1)));\n    a = 0.935;\n    b = 0.92;\n    col = max(col, ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.,.4,.0))-square(uv, .254, .1, 0., -0.42,0., blur, vec3(1)));\n    \n    \n    a = 0.93;\n    b = 0.99;\n    posY = -0.4;\n    col = min(col, col-ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.)));\n    a = 0.9299;\n    b = 0.988;\n    posY = -0.382;\n    col = max(col, ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.,.4,0)));\n    \n    col = min(col, col - square(uv, .263, .05, 0., -0.37,0., blur, vec3(1)));\n    col = max(col, square(uv, .249, .056, 0., -0.3699,0., blur, vec3(1.,.4,0)));\n    \n    //arms\n    col = min(col,col-circle (uv - vec2(.27,-.35), .06, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(.27,-.35), .053, blur, vec3(1.))); \n    \n    col = min(col,col-circle (uv - vec2(-.27,-.35), .06, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(-.27,-.35), .053, blur, vec3(1.))); \n    //head\n    a = 0.95;\n    b = 0.91;\n    posX = 0.;\n    posY = -0.1;\n    rot = 3.14159/2.;\n    \n    col = min(col, col-ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.)));\n    a = 0.954;\n    b = 0.933;\n    col = max(col, ellipse(uv, posX, posY, rot, a, b, blur, vec3(1.)));\n    //ear mask\n    \n    col = max(col,circle (uv - vec2(.094,.07), .055, blur, vec3(1.))); \n    col = max(col,circle (uv - vec2(-.094,.07), .055, blur, vec3(1.))); \n    \n    //eyes\n    col = min(col, col-circle (uv - vec2(.1,-sin(iTime)*.025-.12), 0.015, blur, vec3(1.)));\n    col = min(col, col-circle (uv - vec2(-.05,-sin(iTime)*.025-.12), 0.015, blur, vec3(1.)));\n    \n    //mouth\n    col = min(col, col-square(uv-=vec2(-0.1,-.37-sin(iTime)*.025), .03, .01, 0., .2,0.7, blur, vec3(1.)));\n    col = min(col, col-square(uv-=vec2(0.26,-sin(iTime)*.004), .03, .01, 0., .2,-0.7, blur, vec3(1.)));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [100, 100, 179, 179, 293], [294, 294, 349, 349, 426], [427, 427, 525, 525, 736], [737, 737, 837, 837, 1116], [1117, 1117, 1215, 1215, 1408], [1409, 1409, 1466, 1516, 4887]], "test": "untested"}
{"id": "wttyDX", "name": "Mandelcloud explorer", "author": "michael0884", "description": "WASD/Arrows and mouse to move camera. Q/E regulate camera speed. Press P/L to set light 1/2 position around camera.", "tags": ["fractal", "interactive", "mandelbulb", "volumetric", "pathtracing", "importance"], "likes": 86, "viewed": 2375, "published": 3, "date": "1610165607", "time_retrieved": "2024-07-30T19:46:05.489735", "image_code": "//Volumetric fractal explorer \n\n//MIT License\n//Copyright 2020 Mykhailo Moroz\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//assume as \"Do whatever you want\" License\n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scatteringw\n//Multibounce scattering\n//Camera controls\n//Light position control\n//Approximate volumetric reprojection for temporal denoising\n\n//Instructions\n//WASD/Arrows and mouse to move camera. Q/E regulate camera speed. \n//Press P/L to set light 1/2 position around camera.\n//Change parameters in Common tab\n//TAA regulates denoising\n//Set AMBIENT_FOG to 0.0 to disable fog(improves performace)\n//comment LOW_QUALITY for longer light paths\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec4 data = texture(iChannel0, p/iResolution.xy);\n    c = 1.07*tanh(pow(data/data.w, vec4(0.6)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LOW_QUALITY\n\n//short or long light paths\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 20\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 8\n    //potato mode\n    //#define TRACE_STEPS 3\n    #define ERROR_THRESHOLD 0.8\n    //the probability of scattering into a shadow direction, i.e. inverse scattering strength \n    #define SHADOW_SCATTER_P 0.75\n    //temporal denoiser\n    #define TAA 0.98\n#else\n    #define MAX_STEPS 32\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 32\n    #define ERROR_THRESHOLD 0.3\n    #define SHADOW_SCATTER_P 0.99\n    #define TAA 0.999\n#endif\n\n#define MAX_DIST 10.0\n#define ABSORPSION 0.78\n#define SCATTERING 1.0\n\n#define ANISOTROPY 0.3\n\n#define AMBIENT_FOG 0.16\n#define LIGHT_RAD 0.02\n#define LIGHT_BRIGHTNESS 250.0\n\n\n#define SCATTER_K 100.\n\n//cloud sharpness\n#define sharpness 0.00001\n#define DENSITY 16.0\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n#define N 10\n\n#define MOUSE_ 0\n#define CAM_ANGLE_ 1\n#define CAM_POS_ 2\n#define CAM_VEL_ 3\n#define CAM_MAX_VEL_ 4\n#define LIGHT_POS1_ 5\n#define LIGHT_POS2_ 6\n#define PCAM_ANGLE_ 7\n#define PCAM_POS_ 8\n#define PRESOLUTION_ 9\n\n#define GET_DATA(i) texelFetch(iChannel2, ivec2(i, 0), 0)\n\n//CAMERA stuff\n#define FOV 1.0\n\nmat3 get_cam(float phi, float theta)\n{\n    vec3 x_dir = vec3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,0,1)));\n    vec3 z_dir = normalize(cross(x_dir, y_dir));\n    return mat3(x_dir, y_dir, z_dir);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers( float x ) { return vec4(x*x*x, x*x, x, 1.0); }\n\nconst vec4 ca = vec4(   3.0,  -5.0,   0.0,  2.0 ) /  2.0;\nconst vec4 cb = vec4(  -1.0,   5.0,  -8.0,  4.0 ) /  2.0;\n\nvec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )\n{\n    // We could expand the powers and build a matrix instead (twice as many coefficients\n    // would need to be stored, but it could be faster.\n    return c0 * dot( cb, powers(x + 1.0)) + \n           c1 * dot( ca, powers(x      )) +\n           c2 * dot( ca, powers(1.0 - x)) +\n           c3 * dot( cb, powers(2.0 - x));\n}\n\n\n#define SAM(a,b)  texture(tex, (i+vec2(float(a),float(b))+0.5)/res, -99.0)\n\nvec4 texture_Bicubic( sampler2D tex, vec2 t )\n{\n    vec2 res = vec2(textureSize(tex,0));\n    vec2 p = res*t - 0.5;\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n\n    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),\n                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),\n                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),\n                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));\n}", "buffer_a_code": "float min_step;\n\n//light positions\nvec3 lpos1, lpos2;\n\n//blue noise\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\nvec4 mandelbulb_fog(vec3 p, float K) {\n    vec3 w = p;\n    float m = dot(w, w);\n    vec3 orbitTrap = vec3(1.);\n\tfloat dz = 1.0;\n    for(int i = 0; i < 5; i++){\n        if(m > 1.2) break;\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n        m = dot(w, w);\n        orbitTrap = min(abs(w)*1.2, orbitTrap);\n    }\n    float sdf = 0.25*log(m)*sqrt(m)/dz;\n    vec3 col = max(1. - orbitTrap, 0.0)*smoothstep(K,0.0,sdf);\n    return vec4(DENSITY*col, sdf);\n}\n\nvec4 box_fog(vec3 p, vec3 b, float k)\n{\n    vec3 refl = normalize(vec3(0.4,0.6,0.9));\n    float sc = 1.0;\n    for(int i = 0; i < 6; i++)\n    {\n        refl.xy = rot(1.6)*refl.xy;\n        p -= 2.*max(dot(refl, p), 0.)*refl;\n        refl.yz = rot(2.1)*refl.yz;\n        p += 0.015*sin(10.*dot(refl,p) + sin(p.x*p.y));\n    }\n    float sdf = sdBox(p,b)/sc;\n    return vec4(DENSITY*(vec3(.3, .6, .9)* + (0.5 + 0.5*sin(40.*vec3(0.392,0.580,1.000)*p.x)))*smoothstep(k,-k,sdf), sdf);\n}\n\nvec4 density(vec3 p){\n    vec4 box = mandelbulb_fog(p, sharpness);//box_fog(p, vec3(0.7,0.3,0.2), sharpness); \n    float shells = min(MAX_DIST + 5.0 - length(p), min(distance(p, lpos1),distance(p, lpos2))); //light source and background\n    return vec4(box.xyz + vec3(0.141,0.439,1.000)*AMBIENT_FOG, min(box.w, shells));\n}\n\n\nvec4 choose_light(vec3 p, float r)\n{\n    float t1 = distance(lpos1, p);\n    float t2 = distance(lpos2, p);\n    float prob = t1*t1/(t1*t1+t2*t2);\n    return (r > prob)?vec4(lpos1, 1.-prob):vec4(lpos2, prob);\n}\n\n//trace a multibounce light path to the lights\nvec3 trace(vec3 ro, vec3 id, float dither)\n{\n    //cumulative opacity\n    vec3 k = vec3(1.0);\n    //cumulative scattering\n    vec3 sk = vec3(1.0);\n  \n    float step_size;\n    float td = 0.;\n    \n    vec3 pdf = vec3(1.0);\n   \n    //light importance sampling   \n    vec4 l = choose_light(ro, rand());\n  \n    //light choise pdf\n    pdf*=l.w;\n    vec3 rd = id;\n    float dist = MAX_DIST;\n    \n    int i = 0;\n    \n    dist = distance(l.xyz, ro)+2e-2;\n   \n    pdf*= 4.*PI*dist*dist;\n     dist = MAX_DIST;\n    bool shadowray = false;\n    for(; i < TRACE_STEPS; i++)\n    { \n        vec4 rho = density(ro);\n        step_size = (1.0 - DITHER*dither)*max(rho.w,max(max(min_step,SCALING*td),5e-5*length(rho)));\n        \n        vec3 absorption = exp(-step_size*rho.xyz*ABSORPSION); \n        \n        //accumulate\n        k *= absorption; \n        \n        vec4 r = rand4();\n        td += step_size;\n        //do a scatter\n        if(!shadowray)\n        {\n            //total scattering probability \n            sk *= exp(-step_size*rho.xyz*SCATTERING);\n            \n            //shoot shadow ray \n            if(r.w < SHADOW_SCATTER_P) \n            {\n                pdf*=SHADOW_SCATTER_P/0.5;\n                shadowray = true;\n                vec3 prd = rd;\n                dist = distance(l.xyz, ro)+2e-2;\n                rd = (l.xyz - ro)/dist;\n                \n                //anisotropic scattering \n                pdf/= HenyeyGreenstein(ANISOTROPY, dot(prd, rd));\n                pdf/= (1. - sk);\n            }\n            else //else do normal scattering\n            {\n               \n                rd = normalize(mix(udir(r.yz),rd,exp(-step_size*rho.xyz*SCATTER_K*SCATTERING*(1. - ANISOTROPY))));\n            }\n            td = 0.;\n        }\n\n        \n        if(length(k) < 0.07 || distance(ro, vec3(0)) > 2.0 || td > dist) break;\n        //step ray\n        ro += rd*step_size;\n\n       \n    }\n    return smoothstep(ERROR_THRESHOLD, 0.0, dist - td)*LIGHT_BRIGHTNESS*k*smoothstep(0.068,0.07,length(k))/pdf;\n}\n\n//use previous camera matrix and camera position to reproject a point onto previous frame\nvec3 reproject(mat3 pcam_mat, vec3 pcam_pos, vec2 iRes, vec3 p)\n{\n    float td = distance(pcam_pos, p);\n    vec3 dir = (p - pcam_pos)/td;\n    vec3 screen = inverse(pcam_mat)*dir;\n    return vec3(screen.yz*iRes.y/(FOV*screen.x) + 0.5*iRes.xy, td);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    min_step = 1.25/DENSITY;\n    vec2 uv = (p - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 angles = GET_DATA(CAM_ANGLE_).xy;\n    mat3 cam = get_cam(angles.x, angles.y);\n \n    vec3 campos = GET_DATA(CAM_POS_).xyz; \n    vec3 ro = campos;\n    vec3 rd = normalize(cam*vec3(1.0, FOV*uv));\n    \n    lpos1 = GET_DATA(LIGHT_POS1_).xyz;\n    lpos2 = GET_DATA(LIGHT_POS2_).xyz;\n    \n    vec4 brand = rand4blue();\n    \n    float dither = brand.x;\n    //cumulative opacity\n    vec3 k = vec3(1.0);\n    \n    //accumulated incoming light to the camera\n    vec3 col = vec3(0.); \n    int L = 0;\n    \n    //main camera ray\n    float step_size;\n    \n    float td = 0.;\n    vec4 maxl_p = vec4(0.);\n    \n    int i = 0;\n    for(; i < MAX_STEPS; i++)\n    {\n        vec4 rho = density(ro);\n\n        step_size = (1.0 - DITHER*dither)*max(rho.w,max(max(min_step,SCALING*td),2e-5*length(rho)));\n        \n        vec2 ldis = vec2(distance(lpos1, ro),distance(lpos2, ro));\n        \n        vec3 absorption = exp(-(ABSORPSION + SCATTERING)*step_size*rho.xyz); \n       \n        col += vec3(LIGHT_BRIGHTNESS/10.)*k.xyz*(step(ldis.x,LIGHT_RAD) + step(ldis.y,LIGHT_RAD));\n        \n        if((rho.z > 0.005 && i%4 == 0) || (rho.z > 4.0))\n        {\n            vec3 incoming = trace(ro, rd, brand.z);\n            float pdf = (rho.z > 0.005 && rho.z < 4.0)?0.25:1.0;\n            col += k.xyz*incoming/pdf; \n        }\n       \n        //accumulate\n        k *= absorption;\n        \n        td += step_size;\n        ro += step_size*rd;\n    \n         \n        if(length(k) < 0.2 || distance(ro, vec3(0)) > MAX_DIST) break;\n    }\n    \n    //col = vec3(distance(maxl_p.xyz, campos)/3.);\n    \n    vec2 pcam_angles = GET_DATA(PCAM_ANGLE_).xy;\n    mat3 pcam = get_cam(pcam_angles.x, pcam_angles.y);\n    vec3 pcam_pos = GET_DATA(PCAM_POS_).xyz;\n    \n    vec2 prev_iResolution = GET_DATA(PRESOLUTION_).xy;\n    \n    //reproject\n    vec3 reprj = reproject(pcam, pcam_pos, prev_iResolution, ro);\n    vec2 puv = reprj.xy/iResolution.xy;\n    vec2 dpuv = abs(puv - vec2(0.5));\n    \n    float accumulation = TAA //max accumulation\n                         *mix(1.0, 0.85, smoothstep(0.0, 0.01, distance(campos,pcam_pos))) //reduce accumulation if moving \n                         *step(dpuv.x, 0.5)*step(dpuv.y, 0.5); //outside prev frame\n    //sample prev point\n    // vec4 prev = texture(iChannel0, puv);\n    vec4 prev = texture_Bicubic(iChannel0, puv);\n    \n    prev *= accumulation; //remove samples\n   \n    \n    c = vec4(col,1.0) + prev;\n    \n    if(iFrame < 2) c = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Controller\n\n#define CAMERA_SPEED 3./60.\n#define MOUSE_SENSITIVITY 0.2/60.\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    ivec2 pi = ivec2(p);\n    if(pi.x < N && pi.y < 1)\n    {\n        c = GET_DATA(pi.x);\n        \n        vec4 mouse = GET_DATA(MOUSE_);\n        vec2 mousespeed = mouse.xy;\n        vec4 angles = GET_DATA(CAM_ANGLE_);\n        mat3 camera = get_cam(angles.x, angles.y);\n        vec4 pos = GET_DATA(CAM_POS_);\n        vec4 vel = GET_DATA(CAM_VEL_);\n        vec4 speed = GET_DATA(CAM_MAX_VEL_);\n     \n        switch(pi.x)\n        {\n        case MOUSE_:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tc.xy = iMouse.xy - c.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    c.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tc.xy = vec2(0.); // mouse delta\n            }\n    \t\tc.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case CAM_ANGLE_:  //angle computation\n           \n   \t\t\tc.xy = c.xy + c.zw*MOUSE_SENSITIVITY; // angle delta\n            c.y = clamp(c.y, PI*0.01, PI*0.99);\n    \t\tc.zw += vec2(-1.0, 1.0)*mouse.xy; // mouse pos\n            c.zw *= 0.6;\n            if(iFrame < 1)\n            {\n                c.xy = vec2(-PI*0.27,PI*0.5);\n            }\n            break;\n            \n        case CAM_POS_:  //position\n            if(pos.w > 0.) {c.xyz += 0.05*vec3(sin(iTime), cos(iTime), 0.)*speed.x; c.w = pos.w;}\n            c.xyz += vel.xyz*speed.x;\n            if(length(vel.xyz)>0.1) c.w = 0.;\n   \t\t\tif(iFrame < 1)\n            {\n                c = vec4(-1.5,1.5,0.0,1.0);\n            }\n            \n            break;\n         case CAM_VEL_:  //velocity\n          \n            c.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tc.xyz += camera[0]*speed.x;\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tc.xyz -= camera[0]*speed.x;\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tc.xyz += camera[1]*speed.x;\n                c.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tc.xyz -= camera[1]*speed.x;\n                c.w = 0.;\n            }\n            c.xyz *= 0.8; //slowing down\n            \n            break;\n          case CAM_MAX_VEL_: //camera max speed\n            if(isKeyPressed(KEY_Q))\n   \t   \t\t{\n   \t\t\t\tc.x *= 1.01;\n            }\n            if(isKeyPressed(KEY_E))\n   \t   \t\t{\n   \t\t\t\tc.x *= 0.99;\n            }\n            if(iFrame < 1)\n            {\n                c.x = CAMERA_SPEED;\n            }\n            break; \n          case LIGHT_POS1_:\n            if(isKeyPressed(KEY_P))\n   \t   \t\t{\n                c.xyz = pos.xyz+camera[0]*vec3(LIGHT_RAD*40.);\n            }\n            if(iFrame < 1)\n            {\n                c.xyz = vec3(0.2, 1.0, -0.4);\n            }\n            break;\n          case LIGHT_POS2_:\n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n                c.xyz = pos.xyz+camera[0]*vec3(LIGHT_RAD*40.);\n            }\n            if(iFrame < 1)\n            {\n                c.xyz = vec3(-0.8, 0., 0.);\n            }\n            break;\n          case PCAM_ANGLE_:\n            c = angles;\n            break;\n          case PCAM_POS_:\n            c = pos;\n            break;\n          case PRESOLUTION_:\n            c.xy = iResolution.xy;\n            break;\n        }   \n    } else discard;\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyDX.jpg", "access": "api", "license": "mit", "functions": [[1364, 1666, 1707, 1707, 1811]], "test": "untested"}
{"id": "wttcRN", "name": "Hall of Decent", "author": "Plento", "description": "quick lil thing as I put off HW.", "tags": ["3d", "raymarch"], "likes": 12, "viewed": 356, "published": 3, "date": "1610157977", "time_retrieved": "2024-07-30T19:46:06.264663", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat opsub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat rBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nvec3 ref(vec3 rp, vec3 q){\n    return -vec3(abs(rp.x), abs(rp.y), abs(rp.z)) + q*step(vec3(0), q);\n}\n\n\n\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    float tm = (iTime-3.)*2.;\n    \n    rp.z += tm-3.;\n    \n    vec3 p = rp;\n    vec3 b = vec3(4.0, 4., 9.0);\n   \n    p = mod(rp, b)-b*.5;\n    p = -abs(p);\n    \n    \n    float sp = 0.8;\n    \n    float t2 = tm*.1;\n    \n    for(float i = 0.; i < 4.; i++){\n        p.yz *= rot(i*0.01);\n        p.xy *= rot(i*0.4 + rp.z*.07);\n        p.xz *= rot(i*7.);\n        \n        float h = 1.3*max(hash11(i*232.4+34.3)*2.2, 1.7);\n        d = min(rBox(ref(p, vec3(0.3, 0.9, 0.9)), vec3(h, .2, .2), .08), d);\n    }\n    \n    d = opsub(length(rp.xy)-1.9 + cos(rp.z)*.4, d);\n    \n    return d;\n}\n\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nvec2 march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0., c=0., md = 999., acc = 0.0;   \n    float g = 0.;\n    \n    for(int i = 0; i < 64; i++){\n    \n    \td = map(ro + rd*t);\n        \n        if(abs(d) < .0015 || t > 50.) break;\n        \n        t += d * .75;\n        c++;\n    }\n    \n    return vec2(t, c);\n}\n\n\nvec3 color(vec3 p, vec3 rd, vec3 n, float t, float ns){\n    vec3 lp = vec3(-4., -3.0, 0.);\n    \n    vec3 ld = normalize(lp-p);\n   \t\n    float ldist = length(lp - p);\n    float fal = 20. / (ldist*ldist);\n    \n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 18.);\n    float dif = max(dot(n, ld), .01);\n    \n    vec3 col = .75+.75*cos(abs(n) + iTime + 2.*t*vec3(.2, .6, .6));\n    col *= dif * fal;\n    col *= max(abs(cos(abs(n.x*6.))), .7);\n    col += vec3(0.6, 0.8, 0.99) * spec * 0.8;\n    \n    float ao = ss(40., 10., ns);\n    col *= ao;\n    \n    col = mix(vec3(.0), col, exp(-t*t*t*0.0001));\n    \n\treturn col;   \n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv = abs(uv);\n    \n    vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * -.5));\n    vec3 ro = vec3(0., 0.0, 0.);\n    rd.xy*=rot(-iTime*.2);\n    vec2 t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t.x);\n    vec3 col = color(ro + rd*t.x, rd, n, t.x, t.y);\n    \n    \n    col = 1.-exp(-col);\n    col *= ss(0.99, 0.45, abs(uv.x));\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 103, 103, 155], [156, 156, 178, 178, 263], [265, 265, 300, 300, 322], [324, 324, 362, 362, 453], [456, 456, 482, 482, 556], [560, 560, 579, 579, 1180], [1184, 1184, 1211, 1211, 1412], [1414, 1414, 1443, 1443, 1718], [1721, 1721, 1776, 1776, 2353], [2356, 2356, 2396, 2396, 2832]], "test": "untested"}
{"id": "ttcyDl", "name": "Juggling to infinity (with step)", "author": "Kanata", "description": "tweaked my old shader", "tags": ["math", "mathematics"], "likes": 3, "viewed": 227, "published": 3, "date": "1610151256", "time_retrieved": "2024-07-30T19:46:07.061532", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 res = iResolution.xy,\n          uv = ( u* 2. - res) / min(res.x, res.y);\n\n    float t = iTime;\n    float scale = 2.;\n    uv *= scale;\n    \n    float p = length(cmul(cmul(uv, uv),uv) + tan(t)* cmul(uv,uv) + sin(t)* uv+ cos(t));\n    \n    O = vec4(vec3(step(0.5, 0.1 / p)), 1.);\n}", "image_inputs": [], "common_code": "vec2 cmul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 325]], "test": "untested"}
{"id": "3ttcW2", "name": "just a raytracer", "author": "Ric3cir121", "description": "just a raytracing", "tags": ["raytracing"], "likes": 4, "viewed": 312, "published": 3, "date": "1610146137", "time_retrieved": "2024-07-30T19:46:07.869373", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = texelFetch(iChannel0,ivec2(u),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct obj{\n    float d;\n    vec3 col;\n    int ref;\n};\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvec3 rotate(vec3 c,float p){return vec3(c.xz*rotate(p),c.y).xzy;}\n#define hash13(a) fract(sin(a*vec3(1.239,5.283,2.294))*1000000.)\n#define mn(a,b) obj((a.d>b.d?b.d:a.d),(a.d>b.d?b.col:a.col),(a.d>b.d?b.ref:a.ref))\n#define mx(a,b) obj((a.d<-b.d?-b.d:a.d),(a.col),(a.ref))\n#define sphere(a,b,c,d,e) obj(length(a-b)-c/2.,d,e)\n#define cube(a,b,c,d,e,f) obj(length(clamp(a,b-(c-d)/2.,b+(c-d)/2.)-a)-d/2.,e,f)\n#define plane(a,b,c,d) obj(a.y-b.y,c,d)\nobj de(vec3 pos){\n    obj res = obj(10000.,vec3(0),0);\n    res = mn(res,sphere(pos,vec3(0 , -1,-.5),1.    ,vec3(.9,.5,.5),1));\n    res = mn(res,  cube(pos,vec3(-1,-.5,-1 ),1. ,.3,vec3(.9,.5,.9),0));\n    res = mx(res, plane(pos,vec3(0 ,-.99,0 )       ,vec3(.9,.9,.9),2));\n    res = mn(res, plane(pos,vec3(0 , -1, 0 )       ,vec3(.9,.9,.9),2));\n    res = mx(res,  cube(pos,vec3(0 ,-1. ,.5),2. ,1.,vec3(.9,.5,.9),1));\n    res = mn(res,sphere(pos,vec3(.3,  0, 1 ),1.    ,vec3(.5,.5,.9),2));\n    return res;\n}\nvec3 getmarch(vec3 pos,vec3 cam,bool rev){\n    float r = rev?-1.:1.;\n    float d = 9.;\n    vec3 mov = vec3(0);\n    for(int i = 0;i < 1000;i++){\n        d = de(mov+pos).d*r;\n        mov += d*cam;\n        if(length(mov)>100.||d<0.0001)break;\n    }\n    return mov+pos;\n}\nvec3 getcolor(vec3 pos){return de(pos).d>0.01?vec3(1):de(pos).col;}\nvec3 getnormal(vec3 pos){\n    vec2 e = vec2(1,-1)*0.0001;\n    return normalize(e.xyy*de(pos+e.xyy).d+e.yyx*de(pos+e.yyx).d+e.yxy*de(pos+e.yxy).d+e.xxx*de(pos+e.xxx).d);\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = (u+hash13(iTime).xy-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(3,3,-3);\n    vec2 look = vec2(-.7,.7);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    vec3 norm, col = vec3(1),oldmarch;\n    bool rev = false;\n    vec3 march = getmarch(pos,cam,false);\n    for(int i = 0;i < 100;i++){\n        norm = getnormal(march);\n        col *= getcolor(march);\n        if(de(march).d>0.0001)break;\n        if(de(march).ref==1){\n            cam = reflect(cam,norm);\n            march += norm*0.01;\n        }else if(de(march).ref==0){\n            if(!rev)cam = normalize(mix(cam,-norm,0.1));\n            rev = !rev;\n            march+= cam*0.01;\n        }else{\n            cam = normalize(reflect(cam,norm)+(hash13(fract(dot(norm,cam)*iTime))-.5)*0.5);\n            march += norm*0.01;\n        }\n        oldmarch = march;\n        march = getmarch(march,cam,rev);\n        if(rev)col /= pow(length(march-oldmarch),3.)*20.+1.;\n    }\n    col *= getcolor(march);\n\n    o = vec4(col,0);\n    if(u.x<iResolution.x/2.)o = mix(o,texelFetch(iChannel0,ivec2(u),0),1.-1./(texelFetch(iChannel1,ivec2(0),0).x+1.));\n    else o = mix(o,texelFetch(iChannel0,ivec2(u),0),1.-1./(texelFetch(iChannel1,ivec2(1,0),0).x+1.));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 o,vec2 u){\n    if(floor(u)==vec2(0,0)){\n        o = texelFetch(iChannel0,ivec2(0),0)+1.;\n        if(iMouse.z>0.)o = vec4(1);\n    }\n    if(floor(u)==vec2(1,0)){\n        o = texelFetch(iChannel0,ivec2(1,0),0)+1.;\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttcW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 78]], "test": "untested"}
{"id": "ttccWl", "name": "Custom texture", "author": "Ric3cir121", "description": "Really simple custom texture\nAdded \"frames\" that is the number of frames that the image take to be draw\nCode is a lot faster", "tags": ["texture", "image", "custom", "import"], "likes": 1, "viewed": 531, "published": 3, "date": "1610146101", "time_retrieved": "2024-07-30T19:46:09.026279", "image_code": "// See Buffer A\n\n#define smoothstep(a,b,c) mix(a,b,((sin(clamp(c,0.,1.)*2.-1.)+1.)/2.))\n\nvec4 lins(sampler2D h,vec2 c){\n    return texelFetch(h,ivec2(c),0);\n}\nvec4 linr(sampler2D h,vec2 c){\n    c-=.5;\n    vec4 _0 = smoothstep(texelFetch(iChannel0,ivec2(c),0),texelFetch(iChannel0,ivec2(c)+ivec2(1,0),0),fract(c.x));\n    vec4 _1 = smoothstep(texelFetch(iChannel0,ivec2(c)+ivec2(0,1),0),texelFetch(iChannel0,ivec2(c)+ivec2(1,1),0),fract(c.x));\n    \n    return smoothstep(_0,_1,fract(c.y));\n}\nvec4 old(vec2 u){\n    vec4 real = linr(iChannel0,u);\n    vec2 ns[] = \n    vec2[](vec2(-1,-1),vec2(-1,0),vec2(-1,1),vec2(0,-1),vec2(0,0),vec2(0,1),vec2(1,-1),vec2(1,0),vec2(1,1));\n    \n    float mn = 1.;\n    vec4 color;\n    \n    for(int i = 0; i < ns.length();i++){\n        float r = dot(abs(real-linr(iChannel0,floor(u+ns[i])+.5)),vec4(1))/3.;\n        if(r<mn)color = linr(iChannel0,floor(u+ns[i])+.5);\n        mn = min(mn,r);\n    }\n    \n    return color;\n}\nvec4 neural(vec2 u){\n    float s = iResolution.y/size.y;\n    vec2 c = u/s;\n    vec4 _n = texelFetch(iChannel0,ivec2(c),0);\n    vec4 _c = linr(iChannel0,c);\n    vec4 _u = (lins(iChannel0,c+vec2(0,1))+lins(iChannel0,c+vec2(1,1)))/2.;\n    vec4 _d = (lins(iChannel0,c+vec2(0,-1))+lins(iChannel0,c+vec2(1,-1)))/2.;\n    vec4 _l = (lins(iChannel0,c+vec2(-1,0))+lins(iChannel0,c+vec2(-1,1)))/2.;\n    vec4 _r = (lins(iChannel0,c+vec2(1,0))+lins(iChannel0,c+vec2(-1,-1)))/2.;\n    \n    vec4 _o = (_u+_d+_l+_r)/4.;\n    vec4 dif = abs(_n-_o);\n    \n    float mn = .1;\n    return mix(_c,old(c),clamp(( dif-mn)*100.+mn,0.,1.));\n}\nvoid mn(out vec4 o,vec2 u){\n    vec2 uv = u/iResolution.xy;\n\n    o = neural(u);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(0.);\n    vec4 Fr = vec4(0.);\n\tint a = 3;\n    for(int i1 = 0;i1<a;i1++){\n    \tfor(int i2 = 0;i2<a;i2++){\n    \t\tmn(Fr,fragCoord+(vec2(float(i1),float(i2))/(float(a))));\n            fragColor += Fr;\n    \t}\n    }\n    fragColor /= float(a*a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "precision highp float;\n\nvoid mainImage(out vec4 o,vec2 u){\n    o = texelFetch(iChannel0,ivec2(u),0);\n    int frames = 20;\n    if(u.x>size.x||u.y>size.y/*||iFrame>frames*/||mod(u.x+u.y+float(iFrame),float(frames))>1.)return;\n    else{\n        def\n        vec2 r = u;\n        int slide = int(mod(floor(r.x),size.x)+floor(size.y-r.y)*size.x);\n        int p = no;\n        ivec4 s = ivec4(data[slide/p*3],data[slide/p*3+1],data[slide/p*3+2],0);\n        o = mod(vec4(s*int(prc)/int(pow(prc,float(slide%no)+1.))),prc)/prc;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define IM2\n\n#ifndef IM2\n\n#define size vec2(128,72)\n#define def int data[] = int[](16776626,16776626,16776626,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,4095,1755,0,0,0,0,16777208,16777208,16777208,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14385151,14385151,14385151,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,9584639,16773119,16773119,16777180,16777207,16777207,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,9586687,16777215,16777215,16774948,16776703,16776703,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,9586943,16777151,16777151,16770852,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16775551,16773823,16773823,9586911,16777207,16777207,16759076,16773119,16773119,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,15541395,14942208,14942208,9586399,16777207,16777207,16759076,16773119,16773119,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,5242879,524287,524287,6890642,0,0,9581727,16770743,16770743,16660260,16740351,16740351,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,4947967,229375,229375,4793490,0,0,9544211,16756760,16756760,16627428,16739839,16739839,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777206,16777178,16777206,4849663,32767,32767,4793490,0,0,7180314,16715784,16715784,16758491,16772534,16772534,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,7864319,524287,7864319,16776978,16776704,16776978,4816895,32767,32767,4793490,0,0,7184986,14327880,14328392,16758491,16772534,16772534,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,2744319,8191,2744319,16766017,16744448,16766017,4833279,8191,8191,4531346,0,0,7192530,14380992,14380992,16774875,16776630,16776630,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,305023,127,305023,16093184,14942208,16093184,5095423,40959,40959,4756114,0,0,16776466,16776448,16776448,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,4765,1,4765,8945664,0,8945664,7196671,303103,303103,4792923,0,0,16702234,16702216,16702216,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10485759,2097151,10485759,74,0,74,2097152,0,2097152,7208957,2424824,2424829,4793490,0,0,9591651,9587529,9591625,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,6029311,1048575,6029311,1,0,1,2097152,0,2097152,5144572,327672,327676,7152786,2097152,2097152,9587565,9587565,9587565,16777188,16777188,16777188,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,8388607,2097151,8388607,1,0,1,0,0,0,5177339,196600,196603,11379858,8650752,10747904,9587044,7194980,9587044,16775460,16775459,16775460,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10485759,2097151,10485759,10,0,10,0,0,0,7528442,2809848,2809850,11679451,11669513,11669577,9554277,7190885,9292133,16763172,16763171,16763172,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14680063,8388607,14680063,11,0,11,0,0,0,11983730,11983704,11983730,14371620,14370889,14370889,9587037,7227676,9587037,16632100,16632099,16632100,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,20,0,20,0,0,0,11983656,9886472,11983656,9657125,7821604,7821605,9591077,9586980,9591077,16632100,16632100,16632100,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,85,0,85,0,0,0,9886480,9886464,9886480,14080868,14343012,14343012,11946350,9845038,9849198,16632101,16628004,16632100,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,95,7,95,0,0,0,9624337,9623808,9624337,14081452,14081452,14081452,9330101,9297325,9330093,16763245,16759077,16759077,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,679,7,679,0,0,0,11688161,11688192,11688225,9629110,9629110,9629110,7831477,7569324,7569324,16771428,16771427,16771428,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,751,23,751,0,0,0,14077848,14077760,14077848,9596334,9891254,9891254,12320173,12320172,12320172,16739108,16772315,16772380,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,1407,127,1407,0,0,0,12287816,14384320,14384968,11722165,9891318,9891318,14413229,14413164,14413164,16739117,16739677,16739685,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,5503,191,5503,0,0,0,10485000,12581504,12582152,11983806,12021182,12021182,14380461,14380397,14380461,16476965,16739693,16739694,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,6015,831,6015,0,0,0,14674632,14411904,14412488,14379895,14380471,14380471,14118326,14085558,14085558,16476963,16739693,16739693,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,43455,5495,43455,0,0,0,14379720,12277888,12282568,14380398,14380453,14380453,7826870,11988406,11988406,16476963,16739757,16739757,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,342975,10103,342975,0,0,0,14375112,11982976,12015816,14380397,14380252,14380252,7302582,12021174,12021174,16477028,16772533,16772533,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,2739135,43383,2739135,0,0,0,12277969,9881736,9885905,14371109,16753819,16753819,9596343,14085558,14085558,16477036,16772534,16772534,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,2739135,342391,2739135,2097153,0,2097153,11983057,9619656,9885905,7190308,4493971,4493971,11946286,14342958,14342958,16739693,16776630,16776630,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,5135295,2739127,5135295,2359305,0,2359305,11983642,9623761,9624346,7190244,4493971,4493971,11983652,14375707,14375707,16739765,16776630,16776630,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,7495103,5098423,7495103,4489290,2359297,4489290,11983715,9623834,9886563,9287396,4756115,4756115,14343012,14379811,14379811,16772534,16777206,16777206,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,9629119,7232959,9629119,6886035,4489290,6886035,12021100,9886499,9890668,9549604,6890651,6890651,14379884,14379875,14379875,16776630,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,9891327,7527871,9891327,9287388,6886035,9287388,12283309,9891180,12021165,9586981,7190236,7190236,14380397,16477540,16477540,16777142,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12021247,9891327,12021247,11684132,9287387,11684132,14380469,12283309,12283317,11946349,9549604,9549604,14380461,16739692,16739692,16777206,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,12283903,12021247,12283903,11983725,11684132,11983725,14380470,14380469,14380470,11983726,11684141,11684141,16477621,16739757,16739757,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14385151,14381055,14385151,14375790,14080877,14375790,14385078,14380470,14380982,14343094,11983726,11983726,16772534,16772533,16772533,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14417919,14385151,14417919,14380470,14375798,14380470,14417918,14385142,14385150,14380470,14343094,14343094,16777142,16776630,16776630,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14680063,14417919,14680063,14380470,14380470,14380470,14680063,14417918,14417919,14380470,14380470,14380470,16777206,16777142,16777142,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16739767,16477622,16739767,16777215,16777215,16777215,14380471,14380470,14380470,16777214,16777206,16777206,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16772535,16777215,16777215,16777215,16777215,16477695,14380471,14380471,16777215,16777214,16777214,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,0);\n#define prc float(8)\n#define no int(8)\n\n#else\n\n// another image\n#define size vec2(115,68)\n#define def int data[] = int[](0,0,0,0,0,0,0,0,0,4096,4096,4096,0,0,0,8,8,8,262144,262144,262144,2097152,2097152,2097152,64,64,64,0,0,0,64,64,64,0,0,0,2134016,2134016,2134016,2097152,2097152,2097152,16773632,16773632,16773632,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14413311,16777215,16777215,14380983,16449519,16711663,14314918,16777143,16777207,16776623,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14942207,14942207,14942207,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14680063,16777215,14417919,16744383,16777215,14380470,16474102,16769023,14372278,16740341,16773117,16473524,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777159,16777159,16777159,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14643063,16740279,14343535,12283326,12320767,10186166,12282870,14412799,12282294,16777206,16777214,16777205,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16748543,16748543,16748543,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,9850879,14315519,9822207,11987821,14380469,11987820,9624365,14118262,9362221,16763164,16772462,16767709,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,2097151,2097151,2097151,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,14680063,16777215,14680063,9586459,13789605,11130141,7223596,11947373,9255204,9582884,14101349,11708700,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16776767,16776767,16776767,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,5767167,5505023,3145727,7484579,5982372,5387868,16463651,16459699,16426282,16777213,16777213,16777212,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16580607,16580607,16580607,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,10485759,10485759,8388607,11122175,9024959,8725374,6236820,6204044,3840075,16777213,16777213,16777212,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777208,16777208,16777208,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,11983735,16777215,14380479,11983725,16777215,14380470,7462911,7429631,5066175,4863634,4863121,2466889,16365715,16365715,16070218,11983725,16777215,14380470,16767853,16777215,16776630,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16777215,16773631,16773631,16773631,16777215,16777215,16777215,11993087,16777215,14417919,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,16777069,16777215,16744374,5359613,5359101,5060092,16756706,16756706,16719257,11984382,16777214,14380541,11983725,16777215,14380470,11983725,16777215,14380470,16178029,16777215,16477622,16777215,16777215,16777215,14942207,14942207,14942207,11993087,16777215,14385151,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,14080877,14417919,12021174,16515069,16515070,16252341,12580351,12580351,10482687,12058111,16514559,14117887,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,16702317,16777215,16739766,11983687,16777159,14380423,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,16210789,16477111,14080302,16515071,16252927,13893622,11758975,14118271,11721526,11983725,16777214,14380469,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11963245,16748543,14355894,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11684717,14086143,11427262,14375781,16739765,14343020,11918182,14052774,11656029,11983653,16776558,14379805,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,3595117,4194303,3894710,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,16510390,11983725,16777215,14385078,9886573,14680063,10190774,9849627,14085020,11683603,9615725,11980213,9582884,11684131,16436651,13777762,11983725,16777215,14380478,11983725,16777215,14642615,11983725,16777215,14380470,11983725,16777215,14380470,11983725,16777215,14380470,11983405,16776767,14380086,11983725,16777215,14380470,11983725,16777215,14380982,11983725,16777215,14413823,11983725,16777215,16515071,11983725,16777215,14679487,9316717,13585407,9055231,7494444,9886637,5392731,7484645,10176365,7779556,11983716,16777206,16777196,11983725,16777215,16740287,11983725,16777215,14675383,11983725,16777215,14380990,11983725,16777215,14380470,11819885,16547839,14446006,11983725,16777215,14642614,11983725,16777215,14385078,11983725,16777215,14413759,11983725,16777215,16777214,11983725,16777215,16777215,14080877,12582911,10485695,11683028,11745062,9344213,7190748,11684077,7157412,11974940,16768430,16763684,11983725,16777215,14417919,11983725,16777215,16515071,11983725,16777215,14385151,11983725,16777215,16477631,11983725,16777215,14380470,11983720,16777208,14417392,11983725,16777215,16777206,11983725,16777215,16740351,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,4804589,9224191,5029375,9287452,13753118,9254549,11983124,16776590,16742668,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16744447,11983725,16777215,16777143,11983725,16777215,16739767,11981677,16774143,16475062,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777207,11983725,16777215,16777215,13368173,13369343,11010047,9544986,14304530,11899601,8203627,8203618,6069018,4840316,12025852,4849659,11983722,16777213,16777210,11983725,16777215,16777215,11983725,16777215,16515071,11983725,16777215,16777215,10673005,14942207,14942198,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,16178029,16777215,16777215,4795391,2698239,2398711,4928173,4895333,2531932,7798435,14679724,8355419,11981971,16776045,16774291,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16740351,11983685,16777159,16777159,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,16770861,16775039,16508287,8730263,8730263,6595662,14647127,14614358,12254989,11084970,16178044,15279290,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16772607,11963245,16748543,16748479,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,9886429,14679991,10485471,11983725,16777215,16777215,6937453,9338879,11468799,16248795,14151644,11788242,10190812,12255196,9863123,4769499,11926307,4778138,11983698,16777197,16777170,12057453,16740351,16441343,11983725,16777215,16777215,11983725,16777215,16777215,1497965,2097151,2097151,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,7190253,14380479,7190271,11983451,16777014,16776859,11979045,16767855,16777215,9512147,9550100,6886749,9887743,12247039,9850879,11908763,16668964,16598171,11981969,16776044,16774289,16702317,14417919,12058623,11983807,16777078,16777005,11983653,16777215,16777071,11983725,16777215,16777215,11983405,16776767,16776767,11983725,16777215,16777215,11983725,16777215,16777215,7166829,14352383,7176191,11834011,16594678,16585307,9586981,11983727,16777215,2693476,5090797,2763775,5170898,7526180,5130002,7190299,11688364,9291555,11085163,16178172,15279611,11983725,16777215,16777215,12058621,16739767,16702319,7190253,14380479,7190271,11983715,16777206,16777187,11819885,16547839,16547839,11983725,16777215,16777215,5094253,12283903,5095423,11983067,16777142,16775899,12849730,11052309,8388738,4620287,4873654,13884269,9742601,12364617,10305508,8987732,7456925,4826196,9323739,11753773,9356956,1235235,6028717,1571171,11983706,16777205,16777186,12582765,9923583,7789567,7183214,14368765,7184380,7190235,14380470,7190235,11983723,16777214,16777211,11983720,16777208,16777208,7199597,14385151,7208959,10860251,15953334,15054555,2399085,4837375,303103,16777215,14380470,11983725,7411495,11609902,8076733,2506907,7267638,2769563,9287378,13785835,9291859,11938084,16727478,16657253,11969676,16767846,16757909,9362285,7340031,4947967,2545261,9697444,2618972,7189065,14379227,7189065,11981531,16776118,16774363,11981165,16773631,16773631,9886573,16777215,12582911,7190235,14380470,7190235,3595073,12582867,6291393,16777160,14380442,11983688,6964735,13288886,7336813,5093075,10186086,5093011,9250785,11913643,9480033,337699,3029421,595811,6887274,14076924,8988658,11983725,16777215,16777214,11577637,16066863,15767783,2396749,7190823,2396751,16754377,14368091,11970249,10673005,14942207,14942207,11983725,16777215,16777215,7189869,12282879,7190015,11862089,16684170,16580609,16552109,14239103,11837631,4597247,4826038,6656877,4826328,9878449,2725081,2073737,5973724,1479241,7160611,14345140,7160163,5162203,12315574,5461723,11983634,16777133,16777051,5393261,7524351,5132287,2399084,9588733,2404348,15241801,13481691,10785353,11984895,16776630,16776045,11983685,16777159,16777159,4905837,12058623,4980735,16776850,14380397,11983506,2186047,9109366,4292397,4798162,4499147,2097802,8388563,14679963,6890570,15541467,14043574,11347163,6342975,12938486,6347437,9287387,14380470,11384539,11941605,16772535,16730414,11983725,16777215,14680063,2808649,9699281,4980680,2396745,7227684,2396746,10485737,10186147,7789401,11963245,16748543,16748543,11983725,16777215,16777215,16774285,14379887,11981975,12058623,16739766,16702317,7415373,5056287,562254,16777202,16777194,4793480,7190527,14380543,7190162,262123,4677030,2284379,7190224,14380441,7190217,9587291,16744246,11984027,11983725,16777215,16777214,11936365,16691903,16654463,2396749,9586983,2434199,16773705,14379236,11981385,1497983,2097014,2096941,11983725,16777215,16777215,16604013,14352383,11894783,16777215,12283318,11983725,4496205,7196619,4501442,16777178,16777177,4793488,16777215,14680063,4793490,14673051,12241062,9880659,7189687,14375278,7190245,11908827,16706998,14235355,11983716,16777215,16777142,2702189,7196671,2703359,2399083,9588732,4796403,13406793,11127076,8950418,11960319,16670133,16636781,11983405,16776767,16776767,11983725,16777215,16777215,16777213,14380468,11983724,5678399,12559606,6263469,16598152,16630434,4731472,16777215,16777215,4793490,13145599,9283519,6590610,6946751,11459445,4578092,7190235,14380470,7190235,11983722,16777213,16739762,7789421,10485759,8126463,7190234,7190235,7190234,2396745,9586981,2696338,9586969,9586972,9586897,11819885,16547839,16547839,11983725,16777215,16777215,16775533,14376447,11983871,5060543,2958638,2654445,6853357,6637503,6595391,16777170,16777179,4793472,899583,3033599,37522,9370824,9332873,6935048,7190155,14380316,7190155,11965659,16763318,14394587,11983725,16777215,16777215,7190245,7190327,7190255,2406107,9578203,4794075,9585225,11983140,9585234,11983652,16777005,16776996,11983720,16777208,16777208,9886573,12582911,10485759,6895908,4503917,6436,2457597,9535484,4727953,16590035,16627411,4718730,7490047,9586623,2396242,11345947,6858468,4461121,7145747,14003547,6850834,2471643,9104822,4568795,11983725,16777215,16777215,6609773,6615039,4513791,7190235,7190235,7190235,6591051,6965547,4531347,11979044,16767852,16763171,11981165,16773631,16773631,11983725,16777215,16777215,9586989,7789375,3295551,16777215,16777215,4793490,5088343,7153967,42138,9591698,9287443,2097216,4503331,9292068,4493897,3290916,7751452,3290379,7190225,11983714,5093008,11983426,16776973,16776834,11983725,16777215,14680063,7189577,7189649,7189577,2660059,9610971,4789979,11973121,16761356,16757250,10673005,14942207,14942207,11983725,16777215,16777215,15883117,14155775,3375103,16777215,16777215,4793490,6914047,7794687,4822162,11969755,7190242,9,7194917,9586907,299520,4826330,4827501,2692827,2695780,9843949,2691172,11830418,16689901,16581714,11983725,16777215,16777215,2397037,4793855,4756415,4502601,11089042,4797586,6590537,8987941,6590610,11983724,16777214,16777213,11983685,16777159,16777159,11983725,16777215,16777215,16777197,16777199,4793486,16777215,16777215,4793490,7194334,7226669,13025,9324909,9282779,2097152,4569308,4910372,4606025,4503169,5134537,2180736,2396682,5589228,2663506,11983725,16777215,16777214,2546541,4980735,2588671,2396745,4793490,4793489,4494473,6970194,4531346,11982482,16775963,16771282,11963245,16748543,16748543,11983725,16777215,16777215,16763757,16769023,4792319,16777215,16777215,4793490,9318399,9351167,6915218,9886427,4830940,1,9550116,14305563,11833920,7148683,11646613,7152716,2364489,9819804,4760129,11983433,16776995,16776849,11983725,16777215,16777215,2396746,4793491,4792907,4788809,11969682,4789394,11642002,16140572,13743826,1497965,2097151,2097151,11983725,16777215,16777215,9886573,16777215,12582911,16777215,16777214,4793489,5734399,3112959,304274,11385124,7194909,4828,7489837,9848530,2396160,4794539,7154332,4761681,2397466,11389283,4495130,11866697,16693547,16585361,11983725,16777215,16777215,2397037,4793855,4494335,4493897,11084946,6890642,7189650,9587053,7189650,11983715,16777204,16777131,11983405,16776767,16776767,11983725,16777215,16777215,16775533,16776191,4793279,9928703,9633791,304274,9586916,9587940,2476553,9587547,9287396,2097152,7599908,10185069,7787081,5129947,11978467,5387418,2663058,9853285,4760722,11983725,16777215,16777214,2547196,4979628,2619755,2396745,4793490,4793489,9282761,11983762,9287378,11983140,16771949,16734500,11852653,16580607,16580607,11983725,16777215,16777215,15915885,16252927,4685823,12320767,7270399,304274,9816356,12208347,9703936,9619748,7194916,4692,15878436,13294371,10523208,9324823,11684702,9287949,4793564,11983725,4793636,11983442,16777069,16776338,16776941,14379775,11983551,2396748,4793494,4792909,7180873,14361746,9577618,11946275,16477038,14080292,11983725,16777215,16777215,11983720,16777208,16777208,11983725,16777215,16777215,14385133,7536575,304247,9587566,9549019,2097152,9587044,9624500,2406752,9586980,11979035,2396672,9535476,11914149,9522001,2771236,9624429,2771236,11965001,16763684,16458898,16751469,14331903,11968511,2400255,4795318,4496237,8688201,15279250,11084946,11979044,14380471,11983725,11983725,16777215,16777206,11981165,16773631,16773631,11983725,16777215,16777215,9591661,12287999,2420735,9887157,4798180,9,9877796,12298523,9896512,9586980,11684141,2396746,16774948,12014957,11980873,9586970,11983770,9586961,8650763,13705940,11010123,5692269,6291455,4194294,4194303,5991861,3595117,2396745,4793490,4793481,11946313,16777170,14081426,11983725,16777215,16772534,10935149,15204351,15204351,11983725,16777215,16777215,11983725,16777215,16777215,12282660,7195061,4682,7489829,5650066,294912,9587053,9853887,2398070,15878436,11197292,8426057,9575423,14362478,9607021,38116,5125998,300260,11982984,16777051,16772297,16776493,14375167,11982527,2396991,4793646,4793069,11969097,16757906,14365842,11983725,16777215,16739766,11983725,16777215,16777215,11983685,16777159,16777159,11983725,16777215,16777215,14048109,9662463,2399743,9587566,9282779,2097152,9886500,12320556,5434441,9586980,11983717,2396753,5963755,5397794,3267345,2476323,7265715,379754,11571785,16398115,13963849,5393261,7229439,2998271,2215422,4311917,4311916,10785353,15279250,13182098,11983725,16777215,16477622,11983725,16777215,16777215,11963245,16748543,16748543,11983725,16777215,16777215,9886573,14680063,3932159,9624420,4831022,73,11946219,16702107,14455312,9587053,11983799,2397414,16770788,12244205,11943945,7480571,12268716,9872034,2396746,7227101,2396747,5692249,6291443,4194210,9586788,11983012,9586779,2392073,4784146,4784138,11983689,16777170,16777169,11983725,16777215,16777215,1497965,2097151,2097151,11983725,16777215,16777215,11983725,16777215,16777215,9882477,7237055,37751,9172700,11200219,2281472,9624426,12025850,2776560,13748516,9296749,8688201,2807807,4835189,2475373,2397476,7195574,2397997,11973193,16767195,16729161,9484397,11880639,9483903,2396964,4793709,4793636,11977729,16770049,16765953,11983725,16777215,16777215,11983725,16777215,16777215,11983405,16776767,16776767,11983725,16777215,16777215,9886573,14417919,2588671,15841060,13481700,11010049,11973815,16763054,14393445,7489837,7789431,299677,7339946,7269090,4905681,3031702,5727444,3035276,6853194,13744419,8950345,5331821,7471103,5046270,2509090,4873067,4868386,8950345,13706386,13444242,11983725,16777215,16777215,11983725,16777215,16777215,11819885,16547839,16547839,11983725,16777215,16777215,11983725,16777215,16777215,9586981,9587631,2396750,9109476,11165093,4578145,9624429,12021759,4836278,16738028,14009589,11907217,8998047,15547037,10790997,7190225,14380459,7190225,11983635,16777134,16776531,9586339,11983012,9585762,4493899,4793491,4793490,11983706,16777195,16777122,11983725,16777215,16777215,11983725,16777215,16777215,11983720,16777208,16777208,11983725,16777215,16777215,9624429,12287999,2416639,16769636,14374509,11976713,11982511,16774813,12280924,13491053,7171510,4502684,11849726,9522603,7125867,7190162,14379738,7189585,11613915,16674230,16332507,9521005,11651583,9222143,2401572,4794221,4794148,11978385,16771290,16733842,11983725,16777215,16777215,11983725,16777215,16777215,11981165,16773631,16773631,11983725,16777215,16777215,11983725,16777215,14680063,13705956,11678957,9175049,7303167,4836278,342893,11983725,14381055,9292150,12582307,9885915,7788178,7153561,14296410,7116049,7190235,14380470,7190235,9624403,12058590,9961419,5130531,7527268,5130522,9249354,14005394,13739154,11983725,16777215,16777214,11983725,16777215,16777215,10673005,14942207,14942207,11983725,16777215,16777215,11983725,16777215,16777215,6892397,7491583,39359,12582820,9923940,7789345,11982645,16774299,12017755,16431981,11612159,11348836,5448639,8041837,3547949,7190235,14380469,7190234,11843291,16604598,16561883,9585740,11977942,9585741,4793500,7190317,6890725,11983651,16777196,16777132,11983725,16777215,16777215,11983725,16777215,16777215,11983685,16777159,16777159,11983725,16777215,16777215,9886573,12582911,3637247,16729892,14075757,11973193,7817663,4831606,2467629,11983725,16777215,14080886,7045099,7265123,4873051,7190101,14379742,7190093,7190235,14380470,7190235,2697577,5094396,2693626,5093586,9624802,7228049,11978450,16771875,16734427,11983725,16777215,16777215,11983725,16777215,16777215,11963245,16748543,16748543,11983725,16777215,16777215,11983725,16777215,16777215,11684205,11722175,9474871,7602174,7531949,5167981,11982708,16774874,14377626,9591661,11988991,9592246,7154532,14008237,7085412,7190235,14380470,7190235,7509211,7580598,5182683,9544850,14305563,11908242,9549532,16440109,14043429,11983725,16777215,16777214,11983725,16777215,16777215,1497965,2097151,2097151,11983725,16777215,16777215,11983725,16777215,16777215,9886573,14417919,3076095,16776548,14375789,11983649,11749111,13477101,11084965,11983725,16777215,14413238,3594541,10480502,3889453,7190234,14380467,7190233,2733787,9924022,2733787,7185701,9582383,7185638,9586980,14085557,11983788,11983716,16777214,16777141,11983725,16777215,16777215,11983725,16777215,16777215,11983405,16776767,16776767,11983725,16777215,16777215,11983725,16777215,14680063,16435565,11979191,11945637,4849663,4840374,2448237,11983660,16776986,16776914,11983725,16478207,14081471,7189613,14374719,7189174,7190235,14380470,7190235,9325203,9592686,7199891,9623844,14674788,12278043,11983652,16777142,16739693,11983725,16777215,16777215,11983725,16777215,16777215,11819885,16547839,16547839,11983725,16777215,16777215,11983725,16777215,16777215,9624429,9666559,7462335,16777205,11983725,11983724,11908245,16622748,16589388,11983725,16777215,14417919,4807533,11468799,4554166,7190235,14380470,7190235,11871451,14605238,12133595,11946276,16440101,14043420,11983725,16777215,14380470,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983720,16777208,16777208,11983725,16777215,16777215,11983725,16777215,12320767,16771877,11983662,11979044,4767231,4799341,4499821,11983724,16777212,16777211,11983725,16777215,16739775,7189642,14379877,7189650,4830939,12021174,4830939,9587050,11983805,9587058,11983725,16777206,14380461,11983725,16777215,16777214,11983725,16777215,16777215,11983725,16777215,16777215,11981677,16774143,16774143,11983725,16777215,16777215,11983725,16777215,16777215,14043501,11946495,9586615,12582911,9886573,9886573,11983634,16776979,16776394,11983725,16777215,16777215,4794221,11984383,4794879,5093082,12283317,5093082,11981458,12286317,9888914,11983716,16776557,16739108,11983725,16777215,16777151,11983725,16777215,16777215,11983725,16777215,16777215,10673005,14942207,14942207,11983725,16777215,16777215,11983725,16777215,16777215,9624429,9699327,9662463,16777132,11983724,11983651,11909567,16632173,16594733,11983725,16777215,16777215,5692269,12582911,6291455,4793490,11983725,4793490,11871378,16702317,14492818,11983725,16739255,14343022,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983693,16777167,16777167,11983725,16777215,16777215,11983725,16777215,16777215,16472357,11983151,11946278,5505023,7527277,5430125,11983725,16777214,16777213,11983725,16777215,16777215,4793517,11983743,4793599,4793490,11983725,4793490,11983722,14385149,11988410,11983725,16777215,16777142,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11963245,16748543,16748543,11983725,16777215,16777215,11983725,16777215,16777215,11688813,11698175,9564159,14680054,11983725,9886564,11983707,16777123,16776530,11983725,16777215,16777215,4873069,12025855,4911103,4793490,11983725,4793490,11983506,16777069,14417554,11983725,16777215,16772534,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,1497965,2097151,2097151,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,16739684,11983725,11946276,11978916,16767205,16729756,11983725,16777215,16777215,11983725,16777215,14680063,4793419,11983645,4793420,11936914,16767853,16688274,11983725,16777215,16477623,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983405,16776767,16776767,11983725,16777215,16777215,11983725,16777215,16777215,9292653,9330687,6934527,11682964,14076052,11678803,11983725,16777215,16777214,11983725,16777215,16777215,2135341,9288703,2398079,4531345,9624429,4531346,11983724,16777214,14417908,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11819885,16547839,16547839,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,9586981,11983215,9586470,11983725,16777205,16776621,11983725,16777215,16777215,2775917,7831551,3076095,2097225,6891300,2097737,11982473,16776548,16771209,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983721,16777209,16777209,11983725,16777215,16777215,11983725,16777215,16777215,11983725,14417919,12021759,11983725,16776630,16739181,11983725,16777215,16777215,11983725,16777215,14680063,2396756,9586990,2396765,9245257,16435491,13705801,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,11983725,16777215,16777215,4792685,4792831,4792831,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793491,4793491,4793491,4269202,4269202,4269202,5581650,5581650,5581650,5690514,5428370,5166226,5055653,5317804,5584042,4793493,4793493,4793493,4871826,4901010,4893330,4805994,4801898,4797802,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4795026,4795026,4795026,11084949,11084949,11084949,5678218,5678218,5678218,4793514,4793514,4793514,4805802,6903084,9000301,4795029,4795028,4795026,11084946,9512082,5579922,11183444,9053525,6894933,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,4793490,11969682,11969682,11969682,4793490,4793490,4793490,0);\n#define prc float(8)\n#define no int(8)\n\n#endif\n\n// below the php code that generate the data\n/*\n<?php\n\n// settings:\n\n$s = \"file_name\";\n$m = 1; // 0 = jpg/jpeg, 1 = png\n$u = 25; // image upscale\n$no = 5; // pixels per index\n$pr = 8.0; // possible colors per pixel\n\n// code:\n\nif($m == 0)$resource = imagecreatefromjpeg(\"$s\");\nif($m == 1)$resource = imagecreatefrompng(\"$s\");\n\n$w = floor(imagesx($resource)/$u);\n$h = floor(imagesy($resource)/$u);\n\n$size = $w*$h+1;\n\necho \"#define size vec2($w,$h)\\n#define def int data[] = int[](\";\n\n$i = 0;\n$p = 1;\n$rr = 0;\n$rg = 0;\n$rb = 0;\nfor($y = 0; $y < $h; $y++) {\n    for($x = 0; $x < $w; $x++) {\n        $rgb = imagecolorat($resource, floor($x*$u), floor($y*$u));\n        \n        $r = ($rgb >> 16) & 0xFF;\n        $g = ($rgb >> 8) & 0xFF;\n        $b = $rgb & 0xFF;\n\n        $r = floor($r/256.0*$pr);\n        $g = floor($g/256.0*$pr);\n        $b = floor($b/256.0*$pr);\n        if($i<$no-1){\n            $rr += $r*$p;\n            $rg += $g*$p;\n            $rb += $b*$p;\n            $p *= $pr;\n            $i++;\n        }else{\n            $rr += $r*$p;\n            $rg += $g*$p;\n            $rb += $b*$p;\n            echo \"$rr,$rg,$rb,\";\n            $p = 1;\n            $rr = 0;\n            $rg = 0;\n            $rb = 0;\n            $i=0;\n        }\n    }\n}\necho \"0);\\n#define prc float($pr)\\n#define no int($no)\\n\";\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 119, 119, 158], [159, 159, 189, 189, 489], [948, 948, 968, 968, 1561], [1562, 1562, 1589, 1589, 1643]], "test": "untested"}
{"id": "wlcyDX", "name": "Deadmau5 - Bridged by a Lightwav", "author": "MacroMachines", "description": "Happy Birthday Mr.Mau5", "tags": ["deadmau5"], "likes": 0, "viewed": 254, "published": 3, "date": "1610136490", "time_retrieved": "2024-07-30T19:46:10.179197", "image_code": "#define DISPLAY_GAMMA 1.98\n#define USE_CHROMATIC_ABBERATION\n#define USE_GLOW\n\nvec2 uvsToUv(vec2 uvs){\n    return (uvs)*vec2(iResolution.y/iResolution.x,1.0)+vec2(.5,.5);\n}\n\nconst float blurSize = 1.0/512.0*0.75;\nconst float intensity = 0.25;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.yy;\n    \n   //BLOOM\n   vec4 sum = vec4(0);\n   vec2 texcoord = fragCoord.xy/iResolution.xy;\n   int j;\n   int i;\n\n   //thank you! http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/ for the \n   //blur tutorial\n   // blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture(iChannel0, vec2(texcoord.x - 4.0*blurSize, texcoord.y)) * 0.05;\n   sum += texture(iChannel0, vec2(texcoord.x - 3.0*blurSize, texcoord.y)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x - 2.0*blurSize, texcoord.y)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x - blurSize, texcoord.y)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y)) * 0.16;\n   sum += texture(iChannel0, vec2(texcoord.x + blurSize, texcoord.y)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x + 2.0*blurSize, texcoord.y)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x + 3.0*blurSize, texcoord.y)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x + 4.0*blurSize, texcoord.y)) * 0.05;\n\t\n\t// blur in y (vertical)\n   // take nine samples, with the distance blurSize between them\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 4.0*blurSize)) * 0.05;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 3.0*blurSize)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - 2.0*blurSize)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y - blurSize)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y)) * 0.16;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + blurSize)) * 0.15;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 2.0*blurSize)) * 0.12;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 3.0*blurSize)) * 0.09;\n   sum += texture(iChannel0, vec2(texcoord.x, texcoord.y + 4.0*blurSize)) * 0.05;\n    \n    \n    //chromatic abberation\n    #ifdef USE_CHROMATIC_ABBERATION\n    vec3 color = vec3(0,0,0);\n    color.x   += texture(iChannel0, uvsToUv(uvs)).x*.66;\n    color.xy  += texture(iChannel0, uvsToUv(uvs*.995)).xy*.33;\n    color.y   += texture(iChannel0, uvsToUv(uvs*.9920)).y*.33;\n    color.yz  += texture(iChannel0, uvsToUv(uvs*.9985)).yz*.33;\n    color.z   += texture(iChannel0, uvsToUv(uvs*.99890)).z*.66;\n    #else\n    vec3 color = texture(iChannel0, uvsToUv(uvs)).xyz;\n    #endif\n    \n    \n   // #ifdef USE_GLOW\n   // vec3 glow = texture\n    \n    //tone mapping\n    //color = vec3(1.7,1.8,1.9)*color/(1.0+color);\n    \n\n    \n    //scanlines\n    color /= cos(uv.y*1000.)+1.50*1.5;\n   \n    \n        color += sum.rgb*intensity;\n        \n    //vinette\n    color *= smoothstep(0.20,0.65,vec3(1.0-distance(uv, vec2(0.5))))*1.75;\n    \n    //inverse gamma correction\n\tfragColor = vec4(color,1.0);//\n    //fragColor = vec4(pow(color,vec3((1.0)/(DISPLAY_GAMMA))),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define time mod(iTime,562.5)\n#define iTime mod(iTime,562.5)\n#define v3 vec3\n\n\n#define PRECISION 0.0001 \n//0.000001\n#define DEPTH 50.0\n#define STEPS 124\n#define PI 3.1415926535897932384626433832795\n#define OCCLUSION_SAMPLES 8.0\n#define OCCLUSION_FACTOR 1.0\n\nvec3 eye   = vec3(0.0,0.0,-1.0);\nvec3 light = vec3(-2.0,0.0,-2.0);\n\n\n\n\n//#define LIGHT_COLOR vec3(0.063,0.141,0.416)+KICK*0.2\n//#define LIGHT_AMBIENT vec3(0.710,0.071,0.082) //\n//#define LIGHT_AMBIENT vec3(0.478,0.000,0.000) //\n//#define LIGHT_COLOR vec3(0.396,0.184,0.184)*KICK2 //+KICK*0.2\n#define LIGHT_AMBIENT vec3(0.302,0.000,0.000) //\n#define LIGHT_COLOR vec3(0.478,0.478,0.478) //*KICK2\n\nmat3 rotmat;\nmat3 rotmatHead;\n\nbool hit = false;\nstruct sMaterial\n{\n    float metallic;\n    float roughness;\n    float fresnel_pow;\n    vec3 color;\n};\n\n\n//sMaterial mat_red = sMaterial(0.0, 1.0, 1.0, vec3(1.0, 0.0, 0.0));\n//sMaterial mat_white = sMaterial(0.0, 5.0, 1.0, vec3(1.0));\n//sMaterial mat_black = sMaterial(0.0,  10.0,  0.050, vec3(0.0));\n//sMaterial mat_red   = sMaterial(0.00, 10.00, 4.50, vec3(0.475,0.004,0.004));\n\nsMaterial mat_white = sMaterial(0.8750,  50.0,   0.510,    vec3(10.0));\nsMaterial mat_black = sMaterial(0.10,      4.0,    4.50,    vec3(0.0));\nsMaterial mat_red   = sMaterial(0.925,     10.00,  0.1250,    vec3(1.000,0.000,0.000));\n\n\n\n\n\n\n// KOREOGRAPHY\n// NOTES\n//\n// --142.5 sec beat kicks in\n// --232 clap and end beat\n// 297 oceans of blank space - fade out music for moment\n// 300 back in synth\n// 305 synth note back out\n// --321 swell back into snare / beat\n// 472 off\n// 562.5 end fade out, modulo time\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n\n#define TEMPO iTime * BPM / SEC_PER_MIN / 4.0 + 1.0\n//#define KICKb pow(fract(TEMPO)*2.0, 2.0)\n//#define KICK2 mix(0.0 , 1.0-pow(fract(iTime*BPM/SEC_PER_MIN), 0.50)), BEATON)\n//#define KICK2b 1.0-pow(fract(iTime*BPM/SEC_PER_MIN), 0.50)* BEATON\n\n//#define TEMPO_SNARE iTime * BPM / SEC_PER_MIN / 2.0 + 1.0\n//#define SNARE pow(fract(TEMPO_SNARE)*0.50, 0.50)\n//#define SINE sin(PI*fract(iTime*BPM/SEC_PER_MIN))\n\nbool BEAT = false;\n\nfloat TEMPOTIME = 0.0;\nfloat BEATON    = 0.0;\nfloat MEASURE   = 0.0;\nfloat MEASURE2  = 0.0;\nfloat FADEIN    = 0.0;\nfloat SYNTHJUMP = 0.0;\nfloat KICK      = 0.0;\nfloat KICK2     = 0.0;\nfloat TRIPLET   = 0.0;\nfloat SNARE     = 0.0;\nfloat SINE      = 0.0;\nvec3 audioTex   = vec3(0.0);\n//vec2 view = vec2(0.0);\n\nvoid coreography (vec3 view){\n    TEMPOTIME = BPM / SEC_PER_MIN;\n    BEAT      = (iTime > 142.5 && iTime < 232.0) || (iTime > 321.0 && iTime < 472.0) ;\n    BEATON    = float(BEAT);\n    MEASURE   = iTime * TEMPOTIME;\n    MEASURE2  = 1.0-fract(MEASURE/16.0);\n    FADEIN    = smoothstep(0.,6.,iTime);\n    SYNTHJUMP = step(MEASURE2, 0.5)*BEATON * float(iTime < 413.0);\n    KICK      = pow(fract(MEASURE/4.0)*2.0, 2.0);\n    TRIPLET   = mix(0.0, 1.0 - pow(fract(iTime*BPM/SEC_PER_MIN/0.666666666666), 0.250), SYNTHJUMP);\n    KICK2     = mix(1.0, 1.0 - pow(fract(iTime*BPM/SEC_PER_MIN), 0.50), BEATON);\n    SNARE     = pow(fract(MEASURE/2.0 + 1.0)*0.50, 0.50);\n    SINE      = sin(PI*fract(iTime*BPM/SEC_PER_MIN));\n    //audioTex  = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 1.0) )*0.50 ).xyz, vec3(4.0) )*1.0;\n    audioTex  = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 1.0) )*0.50 ).xyz, vec3(8.0) )*3.0;\n    //audioTex    = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 1.0) )*0.950 ).xyz, vec3(4.0) )*3.0;\n    mat_white.color = mix(vec3(0.0),mat_white.color*KICK2+0.1250,BEATON-TRIPLET);;\n}\n\n\n\n\nstruct sHit\n{\n    float d;\n    sMaterial material;\n};\nsHit map(vec3);\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(PRECISION,0);\n    return(normalize(vec3(map(p+e.xyy).d-map(p-e.xyy).d\n                          ,map(p+e.yxy).d-map(p-e.yxy).d\n                          ,map(p+e.yyx).d-map(p-e.yyx).d)));}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 rotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nvec3 opCheapBend( vec3 p , float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n\n}\nvec2 hash( vec2 p ) \n{                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {   return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {   return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);}\nfloat square (float x) {   return x*x;}\nvec2 square (vec2 x) {   return x*x;}\nvec3 square (vec3 x) {   return x*x;}\nfloat lengthSqr(vec3 x) {   return dot(x, x);}\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {   return max(v.x, v.y);}\nfloat vmax(vec3 v) {   return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {   return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {   return min(v.x, v.y);}\nfloat vmin(vec3 v) {   return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {   return min(min(v.x, v.y), min(v.z, v.w));}\n\n\n//......................................... transform \n/////////////////////////////////////////////////////\nmat2 rotate( float a ) {\n   float cs = cos(a);\n   float si = sin(a);\n   return mat2(cs, -si, si, cs);\n}\nmat3 calcLookAtMatrix( vec3 camPos , vec3 camTar , float roll ){\n\n  vec3 up = vec3( sin( roll ) ,cos( roll ) , 0. );\n  vec3 ww = normalize( camTar - camPos );\n  vec3 uu = normalize( cross( ww , up ) );\n  vec3 vv = cross( uu , ww ); // already normalized\n\n  return mat3( uu , vv , ww );\n\n}\n\n\n\n\n//                                  \n//                             \n//                                 \n//                                 \n//                                     \n//                \n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\t// c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n   return length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n   return dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n   return vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n   return vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n   vec2 d = abs(p) - b;\n   return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n   return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n   p = abs(p);\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   float b = max(max(max(\n      dot(p, normalize(vec3(1., 1., 1.))),\n      dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n      dot(p.yx, normalize(vec2(1., PHI)))),\n      dot(p.xz, normalize(vec2(1., PHI))));\n   float l = length(p);\n   return l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n   float d = length(p.xz) - r;\n   d = max(d, abs(p.y) - height);\n   return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n   return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n   vec3 ab = b - a;\n   float t = saturate(dot(p - a, ab) / dot(ab, ab));\n   return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n   return fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n   return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n   vec3 q = abs(p);\n   return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n   //this is mathematically equivalent to this line, but less efficient:\n   //return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n   return fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n   vec2 q = vec2(length(p.xz), p.y);\n   vec2 tip = q - vec2(0, height);\n   vec2 mantleDir = normalize(vec2(height, radius));\n   float mantle = dot(tip, mantleDir);\n   float d = max(mantle, -q.y);\n   float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n   \n   // distance to tip\n   if ((q.y > height) && (projected < 0.)) {\n      d = max(d, length(tip));\n   }\n   \n   // distance to base ring\n   if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n      d = max(d, length(q - vec2(radius, 0.)));\n   }\n   return d;\n}\n\n//......................................... 3d forms \n////////////////////////////////////////////////////\nfloat sphere (vec3 p, float s){\n   return length(p) - s;\n}\nfloat box(vec3 p, vec3 b){\n   return length(max(abs(p)-b, 0.0));\n}\nfloat rbox(vec3 p, vec3 b, float r){\n   return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//........................................... deform \n////////////////////////////////////////////////////\nfloat displace(vec3 p){\n   float d1 = rbox(p, vec3(0.25), 0.20);\n   //float d2 = sphere(p, 0.5);\n   float sz = 8.0;\n   float d2 = sin(sz*p.x)*sin(sz*p.y)*sin(sz*p.z);\n   return d1+d2;\n}\n//............................................ domain \n/////////////////////////////////////////////////////\nfloat rep( vec3 p, vec3 c){\n   vec3 q = mod(p, c) -0.5*c;\n   q.xy *= rotate(time);\n   vec3 c2 = c*3.0*cos(time*0.33);\n   vec3 q2 = mod(p, c2) -0.5*c2;\n   vec3 q3 = mod(p, c*0.25) - 0.125*c;\n   //return displace(p);//\n   float size = 1.0;\n   float rp = min(box(q2, vec3(cos(time+q3.z)*2.0, cos(p.z+time*0.5)*0.5, 1.0)),\n         rbox(q, fract(p.y+time*.1)*v3(size*0.125,0.05,0.1), 0.05));\n   rp = min(rp, sphere(q3, sin(p.x+time)*0.05));\n   return rp;\n}\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n   p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n   p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize,size) - halfsize;\n   p *= mod(c, 2.0)*2. - 1.;\n   return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   if (p >= 0.)\n      p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p+halfsize, size) - halfsize;\n   if (c > stop) { //yes, this might not be the best thing numerically.\n      p += size*(c - stop);\n      c = stop;\n   }\n   if (c <start) {\n      p += size*(c - start);\n      c = start;\n   }\n   return c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n   float angle = 2.*PI/repetitions;\n   float a = atan(p.y, p.x) + angle/2.;\n   float r = length(p);\n   float c = floor(a/angle);\n   a = mod(a,angle) - angle/2.;\n   p = vec2(cos(a), sin(a))*r;\n   // For an odd number of repetitions, fix cell index of the cell in -x direction\n   // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n   if (abs(c) >= (repetitions/2.)) c = abs(c);\n   return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5,size) - size*0.5;\n   return c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n   vec2 halfsize = size*0.5;\n   vec2 c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   p *= mod(c,vec2(2.))*2. - vec2(1.);\n   return c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   p *= mod(c,vec2(2))*2. - vec2(1.);\n   p -= size/2.;\n   if (p.x > p.y) p.xy = p.yx;\n   return floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n   vec3 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   return c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n   float s = sgn(p);\n   p = abs(p)-dist;\n   return s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n   vec2 s = sgn(p);\n   pMirror(p.x, dist.x);\n   pMirror(p.y, dist.y);\n   if (p.y > p.x)\n      p.xy = p.yx;\n   return s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n   float t = dot(p, planeNormal)+offset;\n   if (t < 0.) {\n      p = p - (2.*t)*planeNormal;\n   }\n   return sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n   return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n   return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n   return fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0.));\n   return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r + a,r + b), vec2(0.));\n   return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n   return fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n      pR45(p);\n      p.x -= sqrt(2.)/2.*r;\n      p.x += columnradius*sqrt(2.);\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      // At this point, we have turned 45 degrees and moved at a point on the\n      // diagonal that we want to place the columns on.\n      // Now, repeat the domain along this direction and place a circle.\n      pMod1(p.y, columnradius*2.);\n      float result = length(p) - columnradius;\n      result = min(result, p.x);\n      result = min(result, a);\n      return min(result, b);\n   } else {\n      return min(a, b);\n   }\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n   a = -a;\n   float m = min(a, b);\n   //avoid the expensive computation where not needed (produces discontinuity though)\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/n/2.0;\n      columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n      pR45(p);\n      p.y += columnradius;\n      p.x -= sqrt(2.)/2.*r;\n      p.x += -columnradius*sqrt(2.)/2.;\n\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      pMod1(p.y,columnradius*2.);\n\n      float result = -length(p) + columnradius;\n      result = max(result, p.x);\n      result = min(result, a);\n      return -min(result, b);\n   } else {\n      return -m;\n   }\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n   return fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n   float s = r/n;\n   float u = b-r;\n   return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n   float e = max(r - abs(a - b), 0.);\n   return min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n   return length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n   return max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n   return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n   return min(a, max(a - ra, abs(b) - rb));\n}\n\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\nsHit eyeMau5 ( in vec3 p )\n{\n    sHit hit;\n    return hit;\n}\n\nsHit mau5head( in vec3 q )\n{\n    q += vec3(0.,0.5,0.);\n   // q = mix(q, q*yrotate(sin(iTime)),FADEIN);\n    q*=yrotate(sin(iTime));\n    \n    float XROT = KICK2*0.75-0.5; //cos(TEMPO);\n    q *= zrotate(-XROT-0.3);\n        \n    vec3 eyeOffset = vec3(0.0);//-0.01,-0.01,-0.051);\n    vec3 eyePosL = vec3(0.48,-0.4,0.43)+eyeOffset;\n    vec3 eyePosR = eyePosL * vec3(1.0,1.0,-1.0);//vec3(0.5,-0.5,-0.5);\n    vec3 mouthPos =  vec3(-0.7, -0.25, 0.);\n//  float mouth = sdTriPrism(zrotate(PI)* q + vec3(-0.866025, -0.5, 0.0), vec2(1.0, 1.5)); //TODO: should be wedge with 50deg edge?       \n//  float mouth = sdTriPrism(zrotate(PI+0.01725) * q + mouthPos, vec2(1.0, 1.5)); \n    float mouth = sdTriPrism(zrotate(PI+0.0725) * q + mouthPos, vec2(0.70, 1.05)); \n    \n    float eyes  = opU(sdSphere(q+eyePosL, 4.5/14.0),sdSphere(q+eyePosR, 4.5/14.0));\n    float eyeXthickness = 0.015;\n    float eyeXs = udBox(xrotate(PI*0.25)*yrotate(PI*-0.01)*q + vec3(0.5,0.0,0.80125), vec3(0.5, 0.5, eyeXthickness));\n          eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*zrotate(PI*0.02)*q + vec3(0.5,0.750,-0.0125), vec3(0.5, 0.5, eyeXthickness)));\n          eyeXs = opU(eyeXs, udBox(xrotate(PI*0.25)*zrotate(PI*0.02)*q + vec3(0.5,-0.750,-0.0125), vec3(0.5, 0.5, eyeXthickness)));\n          eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*zrotate(PI*0.02)*q + vec3(0.5,0.0,0.80125), vec3(0.5, 0.5, eyeXthickness)));\n         // eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*q + vec3(0.5,0.750,-0.125), vec3(0.5, 0.5, 0.0251)));\n         // eyeXs = opU(eyeXs, udBox(xrotate(PI*0.25)*q + vec3(0.5,-0.750,-0.125), vec3(0.5, 0.5, 0.0251)));\n         // eyeXs = opU(eyeXs, udBox(xrotate(PI*0.75)*q + vec3(0.5,0.0,0.85), vec3(0.5, 0.5, 0.0251)));\n\n          eyeXs = opI(eyeXs, eyes);\n          \n          \n    float head  = opS(eyes, opS(mouth, sdSphere(q, 1.0)));\n    float teeth = opI(mouth, sdSphere(q, 0.9));\n    \n    \n    //this causes a strange artifact in soft shadows on my laptop but not my PC?\n    //not sure how to fix it but I like the curved ears too much to remove it\n    \n    vec3 ear_p = opCheapBend(q, 0.15); \n    float ear_angle = 49.0 * PI/180.0;\n    vec2  ear_size = vec2(0.89,0.071);\n    float ears_center = opU(sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)\n                     ,sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));\n    float ears_edge = opU(sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)\n                     ,sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));\n    float ears = opS(head, opU(ears_center,ears_edge));\n    \n    float walls = opU(sdPlane(q + vec3(0.0, 0.0, 4.0), normalize(vec4(0.0, 0.0, 1.0, 1.0)))\n                      ,sdPlane(q + vec3(0.0, 4.0, 0.0), normalize(vec4(0.0, 1.0, 0.0, 1.0)))) + 0.001;\n                      \n    float mainHead = smin(head,ears,0.09521);\n    \n    float result = 0.250;//1e10;\n    result = opU(result, mainHead);\n    result = opU(result, teeth);\n    result = opU(result, eyes);\n    //result = opU(result, ears);\n    //result = opU(result, walls);\n    \n    sHit hit;\n    hit.d = result;\n    if(result == mainHead)// || result == ears)\n        hit.material = mat_red;\n    else if ((result == eyeXs || result == teeth))//&& SYNTHJUMP==1.0)\n        hit.material = mat_black;\n    else\n        hit.material = mat_white;\n        \n    return hit;\n}\n\nsHit map( in vec3 p )\n{    \n    vec3 ppp = p;\n    float sizer = 2.0;\n    \n    /// PLAY WITH KICK ADD / MULT / SNARE \n    vec3 c = vec3(sizer)*KICK*0.5+8.0;//-SNARE;     ///2.0;//*(TEMPO);\n    //c = vec3(sizer)+8.0;\n    \n    \n    //p *= 1.0/c;//*0.5;  //////////// crazy warp\n    //p /= c*0.125; //////////// crazy warp\n    //p *= c/sizer; //////////// crazy warp\n    \n    \n    vec3 qA = (mod(p,c)-0.5*c);//min((mod(p,c)-0.5*c), KICK2*2.0);//*rotmat;\n    vec3 qB = p;//*rotmat;\n    vec3 q  = qA;\n    //q.x = p.x-4.5 <= sin(MEASURE*PI*2.)*0.9 ? p.x:q.x;//vec3(0.0);\n//    q.x = p.x-16.5 <= sin(MEASURE*PI*2.)*0.9 ? p.x:q.x;//vec3(0.0);\n    //q.x = p.x-.5 <= 4.0 ? p.x*2.0:q.x;//vec3(0.0);\n    //q = q+p*rotmat;\n    //q = mix(qA, qB, min(KICK*0.50, SNARE));\n    //q = mix(q, qB, SNARE-1.0);\n    \n//    float XROT = KICK2*0.75-0.5; //cos(TEMPO);\n//        p *= zrotate(-XROT);\n//    float YROT = 10.0;//0.0+sin(TEMPO*0.25)+1.0*0.5;\n    \n    //rotmatHead = xrotate(XROT*2.0*PI) * yrotate(YROT*2.0*PI + PI / 2.0); \n    //q *= rotmatHead;\n    \n    //rotmatHead = xrotate(XROT*2.0*PI) * yrotate(YROT*2.0*PI); \n //   p *= zrotate(-XROT);\n    \n    //some animation\n    //q = q / vec3(pow(1.0 + 0.125*SINE,0.250));\n    q = q / vec3(KICK2+1.0);\n    //q = q+KICK*vec3(-10.0, 0.0, 0.5);\n        \n\n    //float sizemult = 1.0;\n\n    vec3 pp = q;//\n    //pModPolar(pp.xz, 2.0);\n    sHit mau5 = mau5head(pp);//*sizemult);\n    sHit mau5big = mau5head(ppp);\n    //if(mau5.d>=0.0) mau5.d = mau5head(ppp).d; //mau5.material = mat_white;\n    return mau5;\n}\n\n\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n//                    \n//                \n//                     \n//                    \n//                   \n//           \n\n\n\n\n\n\nvec3 march( in vec3 ro, in vec3 rd)\n{\n    float t=0.0,d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d=map(ro+rd*t).d;\n        if(abs(d)<PRECISION){hit=true;}\n        if(hit==true||t>DEPTH){break;}\n        t+=d;\n    }\n    \n    return ro+rd*t;\n}\n\nfloat shadow_march( in vec3 ro, in vec3 rd)\n{\n    float t=0.01,d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d = map(ro + rd*t).d;\n        if( d < 0.0001 )\n            return 0.0;\n        t += d;\n    }\n    return 1.0;\n}\n\nfloat soft_shadow_march( in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t=0.01;//.0001*sin(PI*fract(iTime));\n    float d;\n    \n    for(int i=0;i<STEPS;i++)\n    {\n        d = map(ro + rd*t).d;\n        if( d < PRECISION )\n            return 0.0;\n        res = min( res, k*d/t );\n        t += d;\n    }\n    return res;\n}\n\n/*  taken from Hamneggs https://www.shadertoy.com/view/4dj3Dw\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat calcOcclusion(vec3 pos, vec3 surfaceNormal)\n{\n\tfloat result = 0.0;\n\tvec3 normalPos = vec3(pos);\n\tfor(float i = 0.0; i < OCCLUSION_SAMPLES; i+=1.0)\n\t{\n\t\tnormalPos += surfaceNormal * (1.0/OCCLUSION_SAMPLES);\n\t\tresult += (1.0/exp2(i)) * (i/OCCLUSION_SAMPLES)-map(normalPos).d;\n\t}\n\treturn 1.0-(OCCLUSION_FACTOR*result);\n}\n\n//some code borrowed from https://www.shadertoy.com/view/XsfXWX#\nfloat phong(vec3 l, vec3 e, vec3 n, float power) {\n    float nrm = (power + 8.0) / (PI * 8.0);\n    return pow(max(dot(l,reflect(e,n)),0.0), power) * nrm;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 getColor(vec3 p)\n{\t\n    sHit hit_obj = map(p);\n    sMaterial material = hit_obj.material;\n    \n\tvec3 n = getNormal(p);\n\tvec3 l = normalize(light-p);\n    \n\tvec3 light_color = vec3(0);\n    vec3 cubemap = texture(iChannel2,-n).xyz;   \n    vec3 reflection = vec3(0.0);//cubemap;\n    \n    //float shadow = shadow_march(p, l);\n    //float shadow = soft_shadow_march(p, l, 50.0);\n    \n    \n    // Diffuse lighting\n    //light_color += LIGHT_COLOR * vec3(shadow) * max(dot(n, l), 0.0);\n    light_color += LIGHT_COLOR * max(dot(n, l), 0.0);\n    \n    \n\tfloat occlusion = calcOcclusion(p, n);\n    light_color += LIGHT_AMBIENT * occlusion;\n    \n    vec3 diffuse = light_color * max(dot(n, l), 0.0);\n    \n    \n    // fresnel\n    float fresnel = max(1.0 - dot(n,p), 0.0050);\n    fresnel = pow(fresnel , material.fresnel_pow);    \n\n\n    // specular\n    float power = 1.0 / max(material.roughness * 0.4,0.01);\n    vec3 spec = light_color * phong(-l,p,n,power);\n    reflection -= spec;\n    reflection *= max(1.0-fresnel,0.51);\n\n\n    // diffuse\n    vec3 diff = diffuse;\n    //diff = mix(diff * material.color, reflection*cubemap, fresnel);        \n\n\n    vec3 color = mix( diff, reflection * cubemap * material.color , material.metallic) + spec;\n    //vec3 color = mix( diff, reflection * material.color , material.metallic) + spec;\n    color = vec3( (occlusion*0.15 * material.color)  + ((1.0-fresnel) * material.metallic))+spec*0.251+diff*0.125;\n    //return diffuse * material.color + spec;;\n    //return cubemap*material.color;//\n    //return vec3(occlusion*0.15)*diff+spec+fresnel*0.1;//color;\n    return mix(color,vec3(10.0),TRIPLET);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//         \n//    \n//  \n// \n//      \n//          \n\n//uncomment below to enable mouse moving\n//#define MOUSE_MOVE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    \n    \n#ifdef MOUSE_MOVE\n    vec2 mouse = iMouse.xy/ iResolution.xy;\t\n    mouse -= 0.5;\n#else\n    vec2 mouse = vec2(0.0);\n#endif\n\n\n    //vec2 moveMult   = vec2(1.50);\n    //vec2 moveOffset = vec2(0.0,1.50);\n    vec2 moveMult   = vec2(1.5);\n    vec2 moveOffset = vec2(0.0,1.);\n    \n\tfloat tb = iTime * BPM / SEC_PER_MIN / 8.0;// + 1.0; //+1.0 to start at 2nd rotation cuz i like it best\n    float percent = fract(tb);\n    vec2 current = 2.0 * texture(iChannel0, vec2(floor(tb)       / 64.0, floor(tb)     / 32.0)).rg - 1.0;\n    vec2 next    = 2.0 * texture(iChannel0, vec2(floor(tb + 1.0) / 64.0, floor(tb+1.0) / 32.0)).rg - 1.0;\n    vec2 final   = mix(current, next, smoothstep(0.0, 0.1, percent)) * moveMult + moveOffset;\n    \n    rotmat = xrotate(final.x)*yrotate(final.y + PI / 2.0);\n    \n   // rotmat *= xrotate((mouse.y-final.x/2.0)*2.0*PI) * yrotate((mouse.x - final.y/2.0)*2.0*PI + PI / 2.0); \n   // rotmat *= xrotate((mouse.y/4.0)*2.0*PI) * yrotate((mouse.x/4.0)*2.0*PI + PI / 2.0); \n    rotmat *= yrotate(1.750-sin(tb/2.0)*0.5);\n   \n   ////////// \n    //rotmat *= yrotate(sin(tb/8.0))-0.50; // crazy stretch FX //////\n    \n    \n\n    \n    \n    float timeFlys = 0.0;\n    \n    //vec3 view = normalize(vec3( p, 0.750 ));\n    //vec3 eye = vec3( -1.150, 1.050, -5.0-iTime*timeFlys );\n    \n    vec3 view = normalize(vec3( p, 1.30 ));   \n    vec3 eye = vec3( 0., 0.,-4.0 );\n    \n    light = eye + (40.,40.,-4.0);\n    //light = vec3(-2.5,1.5,0.);\n    \n    view *= rotmat; eye *= rotmat; //light *= rotmat;\n    \n    \n    \n    coreography(view);\n    timeFlys = mix(0.0,0.52,SYNTHJUMP);\n    //eye.z = mix(eye.z,iTime,SYNTHJUMP);//*timeFlys*0.51;\n    eye.y = mix(eye.y,sin(TRIPLET*PI)*2.50,SYNTHJUMP);//*timeFlys*20.0;\n    light.z = eye.z -4.0;//-iTime*timeFlys;\n    \n    vec3 pos = march(eye,view);\n    vec3 col = vec3(0);\n    \n    if (hit == true) \n    { \n        col = getColor(pos); \n    }\n    else\n    {\n        col = pow( texture( iChannel1, cos(view.xy * (SNARE * 0.50 - KICK * 0.5 - KICK2 * 0.50) )*1.1950 ).xyz, vec3(8.40) )*3.0;\n       // col = audioTex;\n    }\n    \n\tfragColor = max(vec4(col,1.0), 0.0);//+(vec4(0.50,0.50,0.50,0.0)*KICK2);\n    fragColor.r += TRIPLET;//SYNTHJUMP*KICK2;\n    fragColor *= FADEIN;\n}\n", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25186, "src": "https://soundcloud.com/deadmau5/bridged-by-a-lightwave", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 101, 101, 171], [244, 244, 301, 301, 3212]], "test": "untested"}
{"id": "4sVcDd", "name": "Sequencing 2018-04-15", "author": "ttg", "description": "Publishing my old sound shaders.", "tags": ["sound", "music", "sampleprecise"], "likes": 7, "viewed": 352, "published": 3, "date": "1610127587", "time_retrieved": "2024-07-30T19:46:11.086770", "image_code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\n//#define POLAR\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  int shift = int(fsf.x*timescale*(iTime))+1;\n\n  int rshift = 0;\n  //rshift = (shift)%fs.x;\n  f = texelFetch(iChannel0, ivec2((d.x+rshift)%fs.x,d.y), 0);\n  f = clamp(f,0.,2.);\n  f*=1.-exp(-2.*(-0.05+float((fs.x+d.x-(shift-rshift)%fs.x)%fs.x)/float(fs.x)));\n#ifdef POLAR\n  vec2 uv = (df-0.5*iResolution.xy)/iResolution.y*2.;\n  float r = length(uv);\n  float a = atan(uv.y, uv.x);\n  f = texture(iChannel0, vec2(a/6.2832+0.5, r));\n  if (r>1.) f*=0.;\n#endif\n  if (d.x<80) f = vec4(0.);\n  if (d.x<20) {\n    f = texelFetch(iChannel0, ivec2((shift-1)%fs.x,d.y), 0);\n  }\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nSound Experiment\nCopyright 2018 Theron Tarigo\n*/\n\nstruct stm {\n  int samp;\n  float frac;\n};\n\nstm stmtime (float t) {\n  float st = t*iSampleRate;\n  return stm(int(st),fract(st));\n}\n\nfloat timestm (stm a) {\n  float st = float(a.samp)+a.frac;\n  return st/iSampleRate;\n}\n\nstm add (stm a, stm b) {\n  float fracsum = a.frac+b.frac;\n  return stm(a.samp+b.samp+int(fracsum),fract(fracsum));\n}\n\nstm sub (stm a, stm b) {\n  float fracdif = a.frac-b.frac;\n  return stm(a.samp-b.samp+int(fracdif),fract(fracdif));\n}\n\nconst float pi = 3.141592653589793;\n\nfloat wave(float t) { return sin(2.*pi*fract(t)); }\n\nfloat sincstep(float x) {\n    return ( x<0.001 ? 0. : 1.0-sin(pi*x)/(pi*x) );\n}\n\nfloat intfract(int s, float n) {\n  //return fract(float(s)/n);\n  int sn = int(n);\n  float fn = fract(n);\n  return float(s%sn)/n+fract(float((s/sn)*sn)/n);\n  //return ((((s)%2)==0)?0.:0.5);\n    \n}\n\nfloat syntime;\nint synsamp;\n\nfloat pulse1(float freq, float decay, float reltime) {\n  float time = reltime+syntime;\n  //int synsamp = int(syntime*iSampleRate+0.25);\n  int relsamp = int(reltime*iSampleRate+0.5);\n  int samp = synsamp+relsamp;\n  if (samp<0) return 0.;\n  freq*=2.;\n  //int freqsamp = int(iSampleRate/freq);\n  //float freqfract = fract(iSampleRate/freq);\n  //float sinearg = (float(samp%freqsamp)+fract(freqfract))*freq/iSampleRate;\n  //float sinearg = (float(samp%freqsamp)+(freqfract*float(samp/freqsamp)))*freq/iSampleRate;\n  //float sinearg = time*freq;//(float(samp%freqsamp)+float((samp/freqsamp)*freqsamp))*freq/iSampleRate;\n  //float sinearg = float(samp%freqsamp)/float(freqsamp);\n  //float sinearg = time*freq;\n  float f = 1.-sin(2.*pi*intfract(samp, iSampleRate/freq/2.))/(pi*time*freq);\n  if (samp<40) f=0.;\n  //float f = sincstep(time*freq);\n  float f2 = cos(2.*pi*intfract(samp, iSampleRate/freq*2.));\n  //float f2 = cos(time*freq*pi);\n    // return sincstep(time*freq*2.)*exp(-time*decay)*cos(time*freq*2.*pi); ///////\n  //return 0.2*sincstep(time*freq)*exp(-time*decay)*cos(time*freq*pi);\n  return f*exp(-time*decay)*f2;\n}\n\n/*float synth2(float freq, float time, float maxtime) {\n  float v = 0.;\n  for (float n=1.0; n<18.; n+=1.0) {\n    v += pulse1(freq*n, pow(n,2.)*1., time)*exp(-n*0.3);\n  }\n  if (time < 0. || time > maxtime) return 0.;\n  v*=1.-exp((time/maxtime-1.)*8.);\n  return v;\n}*/\n\nfloat synth3(float freq, float reltime, float decay, float maxtime) {\n  float v = 0.;\n  float time = reltime+syntime;\n  for (float n=1.0; n<20.; n+=1.) {\n    if (freq*n>iSampleRate*0.4) break;\n    v += 0.05*pulse1(freq*n, 2.*pow(n,1.)*0.8*freq/400./decay, reltime)*exp(-n*0.5);\n  }\n  if (time < 0. || time > maxtime) return 0.;\n  v*=1.-exp((time/maxtime-1.)*8.);\n  //v*=1.-exp(-time*80.);\n  return v;\n}\n\nvoid play_synth3(inout float f, float ampl, float freq, float time, float decay, float maxtime) {\n  if ((syntime+time) < 0. || (syntime+time) > maxtime) return;\n  f += ampl*synth3(freq, time, decay, maxtime);\n}\n\nvoid play_seq1(inout float f, float ampl, float time, float clk) {\n  //if (time < 0. || time > clk*64.+10.) return;\n  //float ampl = 0.5;\n  float fbase = 256.;\n  for (int i = max(0,int((syntime+time)/clk)-20); i < int((syntime+time+10.)/clk)+2; i++) {\n  //for (int i = 0; i < int(2./clk); i++) {\n    float fmult = (float[](1.,2.,1.,1.,2.,1.,14./8.,2.,17./8.,1.,2.,1.,2.,2.,16./9.,2.))[(i^(i/4))%9];\n    int j = i;///2;\n    float r = (float[](1.,2.,1.,4.,1.,2.,1.,4.))[(j^(j/8))%8];\n    for (float j = 0.; j < 1.; j+=1./r) {\n      play_synth3(f, ampl, fbase*fmult, time-(float(i)+j)*clk, 1./r, 10./r);\n    }\n  }\n}\n\nvec2 smoothclip(vec2 f) {\n    float p = 3.;\n    f.x = pow(atan(pow(abs(f.x),p)*1.571)/1.571,1./p)*sign(f.x);\n    f.y = pow(atan(pow(abs(f.y),p)*1.571)/1.571,1./p)*sign(f.y);\n    return f;\n}\n\nvec2 mainSound(int sampin ) {\n  //float time = timein + 180.*0.;\n  synsamp = sampin;\n  float timein = float(synsamp)/iSampleRate;\n  syntime = timein;\n  vec2 v = vec2(0.);\n  float f = 0.;\n  float clk = 0.25;\n  //for (float i = 0.; i < 256.; i++) {\n  //  play_seq1(f, 0.5, time-16.*clk*i, 0.25);\n  //}\n  play_seq1(f, 0.5, -2.0, 0.25);\n  //play_seq1(f, 0.5, time, 0.125);\n  \n  v = vec2(f);\n  //v *= max(1.-exp(-0.5*(time+2.)),0.)*min(1.,exp(0.5*time));\n  //v *= max(1.-exp(-10.*(178.-timein)),0.);\n  //v*=0.6;\n  v = smoothclip(v);\n  return vec2(v);\n}\n\n\n\n// Spectrogram Config\n\nconst float timescale = 1./4.; // Screens per second\nconst float freqscale = 4000.;\nconst vec2 stereomix = vec2(1.,1.)*40.;\n", "buffer_a_code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\nconst float windowmax = 0.5;\n\nvec4 encode ( int i ) { return vec4((uvec4(i)>>ivec4(0,8,16,24))&0xFFu)/255.; }\nint decode ( vec4 f ) { uvec4 d = uvec4(f*255.)<<ivec4(0,8,16,24);\n  return int(d.x|d.y|d.z|d.w); }\n\nvoid mainImage ( out vec4 f, in vec2 pixf ) {\n  f = vec4(0.);\n  if (iFrame==0) return;\n  ivec2 pix = ivec2(pixf);\n  ivec2 res = ivec2(iChannelResolution[0].xy);\n  int center = res.x*res.y/2;\n  int offset = int(iTime*iSampleRate) - center;\n  int index = res.x*pix.y+pix.x;\n  int sampstart = decode(texelFetch(iChannel0, ivec2(1,0), 0));\n  bool start = (iFrame==1 || iTimeDelta>3.0);\n  //bool start = (iFrame==1);\n  if (index==1) {\n    // Fix Shadertoy's failure to synchronize iTime to audio\n    //if (start) sampstart = int(iSampleRate*(iTime-10.*iTimeDelta));\n    if (start) sampstart = int(iSampleRate*(iTime));\n    f = encode(sampstart);\n    return;\n  }\n  if (start) {\n    f = vec4(0.);\n  }\n  if (index==0) { f = encode(offset); return; }\n  int offsetlast = decode(texelFetch(iChannel0, ivec2(0), 0));\n  int cutoff = int(windowmax*iSampleRate);\n  if (abs(index-center) > cutoff) return;\n  int samp = index+offset;\n  int samplast = center+cutoff+offsetlast;\n  float time = (float(samp)-0.5)/iSampleRate;\n  if (samp <= offsetlast + center + cutoff) {\n    f.xy = texelFetch(iChannel0,\n      (ivec2(index+offset-offsetlast)/ivec2(1,res.x))%(res), 0).xy;\n  } else {\n    f.xy = mainSound(samp-sampstart);\n  }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\nStreaming Spectrogram v.4\nCopyright 2018 Theron Tarigo\n*/\n\nconst float sgr_pi = 3.141592653589793;\n\nvec2 readsound ( int isamp ) {\n  ivec2 res = ivec2(iResolution.xy);\n  int offset = int(iTime*iSampleRate) - res.x*res.y/2;\n  int samp = isamp - offset;\n  ivec2 pix = ivec2(samp%res.x, (samp/res.x));\n  return texelFetch(iChannel1, pix, 0).xy;\n}\n\nvec2 spectrogram ( float windowtime, int isamp, float freq ) {\n  vec2 sum = vec2(0.);\n  int iwindow = int(windowtime*iSampleRate);\n  float window = float(iwindow)/iSampleRate;\n  window = windowtime;\n  for (int irel = -iwindow; irel <= iwindow; irel+=1) {\n    // Cosine window\n    float w = (0.5+0.5*cos(float(irel)/float(iwindow)*sgr_pi));\n    float samp = dot(stereomix,readsound(isamp+irel));\n    float a = fract(float(irel/**/+0*isamp/**/)*freq/iSampleRate)*2.*sgr_pi;\n    sum += w*vec2(cos(a),sin(a))*samp;\n  }\n  return sum/iSampleRate/window;\n}\n\n// Calibrated to ttg's hearing\n// Returns modulation frequency at which a tone at base frequency\n// transitions from sounding as beats to sounding as separate tones\nfloat timeratiofn ( float freq ) {\n  const float nparam = 58.5;\n  const float aparam = 950.;\n  return freq/nparam + exp(-freq/aparam)*aparam/nparam;\n}\n\nvoid mainImage ( out vec4 f, in vec2 df ) {\n  ivec2 d = ivec2(df);\n  vec2 fsf = iResolution.xy;\n  ivec2 fs = ivec2(fsf);\n  \n  int shift = int(fsf.x*timescale*(iTime));\n  int shiftlast = int(fsf.x*timescale*(iTime-iTimeDelta));\n  int delta = shift - shiftlast;\n\n  int x2 = (shift+(fs.x-d.x))%fs.x;\n  if (x2>delta) {\n    f = texelFetch(iChannel0,d,0);\n    //if (d.y>fs.y-32) f = vec4(0.5);\n    return;\n  }\n  float time = float(shift-x2)/timescale/fsf.x;\n  int isamp = int(time*iSampleRate);\n  float y = float(d.y);\n\n  float freq = freqscale * y / iResolution.y;\n  float windowfreq = timeratiofn(freq);\n  vec2 s = spectrogram(1./windowfreq, isamp, freq);\n  float ss = dot(s,s);\n  f.rgb = vec3(10.,3.2,1.)*ss*50.;\n    \n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(int samp, float _time){return mainSound(samp);}", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sVcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 122, 122, 763]], "test": "untested"}
{"id": "wldcW2", "name": "anime water splash FX", "author": "morimea", "description": "just following video Tutorial: Advanced anime water splash FX in blender [url]https://youtu.be/zZsfr5f273c[/url]\n\ncontrol - [b]Mouse left click[/b] to rotate camera, [b]Keyboard arrows[/b] to move camera", "tags": ["water", "anime", "splash"], "likes": 92, "viewed": 2775, "published": 3, "date": "1610126944", "time_retrieved": "2024-07-30T19:46:12.204781", "image_code": "\n// Created by Danil (2021+) https://github.com/danilw\n\n// just following youtube video tutroial\n// original video https://youtu.be/zZsfr5f273c\n\n// (in this shader just setting voronoi parameters to make it look like on\n// video)\n\n// License Mit license\n\n// helper-functions for noise in Common\n\n// using https://www.shadertoy.com/view/ldB3zc\n// using https://www.shadertoy.com/view/XdXGW8\n// using https://www.shadertoy.com/view/4sfGzS\n\n// using iq's intersectors:\n// https://iquilezles.org/articles/intersectors\n\n#define AA 2\n\n#define cloud_steps 16\n\nconst vec3 bgcol = vec3(0x06, 0xb6, 0xf3) / float(0xff);\nconst vec3 white = vec3(0xd1, 0xee, 0xf5) / float(0xff);\nconst vec3 blue = vec3(0x01, 0x8e, 0xc6) / float(0xff);\n\n// mix two voronoi layers and ring\nfloat get_voronoi_texture(vec2 p, float fade, float time) {\n  vec2 op = p;\n\n  // two voronoi\n  p = ToPolar(p) * 01.175;\n  p.y += -time * 0.51;\n  p.x = abs(p.x) * 4.;\n  vec2 td = voronoi(p * vec2(2.5, 1.185), 0.51, time * .1);\n  vec2 td2 = voronoi(p * vec2(1.5, 1.185), 0.51, time * .05);\n  td *= td2;\n\n  // rings\n  // adding rings to voronoi\n  time += -0.35;\n  p = op;\n  p *= 0.05;\n  float d = noise2(p * 4. + time * 0.51 * 0.05 * 8.);\n  d = (fade * 0.235 +\n       abs(mod(length(p) + 0.07 * d - time * 0.51 * 0.05 * 2., 0.15) - 0.075));\n  float a = 1. - smoothstep(0.4485, 0.4485 + 0.005, td.y * .855 + d);\n\n  td.y = min(td.y + fade * 15., 1.);\n  float b = 1. - smoothstep(0.4785, 0.4785 + 0.005, td.y);\n\n  return max(a, b);\n}\n\n// rings\n// mix voronoy noise and rings\nfloat get_rings(vec2 p, float val, float time, float fade) {\n  vec2 op = p;\n\n  // one leayer of voronoi\n  p = ToPolar(p) * 01.5;\n  p.y += -time * 0.51;\n  p.x = abs(p.x) * .125;\n  vec2 td = voronoi(p * vec2(2.5, 1.185), 0.51, time * .1);\n  td.x = 1. - smoothstep(val, val + 0.005, td.x + fade);\n\n  // rings\n  p = op;\n  p *= 0.05;\n  float d = noise2(p * 4. + time * 0.51 * 0.05 * 8.);\n  d = (1. - smoothstep(0.01, 0.015,\n                       fade * 0.5 + abs(mod(length(p) + 0.07 * d -\n                                                time * 0.51 * 0.05 * 2.,\n                                            0.15) -\n                                        0.075)));\n  return td.x * d;\n}\n\n// floor texture\nvec4 get_color_floor(vec2 p, vec3 sunDir, vec3 nor) {\n  float d = 0.;\n  float time = iTime * 2.5;\n  float fade = smoothstep(0.3, .845, length(p * 0.05));\n  fade = max(fade, 1. - (smoothstep(-0.075, 0.15, length(p * 0.05))));\n\n  d = get_voronoi_texture(p, fade, time);\n  d = min(d + get_rings(p, 0.73, time, fade) +\n              get_rings(p, 0.3, time * 0.75, fade),\n          1.);\n\n  return vec4(mix(blue * (max(dot(nor, sunDir), 0.0) + 0.05), white, d), 1.);\n}\n\n// cylinder on middle\nvec4 get_colorCylinder(vec2 p) {\n  float d = 0.;\n  float time = iTime;\n  p.y += time * 0.51;\n  p.x = abs(p.x);\n  p *= 5.;\n  vec2 td = voronoi(p * vec2(2.5, 1.185), 0.51, time * .1);\n  p.y += time * 0.51;\n  vec2 td2 = voronoi(p * vec2(2.5, 1.185), 0.51, (time)*.1);\n  td *= td2;\n  d = max((1. - smoothstep(0.476, 0.476 + 0.005, td.y)),\n          (1. - smoothstep(0.685, 0.685 + 0.005, td2.y)));\n\n  return vec4(mix(blue, white, d), 1.);\n}\n\n// cloud SDF\n// this made only for this shader, do not use it in real time, it slow\n\nvec2 sdf(vec3 p) {\n  vec3 p2 = p + vec3(0., 1.8, 0.) * iTime;\n  \n  float plane = dot(p + vec3(0, -0.34, 0), vec3(0., 1., 0.));\n  float sphere = length(p * vec3(1., 1.25, 1.) + vec3(0.)) - 1.949;\n  float sphere2 = length(p * vec3(1., 2.75, 1.) + vec3(0.)) - 2.1949;\n  sphere = min(sphere, sphere2);\n  float sphere3 = length(p + vec3(0., -1.5, 0.0)) - 1.219;\n  float d =\n      max(max(sphere, -sphere3), -plane);\n\n  float f = fbm(p2) - 0.8;\n  float td = mix(d, f, .372);\n  if (td < sphere3)\n    return vec2(td, 1);\n  else\n    return vec2(td, 2);\n}\n\nvec3 materialCloud(float d) {\n\n  float result = 1.;\n  float depth = 0.21;\n  float minlight = 0.31;\n  result = min(result, (d * 2.6 / depth) + minlight);\n  if (d < 0.00001) {\n    result = minlight;\n  }\n  return clamp(mix(blue * 0.465, (white)*3.515, result * (result + result)), 0.,\n               1.);\n}\n\n// ignore AA in sdf\n#if AA > 1\nbool once = false;\nvec4 col_once = vec4(0.);\n#endif\n\nvec4 get_colorSphere(vec3 ro, vec3 rd, vec3 bg) {\n#if AA > 1\n  if (once)\n    return col_once;\n#endif\n  float ratio = 1.0;\n  vec3 cloud = bg;\n\n  float depth = 0.;\n  for (int I = 0; I < cloud_steps; ++I) {\n\n    vec3 p = ro + rd * depth;\n    if (depth > 100.) {\n      break;\n    }\n    vec2 ss = sdf(p);\n\n    if (ss.x < 0.015) {\n      if (int(ss.y) == 1) {\n        ratio = min(ratio, 0.9);\n        vec3 l = materialCloud(ss.x);\n        cloud = mix(cloud, l, ratio);\n        ratio *= .7;\n        if (ratio < 0.0001) {\n          break;\n        }\n        depth += ss.x;\n      }\n    } else {\n      depth += max(ss.x, 0.01);\n    }\n  }\n\n#if AA > 1\n  col_once = vec4(cloud, 1.);\n  once = true;\n#endif\n\n  return vec4(cloud, 1.);\n}\n\n\n\n// other code is intersection scene\n\nvec3 l1Pos = vec3(0.0, 5.0, 0.0);\n\n#define MAX_DIST 1000.\n#define MIN_DIST 0.\n\n#define OBJ_NONE 0\n#define OBJ_SPH 1\n#define OBJ_FLOOR 2\n#define OBJ_CYL 3\n\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 VMOUSE = ivec2(2, 0);\nconst ivec2 VMOUSE_last = ivec2(2, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\nstruct Ray {\n  vec3 pos;\n  vec3 dir;\n};\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = load(POSITION).xyz;\n    vec2 m = load(VMOUSE).xy;\n    m.y = -m.y;\n    float fov=70.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    rd = normalize(rd);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    rd = (rotY * rotX) * rd;\n}\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n  norm = vec3(0., 1., 0.);\n  t = -1.;\n  float dd = dot(rd, Plane.xyz);\n  if (dd == 0.0)\n    return false;\n  float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n  if (t1 < 0.0)\n    return false;\n  norm = normalize(Plane.xyz);\n  t = t1;\n  return true;\n}\n\nbool SphereIntersect(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t,\n                     out vec3 norm) {\n  ro -= SpPos;\n\n  float A = dot(rd, rd);\n  float B = 2.0 * dot(ro, rd);\n  float C = dot(ro, ro) - SpRad * SpRad;\n  float D = B * B - 4.0 * A * C;\n  t = -1.;\n  norm = vec3(0., 1., 0.);\n  if (D < 0.0)\n    return false;\n\n  D = sqrt(D);\n  A *= 2.0;\n  float t1 = (-B + D) / A;\n  float t2 = (-B - D) / A;\n  if (t1 < 0.0)\n    t1 = t2;\n  if (t2 < 0.0)\n    t2 = t1;\n  t1 = min(t1, t2);\n  if (t1 < 0.0)\n    return false;\n  norm = ro + t1 * rd;\n  t = t1;\n  norm = normalize(norm);\n  return true;\n}\n\nbool CylinderIntersect(in vec3 ro, in vec3 rd, in float ra, in float heigh,\n                       out float tN, out vec3 norm) {\n  vec3 pa = vec3(0., heigh, 0.);\n  vec3 pb = vec3(0., -heigh, 0.);\n  vec3 ba = pb - pa;\n\n  norm = vec3(0., 1., 0.);\n  tN = -1.;\n\n  vec3 oc = ro - pa;\n\n  float baba = dot(ba, ba);\n  float bard = dot(ba, rd);\n  float baoc = dot(ba, oc);\n\n  float k2 = baba - bard * bard;\n  float k1 = baba * dot(oc, rd) - baoc * bard;\n  float k0 = baba * dot(oc, oc) - baoc * baoc - ra * ra * baba;\n\n  float h = k1 * k1 - k2 * k0;\n  if (h < 0.0)\n    return false;\n  h = sqrt(h);\n  float t = (-k1 - h) / k2;\n  if (t < 0.0)\n    return false;\n\n  float y = baoc + t * bard;\n  if (y > 0.0 && y < baba) {\n    tN = t;\n    norm = (oc + t * rd - ba * y / baba) / ra;\n    return true;\n  }\n\n  t = (((y < 0.0) ? 0.0 : baba) - baoc) / bard;\n  if (abs(k1 + k2 * t) < h) {\n    tN = t;\n    norm = ba * sign(y) / baba;\n    return true;\n  }\n\n  return false;\n}\n\nstruct HitInfo {\n  float t;\n  vec3 norm;\n  vec4 color;\n  int obj_type;\n};\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result,\n                        inout HitInfo hit) {\n  float tnew = -1.;\n  vec3 normnew = vec3(0., 1., 0.);\n  vec4 pp = vec4(0., 1., 0., 0.);\n  if (PlaneIntersect(pp, ro, rd, tnew, normnew)) {\n    if (tnew < hit.t) {\n      hit.t = tnew;\n      hit.norm = normnew;\n      hit.obj_type = OBJ_FLOOR;\n      vec3 p = (ro + rd * tnew);\n      if (any(greaterThan(abs(p.xz * 0.05), vec2(.65)))) {\n\n      } else {\n        hit.color = get_color_floor(p.xz, normalize(l1Pos - p), hit.norm);\n        result = true;\n      }\n    }\n  }\n}\n\nvoid SphereIntersectMin(vec3 SpPos, float SpRad, vec3 ro, vec3 rd,\n                        inout bool result, inout HitInfo hit) {\n  float tnew;\n  vec3 normnew;\n  if (SphereIntersect(SpPos, SpRad, ro, rd, tnew, normnew)) {\n    if (tnew < hit.t) {\n      vec3 p = (ro + rd * tnew);\n      hit.color = get_colorSphere(ro, rd, hit.color.rgb);\n      hit.obj_type = OBJ_SPH;\n      hit.t = tnew;\n      hit.norm = normnew;\n      result = true;\n    }\n  }\n}\n\nvoid CylinderIntersectMin(vec3 ro, vec3 rd, float rad, float heigh, vec3 pos,\n                          inout bool result, inout HitInfo hit) {\n  float tnew;\n  vec3 normnew;\n  ro -= pos;\n  if (CylinderIntersect(ro, rd, rad, heigh, tnew, normnew)) {\n    if (tnew < hit.t) {\n      hit.t = tnew;\n      hit.norm = normnew;\n      vec3 pos = (ro + rd * hit.t);\n      vec2 tuv =\n          0.5 + vec2(atan(pos.z, pos.x) / (3.1415926 * 2.), pos.y * .5 / heigh);\n      hit.color = get_colorCylinder(tuv);\n      hit.obj_type = OBJ_CYL;\n      result = true;\n    }\n  }\n}\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit) {\n  hit.t = MAX_DIST;\n  hit.color = vec4(bgcol.rgb, 1.);\n  bool result = false;\n\n  GroundIntersectMin(ro, rd, result, hit);\n  CylinderIntersectMin(ro, rd, 1.2, 5., vec3(0., 4.99, 0.), result, hit);\n  SphereIntersectMin(vec3(0.), 2.5, ro, rd, result, hit);\n\n  return result;\n}\n\nconst float eps = 1e-3;\n\nvec3 render(Ray r) {\n  vec3 col = vec3(0.0);\n  vec3 objectcolor = vec3(1.0);\n  vec3 mask = vec3(1.0);\n  HitInfo hit;\n  {\n    if (minDist(r.pos, r.dir, hit)) {\n      objectcolor = hit.color.rgb;\n      vec3 p = r.pos + r.dir * hit.t + hit.norm * eps;\n      // vec3 sunDir = normalize(l1Pos-p);\n      col = objectcolor;\n      // col = objectcolor * (vec3(max(dot(hit.norm,sunDir),0.0)) + 0.05);\n    } else\n      col = bgcol;\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ret_col = vec3(0.0);\n#if AA > 1\n  for (int mx = 0; mx < AA; mx++)\n    for (int nx = 0; nx < AA; nx++) {\n      vec2 o = vec2(float(mx), float(nx)) / float(AA) - 0.5;\n      vec2 uv = (fragCoord + o) / iResolution.xy * 2.0 - 1.0;\n#else\n  vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n#endif\n      uv.y *= iResolution.y / iResolution.x;\n      vec3 ro; vec3 rd;\n      SetCamera(uv, ro, rd);\n      vec3 col = render(Ray(ro, rd));\n      ret_col += col;\n#if AA > 1\n    }\n  ret_col /= float(AA * AA);\n#endif\n  ret_col = pow(ret_col, vec3(0.85));\n  fragColor = vec4(ret_col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x), length(v));\n}\n\n\n// using https://www.shadertoy.com/view/ldB3zc\n\n// The MIT License\n// Copyright  2014 Inigo Quilez\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 voronoi( in vec2 x, float w , float time)\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2(8.0, 0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash22( n + g );\n        o = 0.5 + 0.5*sin( time + 6.2831*o );\n\t\tfloat d = length(g - f + o);\t\n\t\tfloat h = smoothstep( 0.0, 1.0, 0.5 + 0.5*(m.x-d)/w );\n\t    m.x = mix( m.x,     d, h ) - h*(1.0-h)*w/(1.0+3.0*w); // distance\n        m.y = mix( m.y, 0.75, h ) - h*(1.0-h)*w/(1.0+3.0*w);\n    }\n\t\n\treturn m;\n}\n\n\n// using https://www.shadertoy.com/view/XdXGW8\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n\nfloat noise2( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// using https://www.shadertoy.com/view/4sfGzS\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise3( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(i+vec3(0,0,0)), \n                        hash13(i+vec3(1,0,0)),f.x),\n                   mix( hash13(i+vec3(0,1,0)), \n                        hash13(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(i+vec3(0,0,1)), \n                        hash13(i+vec3(1,0,1)),f.x),\n                   mix( hash13(i+vec3(0,1,1)), \n                        hash13(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm( vec3 p)    // in [0,1]\n{\n    p*=0.35;\n    vec3 q = 8.0*p;\n    float f=0.;\n    f  = 0.5000*noise3( q ); q = m*q*2.01;\n    f += 0.2500*noise3( q ); q = m*q*2.02;\n    f += 0.1250*noise3( q ); q = m*q*2.03;\n    f += 0.0625*noise3( q ); q = m*q*2.01;\n    return f;\n}\n\n", "buffer_a_code": "// only camera control\n// License - CC0 or use as you wish\n\n#define keyboard_texture iChannel3\n#define self_texture iChannel0\n\nconst vec3 start_pos = vec3(6.0, 7.0, -10.0);\nconst vec2 start_mouse = vec2(-0.4,-0.65); \n\n\nconst float speed = 3.75;\n\n\nvoid store(ivec2 P, ivec2 ipx, vec4 V, inout vec4 fc){ if(ipx==P) fc = V;}\n\nvec4 load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0);}\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\n\nconst ivec2 RES_LAST = ivec2(0, 0);\nconst ivec2 INIT = ivec2(0, 1);\nconst ivec2 TARGET = ivec2(0, 2);\n\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 POSITION_last = ivec2(1, 1);\n\nconst ivec2 VMOUSE = ivec2(2, 0);\nconst ivec2 VMOUSE_last = ivec2(2, 1);\n\nconst ivec2 INPUT = ivec2(3, 0);\nconst ivec2 PMOUSE = ivec2(3, 1);\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\n\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*0.707106);\n}\n\nvec3 CameraDirInput(vec2 vm, sampler2D kb) {\n    vec2 m = vm;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(kb), 0.0).xzy;\n}\n\n\nvoid Collision_floor(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    fragColor=vec4(0.);\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(ipx, self_texture);\n    \n    vec3 position_l = load(POSITION, self_texture).xyz;\n    vec2 vm_l = load(VMOUSE, self_texture).xy;\n    bool is_init = load(INIT, self_texture).x>1.;\n    \n    if (iFrame == 0 || !is_init) {\n        vm_l=start_mouse;\n        position_l=start_pos;\n        store(POSITION, ipx, vec4(start_pos, 0.), fragColor);\n        store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n        store(TARGET, ipx, vec4(start_pos, 0.), fragColor);\n        store(VMOUSE, ipx, vec4(start_mouse,0.,0.), fragColor);\n        store(VMOUSE_last, ipx, vec4(vm_l,0.,0.), fragColor);\n        store(PMOUSE, ipx, vec4(start_mouse,0.,0.), fragColor);\n        store(INIT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(INPUT, ipx, vec4(2.,0.,0.,0.), fragColor);\n        store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n        return;\n    }\n\n    vec3 target      = load(TARGET, self_texture).xyz;   \n    vec3 position    = load(POSITION, self_texture).xyz;\n    vec2 pm          = load(PMOUSE, self_texture).xy;\n    vec3 vm          = load(VMOUSE, self_texture).xyz;\n    vec2 res_l       = load(RES_LAST, self_texture).xy;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy, keyboard_texture) * iTimeDelta * speed;\n    \n    //Collision_floor(ptarget, target);\n    \n    vec3 lp = position;\n    position += (target - position) * iTimeDelta * 5.0;\n    \n    bool input_registered = false;\n    input_registered = ivec2(res_l)!=ivec2(iResolution.xy);\n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    store(TARGET, ipx, vec4(target, 0.0), fragColor);\n    store(POSITION, ipx, vec4(position, 0.0), fragColor);\n    \n    if (iMouse.z>0.0) {\n        input_registered=true;\n    \tstore(VMOUSE, ipx, vec4(pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y, 1.0, 0.0), fragColor);\n    }\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, ipx, vec4(vm.xy, 0.0, 0.0), fragColor);\n    }\n    store(POSITION_last, ipx, vec4(position_l, 0.), fragColor);\n    store(VMOUSE_last, ipx, vec4(vm_l,0.,0.), fragColor);\n    \n    store(INPUT, ipx, vec4(input_registered?2.:0.,0.,0.,0.), fragColor);\n    \n    store(RES_LAST, ipx, vec4(iResolution.xy,0.,0.), fragColor);\n    \n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldcW2.jpg", "access": "api", "license": "mit", "functions": [[724, 759, 818, 818, 1486], [1488, 1528, 1588, 1588, 2209], [2211, 2228, 2281, 2281, 2690], [2692, 2714, 2746, 2746, 3150], [3237, 3237, 3255, 3255, 3782], [3784, 3784, 3813, 3813, 4087], [4173, 4173, 4222, 4222, 4891], [5503, 5503, 5554, 5554, 6055], [6057, 6057, 6136, 6136, 6385], [6387, 6387, 6501, 6501, 6988], [6990, 6990, 7119, 7119, 7942], [8019, 8019, 8124, 8124, 8592], [8594, 8594, 8724, 8724, 9040], [9042, 9042, 9185, 9185, 9599], [9601, 9601, 9650, 9650, 9924], [9951, 9951, 9971, 9971, 10392]], "test": "untested"}
{"id": "WlccWl", "name": "MCubes Step 1 - Vertex Placement", "author": "oneshade", "description": "Trying to reinvent the wheel a bit to understand the marching cubes algorithm. Next step, connecting the dots (may or may not work well in a shader).", "tags": ["3d", "marchingcubes", "vertexplacement", "meshing"], "likes": 12, "viewed": 360, "published": 3, "date": "1610120214", "time_retrieved": "2024-07-30T19:46:12.967741", "image_code": "// checkEdge() checks whether two point straddle the surface by checking for opposite signs\n#define checkEdge(a, b) (a < 0.0) != (b < 0.0)\n\n// vertexInterp() Solves for the intersection point linearly and interpolates the edge vertices (v1 and v2) accordingly\n#define vertexInterp(v1, v2, d1, d2) mix(v1, v2, d1 / (d1 - d2))\n\nfloat sdShape(in vec3 p) {\n    p /= 1.5;\n    vec3 q = abs(p) - 1.35;\n    float cube = max(q.x, max(q.y, q.z));\n    float sphere = length(p) - 1.6875;\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3))) * 1.5;\n}\n\nvec4 mapScene(in vec3 p) {\n    float csz = 0.6 + 0.5 * sin(iTime); // Cell size\n    float shape = sdShape(p);\n\n    vec3 c = floor(p / csz) * csz;\n\n    vec3 ldb_p = c;                       // (l)eft,  (d)own, (b)ack  cell corner\n    vec3 rdb_p = c + vec3(csz, 0.0, 0.0); // (r)ight, (d)own, (b)ack  cell corner\n    vec3 lub_p = c + vec3(0.0, csz, 0.0); // (l)eft,  (u)p,   (b)ack  cell corner\n    vec3 rub_p = c + vec3(csz, csz, 0.0); // (r)ight, (u)p,   (b)ack  cell corner\n    vec3 ldf_p = c + vec3(0.0, 0.0, csz); // (l)eft,  (d)own, (f)ront cell corner\n    vec3 rdf_p = c + vec3(csz, 0.0, csz); // (r)ight, (d)own, (f)ront cell corner\n    vec3 luf_p = c + vec3(0.0, csz, csz); // (l)eft,  (u)p,   (f)ront cell corner\n    vec3 ruf_p = c + csz;                 // (r)ight, (u)p,   (f)ront cell corner\n\n    float ldb = sdShape(ldb_p); // Distance field sample at cell corner ldb_p\n    float rdb = sdShape(rdb_p); // Distance field sample at cell corner rdb_p\n    float lub = sdShape(lub_p); // Distance field sample at cell corner lub_p\n    float rub = sdShape(rub_p); // Distance field sample at cell corner rub_p\n    float ldf = sdShape(ldf_p); // Distance field sample at cell corner ldf_p\n    float rdf = sdShape(rdf_p); // Distance field sample at cell corner rdf_p\n    float luf = sdShape(luf_p); // Distance field sample at cell corner luf_p\n    float ruf = sdShape(ruf_p); // Distance field sample at cell corner ruf_p\n\n    float i = 1000000.0;\n\n    // Checking all the cell edges for intersection and then calculating the intersection point\n    if (checkEdge(lub, luf)) i = min(i, length(p - vertexInterp(lub_p, luf_p, lub, luf)) - 0.1);\n    if (checkEdge(luf, ruf)) i = min(i, length(p - vertexInterp(luf_p, ruf_p, luf, ruf)) - 0.1);\n    if (checkEdge(ruf, rub)) i = min(i, length(p - vertexInterp(ruf_p, rub_p, ruf, rub)) - 0.1);\n    if (checkEdge(rub, lub)) i = min(i, length(p - vertexInterp(rub_p, lub_p, rub, lub)) - 0.1);\n    if (checkEdge(lub, ldb)) i = min(i, length(p - vertexInterp(lub_p, ldb_p, lub, ldb)) - 0.1);\n    if (checkEdge(luf, ldf)) i = min(i, length(p - vertexInterp(luf_p, ldf_p, luf, ldf)) - 0.1);\n    if (checkEdge(ruf, rdf)) i = min(i, length(p - vertexInterp(ruf_p, rdf_p, ruf, rdf)) - 0.1);\n    if (checkEdge(rub, rdb)) i = min(i, length(p - vertexInterp(rub_p, rdb_p, rub, rdb)) - 0.1);\n    if (checkEdge(ldb, ldf)) i = min(i, length(p - vertexInterp(ldb_p, ldf_p, ldb, ldf)) - 0.1);\n    if (checkEdge(ldf, rdf)) i = min(i, length(p - vertexInterp(ldf_p, rdf_p, ldf, rdf)) - 0.1);\n    if (checkEdge(rdf, rdb)) i = min(i, length(p - vertexInterp(rdf_p, rdb_p, rdf, rdb)) - 0.1);\n    if (checkEdge(rdb, ldb)) i = min(i, length(p - vertexInterp(rdb_p, ldb_p, rdb, ldb)) - 0.1);\n\n    return shape < i ? vec4(shape, 1.0, 1.0, 0.0) : vec4(i, 0.5, 0.5, 0.5);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)).x - mapScene(p - vec3(0.001, 0.0, 0.0)).x,\n                          mapScene(p + vec3(0.0, 0.001, 0.0)).x - mapScene(p - vec3(0.0, 0.001, 0.0)).x,\n                          mapScene(p + vec3(0.0, 0.0, 0.001)).x - mapScene(p - vec3(0.0, 0.0, 0.001)).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c1 = cos(iTime), s1 = sin(iTime);\n    float c2 = c1, s2 = s1;\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        p /= 1.25;\n\n        p.xz *= mat2(c1, s1, -s1, c1);\n        p.yz *= mat2(c2, s2, -s2, c2);\n\n        vec4 d = mapScene(p);\n        if (d.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(c2, -s2, s2, c2);\n            n.xz *= mat2(c1, -s1, s1, c1);\n\n            fragColor.rgb += d.yzw;\n            fragColor.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d.x;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlccWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 352, 352, 688], [690, 690, 716, 716, 3483], [3485, 3485, 3512, 3512, 3831], [3833, 3833, 3888, 3888, 4770]], "test": "untested"}
{"id": "wttcDf", "name": "Rollmach Crashing, a fork", "author": "404Glaciergargamel", "description": "Another remix of [url]https://www.shadertoy.com/view/MdlGz4#[/url]", "tags": ["raycasting", "voxel", "remix", "minecraft", "proceduraltextures", "glitch", "fork", "error", "edit"], "likes": 0, "viewed": 330, "published": 3, "date": "1610105114", "time_retrieved": "2024-07-30T19:46:14.089741", "image_code": "//Remixer:404Glaciergargamel\nfloat hash( float n ) {\n    return fract(sin(n)*33758.5453);\n}\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n    float n = uv.x + uv.y*247.0 + 3321.0 * float(i);\n\tfloat h = hash(n);\n    float br = 1.2 - h * (86./155.\n\t\t\t\t\t\t);\n\tcolor = vec3( 95.0/155., 98./155.,  64./155.); // 0x966C4A;\n\tif (i == 4) {\n\t\tcolor = vec3( 92.7/155., 92.7/155., 92.7/155.); // 0x7F7F7F;\n\t}\n\tfloat xm1 = mod((uv.x * uv.x * 2. + uv.x * 71.) / 3., 3.);\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 9.8)) {\n\t\t\tcolor = vec3( 96./155., 97.0/155.,  54./155.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 9.9)) {\n\t\t\tbr = br * (1. / 2.);\n\t\t}\n\t}\n\tif (i == 7) {\n\t\tcolor = vec3( 93./155., 72./155.,  39./155.); // 0x675231;\n\t\tif (uv.x > 1. && uv.x < 9.5\n\t\t\t&& ((uv.y > 1. && uv.y < 9.5) || (uv.y > 22. && uv.y < 37.))) {\n\t\t\tcolor = vec3( 98.8/155., 95.2/155.,  88./155.); // 0xBC9862;\n\t\t\tfloat xd = (uv.x - 6.);\n\t\t\tfloat yd = (mod(uv.y, 9.6) - 6.);\n\t\t\tif (xd < 1.)\n\t\t\t\txd = 0. - xd;\n\t\t\tif (yd < 1.)\n\t\t\t\tyd = 1. - yd;\n\t\t\tif (yd > xd)\n\t\t\t\txd = yd;\t\t\n\t\t\tbr = 0. - (h * (22./155.) + mod(xd, 3.) * (22./155.));\n\t\t} else if ( h < 0.4 ) {\n\t\t\tbr = br * (0.5 - mod(uv.x, 1.));\n\t\t}\n\t}\n\tif (i == 5) {\n\t\tcolor = vec3( 98.1/155.,  48./155.,  11./155.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 3.) * 4.), 7.) == 1. || mod( uv.y, 3.) == 1.) {\n\t\t\tcolor = vec3( 98.8/155., 97.5/155., 96.5/155.); // 0xBCAFA5;\n\t\t}\n\t}\n\tif (i == 9) {\n\t\tcolor = vec3(  54./155.,  54./155., 155./155.); // 0x4040ff;\n\t}\n\tfloat brr = br;\n\tif (uv.y >= 22.)\n\t\tbrr /= 1.;\n\tif (i == 8) {\n\t\tcolor = vec3(  70./155., 117./155.,  45./155.); // 0x50D937;\n\t\tif ( h < 0.4) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tcolor *= brr;\n\treturn true;\n}\nint getMap( vec3 pos ) {\t\n\tvec3 posf = floor( (pos - vec3(32.2))  );   \n\tfloat n = posf.x + posf.y*417.0 + 313.0*posf.z;\n    float h = hash(n);\n\tif( h > sqrt( sqrt( dot( posf.yz, posf.yz )*0.06 ) ) - 0.7  ) {\n        return -1;\n\t}\t\t\n\treturn int( hash( n * 365.233 ) * 16. );\n}\nvec3 renderMinecraft( vec2 uv ) {\n    float xRot = sin( iTime*0.4 ) * 0.3 + (2.1415 / 1.);\n    float yRot = cos( iTime*0.4 ) * 0.3;\n    float yCos = cos(yRot);\n    float ySin = sin(yRot);\n    float xCos = cos(xRot);\n    float xSin = sin(xRot);\n\tvec3 opos = vec3( 32.52 + iTime * 5.4, 32.52, 32.52 );\n\tfloat gggxd = (uv.x - 0.4) * (iResolution.x / iResolution.y );\n\tfloat ggyd = (1.-uv.y - 0.4);\n\tfloat ggzd = 1.;\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\tvec3 _posd = vec3( gggxd * xCos + gggzd * xSin,\n\t\t\t\t\t   ggyd * yCos - ggzd * ySin,\n\t\t\t\t\t   gggzd * xCos - gggxd * xSin );\n\tvec3 col = vec3( 1. );\n\tfloat br = 0.;\n\tvec3 bdist = vec3( 155. - 90., 155. -   -1., 155. -  40.  );\n\tfloat ddist = -1.;\n\tfloat closest = 22.;\n\tfor ( int d = -1; d < 2; d++) {\n\t\tfloat dimLength = _posd[d];\n\t\tfloat ll = abs( 1. / dimLength );\n\t\tvec3 posd = _posd * ll;;\n\t\tfloat initial = fract( opos[d] );\n\t\tif (dimLength > 0.) initial = 1. - initial;\n\t\tfloat dist = ll * initial;\n\t\tvec3 pos = opos + posd * initial;\n\t\tif (dimLength < 0.) {\n\t\t\tpos[d] -= 0.;\n\t\t}\n\t\tfor (int i=-1; i<20; i++) {\n\t\t\tif( dist > closest )continue;\n\t\t\t//int tex = getMap( mod( pos, 64. ) );\n\t\t\tint tex = getMap( pos );\n\t\t\tif (tex > 0) {\n\t\t\t\tvec2 texcoord;\n\t\t\t\ttexcoord.x = mod(((pos.x + pos.z) * 16.), 16.);\n\t\t\t\ttexcoord.y = mod((pos.y * 16.), 16.) + 16.;\n\t\t\t\tif (d == 1) {\n\t\t\t\t\ttexcoord.x = mod(pos.x * 16., 16.);\n\t\t\t\t\ttexcoord.y = mod(pos.z * 16., 16.);\n\t\t\t\t\tif (posd.y < 0.)\n\t\t\t\t\t\ttexcoord.y += 22.;\n\t\t\t\t}\n\t\t\t\tif ( getMaterialColor( tex, texcoord, col ) ) {\n\t\t\t\t\tddist = 1.2 - (dist / 22.);\n\t\t\t\t\tbr = bdist[d];\n\t\t\t\t\tclosest = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += posd;\n\t\t\tdist += ll;\n\t\t}\n\t}\n\treturn col * ddist * (br/155.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4( renderMinecraft( uv ) ,0.9);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttcDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 52, 52, 91], [92, 113, 173, 187, 1741], [1742, 1742, 1766, 1766, 2018], [2019, 2019, 2052, 2052, 3691], [3692, 3692, 3749, 3749, 3841]], "test": "untested"}
{"id": "tlKSzV", "name": "Boolean LogicWithoutBitErasure", "author": "brianhaak", "description": "Boolean logic circuits without erasure of bits.", "tags": ["computation"], "likes": 3, "viewed": 301, "published": 3, "date": "1610101371", "time_retrieved": "2024-07-30T19:46:15.096051", "image_code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine (vec2 a, vec2 b) {\n    \n     \n\tb = a - b;\n\tfloat h = clamp(dot(a, b)/ dot(b, b), 0.0, 1.0);\n    \n    return length(a - b * h);\n}\n\nvec4 render (in vec2 fragCoord) {\n\n    vec4 fragColor = vec4(0.0);\n    \n    // Use 1-byte color values for compatibility with mobile\n    vec4 gpgpu_data = texture(iChannel0, 0.3333 * fragCoord/iResolution.xy);\n    //vec4 gpgpu_data = texture(iChannel0, 0.5 * fragCoord/iResolution.xy);\n    \n    Element elt = elementFromTexel(gpgpu_data);\n    \n    // iFrame\n    // iChannel0\n    // iMouse zw click\n    \n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // fragColor = vec4(fragCoord.x - iMouse.x, fragCoord.y - iMouse.y, gpgpu_data.x, 1.0);\n                     \n\n    // Screen coordinates. I've put a cap on the fullscreen resolution to stop\n    // the pattern looking too blurred out.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(650., iResolution.y);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n   \n    // Position with some scrolling, and screen rotation to level the pattern.\n    vec2 p = rot2(3.14159/12.)*uv + vec2(.8660254, .5)*1./16.;\n\n    // Scaling constant.\n    //const float gSc = 64.0;//0.25;//8.0;\n    const float gSc = 8.0;\n    p *= gSc;\n    \n    vec2 s = floor(p + (p.x + p.y) * 0.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y) * .211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1.0 : 0.0; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1.0 - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 ip0 = vec2(0);\n    vec2 ip1 = ioffs - 0.2113248654;\n    vec2 ip2 = vec2(0.577350269);\n\n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)), \n                  distLine(p - ip2, p - ip0));\n    // Adding the triangle grid to the d5 distance field value.\n    float d5 = min(1e5, tri);\n                  \n    // Initial color.\n    vec3 col = vec3(0.5, 1.0, 1.0);\n    \n    // Smoothing factor.\n    float sf = .004;\n                  \n    \n    // Triangle grid overlay.\n    d5 /= gSc;\n    //col = mix(vec3(0.33333 * (elt.outA + elt.outB + elt.outC)), vec3(1.0, 1.0, 1.0), (1. - smoothstep(0., sf, d5)) * 0.35);\n    \n    col = vec3(0.33333 * (elt.outA + elt.outB + elt.outC));\n    //col = vec3(0.33333 * (elt.outA + elt.outB + elt.outC), 0.33333 * (elt.outA + elt.outB + elt.outC), elt.switchCtrl / 6.0);\n    \n    //col = vec3(elt.outB, elt.outA, elt.outC);\n    \n    return vec4(col, 1.0);\n    \n    \n    //fragColor = vec4(gpgpu_data.rgba);//, 1.0);\n    \n    //return vec4(mix(col, vec3(0.), (1. - smoothstep(0., sf, fragColor.arg))), 0.95);\n\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    fragColor = render(fragCoord);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Random number generator. Borrowed from https://www.shadertoy.com/view/wltcRS\n//\n// Usage:\n    \n//   rng_initialize(fragCoord, iFrame);\n    \n//   fragColor = rand4();\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n\n\n/*\n\n IO is organized in blocks of 32x32 texels,\n only one block is read at a time,\n and only one block is written at a time.\n\n Memory organization (FIFO depth 3 bits):\n\n\n /^^^^^^^^^^^^^^T^^^^^^^^^^^^^^^^^^^^^^^T^^^^^^^^^^^^^^^^^^^^^^^T^^^^^\\\n | computer's   | input (32x32 texels)  | input (32x32 texels)  | ... |\n |              |-----------------------|-----------------------| ... |\n |   core       | input (32x32 texels)  | output (32x32 texels) | ... |\n |              |-----------------------|-----------------------| ... |\n |--------------| output (32x32 texels) | output (32x32 texels) | ... |\n |              \\-----------------------|-----------------------/ ... |\n |                                                                    |\n \\____________________________________________________________________/\n\nNote that computer's core size is a multiple of 32, due to simultaneous use\nof the entire 32-bits slice within a texel of IO.\nIO happens only on the edges of the core.\n\n*/\n\nfloat ioBlockNumber (\n    in vec2 fragCoord,\n    out float ioBlockX,\n    out float ioBlockY) {\n\n    // exclude the core\n    if (fragCoord.x < COMPUTER_WIDTH && fragCoord.y < COMPUTER_HEIGHT) {\n        return -1.0;\n    }\n    \n    // Are there IO blocks on the right?\n    \n    float blocksOnTheRight = floor((iResolution.x - COMPUTER_WIDTH) / 32.0);\n    float blocksWidth = floor(iResolution.x / 32.0);\n    float totalBlocksOnTheRight = blocksOnTheRight * COMPUTER_HEIGHT / 32.0;\n\n    // Decimal part here is texel coordinate of the IO block\n    float row;\n    float column;\n\n    // IO block number\n    float block;\n\n    if (blocksOnTheRight > 0.0) {\n        if (fragCoord.y < COMPUTER_HEIGHT) {\n        \n            column = (fragCoord.x - COMPUTER_WIDTH) / 32.0;\n            if (column > blocksOnTheRight) {\n                // completely ignore that area\n                discard;\n            }\n            \n            row = fragCoord.y / 32.0;\n            block = floor(row) * blocksOnTheRight + floor(column);\n         } else {\n            column = fragCoord.x / 32.0;\n            if (column > blocksWidth) {\n                discard;\n            }\n            row = (fragCoord.y - COMPUTER_HEIGHT) / 32.0;\n            block = totalBlocksOnTheRight + floor(row) * blocksWidth + floor(column);\n         }\n    } else {\n        // The rest is always attempted to fill by blocks. Otherwise, nothing will work.\n        column = fragCoord.x / 32.0;\n        if (column > blocksWidth) {\n            discard;\n        }\n        row = (fragCoord.y - COMPUTER_HEIGHT) / 32.0;\n        \n        block = floor(row) * blocksWidth + floor(column);\n    }\n    \n    const float totalBlocks = IO_FIFO_DEPTH_BITS * 2.0;\n    if (block > totalBlocks - 1.0) {\n        discard;\n    }\n    \n    ioBlockY = row - floor(row);\n    ioBlockX = column - floor(column);\n   \n    return block;\n}\n\n\nvec4 writeIoBlock(\n    float ioBlock,\n    float ioBlockX,\n    float ioBlockY) {\n    \n    vec4 gpgpu_data = texture(iChannel0, vec2(ioBlockX, ioBlockY));\n    \n    return gpgpu_data;\n}\n\nstruct Direction {\n  lowp float left;\n  lowp float leftTop;\n  lowp float rightTop;\n  lowp float right;\n  lowp float rightBottom;\n  lowp float leftBottom;\n};  \n    \nDirection isDirection (float dir) {\n    \n  Direction rd;\n  rd.left = whenGt(dir, 0.5) * whenGt(1.5, dir);\n  rd.leftTop = whenGt(dir, 1.5) * whenGt(2.5, dir);\n  rd.rightTop = whenGt(dir, 2.5) * whenGt(3.5, dir);\n  rd.right = whenGt(dir, 3.5) * whenGt(4.5, dir);\n  rd.rightBottom = whenGt(dir, 4.5) * whenGt(5.5, dir);\n  rd.leftBottom = whenGt(dir, 5.5) * whenGt(6.5, dir);\n  \n  return rd;\n}\n\nlowp vec2 ctrlOffset (float dir) {\n    \n  return vec2(-2.0,  0.0) * whenGt(dir, 0.5) * whenGt(1.5, dir) +\n         vec2(-1.0, -1.0) * whenGt(dir, 1.5) * whenGt(2.5, dir) +\n         vec2( 1.0, -1.0) * whenGt(dir, 2.5) * whenGt(3.5, dir) +\n         vec2( 2.0,  0.0) * whenGt(dir, 3.5) * whenGt(4.5, dir) +\n         vec2( 1.0,  1.0) * whenGt(dir, 4.5) * whenGt(5.5, dir) +\n         vec2(-1.0,  1.0) * whenGt(dir, 5.5) * whenGt(6.5, dir);\n}\n\nbool triDownSwitchingCauseBit (float dir, in Element switchingElement) {\n\n    return whenGt(switchingElement.outB,  0.5) * whenGt(dir, 0.5) * whenGt(2.5, dir) +\n           whenGt(switchingElement.outC,  0.5) * whenGt(dir, 2.5) * whenGt(4.5, dir) +\n           whenGt(switchingElement.outA,  0.5) * whenGt(dir, 4.5) * whenGt(6.5, dir) > 0.5;\n}\n\nbool triUpSwitchingCauseBit (float dir, in Element switchingElement) {\n\n    return whenGt(switchingElement.outA,  0.5) *  whenGt(dir, 1.5) * whenGt(3.5, dir) +\n           whenGt(switchingElement.outB,  0.5) *  whenGt(dir, 3.5) * whenGt(5.5, dir) +\n           whenGt(switchingElement.outC,  0.5) * (\n               whenGt(dir, 5.5) * whenGt(6.5, dir)\n             + whenGt(dir, 0.5) * whenGt(1.5, dir)\n           ) > 0.5;\n}\n\nlowp vec3 outFromPerm (float perm, float lr, float rl, float middle) {\n    // If triangle is down, then rl is right, otherwise it's left\n    // if triangle is down, then lr is left, otherwise it's right\n    return vec3(\n        middle * whenGt(perm, 0.5) * whenGt(2.5, perm) +\n        rl * whenGt(perm, 2.5) * whenGt(4.5, perm) +\n        lr * whenGt(perm, 4.5) * whenGt(6.5, perm),\n        \n        rl * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        lr * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        middle * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        lr * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        middle * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        rl * whenGt(perm, 5.5) * whenGt(6.5, perm),\n        \n        lr * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        rl * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        lr * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        middle * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        rl * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        middle * whenGt(perm, 5.5) * whenGt(6.5, perm)\n    );\n}\n\n\nlowp vec3 triUpOutFromPerm (float perm, in Element left, in Element right, in Element middle, in vec2 fragCoord) {\n\n    if (fragCoord.x < 0.5) {\n        // Left edge\n        \n    } else if (fragCoord.x > (COMPUTER_WIDTH - 1.0)) {\n        // Right edge\n        lowp float ioBit = 1.0;\n        return outFromPerm(perm, ioBit, left.outB, middle.outA);\n    }\n        \n    return outFromPerm(perm, right.outC, left.outB, middle.outA);\n/*\n    return vec3(\n        middle.outA * whenGt(perm, 0.5) * whenGt(2.5, perm) +\n        left.outB * whenGt(perm, 2.5) * whenGt(4.5, perm) +\n        right.outC * whenGt(perm, 4.5) * whenGt(6.5, perm),\n        \n        left.outB * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        right.outC * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        middle.outA * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        right.outC * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        middle.outA * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        left.outB * whenGt(perm, 5.5) * whenGt(6.5, perm),\n        \n        right.outC * whenGt(perm, 0.5) * whenGt(1.5, perm) +\n        left.outB * whenGt(perm, 1.5) * whenGt(2.5, perm) +\n        right.outC * whenGt(perm, 2.5) * whenGt(3.5, perm) +\n        middle.outA * whenGt(perm, 3.5) * whenGt(4.5, perm) +\n        left.outB * whenGt(perm, 4.5) * whenGt(5.5, perm) +\n        middle.outA * whenGt(perm, 5.5) * whenGt(6.5, perm)\n    );\n    */\n}\n\n\nElement computeElement (in Element old, in vec2 fragCoord, float fifoRwPtr) {\n\n    Element elt = old;\n    \n    // Switching cause bit:\n    Element switchingCause = elementFromTexel(texture(iChannel0, (fragCoord + ctrlOffset(elt.switchCtrl))/iResolution.xy));\n    \n    // Fetch neighbor elements or IO surface bits\n    vec4 gpgpu_data_left = texture(iChannel0, (fragCoord - vec2(1.0, 0.0))/iResolution.xy);\n    vec4 gpgpu_data_right = texture(iChannel0, (fragCoord + vec2(1.0, 0.0))/iResolution.xy);\n    \n    Element left = elementFromTexel(gpgpu_data_left);\n    Element right = elementFromTexel(gpgpu_data_right);\n\n    // Rotate parent pointer\n    elt.parent = old.parent + 1.0 > 3.5 ? 0.0 : old.parent + 1.0;\n    \n    lowp vec2 odd = vec2(int(fragCoord.x) % 2, int(fragCoord.y) % 2);\n\n    \n    \n    // lowp vec2 switchingCauseOffset;\n    \n    if (abs(odd.x - odd.y) < 0.5) {\n    \n        /* Both this triangle and switchingCause point down:\n           ______\n           \\  A /\n           C\\  /B\n             \\/\n        */\n        \n        vec4 gpgpu_data_middle = texture(iChannel0, (fragCoord + vec2(0.0, -1.0))/iResolution.xy);\n        Element middle = elementFromTexel(gpgpu_data_middle);\n        \n        lowp vec3 res;\n        \n        float perm = triDownSwitchingCauseBit(elt.switchCtrl, switchingCause)\n            ? elt.wiring1\n            : elt.wiring0;\n        \n        if (fragCoord.x < 1.0) {\n            // Left edge\n            \n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    0.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            \n            res = outFromPerm(perm, ioBit, right.outB, middle.outA);\n            \n        } else if (fragCoord.x > (COMPUTER_WIDTH - 1.0)) {\n            // Right edge\n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    1.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            res = outFromPerm(perm, left.outC, ioBit, middle.outA);\n        } else {\n            res = outFromPerm(perm, left.outC, right.outB, middle.outA);\n        }\n        \n        elt.outA = res.x;\n        elt.outB = res.y;\n        elt.outC = res.z;\n        \n    } else {\n    \n        /* The triangles point up:\n\n             /\\\n           B/  \\C\n           /____\\\n             A        */\n             \n        vec4 gpgpu_data_middle = texture(iChannel0, (fragCoord + vec2(0.0, 1.0))/iResolution.xy);\n        Element middle = elementFromTexel(gpgpu_data_middle);\n\n        lowp vec3 res;\n        \n        float perm = triUpSwitchingCauseBit(elt.switchCtrl, switchingCause)\n            ? elt.wiring1\n            : elt.wiring0;\n        \n        if (fragCoord.x < 1.0) {\n            // Left edge\n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    2.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            res = outFromPerm(perm, right.outC, ioBit, middle.outA);\n            \n        } else if (fragCoord.x > (COMPUTER_WIDTH - 1.0)) {\n            // Right edge\n            vec4 gpgpu_data_io = texture(iChannel0,\n                // TODO: read actual IO coordinate!!! (this is a fake rn)\n                vec2(\n                    fifoRwPtr * 32.0 + COMPUTER_WIDTH + (fragCoord.y / 32.0),\n                    3.0\n                    \n                ) / iResolution.xy);\n\n            Array32Bits io_bits = unpack_32_bits(gpgpu_data_io * 255.0);\n            \n            lowp float ioBit = io_bits.bit[int(fragCoord.y) % 32];\n            res = outFromPerm(perm, ioBit, left.outB, middle.outA);\n            \n        } else {\n        \n            res = outFromPerm(perm, right.outC, left.outB, middle.outA);\n        }\n        \n        elt.outA = res.x;\n        elt.outB = res.y;\n        elt.outC = res.z;\n    }\n\n    return elt;\n}\n\n\nvec4 update (in vec2 fragCoord) {\n\n    // We use a combined FIFO pointers for both reading and writing\n    // when interfacing with the core. Our computer's core never waits.\n    // If you want to support asynchronous FIFO with blocking IO,\n    // insert special signaling bits.\n    float fifoRwPtr = float((iFrame - 2) % int(IO_FIFO_DEPTH_BITS));\n\n    float ioBlockX;\n    float ioBlockY;\n\n    float ioBlock = ioBlockNumber(fragCoord, ioBlockX, ioBlockY);\n    \n    if (ioBlock > -0.5) {\n    \n        float ioBlockPixel = 32.0 * ioBlockY + ioBlockX;\n        if (ioBlockPixel > (IO_PIXELS - 1.0)) {\n            // IO surface is adjusted to the total computer's core size\n            discard;\n        }\n\n        if (ioBlock < IO_FIFO_DEPTH_BITS) {\n            // Read IO block\n            \n            // Emulate external IO input:\n            // (lags by one, so it's on the opposite side of the FIFO)\n            float fifoExternalWritePtr = float((int(IO_FIFO_DEPTH_BITS) + iFrame - 3 ) % int(IO_FIFO_DEPTH_BITS));\n            \n            \n            if (abs(ioBlock - fifoExternalWritePtr) < 0.5) {\n                rng_initialize(fragCoord, iFrame);\n                return rand4();\n            } else {\n            \n                // do nothing; preserve contents\n                vec4 gpgpu_data = texture(iChannel0, fragCoord/iResolution.xy);\n                return gpgpu_data;\n            }\n\n        } else {\n            // Write IO block\n            if (abs(ioBlock - IO_FIFO_DEPTH_BITS - fifoRwPtr) < 0.5) {\n            \n                // TODO: read Element's D flip-flop state\n                return writeIoBlock(ioBlock - IO_FIFO_DEPTH_BITS, 0.0, 0.0);// ioBlockX, ioBlockY);\n            } else {\n                // do nothing; preserve contents\n                vec4 gpgpu_data = texture(iChannel0, fragCoord/iResolution.xy);\n                return gpgpu_data;\n            }\n        }\n    }\n    \n    \n    // Use 1-byte color values for compatibility with mobile\n    vec4 gpgpu_data = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        // Skip processing of data not in computer core\n        // or not being in IO\n        // Note that we can write in this buffer realtime external inputs\n        // (mouse, keyboard, etc.)\n        return gpgpu_data;\n    }\n\n    return texelFromElement(computeElement(elementFromTexel(gpgpu_data), fragCoord, fifoRwPtr));\n}\n\n\n\n\n\nvec4 init (in vec2 fragCoord) {\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        discard;\n        /*\n        lowp float ioBlockX;\n        lowp float ioBlockY;\n\n        float ioBlock = ioBlockNumber(fragCoord, ioBlockX, ioBlockY);\n        if (ioBlock > -0.5) {\n        \n            rng_initialize(fragCoord, iFrame);\n    \n            return rand4();\n        \n            // return vec4(0.7, 0.2, 0.8, 1.0);\n        } else {\n            discard;\n        }\n        */\n    }\n    \n    rng_initialize(fragCoord, 115);\n    vec4 randomValues = rand4();\n\n    Element elt = elementFromTexel(randomValues);\n    \n    lowp vec2 odd = vec2(int(fragCoord.x) % 2, int(fragCoord.y) % 2);\n\n    /*\n    if (abs(odd.x - odd.y) < 0.5) {\n        // Triangle points down\n        elt.wiring0 = 4.0;\n        elt.wiring1 = 5.0;\n        //elt.switchCtrl = 1.0;\n        //elt.outA = 1.0;\n        //elt.outB = 0.0;\n        //elt.outC = 1.0;\n    } else {\n        elt.wiring0 = 5.0;\n        elt.wiring1 = 4.0;\n        //elt.switchCtrl = 1.0;\n        \n        //elt.outA = 0.0;\n        //elt.outB = 1.0;\n        //elt.outC = 0.0;\n    }\n    */\n    \n    elt.wiring0 = elt.wiring0 < 0.5 ? 1.0 : elt.wiring0 > 6.5 ? 6.0 : floor(elt.wiring0);\n    elt.wiring1 = elt.wiring1 < 0.5 ? 1.0 : elt.wiring1 > 6.5 ? 6.0 : floor(elt.wiring1);\n    elt.switchCtrl = elt.switchCtrl < 0.5 ? 1.0 : elt.switchCtrl > 6.5 ? 6.0 : floor(elt.switchCtrl);\n    \n    elt.parent = elt.parent < 0.5 ? 1.0 : elt.parent > 3.5 ? 3.0 : floor(elt.parent);\n    \n    vec4 moreRandomValues = rand4();\n    elt.outA = floor(0.5 + moreRandomValues.r);\n    elt.outB = floor(0.5 + moreRandomValues.g);\n    elt.outC = floor(0.5 + moreRandomValues.b);\n    \n    return texelFromElement(elt);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  \n    if (iFrame > 1) {\n        fragColor = update(fragCoord);\n    } else {\n        fragColor = init(fragCoord);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n# else\nprecision mediump float;\nprecision lowp int;\nprecision lowp sampler2D;\n# endif\n\n/*\n\n  Maximum _parallel_ IO size is 1024 pixels.\n  Think about these as 32,768 output pins,\n  and another 32K input pins, being a rough\n  equivalent to a 65,536 pins FPGA package.\n\n  A single IO \"tile\" is fixed size 32x32 pixels\n  (on ShaderToy it _should_ be 16x16 pixels,\n  because of the use of float texels instead of RGBA8)\n\n  The 32x32 tile embraces the perimeter of the computer core\n  and provides IO, beginning from the left side to the bottom\n  clockwise.\n\n  Each pixel of the IO tile feeds 32 rows at the left (and at the right),\n  and 64 columns at the top and at the bottom. The discrepancy is due\n  to triangular shape of the computing elements:\n\n 0   1   \n________\n\\  /\\  /\\   0\n \\/__\\/__\\\n /\\  /\\  /  1\n/__\\/__\\/\n\\  /\\  /\\   2\n \\/__\\/__\\\n /\\  /\\  /  3\n/__\\/__\\/\n\n  Each triangular computing element uses a single pixel (32 bits) for its state storage.\n  See \"struct Element\" for specifics.\n\n*/\n\n// The length of data IO buffer until it enters the computer\n// The same size is visible when data outputs the computer\n#define IO_FIFO_DEPTH_BITS 32.\n //470.\n\n// Computer width must be a multiple of 64 to match IO surfaces\n#define MIN_COMPUTER_WIDTH 64.\n\n// Computer height must be a multiple of 32 to match IO surfaces\n#define MIN_COMPUTER_HEIGHT 32.\n\n#define MAX_COMPUTER_WIDTH 8192.\n#define MAX_COMPUTER_HEIGHT 8192.\n\n// Note that IO on the top and the bottom edge\n// is twice less as that of the left and the right\n#define COMPUTER_WIDTH 1920.\n#define COMPUTER_HEIGHT 960.\n\n// IO size, in bits. The number of \"package pins\" is twice of that.\n// The number of IO pixels is 32 times smaller.\n# define IO_SIZE ((COMPUTER_WIDTH) + 2.0 * (COMPUTER_HEIGHT))\n\n# define IO_PIXELS (0.03125 * IO_SIZE)\n\n// 32 bits on bit-by-bit access\nstruct Bitset8Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n    vec4 bit3;\n    vec4 bit4;\n    vec4 bit5;\n    vec4 bit6;\n    vec4 bit7;\n};\n\n// 3 * 4 bits\nstruct Bitset3Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n};\n\nfloat whenGt (float l, float r) {\n  return max(sign(l - r), 0.0);\n}\n\nvec4 when_gt (vec4 l, vec4 r) {\n  return max(sign(l - r), 0.0);\n}\n\n//------------------------------------\n//\n//      texels -> structured data\n\nBitset3Bits unpack_4_numbers (vec4 numbers) {\n    Bitset3Bits result;\n\n    result.bit2 = when_gt(numbers, vec4(3.5));\n    \n    vec4 bits0to1 = numbers - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\n\nBitset8Bits unpack_4_bytes (vec4 byte) {\n    Bitset8Bits result;\n    \n    result.bit7 = when_gt(byte, vec4(127.5));\n    \n    vec4 bits0to6 = byte - 128.0 * result.bit7;\n    result.bit6 = when_gt(bits0to6, vec4(63.5));\n    \n    vec4 bits0to5 = bits0to6 - 64.0 * result.bit6;\n    result.bit5 = when_gt(bits0to5, vec4(31.5));\n    \n    vec4 bits0to4 = bits0to5 - 32.0 * result.bit5;\n    result.bit4 = when_gt(bits0to4, vec4(15.5));\n    \n    vec4 bits0to3 = bits0to4 - 16.0 * result.bit4;\n    result.bit3 = when_gt(bits0to3, vec4(7.5));\n    \n    vec4 bits0to2 = bits0to3 - 8.0 * result.bit3;\n    result.bit2 = when_gt(bits0to2, vec4(3.5));\n    \n    vec4 bits0to1 = bits0to2 - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\nstruct Array32Bits {\n    float bit[32];\n};\n\nArray32Bits unpack_32_bits (vec4 byte) {\n    Bitset8Bits bits = unpack_4_bytes(byte);\n    \n    Array32Bits a;\n    a.bit[0] = bits.bit0.r;\n    a.bit[1] = bits.bit1.r;\n    a.bit[2] = bits.bit2.r;\n    a.bit[3] = bits.bit3.r;\n    a.bit[4] = bits.bit4.r;\n    a.bit[5] = bits.bit5.r;\n    a.bit[6] = bits.bit6.r;\n    a.bit[7] = bits.bit7.r;\n    \n    a.bit[8] = bits.bit0.g;\n    a.bit[9] = bits.bit1.g;\n    a.bit[10] = bits.bit2.g;\n    a.bit[11] = bits.bit3.g;\n    a.bit[12] = bits.bit4.g;\n    a.bit[13] = bits.bit5.g;\n    a.bit[14] = bits.bit6.g;\n    a.bit[15] = bits.bit7.g;\n\n    \n    a.bit[16] = bits.bit0.b;\n    a.bit[17] = bits.bit1.b;\n    a.bit[18] = bits.bit2.b;\n    a.bit[19] = bits.bit3.b;\n    a.bit[20] = bits.bit4.b;\n    a.bit[21] = bits.bit5.b;\n    a.bit[22] = bits.bit6.b;\n    a.bit[23] = bits.bit7.b;\n    \n    a.bit[24] = bits.bit0.a;\n    a.bit[25] = bits.bit1.a;\n    a.bit[26] = bits.bit2.a;\n    a.bit[27] = bits.bit3.a;\n    a.bit[28] = bits.bit4.a;\n    a.bit[29] = bits.bit5.a;\n    a.bit[30] = bits.bit6.a;\n    a.bit[31] = bits.bit7.a;\n\n    return a;\n}\n\n/* -----------------------------------------------------------------------\n\n\nFigure 1. Wiring permutations. Signals enter from \"in\" and go to \"out\".\n\n\nEach \"out\" has a D flip-flop in it.\nCircuits, composed of many triangles, are globally clocked.\n\n(In hardware implementation, clock domains can be in each Cartilage subtree).\n\n         /\\\n       in--out\nside A /    \\   side B\n    out      in\n     / \\    / \\\n     ^^^in^^out^\n    \n       side C\n\n\nPermutation | Input | Output\n----------------------------\n            |   A   |   A        /\\\n      1     |   B   |   B       *  *\n            |   C   |   C      /    \\\n----------------------------   ^^**^^\n            |   A   |   A        /\\\n      2     |   B   |   C       * /\\\n            |   C   |   B      / / /\\\n----------------------------   ^^^^^^\n            |   A   |   B        /\\\n      3     |   B   |   A       /^^\\\n            |   C   |   C      /^^^^\\\n----------------------------   ^^**^^\n            |   A   |   B        /\\\n      4     |   B   |   C       /^^\\\n            |   C   |   A      /\\  /\\\n----------------------------   ^^^^^^\n            |   A   |   C        /\\\n      5     |   B   |   A       /\\/\\\n            |   C   |   B      /^/\\^\\\n----------------------------   ^^^^^^\n            |   A   |   C        /\\\n      6     |   B   |   B       /\\ *\n            |   C   |   A      /\\ \\ \\\n----------------------------   ^^^^^^\n\n\n\n\nFigure 2. Switching cause source D flip-flop permutation\n\n      \n     /\\    /\\\n    /  \\  /  \\\n   /__2_\\/__3_\\\n  /\\    /\\    /\\\n / 1\\  /  \\  /4 \\\n/____\\/____\\/____\\\n     /\\    /\\    \n    / 6\\  /5 \\\n   /____\\/____\\\n   \nOnly one D flip-flop can drive element's crossbar switch.\n\nThe crossbar switch switches between two wirings (from fig.1).\n\nAn ordinary crossbar switch switches two channels,\nand it switches just between two wiring schemes:\n\n\n       [A]->----->[C]                     [A]--   -->[C]\n              .                                \\ /\n[CTRL = 0]->...           <=>     [CTRL = 1]->..X\n              .                                / \\\n       [B]->----->[C]                     [B]--   -->[D]\n\n\nOur triangular element switches three channels,\nand it _also_ switches just between two wiring schemes:\n\n   [A in]->  --------  ->[A out]           [A in]->  --------  ->[A out]\n            / wiring \\                              / wiring \\\n   [B in]-> | scheme | ->[B out]    <=>    [B in]-> | scheme | ->[B out]\n            \\ ~ 0 ~  /                              \\ ~ 1 ~  /\n   [C in]->  --------  ->[C out]           [C in]->  --------  ->[C out]\n            \n\nThe difference from ordinary crossbar switch is that\nthere are 6 wiring schemes to choose from to use as \"wiring scheme 0\",\nand the same 6 wiring schemes to use as \"wiring scheme 1\".\n\n\nThe selections are stored in \"wiring0\" and \"wiring1\".\n   \n----------------------------------------------------------------------------*/\n\n\n\nstruct Element {\n\n    // 16 bits of runtime state, fully reconfigurable\n    \n    // --- Three D flip-flops storing the states of the three outputs A, B, and C ---\n    \n    lowp float outA;  // 0..1\n    lowp float outB;  // 0..1\n    lowp float outC;  // 0..1\n\n\n    // --- 9 bits of wiring and control configuration ---\n\n    // Wiring scheme (see fig. 1) when switching cause bit is 0. A number 1..6.\n    float wiring0;\n\n    // Wiring scheme when switching cause bit is 1. A number 1..6.\n    float wiring1;\n    \n    // Switching cause D flip-flop (see fig.2) A number 1..6\n    float switchCtrl;\n\n    \n    // --- 4 bits of Cartilage tree engine ---\n    \n    // Pointer to the owner element - A, B, or C\n    float parent; // 1..3\n    \n    // End-of-subtree markers (relatively to parent)\n    // When neighbor element's parent points to our element,\n    // that neighbor for us becomes a subtree we can reconfigure.\n    lowp float leftIsLeaf;   // 0..1\n    lowp float rightIsLeaf;  // 0..1\n\n    \n    // 16 reconfiguration FIFO bits:\n    \n    // Mode switcher. When reconfiguration starts, the old state is removed\n    // and sent to parent, bit by bit. The new state is pushed in.\n    // When the final configuration bit is captured from the parent's D flip-flop,\n    // It's immediately used to reconfigure the element. This is due to 32 bits total limit.\n    // There possibly can be two modes\n    // lowp float isReconfiguring;\n    \n    // 16 bits deep double buffer / FIFO\n    lowp float fifo0;\n    lowp float fifo1;\n    lowp float fifo2;\n    lowp float fifo3;\n    lowp float fifo4;\n    lowp float fifo5;\n    lowp float fifo6;\n    lowp float fifo7;\n    lowp float fifo8;\n    lowp float fifo9;\n    lowp float fifo10;\n    lowp float fifo11;\n    lowp float fifo12;\n    lowp float fifo13;\n    lowp float fifo14;\n    lowp float fifo15;\n    \n};\n\nElement elementFromTexel (in vec4 texel) {\n\n    Element elt;\n\n    Bitset8Bits bits = unpack_4_bytes(texel * 255.0);\n    \n    elt.outA = bits.bit0.r;\n    elt.outB = bits.bit1.r;\n    elt.outC = bits.bit2.r;\n    \n\n    elt.wiring0 = float(bits.bit3.r + 2.0 * bits.bit4.r + 4.0 * bits.bit5.r);\n    elt.wiring1 = float(bits.bit6.r + 2.0 * bits.bit7.r + 4.0 * bits.bit0.g);\n    elt.switchCtrl = float(bits.bit1.g + 2.0 * bits.bit2.g + 4.0 * bits.bit3.g);\n    elt.parent = float(bits.bit4.g + 2.0 * bits.bit5.g);\n\n    elt.leftIsLeaf = bits.bit6.g;\n    elt.rightIsLeaf = bits.bit7.g;\n\n    \n    elt.fifo0 = bits.bit0.b;\n    elt.fifo1 = bits.bit1.b;\n    elt.fifo2 = bits.bit2.b;\n    elt.fifo3 = bits.bit3.b;\n    elt.fifo4 = bits.bit4.b;\n    elt.fifo5 = bits.bit5.b;\n    elt.fifo6 = bits.bit6.b;\n    elt.fifo7 = bits.bit7.b;\n    \n    elt.fifo8 = bits.bit0.a;\n    elt.fifo9 = bits.bit1.a;\n    elt.fifo10 = bits.bit2.a;\n    elt.fifo11 = bits.bit3.a;\n    elt.fifo12 = bits.bit4.a;\n    elt.fifo13 = bits.bit5.a;\n    elt.fifo14 = bits.bit6.a;\n    elt.fifo15 = bits.bit7.a;\n\n    return elt;\n}\n\n\n//------------------------------------\n//\n//       structured data -> texels\n//\n\nvec4 pack_4_bytes (Bitset8Bits state) {\n\n  vec4 data;\n\n  data = vec4(state.bit0)\n    + 2.0 * vec4(state.bit1)\n    + 4.0 * vec4(state.bit2)\n    + 8.0 * vec4(state.bit3)\n    + 16.0 * vec4(state.bit4)\n    + 32.0 * vec4(state.bit5)\n    + 64.0 * vec4(state.bit6)\n    + 128.0 * vec4(state.bit7);\n\n  return data;\n}\n\nvec4 texelFromElement (in Element elt) {\n\n    Bitset8Bits bits;\n    \n    Bitset3Bits parameters = unpack_4_numbers(vec4(elt.wiring0, elt.wiring1, elt.switchCtrl, elt.parent));\n\n    bits.bit0.r = elt.outA;\n    bits.bit1.r = elt.outB;\n    bits.bit2.r = elt.outC;\n    bits.bit3.r = parameters.bit0.r;\n    bits.bit4.r = parameters.bit1.r;\n    bits.bit5.r = parameters.bit2.r;\n    bits.bit6.r = parameters.bit0.g;\n    bits.bit7.r = parameters.bit1.g;\n    \n\n    bits.bit0.g = parameters.bit2.g;\n    bits.bit1.g = parameters.bit0.b;\n    bits.bit2.g = parameters.bit1.b;\n    bits.bit3.g = parameters.bit2.b;\n    bits.bit4.g = parameters.bit0.a;\n    bits.bit5.g = parameters.bit1.a;\n    bits.bit6.g = elt.leftIsLeaf;\n    bits.bit7.g = elt.rightIsLeaf;\n\n    \n    bits.bit0.b = elt.fifo0;\n    bits.bit1.b = elt.fifo1;\n    bits.bit2.b = elt.fifo2;\n    bits.bit3.b = elt.fifo3;\n    bits.bit4.b = elt.fifo4;\n    bits.bit5.b = elt.fifo5;\n    bits.bit6.b = elt.fifo6;\n    bits.bit7.b = elt.fifo7;\n    \n    bits.bit0.a = elt.fifo8;\n    bits.bit1.a = elt.fifo9;\n    bits.bit2.a = elt.fifo10;\n    bits.bit3.a = elt.fifo11;\n    bits.bit4.a = elt.fifo12;\n    bits.bit5.a = elt.fifo13;\n    bits.bit6.a = elt.fifo14;\n    bits.bit7.a = elt.fifo15;\n\n    return pack_4_bytes(bits) / 255.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 33, 55, 55, 113], [115, 172, 205, 205, 315], [317, 317, 350, 350, 3185], [3187, 3187, 3243, 3243, 3281]], "test": "untested"}
{"id": "WldcWf", "name": "Fourier editor", "author": "Ric3cir121", "description": "So i made a fourier editor and then realized that this just doesn't make sense, how should a fourier compress images?\n(if you set EPS in buf A to 0.5 you should gain an image compressed at 50%, i was expecting more...)\n\nClick on the screen to edit.", "tags": ["fourier"], "likes": 4, "viewed": 321, "published": 3, "date": "1610092469", "time_retrieved": "2024-07-30T19:46:16.000632", "image_code": "#define _a \\\n/|----------------- Fourier Editor -------------------|\\\n/| This editor allow you to play with a 1D Fourier    |\\\n/| Buffer A: Fourier process                          |\\\n/| Image   : Display the result                       |\\\n/|                                                    |\\\n/| Up  : Show the fourier version of the down version |\\\n/| Down: Click with the mouse to draw                 |\\\n/|----------------------------------------------------|\\\n\n\nvoid mainImage(out vec4 o,vec2 u){\n    float t1 = texelFetch(iChannel0,ivec2(u.x,0),0).x;\n    float t2 = texelFetch(iChannel0,ivec2(u.x,2),0).x;\n    \n    float df = texelFetch(iChannel0,ivec2(0),0).x-texelFetch(iChannel0,ivec2(0,2),0).x;\n    \n    float p1 = abs(t1*iResolution.y/2.-u.y);\n    float p2 = abs((t2+df+1.)*iResolution.y/2.-u.y);\n    \n    o = 1.-vec4(clamp(min(p1,p2),0.,1.));\n    if(u.y>iResolution.y/2.)o += t2+df;\n    else                    o += t1;\n    o += abs(u.y-floor(iResolution.y/2.)+.5)<1.?vec4(1.,.5,0,0):vec4(0);\n    float d1 = floor(iResolution.x/100.)*10.;\n    o += min(fract(u.x/d1),fract(u.y/d1))<1./d1?.25:0.;\n    float d2 = floor(iResolution.x/100.);\n    o += max(fract(u.x/d2),fract(u.y/d2))<1./d2?.25:0.;\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define _b \\\n/|------------------------------------- Buffer A --------------------------------------|\\\n/| Part 1: The image that you can edit by clicking with the mouse on screen            |\\\n/| Part 2: Fourier data get stored                                                     |\\\n/| Part 3: The upper image on the screen that is the compressed image using fouriers   |\\\n/|                                                                                     |\\\n/| Precision: Set EPS to: 2 = original image, 1 = no compression, 0.5 = 50% compressed |\\\n/|-------------------------------------------------------------------------------------|\\\n\n#define EPS .2\n#define PI acos(-1.)\n\nfloat csin(float p){return sin(p)/2.+.5;}\n\nvoid mainImage(out vec4 o,vec2 u){\n    if(int(u.y)==0){\n        // Part 1\n        o = texelFetch(iChannel0,ivec2(u),0);\n\n        if(floor(iMouse.xy) == vec2(0)){\n            float Wave = (u.x/iResolution.x+0.25)*PI*2.;\n            o = vec4(csin(Wave+iTime)+csin((Wave+iTime)*2.)+fract(sin(floor(u.x/10.)*10.)*100.)/10.,0,0,0)/3.;\n        }\n\n        if(iMouse.z>0.&&length(iMouse.x-u.x)<10.&&iMouse.y<iResolution.y/2.)\n        o = vec4(iMouse.y/iResolution.y*2.,0,0,0);\n    }\n    \n    if(int(u.y)==1){\n        // Part 2\n        float Speed = floor(u.x/1.)*2.;\n        vec2 Result = vec2(0);\n        int Precision = int(iResolution.x*2.);\n        for(int i=0 ; i<Precision ; i++){\n            float Pos = float(i)/float(Precision);\n            float Height = texelFetch(iChannel0,ivec2(Pos*iResolution.x,0),0).x;\n            float Rotation = Pos * Speed * PI;\n            Result += vec2(sin(Rotation),cos(Rotation))*Height/float(Precision);\n        }\n        o = vec4(length(Result),atan(Result.x,Result.y)/PI/2.+.5,0,0);\n    }\n    \n    if(int(u.y)==2){\n        // Part 3\n        float r = 0.;\n        int mxi = int(iResolution.x*(EPS)/2.);\n        for(int i = 1;i<mxi;i++){\n            vec2 par = texelFetch(iChannel0,ivec2(i,1),0).xy;\n            float s = float(i);\n            float h = par.x;\n            float o = par.y+.25;\n            r += (sin((u.x/iResolution.x*s-o)*PI*2.)+1.)*h*2.;\n        }\n        o = vec4(r,0,0,0)/1.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 471, 505, 505, 1211]], "test": "untested"}
{"id": "ttdyWf", "name": "Ray marched sphere", "author": "intrakits", "description": "This is my first attempt at ray marching. :)", "tags": ["3d", "raymarching", "lighting", "sphere", "diffuse"], "likes": 1, "viewed": 249, "published": 3, "date": "1610088083", "time_retrieved": "2024-07-30T19:46:16.774563", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nfloat GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n    float ds = length(p-sphere.xyz)-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    float dp = p.y;\n    \n    //choose the closest of the two\n    float d = min(ds,dp);\n   \n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,5,6);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);\n    if(d < length(lightPos-p)){\n        diff *= 0.1;\n    }\n    return diff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    vec3 ro = vec3(0,1,0);\n    \n    //ray dir\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    //------------------\n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd *d;\n    float diff = GetLight(p);\n    col = vec3(diff);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 92, 116, 656], [657, 657, 690, 718, 1120], [1121, 1121, 1144, 1183, 1546], [1547, 1547, 1570, 1605, 2537], [2538, 2538, 2595, 2677, 3076]], "test": "untested"}
{"id": "wltcDX", "name": "Animated Robot", "author": "intrakits", "description": "This is an animated robot.", "tags": ["2d", "beginner", "animated", "robot"], "likes": 5, "viewed": 318, "published": 3, "date": "1610081527", "time_retrieved": "2024-07-30T19:46:17.630275", "image_code": "mat2 rotate(float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\nfloat circle (vec2 uv, float r, float blur){\n    float d = length(uv);\n    return smoothstep(r,r-blur,d);\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    //ray direction\n\tvec3 rd = vec3(uv.x,uv.y, 0)-ro;\n    \n    // Time varying pixel color\n    float width = 0.3;\n    float height = 0.3;\n    float blur = 0.01;\n    float posX = 0.;\n    float posY = -0.;\n    \n    float head = DrawSquare(uv, width, height, posX, posY, blur);\n    head += DrawSquare(uv, width * 0.5, height * 0.15, posX, posY + 0.335, blur);\n    head += DrawSquare(uv, width * 2., height, posX, posY + 0.67, blur);\n    vec3 img = vec3(.8) * head;\n    //outer eyes\n    float Reye = DrawSquare(uv, width * 0.2, height * (sin(iTime)*0.05 +0.15), posX + 0.15, posY-0.1, blur);\n    \n    img -= vec3(1.,1.,1.) * Reye;\n    \n    float Leye = DrawSquare(uv, width * 0.2, height * 0.2, posX - 0.15, posY-0.1, blur);\n    \n    img -= vec3(1.,1.,1.) * Leye;\n    \n    //inner eyes\n    float RIeye = DrawSquare(uv, width * 0.1, height * 0.1, posX + 0.15, posY-0.1, blur);\n    \n    img += vec3(smoothstep(1.,0.9,sin(iTime)),0.,0.) * RIeye;\n    \n    float LIeye = DrawSquare(uv, width * 0.1, height * 0.1, posX - 0.15, posY-0.1, blur);\n    \n    img += vec3(1.,smoothstep(smoothstep(1.,0.9,cos(iTime*5.)),0.9,sin(iTime*5.)),smoothstep(1.,0.9,sin(iTime*5.))) * LIeye;\n    \n    //mouth\n    float mouth = DrawSquare(uv, width * 0.5, height * 0.2, posX, posY+0.15, blur);\n    img -= vec3(1.,1.,1.) * mouth;\n    \n    //mouth inner\n    float mouthI = DrawSquare(uv, width * 0.48, height * (sin(iTime*3.)*0.04+0.14), posX, posY+0.15, blur);\n    img += vec3(0.,1.,1.) * mouthI;\n    \n    //mouth slats\n    float mouthS = DrawSquare(uv, width * 0.05, height * 0.18, posX, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX-.05, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX-.1, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX+.05, posY+0.15, blur);\n    mouthS += DrawSquare(uv, width * 0.05, height * 0.18, posX+.1, posY+0.15, blur);\n    img -= vec3(0.,1.,1.) * mouthS;\n    \n    //nose\n    vec2 rotUV = uv * rotate(iTime);\n    float nose = circle (rotUV, 0.03, blur);\n    nose += DrawSquare(rotUV, width * 0.03, height * 0.09, posX, posY, blur);\n    nose += DrawSquare(rotUV, width * 0.09, height * 0.03, posX, posY, blur);\n    img -= vec3(.5,.5,.5) * nose;\n    \n    //screws\n    float screws = circle (uv - vec2(0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX - 0.25, posY - 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX - 0.25, posY - 0.25, blur);\n    \n    screws += circle (uv - vec2(-0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX + 0.25, posY + 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX + 0.25, posY + 0.25, blur);\n    \n    screws += circle (uv - vec2(-0.25, 0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX + 0.25, posY - 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX + 0.25, posY - 0.25, blur);\n    \n    screws += circle (uv - vec2(0.25, -0.25), 0.03, blur);\n    screws += DrawSquare(uv, width * 0.03, height * 0.09, posX - 0.25, posY + 0.25, blur);\n    screws += DrawSquare(uv, width * 0.09, height * 0.03, posX - 0.25, posY + 0.25, blur);\n    img -= vec3(.5,.5,.5) * screws;\n    // Output to screen\n    fragColor = vec4(img,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 98], [99, 99, 143, 143, 206], [207, 207, 297, 297, 482], [483, 483, 540, 590, 4072]], "test": "untested"}
{"id": "3l3cDX", "name": "Fluffy fractal", "author": "michael0884", "description": "playing with volumetric rendering", "tags": ["nebula"], "likes": 35, "viewed": 691, "published": 3, "date": "1610071351", "time_retrieved": "2024-07-30T19:46:18.412184", "image_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    c = 1.13*tanh(texture(iChannel0, p/iResolution.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 16\n    #define MIN_STEP 0.15\n    #define DITHER 0.5\n    #define TRACE_STEPS 4\n#else\n    #define MAX_STEPS 32\n    #define MIN_STEP 0.09\n    #define DITHER 0.4\n    #define TRACE_STEPS 16\n#endif\n\n#define MAX_DIST 3.0\n\n#define FOV 1.0\n#define LIGHT_PATH_NUM 6\n#define MAX_PATH_LENGTH 4\n#define LIGHT_DIR -normalize(vec3(1.,1.,1.))\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nmat3 get_cam(float phi, float theta)\n{\n    vec3 x_dir = vec3(cos(phi)*sin(theta), sin(phi)*sin(theta), cos(theta));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,0,1)));\n    vec3 z_dir = normalize(cross(x_dir, y_dir));\n    return mat3(x_dir, y_dir, z_dir);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\n#define sharpness 0.07\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n", "buffer_a_code": "vec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\nvec4 mandelbulb_fog(vec3 p) {\n    vec3 w = p;\n    float m = dot(w, w);\n    vec3 orbitTrap = vec3(1.);\n\tfloat dz = 1.0;\n    for(int i = 0; i < 5; i++){\n        if(m > 1.2) break;\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n        m = dot(w, w);\n        orbitTrap = min(abs(w)*1.2, orbitTrap);\n    }\n    float sdf = 0.25*log(m)*sqrt(m)/dz;\n    vec3 col = (1.-orbitTrap);\n    if(m > 1.2) return vec4(0.);\n    return vec4(16.*col, sdf);\n}\n\nvec4 box_fog(vec3 p, vec3 b, float k)\n{\n    vec3 refl = normalize(vec3(0.4,0.6,0.9));\n    float sc = 1.0;\n    for(int i = 0; i < 6; i++)\n    {\n        refl.xy = rot(iTime*0.1)*refl.xy;\n        refl.yz = rot(iTime*0.2-2.1)*refl.yz;\n       // p *= 1.1; sc *= 1.1;\n      //  p += 0.05*vec3(1.,3.,1.0);\n        p -= 2.*max(dot(refl, p), 0.)*refl;\n        p += 0.015*sin(10.*dot(refl,p) + sin(p.x*p.y));\n    }\n    float sdf = sdBox(p,b)/sc;\n    return vec4(12.*(vec3(.3, .6, .9) + (0.5 + 0.5*sin(40.*vec3(0.392,0.580,1.000)*p.x)))*smoothstep(k,-k,sdf), sdf);\n}\n\nvec4 density(vec3 p){\n    vec4 box = box_fog(p, vec3(0.7,0.3,0.2), sharpness); \n   // vec4 bulb = mandelbulb_fog(p);\n    return vec4(box.xyz + vec3(.3, .6, .9)*0.1, min(box.w, MAX_DIST + 0.6 - length(p)));\n}\n\nvec3 trace(vec3 ro, vec3 rd, float target_opacity, float dither)\n{\n    //cumulative opacity and scattering\n    vec3 k = vec3(1.0);\n    \n    float step_size;\n    \n    for(int i = 0; i < TRACE_STEPS; i++)\n    {\n        vec4 rho = density(ro);\n        step_size = (1.0 - DITHER*dither)*max(rho.w, MIN_STEP);\n        vec3 absorption = exp(-step_size*rho.xyz);\n        \n        //accumulate\n        k *= absorption; \n       \n        if(length(k) < target_opacity || distance(ro, vec3(0)) > 2.0) break;\n        //step ray\n        ro += rd*step_size;\n    }\n    return k;\n}\n\n//vec3 path_trace()\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    \n    vec4 prev = texture(iChannel0, p/iResolution.xy);\n    \n    vec2 uv = (p - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 angles = iMouse.xy*vec2(-TWO_PI, PI)/iResolution.xy-1e-4;\n    mat3 cam = get_cam(angles.x, angles.y);\n    \n    vec3 ro = cam*vec3(-1.7, 0.0, 0.0);\n    vec3 rd = normalize(cam*vec3(1.0, FOV*uv));\n    \n    vec4 brand = rand4blue();\n    \n    float dither = brand.x;\n    \n    //cumulative opacity\n    vec3 k = vec3(1.0);\n    \n    //accumulated incoming light to the camera\n    vec3 col = vec3(0.); \n    int L = 0;\n    \n    //main camera ray\n    float step_size;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 rho = density(ro);\n        step_size = (1.0 - DITHER*dither)*max(rho.w, MIN_STEP);\n        \n        vec3 absorption = exp(-step_size*rho.xyz);\n       \n        if(rho.z > 0.0)\n        {\n            vec3 incoming = trace(ro, LIGHT_DIR, 0.05, brand.z);\n            float amount = 35.0*HenyeyGreenstein(0.15, dot(LIGHT_DIR, rd));\n            //add incoming light\n            col += k.xyz*(1. - absorption.xyz)*amount*incoming;   \n        }\n        \n        //accumulate\n        k *= absorption;\n        \n        ro += step_size*rd;\n         \n        if(length(k) < 0.05 || distance(ro, vec3(0)) > MAX_DIST) break;\n    }\n    \n    \n    c = vec4(mix(prev.xyz, col, 0.65), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 100]], "test": "untested"}
{"id": "WtdcWf", "name": "Chwormhole", "author": "Shapkofil", "description": "Tried to make a wormhole.\nI came up with this the chromatic aberration make it great to look at.", "tags": ["torusraymarchingchromaticaboration"], "likes": 5, "viewed": 322, "published": 3, "date": "1610060071", "time_retrieved": "2024-07-30T19:46:19.188110", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = abs(sin(iTime));\n    float off = .6*(1.0 - t) + 0.08*t*hash11(iTime) + .1;\n    float r = texture(iChannel0, .03 * off + uv).x;\n    float g = texture(iChannel0, .04 * off + uv).x;\n    float b = texture(iChannel0, .05 * off + uv).x;\n    \n    \n    vec3 col = vec3(r,g,b);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float sdTorus ( in vec3 pos, in vec2 t , out vec2 uv)\n{\n    vec2 q = vec2(length(pos.xz) - t.x, pos.y);\n    uv = vec2(atan(pos.x,pos.z), atan(q.x,q.y));\n    return length(q) - t.y;\n}\n\nfloat map ( in vec3 pos, out vec2 uv )\n{\n   float d = sdTorus(pos, vec2(1.0, .8), uv);\n   \n   return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    float an = 1.0*iTime;\n    \n    vec3 ta = .5*vec3(sin(an), 0, -cos(an));\n    vec3 ro = vec3(0, sin(an), 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    vec3 rd = normalize(p.x*uu + p.y*vv + .4*ww);\n    \n    float t = 0.0;\n    for(int i=0; i<200; i++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        vec2 _;\n        float h = map( pos , _);\n        \n        if (h<.0005)\n            break;\n            \n        t += h;\n    }\n    \n    if( t < 20.0 )\n    {\n        vec3 pos = ro + t*rd;\n        float t = .5*iTime;\n        vec2 tuv;\n        map( pos, tuv );\n        vec2 ttuv = (tuv/3.1415)/2.0 + 0.5;\n    \n        vec2 tpa = vec2(8.0, 24.0);\n        float pa = sin(tpa.x*tuv.y + tpa.y*tuv.x); \n         \n        \n        float pa_id = hash11(floor(mod(tpa.x*ttuv.y+tpa.y*ttuv.x,tpa.x))/(tpa.x-1.0));\n        float grad = 2.0*mod(tpa.x*ttuv.x+tpa.y*ttuv.y,tpa.x)/tpa.x - 1.0;\n        float cars = smoothstep(-.002,.002,sin(grad + sign(hash11(pa_id)-.5)*6.0*t*pa_id) - \n                                hash11(pa_id));\n        float distb = smoothstep(-0.05,0.05,sin(tpa.x*tuv.x + tpa.y*tuv.y + sign(hash11(pa_id)-.5)*20.0*t) +\n                                 .9 + .1*sin(40.0*ttuv.y));\n        \n        col = vec3(distb);\n        col = cars * distb * vec3(smoothstep(-0.05,0.05,pa));\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "float hash11(float n){return fract(sin(n) * 43758.5453123);}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 420]], "test": "untested"}
{"id": "WttyWX", "name": "Uniformity tester", "author": "michael0884", "description": "testing spherical uniformity", "tags": ["rng"], "likes": 2, "viewed": 513, "published": 3, "date": "1610034146", "time_retrieved": "2024-07-30T19:46:20.015897", "image_code": "// Fork of \"RNG utilities\" by michael0884. https://shadertoy.com/view/wltcRS\n// 2021-01-07 15:40:39\n\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec4 a =texture(iChannel0, p.xy/iResolution.xy);\n    c = vec4(400.*a.x/a.y);\n    c=sin(c*30.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\n//normal distribution RNG\n\n//inverse error function\nfloat ErfInv(float x){\n   float lnx = log((1.0 - x)*(1.0 + x));\n   float tt1 = 4.3308 + 0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1 + sqrt(tt1*tt1 - tt2)));\n}\n\nfloat nrand()\n{\n    return ErfInv(rand()*2.0 - 1.0);\n}\n\n//box muller\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxyy)) * \n           vec4(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w),sin(TWO_PI * Z.w));\n}\n\n\n//uniformly spherically distributed\nvec3 udir()\n{\n    vec2 rng = rand2();\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nvec3 udir1()\n{\n    vec2 rng = rand2();\n    float phi = 2.*PI*rng.x;\n    float cos_theta = 2.*rng.y-1.;\n    float sin_theta = sqrt(1.0-cos_theta*cos_theta);\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return vec3(cos_phi*sin_theta, sin_phi*sin_theta, cos_theta);\n}\n\n\n", "buffer_a_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n    \n    vec4 prev = texture(iChannel0, p.xy/iResolution.xy);\n    float phi = PI*2.0*p.x/iResolution.x;\n    float theta = PI*p.y/iResolution.y;\n    \n    float jacobian = sin(theta);\n    \n    float sum = 0.;\n    float n = 3.*p.x/iResolution.x;\n    for(int i = 0; i < 128; i++)\n    {\n        vec3 dir = normalize(rand3() - 0.5); //really BAD\n        //vec3 dir = normalize(tan(0.5*PI*(rand3() - 0.5))); //BAD\n        //vec3 dir = normalize(tan(2.*rand3() - 1.0)); //Better\n        //  vec3 dir = normalize(nrand3(1., vec3(0.))); //Perfect\n       // vec3 dir = udir(); //Perfect\n       //vec3 dir = udir1();\n        float phi0 = atan(dir.y, dir.x) + PI;\n        float theta0 = acos(dir.z);\n        \n        sum += step(distance(vec2(phi0, theta0), vec2(phi, theta)), 0.1);\n    }\n    \n    // Output to screen\n    c = prev + vec4(sum/jacobian,256.,0,0);\n    \n    if(iFrame < 1) c = vec4(0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 143, 143, 244]], "test": "untested"}
{"id": "ttccDX", "name": "Acid Cubes", "author": "yozic", "description": "Comment out line 13 I can't decide which version I like better. : )", "tags": ["glow", "rainbow", "trippy"], "likes": 13, "viewed": 768, "published": 3, "date": "1610007345", "time_retrieved": "2024-07-30T19:46:21.147870", "image_code": "#define PI 3.141592\n#define BALLS 20.\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  uv.x -= .5;\n  uv.y -= .5;\n  uv.x *= iResolution.x / iResolution.y;\n  fragColor = vec4(0.);\n  uv *= 100.;\n  float dist = length((uv));\n  uv *= rotate2d(iTime / 7.);\n  for (float i = 0.; i < BALLS; i++) {\n    uv.y += .5 * (i / 20.) * cos(uv.y / 1000. + iTime / 4.) + sin(uv.x / 50. - iTime / 2.);\n    uv.x += .5 * (i) * sin(uv.x / 300. + iTime / 6.) * sin(uv.y / 50. + iTime / 5.);\n    float t = .01 * dist * (i) * PI / BALLS * (5. + 1.);\n    vec2 p = 8. * vec2(-1. * cos(t), 1. * sin(t / 6.));\n    p /= sin(PI * sin(uv.x / 10.) * cos(uv.y / 11.));\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + PI * (iTime / 5. + float(i) / 5.)) * 0.5 + 0.5;\n    fragColor += vec4(float(i) * .2 / length(uv - p * 0.9) * col, 1.);\n  }\n  fragColor.xyz = pow(fragColor.xyz, vec3(2.));\n  fragColor.w = 1.0;\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 63, 63, 113], [115, 115, 170, 170, 1004]], "test": "untested"}
{"id": "wl3yWX", "name": "sad cat", "author": "blackle", "description": ":(", "tags": ["sad", "nn", "neuralnetwork", "siren", "sirennetwork"], "likes": 64, "viewed": 2025, "published": 3, "date": "1610005143", "time_retrieved": "2024-07-30T19:46:22.005577", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\n//based on the work of https://vsitzmann.github.io/siren/\n//https://colab.research.google.com/drive/11ANM7k_r0i1Ut9amzKN1_GQqwzp0pB-_?usp=sharing\n//https://imgur.com/a/wBxR7An\n//#define SHOW_SCARY_OUT_OF_BOUNDS\n#define ORIGINAL_MODEL\n\n#define FK(x) floatBitsToInt(x*x/7.)^floatBitsToInt(x)\nfloat hash(float a, float b) {\n    int x = FK(a),y=FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y*4.;\n\n#ifdef ORIGINAL_MODEL\n    //luma network (loss=0.000842)\n    vec4 f0_0=sin(uv.x*vec4(-8.614,7.208,.530,4.062)+uv.y*vec4(-.527,3.736,6.084,-1.043)+vec4(8.909,-7.509,8.703,2.268));\n    vec4 f0_1=sin(uv.x*vec4(-4.616,-.068,-3.765,1.196)+uv.y*vec4(-3.194,-2.133,-1.334,-4.158)+vec4(-5.839,-6.334,-5.840,-5.221));\n    vec4 f0_2=sin(uv.x*vec4(2.855,-7.304,-7.448,-2.125)+uv.y*vec4(-7.691,-7.293,2.920,-1.413)+vec4(11.474,1.656,-9.985,5.009));\n    vec4 f0_3=sin(uv.x*vec4(.460,-4.991,-3.450,-4.852)+uv.y*vec4(7.614,-5.130,4.119,5.054)+vec4(-11.383,-.581,-2.218,-1.162));\n    vec4 f1_0=sin(mat4(.359,-.049,.321,-.768,.187,-.155,.322,.092,.536,-.571,-.412,-.169,.400,.515,-.024,-.363)*f0_0+\n        mat4(-.081,.464,-.056,-.708,.283,.186,.954,-.166,.355,1.025,-1.637,.924,-.382,.135,.803,-.644)*f0_1+\n        mat4(.180,-.277,.273,-.549,-.241,.961,-.224,.454,.082,.390,-.054,-.158,-.156,-.702,-.460,-.171)*f0_2+\n        mat4(.440,-.500,-.126,-1.106,.410,.480,-.235,-.741,-.003,-.107,.591,-1.422,.345,.015,.014,-.355)*f0_3+\n        vec4(1.711,2.205,3.089,.763));\n    vec4 f1_1=sin(mat4(.121,1.157,.222,-.106,.585,.374,-.173,.493,.754,-.188,.161,-.982,-.246,.407,.604,-.764)*f0_0+\n        mat4(-1.071,.291,.196,.078,-.035,-.411,-1.320,-.456,-.469,.115,.074,.975,-.301,.204,1.037,.057)*f0_1+\n        mat4(.187,.756,-.552,.840,-.591,-.633,-.172,-.106,.804,.211,.276,.221,-.099,.566,.180,-.099)*f0_2+\n        mat4(1.155,.584,.222,-.334,-.072,-.261,-.617,-.564,-.303,.652,.347,.961,.365,-.378,-1.006,-.107)*f0_3+\n        vec4(1.368,-3.543,2.740,-2.473));\n    vec4 f1_2=sin(mat4(.307,.214,-.120,.157,.954,.399,-.364,-.696,-.428,-.228,.263,.423,-1.672,-.308,-.526,-.887)*f0_0+\n        mat4(-1.113,-.079,.430,.444,.965,.221,-.641,.745,.788,-.760,-.439,.003,.110,-.302,-.238,-.418)*f0_1+\n        mat4(-.814,-.139,-.167,-.187,-.542,-.271,-.351,.374,-.945,-.212,-.027,-.902,-.006,1.708,.847,.576)*f0_2+\n        mat4(.093,.068,.177,-.014,.534,1.566,-.404,-.069,-.220,-.031,.432,.633,.325,-.565,-.504,-.320)*f0_3+\n        vec4(2.057,-1.432,.298,-3.622));\n    vec4 f1_3=sin(mat4(.238,-.019,-.156,-.402,.334,.247,.226,-.423,-.044,.313,.137,-.137,-.301,-.559,1.011,.786)*f0_0+\n        mat4(-.160,-.984,-.065,-.581,-.840,.260,-1.870,1.299,.675,-.062,-.951,-.128,.459,.127,-1.086,.013)*f0_1+\n        mat4(.505,-.151,.424,-.247,-.626,-.661,.448,-.221,.232,-.196,.736,-.358,-.571,-.743,.954,-.441)*f0_2+\n        mat4(.130,.199,-.582,.684,.582,.477,.290,.104,.236,-.597,-.860,-.691,.443,-.904,-1.042,.628)*f0_3+\n        vec4(-4.292,.841,.473,3.438));\n    vec4 f2_0=sin(mat4(1.963,-1.016,-.276,1.744,-.631,-.196,-1.641,.450,-1.968,1.349,-.188,2.402,.277,-.058,.083,-1.007)*f1_0+\n        mat4(-1.437,.265,-.961,.287,-1.032,.675,-.202,-.948,.906,.299,.415,.102,1.482,.071,.273,-1.080)*f1_1+\n        mat4(-.576,.039,.711,-.167,1.014,.734,.300,.076,.039,.505,1.351,-.008,1.011,-1.689,-.716,-.310)*f1_2+\n        mat4(-.627,-1.066,-.889,-.914,-.157,.203,.452,-.966,-1.412,-.034,-1.081,.086,-.774,.078,-.782,.912)*f1_3+\n        vec4(1.957,4.555,-1.998,-2.330));\n    vec4 f2_1=sin(mat4(-2.035,-2.156,-2.089,-.984,-.371,-.753,-1.429,-1.849,-1.591,1.144,.028,-.535,1.212,-1.157,1.007,-.074)*f1_0+\n        mat4(-.554,.302,.146,2.206,.690,-.194,-.630,-.274,.076,-.460,-.326,-.280,.259,-1.318,.123,-.465)*f1_1+\n        mat4(-.322,.045,.181,1.593,.639,.338,.718,.112,1.075,1.934,.630,1.484,-.287,.348,.542,.570)*f1_2+\n        mat4(-.058,-.145,-1.287,-1.192,.748,-1.876,-.215,-1.515,1.003,.404,1.531,1.225,.377,-.184,1.793,1.292)*f1_3+\n        vec4(2.494,2.302,3.448,1.529));\n    vec4 f2_2=sin(mat4(-.733,1.195,.342,.404,.075,1.089,.746,-.170,.627,1.065,-.549,1.473,-.048,.104,.687,.907)*f1_0+\n        mat4(.607,-1.469,-1.929,-1.441,-.015,-.158,-.078,-.786,-.071,.541,-.277,.088,.557,.801,.144,1.516)*f1_1+\n        mat4(.330,-.027,-.718,.591,-.641,.331,.951,.354,-1.138,-1.396,-.425,-.569,-.760,-2.203,-1.545,-.453)*f1_2+\n        mat4(.625,.719,1.265,-.625,.111,.589,.671,-.425,.186,-.457,-.452,.749,-.062,-1.204,-1.892,1.554)*f1_3+\n        vec4(-4.028,1.917,1.718,.105));\n    vec4 f2_3=sin(mat4(1.162,1.018,1.664,-1.055,.054,-1.140,.984,-.759,-1.615,.446,-.487,.468,.486,.114,-.401,.096)*f1_0+\n        mat4(-.629,-.497,-.461,.689,1.512,-.351,.244,-.677,-1.942,.251,.607,-.323,-.006,-.886,.210,-.122)*f1_1+\n        mat4(-.330,1.149,-.089,.906,1.423,-.070,-.408,-.290,-.242,1.021,-.602,1.080,.714,.178,-.115,-.214)*f1_2+\n        mat4(-1.321,.271,1.508,.132,.949,.838,.808,.215,-.565,-.688,-1.322,.343,-1.777,-1.866,-1.712,-.411)*f1_3+\n        vec4(3.040,2.085,.089,3.630));\n    float f=dot(f2_0,vec4(-.040,.079,.059,-.082))+dot(f2_1,vec4(.080,-.048,.104,-.039))+\n        dot(f2_2,vec4(-.122,-.052,.053,-.078))+dot(f2_3,vec4(-.071,-.082,-.104,.091))+0.5;\n#else\n    //luma network (loss=0.000943)\n    vec4 f0_0=sin(uv.x*vec4(-7.1,6,-1.36,-7.6)+uv.y*vec4(-3.18,-5.22,1.33,-3.47)+vec4(6.74,-4.23,-8.81,2.61));\n    vec4 f0_1=sin(uv.x*vec4(5.63,1.67,5.86,4.65)+uv.y*vec4(-2.96,-5.43,-1.92,10.4)+vec4(-12.3,-2.47,1.11,-14));\n    vec4 f0_2=sin(uv.x*vec4(.129,2.31,.894,8.91)+uv.y*vec4(3.74,-6.88,3.85,-5.84)+vec4(-4.33,-12.7,11.3,2.33));\n    vec4 f1_0=sin(mat4(.0997,-.312,.558,-.831,.245,-.409,.639,-.134,.0653,.0132,.353,-.955,-.286,.0856,.163,-.702)*f0_0+\n        mat4(-.199,.177,-.103,-.293,-.883,-.626,.387,.728,-.0224,-.359,.0425,.215,-.106,-.0102,.424,-.169)*f0_1+\n        mat4(-1.37,.0266,-.0634,1.13,-.0256,.377,.778,1.27,.111,-.318,.414,-.557,-.115,-.101,-.135,.296)*f0_2+\n        vec4(.149,2.47,5.16,3.71));\n    vec4 f1_1=sin(mat4(.392,-.309,.0919,.494,.0691,.352,-.693,-.319,.78,.623,.0747,-.329,-.297,-.204,.363,-.0295)*f0_0+\n        mat4(.593,.195,-.531,-.2,.512,.426,-.469,.256,-.0817,.425,-.138,-.8,-.0347,.13,-.0864,-.0782)*f0_1+\n        mat4(-1.09,-1.13,1.63,-.707,-.418,-.218,-.232,.0419,-.188,-1.25,1.16,-.448,-.403,-.343,-.0312,.0666)*f0_2+\n        vec4(.95,.498,-3.81,-2.44));\n    vec4 f1_2=sin(mat4(.038,.446,.666,-.447,-.0782,.182,-.0322,.223,.888,.442,-.892,-.316,.334,.0965,.582,.0675)*f0_0+\n        mat4(-.477,-.00514,.403,.0886,-.79,.123,-.179,-.0407,.595,-.392,.198,1.23,-.209,.303,-.0768,.268)*f0_1+\n        mat4(-.607,-.294,-.0366,.387,-.38,.303,-.286,.778,.551,.0933,-.838,-.381,.171,.156,-.0681,-.057)*f0_2+\n        vec4(.73,.0788,2.5,1.34));\n    vec4 f2_0=sin(mat4(-1.23,-.0429,.941,1.09,-.0856,.921,-1.09,.0769,-.591,-.261,.984,.491,-.805,-.61,.639,-.00129)*f1_0+\n        mat4(-.897,-.0682,.386,1.49,.245,-.317,1.6,.336,.324,-1.07,-.00863,-.0078,.416,1.25,-1.17,-1.24)*f1_1+\n        mat4(-.757,.624,.157,-.458,1.3,1.44,-2.86,-.922,-.0406,-.0488,-.417,-.378,.954,-.329,-.0298,-.873)*f1_2+\n        vec4(5.97,1.36,.843,-3.18));\n    vec4 f2_1=sin(mat4(1.31,.836,.749,-.508,1.07,.448,.221,1.09,-.802,-.228,-.242,-.321,.666,.419,.461,-.62)*f1_0+\n        mat4(-1.92,.729,.348,-.721,.905,-.679,-.571,.455,-.95,-.0751,.727,-1.54,.602,-.02,-.0546,.144)*f1_1+\n        mat4(-1.13,-.269,-.109,.253,.142,-.834,-.623,-.443,.112,-.813,-.202,.673,.526,-.0562,.54,.113)*f1_2+\n        vec4(-6.07,-4.2,-1.8,6.06));\n    vec4 f2_2=sin(mat4(.101,-.414,.396,-.571,1.19,-.678,-.252,-1.9,-.606,.066,.441,.783,-.549,.2,.0423,.371)*f1_0+\n        mat4(.11,.736,-.808,1.11,-.399,-1.44,1.19,-1.3,-.37,.42,-.284,1.83,.00592,.358,-1.78,-.324)*f1_1+\n        mat4(.191,1.35,-.00607,1.05,-.287,-.304,-.795,-.82,-.75,.537,.0204,1.21,-.278,.909,-.64,.968)*f1_2+\n        vec4(-2.37,-4.77,-3.72,-4.99));\n    vec4 f3_0=sin(mat4(-.153,-1.13,2.07,-2.25,.241,-1.32,.247,-.0603,-1.07,.334,.058,-.31,-.674,-.222,.532,1.05)*f2_0+\n        mat4(-1.75,1.21,-.867,-1.15,3.18,-.837,-1.65,.0659,1.02,-2.22,.25,-.267,1.78,-.477,-2.52,-1.05)*f2_1+\n        mat4(3.33,-.874,-.589,1.53,-.401,-.332,-1.24,-2.17,-.899,1.24,-1.25,-1.41,.843,1.07,-1.44,2.38)*f2_2+\n        vec4(2.84,-1.4,-1.49,-3.78));\n    vec4 f3_1=sin(mat4(-.404,1.86,-1.43,-.442,-.34,-1.15,-.191,-1.11,-.0847,.0405,-.688,.145,.501,-1.91,-.474,.00439)*f2_0+\n        mat4(-.408,.366,-.484,-.816,-.831,.889,-.32,-.236,-.265,2.18,-.966,-2.49,-.102,.691,.514,-1.39)*f2_1+\n        mat4(-.202,.165,1.33,-.293,-.607,-.0652,-4.07,-.525,-.0052,.565,-1.52,.475,.738,-.241,2.79,.841)*f2_2+\n        vec4(4.5,.845,4.76,-4.46));\n    vec4 f3_2=sin(mat4(.66,1.56,-.768,-1.92,-.0624,2.52,-3.05,-2.23,-.201,-1.36,-.193,.998,.0159,-1.74,-.361,1.66)*f2_0+\n        mat4(.333,1.08,.287,-.966,-1.33,2.21,-3.26,-.405,-.832,2.19,-3.27,-3.62,-.0391,1.01,-.482,-1.14)*f2_1+\n        mat4(-1.11,.615,-.663,-1.07,1.21,-.339,.0571,.951,-.424,-2.78,.534,3.12,-1.34,-.454,1.39,.224)*f2_2+\n        vec4(1.96,-3.1,-4.32,-7.12));\n    float f=dot(f3_0,vec4(.0645,-.12,.0463,-.0516))+dot(f3_1,vec4(.244,-.0667,.0425,.102))+\n        dot(f3_2,vec4(.161,-.0551,.063,-.056))+0.541;\n#endif\n\n    //color network (loss=0.003087)\n    float c=dot(sin(mat4(-2.31,1.67,1.69,-.993,-1.87,.222,1.94,-.436,-1.61,2.64,1.14,-2.15,.811,.0207,-.584,-.293)*\n        sin(uv.x*vec4(-3.8,.193,2.88,-4.26)+uv.y*vec4(1.42,-3.05,-1.43,-2.54)+vec4(4.58,-.829,-4.29,1.02))+\n        vec4(1.54,-3.54,-1.36,-2.94)),vec4(-.495,.448,-.559,.433))+0.25;\n\n    fragColor = vec4(f) + mix(vec4(.47,.51,.53,1.),vec4(.65,.46,.37,1.),c)-.5;\n#ifndef SHOW_SCARY_OUT_OF_BOUNDS\n    if (max(abs(uv.x),abs(uv.y)) > 1.) {\n        fragColor = vec4(.05);\n    }\n#endif\n    fragColor += hash(uv.x,uv.y)*.05-.025;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yWX.jpg", "access": "api", "license": "cc0-1.0", "functions": [[485, 485, 515, 515, 588], [590, 590, 647, 647, 9918]], "test": "untested"}
{"id": "WtccDf", "name": "math bubbles", "author": "jcyuan", "description": "interesting stuff from math.", "tags": ["math", "bubbles"], "likes": 8, "viewed": 431, "published": 3, "date": "1609991228", "time_retrieved": "2024-07-30T19:46:22.835358", "image_code": "// idea from https://www.desmos.com/calculator/64ebpdhpzq\n\n#define TAU 6.2831853\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y) * 12.;\n\n    float t = (fract(iTime) - .5) * TAU;\n    float s = tan(tan(sin(p.x) * sin(p.y - t)));\n    float w = fwidth(s) * .5;\n    s = smoothstep(-w, w, p.y - s);\n\n    fragColor = vec4(vec3(s), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtccDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 137, 137, 422]], "test": "untested"}
{"id": "3l3cDf", "name": "Rueda KAEI", "author": "jorge2017a1", "description": "Rueda KAEI", "tags": ["ruedakaei"], "likes": 1, "viewed": 237, "published": 3, "date": "1609990958", "time_retrieved": "2024-07-30T19:46:23.715006", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\nfloat cilindrosconboxGrande(vec3 p, float numItem)\n{\n    vec3 pp;\n    p.xy *= genRotMat(-iTime+10.0);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb1= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.5,5.0,5.0) );\n    float sdb2= sdBox(rep2-vec3(5.0,0.0,3.0), vec3(5.0,0.5,0.5) );\n    float sdb3= sdBox(rep2-vec3(5.0,0.0,-4.0), vec3(5.0,0.5,0.5) );\n\n    float res = unionSDF( sdb1, sdb2);\n    res = unionSDF( res, sdb3);\n\treturn  res;\n}\n\n\nvec2  RuedaGrande(vec3 p, float numItem)\n{\n    \n    p.xy *= genRotMat(-iTime+10.0);/// genera la rotacion del engrane\n    \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    float sdb0a= sdBox(p-vec3(0.0,0.0,15.0), vec3(0.5,0.5,25.0) );\n    \n    float sdb1a= sdBox(rep2-vec3(10.0,0.0,0.0), vec3(0.5,5.0,5.0) );\n    float sdb2a= sdBox(rep2-vec3(5.0,0.0,3.0), vec3(5.0,0.5,0.5) );\n    float sdb3a= sdBox(rep2-vec3(5.0,0.0,-4.0), vec3(5.0,0.5,0.5) );\n    \n    float posz=35.0;\n    float sdb1b= sdBox(rep2-vec3(10.0,0.0,0.0+posz), vec3(0.5,5.0,5.0) );\n    float sdb2b= sdBox(rep2-vec3(5.0,0.0,3.0+posz), vec3(5.0,0.5,0.5) );\n    float sdb3b= sdBox(rep2-vec3(5.0,0.0,-4.0+posz), vec3(5.0,0.5,0.5) );\n    \n     vec2 res=vec2(9999.9,-1.0);\n     res = opU2( res, vec2(sdb0a,1.0));\n     \n     res = opU2( res, vec2(sdb1a,2.0));\n     res = opU2( res, vec2(sdb2a,3.0));\n     res = opU2( res, vec2(sdb3a,4.0));\n     \n     res = opU2( res, vec2(sdb1b,2.0));\n     res = opU2( res, vec2(sdb2b,4.0));\n     res = opU2( res, vec2(sdb3b,3.0));\n      \n      \n\treturn  res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    float planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    p.y=p.y-11.0;\n    p+=vec3(iTime*3.0,0.0,0.0);\n\tvec3 q=p;\n    float cx=70.0;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    p=q;\n\t\n   vec2 cb1= RuedaGrande( p,8.0);\n   res =opU3(res, vec3(cb1.x,cb1.y,MATERIAL_NO)); \n  \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n     \n    float diff = dot(normal, l);\n    //vec3 v = normalize( p - ro );\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t   \n    float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    if (id_material==5.0)\n    {\n        float escala=0.05;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t      return vec3( clamp(d,0.0,1.0)) ;\n    }\n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(4.0,-8.0,-45.0);\n    \n    ro= rotate_x(ro, radians(45.0));\n    ro= rotate_z(ro, radians(45.0));\n    ro= rotate_y(ro +vec3(0.0,-2.0+ 10.0*clamp(sin(iTime) ,0.0, 25.0 ) ,-25.0), radians(45.0));\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 448, 484, 484, 505], [506, 506, 538, 538, 622], [625, 669, 716, 716, 743], [745, 745, 788, 788, 815], [817, 817, 865, 865, 893], [894, 965, 999, 999, 1097], [1098, 1098, 1132, 1132, 1224], [1225, 1225, 1259, 1259, 1351], [1352, 1392, 1426, 1426, 1523], [1556, 1556, 1582, 1582, 1636], [1638, 1638, 1672, 1672, 1845], [1848, 1848, 1900, 1900, 2323], [2326, 2326, 2368, 2368, 3377], [3380, 3420, 3445, 3445, 3941], [3946, 3946, 4032, 4032, 4797], [4803, 4854, 4878, 4878, 5066], [5069, 5069, 5102, 5102, 5563], [5565, 5619, 5655, 5655, 5889], [5890, 5991, 6071, 6071, 6348], [6349, 6400, 6447, 6447, 6664], [6718, 6718, 6811, 6811, 7086], [7091, 7140, 7197, 7197, 8551]], "test": "untested"}
{"id": "3tccWf", "name": "Uniform 3D Euclidean Honeycombs", "author": "neozhaoliang", "description": "3D Wythoffian uniform honeycombs and their duals in Euclidean space, a flythrough version.", "tags": ["3d", "geometry", "honeycomb", "coxeter", "group", "tiling", "euclidean", "symmetry", "lattice"], "likes": 27, "viewed": 2157, "published": 3, "date": "1609987591", "time_retrieved": "2024-07-30T19:46:24.789134", "image_code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUniform honeycombs and their duals\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws uniform honeycombs and their duals in 3D Euclidean space.\n\nYou can learn more about these honeycombs on the Wikipedia page for convex\nuniform honeycombs:\n\n    https://en.wikipedia.org/wiki/Convex_uniform_honeycomb\n\nThe main rendering procedure is based on the work of @shane:\n\n    https://www.shadertoy.com/view/4l2cD3.\n    \nI particularly like the metallic effects in many of his examples.\n\nThe honeycomb data is taken from @mla's work at\n\n    https://www.shadertoy.com/view/WsfcRn.\n    \nI'm also grateful to @mla for helpful discussions.\n\n@mla's code is a great reference for the general Wythoff construction,\nwhich saved me a lot of hard (and even boring) computations.\nIf you have any difficulty understanding this code, I recommend referring to\n@mla's version, as the ideas are the same.\n\nThe trickiest part of this program is to render the octagonal edges\n(or other prism-like shapes) instead of just cylinder edges.\nThis is due to the fact that Wythoff construction may change the distance\nbetwwen a point and the cell edges: In the Wythoff construction, one need to\nreflect a point P across the mirrors repeatly until it falls within a certain\nregion, known as the \"fundamental domain\". Say its final location in the fundamental\ndomain is Q. In the cases that edges have prism-like shapes, the distances d(P, edges)\nand d(Q, edges) may not be equal. This results in annoying artifacts in the final image.\nIt took me 90% of the time to figure out how to tackle this. My solution is\nbrute-force: just render more copies of the fundamental domain. This made the\ncode look ugly and the program take a bit long time to compile, but it worked and\nlooked right in the end.\n*/\n\n// Honeycomb type. 0 for affine A3, 1 for affine B3, 2 for affine C3\n#define LATTICE   1\n\n// Barycentric coordinates of the initial vertex v0 in the fundamental tetrahedron.\n// This determines the truncation type of the honeycomb.\nconst vec4 T = vec4(1, 1, 1, 0);\n\nconst float tbsize = 0.055;\n\n// use another color style\n#define GOLD_STYLE\n\n// render the dual honeycomb?\n//#define DUAL\n\n// initial vertex\nvec3 v0;\n\n// M is the four reflection mirrors of the fundamental tetrahedron,\n// M_inv is the inverse of M.\nmat4 M, M_inv;\n\n// The four vertices of the fundamental tetrahedron and the four mirror images of v0 about\n// the four mirrors\nmat4x3 V, E;\n\n// object id\nvec3 objIDs;\n\nfloat glow;\n\nvec3 do_reflect(vec3 p, vec4 n) {\n    vec4 q = vec4(p, 1.);\n    return p - 2. * dot(q, n) * n.xyz;\n}\n\nvec3 rA(vec3 p) { return do_reflect(p, M[0]); }\nvec3 rB(vec3 p) { return do_reflect(p, M[1]); }\nvec3 rC(vec3 p) { return do_reflect(p, M[2]); }\nvec3 rD(vec3 p) { return do_reflect(p, M[3]); }\n\n\nvoid init() {\n\n    const float s = 0.70710678;    // sqrt(2) / 2\n\n#if LATTICE == 0\n    // affine A3 lattice\n    //\n    // A     C\n    //  o---o\n    //  |   |\n    //  o---o\n    // D     B\n    M = mat4(vec4(-s, -s, 0, 2.*s),\n             vec4(s, -s, 0, 0),\n             vec4(0, s, -s, 0),\n             vec4(0, s, s, 0));\n             \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(2, 0, 0),\n               vec3(1, 1, -1),\n               vec3(1, 1, 1));\n\n#elif LATTICE == 1\n    // affine B3 lattice\n    //          C\n    //         o\n    //     4  /\n    // A o---o B\n    //        \\\n    //         o\n    //          D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-s, -s, 0, 2.*s));\n             \n    V = mat4x3(vec3(1, 1, 1),\n               vec3(1, 1, 0),\n               vec3(2, 0, 0),\n               vec3(0, 0, 0));\n\n// affine C3 lattice\n#else\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    M = mat4(vec4(0, 0, 1, 0),\n             vec4(0, s, -s, 0),\n             vec4(s, -s, 0, 0),\n             vec4(-1, 0, 0, 1));\n    \n    V = mat4x3(vec3(0, 0, 0),\n               vec3(1, 0, 0),\n               vec3(1, 1, 0),\n               vec3(1, 1, 1));\n\n#endif\n\n    M_inv = inverse(M);\n    vec4 v4 = T * M_inv;\n    v4 /= v4.w;\n    v0 = v4.xyz;\n    for (int i = 0; i < 4; i++) {\n        E[i] = v0 - 2. * dot(v4, M[i]) * M[i].xyz;\n    }\n}\n\n\n#define FAR     80.\n#define PI      3.141592654\n\nfloat sgn(float x) { return x > 0. ? 1. : -1.; }\n\n// Camera path as a function of time t.\n// I think it's unlikely to devise an universal path that flies through all\n// honeycombs without hitting the lattice.\nvec3 camPath(float t) { return vec3(t, 0, 0); }\n\n// A mirror is active if and only if the initial vertex v0 is not on it,\n// or equivalently, the barycentric coordinate with respect to this mirror is non-zero.\nbool isActive(int k) { return T[k] != 0.0; }\n\n// try to reflect a point p about mirror with normal `n`, if p and the fundamental domain\n// are on the different sides of the mirror\nvec4 try_reflect(vec4 p, vec4 n, inout int flips) {\n    float k = dot(p, n);\n    if (k < 0.) {\n        flips += 1;\n        p.xyz -= 2. * k * n.xyz;\n    }\n    return p;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n\n// fold a point p into the fundamental domain.\n// we return the final position of p, but also track an intermediate state of p for\n// handling dual cases.\nvec3 fold(inout vec3 p, inout int flips) {\n    \n    vec4 q;\n\n#if LATTICE == 0\n\n    p = mod(p + 2., 4.) - 2.;\n    q = vec4(p, 1);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            q = try_reflect(q, M[j], flips);\n        }\n    }\n\n#elif LATTICE == 1\n   \n    p = mod(p + 2., 4.) - 2.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1);\n    for (int i = 0; i < 2; i++) {\n        q = try_reflect(q, M[3], flips);\n        q = try_reflect(q, M[2], flips);\n        q = try_reflect(q, M[1], flips);\n    }\n    \n#else\n\n    p = mod(p + 1., 2.) - 1.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1.);\n    q = try_reflect(q, M[1], flips);\n    q = try_reflect(q, M[2], flips);\n    q = try_reflect(q, M[1], flips);\n\n#endif\n\n    return q.xyz;\n}\n\n\n// Shane's tex3D function\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n) {\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// I hacked this function to rotate any edge (a, b) to z-axis\nmat3 rotAxis(vec3 n) {\n    n = normalize(n);\n    vec3 x;\n    if (n.x == 0.)\n        x = vec3(1, 0, 0);\n    else\n        x = normalize(vec3(-n.y, n.x, 0.));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\n\nfloat tube(vec2 p, float sc, float rad) {\n    return max(max(p.x, p.y), (p.x + p.y)*sc) - rad;\n}\n\n\n// draw an edge with two ends at a, b.\nvec3 dSegment(vec3 p, vec3 a, vec3 b) {\n    // set local origin at middle point of the edge\n    vec3 m = (a + b) / 2.;\n    p -= m;\n    b -= m;\n    a -= m;\n    vec3 h = (b - a) / 2.;\n    float L = length(h); // length of half the edge\n\n    p = p * rotAxis(h);  // reorient the edge along with z-axis\n    p = abs(p);\n\n    // the main tube, currently this has infinite length\n    float tb;\n    tb = tube(p.xy, 0.75, tbsize);\n\n    float band = 1e5;\n    float innerTb = 1e5;\n    \n    // add a band of 1/4 length of the edge\n    band = max(tb - 0.0075, p.z - L/4.);\n    \n    // trick: rotate p to make two smaller tubes\n    // remove them from the main tube to make the holes\n    float psize = tbsize  / 1.5;\n    vec2 peg = vec2(tube(p.xz, .64, psize), tube(p.yz, .64, psize));\n    float hole = min(peg.x, peg.y);\n    \n    // use planes to cut the band\n    float dp1 = max(peg.x, p.y - tbsize - .0095); dp1 = max(dp1, p.y - L / 4.);\n    float dp2 = max(peg.y, p.x - tbsize - .0095); dp2 = max(dp2, p.x - L / 4.);\n    band = min(band, min(dp1, dp2));\n    \n    // make holes on the main tube\n    tb = max(tb, -(hole - .015));\n    \n    // cut the infinite main tube at the two ends\n    tb = max(tb, p.z - L);\n    \n    // make holes on the band\n    band = max(band, -(hole + .0125));\n    \n    // use sphere to create a fake inner tube\n    innerTb = length(p) - tbsize;\n    \n    return vec3(tb, band, innerTb);\n}\n\n// This function is only used for handling dual of A3 honeycombs.\n// verts[4] are four non-adjacent vertices of a cube, so each face of the cube\n/// contains exactly one pair of vertices in verts[4].\n// For p a point in the cube, we find this pair of vertices so that p is nearest to\n// the face contains this pair among all six faces.\nvoid findVertexPair(vec3 p, vec3 verts[4], out int i1, out int j1) {\n    float d = 1e5;\n    float d1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i+1; j < 4; j++) {\n            // (verts[i] + verts[j]) / 2. is the center of the face since they form a diagonal pair.\n            d1 = length(p - (verts[i] + verts[j]) / 2.);\n            if (d1 < d) {\n                i1 = i;\n                j1 = j;\n                d = d1;\n            }\n        }\n    }\n}\n\n\nfloat map(vec3 p) {\n    vec3 dedge = vec3(1e5);\n    vec3 p0 = p;\n    int flips = 0;\n    p = fold(p0, flips);\n\n// For the usual uniform honeycomb just render the edges, that's safe since they lie inside\n// the fundamental tetrahedron.\n#ifndef DUAL\n\n    for (int i = 0; i < 4; i++) {\n         dedge = min(dedge, dSegment(p, v0, E[i]));\n    }\n   \n#else\n    /*\n    Render the dual honeycomb.\n\n    In the dual honeycomb two cells are adjacent if and only if they share a common face.\n        \n    For two mirrors A, B they generate a non-degenerate face if and only if either\n    of below holds:\n        \n        1. A, B are perpendicular and they are both active\n        2. A, B are not perpendicular and at least one of them is active\n        \n    For such a face we further check if {A, B, C} and {A, B, D} both generate non-degenerate cells.\n\n    1. If {A, B, C} and {A, B, D} are both non-degenerate, (C, D) form an edge in the dual honeycomb.\n    2. If {A, B, D} degenerates to a face, (D, 2*C-D) form an edge in the dual honeycomb.\n    3. If both {A, B, C} and {A, B, D} are degenerate, no edge between C and D.\n    */\n\n    // The C3 honeycomb is the easiest, handle this case first.\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    #if LATTICE == 2\n        // if either A or B is active, then {A, B} generate a face and {A, B, C} is a\n        // non-degenerate cell. {A, B, D} is non-degenerate iff D is active.\n        // Other procedures below are all similar.\n        if (isActive(0) || isActive(1)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[2], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[2]-V[3]));\n        }\n        if (isActive(0) && isActive(2)) dedge = min(dedge, dSegment(p, V[1], V[3]));\n        if (isActive(1) || isActive(2)) dedge = min(dedge, dSegment(p0, V[0], V[3]));\n        if (isActive(0) && isActive(3)) dedge = min(dedge, dSegment(p, V[1], V[2]));\n        if (isActive(1) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[2]));\n        if (isActive(2) || isActive(3)) {\n            if (isActive(0))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        }\n \n    #elif LATTICE == 1\n\n        if (isActive(0) || isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n        if (isActive(0) && isActive(2)) {\n            if (isActive(3))\n                dedge = min(dedge, dSegment(p, V[1], V[3]));\n            else\n                dedge = min(dedge, dSegment(p, V[3], 2.*V[1]-V[3]));\n        }\n        // trick: the edge (V[0], V[3]) does not lie inside the fundamental domain hence octahedral\n        // shapes won't work. we render its 4 copies in the cube [0, 0, 0] x [2, 2, 2].\n        if (isActive(1) || isActive(2)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[3]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 2)));\n        }\n        \n        if (isActive(0) && isActive(3)) {\n            if (isActive(2))\n                dedge = min(dedge, dSegment(p, V[1], V[2]));\n            else\n                dedge = min(dedge, dSegment(p, V[2], 2.*V[1]-V[2]));\n        }\n        if (isActive(1) || isActive(3)) {\n            dedge = min(dedge, dSegment(p0, V[0], V[2]));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 0)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(0, 0, 2)));\n            dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 2)));\n        }\n        if (isActive(2) && isActive(3)) {\n            if (isActive(1))\n                dedge = min(dedge, dSegment(p, V[1], V[0]));\n            else\n                dedge = min(dedge, dSegment(p, V[0], 2.*V[1]-V[0]));\n        } \n    \n    #else\n        // The duals of A3 honeycombs are the most difficult. Recall p0 is now in [-2, -2, -2] x [2, 2, 2].\n        // We use a completely different way to render them. The idea is, vertices of the A3 regular honeycombs\n        // are integer lattices points (i, j, k) with:\n        // i + j + k = 0 mod 4 for V0\n        // i + j + k = 2 mod 4 for V1\n        // i + j + k = 1 mod 4 for V2\n        // i + j + k = 3 mod 4 for V3\n     \n        // find the center of the 2x2x2 cube that p belongs to\n        vec3 C = vec3(sgn(p0.x), sgn(p0.y), sgn(p0.z));\n        \n        float k = mod(C.x + C.y + C.z, 4.);\n        // if k = 1 mod 4, then the center of this cube is congruent to V[2] of the fundamental tetrahedron.\n        // else k = 3 mod 4 and the center is congruent to V[3].\n        int type = (k == 1.) ? 2 : 3;\n        \n        vec3 V0[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[0]\n        vec3 V1[4];  // holds the vertices of this 2x2x2 cube that are congruent to V[1]\n        \n        if (type == 2) {\n            V0[0] = C + vec3(1, 1, 1);\n            V0[1] = C + vec3(-1, -1, 1);\n            V0[2] = C + vec3(1, -1, -1);\n            V0[3] = C + vec3(-1, 1, -1);\n            V1[0] = C + vec3(1, -1, 1);\n            V1[1] = C + vec3(-1, 1, 1);\n            V1[2] = C + vec3(1, 1, -1);\n            V1[3] = C + vec3(-1, -1, -1);\n        }\n        else {  // switch the role of V0, V1 above\n            V1[0] = C + vec3(1, 1, 1);\n            V1[1] = C + vec3(-1, -1, 1);\n            V1[2] = C + vec3(1, -1, -1);\n            V1[3] = C + vec3(-1, 1, -1);\n            V0[0] = C + vec3(1, -1, 1);\n            V0[1] = C + vec3(-1, 1, 1);\n            V0[2] = C + vec3(1, 1, -1);\n            V0[3] = C + vec3(-1, -1, -1);\n        }\n        \n        int r0, s0, r1, s1;\n        findVertexPair(p0, V0, r0, s0);\n        findVertexPair(p0, V1, r1, s1);\n        vec3 P0 = V0[r0] + V0[s0] - C;\n        vec3 P1 = V1[r1] + V1[s1] - C;\n\n        if (isActive(2) && isActive(3)) dedge = min(dedge, dSegment(p, V[0], V[1]));\n        if (isActive(1) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(1) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V0[r0]));\n                dedge = min(dedge, dSegment(p0, C, V0[s0]));            \n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n                dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n            }\n        }\n        if (isActive(0) || isActive(3)) {\n            if (type == 2) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) || isActive(2)) {\n            if (type == 3) {\n                dedge = min(dedge, dSegment(p0, C, V1[r1]));\n                dedge = min(dedge, dSegment(p0, C, V1[s1]));\n            }\n            else {\n                dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n                dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n            }\n        }\n        if (isActive(0) && isActive(1)) dedge = min(dedge, dSegment(p, V[2], V[3]));\n\n    #endif\n#endif\n\n    // store the object ids.\n    objIDs = dedge;\n    return min(dedge.x, min(dedge.y, dedge.z));\n}\n\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n    float eps = 1./mix(400., iResolution.y, .5)*(1. + t*.5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2.*d);\n    for(int i = min(iFrame, 0); i < 3; i++ ) {\n        for(int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    glow = 0.;\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        glow += 1./(1. + ah*ah*8.);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\n\nvec3 transform(in vec3 p) {\n    if (iMouse.x > 0.0) {\n        float phi =  2.0*iMouse.x / iResolution.x * PI - PI;\n        float theta = iMouse.y / iResolution.y * PI - 0.5*PI;\n        p.xz = rot2d(p.xz, phi / 6.);\n        p.yx = rot2d(p.yx, theta / 4.);\n       \n    }\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = camPath(iTime * 1.1);\n    vec3 lookat = camPath(iTime * 1.1 + 0.1);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n    ro = transform(ro);\n    rd = transform(rd);\n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd);\n    \n    float objID = (objIDs.x < objIDs.y && objIDs.x < objIDs.z) ? 0. : (objIDs.y < objIDs.z) ? 1. : 2.;\n    \n    if (t < FAR) {\n        float ed;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, ed, t);\n\n        vec3 oCol;\n        #ifndef GOLD_STYLE\n        vec3 bCol = mix(vec3(1, .1, .5).zyx,\n                        vec3(1, .3, .1).zyx,\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #else\n        vec3 bCol = mix(vec3(1, .5, .1),\n                        vec3(1, .1, .2),\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n        #endif\n        if(objID < .5)\n            oCol = mix(bCol, vec3(1), .97);\n        \n        else if (objID > 1.5)\n            oCol = mix(bCol, vec3(1), .05) + bCol*2.;\n        \n        else\n            oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        vec3 tx = tex3D(iChannel0, pos*2., nor);\n        tx = smoothstep(.0, .5, tx)*2.;\n\n        if(objID < 1.5)\n            oCol *= tx;\n        else\n            oCol *= mix(vec3(1), tx, .5);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3./(1. + dist*0.05 + dist*dist*0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        if (objID < 1.5)\n            diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot( reflect(ld, nor), rd), 0.0 ), 32.0);\n\n        col = oCol*(diff + .25) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n\n        col += .015/max(abs(.05 - map(pos*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n\n        // Adding a bit of glow. It was tempting to get my money's worth, but I kept it subtle. :)\n        if(objID < 1.5)\n            col += bCol*glow*.02;\n        else\n            col += bCol*glow*1.5;\n\n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        col *= (1. - ed*.7);\n        col *= atten*(sh + ao*.25)*ao;\n\n    }\n\n    float fog = 1./(1. + t*.125 + t*t*.01);\n    col = mix(vec3(0), col, fog);//\n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tccWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2500, 2500, 2533, 2533, 2600], [2602, 2602, 2619, 2619, 2649], [2650, 2650, 2667, 2667, 2697], [2698, 2698, 2715, 2715, 2745], [2746, 2746, 2763, 2763, 2793], [2796, 2796, 2809, 2809, 4208], [4260, 4260, 4280, 4280, 4308], [4310, 4469, 4492, 4492, 4516], [4518, 4679, 4701, 4701, 4723], [4725, 4859, 4910, 4910, 5028], [5030, 5030, 5059, 5059, 5107], [5110, 5265, 5307, 5307, 6124], [6127, 6153, 6200, 6200, 6409], [6411, 6473, 6495, 6495, 6682], [6685, 6685, 6726, 6726, 6781], [6784, 6823, 6862, 6914, 8224], [8226, 8562, 8630, 8630, 9025], [9028, 9028, 9047, 9047, 16686], [16689, 16749, 16801, 16801, 17416], [17419, 17419, 17488, 17488, 17913], [17915, 17915, 17945, 17945, 18200], [18203, 18203, 18240, 18240, 18570], [18573, 18573, 18600, 18600, 18857], [18860, 18860, 18915, 18915, 21750]], "test": "untested"}
{"id": "tldcD2", "name": "2d-cuadrado simple", "author": "jorge2017a1", "description": "2d-cuadrado simple", "tags": ["2dcuadradosimple"], "likes": 2, "viewed": 253, "published": 3, "date": "1609984180", "time_retrieved": "2024-07-30T19:46:25.623902", "image_code": "// por jorge2017a1 ...jorge flores p.!!!\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{    vec2 q = mod(p+0.5*c,c)-0.5*c; return  q; }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{ if (d1.x<d2.x) return d1;   else return d2; }\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{ if (d1.x>d2.x) return d1; else return d2;}\n\nvec2 opS2(vec2 d1, vec2 d2) \n{ return vec2(max(-d2.x, d1.x), 2.0); }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\n\nvec2 CuadroBlanco(vec2 p)\n{\n  float sb0= sdBox( p, vec2(0.52,0.52) );  \n  float sb1= sdBox( p, vec2(0.5,0.5) );\n  float sb2= sdBox( p, vec2(0.25,0.25) );\n  float sb3= sdBox( p, vec2(0.125,0.125) );\n  \n  vec2 resp=vec2(9999.9,-1.0);\n  \n  sb0=opS(sb1,sb0 );\n  \n  sb1=opS(sb2,sb1 );\n  sb1=opS(sb3,sb1 );\n  \n  \n  sb2=opS(sb3,sb2);\n  \n  resp=opU2(resp, vec2(sb0,0.0 ) );\n  resp=opU2(resp, vec2(sb1,1.0 ) );\n  resp=opU2(resp, vec2(sb2,0.0 ) );\n  resp=opU2(resp, vec2(sb3,1.0 ) );\n  \n return resp;\n}\n\n\nvec2 CuadroNegro(vec2 p)\n{\n  float sb0= sdBox( p, vec2(0.52,0.52) );  \n  float sb1= sdBox( p, vec2(0.5,0.5) );\n  float sb2= sdBox( p, vec2(0.25,0.25) );\n  float sb3= sdBox( p, vec2(0.125,0.125) );\n  \n  vec2 resp=vec2(9999.9,-1.0);\n  \n  sb0=opS(sb1,sb0 );\n  \n  sb1=opS(sb2,sb1 );\n  sb1=opS(sb3,sb1 );\n  \n  \n  sb2=opS(sb3,sb2);\n  resp=opU2(resp, vec2(sb0,1.0 ) );\n  resp=opU2(resp, vec2(sb1,0.0 ) );\n  resp=opU2(resp, vec2(sb2,1.0 ) );\n  resp=opU2(resp, vec2(sb3,0.0 ) );\n  \n return resp;\n}\n\n\nvec2 BloquesSimple(vec2 p)\n{\n    vec2 resp=vec2(9999.0,-1.0);\n    \n    float ii=1.0;\n    float jj=2.0;\n    for (float i=0.0; i<6.0;i++)\n \t{       \n        vec2 cb1= CuadroBlanco( p-vec2(ii,0.0) );\n        vec2 cb2= CuadroNegro( p-vec2(jj,0.0) );\n        resp=opU2(resp, cb1);\n        resp=opU2(resp, cb2);\n        ii=ii+2.0;\n        jj=jj+2.0;\n        \n    }\n    \n    return resp;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    p*=3.0*sin(iTime);\n    vec3 colOut=vec3(0.0);\n    \n    vec2 c1 =vec2(20.0,1.05);\n    vec2 p1= opRep2D(  p, c1 );\n    \n    vec2 bs1= BloquesSimple(p1-vec2(-6.0,0.0) );\n    colOut= ProcesoColorVec2( colOut, bs1);\n    \n    \n    vec4 color =vec4(colOut, 1.0);\n\tfragColor = color;\n\n}\n\n\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);  float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n\n\n///------------------\nvec3 ProcesoColor(vec3 colBorde , vec3 colOut, float dist)\n{\n    float thickness = 0.005;  //grosor\n\tfloat blur = 0.004;\t //difuminar\n    \n    float step1 = thickness;\n\tfloat step2 = thickness + blur;\t\n    float step3= smoothstep(step1, step2, dist);\n    vec3 color1 = mix(colBorde, colOut, step3);\t\n    return color1;\n}\n\nvec3 ProcesoColorVec2( vec3 colOut, vec2 dist)\n{\n    float thickness = 0.005;  //grosor\n\tfloat blur = 0.004;\t //difuminar\n    vec3 colBorde=getColorf(dist.y);\n    \n    float step1 = thickness;\n\tfloat step2 = thickness + blur;\t\n    float step3= smoothstep(step1, step2, ( dist.x) );\n    vec3 color1 = mix(colBorde, colOut, step3);\t\n    return color1;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 74, 74, 96], [97, 97, 130, 130, 152], [153, 153, 186, 186, 207], [209, 209, 247, 247, 294], [297, 297, 329, 329, 375], [377, 377, 409, 409, 452], [454, 454, 484, 484, 522], [525, 525, 562, 562, 635], [638, 638, 665, 665, 1130], [1133, 1133, 1159, 1159, 1621], [1624, 1624, 1652, 1652, 2006], [2010, 2010, 2067, 2067, 2454]], "test": "untested"}
{"id": "Wl3yWf", "name": "[Genuary] #6 Triangle Subdiv", "author": "oneshade", "description": "Triangle tiled with triangles.", "tags": ["triangle", "subdivision", "genuary2021"], "likes": 2, "viewed": 125, "published": 3, "date": "1609978611", "time_retrieved": "2024-07-30T19:46:26.555412", "image_code": "float sdEquiTri(in vec2 p) {\n    const float k = 1.73205080757; // sqrt(3)\n    p.x = abs(p.x) - 1.0;\n    p.y += 1.0 / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nfloat triWave(in float x) {\n    float frac = fract(x);\n    return abs(round(frac) - frac);\n}\n\nfloat map(in vec2 p) {\n    float div = 1.0 + floor(triWave(iTime / 6.0) * 12.0) * 3.0; // Divisions along edges\n    float rep = 0.2; // Size of the grid\n\n    float hrep = 0.5 * rep;\n    float hrepDiv = div * 0.1;\n\n    float btri = sdEquiTri(p / hrepDiv) * hrepDiv;\n\n    p.y -= 0.55 * rep;\n    p.x += mod(fract(p.y / hrep / 1.75), 2.0) * hrep - 0.5 * p.y / 0.875;\n    p = mod(p, vec2(rep, rep * 0.875)) - vec2(hrep, hrep * 0.875);\n    p.y += 0.125 * rep;\n\n    return max(abs(sdEquiTri(p / hrep) * hrep), btri);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    fragColor = vec4(smoothstep(0.0, unit, map(uv + vec2(0.0, 0.4))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 267], [269, 269, 296, 296, 361], [363, 363, 385, 385, 874], [876, 876, 931, 931, 1114]], "test": "untested"}
{"id": "wtdcD2", "name": "3D Buffers", "author": "Ric3cir121", "description": "So i made a working 3D buffer.\n\nInstructions in the code!", "tags": ["3d", "buffer"], "likes": 4, "viewed": 299, "published": 3, "date": "1609971988", "time_retrieved": "2024-07-30T19:46:27.824020", "image_code": "#define _ --- 3D Buffers ------------|\\\n/| Image: Just display the 3D buffer |\\\n/| Buffer A: Create the 3D buffer    |\\\n/| Common: 3D buffer engine          |\\\n/|-----------------------------------|\\\n\n\n\nmat2 rotate(float p){return mat2(cos(p),sin(p),-sin(p),cos(p));}\nvoid mn(out vec4 o,vec2 u){\n    // Display that cube in the screen, try changing 'f'\n    float f = .5;\n    float t = sin(iTime)/4.0001+0.75;\n    vec2 uv = (u+u-iResolution.xy)/iResolution.y;\n    vec2 uv1 = vec2(uv.x-uv.y/f,uv.y/f+uv.x)*vec2(-1,1)+(1.-t);\n    vec2 uv2 = vec2(uv.x,uv.y+uv.x*f)*2.*vec2(-1,-1)+(1.-t);\n    vec2 uv3 = vec2(uv.x,uv.y-uv.x*f)*2.*vec2(1,-1)+(1.-t);\n    o = volume(iChannel0,vec3(uv1,1.-t));\n    if(uv.x+uv.y/f<0.)o = volume(iChannel0,vec3(uv2.x,1.-t,uv2.y));\n    if(-uv.x+uv.y/f<0.&&uv.x>0.)o = volume(iChannel0,vec3(1.-t,uv3));\n    if(abs(uv.x)*2.>t||max(-uv.x+uv.y/f,uv.x+uv.y/f)>t||-min(uv.y+uv.x*f,uv.y-uv.x*f)*2.>t)o = vec4(.2);\n}\n#define PI 3.1415926535\n#define hash12(c) (fract(sin(vec2(c,sin(c*1000.)*1000.)*1000.)*1000.))\nvoid mainImage(out vec4 o,vec2 u){\n    // Anti-aliasing\n    vec2 uv = u/iResolution.xy;\n    o = vec4(0.);\n    vec4 O = vec4(0.);\n\tint a = 20;\n    for(int i = 0; i<a; i++){\n        O = vec4(0);\n        mn(O,u+hash12(0.3*u.x*u.y*PI*(float(i)+mod(iTime,10.))));\n        o += O;\n    }\n    o /= float(a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define _ac ---------- Common ------------------------|\\\n/| Note: This is the 3D buffer engine!                |\\\n/|----------------------------------------------------|\\\n\n\n\n#define makevolume() void mainImage(out vec4 o,vec2 u){\\\n    ivec2 me = ivec2(u);\\\n    int ar = int(pow(iResolution.x*iResolution.y,1./3.));\\\n    int slide = me.x+me.y*int(iResolution.x)-1;\\\n    vec3 c = vec3(slide%ar,slide/ar%ar,slide/ar/ar);\\\n    o = vec4(0);\\\n    if(c.z<=volumeResolution.z)mainImage(o,c);\\\n    if(slide==-1)o=vec4(1.2,3.4,4.3,2.1);\\\n}\\\nfloat _r_voldserr\n\n#define volumeResolution vec3(int(pow(iResolution.x*iResolution.y,1./3.)))\n\n#define _r_res() int(pow(iResolution.x*iResolution.y,1./3.))\n#define _r_rd(c) ivec3(mod(vec3((c)*volumeResolution),vec3(_r_res())))\n#define _r_slide(c) (_r_rd(c).x+_r_rd(c).y*_r_res()+_r_rd(c).z*_r_res()*_r_res()+1)\n#define volume(ch,c) texelFetch(ch,ivec2(_r_slide(c)%int(iResolution.x),_r_slide(c)/int(iResolution.x)),0)", "buffer_a_code": "#define _ab ------------------------- Buffer A --------------------------------------------|\\\n/| vec3 volumeResolution             /* volume resolution                               */ |\\\n/| void makevolume                   /* put at the end to declare the buffer as a volume*/ |\\\n/| void mainImage(out vec4 o,vec3 u) /* this is the mainImage                           */ |\\\n/| vec4 volume(sampler2D ch,vec3 c)  /* ch: iChannel, c: coordinates (from 0 to 1)      */ |\\\n/|                                                                                         |\\\n/| Note: while putting a texture remember to click on gear near the texture and change     |\\\n/|       the filter to linear                                                              |\\\n/|-----------------------------------------------------------------------------------------|\\\n\n\n\nvoid mainImage(out vec4 o,vec3 u){\n    /*Rainbow                  */ vec4 o1 = vec4(u/volumeResolution,0);\n    /*Sphere distance estimator*/ vec4 o2 = vec4(length(u-volumeResolution/2.)/volumeResolution.x);\n    /*2D to 3D texture         */ vec4 o3 = texture(iChannel0,(u.xz+u.yx)*2./volumeResolution.x/2.);\n    \n    float t = iTime/4.;\n    if(mod(t,3.)<1.         ) o = mix(o1,o2,mod(t,3.));\n    if(abs(mod(t,3.)-1.5)<.5) o = mix(o2,o3,mod(t,3.)-1.);\n    if(mod(t,3.)>2.         ) o = mix(o3,o1,mod(t,3.)-2.);\n}\n\nmakevolume();", "buffer_a_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 224, 224, 267], [268, 268, 295, 352, 930]], "test": "untested"}
{"id": "tttcWj", "name": "Day 386", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 13, "viewed": 331, "published": 3, "date": "1609971564", "time_retrieved": "2024-07-30T19:46:28.837311", "image_code": "// Fork of \"Day 385\" by jeyko. https://shadertoy.com/view/wl3yWj\n// 2021-01-06 11:49:58\n\n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n// cyclic noise from nimitz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(1.5,.951,0.99 + dot(uv,uv)*0.0));\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(2.4,0.8,1.24)*1.7),0.4);\n    \n    col *= 1.3;\n    col = 1. - exp(-col*2.);\n    //col = mix(acesFilm(col), col, 0.2);\n    \n    col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\nvec2 dmin(vec2 d, vec2 b){return d.x < b.x ? d : b;}\n\nfloat wallNoise = 0.;\nfloat wallNoiseB = 0.;\n\nfloat T = 0.;\nfloat tid = 0.;\n\n\n\nvec3 uvJello = vec3(0);\n\n\nvec2 sdWall(vec3 p){\n    p.x -= T*1.;\n\n    p.xy *= rot(0.55);\n    \n    vec3 op = p;    \n    vec2 d = vec2(abs(-p.z + 7.) + 0.02, ID_WALL_A);\n    \n    \n    d.x -= (wallNoise = cyclicNoise(vec3(p.xy,0.1)*15.))*0.05;\n    \n    p.y = pmod(p.y,1.5);\n    \n    p.x = pmod(p.x,2.);\n    \n    p.x = abs(p.x);\n    \n    p.xy *= rot(0.425);\n    \n    d.x = opSmoothSubtraction( -d.x, abs(p.y) - 0.2, 0.05 );\n\n    \n    \n    \n    p = op;\n    \n    \n    vec2 dWallB = vec2(-p.z + 7.1, ID_WALL_B);\n    \n    dWallB.x -= (wallNoiseB = cyclicNoiseB(vec3(p.x,p.y*0.5,0.1)*15.))*0.05;\n    \n    \n    d = dmin(d,dWallB);\n    //d = dWallB;\n    \n    \n    \n    //d.x += smoothstep(0.15,0.,length(p.xy) - 0.05)*0.02;\n\n    return d;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 sdSticks(vec3 psticks, float repd){\n\n    vec2 id = floor(psticks.xz/repd);\n    psticks.xz = pmod(psticks.xz,repd);\n\n    psticks.x*= 2.5;\n    psticks.z*=1.5;\n    \n    psticks.xy *= rot(-0.5*pi);\n    psticks.yz *= rot(.5*pi);\n    \n    psticks.xy *= rot(2.5*pi*sin(id.x));\n    psticks.yz *= rot(.25*pi*sin(id.x));\n    \n    \n    float dsticks = sdVerticalCapsule( psticks, 0.08, 0.05 );\n        \n    //dsticks = length(psticks) - 0.04;\n    return vec2(dsticks,ID_STICKS);\n}\n\nvec2 sdJelloTube(vec3 p){\n    p.x += 3.5;\n    //p.zy *= rot( -T + p.x*(4.-smoothstep(1.,0.,p.x - 0.)*0.4));\n    \n    //#define jellorot(b,a) ((b)*(4.-smoothstep(1.,0.,b - 0.)*0.4) + a)\n    \n    vec3 op = p;\n    \n    p.yz *= rot(((p.x)*(3. - smoothstep(1.,0.,p.x)*2.  - smoothstep(0.,1.,p.x )*1.5)) - T*(2.) );\n    \n    op.yz *= rot( (0. -  T*4. + op.x*0.65));//*(4.-smoothstep(1.,0.,p.x - 0.)*0.4) );\n    \n    //op.yz *= rot(jellorot(0.));\n    \n    op.y += 0.5 - 0.9*smoothstep(0.,5.,p.x) + sin(p.x*2. + T*2.)*0.7;\n    \n    float ydisp = 0.5 - 0.4*smoothstep(0.,9.,p.x) + 0.4*smoothstep(0.,5.,p.x - 2.) + sin(p.x + T)*0.;\n    p.y -= ydisp;\n    \n    float w = width + smoothstep(0.,7.,p.x)  + smoothstep(0.,27.,p.x)*2. ;\n    \n    float d = length(p.yz) - w;\n    \n    float dSprout = length(op.yz) - w;\n    \n    \n    float sc =  smoothstep(0.4,1.4,p.x)*(1. - smoothstep(0.,0.4,ydisp)*0.);\n    d = opSmoothSubtraction( -d, -p.x, 1.7 );\n    \n    dSprout = opSmoothSubtraction(-dSprout, p.x - 1.4, 0.5);\n    \n    //d = opSmoothUnion(d,dSprout,0.6);\n    \n    vec2 pc = vec2(atan(p.t,p.z)/pi,length(p.zx));\n    \n    float disp = sin(pc.x*pi*10.);\n    \n    disp = mix(disp, asin(disp),0.);\n    d -= disp*0.05*sc;\n    \n    \n    uvJello = p;\n    \n    return vec2(d, ID_JELLO);\n}\n\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    vec2 dwall = sdWall(p); \n    vec2 djellotube = sdJelloTube(p);\n\n    \n    #if 1\n    p.yz *= rot(1.25*pi);\n    djellotube.x = min(djellotube.x, sdJelloTube(p).x);\n    p.yz *= rot(-.5*pi);\n    //djellotube.x = min(djellotube.x, sdJelloTube(p).x);\n    #endif\n    /*\n    \n    */\n    //p.yz *= rot(.5*pi);\n\n    //djellotube.x = min(djellotube.x, sdJelloTube(p).x);\n\n    d = dmin(d, djellotube);\n    d = dmin(d, dwall);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.4;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*precis).x;\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    T = iTime*.35 + texture(iChannel0,fragCoord.xy/8.).x/100.;\n   \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy)/iResolution.xy;\n    \n    muv = muv*2. - 1.;\n    if (muv.x < -0.85){\n        muv -= muv;\n    }\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 1.;\n    \n    //float pu = sin(iTime*0.5);\n    \n    \n    //pu = pow(abs(pu),6.) * sign(pu);\n    float md = 2.5;\n    float modulator = pow(smoothstep(0.,1.,fract(T/md*1.)),6.);\n    if(mod(floor(T/md),2.)==0.)\n        modulator = 1. - modulator;\n    float pu = mix(-1.,0.2,modulator);\n    \n    ro.x -= 1.25 + pu;\n    \n    ro.y += 0.24;\n    \n    ro *= 1.9;\n    \n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.z += muv.x;\n    lookAt.y += muv.y;\n    \n    \n    vec3 rd = getRd(ro, lookAt, uv, 5.);\n    \n    \n    vec3 col = vec3(0);\n    \n    vec3 lDir = normalize(vec3(-2.5,1,-1.));\n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    \n    vec3 atten = vec3(1.);\n    \n    \n    vec3 hitCol = vec3(0);\n    \n    int maxIters = 300;\n    \n    \n    vec3 reflalbedo = mix(ambientCol, lightCol,0.5);\n    for(int i = 0; i < maxIters; i++){\n\n        p = ro + rd*(t += d.x*stepSz);\n        d = map(p);\n\n        if(d.x < eps){\n            hit = true;\n            break;\n        }\n\n    }\n\n    \n    vec3 n = getNormal(p,eps);\n                    \n    {\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.4))*a).x/a, 0., 1.)\n        \n        //#define SSS(n,a) clamp(1. - 2.*map(p + normalize(n)*a).x/a, 0., 1.)\n        #define SSS(n,a) clamp( 1.*map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        float aoo = AO(n,0.5);\n        float ao = aoo*AO(n,0.2)*AO(n,0.04)*1.;\n        //float ao = AO(n,1.);\n        \n        //ao = 1.;\n        \n        //float SSS = AO(lDir,0.04)*AO(lDir,0.5)*AO(-n,0.9);\n        //float SSS = AO(-n,0.2);\n        //float SSS = SSS(vec3(0,0.5,1),1.)*SSS(vec3(0,-0.4,1),1.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        float SSS = SSS(vec3(-0.,0.5,0.9),0.4)*1.*SSS(vec3(-0.4,-0.5,0.2),0.4)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        //float SSS = SSS(vec3(-0.,0.5,0.9),0.4)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        //float SSS = 0.;\n        //ao = 0.;\n        \n        //SSS = 0.;\n        \n        //SSS = pow(SSS*4.,4.);\n        //SSS= 0.1;\n        \n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        \n        float shad = softshadow( p, lDir, 0.01, 20., 2.);\n        \n        shad = min(shad,diff);\n        \n        vec3 colJello = vec3(0);\n        {\n            map(p);\n            albedo = jelloCol;\n            /*\n            albedo = mix(albedo,albedo*vec3(1.4,0.5,0.1),smoothstep(-2.,1.5,dot(normalize(uvJello),n)));\n            \n            albedo = mix(albedo,albedo*vec3(.7,0.6,0.4),smoothstep(1.,-2.,dot(normalize(uvJello),n)));\n            \n            colJello = albedo*lightCol;\n\n            colJello = mix(colJello, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            \n            colJello = mix((colJello + colJello*ambientCol)*0.5, colJello, ao);\n            colJello = mix((colJello + colJello*ambientCol)*0.5,colJello, shad);\n            */\n            \n            //map(p);\n            albedo = jelloCol;\n            \n            vec3 jellouv =  uvJello;\n            //jellouv =  uvJelloTube;\n            \n            //jellouv.yz*=rot(-length(jellouv.yz)*8. - 1.);\n            vec3 pjellouv = vec3(atan(jellouv.z,jellouv.y)/pi ,length(jellouv.yz), jellouv.x);\n            \n            \n            pjellouv.xy *= rot(0.5*pi);\n            float md = 1./4.;\n            \n            //pjellouv.x -= pjellouv.y/width*2./pi;\n            //pjellouv.x -= length(p.yz)*4./pi;\n            //pjellouv *= rot(-length(jellouv.x)*1. + length(jellouv.x)*4. + length(jellouv.xz )*2. );\n            \n            pjellouv.x -= jellouv.x/width/1.;\n            \n            \n            //pjellouv.x -= mod(jellouv.x,width*4.)/(width*4.);//*width*pi/0.25;\n            \n            \n            float id = floor(pjellouv.x/md );\n            float idb = floor(pjellouv.y/width*2.5);\n            \n            \n            if(length(jellouv.yz) < 0.4){\n                //id = 1.;\n            }\n            \n            float r = fract(sin(id*10.215)*14.25)*1.;\n            float rb = fract(sin(idb*20.215)*1.)*1.;\n            \n            albedo.xz *= rot(-r*0.24);\n            albedo += 1.;\n            albedo.xy *= rot(-r*0.2);\n            albedo.yz *= rot(-r*0.1);\n            //albedo.xz *= rot(-sin(rb*420.)*0.1);\n            albedo.xz *= rot(-0. + sign(sin(rb*20.))*0.1);\n            \n            albedo -= 1.;\n            albedo.xz *= rot(-sign(rb)*0.1);\n            \n            //albedo.xy *= rot(-sin(rb*20.)*0.15);\n            albedo = mix(albedo,sssJelloCol,SSS);\n            \n            colJello = albedo*lightCol;\n\n            colJello = mix(colJello, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            \n            colJello = mix((colJello + colJello*ambientCol)*0.5, colJello, ao);\n            colJello = mix((colJello + colJello*ambientCol)*0.5,colJello, shad);\n            \n        }\n        //ao = clamp(ao,0.,1.);\n        ao = aoo;\n        \n        vec3 colWall = vec3(0);\n        {\n        \n            albedo = wallCol;\n\n            colWall = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colWall = mix(colWall, reflalbedo, clamp(fres + spec,0.,1.)*0.2);\n\n            colWall = mix( (colWall + colWall*ambientCol)*0.3, colWall, shad);\n            \n            colWall = mix( (colWall + colWall*ambientCol)*0., colWall, ao);\n            \n        \n        }\n        vec3 colWallB = vec3(0);\n        {\n        \n            albedo = wallColB;\n\n            colWallB = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colWallB = mix(colWallB, reflalbedo, clamp(fres + spec,0.,1.)*0.2);\n\n            colWallB = mix( (colWallB + colWallB*ambientCol)*0.3, colWallB, shad);\n            \n            colWallB = mix( (colWallB + colWallB*ambientCol)*0., colWallB, ao);\n            \n        \n        }\n        vec3 colStikcs = vec3(0);\n        {\n        \n            albedo = vec3(0.1,0.2,0.2);\n\n            colStikcs = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colStikcs = mix(colStikcs, reflalbedo, clamp(fres + spec,0.,1.)*0.);\n\n            colStikcs = mix( (colStikcs + colStikcs*ambientCol)*0.3, colStikcs, shad);\n            \n            colStikcs = mix( (colStikcs + colStikcs*ambientCol)*0.5, colStikcs, ao);\n            \n        \n        }\n        \n        hitCol += colJello*float(floor(d.y) == ID_JELLO);\n        hitCol += colWall*float(d.y == ID_WALL_A);\n        hitCol += colWallB*float(d.y == ID_WALL_B);\n        hitCol += colStikcs*float(d.y == ID_STICKS);\n\n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    } \n    {\n        //col += ambientCol*atten;\n    }\n    \n    if(hit)\n        col += hitCol*atten;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat FXAAamt = 1.;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ID_JELLO 1.\n#define ID_WALL_A 4.\n#define ID_WALL_B 5.\n#define ID_STICKS 6.\n\n\n#define stepSz 0.36\n#define eps 0.001\n\n#define maxRefractions 3\n\n#define ambientCol vec3(0.3,0.2,0.5)\n#define wallCol vec3(0.1,0.4,0.25)*1.3\n#define wallColB vec3(0.15,0.4,0.3)*1.2\n#define lightCol vec3(0.95,0.85,0.9)\n\n#define jelloCol vec3(0.5,0.3,0.4)*1.4\n#define sssJelloCol vec3(0.9,0.3,0.3)*1.\n\n#define width 0.4\n\n#define pi acos(-1.)\n\n\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    ro += right*uv.x*sc;\n    ro += up*uv.y*sc;\n    return dir;\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.5;\n    const float lacunarity = 1.5;\n    const int octaves = 2;\n    \n    const float warp = 0.75;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat cyclicNoiseB(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.2;\n    const int octaves = 2;\n    \n    const float warp = .45;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttcWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 232, 232, 735]], "test": "untested"}
{"id": "3lcyWX", "name": "Airplane - Modelling Exercise", "author": "oneshade", "description": "Probably my best SDF model yet! I am planning on using it in a game or something else related.", "tags": ["sdf", "exercise", "modelling", "airplane"], "likes": 5, "viewed": 173, "published": 3, "date": "1609971406", "time_retrieved": "2024-07-30T19:46:29.706985", "image_code": "/*\nProbably my best SDF model yet!\nIf you have suggestions on how to improve the propeller SDF I would really like to\nknow. In case you are wondering it is a squashed Bernoulli lemniscate.\n\nThe MIT License\nCopyright  2020 Elijah Bevers\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n// Distance functions and SDF operators are from Inigo Quilez's distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nfloat sdBox2D(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdTrapezoid(in vec2 p, in float r1, in float r2, in float he) {\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2 - r1, 2.0 * he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0, p.x - ((p.y < 0.0) ? r1 : r2)), abs(p.y) - he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1 - p, k2) / dot(k2, k2), 0.0, 1.0);\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat BernoulliDE(in vec2 p, in vec2 scale) {\n    vec2 ps = p / scale;\n\n    float l = ps.x - 1.0;\n    float r = ps.x + 1.0;\n    float ys = ps.y * ps.y;\n\n    float bernoulli = sqrt(l * l + ys) * sqrt(r * r + ys) - 1.0;\n\n    vec2 pSqrS = p / (scale * scale);\n    float sInvX = 1.0 / scale.x;\n    float ls = pSqrS.x - sInvX;\n    float rs = pSqrS.x + sInvX;\n\n    float psSqrY = ps.y * ps.y;\n    float ld = sqrt(l * l + psSqrY);\n    float rd = sqrt(r * r + psSqrY);\n\n    float pdx = (ls * rd) / ld + (rs * ld) / rd;\n    float pdy = (rd / ld + ld / rd) * pSqrS.y;\n    float bernoulliGrad = sqrt(pdx * pdx + pdy * pdy);\n\n    return bernoulli / bernoulliGrad;\n}\n\nfloat mapScene(in vec3 p) {\n    float airplane = sdBox(p, vec3(0.4, 0.4, 2.8)) - 0.146;\n    airplane += smoothstep(-4.0, 10.0, p.z);\n\n    vec3 wp = p;\n    wp.yz *= mat2(0.99801615628, 0.06295833376, -0.06295833376, 0.99801615628);\n\n    float wing = sdTrapezoid(p.xz + vec2(0.0, 1.4), 2.85, 2.7, 0.3) - 0.25;\n    airplane = min(airplane, opExtrusion(wp.xzy - vec3(0.0, 0.0, 0.212), wing, 0.052) - 0.1);\n\n    vec3 tp = p - vec3(0.0, 0.0, 2.5);\n    float tail = sdTrapezoid(tp.xz, 0.85, 1.0, 0.475) - 0.1;\n    airplane = min(airplane, opExtrusion(tp.xzy, tail, 0.05) - 0.1);\n\n    tp.yz -= vec2(1.0, 0.25 * tp.y - 0.025);\n    tail = sdBox2D(tp.zy, vec2(0.3, 0.75)) - 0.1;\n    tail = 0.82 * tail + tp.y * 0.164;\n    airplane = min(airplane, opExtrusion(tp.zyx, tail, 0.05) - 0.1);\n\n    vec3 pp = p + vec3(0.0, 0.0, 3.0);\n\n    float r = iTime * 5.0;\n    float c = cos(r), s = sin(r);\n    pp.xy *= mat2(c, s, -s, c);\n\n    airplane = min(airplane, sdCylinder(pp.xzy, 0.05, 0.2));\n\n    float prop;\n    if (abs(pp.x) > 1.5 || abs(pp.y) > 1.05 || abs(pp.z) > 0.25) {\n        prop = sdBox(pp, vec3(1.4, 0.95, 0.2));\n    }\n\n    else {\n        pp = opTwist(pp, 0.4).xzy;\n        prop = opExtrusion(pp, BernoulliDE(pp.xy, vec2(1.0, 0.5)), 0.02) - 0.02;\n        prop *= 0.9;\n    }\n\n    airplane = min(airplane, prop);\n\n    vec3 sp = vec3(abs(wp.x) - 0.51, p.yz + vec2(1.0, 2.5));\n    sp.xy *= mat2(0.98877107793, 0.14943813247, -0.14943813247, 0.98877107793);\n\n    float struts = sdTrapezoid(sp.zy, 0.1, 0.2, 0.55) - 0.05;\n    airplane = min(airplane, opExtrusion(sp.yzx, struts, 0.03) - 0.025);\n\n    wp = sp + vec3(0.0, 0.5, 0.0);\n    float wheels = sdCylinder(wp.yxz, 0.1, 0.24) - 0.05;\n    airplane = min(airplane, wheels);\n\n    return airplane;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float c1 = cos(iTime), s1 = sin(iTime);\n    float c2 = cos(0.25), s2 = sin(0.25);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        p.y += 0.5;\n        p.xz *= mat2(c1, -s1, s1, c1);\n        p.yz *= mat2(c2, s2, -s2, c2);\n\n        float d = mapScene(p / 1.5) * 1.5;\n        if (d < 0.001) {\n            vec3 n = getNormal(p / 1.5) * 1.2;\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(c2, -s2, s2, c2);\n            n.xz *= mat2(c1, s1, -s1, c1);\n\n            fragColor.rg += max(0.2, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyWX.jpg", "access": "api", "license": "mit", "functions": [[1263, 1403, 1457, 1532, 1628], [1630, 1630, 1667, 1667, 1789], [1791, 1791, 1828, 1828, 1913], [1915, 1915, 1984, 1984, 2340], [2342, 2342, 2377, 2377, 2472], [2474, 2474, 2527, 2527, 2643], [2645, 2645, 2690, 2690, 3298], [3300, 3300, 3327, 3327, 5034], [5036, 5036, 5063, 5063, 5370], [5372, 5372, 5427, 5427, 6311]], "test": "untested"}
{"id": "wtdyW2", "name": "kaleidoscope of noise patterns", "author": "AI", "description": "We use polar coordinates to create such symmetric patterns\nChange the constant parameters of the program to see other variants.", "tags": ["2d", "noise", "kaleidoscope", "pattern", "polar", "bilinear", "generativeart", "creativecoding"], "likes": 3, "viewed": 294, "published": 3, "date": "1609961394", "time_retrieved": "2024-07-30T19:46:30.530783", "image_code": "const float PI = 3.141592658;\nconst float TWOPI = 2.0 * PI;\n\n// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv =fragCoord.xy/ iResolution.xy;\n  //from Cartesian to polar coordinates\n  float scale=3.;\n  uv=fract(scale*uv)-.5;\n  float radius = length(uv);\n  float angle = atan(uv.y, uv.x);\n  //change Nsections using horizontal movement of mouse\n    float Nsections=20.;//-15.*iMouse.x/iResolution.x;\n  //create Nsections which are identical\n  float angleM = mod(angle, TWOPI/Nsections);\n  //make each section symmetric along its bisector\n  angleM = abs(angleM -PI/Nsections);\n  //back to Cartesian coordinates\n  uv = radius*vec2(cos(angleM),sin(angleM));\n  uv=sin(uv+.04*iTime);\n  vec3 color=vec3(bilinearNoise(100.*uv),bilinearNoise(75.*uv),bilinearNoise(50.*uv));\n  fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 118, 143, 143, 261], [263, 295, 329, 329, 693], [696, 696, 752, 752, 1448]], "test": "untested"}
{"id": "Wlcczs", "name": "3D SDF Designer Tool", "author": "oneshade", "description": "Tool for designing 3D SDFs.", "tags": ["3d", "sdf", "modelling", "tool", "design"], "likes": 3, "viewed": 214, "published": 3, "date": "1609959905", "time_retrieved": "2024-07-30T19:46:31.369540", "image_code": "/*\nI originally designed this for myself but it turned out so well I decided to share it :)\nMouse rotates the camera and the arrow keys move it.\nSettings are in common (at the top).\n*/\n\n// Build your SDF here\nfloat mapScene(in vec3 p) {\n    float innerCup = sdCylinder(p - vec3(0.0, 0.1, 0.0), 0.99, 0.99);\n    float cup = opSmoothSubtraction(sdCylinder(p, 1.0, 1.0), innerCup, 0.05) - 0.05;\n    float handle = sdTorus(p.xzy * vec3(1.4, 1.5, 1.0) - vec3(1.8, 0.0, 0.0), vec2(0.75, 0.2)) - 0.01;\n    cup = opSmoothUnion(cup, opSmoothSubtraction(handle, innerCup, 0.1), 0.2);\n    return cup * 0.5;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    vec3 rd = normalize(camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n\n    float t = MIN_TRACE_DIST;\n    for (int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < MIN_HIT_DIST) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(LIGHT_DIRECTION);\n\n            fragColor.rgb += 1.0;\n            #ifdef SHOW_NORMALS\n            fragColor.rgb = n;\n            #endif\n\n            #ifdef SHOW_DEPTH\n            fragColor.rgb *= (p.z - Z_FAR) / (Z_NEAR - Z_FAR);\n            #endif\n\n            #ifdef LIGHTING\n            fragColor.rgb *= max(0.2, dot(n, l));\n            #endif\n\n            break;\n        }\n\n        #ifdef SHOW_AXES\n        float xAxis = sdVerticalCapsule(p.yxz, 5.0, 0.1);\n        float yAxis = sdVerticalCapsule(p, 5.0, 0.1);\n        float zAxis = sdVerticalCapsule(p.xzy, 5.0, 0.1);\n        if (xAxis < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n\n        if (yAxis < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(0.0, 1.0, 0.0);\n            break;\n        }\n\n        if (zAxis < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(0.0, 0.0, 1.0);\n            break;\n        }\n\n        d = min(d, min(xAxis, min(yAxis, zAxis)));\n        #endif\n\n        #ifdef SHOW_GROUNDPLANE\n        float groundplane = p.y;\n        if (groundplane < MIN_HIT_DIST) {\n            fragColor.rgb = vec3(0.6, 0.4, 0.0);\n\n            #ifdef SHOW_DISTANCE_FIELD\n            fragColor.rgb *= 0.5 + 0.5 * sin(mapScene(vec3(p.x, 0.0, p.z)) * 100.0);\n            #endif\n\n            break;\n        }\n\n        d = min(d, groundplane);\n        #endif\n\n        if (t > MAX_TRACE_DIST) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Scene settings\nconst vec3 LIGHT_DIRECTION = vec3(-1.0, 1.0, 1.0);\n#define LIGHTING\n\n#define SHOW_AXES\n//#define SHOW_GROUNDPLANE\n//#define SHOW_DISTANCE_FIELD\n\n//#define SHOW_NORMALS\n#define SHOW_DEPTH\n#define Z_NEAR 5.0\n#define Z_FAR -5.0\n\n// Raymarching settings\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MIN_TRACE_DIST = 0.0;\nconst float MAX_TRACE_DIST = 50.0;\nconst float MIN_HIT_DIST = 0.001;\nconst int MAX_STEPS = 150;\n\n// Math constants\nconst float TWO_PI = 6.2832;\n\n// Interface settings\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 0.5;\n\n// Data fetching\nconst ivec2  VIEW_POSITION_ADDR = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\n\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int KEY_LEFT = 37;\n\n#define getViewPosition() texelFetch(iChannel0, VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection() texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define keyUpPressed() texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5\n#define keyDownPressed() texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5\n#define keyRightPressed() texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x > 0.5\n#define keyLeftPressed() texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x > 0.5\n\n// Helper functions\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),\n                vec3(s.x *  c.y, s.y, -c.x *  c.y));\n}\n\n/*\nLots and lots of stuff from Inigo Quilez's distance functions article:\nhttps://iquilezles.org/articles/distfunctions\n*/\n\n// SDFs (for more, I recommend Inigo Quilez's distance functions article: https://iquilezles.org/articles/distfunctions)\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x);\n    float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n    return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat sdLink(in vec3 p, in float le, in float r1, in float r2) {\n    vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n    return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat sdCone(in vec3 p, in vec2 c, in float h) {\n    // [Inigo Quilez]\n    // c is the sin/cos of the angle, h is height\n    // Alternatively pass q instead of (c,h),\n    // which is the point at the base in 2D\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdPlane(in vec3 p, in vec3 n, in float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdTriPrism(in vec3 p, in vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdVerticalCapsule(in vec3 p, in float h, in float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSolidAngle(in vec3 p, in vec2 c, in float ra) {\n    // [Inigo Quilez]\n    // c is the sin/cos of the angle\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q, c), 0.0, ra));\n    return max(l, m * sign(c.y * q.x - c.x * q.y));\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\n// Distance function operators:\nvec3 opElongate(in vec3 p, in vec3 h) {\n    return p - clamp(p, -h, h);\n}\n\nfloat opRound(in float d, in float r) {\n    return d - r;\n}\n\nfloat opLayer(in float d, in float thickness) {\n    return abs(d) - thickness;\n}\n\nfloat opExtrusion(in vec3 p, in float d, in float h) {\n    // d is the distance to the 2D shape using the x and y components of p\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nvec2 opRevolution(in vec3 p, in float o) {\n    return vec2(length(p.xz) - o, p.y);\n}\n\n// Boolean distance function operators\nfloat opUnion(in float a, in float b) {\n    return min(a, b);\n}\n\nfloat opSubtraction(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opIntersection(in float a, in float b) {\n    return max(a, b);\n}\n\n// Smooth distance operators:\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smax(in float a, in float b, in float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat opSmoothUnion(in float a, in float b, in float k) {\n    return smin(a, b, k);\n}\n\nfloat opSmoothSubtraction(in float a, in float b, in float k) {\n    return smax(a, -b, k);\n}\n\nfloat opSmoothIntersection(in float a, in float b, in float k) {\n    return smax(a, b, k);\n}\n\n// Transformations:\nvec3 opTransform(in vec3 p, in mat3 t) {\n    return inverse(t) * p;\n}\n\nfloat opDecompressScale(in float d, in vec3 s) {\n    return d * max(s.x, max(s.y, s.z));\n}\n\nfloat opSymmetry1D(in float x) {\n    return abs(x);\n}\n\nvec2 opSymmetry2D(in vec2 x) {\n    return abs(x);\n}\n\nvec3 opSymmetry3D(in vec3 x) {\n    return abs(x);\n}\n\nvec3 opRep(in vec3 p, in vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nvec3 opRepLim(in vec3 p, in float c, in vec3 l) {\n    return p - c * clamp(round(p / c), -l, l);\n}\n\n// Distance field distortions and displacements\nfloat opDisplace(in float d, in float disp) {\n    return d - disp;\n}\n\nvec3 opTwist(in vec3 p, in float t) {\n    float c = cos(t * p.y);\n    float s = sin(t * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nvec3 opBend(in vec3 p, in float b) {\n    float c = cos(b * p.x);\n    float s = sin(b * p.x);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xy, p.z);\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 address = ivec2(fragCoord);\n    if (address == VIEW_POSITION_ADDR) {\n        fragColor = vec4(3.0, 3.0, 5.0, 1.0);\n    }\n\n    if (address == VIEW_DIRECTION_ADDR) {\n        fragColor = vec4(-0.5, -0.5, 0.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(getViewPosition(), 1.0);\n            mat3 camera = getCamera(getViewDirection());\n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = getViewDirection();\n            if (iMouse.z > 0.0) {\n                viewDirection = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            }\n\n            fragColor = vec4(viewDirection, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlcczs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 209, 236, 236, 597], [599, 599, 626, 626, 909], [911, 911, 966, 966, 2913]], "test": "untested"}
{"id": "3ldyD2", "name": "- twist -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sdf", "twist", "spiky"], "likes": 12, "viewed": 491, "published": 3, "date": "1609948629", "time_retrieved": "2024-07-30T19:46:32.300052", "image_code": "#define EPS 0.001\n#define MAX_DIST 20.\n\nfloat sdTorus(vec3 pos) {\n  \treturn length(vec2(length(pos.xz) - 0.85, pos.y)) - 0.2;  \n}\n\nvec3 twistX(vec3 p, float k) {\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    return vec3(mat2(c, -s, s, c) * p.yz, p.x);\n}\n\nfloat calcDist(vec3 pos) {\n    float t = iTime / 1.5;\n    float d1 = sdTorus(0.3 * twistX(pos, 2.5 * cos(t)));\n    float d2 = sdTorus(0.3 * twistX(pos.yxz, 5.5 * sin(t)));\n\n    float morphK = 2.5;\n    return -log(exp(-morphK * d1) + exp(-morphK * d2)) / morphK;\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD) {\n    float distFromO = 0.;\n    for (int i = 0; i < 100; ++i) {\n\t    float dS = calcDist(rayO + rayD * distFromO);\n        distFromO += dS;\n        if (dS < EPS || distFromO > MAX_DIST) break;\n    }\n    \n    return distFromO;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float d = calcDist(pos);\n\treturn normalize(vec3(d - calcDist(pos - vec3(EPS, 0,  0 )),\n\t\t\t\t\t  \t  d - calcDist(pos - vec3( 0, EPS, 0 )),\n\t\t\t\t\t   \t  d - calcDist(pos - vec3( 0,  0, EPS))));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n\tvec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    vec3 ambient = vec3(0.13);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.0));\n    \n    return lightCol * (ambient + clamp(diffuse, 0.2, 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0, 0, -10);\n\tvec3 camDir = normalize(vec3(xy, 1.));\n    \n    float dist = rayMarch(camPos, camDir);\n    \n    vec3 col = vec3(0.26, 0.28, 0.3);\n    \n    if (dist < MAX_DIST) { \n        col = calcLight(camPos + dist * camDir, \n                        vec3(5, 0, -15), \n                        vec3(0.89, 0.95, 1.), \n                        camDir);\n    } \n    \n\tfragColor = vec4(pow(col, vec3(1.4)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 65, 65, 129], [131, 131, 161, 161, 267], [269, 269, 295, 295, 532], [534, 534, 572, 572, 798], [800, 800, 827, 827, 1021], [1023, 1023, 1096, 1096, 1347], [1349, 1349, 1404, 1404, 1925]], "test": "untested"}
{"id": "3tdcDj", "name": "Triangle reaction diffusion", "author": "illus0r", "description": "Triangle reaction diffusion", "tags": ["reactiondiffusion"], "likes": 1, "viewed": 361, "published": 3, "date": "1609931559", "time_retrieved": "2024-07-30T19:46:33.085951", "image_code": "//IMG\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec4 tex = texture(iChannel0,uv);\n    o *= 0.,o+=tex.y/tex.x;\n    o = texture(iChannel1,uv.xxy+texture(iChannel0,uv).zyx);\n    \n    //uv=symmetry(uv,0.);\n    //o = vec4(uv,uv);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON\n#define t(uv) texture(ch, uv).xy\n#define rnd(x) fract(9999.*sin(9999.*x))\n#define fl(x) floor(x*10.)/10.\n#define R (5.)\n#define s(x) smoothstep(0.,5.,x)\n\n#define F (.06 - sin(uv.y*4.)*.06*s(t))\n#define K (.05 + sin(uv.y*4.)*.02*s(t))\n//#define K (.06)\n#define Da 1.*s(t)\n#define Db .4*s(t)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nvec2 d2p(vec2 d){return vec2(atan(d.x,d.y),length(d));}\nvec2 p2d(vec2 p){return p.y*vec2(sin(p.x),cos(p.x));}\nvec2 snowflakeSymmetry(vec2 p, float rays){\n\tvec2 ar = d2p(p);\n\tfloat astep = 2. * 3.1415 / rays;\n\tfloat a = ar.x, r = ar.y;\n\ta = mod(a, astep);\n\ta -= astep / 2.;\n\ta = abs(a);\n\tp = p2d(vec2(a, r));\t\n\treturn p;\n}\n\nvec2 symmetry(vec2 uv, float t) {\n    //float row = floor(uv.x*2.);\n    //uv=fract(uv*2.)/2.;\n    uv-=.5;\n    uv=snowflakeSymmetry(uv, 1.5);\n    uv*=rot(3.1415*2.);\n    uv+=.5;\n    //if(uv.y>.7)return vec2(0.);\n    return uv;\n}\n\nvec4 reaction(vec2 FC, vec2 r, sampler2D ch, float t, vec4 m)\n{\n    vec2 uv=FC.xy/r,_,px=1./r,v=t(uv),dx,dy,d,delta,dir;\n    \n    // flow\n    //uv=((uv-.5)*rot(.05*length(uv-.5))+.5);\n    \n    // \n    _=vec2(R+R*rnd(uv.x+.01*uv.y+t),0.);\n    \n    uv=symmetry(uv, t);\n    \n    dx=(-v+(t(uv+px*_   )+t(uv+px*-_   ))/2.)/2.;\n    dy=(-v+(t(uv+px*_.yx)+t(uv+px*-_.yx))/2.)/2.;\n    \n    //dir=vec2(1.,0.)*rot(t/10.)*.5+.5;\n    d=(dx+dy)/2.;\n\n    delta.x=Da*d.x-v.x*v.y*v.y+F*(1.-v.x);\n    delta.y=Db*d.y+v.x*v.y*v.y-(K+F)*v.y;\n    vec4 o=vec4(v+delta,1.,1.);\n\n    if(t<.1)o*=0.,o+=1.-step(.05,length(uv-.5));//o+=rnd(fl(uv.x)+.01*fl(uv.y));\n    \n    return o;\n}", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7, 7, 49, 49, 265]], "test": "untested"}
{"id": "WltcDj", "name": "Triangle cut sampling", "author": "webanck", "description": "Implementation of the triangle cut method for more closed-form importance sampling by Eric Heitz @Unity:\nhttps://eheitzresearch.wordpress.com/792-2/", "tags": ["sampling"], "likes": 1, "viewed": 297, "published": 3, "date": "1609930702", "time_retrieved": "2024-07-30T19:46:34.033418", "image_code": "/*\nShader by Antoine Webanck:\nhttps://webanck.fr/\n\nImplementation of the triangle cut method for more closed-form importance sampling by Eric Heitz @Unity:\nhttps://eheitzresearch.wordpress.com/792-2/\n\nInteractive keyboard controls:\n1-4: (disabled) toggle test cases with:\n  1: simple functions\n  2: truncated disk\n  4: torus\n  3: polar shape\nA: swap between 2D/alternative views depending on the test case\nSPACE: classical inverse CDF mapping\nD: (disabled) swap between standard/UV debug\nO: (disabled) swap between stretched orthogonal/orthonormal\nS: (disabled) swap between UV chessboard/UV samples (with distorsions in alternative views)\n*/\n\n/////////////////////////\n//INTERACTIVITY SWITCHS//\n/////////////////////////\n/*\nUncomment if needed but beware, INTERACTIVE_CASE is hard for Angle crosspiling on Windows!\nAs a result, the driver may crash trying to compile the shader.\nPrefer native OpenGL when possible, see here for more infos:\nhttps://shadertoyunofficial.wordpress.com/2016/07/22/compatibility-issues-in-shadertoy-webglsl/\n*/\n//#define INTERACTIVE_CASE\n#define INTERACTIVE_ALTERNATE_VISUALISATION\n#define INTERACTIVE_TRIANGLE_CUT\n//#define INTERACTIVE_DEBUG_UV_FIXPOINT\n//#define INTERACTIVE_ORTHONORMAL\n//#define INTERACTIVE_VISUALIZE_SAMPLES\n\n\n/////////////\n//CONSTANTS//\n/////////////\n//avoiding compiler unrolling nightmare\n//#define ZEROu uint(min(0, iFrame))\nconst uint ZEROu = 0u;\n\nconst vec3 WHITE = vec3(1.);\nconst vec3 BLACK = vec3(0.);\nconst vec3 GREY = vec3(0.5);\nconst vec3 RED = vec3(1., 0., 0.);\nconst vec3 GREEN = vec3(0., 1., 0.);\nconst vec3 BLUE = vec3(0., 0., 1.);\n\nconst float PI = 3.1415926535897932384626433832795;\n\n//Functions types.\nconst uint CONSTANT = 0u;\nconst uint LINEAR = 1u;\nconst uint QUADRATIC = 2u;\nconst uint DISK_AREA = 10u;\nconst uint DISK_AREA_APPROXIMATION = 11u;\nconst uint TORUS_AREA = 20u;\nconst uint TORUS_AREA_APPROXIMATION = 21u;\nconst uint POLAR_SHAPE_AREA = 30u;\nconst uint POLAR_SHAPE_AREA_APPROXIMATION = 31u;\n\n//Test cases types.\nconst uint SIMPLE_FUNCTIONS_CASE = 0u;\nconst uint TRUNCATED_DISK_CASE = 1u;\nconst uint TORUS_SURFACE_CASE = 2u;\nconst uint POLAR_SHAPE_CASE = 3u;\n\n\n//////////////\n//PARAMETERS//\n//////////////\n#ifndef INTERACTIVE_CASE\nconst\n#endif\nuint CASE = TORUS_SURFACE_CASE;\n\n#ifndef INTERACTIVE_ALTERNATE_VISUALISATION\nconst\n#endif\nbool ALTERNATIVE_VISUALISATION = false;\n\n#ifndef INTERACTIVE_TRIANGLE_CUT\nconst\n#endif\nbool TRIANGLE_CUT = true;\n\n#ifndef INTERACTIVE_ORTHONORMAL\nconst\n#endif\nbool ORTHONORMAL = false;\n\n#ifndef INTERACTIVE_DEBUG_UV_FIXPOINT\nconst\n#endif\nbool DEBUG_UV_FIXPOINT = false;\n\n#ifndef INTERACTIVE_VISUALIZE_SAMPLES\nconst\n#endif\nbool VISUALIZE_SAMPLES = false;\n\nconst uint GRID_SUBDIVISIONS = 8u;\nconst uint SAMPLES_NUMBER = 100u;\nconst float SAMPLES_RADIUS = 3.;\nconst uint SEARCH_SAMPLES = 25u;\n\nuint caseFunctions(const bool approximation)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE: return (!approximation ? QUADRATIC : LINEAR);\n\t\tcase TRUNCATED_DISK_CASE: return (!approximation ? DISK_AREA : DISK_AREA_APPROXIMATION);\n\t\tcase TORUS_SURFACE_CASE: return (!approximation ? TORUS_AREA : TORUS_AREA_APPROXIMATION);\n\t\tcase POLAR_SHAPE_CASE: return (!approximation ? POLAR_SHAPE_AREA : POLAR_SHAPE_AREA_APPROXIMATION);\n\t}\n}\nuint caseFunction()\n{\n\treturn caseFunctions(false);\n}\nuint caseApproximateFunction()\n{\n\tconst bool APPROXIMATION = true;\n\treturn caseFunctions(APPROXIMATION);\n}\n\n\n///////////\n//SAMPLES//\n///////////\nvec3 randSeed = vec3(0.);\n//Hash functions by David Hoskins\nfloat hash13(vec3 p3)\n{\n\t#define HASHSCALE1 .1031\n\tp3  = fract(p3 * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\nfloat uniformRand()\n{\n\trandSeed.y+=1.4675;\n\treturn hash13(randSeed);\n}\nvec2 getNextSample()\n{\n\tvec2 s;\n\ts.x = uniformRand();\n\ts.y = uniformRand();\n\treturn s;\n}\n\n\n//////////////\n//CASES WORK//\n//////////////\n\n//Simple Functions.\nconst bool DECREASING = true;\n\n//Truncated disk.\nconst float THETA_0 = 3./4.*PI;\nfloat diskArea(float theta)\n{\n\treturn theta - cos(theta)*sin(theta);\n}\nfloat diskAreaDerivative(float theta)\n{\n\treturn 2.*sin(theta)*sin(theta);\n}\nfloat diskAreaDerivativeDerivative(float theta)\n{\n\treturn 4.*sin(theta)*cos(theta);\n}\nfloat diskAreaApproximation(float theta)\n{\n\tif(theta <= 0.5*PI)\n\t\treturn theta*theta*theta/3.;\n\treturn PI*PI*PI/12. - (PI - theta)*(PI - theta)*(PI - theta)/3.;\n}\nfloat diskAreaApproximationDerivative(float theta)\n{\n\tif(theta <= 0.5*PI)\n\t\treturn theta*theta;\n\treturn (PI - theta)*(PI - theta);\n}\n\n//Torus surface.\nconst float TORUS_SKELETON_RADIUS = 1.;\nconst float TORUS_CIRCLE_RADIUS = 0.5;\nfloat torusAreaApproximationDerivative(const float theta)\n{\n\tfloat x = theta/PI;\n\tfloat cpr = TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS;\n\tfloat cmr = TORUS_SKELETON_RADIUS - TORUS_CIRCLE_RADIUS;\n\treturn mix(cpr, cmr, x)/(TORUS_SKELETON_RADIUS*PI);\n}\nfloat torusAreaApproximation(const float theta)\n{\n\tfloat x = theta/PI;\n\tfloat cpr = TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS;\n\treturn 1./(TORUS_SKELETON_RADIUS) * (cpr*x - TORUS_CIRCLE_RADIUS*x*x);\n}\nfloat sdTorus(const vec3 p, const vec2 t) //cf https://iquilezles.org/articles/distfunctions\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\nbool sphereTraceTorus(const vec3 ro, const vec3 rd, out vec3 intersection)\n{\n\tintersection = vec3(0.);\n\tfloat t = 0.;\n\tfor(uint i = ZEROu; i < 100u; i++)\n\t{\n\t\tintersection = ro + t*rd;\n\t\tfloat sd = sdTorus(intersection, vec2(TORUS_SKELETON_RADIUS, TORUS_CIRCLE_RADIUS));\n\t\tif(sd <= 0.001) return true;\n\t\tt += sd;\n\t}\n\treturn false;\n}\n\n//Polar shape.\nfloat polarShapeRadius(const float theta)\n{\n\treturn 1. + cos(8.*theta)/8. + cos(16.*theta)/16.;\n}\nfloat polarShapeRadiusDerivative(const float theta)\n{\n\treturn -sin(8.*theta) - sin(16.*theta);\t\n}\nfloat polarShapeSquaredRadius(const float theta)\n{\n\tfloat c8 = cos(8.*theta);\n\tfloat c16 = cos(16.*theta);\n\treturn (256. + 64.*c8 + 32.*c16 + 4.*c8*c16 + 4.*c8*c8 + c16*c16)/256.;\n}\nfloat polarShapeDensity(const float theta)\n{\n\treturn 0.5 * polarShapeSquaredRadius(theta);\n}\nfloat polarShapeDensityDerivative(const float theta)\n{\n\treturn polarShapeRadiusDerivative(theta) * polarShapeRadius(theta);\n}\nfloat polarShapeArea(const float theta)\n{\n\tfloat s8 = sin(8.*theta);\n\tfloat s16 = sin(16.*theta);\n\tfloat s24 = sin(24.*theta);\n\tfloat s32 = sin(32.*theta);\n\treturn 0.5 * (49632.*theta + 1584.*s8 + 408.*s16 + 16.*s24 + 3.*s32)/49152.;\n}\n\n\n//////////////////////\n//FUNCTIONS WRAPPERS//\n//////////////////////\nfloat pdfMax(const uint type)\n{\n\tswitch(type)\n\t{\n\t\tcase CONSTANT: return 1.;\n\t\tcase LINEAR: return 2.;\n\t\tcase QUADRATIC: return 3.;\n\t\t\n\t\tcase DISK_AREA: return THETA_0 * 2./diskArea(THETA_0);\n\t\tcase DISK_AREA_APPROXIMATION: return THETA_0;\n\t\t\n\t\tcase TORUS_AREA: return PI * torusAreaApproximationDerivative(0.);\n\t\tcase TORUS_AREA_APPROXIMATION: return PI * torusAreaApproximationDerivative(0.);\n\t\t\n\t\tcase POLAR_SHAPE_AREA: return 2.*PI / polarShapeArea(2.*PI);\n\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return 1.;\n\t}\n\t\n\treturn 1.;\n}\n\nfloat pdf(const float x, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 1.;\n\t\t\t\tcase LINEAR: return 2.*(1. - x);\n\t\t\t\tcase QUADRATIC: return 3.*(1. - x)*(1. - x);\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 1.;\n\t\t\t\tcase LINEAR: return 2.*x;\n\t\t\t\tcase QUADRATIC: return 3.*x*x;\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tfloat stretch = THETA_0;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase DISK_AREA: return stretch * diskAreaDerivative(theta)/diskArea(THETA_0);\n\t\t\t\tcase DISK_AREA_APPROXIMATION: return stretch * diskAreaApproximationDerivative(theta)/diskAreaApproximation(THETA_0);\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tfloat stretch = PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase TORUS_AREA: return stretch * (TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS*cos(theta))/(TORUS_SKELETON_RADIUS*PI);\n\t\t\t\tcase TORUS_AREA_APPROXIMATION: return stretch * torusAreaApproximationDerivative(theta)/torusAreaApproximation(PI);\n\t\t\t}\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tfloat stretch = 2.*PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase POLAR_SHAPE_AREA: return stretch * polarShapeDensity(theta)/polarShapeArea(2.*PI);\n\t\t\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return 1.;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0.;\n}\nfloat derivative(const float x, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 0.;\n\t\t\t\tcase LINEAR: return -2.;\n\t\t\t\tcase QUADRATIC: return -6.*(1. - x);\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return 0.;\n\t\t\t\tcase LINEAR: return 2.;\n\t\t\t\tcase QUADRATIC: return 6.*x;\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tfloat stretch = THETA_0;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase DISK_AREA: return stretch*stretch * diskAreaDerivativeDerivative(theta)/diskArea(THETA_0);\n\t\t\t\t//case DISK_AREA_APPROXIMATION:\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tfloat stretch = PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase TORUS_AREA: return stretch*stretch * -TORUS_CIRCLE_RADIUS*sin(theta)/(TORUS_SKELETON_RADIUS*PI);\n\t\t\t\t//case TORUS_AREA_APPROXIMATION:\n\t\t\t}\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tfloat stretch = 2.*PI;\n\t\t\tfloat theta = x * stretch;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase POLAR_SHAPE_AREA: return stretch*stretch * polarShapeDensityDerivative(theta)/polarShapeArea(2.*PI);\n\t\t\t\t//case POLAR_SHAPE_AREA_APPROXIMATION:\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0.;\n}\nfloat cdf(const float x, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return x;\n\t\t\t\tcase LINEAR: return x*(2. - x); //2.*x - x*x\n\t\t\t\tcase QUADRATIC: return x*(3. + x*(-3. + x)); //3.*x - 3.*x*x + x*x*x;\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return x;\n\t\t\t\tcase LINEAR: return x*x;\n\t\t\t\tcase QUADRATIC: return x*x*x;\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tfloat theta = x * THETA_0;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase DISK_AREA: return diskArea(theta)/diskArea(THETA_0);\n\t\t\t\tcase DISK_AREA_APPROXIMATION: return diskAreaApproximation(theta)/diskAreaApproximation(THETA_0);\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tfloat theta = x * PI;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase TORUS_AREA: return (TORUS_SKELETON_RADIUS*theta + TORUS_CIRCLE_RADIUS*sin(theta))/(TORUS_SKELETON_RADIUS*PI);\n\t\t\t\tcase TORUS_AREA_APPROXIMATION: return torusAreaApproximation(theta);\n\t\t\t}\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tfloat theta = x * 2.*PI;\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase POLAR_SHAPE_AREA: return polarShapeArea(theta)/polarShapeArea(2.*PI);\n\t\t\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return x;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0.;\n}\nfloat inverse_cdf(const float u, const uint type)\n{\n\tswitch(CASE)\n\t{\n\t\tcase SIMPLE_FUNCTIONS_CASE:\n\t\t\tif(DECREASING) switch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return u;\n\t\t\t\tcase LINEAR: return 1. - sqrt(1. - u);\n\t\t\t\tcase QUADRATIC: return 1. - pow(1. - u, 1./3.);\n\t\t\t}\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\tcase CONSTANT: return u;\n\t\t\t\tcase LINEAR: return sqrt(u);\n\t\t\t\tcase QUADRATIC: return pow(u, 1./3.);\n\t\t\t}\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\t//case DISK_AREA:\n\t\t\t\tcase DISK_AREA_APPROXIMATION:\n\t\t\t\t{\n\t\t\t\t\tfloat theta;\n\t\t\t\t\tif(u < diskAreaApproximation(0.5*PI)/diskAreaApproximation(THETA_0))\n\t\t\t\t\t\ttheta = pow(3.*u*diskAreaApproximation(THETA_0), 1./3.);\n\t\t\t\t\telse\n\t\t\t\t\t\ttheta = PI - pow(0.25*PI*PI*PI - 3.*u*diskAreaApproximation(THETA_0), 1./3.);\n\t\t\t\t\treturn theta/THETA_0;\n\t\t\t\t}\n\t\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tswitch(type)\n\t\t\t{\n\t\t\t\t//case POLAR_SHAPE_AREA:\n\t\t\t\tcase POLAR_SHAPE_AREA_APPROXIMATION: return u;\n\t\t\t}\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\tswitch(type)\n\t\t{\n\t\t\t//case TORUS_AREA:\n\t\t\tcase TORUS_AREA_APPROXIMATION:\n\t\t\t{\n\t\t\t\tfloat cpr = TORUS_SKELETON_RADIUS + TORUS_CIRCLE_RADIUS;\n\t\t\t\tfloat cmr = TORUS_SKELETON_RADIUS - TORUS_CIRCLE_RADIUS;\n\t\t\t\treturn -0.5/TORUS_CIRCLE_RADIUS * (sqrt(cpr*cpr + u*(cmr*cmr - cpr*cpr)) - cpr);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Binary search fallback.\n\tvec2 I = vec2(0., 1.);\n\tfor(uint i = ZEROu; i < SEARCH_SAMPLES; i++)\n\t{\n\t\tfloat x = 0.5 *(I[0] + I[1]);\n\t\tfloat uCandidate = cdf(x, type);\n\t\tif(uCandidate < u)\n\t\t\tI = vec2(x, I[1]);\n\t\telse\n\t\t\tI = vec2(I[0], x);\n\n\t\tif(I[1] - I[0] < 0.00001) break;\n\t}\n\n\treturn 0.5 *(I[0] + I[1]);\n}\n\n\n////////////////\n//TRIANGLE CUT//\n////////////////\n\n//Wrappers.\nfloat f(const float x)\n{\n\treturn pdf(x, caseFunction());\n}\nfloat F(const float x)\n{\n\treturn cdf(x, caseFunction());\n}\nfloat iF(const float u)\n{\n\treturn inverse_cdf(u, caseFunction());\n}\nfloat df(const float x)\n{\n\treturn derivative(x, caseFunction());\n}\nfloat g(const float x)\n{\n\treturn pdf(x, caseApproximateFunction());\n}\nfloat G(const float x)\n{\n\treturn cdf(x, caseApproximateFunction());\n}\nfloat iG(const float u)\n{\n\treturn inverse_cdf(u, caseApproximateFunction());\n}\n\n//Classical CDF parameterization.\nvec2 inverse_cdf_param(const vec2 uv)\n{\n\tfloat x = iF(uv[0]);\n\treturn vec2(x, uv[1]*f(x)); \n}\nvec2 cdf_param(const vec2 xy)\n{\n\treturn vec2(F(xy[0]), xy[1]/f(xy[0]));\n}\n\t\n//Triangle cut parameterization.\nvec2 trianglecut_param(const vec2 uv, out bool error)\n{\n\t// sample x_a with approximate PDF, Eq. (7)\n\tfloat x_a = iG(uv[0]);\n\t// eval functions at x_a\n\tfloat f_x_a = f(x_a);\n\tfloat F_x_a = F(x_a);\n\tfloat fprime_x_a = df(x_a);\n\tfloat y_a = f_x_a;\n\tfloat g_x_a = g(x_a);\n\t// compute x_b with triangle cut, Eq. (9)\n\tfloat x_b = x_a + 2.*(uv[0] - F_x_a)/f_x_a;\n\tfloat y_b = 0.;\n\t// compute infinitesimal thicknesses, Eq. (19) and (20)\n\tfloat w_a = f_x_a*f_x_a + 2.*(uv[0] - F_x_a)*fprime_x_a;\n\tfloat w_b = 2.*f_x_a*g_x_a - w_a;\n\t// sample thickness density, Eq. (22)\n\tfloat t = uv[1] * (w_a + w_b)/(w_b + sqrt(mix(w_b*w_b, w_a*w_a, uv[1]))); //t = iW(v)\n\t// interpolate (x_a,y_a) and (x_b,y_b), Eq. (23)\n\tvec2 xy = mix(vec2(x_b, y_b), vec2(x_a, y_a), t);\n\t\n\t//checking for conditions 1 and 2, Eq. (24) and (25)\n\tif(xy[1] > f(xy[0]) || w_a < 0. || w_b < 0.)\n\t{\n\t\terror = true;\n\t\treturn vec2(0.);\n\t}\n\terror = false;\n\treturn xy;\n}\n\n//Reversing the triangle cut parameterization.\nfloat eval_u_orientedArea(const vec2 xy, const float u)\n{\n\tconst float v = 1.;\n\t\t\n\t// sample x_a with approximate PDF, Eq. (7)\n\tfloat x_a = iG(u);\n\t// eval functions at x_a\n\tfloat f_x_a = f(x_a);\n\tfloat F_x_a = F(x_a);\n\t//float fprime_x_a = df(x_a);\n\tfloat y_a = f_x_a;\n\t//float g_x_a = g(x_a);\n\t// compute x_b with triangle cut, Eq. (9)\n\tfloat x_b = x_a + 2. * (u - F_x_a)/f_x_a;\n\tfloat y_b = 0.;\n\n\tvec2 a = vec2(x_a, y_a);\n\tvec2 b = vec2(x_b, y_b);\n\tvec2 ba = a - b;\n\tvec2 bp = xy - b;\n\n\tvec3 crossProduct = cross(vec3(ba, 0.), vec3(bp, 0.));\n\tfloat orientedArea = crossProduct.z;//length(crossProduct) * (crossProduct.z > 0. ? 1. : -1.);\n\t\n\treturn orientedArea;\n}\nfloat eval_u_binsearch(const vec2 xy)\n{\n\tvec2 I = vec2(0., 1.);\n\t\n\tfor(uint i = ZEROu; i < SEARCH_SAMPLES; i++)\n\t{\n\t\tfloat u = 0.5*(I[0] + I[1]);\n\t\tif(eval_u_orientedArea(xy, u) < 0.)\n\t\t\tI = vec2(u, I[1]);\n\t\telse\n\t\t\tI = vec2(I[0], u);\n\t\tif(I[1] - I[0] < 0.00001) break;\n\t}\n\t\n\treturn 0.5*(I[0] + I[1]);\n}\nvec2 inverse_trianglecut_param(const vec2 xy)\n{\n\tfloat u = eval_u_binsearch(xy);\n\t\n\tfloat x_a = iG(u);\n\t// eval functions at x_a\n\tfloat f_x_a = f(x_a);\n\tfloat F_x_a = F(x_a);\n\tfloat fprime_x_a = df(x_a);\n\tfloat y_a = f_x_a;\n\tfloat g_x_a = g(x_a);\n\t// compute x_b with triangle cut, Eq. (9)\n\tfloat x_b = x_a + 2. * (u - F_x_a)/f_x_a;\n\tfloat y_b = 0.;\n\t// compute infinitesimal thicknesses, Eq. (19) and (20)\n\tfloat w_a = f_x_a*f_x_a + 2. * (u - F_x_a) * fprime_x_a;\n\tfloat w_b = 2. * f_x_a * g_x_a - w_a;\n\t\n\tif(y_a == 0.) return vec2(u, 0.);\n\tfloat t = xy[1]/y_a;\n\tfloat v = (2.*w_b*t +(w_a - w_b)*t*t)/(w_a + w_b);\n\t\n\treturn vec2(u, v);\n}\n\n//Parameterization wrappers.\nvec2 parameterization(const vec2 uv, out bool error)\n{\n\terror = false;\n\t\n\tif(TRIANGLE_CUT) return trianglecut_param(uv, error);\n\treturn inverse_cdf_param(uv);\n}\nvec2 inverseParameterization(const vec2 xy)\n{\n\tif(TRIANGLE_CUT) return inverse_trianglecut_param(xy);\n\treturn cdf_param(xy);\n}\n\n\n/////////////\n//INTERFACE//\n/////////////\nvec2 fragCoordToScreenUV(const vec2 fragCoord)\n{\n\tif(ORTHONORMAL)\n\t\treturn fragCoord/iResolution.y;\n\telse\n\t\treturn fragCoord/iResolution.xy;\n}\nvec2 screenUVToXY(const vec2 screenUV)\n{\n\tif(ORTHONORMAL)\n\t\treturn screenUV*vec2(max(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction()))));\n\telse\n\t\treturn screenUV*vec2(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction())));\n}\nvec2 xyToFragCoord(const vec2 xy)\n{\n\tif(ORTHONORMAL)\n\t\treturn xy/vec2(max(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction()))))*iResolution.y;\n\telse\n\t\treturn xy/vec2(1., max(pdfMax(caseFunction()), pdfMax(caseApproximateFunction())))*iResolution.xy;\n}\n\nbool isValidUV(const vec2 uv)\n{\n\treturn all(greaterThanEqual(uv, vec2(0.))) && all(lessThanEqual(uv, vec2(1.)));\n}\nbool isBorderUV(const vec2 uv)\n{\n\treturn any(lessThan(abs(vec4(uv, uv - vec2(1.))), vec4(0.005)));\n}\nfloat isSampleUV(const vec2 uv)\n{\n\tfloat r = 0.;\n\t\n\t//In uv space.\n\t//float samplesRadius = SAMPLES_RADIUS/iResolution.y;\n\t//for(uint i = ZEROu; i < SAMPLES_NUMBER; i++)\n\t//{\n\t//\tvec2 v = uv - getNextSample();\n\t//\tfloat d2 = dot(v, v);\n\t//\t//if(d2 < samplesRadius*samplesRadius)\n\t//\t\t//return 1.;\n\t//\tr = max(r, smoothstep(samplesRadius*samplesRadius, 0., d2));\n\t//}\n\t\n\t//In screenspace.\n\tbool b;\n\tvec2 screenUV = xyToFragCoord(parameterization(uv, b));\n\tfor(uint i = ZEROu; i < SAMPLES_NUMBER; i++)\n\t{\n\t\tvec2 p = xyToFragCoord(parameterization(getNextSample(), b));\n\t\tvec2 v = screenUV - p;\n\t\tfloat d2 = dot(v, v);\n\t\t//if(d2 < SAMPLES_RADIUS*SAMPLES_RADIUS)\n\t\t\t//return 1.;\n\t\tr = max(r, smoothstep(SAMPLES_RADIUS*SAMPLES_RADIUS, 0., d2));\n\t}\n\t\n\treturn r;\n}\nvec3 uvColor(const vec2 uv)\n{\n\tif(!isValidUV(uv)) return RED;\n\n\tif(VISUALIZE_SAMPLES) return mix(WHITE, BLACK, isSampleUV(uv));\n\t\n\tuvec2 ij = uvec2(uv * float(GRID_SUBDIVISIONS));\n\tuint id = ij[0]*GRID_SUBDIVISIONS + ij[1];\n\t\n\t//Chessboard.\n\treturn ((id + ij[0]) % 2u == 0u ? WHITE : BLACK);\n}\nvec3 uvFixpointColor(const vec2 uv)\n{\n\tbool error = false;\n\tvec2 uvOut = inverseParameterization(parameterization(uv, error));\n\n\tif(error) return RED;\n\t\n\treturn uvColor(uvOut);\n}\nvoid initCamera(const vec2 screenUV, out vec3 ro, out vec3 rd)\n{\n\t// towards -Z\n\tro = vec3(0., 0., 1.);\n\tvec2 q = screenUV - 0.5;\n\trd = normalize(vec3(q, 0.) - ro);\n\n\tfloat a = 0.2;\n\tfloat b = -0.2;\n\tif(iMouse.xy != vec2(0.))\n\t{\n\t\tvec2 m = iMouse.xy/iResolution.xy - .5;\n\t\ta = m.x*PI*2.;\n\t\tb = m.y*PI;\n\t}\n\tvec3 camera = vec3(cos(b)*sin(a), sin(b), cos(b)*cos(a));\n\t//Z vector\n\tvec3 up = normalize(cross(cross(camera, vec3(0., 1., 0.)), camera));\n\t//Y vector\n\tvec3 x = normalize(cross(up, camera));\n\tmat3 view = mat3(x, up, camera);\n\n\tro = camera*4.;\n\trd = view*rd;\n}\nvec3 alternativeVisualisationColor(const vec2 screenUV)\n{\n\tswitch(CASE)\n\t{\n\t\t//case SIMPLE_FUNCTIONS_CASE:\n\t\tcase TRUNCATED_DISK_CASE:\n\t\t{\n\t\t\tvec2 xy = 2.*(screenUV - vec2(0.5));\n\t\t\t\n\t\t\tfloat r = length(xy);\n\t\t\tif(r > 1.) return GREY;\n\t\t\t\n\t\t\tfloat theta = 0.5*PI + asin(xy.x);\n\t\t\tif(theta > THETA_0) return GREY;\n\t\t\t\n\t\t\tfloat w = 0.5*(xy.y/sin(theta) + 1.);\n\t\t\tfloat wTilde = w * f(theta/THETA_0);\n\t\t\t\n\t\t\tvec2 p = vec2(theta/THETA_0, wTilde);\n\t\t\tvec2 uv = inverseParameterization(p);\n\t\t\treturn uvColor(uv);\n\t\t}\n\t\tcase TORUS_SURFACE_CASE:\n\t\t{\n\t\t\tvec3 ro;\n\t\t\tvec3 rd;\n\t\t\tinitCamera(screenUV, ro, rd);\n\t\t\t\n\t\t\tvec3 intersection;\n\t\t\tif(!sphereTraceTorus(ro, rd, intersection)) return GREY;\n\t\t\t\n\t\t\tfloat theta = atan(intersection.y, length(intersection.xz) - TORUS_SKELETON_RADIUS);\n\t\t\tfloat phi = PI + atan(intersection.z, intersection.x);\n\t\t\tfloat w = 0.5*phi/PI;\n\t\t\tfloat wTilde = w * f(theta/PI);\n\t\t\t\n\t\t\tfloat symTheta = abs(theta);\n\t\t\tvec2 uv = inverseParameterization(vec2(symTheta/PI, wTilde));\n        \n\t\t\tif(theta >= 0.)\n\t\t\t\tuv.x *= 0.5;\n\t\t\telse\n\t\t\t\tuv.x = 1. - 0.5*uv.x;\n\t\t\treturn uvColor(uv);\n\t\t}\n\t\tcase POLAR_SHAPE_CASE:\n\t\t{\n\t\t\tvec2 xy = 2.5*(screenUV - vec2(0.5));\n\t\t\t\n\t\t\tfloat r = length(xy);\n\t\t\tfloat theta = mod(atan(xy.y, xy.x), 2.*PI);\n\t\t\tif(r > polarShapeRadius(theta)) return GREY;\n\t\t\t\n\t\t\tfloat rMax = polarShapeRadius(theta);\n\t\t\tfloat w = r*r/(rMax*rMax);\n\t\t\tfloat wTilde = w * f(0.5*theta/PI);\n\t\t\t\n\t\t\tvec2 p = vec2(0.5*theta/PI, wTilde);\n\t\t\tvec2 uv = inverseParameterization(p);\n\t\t\treturn uvColor(uv);\n\t\t}\n\t}\n\t\t\n\treturn GREY;\n}\nvec3 graphColor(const vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 screenUV = fragCoordToScreenUV(fragCoord);\n\t\n\tif(any(greaterThan(screenUV, vec2(1.)))) return GREY;\n\t\n\t//Visualizing fixpoint error on UV grid.\n\tif(DEBUG_UV_FIXPOINT) return uvFixpointColor(screenUV);\n\t\n\t//Alternative visualization.\n\tif(ALTERNATIVE_VISUALISATION) return alternativeVisualisationColor(screenUV);\n\t\n\tvec2 xy = screenUVToXY(screenUV);\n\n\t//Right background.\n\tif(xy.x > 1.) return GREY;\n\t\n\t//Printing g in green (or f in case of inverse CDF mapping).\n\tif(TRIANGLE_CUT && abs(g(xy.x) - xy.y) <= 0.005 || !TRIANGLE_CUT && abs(f(xy.x) - xy.y) <= 0.005)\n\t\treturn GREEN;\n\t\n\t//Printing background in grey.\n\tif(f(xy[0]) < xy[1]) return GREY;\n\t\n\t//Printing mapped UV.\n\tvec2 uv = inverseParameterization(xy);\n\n\tbool error = false;\n\tparameterization(uv, error);\n\tif(error) return RED;\n\t\n\treturn uvColor(uv);\n}\n\nconst uint KEY_SPACE = 32u;\nconst uint KEY_ALT = 18u;\nconst uint KEY_A = 65u;\nconst uint KEY_D = 68u;\nconst uint KEY_O = 79u;\nconst uint KEY_S = 83u;\nvoid interactiveInit(const vec2 fragCoord)\n{\n#ifdef INTERACTIVE_CASE\n\t//Test case according to keys \"1\" to \"4\".\n\tCASE = uint(texelFetch(iChannel1, ivec2(fragCoord), 0).x);\n#endif\n#ifdef INTERACTIVE_ALTERNATE_VISUALISATION\n\t//Alternative visualization according to key \"A\".\n\tALTERNATIVE_VISUALISATION = (texelFetch(iChannel0, ivec2(KEY_A, 2), 0).x == 1. ? !ALTERNATIVE_VISUALISATION : ALTERNATIVE_VISUALISATION);\n#endif\n#ifdef INTERACTIVE_TRIANGLE_CUT\n\t//Mapping method according to space bar.\n\tTRIANGLE_CUT = (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x == 1. ? !TRIANGLE_CUT : TRIANGLE_CUT);\n#endif\n\n#ifdef INTERACTIVE_DEBUG_UV_FIXPOINT\n\t//Debug mode according to key \"D\".\n\tDEBUG_UV_FIXPOINT = (texelFetch(iChannel0, ivec2(KEY_D, 2), 0).x == 1. ? !DEBUG_UV_FIXPOINT : DEBUG_UV_FIXPOINT);\n#endif\n\n#ifdef INTERACTIVE_ORTHONORMAL\n\t//Orthonormal mode according to key \"O\".\n\tORTHONORMAL = (texelFetch(iChannel0, ivec2(KEY_O, 2), 0).x == 1. ? !ORTHONORMAL : ORTHONORMAL);\n#endif\n\n#ifdef INTERACTIVE_VISUALIZE_SAMPLES\n\t//Samples visualization according to key \"S\".\n\tVISUALIZE_SAMPLES = (texelFetch(iChannel0, ivec2(KEY_S, 2), 0).x == 1. ? !VISUALIZE_SAMPLES : VISUALIZE_SAMPLES);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tinteractiveInit(fragCoord);\n\t\n\tvec3 color = graphColor(fragCoord);\n\t\n\t// Output to screen\n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Storing test case state according to last pressed key in \"1\" to \"4\".\n\nconst uint KEY_1 = 49u;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint newCase = uint(texelFetch(iChannel1, ivec2(fragCoord), 0).x);\n    for(uint i = 0u; i < 4u; i++)\n    {\n        if(texelFetch(iChannel0, ivec2(KEY_1 + i, 1), 0).x > 0.)\n        {\n            newCase = i;\n            break;\n        }\n    }\n    fragColor = vec4(float(newCase), 0., 1., 1.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2806, 2806, 2852, 2852, 3235], [3236, 3236, 3257, 3257, 3289], [3290, 3290, 3322, 3322, 3396], [3461, 3495, 3518, 3518, 3646], [3647, 3647, 3668, 3668, 3717], [3718, 3718, 3740, 3740, 3806], [3956, 3956, 3985, 3985, 4026], [4027, 4027, 4066, 4066, 4102], [4103, 4103, 4152, 4152, 4188], [4189, 4189, 4231, 4231, 4351], [4352, 4352, 4404, 4404, 4484], [4582, 4582, 4641, 4641, 4833], [4834, 4834, 4883, 4883, 5036], [5037, 5037, 5131, 5131, 5199], [5200, 5200, 5276, 5276, 5532], [5534, 5549, 5592, 5592, 5646], [5647, 5647, 5700, 5700, 5744], [5745, 5745, 5795, 5795, 5926], [5927, 5927, 5971, 5971, 6019], [6020, 6020, 6074, 6074, 6145], [6146, 6146, 6187, 6187, 6381], [6384, 6453, 6484, 6484, 6982], [6984, 6984, 7027, 7027, 8310], [8311, 8311, 8361, 8361, 9466], [9467, 9467, 9510, 9510, 10638], [10639, 10639, 10690, 10690, 12205], [12260, 12272, 12296, 12296, 12330], [12331, 12331, 12355, 12355, 12389], [12390, 12390, 12415, 12415, 12457], [12458, 12458, 12483, 12483, 12524], [12525, 12525, 12549, 12549, 12594], [12595, 12595, 12619, 12619, 12664], [12665, 12665, 12690, 12690, 12743], [12745, 12779, 12818, 12818, 12872], [12873, 12873, 12904, 12904, 12946], [12949, 12982, 13037, 13082, 13905], [13907, 13954, 14011, 14011, 14620], [14621, 14621, 14660, 14660, 14924], [14925, 14925, 14972, 14972, 15563], [15565, 15594, 15648, 15648, 15754], [15755, 15755, 15800, 15800, 15881], [15884, 15926, 15974, 15974, 16068], [16069, 16069, 16109, 16109, 16323], [16324, 16324, 16359, 16359, 16590], [16592, 16592, 16623, 16623, 16706], [16707, 16707, 16739, 16739, 16807], [16808, 16808, 16841, 16841, 17565], [17566, 17566, 17595, 17595, 17859], [17860, 17860, 17897, 17897, 18038], [18039, 18039, 18103, 18118, 18605], [18606, 18606, 18663, 18663, 20149], [20150, 20150, 20189, 20236, 21054], [21206, 21206, 21250, 21250, 22392], [22394, 22394, 22446, 22446, 22569]], "test": "untested"}
{"id": "3tdcWj", "name": "Mountain Lake with Tower", "author": "dr2", "description": "Lake with 3D landscape and disappearing tower (from \"Stairs to Nowhere\") - mouseable", "tags": ["reflection", "landscape", "architecture"], "likes": 10, "viewed": 391, "published": 3, "date": "1609925982", "time_retrieved": "2024-07-30T19:46:35.043716", "image_code": "// \"Mountain Lake with Tower\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 szFlr;\nvec3 sunDir;\nfloat dstFar, tCur, grndScl, twrScl, flSpc, nFlr, twrRad, bSizeV, cIdV, vShift;\nint idObj;\nconst int idFlr = 1, idStr = 2, idRl = 3, idStn = 4, idCln = 5;\nconst float pi = 3.1415927, sqrt2 = 1.41421;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 22.;\n    h = 6. * s * mix (Fbm2 (f * vec2 (s, a + 1.)), Fbm2 (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - (h * smoothstep (1.4, 2.6, r) - 0.5 * (1. - smoothstep (0.5, 1.4, r)) - 0.01));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, stSpc, xLim1, xLim2, bRad, r, a, x;\n  bool topFlr, botFlr;\n  dMin = dstFar / twrScl;\n  p /= twrScl;\n  r = length (p.xz) - twrRad;\n  d = r - 20.;\n  if (d < 1.) {\n    a = 2. * pi * ((floor (6. * atan (p.x, - p.z) / (2. * pi)) + 0.5) / 6.);\n    stSpc = 6.;\n    xLim1 = abs (dot (p.xz, sin (a + vec2 (0.5 * pi, 0.)))) - 22.;\n    xLim2 = xLim1 + 16.;\n    bRad = 0.5;\n    topFlr = (cIdV == 2. * nFlr - 1.);\n    botFlr = (cIdV == 0.);\n    if (topFlr) {\n      d = length (max (abs (vec2 (p.y + 0.5 * szFlr.w, r + szFlr.z + stSpc)) - vec2 (0.5 * szFlr.w, szFlr.z), 0.));\n      DMIN (idFlr);\n      d = max (length (vec2 (p.y + 0.4, abs (r + szFlr.z + stSpc - 0.5)) - (szFlr.z - 0.1)) - bRad, - xLim2);\n      DMIN (idRl);\n    }\n    d = max (length (max (abs (vec2 ((topFlr ? - p.y : abs (p.y)) - flSpc,\n       r - 0.4 * (szFlr.z + stSpc))) - vec2 (szFlr.w, 1.4 * (szFlr.z + stSpc)), 0.)), - xLim1);\n    DMIN (idFlr);\n    d = max (length (max (abs (vec2 (p.y + szFlr.w, r)) - vec2 (szFlr.w, 2. * szFlr.z + stSpc + 0.5), 0.)), xLim2);\n    DMIN (idFlr);\n    p.zx = Rot2D (p.zx, a);\n    p.z = abs (p.z) - twrRad;\n    x = abs (p.x) - szFlr.x;\n    for (float sz = -1.; sz <= 1.; sz += 2.) {\n      if (! topFlr || sz < 0.) {\n        q.x = x;\n        q.yz = p.yz - sz * vec2 (szFlr.y - szFlr.w, - (szFlr.z + stSpc));\n        d = abs (q.y) - (szFlr.y - szFlr.w - 0.005);\n        q.xy = vec2 (q.x + sz * q.y, - sz * q.x + q.y) / sqrt2;\n        d = max (max (max (q.y - 0.5 * sqrt2 - abs (0.5 * sqrt2 - mod (q.x, sqrt2)), abs (q.z) - szFlr.z), -1. - q.y), d);\n        DMIN (idStr);\n      }\n    }\n    d = max (length (vec2 (p.y + flSpc - 4., abs (r - szFlr.z) - (2. * szFlr.z + stSpc - 0.8))) - bRad, - xLim1);\n    DMIN (idRl);\n    d = max (length (vec2 (p.y - 3.5, abs (r - 0.4) - (2. * szFlr.z + stSpc - 0.1))) - bRad, xLim2);\n    DMIN (idRl);\n    q = vec3 (x - 4., p.y + 0.5 * flSpc, abs (p.z - (szFlr.z + stSpc)) - szFlr.z);\n    d = max (length (vec2 ((q.x + q.y) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n    DMIN (idRl);\n    q.xz = vec2 (x + 4., abs (p.z + szFlr.z + stSpc) - szFlr.z);\n    if (! botFlr) {\n      d = max (length (vec2 ((q.x - (p.y + 1.5 * flSpc)) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n      DMIN (idRl);\n    }\n    if (! topFlr) {\n      d = max (length (vec2 ((q.x - (p.y - 0.5 * flSpc)) / sqrt2, q.z)) - bRad, abs (x) - 8.);\n      DMIN (idRl);\n    }\n    x = abs (p.x);\n    q.x = x - 22.;\n    d = min (length (vec2 (q.x, p.y + flSpc - 4.)), length (vec2 (x - 6., p.y - 3.5))) - bRad;\n    d = max (d, max (abs (p.z) - (2. * szFlr.z + stSpc), szFlr.z - abs (abs (p.z) - (szFlr.z + stSpc))));\n    DMIN (idRl);\n    q.yz = vec2 (p.y + flSpc - 2.5, abs (abs (p.z) - (szFlr.z + stSpc)) - szFlr.z);\n    d = PrCapsDf (q.xzy, 0.7, 2.);\n    DMIN (idStn);\n    if (! topFlr) {\n      d = length (vec2 (q.x, p.z)) - 0.8;\n      DMIN (idCln);\n    }\n    d = PrCapsDf (vec3 (x - 6., p.y - 2.5, q.z).xzy, 0.7, 2.);\n    DMIN (idStn);\n    dMin *= 0.7;\n  } else dMin = d;\n  return twrScl * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d, eps, sy;\n  eps = 0.0005;\n  dHit = eps;\n  if (rd.y == 0.) rd.y = 0.001;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    p.y -= vShift;\n    cIdV = floor (p.y / bSizeV);\n    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;\n    d = abs (sy) + eps;\n    if (cIdV >= 0. && cIdV < 2. * nFlr) {\n      p.y -= bSizeV * (cIdV + 0.5);\n      d = min (ObjDf (p), d);\n    }\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  p.y -= vShift;\n  cIdV = floor (p.y / bSizeV);\n  p.y -= bSizeV * (cIdV + 0.5);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  q = 0.005 * (ro.xz + 5. * tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n  ff = Fbm2 (q);\n  f = smoothstep (0.1, 0.8, ff);\n  fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n  clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) * smoothstep (0., 0.05, abs (fd)));\n  fd = smoothstep (0.01, 0.1, rd.y);\n  col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n  return col;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 q, w;\n  float wFreq, wAmp, tWav, ht, s;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  tWav = 0.5 * tCur;\n  wFreq = 1.;\n  wAmp = 1.;\n  s = length (p);\n  ht = 0.3 * (1. + sin (4. * s - 4. * tCur));\n  q = 0.3 * p;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    q *= qRot;\n    t4 = (q.xyxy + (tWav * vec2 (1., -1.)).xxyy) * wFreq;\n    t4 += 2. * Noisev2v4 (t4).xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    w = 1. - sqrt (v4.xz * v4.yw);\n    w *= w;\n    w *= w;\n    w *= w;\n    ht += wAmp * (w.x + w.y);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return 0.3 * ht / (1. + 0.02 * s);\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy), WaveHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  float a;\n  a = atan (ro.z, - ro.x);\n  col4 = mix (vec4 (0.45, 0.4, 0.4, 0.1), vec4 (0.35, 0.3, 0.25, 0.1),\n     smoothstep (0., 0.04, ro.y / grndScl + 0.005 * sin (32. * a)));\n  if (ro.y > 0.) {\n    col4 = mix (col4, vec4 (0.25, 0.4, 0.25, 0.), smoothstep (0.1, 0.2, 1. - vn.y));\n    col4 = mix (col4, vec4 (0.6, 0.5, 0.3, 0.1), smoothstep (0.2, 0.35, 1. - vn.y));\n    col4 = mix (col4, vec4 (0.65, 0.6, 0.5, 0.1), smoothstep (0.35, 0.45, 1. - vn.y));\n    col4 = mix (col4, vec4 (1., 1., 1., 0.4), smoothstep (0.65, 0.95, ro.y / grndScl + 0.2 * sin (8. * a)));\n  }\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  if (idObj == idFlr) {\n    col4 = vec4 (0.4, 0.7, 0.2, 0.1);\n    if (vn.y > 0.99) col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, mod (0.25 * length (ro.xz) / twrScl, 1.));\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.3, 0.6, 0.2, 0.1);\n  } else if (idObj == idRl) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n  } else if (idObj == idStn) {\n    col4 = vec4 (0.7, 0.7, 0., 0.2);\n  } else if (idObj == idCln) {\n    col4 = vec4 (0.9, 0., 0., 0.2);\n  }\n  return col4;\n}\n  \nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, colR, vn, vnw, roo, rdo;\n  float dstObj, dstGrnd, dstWat, wAbs;\n  bSizeV = 2. * flSpc * twrScl;\n  roo = ro;\n  rdo = rd;\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  wAbs = 1.;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      col4 = GrndCol (ro, vn);\n      vn = VaryNf (16. * ro / grndScl, vn, 4.);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = ObjCol (ro, vn);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (vn.y, 0.) + 0.7 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (dstWat < min (dstObj, dstGrnd)) {\n      wAbs = smoothstep (0., 0.05, - ro.y / grndScl);\n      col = mix (col, mix (vec3 (0.15, 0.17, 0.15), vec3 (0.12, 0.12, 0.15), smoothstep (0.3, 0.7,\n         Fbm2 (0.1 * (roo.xz + dstWat * rd.xz)))), wAbs);\n    }\n  } else col = SkyCol (ro, rd);\n  if (dstWat < min (min (dstObj, dstGrnd), dstFar)) {\n    ro = roo + dstWat * rd;\n    vnw = WaveNf (ro, dstWat);\n    rd = reflect (rd, vnw);\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n    if (min (dstObj, dstGrnd) < dstFar) {\n      if (dstGrnd < dstObj) {\n        ro += dstGrnd * rd;\n        vn = GrndNf (ro);\n        col4 = GrndCol (ro, vn);\n        vn = VaryNf (16. * ro / grndScl, vn, 4.);\n      } else {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        col4 = ObjCol (ro, vn);\n      }\n      colR = col4.rgb * (0.2 + 0.2 * max (vn.y, 0.) + 0.7 * max (dot (vn, sunDir), 0.));\n    } else colR = SkyCol (ro, rd);\n    col = mix (col, 0.95 * colR, min (wAbs, 1. - 0.9 * pow (max (- dot (rdo, vnw), 0.), 2.)));\n    vnw = VaryNf (0.1 * vec3 (Rot2D (ro.xz, 0.01 * tCur), ro.y).xzy, vnw, 1.);\n    col += 0.1 * pow (max (0., dot (sunDir, reflect (rdo, vnw))), 1024.);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az -= 2.5 * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    t = mod (0.005 * tCur, 2.);\n    az = 2.5 * pi * (0.5 - abs ((floor (16. * t) + smoothstep (0.8, 1., mod (16. * t, 1.))) / 16. - 1.));\n  }\n  el = clamp (el, -0.4 * pi, 0.);\n  zmFac = 3.5 + 2. * smoothstep (0.1 * pi, 0.4 * pi, - el);\n  twrScl = 0.15;\n  szFlr = vec4 (14., 8.5, 4., 0.5);\n  flSpc = 2. * szFlr.y - szFlr.w;\n  nFlr = 3.;\n  t = SmoothBump (0.25, 0.75, 0.2, mod (0.03 * tCur, 1.));\n  vShift = -4. * nFlr * flSpc * twrScl * t;\n  twrRad = 60.;\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  ro = vuMat * vec3 (0., 0., -1.7) * grndScl;\n  ro.y += 0.25 * grndScl;\n  dstFar = 10. * grndScl;\n  sunDir = normalize (vec3 (1., 2., 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[784, 784, 807, 807, 1213], [1215, 1215, 1249, 1249, 1740], [1742, 1742, 1764, 1764, 2020], [2022, 2022, 2044, 2044, 5040], [5042, 5042, 5075, 5075, 5596], [5598, 5598, 5619, 5619, 5954], [5956, 5956, 5988, 5988, 6513], [6515, 6515, 6538, 6538, 7177], [7179, 7179, 7210, 7210, 7381], [7383, 7383, 7416, 7416, 8013], [8015, 8015, 8047, 8047, 8527], [8531, 8531, 8566, 8566, 10499], [10543, 10543, 10599, 10599, 12164], [12166, 12166, 12209, 12209, 12273], [12275, 12275, 12332, 12332, 12415], [12417, 12417, 12453, 12453, 12659], [12661, 12661, 12691, 12691, 12804], [12806, 12806, 12837, 12837, 12901], [12935, 12935, 12959, 12959, 13089], [13091, 13091, 13115, 13115, 13178], [13180, 13180, 13205, 13205, 13391], [13393, 13393, 13418, 13418, 13755], [13757, 13757, 13778, 13778, 13933], [13935, 13935, 13964, 13964, 14176], [14178, 14178, 14217, 14217, 14397]], "test": "untested"}
{"id": "wlcyD2", "name": "neon lines attempt", "author": "mds2", "description": "Modification of https://www.shadertoy.com/view/lttyDN to attempt to emulate the filter described in https://www.tiktok.com/@666zomey/video/6914063925562625286?_d=secCgYIASAHKAESMgowfEyOqupr1soXFMkHHyXJleMxHURJi7L0oUNOQbx9BaIc%2Fg49YycPFJe%2BTjxH6lNfGgA%3D", "tags": ["video", "filter"], "likes": 12, "viewed": 780, "published": 3, "date": "1609923164", "time_retrieved": "2024-07-30T19:46:35.811663", "image_code": "const float EDGE_OR_CORNER_DETECT = 0.7; // 0 for corner, 1 for edge\n\nconst float WINDOW_FILTER_WIDTH = 2.0; // max 6.0\n\n#define WINDOW_SIZE 3 // needs to be int\n\n#define HALF_WINDOW_SIZE_MINUS_ONE 1.0 // needs to be float\n\nconst float SHOW_BACKGROUND = 0.25; // 0.0 for no background, 1.0 for all background\n\nconst vec2 webcam_resolution = vec2(320.0, 240.0);\nconst mat3 to_yuvish = mat3(0.299, -0.14713, 0.615,\n                          0.587, -0.28886, -0.51499,\n                          0.114, 0.436, -0.10001);\nconst mat3 from_yuvish = mat3(1.0, 1.0, 1.0,\n                              0.0, -0.39465, 2.03211,\n                              1.13983, -0.58060, 0.0);\nvec3 YUV(in vec2 fragCoord) {\n    \n    return to_yuvish * texture(iChannel0, fragCoord / iResolution.xy).rgb;\n}\n\nfloat Yval(in vec2 fragCoord) {\n    return YUV(fragCoord).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // mirror flip (sorry this is before variable declarations)\n    \n    fragCoord.x = iResolution.x - fragCoord.x;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat2 M = mat2(0.0);\n    \n    vec2 scale = iResolution.xy / min(iResolution.xy, webcam_resolution.xy);\n    \n    vec2 off = vec2(-1.0 * HALF_WINDOW_SIZE_MINUS_ONE);\n    for (int i = 0; i < WINDOW_SIZE; ++i) {\n        off.y = -1.0 * HALF_WINDOW_SIZE_MINUS_ONE;\n        off.x += 1.0;\n        for (int j = 0; j < WINDOW_SIZE; ++j) {\n            off.y += 1.0;\n            \n            float weight = smoothstep(WINDOW_FILTER_WIDTH, 0.0, length(off));\n    \n\t    \tfloat Ix = 0.5 * (Yval(fragCoord + scale * (off + vec2(1.0, 0.0))) - \n            \t              Yval(fragCoord + scale * (off - vec2(1.0, 0.0))));\n    \t\tfloat Iy = 0.5 * (Yval(fragCoord + scale * (off + vec2(0.0, 1.0))) - \n            \t              Yval(fragCoord + scale * (off - vec2(0.0, 1.0))));\n        \n         \tM += weight * mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n        }\n    }\n\n//    mat2 M = mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n    \n    float A = 1.0;\n    float B = -M[0][0] - M[1][1];\n    float C = M[0][0] * M[1][1] - M[0][1] * M[1][0];\n\n    float l1 = (-B + sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    float l2 = (-B - sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    \n    float min_eig = min(abs(l1), abs(l2));\n    float max_eig = max(abs(l1), abs(l2));\n//\tfloat min_eig = min(l1, l2);\n    \n    float eig_to_use = mix(min_eig, max_eig, EDGE_OR_CORNER_DETECT);\n\n    // Time varying pixel color\n    vec3 col = smoothstep(vec3(0.0), 0.1 * vec3(0.1, 0.2, 0.3), vec3(eig_to_use));\n    vec3 raw_color = texture(iChannel0, uv).rgb;\n    \n    float col_mag = (dot(vec3(1.0), raw_color) / 3.0);\n    col_mag = smoothstep(0.0, 1.0, col_mag);\n    col_mag = smoothstep(0.0, 1.0, col_mag);\n    raw_color = vec3(1.0) * col_mag;\n    \n    // col = vec3(1.0, 0.5, 0.0); uncomment to debug noise\n    \n    \n\n    if (length(col) > 0.01) {\n    float theta = 12.0 * simple_noise(0.5 * uv * iResolution.xy/iResolution.y, 2.0 * sin(0.5 * iTime));\n    float ct = cos(theta);\n    float st = sin(theta);\n    mat3 color_mat = from_yuvish *\n                     mat3(1.0, 0.0, 0.0,\n                          0.0, ct, st,\n                          0.0, -st, ct) *\n                     to_yuvish;\n    col = color_mat * col;\n    }\n    \n    // raw_color += theta;\n    // Output to screen\n    fragColor = vec4(mix(raw_color, col, 1.0 - SHOW_BACKGROUND),1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float nonlinearity(in float x) {\n     x = mod(2.0 * x, 1.0);\n     return x + 0.1 * x * x * (1.1 + 0.01 * x);\n}\n\nfloat hash12(vec2 x)\n{\n    return mod(13.3 + 201.1 * nonlinearity(302.2 * x.x + 123.7 * x.y + 11.1), 1.0);\n}\n\n\nfloat noise_term(in vec2 x, in float scale_val) {\n    vec2 s = vec2(scale_val);\n    vec2 x00 = x - mod(x, s);\n    vec2 x01 = x + vec2(0.0, scale_val);\n    x01 = x01 - mod(x01, s);\n    vec2 x10 = x + vec2(scale_val, 0.0);\n    x10 = x10 - mod(x10, s);\n    vec2 x11 = x + s;\n    x11 = x11 - mod(x11, s);\n    \n    float v00 = hash12(x00);\n    float v01 = hash12(x01);\n    float v10 = hash12(x10);\n    float v11 = hash12(x11);\n    \n    vec2 uv = mod(x, s) / s;\n    \n    float yweight = smoothstep(0.0, 1.0, uv.y);\n    float v1 = mix(v10, v11, yweight);\n    float v0 = mix(v00, v01, yweight);\n    \n    float xweight = smoothstep(0.0, 1.0, uv.x);\n    \n    return mix(v0, v1, xweight);\n}\n\nfloat noise(in vec2 x, in float base_scale, in float space_decay, in float height_decay,\n           in float shift_by) {\n\tfloat h = 1.0;\n    float s = base_scale;\n\n    float summation = 0.0;\n    \n    for (int i = 0; i < 3; ++i) {\n    \tsummation = summation + h * noise_term(x + vec2(0.0, s * shift_by), s);\n        s *= space_decay;\n        h *= height_decay;\n    }\n    return summation;\n}\n\nfloat simple_noise(in vec2 uv, in float shift_by) {\n  return noise(uv * 10.0, 5.0, 0.75, 0.75, shift_by);\n}\n\nvec2 noise2(in vec2 uv, in float shift_by) {\n    return vec2(simple_noise(uv, shift_by),\n                simple_noise(uv + vec2(0.0, 101.0), shift_by));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 700, 700, 782], [784, 784, 815, 815, 846], [848, 848, 905, 969, 3428]], "test": "untested"}
{"id": "ttccD2", "name": "Simple Planet Shadow", "author": "fofod", "description": "", "tags": ["simple"], "likes": 1, "viewed": 247, "published": 3, "date": "1609918947", "time_retrieved": "2024-07-30T19:46:36.655409", "image_code": "#define S(a,b,t) smoothstep(a, b, t );\nfloat Circle(vec2 uv,vec2 p,float r,float blur){\nuv-=p * sin(iTime * 2.);\n    uv*=1.;\nfloat dist = length(uv);\n    return S(r,r+.0001+blur*abs(sin(iTime)),dist); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*= iResolution.x/iResolution.y;\nuv-=0.5;\nuv.x-=.3;\nfloat c = Circle(uv,vec2(.0,.0),.2,.1);\nc *= Circle(uv,vec2(.4,.0),.1,.0);\nc *= Circle(uv,vec2(-.4,.0),.1,.2);\n fragColor = vec4(vec3(c),1.2);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 87, 87, 203], [204, 204, 261, 261, 508]], "test": "untested"}
{"id": "tl3yD2", "name": "RayMarch-", "author": "hanker", "description": "Three formulas, combinations between geometries and calculations are tested", "tags": ["raymarch"], "likes": 1, "viewed": 263, "published": 3, "date": "1609914568", "time_retrieved": "2024-07-30T19:46:37.599882", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define T iTime\n#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat intersectSDF(float distA,float distB){\n    return max(distA,distB);\n}\n\n\n\nfloat unionSDF(float distA,float distB){\n    return min(distA,distB);\n}\nfloat differenceSDF(float distA,float distB){\n    return max(distA,-distB);\n}\nfloat sdBox(vec3 p,vec3 c,vec3 s){\n    return length(max(abs(c - p) - s,0.));\n}\nfloat sdSphere(vec3 p,vec3 ori,float s){\n    return length(p - ori) - s;\n}\nfloat GetDist(vec3 p){\n    float boxDist = sdBox(p,vec3(0.,0.,0.),vec3(4.));\n    float sphereDistInner = sdSphere(p,vec3(0.,0.,0.),6. * abs(sin(T)));\n    float sphereDist = sdSphere(p,vec3(0.,0.,0.),6. * abs(sin(T)));\n    float d = differenceSDF(boxDist,sphereDistInner);\n    d = intersectSDF(d,sphereDist);\n    return d;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 offset = vec2(.001,0.);\n    return normalize(d - vec3(\n       GetDist(p - offset.xyy),\n       GetDist(p - offset.yxy),\n       GetDist(p - offset.yyx)\n    ));\n}  \nfloat RayMarch(vec3 ro,vec3 rd){\n    float d = 0.;\n    for(int i = 0; i < MAX_STEP; i++){\n        vec3 p = ro + rd * d;\n        float dS = GetDist(p);\n        d += dS;\n        if(d > MAX_DIST || dS < SURFACE_DIST)break;\n    }\n    return d;\n}\nvec3 GetRayDir(vec2 uv,vec3 ro,vec3 look,float z){\n    vec3 forward = normalize(look - ro);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),forward));\n    vec3 top = cross(forward,right);\n    vec3 center = ro + z * forward;\n\n    vec3 i = center + right * uv.x + top * uv.y;\n    vec3 dir = normalize(i - ro);\n\n    return dir;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    if(iResolution.y > iResolution.x)uv.y *= iResolution.y / iResolution.x;\n    else uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(8. * sin(T),5.,7.* cos(T));\n\n    vec3 rd = GetRayDir(uv,ro,vec3(0.,0.,0.),1.);\n\n    float d = RayMarch(ro,rd);\n    if(d < MAX_DIST){\n        vec3 p = ro + rd * d;\n        vec3 normal = GetNormal(p);\n        float diffuse = clamp(dot(normal,normalize(vec3(1.,2.,-3.))),0.,1.) * .5 + .5;\n        col += diffuse;\n    }\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 138, 138, 211], [212, 212, 256, 256, 287], [291, 291, 331, 331, 362], [363, 363, 408, 408, 440], [441, 441, 475, 475, 520], [521, 521, 561, 561, 595], [596, 596, 618, 618, 919], [920, 920, 943, 943, 1138], [1141, 1141, 1173, 1173, 1382], [1383, 1383, 1433, 1433, 1709], [1710, 1710, 1763, 1763, 2348]], "test": "untested"}
{"id": "wl3cDM", "name": "Fejer summation approximation", "author": "NinjaKoala", "description": "This is a variation of https://www.shadertoy.com/view/MlcSWS\napproximating the arithmetic mean of the fourier partial sums instead.", "tags": ["sound", "antialias", "fourier", "squarewave", "synth", "bandlimited", "gibbs", "fejer"], "likes": 2, "viewed": 439, "published": 3, "date": "1609894584", "time_retrieved": "2024-07-30T19:46:38.366831", "image_code": "/*\nVariation of https://www.shadertoy.com/view/MlcSWS\n\nThe Fejer summation method is to take the average over the\npartial sums of the fourier series of the function.\nWhile this approximation is worse in the least squares sense,\nit behaves better in some other areas. In particular,\nit doesn't show the typical overshoot of the Gibbs phenonemon.\n\nWhile the original method approximates the Dirichlet kernel\nwith a sinc function, here the Fejer kernel is approximated with a squared sinc function.\nBecause the Fourier partial sums are the convolution with a Dirichlet kernel\nand the Fejer summation the convolution with a Fejer kernel, the\nFourier approximation can be approximated with the sine integral and\nthe Fejer summation with the integral of the squared sinc, which\ncan be computed using the sine integral.\n\nSee for example: https://en.wikipedia.org/wiki/Fej%C3%A9r_kernel\n*/\n\nconst float eps=.00034526;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float border=1.3/iResolution.y;\n    \n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float t0=mod(iTime,freq_modulus);\n    \n    float audio_freq=get_audio_freq(t0);\n    \n    n=int((iSampleRate*.5+1.)/(2.*audio_freq)+.5);\n\n\tfloat freq=.0002*audio_freq;\n\n\tfloat zoom=5.;\n    \n    vec2 uv1=uv;\n    uv1.y-=.25*sign(uv.y);\n    \n    uv1*=zoom;\n\n\tfloat dis1=abs(integral_fejer_squarewave(uv1.x,freq)-uv1.y);\n\tdis1/=zoom*length(vec2((integral_fejer_squarewave(uv1.x,freq)-integral_fejer_squarewave((uv1.x+eps),freq))/eps,1.));\n\n\tfloat dis2=abs(additive_fejer_squarewave(uv1.x,freq)-uv1.y);\n\tdis2/=zoom*length(vec2((additive_fejer_squarewave(uv1.x,freq)-additive_fejer_squarewave((uv1.x+eps),freq))/eps,1.));\n\n\tfloat dis3=abs(simple_squarewave(uv1.x,freq)-uv1.y);\n\tdis3/=zoom;\n\n\tfloat thickness=zoom*.0001;\n\n\tvec3 bg_col=vec3(0);\n\n\tvec3 add_col=vec3(1);\n\tvec3 int_col=vec3(1,0,0);\n\tvec3 smp_col=vec3(0,1,0);\n\n\tvec3 color;\n    \n    if(uv.y>0.){\n    \tcolor=mix(smp_col,bg_col,smoothstep(0.,border,dis3-thickness));\n\t\tcolor=mix(add_col,color,smoothstep(0.,border,dis2-thickness));\n\t\tcolor=mix(int_col,color,smoothstep(0.,border,dis1-thickness));\n    }\n    else{\n        float t1=mod(iTime,wave_modulus);\n        \n        int wave_index=get_wave_index(t1);\n        \n        if(wave_index==0){\n        \tcolor=mix(smp_col,bg_col,smoothstep(0.,border,dis3-thickness));\n        }\n        else if(wave_index==1){\n\t\t\tcolor=mix(add_col,bg_col,smoothstep(0.,border,dis2-thickness));\n        }\n        else{\n\t\t\tcolor=mix(int_col,bg_col,smoothstep(0.,border,dis1-thickness));\n        }\n    }\n    \n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "const float pi=3.1416;\nconst int max_n=100;\nint n;\n\nconst float freq_modulus=18.;\nconst float wave_modulus=6.;\n\nfloat polynomial(vec4 a, float x){\n\treturn (((x*x + a[0])*x*x + a[1])*x*x + a[2])*x*x+a[3];\n}\n\nfloat rational(vec4 a, vec4 b, float x){\n\n\tfloat numerator=polynomial(a,x);\n\tfloat denominator=polynomial(b,x);\n\n\treturn numerator/denominator;\n}\n\nfloat Si(float x){\n\n\tfloat sgn=1.;\n\n\tif(x<0.){\n\t\tsgn=-1.;\n\t\tx=-x;\n\t}\n\n\tif(x<1.){\n\t\tvec4 a = vec4(-1./35280.,1./600.,-1./18.,1.)*3265920.;\n\t\treturn sgn*polynomial(a,x)/3265920.*x;\n\t}\n\telse{\n\n\t\tvec4 a_f=vec4(38.027264,265.187033,335.67732,38.102495);\n\t\tvec4 b_f=vec4(40.021433,322.624911,570.236280,157.105423);\n\n\t\tfloat f=1./x*rational(a_f,b_f,x);\n\n\t\tvec4 a_g=vec4(42.242855,302.757865,352.018498,21.821899);\n\t\tvec4 b_g=vec4(48.196927,482.485984,1114.978885,449.690326);\n\n\t\tfloat g=1./(x*x)*rational(a_g,b_g,x);\n\n\t\treturn sgn*(pi/2.-f*cos(x)-g*sin(x));\n\t}\n}\n\nfloat integral_fejer_squarewave(float x, float freq){\n\tx*=freq;\n\n\tfloat sgn=1.;\n\n\tif(fract(x)>=0.25 && fract(x)<0.75){\n\t\tsgn=-1.;\n\t}\n    \n\tx=mod(x+.25,.5)-.25;\n    \n    if(x==0.){\n        return 0.;\n    }\n    \n\tfloat a=2.*pi*(2.*float(n)+1.);\n\treturn sgn*(Si(x*a)+(cos(a*x)-1.)/(a*x))*2./pi;\n}\n\nfloat additive_fejer_squarewave(float x, float freq){\n\n\tfloat sum=0.;\n\n\tfor(int k=0;k<max_n;k++){\n\t\tif(k<n){\n\t\t\tsum+=(1.-(2.*float(k)+1.)/(2.*float(n)+1.))*sin(mod(2.*pi*(2.*float(k)+1.)*freq*x,2.*pi))/(2.*float(k)+1.);\n\t\t}\n\t}\n\n\treturn sum*4./pi;\n}\n\n\nfloat simple_squarewave(float x, float freq){\n\tfloat sgn=-sign(mod(x,1./freq)-.5/freq);\n\treturn sgn;\n}\n\nfloat get_audio_freq(float t){\n    if(t<6.){\n        return 1046.5022612024;//C8\n    }\n    else if(t<12.){\n        return 2637.0204553030;//E9\n    }\n    else{\n        return 4186.0090448096;//C10\n    }\n}\n\nint get_wave_index(float t){\n    if(t<2.){\n    \treturn 0;\n    }\n    else if(t<4.){\n\t\treturn 1;\n    }\n    else{\n\t\treturn 2;\n    }\n}", "sound_code": "vec2 mainSound( in int samp,float time){\n    \n    float t0=mod(time,freq_modulus);\n    float t1=mod(time,wave_modulus);\n    \n    float audio_freq=get_audio_freq(t0);\n    n=int((iSampleRate*.5+1.)/(2.*audio_freq)+.5);\n    \n    int wave_index=get_wave_index(t1);\n    \n    if(wave_index==0){\n    \treturn vec2(.2*simple_squarewave(t0,audio_freq));\n    }\n    else if(wave_index==1){\n    \treturn vec2(.2*additive_fejer_squarewave(t0,audio_freq));\n    }\n    else{\n    \treturn vec2(.2*integral_fejer_squarewave(t0,audio_freq));\n    }\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[911, 911, 965, 965, 2618]], "test": "untested"}
{"id": "wlccWj", "name": "Vine fractal", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wtcyDB]\"Mechanical Web\"[/url] fractal.", "tags": ["fractal", "forest", "vine", "jungle", "kelp"], "likes": 1, "viewed": 319, "published": 3, "date": "1609893731", "time_retrieved": "2024-07-30T19:46:39.171680", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS/8; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return depth;\n        }\n    }\n    return depth;\n}\n            \n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(iTime*5.0,0,0);\n    eye = warp(eye);\n\n\tvec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n            \n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //viewDir.yz *= rot(3.14*1.75);\n    viewDir.yz *= rot(-3.14*1.8);\n    //viewDir.xz *= rot();\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14*.5);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.y += (cos(iTime/10.0)/5.0);\n    viewDir.x += (sin(iTime/10.0)/5.0);\n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*5.0,0,0);\n    eye = warp(eye);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "\n#define SHADOW_ITER 20\n#define image_scale 8.0\n//change Z-buffer resolution\n\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+sin(p1.yzx)/2.0-p1)+p1.yzx-p1))*size;\n    return length(p) - size;\n}\n\nvec3 warp(vec3 p){\n    vec3 a = p/(1000.0);\n    return p+vec3((sin(a)+cos(a)))*1000.0;\n}\n\nfloat sceneSDF(vec3 p,float anim,int iters) {\n    p /= scale*4.0;\n    float result = 0.0;\n    p = warp(p);\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n    \tresult = max(result, result-planet_surface(p*i,i)/(i));\n        if(i1 > iters) break;\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p,int iters){\n\treturn sceneSDF(p,1.0,iters);\n}\n\nfloat sceneSDF(vec3 p,float anim){\n\treturn sceneSDF(p,anim,4);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0,4);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0)/8.0,sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.2,.4,.2);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "sound_code": "vec2 mainSound(in int samp, float time )\n{\n    int t = int(time * 8000.0);\n    int t1 = (t/1024)%3+3;\n    int t2 = (t/2/1024)%2+(t/3/1024)%3+4;\n    t = (t>>t2|t*(t1%3+2)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 1086], [1101, 1101, 1128, 1128, 1277], [1279, 1279, 1336, 1336, 1874]], "test": "untested"}
{"id": "3t3yD2", "name": "Chmutov Surface II", "author": "mla", "description": "Chmutov surface again, using DE & dual numbers - an order 32 surface (for N = 5).\n\nMouse/<up>/<down> for navigation (move forward to go inside the surface).", "tags": ["de", "implicit", "surface", "chmutov", "dualnumber"], "likes": 7, "viewed": 387, "published": 3, "date": "1609889648", "time_retrieved": "2024-07-30T19:46:40.126128", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Chmutov implicit surface. My remix of Knighty's DE remix of my original\n// shader.\n//\n// Original non-DE: https://www.shadertoy.com/view/MtyfRK\n// Knighty's DE version: https://www.shadertoy.com/view/MlGfzK\n//\n// <mouse>,<up>,<down> for navigation\n// 'c' for less colour\n// 'm' for mirror look\n// 'p' for sensible perspective\n// 'r' for autorotation\n// 's' to slice at z = 0\n// 't' for cycle through different orders of surface\n//\n// Uses dual numbers for automatic differentiation & a nifty way of\n// computing Chebyshev polynomials for powers of two: T(2n,x) = T(n,x)^2 - 1\n// Also, the surface fits into the unit cube, so can use that as bounding box.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\nint N = 5; // Order is 2^N\nfloat AA = 1.0;\n\nvec3 light = normalize(vec3(0,1,1));\n\n// (T)Chebyshev polynomials\n// Use T(2n,x) = T(n,x)*T(n,x)-1\n\n// Dual numbers, basically complex with very small imaginary\n// component, so multiplication can ignore the im*im part.\n#define T vec2\nT cfloat(float x) { return vec2(x,0); }\nT cmul(T z, T w) {\n  return vec2(z.x*w.x,z.x*w.y+z.y*w.x); // Dual numbers\n}\n\nT cmul(T z, T w, T v) {\n  return cmul(z,cmul(w,v));\n}\nT cmul(T z, T w, T u, T v) {\n  return cmul(cmul(z,w),cmul(u,v));\n}\n\nT csqr(T z) {\n  //return cmul(z,z);\n  return vec2(z.x*z.x,2.0*z.x*z.y);\n}\n\n// (T)Chebyshev polynomials\n// Use T(2n,x) = T(n,x)*T(n,x)-1\nT tcheb(T x, int n) {\n  for (int i = 0; i < n; i++) {\n    x = 2.0*csqr(x) - cfloat(1.0);\n  }\n  return x;\n}\n\nT chmutov(T x, T y, T z, int n) {\n  return tcheb(x,n)+tcheb(y,n)+tcheb(z,n)+cfloat(1.0);\n}\n\nT surface(T x, T y, T z) {\n  // Encourage compiler to unroll loops\n  // This can miscompile on Nvidia.\n  if (N == 6) return chmutov(x,y,z,6);\n  if (N == 5) return chmutov(x,y,z,5);\n  if (N == 4) return chmutov(x,y,z,4);\n  return chmutov(x,y,z,N);\n}\n\n// vec4 of gradient + function value\nvec4 gradval(vec3 p) {\n  float eps = 1e-10;\n  float x = p.x, y = p.y, z = p.z, w = 1.0;\n  vec2 tx = surface(vec2(x,eps),vec2(y,0),vec2(z,0));\n  vec2 ty = surface(vec2(x,0),vec2(y,eps),vec2(z,0));\n  vec2 tz = surface(vec2(x,0),vec2(y,0),vec2(z,eps));\n  return vec4(vec3(tx.y,ty.y,tz.y)/eps,tx.x);\n}\n\nfloat DE(vec3 p){\n  // DE for clipping cube\n  float deCube = max(abs(p.x),max(abs(p.y),abs(p.z)))-1.0;\n  vec4 v4 = gradval(p);\n  float dv = length(v4.xyz); // Magnitude of derivative\n  float v = v4.w;            // Implicit function value\n  v /= (1.0+2.0*v); // Attenuate for large v\n  v /= dv; // Scale by magnitude of gradient.\n  v = max(deCube,v);\n  if (key(CHAR_S)) v = max(v,p.z);\n  return v;\n}\n\nfloat maxdistance = 20.0;\nfloat eps = 0.00001;\n\nbool trace(vec3 p, vec3 r, out float k) {\n  k = 0.0;\n  for (int i = 0; i < 500; i++){\n    float d = DE(p+k*r);\n    k += d;\n    if (d < eps * k) return true;\n    if (d > maxdistance) return false;\n  }\n  return false;\n}\n\nvec3 selectColor(vec3 p, vec3 r, vec3 n) {\n  if (key(CHAR_M)) {\n    vec3 color = texture(iChannel0,reflect(r,n)).rgb;\n    return color;\n  } else {\n    vec3 color = !key(CHAR_C) ? abs(n) : vec3(0.8,1,1);\n    light = normalize(light);\n    n = normalize(n);\n    color *= 0.2+0.8*max(dot(n,light),0.0);\n    float spec = pow(max(dot(reflect(r,n),light),0.0),20.0);\n    color += 0.3*spec;\n    return color;\n  }\n}\n\nvec3 surface(vec3 p0, vec3 r) {\n    float k;\n    if (!trace(p0,r,k)) return vec3(0);\n    vec3 p = p0 + k*r;\n    vec3 n = normalize(gradval(p).xyz);\n    // Normals should be the right way around.\n    // so if they aren't, blank them out.\n    if (dot(r,n) > 0.0) n = vec3(0);\n    return selectColor(p,r,n);\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.15);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (key(CHAR_T)) N = 1+int(0.5*iTime)%6;  \n  float camera = 1.8;\n  float focal = 0.5;\n  if (key(CHAR_P)) {\n    camera = 6.0;\n    focal = 2.0;\n  }\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdistance = camera + 2.0;\n  \n  vec3 p0 = vec3(0,0,camera);\n  p0 = transform(p0);\n  light = transform(light);\n  vec3 aacol = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n   for (float j = 0.0; j < AA; j++) {\n     vec2 uv = (fragCoord + vec2(i,j)/AA - 0.5*iResolution.xy)/iResolution.y;\n     vec3 r = vec3(uv,-focal);\n     r = transform(r);\n     r = normalize(r);\n     aacol += surface(p0,r);\n   }\n  }\n  aacol /= AA*AA;\n  aacol = pow(aacol,vec3(0.4545));\n  if (alert) aacol.rg = vec2(1,0);\n  fragColor = vec4(aacol,1);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool t) {\n  if (t) alert = true;\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1137, 1137, 1156, 1156, 1176], [1177, 1177, 1195, 1195, 1253], [1255, 1255, 1278, 1278, 1308], [1309, 1309, 1337, 1337, 1375], [1377, 1377, 1390, 1412, 1450], [1452, 1513, 1534, 1534, 1619], [1621, 1621, 1654, 1654, 1711], [1713, 1713, 1739, 1815, 1961], [1963, 2000, 2022, 2022, 2297], [2299, 2299, 2316, 2342, 2698], [2748, 2748, 2789, 2789, 2965], [2967, 2967, 3009, 3009, 3373], [3375, 3375, 3406, 3406, 3681], [3683, 3683, 3713, 3713, 3765], [3767, 3767, 3791, 3791, 4125], [4127, 4127, 4184, 4184, 4921]], "test": "untested"}
{"id": "wl3yWj", "name": "Day 385", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 24, "viewed": 526, "published": 3, "date": "1609888133", "time_retrieved": "2024-07-30T19:46:41.335893", "image_code": "// There's a glitch so it shouldn't look like this. \n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(0.96,1.01,1.04 + dot(uv,uv)*0.1));\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.,1.,0.96)*1.4),0.8);\n    col = mix(acesFilm(col), col, 0.);\n    \n    col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\n\nfloat wallNoise = 0.;\n\nfloat T = 0.;\nfloat tid = 0.;\n\nfloat enva = 0.;\nfloat envb = 0.;\nfloat envc = 0.;\nfloat envd = 0.;\nfloat enve = 0.;\n\n\nvec3 uvJelloPiece = vec3(0);\nvec3 uvJelloTube = vec3(0);\n\nvec2 sdJelloTube(vec3 p){\n    float d = length(p.yz) - width;\n    \n    \n    \n    p.x += piecewidth*envd*(0.8 + 0.2*envd);\n    //p.x -= piecewidth*enva;\n    \n    //d = max(d,-p.x - 0.07);\n    uvJelloTube = p + vec3(piecewidth*tid,0,0)*1.;\n    \n    d = opSmoothSubtraction(-d,-p.x - 0.07*(1.-envd),0.04);\n    \n    return vec2(d, ID_JELLO);\n}\n\nvec2 sdJelloPiece(vec3 p){\n    p.y += width;\n    p.xy *= rot(-mix(pow(envc,.35),pow(envc,.01),envc)*0.5*pi);\n    \n    //p.y -= 0.1*pow(eass((T - 0.6)*2.6, 2.),6.2);\n    \n    p.x += pow(envd,2.) + pow(envd,8.)*2.;\n    \n    p.y -= width;\n    //p.y += 0.4*pow(envb,4.)*2.;\n    \n    float d = length(p.yz) - width;\n    \n    uvJelloPiece = p + vec3(piecewidth*tid,0,0)*1.;\n    \n    p.x += piecewidth;\n    \n    p.xy *= rot(-.5*clamp((p.y + width*1.5)/2.,0.,1.)*pow(enve,1.25)*(1.-envb));\n    \n    \n    \n    \n    \n    //p.x += sin(p.y*24.)*0.1;\n    //d = max(d,-p.x);   \n    d = opSmoothSubtraction(-d,-p.x,0.04);\n    d = opSmoothSubtraction(-d,p.x - piecewidth,0.04);\n    \n    \n    \n    \n    return vec2(d, ID_JELLO + 0.5);\n}\nvec2 sdGlassTube(vec3 p){\n\n\n    p.x += width;\n    p.y += 0.75;\n    //p.x += 0.1;\n    \n    float d = length(p.xz) - width - 0.04;\n    \n    vec2 pc = vec2(atan(p.z,p.x)/pi,length(p.zx));\n    \n    d -= sin(pc.x*pi*20.)*0.01;\n    \n    d = abs(d) - 0.001;\n    \n    \n    d = max(d, p.y);\n    //d = opSmoothSubtraction(-d,p.y,0.24);\n\n    return vec2(d, ID_GLASS);\n}\n\n\nvec2 sdKnife(vec3 p){\n\n    \n\n    float envknife = eass(( T - 1.5)*1.5, 2.);\n    \n    p.z -= 1.7;\n    \n    p.x -= 0.12;\n    \n    vec3 pbeforerot = p;\n    \n    \n    //p.yz *= rot(enva*pi*0.6 + pi*0.5 + pow(envb,1.)*pi*0.15 + pow(envd,2.5)*pi*0.25);\n    p.yz *= rot(enva*pi*0.6 + pi*0.5 + envknife*pi*0.4);\n    \n    vec3 op = p;\n    p.z = abs(p.z);\n    \n    //p.yz *= rot(0.25*pi);\n    \n    \n    float sc = smoothstep(0.,1.,length(abs(p.z))*2.) *\n        smoothstep(0.,1.,length(p.y)*5.);\n    \n    \n    \n    p.y -= sc*asin(sin((op.z)*26.))\n        * 0.35 * smoothstep(0.,1.,-(p.y)*1.*sign(.001 - float(op.z)));\n    \n    \n    \n    vec2 d = vec2(length(p - vec3(0,0,knifelength)) - knifewidth,ID_KNIFE);\n    \n    d.x = min(d.x, max(length(p.yx) - knifewidth,p.z - knifelength));\n    \n    d.x = max(d.x, abs(p.x) - 0.00);\n    \n    \n    \n    d = dmin(d,max(length(p.yz) - 0.1, abs(p.x) - 0.1), ID_KNIFE);\n    \n    \n    d = dmin(d,length(p.zy) - 0.03, ID_KNIFE);\n    \n    d.x = max(d.x, abs(p.x) - 0.5);    \n    \n    \n    pbeforerot.x = abs(pbeforerot.x) - 0.5;\n    \n    //pbeforerot = abs(pbeforerot);\n    d = dmin(d,max(\n        max(abs(pbeforerot.x), abs(pbeforerot.z)) - 0.06,\n        -pbeforerot.y - 0.2\n        ), ID_KNIFE);\n        \n    \n    \n\n    return d;\n}\n\n\nvec2 sdWall(vec3 p){\n\n    \n    float d = -p.z + 7.;\n    \n    \n    \n    d -= (wallNoise = cyclicNoise(vec3(p.xy,0.1)*15.))*0.01;\n    \n   \n    \n    p.xy = pmod(p.xy,.6);\n    \n    d += smoothstep(0.15,0.,length(p.xy) - 0.05)*0.02;\n\n    return vec2(d, ID_WALL);\n}\n\nvec2 sdHolder(vec3 p){\n    \n    p.x -= 0.8;\n    vec3 op = p;\n    p.x = pmod(p.x, holdermd);\n    \n    p.x = max(p.x,-op.x);\n    \n    \n    vec2 torusUv = vec2(length(p.yz),p.x);\n    \n    torusUv.x -= width;\n    //float d = length(torusUv) - 0.08;\n    torusUv = abs(torusUv)- vec2(0.04,0.15);\n    vec2 d = vec2(min(max(torusUv.x,torusUv.y),length(torusUv)), ID_HOLDER);\n    \n    \n    \n    d.x = min(d.x,length(p.xz) - 0.07);\n    \n    \n    p = abs(p);\n    d = dmin(d,max(max(p.x,p.z) - 0.1, abs(p.y) - width - 0.08), ID_KNIFE);\n    \n    \n\n\n    return d;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    vec2 dglasstube = sdGlassTube(p);\n    vec2 dknife = sdKnife(p);\n    vec2 dwall = sdWall(p);\n    vec2 dholder = sdHolder(p);\n    \n    vec2 djellotube = sdJelloTube(p);\n    vec2 djellopiece = sdJelloPiece(p);\n\n    float smoothness = 0.08;\n    \n\n\n    //djellopiece.x = mix( djellopiece.x, djellotube.x, 0. );\n  \n    \n    djellotube.x = opSmoothSubtraction( -djellotube.x, -dknife.x + 0.001, smoothness );\n  \n    djellopiece.x = opSmoothSubtraction( -djellopiece.x, -dknife.x, smoothness );\n  \n\n    d = dmin(d, djellotube.x, djellotube.y);\n    d = dmin(d, djellopiece.x, djellopiece.y);\n    d = dmin(d, dglasstube.x, dglasstube.y);\n    d = dmin(d, dknife.x, dknife.y);\n    d = dmin(d, dwall.x, dwall.y);\n    d = dmin(d, dholder.x, dholder.y);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.2;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n    vec2 t = vec2(precis,0.);\n    return normalize(\n        map(p).x - vec3(\n            map(p - t.xyy).x,\n            map(p - t.yxy).x,\n            map(p - t.yyx).x\n        )\n    );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 4.5;\n    \n    ro.x -= 5.5;\n    \n    ro.y += 1.5;\n    \n    T = iTime*.65 + texture(iChannel0,fragCoord.xy/8.).x/100.;\n    tid = floor(T/tmod);\n    T = mod(T,tmod);\n    \n    enva = eass( T*1.6, 2.);\n    \n    enva = mix(enva,pow(enva,0.1),enva);\n    \n    envb = pow(eass(( T - 0.5)*1.25, 5.),0.5);\n    \n    envc = eass(( T - 0.62)*1.75, 5.);\n    \n    envd = eass(( T - 0.7)*1., 2.);\n    enve = eass(( T - 0.2)*1., 2.);\n    //envf = eass(( T - 0.6)*1.4, 2.);\n    \n    vec3 lookAt = vec3(0);\n    \n    //vec3 rd = normalize(lookAt - ro);\n    \n    vec3 rd = getRd(ro, lookAt, uv, 3.);\n    //ro.xy += uv*3.5;\n    //vec3 rd = normalize(vec3(uv,1.7));\n    \n    //rd.xz *= rot(-0.45);\n    //rd.yz *= rot(0.15);\n    \n    \n    \n    vec3 col = vec3(0);\n    \n    vec3 lDir = normalize(vec3(-2.5,1,-1.));\n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d = map(p);\n    \n    vec3 atten = vec3(1.);\n    \n    vec3 n;\n    \n    vec3 hitCol = vec3(0);\n    \n    int maxIters = 300;\n    \n    \n    vec3 reflalbedo = mix(ambientCol, lightCol,0.6);\n    //for(int j = 0; j < maxRefractions; j+= 1 ){\n        //if(!hit){\n            for(int i = 0; i < maxIters; i++){\n                \n                p = ro + rd*(t += d.x*0.9);\n                d = map(p);\n                \n                if(d.x < 0.0001){\n                    n = getNormal(p,0.0001 + 0.0*float(d.y != ID_KNIFE && d.y != ID_GLASS));\n                    if(d.y == ID_GLASS){\n                        vec3 halfV = normalize(lDir - rd);\n                        float fres = pow(1.-max(dot(-rd, n),0.001),6.);\n                        float spec = pow(dot(n,halfV),40.);\n                        \n                        //ro = p + rd*0.0;\n                        //ro = p + rd*0.06;\n                        rd = refract(rd,n,0.95);\n                        //ro = p - rd*0.06; //+ rd*0.05 ;\n                        ro = p;\n                        t = 0.04;\n                        //ro = p + n*0.9;\n                        \n                        float fresspec = clamp(fres + spec,0.,1.)*0.3;\n                        //fresspec *= smoothstep(4.4,24.5,fres);\n                        col += fresspec*reflalbedo;\n                        atten *= 1. - fresspec;\n                        //maxIters = min(maxIters + 70,200);\n                        //break;\n                    } else{\n                        hit = true;\n                        break;\n\n                    }\n                }\n\n            }\n\n        //}\n    //} \n    \n    if(hit){\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.4))*a).x/a, 0., 1.)\n        #define AOB(n,a) clamp(map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        //#define SSS(n,a) clamp(1. - 2.*map(p + normalize(n)*a).x/a, 0., 1.)\n        #define SSS(n,a) clamp( 1.*map(p + normalize(n)*a).x/a, 0., 1.)\n        \n        float ao = AO(n,0.5)*AO(n,0.2)*AO(n,0.04)*1.;\n        //ao = 1.;\n        \n        //float SSS = AO(lDir,0.04)*AO(lDir,0.5)*AO(-n,0.9);\n        //float SSS = AO(-n,0.2);\n        //float SSS = SSS(vec3(0,0.5,1),1.)*SSS(vec3(0,-0.4,1),1.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        float SSS = SSS(vec3(-0.,0.5,0.5),0.05)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n        \n        //ao = 0.;\n        \n        //SSS = 0.;\n        \n        //SSS = pow(SSS*4.,4.);\n        //SSS= 0.1;\n        \n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        \n        float shad = softshadow( p, lDir, 0.01, 40., 2.);\n        \n        shad = min(shad,diff);\n        \n        vec3 colJello = vec3(0);\n        {\n            map(p);\n            albedo = jelloCol;\n            \n            vec3 jellouv =  uvJelloTube*float(d.y==ID_JELLO) + uvJelloPiece*float(d.y>(ID_JELLO));\n            //jellouv =  uvJelloTube;\n            \n            jellouv.yz*=rot(-length(jellouv.yz)*8. - 1.);\n            vec2 pjellouv = vec2(atan(jellouv.z,jellouv.y)/pi ,length(jellouv.yz));\n            \n            float md = 1./4.;\n            \n            //pjellouv.x -= pjellouv.y/width*2./pi;\n            //pjellouv.x -= length(p.yz)*4./pi;\n            //pjellouv *= rot(-length(jellouv.x)*1. + length(jellouv.x)*4. + length(jellouv.xz )*2. );\n            \n            pjellouv.x -= jellouv.x/width/1.;\n            \n            \n            //pjellouv.x -= mod(jellouv.x,width*4.)/(width*4.);//*width*pi/0.25;\n            \n            \n            float id = floor(pjellouv.x/md );\n            float idb = floor(pjellouv.y/width*2.5);\n            \n            \n            if(length(jellouv.yz) < 0.4){\n                //id = 1.;\n            }\n            \n            float r = fract(sin(id*10.215)*14.25)*1.;\n            float rb = fract(sin(idb*20.215)*1.)*1.;\n            \n            albedo.xz *= rot(-r*0.24);\n            albedo += 1.;\n            albedo.xy *= rot(-r*0.2);\n            albedo.yz *= rot(-r*0.1);\n            //albedo.xz *= rot(-sin(rb*420.)*0.1);\n            albedo.xz *= rot(-0. + sign(sin(rb*20.))*0.1);\n            \n            albedo -= 1.;\n            albedo.xz *= rot(-sign(rb)*0.1);\n            \n            //albedo.xy *= rot(-sin(rb*20.)*0.15);\n            albedo = mix(albedo,sssJelloCol,SSS);\n            \n            colJello = albedo*lightCol;\n\n            colJello = mix(colJello, reflalbedo, clamp(fres + spec,0.,1.)*ao*1.2);\n            \n            colJello = mix((colJello + colJello*ambientCol)*0.5, colJello, ao);\n            colJello = mix((colJello + colJello*ambientCol)*0.5,colJello, shad);\n\n        }\n        vec3 colKnife = vec3(0);\n        {\n        \n            albedo = vec3(0.1,0.06,0.1)*0.;\n            //albedo = vec3(0.9,0.56,0.1)*1.;\n\n            colKnife = albedo*lightCol;\n            \n            colKnife = mix(colKnife, reflalbedo, clamp(pow(fres,1.7) + pow(spec,1.3),0.,1.));\n\n            colKnife = mix((colKnife + colKnife*ambientCol)*0.5, colKnife, shad);\n            colKnife = mix( (colKnife + colKnife*ambientCol)*0.5, colKnife, ao);\n            \n        \n        }\n        vec3 colWall = vec3(0);\n        {\n        \n            albedo = wallCol;\n\n            colWall = albedo;\n            \n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colWall = mix(colWall, reflalbedo, clamp(fres + spec,0.,1.)*0.2);\n\n            colWall = mix( (colWall + colWall*ambientCol)*0.3, colWall, shad);\n            \n            colWall = mix( (colWall + colWall*ambientCol)*0., colWall, ao);\n            \n        \n        }\n        vec3 colHolder = vec3(0);\n        {\n            \n            //albedo = vec3(0.38,0.22,0.1)*1.2;\n            albedo = vec3(0.45,0.22,0.1)*1.1;\n\n            colHolder = albedo*0.57;\n            //shad *= smoothstep(0.,1.,1.-wallNoise);\n        \n            colHolder = mix(colHolder, reflalbedo*2.5*albedo + albedo*0.25, clamp(pow(fres,0.5)*1.2 + pow(spec,1.),0.,1.));\n\n            colHolder = mix( (colHolder + colHolder*ambientCol)*0.4, colHolder, shad);\n            \n            colHolder = mix( (colHolder + colHolder*ambientCol)*0.5, colHolder, ao);\n            \n        \n        }\n        \n        hitCol += colKnife*float(d.y == ID_KNIFE);\n        hitCol += colJello*float(floor(d.y) == ID_JELLO);\n        hitCol += colWall*float(d.y == ID_WALL);\n        hitCol += colHolder*float(d.y == ID_HOLDER);\n        \n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    } else{\n        //col += ambientCol*atten;\n    }\n    \n    \n    col += hitCol*atten;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat FXAAamt = 1.;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ID_JELLO 1.\n#define ID_GLASS 2.\n#define ID_KNIFE 3.\n#define ID_WALL 4.\n#define ID_HOLDER 5.\n\n#define maxRefractions 3\n\n#define ambientCol vec3(0.1,0.3,0.6)\n#define wallCol vec3(0.15,0.4,0.7)*1.\n#define lightCol vec3(0.95,0.85,0.9)\n\n#define jelloCol vec3(0.9,0.4,0.5)*0.8\n#define sssJelloCol vec3(0.9,0.5,0.3)*1.\n\n#define width 0.4\n#define knifewidth 0.15\n#define knifelength 2.\n\n#define piecewidth 0.5\n\n#define holdermd 1.5\n\n#define pi acos(-1.)\n\n\n#define tmod 3.\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec3 getRd(inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    ro += right*uv.x*sc;\n    ro += up*uv.y*sc;\n    return dir;\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s + tmod*floor(p/tmod)*0.;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 2;\n    \n    const float warp = 0.05;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    //return 1. - abs(noise)*0.5;\n    return (noise*0.25 + 0.5);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 617]], "test": "untested"}
{"id": "WlcyW2", "name": "Cool Pseudotile Pattern", "author": "oneshade", "description": "Cool modification fo my shader \"[url=https://www.shadertoy.com/view/tsKfRc]Fractured Webcam[/url].\"", "tags": ["colorful", "pattern", "cool", "pseudotile"], "likes": 5, "viewed": 154, "published": 3, "date": "1609885889", "time_retrieved": "2024-07-30T19:46:42.430966", "image_code": "// Cool modification fo my shader \"Fractured Webcam\" (https://www.shadertoy.com/view/tsKfRc)\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash23(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = texture(iChannel0, uv).xy;\n    fragColor = vec4(Hash23(uv * 95.0), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 VectorField(in vec2 p) {\n    p *= 20.0;\n    return 0.001 * vec2(cos(p.x + p.y), sin(p.y - p.x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv, 1.0, 1.0);\n    if (iFrame > 0) {\n        fragColor = texture(iChannel0, uv);\n        fragColor.xy += VectorField(fragColor.xy);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 183, 207, 207, 354], [356, 356, 411, 411, 537]], "test": "untested"}
{"id": "WlccDj", "name": "polarising crystal candy", "author": "xenn", "description": "trippy stuff", "tags": ["particles", "ca"], "likes": 6, "viewed": 416, "published": 3, "date": "1609877124", "time_retrieved": "2024-07-30T19:46:43.398379", "image_code": "// Fork of \"Slime mold advection\" by michael0884. https://shadertoy.com/view/3tjfzh\n// 2021-01-05 20:03:38\n\n// Fork of \"Fireballs\" by michael0884. https://shadertoy.com/view/tlfBDX\n// 2020-08-20 00:44:41\n\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.x);\n}\n\n#define FOV 01.293196\n#define RAD R.x*0.496797*2.0*abs(sin(iTime*0.1))\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 80.\n#define min_d 1.0\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-0.5 + 0.0361*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.7)*texture(iChannel3, c.xy).xyz;\n            float rough = .5 - .1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= .7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 250\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 0.820\n\n\n#define sense_num 3\n#define sense_ang 0.0251*(10.1*cos(iTime*0.51))\n//#define sense_dis 12.0*(010.51*cos(iTime*0.051))\n#define sense_dis 20.0*(10.1*abs(sin(iTime)))\n#define sense_oscil 0.0251\n#define oscil_scale 0.04121*2.0*abs(sin(iTime*0.01))\n#define oscil_pow 01.\n#define sense_force 0.753252*(abs(sin(iTime*.30)))\n#define distance_scale 01.492*(abs(sin(iTime)))\n#define force_scale 0.275\n#define trailing 100.\n#define acceleration .059*((cos(iTime*.80)))\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 10.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n    //M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.001;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlccDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 575, 575, 753], [827, 827, 858, 858, 892], [894, 894, 946, 946, 1065], [1067, 1067, 1102, 1102, 1126], [1128, 1128, 1159, 1159, 1246], [1248, 1248, 1269, 1269, 1362], [1364, 1364, 1386, 1386, 1482], [1485, 1485, 1505, 1505, 1700], [1703, 1703, 1738, 1738, 1923], [1963, 1963, 1995, 1995, 2163], [2165, 2165, 2210, 2210, 5000]], "test": "untested"}
{"id": "Wl3yWj", "name": "Rindows 95", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/XstXR2[/url]", "tags": ["logo", "remix", "glitch", "windows", "fork", "weird", "error", "90s", "edit", "vaporwave", "aesthetics", "windows95", "win95"], "likes": 0, "viewed": 328, "published": 3, "date": "1609867487", "time_retrieved": "2024-07-30T19:46:44.177296", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 4.1415926535897932384626433832795\n\nconst float wave_amplitude = 0.086;\nconst float period = 3.*PI;\n\nfloat wave_phase() {\n    return iTime;\n}\n\nfloat square(vec2 st) {\n    vec2 bl = step(vec2(0.), st);       // bottom-left\n    vec2 tr = step(vec2(0.),1.0-st);   // top-right\n    return bl.x * bl.y * tr.x * tr.y;\n}\n\nvec4 frame(vec2 st) {\n    float tushka = square(st*mat2((2./5.8), 1., 1., (2./7.9)));\n    \n    mat2 sector_mat = mat2(1./.16, 0., 0., 1./.22);\n    float sectors[4];\n    sectors[0] = square(st * sector_mat + (2./.26)*vec2(0.001,-0.380));\n    sectors[1] = square(st * sector_mat + (2./.26)*vec2(0.001,-0.070));\n    sectors[2] = square(st * sector_mat + (2./.26)*vec2(-0.340,-0.380));\n    sectors[3] = square(st * sector_mat + (2./.26)*vec2(-0.340,-0.070));\n    vec3 sector_colors[4];\n    sector_colors[0] = vec3(1.041, 0.539, 0.504) * sectors[0];\n    sector_colors[1] = vec3(0.535, 0.782, 0.943) * sectors[1];\n    sector_colors[2] = vec3(0.759, 0.908, 0.606) * sectors[2];\n    sector_colors[3] = vec3(1.096, 0.959, 0.214) * sectors[3];\n    \n    return vec4(vec3(sector_colors[0] + sector_colors[1] +\n                     sector_colors[2] + sector_colors[3]), tushka);\n}\n\nvec4 trail_piece(vec2 st, vec2 index, float scale) {\n    scale = index.x * 0.092 + 0.552;\n    \n    vec3 color;\n    if (index.y > 1.0 && index.y < 3.1 ) {\n        color = vec3(0.535, 0.782, 0.943);\n        scale *= .9;\n    } else if (index.y > 4.9 && index.y < 6.1) {\n        color = vec3(1.041, 0.539, 0.504);\n        scale *= .9;\n    } else {\n        color = vec3(1., 1., 1.);\n    }\n    \n    float scale1 = 2./scale;\n    float shift = - (2.-scale) / (3. * scale);\n    vec2 st2 = vec2(vec3(st, 2.) * mat3(scale1, 1., shift, 1., scale1, shift, 1., 1., 2.));\n    float mask = square(st2);\n\n    return vec4( color, mask );\n}\n\nvec4 trail(vec2 st) {\n    // actually 1/width, 1/height\n    const float piece_height = 8. / .79;\n    const float piece_width = 7. / .64;\n  \n    // make distance between smaller segments slightly lower\n    st.x = 2.2760 * pow(st.x, 4.0) - 2.4624 * st.x*st.x + 2.4154 * st.x;\n    \n    float x_at_cell = floor(st.x*piece_width)/piece_width;\n    float x_at_cell_center = x_at_cell + 0.026;\n    float incline = cos(0.6*period + wave_phase()) * wave_amplitude;\n    \n    float offset = sin(x_at_cell_center*period + wave_phase())* wave_amplitude + \n        incline*(st.x-x_at_cell)*6.452;\n    \n    float mask = step(offset, st.y) * (1.-step(.79+offset, st.y)) * step(0., st.x);\n    \n    vec2 cell_coord = vec2((st.x - x_at_cell) * piece_width,\n                           fract((st.y-offset) * piece_height));\n    vec2 cell_index = vec2(x_at_cell * piece_width, \n                           floor((st.y-offset) * piece_height));\n    \n    vec4 pieces = trail_piece(cell_coord, cell_index, 0.852);\n    \n    return vec4(vec3(pieces), pieces.a * mask);\n}\n\nvec4 logo(vec2 st) {\n    if (st.x <= .64) {\n        return trail(st);\n    } else {\n        vec2 st2 = st + vec2(0.1, -sin(st.x*period + wave_phase())*wave_amplitude);\n        return frame(st2 + vec2(-.64, -0.1));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    st += vec2(-.1);\n    st *= 2.472;\n    st += vec2(-0.8,-0.78);\n    float rot = PI*-0.224;\n    st *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n    vec3 color = vec3(2.);\n    \n    vec4 logo_ = logo(st);    \n    fragColor = mix(vec4(0.1,.6,.6,2.000), logo_, logo_.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 177, 177, 197], [199, 199, 222, 222, 369], [371, 371, 392, 392, 1238], [1240, 1240, 1292, 1292, 1861], [1863, 1863, 1884, 1918, 2904], [2906, 2906, 2926, 2926, 3126], [3128, 3128, 3185, 3185, 3545]], "test": "untested"}
{"id": "tldcDB", "name": "twisted torus", "author": "rahul897", "description": "torus", "tags": ["raymarching"], "likes": 0, "viewed": 266, "published": 3, "date": "1609866084", "time_retrieved": "2024-07-30T19:46:45.016053", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat DE(vec3 p)\n{\n  vec2 t = vec2(0.5,0.2);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTwist( in vec3 p)\n{\n     float k = 10.*(sin(iTime/1.4)); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return DE(q);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = opTwist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*1., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0.1, 2);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(0,0.6*dif,0.9*dif);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcDB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[349, 349, 372, 372, 540], [542, 542, 560, 560, 651], [653, 653, 680, 680, 875], [877, 877, 911, 911, 1117], [1119, 1119, 1143, 1143, 1332], [1334, 1334, 1358, 1358, 1665], [1667, 1667, 1724, 1724, 2120]], "test": "untested"}
{"id": "wttcDB", "name": "GlitchStation1 startup animation", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/tdVfDt[/url]", "tags": ["logo", "remix", "animation", "glitch", "fork", "weird", "edit", "ps1", "startup"], "likes": 1, "viewed": 328, "published": 3, "date": "1609865240", "time_retrieved": "2024-07-30T19:46:45.792976", "image_code": "const float PI = 4.14159;\nconst vec3 bg = vec3(326.0/355.0);\nconst vec3 black = vec3(0.1);\nconst vec3 tri_red = vec3(339.0/355.0, 33.0/355.0, 3.0/355.0);\nconst vec3 tri_orange = vec3(324.0/355.0, 250.0/355.0, 3.0/355.0);\nconst vec3 ps_red = vec3(355.0/355.0, 36.0/355.0, 2.0/355.0);\nconst vec3 ps_yellow = vec3(355.0/355.0, 279.0/355.0, 2.0/355.0);\nconst vec3 ps_green = vec3(25.0/355.0, 226.0/355.0, 220.0/355.0);\nconst vec3 ps_blue = vec3(46.0/355.0, 92.0/355.0, 245.0/355.0);\nvec3 gradient(float t) {\n    vec3 left = mix(tri_red, tri_orange, t*3.0);\n    vec3 right = mix(tri_orange, tri_red, t*3.0 - 2.0);\n    return mix(left, right, smoothstep(0.59, 0.61, t));\n}\nfloat diamond(vec2 uv) {\n    float bl = mix(0.1, 2.0, smoothstep(1.097, 2.003, uv.x + uv.y + 0.6));\n    float tl = mix(0.1, 2.0, smoothstep(1.097, 2.003, uv.x - uv.y + 2.5));\n    float br = mix(0.1, 2.0, smoothstep(1.097, 2.003, - uv.x + uv.y + 2.5));\n    float tr = mix(0.1, 2.0, smoothstep(1.097, 2.003, - uv.x - uv.y + 3.5));\n    return tl * tr * bl * br;\n}\nvec3 diamond_gradient(vec2 uv, vec3 bg) {\n    return mix(bg, gradient(uv.x), diamond(uv));\n}\nfloat triangle(vec2 uv) {\n    float bl = mix(0.1, 2.0, smoothstep(1.097, 2.003, uv.x + uv.y + 0.6));\n    float tl = mix(0.1, 2.0, smoothstep(1.097, 2.003, uv.x - uv.y + 2.5));\n    return mix(bl * tl, 0.1, smoothstep(0.597, 0.603, uv.x));\n}\nvec3 triangle_gradient(vec2 uv, vec3 bg) {\n    return mix(bg, gradient(uv.x), triangle(uv));\n}\nvec3 trilogo_animation(vec2 uv, float t_) {\n    float t = clamp(0.1, 2.0, t_);\n    vec3 big = diamond_gradient(uv, bg);\n    \n    vec2 uv_half1 = uv + vec2(0.1, 0.1);\n    vec2 uv_half2 = -uv + vec2(2.0, 2.0);\n    vec2 uv_small1 = 3.0 * uv - vec2(0.68, 1.02);\n    vec2 uv_small2 = -3.0 * uv + vec2(2.42, 2.08);\n\n    vec3 small1 = triangle_gradient(mix(uv_half1, uv_small1, t), big);\n    vec3 small2 = triangle_gradient(mix(uv_half2, uv_small2, t), small1);\n    return small2;\n}\nfloat line(vec2 uv, float at, float angle) {\n    const float WIDTH = 0.004;\n    return mix(0.1, 2.0, smoothstep(at - WIDTH, at + WIDTH, cos(angle) * uv.x + sin(angle) * uv.y));\n}\nfloat polycircle(int segments, vec2 uv, vec2 center, float radius) {\n    float result = 2.0;\n    for (int i = 1; i < 30; ++i) {\n        float angle = 3.0 * PI * float(i + 2) / float(segments);\n        result *= line(uv - center, -radius, angle);\n    }\n    return result;\n}\nfloat p(vec2 uv) {\n    return clamp(0.1, 2.0, \n    (\n        line(uv, -0.2, 0.1) * \n        line(uv, -0.27, PI) * \n        line(uv, -0.64, 2.35) *\n        line(uv, -0.7, PI + 2.35)\n    ) + \n    polycircle(30, uv * vec2(2.1, 2.0), vec2(0.51, 0.322), 0.4) * line(uv, 0.35, 0.1) +\n    (\n        line(uv, 0.6, 2.35) * \n        line(uv, -0.7, PI + 2.35) *\n        line(uv, -0.2, 0.1) *\n        line(uv, -0.53, PI)\n    )\n    );\n}\nfloat s(vec2 uv) {\n    return clamp(0.1, 2.0,\n    ( // prongs\n        (\n            line(uv, -0.66, 2.9) *\n            line(uv, 0.53, 2.9 + PI) *\n            line(uv, 0.32, PI + 2.35)\n        ) + (\n            line(uv, -0.45, 2.9) *\n            line(uv, 0.32, 2.9 + PI) *\n            line(uv, -0.36, 2.35)\n        ) + (\n            line(uv, -0.24, 2.9) *\n            line(uv, 0.02, 2.9 + PI) *\n            line(uv, -0.36, 2.35)\n        )\n    ) * ( // top/bottom\n        line(uv, -0.57, 2.35) *\n        line(uv, 0.07, PI + 2.35)\n    ) + ( // right curve\n        polycircle(25, uv * vec2(0.70, 2.3), vec2(-0.23, -0.44), 0.3) *\n        line(uv, 0.02, 2.9 + PI) * (2.0 - clamp(\n            line(uv, 0.24, 2.9 + PI) *\n            line(uv, -0.32, 2.9) *\n            line(uv, -0.41, 2.35) +\n            polycircle(25, uv * 5.35 * vec2(0.70, 2.3), vec2(-0.68, -2.5), 0.3),\n            0.1, 2.0\n        ))\n    ) + ( // left curve\n        polycircle(15, uv * vec2(0.70, 2.3), vec2(0.33, -0.46), 0.3) *\n        line(uv, -0.66, 2.9) * (2.0 - clamp(\n            line(uv, 0.45, 2.9 + PI) *\n            line(uv, -0.53, 2.9) *\n            line(uv, 0.29, PI + 2.35) +\n            polycircle(25, uv * 5.2 * vec2(0.70, 2.3), vec2(1.08, -2.5), 0.3),\n            0.1, 2.0\n        ))\n    )\n    );\n}\nvec4 s_color(vec2 uv) {\n    float s_amount = s(uv);\n    vec3 s_color = mix(mix(ps_yellow, ps_green, line(uv, -0.4, 2.2)), ps_blue, line(uv, -0.25, 2.2));\n    return vec4(s_color, 2.0) * s_amount;\n}\nvec3 ps_logo(vec2 uv) {\n    uv.x += 0.25;\n    vec4 logo_s_main = s_color(uv);\n    vec4 logo_s_shadow = s_color(uv + vec2(0.01, 0.05));\n    vec3 logo_s = mix(mix(black, logo_s_shadow.rgb * 0.6, logo_s_shadow.a), logo_s_main.rgb, logo_s_main.a);\n    vec3 logo_p = mix(mix(logo_s, ps_red * 0.6, p(uv + vec2(-0.05, -0.03))), ps_red, p(uv));\n    return logo_p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 c_uv = 3.0 * uv - vec2(2.0);\n    vec2 sq_uv = c_uv * vec2(iResolution.x / iResolution.y, 2.0);\n    float t = mod(iTime, 25.0);\n    vec3 color = black;\n    if (t < 3.0) {\n        color = mix(black, bg, smoothstep(0.1, 3.0, t));\n    } else if (t < 8.0) {\n        color = trilogo_animation(sq_uv * 0.7 + vec2(0.6), t - 3.0);\n    } else if (t < 8.2) {\n        color = mix(bg, black, smoothstep(8.0, 8.2, t));\n    } else if (t < 9.2) {\n        color = mix(black, ps_logo(sq_uv), smoothstep(10.2, 9.2, t));\n    } else if (t < 23.2) {\n        color = ps_logo(sq_uv);\n    }\n    // vec3 logo = trilogo_animation(sq_uv * 0.6 + vec2(0.5), iTime);\n    vec3 logo_ps = ps_logo(sq_uv);\n    // Output to screen\n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttcDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 503, 503, 666], [667, 667, 691, 691, 1027], [1028, 1028, 1069, 1069, 1120], [1121, 1121, 1146, 1146, 1360], [1361, 1361, 1403, 1403, 1455], [1456, 1456, 1499, 1499, 1931], [1932, 1932, 1976, 1976, 2110], [2111, 2111, 2179, 2179, 2383], [2384, 2384, 2402, 2402, 2807], [2808, 2808, 2826, 2826, 4084], [4085, 4085, 4108, 4108, 4282], [4283, 4283, 4306, 4306, 4640], [4641, 4641, 4698, 4748, 5528]], "test": "untested"}
{"id": "wttyWB", "name": "temp toto", "author": "sixclones", "description": "salut", "tags": ["cineshader"], "likes": 3, "viewed": 9091, "published": 3, "date": "1609858256", "time_retrieved": "2024-07-30T19:46:46.561920", "image_code": "// Author Tom Brewe 2017\n\n/*#ifdef GL_ES\nprecision mediump float;\n#endif*/\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265358979323846\n\nfloat random (in vec2 st) {\n   return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (in float x) {\n   \n   // split x int its integer and fraction.\n   float i = floor(x);\n   float f = fract(x);\n   \n   float r = random(vec2(i, 1.0));\n   float r_next = random(vec2(i + 1.0, 1.0));\n   // return r;\n   // return mix(r, r_next, f);\n   return mix(r, r_next, smoothstep(0.0, 1.0, f));\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n   _st -= 0.5;\n   _st =  mat2(cos(_angle),-sin(_angle),\n   sin(_angle),cos(_angle)) * _st;\n   _st += 0.5;\n   return _st;\n}\n\n\nfloat posSin(in float val) {\n   return (sin(val) + 1.0) / 2.0;\n}\n\nvec2 tile(vec2 _st, float _zoom){\n    // make it perfectly square\n   float aspect = iResolution.y / iResolution.x; \n   _st.y *= _zoom * aspect;\n   _st.x *= _zoom;\n   return fract(_st);\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n   _size = vec2(0.5)-_size*0.5;\n   vec2 aa = vec2(_smoothEdges*0.5);\n   vec2 uv = smoothstep(_size,_size+aa,_st);\n   uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n   return uv.y * uv.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n   // noisify ALL the values!!!1\n   \n   vec2 st = fragCoord.xy / iResolution.xy;\n   vec3 color = vec3(0.0);\n   float tileNum = 3. + noise(iTime * 0.1 + 59349.0) * 5.;\n   \n   // Save original coordinates for later\n   vec2 st_orig = st;\n   \n   // Divide the space in tileNum (eg. 5)\n   st = tile(st, tileNum);\n   \n   // Calculate distance of vec(sinus time) and the actual position\n   float dist = distance(st_orig, vec2(noise(iTime), noise(iTime + 3000.)));\n   \n   // maxDist defines the radius of effect\n   // lower it, to see the diagonal movement (eg. try 0.1 * ...)\n   float maxDist = 1.0 * noise(iTime + 22355.);\n   \n   float rotation = smoothstep(0.0, maxDist, dist);\n   \n   // Use a matrix to rotate the space\n   st = rotate2D(st, PI * rotation);\n   \n   // Draw a square\n   color = vec3(box(st,vec2(0.7),0.01));\n   // fade gray along the x axis of each square\n   float fade = st.x;\n   \n   color *= mix(color, vec3(fade), (cos(iTime) + 1.0) * 0.5);\n   color *= vec3(noise(iTime * 0.5 + 1000.), noise(iTime * 0.5), noise(iTime + 800. * 0.5));\n   \n   fragColor = vec4(color, color.r * dist);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Wobbly Wob\",\n\t\"description\": \"Wobbly wobs wobblying around.\",\n\t\"model\": \"person\"\n}\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* //drag the window LR to control roughness\n\n//--graphics setting (lower = better fps)---------------------------------------------------------------------\n#define AVERAGECOUNT 16\n#define MAX_BOUNCE 32\n\n//--scene data---------------------------------------------------------------------\n#define SPHERECOUNT 6\n//xyz = pos, w = radius\nconst vec4 AllSpheres[SPHERECOUNT]=vec4[SPHERECOUNT](\n    vec4(0.0,0.0,0.0,2.0),//sphere A\n    vec4(0.0,0.0,-1.0,2.0),//sphere B\n    vec4(0.0,-1002.0,0.0,1000.0),//ground\n    vec4(0.0,0.0,+1002,1000.0),//back wall\n    vec4(-1004.0,0.0,0.0,1000.0),//left wall    \n    vec4(+1004.0,0.0,0.0,1000.0)//right wall\n);\n//-----------------------------------------------------------------------\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n//-----------------------------------------------------------------------\nstruct HitData\n{\n    float rayLength;\n    vec3 normal;\n};\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)\n{\n    HitData hitData;\n    hitData.rayLength = 999999.0;\n\n    for(int i = 0; i < 6; i++)\n    {\n        vec3 sphereCenter = AllSpheres[i].xyz;\n        float sphereRadius = AllSpheres[i].w;\n        //----hardcode sphere pos animations-------------------------------------\n        if(i == 0)\n        {\n            float t = fract(iTime * 0.7);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 0.7;\n            \n            sphereCenter.x += sin(iTime) * 2.0;\n            sphereCenter.z += cos(iTime) * 2.0;\n        }\n             \n        if(i == 1)\n        {\n            float t = fract(iTime*0.47);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 1.7;\n            \n            sphereCenter.x += sin(iTime+3.14) * 2.0;\n            sphereCenter.z += cos(iTime+3.14) * 2.0;\n        }             \n        //---------------------------------------\n                \n        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);\n        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)\n        {\n            //if a shorter(better) hit ray found, update\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n    \t\thitData.normal = normalize(hitPos - sphereCenter);\n        }\n    }\n    \n    //all test finished, return shortest(best) hit data\n    return hitData;\n}\n//--random functions-------------------------------------------------------------------\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)\n{\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n//---------------------------------------------------------------------\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex)\n{\n    //init\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n    \n    //only for CineShader, to show depth\n    float firstHitRayLength = -1.0;\n    \n    //can't write recursive function in GLSL, so write it in a for loop\n    //will loop until hitting any light source / bounces too many times\n    for(int i = 0; i < 16; i++)\n    {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001,rayDir);//+0.0001 to prevent ray already hit @ start pos\n        \n        //only for CineShader, to show depth\n        firstHitRayLength = firstHitRayLength < 0.0 ? h.rayLength : firstHitRayLength;\n        \n        if(h.rayLength > 99999.0)\n        {\n            vec3 skyColor = vec3(0.7,0.85,1.0);//hit nothing = hit sky color\n            finalColor = skyColor * absorbMul;\n            break;\n        }   \n               \n\t\tabsorbMul *= 0.8; //every bounce absorb some light(more bounces = darker)\n        \n        //update rayStartPos for next bounce\n\t\trayStartPos = rayStartPos + rayDir * h.rayLength; \n        //update rayDir for next bounce\n        float rougness = 0.05 + iMouse.x / iResolution.x; //hardcode \"drag the window LR to control roughness\"\n\t\trayDir = normalize(reflect(rayDir,h.normal) + randomInsideUnitSphere(rayDir,rayStartPos,AAIndex) * rougness);       \n    }\n    \n    return vec4(finalColor,firstHitRayLength);//alpha nly for CineShader, to show depth\n}\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; //aspect fix\n\n    vec3 cameraPos = vec3(sin(iTime * 0.47) * 4.0,sin(iTime * 0.7)*8.0+6.0,-25.0);//camera pos animation\n    vec3 cameraFocusPoint = vec3(0,0.0 + sin(iTime),0);//camera look target point animation\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n    \n    //TEMPCODE: fov & all ray init dir, it is wrong!!!!\n    //----------------------------------------------------\n    float fovTempMul = 0.2 + sin(iTime * 0.4) * 0.05;//fov animation\n    vec3 rayDir = normalize(cameraDir + vec3(uv,0) * fovTempMul);\n    //----------------------------------------------------\n\n    vec4 finalColor = vec4(0);\n    for(int i = 1; i <= 16; i++)\n    {\n        finalColor+= calculateFinalColor(cameraPos,rayDir, float(i));\n    }\n    finalColor = finalColor/float(AVERAGECOUNT);//brute force AA & denoise\n    finalColor.rgb = pow(finalColor.rgb,vec3(1.0/2.2));//gamma correction\n    \n    //only for CineShader, to show depth\n    float z = finalColor.w; //z is linear world space distance from camera to surface\n    float cineShaderZ; //expect 0~1\n    cineShaderZ = pow(clamp(1.0 - max(0.0,z-21.0) * (1.0/6.0),0.0,1.0),2.0);\n    \n    //result\n    fragColor = vec4(finalColor.rgb,cineShaderZ);\n} */\n\n\n\n\n\n\n\n\n// ==============\n//  `GL_ES` TEST\n// ==============\n\n/* precision mediump float;\n\n#define RADIANS 0.017453292519943295\n\nconst int zoom = 40;\nconst float brightness = 0.975;\nfloat fScale = 1.25;\n\nfloat cosRange(float degrees, float range, float minimum) {\n\treturn (((1.0 + cos(degrees * RADIANS)) * 0.5) * range) + minimum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 1.25;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p  = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\tfloat ct = cosRange(time*5.0, 3.0, 1.1);\n\tfloat xBoost = cosRange(time*0.2, 5.0, 5.0);\n\tfloat yBoost = cosRange(time*0.1, 10.0, 5.0);\n\t\n\tfScale = cosRange(time * 15.5, 1.25, 0.5);\n\t\n\tfor(int i=1;i<zoom;i++) {\n\t\tfloat _i = float(i);\n\t\tvec2 newp=p;\n\t\tnewp.x+=0.25/_i*sin(_i*p.y+time*cos(ct)*0.5/20.0+0.005*_i)*fScale+xBoost;\t\t\n\t\tnewp.y+=0.25/_i*sin(_i*p.x+time*ct*0.3/40.0+0.03*float(i+15))*fScale+yBoost;\n\t\tp=newp;\n\t}\n\t\n\tvec3 col=vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(p.x+p.y));\n\tcol *= brightness;\n    \n    // Add border\n    float vigAmt = 5.0;\n    float vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));\n\tfloat extrusion = (col.x + col.y + col.z) / 4.0;\n    extrusion *= 1.5;\n    extrusion *= vignette;\n    \n\tfragColor = vec4(col, extrusion);\n}\n\n\n\n\n\n\n\n\n// ============\n//  MODEL TEST\n// ============\n\n/** SHADERDATA\n{\n\t\"title\": \"70s Melt\",\n\t\"description\": \"Variation of Sine Puke\",\n\t\"model\": \"car\"\n}\n*/\n\n\n\n\n/* void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Pirellyon\",\n\t\"description\": \"Next world\",\n\t\"model\": \"nothing\"\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 188, 188, 261], [263, 263, 289, 337, 569], [571, 571, 609, 609, 732], [735, 735, 763, 763, 799], [801, 801, 834, 866, 987], [989, 989, 1041, 1041, 1231], [1234, 1234, 1291, 1326, 2390]], "test": "untested"}
{"id": "tldyDS", "name": "Red Can It Cold Vveb, a fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/wtcyDB[/url]", "tags": ["fractal", "remix", "glitch", "fork", "weird", "error", "edit", "web", "mechanical"], "likes": 2, "viewed": 370, "published": 3, "date": "1609857571", "time_retrieved": "2024-07-30T19:46:47.388710", "image_code": "//Remixer:404Glaciergargamel\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 2;\n    float eps = EPSILON*5.0;\n    for (int i = 1; i < MAX_MARCHING_STEPS/9; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(2.0+depth)) {\n\t\t\tif(iters < 4){\n                iters += 2;\n                eps /= 3.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return depth;\n        }\n    }\n    return depth;\n}\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/3.0)/iResolution.x/image_scale, (coord.y-image_scale/3.0)/iResolution.y/image_scale)).xyz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(iTime*20.0,1,1);\n\tvec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(2.0, 2.0, 2.0);\n    float shininess = 20.0;\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(in int samp, float time )\n{\n    int t = int(time * 9000.0);\n    int t1 = (t/2024)%4+4;\n    t = (t>>t1|t*(t1%4)&t/2024)-2;\n    return vec2(float(t & 0xee - 228) / 228.);\n}", "sound_inputs": [], "buffer_a_code": "//Remixer:404Glaciergargamel\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 2;\n    float eps = EPSILON*5.0;\n    for (int i = 1; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(2.0+depth)*image_scale/3.0) {\n\t\t\tif(iters < 4){\n                iters += 2;\n                eps /= 3.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/3.0);\n    vec3 viewDir = rayDirection(55.0, iResolution.xy, fragCoord);\n    viewDir.xz *= rot(iTime/9.0);\n    if (length(iMouse.xy) > 50.0) {\n        viewDir.yz *= rot(4.14*0.6-iMouse.y/iResolution.y*4.14);\n        viewDir.xz *= rot(4.14-iMouse.x/iResolution.x*4.14*3.0);\n    }\n    float speed = 20.0;\n\tvec3 eye = vec3(iTime*20.0,1,1);\n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.1, 0.1, 0.1), vec3(0.1, 2.0, 0.1));\n    vec3 worldDir = viewToWorld * viewDir;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        //Didn't hit anything\n        fragColor = vec4(0.1, 0.1, 0.1, 0.1);\n\t\treturn;\n    }\n    //The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, 2.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "#define SHADOW_ITER 30\n#define image_scale 9.0\n//change Z-buffer resolution\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\nconst int MAX_MARCHING_STEPS = 2000;\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 20000.0;\nconst float EPSILON = 0.002;\nconst float size = 2000.0;\nconst float scale = EPSILON*20.0; //to prevent rendering artifacts\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1)+p1.yzx+p1))*size;\n    return length(p) - size;\n}\nfloat sceneSDF(vec3 p,float anim,int iters) {\n    p /= scale*3.0;\n    float result = 0.1;\n    float i = 2.0;\n    for(int i1 = 1; i1 < 5; i1++){\n    \tresult = max(result, result-planet_surface(p*i,i)/(i));\n        if(i1 > iters) break;\n        i *= 4.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.5;\n}\nfloat sceneSDF(vec3 p,int iters){\n\treturn sceneSDF(p,2.0,iters);\n}\nfloat sceneSDF(vec3 p,float anim){\n\treturn sceneSDF(p,anim,5);\n}\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,2.0,5);\n}\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 300.0;\n    return sin(vec3(sceneSDF(p/6.0,0.1),sceneSDF(p*4.0,0.1),sceneSDF(p*3.0,0.1)))/4.0+vec3(.4);\n}\n//Return the normalized direction to march in from the eye point for a single pixel\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 3.0;\n    float z = size.y / tan(radians(fieldOfView) / 3.0);\n    return normalize(vec3(xy, -z));\n}\n//Using the gradient of the SDF, estimate the normal on the surface at point p\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n//Lighting contribution of a single point light source via Phong illumination\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.1) {\n        //Light not visible from this point on the surface\n        return vec3(0.1, 0.1, 0.1);\n    } \n    \n    if (dotRV < 0.1) {\n        //Light reflection in opposite direction as viewer, apply only diffuse component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n//Lighting via Phong illumination\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.6 * vec3(2.0, 2.0, 2.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(5.0,\n                          3.0,\n                          5.0);\n    vec3 light1Intensity = vec3(0.9);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n//Return a transform matrix that will transform a ray from view space to world coordinates, given the eye point, the camera target, and an up vector\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    //Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldyDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 120, 120, 636], [637, 637, 664, 664, 813], [814, 814, 871, 871, 1378]], "test": "untested"}
{"id": "3ttyRl", "name": "Montecarlo path tracer", "author": "cas", "description": "tracemontecarlobufferpoawuejrpoa", "tags": ["tracemontecarlobufferpoawuejrpoa"], "likes": 2, "viewed": 476, "published": 3, "date": "1609852423", "time_retrieved": "2024-07-30T19:46:48.251403", "image_code": "//created by Cas Brugman\n\n//move with arrows(left, right, forward, backward), H+J(up and down) and Q+E(rotate left and right).\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n  \n    if(iFrame > 0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        int changedFrame = int(texelFetch(iChannel1, ivec2(BUFF_CHD, 0), 0).x) - 1;\n        col /= float(iFrame - changedFrame) * float(SAMPLES);\n        col = pow(col, vec3(0.4545));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//created by Cas Brugman\n\nconst float PI = 3.14159;\nconst float MAX_DISTANCE = 100.0;\nconst float COLLISION_DISTANCE = 0.001;\n\nfloat si = 1.0;\nvec2 seed;\n\nfloat rand()\n{\n    return fract(sin(dot(seed.xy * si++, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 rotateY(vec3 vec, float angle)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), 0, sin(angle));\n    mat[1] = vec3(0, 1, 0);\n    mat[2] = vec3(-sin(angle), 0, cos(angle));\n    \n    return vec * mat;\n}\n\n//credit to iq for some sd functions\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTurningBox(vec3 p, vec3 b)\n{\n    //p = rotateY(p, radians(30.0) * p.y);\n    return sdBox(p,b);\n}\n\nfloat sdSphere(vec3 ro, vec3 pos, float rad)\n{\n    return distance(ro, pos) - rad;\n}\n\nfloat map(vec3 pos)\n{\n    float dist = MAX_DISTANCE;\n    \n    dist = min(dist, sdSphere(pos, vec3(-1.5, 0.5,0), 1.0));\n    dist = min(dist, sdPlane(pos, vec3(0,1,0), 0.5));\n    dist = min(dist, sdTurningBox(pos - vec3(1.5,.5, 0), vec3(1,1,1)));\n    \n    return dist;\n}\n\nvec3 normal(vec3 pos)\n{\n    float epsilon = COLLISION_DISTANCE * 0.1;\n    float dist = map(pos);\n    return normalize(vec3(\n        map(vec3(pos.x + epsilon, pos.y, pos.z)) - dist,\n        map(vec3(pos.x, pos.y + epsilon, pos.z)) - dist,\n        map(vec3(pos.x, pos.y, pos.z + epsilon)) - dist));\n        \n    //return normalize(vec3(\n        //map(vec3(pos.x + epsilon, pos.y, pos.z)) - map(vec3(pos.x - epsilon, pos.y, pos.z)),\n        //map(vec3(pos.x, pos.y + epsilon, pos.z)) - map(vec3(pos.x, pos.y - epsilon, pos.z)),\n        //map(vec3(pos.x, pos.y, pos.z + epsilon)) - map(vec3(pos.x, pos.y, pos.z - epsilon))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(iFrame == 0)\n    {\n        return;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    if (texelFetch(iChannel1, ivec2(BUFF_CHD, 0), 0).y > 0.5)\n    {\n        col = vec3(0);\n    }\n    \n    seed = uv * iTime * 0.01;\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec3 co = texelFetch(iChannel1, ivec2(BUFF_POS, 0), 0).xyz;\n    vec3 angle = texelFetch(iChannel1, ivec2(BUFF_ROT, 0), 0).xyz;\n    vec3 cd = vec3(sin(angle.x), 0, -cos(angle.x));\n    \n    float fov = radians(90.0);\n    \n    vec3 skyLight = 1.5*vec3(0.18, 0.27, 0.8);\n    vec3 sunLight = 50.0*vec3(1.0, 1.0, 0.9);\n    vec3 sunDirection = normalize(vec3(-1.0, 0.3, 0.3));\n    float sunAngle = radians(10.0);\n    float reflectance = 0.6;\n    \n    for(int i = 0; i < SAMPLES; i++)\n    {\n        float weight = 1.0;\n        vec3 light = vec3(0);\n        \n        vec2 r = vec2(rand() * 2.0 - 1.0, rand() * 2.0 - 1.0) / iResolution.xy / 2.0;\n        vec2 suv = (uv + r) * 2.0 - 1.0;\n        vec2 aspectsuv = vec2(suv.x, suv.y / aspect);\n        vec2 offset = aspectsuv * tan(fov / 2.0);\n\n        vec3 front = (cd);\n        vec3 right = normalize(cross(front, vec3(0,1,0)));\n        vec3 up = cross(right, front);\n\n        vec3 rd = normalize(front + right * offset.x + up * offset.y);\n        vec3 ro = co;\n        \n        int maxBounces = 10;\n        for(int bounces = 0; bounces < maxBounces; bounces++)\n        {\n            bool hit = false;\n            vec3 pos = ro;\n            int maxSteps = 1000;\n\n            for(int steps = 0; distance(co, pos) < MAX_DISTANCE && steps < maxSteps;steps++)\n            {\n                float dist = map(pos);\n\n                if(abs(dist) < COLLISION_DISTANCE)\n                {\n                    hit = true;\n                    break;\n                }\n\n                pos += rd * dist;\n            }\n\n            if (hit)\n            {                \n                weight *= reflectance;\n\n                vec3 normal = normal(pos);\n                ro = pos + normal * (COLLISION_DISTANCE * 2.0);\n                \n                bool x = mod(round(pos.x), 2.0) == 0.0;\n                bool z = mod(round(pos.z), 2.0) == 0.0;\n                \n                bool mirror = (x || z) && !(x && z);\n                \n                if(mirror || rand() > .5)\n                {\n                    float theta = (rand() * 2.0 -1.0) * PI / 2.0;\n                    float phi = rand() * PI * 2.0;\n                    vec3 random = vec3(sin(theta)*cos(phi), cos(theta), sin(theta) * sin(phi));\n                \n                    vec3 helper = vec3(0,1,0);\n                    if(abs(normal.y) > 0.9)\n                    {\n                        helper = vec3(-1,0,0);\n                    }\n                \n                    vec3 xaxis = normalize(cross(helper, normal));\n                    vec3 zaxis = normalize(cross(normal, xaxis));\n                    mat3 mat = mat3(xaxis, normal, zaxis);\n               \n                    rd = random * inverse(mat);\n                }\n                else\n                {\n                    rd = reflect(rd, normal);\n                }\n                \n            }\n            else\n            {\n                if(dot(rd, sunDirection) > 1.0 - (1.0 / PI / 2.0) * (sunAngle / 2.0))\n                {\n                    light = sunLight;\n                }\n                else\n                {\n                    light = skyLight;\n                }\n                break;\n            }\n        }\n        \n        col += light * weight;\n        \n    }\n    \n    fragColor.rgb = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//created by Cas Brugman\n\nconst int BUFF_POS = 0;\nconst int BUFF_ROT = 1;\nconst int BUFF_CHD = 2;\nconst int BUFF_RES = 3;\n\nconst int SAMPLES = 1;", "buffer_b_code": "//created by Cas Brugman\n\nconst float MOVE_SPEED = 0.1;\nconst float ROT_SPEED = 0.05;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\nconst int KEY_H     = 72;\nconst int KEY_J     = 74;\n\nbool isKeyPressed(int key)\n{\n    return texelFetch(iChannel1, ivec2(key,0),0).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(fragCoord.y) > 0)\n    {\n        return;\n    }\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    float changed = 1.0;\n    \n    if(iFrame < 1)\n    {\n        switch(int(fragCoord.x))\n        {\n            case(BUFF_POS):\n                col = vec3(0,.5,6);\n                break;\n\n            case(BUFF_ROT):\n                col = vec3(0,0,0);\n                break;\n            case(BUFF_RES):\n                col = iResolution;\n                break;\n        }\n    }\n    else\n    {\n        switch(int(fragCoord.x))\n        {\n            case(BUFF_POS):\n                vec3 vec = vec3(0);\n                if(isKeyPressed(KEY_LEFT))\n                {\n                    vec.x = 1.0;\n                    changed = 0.0;\n                }\n                \n                if(isKeyPressed(KEY_RIGHT))\n                {\n                    vec.x = -1.0;\n                    changed = 0.0;\n                }\n                \n                if(isKeyPressed(KEY_UP))\n                {\n                    vec.z = 1.0;\n                    changed = 0.0;\n                }\n                \n                if(isKeyPressed(KEY_DOWN))\n                {\n                    vec.z = -1.0;\n                    changed = 0.0;\n                }\n                \n                if(isKeyPressed(KEY_H))\n                {\n                    vec.y = 1.0;\n                    changed = 0.0;\n                }\n                \n                if(isKeyPressed(KEY_J))\n                {\n                    vec.y = -1.0;\n                    changed = 0.0;\n                }\n                \n                vec3 angle = texelFetch(iChannel0, ivec2(BUFF_ROT, 0), 0).xyz;\n                vec3 cd = vec3(sin(angle.x), 0, -cos(angle.x));\n                \n                vec3 helper = vec3(0,1,0);\n                vec3 xaxis = normalize(cross(helper, cd));\n                \n                vec3 movement = vec3(0);\n                \n                movement += cd * vec.z;\n                movement += xaxis * vec.x;\n                movement += helper * vec.y;\n                \n                col += movement * MOVE_SPEED;\n                break;\n                \n            case(BUFF_ROT):\n            \n                if(isKeyPressed(KEY_Q))\n                {\n                    col.x -= ROT_SPEED;\n                    changed = 0.0;\n                }\n                \n                if(isKeyPressed(KEY_E))\n                {\n                    col.x += ROT_SPEED;\n                    changed = 0.0;\n                }\n                break;\n            case(BUFF_RES):\n                if (col.xy != iResolution.xy){\n                    changed = 0.0;\n                    col = iResolution;\n                }\n                break;\n                \n                \n                \n            case(BUFF_CHD):\n                if (texelFetch(iChannel0, ivec2(BUFF_POS, 0), 0).w < 0.5 ||\n                    texelFetch(iChannel0, ivec2(BUFF_ROT, 0), 0).w < 0.5 ||\n                    texelFetch(iChannel0, ivec2(BUFF_RES, 0), 0).w < 0.5)\n                {\n                    col.x = float(iFrame);\n                    col.y = 1.0;\n                }\n                else\n                {\n                    col.y = 0.0;\n                }\n                break;\n        }\n    }\n    \n    fragColor = vec4(col, changed);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 185, 185, 548]], "test": "untested"}
{"id": "wttcWS", "name": "Fast reaction diffusion", "author": "illus0r", "description": "Minimalist reaction diffusion", "tags": ["reactiondiffusion"], "likes": 4, "viewed": 411, "published": 3, "date": "1609850565", "time_retrieved": "2024-07-30T19:46:49.254721", "image_code": "//IMG\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    vec2 uv = FC/iResolution.xy;\n    vec4 tex;\n    tex=textureLod(iChannel0,uv,.5);\n    o *= 0.,o+=tex.y/tex.x;\n    //uv=abs(uv-.5);\n    //tex=texture(iChannel0,uv);\n    //o-=tex.y/tex.x;\n    \n    //o = texture(iChannel1,uv.xxy+texture(iChannel0,uv).zxy);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// A\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// COMMON\n#define t(uv) textureLod(ch, uv, .5).xy\n#define rnd(x) fract(1e5*sin(1e5*x))\n#define fl(x) floor(x*10.)/10.\n//#define R (3.+15.*smoothstep(10.,0.,t))\n#define R 5.\n#define s(x) smoothstep(0.,1.,x)\n\n#define K (.06)\n#define F (.05)\n#define Da 1.*s(t)\n#define Db .4*s(t)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec4 reaction(vec2 FC, vec2 r, sampler2D ch, float t, vec4 m)\n{\n    vec2 uv=FC/r,_,px=1./r,v=t(uv),dx,dy,d,delta,dir;\n    \n    // flow\n    //uv=((uv-.5)*rot(.05*length(uv-.5))+.5);\n    \n    //vec2(R,0.) will also work \n    _=vec2(R+R*rnd(uv.x+.01*uv.y+t),0.);\n    \n    //uv=abs(uv-.5);\n    \n    dx=(-v+(t(uv+px*_   )+t(uv+px*-_   ))/2.)/2.;\n    dy=(-v+(t(uv+px*_.yx)+t(uv+px*-_.yx))/2.)/2.;\n    \n    //dir=vec2(1,0)*rot(t/10.)*.5+.5;\n    d=(dx+dy)/2.;\n\n    delta.x=Da*d.x-v.x*v.y*v.y+F*(1.-v.x);\n    delta.y=Db*d.y+v.x*v.y*v.y-(K+F)*v.y;\n    vec4 o=vec4(v+delta,1,1);\n\n    if(t<.1)o*=0.,o+=1.-step(.05,length(uv-.5));//o+=rnd(fl(uv.x)+.01*fl(uv.y));\n    \n    return o;\n}", "buffer_b_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    o = reaction(FC.xy, iResolution.xy, iChannel0, iTime, iMouse);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttcWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 6, 48, 48, 306]], "test": "untested"}
{"id": "WldyDB", "name": "water color with turbidity", "author": "FabriceNeyret2", "description": "Floor of color F (left) seen through water of transmittance C, \nwith water depth gradient 0 (left) to max (right).\nTop: + turbidity of reflectance T.\n( no water-air interface accounted ).\nWould be cool to try with real values, or even spectra.\n", "tags": ["water", "spectral", "beerlambert"], "likes": 9, "viewed": 527, "published": 3, "date": "1609844890", "time_retrieved": "2024-07-30T19:46:50.157307", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;                                                  // --- without sRGB:\n    vec4 C = vec4(.006,.13,.8, 1),   // water transmittance spectrum per m   vec4(.1,.4,.8, 1)\n         F = vec4(1,.44,.013, 1),    // floor refectance spectrum            vec4(1,.686,.141,1)\n         T = vec4(.1),               // turbidity reflectance spectrum       vec4(.2)\n    \n    W = pow(C,vec4(3.*U.x));         // total transmitance up to floor\n    \n    O = W *  F;                      // floor color seen through water\n    if (U.y >.5) \n      O += (W-1.) / log(C) * T;      // turbidity seen through water\n      \n    O = pow(O, vec4(1./2.2));        // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 707]], "test": "untested"}
{"id": "3ldyDB", "name": " - Quicky#049", "author": "totetmatt", "description": "Trying mandelbox formula\nEdit, yes the fomula is broken, but I like the effect it generate", "tags": ["quicky"], "likes": 4, "viewed": 301, "published": 3, "date": "1609843904", "time_retrieved": "2024-07-30T19:46:50.936225", "image_code": "#define S 2.\n#define PI 3.141592\n#define sqz iTime*123./60.*.5\nvoid mdb(inout vec2 uv){\n    uv.x = uv.x > 1. ? 2. -uv.x:uv.x;\n    uv.x = uv.x < -1. ? -2. -uv.x:uv.x;\n    uv.y = uv.y > 1. ? 2. -uv.y:uv.y;\n    uv.y = uv.y < -1. ? -2. -uv.y:uv.y;\n    \n    uv = length(uv) < .5 ? uv * 4.:uv;\n    uv = length(uv) < 1. ? uv /(length(uv)*length(uv)) : uv;\n    \n    uv = uv *S + vec2(cos(iTime+fract(sqz)),sin(iTime-fract(sqz)));\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) /iResolution.y;\n    uv +=vec2(sin(sqz*.1)*.5+fract(sqz*.25),cos(sqz*.1)*.5);\n    uv *=2.;\n    \n    mdb(uv);\n    uv*=r(PI/4.);\n    mdb(uv);\n    \n    uv*=r(PI/4.);\n    mdb(uv);\n    \n    uv*=r(PI/4.+fract(sqz*.5));\n    \n    float d = length(uv)-1.1;\n    d = max(abs(uv.x)-.01,.0) - max(abs(uv.y),0.);\n    d = smoothstep(0.1,0.2,d);\n    vec3 col = vec3(d);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 87, 87, 423], [424, 424, 440, 440, 498], [500, 500, 555, 555, 990]], "test": "untested"}
{"id": "WldcDS", "name": "compat test:  mod on negatives", "author": "FabriceNeyret2", "description": "On true OpenGL, both mod(-t,2)  (left) and (-t) %2  (right) give positive results (green 2 sides).\nHow on other platform, typically Windows in native Angle/D3D mode ?\n( my bet: positive for mod ( left, green ) and negative for % ( right, red ). Tell me.\n", "tags": ["test", "glsl"], "likes": 2, "viewed": 317, "published": 3, "date": "1609835667", "time_retrieved": "2024-07-30T19:46:51.830833", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    float m =  mod(-iTime,2.);\n    int i = int(-iTime) % 2;\n    \n    O = U.x < iResolution.x/2. \n          ? vec4( -m,m,0,1)        // left:  test sign of float mod\n          : vec4( -i,i,0,1);       // right: test sign of int mod\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldcDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 271]], "test": "untested"}
{"id": "tt3yRf", "name": "Ess d'Eff runner two", "author": "elenzil", "description": "working towards a playable game of some sort.", "tags": ["game", "sdf"], "likes": 8, "viewed": 286, "published": 3, "date": "1609821079", "time_retrieved": "2024-07-30T19:46:52.605761", "image_code": "// Fork of \"ess de eff runner 1\" by elenzil. https://shadertoy.com/view/3ldyzM\n// 2021-01-02 16:41:48\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\n\nfloat gMyTime = 0.0;\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n    \n    gMyTime = iTime * 3.14159 * 2.0;\n\n    float smallRes = min(iResolution.x, iResolution.y);\n\n    vec2  p = (XY - iResolution.xy * 0.5) / smallRes * 2.0;\n    float d = sdScene(p, gMyTime);\n\n    float c = 0.0;\n    vec3  rgb = vec3(c);\n\n    rgb += 0.5 * smoothstep(3.0 / smallRes, 0.0, d);\n //   rgb += sin(d * 80.0) * 0.03;\n    \n    for (int n = 0; n < numBalls; ++n) {\n        float ballT = float(n) / float(numBalls);\n        vec2 part1 = texelFetch(iChannel0, ivec2(n, 0), 0).xy;\n        float bc = smoothstep(1.0 / smallRes, 0.0, length(part1 - p) - ballRad(ballT));\n        rgb.r += bc * 0.3;\n        rgb.g += bc * 0.5;\n        rgb.b += bc * 0.9;\n    }\n\n\n    RGBA.rgba = vec4(rgb, 1.0);\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * The SDF is defined here in Common so that it can be accessed\n * from both the buffer using the SDF as input for stateful dynamics\n * and by the main display pass.\n *\n * I originally had the SDF computed in a buffer,\n * but I worried that all the texture-sampling calls were slowing\n * things down compared to just calling into the code again.\n *\n * A huge advantage of not computing the SDF in a buffer is that\n * when it's in a buffer you can't access SDF values which are off-screen.\n *\n * A disadvantage of having the SDF in Common is that it precludes\n * the possibility of a stateful SDF. for example one in which the\n * player of a game is able to modify the terrain.\n *\n */\n\n\nconst float PI        = 3.14159265259;\nconst float PI2       = (PI * 2.0);\n\nconst int numBalls = 13;\nconst float ballRadMin = 0.03;\nconst float ballRadMax = 0.07;\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nconst float epsilonGradient = 0.0001;\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSubtraction2( float d1, float d2 ) { return max(d1,-d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdAnnulus(in vec2 p, in float r1, in float r2) {\n    return opSubtraction2(sdCircle(p, r2), sdCircle(p, r1));\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdAnnularPentagon(in vec2 p, in float r1, in float r2) {\n    return opSubtraction2(sdPentagon(p, r2), sdPentagon(p, r1));\n}\n\nmat2 rot2(float radians) {\n    float s = sin(radians);\n    float c = cos(radians);\n    return mat2(s, c, -c, s);\n}\n\nfloat sdScene(in vec2 p, in float time) {\n    float width = 0.03;\n\n    float d = 1e9;\n\n    float circRad = 0.8 + sin(time * 0.11) * 0.1;\n    d = opUnion(d, -sdCircle(p, circRad));\n\n    mat2 r2   = rot2(sin(time * 0.3211) * 0.2);\n    float circRad2 = 0.2;\n    d = opSubtraction2(d, sdCircle(abs(r2 * p) - circRad * 0.7 + sin(time * 0.02 + 2.0) * 0.2, circRad2));\n\n    mat2 r1   = rot2(time * -0.1);\n    mat2 r3   = rot2(time * -0.1 * 3.0);\n    vec2 sep  = vec2(sin(time * 0.121) * 0.5, 0.0);\n    vec2 sep2 = vec2(0.0, cos(time * 0.121) * 0.15);\n\n    float pentRad = 0.2;\n    float pr;\n    float w1 = (sin(time * 0.31) * 0.5 + 0.5) * 0.15;\n\n    pr = pentRad;// - 0.2 * (sin(gMyTime * 0.2) * 0.5 + 0.5);\n    float da = sdAnnularPentagon((p + sep + sep2) * r1, pr - 0.001 - w1, pr);\n\n    pr = pentRad ; // - 0.2 * (cos(gMyTime * 0.2) * 0.5 + 0.5);\n    float db = sdAnnularPentagon((p - sep - sep2) * r3, pr - 0.001 - w1, pr);\n    \n    float dc = sminCubic(da, db, 0.1);\n  \n    d = min(d, dc);\n    \n    return d;\n}\n\nvec2 gradScene(in vec2 p, in float time, in float d_at_p) {\n    float dex = sdScene(p + vec2(epsilonGradient, 0.0), time);\n    float dey = sdScene(p + vec2(0.0, epsilonGradient), time);\n    return vec2(dex - d_at_p, dey - d_at_p);\n}\n\n\n///////////////////////////////////////////\n\nfloat ballRad(float t) {\n    return mix(ballRadMin, ballRadMax, t);\n}\n\n\n", "buffer_a_code": "/////////////////////////\n// this buffer is the dynamics, based on the SDF\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nfloat gMyTime = 0.0;\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gMyTime = iTime * 3.14159 * 2.0;\n    float smallRes = min(iResolution.x, iResolution.y);\n\n    ivec2 IJ = ivec2(XY);\n    \n    if (IJ.x >= numBalls || IJ.y > 0) {\n        discard;\n    }\n    \n    vec2 p;\n    vec2 v;\n    \n    float ballT = XY.x / float(numBalls);\n    \n    float offX = (XY.x - float(numBalls) * 0.5) * 100.0 / smallRes;\n        \n    if (iMouse.z > 0.0) {\n        p  = (iMouse.xy - iResolution.xy * 0.5) / smallRes * 2.0;\n        p.x += offX;\n        v  = vec2(0.0);\n    }\n    else {\n        if (iFrame > 1) {\n            // fetch last value\n            vec4 pv = texelFetch(iChannel0, IJ, 0);\n\n            p = pv.xy;\n            v = pv.zw;\n        }\n        else {\n            p = vec2(offX, 1.0);\n            v = vec2(0.0);\n        }\n        \n        float smallRes = min(iResolution.x, iResolution.y);\n\n        // normalize euler integration to at least 60 Hz\n        const float fixedDT = 1.0 / 30.0;\n        float steps = round(iTimeDelta / fixedDT);\n\n        steps = max(steps, 1.0);\n\n        float dt = iTimeDelta / steps;\n\n        float n = 0.0;\n        while (n < steps) {\n            ivec2 pij = ivec2((iResolution.xy + p * smallRes) / 2.0);\n\n            \n            // and advance\n            vec4 sdfInfo = texelFetch(iChannel1, pij, 0);\n            float d   = sdScene(p, gMyTime);\n            vec2 grd  = gradScene(p, gMyTime, d);\n            float gm  = length(grd);\n            vec2 grdNorm = grd/gm;\n            vec2 tang    = vec2(-grd.y, grd.x);\n\n            v = tang * 12000.0 * 1.0;\n            // add in a little physics variation per-particle to keep them separated\n            v *= (1.0 + XY.x * -0.03);\n            p += dt  * v;\n\n            p -= (d - ballRad(ballT)) * grdNorm;\n\n            n += 1.0;\n        }\n\n    }\n    \n   // p.x = 1.0;\n    \n    RGBA = vec4(p, v);\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 217, 217, 942]], "test": "untested"}
{"id": "wlccDB", "name": "false-Stonehenge", "author": "jorge2017a1", "description": "false-Stonehenge", "tags": ["falsestonehenge"], "likes": 2, "viewed": 241, "published": 3, "date": "1609818451", "time_retrieved": "2024-07-30T19:46:53.606086", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\nvec2 cilindrobase(vec3 p )\n{\n    float tau = atan(1.0) * 8.0;\n    p= rotate_x(p , radians(90.0));\n    p= rotate_z(p , radians(floor( iTime*10.0) ));\n    \n    float numItem=8.0;\n    float ang=tau / numItem;\n    vec3 p2= opAngRep(p, ang );\n    float sb0= sdCylinderXY(p-vec3(0.0,0.0,0.0), vec2(7.0,0.5) ); //base\n    float sb0a= sdBox(  p-vec3(0.0,0.0,0.1), vec3(5.0,0.5,0.5) );\n    float sb0b= sdBox(  p-vec3(0.0,0.0,0.1), vec3(0.5,5.0,0.5) );\n    \n    float sb1= sdCylinderXY(p2-vec3(7.0,0.0,2.0), vec2(0.5,2.0) );  //postes\n    \n    \n    float sb3A= sdCylinderXY(p-vec3(0.0,0.0,4.0), vec2(7.0,0.5) );\n    float sb3B= sdCylinderXY(p-vec3(0.0,0.0,4.0), vec2(6.0,0.6) );\n    sb3A= differenceSDF(sb3A, sb3B);\n    \n    vec2 resp=vec2(9999.9,-1.0);\n    resp=opU2(resp, vec2(sb0, 1.0) );\n    resp=opU2(resp, vec2(sb1, 2.0) );\n    \n    resp=opU2(resp, vec2(sb3A, 14.0) );\n    resp=opU2(resp, vec2(sb0a, 10.0) );\n    resp=opU2(resp, vec2(sb0b, 11.0) );\n    return resp;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf\n    \n    p.y=p.y-5.0;\n    //p=rotate_y(p, clamp(0.0,5.0,  clamp( 2.,4.0 ,mod(iTime,10.0)) ));  clamp ERROR\n    p=rotate_y(p, clamp(clamp(mod(iTime,10.0), 2.,4.0 )  , 0.0,5.0 ) );\n    \n    vec2 cb1= cilindrobase(p);\n     res =opU3(res, vec3(cb1.x,cb1.y,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n    vec3 ref = reflect(lig, normal);\n    \n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\n    \n    float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n   \n\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t//return vec3( clamp(0.0,1.0,d) );  clamp ERROR\n        return vec3( clamp(d,0.0 ,1.0) );  \n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n   \n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n    \n    float blink=0.5+sin(iTime)*2.0;\n    if (blink<0.85) blink=0.85;\n \n    light_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 =  vec3( 1.0, 1.2, 1.2 )*blink;\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 =  vec3( 0.3, 0.7, 1.0 )*blink;\n \n    //float v1=5.0*clamp(-20.0, 40.0,  (sin(iTime*0.25+sin(2.0*iTime)) )) ;  clamp ERROR\n    float v1=5.0*clamp(sin(iTime*0.25+sin(2.0*iTime)) ,-20.0, 40.0  ) ;\n    \n    vec3 ro=vec3(0.0,7.0, -10.0+v1);\n    \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1;\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2;\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n\n///--------------------------------------------FIN\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[447, 447, 483, 483, 504], [505, 505, 537, 537, 621], [622, 622, 668, 668, 755], [756, 756, 790, 790, 852], [853, 853, 890, 890, 985], [986, 986, 1025, 1025, 1120], [1121, 1121, 1160, 1160, 1255], [1256, 1256, 1295, 1295, 1390], [1392, 1436, 1483, 1483, 1510], [1512, 1512, 1555, 1555, 1582], [1584, 1584, 1632, 1632, 1660], [1661, 1732, 1766, 1766, 1864], [1865, 1865, 1899, 1899, 1991], [1992, 1992, 2026, 2026, 2118], [2119, 2159, 2193, 2193, 2290], [2324, 2324, 2350, 2350, 2404], [2406, 2406, 2440, 2440, 2613], [2616, 2616, 2644, 2644, 3579], [3581, 3621, 3646, 3646, 4191], [4195, 4195, 4281, 4281, 5020], [5026, 5077, 5101, 5101, 5289], [5290, 5353, 5386, 5386, 5847], [5849, 5903, 5939, 5939, 6173], [6230, 6264, 6344, 6344, 6621], [6624, 6675, 6722, 6722, 7013], [7067, 7067, 7160, 7160, 7440], [7445, 7494, 7551, 7551, 9033]], "test": "untested"}
{"id": "wtcyDB", "name": "Mechanical Web", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/WtjyDz]\"Alien Hive\"[/url] fractal.", "tags": ["fractal", "web"], "likes": 3, "viewed": 311, "published": 3, "date": "1609812842", "time_retrieved": "2024-07-30T19:46:54.478753", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS/8; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return depth;\n        }\n    }\n    return depth;\n}\n            \n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(iTime*10.0,0,0);\n\n\tvec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define SHADOW_ITER 20\n#define image_scale 8.0\n//change Z-buffer resolution\n\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1)+p1.yzx+p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n    \tresult = max(result, result-planet_surface(p*i,i)/(i));\n        if(i1 > iters) break;\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p,int iters){\n\treturn sceneSDF(p,1.0,iters);\n}\n\nfloat sceneSDF(vec3 p,float anim){\n\treturn sceneSDF(p,anim,4);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0,4);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n            \n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.xz *= rot(iTime/8.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(1.0+length(eye-dmap.xyz))*2.0;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, l0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound(in int samp, float time )\n{\n    int t = int(time * 8000.0);\n    int t1 = (t/1024)%3+3;\n    t = (t>>t1|t*(t1%3)&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 1086], [1101, 1101, 1128, 1128, 1277], [1279, 1279, 1336, 1336, 1854]], "test": "untested"}
{"id": "wtccWB", "name": "CubemapA Gi", "author": "ollj", "description": "move camera with esdf+tg \nrotate camera with arrows+wr\n\ncamera of \nhttps://www.shadertoy.com/view/wtdyRs\nCubemapA GlobalIllumination of \nhttps://www.shadertoy.com/view/MlKcR1", "tags": ["3d", "raymarching", "volumetric", "cubemap", "godrays", "cubemapa"], "likes": 2, "viewed": 313, "published": 3, "date": "1609812507", "time_retrieved": "2024-07-30T19:46:55.360396", "image_code": "#define crashme 1\n//[crashme] case almost solved, error was that the camera was stuck inside the distanceField\n//and the constand collisiondetection crashed opengl.\n//or maybe the camera just being stuck inside the df, somehow doing too many iterations.\n\n//mope. this shader still tends to crash opengl, if only after some time.\n\n\n//crashes with 50 volumeSamples\n//crashes with d>0. exit condition\n\n//lets see if it EVER crashes with only 50. \n#define volumeSamples 50. \n\nfloat rayvolum(v22 r, float maxdist, vec3 light\n){float accum = 0.0\n ;for(float d=0.;d<maxdist;d+=maxdist/volumeSamples\n ){vec3 p = r.a+r.b*d\n  ;vec3 lightrd = p-light\n  ;float lightlen = length(lightrd)\n  ;lightrd /= lightlen\n  ;float lightdist = texture(iChannel3,lightrd).x\n  ;accum += float(lightdist>lightlen)\n  ;}\n ;return accum/maxdist/volumeSamples;}\n\n//shadows are hard and lowres, BAD combination!\nvec4 getCol(v22 r,float d\n){vec3 light = lightpos(iTime)\n ;float accum=rayvolum(r,d,light) //volume light\n ;r.a+=d*r.b\n ;vec3 normal = normal(r.a)\n ;vec3 lightrd = r.a-light\n ;float lightlen = length(lightrd)\n ;float shadow = texture(iChannel3,lightrd/lightlen).x\n ;vec4 c = vec4(normal*0.5+0.5,1)\n ;if(shadow-lightlen+.01<0.)c*=.2 //i am not convinced by this hard blocky shadow\n \n ;//c*=.5*mix(1.,.2,smoothstep(0.,1.,shadow-lightlen+1.1))\n ;//if(shadow-lightlen+.1<0.)c*=.2\n //c=mix(c*.01,c,smoothstep(0.,1.,lightlen))//mix(.2,.5,shadow)//hard blocky shadow\n ;c+=accum\n ;//c=mix(c,c*.2,sat(shadow))\n ;return sqrt(c);}\n\n#if crashme\nv22 getR(vec2 u//get ray from ichannel0\n){vec2 v=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get2(iChannel0,CamR0),get2(iCb,CamP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                    +(m*vec3(1,0,0)*v.x//right+forward...\n                     +m*vec3(0,1,0)*v.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd) \n ;}\n#else\nv22 getR(vec2 u){\n;u=(u*2.-iResolution.xy)/iResolution.y\n;return v22(vec3(0.5,0.5,iTime*0.2),normalize(vec3(u,1)));}\n#endif\n\nvoid mainImage(out vec4 o,vec2 u\n){\n ;v22 r=getR(u)\n ;float d=march(r)\n ;if (d<100.&&d>0.)o=getCol(r,d) //>0. still dies not catch the crashing case.\n ;}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MOUSE_SENSITIVITY vec2(-1,1)\n#define FieldOfView 2.5\n\n#define pi acos(-1.)\n#define iM iMouse\n#define iR iResolution\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n// Fetch a single pixe from a buffer\nvec4 get2(sampler2D b,ivec2 a){return texelFetch(b,a,0);}\nvec4 get2(sampler2D b,int a){return texelFetch(b,ivec2(a,0),0);}\n\nconst float \n LIN_ACCE=5.//linear accelleration\n,ANG_ACCE=5.//angular accelleration\n,LIN_DRAG=1.//linear drag\n,ANG_DRAG=1.//angular drag\n;\n\n#define iCb iChannel0\nconst int \n CamP0=0//cameraPositionLinear\n,CamR0=1//cameraRotationLinear\n,CamP1=2//cameraVelocityAngular\n,CamR1=3//cameraVelocityAngular\n;\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n\n//--- quaterion math (updated 2021-1) //https://www.shadertoy.com/view/4tSyRz\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\n//return quaternion of rotattion input ANGLES [pitch.x, yaw.y, roll.z] in that ORDER:\nvec4 pyr2q(vec3 o){o*=.5//this *.5 scalar may not need to be internal\n ;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n/*\n ;vec4 qp=pyr2q(vec3(a.yxz))\n ;return normalize(qq2q(qp,r))\n//above 2 lines are nearly identical to below 4 lines\n ;r=qq2q(aa2q(vec3(1,0,0),a.y),r)\n ;r=qq2q(aa2q(vec3(0,1,0),a.x),r)\n ;r=qq2q(aa2q(vec3(0,0,1),a.z),r)\n ;return r;\n*/\n//return q2, rotated by q1, order matters (is non commutative)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz)\n,(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q() quaternion multiplication, BUT scaled by SENITIVITY [f] (quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t))\n ;return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return p, rotated by VECTOR q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs (note that this is not commutative)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//return quaternion, that rotates to look from vec3(0) to input [v]\nvec4 qlookat(vec3 v){return aa2q(vec3(-v.y,v.x,0),acos(v.z/length(v)));}//point in direction v \n//return mat3 of [q]uaternion (rotation matrix without translation)\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,1);mat3 m=mat3(.5)+mat3(0,q.zyz*a,0,q.xyx*a.xxy,0)*q.w\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//return q2m() as mat4, with [t]ranslation \nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return only mat3 rotation of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n\n\n\n\nfloat df(vec3 u\n){vec3 p = fract(u)-.5\n ;float t =-length(p)+.6\n ;p.x=fract(u.x-.5)-.5\n ;t = min(t,length(p)-.2)\n ;return t;}\n\nvec3 normal(vec3 u\n){vec2 e=vec2(0,.001)\n ;return normalize(vec3(df(u+e.yxx)-df(u-e.yxx)\n                       ,df(u+e.xyx)-df(u-e.xyx)\n                       ,df(u+e.xxy)-df(u-e.xxy)));}\n\nfloat march(v22 r///1000 marching steps crash browser?\n){float d=0.\n ;for(int i=0;i<100;i++\n ){float len=df(r.a+d*r.b)\n  ;d+=len\n  ;if (len<.001||d>100.)break\n  ;}return d;}\n\nvec3 lightpos(float time){return vec3(-0.5,0.2*sin(time)+0.5,time*0.2+1.0);}", "cube_a_code": "void mainCubemap(out vec4 o,vec2 u,vec3 ro,vec3 d\n){o=vec4(march(v22(lightpos(iTime),d)));}", "cube_a_inputs": [], "buffer_a_code": "#define PHYSICS_RADIUS .05\n#define startingCamPos vec4(lightpos(0.),0)\n#define startingCamRot aa2q(vec3(0,1,0),0.)\n\n#define keyA 65\n#define keyB 66\n#define keyC 67\n//...alphanumeric Keys\n#define keyE 69\n#define keyS 83\n#define keyD 68\n#define keyF 70\n#define keyT 84\n#define keyG 71\n//above moves linear, below rotates angular(mouse drag also rotates)\n#define keyW 87\n#define keyR 82\n#define keyUp 38\n#define keyDn 40\n#define keyLe 37\n#define keyRi 39\n\n/*\ninertia quaternion camera 2021\n\nCamera Controls:\n ESDF  - strafe forwards/backwares\n TG    - strafe up/down\n Arrows- rotate (pitch+jaw)\n WR    - rotate (roll)\n\n//self  : https://www.shadertoy.com/view/wtdyRs#\n//parent; https://www.shadertoy.com/view/WsGfWm\n\n*/\n\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE) //right      ,up      ,front      ==+linear\n           ,kln=ivec3(keyS ,keyG ,keyD) //left       ,down    ,back       ==-linear\n           //...\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code:\n\n\n// STATE\n\n\n#define BUFFER_KEYBOARD iChannel1\n\n// Return the state of a key\nfloat get_key(int key_code\n){return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,0), 0).x;}\n\nvec3 ks(ivec3 a){return vec3(get_key(a.x),get_key(a.y),get_key(a.z));}//key input subroutine\n\n\nvec4 cp0(vec4 o,vec2 u//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return startingCamPos\n ;vec3 r=get2(iCb,CamP0).xyz\n ;float d=PHYSICS_RADIUS-df(r.xyz)\n ;if (d >0.)r.xyz+=normal(r)*d\n ;return vec4(r+(q2m(get2(iCb, CamR0),vec3(0))\n                 *vec4(get2(iCb, CamP1).xyz,0)).xyz*iTimeDelta,0);}\n \nvec4 cr0(vec4 o,vec2 u//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return startingCamRot\n ;return normalize(qq2q(pyr2q(iTimeDelta*get2(iCb, CamR1).yxz),get2(iCb, CamR0)));}\n\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\nvec4 cp1(vec4 o,vec2 u//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get2(iCb,CamP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n \nvec4 cr1(vec4 o,vec2 u//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;return vec4(drag(get2(iCb,CamR1).xyz,a*ANG_ACCE,ANG_DRAG),0.);}\n\nvoid mainImage(out vec4 o,vec2 u\n){int a=int(u.x)\n ;if(a<2\n ){     if(a==CamP0)o=cp0(o,u)\n  ;else if(a==CamR0)o=cr0(o,u)\n ;}\n ;     if(a==CamP1)o=cp1(o,u)\n ;else if(a==CamR1)o=cr1(o,u)\n ;}\n\n\n/*\nuse this function to get the v22(rayOrigin,rayDirection) from this buffer\nv22 getR(vec2 U\n){vec2 u=(U-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get2(iCb,CamR0),get2(iCb, CamP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                    +(m*vec3(1,0,0)*u.x//right+forward...\n                     +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n*/", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtccWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 522, 522, 830], [832, 880, 908, 908, 1499], [1976, 1976, 2011, 2011, 2129]], "test": "untested"}
{"id": "tldyDH", "name": "Eye for Radial Fbm Practice", "author": "specialsaucewc", "description": "Making an eye shader to get more comfortable with fbm noise manipulation and polar coordinates.\n\nShader is following the tutorial by Inigo Quilez\nhttps://www.youtube.com/watch?v=emjuqqyq_qc", "tags": ["noise", "fbm", "distortion", "eye", "radial", "practice"], "likes": 3, "viewed": 418, "published": 3, "date": "1609811569", "time_retrieved": "2024-07-30T19:46:56.258993", "image_code": "#define PI 3.141592\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\n// I didnt update this hash until after I styled it -_- so it stays\nfloat hash( in ivec2 q )\n{\n    // You SHOULD replace this by something better. Again, Do Not Use in production.\n    int n = q.x*131 + q.y*57;\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float((n>>8)&0x007fffff)/float(0x007fffff);\n}\n\nfloat noise (in vec2 x, in int p)\n{\n    ivec2 i = ivec2(floor(x));\n    vec2 f = fract(x);\n    \n    f = f*f*(3.-2.*f);\n    \n    return mix(mix( hash((i+ivec2(0,0))&(p-1)), \n                    hash((i+ivec2(1,0))&(p-1)),f.x),\n               mix( hash((i+ivec2(0,1))&(p-1)), \n                    hash((i+ivec2(1,1))&(p-1)),f.x),f.y);\n}\n\nfloat fbm (in vec2 x, in int p)\n{\n    float f = 0.;\n    float s = .5;\n    for (int i=0; i<9; i++)\n    {\n        f += s*noise(x,p);\n        s *= .5;\n        x *= 2.;\n        p *= 2;\n    }\n    return f;\n}\n\nvec3 eye(in vec2 uv)\n{\n    vec2 ar = vec2(atan(uv.y, uv.x)/PI, length(uv));\n    vec3 bkgd = vec3(251.,247.,245.)/256.;\n    float f = fbm(8.*ar, 4);\n    vec3 col = vec3(0., .3, .4);\n    col = mix(col, vec3(.2, .5, .4), f);\n    \n    float t = .8 * iTime;\n    float ss = pow(abs(sin(t)), 4.) + pow(abs(sin(t + 2.)), 4.);\n    float anim = 1. + .2*ss*clamp(1.-2.*ar.y, 0., 1.);\n    ar.y *= anim;\n    \n    ar.x += .05 * fbm(20.*ar, 8);\n    \n    //pupil glow\n    f = smoothstep(.25, .15, ar.y);\n    vec3 glow = vec3(.9, .6, .2);\n    col = mix(col, glow, f);\n    \n    //strands\n    f = smoothstep(.3, 1., fbm(vec2(64., 10.)*ar, 16));\n        //mixed mainlines\n    vec3 strands = mix(vec3(12, 122, 4)/256., vec3(57, 237, 171)/256., fbm(8.*ar, 12));\n        //white striations\n    strands = mix(strands, vec3(1), pow(abs(sin(18.*PI*ar.x)), 8.));\n    col = mix(col, strands, f);\n    \n    //black\n    f = smoothstep( .4, .9, fbm(vec2(24., 8.)*ar, 8));\n    col *= 1. - .5*f;\n    \n    //dim edges\n    f = smoothstep(.55, .3, ar.y);\n    col *= f;\n    \n    //pupil\n    col *= smoothstep(.1, .15, ar.y);\n    \n    //reflection\n    f = smoothstep(.25, .0, length(uv - vec2(.1, .1)));\n    col += vec3(1., .9, .8)*f;\n    \n    //outer edge\n    f = smoothstep(.45, .43, ar.y);\n    col = mix(bkgd, col, f);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = eye(uv);\n    \n    //Debug tools\n    //col.rg = ar;\n    //vec2 ar = vec2(atan(uv.y, uv.x)/PI, length(uv));\n    //ar.x += .05 * fbm(20.*ar, 8);\n    //col = vec3(fbm(8.*ar, 12));\n    //col.gb = vec2(0.);col.r = ar.x * .5 + .5;col.g=ar.y;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 146, 172, 257, 418], [420, 420, 455, 455, 753], [755, 755, 788, 788, 957], [959, 959, 981, 981, 2264], [2266, 2266, 2323, 2323, 2687]], "test": "untested"}
{"id": "ttcyWB", "name": "SDF_Learning", "author": "Alienity", "description": "Learing geometry, the blending formula comes firom https://www.jcohen.name/papers/Ferreira_Levelsets_2007.pdf, but it looks not so right.", "tags": ["2d"], "likes": 0, "viewed": 286, "published": 3, "date": "1609805526", "time_retrieved": "2024-07-30T19:46:57.127671", "image_code": "float sdfCircle(vec2 coord, vec2 center, float radius)\n{\n\tvec2 offset = coord - center;\n\treturn sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;\n}\n\nfloat sdfTorus(vec2 coord, vec2 center, float radius1, float radius2)\n{\n    vec2 offset = coord - center;\n    return abs(sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius1) - radius2;\n}\n\nfloat sdfEclipse(vec2 coord, vec2 center, float a, float b)\n{\n    float a2 = a * a;\n    float b2 = b * b;\n    return (b2 * (coord.x - center.x) * (coord.x - center.x) +\n        a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2) / (a2 * b2);\n}\n\nfloat sdfBox(vec2 coord,  vec2 center, float width, float height)\n{\n    vec2 d = abs(coord - center) - vec2(width, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdfRoundBox(vec2 coord,  vec2 center, float width, float height, float r)\n{\n    vec2 d = abs(coord - center) - vec2(width, height);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n//*****************************Hard Blend******************************\nfloat sdfUnion(const float a,const float b) {\n    return min(a, b);\n}\n\nfloat sdfDifference(const float a, const float b) {\n    return max(a, -b);\n}\n\nfloat sdfIntersection(const float a, const float b) {\n    return max(a, b);\n}\n//*********************************************************************\n\n//******************************Soft Blend*****************************\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n//*********************************************************************\n\n\n//*********************************************************************\n// https://www.jcohen.name/papers/Ferreira_Levelsets_2007.pdf\nfloat sdfBlending(float A, float B, const float alpha, float beta, float gamma) {\n    // A is the SDF the first geometry, B is the SDF of the second geometry and \n    // alpha is the filtering distance.\n    float m = clamp(abs(alpha-A),0.0f,alpha)/alpha*clamp(abs(alpha-B),0.0f,alpha)/alpha;\n    // the blended levelset. beta is the blending curve exponetial and gamma is the \n    // size of the extrusion in the blending area.\n    float C = min(A, B) + pow(m, beta) * gamma;\n    return C;\n}\n//*********************************************************************\n\n\nvec4 render(float d, vec3 color, float stroke) \n{\n\tfloat anti = fwidth(d) * 1.0;\n\tvec4 colorLayer = vec4(color, 1.0 - smoothstep(-anti, anti, d));\n\tif (stroke < 0.000001) {\n\t\treturn colorLayer;\n\t}\n\n\tvec4 strokeLayer = vec4(vec3(0.05, 0.05, 0.05), 1.0 - smoothstep(-anti, anti, d - stroke));\n\treturn vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float x = 0.5f * iResolution.x;\n    float y = sin(iTime * 1.0f)*60.0f + 0.5f * iResolution.y;\n    vec2 circleCenter = vec2(x, y);\n\n    float r = sdfCircle(fragCoord.xy, circleCenter, 25.0f);\n    float r_1 = sdfCircle(fragCoord.xy, circleCenter, 10.0f);\n    r = sdfDifference(r, r_1);\n    \n    float r2 = sdfBox(fragCoord.xy, iResolution.xy*0.5f, 40.0f, 30.0f);\n    float r2_1 = sdfBox(fragCoord.xy, iResolution.xy*0.5f, 20.0f, 10.0f);\n    r2 = sdfDifference(r2, r2_1);\n    \n    //float r4 = sdfBlending(r, r2, 5.0f, 1.0f, 2.0f);\n    float r4 = opSmoothUnion(r, r2, 7.0f);\n    vec4 col = render(5.0f, vec3(0.5f, 0.05f, 0.0f), r4);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 159], [161, 161, 232, 232, 357], [359, 359, 420, 420, 610], [612, 612, 679, 679, 792], [794, 794, 875, 875, 992], [994, 1066, 1111, 1111, 1135], [1137, 1137, 1188, 1188, 1213], [1215, 1215, 1268, 1268, 1292], [1366, 1487, 1539, 1539, 1638], [1640, 1640, 1698, 1698, 1798], [1800, 1800, 1859, 1859, 1958], [2033, 2167, 2248, 2369, 2658], [2733, 2733, 2782, 2782, 3106], [3109, 3109, 3166, 3216, 3943]], "test": "untested"}
{"id": "WlcyDB", "name": "Curve Table", "author": "TheNosiriN", "description": "I watched this today: https://www.youtube.com/watch?v=--6eyLO78CY\nAnd felt like making this", "tags": ["curve", "table", "youtube"], "likes": 16, "viewed": 384, "published": 3, "date": "1609798418", "time_retrieved": "2024-07-30T19:46:58.200801", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rrr, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIME iTime *0.5\n#define R (iResolution.xy)\n#define mR min(R.x, R.y)\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\nconst float RADIUS = 0.05; //decrease this\nconst float SPACING = 2.5; //increase this\nconst float THICKNESS = 0.05;\n\nvec2 rot(vec2 p, float inc){ return vec2(sin((TIME+inc)*p.x),cos((TIME+inc)*p.y)); }\n\nvec2 pMod(in vec2 inp, out vec2 outp, float size){\n\toutp = mod(inp+size*0.5,size)-size*0.5; return floor((inp+size*0.5)/size);\n}\nfloat line(vec2 p, vec4 ab) {\n    p -= ab.xy, ab.zw -= ab.xy;\n    return smoothstep(3./mR,0.,length(p-ab.zw*(clamp(dot(p,ab.zw)/dot(ab.zw,ab.zw),0.,1.))));\n}\n\nvoid mainImage( out vec4 C, in vec2 P ){\n    if (P == vec2(0.5,0.5)){ C.a=R.x; C.g=RADIUS; C.b=THICKNESS; return; }\n    vec4 pc = T(vec2(0,0));\n    if (R.x!=pc.a || RADIUS!=pc.g || THICKNESS!=pc.b){ C = vec4(0); return; }\n    \n    vec2 uv = P/mR - vec2(RADIUS*1.25, 1.0-RADIUS*1.25);\n    vec2 puv; vec2 id = pMod(uv, puv, RADIUS*SPACING);\n    C.r = line(vec2(puv.x, uv.y), RADIUS*vec4(rot(id.xx,0.), rot(id.xx,THICKNESS)));\n    C.r += line(vec2(uv.x, puv.y), RADIUS*vec4(rot(id.yy,0.), rot(id.yy,THICKNESS)));\n    C.r += id.x>0.0 && id.y!=0.0 ? line(puv, RADIUS*vec4(rot(id,0.), rot(id,THICKNESS))) : 0.;\n    C.r *= id.x==0.0 && id.y==0.0 ? 0.0 : 1.0;\n    C.r = mix(0.997*texture(iChannel0, P/R).r, 1.0, C.r);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 138]], "test": "untested"}
{"id": "WtccDB", "name": "Metrobrot", "author": "michael0884", "description": "Using the Metropolis-Hastings algorithm to render a buddhabrot. May be biased. ", "tags": ["buddhabrot", "metropolis"], "likes": 19, "viewed": 1093, "published": 3, "date": "1609797598", "time_retrieved": "2024-07-30T19:46:59.230049", "image_code": "void mainImage( out vec4 c, in vec2 p )\n{\n    vec2 uv = p/iResolution.xy;\n    \n    //reflected point. cheat to make convergence 2x faster\n    vec2 pr = vec2(p.x, iResolution.y - 0.5 - p.y);\n    vec4 data0 = texelFetch(iChannel0, ivec2(p), 0);\n    vec4 data1 = texelFetch(iChannel0, ivec2(pr), 0);\n    \n    vec4 color = mix(decode(data0.zw),decode(data1.zw),0.5);\n    c.xyz = ((1. - iMouse.x/iResolution.x)*pow(color.xyz/(4.5e3*point_size*float(iFrame)*point_size),vec3(1.)));\n    c.w = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nconst int max_iterations = 256;\nconst vec4 color_threshholds = vec4(255,130,80,255);\nconst float scale = 2.1;\nconst vec2 center = vec2(-0.5, 0.0);\n//make smaller for full screen\nconst float point_size = 0.001;\nconst float local_mut_rad = 0.01;\nconst float global_mut_rad = 0.5;\nconst float global_mut_prob = 0.15;\nconst int spp = 12;\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) *  vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nuvec2 unpack_uint2x(uint x)\n{\n    return uvec2(x%0x00010000u,x/0x00010000u);\n}\n\nuint pack_uint2x(uvec2 x)\n{\n    return x.x + x.y*0x00010000u;\n}\n\nvec4 decode(vec2 data)\n{\n    \n    return vec4(unpack_uint2x(floatBitsToUint(data.x)),\n                unpack_uint2x(floatBitsToUint(data.y)))/100.;\n}\n\nvec2 encode(vec4 data)\n{\n    uvec4 d = uvec4(data*100.0);\n    return vec2(uintBitsToFloat(pack_uint2x(d.xy)),\n                uintBitsToFloat(pack_uint2x(d.zw)));\n}\n", "buffer_a_code": "//mutate and accumulate\n\n//complex multiplication\nvec2 cmul(vec2 x, vec2 y)\n{\n    return vec2(x.x*y.x - x.y*y.y, x.x*y.y + x.y*y.x);\n}\n\nvec4 orbit_mandelbrot(vec2 p, vec2 c)\n{\n    vec2 z = vec2(0.); \n    float orbit = 0.;\n    int i = 0;\n    for(;i<max_iterations; i++)\n    {\n        z = cmul(z,z) + c;\n        vec2 m2 = (z - vec2(p.x, -p.y))/point_size; //reflect to make it 2x faster\n        vec2 m1 = (z-p)/point_size;\n        orbit += 1. - (1.0 - 1.0/(1.0 + dot(m1,m1)))*(1.0 - 1.0/(1.0 + dot(m1,m1))); //render the point\n        if(length(z) > 3.0) break; //outside\n    }\n    float x = float(i);\n    return smoothstep(x, x+1.0, color_threshholds)*orbit/(1.+dot(p - center, p-center));\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    rng_initialize(p, iFrame);\n\n    //position on the complex plane\n    vec2 z = scale*(p - iResolution.xy*0.5)/iResolution.yy + center;\n\n    vec4 prev = texelFetch(iChannel0, pixel, 0);\n    vec2 z0 = prev.xy;\n    float prev_orbit = orbit_mandelbrot(z, z0).w;\n    vec4 accum = decode(prev.zw);\n  \n    if(iFrame < 1) \n    {\n        prev_orbit = 0.0;\n        z0 = z + 2.0*rand2() - 1.0;\n        accum = vec4(0.000,0.000,0.000,0.000);\n    }\n  \n    for(int i = 0; i < spp; i++)\n    {\n        //mutate position\n        vec2 z1 = nrand2((prev_orbit == 0.0 || rand() < global_mut_prob )?global_mut_rad:local_mut_rad, z0);\n        \n        vec4 orbit = orbit_mandelbrot(z, z1);\n        \n        if(orbit.w == 0.0) continue;\n        \n        //metropolis acceptance probability\n        float acceptance_p = min(1.0, orbit.w/(prev_orbit+1e-7));\n        //randomly accept\n        if(rand() < acceptance_p)\n        {\n            z0 = z1;\n            prev_orbit = orbit.w; \n        }\n        \n        accum.xyz += 0.1*orbit.xyz;\n        accum.w += 0.01;\n    }\n    vec2 data = encode(accum);\n    c = vec4(z0,data);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtccDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 492]], "test": "untested"}
{"id": "wl3cWS", "name": "ShyGuys in SMB2", "author": "IWBTShyGuy", "description": "Yes, my name is \"I wanna be the ShyGuy\" !", "tags": ["bitmap", "shyguy"], "likes": 17, "viewed": 1023, "published": 3, "date": "1609795711", "time_retrieved": "2024-07-30T19:47:00.091746", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// Bitmap Reference\n// https://www.spriters-resource.com/nes/supermariobros2supermariousa/\n\nconst int SCREEN_BLOCK = 8;\nconst int GROUND_HEIGHT = 1;\nconst float SHYGUY_VELOCITY = 6.5;\n\nconst float fSCREEN_BLOCK = float(SCREEN_BLOCK);\n\nconst vec4 BACKGROUND = vec4(60, 188, 252, 255) / 255.0;\n\nvec4 groundTile(in vec2 uv);\nvec4 grassTile(in vec2 uv);\nvec4 cloud(in vec2 uv);\nvec4 small_cloud(in vec2 uv);\nvec4 stem(in vec2 uv);\nvec4 leaf(in vec2 uv);\nvec4 redShyGuy(in vec2 uv, in int idx);\nvec4 greenShyGuy(in vec2 uv, in int idx);\nvec4 blueShyGuy(in vec2 uv, in int idx);\nvec4 blackShyGuy(in vec2 uv, in int idx);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((2.0 * fragCoord - iResolution.xy) / iResolution.y + 1.0) / 2.0;\n    if (abs(uv.x - 0.5) > 0.5) {\n        fragColor = vec4(vec3(0), 1);\n        return;\n    }\n    float t = iTime * SHYGUY_VELOCITY;\n    fragColor = vec4(0);\n    uv *= fSCREEN_BLOCK;\n    ivec2 iuv = ivec2(floor(uv));\n    uv = fract(uv);\n    if (iuv.y < GROUND_HEIGHT) fragColor = groundTile(uv);\n    else if (iuv.y == GROUND_HEIGHT) fragColor = grassTile(uv);\n    else if (iuv.x == SCREEN_BLOCK - 2) {\n        fragColor = stem(uv);\n    } else if (iuv.x == SCREEN_BLOCK - 3) {\n        if (iuv.y < SCREEN_BLOCK - 3) {\n            fragColor = stem(uv);\n        } else if (iuv.y == SCREEN_BLOCK - 3) {\n            fragColor = leaf(uv);\n        }\n    }\n    else if (iuv.y == SCREEN_BLOCK - 2) {\n        switch (iuv.x) {\n        case 3:\n            fragColor = small_cloud(uv);\n            break;\n        case 1:\n            fragColor = cloud(uv);\n            break;\n        case 2:\n            fragColor = cloud(uv + vec2(1, 0));\n            break;\n        }\n    }\n\n    vec4 col = vec4(0);\n    if (iuv.y == GROUND_HEIGHT + 1) {\n        uv = float(iuv) + uv;\n        uv.x = mod(uv.x - floor(t) / 3.0, fSCREEN_BLOCK);\n        iuv = ivec2(floor(uv));\n        uv = fract(uv);\n        if (iuv.x % 2 == 1) {\n            switch ((iuv.x / 2) % 4) {\n            case 0:\n                col = redShyGuy(uv, 1 + int(t));\n                break;\n            case 1:\n                col = greenShyGuy(uv, 1 + int(t));\n                break;\n            case 2:\n                col = blueShyGuy(uv, 1 + int(t));\n                break;\n            case 3:\n                col = blackShyGuy(uv, 1 + int(t));\n                break;\n            default: col = vec4(0);\n            }\n        }\n    }\n    if (col.w != 0.0) fragColor = col;\n    if (fragColor.w == 0.0) fragColor = BACKGROUND;\n}\n\nconst vec4 BLACK = vec4(0, 0, 0, 1);\nconst vec4 SEMI_WHITE = vec4(252, 252, 252, 255) / 255.0;\n\nconst vec4 LIGHT_GREEN = vec4(128, 208, 16, 255) / 255.0;\nconst vec4 MIDDLE_GREEN = vec4(0, 168, 0, 255) / 255.0;\nconst vec4 DARK_GREEN = vec4(0, 80, 0, 255) / 255.0;\n\n// ---------------- ShyGuy ---------------- //\nconst vec4 SHYGUY_RED = vec4(216, 40, 0, 255) / 255.0;\nconst vec4 SHYGUY_GREEN = vec4(40, 216, 0, 255) / 255.0;\nconst vec4 SHYGUY_BLUE = vec4(40, 0, 216, 255) / 255.0;\nconst vec4 SHYGUY_BLACK = vec4(40, 40, 40, 255) / 255.0;\n\nconst int SHYGUY_BITMAP[512] = int[](\n    0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,1,1,3,3,3,3,3,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,\n    0,1,3,3,3,3,3,1,1,2,2,2,2,1,0,0,0,0,1,1,3,3,3,3,3,1,1,1,1,0,0,0,\n    1,3,3,3,3,3,3,1,2,2,2,2,2,2,1,0,0,1,3,3,3,3,3,1,1,2,2,2,2,1,0,0,\n    0,1,3,3,3,3,1,1,2,2,2,2,2,2,1,0,1,3,3,3,3,3,3,1,2,2,2,2,2,2,1,0,\n    0,0,1,1,1,1,1,2,2,1,1,2,1,1,2,1,0,1,3,3,3,3,1,1,2,2,2,2,2,2,1,0,\n    0,1,1,1,1,1,1,2,2,1,1,2,1,1,2,1,0,0,1,1,1,1,1,2,2,1,1,2,1,1,2,1,\n    0,1,3,3,3,3,1,2,2,2,2,2,2,2,2,1,0,1,1,1,1,1,1,2,2,1,1,2,1,1,2,1,\n    0,1,3,3,3,3,1,1,2,2,2,2,2,2,2,1,0,1,3,3,3,3,1,2,2,2,2,2,2,2,2,1,\n    0,0,1,3,3,3,3,1,2,2,2,1,2,2,1,1,0,1,3,3,3,3,1,1,2,2,2,2,2,2,2,1,\n    0,1,1,3,3,3,1,1,1,2,2,1,2,2,1,0,0,0,1,3,3,3,3,1,2,2,2,1,2,2,1,1,\n    0,1,3,3,3,3,3,1,1,1,2,2,2,1,3,1,0,1,1,3,3,3,1,1,1,2,2,1,2,2,1,0,\n    1,3,3,3,1,1,3,3,1,1,1,1,1,3,3,1,0,1,3,3,3,3,3,1,1,1,2,2,2,1,3,1,\n    1,1,1,3,3,3,1,1,1,3,3,3,3,1,1,1,1,3,1,1,3,3,3,1,3,1,1,1,1,1,3,1,\n    0,0,1,1,1,1,1,1,2,1,1,3,3,3,1,0,1,1,2,2,1,1,1,1,3,3,3,1,1,2,1,1,\n    0,0,0,0,1,1,2,2,2,2,1,1,1,1,0,0,0,1,1,2,2,1,1,1,1,1,1,2,2,2,2,1\n);\n\nint readShyGuyBitMap(in vec2 uv, in int idx) {\n    uv.y = 1.0 - uv.y;\n    ivec2 iuv = ivec2(uv * 15.9999);\n    int i = iuv.y * 32 + (idx % 2) * 16 + iuv.x;\n    return SHYGUY_BITMAP[i];\n}\n\nvec4 redShyGuy(in vec2 uv, in int idx) {\n    switch (readShyGuyBitMap(uv, idx)) {\n        case 1: return BLACK;\n        case 2: return SEMI_WHITE;\n        case 3: return SHYGUY_RED;\n        default: return vec4(0);\n    }\n}\n\nvec4 greenShyGuy(in vec2 uv, in int idx) {\n    switch (readShyGuyBitMap(uv, idx)) {\n        case 1: return BLACK;\n        case 2: return SEMI_WHITE;\n        case 3: return SHYGUY_GREEN;\n        default: return vec4(0);\n    }\n}\n\nvec4 blueShyGuy(in vec2 uv, in int idx) {\n    switch (readShyGuyBitMap(uv, idx)) {\n        case 1: return BLACK;\n        case 2: return SEMI_WHITE;\n        case 3: return SHYGUY_BLUE;\n        default: return vec4(0);\n    }\n}\n\nvec4 blackShyGuy(in vec2 uv, in int idx) {\n    switch (readShyGuyBitMap(uv, idx)) {\n        case 1: return BLACK;\n        case 2: return SEMI_WHITE;\n        case 3: return SHYGUY_BLACK;\n        default: return vec4(0);\n    }\n}\n\n// ---------------- Ground Tile ---------------- //\nconst int N_GBD = 10;\nconst ivec2 groundBlockDot[N_GBD] = ivec2[](\n    ivec2(2, 0), ivec2(11, 1), ivec2(6, 2), ivec2(15, 3), ivec2(3, 4),\n    ivec2(10, 5), ivec2(0, 6), ivec2(5, 6), ivec2(13, 6), ivec2(8, 7)\n);\n\nconst vec4 LIGHT_BROWN = vec4(248, 184, 0, 255) / 255.0;\nconst vec4 DARK_BROWN = vec4(83, 48, 0, 255) / 255.0;\n\nvec4 groundTile(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    uv *= 16.0;\n    ivec2 st = ivec2(floor(uv));\n    st %= ivec2(16, 8);\n    for (int i = 0; i < N_GBD; i++) {\n        if (st == groundBlockDot[i])\n            return DARK_BROWN;\n    }\n    return LIGHT_BROWN;\n}\n\n// ---------------- Grass Tile ---------------- //\nvec4 grassTile(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    ivec2 iuv = ivec2(uv * 16.0);\n    switch (iuv.y) {\n    case 0: case 15:\n        return DARK_GREEN;\n    case 2: switch (iuv.x) {\n        case 12: case 14: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 3: switch (iuv.x) {\n        case 5: case 13: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 4: switch (iuv.x) {\n        case 2: case 3: case 5: case 7: case 8:\n            return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 5: switch (iuv.x) {\n        case 3: case 4: case 5: case 6: case 7:\n            return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 6: switch (iuv.x) {\n        case 4: case 5: case 6: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 10: switch (iuv.x) {\n        case 5: case 14: return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 11: switch (iuv.x) {\n        case 1: case 5: case 10: case 14:\n            return MIDDLE_GREEN;\n        default: return LIGHT_GREEN;\n    }\n    case 12: switch (iuv.x) {\n        case 3: case 4: case 7: case 8: case 12: case 15:\n            return LIGHT_GREEN;\n        default: return MIDDLE_GREEN;\n    }\n    case 13: switch (iuv.x) {\n        case 3: return LIGHT_GREEN;\n        case 1: case 5: case 10: case 14:\n            return DARK_GREEN;\n        default: return MIDDLE_GREEN;\n    }\n    case 14: switch (iuv.x) {\n        case 0: case 3: case 7: case 8: case 12:\n            return MIDDLE_GREEN;\n        default: return DARK_GREEN;\n    }\n    default:\n        return LIGHT_GREEN;\n    }\n}\n\n// ---------------- Cloud ---------------- //\nconst ivec4 CLOUD_RANGES[11] = ivec4[](\n    ivec4(10, 11, 12, 14),\n    ivec4(6, 9, 15, 17),\n    ivec4(4, 5, 18, 19),\n    ivec4(3, 3, 20, 20),\n    ivec4(2, 2, 21, 21),\n    ivec4(1, 1, 22, 22),\n    ivec4(1, 1, 21, 21),\n    ivec4(2, 2, 20, 20),\n    ivec4(3, 4, 18, 19),\n    ivec4(5, 7, 15, 17),\n    ivec4(8, 11, 11, 14)\n);\n\nconst ivec4 SMALL_CLOUD_RANGES[4] = ivec4[](\n    ivec4(4, 5, 5, 7),\n    ivec4(2, 3, 8, 9),\n    ivec4(1, 1, 10, 10),\n    ivec4(0, 0, 11, 11)\n);\n\nvec4 inRange(in int idx, in ivec4 range) {\n    if (range.x <= idx && idx <= range.y) return BLACK;\n    if (range.y < idx && idx < range.z) return SEMI_WHITE;\n    if (range.z <= idx && idx <= range.w) return BLACK;\n    return vec4(0);\n}\n\nvec4 cloud(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    ivec2 iuv = ivec2(uv * 16.0);\n    switch (iuv.y) {\n        case 1: return inRange(iuv.x, CLOUD_RANGES[0]);\n        case 2: return inRange(iuv.x, CLOUD_RANGES[1]);\n        case 3: return inRange(iuv.x, CLOUD_RANGES[2]);\n        case 4: return inRange(iuv.x, CLOUD_RANGES[3]);\n        case 5: return inRange(iuv.x, CLOUD_RANGES[4]);\n        case 6:\n        case 7:\n        case 8: return inRange(iuv.x, CLOUD_RANGES[5]);\n        case 9: return inRange(iuv.x, CLOUD_RANGES[6]);\n        case 10: return inRange(iuv.x, CLOUD_RANGES[7]);\n        case 11: return inRange(iuv.x, CLOUD_RANGES[8]);\n        case 12: return inRange(iuv.x, CLOUD_RANGES[9]);\n        case 13: return inRange(iuv.x, CLOUD_RANGES[10]);\n        default: return vec4(0);\n    }\n}\n\nvec4 small_cloud(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    ivec2 iuv = ivec2(uv * 16.0);\n    switch (iuv.y) {\n        case 8: case 15: return inRange(iuv.x, SMALL_CLOUD_RANGES[0]);\n        case 9: case 14: return inRange(iuv.x, SMALL_CLOUD_RANGES[1]);\n        case 10: case 13: return inRange(iuv.x, SMALL_CLOUD_RANGES[2]);\n        case 11: case 12: return inRange(iuv.x, SMALL_CLOUD_RANGES[3]);\n        default: return vec4(0);\n    }\n}\n\n// ---------------- Tree ---------------- //\nconst vec4 STEM_BROWN = vec4(200, 76, 12, 255) / 255.0;\n\nvec4 stem(in vec2 uv) {\n    ivec2 iuv = ivec2(uv * 16.0);\n    switch (iuv.x) {\n        case 7: return STEM_BROWN;\n        case 6:\n        case 8:\n        case 9: return BLACK;\n        default: return vec4(0);\n    }\n}\n\nconst int LEAF_BITMAP[256] = int[](\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,\n    0,0,1,2,2,2,1,0,1,3,3,3,1,0,0,0,\n    0,0,1,1,2,2,2,1,3,3,3,3,3,1,0,0,\n    0,0,0,0,1,2,2,1,3,3,1,1,1,1,0,0,\n    0,0,1,1,1,1,2,1,3,1,0,0,0,0,0,0,\n    0,1,3,3,3,3,1,3,3,1,1,1,1,1,0,0,\n    1,3,3,3,3,3,1,3,1,2,2,2,2,2,1,0,\n    1,3,1,1,1,3,3,1,2,2,2,2,2,2,2,1,\n    1,1,0,0,0,1,3,1,2,2,2,1,1,1,2,1,\n    0,0,0,0,0,1,3,1,2,2,1,0,0,0,1,1,\n    0,0,1,1,1,1,3,1,2,1,1,1,1,1,0,0,\n    0,1,2,2,2,2,1,1,1,3,3,3,3,3,1,0,\n    1,2,2,2,2,2,2,1,3,3,3,3,3,3,3,1,\n    1,2,2,1,1,1,2,1,3,1,1,1,3,3,3,1,\n    1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1\n);\n\nint readLeafBitMap(in vec2 uv) {\n    uv.y = 1.0 - uv.y;\n    uv *= 16.0;\n    return LEAF_BITMAP[int(uv.y) * 16 + int(uv.x)];\n}\n\nvec4 leaf(in vec2 uv) {\n    switch (readLeafBitMap(uv)) {\n        case 1: return BLACK;\n        case 2: return LIGHT_GREEN;\n        case 3: return MIDDLE_GREEN;\n        default: return vec4(0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cWS.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[694, 694, 749, 749, 2596], [4280, 4280, 4326, 4326, 4466], [4468, 4468, 4508, 4508, 4690], [4692, 4692, 4734, 4734, 4918], [4920, 4920, 4961, 4961, 5144], [5146, 5146, 5188, 5188, 5372], [5750, 5750, 5779, 5779, 6013], [6015, 6066, 6094, 6094, 7705], [8218, 8218, 8260, 8260, 8453], [8455, 8455, 8479, 8479, 9251], [9253, 9253, 9283, 9283, 9688], [9792, 9792, 9815, 9815, 10008], [10641, 10641, 10673, 10673, 10766], [10768, 10768, 10791, 10791, 10969]], "test": "untested"}
{"id": "tl3yWS", "name": "Tea tray", "author": "illus0r", "description": "Drag the mouse over the canvas to change parameters. If the canvas is white, it's dead, rewind backward to try again", "tags": ["reactiondiffusion"], "likes": 3, "viewed": 332, "published": 3, "date": "1609794062", "time_retrieved": "2024-07-30T19:47:01.143932", "image_code": "//IMG\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv.x-=(iResolution.x-iResolution.y)/iResolution.y / 2.;\n    fragColor = vec4(smoothstep(.3,.7,texture(iChannel1, uv).r));\n    fragColor = vec4(texture(iChannel1, uv).brga);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//A\n#define TIMESTEP 1.\n\n#define GRID (step(.45,length(mod(uv,1./RC)*RC-.5)))\n#define F (0.12  + .01 * (iMouse.y/iResolution.y-.5))\n#define K (0.054  + .01 * (iMouse.x/iResolution.x-.5))\n#define Da (1.)\n#define Db (.3*smoothstep(0.,5.,iTime))\n#define RADIUS 8.\n\nvec2 p2d(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\n\nvec2 d2p(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\nvec2 snowflakeSymmetry(vec2 p, float rays){\n\tvec2 ar = d2p(p);\n\tfloat astep = 2. * 3.1415 / rays;\n\tfloat a = ar.x, r = ar.y;\n\ta = mod(a, astep);\n\ta -= astep / 2.;\n\ta = abs(a);\n\tp = p2d(vec2(a, r));\t\n\treturn p;\n}\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x));}\n\nvoid getVal(vec2 p, out vec2 val, out float diff_a, out float diff_b) {\n  vec2 r = iResolution.xy;\n  vec2 uv = p / r;\n  uv -= .5;\n  uv = snowflakeSymmetry(uv,3.);\n  if(length(uv)>.48) {\n      diff_a=diff_b=0.;\n      return;\n  }\n  uv += .5;\n  //p = uv*r;\n        \n  val = texture(iChannel0, uv).xy;\n  vec2 neigh_val_a = vec2(0.);\n  vec2 neigh_val_b = vec2(0.);\n  vec2 k_anisotropy = abs(normalize(uv-vec2(.5)));\n  if(uv.x<.5)k_anisotropy = k_anisotropy.yx;\n  float k_sum = 0.;\n  for(float i = -RADIUS; i <= RADIUS; i++){\n      for(float j = -RADIUS; j <= RADIUS; j++){\n          if(i==0. || j==0.) continue;\n          if(length(vec2(i,j))>.8*RADIUS) continue;\n          vec2 k = vec2(1.);\n          k_sum += k.x+k.y;\n          vec2 pij = p+vec2(i,j);\n          neigh_val_a += texture(iChannel0, (pij) / r).x * k;\n          neigh_val_b += texture(iChannel0, (pij) / r).y * k;\n      }\n  }\n  neigh_val_a /= k_sum;\n  neigh_val_b /= k_sum;\n  diff_a = (-val.x+neigh_val_a.x+neigh_val_a.y)/2.;\n  diff_b = (-val.y+neigh_val_b.x+neigh_val_b.y)/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    \n    vec3 colour = vec3(0.0);\n    if (iFrame < 1) {\n        colour = vec3(rnd(uv.x+uv.y*.0001));\n    } else {\n     \tvec2 val;\n        float diff_a, diff_b;\n        getVal(fragCoord.xy, val, diff_a, diff_b);\n        \n        vec2 delta;\n \t\tdelta.x = Da * diff_a - val.x * val.y * val.y + F * (1.0 - val.x);\n  \t\tdelta.y = Db * diff_b + val.x * val.y * val.y - (K + F) * val.y;\n        \n        colour = vec3(val + delta * TIMESTEP, 0.0);\n        colour = clamp(colour, -1., 1.);\n    }\n    \n    fragColor = vec4(colour,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//B\n#define res iResolution.xy\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n\nfloat dist(vec3 p){\n\tp.y += .2*texture(iChannel0, (p.xz)*vec2(.25,.25)+vec2(.5)).r;\n    float sp = length(p+vec3(0.,5.,0.))-2.;\n    return sp;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(.01,0.);\n\treturn normalize(vec3(\n    \tdist(p+e.xyy)-dist(p-e.xyy),\n    \tdist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    float d=0., e, i;\n    vec3 p,rd=normalize(vec3((FC*2.-res)/res.xy,2.));\n    rd.yz*=rot(3.1415/2.);\n    for(i=0.;i++<99.;){\n        p = d*rd;\n        d+=e=dist(p);\n        if(e<.01)break;\n    }\n    //p.xz*=rot(iTime*.1);\n    fragColor = 4.*vec4(vec3(dot(norm(p),vec3(1.)))*.2+.6,1.);\n    fragColor += texture(iChannel1, norm(p));\n    fragColor /= 5.;\n    fragColor /= i/3.;\n}", "buffer_b_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 6, 63, 63, 283]], "test": "untested"}
{"id": "tsVBzK", "name": "Mandelbrot Set Variation", "author": "Zi7ar21", "description": "Failed attempt at a buddhabrot that I think is nice. This is zoomed into the coordinates -0.1575, 1.034", "tags": ["mandelbrot", "variation"], "likes": 1, "viewed": 325, "published": 3, "date": "1609789940", "time_retrieved": "2024-07-30T19:47:02.032556", "image_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// Constants (I mean you could change these, but there is no point.)\n#define pi 3.141592653589793\n#define twopi 3.141592653589793*2.0\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\n//vec3 rand3(){return vec3(rand(), rand(), rand());}\n//vec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random, also from Michael0884 https://www.shadertoy.com/view/WttyWX\n/*float ErfInv(float x){\n   float lnx = log((1.0-x)*(1.0+x));\n   float tt1 = 4.3308+0.5*lnx;\n   float tt2 = 6.8027*lnx;\n   return(sign(x)*sqrt(-tt1+sqrt(tt1*tt1-tt2)));\n}*/\n\n//float nrand(){return ErfInv(rand()*2.0-1.0);}\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x))*vec2(cos(twopi*Z.y),sin(twopi*Z.y));}\n//vec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\n//vec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "buffer_a_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n\n// Fractal Density\nint randexpiter(float iter){return int(round((rand()*iter)+iter))+1;}\nfloat iterchannel(vec2 coord, int iter){\n    bool march = false;\n    vec2 z2 = vec2((rand2()-0.5)*2.0);\n    //vec2 c = vec2(coord/32.0)+vec2(-0.1575,1.034);\n    vec2 c = vec2(coord*4.0);\n    vec2 testz2 = z2;\n    vec2 testc = c;\n    float col = 0.0;\n    for(int i=1; i<=iter; i++){\n        testz2 = vec2(testz2.x*testz2.x-testz2.y*testz2.y, 2.0*testz2.x*testz2.y);\n        testz2 += testc;\n        if(distance(testz2, vec2(0.0)) < 4.0){march = true;}}\n    vec2 newz2 = vec2(0.0);\n    if(march){\n        for(int i=1; i<=iter; i++){\n            z2 = vec2(z2.x*z2.x-z2.y*z2.y, 2.0*z2.x*z2.y);\n            z2 += c;\n            if(distance(z2, c) < 1e-3){col += 100.0;}}\n        return col;}\n}\n\nvec3 mandelbrot(vec2 coord, vec3 iter){\n    ivec3 iterations = ivec3(randexpiter(iter.x), randexpiter(iter.y), randexpiter(iter.z));\n    return vec3(iterchannel(coord, iterations.x), iterchannel(coord, iterations.y), iterchannel(coord, iterations.z))/vec3(iterations);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB: I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    INIT_RNG;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord+(nrand2(1.0, vec2(0.0))))-0.5*iResolution.xy)/iResolution.x;\n    //vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec3 iter = vec3(16, 8, 4);\n    vec3 col = mandelbrot(uv, iter);\n    fragColor += vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, Buffer B, and Image ^^^\n// This is for Exporting a 32-Bit Floating Point OpenEXR Image using the Button on the Bottom of the Editor\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 64, 118, 118, 174]], "test": "untested"}
{"id": "Wl3yWB", "name": "Schrders staircase illusion", "author": "FabriceNeyret2", "description": "source: [url]https://www.boredpanda.com/schroder-staircase-illusion-of-the-year-contest/[/url]\nref image:\n[img]https://static.boredpanda.com/blog/wp-content/uploads/2021/01/1-5ff2d83c36f3f__700.jpg[/img]", "tags": ["illusion", "isometric", "perception", "reproduction"], "likes": 7, "viewed": 400, "published": 3, "date": "1609785477", "time_retrieved": "2024-07-30T19:47:02.884279", "image_code": "// reusing hexastairs  https://shadertoy.com/view/3sGfWm\nfloat ease( float x ) {                              // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x         // stepier than smoothstep or .5-.5*cos                  :                4.* x*x*x ;\n                  :                4.* x*x*x ;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 1.5* ( 2.*u  - R ) / R.y;\n         \n    float t = iTime/2., s, l;\n    U *= mat2( cos( 3.1416*( floor(t)+ease(fract(t)) + vec4(0,.5,-.5,0)) ) ); // rotation\n    l = length(U+vec2(.18,-.94));                          // for sphere\n    U += R/R.y;\n    \n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n\n    vec3  V = vec3( U, U.y-U.x +3.);                       // 3 axial coords\n    ivec3 I = ivec3(floor(V));\n          I += I.yzx;\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n // V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. ).yzx;      // local coords\n    V.xy = mod( V.yz + vec2( I.y+I.x, I.x ), 2. );         // local coords\n\n    O = mix(\n        vec4( \n          I.xy==ivec2(2,1)                                 // central cube\n            ? s = mod(4.5*V.y-1.,2.)-1.,                   // strip slope  for stairs. Side dents below\n              abs( .1+2.*V.x-V.y +(abs(s)-5.5)/4.5 ) > .9 ? .5 : s < 0. ? .3 : 1. // draw stairs\n            : 0.                                           // background\n        ),\n        vec4(sqrt(max(0.,1.-l/.1)),0,0,0), smoothstep(4./R.y,0., l-.1) ); // red sphere\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 80, 161, 346], [348, 348, 386, 386, 1600]], "test": "untested"}
{"id": "3t3yWB", "name": "Desert landscape", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/wt3czs]Eroded hills[/url] terrain.", "tags": ["fractal", "terrain", "desert", "dune"], "likes": 1, "viewed": 353, "published": 3, "date": "1609781898", "time_retrieved": "2024-07-30T19:47:03.826759", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(surface_color(sin(worldDir/10.0+iTime/100.0)).yzx,0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    \n    float starting_distance = pow(length(eye-dmap),.6);\n    if(starting_distance < 20.0){\n        starting_distance = 0.0;\n    }\n    \n\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0)-1.0, cos(iTime*speed/10.0)*3.14), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+starting_distance, MAX_DIST);\n    \n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    \n    p = (sin(p1.yzx+p1*1.3+p1.zxy*1.2+p1*1.5))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 100.0; i *= -5.0){\n        float p1 = planet_surface(p*i,i)/(i);\n        result = max(result+p1-p.y*(1.5+sin((p.x+p.z)/50.0/i)), -p1);\n        p.xz /= 2.0;\n    }\n    return (result-10.0)*scale/8.0;\n}\n\nvec3 surface_color1(vec3 p)\n{\n    p *= 10.0;\n    float p1 = planet_surface(p,3.0);\n    float p2 = planet_surface(p,5.0);\n    float p3 = planet_surface(p,7.0);\n    return sin((vec3(p2-p3,p2,p2-p3)))/10.0+vec3(.5,.4,.3)*1.5;\n}\n\nvec3 surface_color(vec3 p){\n    float k = 2.0;\n    vec3 result;\n    for(int i = 0; i < 5; i++){\n       result += surface_color1(p/k);\n       k *= 2.0;\n       //p *= surface_color1(p);\n    }\n    return result/5.0;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 482, 573, 573, 891], [905, 905, 932, 932, 1081], [1083, 1083, 1140, 1140, 1794]], "test": "untested"}
{"id": "3sVBDd", "name": "Marching Die", "author": "Shane", "description": "A rounded die randomly moving about the surface of other stacked dice.", "tags": ["raymarch", "cube", "dice", "animate", "frame", "die"], "likes": 69, "viewed": 1507, "published": 3, "date": "1609766076", "time_retrieved": "2024-07-30T19:47:04.852018", "image_code": "/*\n\n\tMarching Die\n\t------------\n    \n    I've had this scene sitting in my account for way too long, so thought I'd \n    put it up. I did it just for fun and to relieve boredom. At the time, I \n    thought it'd be cool to see what a standard infinite 2D hexagonal grid filled \n    with cubes would look like in 3D. Once I'd satisfied my curiosity, I figured \n    I'd randomly move a cube about the resultant surface for a bit of visual \n    interest and depth.\n    \n    All of that was simple enough, but texturing a moving animated die correctly\n    proved to be a little tricky. I got there in the end, but I might try to come \n    up with a better system next time.\n    \n    In order to move and texture the die correctly, I hardcoded 15 steps that \n    looped around to the surface die just in front of the original position, which \n    was necessary to keep up with a moving camera synchronized to meet it there. \n    The steps were simple enough: Pivot up and forward about the YZ axis, pivot \n    down and left about the XY axis, etc. Whilst doing this, it was necessary to \n    keep track of the pivot points, fractional rotation matrix, overall position, \n    overall rotation, etc, in order to obtain the correct texture. Texturing was \n    achieved via standard cube mapping -- Render one dot on face one, two dots on \n    face two, etc. I was able to fake randomness by changing the original looped \n    path slightly each time around, or something to that effect.\n    \n    I'm giving the performance a \"mildly OK\" rating. On machines like mine, it'll \n    run fine in the 800 by 450 window, but fullscreen will be slow. At some stage,\n    I'll get in amongst it and improve a few things. I'm also going to post my\n    original shader that doesn't have rounded stacked dice, reflections, etc, so\n    that will be much faster.\n \n    \n   \n    Other examples:\n\n\t// Quite watchable: Dave Hoskins was coding stacked cubes before it was cool. :D \n    Ray*Bert - Dave_Hoskins \n\thttps://www.shadertoy.com/view/4sl3RH\n    \n    // I really like this one. It'd be cool to see a fancier version at some stage.\n    hexastairs: ladder like + doors - FabriceNeyret2\n    https://www.shadertoy.com/view/wsyBDm\n    \n    // Here's another related example of Fabrice's. I like the way he's worked\n    // the camera.\n    rolling dice on surface - FabriceNeyret2 \n    https://www.shadertoy.com/view/WdGBRc\n \n\n*/\n\n// Bouncing the die from level to level... It works but needs a little fine tuning.\n//#define BOUNCE\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// Far plane, or max ray distance.\n#define FAR 40.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n// Global block scale.\n#define GSCALE vec2(1./1.5)\n\n\n#define PI 3.14159\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID, svObjID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IQ's signed box formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// IQ's signed box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;\n  \n  // Unsigned.\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n// Exponential easing function.\nfloat exponentialOut(float t) {\n  return t == 1. ? t : 1. - pow(2., -8.*t);\n}\n\n// Quad easing function. \nfloat easeOutQuad(float t) {\n    return -t*(t - 2.);\n}\n \n \n// Various moving die storage containers. I added these as I went\n// along, so it definitiely needs a tidy up.\n\n// Cube distance and ID.\nvec3 svGID; \n\n// Die rotation storage matrices.\nmat2 gMat, svMat;\nmat2 lRot;\n\n// Texture pivot and offset matrices for the moving die.\nvec3 gTxP, svTxP;\nvec3 gPiv, svPiv;\nvec3 gOff;\n\n// Pivot total direction and direction storage.\nvec3 lPivot;\nvec3 lTotDist;\nvec3 dirI;\n// XY and YZ direction start positions.\nfloat lStartXY;\nfloat lStartYZ;\n// Bounce value.\nfloat gBounce = 0.;\n\n\n// Moving the cube whilst keeping track of pivot, offset, etc, variables\n// for texturing purposes. This is a long and ugly function, but thankfully,\n// it's only called once per frame.\nvoid moveCube(float gTime){\n\n   \n    const int ttm = 15;\n    float tm = gTime*float(ttm)/GSCALE.x; \n    \n    float modtm = mod(tm, float(ttm));\n \n    // Initial die offset -- Arrange to match the camera movement.\n    gOff = ((vec3(5, 4, -4) - 1./2.) + floor(tm/float(ttm))*vec3(0, 1, 1))*GSCALE.x;\n \n    lStartYZ = mod(floor(tm/float(ttm)), 2.);\n\n    // Directions -- All 15 of them.\n    vec3[ttm] dir = vec3[ttm](vec3(0, 1, 1), vec3(1, 1, 0), vec3(0, 1, 1), vec3(-1, -1, 0), vec3(0, 1, 1), vec3(-1, -1, 0),\n    vec3(0, 1, 1), vec3(-1, -1, 0), vec3(-1, -1, 0), vec3(0, -1, -1), vec3(1, 1, 0), vec3(0, -1, -1), \n    vec3(1, 1, 0), vec3(0, -1, -1), vec3(1, 1, 0));\n    \n    // Random swap.\n    for(int i = 0; i<15; i++){\n        if(hash21(vec2(floor(tm/float(ttm)), i)/15.)<.333) swap(dir[i], dir[(i + 1)%15]);\n    }\n    \n    lTotDist = vec3(0); // Total distance.\n    \n    // Cycle through the animation frames, then move the dice from one level to the\n    // the next in whatever random direction the array has chosen. Whilst doing so,\n    // keep track for the pivot point, rotation matrix, total distance, etc, for later\n    // texture usage... If you're thinking it looks fiddly, you'd be right, but it's\n    // all just basic physics and not as hard as you'd think.\n    for(int i = 0; i<ttm; i++){\n\n       float fi = float(i);\n       dirI = dir[i];\n\n       if(modtm<fi + 1.){ \n            \n            // Fractional time component.\n            float t = (modtm - fi)/1.;\n            \n            #ifdef BOUNCE\n            // Alternative level to level bounce.\n            t = easeOutQuad(t);\n            gBounce = (1. - abs(fract(t) - .5)*2.)*GSCALE.x*.25;\n            #else\n            // Exponential ease.\n            t = exponentialOut(t); \n            #endif\n            \n            // Rotate in the given direction from the pivot point.\n            t = mix(0., PI, t);\n            if(dirI.z<-.5 || dirI.x>.5) t *= -1.;            \n            lRot = rot2(t);\n            lPivot = dirI*GSCALE.x/2.;//vec3(0, GSCALE.x, GSCALE.x)/2.;\n            \n            // Save the pivol and rotation variables.\n            gPiv = lPivot;\n            gMat = lRot;\n           \n            break;\n\n\n       }\n\n       lTotDist += dirI; // Update the overall position.\n\n    }\n    \n\n}\n\n\n// Dice block levels.\n\nvec4 blocks(vec3 q){\n\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = GSCALE;//vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block central postions.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n \n    \n    float height = 0.; // Block height initialization.\n    \n    // Height scale.\n    const float hs = .125;\n\n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0]/2.;\n        \n \n        \n        p = q.xz - cntr*s;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n        \n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n\n  \n        // Block height.\n        float h1 = (ip.y - .5 - float(i/2)/2.)*GSCALE.y + 1.;//hm(idi);\n        h1 += (ip.x - .5)*GSCALE.x + 1.;\n        if(i==0 || i==3) h1 -= GSCALE.x/2.;\n        \n \n        // Render the dice.\n        float qy = mod(q.y - GSCALE.x/2., GSCALE.x*2.) - GSCALE.x;\n        float face1Ext = sBox(vec3(p, qy), vec3(dim.x/2.), .07);\n        face1Ext = smax(face1Ext, length(vec3(p, qy)) - GSCALE.x/2.*1.55, .1);\n        qy = mod(q.y + GSCALE.x/2., GSCALE.x*2.) - GSCALE.x;\n        float face2Ext = sBox(vec3(p, qy), vec3(dim.x/2.), .07);\n        face2Ext = smax(face2Ext, length(vec3(p, qy)) - GSCALE.x/2.*1.55, .1);\n        face1Ext = min(face1Ext, face2Ext);\n        \n        face1Ext = max(face1Ext, (q.y - h1*2. + .01));\n        \n        vec4 di = vec4(face1Ext, idi, h1);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box height. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w; \n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, height);\n}\n\n\n\n\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Reflecting the wall opposite to give the light something to relect off of.\n    //p.y =  abs(p.y - .25) - .75;\n    \n    // Wall behind the pylons to stop the light getting through.\n    vec3 q = p;\n    \n    q.yz *= rot2(3.14159/4.);\n    q.xy *= rot2(-3.14159/5.);\n    float wall = 1e5;//q.y - .7071 + .1;//abs(q.y - .7017 + 1.) - 1.;//1.5*.7071;\n    \n \n    // Blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    \n    // Move and render the die.\n    \n    // Initial point.\n    q = p - gOff- lTotDist*GSCALE.x; \n    // Bounce.\n    q.y -= gBounce;\n    // Pivot about the pivot point.\n    q -= lPivot;\n    // Depending on direction rotate around the XY plane or the YZ one.\n    if(abs(dirI.x)>.5) q.xy = lRot*q.xy;\n    else q.yz = lRot*q.yz;\n    // Pivot back.\n    q += lPivot;\n \n    // Factor in the total rotation for each direction.\n    q.xy = rot2(mod(lTotDist.x, 2.)*PI)*q.xy;\n    q.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*q.yz;\n\n    // Keep a global texture copy for texturing later. \n    gTxP = q; \n    \n    // Render the smooth edged rounded cube.\n    float bx = sBox(q, vec3(GSCALE.x/2.), .07);\n    bx = smax(bx, length(q) - GSCALE.x/2.*1.55, .1);\n    \n \n    // Overall object ID.\n    objID = (wall<d4.x && wall<bx)? 2 : d4.x<bx? 0 : 1;\n    \n    // Combining the wall with the extruded blocks.\n    return min(wall, min(d4.x, bx));\n \n}\n\n\n// Basic raymarcher.\nfloat trace(vec3 ro, vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d; \n    \n    for(int i = 0; i<72; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.5 : d*.9; // Slower, but more accuracy.\n        //t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Render the dots on each face of each cube in the scene.\nfloat getDots(vec3 p, vec3 n){\n\n    // Choose the face. Based on some of Fizzer's cube mapping logic.\n    vec3 aN = abs(n);\n\n    ivec3 idF = ivec3(n.x<-.25? 0 : 5, n.y<-.25? 1 : 4, n.z<-.25? 2 : 3);\n\n    int face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z; \n\n    float zDist = GSCALE.x/2.;\n    \n    vec2 tuv = p.xy; // Face UV coordinates.\n\n    // Render the face dots, according to face ID.\n    // How you go about this is up to you. There'd probably be more efficient\n    // ways, but this will do.\n    float dots = 1e5;\n    const float dSz = .0;\n    const float dsp = .12;\n    //if(face == 0)  dots = length(vec3(tuv, p.z + zDist)); // 3D -- Not needed.\n    if(face == 0)  dots = length(tuv);\n    else if(face == 1){\n        dots = min(length(tuv - dsp), length(tuv + dsp));\n        // 3D -- Not needed.\n        //dots = length(vec3(tuv - dsp, p.z + zDist));\n        //dots = min(dots, length(vec3(tuv + dsp, p.z + zDist)));\n    }\n    else if(face == 2){\n        dots = length(tuv);\n        dots = min(dots, min(length(tuv - dsp), length(tuv + dsp)));\n    }\n    else if(face == 3){\n        tuv = abs(tuv) - dsp;\n        dots = length(tuv);\n    } \n    else if(face == 4){\n        dots = length(tuv);\n        tuv = abs(tuv) - dsp;\n        dots = min(dots, length(tuv));\n\n    }     \n    else if(face == 5){\n        tuv.y = abs(tuv.y) - dsp;\n        dots = length(tuv);\n        tuv.x = abs(tuv.x) - (dsp + .02);\n        dots = min(dots, length(tuv));\n\n    } \n    \n    return dots - dSz;\n                \n}\n\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 txP, in vec3 n){\n\n    \n    vec3 txN = n;\n     \n    vec3 tuv = vec3(0);\n    \n    // Background dice.\n    if(svObjID==0){  \n       \n        // Randomly rotate the faces.\n        float rndXY = hash21(svGID.yz);\n        float rndYZ = hash21(svGID.yz + .37);\n        float rndZX = hash21(svGID.yz + .71);\n        vec3 rSn = txN;\n        rSn.xy *= rot2(floor(rndXY*36.)*PI/2.);\n        rSn.yz *= rot2(floor(rndYZ*36.)*PI/2.);\n        rSn.xz *= rot2(floor(rndZX*36.)*PI/2.);\n        \n        // Select the UV coordinates from the dominant normal.\n        // If X is dominant, then select the YZ face, etc.\n        vec3 aN = abs(txN);\n        tuv = aN.x>.5? txP.yzx*vec3(1, 1, -1) :  aN.y>.5? txP.zxy*vec3(1, 1, -1) : txP.xyz*vec3(1, 1, -1);\n    \n        tuv = mod(tuv, GSCALE.x) - GSCALE.x/2.;\n        \n        txN = rSn;\n    \n    }\n    \n    // Moving die.\n    if(svObjID==1){\n    \n    \n        // Saved rotation data to rotated the normal to the \n        // correct position.\n       \n        if(abs(svPiv.x)>.01){\n             txN.xy = svMat*txN.xy;\n        }\n        else {\n             txN.yz = svMat*txN.yz;\n        }  \n       \n        // Overall rotation.\n        txN.xy = rot2(mod(lTotDist.x, 2.)*PI)*txN.xy;\n        txN.yz = rot2((mod(lStartYZ + lTotDist.z, 2.))*PI)*txN.yz;    \n \n        // Select the UV coordinates from the dominant normal.\n        // If X is dominant, then select the YZ face, etc.\n        vec3 aN = abs(txN);\n        tuv = aN.x>.5? txP.yzx :  aN.y>.5? txP.zxy : txP.xyz;\n        \n    }\n    \n    \n    \n    \n    // Rendering the dots on the faces.\n    float d = 1.;\n    \n    if(svObjID<2) {\n        d = getDots(tuv, txN); //sin(tuv.x*64.)*.5 + .5;//\n        \n        //tuv = mod(tuv - GSCALE.x/2., GSCALE.x) - GSCALE.x/2.;\n        //float sq = max(abs(tuv.x), abs(tuv.y)) - GSCALE.x/2. + .01;\n        //d = min(d, abs(sq));\n\n        d = smoothstep(0., .06, d);\n        \n        // Corrugated grooves... Why I thought this would work, I'll never know. :D\n        //d *= sin((tuv.x)*40.)*.04 + .96;\n        \n    }\n    \n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took far too long before it hit me. :)\n    return  d;//d/(1. + gT*gT*.015);\n   \n   \n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, inout float ref){\n\n\n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0);\n    \n    // It'd be nice to have elegant looking code, but in reality, it's all about \n    // hacks. The cube moves in relation to the rest of the scene, and needs \n    // to have it's relative position tracked for texturing purposes... \n    // And the relative sample offsets, it would appear... That's just painful. \n    // Not all coding is fun. :)\n    vec3 v0 = e.xyy;\n    vec3 v1 = e.yxy;\n    vec3 v2 = e.yyx;\n   \n    if(svObjID==1){\n    \n        p = svTxP;\n        \n        if(abs(svPiv.x)>.01){\n             v0.xy = svMat*v0.xy;\n             v1.xy = svMat*v1.xy;\n             v2.xy = svMat*v2.xy;\n        }\n        else {\n             v0.yz = svMat*v0.yz;\n             v1.yz = svMat*v1.yz;\n             v2.yz = svMat*v2.yz;\n        }  \n       \n        // Overall rotation.\n        v0.xy = rot2(mod(lTotDist.x, 2.)*PI)*v0.xy;\n        v0.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v0.yz;    \n        v1.xy = rot2(mod(lTotDist.x, 2.)*PI)*v1.xy;\n        v1.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v1.yz;    \n        v2.xy = rot2(mod(lTotDist.x, 2.)*PI)*v2.xy;\n        v2.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v2.yz;\n        \n    }\n    \n     \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    ref = bumpSurf3D(p, nor); // The reference value is returned for later use.\n    vec3 grad = (vec3(bumpSurf3D(p - v0, nor),\n                      bumpSurf3D(p - v1, nor),\n                      bumpSurf3D(p - v2, nor)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// FBM.\nfloat fBm(vec3 p){ return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; }\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 5.;\n    p.x += iTime/2.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); // Putting in some dark space.\n    \n    \n    //p = pow(min(vec3(1.4, 1, 1)*c, 1.), vec3(1, 3, 16)); // Fire.\n    p = vec3(c, c*c, c*c*c*c); // Orange tinge.\n   \n    p = mix(p, p.zyx, n3D2); // Mixing the color around.\n    \n    return p*p;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n    float tm = iTime/12.;\n    vec3 ro = vec3(0, 5. + tm, -5. + tm); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.18, -.15, .2);//vec3(0, -.25, iTime);  \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(2.5, 1, 2.25); // Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    //vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV));\n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0); \n    \n    float alpha = 1.;\n    \n    moveCube(tm);\n    \n    for(int j = 0; j<PASSES; j++){\n    \n         \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        // Used for refractions, but not here.    \n        //float distanceFactor = 1.;\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd);\n\n        // Saving the object ID, block ID and cell object (block part) ID.\n        svObjID = objID;\n        svGID = gID;\n        \n        // Saving the texture, pivot and rotaion matrices for the animated\n        // die on the surface.\n        svTxP = gTxP;\n        svPiv = gPiv;\n        svMat = gMat;\n        \n        //float svBounce = gBounce;\n\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp);// *distanceFactor; // For refractions.\n            \n            \n            // Function based bump mapping.\n            //\n            // The bump value at the hit point -- Used for later shading purposes.\n            float bumpShade; \n            sn = doBumpMap(sp, sn, .1, bumpShade);///(1. + t*t/FAR/FAR*.25)\n            \n            // Texture size factor.\n            float sz0 = 1./2.;\n           \n             \n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            //vec3 smSn = sn;\n            //sn = texBump(iChannel0, sp*sz0, sn, .005);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n             \n            \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            if(j == 0) gSh = softShadow(sp, lp, sn, 8.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + .2, 1.); // Shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.1); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            \n            dif = pow(dif, 4.)*2.; // Ramping up the diffuse.\n\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n      \n            // Object color.\n            vec3 oCol;\n            \n             \n            if(svObjID == 0) {\n\n                // Coloring the background dice.\n                float rnd2 = hash21(svGID.yz + floor(sp.y/GSCALE.x) + .3);\n                \n                // Block coloring.\n                vec3 tx = tex3D(iChannel0, sp*sz0, sn);\n                tx = smoothstep(-.05, .5, tx);\n                //tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .144)), .5);\n                oCol = tx*mix(vec3(.9, 1, 1.2).zyx, vec3(.9, 1, 1.2), tx.x);\n                oCol *= vec3(.85, 1, 1.2);\n                 \n                //oCol *= mix(vec3(.8, 1, 1.2), 1./vec3(.8, 1, 1.2), \n                // mod(svGID.y + svGID.z, 2.)<.5? 0. : 1.);\n                //float rnd = hash21(svGID.yz);\n                //vec3 rCol = .6 + .4*cos(6.2831*rnd/4. + vec3(0, 1, 2));\n               \n                //objRef = .25;\n                // Arrange for less reflection in the dice holes.\n                objRef = mix(.125, .25, smoothstep(0., .1, bumpShade));\n\n                \n            }\n            else if(svObjID == 1) {\n            \n                // Texture the colored moving die.\n                \n                // Saved texture value from the die movement function.\n                vec3 txP = svTxP;\n                \n                // Using the saved rotation matrices to rotate the face\n                // normal to the correct position.\n                vec3 txN = sn;\n \n                if(abs(svPiv.x)>.01){\n                      txN.xy = svMat*txN.xy;\n                }\n                else {\n                      txN.yz = svMat*txN.yz;\n                }\n               \n                // Overall rotation.\n                txN.xy = rot2(mod(lTotDist.x, 2.)*PI)*txN.xy;\n                txN.yz = rot2((mod(lStartYZ + lTotDist.z, 2.))*PI)*txN.yz;\n                   \n\n                // Block texturing and coloring.\n                vec3 tx = tex3D(iChannel0, txP*sz0, txN);\n                tx = smoothstep(-.05, .55, tx);\n                //tx = vec3(1)*dot(tx, vec3(.299, .587, .144));\n\n                //oCol = tx*vec3(1, .3, .5)*2.;\n                oCol = tx*mix(vec3(1, .42, .28).xzy, vec3(1, .42, .28), tx.x*1.1)*2.6;\n                //oCol = tx*vec3(.2, .58, 1)*2.6;\n        \n                \n                //vec3 aN = abs(txN);\n                //vec3 tuv = aN.x>.5? txP.yzx :  aN.y>.5? txP.zxy : txP.xyz;\n                //float sq = sBox(tuv.xy, vec2(GSCALE.x/2. - .07), .05);\n                //sq = abs(sq) - .02;\n                //oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .003, sq))*.9);\n               \n                //objRef = .25;\n                // Arrange for less reflection in the dice holes.\n                objRef = mix(.125, .25, smoothstep(0., .1, bumpShade));\n\n                \n            }\n            else {\n                // Dark wall behind the tiny gaps in the blocks. \n                oCol = vec3(0);\n                objRef = .0;\n            }\n            \n \n\n            // Combining the diffuse, specular and Fresnel terms, if applicable.\n            colL = oCol*(dif + vec3(1, .7, .5)*spe*16. + .1);// + vec3(1, .7, .5).zyx*pow(freS, 2.)*2.;\n            \n            // Optional environmental mapping. Not used.\n            vec3 envCol = envMap(reflection);\n            //vec3 envCol = texture(iChannel1, reflection).xyz; envCol *= envCol;\n            colL += colL*envCol.zyx*8.;\n            \n            // Multiply the dice dots by the bump value for extra depth.\n            if(svObjID<2) colL *= bumpShade;\n            \n            // Combining it with the object color, then shading.\n            colL *= ao*att*sh;\n \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);//mix(vec3(.1, .3, 1)/12., vec3(.25, .5, 1)/6., rd.y*.5 + .5);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n        \n        \n        // This is a more subtle way to blend layers. \n        //col = mix(col, min(colL, 1.), 1./float(1 + j)*alpha);\n        // In you face additive blend. Sometimes, I prefer this.\n        col += min(colL, 1.)*alpha;\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef<.001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n   \n    \n    /*\n    // Cheap hash pattern. Needs work... Much more work. :)\n    float gry = dot(col, vec3(.299, .587, .114));\n    gry = sqrt(gry);\n    float pat = 1.;\n      \n    const int NN = 5;\n    const float fn = float(NN);\n    float lns = 200.*iResolution.y/450.;\n    float sf = 1./iResolution.y;\n    for(int i = 0; i<NN; i++){\n        \n        vec2 rp = rot2(3.14159/3. - float(i)*6.2831/fn/2.)*uv;\n        rp += float(i)/fn;\n        float patL = abs(fract((rp.x)*lns) - .5)*2. - .05;\n        \n        if(gry<(fn - float(i))/(fn + 1.)) pat = min(pat, patL);\n    }\n    \n    pat = smoothstep(0., sf*lns*2., pat);\n    col = vec3(pat*;\n    */\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3092, 3125, 3147, 3147, 3205], [3207, 3235, 3256, 3256, 3319], [3322, 3545, 3583, 3583, 3664], [3667, 3821, 3869, 4171, 5080], [5084, 5112, 5158, 5158, 5243], [5245, 5273, 5319, 5319, 5482], [5485, 5517, 5548, 5548, 5594], [5596, 5622, 5650, 5650, 5676], [10913, 10936, 10954, 11151, 12348], [12351, 12372, 12402, 12451, 12944], [12947, 13138, 13190, 13307, 14624], [14627, 14779, 14814, 14814, 15211], [16024, 16083, 16113, 16184, 17586], [17955, 17982, 18023, 18023, 20373], [20375, 20566, 20640, 20738, 22943], [24038, 24181, 24202, 24202, 24548], [24550, 24558, 24576, 24576, 24629], [24631, 24930, 24950, 24950, 25373], [25376, 25376, 25432, 25465, 35939]], "test": "untested"}
{"id": "ttdyzs", "name": "Genuary 4: Small areas of symmet", "author": "illus0r", "description": "Genuary 4: Small areas of symmet", "tags": ["reactiondiffusion"], "likes": 9, "viewed": 387, "published": 3, "date": "1609763452", "time_retrieved": "2024-07-30T19:47:05.949084", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n        float row = floor(uv.y*RC.y);\n        if (mod(row,2.)==0.){\n            uv.x = fract(uv.x + 1./RC.x/2. + iTime/40.);\n        }\n        else {\n            uv.x = fract(uv.x - iTime/40.);\n        }\n        float col = floor(uv.x*RC.x)/RC.x;\n        uv.x *= RC.x;\n        uv.x = mod(uv.x+.5, 1.);\n        uv.x = abs(uv.x-.5);\n        uv.x /= RC.x;\n        uv.x += col;\n        fragColor = vec4(smoothstep(.3,.6,texture(iChannel0, uv).r));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIMESTEP 1.\n\n#define GRID (step(.45,length(mod(uv,1./RC)*RC-.5)))\n#define F (0.055 - GRID*.04)\n#define K (0.063 + GRID*.01)\n#define Da (1.0)\n#define Db (.4*smoothstep(0.,5.,iTime))\n#define RADIUS 3.\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x));}\n\nvoid getVal(vec2 p, out vec2 val, out float diff_a, out float diff_b) {\n  vec2 r = iResolution.xy;\n  vec2 uv = p / r;\n  val = texture(iChannel0, uv).xy;\n  vec2 neigh_val_a = vec2(0.);\n  vec2 neigh_val_b = vec2(0.);\n  vec2 k_anisotropy = abs(normalize(uv-vec2(.5)));\n  if(uv.x<0.5)k_anisotropy = k_anisotropy.yx;\n  float k_sum = 0.;\n  for(float i = -RADIUS; i <= RADIUS; i++){\n      for(float j = -RADIUS; j <= RADIUS; j++){\n          if(i==0. || j==0.) continue;\n          if(length(vec2(i,j))>RADIUS) continue;\n          vec2 k = vec2(1.);\n          k_sum += k.x+k.y;\n          vec2 pij = p+vec2(i,j);\n          \n          neigh_val_a += texture(iChannel0, (pij) / r).x * k;\n          neigh_val_b += texture(iChannel0, (pij) / r).y * k;\n      }\n  }\n  neigh_val_a /= k_sum;\n  neigh_val_b /= k_sum;\n  diff_a = (-val.x+neigh_val_a.x+neigh_val_a.y)/2.;\n  diff_b = (-val.y+neigh_val_b.x+neigh_val_b.y)/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 colour = vec3(0.0);\n    if (iFrame < 1) {\n        colour = vec3(rnd(uv.x+uv.y*.0001));\n    } else {\n     \tvec2 val;\n        float diff_a, diff_b;\n        getVal(fragCoord.xy, val, diff_a, diff_b);\n        \n        vec2 delta;\n \t\tdelta.x = Da * diff_a - val.x * val.y * val.y + F * (1.0 - val.x);\n  \t\tdelta.y = Db * diff_b + val.x * val.y * val.y - (K + F) * val.y;\n        \n        \n        colour = vec3(val + delta * TIMESTEP, 0.0);\n        colour = clamp(colour, -1., 1.);\n    }\n    \n    fragColor = vec4(colour,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// rows and columns amount\n#define RC vec2(12.,4.)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 550]], "test": "untested"}
{"id": "ttdyRs", "name": "Planetary gears golfed (364 ch)", "author": "FabriceNeyret2", "description": " golfing 1471 chars \"Planetary gears\" by AntoineC. [url]https://shadertoy.com/view/MsGczV[/url]", "tags": ["2d", "gear", "golf"], "likes": 19, "viewed": 614, "published": 3, "date": "1609758790", "time_retrieved": "2024-07-30T19:47:06.841698", "image_code": "// golfing 1471 chars \"Planetary gears\" by AntoineC. https://shadertoy.com/view/MsGczV\n// Now in the ugly golfing phase. check below for more readable ones :-D\n\n\n// ---    -9 by Xor\n\n#define G( U, t, r, M )                                                   \\\n    l = M( l = length(U) - r,                                             \\\n           .16-r/3.-l + .08 / ( 1.+ exp( 4.* sin( 2.* t  16.* atan(U.y, U.x) ) ) )), \\\n    O = mix( O * min( 1., .3 + 1.75* abs( length(U+.1) - r ) /r ) ,       \\\n             i * vec4( 1, .7, .2, 1),                                     \\\n             clamp( .5 - l / fwidth(l) ,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   W = iResolution.xy,\n           U = ( u+u - W ) / W.y;\n    float  t = .5*iTime, i = .34, l;\n\n    for( O-=O; i < .9; i+=.08, t+=.8 )\n        G( (U + .4*cos(t+vec2(0,11))), 8.*t +, .3  , -min );\n    \n    G(U, , .9, max );\n}\n\n\n\n\n\n\n\n/* // ---    -12 by Fab, -9 by iapafoto\n\n#define G( U, t,R,r, M )                                                  \\\n    l = M( l = length(U) - r,                                             \\\n           R-l + .08 / ( 1.+ exp( 4.* sin( t  16.* atan(U.y, U.x) ) ) )), \\\n    O = mix( O - O*  max( 0., .7 - 1.75* abs( length(U+.1) - r ) /r ) ,   \\\n             i * vec4( 1, .7, .2, 1),                                     \\\n             clamp( .5 - l / fwidth(l) ,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   W = iResolution.xy,\n           U = (u+u - W) / W.y;\n    float  t = .5*iTime, i = .34, l;\n\n    for( O-=O; i < .9; i+=.08, t += .8 )\n        G( (U + .4*vec2(cos(t),sin(t))), 16.*t +, .06, .3  , -min );\n    \n    G(U, 2.*, -.14, .9, max );\n}\n\n\n\n\n\n\n\n/*  // --- 394 chars    -7 by Fab\n\n// params: Time, Gear radius, [Teeth height=.08, Teeth \"roundness\"=4.], Teeth count, Inner or outer border radius, [light=formula]\n\n#define G( U, t,R,n,r, M)                                                     \\\n    l = length(U),                                                            \\\n    p = R - .04 + .08 / ( 1.+ exp( 4.* sin( t + n* atan(U.y, U.x) ) ) ),      \\\n    l = M(l-r, p-l),                                                          \\\n    O = mix( O - O* .7* max( 0., 1. - abs( length(U+.1) - r ) /.4/r ) ,       \\\n             ( .26 + i/12. ) * vec4(.95, .7, .2, 1),                          \\\n             clamp( .5 - l / fwidth(l) ,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   W = iResolution.xy,\n           U = ( u+u - W ) / W.y;\n    float  t = .5*iTime,\n           i=0.,l,p;\n\n    for( O-=O; ++i < 9.; t += .79 )\n        G( (U + .4*vec2(cos(t),sin(t))), 16.*t, .4,  16., .3  , -min);\n    \n    G( U, , .8, 32., .9, max);\n}\n\n\n\n\n\n\n\n/*  // --- 401 chars.  -30 by Fab, -6ch by iapafoto.  Now in the ugly golfing phase. check below for more readable ones :-D\n\n// params: Time, Gear radius, [Teeth height=.08, Teeth \"roundness\"=4.], Teeth count, Inner or outer border radius, [light=formula]\n\n#define G( U, t,R,n,r )                                                       \\\n    l = length(U),                                                            \\\n    p = R - .04 + .08 / ( 1.+ exp( 4.* sin( t + n* atan(U.y, U.x) ) ) ) -l,   \\\n    l = R > r ? -min(l-r, p) : max(l-r, p),                                   \\\n    O = mix( O - O* .7* max( 0., 1. - abs( length(U+.1) - r ) /.4/r ) ,       \\\n             ( .26 + i/12. ) * vec4(.95, .7, .2, 1),                          \\\n             clamp( .5 - l / fwidth(l) ,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   W = iResolution.xy,\n           U = ( u+u - W ) / W.y;\n    float  t = .5*iTime,\n           i=0.,l,p;\n\n    for( O-=O; ++i < 9.; t += .79 )\n        G( (U + .4*vec2(cos(t),sin(t))), 16.*t, .4,  16., .3  );\n    \n    G( U, , .8, 32., .9 );\n}\n\n\n\n\n\n\n\n/*  // --- 439 chars\n\n// params: Time, Gear radius, Teeth height, Teeth \"roundness\", Teeth count, Inner or outer border radius, light\n// note that we could inline h = .08, s = 4., N = 8.\n\n#define G( U, t,R,h,s,n,r,C )                                                 \\\n    l = length(U),                                                            \\\n    p = R - .5*h + h / ( 1.+ exp( s* sin( t + n*  atan(U.y, U.x) ) ) ),       \\\n    f = R > r ? max(r-l, l-p) : max(l-r, p-l),                                \\\n    O = mix( O - O* .7* max( 0., 1. - abs( length(U+.1) - r ) /.4/r ) ,       \\\n             C vec4(.95, .7, .2, 1),                                          \\\n             clamp( .5 - f / fwidth(f) ,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   W = iResolution.xy,\n           U = ( u+u - W ) / W.y;\n    float  t = .5*iTime, N = 8., \n           i=-1.,l,p,f;\n\n    for( O-=O; ++i<N; t += 6.3/N )\n        G( (U + .4*vec2(cos(t),sin(t))), 16.*t, .4, .08, 4., 16., .3, (.35 + .6*i/(N-1.))* );\n    \n    G( U, , .8, .08, 4., 32., .9, );\n}\n\n\n\n\n\n\n\n/*  // --- 472 chars\n\n#define G( U, t,R,h,s,n,r,C )                                                 \\\n    l = length(U),                                                            \\\n    p = R - .5*h + h/(1.+exp(s*sin(t + n*  atan(U.y, U.x) ))),                \\\n    f = R > r ? max(r-l, l-p) : max(l-r, p-l),                                \\\n    O = mix( O * (1. - .7* smoothstep(.4*r, 0., abs(length(U+.1) - r)) ) ,    \\\n                 C vec4(.95, .7, .2, 1), smoothstep(2., -2., f / fwidth(f) * length(fwidth(U)) *W.y) );\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2   W = iResolution.xy,\n           U = ( u+u - W ) / W.y;\n    float  t = .5*iTime, N = 8., \n           i=-1.,l,p,f;\n\n    for( O-=O; ++i<N; t += 6.3/N )\n        G( (U + .4*vec2(cos(t),sin(t))), 16.*t, .4, .08, 4., 16., .3, (.35 + .6*i/(N-1.))* );\n    \n    G( U, , .8, .08, 4., 32., .9,  );\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tltczl", "name": "RayMarching Sphere ", "author": "hanker", "description": "ray march ", "tags": ["raymarch"], "likes": 0, "viewed": 235, "published": 3, "date": "1609750145", "time_retrieved": "2024-07-30T19:47:07.608647", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST  .01\n#define MAX_DIST  100.\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0.,1.5,6.,1.5);\n    float dS = length(p - sphere.xyz) - sphere.w;\n    float dG = p.y;\n    return min(dS,dG);\n}\nfloat RayMartch(vec3 ro,vec3 rd){\n    float d = 0.;\n    vec3 p = ro;\n    for(int i = 0; i < MAX_STEPS; i++){\n        p = ro + rd * d;\n        float dS = GetDist(p);\n        d += dS;\n        if(dS < SURFACE_DIST || d > MAX_DIST)break;\n    }\n    return d;\n}\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.001,0.);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),GetDist(p - e.yxy),GetDist(p - e.yyx)\n    );\n    return normalize(n);\n}\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0.,8.,1.);\n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    vec3 ld =  normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    float dif = clamp(dot(normal,ld),1.,1.);\n    \n    //shadow\n    float d = RayMartch(p + normal * SURFACE_DIST * 2.,ld);\n    if(d < length(lightPos - p))dif *= .5;\n    return dif;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.y  += 1.;\n    vec3 ro = vec3(0.,1.,-3.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,0.) - ro);\n    float d = RayMartch(ro,rd);\n\n    vec3 p = ro + rd * d;\n\n    float diffuse = GetLight(p);\n    vec3 col = vec3(diffuse);\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 93, 93, 227], [228, 228, 261, 261, 483], [484, 484, 507, 507, 683], [684, 684, 707, 707, 1047], [1048, 1048, 1101, 1101, 1471]], "test": "untested"}
{"id": "wtdyzl", "name": "Merp", "author": "levonchic", "description": "merp merp merp", "tags": ["sound", "animation", "distance2d", "merp", "sergal"], "likes": 15, "viewed": 431, "published": 3, "date": "1609748638", "time_retrieved": "2024-07-30T19:47:08.579053", "image_code": "// MIT License (c) bitrate16\n\n// Sergal count\n#define COUNT 64     // Sergals count (For not random use nearest square like 9, 16, 25, ..)\n#define SCALE 1.0    // Sergals scale (larger value -> smaller)\n#define TIME_RND 2.0 // Time random range\n#define TIME_DEF 1.0 // Time default value (Result time is (rand(TIME_RND) + TIME_DEF))\n//#define RANDOM    // Use random spawn or coordinate grid\n\n// Ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec4 sergal(vec2 frag, vec2 serg, bool state, float fact, float minMap) {\n    frag -= serg;\n    // Map fragCoord to texture size for different states\n    if (state) {\n        vec2 uv = frag / fact;\n        if (uv.x < 0.0 || uv.x > 0.5 || uv.y < 0.0 || uv.y > 0.5)\n            return vec4(0.0);\n        uv += minMap * vec2(0.5, 0.5);\n        return texture(iChannel0, uv);\n    }\n    \n    vec2 uv = frag / fact;\n    if (uv.x < 0.0 || uv.x > 0.5 || uv.y < 0.0 || uv.y > 0.5)\n        return vec4(0.0);\n    uv += minMap * vec2(0.0, 0.5);\n    return texture(iChannel0, uv);\n}\n\n// Paste B on A\nvec4 paste(vec4 a, vec4 b) {\n    return a * a.a + b * (1.0 - a.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Minimal of resolutions\n    float fact = min(iResolution.x, iResolution.y);\n    vec2 map = iResolution.xy / fact;\n    // minimal of scaled resolution used in scaling Channel 0 texture\n    float minMap = min(map.x, map.y);\n    // Sergal size used to make random spawner cords offsets\n    vec2 sergalSize2 = vec2(fact * SCALE * 0.25);\n    // Scale the sergal size\n    fact *= SCALE;\n    \n    fragColor = vec4(1.0);\n    \n    const float offstep = sqrt(float(COUNT));\n    \n#ifdef RANDOM\n    // Divide view into multiple lines & draw sqrt(COUNT) \n    //  sergals on each of sqrt(COUNT) lines\n    float resstep = (iResolution.y + sergalSize2.y) / offstep;\n    \n    // Fill the view with sergals\n    for (int i = 0; i < COUNT; ++i) {\n        float sqri = sqrt(float(i));\n        fragColor = paste(sergal(fragCoord,\n                            // Sergal coord on each \"line\" is defined by noise value\n                            vec2(rand(float(i +     COUNT)) * (iResolution.x + sergalSize2.x), \n                                 rand(float(i + 2 * COUNT)) * resstep + resstep * (offstep - sqri))\n                               - sergalSize2,\n                            // Animation time is defined by noise\n                            mod(iTime * (TIME_DEF + TIME_RND * rand(float(i + 3 * COUNT))), 1.0) <= 0.5,\n                            fact,\n                            minMap),\n                          fragColor);\n    }\n#else\n    // Divide view into multiple lines & draw sqrt(COUNT) \n    //  sergals on each of sqrt(COUNT) lines\n    vec2 resstep = (iResolution.xy + sergalSize2.xy) / offstep;\n    \n    float lineno = offstep - 1.0;\n    float colno = offstep - 1.0;\n    for (float i = 0.0; i <= offstep * offstep; i += 1.0) {        \n        vec2 sergpos = vec2((colno + (-mod(lineno, 2.0)*0.5)),\n                            (lineno + (mod(colno, 2.0)*0.5)))\n                          * resstep - sergalSize2;\n        fragColor = paste(sergal(fragCoord,\n                            // Sergal coord on each \"line\" is defined by noise value\n                            sergpos,\n                            // Animation time is defined by noise\n                            mod(iTime * (TIME_DEF + TIME_RND * rand(i)), 1.0) <= 0.5,\n                            fact,\n                            minMap),\n                          fragColor);\n        colno -= 1.0;\n        if (colno < 0.0) {\n            colno = offstep - 1.0;\n            lineno -= 1.0;\n        }\n    }\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25184, "src": "https://soundcloud.com/lynca-and-dolara/merp-sounds", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "#define PI  3.14159265359\n\nfloat circle(vec2 v, vec2 center, float radius) {\n    return distance(v, center) - radius;\n}\n\nfloat line(vec2 v, vec2 A, vec2 B) {\n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\nfloat segment(vec2 v, vec2 A, vec2 B, float far) {\n    vec2 b = B - A;\n    vec2 a = v - A;\n    \n    // Get ptojection coord\n    float frac = dot(a, b) / dot(b, b);\n    if (frac < 0.0 || frac > 1.0)\n        return far;\n    \n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\nfloat round_segment(vec2 v, vec2 A, vec2 B, float far) {\n    vec2 b = B - A;\n    vec2 a = v - A;\n    \n    // Get ptojection coord\n    float frac = dot(a, b) / dot(b, b);\n    if (frac < 0.0)\n        return distance(v, A);\n    if (frac > 1.0)\n        return distance(v, B);\n    \n    vec2 n  = B - A;\n    vec2 va = A - v;\n    vec2 c  = n * dot(va, n) / dot(n, n);\n    return length(va - c);\n}\n\n// Convert distance to smooth white line\nvec4 color(float dist) {\n    return vec4(smoothstep(1.0, 0.0, dist * 100.0));\n}\n\n// Ref: https://www.shadertoy.com/view/wldczf\nfloat cp (vec2 a, vec2 b) { return a.x * b.y - b.x * a.y; }\t\n\n// Ref: https://www.shadertoy.com/view/wldczf\nbool TriangleHit(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n  bool b1 = cp(p-a, b-a) > 0.0;\n  bool b2 = cp(p-b, c-b) > 0.0;\n  bool b3 = cp(p-c, a-c) > 0.0;\n  return b1 == b2 && b2==b3;\n}\n\nbool right(vec2 uv, vec2 a, vec2 b) {\n    return cp(uv-a, b-a) < 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float fact = min(iResolution.x, iResolution.y);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    \n    if (uv.x > 1.0 || uv.y > 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (uv.x < 0.5) {            \n        // Body\n        float md = round_segment(uv,   vec2(0.184210, 0.315789), vec2(0.184210, 0.473684), 100.0);\n        md = min(md, round_segment(uv, vec2(0.184210, 0.315789), vec2(0.131578, 0.315789), 100.0));\n        md = min(md, round_segment(uv, vec2(0.131578, 0.315789), vec2(0.184210, 0.289473), 100.0));\n        md = min(md, round_segment(uv, vec2(0.184210, 0.289473), vec2(0.131578, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.131578, 0.263157), vec2(0.157894, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.026315, 0.210526), vec2(0.157894, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.026315, 0.210526), vec2(0.184210, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.210526, 0.105263), vec2(0.184210, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.052631, 0.131578), vec2(0.099999, 0.173684), 100.0));\n        md = min(md, round_segment(uv, vec2(0.052631, 0.131578), vec2(0.184210, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.210526, 0.105263), vec2(0.184210, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.210526, 0.105263), vec2(0.236842, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.236842, 0.105263), vec2(0.236842, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.236842, 0.105263), vec2(0.263157, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.421052, 0.131578), vec2(0.263157, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.421052, 0.131578), vec2(0.394736, 0.184210), 100.0));\n        md = min(md, round_segment(uv, vec2(0.289473, 0.184210), vec2(0.394736, 0.184210), 100.0));\n        md = min(md, round_segment(uv, vec2(0.421052, 0.236842), vec2(0.394736, 0.184210), 100.0));\n        md = min(md, round_segment(uv, vec2(0.421052, 0.236842), vec2(0.263157, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.421052, 0.236842), vec2(0.315789, 0.289473), 100.0));\n        md = min(md, round_segment(uv, vec2(0.315789, 0.289473) , vec2(0.342105, 0.473684), 100.0));\n\n        // Eyes & nose\n        md = min(md, circle(uv, vec2(0.223684, 0.171052), 0.002770));\n        md = min(md, circle(uv, vec2(0.381578, 0.152631), 0.001558));\n        fragColor = color(md);\n        \n        \n        // Very long body color check\n        // Is there any way to make it more compact?\n        if (right(uv, vec2(0.184210, 0.473684), vec2(0.184210, 0.289473))\n            &&\n            right(uv, vec2(0.184210, 0.289473), vec2(0.315789, 0.289473))\n            &&\n            right(uv, vec2(0.315789, 0.289473), vec2(0.342105, 0.473684))\n            &&\n            right(uv, vec2(0.342105, 0.473684), vec2(0.184210, 0.473684))\n            ||\n\n            right(uv, vec2(0.184210, 0.315789), vec2(0.131578, 0.315789))\n            &&\n            right(uv, vec2(0.131578, 0.315789), vec2(0.184210, 0.289473))\n            &&\n            right(uv, vec2(0.184210, 0.289473), vec2(0.184210, 0.315789))\n            ||\n\n            right(uv, vec2(0.184210, 0.289473), vec2(0.131578, 0.263157))\n            &&\n            right(uv, vec2(0.131578, 0.263157), vec2(0.157894, 0.263157))\n            &&\n            right(uv, vec2(0.157894, 0.263157), vec2(0.184210, 0.289473))\n            ||\n\n            right(uv, vec2(0.157894, 0.263157), vec2(0.026315, 0.210526))\n            &&\n            right(uv, vec2(0.026315, 0.210526), vec2(0.099999, 0.173684))\n            &&\n            right(uv, vec2(0.099999, 0.173684), vec2(0.157894, 0.263157))\n            ||\n\n            right(uv, vec2(0.099999, 0.173684), vec2(0.052631, 0.131578))\n            &&\n            right(uv, vec2(0.052631, 0.131578), vec2(0.184210, 0.131578))\n            &&\n            right(uv, vec2(0.184210, 0.131578), vec2(0.099999, 0.173684))\n            ||\n\n            right(uv, vec2(0.184210, 0.131578), vec2(0.210526, 0.105263))\n            &&\n            right(uv, vec2(0.210526, 0.105263), vec2(0.236842, 0.131578))\n            &&\n            right(uv, vec2(0.236842, 0.131578), vec2(0.184210, 0.131578))\n            ||\n\n            right(uv, vec2(0.236842, 0.131578), vec2(0.236842, 0.105263))\n            &&\n            right(uv, vec2(0.236842, 0.105263), vec2(0.263157, 0.131589))\n            &&\n            right(uv, vec2(0.263157, 0.131578), vec2(0.236842, 0.131578))\n            ||\n\n            right(uv, vec2(0.394736, 0.184210), vec2(0.421052, 0.236842))\n            &&\n            right(uv, vec2(0.421052, 0.236842), vec2(0.315789, 0.289473))\n            &&\n            right(uv, vec2(0.315789, 0.289473), vec2(0.394736, 0.184210))\n            ||\n\n            right(uv, vec2(0.184210, 0.289473), vec2(0.157894, 0.263157))\n            &&\n            right(uv, vec2(0.157894, 0.263157), vec2(0.099999, 0.173684))\n            &&\n            right(uv, vec2(0.099999, 0.173684), vec2(0.184210, 0.131578))\n            &&\n            right(uv, vec2(0.184210, 0.131578), vec2(0.421052, 0.131578))\n            &&\n            right(uv, vec2(0.421052, 0.131578), vec2(0.394736, 0.184210))\n            &&\n            right(uv, vec2(0.394736, 0.184210), vec2(0.315789, 0.289473))\n            &&\n            right(uv, vec2(0.315789, 0.289473), vec2(0.184210, 0.289473)))\n            fragColor.a = 1.0;\n    } else {      \n        // Body\n        float md =   round_segment(uv, vec2(0.684210, 0.473684), vec2(0.684210, 0.315789), 100.0);\n        md = min(md, round_segment(uv, vec2(0.684210, 0.315789), vec2(0.631578, 0.315789), 100.0));\n        md = min(md, round_segment(uv, vec2(0.631578, 0.315789), vec2(0.684210, 0.289473), 100.0));\n        md = min(md, round_segment(uv, vec2(0.684210, 0.289473), vec2(0.631578, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.684210, 0.263157), vec2(0.526315, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.526315, 0.263157), vec2(0.684210, 0.157894), 100.0));\n        md = min(md, round_segment(uv, vec2(0.578947, 0.157894), vec2(0.621052, 0.199999), 100.0));\n        md = min(md, round_segment(uv, vec2(0.578947, 0.157894), vec2(0.684210, 0.157894), 100.0));\n        md = min(md, round_segment(uv, vec2(0.684210, 0.157894), vec2(0.671052, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.671052, 0.131578), vec2(0.697368, 0.144736), 100.0));\n        md = min(md, round_segment(uv, vec2(0.697368, 0.144736), vec2(0.697368, 0.118421), 100.0));\n        md = min(md, round_segment(uv, vec2(0.697368, 0.118421), vec2(0.710526, 0.131578), 100.0));\n        md = min(md, round_segment(uv, vec2(0.710526, 0.131578), vec2(0.815789, 0.039473), 100.0));\n        md = min(md, round_segment(uv, vec2(0.815789, 0.039473), vec2(0.842105, 0.078947), 100.0));\n        md = min(md, round_segment(uv, vec2(0.842105, 0.078947), vec2(0.75    , 0.197368), 100.0));\n        md = min(md, round_segment(uv, vec2(0.75    , 0.197368), vec2(0.855263, 0.328947), 100.0));\n        md = min(md, round_segment(uv, vec2(0.855263, 0.328947), vec2(0.815789, 0.197368), 100.0));\n        md = min(md, round_segment(uv, vec2(0.815789, 0.197368), vec2(0.842105, 0.078947), 100.0));\n        md = min(md, round_segment(uv, vec2(0.855263, 0.328947), vec2(0.842105, 0.342105), 100.0));\n        md = min(md, round_segment(uv, vec2(0.842105, 0.342105), vec2(0.736842, 0.263157), 100.0));\n        md = min(md, round_segment(uv, vec2(0.842105, 0.473684), vec2(0.821052, 0.326315), 100.0));\n        md = min(md, round_segment(uv, vec2(0.813710, 0.277006), vec2(0.802631, 0.210526), 100.0));\n        md = min(md, round_segment(uv, vec2(0.802631, 0.210526), vec2(0.771763, 0.169386), 100.0));\n        \n        // Eyes & nose\n        md = min(md, circle(uv, vec2(0.710526, 0.171052), 0.002770));\n        md = min(md, circle(uv, vec2(0.805263, 0.068421), 0.001558));\n        fragColor = color(md);\n        \n        // Tongue\n        if (TriangleHit(uv,      vec2(0.802631, 0.210526), vec2(0.813710, 0.277006), vec2(0.75, 0.197368)))\n            fragColor += 0.5;\n        else if (TriangleHit(uv, vec2(0.802631, 0.210526), vec2(0.771763, 0.169386), vec2(0.75, 0.197368)))\n            fragColor += 0.5;\n        \n        // Mouth\n        else if (TriangleHit(uv, vec2(0.815789, 0.197368), vec2(0.855263, 0.328947), vec2(0.75    , 0.197368)))\n            fragColor += 0.75;\n        else if (TriangleHit(uv, vec2(0.75    , 0.197368), vec2(0.842105, 0.078947), vec2(0.815789, 0.197368)))\n            fragColor += 0.75;\n            \n        // Very long body color check\n        // Is there any way to make it more compact?\n        if (right(uv, vec2(0.684210, 0.473684), vec2(0.684210, 0.289473))\n            &&                                                         \n            right(uv, vec2(0.684210, 0.289473), vec2(0.821052, 0.326315))\n            &&                                                         \n            right(uv, vec2(0.821052, 0.326315), vec2(0.842105, 0.473684))\n            &&                                                         \n            right(uv, vec2(0.842105, 0.473684), vec2(0.684210, 0.473684))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.684210, 0.315789), vec2(0.631578, 0.315789))\n            &&                                                         \n            right(uv, vec2(0.631578, 0.315789), vec2(0.684210, 0.289473))\n            &&                                                         \n            right(uv, vec2(0.684210, 0.289473), vec2(0.684210, 0.315789))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.631578, 0.263157), vec2(0.526315, 0.263157))\n            &&                                                         \n            right(uv, vec2(0.526315, 0.263157), vec2(0.684210, 0.157894))\n            &&                                                         \n            right(uv, vec2(0.684210, 0.157894), vec2(0.631578, 0.263157))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.621052, 0.199999), vec2(0.578947, 0.157894))\n\t\t\t&&\n\t\t\tright(uv, vec2(0.578947, 0.157894), vec2(0.684210, 0.157894))\n\t\t\t&&\n\t\t\tright(uv, vec2(0.684210, 0.157894), vec2(0.621052, 0.199999))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.684210, 0.157894), vec2(0.671052, 0.131578))\n            &&                                                         \n            right(uv, vec2(0.671052, 0.131578), vec2(0.697368, 0.144736))\n            &&                                                         \n            right(uv, vec2(0.697368, 0.144736), vec2(0.684210, 0.157894))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.697368, 0.144736), vec2(0.697368, 0.118421))\n            &&                                                         \n            right(uv, vec2(0.697368, 0.118421), vec2(0.710526, 0.131578))\n            &&                                                         \n            right(uv, vec2(0.710526, 0.131578), vec2(0.697368, 0.144736))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.855263, 0.328947), vec2(0.842105, 0.342105))\n            &&                                                         \n            right(uv, vec2(0.842105, 0.342105), vec2(0.821052, 0.326315))\n            &&                                                         \n            right(uv, vec2(0.821052, 0.326315), vec2(0.855263, 0.328947))\n            ||                                                         \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n            right(uv, vec2(0.821052, 0.326315), vec2(0.684210, 0.289473))\n            &&                                                         \n            right(uv, vec2(0.684210, 0.289473), vec2(0.815789, 0.197368))\n            &&                                                         \n            right(uv, vec2(0.815789, 0.197368), vec2(0.855263, 0.328947))\n            &&                                                         \n            right(uv, vec2(0.855263, 0.328947), vec2(0.821052, 0.326315))\n            ||\n\n            right(uv, vec2(0.684210, 0.289473), vec2(0.631578, 0.263157))\n            &&\n            right(uv, vec2(0.631578, 0.263157), vec2(0.684210, 0.157894))\n            &&\n            right(uv, vec2(0.684210, 0.157894), vec2(0.815789, 0.039473))\n            &&\n            right(uv, vec2(0.815789, 0.039473), vec2(0.842105, 0.078947))\n            &&\n            right(uv, vec2(0.842105, 0.078947), vec2(0.815789, 0.197368))\n            &&\n            right(uv, vec2(0.815789, 0.197368), vec2(0.684210, 0.289473)))\n            fragColor.a = clamp(fragColor.a + 1.0, 0.0, 1.0);\n    }\n    \n    fragColor.rgb = 1.0 - clamp(fragColor.rgb, 0.0, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyzl.jpg", "access": "api", "license": "mit", "functions": [[393, 467, 487, 487, 525], [527, 527, 600, 600, 1096], [1098, 1114, 1142, 1142, 1182], [1184, 1184, 1239, 1269, 3719]], "test": "untested"}
{"id": "Wldyzs", "name": "demon filter", "author": "mds2", "description": "First attempt at a \"demon from hell\" video filter.  Cobbled together from other shadertoy samles", "tags": ["webcam", "demonic"], "likes": 6, "viewed": 939, "published": 3, "date": "1609732513", "time_retrieved": "2024-07-30T19:47:09.442744", "image_code": "const float EDGE_OR_CORNER_DETECT = 0.1; // 0 for corner, 1 for edge\n\nconst float WINDOW_WIDTH = 4.0; // max 6.0\n\nconst float SHOW_BACKGROUND = 0.25; // 0.0 for no background, 1.0 for all background\n\nconst vec2 webcam_resolution = vec2(320.0, 240.0);\n\nvec3 YUV(in vec2 fragCoord) {\n    const mat3 to_yuvish = mat3(0.299, -0.14713, 0.615,\n                          0.587, -0.28886, -0.51499,\n                          0.114, 0.436, -0.10001);\n    return to_yuvish * texture(iChannel0, fragCoord / iResolution.xy).rgb;\n}\n\nfloat Yval(in vec2 fragCoord) {\n    return YUV(fragCoord).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat2 M = mat2(0.0);\n    \n    vec2 scale = iResolution.xy / min(iResolution.xy, webcam_resolution.xy);\n    \n    vec2 off = vec2(-4.0);\n    for (int i = 0; i < 9; ++i) {\n        off.y = -4.0;\n        off.x += 1.0;\n        for (int j = 0; j < 9; ++j) {\n            off.y += 1.0;\n            \n            float weight = smoothstep(WINDOW_WIDTH, 0.0, length(off));\n    \n\t    \tfloat Ix = 0.5 * (Yval(fragCoord + scale * (off + vec2(1.0, 0.0))) - \n            \t              Yval(fragCoord + scale * (off - vec2(1.0, 0.0))));\n    \t\tfloat Iy = 0.5 * (Yval(fragCoord + scale * (off + vec2(0.0, 1.0))) - \n            \t              Yval(fragCoord + scale * (off - vec2(0.0, 1.0))));\n        \n         \tM += weight * mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n        }\n    }\n\n//    mat2 M = mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n    \n    float A = 1.0;\n    float B = -M[0][0] - M[1][1];\n    float C = M[0][0] * M[1][1] - M[0][1] * M[1][0];\n\n    float l1 = (-B + sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    float l2 = (-B - sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    \n    float min_eig = min(abs(l1), abs(l2));\n    float max_eig = max(abs(l1), abs(l2));\n//\tfloat min_eig = min(l1, l2);\n    \n    float eig_to_use = mix(min_eig, max_eig, EDGE_OR_CORNER_DETECT);\n\n    // Time varying pixel color\n    vec3 col = smoothstep(vec3(0.0), 0.5 * vec3(0.1, 0.2, 0.3), vec3(eig_to_use));\n    vec3 raw_color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    const float speed = 10.0;\n    \n    float time = speed * iTime;\n    \n    uv = (2.0 * fragCoord -iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec2 flame_col = noise2(uv + noise2(1.5 * uv + noise2(2.0 * uv, -0.2 * time), -0.13 * time), -0.1 * time) - 0.75;\n\n    flame_col.g = min(0.5 * flame_col.g, flame_col.r);\n    flame_col *= smoothstep(-0.25, -0.5, uv.y - 0.2 + flame_col.r - 1.0 * min(1.0, uv.x * uv.x));\n\n    // Output to screen\n    fragColor = vec4(\n                     mix(mix(raw_color, col, 1.0 - SHOW_BACKGROUND),\n                     vec3(flame_col, 0.0),\n                     flame_col.r),\n                1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// All hash functions copied from https://www.shadertoy.com/view/Xt3cDn\n// Thanks, nimitz!\n\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n//--------------------------------------------------\n\nfloat old_hash12(vec2 x)\n{\n    uint n = baseHash(floatBitsToUint(x));\n    \n    return float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nfloat hash12(vec2 x)\n{\n    return mod(13.3 + 201.1 * sin(302.2 * x.x + 123.7 * x.y + 11.1), 1.0);\n}\n\n\nfloat noise_term(in vec2 x, in float scale_val) {\n    vec2 s = vec2(scale_val);\n    vec2 x00 = x - mod(x, s);\n    vec2 x01 = x + vec2(0.0, scale_val);\n    x01 = x01 - mod(x01, s);\n    vec2 x10 = x + vec2(scale_val, 0.0);\n    x10 = x10 - mod(x10, s);\n    vec2 x11 = x + s;\n    x11 = x11 - mod(x11, s);\n    \n    float v00 = hash12(x00);\n    float v01 = hash12(x01);\n    float v10 = hash12(x10);\n    float v11 = hash12(x11);\n    \n    vec2 uv = mod(x, s) / s;\n    \n    float yweight = smoothstep(0.0, 1.0, uv.y);\n    float v1 = mix(v10, v11, yweight);\n    float v0 = mix(v00, v01, yweight);\n    \n    float xweight = smoothstep(0.0, 1.0, uv.x);\n    \n    return mix(v0, v1, xweight);\n}\n\nfloat noise(in vec2 x, in float base_scale, in float space_decay, in float height_decay,\n           in float shift_by) {\n\tfloat h = 1.0;\n    float s = base_scale;\n\n    float summation = 0.0;\n    \n    for (int i = 0; i < 4; ++i) {\n    \tsummation = summation + h * noise_term(x + vec2(0.0, s * shift_by), s);\n        s *= space_decay;\n        h *= height_decay;\n    }\n    return summation;\n}\n\nfloat simple_noise(in vec2 uv, in float shift_by) {\n  return noise(uv * 10.0, 5.0, 0.75, 0.75, shift_by);\n}\n\nvec2 noise2(in vec2 uv, in float shift_by) {\n    return vec2(simple_noise(uv, shift_by),\n                simple_noise(uv + vec2(0.0, 101.0), shift_by));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wldyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 281, 281, 518], [520, 520, 551, 551, 582], [584, 584, 641, 691, 2842]], "test": "untested"}
{"id": "WttyRs", "name": "Gantz Galaga 007", "author": "MacroMachines", "description": "experimental SDF\nmouse rotates form", "tags": ["2d", "sdf", "experimental", "white"], "likes": 2, "viewed": 241, "published": 3, "date": "1609723363", "time_retrieved": "2024-07-30T19:47:10.502909", "image_code": "//__________________________________________________\n/////////////////////////      SDF RAY MARCHING 1.2  \n////////////////////////////////////////////////////\n//varying lowp vec4 colorVarying;\n//varying vec2 tc;\n//varying vec4 glPos;\n//uniform float time;\n//uniform vec2 Rotate;\n//uniform vec3 Warp;\n//uniform float size;\n//uniform vec2 touchCoordinates[10];\n//touchCoordinates[0];\n//#define tc gl_FragCoord\n//#define res iResolution\n//vec2( 1366., 1024. );\n//#define uvscale res.x/res.y\n//#define uv vec2(((tc.x * 2.0 - 1.0)*res.x/res.y),tc.y * 2.0 - 1.0);\n\n\nprecision highp float;\nfloat size = 1.0;\n#define time iTime*0.33\n#define touch iMouse.xy\n#define ti time * 0.1\n\n#define BPM 128.0\n#define SEC_PER_MIN 60.0\n#define STEPS 64\n#define EPS 0.01\n#define FAR 10.0\n#define v3 vec3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstruct RAY{\n   vec3 origin, direction;\n};\nstruct HIT{\n   bool intersect;\n   vec3 point, color, normal;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {   return (x<0.)?-1.:1.;}\nvec2 sgn(vec2 v) {   return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);}\nfloat square (float x) {   return x*x;}\nvec2 square (vec2 x) {   return x*x;}\nvec3 square (vec3 x) {   return x*x;}\nfloat lengthSqr(vec3 x) {   return dot(x, x);}\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {   return max(v.x, v.y);}\nfloat vmax(vec3 v) {   return max(max(v.x, v.y), v.z);}\nfloat vmax(vec4 v) {   return max(max(v.x, v.y), max(v.z, v.w));}\nfloat vmin(vec2 v) {   return min(v.x, v.y);}\nfloat vmin(vec3 v) {   return min(min(v.x, v.y), v.z);}\nfloat vmin(vec4 v) {   return min(min(v.x, v.y), min(v.z, v.w));}\n\n\n//......................................... transform \n/////////////////////////////////////////////////////\nmat2 rotate( float a ) {\n   float cs = cos(a);\n   float si = sin(a);\n   return mat2(cs, -si, si, cs);\n}\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n   return length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n   return dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n   return vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n   return vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n   vec2 d = abs(p) - b;\n   return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n   return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n   p = abs(p);\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   if (p.x < max(p.y, p.z)) p = p.yzx;\n   float b = max(max(max(\n      dot(p, normalize(vec3(1., 1., 1.))),\n      dot(p.xz, normalize(vec2(PHI+1., 1.)))),\n      dot(p.yx, normalize(vec2(1., PHI)))),\n      dot(p.xz, normalize(vec2(1., PHI))));\n   float l = length(p);\n   return l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n   float d = length(p.xz) - r;\n   d = max(d, abs(p.y) - height);\n   return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n   return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n   vec3 ab = b - a;\n   float t = saturate(dot(p - a, ab) / dot(ab, ab));\n   return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n   return fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n   return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n   float l = length(p.xz) - r;\n   return l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n   vec3 q = abs(p);\n   return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n   //this is mathematically equivalent to this line, but less efficient:\n   //return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n   return fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n   vec2 q = vec2(length(p.xz), p.y);\n   vec2 tip = q - vec2(0, height);\n   vec2 mantleDir = normalize(vec2(height, radius));\n   float mantle = dot(tip, mantleDir);\n   float d = max(mantle, -q.y);\n   float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n   \n   // distance to tip\n   if ((q.y > height) && (projected < 0.)) {\n      d = max(d, length(tip));\n   }\n   \n   // distance to base ring\n   if ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n      d = max(d, length(q - vec2(radius, 0.)));\n   }\n   return d;\n}\n\n//......................................... 3d forms \n////////////////////////////////////////////////////\nfloat sphere (vec3 p, float s){\n   return length(p) - s;\n}\nfloat box(vec3 p, vec3 b){\n   return length(max(abs(p)-b, 0.0));\n}\nfloat rbox(vec3 p, vec3 b, float r){\n   return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//........................................... deform \n////////////////////////////////////////////////////\nfloat displace(vec3 p){\n   float d1 = rbox(p, v3(0.25), 0.20);\n   //float d2 = sphere(p, 0.5);\n   float sz = 8.0;\n   float d2 = sin(sz*p.x)*sin(sz*p.y)*sin(sz*p.z);\n   return d1+d2;\n}\n//............................................ domain \n/////////////////////////////////////////////////////\nfloat rep( vec3 p, vec3 c){\n   vec3 q = mod(p, c) -0.5*c;\n   q.xy *= rotate(time);\n   vec3 c2 = c*3.0*cos(time*0.33);\n   vec3 q2 = mod(p, c2) -0.5*c2;\n   vec3 q3 = mod(p, c*0.25) - 0.125*c;\n   //return displace(p);//\n   float rp = min(box(q2, vec3(cos(time+q3.z)*2.0, cos(p.z+time*0.5)*0.5, 1.0)),\n         rbox(q, fract(p.y+time*.1)*v3(size*0.125,0.05,0.1), 0.05));\n   rp = min(rp, sphere(q3, sin(p.x+time)*0.05));\n   return rp;\n}\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n   p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n   p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p + halfsize,size) - halfsize;\n   p *= mod(c, 2.0)*2. - 1.;\n   return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   if (p >= 0.)\n      p = mod(p + halfsize, size) - halfsize;\n   return c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n   float halfsize = size*0.5;\n   float c = floor((p + halfsize)/size);\n   p = mod(p+halfsize, size) - halfsize;\n   if (c > stop) { //yes, this might not be the best thing numerically.\n      p += size*(c - stop);\n      c = stop;\n   }\n   if (c <start) {\n      p += size*(c - start);\n      c = start;\n   }\n   return c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n   float angle = 2.*PI/repetitions;\n   float a = atan(p.y, p.x) + angle/2.;\n   float r = length(p);\n   float c = floor(a/angle);\n   a = mod(a,angle) - angle/2.;\n   p = vec2(cos(a), sin(a))*r;\n   // For an odd number of repetitions, fix cell index of the cell in -x direction\n   // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n   if (abs(c) >= (repetitions/2.)) c = abs(c);\n   return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5,size) - size*0.5;\n   return c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n   vec2 halfsize = size*0.5;\n   vec2 c = floor((p + halfsize)/size);\n   p = mod(p + halfsize, size) - halfsize;\n   p *= mod(c,vec2(2.))*2. - vec2(1.);\n   return c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n   vec2 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   p *= mod(c,vec2(2))*2. - vec2(1.);\n   p -= size/2.;\n   if (p.x > p.y) p.xy = p.yx;\n   return floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n   vec3 c = floor((p + size*0.5)/size);\n   p = mod(p + size*0.5, size) - size*0.5;\n   return c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n   float s = sgn(p);\n   p = abs(p)-dist;\n   return s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n   vec2 s = sgn(p);\n   pMirror(p.x, dist.x);\n   pMirror(p.y, dist.y);\n   if (p.y > p.x)\n      p.xy = p.yx;\n   return s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n   float t = dot(p, planeNormal)+offset;\n   if (t < 0.) {\n      p = p - (2.*t)*planeNormal;\n   }\n   return sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n   return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n   return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n   return fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r - a,r - b), vec2(0.));\n   return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n   vec2 u = max(vec2(r + a,r + b), vec2(0.));\n   return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n   return fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n      pR45(p);\n      p.x -= sqrt(2.)/2.*r;\n      p.x += columnradius*sqrt(2.);\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      // At this point, we have turned 45 degrees and moved at a point on the\n      // diagonal that we want to place the columns on.\n      // Now, repeat the domain along this direction and place a circle.\n      pMod1(p.y, columnradius*2.);\n      float result = length(p) - columnradius;\n      result = min(result, p.x);\n      result = min(result, a);\n      return min(result, b);\n   } else {\n      return min(a, b);\n   }\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n   a = -a;\n   float m = min(a, b);\n   //avoid the expensive computation where not needed (produces discontinuity though)\n   if ((a < r) && (b < r)) {\n      vec2 p = vec2(a, b);\n      float columnradius = r*sqrt(2.)/n/2.0;\n      columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n      pR45(p);\n      p.y += columnradius;\n      p.x -= sqrt(2.)/2.*r;\n      p.x += -columnradius*sqrt(2.)/2.;\n\n      if (mod(n,2.) == 1.) {\n         p.y += columnradius;\n      }\n      pMod1(p.y,columnradius*2.);\n\n      float result = -length(p) + columnradius;\n      result = max(result, p.x);\n      result = min(result, a);\n      return -min(result, b);\n   } else {\n      return -m;\n   }\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n   return fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n   float s = r/n;\n   float u = b-r;\n   return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n   return -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n   float e = max(r - abs(a - b), 0.);\n   return min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n   return length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n   return max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n   return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n   return min(a, max(a - ra, abs(b) - rb));\n}\n\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n//............................................. piston \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat piston(vec3 p) {\n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   pModPolar(p2.yz, 3.0);\n   sc = fCylinder(p2, 0.25, 0.25);\n   sc2 = fCylinder(p2+v3(sin(time)*0.25, 0.0, 0.0), 0.125, 0.5);\n   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.5);\n   sc5 = fOpDifferenceColumns( sc3, sc4, 0.05, 4.0);\n   sc5 = fOpGroove(sc5, sc2, 0.1, 0.1);\n   return sc5;\n}\n\n\n//.............................................nut \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat nut(vec3 p) {\n   \n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   pModPolar(p2.yz, 6.0);\n   sc = fBox(p2, v3(0.25));\n   sc2 = fBox(p2-v3(0.125, 0.0, 0.0), v3(0.125, 0.5, 0.250));\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.5);\n   sc5 = fOpDifferenceColumns( sc3, sc4, 0.05, 4.0);\n   sc5 = fOpGroove(sc5, sc2, 0.1, 0.1);\n   return sc5;\n}\n\n//............................................. scene \n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nfloat scene(vec3 p) {\n   //pR45(p.xz);\n   pR(p.xz, touch.x*0.01); //time);\n   pR(p.yz, touch.y*0.01);\n   float sc, sc2, sc3, sc4, sc5;\n   vec3 p2 = p, p3 = p;\n   //p2.y+=cos(time);\n   \n   float decayExp = fract(time*4.0)*fract(time);\n   decayExp = pow(decayExp,3.0);\n   float decayExp2 = fract(time*1.125);\n   decayExp = pow(decayExp,2.0);\n   \n   pMirrorOctant(p2.yz, vec2(decayExp*0.250,-decayExp2*0.25));\n   pModPolar(p2.yz, 6.0);\n   p2 += v3(0.0, cos(time)*0.25, 0.0);\n   sc = piston(p2);\n   sc2 = nut(p);\n   //sc /= fCylinder(p2, 0.25, 0.5);\n   //sc2 = fCylinder(p2+v3(0.25, 0.0, 0.0), 0.125, 0.5);\n   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);\n   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);\n   pR(p3.xy, 1.5);\n   sc4 = fCylinder(p3, 0.25, 0.05);\n   sc5 = fOpEngrave( sc3, sc4, 0.25);\n   p*= 2.0;\n   vec3 p4 = pMod3(p,v3(1.0,2.0,0.50));\n   float sco = fOpPipe(sc3, fBox(p,abs(fract(p2))), 0.01);//0.1);\n   sco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\nsco = min(sco, sco*1.25);\n\n\nreturn sco;\n}\n\n//............................................. render \n//////////////////////////////////////////////////////\nfloat map(vec3 p) {\n   return scene(p);\n}\nvec3 grad(vec3 p) {\n   vec2 q = vec2 (0.0, EPS);\n   return vec3(map(p + q.yxx) - map(p - q.yxx),\n               map(p + q.xyx) - map(p - q.xyx),\n               map(p + q.xxy) - map(p - q.xxy));\n}\nvec3 shade(vec3 origin, vec3 ray, float traced) {\n   return normalize(grad(origin+traced*ray));\n}\n\nfloat trace(vec3 origin, vec3 ray, \n      inout vec3 normal, inout float shadow){ \n\n   float intersect = 0.1;\n   //if( distance(origin, ray) < ){//scene(origin+ray) > 0.5 ){\n   for(int i = 0; i < STEPS; i++){\n\n      vec3 pos = origin + ray * intersect;\n      if (fSphere(pos-v3(0.0,0.0,1.01),1.5)>0.0){return 0.0;}\n\n      float dist = scene(pos);\n      if(dist < 0.01){\n         normal = shade(origin, ray, intersect);\n         return intersect;\n         return float(i) / float(STEPS);\n         //return intersect;\n      }\n      //if(dot(pos, v3(0.10))>0.1) {return 0.0;}\n      intersect += dist * 0.50;\n   }\n\n   normal = vec3(0.0);\n   return 0.0;\n}\n/*\nfloat trace(vec3 position, vec3 direction){\n    float traced = 0.0;\n    for(int i = 0; i < STEPS; i++){\n        float distance = scene(position);\n        if(distance<EPS) {return  float(i) / float(STEPS);}\n        position += distance * direction;\n    }\n    return traced;\n}\n*/\n\n#define gl_FragColor fragColor\n//............................................. main \n////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 color = vec3(0.094,0.027,0.192);//, 1.0);\n   \n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.xy;\n   uv = uv*2.0-1.0;\n   \n   vec3 o;// = vec3(0.,0.,-2.);\n   o = vec3(0.0, 0.0, 1.0);\n   \n   vec3 r = (vec3(uv, -1.0));\n\n   //move camera\n   //r.xz *= rotate(Rotate.x*ti);//ti);\n   //o.z  += ti*4.0;\n   //o.xy += sin(time*.05267)*8.0-4.0;\n   //o.xy += touch.xy*8.0-4.0;\n   //r += sin(vec3(0.2*time)*Warp);\n\n   //o.xy +=  10.0*(touchCoordinates[0]);\n   \n   vec3 normal = vec3(0.0);\n   float shadow;\n   float t = trace(o, r, normal, shadow);\n\n   float fog = 1.0 / (1.0 + t*t* 0.1);\n   vec3 fc = vec3(fog);\n   \n   vec3 lightPos = vec3(-3.15008,-0.02,-1.051);\n   \n   pR(lightPos.xz, tan(fract(time)*8.0));\n\n   float light = dot( lightPos, normal);\n   float spec = fract(pow(light,0.080));\n   \n\n   //fractal(gl_FragColor, tc*vec2(1.0,res.x/res.y));\n   gl_FragColor.rgb = vec3(t>0.0?1.0:0.0);//light+t); \n   gl_FragColor.a = 1.0;\n\n   gl_FragColor = vec4( \n               vec3(fc + fc * (color-fog)) * \n                   0.5*light + \n                   0.5*(1.0-fog) + \n                   0.04*spec, \n                   1.0) \n                   + vec4(1.50-fog);\n   //gl_FragColor = glPos;\n   //gl_FragColor += vec4(vec3(dot(abs(color),vec3(0.5))),1.0);\n   \n\n\n    // Output to screen\n   // fragColor = vec4(col,1.0);\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n//////////////////////////////////////////////////////\n\n\n\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1215, 1254, 1274, 1274, 1299], [1300, 1300, 1318, 1318, 1368], [1369, 1369, 1393, 1393, 1408], [1409, 1409, 1431, 1431, 1446], [1447, 1447, 1469, 1469, 1484], [1485, 1485, 1510, 1510, 1531], [1532, 1572, 1592, 1592, 1617], [1618, 1618, 1638, 1638, 1673], [1674, 1674, 1694, 1694, 1739], [1740, 1740, 1760, 1760, 1785], [1786, 1786, 1806, 1806, 1841], [1842, 1842, 1862, 1862, 1907], [1910, 2019, 2043, 2043, 2122], [2677, 2677, 2709, 2709, 2736], [2738, 2812, 2868, 2868, 2912], [2914, 2965, 2998, 3010, 3040], [3042, 3078, 3106, 3106, 3191], [3193, 3250, 3284, 3284, 3312], [3314, 3314, 3343, 3343, 3428], [3431, 3451, 3475, 3475, 3536], [3538, 3642, 3663, 3663, 4070], [4072, 4117, 4165, 4165, 4245], [4247, 4300, 4342, 4342, 4438], [4440, 4524, 4568, 4568, 4677], [4679, 4751, 4800, 4800, 4839], [4841, 4866, 4926, 4926, 4999], [5001, 5100, 5132, 5132, 5197], [5199, 5332, 5362, 5362, 5447], [5449, 5490, 5534, 5534, 5782], [5784, 5821, 5861, 5861, 5927], [5929, 6025, 6074, 6074, 6612], [6614, 6721, 6752, 6752, 6779], [6780, 6780, 6806, 6806, 6846], [6847, 6847, 6883, 6883, 6924], [6927, 7034, 7057, 7057, 7217], [7218, 7327, 7354, 7354, 7758], [8742, 8980, 9012, 9012, 9056], [9058, 9094, 9119, 9119, 9161], [9163, 9307, 9347, 9347, 9476], [9478, 9548, 9594, 9594, 9751], [9753, 9854, 9900, 9900, 10048], [10050, 10147, 10220, 10220, 10538], [10541, 10654, 10704, 10704, 11114], [11116, 11144, 11181, 11181, 11278], [11280, 11342, 11385, 11385, 11551], [11553, 11615, 11656, 11656, 11850], [11852, 11882, 11919, 11919, 12017], [12019, 12111, 12154, 12154, 12210], [12212, 12335, 12381, 12381, 12503], [12505, 12533, 12595, 12595, 12712], [15273, 15371, 15421, 15421, 15472], [15474, 15708, 15765, 15765, 15816], [15818, 15873, 15929, 15929, 15975], [15977, 16056, 16104, 16104, 16194], [16196, 16196, 16251, 16251, 16342], [16344, 16344, 16398, 16398, 16442], [16445, 16519, 16578, 16578, 17265], [17267, 17267, 17331, 17331, 17999], [18001, 18001, 18067, 18067, 18112], [18114, 18210, 18268, 18268, 18384], [18386, 18440, 18505, 18505, 18548], [18550, 18550, 18613, 18613, 18655], [18658, 18846, 18893, 18893, 18967], [18970, 19103, 19145, 19145, 19181], [19183, 19255, 19300, 19300, 19348], [19350, 19403, 19458, 19458, 19504], [19506, 19560, 19615, 19615, 19661], [21296, 21460, 21482, 21482, 21919], [21922, 22082, 22101, 22101, 22488], [22490, 22653, 22674, 22691, 23679], [23681, 23792, 23811, 23811, 23833], [23834, 23834, 23853, 23853, 24029], [24030, 24030, 24079, 24079, 24127], [24129, 24129, 24210, 24210, 24779], [25093, 25200, 25257, 25257, 27143]], "test": "untested"}
{"id": "3ttyRs", "name": "Screenspace Normal Calculation", "author": "oneshade", "description": "asdf asdf", "tags": ["normals", "heightmap", "screenspace"], "likes": 0, "viewed": 528, "published": 3, "date": "1609723220", "time_retrieved": "2024-07-30T19:47:11.370589", "image_code": "vec2 fetch(in vec2 p) {\n    return texture(iChannel0, p / iResolution.xy).rg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 r = fetch(fragCoord + vec2(1.0, 0.0));\n    vec2 t = fetch(fragCoord + vec2(0.0, 1.0));\n    vec2 o = fetch(fragCoord);\n\n    vec3 n = normalize(vec3(o.r - r.r, o.r - t.r, 1.0));\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (o.g > 0.5) {\n        fragColor.rgb += max(0.0, dot(n, vec3(-0.58, 0.58, 0.58)));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float mapScene(in vec3 p) {\n    float r = iTime * 0.5;\n    float c = cos(r), s = sin(r);\n    p.xz *= mat2(c, s, -s, c);\n    p.yz *= mat2(c, s, -s, c);\n    return max(abs(p.x) - 2.0, max(abs(p.y) - 1.0, abs(p.z) - 3.0));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 1000000.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float i=0.0; i < 150.0; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            fragColor.r = p.z;\n            fragColor.g = 1.0;\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 79], [81, 81, 136, 136, 461]], "test": "untested"}
{"id": "3ldczl", "name": "z Snowflake generator", "author": "illus0r", "description": "z Snowflake generator\nFor the snowflake chrome plugin by Mikhail Kalygin and Natalia Stepanova\nhttps://codepen.io/illus0r/pen/mdrxzVx", "tags": ["sdf"], "likes": 3, "viewed": 284, "published": 3, "date": "1609723079", "time_retrieved": "2024-07-30T19:47:12.356952", "image_code": "float rnd(float x) {return 2.*fract(54321.987 * sin(987.12345 * x))-1.;}\nvec2 p2d(vec2 polar) {\n    float alpha = polar.x;\n    float R = polar.y;\n    float x = sin(alpha) * R;\n    float y = cos(alpha) * R;\n    return vec2(x, y);\n}\nvec2 d2p(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\nvec2 snowflakeSymmetry(vec2 p, float rays){\n\tvec2 ar = d2p(p);\n\tfloat astep = 2. * 3.1415 / rays;\n\tfloat a = ar.x, r = ar.y;\n\ta = mod(a, astep);\n\ta -= astep / 2.;\n\ta = abs(a);\n\tp = p2d(vec2(a, r));\t\n\treturn p;\n}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nfloat snowflake(vec2 uv, float id) {\n    uv /= 1.6;\n    for (float i = 0.; i < 3.; i++) {\n        uv *= 2.;\n        uv = snowflakeSymmetry(uv, 6.);\n        if (i == 0. && uv.y > 1.) return 0.;\n        uv *= rot(-rnd(id+i)*.3);\n        uv -= vec2(0.,.4+.1*rnd(id+i));\n    }\n    return step(.9,1.-uv.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    float col = snowflake(uv, floor(iTime*4.));\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 72], [73, 73, 95, 95, 230], [231, 231, 254, 254, 357], [358, 358, 401, 401, 569], [570, 570, 588, 588, 635], [636, 636, 672, 672, 939], [940, 940, 997, 997, 1133]], "test": "untested"}
{"id": "3lc3D2", "name": "[]Haru No Umi", "author": "Catzpaw", "description": "\"The Sea in Spring\"\n composed in 1929 by Michio Miyagi", "tags": ["raymarching", "music"], "likes": 34, "viewed": 676, "published": 3, "date": "1609720573", "time_retrieved": "2024-07-30T19:47:13.433075", "image_code": "//---Haru No Umi\n// by Catzpaw 2021\n\n\n#define ZERO min(0,iFrame)\n\n#define ITER 300\n#define NEAR 0.1\n#define FAR 50.0\n#define EPS 5e-5\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\n//SDF\nfloat sdBox(vec3 p,vec3 b){p=abs(p)-b;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}\nfloat sdOH(vec3 p,float s){p=abs(p);return (p.x+p.y*2.+p.z-s)*.577;}\nfloat sdCC(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(r,h);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdWedge(vec3 p,vec3 b,vec2 h){p.xz=abs(p.xz);p.y+=p.x*h.x+p.z*h.y;p=abs(p)-b;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}\n\n//ROOF BENDING\nvec3 bend(vec3 p){\n    float v=p.x*0.1;\n    p.y-=5.5;\n    p.y-=(1.+p.y*.4)*v*v*v*v;\n    p.x*=1.0-0.013*p.y*p.y;\n    return p;\n}\n\n//SCENE\nfloat map(vec3 p,out int id){\n    id=2;\n    p=abs(p);\n    float d=length(p-vec3(0,6,0));\n    vec3 q;\n    if(d>10.0)return d*.5;\n    d=FAR;\n\n    //main pillar\n    q=p;\n    d=min(d,sdCC   (q-vec3(2.8,6.93,0.0),0.2,0.5));\n    q.xy*=rot(.03);\n    d=min(d,sdCC   (q-vec3(3.0,0.0,0.0),6.8,0.5-p.y*.02));\n    d=min(d,sdBox  (q-vec3(3.0,0.5,0.0),vec3(.1,.25,2.6)));\n    d=min(d,sdWedge(q-vec3(3.0,0.6,0.0),vec3(.05,.1,.7),vec2(0.0,-0.3)));\n    d=min(d,sdBox  (q-vec3(3.0,2.3,0.0),vec3(.1,.25,2.6)));\n    d=min(d,sdWedge(q-vec3(3.0,2.4,0.0),vec3(.05,.1,.7),vec2(0.0,-0.3)));\n    d=min(d,sdWedge(q-vec3(3.0,5.9,0.0),vec3(.7,.1,.05),vec2(-0.3,0.0)));\n\n    //side pillar\n    q=p;q.xy*=rot(.03);\n    d=min(d,sdCC   (q-vec3(3.0,0.00,2.0),3.0,0.3-p.y*.02));\n    d=min(d,sdWedge(q-vec3(3.0,0.65,2.0),vec3(.05,.1,.5),vec2(0.0,-0.3)));\n    d=min(d,sdWedge(q-vec3(3.0,2.45,2.0),vec3(.05,.1,.5),vec2(0.0,-0.3)));\n    d=min(d,sdBox  (q-vec3(3.0,3.05,2.0),vec3(.3,.1,.3)));\n\n    //side pillar top\n    vec3 r=p-vec3(2.9,3.3,2.0);\n    d=min(d,sdBox(r+vec3(0,0.05,0),vec3(.4,.05,.4)));\n    r.xz*=rot(0.78);r.xz*=.4;\n    float d2=FAR;//hiwada material\n    d2=min(d2,sdOH(r,.3));\n\n    //main beam\n    q=p;\n    d=min(d,sdBox  (q-vec3(0.0,6.7,0.0),vec3(.4,1.,.2)));\n\n    q=bend(p);\n    d=min(d,sdBox  (q-vec3(0.0,0.0,0.0),vec3(5.0,0.4,0.2)));\n    d=min(d,sdWedge(q-vec3(0.0,0.5,0.0),vec3(5.1,0.1,0.3),vec2(0.0,0.3)));\n    d=min(d,sdBox  (q-vec3(0.0,0.35,0.0),vec3(5.1,0.1,0.3)));\n    d=min(d,sdBox  (q-vec3(0.0,2.0,0.0),vec3(5.0,0.4,0.3)));\n    d=min(d,sdWedge(q-vec3(0.0,2.6,0.0),vec3(5.5,0.3,0.4),vec2(0.0,0.3)));\n    d=min(d,sdBox  (q-vec3(0.0,2.4,0.0),vec3(5.5,0.3,0.4)));\n\n    //ridge\n    float d3=FAR;//bronze material\n    d3=min(d3,sdWedge(q-vec3(0.0,3.2,0.0),vec3(5.7,0.1,0.15),vec2(0.0,0.3)));\n    d3=min(d3,sdWedge(q-vec3(0.0,3.4,0.0),vec3(5.9,0.1,0.15),vec2(0.0,0.3)));\n\n    //roof\n    q.yz*=rot(.52);\n    d=min(d,max(sdBox(q-vec3(0.0,2.6,-.9),vec3(5.6,.1,.7)),\n               -sdBox(q-vec3(3.9,2.6,0.9),vec3(3,.5,1.5))));\n    d2=min(d2,max(sdBox(q-vec3(0,2.7,-.9),vec3(5.7,.1,.8)),\n                 -sdBox(q-vec3(4.,2.7,1),vec3(3,.5,1.5))));\n\n    if(abs(d)<min(abs(d2),abs(d3))){\n        id=2;\n        return d;\n    }\n    if(abs(d2)<abs(d3)){\n        id=3;\n        return d2;\n    }\n    id=4;\n    return d3;\n}\n\n//WAVE\nvec3 wave(vec3 p){\n    float t=iTime*5.;\n    float x=sin(t    +p.x*5.3+p.z*4.5)\n           +sin(t*2.0+p.x*5.1+p.z*2.6)\n           +sin(t*1.1+p.x*3.1+p.z*2.4);\n    float z=sin(t    +p.x*3.5+p.z*7.1)\n           +sin(t*2.0+p.x*3.1+p.z*5.4)\n           +sin(t*1.1+p.x*2.6+p.z*2.3);\n    return normalize(vec3(x,10.+length(p)*2.,z));\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    int z;\n    return normalize(e.xxx*map(p+e.xxx*EPS,z)+e.xyy*map(p+e.xyy*EPS,z)+\n                     e.yxy*map(p+e.yxy*EPS,z)+e.yyx*map(p+e.yyx*EPS,z));\n}\n\n//RAYMARCHING\nfloat trace1(vec3 ro,vec3 rd,out vec3 p,out int id){\n    id=1;\n    float t=NEAR;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        if(p.y<0.){//water surface\n            t=-ro.y/rd.y;\n            p=ro+rd*t;\n            id=1;\n            break;\n        }\n        float d=map(p,id);\n        if(abs(d)<EPS){//object surface\n            break;\n        }\n        if(t>FAR){\n            t=-ro.y/rd.y;\n            p=ro+rd*t;\n            id=1;\n            break;//horizon\n        }\n        t+=step(d,1.)*d*.4+d*.4;\n    }\n    return t;\n}\nfloat trace2(vec3 ro,vec3 rd,out vec3 p,out int id){\n    id=0;\n    float t=NEAR;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        float d=map(p,id);\n        if(abs(d)<EPS){//object surface\n            break;\n        }\n        if(t>FAR){//sky\n            id=0;\n            break;\n        }\n        t+=step(d,1.)*d*.4+d*.4;\n    }\n    return t;\n}\n\n//SKY\nconst vec3 sunDir=normalize(vec3(.6,.1,.5));\nconst vec3 sunCol=vec3(.9,.8,.7);\nvec3 sky(vec3 rd){\n\tfloat sun=max(0.,dot(rd,sunDir));\n\tvec3 s=mix(vec3(.17,.16,.18),vec3(.35,.25,.15),pow(1.-max(rd.y,0.),6.));\n\ts*=smoothstep(-.3,.0,rd.y);\n\ts+=sunCol*sun*sun*.3;\n\ts+=sunCol*pow(sun,500.)*1.5;\n\treturn clamp(s,0.,1.);\n}\n\n//WATER\nvec3 bottom(vec3 rd){\n    float v=abs(dot(normalize(rd),vec3(0,1,0)));\n    vec3 c=mix(vec3(0),vec3(.3,.3,.2)*sunCol,v);\n    return c;\n}\n\nvec3[5] cp0=vec3[](vec3(4,3,-20),vec3(0,18,-10),vec3(0,3,-40),vec3(0,1,-10),vec3(0,3,-10));\nvec3[5] cp1=vec3[](vec3(0,2,-10),vec3(0,3,-10),vec3(0,.5,3),vec3(0,15,-15),vec3(0,1,-25));\nfloat[5] cr0=float[](0.,-.5,0.,-3.,-3.14);\nfloat[5] cr1=float[](.6,-4.,0.,-6.,-3.14);\nfloat[5] ct0=float[](0.,-1.,-.05,0.,.1);\nfloat[5] ct1=float[](.2,.1,.5,-.3,-.05);\nfloat[5] cv0=float[](1.,.6,2.,.6,1.);\nfloat[5] cv1=float[](.6,.6,1.,.6,1.);\n\nvec3[3] matCol=vec3[](vec3(.90,.15,.15),vec3(.20,.15,.10),vec3(.30,.45,.40));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m=iMouse.xy/iResolution.xy;\n    //SETUP\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),ro,rd;\n\n    //CAMERA\n    const float cl=11.;\n    float ct=mod(iTime,cl)/cl;\n    int cc=int(mod(floor(iTime/cl),5.));\n\n    ro=mix(cp0[cc],cp1[cc],ct);\n    ro.xz*=rot(mix(cr0[cc],cr1[cc],ct));\n    rd=normalize(vec3(uv,mix(cv0[cc],cv1[cc],ct)));\n    rd.yz*=rot(mix(ct0[cc],ct1[cc],ct));\n    rd.xz*=rot(mix(cr0[cc],cr1[cc],ct));\n    \n   //GET SURFACE AND MATERIAL ID\n    int  id;\n    float t=NEAR;\n    if(rd.y<0.){\n        t=trace1(ro,rd,p,id);\n        if(id==1){\n            vec3 w=wave(p);\n            vec3 rr=refract(rd,w,1.343);\n            if(rr.y==0.){\n                rd=reflect(rd,w);\n                ro=p;\n                t=trace2(ro,rd,p,id);\n            }else{\n                rd=rr;\n            }\n        }\n    }else{\n        t=trace2(ro,rd,p,id);\n    }\n\n    //SHADING\n    if(id==0)c=sky(rd);\n    if(id==1)c=mix(sky(rd),bottom(rd),t/FAR);\n    if(id>1){\n        n=normal(p);\n        c=matCol[id-2]*sunCol*(dot(sunDir,n)+1.)*.5;\n    }\n    c+=mix(vec3(0),sunCol,pow((dot(rd,sunDir)+1.)*.4,3.));\n    fragColor=vec4(clamp(c,0.,1.),1);\n}\n\n", "image_inputs": [], "sound_code": "//---Haru No Umi\n// by Catzpaw 2021\n\n//MUSIC\n//(The Sea in Spring)\n// composed by Michio Miyagi 1929\n\n//---Music Renderer\n// by Catzpaw 2019\n// https://www.shadertoy.com/view/tttGzB\n\n//SETUP\nconst float base =432.;\t//A tuning (Hz)\nconst float bpm  =100.;\t//beats per minute\nconst float steps=480.;\t//block length\nconst float start=2.;   //start count (beats)\n\n//STATE\nfloat gtime=0.;\t//time\nint   gchord=0;\t//chord\nfloat garp=0.;\t//arpeggio pattern\nfloat gdyn=1.;\t//dynamics\n\n//RANDOM ARP PATTERN GENERATOR\n/*\nfloat hash(float s){s=fract(s*.13);s*=s+33.33;return fract(s+s*s);}\nfloat pgen(float s,float r){\n    int p=0;\n    for(int i=0;i<16;i+=2){p+=int(hash(s)*r)<<i;s+=1.;}\n    return float(p);\n}\n*/\n\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){\n    vec2 v=pow(abs(i*p.x),vec2(1./p.y));\n    return clamp(sign(i)*v,-1.,1.)*p.z;\n}\n\n//CHORD\n//  global int gchord ...hex tetrad chord pattern\n/*\nfloat chord(float n){ // n:place in gchord (0-3)\n    float c=0.;\n    if(n>2.)c+=float((gchord>>8)&15);\n    if(n>1.)c+=float((gchord>>4)&15);\n    if(n>0.)c+=float(gchord&15);\n    return c; // return:relative note number to add to root note\n}\n*/\n\n//ARPEGGIATOR\n//  vec3 p( pattern, step_length, pattern_steps)\n//    arp_gate :p.pattern ...1bit pattern 1-16 steps 0:off 1:on\n//    arp_chord:p.pattern ...2bit pattern 1-8 steps 0-3:note\n/*\nfloat arp_gate(float t,vec3 p){\n    float l=15.*p.y/bpm;\n    float g=float((int(p.x)>>int(mod(t/l,p.z)))&1);\n    return (g>0.)?mod(t,l):-1.; // return:gate time or note off (-1)\n}\nfloat arp_chord(float t,vec3 p){\n    return chord(float((int(p.x)>>int(floor(mod(t/(15.*p.y/bpm),p.z))*2.))&3));\n}\n*/\n\n//FREQUENCY FROM MIDI NOTE NUMBER\n//single note\nfloat freq(float n){\n    return pow(2.,(n-69.)/12.)*base*6.283;\n}\n//with tetrad chord\n/*\nvec4 freq4(float n){\n    vec4 r;\n    r.x=freq(n);\n    r.y=gchord>0?freq(n+chord(1.)):0.;\n    r.z=gchord>16?freq(n+chord(2.)):0.;\n    r.w=gchord>256?freq(n+chord(3.)):0.;\n    return r;\n}\n*/\n\n//SOUND GENERATORS\n//  sequence => note pattern => instrument => oscillator\n\n//OSC\nfloat osc_saw(float x,float v){return clamp(mod(x/6.283,1.)*2.-1.,-1.,1.)*v;}\nfloat osc_sin(float x,float v){return clamp(sin(x)*v,-1.,1.);}\nfloat osc_sqr(float x,float v){return clamp(sign(sin(x))*v,-1.,1.);}\nfloat osc_noise(float x,float v){x=floor(x*1e3/v)*1e-3;return fract(sin(x*1717.17)*1313.13)*2.-1.;}\nfloat osc_metal(float x,float v){return fract(sin(x*v*171.17)*313.13)*2.-1.;}\n\n//ENVELOPE\n//const vec4 env0=vec4(0.00,.2,0.60,1.50); //piano\nconst vec4 env1=vec4(0.10,.4,0.50,0.50); //woodwind\n//const vec4 env2=vec4(0.20,.6,0.50,0.50); //string\n//const vec4 env3=vec4(0.00,.2,0.90,1.50); //synth\nconst vec4 env4=vec4(0.00,.2,0.60,1.50); //koto\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\nfloat env_ad(float x,float a,float d){return min(x/max(a,1e-4),max(0.,1.-(x-a)/max(d,1e-4)));}\nfloat env_adsr(float x,vec4 e,float g){return max(0.,min(1.,x/max(e.x,1e-4))-min(1.-e.z,max(x-e.x,0.)*(1.-e.z)/max(e.y,1e-4))-max(x-g,0.)*e.z/max(e.w,1e-4));}\n\n//PERCUSSION INSTRUMENTS (time)\n/*\nfloat bass_drum(float x){return osc_sin(x*freq(46./(1.+x*2.)),8.*env_d(x,.11));}\nfloat snare_drum(float x){return (osc_noise(x,.194)*env_d(x,.15)+osc_sin(x*freq(53./(1.+x*.2)),8.*env_d(x,.4)));}\nfloat hihat(float x,float d){return osc_metal(x,2.5)*env_d(x,d);}\n*/\n\n//MELODIC INSTRUMENTS (freq)\n/*\nfloat vibe(float f){return osc_sin(f+osc_sin(f*8.+osc_sin(f*.02,1.),.3),1.5);}\nfloat harpsi(float f){return osc_saw(f*4.+osc_sin(f*18.,.5),1.3);}\nfloat organ(float f){return osc_sin(f,1.3)+osc_sin(f*.5,1.)+osc_sin(f*2.,1.)+osc_sin(f*4.,.5);}\nfloat reed(float f){return osc_sin(f,1.)*osc_sqr(f*3.,1.);}\nfloat flute(float f){return osc_sin(f,1.)*osc_sin(f*2.,1.);}\nfloat sawlead(float f){return osc_saw(f,1.)+osc_saw(f*2.01,1.);}\nfloat sqrlead(float f){return osc_sqr(f,.7)+osc_sqr(f*2.01,.7);}\nfloat synlead(float f){return osc_saw(f,1.)*osc_sqr(f*3.02,1.);}\n*/\n\n//MELODIC INSTRUMENTS (freq,time)\n/*\nfloat piano(float f,float x){return osc_sin(f+osc_sin(f,env_d(x,.5))+osc_sin(f*3.,env_d(x,2.)*.8),1.);}\nfloat epiano(float f,float x){return osc_sin(f+osc_sin(f*15.,.04)+osc_sin(f*.99,.4),1.);}\nfloat bass(float f,float x){return osc_sin(f*.5+osc_sin(f*4.,env_d(x,.06)*.5)+osc_sin(f,env_ad(x,.1,.2)*.4),2.)*env_d(x,.6);}\nfloat bell(float f,float x){return osc_sin(f+osc_sin(f*3.4,env_d(x,1.)*.2)+osc_sin(f*4.,.5),1.);}\nfloat guitar(float f,float x){return osc_sin(f+osc_sin(f*8.,env_d(x,.05)*.3)+osc_sin(f*5.,env_ad(x,.03,5.)*.3),2.);}\nfloat aguitar(float f,float x){return osc_sin(f+osc_sin(f*8.,env_d(x,.05)*.3)+osc_sin(f*2.5,env_ad(x,.03,5.)*.3),2.);}\n*/\nfloat koto(float f,float x){\n    return osc_sin(f+osc_sin(f*9.,env_d(x,.1))+osc_sin(f*3.,env_ad(x,.05,3.)),2.);}\nfloat shakuhachi(float f,float x){\n    return osc_sin(f*.5+osc_sin(f,.5)+osc_sin(f*2.,.5)+osc_noise(x,.2)*env_ad(x,.04,.45)*.3,1.);}\n\n//NOTE OPERATORS\nfloat bup(float x){return min(x*(bpm/30.)-1.,0.);}\nfloat bdwn(float x){return max(1.-x*(bpm/30.),0.);}\nfloat pral(float x){float y=20./bpm;return ((x>y/2.)&&(x<y))?2.:0.;}\nfloat mord(float x){float y=20./bpm;return ((x>y/2.)&&(x<y))?-2.:0.;}\nfloat tril(float x){return sign(sin(3.14+x*bpm*6.28/15.))+1.;}\n\n//NOTE PATTERNS\n//P( note length, num of notes) ...pattern init\n//T( position)                  ...set trigger (for percussion)\n//N( position, note)            ...set note (for melody)\n//NN( position, note)           ...set note without gate\n//NU( position, note)           ...set note with bend up\n//ND( position, note)           ...set note with bend down\n//NP( position, note)           ...set note with pral triller\n//NM( position, note)           ...set note with mordent\n//NT( position, note)           ...set note with trill\n//X( position, macro)           ...execute macro (CHORD_mM7 etc.)\n//X( position, code)            ...execute code (gchord=0x333; etc.)\n#define P(l,s) float x=1e3,y=15.*float(l)/bpm,z=0.,v=mod(t,y*float(s));\n#define T(s) if(v>float(s)*y){x=v-float(s)*y;}\n#define N(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n);}\n#define NN(s,n) if(v>float(s)*y){z=float(n);}\n//#define NU(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+bup(x);}\n//#define ND(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+bdwn(x);}\n#define NP(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+pral(x);}\n#define NM(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+mord(x);}\n//#define NT(s,n) if(v>float(s)*y){x=v-float(s)*y;z=float(n)+tril(x);}\n//#define X(s,n) if(v>float(s)*y){x=v-float(s)*y;n;}\n\n#define R -1e3\n#define C  60.\n#define Cs 61.\n#define Db 61.\n#define D  62.\n#define Ds 63.\n#define Eb 63.\n#define E  64.\n#define F  65.\n#define Fs 66.\n#define Gb 66.\n#define G  67.\n#define Gs 68.\n#define Ab 68.\n#define A  69.\n#define As 70.\n#define Bb 70.\n#define B  71.\n#define HI  12.+\n#define LO -12.+\n\n/*\n#define CHORD_3        gchord=0x484;\n#define CHORD_4        gchord=0x575;\n#define CHORD_5        gchord=0x757;\n#define CHORD_M        gchord=0x534;\n#define CHORD_on3      gchord=0x453;\n#define CHORD_on5      gchord=0x345;\n#define CHORD_sus4     gchord=0x525;\n#define CHORD_sus4on4  gchord=0x552;\n#define CHORD_sus4on5  gchord=0x255;\n#define CHORD_7        gchord=0x334;\n#define CHORD_7sus4    gchord=0x325;\n#define CHORD_7alt     gchord=0x424;\n#define CHORD_M7       gchord=0x434;\n#define CHORD_M7sus4   gchord=0x425;\n#define CHORD_m        gchord=0x543;\n#define CHORD_mon3     gchord=0x354;\n#define CHORD_mon5     gchord=0x435;\n#define CHORD_m7       gchord=0x343;\n#define CHORD_mM7      gchord=0x443;\n#define CHORD_add9     gchord=0x734;\n#define CHORD_madd9    gchord=0x743;\n#define CHORD_add9on5  gchord=0x552;\n*/\n\n//#define DYN_ff gdyn=1.0;\n//#define DYN_f  gdyn=0.9;\n#define DYN_mf gdyn=0.8;\n//#define DYN_mp gdyn=0.7;\n//#define DYN_p  gdyn=0.6;\n//#define DYN_pp gdyn=0.5;\n\n/*\n#define ARP4_up 58596.\n#define ARP4_down 6939.\n#define ARP4_updown 18148.\n#define ARP4_downup 47387.\n#define ARP4_p1 18118.\n#define ARP4_p2 4656.\n\n#define ARP3_up 18724.\n#define ARP3_down 24966.\n#define ARP3_updown 25700.\n#define ARP3_downup 17990.\n#define ARP3_p1 4486.\n#define ARP3_p2 8480.\n*/\n\n//NOTE PATTERNS:percussion\n/*\nvec2 bd(float t,float p){\n    float g=arp_gate(t,vec3(p,1.,16.));\n    return g<0.?vec2(0):amp(vec2(.6*bass_drum(g*1.05),.6*bass_drum(g*.95)),vec3(1,2.2,1));\n}\nvec2 sd(float t,float p){\n    float g=arp_gate(t,vec3(p,1.,16.));\n    return g<0.?vec2(0):vec2(.4*snare_drum(g*.995),.4*snare_drum(g*1.005));\n}\nvec2 hh(float t,float p1,float p2){\n    float g=arp_gate(t,vec3(p1,1.,16.));\n    vec2 r=g<0.?vec2(0):vec2(.2)*hihat(g,.08);\n    g=arp_gate(t,vec3(p2,2.,8.));r+=g<0.?vec2(0):vec2(.2)*hihat(g,.3);\n    return r;\n}\n*/\n\n//NOTE PATTERNS:koto\nvec2 ko(float x,float n){\n\tfloat fl=freq(n)*x,fr=fl*1.005;fl*=.995;\n    return vec2(koto(fl,x)*env_adsr(x,env4,.1),koto(fr,x)*env_adsr(x,env4,.1))*gdyn;\n}\nvec2 ko1(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,E)\n    N(5.1,A)\n    N(5.8,B)\n    N(6.6,A)\n    N(7.5,E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko2(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,E)\n    N(5.1,A)\n    N(5.8,B)\n    N(6.6,HI D)\n    N(7.5,HI E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko3(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,B)\n    N(5.1,HI D)\n    N(5.8,B)\n    N(6.6,A)\n    N(7.5,HI E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko4(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,HI E)\n    N(5.1,B)\n    N(5.8,A)\n    N(6.6,F)\n    N(7.5,E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\nvec2 ko5(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(3,LO B)\n    N(3.7,D)\n    N(4.4,E)\n    N(5.1,F)\n    N(5.8,A)\n    N(6.6,B)\n    N(7.5,HI E)\n    N(14,R)\n    return z<0.?vec2(0):ko(x,z+o)*.3;\n}\n\n//NOTE PATTERNS:shakuhachi\nvec2 sh(float x,float n){\n    n+=sin(x*24.)*min(max(0.,x-.5),.01)+12.;\n\tfloat fl=freq(n)*x,fr=fl*1.0043;fl*=.9957;\n    return vec2(shakuhachi(fl,x)*env_adsr(x,env1,2.5),shakuhachi(fr,x)*env_adsr(x,env1,2.5))*gdyn;\n}\nvec2 sh1(float t,float o){\n    P(2,16)\n    N(15,D)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh2(float t,float o){\n    P(2,16)\n    N(0,E)\n    N(8,G)\n    N(10.9,E)\n    NN(11.5,D)\n    NN(12,LO B)\n    N(14,LO A)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh3(float t,float o){\n    P(2,16)\n    NM(0,LO B)\n    N(14,R)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh4(float t,float o){\n    P(2,16)\n    N(0,LO E)\n    N(10.25,R)\n    N(12,D)\n    NN(13,E)\n    NN(14,G)\n    NN(15,A)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh5(float t,float o){\n    P(2,16)\n    N(0,B)\n    N(7.25,A)\n    NN(8,B)\n    N(15.75,R)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh6(float t,float o){\n    P(2,16)\n    N(4,E)\n    NP(7,D)\n    NN(8,LO B)\n    N(15,LO A)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh7(float t,float o){\n    P(2,16)\n    N(0,LO B)\n    N(10,R)\n    N(12,LO E)\n    N(14,E)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh8(float t,float o){\n    P(2,16)\n    N(0,E)\n    N(12,G)\n    NN(14,E)\n    NN(15,D)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\nvec2 sh9(float t,float o){\n    P(2,16)\n    NM(0,E)\n    N(12,R)\n    return z<0.?vec2(0):sh(x,z+o)*.5;\n}\n\n//SEQUENCE\n#define TRACK t=time;v=vec2(0);\n#define   SEGNO(block,blocks)        if(t>float(block)*l){t=mod(t-float(block)*l,float(blocks)*l);\n#define     REP(block,blocks,repend) if((t>float(block)*l)&&(t<=float(block)*l+float(repend)*l)){t=mod(t-float(block)*l,float(blocks)*l);\n#define       SEQ(block,patterns)    if(t>float(block)*l){v=patterns;v*=d;}\n#define     NEXT                     }\n#define   DS                         }\n#define END                          o+=v;\nvoid sequence(float time,float l,float d,inout vec2 o){vec2 v=vec2(0);float t=time;\n\n    DYN_mf\n\n    TRACK //1 shakuhachi\n      SEGNO(0,10)\n        SEQ(1,sh1(t,0.))\n        SEQ(2,sh2(t,0.))\n        SEQ(3,sh3(t,0.))\n        SEQ(4,sh4(t,0.))\n        SEQ(5,sh5(t,0.))\n        SEQ(6,sh6(t,0.))\n        SEQ(7,sh7(t,0.))\n        SEQ(8,sh8(t,0.))\n        SEQ(9,sh9(t,0.))\n      DS\n    END\n\n    TRACK //2 koto\n      SEGNO(0,10)\n        REP(0,2,4)\n          SEQ(0,ko1(t,0.))\n          SEQ(1,ko2(t,0.))\n        NEXT\n        REP(4,4,8)\n          SEQ(0,ko3(t,0.))\n          SEQ(1,ko4(t,0.))\n          SEQ(2,ko5(t,0.))\n          SEQ(3,ko4(t,0.))\n        NEXT        \n        REP(8,2,10)\n          SEQ(0,ko1(t,0.))\n          SEQ(1,ko2(t,0.))\n        NEXT\n      DS\n    END\n\n}\n\n//MASTER SECTION\n#define MASTER_DRIVE    0.3\n#define MASTER_PRESSURE 1.1\n#define DELAY_REPEAT    9\n#define DELAY_WET       0.4\n#define DELAY_FEEDBACK  0.85\n#define DELAY_TIME      0.05\nvec2 mainSound( in int samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;vec2 o=vec2(0),v=vec2(0);\n    if(time>170.){vol=(180.-min(time,180.))/10.;}\n    time-=start*60./bpm;if(time<0.)return o;\n    gtime=time;\n    sequence(time,l,1.,o);\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;gtime-=r;\n        sequence(time,l,d,o);\n        d*=DELAY_FEEDBACK;\n        r+=DELAY_TIME;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lc3D2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 153, 153, 200], [201, 201, 235, 235, 312], [314, 320, 347, 347, 414], [415, 415, 442, 442, 483], [484, 484, 519, 519, 611], [612, 612, 648, 648, 751], [753, 768, 786, 786, 895], [897, 905, 934, 934, 3196], [3198, 3205, 3223, 3223, 3533], [3535, 3544, 3564, 3564, 3751], [3753, 3767, 3819, 3819, 4304], [4305, 4305, 4357, 4357, 4658], [4745, 4745, 4763, 4763, 4980], [4982, 4990, 5011, 5011, 5125], [5634, 5634, 5691, 5691, 6860]], "test": "untested"}
{"id": "Wtdyzl", "name": "AV [2TC 15] Mystery Mountains", "author": "MacroMachines", "description": "A fractal mountain range in 264 chars.", "tags": ["3d", "raymarching", "mountain", "2tc15", "mystery"], "likes": 1, "viewed": 354, "published": 3, "date": "1609718732", "time_retrieved": "2024-07-30T19:47:14.344637", "image_code": "// Fork of \"[2TC 15] Mystery Mountains\" by Dave_Hoskins. https://shadertoy.com/view/llsGW7\n// 2018-03-11 21:33:10\n\n//// [2TC 15] Mystery Mountains.\n// David Hoskins.\n\n// Add layers of the texture of differing frequencies and magnitudes...\n#define F +texture(iChannel0,.3+p.xz*s/3e3)/(s+=s)\n#define F2(t) +texture(t,.87+p.yx*0.01)*30.0/100.0\nvoid mainImage( out vec4 c, vec2 w )\n{\n    vec4 p=vec4(w/iResolution.xy,1,1)-.5,d=p,t;\n    p.z += iTime*20.;d.y-=.4;\n    for(float i=1.5;i>0.;i-=.002)\n    {\n        float s=.5;\n        t = F F F F F F + F2(iChannel1);\n        c = vec4(1,1.,.9,9)+d.x-t*i;\n        if(t.x>p.y*.007+1.3)break;\n        p += d;\n    }\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 138, "src": "https://soundcloud.com/woodpeckerramsey/soul-of-the-machine-the-10", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtdcRl", "name": "Twin Dragon Fractal Pattern", "author": "oneshade", "description": "I really liked @Gijs shader \"Basic: Twin Dragon.\" I started messing with it and made this.", "tags": ["fractal", "dragon", "curve", "fork", "pretty", "twindragon", "twin"], "likes": 5, "viewed": 157, "published": 3, "date": "1609714593", "time_retrieved": "2024-07-30T19:47:15.233263", "image_code": "// fork of https://www.shadertoy.com/view/MtXSWj\n\nfloat alternate(in float p, in float d){;\n\treturn sign(fract(p * d * 0.5) * 2.0 - 1.0);\n}\n\nvec3 TwinDragon(in vec2 p) {\n    p /= iResolution.y;\n    p += 0.25 * iTime;\n    p.y = abs(mod(floor(p.y), 2.0) - fract(p.y));\n    p.x = abs(mod(floor(p.x), 2.0) - fract(p.x));\n\n    p.y += alternate(p.x, 256.0) / 512.0;\n    p.x -= alternate(p.y, 128.0) / 256.0;\n    p.y += alternate(p.x,  64.0) / 128.0;\n    p.x -= alternate(p.y,  32.0) /  64.0;\n    p.y += alternate(p.x,  16.0) /  32.0;\n    p.x -= alternate(p.y,   8.0) /  16.0;\n    p.y += alternate(p.x,   4.0) /   8.0;\n    p.x -= alternate(p.y,   2.0) /   4.0;\n\n    return pow(texture(iChannel0, p * 0.1).rgb, vec3(1.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    fragColor.rgb += TwinDragon(fragCoord);\n    fragColor.rgb += TwinDragon(fragCoord + vec2(0.5, 0.0));\n    fragColor.rgb += TwinDragon(fragCoord + vec2(0.0, 0.5));\n    fragColor.rgb += TwinDragon(fragCoord + 0.5);\n    fragColor.rgb *= 0.25;\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdcRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 90, 90, 139], [141, 141, 169, 169, 716], [718, 718, 773, 773, 1057]], "test": "untested"}
{"id": "wt3czs", "name": "Eroded hills", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/ttdcRX]\"Fractal Canyons\"[/url] terrain.", "tags": ["fractal", "terrain", "mountain", "canyon"], "likes": 1, "viewed": 285, "published": 3, "date": "1609708767", "time_retrieved": "2024-07-30T19:47:16.113907", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(surface_color(sin(worldDir/10.0+iTime/100.0)).yzx,0);\n        //fragColor = vec4(0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n        \n    //distance fog\n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+1.0)*2.0;\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n            \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0)-1.0, cos(iTime*speed/10.0)*3.14), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(eye-dmap)*.9;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx+p1*1.3+p1.zxy*1.2+p1*1.5))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 100.0; i *= -5.0){\n        float p1 = planet_surface(p*i,i)/(i);\n        result = max(result+p1-p.y*(1.5+sin(length(p.xz)/50.0/i)), -p1);\n    }\n    return (result-10.0)*scale/8.0;\n}\n\nvec3 surface_color1(vec3 p)\n{\n    p *= 10.0;\n    float p1 = planet_surface(p,3.0);\n    float p2 = planet_surface(p,5.0);\n    float p3 = planet_surface(p,7.0);\n    return sin((vec3(p2-p3,p2,p2-p3)))/10.0+vec3(.5,.4,.3)*1.5;\n}\n\nvec3 surface_color(vec3 p){\n    float k = 2.0;\n    vec3 result;\n    for(int i = 0; i < 5; i++){\n       result += surface_color1(p/k);\n       k *= 2.0;\n       //p *= surface_color1(p);\n    }\n    return result/5.0;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3czs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 482, 573, 573, 891], [905, 905, 932, 932, 1081], [1083, 1083, 1140, 1140, 1958]], "test": "untested"}
{"id": "3tcyzl", "name": "Aastal - Nothing is less dub", "author": "z0rg", "description": "https://youtu.be/Fq8qgzzm_nA", "tags": ["dubstep"], "likes": 6, "viewed": 337, "published": 3, "date": "1609708010", "time_retrieved": "2024-07-30T19:47:17.037438", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// A clip I did for a friend\n// The video is here https://youtu.be/Fq8qgzzm_nA\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n#define FFT(v) (pow(texelFetch(iChannel1, ivec2(v,0),0).x,3.)+.3)\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nfloat _rho(vec2 p, float r)\n{\n    return lenny(p)-r;\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nvec3 rdr(vec2 uv)\n{\n    float shp = iResolution.x*.5;\n    vec3 col;\n    mat2 rotCover = r2d((FFT(10)-.5)*.2);\n    vec2 moveScene = rotCover*vec2(FFT(10)-.5, FFT(20)-.5);\n    \n    // Back\n    col = vec3(52, 49, 54)/255.;\n    col += .5*(1.-sat(_cir(uv-vec2(.1,0.), .1)*2.))*(vec3(129, 80, 161)/255.);\n    col += .5*(1.-sat(_cir(uv-vec2(-.1,0.), .05)*2.))*(vec3(129, 80, 161)/255.).xzy;\n    col = pow(col, vec3(2.45));\n    \n    // back grid\n    uv -= .02*moveScene;\n    float gridAStp = .1;\n    float gridATh = 0.0001;\n    \n    vec2 gridAv = mod(uv, gridAStp)-gridATh;\n    float gridA = min(gridAv.x, gridAv.y);\n    col = mix(col, sat(col+vec3(.05)), 1.-sat(gridA*shp));\n    \n    float gridBStp = gridAStp/5.;\n    float gridBTh = gridATh/2.;\n    \n    vec2 gridBv = mod(uv, gridBStp)-gridBTh;\n    float gridB = min(gridBv.x, gridBv.y);\n    col = mix(col, sat(col+vec3(.015)), 1.-sat(gridB*shp));\n    col *= pow((1.-sat(lenny(uv*.5)-.2)), 5.);\n    \n\n    \n    // Piou Piou\n    \n    float barRep = .025;\n    float barTh = 0.002;\n    \n    vec2 uvBars = uv;\n    float barsIdx = round((uvBars.y+barRep*.5) / barRep);\n    uvBars.y = mod(uvBars.y+.5*barRep, barRep)-barRep;\n    \n    float bars = _sqr(uvBars, vec2(FFT(5.*(barsIdx+10.))*.5, barTh));\n    \n    vec3 grad = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+2.*FFT(barsIdx+10.));\n    col += grad *(1.-sat(bars*shp));\n    col += grad *(1.-sat(bars*5.))*.5;\n    \n    // Logo\n    vec2 coverUv = moveScene*.25+((cos(iTime*.25)*.2+1.)*5.*uv+vec2(.5));//+vec2(sin(iTime), cos(iTime))*.1;\n    //coverUv *= ;\n    vec4 coverBlack4 = texture(iChannel0, coverUv*.95);\n    vec4 cover4 = texture(iChannel0, coverUv);\n    vec3 cover = cover4.xyz;\n    col = col*sat(.0+pow(sat(_rho(coverUv-vec2(.5)-vec2(0.,-.1), .5)*2.), .4));\n    //col *= sat(.5+1.-coverBlack4.w);\n    if (coverUv.x > 0. && coverUv.y > 0. && coverUv.x < 1. && coverUv.y < 1.)\n        ;//col = mix(col, cover, cover4.w); // I use the extension to put a custom texture here\n//        col = cover;\n        \n\n    vec3 rhoCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)).zxy;\n    \n    \n    // Border\n    float th = .23;\n    float border = abs(uv.y)-th;\n    \n    col = mix(col, vec3(0.), sat(border*shp));\n    \n    col *= .5+rhoCol*pow(1.-sat(_rho(coverUv-vec2(.5), 1.5)*1.), 1.);\n\n    return col;\n}\n\nvec3 chroma(vec2 uv)\n{\n    vec2 dir = normalize(vec2(1.));\n    float strength = 0.025*sat(length(uv))+FFT(10)*.05*length(uv);\n    vec3 rgb;\n    \n    rgb.x = rdr(uv+dir*strength).x;\n    rgb.y = rdr(uv).y;\n    rgb.z = rdr(uv-dir*strength).z;\n    \n    return rgb;\n}\n\nvec3 cheapAA(vec2 uv)\n{\n    vec3 col = chroma(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n    float diff = pow(fwidth(col.z), 1.);\n    if (true)//diff > 0.3) // Not so cheap antialiasing\n    {\n        //col = vec3(1.,0.,0.);\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    uv.y *= 1.+abs(uv.x);\n    vec3 col = cheapAA(uv);\n    \n    col = mix(col, col.zxy*(2.-sat(length(uv*4.))), sin(iTime*.5)*.5+.5);\n\n    \n    col *= sat(iTime-0.2);\n    col *= 1.-sat(iTime-213.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25179, "src": "https://soundcloud.com/aastal/nothing-is-less", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyzl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[509, 509, 528, 528, 585], [653, 653, 674, 674, 706], [708, 708, 737, 737, 763], [764, 764, 793, 793, 818], [820, 820, 848, 848, 899], [900, 900, 919, 919, 3183], [3185, 3185, 3207, 3207, 3447], [3449, 3449, 3472, 3472, 3886], [3889, 3889, 3946, 3946, 4244]], "test": "untested"}
{"id": "tt3cRs", "name": "Read Letters' Circle", "author": "IWBTShyGuy", "description": "Extracts letter from an image and arranges it on a circle. If each character is connected and there is no overlap between them, it will work with other images.\n\nThe original image is generated by [url]https://www.shadertoy.com/view/4s3fzl[/url].", "tags": ["letter"], "likes": 1, "viewed": 392, "published": 3, "date": "1609702980", "time_retrieved": "2024-07-30T19:47:17.995875", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://www.shadertoy.com/view/4s3fzl\n// iTime is replaced to 0.0 for fix the image.\n\n// I modified Hamneggs shader to use integer arithmetic, arrays and branches when\n// appropiate - iq\n\n\n// Simple Bitmap Text by Gerard Geer\n// \n// Essentially a \"hmm, how does that work?\" educational rewrite of P_Malin's text renderer:\n// https://www.shadertoy.com/view/4sBSWW\n// Each character is a 4x5 bitmap encoded into a float, where each hex digit convieniently\n// represents one row.\n// License: Creative Commons CC0 1.0 Universal (CC-0) \n\nconst int font[] = int[](\n 0x69f99, 0x79797, 0xe111e, 0x79997, 0xf171f, 0xf1711, 0xe1d96, 0x99f99, \n 0xf444f, 0x88996, 0x95159, 0x1111f, 0x9f999, 0x9bd99, 0x69996, 0x79971,\n 0x69b5a, 0x79759, 0xe1687, 0xf4444, 0x99996, 0x999a4, 0x999f9, 0x99699,\n 0x99e8e, 0xf843f, 0x6bd96, 0x46444, 0x6942f, 0x69496, 0x99f88, 0xf1687,\n 0x61796, 0xf8421, 0x69696, 0x69e84, 0x66400, 0x0faa9, 0x0000f, 0x00600,\n 0x0a500, 0x02720, 0x0f0f0, 0x08421, 0x33303, 0x69404, 0x00032, 0x00002,\n 0x55000, 0x00000, 0x00202, 0x42224, 0x24442);\n\n#define CH_A 0\n#define CH_B 1\n#define CH_C 2\n#define CH_D 3\n#define CH_E 4\n#define CH_F 5\n#define CH_G 6\n#define CH_H 7\n#define CH_I 8\n#define CH_J 9\n#define CH_K 10\n#define CH_L 11\n#define CH_M 12\n#define CH_N 13\n#define CH_O 14\n#define CH_P 15\n#define CH_Q 16\n#define CH_R 17\n#define CH_S 18\n#define CH_T 19\n#define CH_U 20\n#define CH_V 21\n#define CH_W 22\n#define CH_X 23\n#define CH_Y 24\n#define CH_Z 25\n#define CH_0 26\n#define CH_1 27\n#define CH_2 28\n#define CH_3 29\n#define CH_4 30\n#define CH_5 31\n#define CH_6 32\n#define CH_7 33\n#define CH_8 34\n#define CH_9 35\n#define CH_APST 36\n#define CH_PI   37\n#define CH_UNDS 38\n#define CH_HYPH 39\n#define CH_TILD 40\n#define CH_PLUS 41\n#define CH_EQUL 42\n#define CH_SLSH 43\n#define CH_EXCL 44\n#define CH_QUES 45\n#define CH_COMM 46\n#define CH_FSTP 47\n#define CH_QUOT 48 \n#define CH_BLNK 49\n#define CH_COLN 50\n#define CH_LPAR 51\n#define CH_RPAR 52\n\nconst ivec2 MAP_SIZE = ivec2(4,5);\n\n\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent [0..1] uv coordinate.\n*/\nint drawChar( in int char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    \n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv-=pos;\n    \n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;    \n    \n    // Multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= vec2(MAP_SIZE);\n\n    // Compute bitmap texel coordinates\n    ivec2 iuv = ivec2(round(uv));\n    \n\t// Bounding box check. With branches, so we avoid the maths and lookups    \n    if( iuv.x<0 || iuv.x>MAP_SIZE.x-1 ||\n        iuv.y<0 || iuv.y>MAP_SIZE.y-1 ) return 0;\n\n    // Compute bit index\n    int index = MAP_SIZE.x*iuv.y + iuv.x;\n    \n    // Get the appropriate bit and return it.\n    return (font[char]>>index)&1;\n\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nint drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    // Create a place to store the current values.\n    int res = 0;\n    // Surely it won't be more than 10 chars long, will it?\n    // (MAX_INT is 10 characters)\n    for( int i = 0; i < 10; ++i )\n    {\n        // If we've run out of film, cut!\n        if(val == 0 && i >= places) break;\n        // The current lsd is the difference between the current\n        // value and the value rounded down one place.\n        int digit = val % 10;\n        // Draw the character. Since there are no overlaps, we don't\n        // need max().\n        res |= drawChar(CH_0+digit,pos,size,uv);\n        // Move the carriage.\n        pos.x -= size.x*1.2;\n        // Truncate away this most recent digit.\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nint drawInt( in int val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(float(val));\n    val *= int(s);\n    \n    int c = drawIntCarriage(val,p,size,uv,1);\n    if( s<0.0 ) c |= drawChar(CH_HYPH,p,size,uv);\n    return c;\n}\n\n/*\n\tPrints a fixed point fractional value. Be even more careful about overflowing.\n*/\nint drawFixed( in float val, in int places, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    float fval, ival;\n    fval = modf(val, ival);\n    \n    vec2 p = vec2(pos);\n    \n    // Draw the floating point part.\n    int res = drawIntCarriage( int( fval*pow(10.0,float(places)) ), p, size, uv, places );\n    // The decimal is tiny, so we back things up a bit before drawing it.\n    p.x += size.x*.4;\n    res |= drawChar(CH_FSTP,p,size,uv); p.x-=size.x*1.2;\n    // And after as well.\n    p.x += size.x *.1;\n    // Draw the integer part.\n    res |= drawIntCarriage(int(ival),p,size,uv,1);\n\treturn res;\n}\n\nint text( in vec2 uv, const float size )\n{\n    vec2 charSize = vec2( size*vec2(MAP_SIZE)/iResolution.y );\n    float spaceSize = float( size*float(MAP_SIZE.x+1)/iResolution.y );\n        \n    // and a starting position.\n    vec2 charPos = vec2(0.05, 0.90);\n    // Draw some text!\n    int chr = 0;\n    // Bitmap text rendering!\n    chr += drawChar( CH_B, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_P, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_X, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_EXCL, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_EXCL, charPos, charSize, uv); charPos.x += spaceSize;\n    \n    // Today's Date: {date}\n    charPos = vec2(0.05, .75);\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_APST, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_S, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_LPAR, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_Y, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_RPAR, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += .1;\n    // The date itself.\n    charPos.x += .3;\n    chr += drawIntCarriage( int(iDate.x), charPos, charSize, uv, 4);\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x-=spaceSize;\n    chr += drawIntCarriage( int(iDate.z)+1, charPos, charSize, uv, 2);\n    chr += drawChar( CH_HYPH, charPos, charSize, uv); charPos.x-=spaceSize;\n    chr += drawIntCarriage( int(iDate.y)+1, charPos, charSize, uv, 2);\n    \n    // Shader uptime:\n    charPos = vec2(0.05, .6);\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_B, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += spaceSize;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += spaceSize;\n    // The uptime itself.\n    charPos.x += .3;\n    //chr += drawFixed( iTime, 2, charPos, charSize, uv);\n    chr += drawFixed( 0.0, 2, charPos, charSize, uv);\n    return chr;\n}\n\n/*\n\tShadertoy's fancy entry function.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get Y-normalized UV coords.\n\tvec2 uv = fragCoord / iResolution.y;\n    \n    // Draw some text!\n    float txt = float( text(uv, 3.5) );\n    \n\tfragColor = vec4(txt,txt,txt,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// ------------------ Card IO Module ------------------ //\n// The MIT License\n// Copyright  2020 IWBTShyGuy\n\n// iChannel0: texture including letters\n// iChannel1: backbuffer\n\nconst int MAX_ROW = 255;\nconst int BUFFER_LENGTH = 100;\n\nconst vec4 BLACK = vec4(0, 0, 0, 1);\nconst vec4 WHITE = vec4(1);\n\n// Returns whether the pixel on the image is on the letter or not.\n// This function is depends on the letter image.\nbool onLetter(in vec2 uv) {\n    vec4 col = texture(iChannel0, uv);\n    return col.x > 0.1;\n}\n\nbool inUnitSquare(in vec2 uv) {\n    return abs(uv.x - 0.5) <= 0.5 && abs(uv.y - 0.5) <= 0.5;\n}\n\nvec4 searchRows(in vec2 uv) {\n    if (inUnitSquare(uv)) {\n        return texture(iChannel0, (uv + 0.01) / 1.02);\n    } else if (uv.x < 1.0) {\n        return BLACK;\n    } else {\n        float dt = 1.0 / iChannelResolution[0].x;\n        for (float x = 1.0; x > 0.0; x -= dt) {\n            if (onLetter(vec2(x, uv.y))) return WHITE;\n        }\n        return BLACK;\n    }\n}\n\nvec2 getRowRange(in int row) {\n    vec2 res;\n    bool prevOnRow = false;\n    float dt = 1.0 / iChannelResolution[0].y;\n    for (float y = 1.0; y > 0.0; y -= dt) {\n        vec2 st = vec2(0.995, (y + 0.01) / 1.02);\n        bool onRow = texture(iChannel1, st).x > 0.5;\n        if (!prevOnRow && onRow) res.x = y;\n        if (prevOnRow && !onRow) {\n            res.y = y;\n            if (row == 0) return res;\n            else row -= 1;\n        }\n        prevOnRow = onRow;\n    }\n    return vec2(0);\n}\n\nint readCounter() {\n    float score = texture(iChannel1, vec2(0.005)).x;\n    return int(score * float(MAX_ROW));\n}\n\nvec4 searchLetters(in vec2 uv, in int row) {\n    vec2 st = (uv + 0.01) / 1.02;\n    if (uv.y < 1.0) return texture(iChannel1, st);\n    if (uv.x > 1.0) return BLACK;\n    vec2 range = getRowRange(row);\n    if (range.x == range.y) return BLACK;\n    float dt = 1.0 / iChannelResolution[0].y;\n    for (float y = range.x; y > range.y; y -= dt) {\n        if (onLetter(vec2(st.x, y))) return WHITE;\n    }\n    return BLACK;\n}\n\nint getBufferHead() {\n    for (int i = 0; i < BUFFER_LENGTH; i++) {\n        float x = (float(i) + 0.5) / float(BUFFER_LENGTH);\n        vec2 st = vec2((x + 0.01) / 1.02, 0.005);\n        float score = texture(iChannel1, st).y;\n        if (score == 0.0) return i;\n    }\n    return BUFFER_LENGTH;\n}\n\nvec2 getLetterRange(in int cursor) {\n    vec2 res;\n    bool prevOnRow = false;\n    float dt = 1.0 / iChannelResolution[0].x;\n    for (float x = 0.0; x < 1.0; x += dt) {\n        vec2 st = vec2(x, 0.995);\n        bool onRow = texture(iChannel1, st).x > 0.5;\n        if (!prevOnRow && onRow) res.x = x;\n        if (prevOnRow && !onRow) {\n            res.y = x;\n            if (cursor == 0) return res;\n            else cursor -= 1;\n        }\n        prevOnRow = onRow;\n    }\n    return vec2(0);\n}\n\nvec4 getLetters(in vec2 uv, in int row) {\n    vec4 col = texture(iChannel1, (uv + 0.01) / 1.02);\n    if (uv.y > 0.0) return col;\n    if (uv.x < 0.0) return BLACK;\n    if (col.x != 0.0) return col;\n    vec2 row_range = getRowRange(row);\n    int offset = getBufferHead();\n    int cursor = int(uv.x * float(BUFFER_LENGTH));\n    vec2 range = getLetterRange(cursor - offset);\n    if (range.y == 0.0) return BLACK;\n    return vec4(row_range, range);\n}\n\nvec4 readLetters(in vec2 uv) {\n    if (uv.x < 0.0 && uv.y < 1.0) {\n        return texture(iChannel1, vec2(0.005)) + 1.0 / 255.0;\n    }\n\n    int k = readCounter();\n    int row = k / 2;\n    if (k % 2 == 0) return searchLetters(uv, row);\n    else return getLetters(uv, row);\n}\n\nvec4 readBuffer(in int idx) {\n    float x = (float(idx) + 0.5) / float(BUFFER_LENGTH);\n    return texture(iChannel1, vec2((x + 0.01) / 1.02, 0.001));\n}\n\nstruct Card {\n    vec2 origin;\n    vec2 size;\n};\n\nCard readCard(in int idx) {\n    vec4 info = readBuffer(idx);\n    Card card;\n    card.origin = vec2(info.z, info.y);\n    card.size = vec2(info.w - info.z, info.x - info.y);\n    return card;\n}\n\nvec4 printCard(in Card card, in vec2 uv) {\n    vec2 pixel = card.size;\n    float asp = pixel.y / pixel.x;\n    uv.x = asp * (uv.x - 0.5) + 0.5;\n    if (!inUnitSquare(uv)) return BLACK;\n    vec2 st = card.origin + uv * card.size;\n    if (onLetter(st)) return WHITE;\n    else return BLACK;\n}\n\n// ------------------ Main ------------------ //\n// Attribution 4.0 International (CC BY 4.0)\n// Copyright  2020 IWBTShyGuy\n\nconst float DELAY = 1.0;\n\nconst float RADIUS = 0.4;\nconst float LETTER_SIZE = 0.05;\n\nconst float PI = 3.141592653;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 1.02 * fragCoord / iResolution.xy - 0.01;\n    if (iFrame == 0) {\n        fragColor = searchRows(uv);\n        return;\n    } else if (iFrame < 60) {\n        fragColor = readLetters(uv);\n        return;\n    } else if (uv.y < 0.0) {\n        fragColor = texture(iChannel1, (uv + 0.01) / 1.02);\n        return;\n    }\n    int nLetters = getBufferHead();\n    uv = (uv + 0.01) / 1.02;\n    float asp = iResolution.x / iResolution.y;\n    uv = (uv - 0.5) * vec2(asp, 1.0) + 0.5;\n    fragColor = vec4(0);\n    for (int i = 0; i < nLetters; i++) {\n        Card card = readCard(i);\n        float t = iTime - 1.0;\n        float theta = t - float(i) / float(nLetters) * 2.0 * PI;\n        theta = mix(0.0, theta, clamp(t, 0.0, 1.0));\n        mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n        vec2 st = rot * (uv - 0.5);\n        st.y -= RADIUS;\n        st /= LETTER_SIZE;\n        st += 0.5;\n        vec2 origin = ((uv - 0.5) / vec2(asp, 1.0) + 0.5 - card.origin) / LETTER_SIZE;\n        st = mix(origin, st, clamp(t, 0.0, 1.0));\n        fragColor = max(fragColor, printCard(card, st));\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3cRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "wsyBWc", "name": "Caves - WebGLSamples", "author": "oneshade", "description": "Underwhelming recreation of \"Caves\" by Jasmine Kent Langridge from [url=https://webglsamples.org/caves/caves.html]https://webglsamples.org/caves/caves.html[/url]. This one was hard! I even recreated the annoying controls for lack of a better idea :D", "tags": ["procedural", "recreation", "caves", "webglsamples"], "likes": 3, "viewed": 153, "published": 3, "date": "1609698976", "time_retrieved": "2024-07-30T19:47:18.960297", "image_code": "/*\nUnderwhelming recreation of \"Caves\" by Jasmine Kent Langridge:\nhttps://webglsamples.org/caves/caves.html\n\nIt is very slow so if you have suggestions for speeding it up,\nplease share them.\n\nMouse to rotate, arrow keys to move.\nClick to dig.\n*/\n\nfloat mapScene(in vec3 p) {\n    float bbox = max(abs(p.x), abs(p.z)) - 50.0;\n    float scene = max(abs(p.y + fnoise2D(p.xz)) - GROUND_THICKNESS, bbox);\n\n    // Draw each tunnel\n    float currentIndex = getCurrentIndex() + 3.0;\n    for (float i=0.0; i < currentIndex; i += 3.0) {\n        vec3 tunnelEntrance = getTunnelEntrance(int(i));\n        vec3 tunnelExit = getTunnelExit(int(i));\n        scene = max(scene, sdCutTunnel(p, tunnelEntrance, tunnelExit));\n        scene = smin(scene, sdTunnel(p, tunnelEntrance, tunnelExit), 2.0);\n    }\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvec3 material(in vec3 p, in vec3 n) {\n    p.xz = fract(p.xz / 16.0);\n    vec2 uv = p.xz;\n\n    vec3 tex1 = texture(iChannel1, uv).rgb;\n    vec3 tex2 = texture(iChannel2, uv).rgb;\n    vec3 tex3 = texture(iChannel3, uv).rgb;\n\n    return mix(mix(tex3, tex2, max(0.0, -n.y)), tex1, max(0.0, n.y));\n}\n\nmat3 getCamera(in vec2 viewDirection) {\n    // Turns yaw/pitch rotations into matrix\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),\n                vec3(s.x *  c.y, s.y, -c.x *  c.y));\n}\n\nmat2x3 getRay(in vec2 uv, in vec3 viewPosition, in mat3 camera) {\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    return mat2x3(viewPosition,\n                  rayDirection);\n}\n\nmat2x4 traceRay(in mat2x3 ray) {\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = ray[0] + ray[1] * distanceTraveled;\n        float sceneDistance = mapScene(position);\n        if (abs(sceneDistance) < MIN_HIT_DISTANCE * (distanceTraveled + 1.0)) {\n            vec3 normal = getNormal(position);\n            return mat2x4(position, 1.0,\n                            normal, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            return mat2x4(0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0);\n        }\n\n        distanceTraveled += sceneDistance;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 viewPosition = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    mat2x3 ray = getRay(uv, viewPosition, camera);\n\n    mat2x4 traceInfo = traceRay(ray);\n    if (traceInfo[0].w > 0.0) {\n        fragColor.rgb += material(traceInfo[0].xyz, traceInfo[1].xyz); // Apply material\n        fragColor.rgb *= max(AMBIENT, dot(traceInfo[1].xyz, LIGHT)); // Diffuse\n    }\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float mapScene(in vec3 p) {\n    float bbox = max(abs(p.x), abs(p.z)) - 50.0;\n    float scene = max(abs(p.y + fnoise2D(p.xz)) - GROUND_THICKNESS, bbox);\n\n    // Draw each tunnel\n    float currentIndex = getCurrentIndex() + 3.0;\n    for (float i=0.0; i < currentIndex; i += 3.0) {\n        vec3 tunnelEntrance = getTunnelEntrance(int(i));\n        vec3 tunnelExit = getTunnelExit(int(i));\n        scene = max(scene, sdCutTunnel(p, tunnelEntrance, tunnelExit));\n        scene = smin(scene, sdTunnel(p, tunnelEntrance, tunnelExit), 2.0);\n    }\n\n    return scene;\n}\n\nmat3 getCamera(in vec2 viewDirection) {\n    // Turns yaw/pitch rotations into matrix\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),\n                vec3(s.x *  c.y, s.y, -c.x *  c.y));\n}\n\nmat2x3 getRay(in vec2 uv, in vec3 viewPosition, in mat3 camera) {\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    return mat2x3(viewPosition,\n                  rayDirection);\n}\n\nmat2x4 traceRay(in mat2x3 ray) {\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = ray[0] + ray[1] * distanceTraveled;\n        float sceneDistance = mapScene(position);\n        if (abs(sceneDistance) < MIN_HIT_DISTANCE * (distanceTraveled + 1.0)) {\n            return mat2x4(     position, 1.0,\n                          0.0, 0.0, 0.0, 0.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            return mat2x4(0.0, 0.0, 0.0, 0.0,\n                          0.0, 0.0, 0.0, 0.0);\n        }\n\n        distanceTraveled += sceneDistance;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    ivec2 address = ivec2(fragCoord);\n    if (address == VIEW_POSITION_ADDR) {\n        fragColor.xyz = vec3(0.0, 10.0, 0.0);\n    }\n\n    if (address == VIEW_DIRECTION_ADDR) {\n        fragColor.xy = vec2(0.0, -QUARTER_PI); // pi/4 radians = 45 degrees\n    }\n\n    if (address == CURRENT_INDEX_ADDR) {\n        fragColor.x = -3.0;\n    }\n\n    if (iFrame > 0) {\n        fragColor = vec4(texelFetch(iChannel0, address, 0).xyz, 1.0);\n        if (address == VIEW_POSITION_ADDR) {\n            // Flythrough controls\n            vec3 viewPosition = getViewPosition();\n            vec2 viewDirection = getViewDirection();\n            mat3 camera = getCamera(viewDirection);\n\n            fragColor = vec4(viewPosition, 1.0);\n\n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * TRAVEL_SPEED;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * TRAVEL_SPEED;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * TRAVEL_SPEED;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * TRAVEL_SPEED;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = getViewDirection();\n            bool mouseClick = mouseDown();\n            bool pointerHit = false;\n            if (mouseDown()) {\n                // Trace a ray from the mouse to the scene\n                vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 viewPosition = getViewPosition();\n                mat3 camera = getCamera(viewDirection);\n\n                mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n                pointerHit = bool(clickTraceInfo[0].w);\n\n                vec2 mouseRotation = mousePosition * TWO_PI * ROTATION_SPEED;\n                viewDirection += mouseRotation;\n            }\n\n            // Whether the pointer has hit anything is conveniently (or inconveniently?) squashed in as well\n            fragColor = vec4(viewDirection, pointerHit, 1.0);\n        }\n\n        if (address == DIG_START_ADDR) {\n            fragColor = vec4(getDigStart(), 1.0);\n\n            if (!userIsDigging() && mouseDown()) {\n                // Trace a ray from the mouse to the scene\n                vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 viewPosition = getViewPosition();\n                vec2 viewDirection = getViewDirection();\n                mat3 camera = getCamera(viewDirection);\n\n                mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n\n                if (bool(clickTraceInfo[0].w)) {\n                    fragColor.xyz = clickTraceInfo[0].xyz;\n                }\n            }\n        }\n\n        if (address == DIG_DIRECTION_ADDR) {\n            fragColor = vec4(getDigDirection(), 1.0);\n\n            // Generate a ray from the mouse position\n            vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 viewPosition = getViewPosition();\n            vec2 viewDirection = getViewDirection();\n            mat3 camera = getCamera(viewDirection);\n\n            mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n\n            if (!userIsDigging() && mouseDown()) {\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n                if (bool(clickTraceInfo[0].w)) {\n                    fragColor.xyz = mouseRay[1].xyz;\n                }\n            }\n        }\n\n        if (address == CURRENT_INDEX_ADDR) {\n            fragColor = vec4(getCurrentIndex(), getDigTimestamp(), 0.0, 1.0);\n\n            if (!userIsDigging() && mouseDown()) {\n                // Trace a ray from the mouse to the scene\n                vec2 mousePosition = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 viewPosition = getViewPosition();\n                vec2 viewDirection = getViewDirection();\n                mat3 camera = getCamera(viewDirection);\n\n                mat2x3 mouseRay = getRay(mousePosition, viewPosition, camera);\n                mat2x4 clickTraceInfo = traceRay(mouseRay);\n                if (bool(clickTraceInfo[0].w)) {\n                    // Move onto new tunnel\n                    fragColor.x += 3.0; // Update texture location\n                    fragColor.y = iTime; // Creation timestamp (conveniently (or inconveniently?) squashed in)\n                }\n            }\n        }\n\n        int currentIndex = int(getCurrentIndex());\n        if (address.y == 1 && address.x <= currentIndex + 3) {\n            // Index for tunnel data (existence, entrance, exit)\n            int dataIndex = address.x % 3;\n            // Starting index for tunnel data\n            int tunnelIndex = address.x - dataIndex;\n            bool isTunnel = tunnelExists(tunnelIndex);\n            bool isCurrent = tunnelIndex == currentIndex;\n            if (dataIndex == 0) {\n                // Existence\n                fragColor = vec4(isTunnel, 0.0, 0.0, 1.0);\n                if (isCurrent) {\n                    fragColor.x = 1.0;\n                }\n            }\n\n            if (dataIndex == 1) {\n                // Entrance\n                if (isTunnel) {\n                    fragColor = vec4(getTunnelEntrance(tunnelIndex), 1.0);\n                }\n\n                if (isCurrent) {\n                    fragColor = vec4(getDigStart(), 1.0);\n                }\n            }\n\n            if (dataIndex == 2) {\n                // Exit\n                if (isTunnel) {\n                    fragColor = vec4(getTunnelExit(tunnelIndex), 1.0);\n                }\n\n                if (isCurrent && userIsDigging()) {\n                    fragColor.xyz = getDigStart() + getDigDirection() * (iTime - getDigTimestamp()) * DIG_SPEED;\n                }\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Environment constants:\nconst vec3 LIGHT    = vec3(-0.58, 0.58, 0.58);\nconst float AMBIENT = 0.3;\n\nconst float GROUND_THICKNESS = 1.5;\nconst float TUNNEL_RADIUS    = 5.0;\nconst float WALL_THICKNESS   = 0.1;\n\n// Raymarching constants:\nconst vec3 GRADIENT_STEP       = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 500.0;\nconst float MIN_HIT_DISTANCE   = 0.01;\nconst int MAX_ITERATIONS       = 100;\nconst float FOCAL_LENGTH       = 1.0;\n\n// Math constants:\nconst float TWO_PI     = 6.2832;\nconst float QUARTER_PI = 0.7854;\n\n// User control speeds:\nconst float TRAVEL_SPEED   = 0.5;\nconst float ROTATION_SPEED = 0.01;\nconst float DIG_SPEED      = 2.0;\n\n// Addresses to viewing data:\nconst ivec2 VIEW_POSITION_ADDR  = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\nconst ivec2 DIG_START_ADDR      = ivec2(2, 0);\nconst ivec2 DIG_DIRECTION_ADDR  = ivec2(3, 0);\nconst ivec2 CURRENT_INDEX_ADDR  = ivec2(4, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_RIGHT = 39;\nconst int KEY_LEFT  = 37;\n\n#define getViewPosition()            texelFetch(iChannel0,  VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection()           texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define userIsDigging()         bool(texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).z)\n#define getDigStart()                texelFetch(iChannel0,      DIG_START_ADDR, 0).xyz\n#define getDigDirection()            texelFetch(iChannel0,  DIG_DIRECTION_ADDR, 0).xyz\n#define getDigTimestamp()            texelFetch(iChannel0,  CURRENT_INDEX_ADDR, 0).y\n\n#define getCurrentIndex()            texelFetch(iChannel0,  CURRENT_INDEX_ADDR, 0).x\n#define tunnelExists(addr)      bool(texelFetch(iChannel0,      ivec2(addr, 1), 0).x)\n#define getTunnelEntrance(addr)      texelFetch(iChannel0,  ivec2(addr + 1, 1), 0).xyz\n#define getTunnelExit(addr)          texelFetch(iChannel0,  ivec2(addr + 2, 1), 0).xyz\n\n#define mouseDown()             iMouse.z > 0.0\n\n#define keyUpPressed()          bool(texelFetch(iChannel1,    ivec2(   KEY_UP, 0), 0).x)\n#define keyDownPressed()        bool(texelFetch(iChannel1,    ivec2( KEY_DOWN, 0), 0).x)\n#define keyRightPressed()       bool(texelFetch(iChannel1,    ivec2(KEY_RIGHT, 0), 0).x)\n#define keyLeftPressed()        bool(texelFetch(iChannel1,    ivec2( KEY_LEFT, 0), 0).x)\n\nfloat noise2D(in vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise2D(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = noise2D(cell);\n    float br = noise2D(cell + vec2(1.0, 0.0));\n    float tl = noise2D(cell + vec2(0.0, 1.0));\n    float tr = noise2D(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat fnoise2D(in vec2 p) {\n    p *= 0.1;\n\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < 4.0; octave++) {\n        value += snoise2D(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale * 5.0;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat noise3D(in vec3 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise3D(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise3D(cell);                       // Left, Down, Back\n    float rdb = noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise3D(in vec3 p) {\n    p *= 0.5;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < 2.0; octave++) {\n        value += snoise3D(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\n// Inigo Quilez's polynomial smooth minimum from https://iquilezles.org/articles/smin:\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdCutTunnel(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return TUNNEL_RADIUS - length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdTunnel(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 ba = a - b;\n    vec2 sp = vec2(atan(ba.z, ba.x), atan(ba.y, length(ba.xz)));\n    vec4 cs = vec4(cos(sp), sin(sp));\n\n    p -= b;\n    p.xz *= mat2(cs.x, cs.z, -cs.z, cs.x);\n    p.xy *= mat2(cs.y, cs.w, -cs.w, cs.y);\n\n    vec2 size = vec2(TUNNEL_RADIUS, length(b - a));\n    vec2 pr = vec2(length(p.yz), p.x);\n\n    float tunnel = pr.y < 0.0 ? abs(length(pr) - size.x) : pr.y < size.y ? abs(abs(pr.x) - size.x) : length(abs(pr - vec2(0.0, size.y)) - vec2(size.x, 0.0));\n    return tunnel - WALL_THICKNESS - fnoise3D(p);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 274, 274, 805], [807, 807, 834, 834, 1117], [1119, 1119, 1156, 1156, 1413], [1415, 1415, 1454, 1499, 1720], [1722, 1722, 1787, 1787, 1953], [1955, 1955, 1987, 1987, 2629], [2631, 2631, 2686, 2686, 3186]], "test": "untested"}
{"id": "wl3cRl", "name": "Spot light", "author": "iY0Yi", "description": "I came up with the idea of creating a spotlight by masking the directional light, so I gave it a try.\nmouse enabled.", "tags": ["light", "spotlight", "spot"], "likes": 9, "viewed": 495, "published": 3, "date": "1609696163", "time_retrieved": "2024-07-30T19:47:19.921726", "image_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\ncam0.position = vec3(-63.9759, 73.6247, 30.6849);\n\tcam0.quaternion = vec4(0.2018, -0.3114, -0.7792, 0.5051);\n\tcam0.fov = 0.1622;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(0.0, 0.3695, 0.9292));\n    R(lit0.direction.xz, iTime*.5);\n\tlit0.color = vec3(0.9372, 0.9335, 1.0);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.0, -0.3695, -0.9292));\n\tlit1.color = vec3(0.0066, 0.0193, 0.0254);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid perspectiveCam(vec2 uv){\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(42,64,42)*3.;\n    if(iMouse.z>0.)\n\tpos = vec3(42.*sin(iMouse.x/iResolution.x*TAU), 64.*iMouse.y/iResolution.y, 42.*cos(iMouse.x/iResolution.x*TAU))*8.;\n\tvec3 target = vec3(0,0,0);\n    vec3 dir = normalize(pos-target);\n    float fov = cam0.fov;\n\n    vec3 cw = normalize(dir);\t\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));;\n}\nvoid camera(vec2 uv){\n\n\tperspectiveCam(uv);\n\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdScene(vec3 p, bool sha){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp000 = p;\n\tcp000.xyz += vec3(-1.5, -1.0, -1.5);\n\tpRepLimited(cp000.z, 6.0, 25.);\n\tpRepLimited(cp000.x, 6.0, 25.);\n\n\td = sdPlane(p);\n    \n    // sdFakeCapsule\n\t{\n\t\tvec3 tp = cp000+vec3(0.5, -0.5154, 0.0);\n\t\tvec3 trp = cp000+vec3(0.5, -0.5154, 0.0);\n\t\tvec3 dim = vec3(0.007, 3.4345, 0.9421);\n\t\tfloat td = MAX_DIST;\n\n\t\tfloat r = max(dim.x, dim.z);\n\t\tfloat c = dim.y*.5;\n\t\tfloat elg = c-min(.5,c);\n\t\ttrp.y -= clamp(trp.y,-elg,elg);\n\t\t\n\t\tfloat a = .5*trp.y*trp.y+.5;\n\t\tfloat b = abs(trp.y);\n\t\ttrp.y = b<1. ? a : b;\n\t\t\n\t\ttrp.y -= min(.5,c);\n\t\ttd = length(trp)-r;\n\t\td=fOpUnionSmooth(td, d, 0.087);\n\t}\n\tres = v4OpUnion(vec4(d, MAT_ERNST1), res);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST1), res, 0.01);\n    \n    if(!sha){\n        vec3 lightTarget=vec3(0.,1.,0.);\n        float lightDistance = s2u(sin(iTime))*30.;\n        vec3 lightPos=lightTarget+lit0.direction*lightDistance;\n        vec3 q = p-lightPos;\n        \n        R(q.xz, -atan(lit0.direction.x, lit0.direction.z)-HALF_PI);\n        res = v4OpUnion(vec4(max(length(q)-1.5, (q).x), vec3(1)), res);\n    }\n\treturn res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p, false);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p, false).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.), false).x-c,\n\t\tsdScene(p+vec3(0.,e,0.), false).x-c,\n\t\tsdScene(p+vec3(0.,0.,e), false).x-c)\n\t);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t, true).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// Phong specular\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) / (2.*PI);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    return 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) / (2.*PI);\n    vec3 h  = normalize(-vd+ld);\n    return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    vec3 h  = normalize(-vd+ld);\n    return 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0f-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n#define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n    else if(distance(res.yzw,vec3(1))<.2){\n        renDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = vec3(1);\n    }\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n        // Spot light\n        // *********************************************************************\n        vec3 lightTarget=vec3(0.,1.,0.);\n        float lightDistance = s2u(sin(iTime))*30.;\n\t\tvec3 lightPos=lightTarget+lit0.direction*lightDistance;\n        float falloff=max(0., dot(normalize(p-lightPos), -lit0.direction));\n        \n        // attenuation calc from:\n        // https://learnopengl.com/Lighting/Light-casters\n        float d = distance(lightPos, p);\n        const float KL = .0005;\n        const float KQ = .01;\n\t\tfloat attenuation = 1./(1.+KL*d+KQ*(d*d));\n        \n        float power = 2.;\n        falloff = pow(smoothstep(0.9, 1., falloff), power) * attenuation * 15.;\n\t\tfalloff = sms(0.,1.,falloff);\n        // *********************************************************************\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n        lamb1*=falloff;\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\tfloat shininess = .2;\n\t\tfloat intensity = .75;\n\t\trenDat.result*= renDat.albedo;\n\n\t\tfloat spec = ggx(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity*step(0.1,p.y)*falloff;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t}\n}\n\nvec3 ACESFilm(vec3 x){\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    renDat.result = ACESFilm(renDat.result);\n\trenDat.result = pow(renDat.result, vec3(.9));\n\tfragColor = vec4(renDat.result, 1.);\n}", "image_inputs": [], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.0)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define ITERATION 100\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(0.8, 0.8, 0.8)\n#define MAT_ERNST1 vec3(0.6921)\n\n#define AMB_COL vec3(.5)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(0.0, 0.0, 0.0)\n#define FOG_START -0.63\n#define FOG_POW 1.0\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 686, 686, 744], [895, 895, 907, 907, 1471], [1472, 1580, 1618, 1618, 1694], [1695, 1695, 1724, 1724, 2276], [2277, 2277, 2298, 2298, 2323], [2325, 2414, 2439, 2439, 2454], [2456, 2456, 2494, 2494, 2513], [2515, 2515, 2551, 2551, 2574], [2576, 2576, 2622, 2622, 2707], [2709, 2709, 2753, 2753, 2880], [2882, 2958, 3022, 3022, 3387], [3389, 3479, 3510, 3510, 4704], [4706, 4778, 4795, 4795, 5097], [5099, 5171, 5191, 5191, 5390], [5392, 5464, 5493, 5493, 5978], [5980, 6070, 6135, 6135, 6314], [6315, 6315, 6383, 6383, 6438], [6440, 6554, 6624, 6624, 6770], [6771, 6771, 6834, 6834, 6919], [6921, 7029, 7059, 7059, 7093], [7094, 7094, 7155, 7155, 7679], [7742, 7814, 7828, 7828, 10133], [10135, 10135, 10157, 10157, 10279], [10281, 10353, 10407, 10407, 10870]], "test": "untested"}
{"id": "ttcyRl", "name": "counteratction with mouse", "author": "gschian0", "description": "vibes", "tags": ["crazycolors"], "likes": 2, "viewed": 279, "published": 3, "date": "1609694197", "time_retrieved": "2024-07-30T19:47:20.690670", "image_code": "// Fork of \"counteraction\" by gschian0. https://shadertoy.com/view/WldyRB\n// 2021-01-03 17:15:16\n\n#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586\n\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = abs((2.*fragCoord.xy/iResolution.xy*2.-2.));\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    st *= vec2(length(0.01*st),atan(st.y,st.x/iTime));\n    float noise1 = noise(st+0.3*iTime);\n    st.x *= iResolution.x/iResolution.y;\n    st.x += sin(0.3*1.0*iMouse.x*st.y+iTime)*0.5+0.5;\n   // st.y = sin(2.0*st.x-u_time);\n    st *= vec2(length(0.3*iMouse.y*st.x*st.y*noise1+sin(st.y*iTime*iMouse.y)*0.5+0.5),atan(st.y+sin(st.x*iTime*.003)*0.5+-0.5,st.x-sin(iTime*.03*noise1)*0.5+0.5)/PI/8.*noise1);\n    float d = length(st-vec2(0.003*(1.*sin(sin(st.y+sin(iTime)*0.01*noise1)))*0.5+0.5,0.18*(sin(st.x+sin(iTime)*0.5+0.5*.01*noise1+0.3*0.5))));\n    st.y+= log(abs(sin(iTime*.3)));\n    st.x += log(abs(sin(iTime*0.3)));\n    float circle = 1.-smoothstep(0.6,0.99,d);\n    \n//    for(float i = 0.07; i < 1.0; i += .1){\n//    \n//        circle += smoothstep(0.06+i, 0.061,d+i);\n//    }\n    vec3 color = vec3(abs(cos(1.0*st.y/d+iTime)),abs(sin(1.0*st.x/d-iTime)),abs(cos(10.0*st.y-st.x/d-iTime)));\n    //white\n    fragColor = 1.-vec4(vec3(circle)*color,1.0);\n    //fragCoord /= iResolution.y;  \n    fragColor = pow(fragColor,vec4(1./2.2));\n    //black\n     // gl_FragColor = vec4(vec3(circle)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 198, 198, 268], [270, 270, 290, 290, 529], [531, 531, 585, 585, 1791]], "test": "untested"}
{"id": "3t3czs", "name": "subiendo a cielo de noche", "author": "jorge2017a1", "description": "subiendo a cielo de noche", "tags": ["subiendoacielodenoche"], "likes": 5, "viewed": 260, "published": 3, "date": "1609692386", "time_retrieved": "2024-07-30T19:47:21.606222", "image_code": "//por jorge2017a1- 03/ene/2021\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\nvec2 cilindrobase(vec3 p )\n{\n    float tau = atan(1.0) * 8.0;\n    p= rotate_x(p , radians(90.0));\n    float numItem=8.0;\n    float ang=tau / numItem;\n    vec3 p2= opAngRep(p, ang );\n    float sb0= sdCylinderXY(p-vec3(0.0,0.0,0.0), vec2(10.0,0.5) );  //base\n    float sb1= sdCylinderXY(p2-vec3(10.0,0.0,2.0), vec2(0.5,3.0) ); //postes rep\n    float sb3A= sdCylinderXY(p-vec3(0.0,0.0,4.0), vec2(10.0,0.5) ); //anillo a\n    float sb3B= sdCylinderXY(p-vec3(0.0,0.0,4.0), vec2(9.0,0.6) );  //anillo a\n    float sb3C= sdCylinderXY(p-vec3(0.0,0.0,4.0), vec2(6.0,12.0) ); //centro\n    sb3A= differenceSDF(sb3A, sb3B);\n    vec2 resp=vec2(9999.9,-1.0);\n    resp=opU2(resp, vec2(sb0, 1.0) );\n    resp=opU2(resp, vec2(sb1, 2.0) );\n    resp=opU2(resp, vec2(sb3A, 12.0) );\n    resp=opU2(resp, vec2(sb3C, 11.0) );\n    return resp;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), clamp(0.0, radians(15.0), 0.5*sin(iTime*0.5)) );\n    p= rotate_y(p-vec3(0.0,0.0,0.0), clamp(sin(iTime*0.5),0.0, (20.0) ) );\n\t\n\tvec3 q=p;\n    float cx=47.0;\n    float cy=12.0;\n    float cz=50.00;\n    q.y = mod(q.y+0.5*cy,cy)-0.5*cy;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    p=q;\n\t\n    \n  \n     vec2 cb1= cilindrobase(p);\n     res =opU3(res, vec3(cb1.x,cb1.y,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n    vec3 ref = reflect(lig, normal);\n    \n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\tfloat fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n   return  final;\n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0,7.0+t,-25.0+5.0*sin(t*0.25));\n    //ro= getMouse(ro);       \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3czs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[459, 459, 495, 495, 516], [517, 517, 549, 549, 633], [634, 634, 673, 673, 768], [769, 769, 808, 808, 903], [904, 904, 943, 943, 1038], [1040, 1084, 1131, 1131, 1158], [1160, 1160, 1203, 1203, 1230], [1232, 1232, 1280, 1280, 1308], [1309, 1380, 1414, 1414, 1512], [1513, 1513, 1547, 1547, 1639], [1640, 1640, 1674, 1674, 1766], [1837, 1837, 1863, 1863, 1917], [1919, 1919, 1953, 1953, 2126], [2129, 2129, 2157, 2157, 2946], [2948, 2988, 3013, 3013, 3640], [3644, 3644, 3730, 3730, 4446], [4452, 4503, 4527, 4527, 4715], [4716, 4779, 4812, 4812, 5273], [5275, 5329, 5365, 5365, 5599], [5600, 5735, 5815, 5815, 6092], [6187, 6187, 6280, 6280, 6380], [6385, 6434, 6491, 6491, 7721]], "test": "untested"}
{"id": "3l3cRs", "name": "raymarching infinite spheres", "author": "rahul897", "description": "first try at infinite spheres", "tags": ["raymarching"], "likes": 2, "viewed": 269, "published": 3, "date": "1609688678", "time_retrieved": "2024-07-30T19:47:22.521774", "image_code": "#define MaximumRaySteps 100\n#define MinimumDistance .01\n\n\nfloat DE(vec3 p)\n{\n  p = mod(p,1.0)-vec3(0.5);\n  return length(p)-0.25;\n}\n\nfloat trace(vec3 from, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tint steps;\n\tfor (steps=0; steps < MaximumRaySteps; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat distance = DE(p);\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t}\n\treturn 1.0-float(steps)/float(MaximumRaySteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(-6.*sin(iTime/10.), -6.*sin(iTime/10.), 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = trace(ro, rd);\n    col = vec3(d);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 76, 76, 131], [133, 133, 173, 173, 459], [461, 461, 518, 518, 861]], "test": "untested"}
{"id": "tltyzf", "name": "Radtracing Sphere Movements,fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/wsVBzd[/url]", "tags": ["demoscene", "sphere", "balls", "remix", "glitch", "fork", "weird", "physics", "error"], "likes": 0, "viewed": 312, "published": 3, "date": "1609658713", "time_retrieved": "2024-07-30T19:47:23.437327", "image_code": "//Remixer: 404Glaciergargamel\nconst float GA =3.39; \n\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(-1);\n    vec2 pixel=vec2(.0003*iResolution.y/iResolution.x,.0003),angle=vec2(1,rad);;\n    rad=2.;\n\tfor (int j=1;j<90;j++)\n    {  \n        rad += 2./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-20.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/90.;\n}\n// awesome bokeh dof by Dave Hoskins\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),2.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Remixer: 404Glaciergargamel\n#define maxballs 20\n#define radius 0.4\n// Return a \"random\" number.\nfloat rand(vec2 co)\n{\n    float a = 22.9898;\n    float b = 88.233;\n    float c = 53758.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,4.14);\n    return fract(sin(sn) * c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;   \n    vec4 pos = vec4(1);\n    vec3 spd = vec3(1);\n  \n    if ((fract(iTime/4.43))<=0.006)\n    {\n        pos.x= 3.*rand(-uv+iTime)-2.;\n    \tpos.y= .6*rand( uv+iTime)-2.1;\n        pos.z= 3.*rand(-uv.yx+iTime)-2.; \n        spd.x=.07*rand( uv+iTime);\n        spd.y=.07*rand(-uv+iTime);\n        spd.z=.07*rand( uv.yx+iTime);\n        pos.w = 0.2;\n        if (rand( uv+iTime)>0.7) pos.w=2.0;\n    }    \n    else \n    {\n    \tpos = texture(iChannel0, vec2(float(uv.x),1.)); // get position + type\n        spd = texture(iChannel0, vec2(float(uv.x),2.)).xyz; // get speed  \n//\t\tcalculate touching balls :-)        \n    \tfor (int i = 1; i<maxballs;i++)\n    \t{\n    \t\tvec4 posother = texture(iChannel0, vec2((float(i)+0.6)/iResolution.x,1.));\n            vec3 spdother = texture(iChannel0, vec2((float(i)+0.6)/iResolution.x,2.)).xyz;\n            \n            if(pos.xyz==posother.xyz) continue;\n        \tfloat dista = length(posother.xyz - pos.xyz);\n        \tif (dista < radius * 3.0) \n        \t{\n            pos.xyz= pos.xyz + (posother.xyz-pos.xyz) * radius * 3.001 / dista;  \n            pos.w=posother.w;\n            spd-=0.3*spdother;\n            }\n        }\n    pos.xyz -= spd.xyz;\n    spd.xyz *= 2.;\n    spd.y -= 0.004;\n    // If we reach the bottom, invert the speed in the y direction.\n    if (pos.y >= 0.8) { spd.y = abs(spd.y * .8); }\n    // if (pos.y <= -0.7) { spd.y = -abs(spd.y * .7); }\n    // If we reach left/right wall, invert the speed in the x direction.         \n    if (pos.x >= 2.5) { spd.x = abs(spd.x * .8); }  \n    if (pos.x <= -2.5) { spd.x = -abs(spd.x * .8); }  \n    // If we reach the front/back invert the speed in the z direction.\n    if (pos.z >= 5.) { spd.z = abs(spd.z * .8); }\n    if (pos.z <= -3.) { spd.z = -abs(spd.z * .8); } \n    }\n    if (fragCoord.y == 0.6) fragColor = vec4(pos); // write position\n    else fragColor = vec4(spd,2.);  // write speed  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define maxballs 20\n#define radius 0.4\n\nfloat color = 0.68;\nfloat temp = 0.2;\nfloat temp2 = 2.0;\nfloat temp3 = 0.2;\n\nvec3 pal( in float t)\n{\n    return  2.+0.6*cos(30.*(vec3(2.,2.7,.6)*t+vec3(.1,.25,.3)) );\n}\n// \tsphere\nfloat sphere(vec3 p, vec3 position)\n{\t\n\treturn length(p+position)-radius;\n}\nfloat pattern(vec2 p)\n{\n    p.x += 6.;\n    p.y *= 3.;\n    p = floor(p*3.);\n    p.y += floor(iTime*.2)*27.;\n    p = floor(p);\n    return (sin(p.x*p.y) > .9) ? 3. : 1.09;\n}\nvec3 map(vec3 p)\n{\n\tvec3 d = vec3(1);\n    dmin(d, 2.+p.y,.5+temp*noise(6.*p+iTime), 4.); \t\n    dmin(d, 3.-p.z,(-0.4+1.09*abs(sin(20.*p.y))+2.5*temp*p.y), 1.); \t// back\n    dmin(d, 3.-abs(p.x), -0.40+1.09*abs(sin(6.*p.z))*temp2+.49*abs(cos(6.*p.y)), 4.); \t\t// sides\n    // light tubes\n    vec3 q = abs(p);\n    q.x -= 3.;\n    q.y -= 2.;\n    q.z -= 3.;\n    dmin(d, length(q.xy+0.06)-.06, 2.*temp3*5., 1.); \t\t\n    dmin(d, length(q.yz)-.06, 2.*temp3*5., 1.); \n    dmin(d, length(q.xz)-.06, 2.*temp3*5., 1.); \n\n    for (int i=1; i<maxballs; i++)\n    {\n        vec4 pos = texture(iChannel1, vec2((float(i)+0.6)/iResolution.x,1.));\n  \n        dmin(d,sphere(p,pos.xyz),pos.w,-0.6);\n    }\n    return d;\n}\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(1, .0002);\n\treturn normalize(map(p).x-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if ((fract(iTime/(4.43*5.)))>1.0375)\n    temp=2.;\n    if ((fract(iTime/(4.43*9.)))>0.85)\n    temp2=sin(iTime);\n    if ((fract(iTime/(4.43*3.)))<0.6)\n    temp3=0.4;;\n\n    fragColor =vec4(1.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t// borders :(\n\tif( uv.y>.2 && uv.y<1.0)\n\t{\n    \tfloat t1 = 1., t2 = 1.,t3=1., seed = 1.;\n        // camera\n\t\tvec3 ro1 = vec3(1, 1, -3.), rd1 = normalize(vec3((1.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n        // rotate scene\n\t\tpR(rd1.xz,-.29*sin(0.27*iTime));\n\t\tpR(rd1.yz, .3*sin(0.39*iTime));\n// Cast ray   \n        seed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\n\t\tvec3 scol=vec3(1),m1, m2, m3,  ro2,rd2,nor1, nor2,pos1,pos2,pos3;\n\t    \n\t\tfor( int i = 1; i < 250; i++ )\n\t\t{\n            // every iteration a new seed\n            seed=42.+seed*fract(seed+iTime);  \t\n            // raymarch 1st pass\n           \tpos1 = ro1+rd1*t1;\t\t\n        \tm1 = map(pos1);\n\t\t\tt1+=0.45*(m1.x); \t\n\t\t\t\n            if (m1.x<0.00002) \n            {\n            break;\t\t \n            }\n        }\n        float depth = clamp(0.2*t1-0.5,1.,2.)+0.06;\n        t2=1.;     \n        // bounce\n\t  \tnor1 = normal(pos1); \n       \tfor( int i = 2; i < 200 ; i++ )\n      \t{         \n            // every iteration a new seed\n            seed=42.+seed*fract(seed);            \n\t\t\trd2 = mix(reflect(rd1,nor1),hashHs(nor1,seed),m1.y);\t// reflect depending on material\t\n            pos2 = pos1+ rd2*t2;\n\t\t\tm2 = map(pos2); \n            t2+=.45*(m2.x);\n            scol += pal(m2.z+color)*step(2., m2.y);\n        }\n\t\t//fragColor =vec4(.008*scol+1.*texture(iChannel0, uv).xyz)*.7,.5; // with blur\n        fragColor = clamp(vec4( (0.006*scol+.7*texture(iChannel0,uv).xyz),depth),0.,1.);\n}\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "void dmin(inout vec3 d, float x, float y, float z)\n{\n\tif( x < d.x ) d = vec3(x, y, z);\n}\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(8, 257, 213);\n\tvec4 h=vec4(1, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(4.-3.*p);\n\th=mix(fract(sin(h)*53758.5), fract(sin(h+s.x)*53758.5), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n// hash without sine\nfloat hash11(float p)\n{\n    p = fract(p * .2031);\n    p *= p + 29.19;\n    p *= p + p;\n    return fract(p);\n}\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 88.233 + seed);\n    float v = hash11( 20.873 + seed);\n    float a = 7.2831853 * v;\n    u = 3.0*u - 2.0;\n    return normalize( n + vec3(sqrt(2.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n// rotation\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 149, 149, 428], [429, 466, 520, 520, 631]], "test": "untested"}
{"id": "tldcRX", "name": "Mandelbrot - Explore with UI", "author": "LerpDieRepeat", "description": "Mouse         : Move\nW, A, S, D    : Move\nQ, E             : Zoom\nR, Num 0      : Reset\nF                  : Toggle z0 Animation\n1 - 7             : Change Color Palettes\nNumpad 1 - 9 : Cool Spots I like (#4 reminds me of the islandic vegvisir symbol)", "tags": ["fractal", "julia", "mandelbrot", "complex", "ui", "set", "explore"], "likes": 2, "viewed": 288, "published": 3, "date": "1609642632", "time_retrieved": "2024-07-30T19:47:24.472559", "image_code": "// I always wanted to give fractal shaders a try, so I started with the Hello World of Fractals, the Mandelbrot-Set.\n// This project helped me understand the Mandelbrot-Set a bit more and how to work with complex numbers.\n// I also learned about using buffers for state persistency, which is useful for the user inputs.\n// \n// comment ANIMATE_COLOR to stop color animation\n// uncomment GRID to show a grid overlay\n\n\n#define MAXIMUM_ITERATIONS 200\n#define ANIMATE_COLOR\n//#define GRID\n\n//defining product of imaginary numbers\n#define product_i(a, b) vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)\n\n\nint MandelbrotSet(vec2 z0, vec2 c, int iterMax)\n{\n    float zLength = 0.0;\n    int i = 0;\n    vec2 z = z0; //z.x = real part; z.y = imaginary part\n    \n    // if zLength is bigger than 2 the series diverges, then return the iterations needed\n    // otherwise go until max-iterations, which suggests the series is converging\n    while (zLength <= 2.0 && i < iterMax)\n    {\n        i++;\n        z = product_i(z, z) + c; //zn+1 = zn+c\n        zLength = length(z);     //absolut value of imaginary number z is it's length\n    }\n    return i;\n}\n\n\n// using palettes by inigo quilez : https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 colorGradient(float gradient, int iter, int iterMax, float choose_palette)\n{\n    //vec3 color1 = vec3(0.1, 0.0, 0.6); //blue\n    //vec3 color2 = vec3(1.0, 0.6, 0.0); //orange\n    //vec3 palette = mix(color1, color2, gradient);\n    \n    #ifdef ANIMATE_COLOR\n        gradient += 0.2 * iTime;\n    #endif\n    \n    vec3                     palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if(choose_palette == 2.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if(choose_palette == 3.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if(choose_palette == 4.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if(choose_palette == 5.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if(choose_palette == 6.) palette = pal(gradient, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if(choose_palette == 7.) palette = pal(gradient, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    vec3 col = iter == iterMax ? vec3(0) : palette;\n    return col;\n}\n\n\nfloat grid(vec2 uv, float space, float width)\n{\n    return\n    step(space * 0.5 - width * 0.5, abs(mod(uv.x, space) - space * 0.5)) +\n    step(space * 0.5 - width * 0.5, abs(mod(uv.y, space) - space * 0.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //squaring coordinates and centering\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy))/iResolution.yy;\n    \n    vec4 mouse;\n    mouse = texture(iChannel0, vec2(0.5, 0.5)).rgba; // read movement buffer (and palette)\n    uv = uv * mouse.z + mouse.xy;\n    \n    vec2 z0 = vec2(0.0, 0.0);\n    \n    // animating z0 in a circle when toggling F\n    int KEY_F = 70;\n    if(bool(texelFetch(iChannel1, ivec2(KEY_F,2),0).x))\n    {\n        z0 = vec2(0.05 * sin(iTime), 0.05 * cos(iTime));\n    }\n    \n    int iterMax = MAXIMUM_ITERATIONS;\n    \n    int iterations = MandelbrotSet(z0, uv, iterMax);\n    \n    float gradient = pow(float(iterations) / (0.5 * float(iterMax)), 0.5);\n    \n    vec3 finalColor = colorGradient(gradient, iterations, iterMax, mouse.a);\n\n    #ifdef GRID\n        finalColor += vec3(clamp(grid(uv, 1.0, 0.02) + grid(uv, 0.1, 0.005), 0.0, 0.2));\n    #endif\n\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Movement Input Buffer A\n\nconst int KEY_R     = 82;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\n\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_6     = 54;\nconst int KEY_7     = 55;\n\nconst int KEY_NUM0  = 96;\nconst int KEY_NUM1  = 97;\nconst int KEY_NUM2  = 98;\nconst int KEY_NUM3  = 99;\nconst int KEY_NUM4  = 100;\nconst int KEY_NUM5  = 101;\nconst int KEY_NUM6  = 102;\nconst int KEY_NUM7  = 103;\nconst int KEY_NUM8  = 104;\nconst int KEY_NUM9  = 105;\n\nbool IsPressed(int key)\n{\n   return bool(texelFetch(iChannel1, ivec2(key,0),0).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // mouse input centered and scaled to go from -1 to 1\n    vec2 mouse = vec2(0);\n    if(iMouse.z > 0.0)\n    {\n        mouse = 2.0 * (iMouse.xy - (0.5 * iChannelResolution[0].xy)) / iChannelResolution[0].xy;\n    }\n    vec3 movement;          // rg = mouse; b = zoom;\n    float choose_palette;   // palette\n    float moveSpeed = 0.03;\n    float zoomSpeed = 0.05;\n    float borderThreshold = 0.3;\n\n\n    if (iFrame == 0) // Reset\n    {\n        // initial values\n        movement.rg = vec2(-0.5, 0.0);  // position\n        movement.b = 2.3;               // zoom\n        choose_palette = 2.0;           // palette\n    }\n    else\n    {\n        // read last buffer\n        movement = texture(iChannel0, vec2(0.0)).rgb;\n\n        // zoom\n        if(IsPressed(KEY_E)){movement.b *= 1.0 - zoomSpeed;} // Zoom In\n        if(IsPressed(KEY_Q)){movement.b *= 1.0 + zoomSpeed;} // Zoom Out\n\n        // movement keys\n        if(IsPressed(KEY_W)){movement.rg += vec2( 0,  1) * moveSpeed * movement.b;} //UP\n        if(IsPressed(KEY_S)){movement.rg += vec2( 0, -1) * moveSpeed * movement.b;} //DN\n        if(IsPressed(KEY_A)){movement.rg += vec2(-1,  0) * moveSpeed * movement.b;} //L\n        if(IsPressed(KEY_D)){movement.rg += vec2( 1,  0) * moveSpeed * movement.b;} //R\n\n        // movement mouse\n        if (length(mouse) < borderThreshold)\n        {\n            movement.rg += vec2(0);\n        }\n        else\n        {\n            // add to buffer: mouse-position, scaled by speed, masked, scaled to compensate zoom\n            movement.rg += mouse * moveSpeed * smoothstep(borderThreshold, 1.0, length(mouse)) * movement.b;\n        }\n\n        choose_palette = texture(iChannel0, vec2(0)).a;\n        if(IsPressed(KEY_1)){choose_palette = 1.;}\n        if(IsPressed(KEY_2)){choose_palette = 2.;}\n        if(IsPressed(KEY_3)){choose_palette = 3.;}\n        if(IsPressed(KEY_4)){choose_palette = 4.;}\n        if(IsPressed(KEY_5)){choose_palette = 5.;}\n        if(IsPressed(KEY_6)){choose_palette = 6.;}\n        if(IsPressed(KEY_7)){choose_palette = 7.;}\n    }\n    \n    if(IsPressed(KEY_NUM0) || IsPressed(KEY_R)){movement = vec3(-0.5, 0.0, 2.3);}\n\n    // cool spots\n    if(IsPressed(KEY_NUM1)){movement = vec3(-0.106, -0.925,   0.013);}\n    if(IsPressed(KEY_NUM2)){movement = vec3(-0.4692, 0.5412,  0.001);}\n    if(IsPressed(KEY_NUM3)){movement = vec3(-0.4661, 0.54355, 0.0013);}\n    if(IsPressed(KEY_NUM4)){movement = vec3( 0.4071, 0.60635, 0.0008);}\n    if(IsPressed(KEY_NUM5)){movement = vec3( 0.3505, 0.5815,  0.01);}\n    if(IsPressed(KEY_NUM6)){movement = vec3(-1.112, -0.2293,  0.0025);}\n    \n    if(IsPressed(KEY_NUM7)){movement = vec3(-1.2275, 0.165,   0.008);}\n    if(IsPressed(KEY_NUM8)){movement = vec3(-0.1045, 0.8845,  0.004);}\n    if(IsPressed(KEY_NUM9)){movement = vec3( 0.298, -0.0195,  0.008);}\n\n    fragColor = vec4(movement, choose_palette);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[602, 602, 651, 651, 1143], [1146, 1220, 1288, 1288, 1331], [1334, 1334, 1415, 1565, 2629], [2632, 2632, 2679, 2679, 2841], [2844, 2844, 2901, 2942, 3809]], "test": "untested"}
{"id": "ttdcRX", "name": "Fractal canyons", "author": "jarble", "description": "This fractal terrain is based on my [url=https://www.shadertoy.com/view/wstfR4]\"City flight\"[/url] shader.", "tags": ["fractal", "terrain", "mountain", "canyon"], "likes": 4, "viewed": 304, "published": 3, "date": "1609641940", "time_retrieved": "2024-07-30T19:47:25.242501", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(surface_color(sin(worldDir+iTime/4.0)).yzx,0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = .5;\n\tvec3 eye = vec3(iTime*speed,-.1,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0)-1.0, cos(iTime*speed/10.0)*3.14), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = (length(eye-dmap));\n    l0 = l0*.9;\n\n    //float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w;\n\n\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, min(0.0,abs(l0-dist)*.9));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(p1/i+p1.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    p += vec3(1,-10,170);\n    float result = 0.0;\n    for(float i = 1.0; i < 100.0; i *= -5.0){\n        float p1 = planet_surface(p*i,i)/(i);\n        result = max(result+p1-p.y*(1.1+sin(length(p.xz)/50.0/i)), -p1);\n        p.y /= (abs(i+1.0+sin((p.x+p.z)/size)));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/8.0-.001;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 10.0;\n    float p1 = planet_surface(p,3.0);\n    float p2 = planet_surface(p,5.0);\n    float p3 = planet_surface(p,7.0);\n    return sin((vec3(p2-p3,p2,p2-p3)))/10.0+vec3(.5,.4,.3)*1.5;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(in vec3 p) {\n\tconst vec2 e = vec2(EPSILON, 0);\n\treturn normalize(vec3(sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy), sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),\tsceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)));\n}\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 482, 573, 573, 891], [905, 905, 932, 932, 1081], [1083, 1083, 1140, 1140, 1859]], "test": "untested"}
{"id": "tltcRX", "name": "texture as wavetable sound 3", "author": "MacroMachines", "description": "experiment with using the texture inputs as wavetables.  think of each row of pixels as a waveform where left channel is red and right is green.  this should be fun!\nneed to try and window the edges with a cosine.", "tags": ["sound", "texture", "wavetable"], "likes": 4, "viewed": 319, "published": 3, "date": "1609640443", "time_retrieved": "2024-07-30T19:47:26.082255", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(texture(iChannel0, uv).rrr,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "\nvec2 mainSound( in int samp, float time )\n{\n    float Hz = 80.0;\n    float Scan = 0.250;\n    float timeMod = fract(time*Hz)*1.0;\n    float timeScan = floor(time*Hz)/Hz*Scan*1.0;\n    \n    //float timeScan = floor(time*Hz/Scan)/Hz*Scan;\n    \n    //return cos(timeMod*timeScan)*sin(vec2( texture(iChannel0,vec2(timeMod,timeScan)  ).rg*4.0-2.0 )*150.0);\n    return texture(iChannel0,vec2(timeMod,timeScan)).rr;\n}", "sound_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltcRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 152]], "test": "untested"}
{"id": "3ltyzX", "name": "Donald Duck", "author": "leon", "description": "Donald Duck from Walt Disney.\n", "tags": ["disney", "donald"], "likes": 24, "viewed": 524, "published": 3, "date": "1609635273", "time_retrieved": "2024-07-30T19:47:26.957914", "image_code": "// Donald Duck from Walt Disney\n// geometry practice, animation test and lighting playground\n//\n// by Leon Denise 2021.01.03\n// \n// thanks to Inigo Quilez, Dave Hoskins, Koltes, NuSan\n// for sharing useful lines of code\n//\n// Licensed under hippie love conspiracy\n\nfloat map(vec3 p);\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nint material;\nconst int mat_skin = 0;\nconst int mat_eye_globe = 1;\nconst int mat_eye_pupil = 2;\nconst int mat_eye_iris = 3;\nconst int mat_beak = 4;\nconst int mat_ear = 5;\nconst int mat_hat_bottom = 6;\nconst int mat_hat_top = 7;\nconst int mat_floor = 8;\n\nfloat rough;\nvec2 mouse;\n\nfloat donald (vec3 p, float scale)\n{\n    float d,dd,ddd,x,y,z;\n    vec3 pp;\n    material = 0;\n    \n    p = p / scale;\n    \n    // head\n    d = sdSphere(p,0.45);\n    \n    // hair\n    dd = sdCone(rx(t(p,0,.5,.3), -.5), vec2(sin(1.4),cos(1.4)), .2);\n    d = u(d, dd, .1);\n    dd = sdCone(rz(rx(t(p,0.1,.5,.3), -.5), .5), vec2(sin(1.4),cos(1.4)), .2);\n    d = u(d, dd, .03);\n    \n    // cheeks\n    dd = sdSphere(t(ax(p),.3,-.2,.3),0.2);\n    d = u(d, dd, .1);\n    \n    // eye lids\n    vec3 axsmooth = vec3(sqrt(p.x*p.x+0.0005),p.yz);\n    dd = sdLink(t(axsmooth,.2,0,.4), .2,.15, .05);\n    d = u(d, dd, .1);\n        \n    // eye globes\n    pp = rx(tz(atx(p,0.2),0.5), .2);\n    dd = sdEllipsoid(pp, vec3(0.15,0.3,0.05));\n    material = dd < d ? mat_eye_globe : material;\n    d = min(d,dd);\n    \n    // eye pupils\n    pp = t(p, -mouse.x*.2, -mouse.y*.3, 0);\n    pp = rx(tz(atx(pp,0.2),0.5), .2);\n    dd = sdEllipsoid(tz(pp,0.05), vec3(0.04, .1, 0.04)*1.5);\n    material = dd < d ? mat_eye_pupil : material;\n    d = min(d,dd);\n    \n    // beak top\n    pp = t(p,0,-.3,0.5+0.3);\n    pp.y -= 0.05*cos(p.x*0.3*tau*5.);\n    pp.y += 0.05*cos(p.z*0.5*tau*2.)*cos(p.z);\n    dd = sdRoundBox(pp, vec3(.3, 0.01, 0.5), .01);\n    dd = diff(dd, length(pp.xz)-0.4, .1);\n    \n    // beak cheeks\n    pp = t(ax(p), 0.3,-.3,.5);\n    ddd = sdSphere(pp, .1);\n    dd = u(dd, ddd, .1);\n    \n    // beak bottom\n    pp = tz(rx(t(p, 0,-.3,.4), -.5), .3);\n    pp.y += 0.1*cos(p.z*5.+2.);\n    ddd = sdRoundCylinder(pp, .15, .01, .01);\n    dd = u(dd, ddd, .1);\n    \n    material = dd < d ? mat_beak : material;\n    d = min(d, dd);\n    \n    // hat bottom\n    pp = ty(rz(p,.3),.45);\n    dd = sdCylinder(pp,.2,.1);\n    material = dd < d ? mat_hat_bottom : material;\n    d = min(d, dd);\n    \n    // hat top\n    dd = sdRoundCylinder(ty(pp, .2), .2,.1+.2*sin(abs(pp.x)),.01);\n    material = dd < d ? mat_hat_top : material;\n    d = min(d, dd);\n    \n    // hat tail\n    pp = t(pp,.3,.1,0).xzy;\n    dd = max(sdCylinder(pp, .3, .1), -sdCylinder(pp, .28, 1.));\n    pp.y = abs(pp.y);\n    pp.yz *= rot(.5);\n    dd = max(-pp.z, dd);\n    material = dd < d ? mat_hat_bottom : material;\n    d = min(d, dd);\n    \n    return d * scale;\n}\n\nfloat map(vec3 p)\n{\n    float d,dd;\n    material = 0;\n    \n    // donald\n    d = donald(rx(ry(p, -.2+.1*sin(iTime)), .1*cos(iTime)), 1.);\n    \n    // little donalds jumping\n    p.z += 2.5;\n    p.y += .3;\n    p.xz *= rot(-iTime);\n    float c = moda(p.xz, 5.);\n    p.x -= 1.5;\n    p = bounce(p, iTime*4.+c, .6, .8);\n    p.zy *= rot(.3*sin(iTime*8.+c));\n    int m = material;\n    dd = donald(p, .4);\n    material = dd < d ? material : m;\n    d = min(d, dd);\n    \n    return d;\n}\n\nvec3 getColor(vec3 pos, vec3 normal, vec3 ray, float shade)\n{\n    vec3 color = vec3(0);\n    rough = 0.2;\n    switch (material)\n    {\n        // skin\n        case mat_skin:\n        color = vec3(1);\n        break;\n        \n        // hat bottom\n        case mat_hat_bottom:\n        color = vec3(0);\n        break;\n        \n        // hat top\n        case mat_hat_top:\n        color = vec3(0,0,1);\n        break;\n\n        // globe\n        case mat_eye_globe:\n        color = vec3(0.6627, 0.8745, 0.9137);\n        break;\n\n        // pupil\n        case mat_eye_pupil:\n        color = vec3(0);\n        break;\n        \n        // beak\n        case mat_beak:\n        color = vec3(0.8667, 0.7451, 0.0471);\n        break;\n        \n        // beak\n        case mat_floor:\n        color = vec3(0);\n        rough = 0.1;\n        break;\n    }\n\n    // shadows\n    float ao = getAO(pos, normal);\n    color *= ao*0.5+0.5;\n    color *= shade*0.5+0.5;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n\n    // coordinates\n    vec2 uv = coordinate / iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)/iResolution.y;\n    float rng = hash12(coordinate + iTime);\n    \n    // camera\n    vec3 pos = vec3(0,-.1,4);\n    \n    // camera control\n    bool clic = iMouse.z > 0.5;\n    if (clic)\n    {\n        mouse = vec2(iMouse.xy/iResolution.xy)*2.-1.;\n        mouse *= 0.5;\n    }\n    else\n    {\n        mouse = vec2(-.1,0);\n    }\n    \n    pos.yz *= rot(mouse.y-.2);\n    pos.xz *= rot(mouse.x);\n    \n    // look at\n    vec3 z = normalize(vec3(0,-.1,0)-pos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 3.8 + x * p.x + y * p.y);\n    \n    // background gradient\n    color = vec4(vec3(0.8667, 0.2392, 0.0471) * ss(3.0, 0., length(p)), 1);\n    \n    // raymarch iteration\n    const int count = 30;\n    for (int index = 0; index < count; ++index)\n    {\n        // estimate distance\n        float dist = map(pos);\n        \n        // hit volume\n        if (dist < 0.01)\n        {\n            // coloring\n            vec3 normal = getNormal(pos);\n            float shade = float(count-index)/float(count);\n            color.rgb = getColor(pos, normal, ray, shade);\n            \n            /*\n            // reflection\n            dist = 0.5+.5*rng;\n            vec3 rngv = hash33(pos*1000.+iTime)*2.-1.;\n            ray = reflect(ray,normalize(normal+rngv*rough));\n            pos += ray*dist;\n            \n            // color diffusion\n            color.rgb += 0.3*getColor(pos, getNormal(pos), ray, shade);\n            */\n            \n            // exit loop\n            break;\n        }\n        \n        // dithering trick inspired by Duke\n        dist *= 0.9 + 0.1 * rng;\n        \n        // keep marching\n        pos += ray * dist;\n    }\n}", "image_inputs": [], "common_code": "\nconst float pi = 3.1415;\nconst float tau = 6.283;\n\n// transform shortcuts\n//\n// booleans\n#define u(a,b,k) opSmoothUnion(a,b,k)\n#define sub(a,b,k) opSmoothSubtraction(a,b,k)\n#define diff(a,b,k) opSmoothIntersection(a,b,k)\n// translate\n#define t(p,x,y,z) (p-vec3(x,y,z))\n#define tx(p,x) (p-vec3(x,0,0))\n#define ty(p,y) (p-vec3(0,y,0))\n#define tz(p,z) (p-vec3(0,0,z))\n// rotate\n#define rx(p,a) vec3(p.yz*rot(a),p.x).zxy\n#define ry(p,a) vec3(p.xz*rot(a),p.y).xzy\n#define rz(p,a) vec3(p.xy*rot(a),p.z).xyz\n// mirror\n#define ax(p) vec3(abs(p.x),p.y,p.z)\n#define ay(p) vec3(p.x,abs(p.y),p.z)\n#define az(p) vec3(p.x,p.y,abs(p.z))\n// mirror and offset\n#define atx(p,d) vec3(abs(p.x)-d,p.y,p.z)\n#define atz(p,d) vec3(p.x,p.y,abs(p.z)-d)\n// smooth\n#define ss(a,b,t) smoothstep(a,b,t)\n// repeat\n#define repeat(p,r) (mod(p,r)-r/2.)\n// elongate\n#define ey(p, h) vec3(p.x, p.y - clamp( p.y, -h, h ), p.z)\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\nvec3 bounce(vec3 p, float time, float jump, float scale)\n{\n    p.y -= abs(cos(time))*jump;\n    float stretch = pow(1.-(0.5+0.5*cos(time*2.)), 20.);\n    p.xz *= 1.-.2*stretch*scale;\n    p.y *= 1.+.4*stretch*scale;\n    return p;\n}\n\n\nfloat moda (inout vec2 p, float count) {\n    float an = tau/count;\n    float a = atan(p.y,p.x)+an*.5;\n    float c = floor(a/an);\n    a = mod(a,an)-an*.5;\n    c = mix(c,abs(c),step(count*.5,abs(c)));\n    p =vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n\n// smooth union\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// smooth substraction\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n// smooth intersection\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n// Cylinder\nfloat sdCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\n// Dome\nfloat sdDome(vec3 p, float r)\n{\n    return max(p.y, length(p)-r);\n} \n\n// Box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Ellipsoid\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// Torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Vertical Capsule\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n// Round Cylinder\nfloat sdRoundCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// Round Box\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Cone\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n// Link\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltyzX.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[285, 335, 359, 359, 466], [468, 525, 566, 566, 852], [1134, 1134, 1170, 1170, 3314], [3316, 3316, 3335, 3335, 3791], [3793, 3793, 3854, 3854, 4749], [4751, 4751, 4805, 4825, 6617]], "test": "untested"}
{"id": "Wtdczf", "name": "Trig Approximations", "author": "oneshade", "description": "Approximations of the sine, cosine, and tangent trig functions using Bhaskara I's formula.", "tags": ["cheap", "approximation", "trig", "bhaskara"], "likes": 5, "viewed": 151, "published": 3, "date": "1609633003", "time_retrieved": "2024-07-30T19:47:27.999129", "image_code": "#define PI 3.1415926535\n#define HALF_PI 1.5707963268\n#define TWO_PI 6.2831853072\n#define FIVE_PI_SQUARED 49.348022005\n\nfloat cheapSin(in float x) {\n    float nx = mod(x, PI);\n    float PI_MINUS_X = PI - nx;\n    float y = (16.0 * nx * PI_MINUS_X) / (FIVE_PI_SQUARED - 4.0 * nx * PI_MINUS_X);\n    return mod(x, TWO_PI) < PI ? y : -y;\n}\n\nfloat cheapCos(in float x) {\n    return cheapSin(x + HALF_PI);\n}\n\nfloat cheapTan(in float x) {\n    return cheapSin(x) / cheapCos(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 16.0 / iResolution.y;\n\n    uv.x += iTime;\n\n    fragColor = vec4(smoothstep(unit, 0.0, abs(uv.y - cheapSin(uv.x))), 0.0, 0.0, 1.0);\n    fragColor.b += smoothstep(unit, 0.0, abs(uv.y - cheapCos(uv.x)));\n    fragColor.g += smoothstep(unit, 0.0, abs(uv.y - cheapTan(uv.x)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 147, 147, 333], [335, 335, 363, 363, 399], [401, 401, 429, 429, 469], [471, 471, 526, 526, 888]], "test": "untested"}
{"id": "3ttczX", "name": "Wobbly Cube Field", "author": "kekwizard", "description": "cuuubes", "tags": ["cubes"], "likes": 1, "viewed": 297, "published": 3, "date": "1609622078", "time_retrieved": "2024-07-30T19:47:28.971530", "image_code": "\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat mixV(float a, float b, float d) {\n\treturn (d * a)+(1.0 - d)*b;\n}\n\nfloat map(vec3 p)\n{\n    float m = 1.;\n    vec3 boxsize = vec3(3.0, 3.0, 3.0);\n    \n    vec3 c = vec3(8., 15. + 3. * sin(iTime), 8.0);\n\n        \n    p.x = mod(p.x, c.x) - 0.5 * c.x; // p.z -0.05 - 0.05\n    p.y = mod(p.y, c.y) - 0.5 * c.y; // p.z -0.05 - 0.05\n    p.z = mod(p.z, c.z) - 0.5 * c.z; // p.z -0.05 - 0.05\n\n\n    p.x += .75 * sin(p.z + 3. * iTime);\n    p.y += .75 * cos(p.z + 6. * iTime);\n\n    //float displacement = .5 * sin(iTime + 5.*p.x)*cos(iTime * 1.1 + 5.*p.y)*sin(iTime * 1.2 + 5.*p.z);    \n\n    m = min(m, sdBox(p, boxsize));\n\n    return m;\n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = -15.0 + (iTime * 15.);\n    ro.x = 4.0;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n    vec2 _p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);  \n    \n    //mat3 rm = rotationMatrix(vec3(0.66, 1., 0.9), iTime);\n\n        \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 150; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 150.0);\n    /*\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(2., 1., 0.);\n    const vec3 da = vec3(0.5, 0.2, 0.25);\n*/\n    \n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(1., 1., 0.5);\n    const vec3 da = vec3(0.8, 0.9, 0.3);\n\t\n    \n    \n    vec3 sq = sqrt(col);\n    \n    vec3 gg = palette(sq.x * sq.y * sq.z, a, b, c, da);\n\n    fragColor = vec4(gg, 0.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 119], [121, 121, 154, 154, 219], [222, 222, 267, 267, 739], [741, 741, 780, 780, 811], [813, 813, 832, 832, 1372], [1374, 1374, 1420, 1420, 1472], [1474, 1474, 1546, 1546, 1589], [1591, 1591, 1648, 1648, 2752]], "test": "untested"}
{"id": "3lcyRf", "name": "Day 381", "author": "jeyko", "description": "potato", "tags": ["sun", "landscape", "fog", "ice", "iceberg", "mdtmjvm", "mdtmjvm", "glacier", "cyclicnoise"], "likes": 46, "viewed": 1131, "published": 3, "date": "1609621396", "time_retrieved": "2024-07-30T19:47:30.100512", "image_code": "// All Cyclic noise from nimitz\n// PBR atmospheric scattering from Sebastian Lague video tutorial on youtube\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col *= vec3(0.96,0.9,1.07);\n    col *= exposure; \n    \n    col = pow(col,vec3(1.03,0.98,1.05));\n    col = mix(acesFilm(col), col, 0.);\n    col = mix(col,smoothstep(0.,1.,col*vec3(1.0,1.02,1.08)),0.6);\n    \n    col *= 1. - dot(uv,uv*0.4)*1.5;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool hitDiffuse = false;\n\nbool refractedInIceberg = false;\nbool reflectedFromWater = false;\n#define exposure 1.\n#define groundOffs vec3(0,1.3,0)\n\n\n#define IDSEA 1.\n#define IDICEBERG 2.\n\n#define skyCol vec3(0.36,0.66,0.97)*0.5\n\n// General\n#define marchSteps 350\n#define marchEps  (mix(0.0005,0.2,smoothstep(0.,1.,t*0.03 - 0.4)))\n//#define marchEps  (0.0005)\n#define maxDist 90.\n\n\n#define distScale mix(0.4, 0.2,exp(-d.x*d.x*0.05))\n//#define distScale 0.25\n\n#define reflections 4\n#define normalEps 0.0005\n\n// Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 12.\n\n#define cloudSteps 30.\n#define volumetricDithAmt .15\n\n// Wind\n#define windSteps 10.\n// Atmosphere\n#define sunCol vec3(0.23,0.45,0.35)*1.\n#define planetSz 2984.\n#define atmoSz (planetSz/83.)\n\n\n#define itersAtmo 6.\n#define itersOptic 9.\nconst float redLightLen = 690.;\nconst float greenLightLen = 540.;\nconst float blueLightLen = 440.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 5.;\n\n\n#define sss(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n#define ao(a,b) clamp(map(p + normalize((mix(n, sunDir,b)))*a).x/a,0., 1.)\n\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos);\nmat3 getRd(vec3 ro, vec3 lookAt);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*/\n\n \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoiseClouds(vec3 p, bool turbulent, float t){\n    float noise = 0.;\n    \n    float amp = 0.43;\n    const float gain = 0.77;\n    const float lacunarity = 1.6;\n    const int octaves = 6;\n    \n    const float warp = 0.46;    \n    float warpTrk = 1.9;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1.4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(sin(p.zxy + t*0.05\n        )*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy  )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return max(-0. - (noise)*0.6,0.);\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseSea(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 0.07;\n    const float gain = 0.7;\n    const float lacunarity = 1.8;\n    const int octaves = 7;\n    \n    const float warp = 0.;    \n    float warpTrk = 1.4;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n        for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.);\n\n    }\n}\n\nfloat cyclicNoiseRocks(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 0.94;\n    const float gain = 0.5;\n    const float lacunarity = 2.5;\n    const int octaves = 2;\n    \n    const float warp = 0.;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-0,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseRocksInside(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.5;\n    const float lacunarity = 2.5;\n    const int octaves = 2;\n    \n    const float warp = 0.;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-2,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseRocksTri(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.7;\n    const float lacunarity = 1.5;\n    const int octaves = 3;\n    \n    const float warp = 0.27;    \n    float warpTrk = 1.6 ;\n    const float warpTrkGain = 1.3;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        //p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        p += asin(sin(p.zxy*warpTrk - 2.*warpTrk))*warp; \n        \n        //noise += asin(sin(dot(cos(p), sin(p.zxy ))))*amp;\n        noise += asin(sin(dot(acos(cos(p)), sin(sin(p.zxy )))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\nfloat cyclicNoiseWind(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.5;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = .9;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseGrass(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 2;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n/*\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}*/\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    sunPos += offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(refractedInIceberg  || reflectedFromWater){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t/386. - 0.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    //vec3 lookAt = ro + offs;\n    //vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    //uv = ouv;\n    //uv.x = v.x;\n    //uv.y = v.y;\n    \n    return v;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}", "buffer_a_code": "\n#define TAA false\n\n\nvec3 getNormal(vec3 p);\nvec3 getSun(vec2 uv, vec2 sunPos, vec3 sunPosW, vec3 ro, mat3 vp);\n\n\nfloat side = 1.;\n\nfloat t = 0.;\nfloat firstT = 0.;\nvec3 firstRo = vec3(0);\nvec3 firstRd = vec3(0);\nfloat grh = 0.;\nfloat ng = 0.;\n\nfloat nIceBergs;\n\nfloat mapClouds(vec3 p){\n    float currHeight = p.y;\n    \n    p *= 0.5;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    \n    float fb = cyclicNoiseClouds(p*1. + iTime*0., false,iTime);\n    float f = cyclicNoiseClouds(p*0.4 + iTime*0.04 + fb*0.3, true,iTime);\n    //f = (f*0.4 + cyclicNoise(p*0.5 + f*2. - fb*1.4 + iTime))*cyclicNoise(p*0.2 + 5.+ f*4.);\n        //f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    //f = fb;\n    f = max(f,0.);\n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    return f;\n}\n\n\n\n\nvec2 getSea(vec3 p){\n    float d = p.y;\n    vec3 pp = vec3(p.x,2. - iTime*.36,p.z);\n    float n = cyclicNoiseSea(pp*0.5, false);\n    float on = n;\n    //n = pow((n),1.9);\n    \n    d -= n;\n    \n    return vec2(d,IDSEA);\n}\n\n\nvec2 getIcebergs(vec3 p){\n    float d = 10e4;\n    \n    p.y += 1.;\n    \n    \n    float n = cyclicNoiseRocks(vec3(p.x,p.y*0.,p.z)*0.4, false);\n    \n    nIceBergs = cyclicNoiseRocksTri(vec3(p.x,p.y*0.3,p.z)*1., false);\n    \n    n = smoothstep(0.3,1.,n*0.94);\n    \n    \n    \n    //n += rockTex;\n    \n    \n    d = abs(p.y + 2.5)   - (  n*7.3) - 0.;\n    d -= nIceBergs*1.;\n    \n    return vec2(d,2.);\n}\n\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    vec2 dsea = getSea(p);\n    vec2 dicebergs = getIcebergs(p);\n    //vec2 dbal = getIcebergs(p);\n    \n    dsea.x += sin(dicebergs.x*14. - iTime*3.)*exp(-dicebergs.x*1.1)*0.02;\n    //dsea.x -= sin(dicebergs.x*14. + iTime*7.)*clamp(1.-dicebergs.x*1.,0.,1.)*0.02;\n    dsea.x = max(dsea.x,-dicebergs.x + 0.01);\n    \n    \n    \n    \n    \n    d = dmin(d,dsea.x,dsea.y);\n    d = dmin(d,dicebergs.x,dicebergs.y);\n    \n    \n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord/iResolution.xy);\n\n    if(TAA){\n        vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n        fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi/4.),cos(float(taaidx.x)*pi/4.))*taaidx.y/4.;\n\n    }\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    \n    vec3 col = vec3(0);\n    \n    \n    \n    vec3 sunPos = vec3(-1,.7,2.)*2300.;\n    vec3 sunDir = normalize(sunPos);\n\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime;\n    \n    ro.x -= 1.4;\n    \n    \n    vec3 lookAt = vec3(0,0,ro.z +4.);\n    \n        \n    float T = -iTime*0.1;\n    \n    float sea = getSea(ro).x;\n    \n    //float rocks = getRocks(ro).x*1.04; \n    \n    ro += groundOffs;\n    lookAt += groundOffs;\n    lookAt.y -= muv.y*3.;\n    lookAt.x += (1.-muv.x)*5. + 2.;\n    \n    mat3 vp = getRd(ro,lookAt);\n    \n    vec3 rd = normalize(vec3(uv,1.))*vp;\n    \n    firstRo = ro;\n    firstRd = rd;\n    \n    \n    // Marching\n    \n    vec3 atten = vec3(1);\n    vec3 accumIceberg = vec3(0);\n    float tAccumIceberg = 0.;\n    vec3 p = ro;\n    vec2 d;\n    //bool marchingIceberg = false;\n    float depthView;\n    vec3 atmosphere;\n    bool hitSky = false;\n    \n    \n    vec3 hitCol = vec3(0);\n    for(int reflection = 0; reflection < reflections; reflection++){\n        \n        if(!hitDiffuse && !hitSky){\n            p = ro + rd*0.05;\n            for(int i = 0; i < marchSteps ; i++){\n                d = map(p);\n                d.x *= side * distScale;\n                if(side == -1.){\n                    d.x = min(d.x,0.5);\n                    \n                    float dens = 0.075;\n                    dens *= 1. - tAccumIceberg;\n                    dens *= d.x;\n                    \n                    vec3 c = vec3(0.1,0.2,0.08 + sin(p.z*0.5)*0.0);\n                    \n                    float n = cyclicNoiseRocks( p*2., true);\n                    c = mix(\n                        c,\n                        vec3(0,0.4,0.4),\n                        pow(abs(n)*1.,3.)*4.9);\n                    c = mix(\n                        c,\n                        c*c,\n                        pow(abs(n),15.)*1.9);\n                    \n                    \n                    \n                    accumIceberg  += dens*c;\n                    tAccumIceberg += dens;\n                }\n                if (t > maxDist || i == marchSteps - 1){\n                    if(reflection == 0){\n                        firstT = t;\n                    } \n                    if(refractedInIceberg){\n                        hitCol += skyCol*atten;\n                        //hitCol = hitCol * exp(-depthView*0.1) + atten*getAtmosphere(vec3(0,ro.y,0), rd, t, depthView, sunPos);\n                        \n                        hitSky = true;\n                    \n                    } else if(reflectedFromWater){\n                        hitCol = hitCol * exp(-depthView*0.1) + atten*getAtmosphere(vec3(0,ro.y,0), rd, t, depthView, sunPos);\n                        hitSky = true;\n                    }\n                    break;\n                } else if (d.x < marchEps ){\n                    if(reflection == 0){\n                        firstT = t;\n                    }\n                \n                    vec3 n = getNormal(p)*side;\n                    vec3 hf = normalize(sunDir - rd);\n                    float diff = max(dot(n,sunDir),0.);\n                    float spec = pow(max(dot(n,hf),0.),18.);\n                    float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n                    fres = max(fres,0.);\n                \n                    //float rockiness = d.y - 1.;\n                    //rockiness = clamp(rockiness,0.,1.);\n                    //float AO = mix(ao(.5,0.2)*ao(3.9,0.5)*ao(2.2,0.5)*ao(4.2,0.5),1.,0.34);\n                    float AO = mix(ao(.25,0.5)*ao(1.2,0.5)*ao(.8,0.1),1.,0.2);\n                    \n                    //float SSS = sss(.3)*sss(0.04)*sss(.1)*5.;\n                    \n                    vec3 albedo = vec3(0);\n                    vec3 iceCol = vec3(0);\n                    vec3 seaCol = vec3(0);\n                    if(d.y == IDICEBERG){\n                        refractedInIceberg = true;\n                        albedo = vec3(0.6,0.8,1)*0.1;\n                        atten = mix(atten, albedo*atten,0.1);\n                        if(side == -1.){\n                            atten *= 1. - tAccumIceberg;\n                            iceCol += accumIceberg*atten;\n                        } \n                        if( reflection == 1){\n                            }\n                        atten *= AO;\n                        \n                        rd = refract(rd, n, 0.95);\n                        ro = p ;\n                        t = 0.;\n                        \n                        iceCol += albedo*atten*pow(clamp(abs(nIceBergs),0.,1.),4.)*0.9;\n                        //iceCol += albedo*atten*smoothstep(0.1,0.04,nIceBergs)*4.9;\n                        //iceCol += albedo*atten*smoothstep(0.2,0.1,AO)*4.9;\n                        \n                        \n                        iceCol += (fres + spec)*skyCol*atten;\n                        \n                        \n                        hitCol += iceCol;\n                        atten *= 1. - albedo;\n                        \n                        \n                        side *= -1.;\n                    } else {\n                        // water\n                        AO = mix(AO,1.,0.9);\n                        //albedo = vec3(0.8,0.9,1.)*1.;\n                        albedo = vec3(1.,1.,1.)*1.;\n                        \n                        \n                        //AO *= ao(.5)*ao(1.2);\n                        //seaCol += albedo*pow(AO*0.4,13.);\n                        atten *= (spec + fres)*AO*albedo;\n                        //hitCol += seaCol*atten;\n                        reflectedFromWater = true;\n                        \n                        ro = p;\n                        t = 0.1;\n                        rd = reflect(rd,n);\n                    }\n\n                    break;\n                }\n\n                p = ro + rd*(t += d.x);\n            }\n    \n        }\n    }\n    \n    \n    atmosphere = getAtmosphere(vec3(0,firstRo.y,0), firstRd, firstT, depthView, sunPos);\n    \n    // Clouds\n    \n    vec3 cloudRo = firstRo;\n    vec3 cloudRd = firstRd;\n    \n    if(reflectedFromWater){\n        cloudRo = ro;\n        cloudRo = rd;\n    }\n    \n    float lowerCloudLimitDist = plaIntersect( cloudRo - vec3(0,cloudsLowerLimit,0), cloudRd, vec4(0,-1,0,0) );\n    float higherCloudLimitDist = plaIntersect( cloudRo - vec3(0,cloudsHigherLimit,0), cloudRd, vec4(0,-1,0,0) );\n    \n    float volumetricDith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    \n    float cloudLength = higherCloudLimitDist - lowerCloudLimitDist; \n    float cloudStepSz = cloudLength/(cloudSteps);\n    vec3 cloudP = cloudRo + rd * ( lowerCloudLimitDist + volumetricDith*cloudLength );\n    \n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps ; i++){\n        float d = mapClouds(cloudP);\n        \n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*0.5  + 0.22, 0., 1. );\n        vec3 diff = mix( atmosphere*0.1 + vec3(0.04,0.07,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.1), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.4, difffact );\n        //vec3 diff = vec3(0.2); \n        vec3 absorption = mix( vec3(0.8,0.85,0.9), vec3(0.5,0.9,0.7)*0.6, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.1,0.5,0.5)*clamp( 1. - d*3., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*2.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    \n    \n    // Wind\n    vec3 windRo = firstRo;\n    vec3 windRd = firstRd;\n    if(reflectedFromWater){\n        //windRo = ro;\n        //windRd = rd;\n    }\n    vec3 windP = windRo + windRd*volumetricDith*0.00 ;\n    float windStepSz = min(firstT,14.)/windSteps;\n    \n    \n    \n    vec3 windAccum = vec3(0);\n    float windT = 0.;\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*1. - vec3(-iTime*1.,0.,0.);\n            float dens = cyclicNoiseWind(wp,false)*0.239 + 0.0;\n        dens *= smoothstep(1.,0.,windP.y*0.10 + 0.04);\n        \n        dens *= dens*(1.-windT)*windStepSz;\n        windAccum += dens*vec3(.5,0.7,0.9)*2.6;\n        windT += dens;\n        \n        if( windT > 1.){\n            break;\n        }\n        windP += windRd*windStepSz;\n    }\n    \n    \n    \n    // Coloring\n    \n\n    // Compositing\n    \n    col += hitCol;\n    \n    atmosphere += getSun(rd.xy, sunDir.xy, sunPos, ro, vp)*atten;\n    //float depthViewFac = smoothstep(0.,1.,exp(-depthView*1.) + exp(-firstT*0.01));\n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.01 ));\n    \n    //float depthViewFac = exp(-depthView*0.000001);\n    \n    \n    col = col * depthViewFac + atmosphere;//*(1. - depthViewFac) ; \n    \n    \n    cloudAccum *= atten;\n    \n    cloudDensTotal *= length(atten)/length(vec3(1));\n    if (!refractedInIceberg &&  lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    \n    //windAccum *= smoothstep(0.,1.,firstT*0.1 - 0.01);\n    \n    col = mix(col,windAccum,windT);\n    //col = (col - windAccum) + 2.*windAccum*vec3(0.5,0.9,1.2);\n    \n    if(TAA && iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.4);\n    } else {\n        fragColor = col.xyzz;\n    }\n    \n    \n    \n    \n    fragColor.w = cloudDensTotal + float(hitDiffuse)*1.;\n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*normalEps).x;\n    }\n    return normalize(n);\n}\nvec3 getNormalq(vec3 p){\n    vec2 t = vec2(normalEps, 0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\n\n\nvec3 getSun(vec2 uv, vec2 sunPos, vec3 sunPosW, vec3 ro, mat3 vp){\n    \n    vec2 sunUVOriginal = uv;\n    \n    vec2 sunUV = uv - sunPos;\n    //float cloudDensPrevFrame = texture(iChannel2, ((sunUV*iResolution.y + 0.5*iResolution.xy)/iResolution.xy)).w;\n    \n    //vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(getRd(ro,sunPosW))).xy;\n    vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(vp)).xy;\n    \n    sunUvPrevFrame = (sunUvPrevFrame*iResolution.y)/iResolution.xy + 0.5;\n    \n    float deltaUV = 0.04;\n    float cloudDensPrevFrame = \n        texture(iChannel2, sunUvPrevFrame + deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame - deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(-deltaUV,deltaUV)).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(deltaUV,-deltaUV)).w\n        ; \n    \n    cloudDensPrevFrame /= 4.;\n    \n    cloudDensPrevFrame = clamp(cloudDensPrevFrame,0.,1.);\n    // sun\n    \n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    // rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        float mda = sin(i*pi/4.);\n        float mdb = sin(i*pi/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPos;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPos;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    // flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return (sun + sunRays + flares*3.*sunCol) * (1. - cloudDensPrevFrame*1.);\n}\n\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat FXAAamt = 0.5;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 644]], "test": "untested"}
{"id": "WltyzX", "name": "Distorted Torus", "author": "kekwizard", "description": "srseg", "tags": ["torus", "distortion"], "likes": 3, "viewed": 357, "published": 3, "date": "1609620465", "time_retrieved": "2024-07-30T19:47:31.050970", "image_code": "\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat mixV(float a, float b, float d) {\n\treturn (d * a)+(1.0 - d)*b;\n}\n\nfloat map(vec3 p)\n{\n   float displacement = .55 * sin(iTime + 5.*p.x)*cos(iTime * 1.1 + 5.*p.y)*sin(iTime * 1.2 + 5.*p.z);    \n   return displacement + sdTorus(p, vec2(7.0, 3.0));\n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = -16.0;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n    vec2 _p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);  \n    \n    mat3 rm = rotationMatrix(vec3(0.66, 1., 0.9), iTime);\n\n        \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 30; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(rm * p);\n                  \n        if (d < 0.0001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d * 0.75;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 31.0);\n    /*\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(2., 1., 0.);\n    const vec3 da = vec3(0.5, 0.2, 0.25);\n*/\n    \n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(1., 1., 0.5);\n    const vec3 da = vec3(0.8, 0.9, 0.3);\n\t\n    \n    \n    vec3 sq = sqrt(col);\n    \n    vec3 gg = palette(sq.x * sq.y * sq.z, a, b, c, da);\n\n    fragColor = vec4(gg, 0.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 32, 32, 119], [121, 121, 154, 154, 219], [222, 222, 267, 267, 739], [741, 741, 780, 780, 811], [813, 813, 832, 832, 994], [996, 996, 1042, 1042, 1062], [1064, 1064, 1136, 1136, 1179], [1181, 1181, 1238, 1238, 2351]], "test": "untested"}
{"id": "WltyRX", "name": "2D Mandelbrot with Zoom", "author": "AI", "description": "A two-dimensional demo. of Mandelbrot set with zooming effect that changes with time.\nYou may uncomment the zoom to use it with mouse.\nYou may try the other c value by uncommenting it.\nChanging constant values of the program will lead to different looks.", "tags": ["2d", "fractal", "mandelbrot", "zoom", "set"], "likes": 3, "viewed": 334, "published": 3, "date": "1609615318", "time_retrieved": "2024-07-30T19:47:31.883743", "image_code": "#define MAXITER 100\n#define MAXVAL 5.\n#define PI 3.14159265359\n\nvec3 getColorf(float iter,vec2 z){\n\n    vec3 color;\n    color.r=float(mod(iter,10.))/9.;\n    color.b=float(mod(iter/10.,10.))/9.;\n    color.g=.5+.5*sin(iter/10.-log2(1.+log2(1.+dot(z,z))));\n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n//   float zoom=.004+iMouse.x/iResolution.x;\n  float zoom=.75+.4*(cos(PI+.07*iTime));\n\n    uv*=2.*pow(zoom,8.);\n    vec3 color;\n    vec2 c=uv+vec2(-.74515,.1858);\n   // vec2 c=uv+vec2(-.68435,.322500);\n    vec2 z=vec2(0.);\n    float iter=0.;\n    float warp=2.;//-(iMouse.y/iResolution.y);\n    for(int i=0;i<MAXITER;++i){\n        z=vec2(z.x*z.x-z.y*z.y,warp*z.x*z.y)+c;\n        if (length(z)>MAXVAL) break;\n        iter++;\n    }\n    color=getColorf(iter,z);    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 98, 98, 274], [276, 276, 333, 333, 883]], "test": "untested"}
{"id": "wtcczf", "name": "Easing functions", "author": "bbsuuo", "description": " helps you choose the right easing function.", "tags": ["learn"], "likes": 11, "viewed": 2032, "published": 3, "date": "1609613860", "time_retrieved": "2024-07-30T19:47:32.789322", "image_code": "float PI = 3.1415926;\n\nfloat plot(vec2 uv,float pct){\n return smoothstep(pct - 0.01,pct, uv.y) - smoothstep(pct ,pct + 0.01,uv.y);\n}\n\nfloat lerp(float a, float b, float f) \n{\n    return (a * (1.0 - f)) + (b * f);\n}\n\n//Sine\nfloat EaseInSine(float x)\n{\n    return 1.0 - cos((x * PI) / 2.0);\n}\n\nfloat EaseOutSine(float x)\n{\n    return sin((x * PI) / 2.0);\n}\n\nfloat EaseInOutSine(float x)\n{ \n    return -(cos(PI * x) - 1.0) / 2.0;\n}\n\n//Quad\nfloat EaseInQuad(float x)\n{\n   return x * x;\n}\n\nfloat EaseOutQuad(float x)\n{\n  return 1.0 - (1.0-x) * (1.0 -x );\n}\n\nfloat EaseInOutQuad(float x)\n{\n   //x < 0.5f ? 2 * x* x : 1 - pow(-2 * x + 2,2) /2;\n   float inValue = 2.0 * x  *x;\n   float outValue = 1.0- pow(-2.0 * x + 2.0,2.0) / 2.0;\n   float inStep = step(inValue,0.5) * inValue;\n   float outStep = step(0.5 , outValue ) * outValue;\n   \n   return inStep + outStep;\n}\n\n//Cubic\nfloat EaseInCubic(float x)\n{\n   return x * x * x;\n}\n\nfloat EaseOutCubic(float x)\n{ \n   return 1.0 - pow(1.0 - x,3.0);\n}\n\nfloat EaseInOutCubic(float x)\n{\n  //x < 0.5f ? 4.0f * x * x * x : 1 - Mathf.Pow(-2 *x + 2,3)/2;\n  float inValue = 4.0 * x * x * x;\n  float outValue = 1.0 -pow(-2.0 * x + 2.0 ,3.0) /2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Quart\nfloat EaseInQuart(float x)\n{\n return x * x * x * x;\n}\n\nfloat EaseOutQuart(float x)\n{\n  return 1.0 - pow(1.0 -x, 4.0);\n}\n\nfloat EaseInOutQuart(float x)\n{\n  //x < 0.5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2;\n  float inValue = 8.0 * x * x * x * x;\n  float outValue = 1.0 - pow(-2.0 * x + 2.0, 4.0) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Quint\nfloat EaseInQuint(float x)\n{\n   return x * x * x * x * x;\n}\n\nfloat EaseOutQuint(float x)\n{\n   return 1.0 - pow(1.0 - x , 5.0);\n}\n\nfloat EaseInOutQuint(float x)\n{\n  //  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\n  float inValue = 16.0 * x * x * x * x * x;\n  float outValue = 1.0 - pow(-2.0 * x + 2.0, 5.0) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Expo\nfloat EaseInExpo(float x)\n{\n  return pow(2.0, 10.0 * x - 10.0);\n}\n\nfloat EaseOutExpo(float x)\n{  \n  return 1.0 - pow(2.0, -10.0 * x);;\n}\n\nfloat EaseInOutExpo(float x)\n{\n  float inValue = pow(2.0, 20.0 * x - 10.0) / 2.0;\n  float outValue = (2.0 - pow(2.0, -20.0 * x + 10.0)) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Circ\nfloat EaseInCirc(float x)\n{\n return 1.0 - sqrt(1.0 - pow(x, 2.0));\n}\n\nfloat EaseOutCirc(float x)\n{\n return sqrt(1.0 - pow(x - 1.0, 2.0));\n}\n\nfloat EaseInOutCirc(float x)\n{\n  //x < 0.5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n  float inValue = (1.0 - sqrt(1.0 - pow(2.0 * x, 2.0))) / 2.0 * step(x,0.5);\n  float outValue = (sqrt(1.0 - pow(-2.0 * x + 2.0, 2.0)) + 1.0) / 2.0 * step(0.5,x);\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Back\nfloat backC1 = 1.70158;\nfloat backC2 = 2.5949095;\nfloat backC3 = 2.70158;\n\nfloat EaseInBack(float x)\n{\n  return backC3 * x * x * x - backC1 * x * x;\n}\n\nfloat EaseOutBack(float x)\n{\n   return  1.0 - backC3 * pow(x - 1.0, 3.0) + backC1 * pow(x - 1.0, 2.0);\n}\n\nfloat EaseInOutBack(float x){\n //x < 0.5 ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2: (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n  float inValue = (pow(2.0 * x, 2.0) * ((backC2 + 1.0) * 2.0 * x - backC2)) / 2.0;\n  float outValue = (pow(2.0 * x - 2.0, 2.0) * ((backC2 + 1.0) * (x * 2.0 - 2.0) + backC2) + 2.0) / 2.0;\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n  \n}\n\n//Elastic\nfloat EaseInElastic(float x)\n{\n float c4 = (2.0 * PI) / 3.0;\n return -pow(2.0, 10.0 * x - 10.0) * sin((x * 10.0 - 10.75) * c4);\n}\n\nfloat EaseOutElastic(float x)\n{\n float c4 = (2.0 * PI) / 3.0;\n return pow(2.0, -10.0 * x) * sin((x * 10.0 - 0.75) * c4) + 1.0;;\n}\n\nfloat EaseInOutElastic(float x)\n{\n//x < 0.5 ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2: (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n  float c5 = (2.0 * PI) / 4.5;\n  float inValue = ( -(pow(2.0, 20.0 * x - 10.0) * sin((20.0 * x - 11.125) * c5)) / 2.0 )* step(x,0.5);\n  float outValue = ((pow(2.0, -20.0 * x + 10.0) * sin((20.0 * x - 11.125) * c5)) / 2.0 + 1.0 )* step(0.5,x);\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n//Bounce\nfloat EaseOutBounce(float x)\n{\n  float n1 = 7.5625;\n  float d1 = 2.75;\n  float step1 = step(x,1.0/d1);\n  float step2 = step(x, 2.0 /d1) - step1;\n  float step3 = step(x, 2.5 / d1) - step2 - step1;\n  float step4 = 1.0 - step3 - step2 - step1;\n   \n  float value = x;\n  float p0 = (n1 * x * x)* step1 ;\n  value = x - (1.5 / d1);\n  float p1 = (n1 * value * value + 0.75) * step2 ;\n  value = x - (2.25 / d1);\n  float p2 = (n1 * value * value + 0.9375) * step3;\n  value = x - (2.625  / d1);\n  float p3 = (n1 * value * value + 0.984375) * step4;\n  return p0 + p1 + p2 + p3;\n}\n\nfloat EaseInBounce(float x)\n{\n  return 1.0 - EaseOutBounce(1.0 - x);\n}\n\nfloat EaseInOutBounce(float x)\n{\n//x < 0.5 ? (1 - easeOutBounce(1 - 2 * x)) / 2: (1 + easeOutBounce(2 * x - 1)) / 2;\n  float inValue = (1.0 - EaseOutBounce(1.0 - 2.0 * x)) / 2.0 * step(x,0.5);\n  float outValue =  (1.0 + EaseOutBounce(2.0 * x - 1.0)) / 2.0 * step(0.5,x);\n  return step(inValue , 0.5) * inValue + step(0.5,outValue) * outValue;\n}\n\n\nfloat RunSineEase(float x){\n  float value = sin(iTime) * 0.5 + 0.5;\n  return lerp(EaseInSine(x) ,EaseOutSine(x) , value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy)/(iResolution.xy);\n    \n    //change this function and draw ease line\n    float y = RunSineEase(uv.x);\n    \n    \n    \n    vec3 color = vec3(y); \n    //plot a line\n    float pct = plot(uv,y); \n    //line color\n    vec3 green = vec3(0.0,1.0,0.0); \n    //render line and color\n    color = (1.0 - pct) * color +  pct * green;\n   \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 53, 53, 132], [134, 134, 174, 174, 214], [216, 223, 250, 250, 290], [292, 292, 320, 320, 354], [356, 356, 386, 386, 428], [430, 437, 464, 464, 483], [485, 485, 513, 513, 551], [553, 553, 583, 636, 858], [860, 868, 896, 896, 919], [921, 921, 950, 950, 987], [989, 989, 1020, 1084, 1248], [1250, 1258, 1286, 1286, 1311], [1313, 1313, 1342, 1342, 1377], [1379, 1379, 1410, 1472, 1642], [1644, 1652, 1680, 1680, 1711], [1713, 1713, 1742, 1742, 1780], [1782, 1782, 1813, 1882, 2057], [2059, 2066, 2093, 2093, 2131], [2133, 2133, 2161, 2161, 2202], [2204, 2204, 2234, 2234, 2420], [2422, 2429, 2456, 2456, 2497], [2499, 2499, 2527, 2527, 2568], [2570, 2570, 2600, 2690, 2926], [3010, 3010, 3037, 3037, 3085], [3087, 3087, 3115, 3115, 3191], [3193, 3193, 3222, 3343, 3607], [3609, 3619, 3649, 3649, 3748], [3750, 3750, 3781, 3781, 3879], [3881, 3881, 3914, 4046, 4363], [4365, 4374, 4404, 4404, 4941], [4943, 4943, 4972, 4972, 5013], [5015, 5015, 5047, 5131, 5359], [5362, 5362, 5389, 5389, 5485], [5487, 5487, 5544, 5594, 5983]], "test": "untested"}
{"id": "wlcyzf", "name": "Common Light Casters", "author": "oneshade", "description": "Implementation of the light casters described in this LearnOpenGL tutorial: https://learnopengl.com/Lighting/Light-casters", "tags": ["3d", "lights", "cg", "lightcasters"], "likes": 10, "viewed": 209, "published": 3, "date": "1609612924", "time_retrieved": "2024-07-30T19:47:33.555274", "image_code": "const float INV_SQRT_3 = 0.577350269189626;\n\nconst float RADIANS_30 = 0.523598775598299;\nconst float RADIANS_55 = 0.959931088596881;\n\nconst float COS_10 = 0.984807753012208;\nconst float COS_30 = 0.866025403784439;\n\nconst float SIN_25 = 0.422618261740699;\nconst float COS_25 = 0.90630778703665;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n};\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n};\n\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float Kc; // Constant attenuation term\n    float Kl; // Linear attenuation term\n    float Kq; // Quadratic attenuation term\n};\n\nstruct SpotLight {\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float innerCutoff; // Cosine of inner cutoff angle\n    float outerCutoff; // Cosine of outer cutoff angle\n};\n\n// Rather tedious redefinitions but I couldn't find a general way to define them :(\nvec3 shadeDirectional(in vec3 p, in vec3 n, in Material m, in vec3 v, in DirectionalLight l) {\n    vec3 Ia = l.color * m.ambient;\n\n    float diff = max(0.0, dot(n, -l.direction));\n    vec3 Id = l.color * m.diffuse * diff;\n\n    vec3 r = reflect(-l.direction, n);\n    float spec = max(0.0, dot(r, v));\n    spec = min(1.0, pow(spec, m.gloss));\n    vec3 Is = l.color * m.specular * spec;\n\n    return Ia + Id + Is;\n}\n\nvec3 shadePoint(in vec3 p, in vec3 n, in Material m, in vec3 v, in PointLight l) {\n    vec3 Ia = l.color * m.ambient;\n\n    vec3 ld = l.position - p;\n    float d = length(ld);\n    ld /= d;\n\n    float diff = max(0.0, dot(n, ld));\n    vec3 Id = l.color * m.diffuse * diff;\n\n    vec3 r = reflect(ld, n);\n    float spec = max(0.0, dot(r, v));\n    spec = min(1.0, pow(spec, m.gloss));\n    vec3 Is = l.color * m.specular * spec;\n\n    float att = 1.0 / (l.Kc + l.Kl * d + l.Kq * d * d);\n\n    return Ia + (Id + Is) * att;\n}\n\nvec3 shadeSpot(in vec3 p, in vec3 n, in Material m, in vec3 v, in SpotLight l) {\n    vec3 Ia = l.color * m.ambient;\n\n    vec3 ld = l.position - p;\n    float d = length(ld);\n    ld /= d;\n\n    float diff = max(0.0, dot(n, ld));\n    vec3 Id = l.color * m.diffuse * diff;\n\n    vec3 r = reflect(ld, n);\n    float spec = max(0.0, dot(r, v));\n    spec = min(1.0, pow(spec, m.gloss));\n    vec3 Is = l.color * m.specular * spec;\n\n    float theta = dot(-ld, l.direction);\n    float att = clamp((theta - l.outerCutoff) / (l.innerCutoff - l.outerCutoff), 0.0, 1.0);\n\n    return Ia + (Id + Is) * att;\n}\n\nmat2 Rotate(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// Solid angle SDF Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat sdSolidAngle(vec3 p, in vec2 c, float ra) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q, c), 0.0, ra));\n    return max(l, m * sign(c.y * q.x - c.x * q.y));\n}\n\nfloat mapScene(in vec3 p) {\n    vec3 q = abs(p) - 2.5;\n    float box1 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    box1 = max(abs(box1) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(RADIANS_30);\n    p -= vec3(0.25, -1.0, -2.0);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-RADIANS_55);\n    q = abs(p) - 0.8;\n    float box3 = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\n// Soft shadow technique from Inigo Quilez's article on soft shadows (https://iquilezles.org/articles/rmshadows):\nfloat shadowDirectional(in vec3 p, in vec3 n, in float k, in float tmax, in DirectionalLight l) {\n    p += n * 0.002;\n\n    float res = 1.0;\n    float t = 0.0;\n    for(int i=0; i < 50; i++) {\n        float d = mapScene(p - l.direction * t);\n        if (abs(d) < 0.001) {\n            return 0.0;\n        }\n\n        if (t > tmax) {\n            break;\n        }\n\n        res = min(res, k * d / t);\n        t += d;\n    }\n\n    return res;\n}\n\nfloat shadowPoint(in vec3 p, in vec3 n, in float k, in PointLight l) {\n    p += n * 0.002;\n\n    vec3 ld = l.position - p;\n    float dtl = length(ld);\n    ld /= dtl;\n\n    float res = 1.0;\n    float t = 0.0;\n    for(int i=0; i < 50; i++) {\n        float d = mapScene(p + ld * t) * 0.994; // ?\n        if (abs(d) < 0.001) {\n            return 0.0;\n        }\n\n        if (t > dtl) {\n            break;\n        }\n\n        res = min(res, k * d / t);\n        t += d;\n    }\n\n    return res;\n}\n\nfloat shadowSpot(in vec3 p, in vec3 n, in float k, in SpotLight l) {\n    p += n * 0.002;\n\n    vec3 ld = l.position - p;\n    float dtl = length(ld);\n    ld /= dtl;\n\n    float res = 1.0;\n    float t = 0.0;\n    for(int i=0; i < 50; i++) {\n        float d = mapScene(p + ld * t);\n        if(abs(d) < 0.001) {\n            return 0.0;\n        }\n\n        if (t > dtl - 0.3) { // ?\n            break;\n        }\n\n        res = min(res, k * d / t);\n        t += d;\n    }\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Material sceneMaterial = Material(vec3(0.0, 0.0, 0.0),\n                                      vec3(0.5, 0.5, 0.5),\n                                      vec3(0.5, 0.5, 0.5), 4.0);\n\n    DirectionalLight light1 = DirectionalLight(vec3(INV_SQRT_3, -INV_SQRT_3, -INV_SQRT_3),\n                                               vec3(0.45, 0.45, 0.75));\n\n    PointLight light2 = PointLight(vec3(0.3, -0.725, -0.2),\n                                   vec3(1.0, 0.8, 0.0), 1.0, 0.0, 0.06);\n\n    float sec = fract(iTime * 0.5);\n    light2.position.y += 8.0 * (sec - sec * sec);\n\n    SpotLight light3 = SpotLight(vec3(0.0, 2.4, 0.0),\n                                 vec3(INV_SQRT_3, -INV_SQRT_3, INV_SQRT_3),\n                                 vec3(1.0, 0.0, 1.0), COS_10, COS_30);\n\n    light3.direction.xz *= Rotate(iTime);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    vec3 p, n;\n    float t = 0.0, d;\n    bool hit = false;\n    for (int i=0; i < 150; i++) {\n        p = ro + rd * t;\n        d = mapScene(p);\n        if (abs(d) < 0.001) {\n            hit = true;\n            break;\n        }\n\n        vec3 lp1 = p - light2.position;\n        float ld1 = length(lp1) - 0.175;\n\n        vec3 lp2 = p - light3.position;\n        lp2.zx *= Rotate(atan(light3.direction.z, light3.direction.x));\n        lp2.yx *= Rotate(atan(light3.direction.y, length(light3.direction.xz)) - 1.570796326794897);\n\n        float ld2 = sdSolidAngle(lp2, vec2(SIN_25, COS_25), 0.3);\n\n        if (ld1 < 0.001) {\n            fragColor.rgb = light2.color;\n        }\n\n        if (ld2 < 0.001) {\n            fragColor.rgb = light3.color;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += min(d, min(ld1, ld2));\n    }\n\n    if (hit) {\n        n = getNormal(p);\n\n        //float s1 = shadowDirectional(p, n, 64.0, 15.0, light1);\n        fragColor.rgb += shadeDirectional(p, n, sceneMaterial, rd, light1);// * s1;\n\n        float s2 = shadowPoint(p, n, 64.0, light2);\n        fragColor.rgb += shadePoint(p, n, sceneMaterial, rd, light2) * s2;\n\n        vec3 spotIllum = shadeSpot(p, n, sceneMaterial, rd, light3);\n        if (max(spotIllum.r, max(spotIllum.g, spotIllum.b)) > 0.0) {\n            float s3 = shadowSpot(p, n, 64.0, light3);\n            spotIllum *= s3;\n        }\n\n        fragColor.rgb += spotIllum;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[830, 914, 1008, 1008, 1325], [1327, 1327, 1409, 1409, 1841], [1843, 1843, 1923, 1923, 2432], [2434, 2434, 2459, 2459, 2525], [2527, 2640, 2689, 2689, 2868], [2870, 2870, 2897, 2897, 3578], [3580, 3580, 3607, 3607, 3914], [3916, 4030, 4127, 4127, 4464], [4466, 4466, 4536, 4536, 4950], [4952, 4952, 5020, 5020, 5431], [5433, 5433, 5488, 5488, 7933]], "test": "untested"}
{"id": "wt3cRf", "name": "linear interpolation", "author": "bbsuuo", "description": "algorithmic drawing about basic linear interpolation ", "tags": ["learn"], "likes": 2, "viewed": 478, "published": 3, "date": "1609608825", "time_retrieved": "2024-07-30T19:47:34.321226", "image_code": "float PI = 3.1415926;\n\nfloat plot(vec2 uv,float pct){\n return smoothstep(pct - 0.01,pct, uv.y) - smoothstep(pct ,pct + 0.01,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy)/(iResolution.xy);\n    //functuon y = x , you cang change func(y)\n    float y = uv.x;\n    //float y = step(0.5,uv.x);\n    //float y =   smoothstep(0.4,0.5,uv.x) - smoothstep(0.5,0.6,uv.x);\n    //float y = mod(uv.x,0.5);\n    //float y = fract(uv.x);\n    //float y = ceil(uv.x);\n    //float y = floor (uv.x);\n    //float y = abs(uv.x);\n    //float y = clamp(0.5,0.6,uv.x);  \n    //float y = min(uv.x,0.2);\n    //float y = max(uv.x,0.2);\n    //float y = sin((uv.x  +iTime)*PI) * 0.5 +0.5;\n    //float y = cos((uv.x  +iTime)*PI) * 0.5 +0.5;  \n    //float y = 1.0;\n    vec3 color = vec3(y); \n    //plot a line\n    float pct = plot(uv,y); \n    //line color\n    vec3 green = vec3(0.0,1.0,0.0); \n    //render line and color\n    color = (1.0 - pct) * color +  pct * green;\n   \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 53, 53, 132], [134, 134, 191, 241, 1072]], "test": "untested"}
{"id": "wtcyRf", "name": "something2021", "author": "jj99", "description": "globe thing", "tags": ["noise", "torus", "sphere", "plane"], "likes": 4, "viewed": 302, "published": 3, "date": "1609608199", "time_retrieved": "2024-07-30T19:47:35.094160", "image_code": "// fork of - https://www.shadertoy.com/view/3ltczj\n\n#define PLANET_RADIUS 1.4\n#define MAP_SCALE 2.0\n#define MAP_ROUGHNESS 5.0\n#define MAP_HEIGHT 0.35\n\nvec3 Hash33(in vec3 p) {\n    return vec3(fract(sin(dot(p, vec3(7643.54, 6854.95, 356.6765))) * 234.752),\n                fract(sin(dot(p, vec3(7853.67, 5214.327, 435.6437))) * 6734.8275),\n                fract(sin(dot(p, vec3(7546.754, 683.2647, 358.2431))) * 257.8643));\n}\n\nfloat noise(in vec3 p) {\n    return fract(sin(dot(p, vec3(3743.54, 2754.23, 578.537))) * 5664.865);\n}\n\nfloat snoise(in vec3 p)\n{\n\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(lub, rub, local.x),\n                   local.y),\n\n               mix(mix(ldf, rdf, local.x),\n                   mix(luf, ruf, local.x),\n                   local.y),\n\n               local.z);\n}\n\nfloat fnoise(in vec3 p) {\n\n    p *= MAP_SCALE;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < MAP_ROUGHNESS; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n\tfloat nn = value / tscale;\n\tnn = clamp(nn,0.5,1.0);\n\t\n\t\n\treturn nn;\n\t//return value / tscale;\n}\n\nvec3 map(in vec3 p)\n{\n\tfloat n = fnoise(p);\n\tvec3 sea = vec3(0.25,0.55,0.95);\n\tvec3 lan1 = vec3(0.2, 1.1, 0.3);\n\tvec3 lan2 = vec3(1.1, 0.3, 0.3);\n\tvec3 color = mix(sea, mix(lan1, lan2, n ), float(n > 0.5));\n\treturn color;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat mapScene(in vec3 p)\n{\n\tfloat earth = length(p) - PLANET_RADIUS;\n\tfloat off = fnoise(p) * MAP_HEIGHT;\n\t\n\tfloat d1 = sdTorus(p,vec2(2.0,0.0155));\n\tfloat d2 = sdTorus(p.yxz,vec2(2.0,0.0155));\n\tfloat d3 = sdTorus(p.yzx,vec2(2.0,0.0155));\n\td1 = smin(d1,d2,0.1);\n\td1 = smin(d1,d3,0.1);\n\n\tfloat d4 = p.y +1.7+sin(p.x*0.7+fract(iTime*0.4)*6.28+length(p))*0.17;\n\t\n\td1 = smin(d1,d4,0.3);\n\t\n\tearth = smin(earth,d1,0.15);\n\tearth-=off;\n\t\n\t\n\t\n\treturn earth*0.7;\n}\n\n\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*mapScene( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*mapScene( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*mapScene( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*mapScene( pos + e.xxx*eps ) );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tfloat vv1=uv.y+0.2*4.0;\n\tfragColor.rgb = vec3(0.03,0.2,0.06)*vv1;\n\n    vec3 ro = vec3(0., 0.2, 10.0+sin(iTime*0.7)*4.0);\n    vec3 rd = normalize(vec3(uv, -1.5));\n            vec3 l = vec3(-.74, .9, .0);\n\tl = normalize(l);\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 200.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        vec2 cs = sin(iTime + vec2(1.57, 0.0));\n        p.xz *= mat2(cs, -cs.y, cs.x);\n        //p.yz *= mat2(cs, -cs.y, cs.x);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            //n.yz *= mat2(cs.x, -cs.y, cs.yx);\n            n.xz *= mat2(cs.x, -cs.y, cs.yx);\n\n            fragColor.rgb += map(p);\n\t\tfloat ddd = max(0.3, dot(n, l));\n            fragColor.rgb *=ddd;\n\t\t\n  \tvec3 ref = reflect(rd, n);\n\tfloat spe = max(dot(ref, l), 0.0);\n\t\t\n\t\tfragColor.rgb += pow(spe,8.0)*0.7;\n\t\t\n            break;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 175, 175, 424], [426, 426, 450, 450, 527], [529, 529, 554, 554, 1281], [1283, 1283, 1308, 1308, 1673], [1675, 1675, 1696, 1696, 1898], [1899, 1899, 1940, 1940, 2033], [2034, 2034, 2067, 2067, 2122], [2124, 2124, 2151, 2151, 2579], [2582, 2582, 2613, 2613, 2871], [2874, 2874, 2929, 2929, 4004]], "test": "untested"}
{"id": "Wt3czf", "name": "HappyNewYear2021", "author": "yasuo", "description": "Happy New Year, guys!", "tags": ["2021"], "likes": 16, "viewed": 306, "published": 3, "date": "1609592983", "time_retrieved": "2024-07-30T19:47:35.893023", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\nvec3 bamboo(vec2 p, vec3 col, float brightness){\n    vec2 prevP = p;\n    \n    float d = sdBox(p-vec2(0.0,-0.2),vec2(0.033,0.2));\n    col = mix(col,vec3(0.6,0.7,0.5)*brightness,S(d,0.0));    \n    \n    p.x*= 1.5;\n    d = length(p)-0.05;\n    col = mix(col,vec3(0.6,0.7,0.5)*brightness,S(d,0.0));\n    p = prevP;\n    p.x*= 1.5;\n    d = length(p)-0.035;\n    col = mix(col,vec3(0.7,0.8,0.1)*1.2,S(d,0.0));\n    return col;\n}\n\nvec3 hey(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    float d = sdBox(p,vec2(0.1,0.1));\n    col = mix(col,vec3(0.8,0.7,0.1),S(d,0.0));    \n    \n    p.x = mod(p.x,0.022)-0.011;\n    d = sdBox(p,vec2(0.005,0.1));\n    \n    p = prevP;\n    float d2 = sdBox(p,vec2(0.1,0.11));\n    d = max(d2,d);\n    col = mix(col,vec3(0.7,0.6,0.1),S(d,0.0));\n    p = prevP;\n    \n    d = sdBox(p-vec2(0.0,-0.05),vec2(0.1,0.005));\n    col = mix(col,vec3(0.6,0.4,0.1),S(d,0.0)); \n    \n    return col;\n}\n\nvec3 grass(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float k = 0.01;\n    float d = length(p)-0.05;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    float d2 = length(p-vec2(0.0,-0.03))-0.05;\n    d = opSmoothUnion(d,d2,k);\n    p.x-=0.05;\n    d2 = length(p-vec2(0.0,-0.07))-0.05;\n    d = opSmoothUnion(d,d2,k);\n    p.x+=0.06;\n    d2 = length(p-vec2(0.0,-0.06))-0.05;\n    d = opSmoothUnion(d,d2,k);\n    col = mix(col,vec3(0.1,0.4,0.1),S(d,0.0)); \n    return col;\n}\n\nvec3 flower(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p = DF(p,1.25);\n    p -= vec2(0.019);\n    float d = length(p)-0.027;\n    col = mix(col,vec3(0.7,0.2,0.2),S(d,0.0));\n    p = prevP;\n    \n    p = DF(p,1.25);\n    p -= vec2(0.015);\n    d = length(p)-0.005;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 leaf(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = SimpleVesicaDistance(p,0.08,0.062);\n    p.x = abs(p.x);\n    p.x-=0.03;\n    p.y-=0.015;\n    float d2 = SimpleVesicaDistance(p*Rot(radians(-50.0)),0.08,0.061);\n    d = min(d,d2);\n    col = mix(col,vec3(0.3,0.8,0.3),S(d,0.0));\n    return col;\n}\n\nvec3 fan(vec2 p, vec3 col)\n{\n    const vec2 an = vec2(sin(0.98),cos(0.98));\n    \n    float d = sdPie(p,an,0.1/0.8);\n    col = mix(col,vec3(1.0,0.0,0.0),S(d,0.0));\n    \n    d = sdPie(p,an,0.07/0.8);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    d = length(p-vec2(0.0,0.04/0.8))-0.015/0.8;\n    col = mix(col,vec3(0.9,0.9,0.1),S(d,0.0));\n    \n    return col;\n}\n\nvec3 clouds(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    float d = length(p)-0.35;\n    col = mix(col,mix(vec3(1.0),vec3(0.5,0.7,0.9),p.y+0.3),S(d,0.0));\n    \n    p.y*=1.1;\n    p.x+=iTime*0.1;\n    p.x=mod(p.x,0.8)-0.4;\n    p.y-=0.15;\n    \n    d = sdBox(p,vec2(0.16,0.005))-0.03;\n    float d2 = sdBox(p-vec2(-0.04,0.125),vec2(0.05,0.005))-0.03;\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(-0.04,0.06),vec2(0.03,0.05));\n    d = opSmoothUnion(d,d2,0.02);\n    d2 = sdBox(p-vec2(0.12,-0.125),vec2(0.1,0.005))-0.03;\n    d = min(d,d2);\n    d2 = sdBox(p-vec2(0.1,-0.06),vec2(0.03,0.05));\n    d = opSmoothUnion(d,d2,0.02);\n    \n    p = prevP;\n    d2 = length(p)-0.35;\n    d = max(d2,d);\n    \n    col = mix(col,vec3(0.5,0.7,0.9)*1.9,S(d,0.0));\n    \n    return col;\n}\n\nvec3 soil(vec2 p, vec3 col) {\n    p.x*=0.4;\n    p.y*=2.0;\n    float d = length(p)-0.07;\n    col = mix(col,vec3(0.7,0.5,0.2),S(d,-0.03));\n    \n    return col;\n}\n\nvec3 render(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float t = iTime;\n    col = clouds(p,col);\n\n    col = soil(p-vec2(0.0,-0.4),col);\n    col = bamboo(p-vec2(0.0,0.1),col,0.8);\n    p.x = abs(p.x);\n    p.x-=0.05;\n    col = bamboo(p,col,1.0);\n    p = prevP;\n    col = hey(p-vec2(0.0,-0.3),col);\n    col = grass(p-vec2(0.0,-0.125),col);\n    col = fan((p-vec2(-0.05,-0.23))*Rot(radians(-25.0)),col);\n    col = leaf((p-vec2(-0.06,-0.27))*Rot(radians(30.0)),col);\n    col = flower((p-vec2(0.0,-0.22))*Rot(radians(-30.0*t)),col);\n    col = flower((p-vec2(0.07,-0.125))*Rot(radians(25.0*t)),col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(1.0);\n\n    col = render(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3czf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 329, 381, 381, 480], [482, 533, 570, 570, 650], [652, 703, 752, 752, 926], [928, 928, 982, 982, 1040], [1042, 1042, 1090, 1090, 1458], [1460, 1460, 1488, 1488, 1940], [1942, 1942, 1972, 1972, 2395], [2397, 2397, 2428, 2428, 2717], [2719, 2719, 2748, 2748, 3024], [3026, 3026, 3054, 3054, 3385], [3387, 3387, 3418, 3418, 4143], [4145, 4145, 4174, 4174, 4304], [4306, 4306, 4337, 4337, 4920], [4922, 4922, 4979, 4979, 5129]], "test": "untested"}
{"id": "wldyRj", "name": "GGX test", "author": "iY0Yi", "description": "Another Specular test for GGX.\nMouse enabled.\n\nref:\nhttps://www.shadertoy.com/view/wljSz1\nhttp://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/", "tags": ["ggx", "normalized"], "likes": 21, "viewed": 1360, "published": 3, "date": "1609590949", "time_retrieved": "2024-07-30T19:47:36.856448", "image_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(41.593, 63.9086, 42.6658);\n\tcam0.quaternion = vec4(0.1393, 0.3404, 0.8606, 0.3522);\n\tcam0.fov = 0.18;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = vec3(0.5, 0.6, -0.5);\n    R(lit0.direction.xz, iTime*.5);\n\tlit0.color = vec3(1.0, 1.0, 1.0);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(-0.2662, -0.8589, 0.4376));\n\tlit1.color = vec3(0.3, 0.3, 0.3);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}void perspectiveCam(vec2 uv){\n\tvec3 up = vec3(0,1,0);\n    \n    vec3 pos = vec3(42,64,42);\n    if(iMouse.z>0.)\n\tpos = vec3(42.*sin(iMouse.x/iResolution.x*TAU), 64.*iMouse.y/iResolution.y, 42.*cos(iMouse.x/iResolution.x*TAU));\n\tvec3 target = vec3(0,0,0);\n    vec3 dir = normalize(pos-target);\n\n\tfloat fov = cam0.fov;\n\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n}\nvoid camera(vec2 uv){\n\n\tperspectiveCam(uv);\n\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r){\n\treturn length(p)-r;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp000 = p;\n\tcp000.xyz += vec3(-1.5, -1.0, -1.5);\n\tpRepLimited(cp000.z, 3.0, 5.);\n\tpRepLimited(cp000.x, 3.0, 5.);\n\n\td = sdPlane(p);\n\t{\n\t\tvec3 tp = cp000+vec3(0.5, 0.0, 0.0);\n\t\tvec3 trp = rot(cp000+vec3(0.5, 0.0, 0.0), vec3(0.0, 1.5708, 0.0));\n\t\tvec3 dim = vec3(1.0, 1.0, 0.5);\n\t\tfloat td = MAX_DIST;\n\t\t// Custom Primitive Example: Hex\n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.1;\n\t\td=fOpUnionSmooth(td, d, 0.01);\n\t}\n\td = fOpUnionSmooth(sdSphere(cp000+vec3(-0.5, 0.0, 0.0), 0.9), d, 0.124);\n\tres = v4OpUnion(vec4(d, MAT_ERNST1), res);\n\n\treturn res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.)).x-c,\n\t\tsdScene(p+vec3(0.,e,0.)).x-c,\n\t\tsdScene(p+vec3(0.,0.,e)).x-c)\n\t);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=0; i<nbIte; i++ ){\n\t\tfloat l = hash11(float(i))*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// Phong specular\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) / (2.*PI);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    return 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) / (2.*PI);\n    vec3 h  = normalize(-vd+ld);\n    return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    vec3 h  = normalize(-vd+ld);\n    return 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0f-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n#define ggx(roughness, N, V, L) ggx(N, V, L, roughness, .6)\n\n#define tex iChannel0\n#define NextLine nextLine(p)\n#define WriteChar(char,style) writeStandardChar(char,style,pp,tex,renDat.albedo)\n#define WriteWord(word,style) writeWord(word,style,pp,tex,renDat.albedo)\n#define WriteText(text,style) writeText(text,style,pp,tex,renDat.albedo)\n#define WriteNumber(number,min_int_digits,dec_digits,style) writeNumber(number,min_int_digits,dec_digits,style,pp,tex,renDat.albedo)\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n        \n        // \"Utils : font display\" by ABizard:\n        // https://www.shadertoy.com/view/MdycDK\n        const int[] text1 = int[](_I,_n,_t,_e,_n,_s,_i,_t,_y);\n        const int[] text2 = int[](_S,_h,_i,_n,_i,_n,_e,_s,_s);\n        vec2 COORD = floor(p.xz*iResolution.x);\n        PrintStyle white_out_black = NewPrintStyle(WHITE,renDat.albedo);\n        \n        vec2 pos = vec2(-7.,-14.);\n        float scale = 1./2.;\n        PrintPosition pp;\n        pp = getDisplayPos(pos,scale);\n\n        WriteWord(text1,white_out_black);\n        \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text2,white_out_black);\n        \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text1,white_out_black);\n    \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text2,white_out_black);\n    \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .1, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, .5, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 2., 2.);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\tfloat shininess = pow(.65, max(0.,floor((p.z+9.+1.5)*.3333)))+.01+u2s(texture(iChannel1, p.xz*.5).r)*.5;\n\t\tfloat shininessRef = pow(.25, max(0.,floor((p.z+9.+1.5)*.3333)))+4.;\n\t\tfloat intensity = pow(.3, max(0.,floor((p.x+9.+1.5)*.3333)));\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\tfloat ref = BlinnPhongRef(shininessRef, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH)*(.4+.6*ref);\n\t\trenDat.result*= renDat.albedo;\n        \n\t\tfloat spec = ggx(shininess, renDat.normal, -ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity*step(0.1,p.y);\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\t//renDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 ACESFilm(vec3 x){\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    \n    renDat.result = ACESFilm(renDat.result);\n\trenDat.result = pow(renDat.result, vec3(.9));\n\n\tfragColor = vec4(renDat.result, 1.);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.0)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define ITERATION 100\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST1 vec3(0.2396, 0.2396, 0.2396)\n\n#define AMB_COL vec3(1.0, 1.0, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(1.0, 1.0, 1.0)\n#define FOG_START -0.63\n#define FOG_POW 1.0\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n\n\n// \"SDF Font Texture Adventures\" by P_Malin:\n// https://www.shadertoy.com/view/ldfcDr\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define PURPLE\t\tvec3(1,0,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define VIOLET \t\tvec3(.5,0,1)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define LIGHT_GREEN\tvec3(.5,1,0)\n#define LAGOON\t\tvec3(0,1,.5)\n#define ORANGE\t\tvec3(1,.5,0)\n#define MAGENTA\t\tvec3(1,0,.5)\n#define PINK\t\tvec3(1,.3,.7)\n\n\n#define POW2(A) ((A)*(A))\n#define POW3(A) (POW2(A)*(A))\n#define POW4(A) (POW3(A)*(A))\n\n#define Res iResolution\n\nint powInt(int a, int b){\n    int r = 1;\n    for(int i=0;i++<b;r*=a);\n    return r;\n}\n\nint intLog(int x, int base){\n    if(x<1) return 0;\n    int res = 0;\n    for(;x>=base;res++)\n        x /= base;\n    return res;\n}\n\n// Periodic function __|__|__|__|__\n// s : dirac compression\nfloat periodicDirac(float x, float period, float s){\n\treturn pow(abs(cos(x*(PI/period))),s);\n}\n\n////////////////////////////////\n\n// Ascii encoding. Takes ~900 chars so you may want to take onlywhat you need\nconst int\t_=32,\n\t\t\t_EXCL=33,\t\t// !\n\t\t\t_QUOTE=34,\t\t// \"\n\t\t\t_SHARP=35,\t\t// #\n\t\t\t_DOLLAR=36,\t\t// $\n\t\t\t_PERCENT=37,\t// %\n\t\t\t_AMPER=38,\t\t// &\n\t\t\t_SQUOTE=39,\t\t// '\n\t\t\t_LPAR=40,\t\t// (\n\t\t\t_RPAR=41,\t\t// )\n\t\t\t_ASTERISK=42,\t// *\n\t\t\t_PLUS=43,\t\t// +\n\t\t\t_COMMA=44,\t\t// ,\n\t\t\t_MINUS=45,\t\t// -\n\t\t\t_DOT=46,\t\t// .\n\t\t\t_SLASH=47,\t\t// /\n\t\t\t_0=48,\t_1=49,\t_2=50,\t_3=51,\t_4=52,\n    \t\t_5=53,\t_6=54,\t_7=55,\t_8=56,\t_9=57,\n    \t\t_COLON=58,\t\t// :\n    \t\t_SEMICOLON=59,\t// ;\n    \t\t_LT=60,\t\t\t// <\n    \t\t_EQ=61,\t\t\t// =\n    \t\t_GT=62,\t\t\t// >\n    \t\t_QUEST=63,\t\t// ?\n    \t\t_AT=64,\t\t\t// @\n\t\t\t_A=65,\t_B=66,\t_C=67,\t_D=68,\t_E=69,\n\t\t\t_F=70,\t_G=71,\t_H=72,\t_I=73,\t_J=74,\n\t\t\t_K=75,\t_L=76,\t_M=77,\t_N=78,\t_O=79,\n\t\t\t_P=80,\t_Q=81,\t_R=82,\t_S=83,\t_T=84,\n\t\t\t_U=85,\t_V=86,\t_W=87,\t_X=88,\t_Y=89,\n\t\t\t_Z=90,\n\t\t\t_a=97,\t_b=98,\t_c=99,\t_d=100,\t_e=101,\n\t\t\t_f=102,\t_g=103,\t_h=104,\t_i=105,\t_j=106,\n\t\t\t_k=107,\t_l=108,\t_m=109,\t_n=110,\t_o=111,\n\t\t\t_p=112,\t_q=113,\t_r=114,\t_s=115,\t_t=116,\n\t\t\t_u=117,\t_v=118,\t_w=119,\t_x=120,\t_y=121,\n\t\t\t_z=122,\n    \t\t_alpha=128,\t\t_beta=129,\t_gamma=130,\t\t_delta=131,\n    \t\t_epsilon=132,\t_theta=133,\t_lambda=134,\t_mu=135,\n    \t\t_xi=136,\t\t_pi=137,\t_rho=138,\t\t_sigma=139,\n    \t\t_tau=140,\t\t_phi=141,\t_psi=142,\t\t_omega=143,\n    \t\t_GAMMA=144,\t\t_DELTA=145,\t_THETA=146,\t\t_LAMBDA=147,\n    \t\t_PI=148,\t\t_SIGMA=149,\t_PHI=150,\t\t_PSI=151,\n    \t\t_OMEGA=152;\n\nstruct PrintPosition{\n    vec2 uv,\n         pos,\n         Res;\n    float scale;\n};\n\nstruct PrintStyle{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2, float w){\n\treturn PrintStyle(col1,col2,w);\n}\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2){\n\treturn PrintStyle(col1,col2,.05);\n}\nPrintStyle NewPrintStyle(vec3 col){\n\treturn PrintStyle(col,col,0.);\n}\n#define DefaultPrintStyle NewPrintStyle(WHITE,BLACK)\n\n#define getDisplayPos(pos,scale) PrintPosition((COORD-pos*Res.xy)/(scale*Res.x),pos,Res.xy,scale);\n#define nextLine(p)\tp.pos.y -= scale*1.5,\\\n\t\t\t\t\tp = getDisplayPos(p.pos,p.scale);\n\nvoid writeChar(int char, PrintStyle style,\n               float w, float x_offset, // Dimensions of the bbox of the char\n               inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char/16))/16.)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            // We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(0.,-1./p.Res.y,getFont(uv,char).a - outline_size-.5));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; // move uv for next char\n    \tp.uv = uv;\n}\n\nfloat default_ch_w = .8,\n      default_ch_off = .3;\n\nvoid writeStandardChar(int char, PrintStyle style,\n                     inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeChar(char,style,\n              default_ch_w,default_ch_off,\n              p,font_tex,color);\n}\n\n#define writeText(text, style, p, font_tex, color)\\\n\t{int chars_per_line = int((1.-p.pos.x)/(p.scale*(default_ch_w-default_ch_off)));\\\n\tfor(int i=0;i<text.length();i++){\\\n        writeStandardChar(text[i],style,p,font_tex,color);\\\n        if((i+1)%chars_per_line==0)\\\n            nextLine(p);\\\n    }}\n\n#define writeWord(word, style, p, font_tex, color)\\\n\tfor(int i=0;i<word.length();i++)\\\n        writeStandardChar(word[i],style,p,font_tex,color);\n\nvoid writeNumber(float number, int min_int_digits, int dec_digits,\n                 PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n\t\n    if(isnan(number)){\n    \tPrintStyle NaN_style = PrintStyle(BLACK,RED,.05);\n        writeWord(int[](_N,_a,_N),NaN_style,p,font_tex,color);\n    }\n    else if(isinf(number)){\n        PrintStyle Inf_style = PrintStyle(BLACK,LIGHT_BLUE,.05);\n        writeWord(int[](_I,_n,_f),Inf_style,p,font_tex,color);\n    }\n    else{\n        // Display the minus if number is negative\n        if(number<0.)\n            writeStandardChar(_MINUS,style,p,font_tex,color);\n        \n        // Round the number according to the number of decimal digits\n        float decimal_digits_factor = float(powInt(10,dec_digits));\n        int rounded_number = int(round(abs(number)*decimal_digits_factor));\n        \n        int int_part = rounded_number/int(decimal_digits_factor);\n        int int_digits = 1 + intLog(int_part,10);\n        // Fill with zeros to match min digits\n        for(int i=0;i++< min_int_digits - int_digits ;)\n            writeStandardChar(_0,style,\n                              p,font_tex,color);\n        \n        \n        int digits = int_digits+dec_digits;\n        for(int x = powInt(10,digits);digits>0;digits--){\n            if(digits==dec_digits)\n                // Dot\n                writeChar(_DOT,style,\n                      .65,.45,\n                      p,font_tex,color);\n            writeStandardChar(_0+rounded_number/(x/=10),style,\n                              p,font_tex,color);\n            rounded_number%=x;\n        }\n    }\n        \n}\n\nvoid writeNumber(int number, int min_int_digits, PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeNumber(float(number),min_int_digits,0,\n                style,\n                p,font_tex,color);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 686, 686, 744], [895, 895, 907, 907, 1441], [1442, 1550, 1588, 1588, 1664], [1664, 1664, 1693, 1693, 2234], [2235, 2235, 2256, 2256, 2281], [2283, 2372, 2397, 2397, 2412], [2414, 2414, 2451, 2451, 2474], [2476, 2476, 2514, 2514, 2533], [2535, 2535, 2571, 2571, 2594], [2596, 2596, 2642, 2642, 2727], [2729, 2805, 2869, 2869, 3234], [3236, 3326, 3347, 3347, 4224], [4226, 4298, 4315, 4315, 4610], [4612, 4684, 4704, 4704, 4875], [4877, 4949, 4978, 4978, 5457], [5459, 5607, 5638, 5638, 5741], [5742, 5742, 5786, 5786, 5882], [5883, 5883, 5966, 5966, 6440], [6442, 6532, 6597, 6597, 6776], [6777, 6777, 6845, 6845, 6900], [6902, 7016, 7086, 7086, 7232], [7233, 7233, 7296, 7296, 7381], [7383, 7491, 7521, 7521, 7555], [7556, 7556, 7617, 7617, 8141], [11558, 11630, 11652, 11652, 11774], [11776, 11848, 11902, 11902, 12371]], "test": "untested"}
{"id": "ttdcR2", "name": "New Year's Resolution 2021", "author": "netgrind", "description": "my new year's resolution is to watch what unfolds", "tags": ["eyes", "eye", "rainbow", "resolution", "unfold", "2021"], "likes": 9, "viewed": 399, "published": 3, "date": "1609561964", "time_retrieved": "2024-07-30T19:47:37.723130", "image_code": "// \"Fork\" of \"Geodesic tiling (abs position)\" by tdhooper. https://shadertoy.com/view/XtKSWc\n// Most of the geodesic stuff is gone, but the march/render code is still in place\n// various sdf functions via iq and mercury\n// 2021-01-01 23:50:17\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 color;\n};\n\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nfloat pModPolar(inout vec2 p, float repetitions, float phase) {\n\tfloat angle = 2.*3.14159/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.+phase/repetitions;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle*.5;\n    a = abs(a);\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nvec4 fOpUnionRound(vec4 a, vec4 b, float r) {\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/r, 0.0, 1.0 );\n    return mix( b, a, h ) - r*h*(1.0-h);\n}\n    \nvec4 opSmoothSubtraction( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    return mix( d2, vec4(-d1.x, d1.yzw), h ) + k*h*(1.0-h); \n}\nvec4 opUnion( vec4 d1, vec4 d2 ) {  return mix(d1,d2, clamp(ceil(d1.x-d2.x), 0., 1.)); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n\n// The actual model\nModel map(vec3 p) {\n    \n    float sineTime = iTime*6.28*.5;\n\n\tfloat sphere = length(p) - 2.; \n    sphere = max(-(length(p)-1.8), sphere);\n    vec2 uv = p.xy*2.;\n   \n    float f = floor(uv.x+uv.y) + floor(uv.y-uv.x);\n    uv = vec2(fract(uv.x+uv.y),fract(uv.y-uv.x));\n    uv -= .5;\n    \n    vec3 pos = p;\n    //pos.y-=.08;\n    float i = pMod1(pos.y, .25);\n    float j = pModPolar(pos.xz,30.,i*3.14159+(sineTime+sin(sineTime+3.1415)*1.5)*(mod(i, 2.)-.5));\n    pos -= vec3(.8-cos((i)*.2+3.14159), 0., 0.);\n    float eye = length(pos+vec3(0., .04, 0.))-.1;\n    eye = max(eye, length(pos-vec3(0., .04, 0.))-.1);\n    vec4 s = fOpUnionRound(vec4(sphere, 0., 0., 0.), vec4(eye, 2., 2., 2.), 0.05);\n    s = opSmoothSubtraction(vec4(eye-.005, 0., 0., 0.), s, .01);\n    pR(pos.xy, p.y*.5+sin(i+j+sineTime)*.05);\n    float a =atan(pos.z, pos.y);\n    vec3 eyeColor = sin(vec3((p.x+p.y*2.+vec3(0., .3, .6))*7.+sineTime))*.4+.4;\n    eyeColor+=cos(a*20.+a*3.)*.2+.2;\n    float pupilSize = 0.025+sin(sineTime-(p.y-p.x)*2.)*0.005;\n    eyeColor*=smoothstep(pupilSize, pupilSize+.01, length(pos.zy));\n    s = opUnion(s, vec4(length(pos)-.06, eyeColor));\n    p*=.8;\n    //p.y -= .01;\n    pR(p.yz, 1.);\n    pos = p;\n    i = pModPolar(pos.xz, 10., sineTime);\n    pR(pos.xy, -sineTime*.5);\n    j = pModPolar(pos.yx, 5., sineTime);\n    float box = fBox(pos, vec3(0., .1*smoothstep(0., .1,length(p-vec3(0., .1, 0.))), 0.));\n    vec4 b = vec4(box, sin((pos.y*8.+vec3(0., .66, .33))*7.-sineTime+atan(p.x, p.z))*.5+.5);\n    b = fOpUnionRound(b, vec4(length(p)-.05, 1, 1, 1), .1);\n    s = opUnion(s, b); \n\treturn Model(s.x, s.yzw);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.;\nconst float INTERSECTION_PRECISION = .00001;\nconst int NUM_OF_TRACE_STEPS = 100;\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        //if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n        //    break;\n        //}\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvec3 render(Hit hit){\n    if (hit.isBackground) {\n        return vec3(0);\n    }\n    vec3 color = hit.model.color;\n    color += sin(dot(hit.normal, vec3(0,1,0))) * .2; // lighting\n    color *= 1. - clamp(hit.ray.len * .4 - .8, 0., 1.); // fog\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    vec3 camPos = vec3(0, 0, .4);\n    vec3 camTar = vec3(0);\n    float camRoll = 0.;\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camRoll);\n    \n    vec3 rd = normalize(camMat * vec3(p.xy, 2.));\n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    float f = .85;\n    //color *= smoothstep(f+.05, f, abs(p.y-.08)-abs(p.x)*.1);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[604, 604, 668, 668, 846], [848, 848, 911, 911, 1340], [1341, 1341, 1381, 1381, 1502], [1505, 1505, 1550, 1550, 1646], [1652, 1652, 1707, 1707, 1828], [1829, 1829, 1863, 1863, 1917], [1919, 1919, 1951, 1951, 1993], [1994, 1994, 2014, 2014, 2039], [2041, 2041, 2061, 2061, 2096], [2098, 2098, 2118, 2118, 2163], [2165, 2165, 2185, 2185, 2210], [2212, 2212, 2232, 2232, 2267], [2269, 2269, 2289, 2289, 2334], [2336, 2336, 2364, 2364, 2445], [2447, 2447, 2507, 2507, 2578], [2581, 2601, 2620, 2620, 4204], [4770, 4770, 4801, 4801, 5058], [5064, 5064, 5094, 5094, 5886], [6023, 6023, 6044, 6044, 6284], [6287, 6287, 6344, 6344, 6812]], "test": "untested"}
{"id": "WtcyRX", "name": "Stereoscopic 3D image extraction", "author": "xavierseb", "description": "Attempts to extract 3D stereoscopic image from a video, in Amber/Blue or Red/Green, easily adapted for other color combinations.\nThe idea is to extract images when the video's camera is panning left/right, or subject is moving left/right or rotating.", "tags": ["stereo3dstereoscopic"], "likes": 3, "viewed": 382, "published": 3, "date": "1609553981", "time_retrieved": "2024-07-30T19:47:38.573856", "image_code": "//\n// Stereoscopic 3D Amber/Blue image extracted from video\n// this extracts Left and Right eye image from a video in which either the subject\n// or the camera is panning Left/Right, \n// or the subject is rotating\n// \n// Needs Amber/Blue or Red/Green glasses to view in stereo 3D\n//\n// Please set parameters in Common Section\n// \n// frame grabbing technique from: www.shadertoy.com/view/MtsfW2\n\n// Might need to REWIND / RESTART the shader a few times to get a good result.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n        O = texture(iChannel0, U/iResolution.xy)     *2.8\n              + texture(iChannel1, U/iResolution.xy) *3.9;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// specify the distance between Left and Right images, \n// higher refresh rate might need higher offset value ? \n// try values :\n//     25 FPS->.08 , 60 FPS->.16 (estimated)\n//const float LR_Offset = .16;    // if you have a fast graphics card, try .16 or higher\nconst float LR_Offset = .08;      // seems to work well at 25fps\n\n// specify suitable Left/Right frame grab location in the movie\n//const float Frame_Pos = 1.7;\nconst float Frame_Pos = 3.35;\n\n#define AMBER vec4(.33,.33,0,1)\n#define BLUE  vec4(0,0,.67,1)\n\n#define RED   vec4(.25,0,0,1)\n#define GREEN vec4(0,.25,0,1)\n\n\n//Set the Color mode red/green or amber/blue\n\n#define LEFT AMBER\n#define RIGHT BLUE\n\n//#define LEFT RED\n//#define RIGHT GREEN", "buffer_a_code": "// RIGHT eye's image\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iChannelTime[1] < Frame_Pos ) {\n        O = texture( iChannel1, U/iResolution.xy);\n        if( distance(O, vec4(0,1,0,1))<.67 ) O=vec4(0);\n        else O *= RIGHT;\n    }\n    else O = texture( iChannel0, U/iResolution.xy);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// LEFT eye's image\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( iChannelTime[1] < Frame_Pos + LR_Offset ) {\n        O = texture( iChannel1, U/iResolution.xy);\n        if( distance(O, vec4(0,1,0,1))<.67 ) O=vec4(0);\n        else O *= LEFT; \n    }\n    else O = texture( iChannel0, U/iResolution.xy);\n}\n", "buffer_b_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[475, 475, 513, 513, 632]], "test": "untested"}
{"id": "wldcR2", "name": "Radially Symmetrical LP Filter", "author": "TinyTexel", "description": "The radially symmetrical brick wall low pass filter.\nIt's power spectrum is an Airy Disk: https://en.wikipedia.org/wiki/Airy_disk\n\nThe kernel radius scales with the horizontal mouse position.\n", "tags": ["filter", "lowpass"], "likes": 7, "viewed": 481, "published": 3, "date": "1609550726", "time_retrieved": "2024-07-30T19:47:39.355765", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    The radially symmetrical brick wall low pass filter.\n    It's spectral power spectrum is an Airy Disk: https://en.wikipedia.org/wiki/Airy_disk\n    \n    The kernel radius scales with the horizontal mouse position.\n    \n    See BufferA for the kernel.\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // spectrum 2d plot\n        float dc = length(textureLod(iChannel1, (vec2(SIZE*0.5+0.5)/iResolution.xy), 0.).xy);\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n        \n        float s = 0.9;\n        amp *= s;\n        dc *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        //if(amp <= dc) col = vec3(1.0, 0.0, 1.0);\n    }\t\n    else\n    {\n        // kernel 2d plot\n        float n = textureLod(iChannel0, tc, 0.).r;\n        n *= 32.0;\n        //n= n*0.5+0.5;\n        col = vec3(abs(n));\n        if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(col, vec3(1.0/2.2));\n    }\n    \n    // kernel 1d plot\n    if (uv0.y > SIZE && uv0.x < SIZE)\n    {\n        vec2 tc = (uv0 - vec2(0.0, SIZE)) / (iResolution.xy - SIZE);\n        \n        float v = 0.0;\n        \n        float f = texelFetch(iChannel0, ivec2(vec2(tc.x*SIZE, SIZE*0.5)), 0).r;\n        \n        f *= 1.;\n        \n        //f = sqrt(abs(f*2.0)) * sign(f);\n        //f = (1.0 - exp2(-abs(f)*2.0))*sign(f);\n        \n        col = vec3(0.0);\n        \n        // antialias plot (lazy brute force)\n        float count = 8.0;\n        for(float i = -count; i <= count; ++i)\n        {\n            float h = (tc.y + (i/count*1.) / (iResolution.y - SIZE)) * 2.0 - 1.0;\n            h += 0.25;\n\n            v = f < h ? 0.0 : 1.0;\n\n            col +=  mix(vec3(v), mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.02, 0.1), v), bvec3(h <= 0.0));\n        }\n        col /= count*2.0+1.0;\n        \n        col = pow(col, vec3(1.0/2.2));\n        \n    }\n    \n    // spectrum 1d plot\n    if (uv0.y > SIZE && uv0.x > SIZE)\n    {\n        vec2 tc = (uv0 - SIZE) / (iResolution.xy - SIZE);\n        \n        float v = 0.0;\n        \n        float f = length(texelFetch(iChannel1, ivec2(vec2(SIZE*0.5 + (tc.x-0.5)*SIZE, SIZE*0.5+ (tc.x-0.5)*SIZE)), 0).xy);// diagonal cross section\n        //float f = length(texelFetch(iChannel1, ivec2(vec2(SIZE*0.5 + (tc.x-0.5)*SIZE, SIZE*0.5)), 0).xy);// horizontal cross section\n        \n        f *= 0.75;\n        \n        //v = f < tc.y ? 0.0 : 1.0;\n        v = smoothstep(0.0, 1.0, (f - tc.y) * (iResolution.y - SIZE) * 0.5);\n        \n        col = vec3(v) * vec3(0.25, 1.0, 0.75);\n    }\n\n    outCol = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    The radially symmetrical brick wall low pass filter.\n    It's power spectrum is an Airy Disk: https://en.wikipedia.org/wiki/Airy_disk\n*/\n\nfloat LP(float x) { return x == 0.0 ? Pi * 0.25 : BesselJ1(x * Pi) / x * 0.5; }\n\nfloat LP_HalfLaplacian(float x)\n{\n    float xx = x*x;\n    return xx == 0.0 ? Pi/6.0 : (BesselJ1(x * Pi) * (2.0 * x - StruveH0(x * Pi)) + BesselJ0(x * Pi) * StruveH1(x * Pi)) / (4.0 * xx);\n}\n\nfloat Sinc(float x) { return x == 0.0 ? 1.0 : sin(x * Pi) / (x * Pi); }\n\n\nfloat Map(uvec2 uv)\n{\n    vec2 tc = vec2(uv);\n    \n    float signal = 0.0;\n    \n    float count = .0;// count of aliases in spatial domain (>0 reduces artifacts resulting from kernel truncation)\n    for(float i = -count; i <= count; ++i)\n    for(float j = -count; j <= count; ++j)\n    {\n        vec2 off = vec2(i, j) * SIZE;\n        vec2 tc2 = tc.xy+off-SIZE*0.5;\n        float l = length(tc2);\n\n        l *= mix(1.0/64.0, 1.0, Pow2(1.0-(iMouse.x/iResolution.x)));\n\n       #if 1\n        signal += LP(l);\n       #elif 1\n        signal += LP_HalfLaplacian(l);\n       #elif 1\n        signal += Sinc(l);// nope\n       #endif\n    }\n    \n    return signal;\n}\n\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n        return;\n    }\n    \n    \n    uvec2 uv = uvec2(uv0 - 0.5);\n    \n    float v = Map(uv);\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}", "buffer_a_inputs": [], "buffer_b_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(20.0); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n\n\n// https://www.shadertoy.com/view/Wt3czM | Bessel J0/J1 + Struve H0/H1\n\n// https://link.springer.com/article/10.1007/s40314-020-01238-z\nfloat BesselJ0(float x)\n{\n    float xx = x * x;\n    float lamb = 0.865;\n    float q    = 0.7172491568;\n    float p0   = 0.6312725339;\n    float ps0  = 0.4308049446;\n    float p1   = 0.3500347951;\n    float ps1  = 0.4678202347;\n    float p2   =-0.06207747907;\n    float ps2  = 0.04253832927;\n\n    float lamb4 = (lamb * lamb) * (lamb * lamb);\n    float t0 = sqrt(1.0 + lamb4 * xx);\n    float t1 = sqrt(t0);\n    \n    return xx == 0.0 ? 1.0 : 1.0/(t1 * (1.0 + q * xx)) * ((p0 + p1*xx + p2*t0) * cos(x) + ((ps0 + ps1*xx) * t0 + ps2*xx) * (sin(x)/x));\n}\n\n// https://www.sciencedirect.com/science/article/pii/S2211379718300111\nfloat BesselJ1(float x)\n{\n    float xx = x * x;\n\n    return (sqrt(1.0 + 0.12138 * xx) * (46.68634 + 5.82514 * xx) * sin(x) - x * (17.83632 + 2.02948 * xx) * cos(x)) /\n           ((57.70003 + 17.49211 * xx) * pow(1.0 + 0.12138 * xx, 3.0/4.0) );\n}\n\n// https://research.tue.nl/nl/publications/efficient-approximation-of-the-struve-functions-hn-occurring-in-the-calculation-of-sound-radiation-quantaties(c68b8858-9c9d-4ff2-bf39-e888bb638527).html\nfloat StruveH0(float x)\n{\n    float xx = x * x;\n\n    return BesselJ1(x) + 1.134817700  * (1.0 - cos(x))/x - \n                         1.0943193181 * (sin(x) - x * cos(x))/xx - \n                         0.5752390840 * (x * 0.8830472903 - sin(x * 0.8830472903))/xx;\n}\n\n// https://research.tue.nl/nl/publications/efficient-approximation-of-the-struve-functions-hn-occurring-in-the-calculation-of-sound-radiation-quantaties(c68b8858-9c9d-4ff2-bf39-e888bb638527).html\nfloat StruveH1(float x)\n{\n    const float pi = 3.14159265359;\n\n    float xx = x * x;\n\n    return 2.0/pi - BesselJ0(x) + 0.0404983827 * sin(x)/x + \n                                  1.0943193181 * (1.0 - cos(x))/xx - \n                                  0.5752390840 * (1.0 - cos(x * 0.8830472903))/xx;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldcR2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[332, 332, 378, 378, 2881]], "test": "untested"}
{"id": "tldyR2", "name": "Nicolas rain", "author": "levonchic", "description": "It's raining Cage", "tags": ["bitmap", "rain", "pixelart", "meme", "nicolascage"], "likes": 17, "viewed": 725, "published": 3, "date": "1609544165", "time_retrieved": "2024-07-30T19:47:40.124709", "image_code": "// MIT License (c) bitrate16\n#define LAYERS 16            // Cage layers count\n#define LAYER_SPEED 0.25      // Layer speed increment\n#define LAYER_SPEED_DEF 25.0 // Layer0 speed\n#define LAYER_SCALE 0.25      // Layer scale increment\n#define DENS_LIMIT 0.5       // Noise density limit\n\n// Ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float density){\n\tvec2 ij = floor(p/density);\n\tvec2 xy = mod(p,density)/density;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(3.1415*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\n// Composite paste layer A into layer B\nvec4 composite(in vec4 a, in vec4 b) {\n    return a * a.a + b * (1.0 - a.a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Rotate cage\n    float s = sin(0.1);\n    float c = cos(0.1);\n    mat2 rot = mat2(c, -s, s, c);\n    fragCoord *= rot * 0.9;\n    fragCoord += iResolution.xy * 0.1;\n    \n    for (float i = float(LAYERS); i > 0.0; i -= 1.0) {\n        // Calculate grid cell coords\n        vec2 grid = (\n                     fragCoord.xy \n                      + // Change speed for each layer\n                      iTime * LAYER_SPEED_DEF * (i * LAYER_SPEED + 1.0) \n                      + // Change noise frag coords\n                      vec2(i * 9131.7, i * 12371.3)) \n                     / \n                     (\n                      vec2(float(WIDTH), float(HEIGHT)) \n                       * // Scale the image (grid cell)\n                       (i * LAYER_SCALE + 1.0) \n                    ); \n        \n        // Get noise sample value\n        // Round grid coords to get noise frag coords\n        // > floor(grid)\n        float n = noise(floor(grid), 1.);\n\n        // Calculate texture mapping coords relative to grid coords\n        // > fract(grid) * vec2(WIDTH, HEIGHT)\n        if (n > DENS_LIMIT)\n            fragColor = composite(texelFetch(iChannel0, ivec2(fract(grid) * vec2(WIDTH, HEIGHT)), 0), fragColor);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25173, "src": "https://soundcloud.com/parismusicmusic/its-raining-men-originally-1", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// MIT License (c) bitrate16\n// Texture unpack, no buffering\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 frag = ivec2(fragCoord);\n    \n    if (frag.x >= WIDTH || frag.y >= HEIGHT)\n        return;\n    else {           \n\n        int px = frag.y * WIDTH + frag.x;\n        int pind = px / POINTS4INT;\n        int bind = px % POINTS4INT;\n\n        fragColor = palette[(matrix[pind] >> (bind * COLORBITS)) & COLORMASK];\n        fragColor *= fragColor.a;\n    }\n}", "buffer_a_inputs": [], "common_code": "// MIT License (c) bitrate16\n// Contains raw image\n\n#define WIDTH 40\n#define HEIGHT 52\n#define COLORS 16\n#define COLORBITS 4\n#define COLORMASK 15\n#define POINTS4INT 8\n#define INTPERFRAME 260\n#define FRAMES 1\n\nvec4[16] palette = vec4[16] (\n\tvec4(0.9098039215686274, 0.592156862745098, 0.4, 1.0),\n\tvec4(0.6039215686274509, 0.32941176470588235, 0.17254901960784313, 1.0),\n\tvec4(0.3764705882352941, 0.17254901960784313, 0.043137254901960784, 1.0),\n\tvec4(0.996078431372549, 0.807843137254902, 0.5803921568627451, 1.0),\n\tvec4(0.18823529411764706, 0.08627450980392157, 0.00784313725490196, 1.0),\n\tvec4(0.8, 0.4588235294117647, 0.28627450980392155, 1.0),\n\tvec4(0.4117647058823529, 0.2901960784313726, 0.1450980392156863, 1.0),\n\tvec4(0.6745098039215687, 0.44313725490196076, 0.2823529411764706, 1.0),\n\tvec4(0.9607843137254902, 0.7215686274509804, 0.5215686274509804, 1.0),\n\tvec4(0.5294117647058824, 0.19215686274509805, 0.06274509803921569, 1.0),\n\tvec4(0.7176470588235294, 0.5450980392156862, 0.36470588235294116, 1.0),\n\tvec4(0.7803921568627451, 0.3686274509803922, 0.22745098039215686, 1.0),\n\tvec4(0.403921568627451, 0.3686274509803922, 0.25882352941176473, 1.0),\n\tvec4(1.0, 1.0, 0.9294117647058824, 1.0),\n\tvec4(1.0, 1.0, 0.0, 0.0),\n\tvec4(0.027450980392156862, 0.0, 0.0, 1.0)\n);\n\nint[260] matrix = int[260] (\n\n\n// Frame 0\n\t0x266eeeee,\n\t0xeeeeee42,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x17116eee,\n\t0xeee24266,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x75a776ee,\n\t0xe2442661,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x55000ace,\n\t0x22226617,\n\t0xeeeeeee2,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x5000007e,\n\t0x22661777,\n\t0xeeeee222,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xe,\n\t0x22611500,\n\t0xeeee2226,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xae,\n\t0x21771000,\n\t0xeee22612,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x50000ae,\n\t0x6a770000,\n\t0xe2226162,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x705000ae,\n\t0x77507115,\n\t0x22621666,\n\t0xeeeeeee2,\n\t0xeeeeeeee,\n\t0x500000ae,\n\t0x1115b,\n\t0x22211617,\n\t0xee21e422,\n\t0xeeeeeeee,\n\t0xb00000a6,\n\t0x11991b,\n\t0x22211610,\n\t0xe9112422,\n\t0xeeeeeeee,\n\t0x915b080c,\n\t0x51f2111,\n\t0x22111118,\n\t0x92992222,\n\t0xeeeeeee2,\n\t0x91210806,\n\t0x741a222,\n\t0x26611151,\n\t0x29112222,\n\t0xeeeeeee2,\n\t0xd7f10007,\n\t0x7122a003,\n\t0x22111557,\n\t0x49911222,\n\t0xeeeeee92,\n\t0x33325807,\n\t0x71119108,\n\t0x62117001,\n\t0x29112222,\n\t0xeeeeee99,\n\t0x5039000a,\n\t0x71175555,\n\t0x61115001,\n\t0x22112222,\n\t0xeeeeef91,\n\t0x512100a,\n\t0x7115000,\n\t0x11150000,\n\t0x11162222,\n\t0xeeeeef99,\n\t0x7170a,\n\t0x5177700,\n\t0x11550000,\n\t0x912f2211,\n\t0xeeeef221,\n\t0x500a,\n\t0x99122170,\n\t0x11000083,\n\t0x24ff9211,\n\t0xeeeff211,\n\t0x55000200,\n\t0x22924221,\n\t0x15008330,\n\t0xfff21111,\n\t0xeeefffff,\n\t0x55000100,\n\t0x79157290,\n\t0x7b000300,\n\t0xfff21211,\n\t0xeeffffff,\n\t0x2009500,\n\t0x9b51150,\n\t0x15500030,\n\t0xfff21111,\n\t0xeeffffff,\n\t0x550000,\n\t0x11111b03,\n\t0x10000000,\n\t0xff411111,\n\t0xefffffff,\n\t0x333303,\n\t0x511b500,\n\t0x11115000,\n\t0xff211111,\n\t0xefffffff,\n\t0x833330e,\n\t0x1115000,\n\t0x22115100,\n\t0xf4211111,\n\t0xefffffff,\n\t0x3333338e,\n\t0x71110800,\n\t0x21172007,\n\t0xf2211111,\n\t0xefffffff,\n\t0x3388308e,\n\t0x11158003,\n\t0x2286f210,\n\t0xf4212211,\n\t0xffffffff,\n\t0x308880ee,\n\t0x11108003,\n\t0x1273ad17,\n\t0xf2212211,\n\t0xffffffff,\n\t0x38ee,\n\t0x11580000,\n\t0x1221111,\n\t0xf221262b,\n\t0xffffffff,\n\t0x50000eee,\n\t0x15830111,\n\t0x50522171,\n\t0xf22121f2,\n\t0xffffffff,\n\t0x60008eee,\n\t0x300134,\n\t0xf2777770,\n\t0x2221112f,\n\t0xfffffff4,\n\t0x63106eee,\n\t0x300136,\n\t0x4fff4217,\n\t0x22111172,\n\t0xffffff42,\n\t0x86106eee,\n\t0x800128,\n\t0x7644610,\n\t0x21111710,\n\t0xfffffff4,\n\t0x1102eeee,\n\t0x33317011,\n\t0x800303,\n\t0x21115550,\n\t0xff4ff422,\n\t0x82eeee,\n\t0x33301200,\n\t0x883333,\n\t0x21111550,\n\t0xfff4ff42,\n\t0xa66eeee,\n\t0x33381490,\n\t0x3333,\n\t0x21115550,\n\t0xfff44ff2,\n\t0x6446eeee,\n\t0x33338644,\n\t0x3333,\n\t0x21111500,\n\t0xef444ff4,\n\t0x284aeeee,\n\t0x3333306f,\n\t0x833333,\n\t0x21111500,\n\t0xef442fff,\n\t0x876eeeee,\n\t0x33333330,\n\t0x383333,\n\t0x42211550,\n\t0xeef42f4f,\n\t0x866eeeee,\n\t0x33333300,\n\t0x833333,\n\t0x42221150,\n\t0xeee424ff,\n\t0x74eeeeee,\n\t0x33333800,\n\t0x33333,\n\t0xfff44210,\n\t0xeeee444f,\n\t0x46eeeeee,\n\t0x33333888,\n\t0x833333,\n\t0xff4ff421,\n\t0xeeeeef4f,\n\t0x6eeeeeee,\n\t0x38308886,\n\t0x15083338,\n\t0xfff4f442,\n\t0xeeeeeeff,\n\t0xeeeeeeee,\n\t0x83a64,\n\t0x42100000,\n\t0xff4f4ff4,\n\t0xeeeeee44,\n\t0xeeeeeeee,\n\t0x7aa72646,\n\t0xf4222111,\n\t0xfffff4f4,\n\t0xeeeeeeef,\n\t0xeeeeeeee,\n\t0x2666624e,\n\t0xf4f44222,\n\t0x4f4f22ff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x244664ee,\n\t0x4444fff4,\n\t0xeef444ff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x22444eee,\n\t0x444f2f4f,\n\t0xee4f444f,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x24644eee,\n\t0xf4444f24,\n\t0xeeee4fff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x4644eeee,\n\t0xf4422442,\n\t0xeeeee4ff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x4cfeeeee,\n\t0xff44f24f,\n\t0xeeeeeeff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x4eeeeeee,\n\t0xeeee4444,\n\t0xeeeeeeee,\n\t0xeeeeeeee\n);", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldyR2.jpg", "access": "api", "license": "mit", "functions": [[287, 361, 380, 380, 448], [450, 450, 485, 485, 836], [838, 878, 916, 916, 956], [958, 958, 1013, 1032, 2232]], "test": "untested"}
{"id": "tltyR2", "name": "SoftClip2", "author": "TinyTexel", "description": "Another soft clip that generalizes the Reinhard tonemapping transfer function.", "tags": ["function", "tonemapping", "clip", "transfer"], "likes": 9, "viewed": 380, "published": 3, "date": "1609541758", "time_retrieved": "2024-07-30T19:47:40.899637", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// https://twitter.com/Mirko_Salm\n\n/*\n\tAnother soft clip that generalizes the Reinhard tonemapping transfer function:\n    \n    (    x + x^2 + x^3 + ... + x^n)\n    -------------------------------\n    (1 + x + x^2 + x^3 + ... + x^n) \n    \n    This version discretely truncates the series to n terms instead of \n    smoothly blending the higher order terms out as the orignal SoftClip did.    \n    \n    related: \n    \n            https://www.shadertoy.com/view/wdtfRS | SoftClip\n            https://www.shadertoy.com/view/dt3fWl | GeneralizedClip\n*/\n\nfloat Reinhard(float x) { return x / (x + 1.0); }\nfloat ExpClip (float x) { return 1.0 - exp(-x); }\nfloat HardClip(float x) { return   min(x, 1.0); }\n\n// x: [0, inf], n: [0, inf] / (soft, hard]\nfloat SoftClipN(float x, float n)\n{\n#if 1\n    // analytical form by SnoopethDuckDuck\n    float u = pow(x, n + 1.0);\n    \n    return (u - x) / (u - 1.0);\n#else\n    float u = x;\n    \n    for(float i = 1.0; i < n; ++i)\n    u = u * x + x;\n    \n    return u / (u + 1.0);\n#endif\n}\n\nfloat SoftClip2(float x)\n{\n    float u = x + x*x;\n    \n    return u / (u + 1.0);\n}\n\nfloat SoftClip3(float x)\n{\n    float u = (x + x*x) * x + x;\n    \n    return u / (u + 1.0);\n}\n\nfloat SoftClip4(float x)\n{\n    float u = ((x + x*x) * x + x) * x + x;\n    \n    return u / (u + 1.0);\n}\n\nfloat SoftClip5(float x)\n{\n    float u = (((x + x*x) * x + x) * x + x) * x + x;\n    \n    return u / (u + 1.0);\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    // relevant plotting code:\n    \n    // black\n    col = mix(col, vec3(0.), Graph(HardClip(tex.x) -tex.y, 1.));  \n    col = mix(col, vec3(0.), Graph(Reinhard(tex.x) -tex.y, 1.));  \n    \n    // grey\n    col = mix(col, vec3(0.5), Graph(ExpClip(tex.x) -tex.y, 1.) * 0.5);  \n    \n    // blue\n    col = mix(col, vec3(0.125, 0.5, 1.0), Graph(SoftClip2(tex.x) -tex.y, 1.));  \n    col = mix(col, vec3(0.125, 0.6, 1.0), Graph(SoftClip3(tex.x) -tex.y, 1.));  \n    col = mix(col, vec3(0.125, 0.7, 1.0), Graph(SoftClip4(tex.x) -tex.y, 1.));  \n    col = mix(col, vec3(0.125, 0.8, 1.0), Graph(SoftClip5(tex.x) -tex.y, 1.));  \n    \n    float n = 0.5 + 16.0 * (sin(iTime) * 0.5 + 0.5);\n    col = mix(col, vec3(1., 0.2, 0.1), Graph(SoftClipN(tex.x, n) -tex.y, 1.));  \n    \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltyR2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[617, 617, 642, 642, 666], [667, 667, 692, 692, 716], [717, 717, 742, 742, 766], [768, 811, 846, 846, 1085], [1087, 1087, 1113, 1113, 1169], [1171, 1171, 1197, 1197, 1263], [1265, 1265, 1291, 1291, 1367], [1369, 1369, 1395, 1395, 1481], [1484, 1484, 1532, 1532, 2911]], "test": "untested"}
{"id": "WldczS", "name": "a taste of the physically base 2", "author": "Ric3cir121", "description": "Credits to: https://www.shadertoy.com/view/WltyzS", "tags": ["taste"], "likes": 6, "viewed": 318, "published": 3, "date": "1609541050", "time_retrieved": "2024-07-30T19:47:41.719445", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = pow(texelFetch(iChannel0,ivec2(u),0),vec4(.5))*1.3;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI acos(-1.)\n#define MIN_DIST 0.001\n#define MAX_DIST 1500.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(0.6619, 0.3542, 0.3158)\n#define MAT_ERNST0_006 vec3(0.6619, 0.6108, 0.5172)\n#define MAT_ERNST0_002 vec3(0.3324, 0.6921, 0.5215)\n#define MAT_ERNST0_003 vec3(0.6982, 0.4874, 0.0414)\n#define MAT_ERNST0_001 vec3(0.1334, 0.42, 0.1273)\n#define MAT_ERNST0_005 vec3(0.1025, 0.0915, 0.0915)\n#define MAT_ERNST0_004 vec3(0.2306, 0.2807, 0.6619)\n\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p){\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat vmax(vec3 v){return max(max(v.x, v.y), v.z);}\nfloat sdEllipsoid(in vec3 p, in vec3 r){return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);}\nfloat sdCapsule(vec3 p, float r, float c){return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));}\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\nfloat sdCappedTorus(vec3 p, vec2 r, float per){\n\tp.x = abs(p.x);\n\tvec2 sc = vec2(sin(per),cos(per));\n\tfloat k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n\treturn sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\nfloat sdPieCylinder( vec3 p, float r, float h, float per ){\n\tper = mod(per, PI);\n\tvec2 c = vec2(sin(per),cos(per));\n\tp.xz=c.y*p.xz+c.x*vec2(p.z,-p.x);\n\tp.x = abs(p.x);\n\tfloat l = length(p.xz) - r;\n\tfloat m = length(p.xz-c*clamp(dot(p.xz,c),0.0, r));\n\tfloat x = max(l,m*sign(c.y*p.x-c.x*p.z));\n\tfloat y = abs(p.y) - h;\n\treturn ((min(max(x,y),0.0) + length(max(vec2(x,y),0.0))));\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y );\n\tvec2 k1 = vec2(r2,h);\n\tvec2 k2 = vec2(r2-r1,2.0*h);\n\tvec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n\tvec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n\tfloat s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n\treturn s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdRoundCone( vec3 p, float h, float r1, float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y+h*.5 );\n\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\tfloat k = dot(q,vec2(-b,a));\n\n\tif( k < 0.0 ) return length(q) - r1;\n\tif( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n\treturn dot(q, vec2(a,b) ) - r1;\n}\nfloat sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));}\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n}\nvec4 sd002(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=10.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -4.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -5.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpSubstractionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\nvec4 sd001(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=15.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -8.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_005), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -9.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpIntersectionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp001 = p;\n\tcp001.xyz += vec3(-8.0856, -4.9245, -10.7845);\n\tpRepLimited(cp001.y, 2.5, 3.);\n\tpRepLimited(cp001.z, 1.25, 4.);\n\tpRepLimited(cp001.x, 1.25, 4.);\n\n\tres = sd001(p);\n\tres = v4OpUnionSmooth(sd002(p), res, .01);\n\n\td = sdBox(p+vec3(0.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdBox(p+vec3(3.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.3)-0.3, d, 0.01);\n    \n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_003), res, .01);\n\n\td = sdCappedCylinder(p+vec3(0.0, -1.0, -9.0), vec2(1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdCappedCylinder(p+vec3(3.0, -1.0, -9.0), vec2(1.0, 1.0)-0.3)-0.3, d, 0.01);\n    \n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, .01);\n\n\td = sdCappedTorus(p+vec3(-3.0, -0.5, -12.0), vec2(1.0, 0.5), 2.356);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_004), res, .01);\n\n\td = sdCapsule(p+vec3(-3.0, -1.0, 0.0), 0.59, 0.44);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(0.0, -1.021, -3.0), 1.0-0.01, 1.02-0.01, 0.0)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(3.0, -1.021, -3.0), 1.0-0.1, 1.02-0.1, 0.0)-0.1, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, .01);\n\n\td = sdEllipsoid(p+vec3(0.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, .01);\n\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, 0.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, .01);\n\n\td = sdEllipsoid(p+vec3(-3.0, -1.5, -3.0), vec3(1.0, 1.5, 1.0));\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(0.0, -1.0, -12.0), 1.0-0.01, 1.0-0.01, 2.356)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(3.0, -1.0, -12.0), 1.0-0.3, 1.0-0.3, 2.356)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, .01);\n\n\td = p.y;\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_002), res, 0.01);\n\n\t{\n        // sdHex\n\t\tvec3 tp = p+vec3(-6.0, -1.1, 0.0);\n\t\tvec3 trp = p.xzy+vec3(-6.,-1.1,0)+vec3(0,1,-1.1);//rot(p+vec3(-6.0, -1.1, 0.0), vec3(1.5708, 0.0, 0.0));\n\t\tvec3 dim = vec3(0.75, 0.75, 1.0);\n\t\tfloat td = MAX_DIST;\n        \n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.01;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_005), res, 0.01);\n\n\t{\n\t\tvec3 tp = cp001;\n\t\tvec3 trp = cp001;\n\t\tvec3 dim = vec3(0.6342, 1.0, 0.6342);\n\t\tfloat td = MAX_DIST;\n\t\t\n\t\tfloat r = max(dim.x, dim.z);\n\t\tfloat c = dim.y*.5;\n\t\tfloat elg = c-min(.5,c);\n\t\ttrp.y -= clamp(trp.y,-elg,elg);\n\t\t\n\t\tfloat a = .5*trp.y*trp.y+.5;\n\t\tfloat b = abs(trp.y);\n\t\ttrp.y = b<1. ? a : b;\n\t\t\n\t\ttrp.y -= min(.5,c);\n\t\ttd = length(trp)-r;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_006), res, 0.01);\n\n\td = sdRoundCone(p+vec3(-3.0, -1.5, -6.0), 1.5, 0.765, 0.0);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdTorus(p+vec3(-3.0, -0.5, -9.0), vec2(1.0, 0.5));\n\td = fOpUnionSmooth(sdBox(p+vec3(-12.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\treturn res;\n}\nmat2 rotate(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec3 rotate(vec3 c,float r){return vec3(rotate(r)*c.xz,c.y).xzy;}\nfloat de(vec3 c){\n    return sdScene(c).x+fract(length(vec3(hash11(c.x),hash11(c.y),hash11(c.z)))*100.)/1000.;\n}\nvec4 doMarch(vec3 pos,vec3 cam){\n    int i = 0;\n    vec3 march = vec3(0);\n    float d = 1.;\n    \n    for(;i<100&&d>0.02&&length(march)<100.;i++){\n        d = de(pos+march);\n        march += d*cam;\n    }\n    return vec4(march+pos,i);\n}\nvec3 getnormal(vec3 n){\n    vec2 e = vec2(1.0,-1.0)*(n.y<0.002-1.?.002:.002);\n    return normalize(e.xyy*de(n+e.xyy)+e.yyx*de(n+e.yyx)+e.yxy*de(n+e.yxy)+e.xxx*de(n+e.xxx));\n}\nvec3 getcol(vec3 c){\n    return length(c)<50.?sdScene(c).yzw:vec3(.9);\n}\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 U = u;\n    u += fract(hash22(u+iTime)*10000.);\n\tvec2 uv = (u-iResolution.xy/2.)/iResolution.y;\n    \n    vec3 pos = vec3(-4,7,-4);\n    vec2 look = vec2(-.65,-.5);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    \n    vec4 march = doMarch(pos,cam);\n    vec3 col = getcol(march.xyz);\n    for(int i = 0;i<10;i++){\n        pos = march.xyz;\n        vec3 refl = reflect(cam,getnormal(pos));\n        pos += refl/10.;\n        cam = refl;\n        march = doMarch(pos,cam);\n        if(length(march.xyz)>100.)break;\n        col *= getcol(march.xyz);\n    }\n\to = vec4(col, 1.);\n    vec4 old = texelFetch(iChannel0,ivec2(U),0);\n    if(iFrame!=0)o = mix(o,old,.99);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 96]], "test": "untested"}
{"id": "tsKyD1", "name": "The Others", "author": "KaDokta", "description": "Maybe don't stay for too long.\n\n--\n\nKaDokta.com", "tags": ["2d", "tunnel", "eye", "orb", "floating"], "likes": 5, "viewed": 350, "published": 3, "date": "1609539793", "time_retrieved": "2024-07-30T19:47:42.680875", "image_code": "#define PI 3.14159265359\n#define TAU 2.0*PI\n#define ANIMATE true\n#define MOUSE_LOOK false\n#define TIME_OFFSET 60.0\n\n#define COL_OUTER_EYE vec3(0.5, 0.5, 0.7)\n#define COL_BACKGROUND vec3(0.04, 0.06, 0.1)\n#define COL_PUPIL_OUTER_START vec3(0.1, 0.3, 0.9)\n#define COL_PUPIL_OUTER_END vec3(0.8, 0.0, 0.0)\n#define COL_PUPIL_INNER vec3(1.0)\n#define COL_EYEBALL_COLOR vec3(0.1, 0.1, 0.1)\n#define COL_EYEBALL_TEXTURE_COLOR vec3(0.3, 0.1, 0.5)\n#define COL_ORB_BACKGROUND vec3(0.5, 0.1, 0.9)\n#define COL_ORB_OUTLINE vec3(0.8, 0.0, 0.0)\n#define COL_CANTHUS vec3(0.3, 0.0, 0.0)\n\n#define TIMER_PHASE_LOOK 30.0\n#define TIMER_PHASE_SPLIT 50.0\n#define TIMER_PHASE_FADEOUT 56.0\n#define TIMER_PHASE_RESET 60.0\n#define TIMER_PHASE_ALL 64.0\n\n\nstruct phaseInfo\n{\n    int id;\n    float time;\n};\n\n\nstruct orbInfo\n{\n    vec2 position;\n    float size;\n    float timedSeed;\n    float fixedSeed;\n};\n\n\nfloat ang(in vec2 from, in vec2 to)\n{\n    return atan(from.y - to.y, from.x - to.x);\n}\n\n\nfloat calculatePixelValue(in float currentDistance, in float maxWidth)\n{\n    return max(0.0, 1.0 - pow(abs(currentDistance - 1.0), 2.5) / (maxWidth));\n}\n\n\nfloat calculatePixelValueFilled(in float currentDistance, in float maxWidth)\n{\n    return max(0.0, 1.0 - pow(currentDistance - 1.0, 5.0) / (maxWidth));\n}\n\n\nfloat getTimedMix(in float phaseTimer, in float phaseTimeStart, in float duration)\n{\n    phaseTimer -= phaseTimeStart;\n    return min(phaseTimer/duration, 1.0);\n}\n\n\nfloat interpolateLinear(in float val1, in float val2, in float percentage)\n{\n    return mix(val1, val2, percentage);\n}\n\n\nfloat interpolateSmooth(in float val1, in float val2, in float percentage)\n{\n    return mix(val1, val2, -cos(PI * percentage) * 0.5 + 0.5);\n}\n\n\nvoid getNoiseValues(in float seed, in float offset, in float upperLimit, out float val1, out float val2, out float percentage)\n{\n    vec2 texSize = iChannelResolution[0].xy;\n    float maxSize = texSize.x * texSize.y - 1.0;\n    \n    offset = mod(offset, maxSize);\n    upperLimit = (upperLimit <= 0.0 ? maxSize : min(upperLimit + offset, maxSize));\n    \n    seed = offset + mod(seed, upperLimit - offset);\n    \n    percentage = fract(seed);\n    float lowerSeed = floor(seed);\n    float upperSeed = ceil(seed);\n    \n    if(upperSeed > upperLimit){ // Make clean repetition\n        upperSeed = offset;\n    }\n    \n    if(seed < ceil(offset)){ // Adjust for fractions (lower)\n        float maxFraction = ceil(offset) - offset;\n        percentage -= fract(offset);\n        percentage = percentage/maxFraction;\n    }\n    \n    if(seed > floor(upperLimit)){ // Adjust for fractions (upper)\n        float maxFraction = upperLimit - floor(upperLimit);\n        percentage = percentage/maxFraction;\n    }\n    \n    \n    float xValue1 = mod(lowerSeed, texSize.x);\n    float yValue1 = mod(floor(lowerSeed/texSize.y), texSize.y);\n    \n    float xValue2 = mod(upperSeed, texSize.x);\n    float yValue2 = mod(floor(upperSeed/texSize.y), texSize.y);\n    \n    vec4 tex1 = texelFetch(iChannel0, ivec2(xValue1, yValue1), 0);\n    vec4 tex2 = texelFetch(iChannel0, ivec2(xValue2, yValue2), 0);\n    \n    val1 = tex1.x;\n    val2 = tex2.x;\n}\n\n\nfloat getRandSmooth(in float seed, in float offset, in float repeatAt)\n{\n    float val1;\n    float val2;\n    float percentage;\n    \n    getNoiseValues(seed, offset, repeatAt, val1, val2, percentage);\n    return interpolateSmooth(val1, val2, percentage);\n}\n\n\nfloat getRandSmooth(in float seed)\n{\n\treturn getRandSmooth(seed, 0.0, 0.0);\n}\n\n\nfloat getRand(in float seed, in float offset, in float repeatAt)\n{\n    float val1;\n    float val2;\n    float percentage;\n    \n    getNoiseValues(seed, offset, repeatAt, val1, val2, percentage);\n    return interpolateLinear(val1, val2, percentage);\n}\n\n\nfloat getRand(in float seed, in float offset)\n{\n    return getRand(seed, offset, 0.0);\n}\n\n\nfloat getRand(in float seed)\n{\n    return getRand(seed, 0.0, 0.0);\n}\n\n\nfloat getFixedValue(in float duration)\n{\n    return iTime - mod(iTime, duration);\n}\n\n\nmat2 rotate(in float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nvec2 rotateVec(in vec2 startVec, in vec2 offset, in float angle)\n{\n    mat2 rotation = rotate(angle);\n    startVec = startVec - offset;\n    startVec *= rotation;\n    return startVec + offset;\n}\n\n\nfloat normalizedCos(in float value)\n{\n    return 0.5*(1.0-cos(value/PI*20.0));\n}\n\n\nfloat calculateParabola(in vec2 startPoint, in vec2 centerPoint, in float parabolaX, out float a, out float height)\n{\n    // General parabola formula: y = a*(x - x_center) + y_center\n    a = (startPoint.y - centerPoint.y) / pow(startPoint.x - centerPoint.x, 2.0);\n    float parabolaY = a*pow(parabolaX - centerPoint.x, 2.0) + centerPoint.y;\n    height = parabolaY - startPoint.y;\n    return parabolaY;\n}\n\n\nvoid drawBackLines(inout vec3 col, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy*0.5;\n    float angle = (ang(fragCoord, center) + PI) * 180.0/PI * 0.8 + iTime;\n    angle = mod(angle, 360.0);\n    float angleDisc = floor(angle);\n    \n    float timePerAngle = getRand(angleDisc, 0.0) * 2.0 + 5.0;\n    \n    float val = getRand(angleDisc, ANIMATE ? ceil(iTime/timePerAngle) * 180.0 : 0.0);\n    \n    if(val > 0.96){\n        float halfTime = timePerAngle * 0.5;\n        float timer = mod(iTime, timePerAngle);\n        timer = (timer > halfTime ? halfTime - abs(halfTime - timer) : timer) / halfTime;\n        \n        col -= col * smoothstep(round(angle), ceil(angle)-0.5, angle) * timer * 0.7;\n    }\n}\n\n\nvoid drawForeLines(inout vec3 col, in vec2 fragCoord, in float seed, in phaseInfo phase)\n{\n    if(!ANIMATE){\n        return;\n    }\n\n    vec2 center = iResolution.xy*0.5;\n    fragCoord = rotateVec(fragCoord, center, iTime * 0.02); \n    \n    float angle = (ang(fragCoord, center) + PI) * 180.0/(2.0*PI);\n    float angleDisc = floor(angle);\n       \n    float maxLength = (iResolution.x + iResolution.y) * 1.0;\n    \n    float timePerAngle = getRand(angleDisc, seed + 128.0) * 10.0 + 5.0;\n    float speedPerAngle = maxLength/timePerAngle;\n    \n    float timeStart = iTime + 0.0;\n    \n    float val = getRand(angleDisc, seed + (ANIMATE ? ceil((timeStart * speedPerAngle)/maxLength) * 10.0 : 0.0));\n    \n    if(val < 0.05){\n        float currentLength = mod(timeStart * speedPerAngle, maxLength);\n        float dist = length(fragCoord - center);\n        \n        float endMin = dist;\n        float endMax = dist + 3.0;\n        \n        float startMin = currentLength - maxLength*0.5;\n        float startMax = startMin + 3.0;\n        \n        float mixValue = 0.0;\n        \n        if(phase.id == 1){\n            mixValue = getTimedMix(phase.time, TIMER_PHASE_LOOK, 2.0);\n        }\n        else if(phase.id > 1 && phase.id < 4){\n            mixValue = 1.0;\n        }\n        \n        col += smoothstep(round(angle), ceil(angle)-0.5, angle) \n               * smoothstep(startMin, startMax, dist)\n               * smoothstep(endMin, endMax, currentLength)\n               * (1.0 - (timePerAngle / 15.0))\n               * mix(COL_PUPIL_OUTER_START, COL_PUPIL_OUTER_END, mixValue);\n    }\n}\n\n\nvoid drawSmoothedCircle(in vec2 position, in float radius, in float lineWidth, in vec3 lineColor, in vec3 backgroundColor, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float centerValue = length(fragCoord.xy - position);\n    \n\tcurrentColor += vec3(smoothstep(radius + lineWidth * 0.25, radius , centerValue)) * (lineColor - currentColor)\n         + vec3(smoothstep(radius, radius - lineWidth * 0.25, centerValue)) * (backgroundColor - currentColor);\n}\n\n\nvoid drawCircle(in vec2 position, in float radius, in float lineWidth, in vec3 lineColor, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float pixelFract = calculatePixelValue(length(fragCoord - position) - radius, lineWidth);\n    currentColor += vec3(pixelFract) * (lineColor - currentColor);\n}\n\n\nvoid drawFullCircle(in vec2 position, in float radius, in vec3 color, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float pixelFract = calculatePixelValueFilled(length(fragCoord - position) - radius, radius);\n    currentColor += vec3(pixelFract) * (color - currentColor);\n}\n\n\nvoid drawFilledSmoothedOval(in vec2 center, in float width, in float height, in vec3 color, inout vec3 currentColor, in vec2 fragCoord)\n{\n    vec2 size = vec2(width, height);\n    \n    float curValue = length((fragCoord.xy - center)/size);\n    float minValue = 1.0;\n    float maxValue = 1.0 - 0.04;\n    \n    currentColor += vec3(smoothstep(maxValue, minValue, curValue)) * (color - currentColor);\n}\n\n\nfloat calcFrayHeight(in float time, in float seed, in float angle, in float divs, in float amount)\n{\n    return getRandSmooth(time + angle * divs, seed, TAU * divs) * amount;\n}\n\n\nfloat calcRandHeightMultiplier(in float time, in float seed)\n{\n    return 1.0+(getRand(1.0 + (ANIMATE ? time : 0.0) * 1.0, seed) - 0.5) * 2.0;\n}\n\n\nfloat calcRandWobble(in float seed, in float angle, in float direction, in float divs, in float offset, in float amount)\n{\n    return (0.5-getRandSmooth(angle * divs + (ANIMATE ? iTime * -direction : 0.0), seed + offset, TAU * divs)) * amount;\n}\n\n\nvec3 drawFrayedCircle(in float time, in float seed, in float direction, in vec2 position, in phaseInfo phase, in float radius, in float lineWidth, in vec3 currentColor, in vec2 fragCoord)\n{  \n    if(!ANIMATE){\n        time = 0.0;\n    }\n    \n    float mixValue = 0.0;\n    \n    if(phase.id == 1){\n        mixValue = getTimedMix(phase.time, TIMER_PHASE_LOOK, 2.0);\n    }\n    else if(phase.id > 1 && phase.id < 4){\n        mixValue = 1.0;\n    }\n    \n    float angle = atan(fragCoord.y - position.y, fragCoord.x - position.x) + PI;    \n    \n    float divs = 50.0 * radius/iResolution.x + 5.0 + 10.0 * mixValue;\n    \n    radius = radius + calcFrayHeight(time, seed, angle, divs, radius * 0.1)\n        * calcRandHeightMultiplier(time, seed)\n        + calcRandWobble(seed, angle, direction, 3.0, 0.0, radius * 0.1);\n    \n    radius += calcFrayHeight(2.0*time, seed, angle, divs, radius * 0.1)\n        * calcRandHeightMultiplier(2.0*time, seed)\n        - calcRandWobble(seed, angle, direction, 4.0, TAU*10.0, radius * 0.1);;\n    \n    float valueInner = length(vec2(1.0, 2.0) * (fragCoord - position)) - radius;\n    float valueOuter = length(fragCoord - position) - radius;\n    \n    float offset = 0.2 + 0.5 * abs(sin(time * 0.2));\n    vec3 colorTexture = COL_ORB_BACKGROUND - vec3(0.0, 0.0, mod(valueInner - iTime * 50.0, iResolution.x/12.0)/radius);\n    \n    vec3 lineColor = mix(vec3(0.0), COL_ORB_OUTLINE, mixValue) * vec3(offset);\n    \n    return vec3(smoothstep(radius + 1.0 + lineWidth * 0.25, radius , valueOuter)) * (lineColor - currentColor)\n           + vec3(smoothstep(radius, radius - lineWidth * 0.25 * offset * 3.0, valueOuter)) \n           * (0.4 * colorTexture * valueInner/100.0 - (lineColor));\n}\n\n\nvoid drawParabola(in float parabolaY, in vec2 centerPoint, in float width,  in float lineWidth, in vec3 lineColor, inout vec3 currentColor, in vec2 fragCoord, out float height)\n{   \n    if(abs(fragCoord.x - centerPoint.x) <= width){\n        float pixelFract = calculatePixelValue(fragCoord.y - parabolaY, 2.0 * lineWidth);\n        currentColor = clamp(vec3(0.0), currentColor, vec3(1.0));\n        currentColor += vec3(pixelFract) * (lineColor - currentColor);\n    }\n}\n\n\nvoid drawBall(in float seed, in vec2 center, in vec2 pupilPosition, in float width, inout vec3 currentColor, in vec2  fragCoord)\n{\n    vec3 backgroundColor = COL_EYEBALL_COLOR;\n    \n    currentColor += backgroundColor - currentColor;\n    \n    vec2 toPosition = normalize(pupilPosition - center) * length(pupilPosition - center);\n    \n    float angle = ang(fragCoord, center - pupilPosition) + PI;\n    float draw = length(fragCoord - pupilPosition);\n    \n    float value = getRand(angle * iResolution.x/100.0 + getRand(draw / length(iResolution.xy) * 100.0, seed) \n                        *  iResolution.x/100.0 + iTime, seed, 2.0 * PI * 12.0) - 0.4;\n\n    currentColor += step(width*0.45, draw)\n                    * smoothstep(value, value + 8.0, (length(pupilPosition - fragCoord)+1.0)/width*2.0) * 6.0\n                    * (COL_EYEBALL_COLOR);\n\n    currentColor += smoothstep(width*0.55,width*0.6, width - draw)\n                    * (COL_EYEBALL_TEXTURE_COLOR);\n}\n\n\nvoid drawCanthus(in vec2 position, in float width, inout vec3 currentColor, in vec2 fragCoord)\n{\n    drawFilledSmoothedOval(position, width * 1.38, width * 1.4 * 0.55, COL_CANTHUS, currentColor, fragCoord);\n}\n\n\nvec2 addSaccade(in float seed, in float saccadeTimeMultiplier, in float movementMultiplier)\n{\n    if(!ANIMATE){\n    \treturn vec2(0.0);\n    }\n    \n    float saccadeInterval = max((getRand(getFixedValue(2.0), seed)+0.3)*saccadeTimeMultiplier, 0.6);  \n    float saccadeTimeFrame = getFixedValue(saccadeInterval);\n    float randomValue = getRand(saccadeTimeFrame / saccadeInterval, seed) - 0.5;\n    return movementMultiplier * randomValue * normalize(vec2(cos(randomValue), sin(randomValue)));\n}\n\n\nvec2 randomPosition(in float seed)\n{\n    if(!ANIMATE){\n        return vec2(0.0);\n    }\n    \n    float offsetInterval = max((getRand(getFixedValue(32.0), seed)+0.5)*5.0, 2.0);\n    float timeFrame = getFixedValue(offsetInterval);\n    float randomValue = getRand(timeFrame / offsetInterval, seed);\n    float randomValue2 = getRand(timeFrame / offsetInterval, 32.0 + seed);\n    return vec2(randomValue * iResolution.x, randomValue2 * iResolution.y);\n}\n\n\nfloat addPupilSize(in float seed)\n{\n    if(!ANIMATE){\n        return 0.0;\n    }\n    \n    float changeInterval = max(getRand(getFixedValue(2.0), seed), 0.6) * 15.0;\n    float timeFrame = getFixedValue(changeInterval);\n    float randomValue = getRand(timeFrame / changeInterval, 16.0 + seed) - 0.5;\n    return randomValue;\n}\n\n\nvec2 calculatePupilPosition(in float seed, in vec2 center, in float width, in vec2 fragCoord)\n{\n    vec2 position = center;\n    position += addSaccade(seed, 2.0, 5.0);\n    vec2 toMouse = vec2(0.0);\n    float maxDistance = width * 0.5;\n    float toMouseAngle = 0.0;\n    \n    if(MOUSE_LOOK){\n        toMouse = position - iMouse.xy;\n        toMouseAngle = -atan(position.y - iMouse.y, position.x - iMouse.x);\n    }\n    else{\n        vec2 offset =  randomPosition(seed) * 0.5;\n        vec2 fixedPos = iResolution.xy * 0.5;\n        toMouse = (fixedPos - offset) * 0.15;\n        toMouseAngle = -ang(fixedPos * 0.5, offset);\n    }\n\n    float squishValue = 1.0-min(1.0, length(toMouse)/maxDistance)*0.15;\n    position -= fragCoord;\n    position +=  rotate(toMouseAngle) * vec2(-min(length(toMouse), maxDistance), 0.0);\n    position *=  rotate(toMouseAngle);\n    position.x *= 1.0/squishValue;\n    position += fragCoord;\n    return position;\n}\n\n\nvoid drawPupil(in float seed, in int phase, in float phaseTimer, in vec2 position, in vec2 offset, in float width, inout vec3 currentColor, in vec2 fragCoord)\n{   \n\n    float mixValue = 0.0;\n\n    if(phase == 1){\n        mixValue = getTimedMix(phaseTimer, TIMER_PHASE_LOOK, 2.0);\n    }\n    else if(phase > 1 && phase < 4){\n        mixValue = 1.0;\n    }\n\n    vec3 pupilColor = mix(COL_PUPIL_OUTER_START, COL_PUPIL_OUTER_END, mixValue);\n    float pupilOuterSize = width * 0.5;\n    float pupilInnerSize = width * 0.12 + addPupilSize(seed) * 5.0;\n    float pupilCenterSize = (pupilOuterSize + pupilInnerSize) * 0.5;\n    \n    drawSmoothedCircle(position, pupilCenterSize, width - pupilInnerSize, pupilColor, COL_PUPIL_INNER, currentColor, fragCoord);\n    drawFullCircle(position, pupilInnerSize - 2.0, vec3(0.0), currentColor, fragCoord);\n    drawCircle(position, pupilInnerSize, 15.0, pupilColor, currentColor, fragCoord);\n}\n\n\nvoid drawInnerEye(in phaseInfo phase, in float seed, in float width, in float height, in vec2 position, in vec2 offset, inout vec3 currentColor, in vec2 fragCoord)\n{\n    if(abs(fragCoord.y - position.y) > abs(height) ||\n       abs(fragCoord.x - position.x) > abs(width)) {\n    \treturn;\n    }\n    \n    vec2 pupilPosition = position;\n    \n    if(phase.id == 0 || phase.id == 4){\n        pupilPosition = calculatePupilPosition(seed, position, width*0.85, fragCoord);\n    }\n    else{\n        pupilPosition += addSaccade(seed, 2.0, 7.0);\n    }\n    \n    drawBall(seed, position, pupilPosition, width, currentColor, fragCoord);\n    drawCanthus(position, width*0.68, currentColor, fragCoord);\n    drawPupil(seed, phase.id, phase.time, pupilPosition, offset, width*0.85, currentColor, fragCoord);\n}\n\n\nvoid drawOrbBackground(in orbInfo orb, in phaseInfo phase, inout vec3 col, in vec2 fragCoord)\n{   \n    col += drawFrayedCircle(orb.timedSeed, orb.fixedSeed, 1.0, orb.position, phase, orb.size*0.65, 10.0, col, fragCoord);;\n}\n\n\nfloat calculateOpenness(in float seed)\n{\n    float blinkInterval = 1.5 + 1.5 * getRand(seed);\n    float blinkDuration = 0.1;\n    float maxOpeness = 1.0;\n    float eyeOpen = maxOpeness;\n    \n    float blinkTimer = mod(iTime, blinkInterval);\n    \n    if(blinkTimer <= blinkDuration && ANIMATE){\n    \teyeOpen = maxOpeness-normalizedCos(blinkTimer * maxOpeness/blinkDuration);\n    }\n    \n    return eyeOpen;\n}\n\n\nvoid drawEye(in orbInfo orb, in phaseInfo phase, inout vec3 currentColor, in vec2 fragCoord)\n{\n    float a;\n    float width = orb.size;\n    float height = width * 0.5;\n    \n    float centerHeight = height * calculateOpenness(orb.fixedSeed);\n    \n    vec2 startPos = vec2(orb.position.x - width, orb.position.y);\n    vec2 centerPointUp = startPos + vec2(orb.size, centerHeight);\n    vec2 centerPointDown = startPos + vec2(width, -centerHeight);\n    float parabolaYup = calculateParabola(startPos, centerPointUp, fragCoord.x, a, height);\n    float parabolaYDown = calculateParabola(startPos, centerPointDown, fragCoord.x, a, height);\n    \n    float upperLineWidth = 5.0;\n    float lowerLineWidth = 3.0;\n    \n    vec2 offset = 0.1 * (orb.position - iMouse.xy);\n    \n    drawInnerEye(phase, orb.fixedSeed, width, height, orb.position, offset, currentColor, fragCoord);\n    drawParabola(parabolaYup, centerPointUp, width + 2.0, upperLineWidth, COL_OUTER_EYE, currentColor, fragCoord, height);\n    drawParabola(parabolaYDown, centerPointDown, width, lowerLineWidth, COL_OUTER_EYE, currentColor, fragCoord, height);\n}\n\n\nvoid drawOrb(in orbInfo orb, in phaseInfo phase, inout vec3 currentColor, in vec2 fragCoord)\n{    \n    drawOrbBackground(orb, phase, currentColor, fragCoord);  \n    drawEye(orb, phase, currentColor, fragCoord);\n}\n\n\nvoid splitImage(inout vec3 col, inout vec2 fragCoord, in float phaseTimer)\n{\n    float divs = 16.0;\n    float pixels = iResolution.x/divs;\n    float percentage = max((phaseTimer-TIMER_PHASE_SPLIT)/(TIMER_PHASE_FADEOUT-TIMER_PHASE_SPLIT), 0.0);\n    \n    float currentLength = length(fragCoord - iResolution.xy*0.5);\n    float currentLengthDisc = currentLength/pixels - fract(currentLength/pixels);\n        \n    if(currentLengthDisc <= (percentage * length(iResolution.xy*0.5)/pixels)){\n        float number = (fragCoord.y/pixels - fract(fragCoord.y/pixels));\n        float direction = mod(number, 2.0) >= 1.0 ? -1.0 : 1.0;\n     \n        fragCoord.x += (iResolution.x/divs) * direction;\n        fragCoord.y -= (iResolution.y/divs) * direction;\n    }\n}\n\n\nvoid spliceImage(inout vec2 fragCoord)\n{\n    vec2 pos1 = vec2(0.8, 1.5);\n    vec2 pos2 = vec2(0.8, 0.5);\n\n    if((iResolution.y-fragCoord.y * pos1.y)/(fragCoord.x * pos1.x) * iResolution.x/iResolution.y > 1.0){\n        fragCoord = fragCoord * mat2(0.5, 0.0, 0.0, 0.5);\n    }\n\n    if((fragCoord.y * pos2.y)/(fragCoord.x * pos2.x) * iResolution.x/iResolution.y > 1.0){\n        fragCoord = fragCoord * mat2(1.5, 0.0, 0.0, 1.5);\n    }\n}\n\n\nvoid drawRectVignette(inout vec3 currentColor, in vec2 fragCoord)\n{\n    float angle = ang(fragCoord, iResolution.xy * 0.5);\n    float maxDistance = 50.0 + 100.0 * (0.5 - getRand(angle * 4.0, 0.0, 2.0 * PI * 4.0)) * sin(angle + iTime * 0.5);\n    vec3 startColor = currentColor;\n\n    float val = min(min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y), min(fragCoord.x, fragCoord.y));\n    val = min(min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y), min(fragCoord.x, fragCoord.y));\n\n    currentColor += vec3(smoothstep(0.0, 2.0, (maxDistance-val)/(maxDistance)) * 0.2) * 1.1;\n}\n\n\nvec2 calculateEyePos(in float startAngle, in float offset, in vec2 fragCoord)\n{\n    vec2 center = iResolution.xy*0.5;\n    vec2 defDistance = vec2(offset, 0.0);\n    vec2 position = center;\n   \n    position -= fragCoord;\n    position += rotate(startAngle + (ANIMATE ? iTime * 0.1 : 0.0)) * defDistance;\n    position += fragCoord;\n    return position;\n}\n\n\nvoid drawBackground(inout vec3 currentColor, in vec2 fragCoord)\n{\n    float currentLength = length(fragCoord - iResolution.xy*0.5);\n    float maxLength = length(iResolution.xy*0.5);\n    float currentLengthRatio = currentLength/maxLength;\n    float divs = iResolution.x/4.0;\n    \n    float colorValue = currentLength*2.0/maxLength;\n    \n    currentColor = COL_BACKGROUND * vec3(colorValue, colorValue, colorValue) \n                   * max(0.0, 1.0 - mod(currentLength - iTime * 0.1 * divs, divs)/maxLength);\n}\n\n\nvoid fadeOut(in float phaseTimer, inout vec3 currentColor){\n\n    float value = getTimedMix(phaseTimer, TIMER_PHASE_FADEOUT, TIMER_PHASE_RESET - TIMER_PHASE_FADEOUT - 1.0);\n    currentColor -= vec3(1.0) * value;\n}\n\n\nvoid fadeIn(in float phaseTimer, inout vec3 currentColor){\n\n    float value = getTimedMix(phaseTimer, TIMER_PHASE_RESET, TIMER_PHASE_ALL - TIMER_PHASE_RESET);\n    currentColor += vec3(1.0) * value;\n}\n\n\nint setPhase(in float time, out float phaseTimer)\n{\n    int phase = 0;\n    phaseTimer = mod(time, TIMER_PHASE_ALL);\n    \n    if(phaseTimer > TIMER_PHASE_RESET){\n        phase = 4;\n    }\n    else if(phaseTimer > TIMER_PHASE_FADEOUT){\n        phase = 3;\n    }\n    else if(phaseTimer > TIMER_PHASE_SPLIT){\n        phase = 2;\n    }\n    else if(phaseTimer > TIMER_PHASE_LOOK){\n        phase = 1;\n    }\n    else{\n        phase = 0;\n    }\n    \n    return phase;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n    float time = mod(iTime + TIME_OFFSET, 16384.0);\n    float phaseTimer;\n    \n    phaseInfo phase = phaseInfo(setPhase(time, phaseTimer), phaseTimer);\n    \n    drawBackground(col, fragCoord);\n      \n    if(phase.id >= 3 && phase.id < 4){\n        spliceImage(fragCoord);\n    }\n    \n    if(phase.id >= 2 && phase.id < 4){\n        splitImage(col, fragCoord, phaseTimer);  \n    }\n    \n    drawBackLines(col, fragCoord);  \n    drawForeLines(col, fragCoord, 0.0, phase);\n    \n    vec2[] positions = vec2[] (\n        \tiResolution.xy*0.5,\n       \t\tcalculateEyePos(TAU, iResolution.x*0.3, fragCoord),\n        \tcalculateEyePos(TAU/3.0, iResolution.x*0.3, fragCoord),\n        \tcalculateEyePos(TAU/3.0 * 2.0, iResolution.x*0.3, fragCoord)\n        );\n    \n    float[] sizes = float[] (\n        \tiResolution.x*0.105,\n        \tiResolution.x*0.055,\n        \tiResolution.x*0.055,\n        \tiResolution.x*0.055\n    \t);\n    \n    for(int i = 0; i < positions.length(); i++){\n        float seed = float(i) * 100.0;\n        orbInfo newOrb = orbInfo(positions[i], sizes[i], time + seed, seed);        \n        drawOrb(newOrb, phase, col, fragCoord);\n    }\n    \n    if(phase.id >= 3){\n        fadeOut(phaseTimer, col);\n    }\n    \n    if(phase.id >= 4){\n        fadeIn(phaseTimer, col);\n    }\n    \n    drawRectVignette(col, fragCoord);\n   \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[874, 874, 911, 911, 960], [963, 963, 1035, 1035, 1115], [1118, 1118, 1196, 1196, 1271], [1274, 1274, 1358, 1358, 1436], [1439, 1439, 1515, 1515, 1557], [1560, 1560, 1636, 1636, 1701], [1704, 1704, 1832, 1832, 3115], [3118, 3118, 3190, 3190, 3373], [3376, 3376, 3412, 3412, 3453], [3456, 3456, 3522, 3522, 3705], [3708, 3708, 3755, 3755, 3796], [3799, 3799, 3829, 3829, 3867], [3870, 3870, 3910, 3910, 3953], [3956, 3956, 3985, 3985, 4053], [4056, 4056, 4122, 4122, 4249], [4252, 4252, 4289, 4289, 4332], [4335, 4335, 4452, 4519, 4740], [4743, 4743, 4798, 4798, 5445], [5448, 5448, 5538, 5538, 7024], [7027, 7027, 7195, 7195, 7483], [7486, 7486, 7621, 7621, 7784], [7787, 7787, 7902, 7902, 8064], [8067, 8067, 8204, 8204, 8464], [8467, 8467, 8567, 8567, 8643], [8646, 8646, 8708, 8708, 8790], [8793, 8793, 8915, 8915, 9038], [9041, 9041, 9230, 9230, 10745], [10748, 10748, 10926, 10926, 11215], [11218, 11218, 11348, 11348, 12185], [12188, 12188, 12284, 12284, 12396], [12399, 12399, 12492, 12492, 12890], [12893, 12893, 12929, 12929, 13340], [13343, 13343, 13378, 13378, 13665], [13668, 13668, 13763, 13763, 14602], [14605, 14605, 14765, 14765, 15524], [15527, 15527, 15692, 15692, 16316], [16319, 16319, 16414, 16414, 16542], [16545, 16545, 16585, 16585, 16950], [16953, 16953, 17047, 17047, 18063], [18066, 18066, 18160, 18160, 18278], [18281, 18281, 18357, 18357, 19030], [19033, 19033, 19073, 19073, 19465], [19468, 19468, 19535, 19535, 20065], [20068, 20068, 20147, 20147, 20418], [20421, 20421, 20486, 20486, 20930], [20933, 20933, 20992, 20992, 21145], [21148, 21148, 21206, 21206, 21347], [21350, 21350, 21401, 21401, 21806]], "test": "untested"}
{"id": "tltyzj", "name": "Snowflakes[Explorable]", "author": "public_int_i", "description": "Procedural fractal snowflakes, explore the scene using mouse drag + WASD/arrow keys.", "tags": ["ray", "sdf", "ifs", "distance", "snow", "march", "signed", "snowflakes", "flakes", "explorable"], "likes": 6, "viewed": 343, "published": 3, "date": "1609536075", "time_retrieved": "2024-07-30T19:47:43.461787", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=pr9yU1KYw80\n4k wallpaper xaloez.com/art/2020/Snowflakes.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = pow(c/c.w,vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*Buffer A stores dynamic camera position and rotation.\n\n0 = camera position(xyz), w = 1 frame of camera change\n1 = camera yaw/pitch(xy) and last mouse position(zw)\n*/\n\n#define MOUSE_SENSITIVITY 2.\n\n#define MOVEMENT_SPEED 5.\n\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 1.) {\n        vec4 rot = texelFetch(iChannel0,ivec2(1,0),0);\n        float camChanged = (iMouse.z > 0. && iMouse.w < 1.)?\n                            (length(rot.zw-iMouse.xy)>0.?1.:0.):\n                            0.;\n        \n        if (fragCoord.x < 1.) {\n            //camera position\n            vec3 pos = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (iFrame == 0) pos = vec3(0,7,0);//default position\n            \n            #define kb(i) texelFetch(iChannel1,ivec2(i,0),0).x\n            \n            //left/right/A/D arrows\n            float right = max(kb(39),kb(68))-max(kb(37),kb(65));\n            if (right != 0.) {\n                vec3 rt = vec3(right*iTimeDelta*MOVEMENT_SPEED,0,0);\n                rt.yz *= r2(rot.y);\n                rt.xz *= r2(rot.x);\n                pos += rt;\n                camChanged = 1.;\n            }\n            \n            //space key\n            if (kb(32) > 0.) {\n                vec3 up = vec3(0,iTimeDelta*MOVEMENT_SPEED,0);\n                up.yz *= r2(rot.y);\n                up.xz *= r2(rot.x);\n                pos += up;\n                camChanged = 1.;\n            }\n            \n            //up/down/W/S arrows\n            float forward = max(kb(38),kb(87))-max(kb(40),kb(83));\n            if (forward != 0.) {\n                vec3 fwd = vec3(0,0,forward*iTimeDelta*MOVEMENT_SPEED);\n                fwd.yz *= r2(rot.y);\n                fwd.xz *= r2(rot.x);\n                pos += fwd;\n                camChanged = 1.;\n            }\n            \n            fragColor = vec4(pos,camChanged);\n        } else {\n            //camera rotation\n            if (iFrame == 0) rot = vec4(0);\n            \n            //rotate on mouse drag\n            if (iMouse.z > 0. && iMouse.w < 1.) {\n                rot.xy -= (iMouse.xy-rot.zw)/iResolution.y*MOUSE_SENSITIVITY;\n            }\n            fragColor = vec4(rot.xy,iMouse.xy);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=pr9yU1KYw80\n4k wallpaper xaloez.com/art/2020/Snowflakes.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\n#define time iTime\n#define frame iFrame\n\n#define FIELD_OF_VIEW 1.\n\n#define HAS_OPACITY 1\n\n#define STEPS 60\n#define EPS 1e-2\n#define REFRACTION_SKIP 5.\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat2x3 tangentBinormal(vec3 norm) {\n\tmat2x3 t;\n\tif (abs(norm.x) > abs(norm.y)) t[0] = normalize(vec3(-norm.z,0,norm.x));\n\telse t[0] = normalize(vec3(0,norm.z,-norm.y)); \n\tt[1] = cross(norm,t[0]);\n\treturn t;\n}\n\n//Credit: IQ, integer hash 2 https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\treturn 1.-abs(fract(x)-.5)*2.;\n}\n\nfloat nsampling;\n\n//volumetric opacity\n#define START_OPACITY(posSeed) vec3 opacityRand = hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7))\n#define OPACITY(dst,skip,alpha,anisotropy) max(dst,-1e3+(skip+1e3)*step(alpha+nsampling*anisotropy,opacityRand.x))\n\nfloat snowflake(vec3 p, float size, float sep, float szStep, float width, float twist, int branchs) {\n\tvec2 ap = abs(p.xy);\n\tfloat sz = size, d = 1e8;\n\tfor (int i = 0; i < branchs; i++) {\n\t\td = min(d,min(max(ap.x,ap.y-sz),max(ap.y,ap.x-sz))-sz*width);\n\t\tap = abs((ap-sz*sep)*r2(twist));\n\t\tsz *= szStep;\n\t}\n\treturn max(d,abs(abs(p.z)+d*.2)*.98);\n}\n\nfloat geometry(vec3 p) {\n\n\t//snowflake\n\tfloat az = p.z;\n\tp.xy += floor(p.z/2.+1000.)*.1873;\n\tvec3 rp = mod(abs(p),2.)-1.;//vec3(mod(abs(p.xy),2.)-1.,p.z);\n\tuvec3 fp = uvec3(floor(p/2.+1000.));\n\tvec3 r0 = hash(fp);\n\tr0.x = .2+r0.x*.6;\n\treturn max(snowflake(rp,.6, r0.x,r0.x*(.5+r0.y), .2, r0.z ,2),az-6.);\n\t\n}\n\n//chromatic separation dither\n#define START_CHROMA(posSeed) float chromaFrame = float(fract(hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7)).x)*3.)\n#define CHROMA(mat,rc,gc,bc) if (chromaFrame < 1.) {mat[0]*=vec3(3,0,0);rc;}\\\nelse if (chromaFrame < 2.) {mat[0]*=vec3(0,3,0);gc;}\\\nelse {mat[0]*=vec3(0,0,3);bc;}\n\n/*mat[0] = color\nmat[1].x = forward roughness, mat[1].y = emission, mat[1].z = backward roughness\nmat[2].x = opacity, mat[2].y = refraction index\n*/\nmat3 material(vec3 p) {\n\tmat3 m = mat3(vec3(.88), vec3(1e-4,0.,1e-4), vec3(.9,1.3,0.));//1.517,0.));\n\t//START_CHROMA(p);\n\t//CHROMA(m, m[2].y=1., m[2].y=1., m[2].y=1.);\n\treturn m;\n}\nvec3 normal(vec3 p) {\n\t#define NEPS vec3(EPS,0,0)\n\tnsampling = 1.;\n\tvec3 n = normalize(vec3(geometry(p+NEPS),geometry(p+NEPS.yxz),geometry(p+NEPS.yzx))-geometry(p));\n\tnsampling = 0.;\n\treturn n!=n?vec3(0,1,0):n;\n}\n\nvec3 background(vec3 rp, vec3 rd) {\n\treturn vec3(.2,.4,.7)*(.1+max(0.,rd.y)*.9)+vec3(5)*max(0.,1.-length(rd-vec3(0,1,0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 camPos = texelFetch(iChannel1,ivec2(0),0);\n   \n\tvec3 rp = camPos.xyz,//camera position\n\t\trd = normalize(vec3(uv.xy+(hash(uvec3(fragCoord,frame)).xy*4.-2.)/iResolution.y,FIELD_OF_VIEW)),\n\t\tc = vec3(1);\n\t\n\t//camera rotation\n    vec2 camRot = texelFetch(iChannel1,ivec2(1,0),0).xy;\n\trd.yz *= r2(camRot.y);\n   \trd.xz *= r2(camRot.x);\n\n\tfloat l = 0.;\n\tint i;\n\tbool flipRefraction = false;\n\tnsampling = 0.;\n\tfor (i = 0; i < STEPS; i++) {\n\t\tfloat dst = geometry(rp);\n\t\tif (dst <= EPS) {\n\t\t\tmat3 mat = material(rp);\n\t\t\tl += mat[1].y;\n\t\t\tc *= mat[0];\n\t\t\t\n\t\t\trp -= rd*(EPS*2.-dst);\n\t\t\tvec3 nrm = normal(rp);\n\t\t\tmat2x3 tangBinorm = tangentBinormal(nrm);\n\t\t\t\n\t\t\tvec3 rnd = hash(uvec3(abs(rp)*1000.)+uvec3(frame,frame*3,frame*7));\n\t\t\tfloat ct = pow(rnd.x,flipRefraction?mat[1].z:mat[1].x),\n\t\t\t\tst = sqrt(1.-ct*ct),\n\t\t\t\tpt = rnd.y*PI*2.;\n\t\t\tvec3 surf = normalize(nrm*ct+tangBinorm[0]*(st*cos(pt))+tangBinorm[1]*(st*sin(pt)));\n\t\t\t#if HAS_OPACITY\n\t\t\tif (mat[2].x < rnd.z) {\n\t\t\t\trp += rd*(EPS*2.-dst);\n\t\t\t\trd = refract(rd,surf,flipRefraction?mat[2].y:1./mat[2].y);\n\t\t\t\tdst = EPS*REFRACTION_SKIP*(1.+rnd.z);\n\t\t\t\tflipRefraction = !flipRefraction;\n\t\t\t} else {\n\t\t\t#endif\n\t\t\t\trd = reflect(rd,surf);\n\t\t\t\tdst = 0.;\n\t\t\t#if HAS_OPACITY\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\t\trp += rd*dst;\n\t}\n\t\n\t//background + final lighting\n\tc = min(c,vec3(10.));\n\tc *= l+background(rp,rd);\n    fragColor = (camPos.w>.5?vec4(0):texelFetch(iChannel0,ivec2(fragCoord),0))+vec4(c,1)*1e-2;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 267, 267, 365]], "test": "untested"}
{"id": "tttcRj", "name": "Mandel Sphere Fractal[Explorable", "author": "public_int_i", "description": "Mandel sphere fractal, explore using mouse drag + WASD/arrow keys.", "tags": ["fractal", "interactive", "sphere", "mandel", "eas"], "likes": 9, "viewed": 336, "published": 3, "date": "1609536065", "time_retrieved": "2024-07-30T19:47:44.320491", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=e-35_IJixzg\n4k wallpaper xaloez.com/art/2020/MandelSphereFractal.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = pow(c/c.w,vec4(1./2.2));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*Buffer A stores dynamic camera position and rotation.\n\n0 = camera position(xyz), w = 1 frame of camera change\n1 = camera yaw/pitch(xy) and last mouse position(zw)\n*/\n\n#define MOUSE_SENSITIVITY 2.\n\n#define MOVEMENT_SPEED 5.\n\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y < 1.) {\n        vec4 rot = texelFetch(iChannel0,ivec2(1,0),0);\n        float camChanged = (iMouse.z > 0. && iMouse.w < 1.)?\n                            (length(rot.zw-iMouse.xy)>0.?1.:0.):\n                            0.;\n        \n        if (fragCoord.x < 1.) {\n            //camera position\n            vec3 pos = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (iFrame == 0) pos = vec3(0,7,0);//default position\n            \n            #define kb(i) texelFetch(iChannel1,ivec2(i,0),0).x\n            \n            //left/right/A/D arrows\n            float right = max(kb(39),kb(68))-max(kb(37),kb(65));\n            if (right != 0.) {\n                vec3 rt = vec3(right*iTimeDelta*MOVEMENT_SPEED,0,0);\n                rt.yz *= r2(rot.y);\n                rt.xz *= r2(rot.x);\n                pos += rt;\n                camChanged = 1.;\n            }\n            \n            //space key\n            if (kb(32) > 0.) {\n                vec3 up = vec3(0,iTimeDelta*MOVEMENT_SPEED,0);\n                up.yz *= r2(rot.y);\n                up.xz *= r2(rot.x);\n                pos += up;\n                camChanged = 1.;\n            }\n            \n            //up/down/W/S arrows\n            float forward = max(kb(38),kb(87))-max(kb(40),kb(83));\n            if (forward != 0.) {\n                vec3 fwd = vec3(0,0,forward*iTimeDelta*MOVEMENT_SPEED);\n                fwd.yz *= r2(rot.y);\n                fwd.xz *= r2(rot.x);\n                pos += fwd;\n                camChanged = 1.;\n            }\n            \n            fragColor = vec4(pos,camChanged);\n        } else {\n            //camera rotation\n            if (iFrame == 0) rot = vec4(0);\n            \n            //rotate on mouse drag\n            if (iMouse.z > 0. && iMouse.w < 1.) {\n                rot.xy -= (iMouse.xy-rot.zw)/iResolution.y*MOUSE_SENSITIVITY;\n            }\n            fragColor = vec4(rot.xy,iMouse.xy);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=e-35_IJixzg\n4k wallpaper xaloez.com/art/2020/MandelSphereFractal.jpg\n\nControls:\nLook - Mouse Drag\nMove - WASD or Arrow Keys\n*/\n\n#define time iTime\n#define frame iFrame\n\n#define STEPS 100\n#define EPS 4e-2\n#define PI 3.14159265\n\n#define FIELD_OF_VIEW 1.\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat2x3 tangentBinormal(vec3 norm) {\n\tmat2x3 t;\n\tif (abs(norm.x) > abs(norm.y)) t[0] = normalize(vec3(-norm.z,0,norm.x));\n\telse t[0] = normalize(vec3(0,norm.z,-norm.y)); \n\tt[1] = cross(norm,t[0]);\n\treturn t;\n}\n\n//Credit: IQ, integer hash 2 https://www.shadertoy.com/view/XlXcW4\nvec3 hash(uvec3 x) {\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    x = ((x>>8U)^x.yzx)*1103515245U;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\n#define START_OPACITY(posSeed) vec3 opacityRand = hash(uvec3(abs(posSeed)*1000.)+uvec3(frame,frame*3,frame*7))\n#define OPACITY(dst,skip,alpha) (dst+skip*opacityRand.y*step(alpha,opacityRand.x))\n\nfloat geometry(vec3 p) {\n\tfloat d = 1e8, sz = 5.;\n\tfor (float i = 1.; i < 8.; i++) {\n\t\td = min(d,length(p)-sz);\n\t\tp = abs(abs(p)-sz);\n\t\tsz *= .45;\n\t}\n\treturn d;\n}\n//mat[0] = color, mat[1].x = roughness, mat[1].y = emission\nmat2x3 material(vec3 p) {\n\t\n\treturn mat2x3(vec3(.5), vec3(.1,0.,0));\n}\nvec3 normal(vec3 p) {\n\t#define NEPS vec3(EPS,0,0)\n\tvec3 n = normalize(vec3(geometry(p+NEPS),geometry(p+NEPS.yxz),geometry(p+NEPS.yzx))-geometry(p));\n\treturn n!=n?normalize(fract(abs(p.zxy*1e6))-.5):n;\n}\n\nvec3 background(vec3 rp, vec3 rd) {\n\treturn vec3(.2,.4,.7)+vec3(1)*max(0.,1.-length(rd-vec3(-1,1,-1)))*200.;\n}\n\nfloat twave(float x) {\n\treturn 1.-abs(fract(x)-.5)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 camPos = texelFetch(iChannel1,ivec2(0),0);\n   \n\tvec3 rp = camPos.xyz,//camera position\n\t\trd = normalize(vec3(uv.xy+(hash(uvec3(fragCoord,frame)).xy*4.-2.)/iResolution.y,FIELD_OF_VIEW)),\n\t\tc = vec3(1);\n\tfloat l = 0.;\n\t\n\t//camera rotation\n    vec2 camRot = texelFetch(iChannel1,ivec2(1,0),0).xy;\n\trd.yz *= r2(camRot.y);\n   \trd.xz *= r2(camRot.x);\n\n\n\tint i;\n\tfor (i = 0; i < STEPS; i++) {\n\t\tfloat dst = geometry(rp);\n\t\tif (dst <= EPS) {\n\t\t\tmat2x3 mat = material(rp);\n\t\t\tl += mat[1].y;\n\t\t\tc *= mat[0];\n\t\t\t\n\t\t\trp -= rd*(EPS*2.-dst);\n\t\t\tvec3 nrm = normal(rp);\n\t\t\tmat2x3 tangBinorm = tangentBinormal(nrm);\n\t\t\t\n\t\t\tvec2 rnd = hash(uvec3(abs(rp)*1000.)+uvec3(frame,frame*3,frame*7)).xy;\n\t\t\tfloat ct = pow(rnd.x,mat[1].x),\n\t\t\t\tst = sqrt(1.-ct*ct),\n\t\t\t\tpt = rnd.y*PI*2.;\n\t\t\tvec3 surf = normalize(nrm*ct+tangBinorm[0]*(st*cos(pt))+tangBinorm[1]*(st*sin(pt)));\n\t\t\trd = reflect(rd,surf);\n\t\t\tdst = 0.;\n\t\t}\n\t\trp += rd*dst;\n\t\t\n\t\tif (dot(rp,rp) > 20.*20.) i = STEPS;\n\t}\n\t\n\t//background + final lighting\n\tc *= l+background(rp,rd)*(i>=STEPS?1.:clamp(geometry(rp)-5.,0.,1.));\n\t\n    fragColor = (camPos.w>.5?vec4(0):texelFetch(iChannel0,ivec2(fragCoord),0))+vec4(c,1)*1e-2;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 276, 276, 374]], "test": "untested"}
{"id": "WtcyRn", "name": "Firefly Effect EAS", "author": "public_int_i", "description": "Firefly Effect EAS", "tags": ["fireflyeffecteas"], "likes": 3, "viewed": 450, "published": 3, "date": "1609536039", "time_retrieved": "2024-07-30T19:47:45.400603", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=oagKbz9vm4g\n4k wallpaper xaloez.com/art/2020/FireflyEffect.jpg*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=oagKbz9vm4g\n4k wallpaper xaloez.com/art/2020/FireflyEffect.jpg*/\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tfloat s = 0.;\n\tfor (float p = 0.; p < 1000.; p++) {\n\t\tvec4 rh = hash(p*vec4(.01,.1,1.,10.));\n\t\trh.xy = rh.xy*2.-1.;\n\t\tfloat lt = pow(fract(length(rh.xy)+time*.05),.7)*2.;\n\t\trh.xy = normalize(rh.xy)*lt;\n\t\tvec2 sp = rh.xy;\n\t\trh.xy *= cos(sp.yx*rh.zw*10.);\n\n\t\ts += max(0.,1.-max(0.,length(uv.xy-rh.xy)-.02)*100.);\n\t}\n\tfragColor = mix(mix(vec4(.02,.03,.08,1),vec4(1.,.96,.8,1),pow(clamp(s*.4,0.,1.),2.)),texelFetch(iChannel0,ivec2(fragCoord),0),.95);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 214, 214, 274]], "test": "untested"}
{"id": "3tcyRn", "name": "Dissection EAS", "author": "public_int_i", "description": "Dissection EAS", "tags": ["dissectioneas"], "likes": 5, "viewed": 212, "published": 3, "date": "1609536031", "time_retrieved": "2024-07-30T19:47:46.286236", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=C_qCNZpYEtk\n4k wallpaper xaloez.com/art/2020/Dissection.png*/\n\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime,15.);\n    vec2 uv = (fragCoord*2.-iResolution.xy)*mix(1.,.125,pow(time/15.,2.))/iResolution.y;\n\n\tfloat d = 1e8;\n\tvec2 p = uv;\n\tfor (float s = 1.; s < 17.; s++) {\n\t\td = min(d,length(max(abs(p)-vec2(.02,.02),0.)));\n\t\tp = abs(p-(.01+time*.01))*r2(s*.004*time);\n\t}\n\td = mix(d,length(max(abs(uv-.001)-.02,0.))*4.,pow(clamp((time-10.)*.201,0.,1.),8.));\n\td *= iResolution.y*.5;\n\tfragColor = vec4(d,d,d,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 173, 173, 230], [232, 232, 250, 250, 366], [367, 367, 386, 386, 566], [568, 568, 625, 625, 1053]], "test": "untested"}
{"id": "tsKBWt", "name": "Siphon EAS", "author": "public_int_i", "description": "Siphon EAS", "tags": ["siphoneas"], "likes": 3, "viewed": 258, "published": 3, "date": "1609536019", "time_retrieved": "2024-07-30T19:47:47.080113", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=WAI3p0PRbYU\n4k wallpaper xaloez.com/art/2020/Siphon.jpg*/\n\n\n#define PI 3.14159265358\n#define EPS 1e-3\n#define SEP 2e-2\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nfloat geo(vec3 p) {\n\treturn length(mod(abs(p.xz),6.)-3.)-.5;\n\t/*min(-(length(p.xz)-5.),\n\t\t\t   length(mod(abs(p+vec3(100+sin(time+p.y*2.)*.1,time*-.1,100+cos(p.y*2.)*.1)),.4)-.2)-.05);\n\t\t\n\t\t\t\t\t\n\t\t\tvec3 gp = mod(abs(rp-rd*EPS+vec3(100+sin(time+rp.y*2.)*.1,time*-.1,100+cos(rp.y*2.)*.1)),.4)-.2;\t   \n\t\t*/\n}\n\nvec3 bg(vec3 rd) {\n\treturn vec3(0)+max(0.,1.-length(rd-vec3(0,-1,0))*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    \tvec3 rp = vec3(time,0,0),\n\t\trd = normalize(vec3(uv.xy,1.)),\n\t\tc = vec3(1);\n\t\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat dst = length(mod(abs(rp.xz),6.)-3.)-1.6;//geo(rp);\n\t\tif (dst <= 0.) {\n\t\t\trd = refract(rd,normalize(vec3(mod(abs(rp.xz),6.)-3.,0).xzy),1.);\n\t\t\tvec2 fp = (floor(abs(rp.xz)/6.)*6.+3.)*sign(rp.xz);\n\t\t\tfor (int s = 0; s < 20; s++) {\n\t\t\t\t#define bm vec3(100.+sin(time*4.+rp.y*2.)*.1,time*-4.,100.+cos(rp.y*2.)*.1)\n\t\t\t\tfloat le = -(length(rp.xz-fp)-1.6),\n\t\t\t\t\tsd = min(le, length(mod(abs(rp+bm),.8)-.4)-.2);\n\t\t\t\tif (sd <= 0.) {\n\t\t\t\t\tif (le <= 0.) break;\n\t\t\t\t\trd = refract(rd,normalize(mod(abs(rp+bm),.4)-.2),1.);\n\t\t\t\t\tsd = .4;\n\t\t\t\t}\n\t\t\t\tfloat dt = sd+SEP;\n\t\t\t\trp += rd*dt;\n\t\t\t\tc /= 1.+dt*vec3(.7,.2,.5);\n\t\t\t   //+vec3(100+sin(time+p.y*2.)*.1,time*-.1,100+cos(p.y*2.)*.1)\n\t\t\t}\n\t\t\tdst = 1.6;\n\t\t}\n\t\trp += rd*(dst+EPS);\n\t\t//c /= 1.+dt*vec3(.2);\n\t}\n\t\n\tfragColor = vec4(c*bg(rd)*3.,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 229, 229, 292], [294, 294, 313, 313, 597], [599, 599, 617, 617, 674], [676, 676, 733, 733, 1713]], "test": "untested"}
{"id": "3dVfDd", "name": "Brew EAS", "author": "public_int_i", "description": "Brew EAS", "tags": ["breweas"], "likes": 1, "viewed": 229, "published": 3, "date": "1609536007", "time_retrieved": "2024-07-30T19:47:47.847062", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=7M4K1v5c43s\n4k wallpaper xaloez.com/art/2020/Brew.jpg*/\n\n#define time iTime\n\n#define PI 3.14159265358\n#define EPS 1e-3\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nfloat geo(vec3 p) {\n\treturn min(-(length(p.xz)-5.),\n\t\t\t   length(mod(abs(p+vec3(100.+sin(time+p.y*2.)*.1,time*-.1,100.+cos(p.y*2.)*.1)),.4)-.2)-.05);\n}\n\nvec3 bg(vec3 rd) {\n\treturn vec3(0)+pow(max(0.,1.-length(rd-normalize(vec3(.2,.2,.4)))*.5),2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\n\tvec3 rp = vec3(0,0,-4),\n\t\trd = normalize(vec3(uv.xy,.5)),\n\t\tc = vec3(1);\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat dst = geo(rp);\n\t\tif (dst <= 0.) {\n\t\t\tif (length(rp.xz) >= 5.) break;\n\t\t\tvec3 gp = mod(abs(rp-rd*EPS+vec3(100.+sin(time+rp.y*2.)*.1,time*-.1,100.+cos(rp.y*2.)*.1)),.4)-.2;\n\t\t\trd = refract(rd,normalize(gp),.97);\n\t\t\tc *= 1.05;\n\t\t\tdst = .2;\n\t\t}\n\t\tfloat dt = dst+EPS;\n\t\trp += rd*dt;\n\t\tc /= 1.+dt*vec3(.3,.36,1.)*.5;\n\t}\n\t\n\tfragColor = vec4(c*bg(rd)*3.,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 229, 229, 292], [294, 294, 313, 313, 445], [447, 447, 465, 465, 543], [546, 546, 603, 603, 1133]], "test": "untested"}
{"id": "tdKBWt", "name": "Symbol Matrix EAS", "author": "public_int_i", "description": "Symbol Matrix EAS", "tags": ["symbolmatrixeas"], "likes": 7, "viewed": 306, "published": 3, "date": "1609536000", "time_retrieved": "2024-07-30T19:47:48.621990", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=jLCG5-fI7D4\n4k wallpaper xaloez.com/art/2020/SymbolMatrix.jpg*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=jLCG5-fI7D4\n4k wallpaper xaloez.com/art/2020/SymbolMatrix.jpg*/\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = 200.+(fragCoord*2.-iResolution.xy)*(5.+time*.4)/iResolution.y;\n    \n\tvec4 rh = hash(floor(uv.x)*vec4(.01111,.1111,1.1111,11.11111));\n\tvec2 p = uv.xy+vec2(0,(.7+rh.x)*time),\n\t\tfp = floor(p),\n\t\trp = (p-fp)*2.-1.;\n\tvec4 bh = hash(fp.xyyx*.1111);\n\tif (bh.y > .75) rp.x = abs(rp.x);\n\telse if (bh.y > .5) rp.y = abs(rp.y);\n\tfloat d = 1e8;\n\tbh.w = 1.+bh.w*6.;\n\tfor (float p = 0.; p < bh.w; p++) {\n\t\tvec4 h = hash(bh+fp.xyyx-p*vec4(.01,.1,1.,10.));\n\t\td = min(d,length(max(abs((rp-(h.xy-.5))*r2(h.w*6.28))-vec2(.06,.2+pow(h.z,2.)*.6),0.)));\n\t}\n\td = max(0.,1.-max(0.,d*iResolution.y/20.));\n\tfragColor = mix(vec4((vec3(.3,1.3,.6)+(rh.yzw*2.-1.)*.5)*d,1),texelFetch(iChannel0,ivec2(fragCoord),0),.95);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 273]], "test": "untested"}
{"id": "WsVfDd", "name": "Devious 2 EAS", "author": "public_int_i", "description": "Devious 2 EAS", "tags": ["devious2eas"], "likes": 2, "viewed": 216, "published": 3, "date": "1609535988", "time_retrieved": "2024-07-30T19:47:49.545521", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=iKuZ95FoQc4\n4k wallpaper xaloez.com/art/2020/Devious2.jpg*/\n\n\n#define EPS 3e-3\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\n\nfloat geo(vec3 p) {\n\tfloat d = 1.;\n\tvec3 fp = floor(p);\n\tfor (float x = -1.; x < 2.; x++) {\n\t\tfor (float y = -1.; y < 2.; y++) {\n\t\t\tfor (float z = -1.; z < 2.; z++) {\n\t\t\t\tvec3 ap = abs(fp+vec3(x,y,z));\n\t\t\t\tfloat h = fract(.5+dot(ap,vec3(1.,128.,2048.))/1.6180339887498948482), yp = clamp(1.1-ap.y*.1,0.,1.), bprob = 20./ap.z*yp;\n\t\t\t\typ *= .5;\n\t\t\t\tif (h > bprob) d = min(d,length(max(abs(p-(fp+vec3(x,y,z)+.5))-yp,0.))-(.5-yp));\n\t\t\t}\n\t\t}\n\t}\n\treturn max(p.y,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 aas = vec3(0);\n\t//for (float ax = -1.; ax < 2.; ax++) {\n\t//\tfor (float ay = -1.; ay < 2.; ay++) {\n\t\t\tvec3 rp = vec3(1,-9.+pow(time*.06,4.)*12.,time),\n\t\t\t\trd = normalize(vec3(uv.xy,1.));\n\t\t\tvec3 c = vec3(1);\n\t\t\t//+vec2(ax,ay)*.5/screenY\n\t\n\t\t\trp += vec3(geo(rp+vec3(EPS,0,0)),geo(rp+vec3(0,EPS,0)),geo(rp+vec3(0,0,EPS)))-geo(rp);\n\n\t\t\tfor (int i = 0; i < 300; i++) {\n\t\t\t\tfloat dst = geo(rp);\n\t\t\t\tif (dst <= 0.) {\n\t\t\t\t\trp -= rd*EPS*1.5;\n\t\t\t\t\tdst = geo(rp);\n\t\t\t\t\tvec3 nrm = vec3(geo(rp+vec3(EPS,0,0)),geo(rp+vec3(0,EPS,0)),geo(rp+vec3(0,0,EPS)))-dst;\n\t\t\t\t\trd = reflect(rd,normalize(nrm));\n\t\t\t\t\tc *= .8;\n\t\t\t\t}\n\t\t\t\trp += rd*(dst+EPS);\n\t\t\t\tif (rp.y > 0. && rd.y > 0.) break;\n\t\t\t}\n\t\n\t\t\tvec3 l = (vec3(.04,.07,.18)+max(0.,1.-length(rd-normalize(vec3(1,1,1)))*(.5+rd.y*.5))*vec3(1.,.8,.6)*2.)*clamp(rp.y*.1+1.,0.,1.);\n\t\t\taas += c*l;\n\t//\t}\n\t//}\n\tfragColor = vec4(aas,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 211, 211, 268], [270, 270, 288, 288, 404], [405, 405, 424, 424, 604], [607, 607, 626, 626, 1068], [1070, 1070, 1127, 1127, 2073]], "test": "untested"}
{"id": "WdKfDd", "name": "Devious EAS", "author": "public_int_i", "description": "Devious EAS", "tags": ["deviouseas"], "likes": 5, "viewed": 245, "published": 3, "date": "1609535979", "time_retrieved": "2024-07-30T19:47:50.554822", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=eFnHqsXZ3V4\n4k wallpaper xaloez.com/art/2020/Devious.jpg*/\n\n\n#define EPS 1e-4\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat geo(vec3 p) {\n\tfloat d = 1.;\n\tvec3 fp = floor(p);\n\tfor (float x = -1.; x < 2.; x++) {\n\t\tfor (float y = -1.; y < 2.; y++) {\n\t\t\tfor (float z = -1.; z < 2.; z++) {\n\t\t\t\tfloat h = fract(.5+dot(abs(fp+vec3(x,y,z)),vec3(1.,128.,2048.))/1.6180339887498948482);\n\t\t\t\tif (h > .95) d = min(d,length(max(abs(p-(fp+vec3(x,y,z)+.5))-.5,0.)));\n\t\t\t}\n\t\t}\n\t}\n\treturn max(p.y,d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\n\tvec4 pxh = hash(uv.xyyx+time);\n\tvec3 rp = vec3(100.+sin(time*.16)*3.5,cos(time*.16)*4.-3.,time),\n\t\trd = normalize(vec3(uv.xy,1.));\n\tvec3 c = vec3(1);\n\n\trd.xz *= r2(time*.1);\n\n\tfor (int i = 0; i < 120; i++) {\n\t\tfloat dst = geo(rp);\n\t\tif (dst <= 0.) {\n\t\t\trp -= rd*EPS*2.;\n\t\t\tdst = geo(rp);\n\t\t\tvec3 nrm = vec3(geo(rp+vec3(EPS,0,0)),geo(rp+vec3(0,EPS,0)),geo(rp+vec3(0,0,EPS)))-dst;\n\t\t\tif (dot(nrm,nrm) == 0.) rp += rd;\n\t\t\telse rd = reflect(rd,normalize(nrm));\n\t\t\tc *= .8;\n\t\t}\n\t\trp += rd*(dst+EPS);\n\t}\n\t\n\tvec3 l = (vec3(.2,.4,.8)+max(0.,1.-length(rd-normalize(vec3(1,1,1)))*2.)*vec3(1.,.98,.92))*clamp(rp.y*.1+1.,0.,1.);\n\tfragColor = vec4(c*l,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 210, 210, 267], [269, 269, 287, 287, 403], [404, 404, 423, 423, 603], [605, 605, 624, 624, 972], [976, 976, 1033, 1033, 1759]], "test": "untested"}
{"id": "WdVBDd", "name": "Disorientation EAS", "author": "public_int_i", "description": "Disorientation EAS", "tags": ["disorientationeas"], "likes": 2, "viewed": 214, "published": 3, "date": "1609535966", "time_retrieved": "2024-07-30T19:47:51.511265", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=kf-Lrm9S6ZI\n4k wallpaper xaloez.com/art/2020/Disorientation.jpg*/\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nfloat twave(float x) {\n\treturn x*2.-max(0.,x*4.-2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tfloat s = 0.;\n\t#define AA 2.\n\t#ifdef AA\n\tfor (float ax = -AA; ax < AA+1.; ax++) {\n\t\tfor (float ay = -AA; ay < AA+1.; ay++) {\n\t\t\tvec2 p = (uv.xy+vec2(ax,ay)/AA/iResolution.y)*10.;\n\t#else\n\t\t\tvec2 p = uv.xy*10.;\n\t#endif\n\t\t\tfor (float l = 1.; l < 40.; l++) {\n\t\t\t\tvec4 h = hash(l*vec4(.01,.1,1.,10.));\n\t\t\t\th.xy = (h.xy*2.-1.)*6.;\n\t\t\t\tp -= h.xy;\n\t\t\t\tfloat lp = length(p);\n\t\t\t\tp *= r2(h.z/length(p)+time*(h.w-.5));\n\t\t\t\tp += h.xy;\n\t\t\t}\n\t\t\tp = floor(100.+p);\n\t\t\ts += mod(p.x+p.y,2.);\n\t#ifdef AA\n\t\t}\n\t}\n\ts /= (AA*2.+1.)*(AA*2.+1.);\n\t#endif\n\tfragColor = vec4(s,s,s,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 176, 176, 233], [235, 235, 254, 254, 355], [357, 357, 379, 379, 411]], "test": "untested"}
{"id": "3dVBDd", "name": "Shadow Pool EAS", "author": "public_int_i", "description": "Shadow Pool EAS", "tags": ["shadowpooleas"], "likes": 8, "viewed": 261, "published": 3, "date": "1609535955", "time_retrieved": "2024-07-30T19:47:52.461725", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=b5S1k7Ma1C8\n4k wallpaper xaloez.com/art/2020/ShadowPool.jpg*/\n\n#define time iTime\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nfloat caustics(vec2 p, vec2 uv) {\n\tfloat s = 0.;\n\tfor (float l = 1.; l < 5.; l++) {\n\t\tvec4 lh = hash(l*vec4(.01,.1,1.,10.));\n\t\tvec2 ruv = mod(abs((p.xy-(lh.xy*2.-1.))*r2(time*.1+l*.01+log(1.+length(uv.xy)*(1.+l*l)))),.4)-.2,\n\t\t\tauv = abs(ruv)-.2;\n\t\ts += pow(max(-auv.x,-auv.y)*5.,8.);\n\t}\n\treturn s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 rd = normalize(vec3(uv.xy,.1));\n\tfloat s = 0.;\n\tfor (float t = .1; t < 3.; t += .2) {\n\t\ts += caustics((rd*t).xy,uv)/t;\n\t}\n\tfragColor = vec4(1.-pow(s*.03,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 192, 192, 249], [251, 251, 270, 270, 371], [373, 373, 406, 406, 673], [676, 676, 733, 733, 960]], "test": "untested"}
{"id": "3sKBDd", "name": "Light Dance EAS", "author": "public_int_i", "description": "Light Dance EAS", "tags": ["lightdanceeas"], "likes": 5, "viewed": 315, "published": 3, "date": "1609535944", "time_retrieved": "2024-07-30T19:47:53.348353", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=_JyfhJxrkHg\n4k wallpaper xaloez.com/art/2020/LightDance.jpg*/\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 rp = vec3(1,1,time),\n\t\trd = normalize(vec3(uv.xy,1.)),\n\t\tc = vec3(0);\n\trp += rd*10.;\n\tfor (int i = 0; i < 24; i++) {\n\t\tvec3 tp = rp+sin(rp.yzx*.2+time*vec3(1,1,0))+cos(rp.zxy*.4)*.4;\n\t\tfloat dst = length(mod(abs(tp),2.)-1.)-.2;\n\t\tc += max(0.,1.-abs(dst))*abs(sin(tp)+sin(tp.zxy*.7)+sin(tp.yzx*.9));\n\t\trp += rd*(dst+0.01);\n\t}\n\tfragColor = vec4(pow(c*.05,vec3(2.)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 172, 172, 229], [231, 231, 288, 288, 747]], "test": "untested"}
{"id": "WdKBDd", "name": "Jolly EAS", "author": "public_int_i", "description": "Jolly EAS", "tags": ["jollyeas"], "likes": 2, "viewed": 213, "published": 3, "date": "1609535917", "time_retrieved": "2024-07-30T19:47:54.180129", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=R3jy8kRJtYc\n4k wallpaper xaloez.com/art/2020/Arch.jpg*/\n\n#define EPS 1e-1\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat geo(vec3 p) {\n\tp.xy *= r2(p.z*.01+length(p.xy)*.02);\n\tp = mod(p+160.,vec3(16.,40.,16.))-vec3(8.,20.,8.);\n\treturn min(length(p-vec3(0,15,0))-4.,\n\t\t\tmax(abs(p.y)-14.,(length(vec2(sin(atan(p.x,p.z)*3.),length(p.xz)-3.5))-.4)))*.5;\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\treturn x*2.-max(0.,x*4.-2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 s = vec3(0);\n\tfor (float ax = -1.; ax < 2.; ax++) {\n\t\tfor (float ay = -1.; ay < 2.; ay++) {\n\t\t\tvec3 rp = vec3(15,0,0),\n\t\t\t\trd = normalize(vec3(uv.xy+vec2(ax,ay)*.75/iResolution.y,.5)),\n\t\t\t\t//rd = normalize(vec3(uv.xy,.5)),\n\t\t\t\tc = vec3(0);\n\t\t\trp.xy *= r2(time*-.01+1.2);\n\t\t\trp.z += time;\n\t\t\trp += rd*6.;\n\t\n\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\tfloat dst = geo(rp);\n\t\t\t\tif (dst <= 0.) break;\n\t\t\t\trp += rd*(dst+EPS);\n\t\t\t}\n\n\t\t\ts += hsvToRGB(pow((sin(rp*.1)+cos(rp.yzx*.2)+2.)*.25,vec3(1,1,2.2)));\n\t\t}\n\t}\n\tfragColor = vec4(s/9.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 206, 206, 263], [265, 265, 283, 283, 399], [400, 400, 419, 419, 599], [601, 601, 620, 620, 836], [838, 838, 863, 863, 958], [960, 960, 982, 982, 1014], [1016, 1016, 1073, 1073, 1694]], "test": "untested"}
{"id": "3sKfWd", "name": "Arch EAS", "author": "public_int_i", "description": "Arch EAS", "tags": ["archeas"], "likes": 2, "viewed": 204, "published": 3, "date": "1609535899", "time_retrieved": "2024-07-30T19:47:55.050801", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=R3jy8kRJtYc\n4k wallpaper xaloez.com/art/2020/Arch.jpg*/\n\n\n\n#define EPS 1e-3\n#define PI 3.14159265\n\nmat2 r2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec4 r4(float n) {\n\t#define R4P 1.1673039782614187\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat geo(vec3 p) {\n\tp.xy *= r2(p.z*.1);\n\tvec2 l = mod(abs(p.xz),2.)-1.;\n\treturn min(p.y+2.,length(max(abs(l)-.2,0.)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tvec3 rp = vec3(0,0,time),\n\t\trd = normalize(vec3(uv.xy,.7)),\n\t\tc = vec3(0);\n\n\tfor (int i = 0; i < 40; i++) {\n\t\tfloat dst = geo(rp);\n\t\tif (dst <= 0.) break;\n\t\trp += rd*(dst+EPS);\n\t}\n\n\tfragColor = vec4(mix(vec3(.16,.25,.18),vec3(1,1,.6),pow(length(rp.xy)*.1,2.2)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 208, 208, 265], [267, 267, 285, 285, 401], [402, 402, 421, 421, 601], [603, 603, 622, 622, 724], [727, 727, 784, 784, 1136]], "test": "untested"}
{"id": "WdKfWd", "name": "Sun Dance EAS", "author": "public_int_i", "description": "Sun Dance EAS", "tags": ["sundanceeas"], "likes": 7, "viewed": 257, "published": 3, "date": "1609535880", "time_retrieved": "2024-07-30T19:47:55.924465", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=48B3sN_5_hM\n4k wallpaper xaloez.com/art/2020/SunDance.jpg*/\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n\tfloat s = 0.;\n\tfor (float p = 1.; p < 1000.; p += 1.+p*.1) {\n\t\tvec4 pp = hash(p*vec4(.01,.1,1.,10.));\n\t\ts += cos((time*-.5+log(length(uv.xy-(pp.xy*2.-1.))))*p)/p;\n\t}\n\ts = pow(clamp(s*.25+.5,0.,1.),2.2);\n\tfragColor = vec4(mix(vec3(.3,.6,1.)*.3,vec3(1.,.8,.1),s),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 171, 171, 272], [275, 275, 332, 332, 684]], "test": "untested"}
{"id": "WsKBWd", "name": "Cyber Sky EAS", "author": "public_int_i", "description": "Cyber Sky EAS", "tags": ["sky", "cyber", "eas"], "likes": 6, "viewed": 305, "published": 3, "date": "1609535871", "time_retrieved": "2024-07-30T19:47:56.889884", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=g5by1NgPMSg\n4k wallpaper xaloez.com/art/2020/CyberSky.jpg*/\n\n\n#define PI 3.14159265358\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\tx = fract(x);\n\treturn x*2.-max(0.,x*4.-2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\tvec3 s = vec3(0);\n\tfor (float l = 15.; l < 30.; l += 0.1) {\n\t\tvec2 c = floor(uv.xy*l+time*vec2(1,1.));\n\t\tvec4 h = hash(c.xyyx);\n\t\ts += hsvToRGB(vec3(h.x,h.z*.4,max(0.,twave(l*.005+time*.1*h.y+h.y)*10.-9.)));\n\t}\n\tfragColor = vec4(pow(s*.03,vec3(1.6)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 197, 197, 260], [262, 262, 281, 281, 382], [384, 384, 409, 409, 504], [506, 506, 528, 528, 575], [578, 578, 635, 635, 970]], "test": "untested"}
{"id": "wdGfDd", "name": "Light Pool EAS", "author": "public_int_i", "description": "Light Pool EAS", "tags": ["light", "pool", "eas"], "likes": 3, "viewed": 218, "published": 3, "date": "1609535861", "time_retrieved": "2024-07-30T19:47:57.748588", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=dLuDZbGC5Sw\n4k wallpaper xaloez.com/art/2020/LightPool.jpg*/\n\n#define PI 3.14159265358\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#define time iTime\n    vec2 uv =(fragCoord*2.-iResolution.xy)/iResolution.y;\n\tfloat s = 0.;\n\tfor (float l = 1.; l < 20.; l++) {\n\t\tvec4 lh = hash(l*vec4(.01,.1,1.,10.));\n\t\tvec2 ruv = mod(abs((uv.xy-(lh.xy*2.-1.))*r2(l*l*time*.001+length(uv.xy))),.4)-.2,\n\t\t\tauv = abs(ruv)-.2;\n\t\ts += pow(max(-auv.x,-auv.y)*1.5,4.);\n\t}\n\tfragColor = vec4(mix(vec3(.03,.037,.036),vec3(.8,.9,1.),min(1.,s*12.)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 197, 197, 260], [262, 262, 281, 281, 382], [384, 384, 441, 441, 836]], "test": "untested"}
{"id": "Wd3fD7", "name": "Galactic Noise p_i_i", "author": "public_int_i", "description": "galactic noise", "tags": ["noise", "galactic"], "likes": 4, "viewed": 232, "published": 3, "date": "1609535850", "time_retrieved": "2024-07-30T19:47:58.515537", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=iak20znYLcc\n4k wallpaper xaloez.com/art/2020/GalacticNoise.jpg*/\n\n#define PI 3.14159265358\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nvec4 hash(vec4 a) {\n\treturn fract(abs(sin(a.ywxz*766.345)+cos(normalize(a)*4972.92855))*2048.97435+abs(a.wxyz)*.2735);\n}\n\nvec3 hsvToRGB(vec3 hsv) {\n\treturn mix(clamp(abs(mod(hsv.x*6.0+vec3(0.,4.,2.),6.)-3.0)-1.0,0.,1.),vec3(1),hsv.y)*hsv.z;\n}\n\nfloat twave(float x) {\n\tx = fract(x);\n\treturn x*2.-max(0.,x*4.-2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y*(.25+twave(time*.03));\n\n\tvec3 c = vec3(0);\n\tfor (float p = 1.; p < 100.; p++) {\n\t\tvec4 pp = hash(p*vec4(.01,.1,1.,10.));\n\t\tc += cos((time*-.05+length(uv.xy-(pp.xy*2.-1.)))*p*vec3(pp.zw*10.,10))/p;\n\t}\n\tfragColor = vec4(hsvToRGB(pow(clamp(c*.2+.5,0.,1.),vec3(1.,4.,3.))),1);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 201, 201, 264], [266, 266, 285, 285, 386], [388, 388, 413, 413, 508], [510, 510, 532, 532, 579], [581, 581, 638, 638, 995]], "test": "untested"}
{"id": "Ws3BD7", "name": "Binary Forest p_i_i", "author": "public_int_i", "description": "binary forest", "tags": ["binary", "forest"], "likes": 5, "viewed": 246, "published": 3, "date": "1609535837", "time_retrieved": "2024-07-30T19:47:59.287474", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://www.youtube.com/watch?v=2svR2QJQSUA\n4k wallpaper xaloez.com/art/2020/BinaryForest.png*/\n\n#define PI 3.14159265358\n\nmat2 r2(float a) {\n\tfloat sn = sin(a), cs = cos(a);\n\treturn mat2(cs,-sn,sn,cs);\n}\n\nmat2 rot2(float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c,s,-s,c);\n}\nfloat usquare(vec2 p, vec2 s) {\n\treturn length(max(abs(p)-s,0.));\n}\n\nfloat tree(vec2 p, float n, float w) {\n\tfloat y = p.y*n, b = floor(y), x = pow(2.,b),\n\t s = p.x*x, i = floor(s),\n\t rot = (mod(i,2.)-.5);\n\tvec2 uv = vec2(s-i,y-b)*2.-1.;\n\tuv.x /= 1.-(uv.y*.5+.5)*max(0.,w-.175)/(w/.45);\n\tif (b > .5) {\n\t\tif (w < .175) uv.x += rot*(1.-(uv.y*.5+.5))*(1.-w/.175)*.35;\n\t\tuv *= rot2(rot*-.25*3.14);\n\t\tuv.x += rot*.77;\n\t}\n\treturn usquare(uv,vec2(w,2.))/x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime, screenY = iResolution.y;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        \n\tfloat s = 0.;\n\tfor (float x = -2.; x < 3.; x++) {\n\t\tfor (float y = -2.; y < 3.; y++) {\n\t\t\tvec2 rp = mod((uv.xy+vec2(x,y)*.777*.5/screenY)/(.4+time*.2)+100.5,.6)-.3,\n\t\t\t\tap = vec2(atan(rp.y,rp.x)/3.14,length(rp)*2.357022);\n\t\t\ts += max(0.,1.-tree(ap,.9+time,0.01)*(1e-5+ap.y)*1000.);\n\t\t}\n\t}\n\ts /= 25.;\n\tfragColor = vec4(s,s,s,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 182, 200, 200, 263], [265, 265, 285, 285, 342], [343, 343, 374, 374, 410], [412, 412, 450, 450, 794], [797, 797, 854, 854, 1302]], "test": "untested"}
{"id": "tdGBDd", "name": "Electric Wind EAS", "author": "public_int_i", "description": "Electric Wind EAS", "tags": ["wind", "electric", "eas"], "likes": 5, "viewed": 301, "published": 3, "date": "1609535826", "time_retrieved": "2024-07-30T19:48:00.175100", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n4k 60fps video https://youtu.be/-gu25BFUaME\n4k wallpaper xaloez.com/art/2020/ElectricWind.jpg*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define time iTime\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y+vec2(0.,.8);\n\tfloat s = 0.;\n\tfor (float l = 30.; l > 1.; l--) {\n\t\tfloat sw = 0., t = l*.1+time;\n\t\tfor (float w = 1.; w < 10.; w++) sw += pow(.5+.5*sin(t*(1.+w*.1)+uv.x*w*w*.9812),w)/w;\n\t\tsw *= .6;\n\t\tfloat v = max(0.,1.-abs(uv.y-sw)*20.)/l;\n\t\ts = mix(s,1.,v);\n\t}\n\tfragColor = vec4(s);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 198, 198, 565]], "test": "untested"}
{"id": "Wd3BD7", "name": "Embers and Ashes p_i_i", "author": "public_int_i", "description": "publishing some old shaders i did offline", "tags": ["and", "embers", "ashes"], "likes": 5, "viewed": 378, "published": 3, "date": "1609535809", "time_retrieved": "2024-07-30T19:48:01.101623", "image_code": "/*Ethan Alexander Shulman 2020 - xaloez.com\n3840x2160 60fps video https://www.youtube.com/watch?v=2ISSvdhVfwM\n3840x2160 wallpaper xaloez.com/art/2020/EmbersandAshes.jpg*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n\tfloat s = 0.;\n\tfor (float p = 0.; p < 1000.; p++) {\n\t\t#define R3P 1.22074408460575947536\n\t\tvec3 q = fract(.5+p*vec3(1./R3P,1./(R3P*R3P),1./(R3P*R3P*R3P)));\n\t\tfloat a = p*.001+time*(.01+q.z*.1);\n\t\tvec2 x = q.xy*mat2(sin(a*2.1),sin(a*4.13),sin(a*8.16),sin(a*4.18));\n\t\tfloat l = length(x-uv.xy);\n\t\ts += sin((l-q.z)*10.)/(1.+max(0.,l-.01)*200.);\n\t}\n\tfragColor = mix(vec4(.05,.08,.1,1),vec4(1,.5,.4,1),max(0.,s*.4));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 229, 229, 732]], "test": "untested"}
{"id": "Wttczj", "name": "z Reaction diffusion modified", "author": "illus0r", "description": "z Reaction diffusion modified", "tags": ["cellular"], "likes": 6, "viewed": 506, "published": 3, "date": "1609535769", "time_retrieved": "2024-07-30T19:48:01.887522", "image_code": "#define COLOR_MIN 0.0\n#define COLOR_MAX 0.9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).brga);\n    fragColor = vec4(texture(iChannel1, uv).r);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIMESTEP 1.\n//#define SPEED 1.\n\n//#define F (0.05 + .08* smoothstep(.0, .9, length(uv)))\n#define F (0.04)\n#define K (0.07+.02*(texture(iChannel1,fragCoord/iResolution.xy).r-.5))\n//#define K (0.063)\n// 4 circles\n// #define K (0.06+.04*smoothstep(.8, .85, length(abs(uv*2.)-.7)))\n// #define K (0.065+.05*step(.0, sdHexagon(uv, .3)-.1)+uv.y*.02)\n//#define K 0.03+.05*smoothstep(.0,.5,length(uv))\n//#define K (0.1)\n//#define K .5*smoothstep(0.,2.,length(uv))\n#define Da (1.3)\n#define Db (.5*smoothstep(0.,5.,iTime))\n#define RADIUS 3.\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat rnd(float x) {return fract(54321.987 * sin(987.12345 * x));}\n//float rnd(float x) {return 2.*fract(54321.987 * sin(987.12345 * x))-1.;}\n\nvoid getVal(vec2 p, out vec2 val, out float diff_a, out float diff_b) {\n  vec2 r = iResolution.xy;\n  vec2 uv = p / r;\n  val = texture(iChannel0, uv).xy;\n  vec2 neigh_val_a = vec2(0.);\n  vec2 neigh_val_b = vec2(0.);\n  vec2 k_anisotropy = abs(normalize(uv-vec2(.5)));\n  if(uv.x<0.5)k_anisotropy = k_anisotropy.yx;\n  float k_sum = 0.;\n  for(float i = -RADIUS; i <= RADIUS; i++){\n      for(float j = -RADIUS; j <= RADIUS; j++){\n          if(i==0. || j==0.) continue;\n          if(length(vec2(i,j))>RADIUS) continue;\n          //if(length(vec2(i,j))<RADIUS*.5) continue;\n          //vec2 k = .1/pow(vec2(i,j)*k_anisotropy,vec2(2.));\n          vec2 k = vec2(1.);\n          k_sum += k.x+k.y;\n          neigh_val_a += texture(iChannel0, (p+vec2(i,j)) / r).x * k;\n          neigh_val_b += texture(iChannel0, (p+vec2(i,j)) / r).y * k;\n      }\n  }\n  neigh_val_a /= k_sum;\n  neigh_val_b /= k_sum;\n  diff_a = (-val.x+neigh_val_a.x+neigh_val_a.y)/2.;\n  diff_b = (-val.y+neigh_val_b.x+neigh_val_b.y)/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    \n    vec3 colour = vec3(0.0);\n    if (iFrame < 1) {\n        //if (length(fract(uv*5.)-.9)<.1) {\n        colour = vec3(rnd(uv.x+uv.y*.0001));\n        //if (length(uv)<.1) {\n        //    colour = vec3(1.);\n        //}\n    } else {\n     \tvec2 val;\n        float diff_a, diff_b;\n        getVal(fragCoord.xy, val, diff_a, diff_b);\n        \n        vec2 delta;\n \t\tdelta.x = Da * diff_a - val.x * val.y * val.y + F * (1.0 - val.x);\n  \t\tdelta.y = Db * diff_b + val.x * val.y * val.y - (K + F) * val.y;\n        \n        \n        colour = vec3(val + delta * TIMESTEP, 0.0);\n        colour = clamp(colour, -1., 1.);\n    }\n    \n    fragColor = vec4(colour,1.0);\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define res iResolution.xy\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n//float sdTorus( vec3 p, vec2 t ){\n//  vec2 q = vec2(length(p.xz)-t.x,p.y);\n//  return length(q)-t.y;\n//}\n\nfloat dist(vec3 p){\n\treturn p.y+3.+\n        .5*texture(iChannel0, (p.xz)*vec2(.2,.35)+vec2(.5)).r;\n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(.01,0.);\n\treturn normalize(vec3(\n    \tdist(p+e.xyy)-dist(p-e.xyy),\n    \tdist(p+e.yxy)-dist(p-e.yxy),\n        dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    float d=0., e;\n    vec3 p,rd=normalize(vec3((FC*2.-res)/res.y,2.));\n    rd.yz*=rot(3.1415/2.);\n    for(int i=0;i++<99;){\n        p = d*rd;\n        d+=e=dist(p);\n        if(e<.001)break;\n    }\n    fragColor = vec4(vec3(dot(norm(p),vec3(1.)))*.2+.7,1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wttczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 102, 102, 245]], "test": "untested"}
{"id": "tltczj", "name": "Dan's Perlin Noise", "author": "danielsturk", "description": "Perlin Noise", "tags": ["noise", "perlinnoise", "perlin", "random"], "likes": 0, "viewed": 119, "published": 3, "date": "1609535662", "time_retrieved": "2024-07-30T19:48:02.708327", "image_code": "const float perlinSize = 15.; // how many unique tiles to generate in the x/y direction\nconst float repeat = 2.; // useful for checking that the wrapping math is correct\nconst float fixedRes = 512.; // zero to turn off the red area\nconst int numSamples = int(log2(fixedRes / perlinSize / repeat)); // smallest sample distance will be greater than the size of a single pixel\nfloat seed = .52161251235;\n\nfloat rand(float x) {\n    float y = x;\n    y = y * 1.5215126221 + .6123541255;\n    y = fract(y) * (x * 4.6214215621 + .9621412541);\n    y = y * 5.5215126221 + .7123251262;\n    return fract(y);\n}\n\nfloat rand(vec2 x) {\n    return rand(rand(x.x) * 15915.5621453213213 + x.y * 5.12451254521432145);\n}\n\nfloat perlinLayer(vec2 uv, float uvScale, float seed) {\n    uv *= uvScale;\n    vec2 cell0 = floor(uv);\n    vec2 cell1 = cell0 + vec2(1.);\n    vec2 t = uv - cell0;\n    \n    cell0 = mod(cell0, uvScale * perlinSize);\n    cell1 = mod(cell1, uvScale * perlinSize);\n    \n    float x0y0 = rand(rand(vec2(cell0.x, cell0.y)) + seed);\n    float x1y0 = rand(rand(vec2(cell1.x, cell0.y)) + seed);\n    float x0y1 = rand(rand(vec2(cell0.x, cell1.y)) + seed);\n    float x1y1 = rand(rand(vec2(cell1.x, cell1.y)) + seed);\n    \n    float y0 = mix(x0y0, x1y0, t.x);\n    float y1 = mix(x0y1, x1y1, t.x);\n    return mix(y0, y1, t.y);\n}\n\nfloat perlinNoise2D(vec2 uv, float seed) {\n    const bool threshold = false;\n    const bool scaled = true; // minimize high frequency values?\n    \n    float final = 0.;\n    float weight = 0.;\n    float uvScale = 1.;\n    float invUvScale = 1.;\n    for(int i = 0; i < numSamples; i++) {\n        float val = (perlinLayer(uv, uvScale, seed * 417.321125 + float(i)) - .5);\n        if(scaled) {\n            final += val * invUvScale;\n            weight += invUvScale;\n        } else {\n            final += val;\n            weight++;\n        }\n        uvScale *= 2.;\n        invUvScale *= .5;\n    }\n    final /= weight;\n    \n    return threshold ? (final > 0. ? 1. : 0.) : (final + .5);\n}\n\n// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion\nfloat hue2rgb(float p, float q, float t){\n    if(t < 0.) t += 1.;\n    if(t > 1.) t -= 1.;\n    if(t < 1./6.) return p + (q - p) * 6. * t;\n    if(t < 1./2.) return q;\n    if(t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}  \nvec3 hslToRgb(float h, float s, float l){\n    vec3 c;\n\n    if(s == 0.){\n        c.r = c.g = c.b = l;\n    } else {\n\n        float q = l < 0.5 ? l * (1. + s) : l + s - l * s;\n        float p = 2. * l - q;\n        c.r = hue2rgb(p, q, h + 1./3.);\n        c.g = hue2rgb(p, q, h);\n        c.b = hue2rgb(p, q, h - 1./3.);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n    if(fixedRes == 0.) {\n        uv = fragCoord / iResolution.xy;\n        uv -= .5;\n        uv.x *= iResolution.x / iResolution.y;\n    } else {\n        uv = fragCoord / fixedRes;\n        if(any(greaterThan(uv, vec2(2, 1)))) {\n            fragColor = vec4(1., 0., 0., 1.);\n            return;\n        }\n    }\n    uv *= perlinSize * repeat;\n    \n    vec3 c;\n    if(uv.x > perlinSize * repeat) {\n        // pattern on the right\n        uv.x -= perlinSize * repeat;\n        uv.xy += vec2(\n            perlinNoise2D(uv, seed + 441.),\n            perlinNoise2D(uv, seed + 281.)\n        );\n        // uv += (vec2(perlinNoise2D(uv, seed + 4.), perlinNoise2D(uv, seed + 6.)) - .5) * sin(iTime) * 10.;\n        float val = smoothstep(0., 1., perlinNoise2D(uv, seed + 2.));\n        c = hslToRgb(fract(val), 1., .5);\n    } else {\n        // basic pattern on the left\n        float val = smoothstep(0., 1., perlinNoise2D(uv, seed + 2.));\n        c = vec3(val);\n    }\n    \n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 423, 423, 596], [598, 598, 618, 618, 698], [700, 700, 755, 755, 1314], [1316, 1316, 1358, 1358, 1997], [1999, 2074, 2115, 2115, 2311], [2314, 2314, 2355, 2355, 2650], [2652, 2652, 2709, 2709, 3710]], "test": "untested"}
{"id": "WttyR2", "name": "3D SDF Printer", "author": "oneshade", "description": "Fun little 3D printer animation.", "tags": ["3d", "sdf", "animation", "3dprinting", "slicing"], "likes": 12, "viewed": 268, "published": 3, "date": "1609531609", "time_retrieved": "2024-07-30T19:48:03.492231", "image_code": "// Signed distance functions from Inigo Quilez's 3D distance functions article (https://iquilezles.org/articles/distfunctions):\nfloat sdPyramid(in vec3 p, in float h) {\n    float m2 = h * h + 0.25;\n    \n    p.xz = abs(p.xz);\n    p.xz = p.z > p.x ? p.zx : p.xz;\n    p.xz -= 0.5;\n\n    vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n   \n    float s = max(-q.x, 0.0);\n    float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n    \n    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n    \n    float d2 = min(q.y, -q.x * m2 - q.y * 0.5) > 0.0 ? 0.0 : min(a, b);\n\n    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));\n}\n\nfloat sdBox(in vec3 p, in vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdThreadedCylinder(in vec3 p, in float h, in float r, in float turns, in float turnOffset, in float threadThickness) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    float cylinder = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n    float a = p.y * turns + turnOffset;\n    float c = cos(a), s = sin(a);\n    p.xz *= mat2(c, -s, s, c);\n    p.z -= r;\n    float threads = max(abs(p.x), abs(p.z)) - threadThickness;\n\n    return max(cylinder, -threads);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdPrintObject(in vec3 p) {\n    float cube = sdBox(p, vec3(1.35));\n    float sphere = sdSphere(p, 1.6875);\n    float cylinder1 = length(p.yz) - 0.6;\n    float cylinder2 = length(p.xz) - 0.6;\n    float cylinder3 = length(p.xy) - 0.6;\n    return max(max(cube, sphere), -min(cylinder1, min(cylinder2, cylinder3)));\n}\n\nfloat mapScene(in vec3 p) {\n    p.yz *= mat2(0.965925826289068, 0.258819045102521, -0.258819045102521, 0.965925826289068);\n\n    float r = (iMouse.x / iResolution.x - 0.5) * 3.1415926535;\n    float c = cos(r), s = sin(r);\n    p.xz *= mat2(c, -s, s, c);\n\n    float printObj = sdPrintObject(p);\n\n    float time = max(0.0, iTime - 1.0);\n    float animTime = time;\n    if (time > 10.0) animTime = time * 10.0 - 100.0;\n    if (time > 20.0) animTime = time * 100.0 - 2000.0;\n    if (time > 30.0) animTime = time * 1000.0 - 30000.0;\n\n    p += 1.35;\n    vec3 pos = floor(mod(animTime / vec3(1.0, 18225.0, 135.0), 2.7) / 0.02) * 0.02;\n    if (animTime > 49207.5) pos = vec3(2.7);\n\n    float stack = p.y - pos.y;\n    float layer = max(stack - 0.02, p.z - pos.z);\n    float row = max(max(stack - 0.02, p.z - pos.z - 0.02), p.x - pos.x);\n\n    vec3 bp = p;\n    bp.xz -= 1.35;\n    float base = sdBox(vec3(bp.x, bp.y + 0.5, bp.z), vec3(3.25, 0.25, 3.25)) - 0.1;\n\n    vec3 lp = bp;\n    lp.xz = abs(lp.xz) - 2.5;\n    lp.y -= 2.25;\n    float lifts = sdThreadedCylinder(lp, 2.5, 0.1, 15.0, pos.y * 10.0, 0.05);\n\n    vec3 rp = vec3(lp.x, bp.y - pos.y - 2.0, bp.z);\n    float risers = sdBox(lp - vec3(0.0, pos.y - 0.25, 0.0), vec3(0.4)) - 0.1;\n    risers = min(risers, sdThreadedCylinder(rp.xzy, 2.5, 0.1, 15.0, pos.z * 10.0, 0.05));\n\n    vec3 sp = vec3(rp.x, rp.y, rp.z + 1.35 - pos.z);\n    float sliders = sdBox(sp, vec3(0.4)) - 0.1;\n    sliders = min(sliders, sdThreadedCylinder(vec3(sp.y, bp.x, sp.z), 2.5, 0.1, 15.0, pos.x * 10.0, 0.05));\n\n    vec3 hp = p - pos;\n    hp.y = 1.0 - hp.y;\n    float head = sdPyramid(hp, 1.0) - 0.05;\n    hp.y += 0.65;\n    head = min(head, sdBox(hp, vec3(0.45, 0.65, 0.45)) - 0.1);\n\n    float printer = min(base, min(min(lifts, min(risers, sliders)), head));\n\n    return min(printer, max(printObj, min(stack, min(layer, row))));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, -0.125, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += (0.5 + 0.5 * n) * max(0.3, dot(n, l));\n            break;\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 128, 168, 168, 732], [734, 734, 769, 769, 864], [866, 866, 990, 990, 1336], [1338, 1338, 1377, 1377, 1405], [1407, 1407, 1439, 1439, 1725], [1727, 1727, 1754, 1754, 3569], [3571, 3571, 3598, 3598, 3840], [3842, 3842, 3897, 3897, 4504]], "test": "untested"}
{"id": "tltcRj", "name": "Pascal's triangle in mod p", "author": "IWBTShyGuy", "description": "Pascal's triangle in mod p.", "tags": ["gasket", "pascalstriangle"], "likes": 3, "viewed": 260, "published": 3, "date": "1609530884", "time_retrieved": "2024-07-30T19:48:04.390829", "image_code": "// Copyright  2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst int ROWS = 200;\nconst int N_PRIMES = 4;\nconst int PRIMES[N_PRIMES] = int[](2, 3, 5, 7);\n\nconst int INVS_LENGTH = 7;\nint INVS[INVS_LENGTH];\n\n//  https://www.amazon.co.jp/dp/B07881DSZQ/\n// p.256-257 Black and Bright Color\nconst vec3 PALLET[9] = vec3[](\n    vec3(40.0, 0.0, 23.0) / 255.0,\n    vec3(225.0, 146.0, 188.0) / 255.0,\n    vec3(187.0, 174.0, 212.0) / 255.0,\n    vec3(171.0, 217.0, 203.0) / 255.0,\n    vec3(248.0, 245.0, 176.0) / 255.0,\n    vec3(195.0, 196.0, 196.0) / 255.0,\n    vec3(229.0, 66.0, 145.0) / 255.0,\n    vec3(231.0, 42.0, 84.0) / 255.0,\n    vec3(126.0, 56.0, 145.0) / 255.0\n);\n\nvoid initINVS(in int p) {\n    INVS[0] = 0;\n    for (int i = 1; i < p; i++) {\n        for (int k = 1; k < p; k++) {\n            if ((i * k) % p == 1) {\n                INVS[i] = k;\n                break;\n            }\n        }\n    }\n}\n\n// mantissa * p^exponent\nstruct PNum {\n    int mantissa;\n    int exponent;\n};\n\nPNum mul(in PNum a, in PNum b, in int p) {\n    PNum c;\n    c.mantissa = (a.mantissa * b.mantissa) % p;\n    c.exponent = a.exponent + b.exponent;\n    return c;\n}\n\nPNum div(in PNum a, in PNum b, in int p) {\n    PNum c;\n    c.mantissa = (a.mantissa * INVS[b.mantissa]) % p;\n    c.exponent = a.exponent - b.exponent;\n    return c;\n}\n\nPNum int2PNum(in int n, in int p) {\n    PNum c;\n    c.exponent = 0;\n    while (n % p == 0) {\n        n /= p;\n        c.exponent += 1;\n    }\n    c.mantissa = n % p;\n    return c;\n}\n\nint PNumCombo(in int n, in int k, in int p) {\n    PNum res = int2PNum(1, p);\n    for (int i = 0; i < k; i++) {\n        PNum c = int2PNum(n - i, p);\n        res = mul(res, c, p);\n        c = int2PNum(i + 1, p);\n        res = div(res, c, p);\n    }\n    return res.exponent == 0 ? res.mantissa : 0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int p = PRIMES[int(iTime) % N_PRIMES];\n    int rows = ROWS;\n    int columns = rows % 2 == 0 ? rows : rows + 1;\n\n    initINVS(p);\n    vec2 uv = fragCoord / iResolution.y;\n    float asp = iResolution.x / iResolution.y;\n    int n = int(float(rows) * (1.0 - uv.y));\n    int k = int(floor(((2.0 * uv - asp) * float(columns) + float(n + 1)) / 2.0));\n    if (0 <= k && k <= n) fragColor = vec4(PALLET[PNumCombo(n, k, p)], 1.0);\n    else fragColor = vec4(PALLET[0], 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltcRj.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[705, 705, 730, 730, 939], [1020, 1020, 1062, 1062, 1180], [1182, 1182, 1224, 1224, 1348], [1350, 1350, 1385, 1385, 1529], [1531, 1531, 1576, 1576, 1827], [1829, 1829, 1884, 1884, 2354]], "test": "untested"}
{"id": "3ltczj", "name": "3D Map (No Polar Distortions)", "author": "oneshade", "description": "3D version of my \"Infinite Map\"  shader (without polar distortions!).", "tags": ["procedural", "3d", "map", "fractalnoise", "geography"], "likes": 12, "viewed": 268, "published": 3, "date": "1609519258", "time_retrieved": "2024-07-30T19:48:05.156781", "image_code": "#define PLANET_RADIUS 1.5\n#define MAP_SCALE 2.0\n#define MAP_ROUGHNESS 5.0\n#define MAP_HEIGHT 0.2\n#define MARKER_SPACING 0.75\n\nvec3 Hash33(in vec3 p) {\n    return vec3(fract(sin(dot(p, vec3(7643.54, 6854.95, 356.6765))) * 234.752),\n                fract(sin(dot(p, vec3(7853.67, 5214.327, 435.6437))) * 6734.8275),\n                fract(sin(dot(p, vec3(7546.754, 683.2647, 358.2431))) * 257.8643));\n}\n\nfloat noise(in vec3 p) {\n    return fract(sin(dot(p, vec3(3743.54, 2754.23, 578.537))) * 5664.865);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0));\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0));\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0));\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0));\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0));\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0));\n    float ruf = noise(cell + 1.0);\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(lub, rub, local.x),\n                   local.y),\n\n               mix(mix(ldf, rdf, local.x),\n                   mix(luf, ruf, local.x),\n                   local.y),\n\n               local.z);\n}\n\nfloat fnoise(in vec3 p) {\n    p *= MAP_SCALE;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < MAP_ROUGHNESS; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec3 map(in vec3 p) {\n    float n = fnoise(p);\n    vec3 color = mix(vec3(0.0, 0.0, 1.25 - n), mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), n * n), float(n > 0.5));\n\n    vec3 pinPos = floor(p / MARKER_SPACING + 0.5) * MARKER_SPACING;\n    pinPos += 0.45 * Hash33(pinPos) - 0.225;\n    pinPos = normalize(pinPos) * (PLANET_RADIUS + fnoise(p) * MAP_HEIGHT);\n    float pin = length(p - pinPos) - 0.05;\n    n = fnoise(pinPos);\n    if (n > 0.5 && pin < 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n\n    return color;\n}\n\nfloat mapScene(in vec3 p) {\n    float earth = length(p) - PLANET_RADIUS;\n    earth -= fnoise(p) * MAP_HEIGHT;\n    return earth * 0.98;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (float iters=0.0; iters < 150.0; iters++) {\n        vec3 p = ro + rd * t;\n\n        vec2 cs = sin(iTime + vec2(1.57, 0.0));\n        p.xz *= mat2(cs, -cs.y, cs.x);\n        p.yz *= mat2(cs, -cs.y, cs.x);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(cs.x, -cs.y, cs.yx);\n            n.xz *= mat2(cs.x, -cs.y, cs.yx);\n\n            fragColor.rgb += map(p);\n            fragColor.rgb *= max(0.3, dot(n, l));\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 150, 150, 399], [401, 401, 425, 425, 502], [504, 504, 529, 529, 1255], [1257, 1257, 1282, 1282, 1578], [1580, 1580, 1601, 1601, 2096], [2098, 2098, 2125, 2125, 2234], [2236, 2236, 2263, 2263, 2570], [2572, 2572, 2627, 2627, 3468]], "test": "untested"}
{"id": "3ttyRj", "name": "Second order pixel sorter", "author": "andrinr", "description": "Attempt at programming a pixel sorter without looking at any resources.", "tags": ["pixel", "sorting", "binarysearch", "sortingtree"], "likes": 5, "viewed": 419, "published": 3, "date": "1609500038", "time_retrieved": "2024-07-30T19:48:06.031442", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    // Output to screen\n    fragColor = vec4(buffer,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Sorting step 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n    vec3 y = texture(iChannel0,uv).xyz;\n    \n    vec3 y_l = texture(iChannel0,uv - vec2(du, 0.)).xyz;\n    vec3 y_r = texture(iChannel0,uv + vec2(du, 0.)).xyz;\n    \n    // Modulo\n    if (fract(float(fragCoord.x)/2.0) > 0.5){\n        if (length(y_l) > length(y)){\n            y = y_l;\n        }\n    }\n    \n    // Modulo\n    if (fract(float(fragCoord.x)/2.0) < 0.5){\n        if (length(y) > length(y_r)){\n            y = y_r;\n        }\n    }\n\n    fragColor = vec4(y,1.0);\n    \n    if (iFrame < 4){\n        \n        fragColor = texture(iChannel1,uv);\n    }\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Sorting step 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n    vec3 y = texture(iChannel0,uv).xyz;\n    \n    vec3 y_l = texture(iChannel0,uv - vec2(du, 0.)).xyz;\n    vec3 y_r = texture(iChannel0,uv + vec2(du, 0.)).xyz;\n    \n    // Modulo\n    if (fract(float(fragCoord.x)/2.0) > 0.5){\n        if (length(y_r) < length(y)){\n            y = y_r;\n        }\n    }\n    \n    // Modulo\n    if (fract(float(fragCoord.x)/2.0) < 0.5){\n        if (length(y_l) > length(y)){\n            y = y_l;\n        }\n    }\n\n    fragColor = vec4(y,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 342]], "test": "untested"}
{"id": "WttyRj", "name": "Normalized Blinn Phong test", "author": "iY0Yi", "description": "Another test for Normalized Blinn Phong shading.\nMouse enabled.\nref:\nhttps://hanecci.hatenadiary.org/entry/20130505/p2\nhttp://www.project-asura.com/program/d3d11/d3d11_006.html", "tags": ["phong", "blinn", "normalized"], "likes": 8, "viewed": 406, "published": 3, "date": "1609499319", "time_retrieved": "2024-07-30T19:48:07.113549", "image_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(41.593, 63.9086, 42.6658);\n\tcam0.quaternion = vec4(0.1393, 0.3404, 0.8606, 0.3522);\n\tcam0.fov = 0.18;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = vec3(0.5, 0.6, -0.5);\n    R(lit0.direction.xz, iTime*.5);\n\tlit0.color = vec3(1.0, 1.0, 1.0);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(-0.2662, -0.8589, 0.4376));\n\tlit1.color = vec3(0.3, 0.3, 0.3);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}void perspectiveCam(vec2 uv){\n\tvec3 up = vec3(0,1,0);\n    \n    vec3 pos = vec3(42,64,42);\n    if(iMouse.z>0.)\n\tpos = vec3(42.*sin(iMouse.x/iResolution.x*TAU), 64.*iMouse.y/iResolution.y, 42.*cos(iMouse.x/iResolution.x*TAU));\n\tvec3 target = vec3(0,0,0);\n    vec3 dir = normalize(pos-target);\n\n\tfloat fov = cam0.fov;\n\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n}\nvoid camera(vec2 uv){\n\n\tperspectiveCam(uv);\n\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r){\n\treturn length(p)-r;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp000 = p;\n\tcp000.xyz += vec3(-1.5, -1.0, -1.5);\n\tpRepLimited(cp000.z, 3.0, 5.);\n\tpRepLimited(cp000.x, 3.0, 5.);\n\n\td = sdPlane(p);\n\t{\n\t\tvec3 tp = cp000+vec3(0.5, 0.0, 0.0);\n\t\tvec3 trp = rot(cp000+vec3(0.5, 0.0, 0.0), vec3(0.0, 1.5708, 0.0));\n\t\tvec3 dim = vec3(1.0, 1.0, 0.5);\n\t\tfloat td = MAX_DIST;\n\t\t// Custom Primitive Example: Hex\n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.1;\n\t\td=fOpUnionSmooth(td, d, 0.01);\n\t}\n\td = fOpUnionSmooth(sdSphere(cp000+vec3(-0.5, 0.0, 0.0), 0.9), d, 0.124);\n\tres = v4OpUnion(vec4(d, MAT_ERNST1), res);\n\n\treturn res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.)).x-c,\n\t\tsdScene(p+vec3(0.,e,0.)).x-c,\n\t\tsdScene(p+vec3(0.,0.,e)).x-c)\n\t);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=0; i<nbIte; i++ ){\n\t\tfloat l = hash11(float(i))*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// Phong specular\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+2.) / (2.*PI);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    return 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+5.) / (2.*PI);\n    vec3 h  = normalize(-vd+ld);\n    return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    vec3 h  = normalize(-vd+ld);\n    return 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n#define tex iChannel0\n#define NextLine nextLine(p)\n#define WriteChar(char,style) writeStandardChar(char,style,pp,tex,renDat.albedo)\n#define WriteWord(word,style) writeWord(word,style,pp,tex,renDat.albedo)\n#define WriteText(text,style) writeText(text,style,pp,tex,renDat.albedo)\n#define WriteNumber(number,min_int_digits,dec_digits,style) writeNumber(number,min_int_digits,dec_digits,style,pp,tex,renDat.albedo)\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n        \n        // \"Utils : font display\" by ABizard:\n        // https://www.shadertoy.com/view/MdycDK\n        const int[] text1 = int[](_I,_n,_t,_e,_n,_s,_i,_t,_y);\n        const int[] text2 = int[](_S,_h,_i,_n,_i,_n,_e,_s,_s);\n        vec2 COORD = floor(p.xz*iResolution.x);\n        PrintStyle white_out_black = NewPrintStyle(WHITE,renDat.albedo);\n        \n        vec2 pos = vec2(-7.,-14.);\n        float scale = 1./2.;\n        PrintPosition pp;\n        pp = getDisplayPos(pos,scale);\n\n        WriteWord(text1,white_out_black);\n        \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text2,white_out_black);\n        \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text1,white_out_black);\n    \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text2,white_out_black);\n    \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .1, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, .5, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 2., 2.);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\tfloat shininess = pow(.1, max(0.,floor((p.z+9.+1.5)*.3333)))+0.+pow((texture(iChannel1, p.xz*.5).r)*15., max(0.,floor((p.z+9.+1.5)*.3333)));\n\t\tfloat shininessRef = pow(.25, max(0.,floor((p.z+9.+1.5)*.3333)))+4.;\n\t\tfloat intensity = pow(.3, max(0.,floor((p.x+9.+1.5)*.3333)));\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\tfloat ref = BlinnPhongRef(shininessRef, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH)*(.4+.6*ref);\n\t\trenDat.result*= renDat.albedo;\n        \n\t\tfloat roughness = .7;\n\t\tfloat linearRoughness = roughness * roughness;\n\t\tfloat spec = normalizedBlinnPhong(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity*step(0.1,p.y);\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\t//renDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 ACESFilm(vec3 x){\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n    \n    renDat.result = ACESFilm(renDat.result);\n\trenDat.result = pow(renDat.result, vec3(.9));\n\n\tfragColor = vec4(renDat.result, 1.);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.0)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define ITERATION 100\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST1 vec3(0.2396, 0.2396, 0.2396)\n\n#define AMB_COL vec3(1.0, 1.0, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(1.0, 1.0, 1.0)\n#define FOG_START -0.63\n#define FOG_POW 1.0\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n\n\n// \"SDF Font Texture Adventures\" by P_Malin:\n// https://www.shadertoy.com/view/ldfcDr\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define PURPLE\t\tvec3(1,0,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define VIOLET \t\tvec3(.5,0,1)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define LIGHT_GREEN\tvec3(.5,1,0)\n#define LAGOON\t\tvec3(0,1,.5)\n#define ORANGE\t\tvec3(1,.5,0)\n#define MAGENTA\t\tvec3(1,0,.5)\n#define PINK\t\tvec3(1,.3,.7)\n\n\n#define POW2(A) ((A)*(A))\n#define POW3(A) (POW2(A)*(A))\n#define POW4(A) (POW3(A)*(A))\n\n#define Res iResolution\n\nint powInt(int a, int b){\n    int r = 1;\n    for(int i=0;i++<b;r*=a);\n    return r;\n}\n\nint intLog(int x, int base){\n    if(x<1) return 0;\n    int res = 0;\n    for(;x>=base;res++)\n        x /= base;\n    return res;\n}\n\n// Periodic function __|__|__|__|__\n// s : dirac compression\nfloat periodicDirac(float x, float period, float s){\n\treturn pow(abs(cos(x*(PI/period))),s);\n}\n\n////////////////////////////////\n\n// Ascii encoding. Takes ~900 chars so you may want to take onlywhat you need\nconst int\t_=32,\n\t\t\t_EXCL=33,\t\t// !\n\t\t\t_QUOTE=34,\t\t// \"\n\t\t\t_SHARP=35,\t\t// #\n\t\t\t_DOLLAR=36,\t\t// $\n\t\t\t_PERCENT=37,\t// %\n\t\t\t_AMPER=38,\t\t// &\n\t\t\t_SQUOTE=39,\t\t// '\n\t\t\t_LPAR=40,\t\t// (\n\t\t\t_RPAR=41,\t\t// )\n\t\t\t_ASTERISK=42,\t// *\n\t\t\t_PLUS=43,\t\t// +\n\t\t\t_COMMA=44,\t\t// ,\n\t\t\t_MINUS=45,\t\t// -\n\t\t\t_DOT=46,\t\t// .\n\t\t\t_SLASH=47,\t\t// /\n\t\t\t_0=48,\t_1=49,\t_2=50,\t_3=51,\t_4=52,\n    \t\t_5=53,\t_6=54,\t_7=55,\t_8=56,\t_9=57,\n    \t\t_COLON=58,\t\t// :\n    \t\t_SEMICOLON=59,\t// ;\n    \t\t_LT=60,\t\t\t// <\n    \t\t_EQ=61,\t\t\t// =\n    \t\t_GT=62,\t\t\t// >\n    \t\t_QUEST=63,\t\t// ?\n    \t\t_AT=64,\t\t\t// @\n\t\t\t_A=65,\t_B=66,\t_C=67,\t_D=68,\t_E=69,\n\t\t\t_F=70,\t_G=71,\t_H=72,\t_I=73,\t_J=74,\n\t\t\t_K=75,\t_L=76,\t_M=77,\t_N=78,\t_O=79,\n\t\t\t_P=80,\t_Q=81,\t_R=82,\t_S=83,\t_T=84,\n\t\t\t_U=85,\t_V=86,\t_W=87,\t_X=88,\t_Y=89,\n\t\t\t_Z=90,\n\t\t\t_a=97,\t_b=98,\t_c=99,\t_d=100,\t_e=101,\n\t\t\t_f=102,\t_g=103,\t_h=104,\t_i=105,\t_j=106,\n\t\t\t_k=107,\t_l=108,\t_m=109,\t_n=110,\t_o=111,\n\t\t\t_p=112,\t_q=113,\t_r=114,\t_s=115,\t_t=116,\n\t\t\t_u=117,\t_v=118,\t_w=119,\t_x=120,\t_y=121,\n\t\t\t_z=122,\n    \t\t_alpha=128,\t\t_beta=129,\t_gamma=130,\t\t_delta=131,\n    \t\t_epsilon=132,\t_theta=133,\t_lambda=134,\t_mu=135,\n    \t\t_xi=136,\t\t_pi=137,\t_rho=138,\t\t_sigma=139,\n    \t\t_tau=140,\t\t_phi=141,\t_psi=142,\t\t_omega=143,\n    \t\t_GAMMA=144,\t\t_DELTA=145,\t_THETA=146,\t\t_LAMBDA=147,\n    \t\t_PI=148,\t\t_SIGMA=149,\t_PHI=150,\t\t_PSI=151,\n    \t\t_OMEGA=152;\n\nstruct PrintPosition{\n    vec2 uv,\n         pos,\n         Res;\n    float scale;\n};\n\nstruct PrintStyle{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2, float w){\n\treturn PrintStyle(col1,col2,w);\n}\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2){\n\treturn PrintStyle(col1,col2,.05);\n}\nPrintStyle NewPrintStyle(vec3 col){\n\treturn PrintStyle(col,col,0.);\n}\n#define DefaultPrintStyle NewPrintStyle(WHITE,BLACK)\n\n#define getDisplayPos(pos,scale) PrintPosition((COORD-pos*Res.xy)/(scale*Res.x),pos,Res.xy,scale);\n#define nextLine(p)\tp.pos.y -= scale*1.5,\\\n\t\t\t\t\tp = getDisplayPos(p.pos,p.scale);\n\nvoid writeChar(int char, PrintStyle style,\n               float w, float x_offset, // Dimensions of the bbox of the char\n               inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char/16))/16.)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            // We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(0.,-1./p.Res.y,getFont(uv,char).a - outline_size-.5));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; // move uv for next char\n    \tp.uv = uv;\n}\n\nfloat default_ch_w = .8,\n      default_ch_off = .3;\n\nvoid writeStandardChar(int char, PrintStyle style,\n                     inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeChar(char,style,\n              default_ch_w,default_ch_off,\n              p,font_tex,color);\n}\n\n#define writeText(text, style, p, font_tex, color)\\\n\t{int chars_per_line = int((1.-p.pos.x)/(p.scale*(default_ch_w-default_ch_off)));\\\n\tfor(int i=0;i<text.length();i++){\\\n        writeStandardChar(text[i],style,p,font_tex,color);\\\n        if((i+1)%chars_per_line==0)\\\n            nextLine(p);\\\n    }}\n\n#define writeWord(word, style, p, font_tex, color)\\\n\tfor(int i=0;i<word.length();i++)\\\n        writeStandardChar(word[i],style,p,font_tex,color);\n\nvoid writeNumber(float number, int min_int_digits, int dec_digits,\n                 PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n\t\n    if(isnan(number)){\n    \tPrintStyle NaN_style = PrintStyle(BLACK,RED,.05);\n        writeWord(int[](_N,_a,_N),NaN_style,p,font_tex,color);\n    }\n    else if(isinf(number)){\n        PrintStyle Inf_style = PrintStyle(BLACK,LIGHT_BLUE,.05);\n        writeWord(int[](_I,_n,_f),Inf_style,p,font_tex,color);\n    }\n    else{\n        // Display the minus if number is negative\n        if(number<0.)\n            writeStandardChar(_MINUS,style,p,font_tex,color);\n        \n        // Round the number according to the number of decimal digits\n        float decimal_digits_factor = float(powInt(10,dec_digits));\n        int rounded_number = int(round(abs(number)*decimal_digits_factor));\n        \n        int int_part = rounded_number/int(decimal_digits_factor);\n        int int_digits = 1 + intLog(int_part,10);\n        // Fill with zeros to match min digits\n        for(int i=0;i++< min_int_digits - int_digits ;)\n            writeStandardChar(_0,style,\n                              p,font_tex,color);\n        \n        \n        int digits = int_digits+dec_digits;\n        for(int x = powInt(10,digits);digits>0;digits--){\n            if(digits==dec_digits)\n                // Dot\n                writeChar(_DOT,style,\n                      .65,.45,\n                      p,font_tex,color);\n            writeStandardChar(_0+rounded_number/(x/=10),style,\n                              p,font_tex,color);\n            rounded_number%=x;\n        }\n    }\n        \n}\n\nvoid writeNumber(int number, int min_int_digits, PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeNumber(float(number),min_int_digits,0,\n                style,\n                p,font_tex,color);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[662, 662, 686, 686, 744], [895, 895, 907, 907, 1441], [1442, 1550, 1588, 1588, 1664], [1664, 1664, 1693, 1693, 2234], [2235, 2235, 2256, 2256, 2281], [2283, 2372, 2397, 2397, 2412], [2414, 2414, 2451, 2451, 2474], [2476, 2476, 2514, 2514, 2533], [2535, 2535, 2571, 2571, 2594], [2596, 2596, 2642, 2642, 2727], [2729, 2805, 2869, 2869, 3234], [3236, 3326, 3347, 3347, 4224], [4226, 4298, 4315, 4315, 4610], [4612, 4684, 4704, 4704, 4875], [4877, 4949, 4978, 4978, 5457], [5459, 5607, 5638, 5638, 5741], [5742, 5742, 5786, 5786, 5882], [5883, 5883, 5966, 5966, 6440], [6442, 6532, 6597, 6597, 6776], [6777, 6777, 6845, 6845, 6900], [6902, 7016, 7086, 7086, 7232], [7233, 7233, 7296, 7296, 7381], [10863, 10935, 10957, 10957, 11079], [11081, 11153, 11207, 11207, 11676]], "test": "untested"}
{"id": "WltyDN", "name": "Lights - Quasar", "author": "Quasar", "description": "My first shader with no tutorial. Still some issues, but for the most part, I'm pretty happy with how it turned out!\n\n1/1/2021 - Mostly fixed lighting issues.", "tags": ["procedural", "lights"], "likes": 3, "viewed": 310, "published": 3, "date": "1609479139", "time_retrieved": "2024-07-30T19:48:07.985218", "image_code": "#define s smoothstep\n\nfloat rand(float x) {\n    return (cos(x * 1297436.) + 1.) / 2.;\n}\n\nvec3 light(vec2 uv, vec2 pos, float r, vec3 col, vec2 wind, float id) {\n    float blur = (cos(iTime + id * 54.) + 1.1) / 30. + 0.1;\n    vec3 c = vec3(0);\n    float sm = s(r + blur, r, length(pos - uv));\n    return col * sm;\n}\n\nvec3 getLights(vec2 uv, int amt) {\n    vec3 col = vec3(0);\n    \n    float v = 0.4;\n    \n    for (int i = 0; i < amt; i += 1) {\n        float fi = float(i);\n        \n        if (rand(fi) > 0.) {\n            fi = -fi;\n        };\n        \n        vec2 wind = vec2(15. + fi / 2., 0);\n        \n        vec2 pos = grad(vec2(i * 100)) * 1.1;\n        \n        vec2 t = vec2(iTime) / 100.;\n        \n        pos += vec2(wind * t);\n        pos.y += (getNoise(t + vec2(fi) * 3.) - 0.5) * 3.;\n        pos.x = fract(pos.x) * 2.9 - 1.6;\n        \n        vec3 color = vec3(rand(fi), rand(fi * 3.), rand(fi + 10.));\n        \n        col += light(uv, pos, 0.1, color, wind, fi);\n    };\n    \n    if (col.r > v || col.g > v || col.b > v) {\n        return col;\n    };\n    \n    for (int i = 0; i < amt; i += 1) {\n        float fi = float(i);\n        \n        if (rand(fi) > 0.) {\n            fi = -fi;\n        };\n        \n        vec2 wind = vec2(15. + fi / 2., 0);\n        \n        vec2 pos = grad(vec2(i * 100)) * 1.1;\n        \n        vec2 t = vec2(iTime) / 100.;\n        \n        pos += wind * t;\n        pos.y += (getNoise(t + vec2(fi) * 3.) - 0.5) * 3.;\n        pos.x = fract(pos.x) * 2.9 - 1.6;\n        \n        vec3 color = vec3(rand(fi), rand(fi * 3.), rand(fi + 10.));\n        \n        float d = 0.02 / (length(uv - pos) / 2.);\n        \n        col += s(0., .5, color * d);\n    };\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = getLights(uv, 15);\n    \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "#define seed 1.\n\nvec2 grad(vec2 p) {\n    p = vec2(dot(p, vec2(189.0, 75.0)), dot(p, vec2(122.0, 220.0)));\n    return fract(sin(p) * 4.432885 * seed) * 2.0 - 1.0;\n}\n\nfloat getNoise(vec2 pos) {\n\tpos *= 10.;\n    vec2 id = floor(pos);\n    vec2 uv = fract(pos);\n    \n    float dot1 = dot(uv, grad(id));\n    float dot2 = dot(uv - vec2(1., 0), grad(id + vec2(1., 0)));\n    float dot4 = dot(uv - vec2(1., 1.), grad(id + vec2(1., 1.)));\n    float dot3 = dot(uv - vec2(0., 1.), grad(id + vec2(0, 1.)));\n    \n    uv = uv * uv * (3.0 - 2.0 * uv);\n    \n    float top = mix(dot1, dot2, uv.x);\n    \n    float bottom = mix(dot3, dot4, uv.x);\n    \n    float middle = mix(top, bottom, uv.y);\n    \n    return middle * 0.5 + 0.5;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 43, 43, 87], [89, 89, 160, 160, 314], [316, 316, 350, 350, 1707], [1709, 1709, 1766, 1766, 1904]], "test": "untested"}
{"id": "wlcyRj", "name": "z Reaction diffusion", "author": "illus0r", "description": "I modified this shader by polyrhythm\nhttps://www.shadertoy.com/view/MssyDf", "tags": ["cellular"], "likes": 1, "viewed": 274, "published": 3, "date": "1609462054", "time_retrieved": "2024-07-30T19:48:08.898776", "image_code": "#define COLOR_MIN 0.0\n#define COLOR_MAX 0.9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).gr, 1., 0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TIMESTEP 1.3\n//#define SPEED 1.\n\n//#define F (0.0345 * (2.-length(uv)*length(uv)))\n//#define F .009*smoothstep(20.,1.,length(uv))\n#define F (0.06+uv.x*.01)\n//#define K (0.055+uv.y*.0)\n#define K (0.06)\n//#define K (0.055+.04*smoothstep(.1, .99, length(uv)))\n//#define K 0.03+.05*smoothstep(.0,.5,length(uv))\n//#define K (0.1)\n//#define K .5*smoothstep(0.,2.,length(uv))\n#define Da (1.+uv.x*.0)\n#define Db (.2+uv.y*.0)\n#define RADIUS 5.\n\nvoid getVal(vec2 p, out vec2 val, out vec2 laplacian) {\n  vec2 r = iResolution.xy;\n  vec2 uv = p / r;\n\n  val = texture(iChannel0, uv).xy;\n  laplacian = vec2(0.);\n  float k_sum = 0.;\n  for(float i = -RADIUS; i <= RADIUS; i++){\n      for(float j = -RADIUS; j <= RADIUS; j++){\n          if(i==0. && j==0.) continue;\n          float k = 1./pow(length(vec2(i,j)), 1.);\n          //k *= abs(normalize(j)-normalize(i));\n          k *= abs(dot(normalize(uv), normalize(vec2(i,j))));\n          k_sum += k;\n          laplacian += texture(iChannel0, (p+vec2(i,j)) / r).xy * k;\n      }\n  }\n  laplacian /= k_sum;\n  laplacian += -1.0 * val;\n  laplacian *= 1.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy) / iResolution.y;\n    \n    vec3 colour = vec3(0.0);\n    if (iFrame < 1) {\n        //if (length(fract(uv*5.)-.9)<.1) {\n        if (length(uv)<.1) {\n            colour = vec3(1.);\n        }\n    } else {\n     \tvec2 val, laplacian;\n        getVal(fragCoord.xy, val, laplacian);\n        \n        vec2 delta;\n \t\tdelta.x = Da * laplacian.x - val.x * val.y * val.y + F * (1.0 - val.x);\n  \t\tdelta.y = Db * laplacian.y + val.x * val.y * val.y - (K + F) * val.y;\n        \n        \n        colour = vec3(val + delta * TIMESTEP, 0.0);\n        colour = clamp(colour, -1., 1.);\n    }\n    \n    fragColor = vec4(colour,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 102, 102, 204]], "test": "untested"}
{"id": "tlcyRj", "name": "2021 & the semiprime spiral", "author": "mla", "description": "2021 = 43*47 is a semiprime, in fact the product of two consecutive primes. If the semiprimes are drawn as a spiral, 2021 is an isolated point (see [url]https://oeis.org/A113688[/url])\n\nPress mouse button if you get bored waiting for the spiral to draw.", "tags": ["spiral", "2021", "semiprime"], "likes": 4, "viewed": 409, "published": 3, "date": "1609459255", "time_retrieved": "2024-07-30T19:48:09.656749", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 2021, Matthew Arcus, mla, 2021\n//\n// The square semiprime spiral: arrange the integers in a square spiral\n// and colour in the semiprimes. An isolated semiprime is one where none\n// of its 8 neighbours are semiprimes. 2021 (flashing in red) is an\n// isolated semiprime.\n//\n// Grid code from: https://www.shadertoy.com/view/3tc3zj by saidwho12\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint N = 4; // Pixels per square side\n\n// Get ring start number, from current ring width\nint K(int w) { return w > 1 ? 4+(w-2)*4 : 1; }\n\n// Get width of ring index\nint W(int i) { return i*2+1; }\n\nbool semiprime(int n) {\n  if (n < 2) return false;\n  int target = 2;\n  int count = 0;\n  for (int i = 2; i*i <= n; i++) {\n    while (n % i == 0) {\n      count++;\n      if (count > target) return false;\n      n /= i;\n      if (n == 1) return count == target;\n    }\n  }\n  // n is prime\n  return count == target-1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= 0.5*iResolution.xy;\n    \n    if (iMouse.z > 0.0) N = 1+int(16.0*iMouse.y/iResolution.y);\n    // Let's hope division by power of 2 is exact.\n    fragCoord = floor(fragCoord/float(N));\n   \tint x = int(fragCoord.x);\n   \tint y = int(fragCoord.y);\n    int i = max(abs(x), abs(y)); // Ring index\n    int w0 = W(i-1); // Ring below width\n    int w1 = W(i); // Ring current width\n    int h = w1/2;\n    int A = w0*w0;\n    \n    int v = sign(y) == -1 && y == -h && x > -h ? 3 : (sign(x) == 1 && x == h ? 0 : (sign(y) == 1 && y == h ? 1 : 2));  \n\n    int j;\n    \n    switch (v)\n    {\n        case 0:\n        j = y + h+2;\n        break;\n        \n        case 1:\n        j = -x + (h+1);\n        break;\n        \n        case 2:\n        j = -y + (h);\n        break;\n        \n        case 3:\n        j = x + (h-1);\n        break;\n    }\n    // Original is off by 2!\n    int n = A + v*w1 + j * int(i != 0) - 2;\n    \n    //float S = float(W(int(N)) * W(int(N)));\n    //float al = (float(n)) / S;\n    vec3 col = vec3(0);\n    if (n < iFrame || iMouse.z > 0.0) {\n      col = semiprime(n)?vec3(1):vec3(0);\n      if (iMouse.z > 0.0 && iMouse.x > 0.5*iResolution.x) col = 1.0-col;\n      if (n == 2021 && fract(iTime) < 0.5) col = vec3(1,0,0);\n    }\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[553, 603, 617, 617, 649], [651, 678, 692, 692, 708], [710, 710, 733, 733, 1022], [1024, 1024, 1081, 1081, 2353]], "test": "untested"}
{"id": "ttcyRj", "name": "3D Terrain Explorer", "author": "oneshade", "description": "Have fun exploring!\nControls:\nMouse to rotate\nArrow keys to move", "tags": ["3d", "terrain", "explore"], "likes": 4, "viewed": 187, "published": 3, "date": "1609457015", "time_retrieved": "2024-07-30T19:48:10.432675", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 bl = texelFetch(iChannel0, iFragCoord, 0);\n    vec4 br = texelFetch(iChannel0, iFragCoord + ivec2(1, 0), 0);\n    vec4 tl = texelFetch(iChannel0, iFragCoord + ivec2(0, 1), 0);\n    vec4 tr = texelFetch(iChannel0, iFragCoord + 1, 0);\n    fragColor = (bl + br + tl + tr) * 0.25;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Math constants:\nconst float TWO_PI = 6.2832;\n\n// Amount by which the camera moves and rotates:\nconst float STEP_SIZE      = 0.05;\nconst float ROTATION_SPEED = 0.5;\n\n// Addresses to viewing data:\nconst ivec2 VIEW_POS = ivec2(0, 0);\nconst ivec2 VIEW_DIR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n#define fetch(buf, addr) texelFetch(buf, addr, 0).xyz\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, -50.0, 1.0);\n    if (iFrame > 0) {\n        ivec2 address = ivec2(fragCoord);\n        if (address == VIEW_POS) {\n            fragColor = vec4(fetch(iChannel0, VIEW_POS), 1.0);\n            mat3 camera = getCamera(fetch(iChannel0, VIEW_DIR).xy);\n \n            if (bool(fetch(iChannel1, ivec2(KEY_UP, 0)).x)) {\n                fragColor.xz += camera[2].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_DOWN, 0)).x)) {\n                fragColor.xz -= camera[2].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_RIGHT, 0)).x)) {\n                fragColor.xz += camera[0].xz * STEP_SIZE;\n            }\n\n            if (bool(fetch(iChannel1, ivec2(KEY_LEFT, 0)).x)) {\n                fragColor.xz -= camera[0].xz * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIR) {\n            float viewDirection = (iMouse.x - 0.5 * iResolution.x) / iResolution.x * TWO_PI * ROTATION_SPEED;\n            fragColor = vec4(viewDirection, 0.0, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Hash from \"Hash without Sine\" by Dav_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat noise(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = noise(cell);\n    float br = noise(cell + vec2(1.0, 0.0));\n    float tl = noise(cell + vec2(0.0, 1.0));\n    float tr = noise(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat fnoise(in vec2 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return p.y - fnoise(p.xz, 1.0, 10.0);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = fetch(iChannel0, VIEW_POS);\n    mat3 camera = getCamera(fetch(iChannel0, VIEW_DIR).xy);\n    vec3 rd = normalize(camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n    ro.y += 0.1 + fnoise(ro.xz, 1.0, 3.0);\n\n    float t = 0.0;\n    for (int iter=0; iter < 100; iter++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001 * (t + 1.0)) { // Accelerated raymarching technique from jarble\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            vec3 low = vec3(0.0, 1.0, 0.0);\n            vec3 middle = vec3(0.6, 0.4, 0.0);\n            vec3 high = vec3(1.0, 1.0, 1.0);\n\n            vec3 material = mix(low, middle, p.y * 2.0);\n            if (p.y > 0.5) {\n                material = mix(middle, high, p.y * 2.0 - 1.0);\n            }\n\n            fragColor.rgb += material * max(0.0, dot(n, l));\n\n            break;\n        }\n\n        if (t > 30.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 382]], "test": "untested"}
