{"id": "dsKBWd", "name": "Shrimple Anti-aliased circle", "author": "OwenTheProgrammer", "description": "This took wayy to long to get correct, but this is an anti-derivative / integral solve for an anti aliased circle given w as some fwidth / ddx ddy, and a radius.", "tags": ["antialiasing", "pain", "suffering"], "likes": 1, "viewed": 261, "published": 3, "date": "1698786420", "time_retrieved": "2024-07-30T17:24:53.581016", "image_code": "#define SHOW_INTEGRAL 0\n\n\n//The derivative of the domain in the range A-B IS the\n//colour of the pixel, so when you form a pixel colour\n//over a larger area, you're basically solving the integrated\n//area gradient over that pixel space dxdy.\nfloat F(float radius, float dist) {\n    return radius - abs(radius - dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Centered uv set\n    vec2 uv = (-0.5 * iResolution.xy + fragCoord);\n    uv /= iResolution.y;\n    \n    //The pixel domain width, could also specify a pixel width\n    float w = max(abs(dFdx(uv.x)), abs(dFdy(uv.y))) * 2.0;\n    //The radius in UV space of the circle\n    float radius = 0.2 * sin(iTime * 0.1) + 0.2;\n    \n    //Integrating a line across the euclidean distance from the center\n    float x = length(uv);\n    \n    //Calculate domain across A->B w.r.t the euclidean distance\n    //May not need to /2 but I cant remember\n    float A = x - w * 0.5;\n    float B = x + w * 0.5;\n    \n    //Fundamental theorem of calculus F'(x+dx)-F'(x-dx) / dx\n#if !SHOW_INTEGRAL\n    float dom = (F(radius, B) - F(radius, A)) / w;\n#else\n    //2x just to illustrate the magnitude changing better\n    float dom = 2.0 * F(radius, x);\n#endif\n    fragColor = vec4(dom);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 242, 277, 277, 319], [321, 321, 376, 398, 1235]], "test": "untested"}
{"id": "mdKBWd", "name": "Rainbow DNA", "author": "bartus131313", "description": "Rainbow DNA", "tags": ["rainbow", "dna"], "likes": 12, "viewed": 306, "published": 3, "date": "1698786007", "time_retrieved": "2024-07-30T17:24:54.423763", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rColor = vec3(0.9, 0.0, 0.3);\n    vec3 gColor = vec3(0.0, 0.9, 0.3);\n    vec3 bColor = vec3(0.0, 0.3, 0.9);\n    vec3 yColor = vec3(0.9, 0.9, 0.3);\n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy);\n    p /= min(iResolution.x, iResolution.y);\n    \n    float a = sin(p.y * 1.5 - iTime * 0.1) / 1.0;\n    float b = cos(p.y * 1.5 - iTime * 0.2) / 1.0;\n    float c = sin(p.y * 1.5 - iTime * 0.3 + 3.14) / 1.0;\n    float d = cos(p.y * 1.5 - iTime * 0.5 + 3.14) / 1.0;\n    \n    float e = 0.1 / abs(p.x + a);\n    float f = 0.1 / abs(p.x + b);\n    float g = 0.1 / abs(p.x + c);\n    float h = 0.1 / abs(p.x + d);\n    \n    vec3 destColor = rColor * e + gColor * f + bColor * g + yColor * h;\n    fragColor = vec4(destColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 791]], "test": "untested"}
{"id": "ddVfDt", "name": "Solace In Structure / Max Cooper", "author": "morisil", "description": "Another experiment with music of Max Cooper", "tags": ["fft", "audio", "piano", "audioreactive"], "likes": 17, "viewed": 604, "published": 3, "date": "1698785316", "time_retrieved": "2024-07-30T17:24:55.230606", "image_code": "// Fork of \"espial by Oliver Buckland, std 3\" by morisil. https://shadertoy.com/view/dsKfDt\n// 2023-10-31 20:47:38\n\n// Fork of \"Cuisse\" by morisil. https://shadertoy.com/view/mdVBDt\n// 2023-10-31 20:26:14\n\n// Fork of \"Julie's Dunes study + noise\" by morisil. https://shadertoy.com/view/md3Sz4\n// 2023-10-31 20:10:04\n\n// Fork of \"Julie's Dunes study\" by morisil. https://shadertoy.com/view/dllSWj\n// 2023-03-21 23:14:02\n\n// NOTE: audio on shadertoy works only if you interact ith the\n// webpage while AudioContext is being created and then SoundCloud\n// track is autoplayed. This visual does not exist without sound,\n// pleese keep it in mind if you see a black screen. In such a case\n// you can reload the page while interacting with it.\n\n// Copyright Kazimierz Pogoda, 2023 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Max Cooper\n\n// See also Generative Art Deco 4:\n// https://www.shadertoy.com/view/mds3DX\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 7.;\nconst float INITIAL_LUMA = .6;\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y) + sin(iTime * .08) * 9.0;\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, sin(dist * 3.0) * .5 + .5);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 feedback = texture(iChannel0, uv);\n    float blur = .4 + sin(iTime * .52) * .2;\n\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec2 origSt = st;\n\n    st -= (feedback.r + feedback.g + feedback.b) * st * .3;\n\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    \n    st *= log(length(st * .428)) * 1.3;\n\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13)) * 1.5;\n        float fft = texture(iChannel0, vec2(length(center), .25)).r;\n        \n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * 1.2;\n        st *= rotate2d(sin(iTime  * .05) * 1.33);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        luma *= .6;\n        blur *= .63;\n    }\n\n    float origDist = length(origSt);\n    float zucconiDomain = ZUCCONI_OFFSET - origDist;\n    vec3 audioColor = spectral_zucconi6(zucconiDomain) * feedback.a * .4;\n    color *= feedback.rgb;\n    color += audioColor;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float spatializeAudio(in float dist) {\n    float fftDomain = pow(dist, 2.0);\n    float fft = texture(iChannel1, vec2(fftDomain * .09, .25)).r;\n    fft = pow(fft, 4.0);\n    return fft;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2. * fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    float dist = length(st);\n    \n    float audioSignal = spatializeAudio(dist);\n    float zucconiDomain = ZUCCONI_OFFSET - dist;    \n    vec3 color = spectral_zucconi6(zucconiDomain) * audioSignal * .2;\n    //float rotationDomain = (color.r + color.g + color.b) * 1.0;\n    //vec2 stShift = vec2(color.r - .005, color.g - .005) * vec2(sin(rotationDomain), cos(rotationDomain));\n    //stShift *= st * .5;\n    \n    vec3 mixedColor = texture(iChannel0, fragCoord / iResolution.xy - st * 0.09\n                             * iResolution.y / iResolution.xy\n                              //,.99\n                             ).rgb;\n    float angle = atan(st.x, st.y);\n\n    float noiseScale = 1.0 + sin(iTime) * .3;\n\n    vec2 offset = uv //+ vec2((mixedColor.g - .5) * 0.01, (mixedColor.r - .5) * 0.01) \n    \n    + (vec2(\n        snoise(vec3(st * noiseScale, iTime * .3)),\n        snoise(vec3(st * noiseScale+ vec2(1000.0), iTime * .3))\n     ) - .5) * .04;\n    //* vec2(sin(angle * 1.0 + iTime * .5), cos(angle * 1.0 + iTime * .7));\n\n    //vec3 prevColor = texture(iChannel0, uv - stShift).rgb;\n    vec3 prevColor = texture(iChannel0, offset).rgb;\n    color += prevColor * 0.95;\n    //vec3 color = prevColor * 0. + spectral_zucconi6(dist * 1.3 - .3) * audioSignal * 2.0;\n\n    fragColor = vec4(color, audioSignal);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35146, "src": "https://soundcloud.com/max-cooper/solace-in-structure", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "const float ZUCCONI_OFFSET = 1.05;\n\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (in float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (in vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (in vec3 x, in vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (in float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (in float x)\n{\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n// 2D Version: https://www.shadertoy.com/view/4sdGD8\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVfDt.jpg", "access": "api", "license": "proprietary-license", "functions": [[1668, 1668, 1739, 1739, 2021], [2023, 2023, 2078, 2078, 3569]], "test": "untested"}
{"id": "dsKfDt", "name": "espial by Oliver Buckland, std 3", "author": "morisil", "description": "Another experiment with music of Oliver Buckland", "tags": ["fft", "audio", "piano", "audioreactive"], "likes": 9, "viewed": 310, "published": 3, "date": "1698784138", "time_retrieved": "2024-07-30T17:24:56.319693", "image_code": "// Fork of \"Cuisse\" by morisil. https://shadertoy.com/view/mdVBDt\n// 2023-10-31 20:26:14\n\n// Fork of \"Julie's Dunes study + noise\" by morisil. https://shadertoy.com/view/md3Sz4\n// 2023-10-31 20:10:04\n\n// Fork of \"Julie's Dunes study\" by morisil. https://shadertoy.com/view/dllSWj\n// 2023-03-21 23:14:02\n\n// NOTE: audio on shadertoy works only if you interact ith the\n// webpage while AudioContext is being created and then SoundCloud\n// track is autoplayed. This visual does not exist without sound,\n// pleese keep it in mind if you see a black screen. In such a case\n// you can reload the page while interacting with it.\n\n// Copyright Kazimierz Pogoda, 2023 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Oliver Buckland\n\n// See also Generative Art Deco 4:\n// https://www.shadertoy.com/view/mds3DX\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 7.;\nconst float INITIAL_LUMA = .6;\n\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y) + sin(iTime * .08) * 9.0;\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, sin(dist * 3.0) * .5 + .5);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 feedback = texture(iChannel0, uv);\n    float blur = .4 + sin(iTime * .52) * .2;\n\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec2 origSt = st;\n\n    st -= (feedback.r + feedback.g + feedback.b) * st * .3;\n\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    \n    st *= log(length(st * .428)) * 1.3;\n\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13)) * 1.5;\n        float fft = texture(iChannel0, vec2(length(center), .25)).r;\n        \n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * 1.2;\n        st *= rotate2d(sin(iTime  * .05) * 1.33);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        luma *= .6;\n        blur *= .63;\n    }\n\n    float origDist = length(origSt);\n    float zucconiDomain = ZUCCONI_OFFSET - origDist;\n    vec3 audioColor = spectral_zucconi6(zucconiDomain) * feedback.a * .6;\n    color *= feedback.rgb;\n    color += audioColor;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float spatializeAudio(in float dist) {\n    float fftDomain = pow(dist, 2.0);\n    float fft = texture(iChannel1, vec2(fftDomain * .09, .25)).r;\n    fft = pow(fft, 4.0);\n    return fft;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st =\n        (2. * fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    float dist = length(st);\n    \n    float audioSignal = spatializeAudio(dist);\n    float zucconiDomain = ZUCCONI_OFFSET - dist;    \n    vec3 color = spectral_zucconi6(zucconiDomain) * audioSignal * .2;\n    //float rotationDomain = (color.r + color.g + color.b) * 1.0;\n    //vec2 stShift = vec2(color.r - .005, color.g - .005) * vec2(sin(rotationDomain), cos(rotationDomain));\n    //stShift *= st * .5;\n    \n    vec3 mixedColor = texture(iChannel0, fragCoord / iResolution.xy - st * 0.09\n                             * iResolution.y / iResolution.xy\n                              //,.99\n                             ).rgb;\n    float angle = atan(st.x, st.y);\n\n    float noiseScale = 1.0;\n\n    vec2 offset = uv //+ vec2((mixedColor.g - .5) * 0.01, (mixedColor.r - .5) * 0.01) \n    \n    + (vec2(\n        snoise(vec3(st * noiseScale, iTime * .3)),\n        snoise(vec3(st * noiseScale+ vec2(1000.0), iTime * .3))\n     ) - .5) * .04;\n    //* vec2(sin(angle * 1.0 + iTime * .5), cos(angle * 1.0 + iTime * .7));\n\n    //vec3 prevColor = texture(iChannel0, uv - stShift).rgb;\n    vec3 prevColor = texture(iChannel0, offset).rgb;\n    color += prevColor * 0.96;\n    //vec3 color = prevColor * 0. + spectral_zucconi6(dist * 1.3 - .3) * audioSignal * 2.0;\n\n    fragColor = vec4(color, audioSignal);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35145, "src": "https://soundcloud.com/oliver-buckland/espial", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "const float ZUCCONI_OFFSET = 1.05;\n\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (in float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (in vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (in vec3 x, in vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (in float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (in float x)\n{\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n// 2D Version: https://www.shadertoy.com/view/4sdGD8\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return .5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKfDt.jpg", "access": "api", "license": "proprietary-license", "functions": [[1557, 1557, 1628, 1628, 1910], [1912, 1912, 1967, 1967, 3458]], "test": "untested"}
{"id": "csdfWS", "name": "Draft tests", "author": "tristanantonsen", "description": "Purple = Original; Pink = Pre-compensated; Black = Final", "tags": ["sdf"], "likes": 0, "viewed": 141, "published": 3, "date": "1698772454", "time_retrieved": "2024-07-30T17:25:00.240211", "image_code": "float circle(vec2 p, vec2 c, float r) {\n    return length(p-c) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( vec2 p, vec2 b, vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\n// straight\nfloat ramp(float t, float inMin, float inMax, float outMin, float outMax) {\n\n    return clamp(mix(outMin, outMax, t), inMin, inMax);\n\n}\n\nfloat map(vec2 p) {\n\n    float l = 0.001;\n    \n    float b1 = sdRoundedBox(p+vec2(0.2, 0.), vec2(.15,.25), vec4(0., 0., 0.1, 0.));\n    float b2 = sdRoundedBox(p-vec2(0.2, 0.), vec2(.15,.25), vec4(0.025, 0., 0., 0.));\n    float b3 = sdRoundedBox(p-vec2(0., 0.), vec2(.3,.1), vec4(0.));\n    \n    float res = opSmoothUnion(b1, b2, 0.);\n    res = opSmoothUnion(res, b3, 0.);\n    \n    return res;\n    \n}\n\nvec2 Gradient(vec2 p) {\n\n    float epsilon = 0.0001;\n    vec2 dx = vec2(epsilon, 0.);\n    vec2 dy = vec2(0., epsilon);\n\n    float ddx = map(p + dx) - map(p - dx);\n    float ddy = map(p + dy) - map(p - dy);\n    \n    return vec2(ddx, ddy);\n\n}\n\nvec2 unitGradient(vec2 p) {\n\n    float epsilon = 0.0001;\n    vec2 dx = vec2(epsilon, 0.);\n    vec2 dy = vec2(0., epsilon);\n\n    float ddx = map(p + dx) - map(p - dx);\n    float ddy = map(p + dy) - map(p - dy);\n    \n    return normalize(vec2(ddx, ddy));\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y / 2.0;\n    \n    \n    vec3 col1 = vec3(255., 255.,255.) / 255.;\n    vec3 col2 = vec3(180.) / 255.;\n    \n    float d = map(uv);\n    vec2 g0 = unitGradient(uv);\n    \n    // pre-compensation\n    vec2 pRComp = vec2(uv.x, uv.y - 0.03 * sign(g0.y));\n    float dComp = map(pRComp);\n    \n    // gradient\n    vec2 g = Gradient(pRComp);\n    vec2 ug = normalize(g); // unit gradient of pre-compensated shape\n    vec3 gradColor = vec3(ug.x, ug.y, 1.0);\n\n    // modifying field\n    \n    float dMax = 0.1;\n    float mag = ramp(abs(uv.y), 0., 1., 0., dMax);\n    \n    // applying draft\n    vec2 pRemap = vec2(uv.x + mag * ug.x, uv.y);\n    float final = map(pRemap);\n    \n    \n    vec4 solidColor = vec4(vec3(0.15), 1.0);\n    \n    float f = 1.5;\n    final *= 255.;\n    float ripple = 0.5 * sin(f * final - 0.5 * iTime) + 0.49;\n    \n    \n    // background\n    vec4 backgroundColor;\n    backgroundColor = vec4(mix(col1, col2, smoothstep(0.9, 1., ripple)), 1.0);        \n    \n    // Show gradient\n    //backgroundColor = vec4(mix(gradColor, col2, smoothstep(0.9, 1., ripple)), 1.0);        \n    \n    // translucent original shape\n    backgroundColor = mix(backgroundColor, backgroundColor * vec4(0.55, 1., 0.8, 1.), smoothstep(1.0,0.0,d * 255.));\n    \n    // translucent compensated shape\n    backgroundColor = mix(backgroundColor, backgroundColor * vec4(1., 0.5, 0.8, 1.), smoothstep(1.0,0.0,dComp * 255.));\n    \n    // solid final shape\n    fragColor = mix(solidColor, backgroundColor, smoothstep(0.0,1.0,final * 255.) );\n    \n    // line @ y = 0\n    fragColor = mix(solidColor, fragColor, smoothstep(0.0,1.,1000. * (abs(uv.y)-0.001)) );\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 69], [71, 123, 169, 169, 326], [328, 328, 379, 379, 687], [689, 689, 741, 741, 860], [862, 862, 914, 914, 1013], [1019, 1019, 1062, 1062, 1084], [1087, 1099, 1174, 1174, 1234], [1236, 1236, 1255, 1255, 1634], [1636, 1636, 1659, 1659, 1876], [1878, 1878, 1905, 1905, 2133], [2136, 2136, 2193, 2243, 3994]], "test": "untested"}
{"id": "csKfDt", "name": "Soul of Sarah II", "author": "ElSolem", "description": "https://www.shadertoy.com/view/dsyfWt\nxy = p.x / p.y :: secret sauce\nhttps://www.shadertoy.com/view/msGBDt", "tags": ["shapes", "figures"], "likes": 2, "viewed": 72, "published": 3, "date": "1698771641", "time_retrieved": "2024-07-30T17:25:01.447982", "image_code": "vec3 pal( in float t)\n{\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,0.0);\n    vec3 d = vec3(0.5,0.20,0.25);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\nvec2 normalizedCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\nfor(float i = 0.0; i< 19.0; i+=1.0){\n normalizedCoord =abs(normalizedCoord );\n normalizedCoord -=0.6;\n  normalizedCoord *=1.3;\n  normalizedCoord *= mat2(\n  cos(0.2),-sin(0.2),\n  sin(0.2),cos(0.2)\n  );\n}\n    normalizedCoord *= mat2(\n sin(0.3),cos(0.3),\n  cos(0.3),sin(0.3)\n  );\n    fragColor = vec4(0,length(normalizedCoord),length(normalizedCoord),1.0);\n    }\n    else\n    {\nfloat angle = iTime*0.01;\nvec2 normalizedCoord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\nfor(float i = 0.0; i< 19.0; i+=1.0){\n normalizedCoord =abs(normalizedCoord );\n normalizedCoord -=0.6;\n  normalizedCoord *=1.3;\n  normalizedCoord *= mat2(\n  cos(angle),-sin(angle),\n  sin(angle),cos(angle)\n  );\n}\n\n    fragColor = vec4(length(normalizedCoord+vec2(-.5,-0.7)),length(normalizedCoord+vec2(0.2,-0.3)),length(normalizedCoord+vec2(-0.4,-0.1)),1.0);\n}\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 194], [196, 196, 253, 318, 1652]], "test": "untested"}
{"id": "DsVBDt", "name": "Change the point of view", "author": "IWBTShyGuy", "description": "Change your point of view, and you will see things differently.", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 133, "published": 3, "date": "1698769966", "time_retrieved": "2024-07-30T17:25:02.598905", "image_code": "// Change your point of view, and you will see things differently.\n// ref: https://www.shadertoy.com/view/mlSyRz\n\n// The MIT License\n// Copyright © 2023 IWBTShyGuy\n\n// regular N-gon, if you want circle, let N = 0\nconst int N0 = 5;\nconst int N1 = 6;\n\nconst float ANGLE = PI / 4.0;\nconst float THICKNESS = 0.01;\n\nvec2 feetRegularPolygon(in vec2 p, in int n, in float r) {\n    vec2 h;\n    float dist = 10.0 * r;\n    for (int i = 0; i < n; i++) {\n        float t0 = 2.0 * PI * float(i) / float(n),\n        t1 = 2.0 * PI * float(i + 1) / float(n);\n        vec2 a = vec2(-sin(t0), cos(t0)) * r,\n        b = vec2(-sin(t1), cos(t1)) * r,\n        ab = b - a, ap = p - a,\n        hab = ap - clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0) * ab;\n        float dist0 = length(hab);\n        if (dist0 < dist) {\n            dist = dist0;\n            h = hab;\n        }\n    }\n    return p + h;\n}\n\nvec2 feetCircle(in vec2 p, in float r) {\n    if (length(p) == 0.0) return vec2(0, r);\n    else return r * normalize(p);\n}\n\nvec2 feet0(in vec2 p) {\n    if (N0 == 0) return feetCircle(p, 0.5);\n    return feetRegularPolygon(p, N0, 0.5);\n}\n\nvec2 feet1(in vec2 p) {\n    if (N1 == 0) return feetCircle(p, 0.5);\n    return feetRegularPolygon(p, N1, 0.5);\n}\n\nfloat sDistCone0(in vec3 p) {\n    Camera cam = Camera(\n        vec3(0, 0, -1),\n        vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        ANGLE,\n        1.0\n    );\n    vec2 uv = 2.0 * screenUV(cam, p) - 1.0,\n    h = feet0(uv);\n    float signum = sign(distance(uv, h) - THICKNESS / 2.0);\n    h = h + normalize(uv - h) * THICKNESS / 2.0;\n    Ray ray = cameraRay(cam, (h + 1.0) / 2.0);\n    vec3 op = p - ray.origin;\n    return signum * length(op - dot(op, ray.direction) * ray.direction);\n}\n\nfloat sDistCone1(in vec3 p) {\n    Camera cam = Camera(\n        vec3(0, 0, 1),\n        vec3(0, 0, -1),\n        vec3(0, 1, 0),\n        ANGLE,\n        1.0\n    );\n    vec2 uv = 2.0 * screenUV(cam, p) - 1.0,\n    h = feet1(uv);\n    float signum = sign(distance(uv, h) - THICKNESS / 2.0);\n    h = h + normalize(uv - h) * THICKNESS / 2.0;\n    Ray ray = cameraRay(cam, (h + 1.0) / 2.0);\n    vec3 op = p - ray.origin;\n    return signum * length(op - dot(op, ray.direction) * ray.direction);\n}\n\nfloat sDist(in vec3 p) {\n    float dist0 = max(-0.5 - p.z, sDistCone0(p));\n    float dist1 = max(p.z - 0.5, sDistCone1(p));\n    return max(dist0, dist1);\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(1.e-4,0);\n    return normalize(vec3(\n        sDist(p + e.xyy) - sDist(p - e.xyy),\n        sDist(p + e.yxy) - sDist(p - e.yxy),\n        sDist(p + e.yyx) - sDist(p - e.yyx)\n    ));\n}\n\nvec3 color(vec3 p, vec3 normal, vec3 dir) {\n    return vec3(-dot(dir, normal));\n}\n\nvoid mainImage0(out vec4 O, in vec2 U) {\n    vec2 r = iResolution.xy;\n    float t = mod(iTime, 4.0 * PI);\n    if (t < 2.0 * PI) t = max(t - PI, 0.0);\n    else t = PI + max(t - 3.0 * PI, 0.0);\n    vec3 camPos = vec3(sin(t), 0.6 * sin(t), cos(t));\n    Camera cam = Camera(\n        camPos,\n        -normalize(camPos),\n        vec3(0,1,0),\n        PI / 6.0,\n        r.x / r.y\n    );\n    Ray ray = cameraRay(cam, U / r);\n    vec3 ro = ray.origin, rd = ray.direction, p;\n\n    float dist = 0.0, dist0;\n    const float MAX_DIST = 2.;\n    for(int i = 0; i++ < 255\n        && (dist0 = sDist(p = ro + dist * rd)) > 1.0e-5\n        && (dist += dist0) < MAX_DIST;); \n    \n    vec3 col = vec3(0);\n    if (dist < MAX_DIST) col = color(p, calcNormal(p), rd);\n    \n    O = vec4(col, min(dist, MAX_DIST));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, Activate AA, level: 2 or 3\n#define AA 2\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if ( fwidth(length(O.w)) > 0.1) {\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += o;\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n    }\n#endif\n\n    O.xyz = pow(O.xyz, vec3(.4545));\n    O.w = 1.0;\n}\n", "image_inputs": [], "common_code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\nvec2 screenUV(in Camera camera, in vec3 p) {\n    vec3 op = p - camera.position;\n    float r = dot(op, camera.direction);\n    float v_unit = r * tan(camera.fov * 0.5);\n    float u_unit = v_unit * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec2 xy = vec2(\n        dot(op, right) / u_unit,\n        dot(op, up) / v_unit\n    );\n    return (1.0 + xy) * 0.5;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVBDt.jpg", "access": "api", "license": "mit", "functions": [[312, 312, 370, 370, 876], [878, 878, 918, 918, 999], [1001, 1001, 1024, 1024, 1113], [1115, 1115, 1138, 1138, 1227], [1229, 1229, 1258, 1258, 1711], [1713, 1713, 1742, 1742, 2195], [2197, 2197, 2221, 2221, 2352], [2354, 2354, 2379, 2379, 2584], [2586, 2586, 2629, 2629, 2667], [2669, 2669, 2709, 2709, 3457]], "test": "untested"}
{"id": "cdVBDt", "name": "Taste of the Divine II", "author": "ElSolem", "description": "Summoning Token : https://www.shadertoy.com/view/dsGBDd\nxy = p.x / p.y :: secret sauce\nhttps://cineshader.com/view/cdVBDt", "tags": ["infinity", "summoning"], "likes": 9, "viewed": 780, "published": 3, "date": "1698769319", "time_retrieved": "2024-07-30T17:25:03.622169", "image_code": "vec3 palette(float d) {\n    return mix(vec3(0.0, 3.02, 1.24), vec3(1.0, 0.01, 1.2), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    for (int i = 0; i < 66; ++i) {\n        float t = iTime * 0.006;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.0);\n        p.xz = abs(p.xz);\n        p.xz -= 0.16;\n    }\n    return dot(sign(p), p) / 6.0;\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 1.0;\n    vec3 col = vec3(0.006);\n    float d;\n    for (float i = 0.0; i < 36.0; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.98;\n        if (d < 0.07) {\n            break;\n        }\n        if (d > 22.0) {\n            break;\n        }\n        col += palette(length(p) * 0.1) / (222.0 * d);\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 20.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = uv.x / uv.y;\n\n    float threshold = 2.0;\n\n    if (abs(xy) < abs(threshold)) {\n        vec3 ro = vec3(55.0, 55.0, -13.0);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(7, 3.0, 17.0)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    } else {\n        vec3 ro = vec3(55.0, 55.0, -13.0);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(7, 3.0, 17.0)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 89], [91, 91, 121, 121, 201], [203, 203, 222, 222, 450], [452, 452, 479, 479, 862], [864, 864, 919, 919, 1869]], "test": "untested"}
{"id": "mdVczK", "name": "Mouse memory test", "author": "fingertwister", "description": "Testing ways of keeping track of mouse position history", "tags": ["development"], "likes": 2, "viewed": 134, "published": 3, "date": "1698768759", "time_retrieved": "2024-07-30T17:25:04.647428", "image_code": "// Base calculation on point - line distance: \n// \n// (p - a) - dot((p - a), n) * n\n//\n// (https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line)\n//\n// The distance can never be longer than the segment length\n// The distance can never be shorter than minDist (avoids division by zero case) \n\nfloat dist2Segment2(vec2 a, vec2 b, vec2 p, float minDist) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float lAb = max(minDist, length(ab)); // ensure minDist\n    vec2 n = ab / lAb;\n    float l = clamp(dot(ap, n), 0., lAb); // clamp to segment length\n    return length(ap - (l * n)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \tvec4 mo = texture(iChannel0,vec2(0));\n \t\n    if (mo.z > 0. && dist2Segment2(mo.zw, mo.xy, fragCoord, 1.) < 10.) {\n    //if (mo.z > 0. && ln(fragCoord, mo.xy, mo.zw) < 10.) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        // Output to screen\n        fragColor = vec4(col,1.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Store last mouse positions\n//\n// if lmb is down:\n//     xy - current xy\n//     zw - last xy (if no last xy then current xy)\n// else:\n//     xy - current xy\n//     zw - zero\n\n#define lmb (iMouse.z > 0.)\n#define previousLmb (p.z > 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(iMouse.xy, lmb \n        ? (previousLmb \n            ? p.xy \n            : iMouse.xy)\n        : vec2(0.));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[300, 300, 360, 360, 590], [592, 592, 649, 699, 1145]], "test": "untested"}
{"id": "DsKfWt", "name": "Reactive liquid", "author": "bartus131313", "description": "Mouse reactive liquid", "tags": ["mouse", "reactive", "liquid"], "likes": 4, "viewed": 155, "published": 3, "date": "1698768742", "time_retrieved": "2024-07-30T17:25:05.440308", "image_code": "uniform sampler2D u_textures[16];\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\n\t// Transform to simplex space (axis-aligned hexagonal grid)\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t// Determine which simplex we're in, with i0 being the \"base\"\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t// o1 is the offset in simplex space to the second corner\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t// Enumerate the remaining simplex corners\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t// Transform corners back to texture space\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t// Compute vectors from v to each of the simplex corners\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\n\t// Wrap to periods, if desired\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t// Transform back to simplex space and fix rounding errors\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { // Shortcut if neither x nor y periods are specified\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t// Compute one pseudo-random hash value for each corner\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t// Pick a pseudo-random angle and add the desired rotation\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t// Reorganize for dot products below\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t// Radial decay with distance from each simplex corner\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t// The value of the linear ramp from each of the corners\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t// Multiply by the radial decay and sum up the noise value\n\tfloat n = dot(w4, gdotx);\n\n\t// Compute the first order partial derivatives\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t// Scale the return value to fit nicely into the range [-1,1]\n\treturn 10.9 * n;\n}\n\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  // 1.0/SQRT_TAU\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n\n#ifndef FNC_BOUNCEIN\n#define FNC_BOUNCEIN\nfloat bounceIn(in float t) { return 1.0 - bounceOut(1.0 - t); }\n#endif\n\n#ifndef FNC_BOUNCEOUT\n#define FNC_BOUNCEOUT\nfloat bounceOut(in float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n\n    float t2 = t * t;\n\n    return t < a\n        ? 7.5625 * t2\n        : t < b\n            ? 9.075 * t2 - 9.9 * t + 3.4\n            : t < c\n                ? ca * t2 - cb * t + cc\n                : 10.8 * t * t - 20.52 * t + 10.72;\n}\n#endif\n#ifndef FNC_BOUNCEINOUT\n#define FNC_BOUNCEINOUT\nfloat bounceInOut(in float t) {\n    return t < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n#endif\n\n// type # to get code suggestions for regions\n// the regions are also foldable\n\nvec2 rot(vec2 v, float a){\n    return mat2x2(\n                cos(a), -sin(a), \n                sin(a), cos(a)\n            ) * v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv * vec2(iResolution.x / iResolution.y, 1.);\n    // @note you can tweak float and vec values\n    // try to right click on 8, choose \"Tweak Value\" (or use a shortcut)\n    st = rot(st, -PI / 8.);\n\n    // normalize mouse coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec2 gradient;\n    // @note to tweak vectors as a whole, right click on vec2/vec3/vec4, select \"Tweak Value\"\n    // 2D vectors have a convenient point tweaking, while higher order vectors are tweaked by values\n    float n = psrdnoise(vec2(3.) * st, vec2(0.), 1.2 * iTime + mouse.y * PI, gradient);\n\n    float lines = cos((st.x + n * 0.1 + mouse.x + 0.2) * PI);\n\n    fragColor = vec4(\n        mix(\n            // @note vec3 and vec4 with normalized values are recognized as colors, \n            // so you can use a color picker to tweak the values\n            vec3(0.949, 0.561, 0.576), // rgb(242, 143, 147)\n            vec3(0.494, 0.047, 0.839), // rgb(126,  12, 214)\n            // @todo try to experiment with functions. How about bounceInOut?\n            bounceIn(lines * 0.5 + 0.5)\n        ), \n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 105, 167, 2527], [5418, 5418, 5444, 5444, 5549], [5552, 5552, 5608, 5608, 6762]], "test": "untested"}
{"id": "DsyfDc", "name": "Lightness & Gamma Fundamentals", "author": "domrally", "description": "Properly managed image & display gamma corrections and accurate perceptual lightness correlate.\nOther examples aren't quite what i consider complete, so here's my mine!\nClick & Shift!\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["desaturate", "relative", "luminance", "gamma", "gray", "brightness", "grey", "visual", "uniform", "correct", "luma", "ciecam02", "lightness", "percept"], "likes": 3, "viewed": 133, "published": 3, "date": "1698764544", "time_retrieved": "2024-07-30T17:25:06.197284", "image_code": "/// by Dom Mandy in 2023\n\n\n/* Decode color from compressed to linear space.\nDo this 1st to image textures before using them.\nImages are encoded in the nonlinear srgb color space.\nThe rgb components need to be linear for filters and effects. */\nvec3 rgb(vec4 srgb) { return mix(srgb / 12.92, pow((srgb + .055) / 1.055, vec4(2.4)), step(.04045, srgb)).rgb; }\n\n\n/* Prepare the gamma for a computer monitor.\nDo this after processing and before sending to the display.\nDisplay adapters expect a nonlinear correction of 1 / 2.2 */\nvec4 gamma(vec3 rgb) { return vec4(pow(rgb, vec3(1) / 2.2), 1); }\n\n\n/* Map 3D color to 1D greyscale using CIE standards from 2002 (as opposed to the commonly used 1976 method).\nThe impact of surroundings is 59% for viewing television.\nThe average relative luminance of an image field is 20% for typically lit scenes.\nEye cone responsivities relative to srgb & rescaling for perceptually uniform lightness gradient */\nfloat lightness(vec3 rgb) { return pow(dot(rgb, vec3(.2126, .7152, .0722)), .59 * (1.48 + sqrt(.2))); }\n\n\n/* Demonstration of color management from image to display output. */\nvoid mainImage(out vec4 pixel, vec2 uv) {\n    vec4 raw = texture(iChannel0, uv /= iResolution.xy);\n\n    // almost always start by linearizing the compressed rgb texture\n    vec3 colorful = rgb(raw),\n         greyscale = vec3(lightness(colorful));\n    \n    // click to drag color|grey boundary\n    uv = round(uv + mix(.5 * sin(-iTime), .5 * (iResolution.x - 2. * iMouse.x) / iResolution.x, max(0., sign(iMouse.z))));\n    vec3 mixed = mix(\n        // correct\n        mix(colorful, greyscale, uv.x),\n        // incorrect\n        mix(raw.rgb, vec3(length(raw.rgb) / sqrt(3.)), uv.x),\n        // hold shift to see incorrect render\n        texelFetch(iChannel1, ivec2(16, 0), 0).x\n    );\n    \n    // almost always end by converting from abstract linear image to hardware scale\n    pixel = gamma(mixed);\n}\n\n\n/*\nFURTHER READING\n\ncolor modeling\n\nhttps://en.wikipedia.org/wiki/Lightness#2002\nhttps://en.wikipedia.org/wiki/SRGB#Transformation\nhttps://en.wikipedia.org/wiki/CIECAM02#Parameter_decision_table\nhttps://en.wikipedia.org/wiki/Gamma_correction#Computer_displays\nhttps://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_perceptual_spaces\nhttps://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale\n\nvisual perception\n\nhttps://en.wikipedia.org/wiki/Cone_cell\nhttps://en.wikipedia.org/wiki/Color_vision\n*/\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsyfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 244, 265, 265, 356], [359, 525, 547, 547, 590], [593, 942, 969, 969, 1045], [1048, 1118, 1159, 1159, 1916]], "test": "untested"}
{"id": "csyBDt", "name": "Circle Rectangle intersection", "author": "secs", "description": "detects if a circle intersects with a rectangle", "tags": ["collision"], "likes": 1, "viewed": 140, "published": 3, "date": "1698754556", "time_retrieved": "2024-07-30T17:25:06.944287", "image_code": "bool in_rect(vec2 center, vec2 size, vec2 coord){\n    return center.x <= coord.x && coord.x <= size.x && center.y <= coord.y && coord.y <= size.y;\n}\n\nbool in_circ(vec2 origin, float radius, vec2 coord){\n    return length(origin - coord)<=radius;\n}\n\nvec2 closest_point(vec2 origin, vec2 center, vec2 size){\n    float x = max(center.x, min(origin.x, size.x));\n    float y = max(center.y, min(origin.y, size.y));\n    return vec2 (x,y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 coord = fragCoord.xy/iResolution.xy*vec2(1920,1080);\n    \n    vec2 center = vec2(300.,300.);\n    vec2 size = center + vec2(600.,300.);\n    \n    vec2 o = iMouse.xy/iResolution.xy*vec2(1920,1080);\n    float r = 150.;\n    \n    vec2 cp = closest_point(o, center, size);\n   \n    if (in_rect(center, size, coord)){\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n    }\n    if (in_circ(o, r, coord)){\n        if (length(o - cp) <= r){\n            fragColor = vec4(1.0,0.0,0.0,0.0);\n        }\n        else{\n        fragColor = vec4(0.0,1.0,0.0,0.0);\n        }\n    }\n     if (in_circ(cp, 10., coord)){\n        fragColor = vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csyBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 148], [150, 150, 202, 202, 247], [249, 249, 305, 305, 434], [436, 436, 493, 493, 1159]], "test": "untested"}
{"id": "dsVBD3", "name": "test: is round != roundeven ?", "author": "FabriceNeyret2", "description": "are some people NOT having a black screen ?\n→ then please give OS/GPU/browser.\n\nround is often implemented as roundEven, cf https://registry.khronos.org/OpenGL-Refpages/gl4/html/round.xhtml\nif you really need round, it is advised to rather use floor(x+.5)", "tags": ["glsl", "compatibility"], "likes": 4, "viewed": 210, "published": 3, "date": "1698739880", "time_retrieved": "2024-07-30T17:25:07.700265", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = vec4( round(U) != roundEven(U) );\n // O = vec4( round(U) == floor(U+.5)  );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 124]], "test": "untested"}
{"id": "mdVfW3", "name": "Rectangle SDF with a crappy sin ", "author": "secs", "description": "SDF of a Rectangle ", "tags": ["sdf"], "likes": 4, "viewed": 113, "published": 3, "date": "1698736113", "time_retrieved": "2024-07-30T17:25:08.451257", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    vec2 b = vec2(.9,.5);\n    vec2 d = abs(uv) - b;\n    float s = length(max(d,0.0)) + length(min(max(d.x,d.y),0.0));\n    s = sin(s*100.-iTime*5.);\n    fragColor = vec4(smoothstep(-1.,1.,s/fwidth(s)));\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 385]], "test": "untested"}
{"id": "msKBDV", "name": "Sombrero Ripple Effect", "author": "secs", "description": "Ripple effect created with the sombrero function", "tags": ["ripple"], "likes": 0, "viewed": 128, "published": 3, "date": "1698733740", "time_retrieved": "2024-07-30T17:25:09.259097", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 cPos = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    float cLength = length(cPos);\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy + cos(cLength*12.0 - iTime*4.0)*0.02);\n    \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 323]], "test": "untested"}
{"id": "dsVBDK", "name": "My First Shader Made", "author": "secs", "description": "from this tutoreal https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["tutorial"], "likes": 0, "viewed": 107, "published": 3, "date": "1698733734", "time_retrieved": "2024-07-30T17:25:10.010089", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fcolor = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    vec2 uv0 = uv;\n    for (float i = 0.0; i < 3.0; i++){\n    uv = fract(uv*1.5)-0.5;\n    float d = length(uv)* exp(-length(uv0));\n    vec3 color = palette(length(uv0)+i*0.2+iTime*0.2);\n    d = sin(d*8.+iTime)/8.;\n    d = abs(d);\n    d = pow(0.01 / d, 1.2);\n    fcolor += color * d;\n    }\n    fragColor = vec4(fcolor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 209], [211, 211, 268, 268, 736]], "test": "untested"}
{"id": "DsVBWc", "name": "lightLine", "author": "zhangzhihao", "description": "一条简单的流光线条", "tags": ["line", "light"], "likes": 4, "viewed": 177, "published": 3, "date": "1698724910", "time_retrieved": "2024-07-30T17:25:10.766068", "image_code": "float squared(float value) { return value * value; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * uvTrue;\n    \n\tfloat lineIntensity;\n    float glowWidth;\n    vec3 color = vec3(0.0);\n    \n\t float Y = uv.y;\n        lineIntensity = 0.4 + squared(1.6 * abs(mod(uvTrue.x  + iTime,2.0) - 1.0));\n\t\tglowWidth = abs(lineIntensity / (150.0 * Y));\n\t\tcolor += vec3(glowWidth,\n                      glowWidth,\n                      glowWidth);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [54, 54, 111, 111, 556]], "test": "untested"}
{"id": "cdKfD3", "name": "spqr domain trick: chiaroscuro", "author": "spqr", "description": "a", "tags": ["a"], "likes": 3, "viewed": 135, "published": 3, "date": "1698722735", "time_retrieved": "2024-07-30T17:25:11.523044", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n   // return max(max(q.x,q.y),q.z);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\n\n\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float ball = box(p, vec3(f1 * .4));\n\n   \n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\nfloat map (vec3 p){\n    // geo\n    float pos = p.y+1.;\n\n    for (float i = 1.; i < 8.; i++) {\n        pos = max(pos, -field(p,pow(2.,i)/16.));\n    }\n    \n    return pos;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.0001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime;\n \n  // nav\n\n\n\n  vec3 s = vec3(0.,3.,-6);\n  vec3 t = vec3(0,-1,0);\n  \n  vec3 fwd = vec3(0,0,3) * iTime;\n  \n  s += fwd;\n  t += fwd;\n \n  s += lattice(tt)*7.;\n  t += lattice(tt+3.9)*7.;\n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <100.; ++z) {\n    i = z;\n    d=abs(map(p));\n    if(d<.01) {\n      hit = true;\n      break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n\n\n  r = reflect(n,r);\n  float factor = length(sin(r*3.))/sqrt(3.);\n  vec3 col = pow(factor,11.) * vec3(4);\n  \n\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 116, 116, 165], [167, 167, 192, 192, 667], [671, 671, 694, 694, 797], [798, 798, 821, 821, 916], [918, 918, 945, 945, 1027], [1029, 1029, 1057, 1057, 1184], [1186, 1186, 1208, 1208, 1298], [1302, 1302, 1337, 1337, 1586], [1587, 1587, 1606, 1617, 1758], [1760, 1760, 1779, 1779, 1891], [1895, 1895, 1952, 1952, 2900]], "test": "untested"}
{"id": "cdKfW3", "name": "Boxes and Rings", "author": "ElSolem", "description": "ring light: https://www.shadertoy.com/view/mtyGWy\nboxes: https://www.shadertoy.com/view/cdKBDy\nxy = p.x / p.y :: secret sauce", "tags": ["rings"], "likes": 4, "viewed": 111, "published": 3, "date": "1698715683", "time_retrieved": "2024-07-30T17:25:12.271044", "image_code": "// https://iquilezles.org/articles/palettes/\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec4 applyAlakazan(vec2 uv0) {\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv0 = fract(uv0 * 1.5) - 0.5;\n\n        float d = length(uv0) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = sin(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n\n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.0;\n\n    if (abs(xy) < abs(threshold)) {\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\n        fragColor = applyAlakazan(uv);\n    } else {\n        int i;\n        for (vec2 c = iResolution.xy, u = (roundEven(fragCoord) - c * 0.5) / c.y, p, z = p + 2e1;\n             z.x < 1e2 && (i = int(p) ^ int(p.y) ^ int(z)) % 93 % 43 < 32;\n             p = u * z + iTime * vec2(2, 9)) {\n            c = fract(-p * sign(u)) / abs(u);\n            z += min(min(c, c.yx), fract(-z)) + 2e-5;\n            fragColor.rgb = (1e2 - z.x) * (2.0 - cos(vec3(i /= 3, i + 5, i + 4)));\n        }\n\n        fragColor /= 2e2 + fwidth(fragColor.g) * 5e2;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 45, 68, 68, 260], [262, 262, 292, 292, 691], [693, 693, 748, 813, 1706]], "test": "untested"}
{"id": "msVfWV", "name": "Into the TV", "author": "ElSolem", "description": "Hash thingy", "tags": ["fractals", "hash"], "likes": 3, "viewed": 51, "published": 3, "date": "1698715374", "time_retrieved": "2024-07-30T17:25:13.204549", "image_code": "/*************************************************************************************************\n * Mark Jarzynski and Marc Olano, Hash Functions for GPU Rendering, \n * Journal of Computer Graphics Techniques (JCGT), vol. 9, no. 3, 21-38, 2020\n * Available online http://jcgt.org/published/0009/03/02/\n * \n * Each block visualized 1 bit of hash from bit 0 in the lower left to bit 31 in the upper right.\n * Some hashes do not generate data in all bits, the bits without data are black.\n * \n * For each one dimensional hash there are 2 examples, linear and nested, both have 2-dimensional\n * inputs (UV coords) and only a single output. For the three and four dimensional hashes we\n * combine x and y in different ways for z and w, though in 3D space you would ideally use z as \n * the third input. Constants are sometimes acceptable depending on the hash. For multi-byte\n * hashes only the two dimensional input varation is used an example here. The source code for\n * all of the variations can be found in the Common tab as well as in the full paper.\n * \n * Comment out the return statements in the hash() function to change the hash.\n * Comment out the #defines for BITPLANE and GRID to visualize the hash itself.\n * Comment out the #define COLOR to see the hash in grayscale (only uses x in multi-dimentionsal hashes)\n * \n */\n\n#define BITPLANE\t// Visualize the bitplanes\n#define ANIMATE\t\t// Animate the bits\n#define COLOR\t    // Visualize 3D COLOR\n#define GRID\t\t// Display a grid to seperate the bitplanes\n\nuvec3 hash(vec2 s)\n{\t\n    /*\tUncomment the hash you want to visualize.\n\n\t\tNote that most of these examples the hash is only given 2 inputs unless the hash requires more.\n\t\tBut Common includes 1 through 4 input variations of the hash if they exist.\n\n\t\tYou should play around with different seeds/different number of inputs.\n\t\t\n\t\tAvailable hashes:\n\t\n\t\tbbs, city, esgtsa, fast, hashwithoutsine, hybridtaus, \n\t\tign, iqint1, iqint2, iqint3, jkiss32, lcg, md5, murmur3,\n\t\tpcg, pcg2d, pcg3d, pcg3d16, pcg4d, pseudo, ranlim32,\n\t\tsuperfast, tea2, tea3, tea4, tea5, trig, wang,\n\t\txorshift128, xorshift32, xxhash32\n\t*/    \n    \n    uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y)); // Play with different values for 3rd and 4th params. Some hashes are okay with constants, most aren't.\n    \n    //return uvec3(bbs(seed(u.xy)));\n\t//return uvec3(bbs(bbs(u.x) + u.y));\n    //return uvec3(city(u.xy));\n    //return uvec3(esgtsa(seed(u.xy)));\n    //return uvec3(esgtsa(esgtsa(u.x) + u.y));\n    //return uvec3(fast(s) * float(0xffffffffu));\n    //return uvec3(hashwithoutsine32(s) * float(0xffffffffu));\n    //return uvec3(hybridtaus(u));\n    //return uvec3(ign(s) * float(0xffffffffu));\n    //return uvec3(iqint1(seed(u.xy)));\n    //return uvec3(iqint1(iqint1(u.x) + u.y));\n    //return iqint2(u.xyz);\n    //return uvec3(iqint3(u.xy));\n    //return uvec3(jkiss32(u.xy));\n    //return uvec3(lcg(seed(u.xy)));\n    //return uvec3(lcg(lcg(u.x) + u.y));\n    //return md5(u).xyz;\n    //return uvec3(murmur3(u.xy));\n    //return uvec3(pcg(seed(u.xy)));\n    //return uvec3(pcg(pcg(u.x) + u.y));\n    //return uvec3(pcg2d(u.xy), 0u);\n    return pcg3d(u.xyz);\n    //return pcg3d16(u.xyz);\n    //return pcg4d(u).xyz;\n    //return uvec3(pseudo(s) * float(0xffffffffu));\n    //return uvec3(ranlim32(seed(u.xy)));\n    //return uvec3(ranlim32(ranlim32(u.x) + u.y));\n    //return uvec3(superfast(seed(u.xy)));\n    //return uvec3(superfast(superfast(u.x) + u.y));\n    //return uvec3(tea(2, u.xy), 0u);\n    //return uvec3(tea(3, u.xy), 0u);\n    //return uvec3(tea(4, u.xy), 0u);\n    //return uvec3(tea(5, u.xy), 0u);\n    //return uvec3(trig(s) * float(0xffffffffu));\n    //return uvec3(wang(seed(u.xy)));\n    //return uvec3(wang(wang(u.x) + u.y));\n    //return uvec3(xorshift128(u));\n    //return uvec3(xorshift32(seed(u.xy)));\n    //return uvec3(xorshift32(xorshift32(u.x) + u.y));\n    //return uvec3(xxhash32(u.xy)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.; // Adjust this value as needed // air: 1.0, water: 1.33, glass: 1.5, diamond: 2.4\n\n    // Check if xy is within the threshold to plot the point\n    if (abs(xy) < abs(threshold))\n    {\n            // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    }\n    else\n    {\n    // Thanks to \"hash: visualising bitplanes\" by hornet https://www.shadertoy.com/view/lt2yDm\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uint bit = uint(8.0 * uv.x) + 8u * uint(4.0 * uv.y);\n\n#ifdef BITPLANE\n    vec2 seed = mod(fragCoord, vec2(iResolution.x/8.0, iResolution.y/4.0));\n#else\n    vec2 seed = fragCoord;\n#endif\n    \n#ifdef ANIMATE\n    seed += 100.0 * iTime;\n#endif\n    \n    uvec3 hash = hash(seed);\n    \n#ifdef BITPLANE\n#ifdef COLOR\n    fragColor = vec4((hash >> bit) & 1u, 1.0);\n#else\n    fragColor = vec4(vec3(float((hash >> bit) & 1u)), 1.0);\n#endif\n#else\n#ifdef COLOR\n    fragColor = vec4(vec3(hash) * (1.0/float(0xffffffffu)), 1.0);\n#else\n    fragColor = vec4(vec3(float(hash) * (1.0/float(0xffffffffu))), 1.0);\n#endif\n#endif\n    \n#ifdef GRID\n    fragColor *= step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor *= step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n#endif\n    }\n}\n\n// https://www.shadertoy.com/view/dsVBRd - Set as default cause if you aren't careful it can turn into flash\n\n// Needed to test this further so used the shader from this link\n// and this one\n// https://www.shadertoy.com/view/Mdt3Df\n\n// You can put any? into the if-else blocks. If you change the origin from 0 to any number the view because bigger/wider\n\n// https://www.shadertoy.com/view/dsyBDy - double mod by Xor", "image_inputs": [], "common_code": "// commonly used constants\n#define c1 0xcc9e2d51u\n#define c2 0x1b873593u\n\n// Helper Functions\nuint rotl(uint x, uint r)\n{\n\treturn (x << r) | (x >> (32u - r));\n}\n\nuint rotr(uint x, uint r)\n{\n\treturn (x >> r) | (x << (32u - r));\n}\n\nuint fmix(uint h)\n{\n    h ^= h >> 16;\n    h *= 0x85ebca6bu;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35u;\n    h ^= h >> 16;\n    return h;\n}\n\nuint mur(uint a, uint h) {\n    // Helper from Murmur3 for combining two 32-bit values.\n    a *= c1;\n    a = rotr(a, 17u);\n    a *= c2;\n    h ^= a;\n    h = rotr(h, 19u);\n    return h * 5u + 0xe6546b64u;\n}\n\nuint bswap32(uint x) {\n    return (((x & 0x000000ffu) << 24) |\n            ((x & 0x0000ff00u) <<  8) |\n            ((x & 0x00ff0000u) >>  8) |\n            ((x & 0xff000000u) >> 24));\n}\n\nuint taus(uint z, int s1, int s2, int s3, uint m)\n{\n\tuint b = (((z << s1) ^ z) >> s2);\n    return (((z & m) << s3) ^ b);\n}\n\n\n\n// convert 2D seed to 1D\n// 2 imad\nuint seed(uvec2 p) {\n    return 19u * p.x + 47u * p.y + 101u;\n}\n\n// convert 3D seed to 1D\nuint seed(uvec3 p) {\n    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;\n}\n\n// convert 4D seed to 1D\nuint seed(uvec4 p) {\n\treturn 19u * p.x + 47u * p.y + 101u * p.z + 131u * p.w + 173u;\n}\n\n\n\n\n/**********************************************************************\n * Hashes\n **********************************************************************/\n\n// BBS-inspired hash\n//  - Olano, Modified Noise for Evaluation on Graphics Hardware, GH 2005\nuint bbs(uint v) {\n    v = v % 65521u;\n    v = (v * v) % 65521u;\n    v = (v * v) % 65521u;\n    return v;\n}\n\n\n\n// CityHash32, adapted from Hash32Len0to4 in https://github.com/google/cityhash\nuint city(uint s)\n{\n    uint len = 4u;\n\tuint b = 0u;\n    uint c = 9u;\n\n    for (uint i = 0u; i < len; i++) {\n    \tuint v = (s >> (i * 8u)) & 0xffu;\n        b = b * c1 + v;\n        c ^= b;\n    }\n\n    return fmix(mur(b, mur(len, c)));\n}\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\nuint city(uvec2 s)\n{\n    uint len = 8u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.y);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\nuint city(uvec3 s)\n{\n    uint len = 12u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.z);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n\n// CityHash32, adapted from Hash32Len12to24 in https://github.com/google/cityhash\nuint city(uvec4 s)\n{\n    uint len = 16u;\n    uint a = bswap32(s.w);\n    uint b = bswap32(s.y);\n    uint c = bswap32(s.z);\n    uint d = bswap32(s.z);\n    uint e = bswap32(s.x);\n    uint f = bswap32(s.w);\n    uint h = len;\n\n    return fmix(mur(f, mur(e, mur(d, mur(c, mur(b, mur(a, h)))))));\n}\n\n\n\n// Schechter and Bridson hash \n// https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint esgtsa(uint s)\n{\n    s = (s ^ 2747636419u) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    return s;\n}\n\n\n\n// UE4's RandFast function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat fast(vec2 v)\n{\n    v = (1./4320.) * v + vec2(0.25,0.);\n    float state = fract( dot( v * v, vec2(3571)));\n    return fract( state * state * (3571. * 2.));\n}\n\n\n\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hashwithoutsine12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hashwithoutsine13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hashwithoutsine21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hashwithoutsine23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashwithoutsine31(float p)\n{\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hashwithoutsine41(float p)\n{\n\tvec4 p4 = fract(vec4(p,p,p,p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hashwithoutsine44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// Hybrid Taus\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch37.html\nuint hybridtaus(uvec4 z)\n{\n    z.x = taus(z.x, 13, 19, 12, 0xfffffffeu);\n    z.y = taus(z.y, 2, 25, 4, 0xfffffff8u);\n    z.z = taus(z.z, 3, 11, 17, 0xfffffff0u);\n    z.w = z.w * 1664525u + 1013904223u;\n\n    return z.x ^ z.y ^ z.z ^ z.w;\n}\n\n// Interleaved Gradient Noise\n//  - Jimenez, Next Generation Post Processing in Call of Duty: Advanced Warfare\n//    Advances in Real-time Rendering, SIGGRAPH 2014\nfloat ign(vec2 v)\n{\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(v, magic.xy)));\n}\n\n\n\n// Integer Hash - I\n// - Inigo Quilez, Integer Hash - I, 2017\n//   https://www.shadertoy.com/view/llGSzw\nuint iqint1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n\n    return n;\n}\n\n// Integer Hash - II\n// - Inigo Quilez, Integer Hash - II, 2017\n//   https://www.shadertoy.com/view/XlXcW4\nuvec3 iqint2(uvec3 x)\n{\n    const uint k = 1103515245u;\n\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return x;\n}\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\n\n\nuint jkiss32(uvec2 p)\n{\n    uint x=p.x;//123456789;\n    uint y=p.y;//234567891;\n\n    uint z=345678912u,w=456789123u,c=0u;\n    int t;\n    y ^= (y<<5); y ^= (y>>7); y ^= (y<<22);\n    t = int(z+w+c); z = w; c = uint(t < 0); w = uint(t&2147483647);\n    x += 1411392427u;\n    return x + y + w;\n}\n\n\n\n// linear congruential generator\nuint lcg(uint p)\n{\n    return p * 1664525u + 1013904223u;\n}\n\n\n\n// MD5GPU\n// https://www.microsoft.com/en-us/research/wp-content/uploads/2007/10/tr-2007-141.pdf\n#define A0 0x67452301u\n#define B0 0xefcdab89u\n#define C0 0x98badcfeu\n#define D0 0x10325476u\n\nuint F(uvec3 v) { return (v.x & v.y) | (~v.x & v.z); }\nuint G(uvec3 v) { return (v.x & v.z) | (v.y & ~v.z); }\nuint H(uvec3 v) { return v.x ^ v.y ^ v.z; }\nuint I(uvec3 v) { return v.y ^ (v.x | ~v.z); }\n\nvoid FF(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + F(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid GG(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + G(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid HH(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + H(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nvoid II(inout uvec4 v, inout uvec4 rotate, uint x, uint ac)\n{\n    v.x = v.y + rotl(v.x + I(v.yzw) + x + ac, rotate.x);\n\n    rotate = rotate.yzwx;\n    v = v.yzwx;\n}\n\nuint K(uint i)\n{\n    return uint(abs(sin(float(i)+1.)) * float(0xffffffffu));\n}\n\nuvec4 md5(uvec4 u)\n{\n    uvec4 digest = uvec4(A0, B0, C0, D0);\n    uvec4 r, v = digest;\n    uint i = 0u;\n\n\tuint M[16];\n\tM[0] = u.x; M[1] = u.y;\tM[2] = u.z;\tM[3] = u.w;\n\tM[4] = 0u; M[5] = 0u; M[6] = 0u; M[7] = 0u; M[8] = 0u;\n\tM[9] = 0u; M[10] = 0u; M[11] = 0u; M[12] = 0u; M[13] = 0u;\n\tM[14] = 0u; M[15] = 0u;\n\n    r = uvec4(7, 12, 17, 22);\n    FF(v, r, M[0], K(i++));\n    FF(v, r, M[1], K(i++));\n    FF(v, r, M[2], K(i++));\n    FF(v, r, M[3], K(i++));\n    FF(v, r, M[4], K(i++));\n    FF(v, r, M[5], K(i++));\n    FF(v, r, M[6], K(i++));\n    FF(v, r, M[7], K(i++));\n    FF(v, r, M[8], K(i++));\n    FF(v, r, M[9], K(i++));\n    FF(v, r, M[10], K(i++));\n    FF(v, r, M[11], K(i++));\n    FF(v, r, M[12], K(i++));\n    FF(v, r, M[13], K(i++));\n    FF(v, r, M[14], K(i++));\n    FF(v, r, M[15], K(i++));\n\n    r = uvec4(5, 9, 14, 20);\n    GG(v, r, M[1], K(i++));\n    GG(v, r, M[6], K(i++));\n    GG(v, r, M[11], K(i++));\n    GG(v, r, M[0], K(i++));\n    GG(v, r, M[5], K(i++));\n    GG(v, r, M[10], K(i++));\n    GG(v, r, M[15], K(i++));\n    GG(v, r, M[4], K(i++));\n    GG(v, r, M[9], K(i++));\n    GG(v, r, M[14], K(i++));\n    GG(v, r, M[3], K(i++));\n    GG(v, r, M[8], K(i++));\n    GG(v, r, M[13], K(i++));\n    GG(v, r, M[2], K(i++));\n    GG(v, r, M[7], K(i++));\n    GG(v, r, M[12], K(i++));\n\n    r = uvec4(4, 11, 16, 23);\n    HH(v, r, M[5], K(i++));\n    HH(v, r, M[8], K(i++));\n    HH(v, r, M[11], K(i++));\n    HH(v, r, M[14], K(i++));\n    HH(v, r, M[1], K(i++));\n    HH(v, r, M[4], K(i++));\n    HH(v, r, M[7], K(i++));\n    HH(v, r, M[10], K(i++));\n    HH(v, r, M[13], K(i++));\n    HH(v, r, M[0], K(i++));\n    HH(v, r, M[3], K(i++));\n    HH(v, r, M[6], K(i++));\n    HH(v, r, M[9], K(i++));\n    HH(v, r, M[12], K(i++));\n    HH(v, r, M[15], K(i++));\n    HH(v, r, M[2], K(i++));\n\n    r = uvec4(6, 10, 15, 21);\n    II(v, r, M[0], K(i++));\n    II(v, r, M[7], K(i++));\n    II(v, r, M[14], K(i++));\n    II(v, r, M[5], K(i++));\n    II(v, r, M[12], K(i++));\n    II(v, r, M[3], K(i++));\n    II(v, r, M[10], K(i++));\n    II(v, r, M[1], K(i++));\n    II(v, r, M[8], K(i++));\n    II(v, r, M[15], K(i++));\n    II(v, r, M[6], K(i++));\n    II(v, r, M[13], K(i++));\n    II(v, r, M[4], K(i++));\n    II(v, r, M[11], K(i++));\n    II(v, r, M[2], K(i++));\n    II(v, r, M[9], K(i++));\n\n    return digest + v;\n}\n\n\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uint seed)\n{\n    uint h = 0u;\n    uint k = seed;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 4u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec2 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 8u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec3 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 12u;\n\n    return fmix(h);\n}\n\n// Adapted from MurmurHash3_x86_32 from https://github.com/aappleby/smhasher\nuint murmur3(uvec4 seed)\n{\n    uint h = 0u;\n    uint k = seed.x;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.y;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.z;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    k = seed.w;\n\n    k *= c1;\n    k = rotl(k,15u);\n    k *= c2;\n\n    h ^= k;\n    h = rotl(h,13u);\n    h = h*5u+0xe6546b64u;\n\n    h ^= 16u;\n\n    return fmix(h);\n}\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\n\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d16(uvec3 v)\n{\n    v = v * 12829u + 47989u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n\tv >>= 16u;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    return v;\n}\n\n\n\n// UE4's PseudoRandom function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat pseudo(vec2 v) {\n    v = fract(v/128.)*128. + vec2(-64.340622, -72.465622);\n    return fract(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));\n}\n\n\n\n// Numerical Recipies 3rd Edition\nuint ranlim32(uint j){\n    uint u, v, w1, w2, x, y;\n\n    v = 2244614371U;\n    w1 = 521288629U;\n    w2 = 362436069U;\n\n    u = j ^ v;\n\n    u = u * 2891336453U + 1640531513U;\n    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;\n    w1 = 33378u * (w1 & 0xffffu) + (w1 >> 16);\n    w2 = 57225u * (w2 & 0xffffu) + (w2 >> 16);\n\n    v = u;\n\n    u = u * 2891336453U + 1640531513U;\n    v ^= v >> 13; v ^= v << 17; v ^= v >> 5;\n    w1 = 33378u * (w1 & 0xffffu) + (w1 >> 16);\n    w2 = 57225u * (w2 & 0xffffu) + (w2 >> 16);\n\n    x = u ^ (u << 9); x ^= x >> 17; x ^= x << 6;\n    y = w1 ^ (w1 << 17); y ^= y >> 15; y ^= y << 5;\n\n    return (x + v) ^ (y + w2);\n}\n\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uint data)\n{\n\tuint hash = 4u, tmp;\n\n    hash += data & 0xffffu;\n    tmp = (((data >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec2 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec3 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec4 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.z & 0xffffu;\n    tmp = (((data.z >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.w & 0xffffu;\n    tmp = (((data.w >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n\n\n// Tiny Encryption Algorithm\n//  - Zafar et al., GPU random numbers via the tiny encryption algorithm, HPG 2010\nuvec2 tea(int tea, uvec2 p) {\n    uint s = 0u;\n\n    for( int i = 0; i < tea; i++) {\n        s += 0x9E3779B9u;\n        p.x += (p.y<<4u)^(p.y+s)^(p.y>>5u);\n        p.y += (p.x<<4u)^(p.x+s)^(p.x>>5u);\n    }\n    return p.xy;\n}\n\n\n\n// common GLSL hash\n//  - Rey, On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1,\n//    22nd European Meeting of Statisticians and the 7th Vilnius Conference on\n//    Probability Theory and Mathematical Statistics, August 1998\n/*\nuvec2 trig(uvec2 p) {\n    return uvec2(float(0xffffff)*fract(43757.5453*sin(dot(vec2(p),vec2(12.9898,78.233)))));\n}\n*/\nfloat trig(vec2 p)\n{\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\n\n\n\n// Wang hash, described on http://burtleburtle.net/bob/hash/integer.html\n// original page by Thomas Wang 404\nuint wang(uint v)\n{\n    v = (v ^ 61u) ^ (v >> 16u);\n    v *= 9u;\n    v ^= v >> 4u;\n    v *= 0x27d4eb2du;\n    v ^= v >> 15u;\n    return v;\n}\n\n\n\n// 128-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift128(uvec4 v)\n{\n    v.w ^= v.w << 11u;\n    v.w ^= v.w >> 8u;\n    v = v.wxyz;\n    v.x ^= v.y;\n    v.x ^= v.y >> 19u;\n    return v.x;\n}\n\n\n\n// 32-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift32(uint v)\n{\n    v ^= v << 13u;\n    v ^= v >> 17u;\n    v ^= v << 5u;\n    return v;\n}\n\n\n\n// xxhash (https://github.com/Cyan4973/xxHash)\n//   From https://www.shadertoy.com/view/Xt3cDn\nuint xxhash32(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec3 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.z + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint xxhash32(uvec4 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.w + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.z * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1512, 1512, 1532, 2119, 3914], [3917, 3917, 3974, 4039, 5709]], "test": "untested"}
{"id": "mdGBWc", "name": "u32noise4", "author": "FordPerfect", "description": "Port of my u32noise4 function from https://gist.github.com/fp64/126289051f0c9e1b70bcba7c3e07a82f\nsuitable as a 2D->1D hash.\nSomewhat expensive. See link for tests of quality.", "tags": ["random", "hash"], "likes": 3, "viewed": 187, "published": 3, "date": "1698701511", "time_retrieved": "2024-07-30T17:25:13.951553", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// GLSL port of u32noise4 function from\n// https://gist.github.com/fp64/126289051f0c9e1b70bcba7c3e07a82f\n// written as a 2D->1D hash.\n// Probably cheaper than Threefry/Philox (with default\n// parameters) from https://github.com/DEShawResearch/random123,\n// (see also e.g. https://www.shadertoy.com/view/XslBR4) but\n// likely also weaker. At least it doesn't promptly fail PractRand.\n// Emphatically NOT cryptographically secure.\n\nuint u32noise4(uvec2 n)\n{\n    n=uvec2(n.x^n.y,~n.x);\n    n^=n.yx>>ivec2(17,15);\n    n*=uvec2(0x01C8E815u,0xA13FC965u);\n    n^=n.yx>>ivec2(15,19);\n    n*=uvec2(0xCF019D85u,0xAC564B05u);\n    n^=n.yx>>ivec2(19,17);\n    n*=uvec2(0x01ED0675u,0x8664F205u);\n    n^=n.yx>>ivec2(17,17);\n    return n.x+n.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    // Thanks to \"hash: visualising bitplanes\" by hornet https://www.shadertoy.com/view/lt2yDm\n    vec2 seed=mod(fragCoord,vec2(iResolution.x/8.0,iResolution.y/4.0));\n    uint bit=uint(int(floor(8.0*uv.x)+8.0*floor(4.0*uv.y)));\n    uvec2 icoord=uvec2(ivec2(floor(seed+10.0*iTime)));\n    float c=float((u32noise4(icoord)>>bit)&1u);\n    fragColor=vec4(c,c,c,1.0);\n    // Grid.\n    fragColor*=step(10.0/iResolution.x,1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor*=step(10.0/iResolution.y,1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGBWc.jpg", "access": "api", "license": "public-domain", "functions": [[498, 498, 523, 523, 797], [799, 799, 854, 854, 1420]], "test": "untested"}
{"id": "csGBDc", "name": "Wiggle Effect from HaxeFlixel", "author": "TheCatWithShaders", "description": "yeah", "tags": ["wavy"], "likes": 1, "viewed": 296, "published": 3, "date": "1698693289", "time_retrieved": "2024-07-30T17:25:14.700549", "image_code": "const int EFFECT_TYPE_DREAMY = 0;\n\n\t\tconst int EFFECT_TYPE_WAVY = 1;\n\n\t\tconst int EFFECT_TYPE_HEAT_WAVE_HORIZONTAL = 2;\n\n\t\tconst int EFFECT_TYPE_HEAT_WAVE_VERTICAL = 3;\n\n\t\tconst int EFFECT_TYPE_FLAG = 4;\n\n\t\t\n\n\t\tconst int effectType = 4;\n\n   const float uSpeed = 2.25;\n\nconst float uFrequency = 5.0;\n\nconst float uWaveAmplitude = 0.1;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n\n{\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n\n    vec2 pt = uv;\n\n    if (effectType == EFFECT_TYPE_DREAMY) \n\n    {\n\n        float offsetX = sin(pt.y * uFrequency + iTime * uSpeed) * uWaveAmplitude;\n\n        pt.x += offsetX;\n\n    }\n\n    else if (effectType == EFFECT_TYPE_WAVY) \n\n    {\n\n        float offsetY = sin(pt.x * uFrequency + iTime * uSpeed) * uWaveAmplitude;\n\n        pt.y += offsetY;\n\n    }\n\n    else if (effectType == EFFECT_TYPE_HEAT_WAVE_HORIZONTAL)\n\n    {\n\n        float x = sin(pt.x * uFrequency + iTime * uSpeed) * uWaveAmplitude;\n\n        pt.x += x;\n\n    }\n\n    else if (effectType == EFFECT_TYPE_HEAT_WAVE_VERTICAL)\n\n    {\n\n        float y = sin(pt.y * uFrequency + iTime * uSpeed) * uWaveAmplitude;\n\n        pt.y += y;\n\n    }\n\n    else if (effectType == EFFECT_TYPE_FLAG)\n\n    {\n\n        float y = sin(pt.y * uFrequency + 10.0 * pt.x + iTime * uSpeed) * uWaveAmplitude;\n\n        float x = sin(pt.x * uFrequency + 5.0 * pt.y + iTime * uSpeed) * uWaveAmplitude;\n\n        pt.x += x;\n\n        pt.y += y;\n\n    }\n\n    vec2 texCoord = (pt + 1.0) / 2.0;\n\n    fragColor = texture(iChannel0, texCoord);\n\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 391, 391, 1518]], "test": "untested"}
{"id": "mdVfDV", "name": "The aurelia logo", "author": "mrange", "description": "CC0: The aurelia logo\nWatched an Aurelia presentation at Swetugg. Saw the logo and thought I\ncould probably shaderify it: https://aurelia.io/\n", "tags": ["2d", "logo"], "likes": 13, "viewed": 280, "published": 3, "date": "1698686064", "time_retrieved": "2024-07-30T17:25:15.456528", "image_code": "// CC0: The aurelia logo\n// Watched an Aurelia presentation at Swetugg. Saw the logo and thought I\n// could probably shaderify it: https://aurelia.io/\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec4 daurelia(vec2 p, float r) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  p1.x += -0.033;\n  p1.y += -0.004;\n  vec2 p2 = p;\n  p2.x += 0.48;\n  p2.y += -0.06;\n  vec2 p3 = p;\n  p3.x += -0.495;\n  p3.y += -0.06;\n  vec2 p4 = p;\n  p4.x += 0.39;\n  p4.y += -0.86;\n  vec2 p5 = p;\n  p5.x += 0.78;\n  p5.y += 0.4;\n  vec2 p6 = p;\n  p6.x += 0.035;\n\n  float d0 = box(p0, vec2(1.0, 0.285)-r);\n  float d1 = box(p1, vec2(0.225, 1.01)-r);\n  float d2 = box(p2, vec2(0.17, 0.63)-r);\n  float d3 = box(p3, vec2(0.11, 0.63)-r);\n  float d4 = box(p4, vec2(0.06, 0.06)-r);\n  float d5 = box(p5, vec2(0.06, 0.07)-r);\n  float d6 = box(p6, vec2(0.55, 0.45)-r);\n\n  d0 -= r;\n  d1 -= r;\n\n  float d7 = -(d0 - 0.06);\n\n  d1 = pmax(d1, d7, r);\n\n  float d = d2;\n  d = min(d, d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d -= r;\n  d = pmax(d, d7,r);\n  return vec4(d0, d1, d, d6);\n}\n\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\nvec3 aurelia(vec3 col, float aa, vec2 p) {\n  const vec3 baseCol00 = HSV2RGB(vec3(341.0/360.0, 0.96, 0.85));\n  const vec3 baseCol01 = HSV2RGB(vec3(260.0/360.0, 0.75, 0.36));\n  const vec3 baseCol10 = HSV2RGB(vec3(285.0/360.0, 0.68, 0.45));\n  const vec3 baseCol11 = HSV2RGB(vec3(268.0/360.0, 0.72, 0.40));\n\n  const mat2 arot = ROT(radians(34.0));\n  const vec2 soff = vec2(0.01, 0.01)*(arot);\n\n  p *= arot;\n  vec4 ad = daurelia(p, 0.0);\n  vec4 sad = daurelia(p+soff, 0.025);\n  float m0 = clamp(0.35*dot2(p-vec2(1.0, 0.0)), 0.0, 1.0);\n  float m1 = clamp(0.35*dot2(p-vec2(0.0, 1.0)), 0.0, 1.0);\n  float shd = mix(0.75, 1.0, smoothstep(aa, -aa, -ad.w));\n  vec3 bcol0 = mix(baseCol00, baseCol01, m0);\n  vec3 bcol1 = mix(baseCol00, baseCol01, m1)*shd;\n  vec3 bcol2 = mix(baseCol10, baseCol11, m1)*shd;\n  float sd = min(min(sad.x, sad.y), sad.z);\n  float od = min(min(ad.x, ad.y), ad.z);\n  od = abs(od)-aa;\n  col *= mix(1.0, 0.4, exp(-60.0*max(sd+0.01, 0.0)));\n  col = mix(col, mix(bcol0, col, 0.0), smoothstep(aa, -aa, ad.x));\n  col = mix(col, mix(bcol1, col, 0.0), smoothstep(aa, -aa, ad.y));\n  col = mix(col, mix(bcol2, col, 0.0), smoothstep(aa, -aa, ad.z));\n  col = mix(col, vec3(1.0), smoothstep(aa, -aa, od));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aa = sqrt(2.0)/RESOLUTION.y;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(1.0);\n  \n  vec2 ap = p;\n  float iz = mix(0.25, 2.0, smoothstep(-0.5, 0.5, -cos(0.5*TIME-0.075*(p.x))));\n  ap /= iz;\n  aa /= iz;\n  ap += sin(vec2(1.0, sqrt(2.0))*0.125*TIME)*4.0;\n\n  ap *= 0.5;\n  ap -= round(ap);\n  ap *= 2.0;\n  \n  col = aurelia(col, aa, ap);  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[482, 482, 504, 504, 650], [945, 1063, 1090, 1090, 1166], [1168, 1268, 1307, 1307, 1392], [1394, 1482, 1521, 1521, 1550], [1552, 1552, 1584, 1584, 2380], [2383, 2383, 2403, 2403, 2425], [2427, 2427, 2469, 2469, 3648], [3650, 3650, 3705, 3705, 4170]], "test": "untested"}
{"id": "dsVfWV", "name": "Rainbow Eyesores", "author": "TheCatWithShaders", "description": "the Vs Dave and Bambi fnf mod shader ported in shadertoy", "tags": ["rainbow"], "likes": 4, "viewed": 373, "published": 3, "date": "1698684280", "time_retrieved": "2024-07-30T17:25:16.212506", "image_code": "const float speed = 1.0;\n\nconst float frequency = 2.0;\n\nconst float waveAmplitude = 1.0;\n\nconst float uampmul = 1.0;\n\nvec4 sineWave(vec4 pt, vec2 pos)\n{\n        \n        float offsetX = sin(pt.y * frequency + iTime * speed);\n        float offsetY = sin(pt.x * (frequency * 2.0) - (iTime / 2.0) * speed);\n        float offsetZ = sin(pt.z * (frequency / 2.0) + (iTime / 3.0) * speed);\n        pt.x = mix(pt.x, sin(pt.x / 2.0 * pt.y + (5.0 * offsetX) * pt.z), waveAmplitude * uampmul);\n        pt.y = mix(pt.y, sin(pt.y / 3.0 * pt.z + (2.0 * offsetZ) - pt.x), waveAmplitude * uampmul);\n        pt.z = mix(pt.z, sin(pt.z / 6.0 * (pt.x * offsetY) - (50.0 * offsetZ) * (pt.z * offsetX)), waveAmplitude * uampmul);\n    \n\n    return vec4(pt.x, pt.y, pt.z, pt.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 pt = texture(iChannel0, uv);\n    fragColor = sineWave(pt, uv);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 152, 152, 756], [758, 758, 813, 813, 929]], "test": "untested"}
{"id": "mdVfDK", "name": "Bridge to Infinity || ft DoMa", "author": "ElSolem", "description": "Polyrefractals working with pentafractals. Fractal Party!!\nxy = p.x / p.y :: secret sauce", "tags": ["parallax", "fractals", "polyfractals", "teamwork"], "likes": 0, "viewed": 100, "published": 3, "date": "1698682939", "time_retrieved": "2024-07-30T17:25:16.974469", "image_code": "\n\nvec2 translate(vec2 p, vec2 offset)\n{\n    return p - offset;\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    mat2 R = mat2(c, -s, s, c);\n    return R * p;\n}\n\nvec2 mirror(vec2 p, float degree)\n{\n    const float tau = pi * 2.0;\n    const float piHalf = 1.57079632679489661923;\n    float angle = tau / degree;\n    float theta = atan(p.y, p.x) + piHalf + angle / 2.0;\n    float turn = floor(theta / angle) * angle;\n    return rotate(p, turn);\n}\n\nvec3 draw(vec3 buffer, float d, float r, vec3 color)\n{\n    float up = min(iResolution.x, iResolution.y);\n    d = up * d;\n    r = r * up / 360.0;\n    r = clamp(r, 1.5, 10000.0);\n    float aa = fwidth(d);\n    return mix(buffer, color, 1.0 - smoothstep(r - aa, r + aa / 2.0, d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float xy = p.x / p.y;\n    float threshold = 1.;\n\n    if (sqrt(xy) == sqrt(p.x * p.y))\n    {\n        vec2 coord = fragCoord - iResolution.xy / 2.0;\n        vec2 uv = coord / min(iResolution.x, iResolution.y);\n        vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n        const float r = 0.5;\n        const float phi = (sqrt(5.0) + 1.0) / 2.0;\n        const float phiSquared = phi * phi;\n        const float rSmaller = r / phiSquared;\n        const float a = r * phi / 2.0;\n        const float h = a - rSmaller;\n        const float w = r * sqrt((sqrt(5.0) + 5.0) / 2.0) / phi;\n        const float phiToThe4th = phiSquared * phiSquared;\n        const float logPhiSquared = log(phiSquared);\n        float t = 1.0 + mod(iTime, phiToThe4th - 1.0);\n        float u = 0.5 * log(t) / logPhiSquared;\n        float z = mix(1.0, 1.0 / phiToThe4th, u);\n        vec2 q = uv * z;\n        float l = length(q);\n        float n = floor(log(r / l) / logPhiSquared);\n        float s = pow(phi, 2.0 * n);\n        q = rotate(q, pi * n - iTime / 8.0);\n        q = mirror(q, 5.0);\n        q = q * s;\n        q = translate(q, vec2(0.0, -rSmaller));\n        float d = sdTriangleIsosceles(vec2(w / 2.0, -h), q) / (s * z);\n        float b = length(uv);\n        col = draw(vec3(0.0), d, 8.0 * b, 4.0 * sqrt(b) * col);\n        fragColor = vec4(col, 1.0);\n    }\n    else\n    {\n        vec2 coord = fragCoord - iResolution.xy / 2.0;\n        vec2 uv = coord / min(iResolution.x, iResolution.y);\n        vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n        const float r = 0.5;\n        const float phi = (sqrt(5.0) + 1.0) / 2.0;\n        const float phiSquared = phi * phi;\n        const float rSmaller = r / phiSquared;\n        const float a = r * phi / 2.0;\n        const float h = a - rSmaller;\n        const float w = r * sqrt((sqrt(5.0) + 5.0) / 2.0) / phi;\n        const float phiToThe4th = phiSquared * phiSquared;\n        const float logPhiSquared = log(phiSquared);\n        float t = 1.0 + mod(iTime, phiToThe4th - 1.0);\n        float u = 0.5 * log(t) / logPhiSquared;\n        float z = mix(1.0, 1.0 / phiToThe4th, u);\n        vec2 q = uv * z;\n        float l = length(q);\n        float n = floor(log(r / l) / logPhiSquared);\n        float s = pow(phi, 2.0 * n);\n        q = rotate(q, pi * n - iTime / 8.0);\n        q = mirror(q, 5.0);\n        q = q * s;\n        q = translate(q, vec2(0.0, -rSmaller));\n        float d = sdTriangleIsosceles(vec2(w / 2.0, -h), q) / (s * z);\n        float b = length(uv);\n        col = draw(vec3(0.0), d, 8.0 * b, 4.0 * sqrt(b) * col);\n        fragColor = vec4(col, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "/// Inigo Quilez's signed distance to a 2D triangle\n// reference Demo: https://www.shadertoy.com/view/MldcD7\n\nconst float pi = 3.1415926535897932384626433832795;\n\nfloat sdTriangleIsosceles(in vec2 q, in vec2 p)\n{\n    p.x = abs(p.x * pi);\n    \n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    \n    float s = -sign(q.y);\n\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                  vec2(dot(b, b), s * (p.y - q.y)));\n\n    return (d.x / d.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 39, 39, 64], [66, 66, 100, 100, 204], [206, 206, 241, 241, 488], [490, 490, 544, 544, 768], [770, 770, 825, 825, 3529]], "test": "untested"}
{"id": "cdVfWK", "name": "Ball scopes", "author": "FordPerfect", "description": "Simple microscope (vertical) and telescope (horizontal) made from ball lenses.", "tags": ["lens", "optics"], "likes": 4, "viewed": 151, "published": 3, "date": "1698673348", "time_retrieved": "2024-07-30T17:25:17.837162", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\nconst float pi=3.14159265358979;\n\n// Refractive index.\n//   1.0        - vacuum\n//   1.000293   - air at 0 °C, 1 atm\n//   1.333      - water at 20 °C\n//   1.458      - fused quartz\n//   1.458..1.7 - typical glass\n//   2.417      - diamond\nconst float n=1.5;\n\n// Balls (position, radius).\n// AB is microscope, AC is telescope.\nvec4 A,B,C;\n\nvec3 ray_dir(vec3 camera,vec3 target,vec3 up,vec3 xyz)\n{\n    vec3 z=normalize(target-camera),x=normalize(cross(up,z)),y=cross(z,x);\n    return normalize(xyz.x*x+xyz.y*y+xyz.z*z);\n}\n\nvec3 sky(vec3 ro,vec3 rd)\n{\n    vec3 ret=vec3(0.0,0.25,0.5)+vec3(0.125,0.25,0.25)*exp(-3.5*max(rd.y,0.0));\n    float m=73.3;\n    vec2 v=vec2(atan(rd.z,rd.x)/pi,rd.y);\n    mat2 q=mat2(0.8,-0.6,0.6,0.8);\n    for(int i=0;i<8;++i)\n    {\n        vec2 c=floor(m*q*v);\n        c.x+=0.5*sin(1.7*c.y+float(i));c.y+=0.5*sin(3.7*c.x);\n        c.x+=0.5*sin(3.7*c.y);c.y+=0.5*sin(3.7*c.x+float(i));\n        c.x+=0.5*sin(7.3*c.y);c.y+=0.5*sin(7.3*c.x);\n        v=c*q/m;\n        v.y=clamp(v.y,-1.0,+1.0);\n        vec3 n=vec3(sqrt(1.0-v.y*v.y)*vec2(cos(pi*v.x),sin(pi*v.x)),v.y).xzy;\n        vec3 d=n-rd;\n        ret+=exp(-2.5+sin(3.7*float(i*i))-1e5*dot(d,d));\n        q=q*q;\n    }\n    return ret;\n}\n\nvec3 ground(vec3 ro,vec3 rd)\n{\n    vec3 v=(ro-(ro.y/rd.y)*rd);\n    vec2 xy=5.0*mat2(0.8,-0.6,0.6,0.8)*v.xz;\n    vec3 ret=vec3(0.0);\n    float K=16.0;\n    ret+=exp(-length(v.xz))*(1.0-pow(0.5+0.5*cos(K*v.x),16.0))*(1.0-pow(0.5+0.5*cos(K*v.z),16.0));\n    float r=0.0;\n    for(int i=0;i<5;++i)\n    {\n        r+=sin(xy.x)*sin(xy.y);\n        xy=mat2(1.1,0.5,-0.5,1.1)*xy+2.0*r*r;\n    }\n    ret+=vec3(0.25,0.5,0.125)+0.0625*vec3(-0.5,+1.0,0.0)*r*exp(-0.02*length(v-ro));\n    return ret;\n}\n\n// Ball lens.\n// See https://en.wikipedia.org/wiki/Lens#Lensmaker's_equation.\nfloat focal_length(float R,float n)\n{\n    return n*R/(2.0*(n-1.0));\n}\n\nfloat ray_sphere(vec3 ro,vec3 rd,vec3 c,float R)\n{\n    const float inf=uintBitsToFloat(0x7F800000u);\n    float p=dot(ro-c,rd),q=dot(ro-c,ro-c)-R*R,d=p*p-q;\n    if(d<0.0) return -inf;\n    float tm,tp;\n    if(p<0.0) {tm=q/(+sqrt(d)-p);tp=-p+sqrt(d);}\n    else {tm=-p-sqrt(d);tp=q/(-p-sqrt(d));};\n    return tm<0.0?(tp<0.0?-inf:tp):tm;\n}\n\nvec3 cast_ray_bg(vec3 ro,vec3 rd)\n{\n    if(rd.y>=0.0) return sky(ro,rd);\n    else return ground(ro,rd);\n}\n\nvec3 cast_ray(vec3 ro,vec3 rd)\n{\n    int count=4;\n    bool air=true;\n    vec3 ret=vec3(0.0);\n    float w=1.0;\n    for(int i=0;i<count;++i)\n    {\n        float tA=ray_sphere(ro,rd,A.xyz,A.w);\n        float tB=ray_sphere(ro,rd,B.xyz,B.w);\n        float tC=ray_sphere(ro,rd,C.xyz,C.w);\n        vec3 c=A.xyz;\n        float t=tA;\n        if(t<-1e-10||tB>1e-10&&tB<t) {t=tB;c=B.xyz;}\n        if(t<-1e-10||tC>1e-10&&tC<t) {t=tC;c=C.xyz;}\n        if(t<0.0) break;\n        ro=ro+t*rd;\n        vec3 normal=normalize(ro-c);\n        if(!air) normal=-normal;\n        // Since refract() doesn't do total internal reflection,\n        // we roll our own.\n        //float eta=(air?1.0/n:n);\n        float eta=(air?1.0/n:n);\n        float k=1.0-eta*eta*(1.0-dot(normal,rd)*dot(normal,rd));\n        if(k<0.0) rd=reflect(rd,normal);\n        else\n        {\n            // Only use BG for reflections, and only from air.\n            if(air)\n            {\n                // Schlick's approximation.\n                float r0=pow((n-1.0)/(n+1.0),2.0);\n                float r=r0+(1.0-r0)*pow(clamp(1.0-abs(dot(normal,rd)),0.0,1.0),5.0);\n                ret+=w*r*cast_ray_bg(ro,reflect(rd,normal));\n                w*=1.0-r;\n            }\n            rd=eta*rd-(eta*dot(normal,rd)+sqrt(k))*normal;\n            air=!air;\n        }\n        ro=ro+0.001*rd;\n    }\n    ret+=w*cast_ray_bg(ro,rd);\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float rA=1.0,rB=1.0,rC=5.0;\n    float fA=focal_length(rA,n),fB=focal_length(rB,n),fC=focal_length(rC,n);\n    float h=1.25*fB;\n    float f=1.0/(1.0/fB-1.0/h);\n    float d=0.875*fA;\n    float H=h+f+d;\n    float R=fA*(2.5+sin(0.73*iTime));\n    float a=mix(-0.01,pi/2.0-0.001,smoothstep(-1.0,+1.0,sin(0.17*iTime)));\n    float D=fA+fC;\n    A=vec4(0.0,H,0.0,rA);\n    B=vec4(0.0,h,0.0,rB);\n    C=vec4(  D,H,0.0,rC);\n    vec3 ro=A.xyz+R*vec3(-cos(a),sin(a),0.1*sin(0.37*iTime)),ta=A.xyz;\n    vec3 rd=ray_dir(ro,ta,vec3(0.0,1.0,0.0),vec3(2.0*fragCoord-iResolution.xy,iResolution.y));\n    vec3 col=cast_ray(ro,rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVfWK.jpg", "access": "api", "license": "public-domain", "functions": [[409, 409, 465, 465, 589], [591, 591, 618, 618, 1275], [1277, 1277, 1307, 1307, 1759], [1761, 1839, 1876, 1876, 1908], [1910, 1910, 1960, 1960, 2244], [2246, 2246, 2281, 2281, 2351], [2353, 2353, 2385, 2385, 3736], [3738, 3738, 3792, 3792, 4434]], "test": "untested"}
{"id": "DdKBzW", "name": "Practice - 2023-10-30", "author": "INCHMAN1900", "description": "Practice from The Book of Shaders", "tags": ["thebookofshaders"], "likes": 5, "viewed": 174, "published": 3, "date": "1698662680", "time_retrieved": "2024-07-30T17:25:18.675920", "image_code": "vec3 line(vec2 uv,vec2 pos,float width) {\n    vec2 c1=smoothstep(pos-vec2(width/2.,0.),pos-vec2(width/2.,0.)+.00001,uv);\n    vec2 c2=smoothstep(pos+vec2(width/2.,0.),pos+vec2(width/2.,0.)+.00001,uv);\n    return vec3(c1.x*c1.y*(1.-c2.x*c2.y));\n}\n\nfloat random(in vec2 _st) {\n    return fract(sin(dot(_st.xy,vec2(1422.9898,7248.233)))*23.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ys=100.;\n    vec2 uv=fragCoord/iResolution.xy;\n    float r1=random(vec2(2143.51,floor(uv.y*ys)));\n    uv*=vec2(.001,1.);\n    uv-=vec2(r1*.001*iTime,0.);\n    float speed=r1*.5;\n    float r2=random(vec2(uv.x*10.-354.53,floor(uv.y*ys)));\n    vec3 col=line(uv,vec2(r2,.0),r1*((1.-iMouse.x/iResolution.x)*3.+.01));\n    // erase some lines\n    col*=mod(uv.y*ys,2.)>1.?0.:1.;\n    fragColor = vec4(1.-col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 244], [246, 246, 273, 273, 347], [349, 349, 406, 406, 820]], "test": "untested"}
{"id": "mdyBRm", "name": "Aurora Bubble", "author": "INCHMAN1900", "description": "Simulating 2D noise using 1D noise", "tags": ["noise"], "likes": 4, "viewed": 198, "published": 3, "date": "1698662511", "time_retrieved": "2024-07-30T17:25:19.471792", "image_code": "#define res iResolution.xy\n\nfloat random(float x) {\n    return fract(sin(754.213+x*3597.623)*954.23);\n}\n\nfloat noise(float x) {\n    float i=floor(x);\n    float f=fract(x);\n    return mix(random(i),random(i+1.),smoothstep(0.,1.,f));\n}\n\nvec3 bubble(vec2 uv) {\n    float a = atan(uv.y,uv.x);\n    float n=sin(a)*a*uv.y*2.;\n    float r=noise(n+iTime)*.1+.6;\n    float c=noise(n+iTime*.2);\n    vec3 col = vec3(smoothstep(r+.005,r,length(uv)));\n    col*=vec3(c,.7,c*.7+.6);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-res)/res.y;\n    fragColor = vec4(bubble(uv),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 51, 51, 103], [105, 105, 127, 127, 233], [235, 235, 257, 257, 484], [486, 486, 543, 543, 622]], "test": "untested"}
{"id": "cdGBDV", "name": "Graph of constant thickness", "author": "Suslik", "description": "A simple test that calculates an approximate SDF of a graph of a function to render it is a line of constant thickness with antialiasing.", "tags": ["line", "antialiasing", "graph"], "likes": 3, "viewed": 279, "published": 3, "date": "1698654868", "time_retrieved": "2024-07-30T17:25:20.300576", "image_code": "//an arbitrary function goes here\n//kind of breaks down for points with very high curvature and/or very thick lines\nfloat F(float x)\n{\n    x -= iResolution.x / 2.0f;\n    return x * sin(x / (iResolution.x / 40.0f)) / 2.0f + iResolution.y / 2.0f;\n}\n\nfloat GradF(float x)\n{\n    float eps = 1.0f; //in pixels\n    return (F(x + eps) - F(x - eps)) / (2.0f * eps);\n}\n\nfloat CosAng(float x)\n{\n    float tanAng = GradF(x);\n    float cosAng = sqrt(1.0f / (tanAng * tanAng + 1.0f));\n    return cosAng;\n}\n\nfloat DistF(vec2 xy)\n{\n    return abs(F(xy.x) - xy.y) * CosAng(xy.x);\n}\n\nfloat AALine(float dist, float width)\n{\n    return 1.0f - clamp((dist - width), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float width = iResolution.x / 1000.0f * (sin(iTime * 3.0f) + 1.0f);\n    \n    float separator = iMouse.z > 0.5f ? iMouse.x : ((sin(iTime) * 0.5f + 0.5f) * iResolution.x);\n    fragColor = vec4(0.03f);\n    if(fragCoord.x < separator)\n    {\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0f), AALine(DistF(fragCoord.xy), width));\n    }else\n    {\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0f), AALine(abs(F(fragCoord.x) - fragCoord.y), width));\n    }\n    fragColor = mix(fragColor, vec4(0.0f, 1.0f, 0.0f, 1.0f), AALine(abs(fragCoord.x - separator), 0.5f));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0f / 2.2f));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 116, 134, 134, 246], [248, 248, 270, 270, 359], [361, 361, 384, 384, 492], [494, 494, 516, 516, 565], [567, 567, 606, 606, 661], [663, 663, 720, 720, 1348]], "test": "untested"}
{"id": "DsGBDK", "name": "Moving GilbertTesselat┣┳┻┫ꓕTiles", "author": "ollj", "description": "Click to show grid & to control spot.\ncheckerboarded+noised alternating ꓕT-crossing & whiteMask pushes T-intersections to the top/Right\nnow with hexes, because https://www.youtube.com/watch?v=Lgio_ygetbo\nIntended for lookup with floats.", "tags": ["grid", "random", "animated", "animation", "t", "blocks", "double", "morph", "spot", "regular", "alternating", "irregular", "asymmetric", "symmetric"], "likes": 22, "viewed": 258, "published": 3, "date": "1698649832", "time_retrieved": "2024-07-30T17:25:21.318853", "image_code": "//#define zoom 2. already exists, called scale, not oto be confused with time_scale\n\n#define RipplesOscillate\n//oscillate between circle and ripples, for eccect-amplitude\n\n#define innerCircleRadius 2.5\n#define transitionRadius  5.\n//outerCircleradius=innerCircleRadius+transitionRadius\n//negative innerCircleRadius -> lower peak, aborted transition\n//negative transitionRadius  -> valley instead of hill\n//transitionRadius also limits==sets to/by how much ANY rectangle is stretched|squashed\n//as long as transitionRadius!=0, triangles will never be squashed down to 0.\n\n//#define linearMixOnly\n//define in to have it soimple, fast, linear only (unclamped)\n//undefine to add at least 50% smoothstep (only smoothstep is clamped)\n\n// https://www.shadertoy.com/view/mdyfD1 asymmetric blocks w regular spot, 2023 by jt\n// based on https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified float\n\n// Change the regularity in the pattern of\n// random-blocks-by-alternating-double-T-crossings\n// (aka asymmetric/irregular)\n// based on distance to \"spotlight\" position.\n// This implementation is intended for lookup with floats.\n// Click to show grid & control spot.\n// Click to lower left returns to demo mode.\n\n// This can be used to place windows into walls of asymmetric blocks:\n// see https://www.shadertoy.com/view/dtl3Wf Asymmetric Blocks Wall\n\n// tags: random, t, blocks, double, alternating, irregular, asymmetric, morph, grid, animation, animated, regular, symmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define time_scale 10.0\n\n#define pi 3.1415926\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2,\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x) // calculate two hashes in parallel\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n//// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\n//// perhaps the best ever devised for this op count, great distribution and cycle\n//uint lowbias32(uint x)\n//{\n//    x ^= x >> 16;\n//    x *= 0x7feb352du;\n//    x ^= x >> 15;\n//    x *= 0x846ca68bu;\n//    x ^= x >> 16;\n//    return x;\n//}\n\n#define HASH(u) triple32(u)\n//#define HASH(u) lowbias32(u)\n\nuint uhash(ivec2 v, bool choose)\n{\n//return uvec2(0u); // verify grid alignment\n    return HASH((uint(v.x)*2u+uint(choose) + HASH(uint(v.y)*2u+uint(choose))) /*+ uint(iFrame / 120)*/);\n}\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nstruct block\n{\n    vec2 center;\n    vec2 extent;\n    ivec2 id;\n};\n\n#define RES 8\n\n#define scale (float(RES*12))\n\n//to get a smoothstepped grid: uv=smoothstep(-.1,.1,ss2t(fract(uv*gridSize/iResolution.xy)))\n//ss2t() turns a seesaw wave to triangle wave\n#define ss2t(a) a=abs(a*2.-1.)\n\n\n#define sat(a) clamp(a,0.,1.)\n#define applyRadii(r) r=sat((r-innerCircleRadius)/transitionRadius)\n\n//from https://www.shadertoy.com/view/wtdSzX\n#ifdef FLAT_TOP_HEXAGON\nconst vec2 shiiit = vec2(1.7320508, 1);\n#else\nconst vec2 shiiit = vec2(1, 1.7320508);\n#endif\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p\n){p = abs(p);    \n    #ifdef FLAT_TOP_HEXAGON\n    return max(dot(p, shiiit*.5), p.y);} // Hexagon.\n    #else\n    return max(dot(p, shiiit*.5), p.x);} // Hexagon.\n    #endif    \n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\n\nvec4 getHex(vec2 p)\n{   // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n  \n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/shiiit.xyxy) + .5;\n    #else\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/shiiit.xyxy) + .5;\n    #endif\n    \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*shiiit, p - (hC.zw + .5)*shiiit);\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID -\n    // in the form of the hexagonal central point.\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that.\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) \n        ? vec4(h.xy, hC.xy) \n        : vec4(h.zw, hC.zw + .5);\n}\n\nfloat spot(vec2 v){//the actual whiteness\n   bool demo = !any(greaterThan(vec2(iMouse), vec2(10))); //= iMouse.z <0.;\n    //bool demo = any(lessThan(vec2(iMouse), vec2(10)));\n    float speed=pi*3.;\n    if(demo)\n        v -= vec2(cos(speed*iTime/time_scale)\n                , sin(speed*iTime/time_scale) )*scale/vec2(RES);\n    else   {\n        // hacky screenspace mouse\n        vec2 R = iResolution.xy;\n        vec2 m = iMouse.xy;\n        m = (2.0 * m - R) / R.y;\n        v -= m * scale/float(RES);    }\n\n\n\n    float r=length(v);//a circle pattern for effect-strenght\n        \n    #ifdef RipplesOscillate\n    float R=r;\n    R*=.2;\n    R=fract(R);\n    R=ss2t(R);\n    R*=9.;\n    //applyRadii(r);                            //single circle\n    applyRadii(R);                              //multiple rings\n    r=sat(abs(sat(hex(getHex(v*.1).xy))-.5)*4.);//hexagonal grid\n    r=mix(r,R,-cos(iTime*.5)*.5+.5);\n    #else \n\n    applyRadii(r);\n    #endif\n \n        return r;\n}\n\n\nfloat whiteEffect(ivec2 d,ivec2 t,int x,bool choose,bool mirror,inout float m){//poorly named function\n//this ewqas turned into a subroutine to understand it, but THAT was all mostly useless.\n     m=spot(vec2(t+d));\n\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // float hash\n    //return choose?r.y:r.x;\n    float r = fract(float(uhash(t+d, choose) % uint(RES))/float(RES))+float(choose?d.y:d.x); // integer hash with fixed resolution\n    \n    float h=float(choose?d.y:d.x);\n    \n    #ifdef linearMixOnly\n    //h= mix(h+1.,h-1.,m*.5)*.5;\n    #else \n    //h=hex(vec2(t+d))*.5;\n    return h;}\n\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror)\n{\n    float m = 1.0;\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //if(all(lessThanEqual(abs(t+d), ivec2(2))))\n    //if(length(vec2(t+d)) < 2.5)\n    //    //return float(choose?d.y:d.x);\n    //    m = 0.;\n    float h=whiteEffect(d,t,x,choose,mirror,m);\n    //at least 50% smoothstep. the final result is clamped afterwards (discontinuity)\n    h= mix(h+1.,h-1.,m*.5)*.5;\n    h+=smoothstep(0.,.5,h)*.5;  //dodo: i fail to get 100% smoothtep?\n    #endif\n    //becausde smoothstep includes a clamp that mix() does not have\n    //and that clamping causes artefacts.\n    return h;\n}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(vec2 p) // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n{\n    ivec2 tile = ivec2(floor(vec2(p))); // global coordinates of tile\n    vec2 local = fract(p);\n\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n    \n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n       \n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    \n    if(flip) // horizontal line goes through: swap vertical with horizontal\n    {\n        // swap components\n        local = local.yx;\n    }\n\n    // vertical line goes through (on flip transpose for horizontal line)\n\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n\n    vec2 v0 =vec2(c,d);   // primary corner in (0,0) tile\n    vec2 v1 =        vec2(       \n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip));     // primary corner in (X,Y) tile\n    if(flip) tile = tile.yx;\n    v0 += vec2(tile);\n    v1 += vec2(tile);\n    ivec2 id = tile + ivec2(x,y);\n    if(flip){// horizontal line goes through: unswap vertical with horizontal\n        v0 = v0.yx;\n        v1 = v1.yx;\n        id = id.yx;    }\n    bool flag = v0.y > v1.y;\n    // fix order of min/max corners\n    vec2 center = (v0.xy+v1.xy)/2.0;\n    vec2 extent = abs(v0.xy-v1.xy)/2.0;\n    return block(center, extent, id);}\n\nvec3 hash32(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) // https://iquilezles.org/articles/distfunctions2d/\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 colorize(ivec2 id){\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    return color;}\n\n\n\n//i forgot how to use p,mod here, and remembered, all I need is ss2t() instead:\n/*\n#define vec1 float\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n/*\n//hg_sdf pmod extensions of https://www.shadertoy.com/view/4ttyDN\n//problem, pMod alone has no good efficient interval bound with gradients outside of the bound interval\n//pmodInterval() exists, but it has (numerically) bad branches.\n//pModr() fixes this\n//[s] sets period-length, n sets number of [c0 discontinuities] == [tileBorderCount]\nfloat pmod(inout float u,float s){float r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \nvec2 pmod(inout vec2 u,vec2 s){vec2 r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \n//vec2 pMod(vec1 u,vec1 s){return vec2( ff(u/s+.5)*vec2(s,1));}//silly variant\nvec1 pModr(inout vec1 p,vec1 s,vec1 n//n==number of repeats (discontinuities), where the smallest discontinuity is at [s]\n){float q=p,f=pmod(q,s);p=p+.5*s;vec2 r=vec2(mix(mix(q,p-s*n,step(n,f)),p,step(f,0.)),clamp(f,0.,n))\n ;p=r.x;return r.y;}\n//for u<0 and u>s*n the space condinues linearily, without repetition, this is different from hg_sdf.\n//it also does not set a start, you must just shift u instead\nfloat pModR(inout float p,vec1 s,vec1 n){float r=pModr(p,s,n);p-=s*.5;return r;}//offset the output for more utility.\n//minor flaw; for s==0. special linear case, it still splits a line in 2 segments.\n*/\n\n//i failed to use euclideanbeat instead of ss2t()\n//Because i could not get the scaling right.\n//,euclideanbeat is THE best hairline-grid function\n//,becauseits hauirlines do not vanish on smaller respolutions (unless used wrongly)\n\n#define u5(a) ((a*.5)+.5)\n\nvoid mainImage(out vec4 fragColor, in vec2 p){\n    vec2 R = iResolution.xy;\n    vec2 P=p;\n    p = (2.0 * p - R) / R.y;\n\n    //p+=.2;\n    //vec2 m = (2.0 * iMouse.xy- R) / R.y;\n\n    block b = blocks_layout(p*scale/vec2(RES));\n    b.center *= float(RES);\n    b.extent *= float(RES);\n\n    vec3 color = colorize(b.id);\n    //color *= spot(p*scale/vec2(RES));\n    \n    color = mix(max(color, 1.0-spot(p*scale/vec2(RES))),color,u5(sin(iTime*.1*u5(sqrt(5.)))));//white overlay\n    \n    //color = mix(vec3(color.x+color.y+color.z)/3.0, color, spot(p*scale/vec2(RES)));\n    //color = mix(1.0-color, color, spot(p*scale/vec2(RES)));\n    \n    // differences between pixel-position and corners\n    vec2 q0 = p-vec2(b.center-b.extent)/scale;\n    vec2 q1 = p-vec2(b.center+b.extent)/scale;\n    // visualize edges\n    float a=0.005/scale*32.;\n    float e=0.01/scale*32.;\n    color = min(color, vec3(smoothstep(a,e,+q0.x)));\n    color = min(color, vec3(smoothstep(a,e,+q0.y)));\n    color = min(color, vec3(smoothstep(a,e,-q1.x)));\n    color = min(color, vec3(smoothstep(a,e,-q1.y)));\n\n    if(iMouse.z > 0.0)    {\n        //snoothed grid!\n        vec2 q = fract(p*scale/float(RES)+.5);\n        q=ss2t(q);\n        q*=2.;//optionally steeper slope dims the gradient out faster, leaving  a black square instead of a black dot.\n        q=smoothstep(-.2,.2, q);//essential for smaller resolutions\n        //q=sqrt(q);   //optionally more exponential\n        color -= vec3(1.-min(q.x, q.y))*.5; //ADD grid+background\n        /*\n        #ifdef checkerboard \n        lazy slow GLOBAL checkerboard\n        vec2 r = p*scale/2.0;\n        color *= mix(0.5, 1.0, step(0.0, sin(r.x*pi*2.0)*sin(r.y*pi*2.0))); // checker\n        #endif \n        /**/\n    }\n    \n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2608, 2759, 2818, 2818, 2972], [3342, 3342, 3376, 3421, 3528], [3530, 3530, 3626, 3626, 3762]], "test": "untested"}
{"id": "dsVfWy", "name": "SupaShade", "author": "AxeMarz", "description": "a cool background", "tags": ["gradient"], "likes": 5, "viewed": 132, "published": 3, "date": "1698630940", "time_retrieved": "2024-07-30T17:25:22.168581", "image_code": "const float GRID_SIZE = 12.;\n\nconst vec3 COLOR_ACCENT_1 = vec3(0, 0, 0);\nconst vec3 COLOR_ACCENT_2 = vec3(.01, .2, .37);\nconst vec3 COLOR_DARK = vec3(.11, .08, .5);\n\nfloat hash2(vec2 p) {\n\treturn texture(iChannel0, p).x;\n}\n\nvec3 lerpColor(vec3 from, vec3 to, float progress) {\n    vec3 range = to - from;\n    return from + range * progress;\n}\n\nvec4 make_grid(vec2 uv) {\n    vec2 coord = floor(uv * GRID_SIZE);\n    vec2 cell_uv = fract(uv * GRID_SIZE);\n    return vec4(coord, cell_uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float aa = 8. / iResolution.y;\n    vec4 grid = make_grid(uv - vec2(0., iTime * .1));\n    \n    // layer moving noise in four directions\n    float noise = 0.;\n    noise += texture(iChannel0, (uv - 13.) / 16. + iTime * .007).x;\n    noise += texture(iChannel0, (uv + 167.) / 16. - iTime * .01).x;\n    noise += texture(iChannel0, (uv + 31.) / 16. * vec2(-1., 1.) - iTime * .005).x;\n    noise += texture(iChannel0, (uv - 71.) / 16. * vec2(1., -1.) - iTime * .013).x;\n    noise /= 4.;\n    \n    float h = hash2(grid.xy / 100.);\n    vec2 st = grid.zw;\n    \n    // flip into quadrants\n    if (int(grid.x) % 2 == 0) {\n        st.x = 1. - st.x;\n    }\n    if (int(grid.y) % 2 == 0) {\n        st.x = 1. - st.x;\n    }\n    \n    // flip tile randomly\n    if (h > .5) {\n        st.x = 1. - st.x;\n    }\n    \n    // mirror over x = -y + 1\n    st = st.x + st.y < 1.\n        ? vec2(st.x, st.y)\n        : vec2(1. - st.y, 1. - st.x);\n    \n    // truchet distance\n    float d = h > .5 ? length(st) : 1. - length(st);\n    \n    float y = uv.y + .5;\n    // adjust the slope of the gradient so it isn't as overpowering\n    float y_fix = 1. - pow(1. - y, 2.);\n    float width = noise * .4 + .3;\n    vec3 color = lerpColor(\n        lerpColor(COLOR_DARK, COLOR_ACCENT_1, y),\n        lerpColor(COLOR_ACCENT_2, COLOR_DARK, y_fix),\n        smoothstep(width + aa, width - aa, d)\n    );\n    \n    vec3 srgb = pow(color, vec3(1. / 2.2));\n    fragColor = vec4(srgb, 1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 187, 187, 222], [224, 224, 276, 276, 342], [344, 344, 369, 369, 486], [488, 488, 543, 543, 2046]], "test": "untested"}
{"id": "csVBDG", "name": "Ulam Race (286 chars)", "author": "fenix", "description": "More fun with the Ulam spiral.\n\nhttps://en.wikipedia.org/wiki/Ulam_spiral", "tags": ["2d", "spiral", "codegolf", "ulam"], "likes": 33, "viewed": 310, "published": 3, "date": "1698625740", "time_retrieved": "2024-07-30T17:25:23.030277", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I wanted to experiment more with the Ulam spiral from my last shader, and this seemed\n//  like an interesting test/pattern. Indeed I found a couple more bugs, needing to adjust\n//  the bottom region in order to see the correct animation. \n//\n//  Credit is due here to @SnoopethDuckDuck for the the ulam number factorization, saving\n//  a few characters. I tried to be judicious but please feel free to golf further if I\n//  missed something!\n// ---------------------------------------------------------------------------------------\n\n// My attempt to fix OpenGL, also includes color change (hopefully an improvement): 286 chars\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n\n    int I = int(u = 2.*floor((sqrt(iTime)*3.+1.)*(u+u-O.xy)/O.y)),\n        J = int(u.y),\n        D = J-I, S = I+J,\n        p = 1 + S/2 + int(iTime*30.)\n              - ( I > 0 && S == 0 ? J*J - D : // squares diagonal - bottom right\n                  I > abs(J)      ? I*I + D : // right region\n                  S > 0           ? J*J     : // top region\n                  D > 0           ? I*I     : // left region\n                                    J*J - D); // bottom region\n    \n    O = p < 0 ?\n            O-O :\n            p%40 > 0 ?\n                abs(cos(vec4(p/40) * vec4(5,8,7,0))) * fract(vec4(-p)/40.) : O;\n}\n/**/\n\n// From SnoopethDuckDuck: 287 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n\n    int I = int(u = 2.*floor((sqrt(iTime)*3.+1.)*(u+u-O.xy)/O.y)),\n        J = int(u.y),\n        D = J-I, S = I+J,\n        p = ( I > 0 && S == 0 ? J*J - D : // squares diagonal - bottom right\n              I > abs(J)      ? I*I + D : // right region\n              S > 0           ? J*J     : // top region\n              D > 0           ? I*I     : // left region\n                                J*J - D   // bottom region\n             ) - S/2 + 1 - int(iTime*30.) ; \n    \n    O = p < 1 ? p%40 < 0 ? abs(cos( vec4(1-p/40)*vec4(5,2,6,0) ))*fract(vec4(p)/40.)\n                         : O\n              : O-O;\n}\n/**/\n\n// From FabriceNeyret2: 294 chars, but the \"cars\" are in the wrong place for me\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n    u = 2.* floor ( ( sqrt(iTime) * 3. + 1.) * (u + u - O.xy) / O.y  );\n\n    int I = int(u),\n        J = int(u.y),\n        D = J-I, S = (I+J)/2,\n        p = ( I > 0 && S == 0  ? J*J - D +S : // squares diagonal - bottom right\n              I > abs(J)       ? I*I + D :    // right region\n              S > 0            ? J*J     :    // top region\n              D > 0            ? I*I     :    // left region\n                                 J*J - D      // bottom region\n             ) - S + 1 - int(iTime*30.) ; \n    \n    O = p < 1 ? -p%40 > 0 ? abs(cos( vec4(1-p/40)*vec4(5,2,6,0) )) *fract(vec4(p)/40.)\n    //O = p < 1 ? -(p - 7)%40 > 0 ? abs(cos( vec4(1-p/40)*vec4(5,2,6,0) )) *fract(vec4(p)/40.) //this version works for me\n                          : O\n              : O-O;\n}\n/**/\n\n// From SnoopethDuckDuck: 309 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O.xyz = iResolution; \n    u = floor((sqrt(iTime) * 3. + 1.) * (u + u - O.xy) / O.y);\n\n    int I = int(u),\n        J = int(u.y),\n        K = 4*J*J,\n        L = 4*I*I,\n        m = I > 0 && I == -J ? K - 4*J :     // squares diagonal - bottom right\n            I > abs(J)       ? L - 3*I + J : // right region\n            J > abs(I)       ? K - I - J :   // top region\n            J > I            ? L - I - J :   // left region\n                               K + I - 3*J;  // bottom region\n\n    float p = float(m + 1 - int(iTime * 30.)) / 40.,\n          n = fract(p);\n    \n    O = p < .025 ? n > 0. ? abs(cos((p-n)*vec4(5, 2, 6, 0)))*n\n                          : O/O\n                 : O-O;\n}\n/**/\n\n// Original: 350 chars\n/*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy, \n         U = floor((sqrt(iTime) * 3. + 1.) * (u + u - R) / R.y);\n\n    int I = int(U.x),\n        J = int(U.y),\n        K = 4*J*J,\n        L = 4*I*I,\n        m = I > 0 && I == -J     ? K - 4*J + 1 :     // squares diagonal - bottom right\n            I > 0 && I >= abs(J) ? L - 3*I + J + 1 : // right region\n            J > 0 && J >= abs(I) ? K - I - J + 1 :   // top region\n            I < 0 && J >= I      ? L - I - J + 1 :   // left region\n                                   K + I - 3*J + 1;  // bottom region\n                                   \n    float p = float(m - int(iTime * 30.)) / 40.,\n          n = fract(p);\n    \n    O = p < .025 ?\n            n == 0. ?\n                vec4(1) :\n                abs(cos(floor(p) * vec4(5, 2, 6, 0))) * n :\n            vec4(0);\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVBDG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[747, 845, 881, 881, 1531]], "test": "untested"}
{"id": "3dV3WK", "name": "dalp Flat Clouds", "author": "dalp", "description": "stepped clouds.  or something.", "tags": ["clouds"], "likes": 10, "viewed": 215, "published": 3, "date": "1698621422", "time_retrieved": "2024-07-30T17:25:23.878012", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\nconst float LEVELS = 12.;\n\nfloat N21 (vec2 p) {\n    return fract(sin(p.x*122.+p.y*52453.)*244156.); // returns a single randomish number based on a coord input\n}\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n\ta += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat SmoothNoise(vec2 uv) {\n \tvec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv,float d) {\n    float c;\n    float uvscale = 4.;\n    float detail = 1.;\n    for (float i=1.;i<=d;i++) {\n    \tc += SmoothNoise(uv*uvscale)*detail;\n        detail *= 0.5;\n        uvscale *= 2.;\n    }\n    return c/1.3;;\n}\n\nfloat GetClouds(vec2 uv, float t, float d) {\n    float speed = sin(t)*.5+.5;\n    // put a thing in here so that whenever the mix is fully one way or another, the 'hidden' one changes\n    float pitime = floor((t - (3.141*.5)) / 6.282);\n    float pitime2 = floor((t - (3.141*1.5)) / 6.282);\n    vec2 offs = vec2(-2.,-2.);\n    vec2 target1 = uv+(offs*pitime);\n    vec2 target2 = uv+vec2(11.,22.)+(offs*pitime2);\n    \n    // pull two noise maps\n    float c1 = SmoothNoise2(target1, d);\n    float c2 = SmoothNoise2(target2, d);\n    float c = mix(c1,c2,speed);                 \n\t\n    c = floor(c*LEVELS)/LEVELS;\n    \n    return c;\n}\n\n// a lot of help here from https://www.shadertoy.com/view/XdyXz3\n// mostly for a better version of the stepping/depth mechanic, and the bevelling trick\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*1.+m.x+(m.y*4.);\n    vec2 offset = vec2(sin(t)*0.006,cos(t)*0.006);\n    vec3 col = vec3(0.);\n    \n    uv += iTime*0.02;  // slow diagonal move\n\tfloat detail = 5.; // 1-6 working range\n\n    // Spin that shit ( a little bit )\n    float si = sin(t*.02);\n    float co = cos(t*.02);\n    mat2 rot = mat2(co,-si,si,co);\n    uv *= rot;\n    \n    //if (mod(iTime,3.)<.5) detail -= 2.;\n    \n    float c = GetClouds(uv,t,detail);\n    float edge = GetClouds(uv+offset,t,detail);\n    \n    //calc HSV color (taken from https://www.shadertoy.com/view/XdyXz3)\n    float h = c*.9 - .2; //rainbow hue\n    float s = 0.5;\n    float v = 0.9 - ( c*(detail*.13) ); //deeper is darker\n    \n    v -= c-edge;\n    \n    col = hsv2rgb(vec3(h,s,v));\n \n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dV3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 82, 82, 196], [198, 198, 216, 216, 339], [341, 341, 362, 362, 531], [533, 533, 561, 561, 871], [873, 873, 910, 910, 1117], [1119, 1119, 1163, 1163, 1745], [1900, 1900, 1957, 1957, 2833]], "test": "untested"}
{"id": "Ws3XRN", "name": "dalp Halftone zoomer", "author": "dalp", "description": "halftones, although not very good.", "tags": ["halftone"], "likes": 8, "viewed": 350, "published": 3, "date": "1698621347", "time_retrieved": "2024-07-30T17:25:24.729734", "image_code": "float Xor(float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n\n    float a = sin(iTime);//*0.26;\n    float s = sin(a+iTime*0.03*sin(-iTime)*0.001);\n    float c = cos(a+iTime*0.1);\n    uv *= mat2(c,-s,s,c);\n    \n    uv *= 32.;\n    vec2 gv = fract (uv)-.5;\n    vec2 id = floor (uv);\n    \n    float d = length(gv);\n    float m = 0.;\n    float t = iTime;\n    \n    for(float y=-1.;y<=1.;y++) {\n\t    for(float x=-1.;x<=1.;x++) {\n        \tvec2 offs = vec2(x,y);\n            \n    \t\tfloat d = length(gv-offs);\n    \t\tfloat dist = length(id+offs)*.1;\n           \n            float r = mix(.02, 1., sin(dist-(t*2.))*.5+.5);\n            m += smoothstep(48./iResolution.y,0., d-r); \n            //m = Xor(m, smoothstep(r,r*.95, d));\n        }    \n    }\n   \n    col += m;    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3XRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 63], [69, 69, 126, 126, 938]], "test": "untested"}
{"id": "DsVfWy", "name": "Infinity Rainbow Circles", "author": "bartus131313", "description": "Infinity rainbow circles", "tags": ["rainbow", "infinity", "cricles"], "likes": 7, "viewed": 222, "published": 3, "date": "1698612584", "time_retrieved": "2024-07-30T17:25:25.568491", "image_code": "vec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float d = length(uv);\n    \n    vec3 col = palette(d + iTime);\n    \n    d = sin(d * 8. - iTime) / 8.;\n    d = abs(d);\n    \n    d = 0.02 / d;\n    \n    col *= d;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 221], [223, 223, 280, 330, 623]], "test": "untested"}
{"id": "DsVBWy", "name": "Graph: f(x) = x ", "author": "kalisina", "description": "Graph of f(x) = x", "tags": ["beginner", "maths", "fxxgraph"], "likes": 2, "viewed": 137, "published": 3, "date": "1698609554", "time_retrieved": "2024-07-30T17:25:26.409243", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float lineWidth = 0.01;\n    \n    vec3 col = vec3(smoothstep(2.0 / iResolution.y, 0.0, abs(uv.x - uv.y) - lineWidth));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 342]], "test": "untested"}
{"id": "DdVfWG", "name": "Chess board transition", "author": "INCHMAN1900", "description": "Chess board like transition.", "tags": ["fractal", "animation"], "likes": 4, "viewed": 167, "published": 3, "date": "1698603498", "time_retrieved": "2024-07-30T17:25:27.216086", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y * 2.;\n\n    vec3 col = vec3(0.);\n    float index = 0.;\n    \n    uv = fract(uv) * 2.;\n    index += step(1., uv.y) * 2.;\n    index += step(1., uv.x);\n    \n    float p = mod(iTime, 2.);\n    if (index == 0.) {\n      col = vec3(step(p, uv.y));\n    } else if (index == 3.) {\n      col = vec3(step(p, 1. - fract(uv.y)));\n    } else if (index == 2.) {\n      col = 1. - vec3(step(p, uv.x));\n    } else {\n      col = 1. - vec3(step(p, 1. - fract(uv.x)));\n    }\n    \n    if (mod(iTime, 4.) > 2.) {\n        col = 1. - col;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 671]], "test": "untested"}
{"id": "cdKBWG", "name": "Decodering", "author": "leon", "description": "inspired by Ryoiji Ikeda and Evangelion", "tags": ["text", "code", "matrix"], "likes": 102, "viewed": 2181, "published": 3, "date": "1698600652", "time_retrieved": "2024-07-30T17:25:27.968075", "image_code": "\n// Decodering\n// Leon Denise 2023-10-29\n// inspired by Ryoiji Ikeda and Evangelion\n\n// 2023-10-31: updated code from Fabrice Neyret suggestions\n\n// Blackle Mori\n// https://suricrasia.online/blog/shader-functions/\n#define erot(p,A,a) mix(dot(A, p)*A, p, cos(a)) + cross(A,p)*sin(a)\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    color = vec4(0,0,0,1);\n    \n    // coordinates\n    vec2 p = (pixel-iResolution.xy/2.)/iResolution.y;\n    \n    // perspective\n    vec3 q = vec3(p, 1.);\n    q = erot(q, vec3(1,1,1), -.5);\n    p = q.xy/q.z;\n    \n    // scroll\n    p.y += iTime*.1;\n    \n    // grid\n    float grid = 16.;\n    vec2 cell = floor(p*grid);\n    \n    // column animation\n    float mask = floor(iTime*hash11(cell.x));\n    mask = step(.5,sin(mask));\n    float speed = 40.*hash11(cell.x+75.);\n    cell.y += floor(iTime*speed)*mask;\n    \n    // random per cell\n    vec2 rng = hash22(cell);\n    \n    // character selection\n    int char = int(iTime * rng.x);\n    int grd = int(grid);\n    char = (char % 50)+145;\n    vec2 offset = vec2(char%grd, char/grd);\n    \n    // atlas coordinates\n    p = mod(p, 1./grid);\n    p += offset/grid;\n    vec4 map = textureLod(iChannel0, p, 1.5/q.z);\n    \n    // color\n    bool colorful = sin(rng.y*6.+iTime) > 0.5;\n    if (colorful)\n    {\n        color.rgb = .5+.5*cos(vec3(0,2,4)+floor(cell.y*.1));\n        color.rgb *= 1.-map.r;\n    }\n    else\n    {\n        color.rgb = vec3(map.r);\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[283, 340, 363, 363, 448], [449, 449, 470, 470, 603]], "test": "untested"}
{"id": "dsVBRd", "name": "Alien Xor Carpet", "author": "domrally", "description": "My 1st attempt at an XOR pattern roller! Bits representing coordinates are XOR'd then Modulo'd by 3 prime numbers.\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "pixel", "alien", "xor", "tile", "bit", "mosaic", "carpet", "tweet", "diagram", "bitwise", "circuit", "roller", "bitfield"], "likes": 10, "viewed": 224, "published": 3, "date": "1698591258", "time_retrieved": "2024-07-30T17:25:28.719067", "image_code": "/*\nby Dom Mandy in 2023\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    int x = int(i /= 6.) ^ int(i.y + 4. * iTime);\n\n    o = 1. - vec4(x%5, x%7, x%3, 0) / (4. - 3. * cos(iTime));\n}\n\n\n/*\nREFERENCES\n\nXor 2023\nhttps://www.shadertoy.com/view/dsyBDy\n\nSnoopethDuckDuck 2023\nhttps://www.shadertoy.com/view/dsVyWc\n\nVirgill 2023\nhttps://www.shadertoy.com/view/DddBWr\n\npizzahollandaise 2023\nhttps://www.shadertoy.com/view/cdKczW\n\nminghir 2023\nhttps://www.shadertoy.com/view/DscyRf\n\nfelipecsl 2023\nhttps://www.shadertoy.com/view/mtV3Dd\n\nscudly 2022\nhttps://www.shadertoy.com/view/NlyfRm\n\nhoskillua 2022\nhttps://www.shadertoy.com/view/ss3yWl\n\ntk87 2022\nhttps://www.shadertoy.com/view/fsyyRR\n\nrast1234 2022\nhttps://www.shadertoy.com/view/fd2fD1\n\n_JZ 2021\nhttps://www.shadertoy.com/view/sdVGWV\n\nhikiko 2021\nhttps://www.shadertoy.com/view/fs33R4\n\nntnl 2021\nhttps://www.shadertoy.com/view/Nsy3zm\n\nmetabog 2021\nhttps://www.shadertoy.com/view/sdfXRl\n\nthope 2021\nhttps://www.shadertoy.com/view/fslSWr\n\nDJDoomz 2020\nhttps://www.shadertoy.com/view/wdtyDX\n\nChris_M_Thomasson 2020\nhttps://www.shadertoy.com/view/wlXcRM\n\nFabriceNeyret2 2020\nhttps://www.shadertoy.com/view/3tXcz4\n\noO0 2018\nhttps://www.shadertoy.com/view/WdfGD4\n\npython273 2018\nhttps://www.shadertoy.com/view/4ldyW8\n*/\n\n\n/*\nFURTHER READING\n\ninteger patterns\nhttps://en.wikipedia.org/wiki/XOR_gate\nhttps://en.wikipedia.org/wiki/Exclusive_or\nhttps://en.wikipedia.org/wiki/Bitwise_operation#XOR\n\npattern size\nhttps://en.wikipedia.org/wiki/Coprime_integers\nhttps://en.wikipedia.org/wiki/Modular_arithmetic\nhttps://en.wikipedia.org/wiki/Modulo#In_programming_languages\n\ncolor mapping\nhttps://en.wikipedia.org/wiki/Versine\nhttps://en.wikipedia.org/wiki/Subtractive_color\nhttps://en.wikipedia.org/wiki/Relative_luminance\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 63, 63, 178]], "test": "untested"}
{"id": "ddGfWG", "name": "Big Momavirus 2", "author": "dr2", "description": "Especially for the tunnel-obsessed Covid phobics; updated for evolving virus - mouseable (see \"Corona Time\" for how long this has been going on)", "tags": ["voronoi", "tunnel", "texture", "heightmap", "virus"], "likes": 14, "viewed": 229, "published": 3, "date": "1698584442", "time_retrieved": "2024-07-30T17:25:29.646587", "image_code": "// \"Big Momavirus 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorus4Df (vec3 p, float ri, float rc);\nvec3 SphFib (vec3 v, float n);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\nvec4 LoadTx (vec2 uv);\n\nvec3 ltDir, vbalPos;\nvec2 trkFx, trkFy, trkAx, trkAy, trkFw, trkAw;\nfloat dstFar, tCur, tunRad, lmpSep, txOrg, txAsp, vbalSpn, vbalDir, qSpk;\nint nFrame, idObj;\nconst int idWal = 1, idFlr = 2, idLmp = 3, idArch = 4, idRail = 5, idTie = 6,\n   idVbal = 7, idVspk = 8, idVcap = 9;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 TrackPos (float z)\n{\n  return vec3 (dot (trkAx, sin (trkFx * z)), dot (trkAy, sin (trkFy * z)), z);\n}\n\nvec3 TrackVel (float z)\n{\n  return normalize (vec3 (dot (trkAx, trkFx * cos (trkFx * z)),\n     dot (trkAy, trkFy * cos (trkFy * z)), 1.));\n}\n\nfloat TSurfHt (vec2 tc)\n{ // heightmap constructed in Buff A\n  return LoadTx (tc * txAsp).x;\n}\n\nfloat RdTun (vec3 p)\n{\n  float a, rh;\n  a = 0.5 * (atan (- p.x, p.y) / pi + 1.);\n  rh = TSurfHt (vec2 ((p.z - txOrg) / (2. * pi * tunRad), a));\n  return tunRad + dot (trkAw, sin (trkFw * p.z)) -\n     rh * (1. - 0.5 * smoothstep (0.5, 1., p.y / tunRad));\n}\n\nfloat TunDf (vec3 p)\n{\n  vec3 q;\n  vec2 rt;\n  float dMin, d;\n  dMin = dstFar;\n  p.xy -= TrackPos (p.z).xy;\n  d = RdTun (p) - length (p.xy);\n  DMIN (idWal);\n  d = (0.82 - 0.02 * p.x * p.x) * tunRad + p.y;\n  DMIN (idFlr);\n  return 0.5 * dMin;\n}\n\nfloat TunRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = TunDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TunNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 0.1 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TunDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat VbalDf (vec3 p, float dMin)\n{\n  vec3 q, qn, uf;\n  float d, rad, len, h, sbFac;\n  sbFac = 1.65;\n  dMin /= 0.6 * sbFac;\n  q = p / sbFac;\n  rad = 1.;\n  qn = normalize (q);\n  uf = SphFib (qn, 120.);\n  d = PrSphDf (q, rad * (1. - 0.05 * smoothstep (0.1, 0.2, length (qn - uf))));\n  DMIN (idVbal);\n  q = RotToDir (uf, vec3 (0., 0., 1.), q - uf);\n  h = Hashfv3 (41. * uf);\n  len = 0.3 * (1. - 0.2 * h);\n  q.z -= len;\n  d = PrCylDf (q, 0.05 * (1. - 0.1 * q.z / len), len);\n  if (d < dMin) qSpk = h;\n  DMIN (idVspk);\n  q.z -= len + 0.05;\n  q.xy = Rot2D (q.xy, pi * (h / 3. + 0.2 * tCur * sign (h - 0.5)));\n  q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 0.08;\n  d = PrSphDf (q * vec3 (1., 1., 1.3), 0.1);\n  DMIN (idVcap);\n  return 0.6 * sbFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d;\n  dMin = dstFar;\n  qq = p;\n  qq.xy -= TrackPos (qq.z).xy;\n  q = qq;\n  d = length (max (abs (vec2 (abs (q.x) - 0.7, q.y + 0.82 * tunRad)) -\n      vec2 (0.06, 0.25), 0.));\n  DMIN (idRail);\n  q.y -= -0.82 * tunRad - 0.05;\n  q.z = mod (q.z + 1., 2.) - 1.;\n  d = PrBoxDf (q, vec3 (0.9, 0.2, 0.1));\n  DMIN (idTie);\n  q = qq;\n  q.z = mod (q.z + lmpSep, 2. * lmpSep) - lmpSep;\n  d = 0.8 * PrTorus4Df (q, 0.16, tunRad - 0.18) - 0.15 *\n     (0.5 + 0.5 * sqrt (abs (sin (15. * atan (q.y, q.x)))));\n  DMIN (idArch);\n  q.y -= tunRad - 0.4;\n  d = PrSphDf (q, 0.3);\n  DMIN (idLmp);\n  q = p - vbalPos;\n  d = PrSphDf (q, tunRad - 0.9);\n  if (d < 0.1) {\n    q.yz = Rot2D (q.yz, vbalSpn);\n    q.xz = Rot2D (q.xz, vbalDir);\n    dMin = VbalDf (q, dMin);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 0.001 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, q, u;\n  vec2 vf;\n  int idObjT;\n  float dstObj, dstTun, dFac, s, att;\n  col = vec3 (0.);\n  dstTun = TunRay (ro, rd);\n  idObjT = idObj;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstTun, dstObj) < dstFar) {\n    if (dstTun < dstObj) {\n      dstObj = dstTun;\n      idObj = idObjT;\n    }\n    ro += dstObj * rd;\n    if (dstObj == dstTun) {\n      vn = TunNf (ro);\n      dFac = (1. - smoothstep (0.2, 0.5, dstObj / dstFar));\n      q.xy = TrackPos (ro.z).xy;\n      ro.xy -= q.xy;\n      if (idObj == idWal) {\n        u = vec3 (2. * pi * tunRad * (atan (ro.y, - ro.x) / (2. * pi) + 0.5), 4. * length (ro.xy), ro.z);\n        vn = VaryNf (4. * u, vn, 4. * dFac * dFac * (1. - 0.5 * smoothstep (0.7, 1., - vn.y)));\n        s = Fbm3 (4. * u);\n        col4 = vec4 (mix (vec3 (0.4, 0.4, 0.45), vec3 (0.45, 0.4, 0.35),\n           smoothstep (0.3, 0.6, s)), 0.);\n      } else if (idObj == idFlr) {\n        s = dFac * (1. - smoothstep (-0.2, -0.1, dot (rd, vn)));\n        vn = RippleNorm (ro.zx, vn, 6. * s);\n        vn = VaryNf (16. * ro, vn, s);\n        col4 = vec4 (vec3 (0.5, 0.35, 0.2) * (1. - 0.2 * smoothstep (0.4, 0.85,\n           length (vec2 (ro.x, mod (ro.z + lmpSep, 2. * lmpSep) - lmpSep)) / tunRad)), 0.);\n      }\n      ro.xy += q.xy;\n    } else {\n      q = ro - vbalPos;\n      vn = ObjNf (ro);\n      if (idObj >= idVbal) {\n        q.yz = Rot2D (q.yz, vbalSpn);\n        q.xz = Rot2D (q.xz, vbalDir);\n      }\n      if (idObj == idLmp) {\n        col4 = vec4 (vec3 (1., 1., 0.7) * 0.5 * (1. - vn.y), -1.);\n      } else if (idObj == idRail) {\n        col4 = vec4 (0.6, 0.6, 0.65, 0.3);\n      } else if (idObj == idTie) {\n        col4 = vec4 (0.4, 0.3, 0., 0.);\n      } else if (idObj == idArch) {\n        col4 = vec4 (0.3, 0.3, 0.3, 0.05);\n        vn = VaryNf (32. * ro, vn, 2.);\n      } else if (idObj == idVbal) {\n        col4 = vec4 (0.5, 0.5, 0.1, 0.1);\n        vf = vec2 (8., 8.);\n      } else if (idObj == idVspk) {\n        col4 = vec4 (HsvToRgb (vec3 (qSpk, 0.7, 0.7)), 0.2);\n        vf = vec2 (64., 0.1);\n      } else if (idObj == idVcap) {\n        col4 = vec4 (HsvToRgb (vec3 (qSpk, 1., 1.)), 0.3);\n        vf = vec2 (64., 2.);\n      }\n      if (idObj >= idVbal) {\n        if (idObj == idVbal) col4.rgb = mix (col4.rgb, 1.5 * vec3 (0.2, 1., 0.2),\n           SmoothBump (0.45, 0.55, 0.005, mod (0.7 * tCur, 1.)));\n        else col4.rgb = mix (col4.rgb, 1.5 * vec3 (1., 1., 0.9),\n           SmoothBump (0.49, 0.51, 0.005, mod (0.5 * length (q) - 0.7 * tCur, 1.)));\n        vn.yz = Rot2D (vn.yz, vbalSpn);\n        vn.xz = Rot2D (vn.xz, vbalDir);\n        vn = VaryNf (vf.x * q, vn, vf.y);\n        vn.xz = Rot2D (vn.xz, - vbalDir);\n        vn.yz = Rot2D (vn.yz, - vbalSpn);\n      }\n      if (col4.a >= 0.) col4.rgb *= (1. - 0.4 * smoothstep (0.4, 0.85,\n         abs (mod (ro.z + lmpSep, 2. * lmpSep) - lmpSep) / tunRad));\n      else col = col4.rgb;\n    }\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, ltDir), 0.) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n    if (idObj == idFlr || idObj == idRail || idObj == idTie || idObj == idWal) {\n      col *= 1. + 0.6 * vec3 (0.3, 1., 0.3) * SmoothBump (-0.01, 0.01, 0.005,\n         abs (fract (0.01 * (ro.z - 20. * tCur)) - 0.5) - 0.25);\n      if (idObj == idWal) col += 1.5 * vec3 (1., 1., 0.5) *\n         pow (max (dot (reflect (rd, vn), ltDir), 0.), 256.);\n      else col *= 0.8 + 0.2 * smoothstep (0., 0.5, length (ro.xz - vbalPos.xz) - 2.);\n    }\n    att = SmoothMin (350. / (dstObj * dstObj), 1., 0.5) * (1. - smoothstep (60., 70., dstObj));\n    col *= att;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, vd;\n  vec2 uv;\n  float el, az, tunPos, zmFac, t;\n  nFrame = iFrame;\n  uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  stDat = Loadv4 (vec2 (0., 0.));\n  tunPos = stDat.y;\n  txOrg = stDat.z;\n  txAsp = stDat.w;\n  stDat = Loadv4 (vec2 (1., 0.));\n  tunRad = stDat.y;\n  az = stDat.z;\n  el = stDat.w;\n  stDat = Loadv4 (vec2 (2., 0.));\n  tCur = stDat.y;\n  trkFx = 2. * pi * vec2 (0.005, 0.0087);\n  trkAx = tunRad * vec2 (2.2, 1.7);\n  trkFy = 2. * pi * vec2 (0.017, 0.0227);\n  trkAy = tunRad * vec2 (0.13, 0.07);\n  trkFw = 2. * pi * vec2 (0.05, 0.028);\n  trkAw = tunRad * vec2 (0.07, 0.04);\n  vd = TrackVel (tunPos);\n  az += 0.5 * pi + atan (- vd.z, vd.x);\n  el += asin (vd.y) - 0.02 * pi;\n  zmFac = 3.5 - 0.5 * SmoothBump (0.3, 0.7, 0.1, abs (az) / pi);\n  t = tunPos + tunRad * sign (0.5 * pi - abs (az)) * (4. + clamp (6. * (Fbm1 (0.02 * tCur) - 0.5),\n     -2.5, 2.5));\n  vbalPos = TrackPos (t);\n  vd = TrackVel (t);\n  vbalDir = -0.5 * pi - atan (vd.z, - vd.x);\n  vbalSpn = -0.5 * pi * tCur;\n  vuMat = StdVuMat (el, az);\n  ro = TrackPos (tunPos) + vuMat * vec3 (0., 0.1, - 0.5) * tunRad;\n  dstFar = 100.;\n  lmpSep = 10.;\n  ltDir = vuMat * normalize (vec3 (0., 0.5, -1.));\n  rd = vuMat * normalize (vec3 (uv , zmFac));\n  rd.zx = Rot2D (rd.zx, 0.1 * atan (ro.x));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorus4Df (vec3 p, float ri, float rc)\n{\n  vec2 q;\n  q = vec2 (length (p.xy) - rc, p.z);\n  q *= q;\n  return sqrt (sqrt (dot (q * q, vec2 (1.)))) - ri;\n}\n\nvec3 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (mod (dot (p, vec3 (37., 39., 41.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (mod (p + vec2 (0., 1.), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (mod (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y),\n     2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Big Momavirus 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n\n/*\n Tunnel surface heightmap based on hexagonal Voronoi subdivision;\n scrolling (nonrepeating) heightmap stored in continually updated texture.\n Run in fullscreen mode to get highest resolution texture.\n (From \"Scrolling Texture Heightmap\")\n*/\n\nfloat SmoothMin (float a, float b, float r);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec2 gVec[7], hVec[7];\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat TSurfHt (vec2 tc)\n{\n  vec4 vc;\n  vc = HexVor (tc);\n  return max (0.3 * SmoothMin (0.4, 0.3 * vc.x, 0.1) * (1. - 0.3 * dot (vc.yz, vc.yz)) *\n     (1. + 2.5 * vc.w), 0.);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, dateCur;\n  vec2 canvas, pxIv;\n  float tCur, tBgn, az, el, tunRad, tunPos, s, si, txOrg, txAsp;\n  int nFrame;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pxIv = floor (fragCoord);\n  txAsp = 3./8.;\n  if (pxIv.x >= txSize.x || pxIv.y >= txAsp * txSize.x) discard;\n  if (nFrame <= 1) tBgn = mod (floor (337. * dateCur.w), 3600.);\n  else tBgn = Loadv4 (vec2 (2., 0.)).z;\n  tCur = mod (tCur, 3600.) + tBgn;\n  az = 0.;\n  if (mod (tCur, 50.) < 25.) az += pi;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = mod (az + pi + 2. * pi * mPtr.x, 2. * pi) - pi;\n    el = clamp (el + 0.5 * pi * mPtr.y, -0.1 * pi, 0.1 * pi);\n  }\n  tunRad = 4.;\n  tunPos = 6. * tCur;\n  HexVorInit ();\n  txOrg = tunPos;\n  s = 2. * pi * tunRad / txAsp;\n  if (abs (az) > 0.6 * pi) txOrg -= s - tunRad;\n  else if (abs (az) > 0.4 * pi) txOrg -= 0.5 * s;\n  else txOrg -= tunRad;\n  si = txSize.x / (2. * s);\n  txOrg = floor (txOrg * si) / si;\n  stDat = vec4 (TSurfHt (2. * ((s * pxIv / txSize + vec2 (txOrg, 0.)))), 0., 0., 0.);\n  if (pxIv.y == 0.) {\n    if (pxIv.x == 0.) stDat.yzw = vec3 (tunPos, txOrg, txAsp);\n    else if (pxIv.x == 1.) stDat.yzw = vec3 (tunRad, az, el);\n    else if (pxIv.x == 2.) stDat.yzw = vec3 (tCur, tBgn, 0.);\n  }\n  Savev4 (pxIv, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.8;\n  p = p.yx;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGfWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1100, 1100, 1125, 1125, 1206], [1208, 1208, 1233, 1233, 1348], [1350, 1350, 1375, 1410, 1444], [1446, 1446, 1468, 1468, 1701], [1703, 1703, 1725, 1725, 1945], [1947, 1947, 1980, 1980, 2164], [2166, 2166, 2187, 2187, 2442], [2444, 2444, 2479, 2479, 3242], [3244, 3244, 3266, 3266, 4078], [4080, 4080, 4113, 4113, 4297], [4299, 4299, 4320, 4320, 4577], [4579, 4579, 4604, 4604, 4983], [4985, 4985, 5029, 5029, 5218], [5220, 5220, 5255, 5255, 8887], [8889, 8889, 8945, 8945, 10331], [10333, 10333, 10365, 10365, 10465], [10467, 10467, 10500, 10500, 10527], [10529, 10529, 10571, 10571, 10622], [10624, 10624, 10671, 10671, 10783], [10785, 10785, 10816, 10873, 11709], [11711, 11711, 11756, 11756, 11848], [11850, 11850, 11907, 11907, 11990], [11992, 11992, 12028, 12028, 12234], [12236, 12236, 12278, 12278, 12434], [12436, 12436, 12466, 12466, 12579], [12581, 12581, 12605, 12605, 12727], [12761, 12761, 12785, 12785, 12865], [12867, 12867, 12891, 12891, 12959], [12961, 12961, 12985, 12985, 13112], [13114, 13114, 13138, 13138, 13301], [13303, 13303, 13328, 13328, 13474], [13476, 13476, 13501, 13501, 13685], [13687, 13687, 13712, 13712, 13937], [13939, 13939, 13961, 13961, 14115], [14117, 14117, 14138, 14138, 14293], [14295, 14295, 14316, 14316, 14471], [14473, 14473, 14502, 14502, 14714], [14716, 14716, 14755, 14755, 15007], [15074, 15074, 15097, 15097, 15129], [15131, 15131, 15155, 15155, 15205]], "test": "untested"}
{"id": "DsGBDy", "name": "angle in [0, 2pi)", "author": "beans_please", "description": "the", "tags": ["atan", "angle"], "likes": 3, "viewed": 122, "published": 3, "date": "1698577359", "time_retrieved": "2024-07-30T17:25:30.393590", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = .5 + .5 * cos(iTime+uv.xyx+vec3(0, 2, 4));\n    \n    float a = atan(uv.y, uv.x);\n    if (a < 0.)\n        a += 6.2831853;\n    \n    col *= a / 6.2831853;\n    \n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 384]], "test": "untested"}
{"id": "cdGfDG", "name": "Cell Expansion", "author": "INCHMAN1900", "description": "Cell expansion under microscope", "tags": ["noise", "cell"], "likes": 2, "viewed": 145, "published": 3, "date": "1698569036", "time_retrieved": "2024-07-30T17:25:31.146577", "image_code": "// Simplex Noise from The Book of Shaders.\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n// transition duration\nfloat td = 6.;\n\nvec3 cell(vec2 uv) {\n    float t = fract(iTime / td);\n    float s = snoise(uv * 30. + iTime) * .01;\n    float r = (exp(t) - 1.) / (exp(1.) - 1.) * .8 + s * log(t + 1. + exp(1.));\n    return vec3(step(r, length(uv)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = cell(fract(uv) - .5);\n    if (mod(iTime / td, 2.) > 1.) {\n        col = 1. - col;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 89, 89, 136], [137, 137, 158, 158, 205], [206, 206, 228, 228, 263], [265, 265, 287, 340, 2037], [2078, 2078, 2098, 2098, 2296], [2298, 2298, 2355, 2355, 2598]], "test": "untested"}
{"id": "dsVfzd", "name": "PolyRefraction Parallax || P=NP", "author": "ElSolem", "description": "Test of the simple parrallax thingy. It applies the symbol equation for calculating parallax. Biconvex Parallax, and Biconcave Parallax. It calculates the line through an Abs(0) and then plots points around it. It starts at 1 and increases exponentially. ", "tags": ["simple", "parallax", "fun", "polyrefraction", "biconvex", "biconcave"], "likes": 5, "viewed": 163, "published": 3, "date": "1698554970", "time_retrieved": "2024-07-30T17:25:31.896571", "image_code": "vec3 palette(float d) {\n    return mix(vec3(0.1, 0.94, 0.98), vec3(1., 0., 1.), d);\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n    for (int i = -5; i < 25; ++i) {\n        float t = iTime * -0.314;\n        p.xz = rotate(p.xz, t);\n        p.xy = rotate(p.xy, t * 1.50);\n        p.xz = abs(p.xz);\n        p.xz -= 0.12;\n    }\n    return dot(sign(p), p) / 1.;\n}\n\nbool Alakazan(float value1, float value2) {\n    return (value1 == value2) || (value1 != value2);\n}\n\nvec4 rm(vec3 ro, vec3 rd) {\n    float t = 20.;\n    vec3 col = vec3(0.0);\n    float d;\n    for (float i = 3.; i < 270.; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p) * 0.3;\n        if (d < 0.02) {\n            break;\n        }\n        if (d > 30.) {\n            break;\n        }\n        // col += vec3(2.64, 0.8, 0.8) / (400. * (d));\n        col += palette(length(p) * 0.1) / (400. * (d));\n        t += d;\n    }\n    return vec4(col, 1. / (d * 100.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Convert pixel coordinates to a normalized range (-1 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // Calculate the value of xy using your equation\n    float xy = p.x / p.y;\n\n    // Define a threshold for plotting the point\n    float threshold = 2.0;\n\n    // Alakazan logic\n    bool alakazanResult = Alakazan(xy, threshold);\n\n    // Check if xy is within the threshold to plot the point\n    if (alakazanResult) {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.)) / iResolution.x;\n        vec3 ro = vec3(0., 0., 50.);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0., 8., 0.)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3. + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    } else {\n        vec2 uv = (fragCoord - (iResolution.xy / 2.)) / iResolution.x;\n        vec3 ro = vec3(0., 0., 50.);\n        ro.xz = rotate(ro.xz, iTime);\n        vec3 cf = normalize(-ro);\n        vec3 cs = normalize(cross(cf, vec3(0., 8., 0.)));\n        vec3 cu = normalize(cross(cf, cs));\n\n        vec3 uuv = ro + cf * 3. + uv.x * cs + uv.y * cu;\n\n        vec3 rd = normalize(uuv - ro);\n\n        vec4 col = rm(ro, rd);\n\n        fragColor = col;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 85], [87, 87, 117, 117, 197], [199, 199, 218, 218, 448], [450, 450, 493, 493, 548], [550, 550, 577, 577, 1010], [1012, 1012, 1067, 1132, 2433]], "test": "untested"}
{"id": "mdKBzd", "name": "raymarching tri reps", "author": "chenxianming", "description": "somewhere i set metal light map, but in here i said \"turn on the light!\"\ndesigned for the LiJiYong studios ( lijiyong.com )", "tags": ["wave", "triangle", "cineshader"], "likes": 11, "viewed": 739, "published": 3, "date": "1698546950", "time_retrieved": "2024-07-30T17:25:32.641580", "image_code": "#define I iResolution\n#define PI 3.1415926\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n#define T(a) fract(iTime * a) * PI * 4.\n#define v( a ) clamp( a, 0., 1. )\n\n// smax\nfloat sm(float a, float b, float c) {\n  float d = clamp(.5 + .5 * (-b + a) / c, 0., 1.);\n  return -(mix(-b, -a, d) - c * d * (1. - d));\n}\n\nfloat mExp( vec2 p1, vec2 p2, in vec2 uv ){\n    return ( uv.y - p2.y ) * ( p1.x - p2.x ) -( ( uv.x - p2.x ) * ( p1.y - p2.y ) );\n}\n// IQ\nfloat tri( in vec2 p, in float r, int invert )\n{\n    if( invert == 1 )\n        p.y *= -1.;\n        \n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvec2 rep( inout vec2 p, vec2 size)\n{\n\n    vec2 h = size * .5;\n    vec2 cell = floor((p + h) / size);\n    \n    p = mod(p + h, size) - h;\n    \n    return cell;\n}\n\nfloat frame( vec3 p, float h2, int inv ){\n    return sm(\n        max(\n            tri( p.xz, .4, inv ),\n            abs( p.y ) - h2\n        ),\n        -max(\n            tri( p.xz, .3, inv ),\n            abs( p.y ) - h2\n        ),\n        .03\n    );\n}\n\nfloat cu( vec3 p, float h1, float h2, int inv ){\n\n    return min(\n        sm(\n            tri( p.xz, .2, inv ),\n            abs( p.y ) - h1,\n            .05\n        ),\n        frame( p, h2, inv )\n    );\n}\n\nfloat c1( vec3 p ){\n\n    p.y += cos( p.x - T( .125 ) ) * .1;\n    p.y += sin( p.z - T( .125 ) ) * .1;\n    \n    p.xy *= rot( PI * .05 ),\n    p.yz *= rot( PI * -.3 );\n    p.z -= iTime * .3;\n    \n    vec2 cell = rep( p.xz, vec2( .85, 1.05 ) );\n\n    p.y += cos( abs( cell.x ) - T( .125 ) ) * .05;\n    p.y += sin( abs( cell.y ) - T( .125 ) ) * .05;\n\n    bool b = mod( cell.y, 1. ) == 0.;\n\n    return cu( p, b ? .1 : .2,  b ? .2 :.1, 0 );\n}\n\nfloat c2( vec3 p ){\n\n    p.y += cos( p.x - T( .125 ) ) * .1;\n    p.y += sin( p.z - T( .125 ) ) * .1;\n    \n    p.xy *= rot( PI * .05 ),\n    p.yz *= rot( PI * -.3 );\n    \n    p.z -= iTime * .3;\n    \n    vec3 p2 = p;\n    \n    // p2.z *= -1.;\n    p2.x += 0.43;\n    p2.z += .48;\n    \n\n    vec2 row = rep( p2.xz, vec2( .85, 1.05 ) );\n    \n    p2.y += cos( abs( row.x ) - T( .125 ) ) * .05;\n    p2.y += sin( abs( row.y ) - T( .125 ) ) * .05;\n    \n    \n    bool b2 = mod( row.x, 2. ) == 0.;\n    \n    return cu( p2, b2 ? .2 : .1,  b2 ? .1 :.2, 1 );\n}\n\nfloat df( vec3 p ){\n    \n    return min( c1( p ), c2( p ) );\n}\n\n// calcNormal (IQ)\nvec3 nrm(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nvec3 tex( vec3 p ){\n    p.xy *= rot( PI * -.1 );\n    p.x = mod( p.x, 4. ) - 3.;\n    float a = abs( p.x ) - 2.;\n    return vec3( cos( p.z / 2. + .5 ) * a, cos( a ) * sin( a ), cos( a ) );\n}\n\nfloat S( vec3 p, vec3 ca, vec3 r, float q ){\n    return v( pow( dot( nrm( p ), normalize( normalize( ca ) - r ) ), q ) );\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V * 2. - I.xy ) / min( I.x, I.y );\n    \n    vec3 c, p, o = vec3( 0., 0., -2. ), r = vec3( u * .9, 1. ), ca = vec3( 0., .7, 0. );\n    \n    \n    float t, d, i, g = 1. - smoothstep( 0., 1.2, length( u * vec2( .6, 1. ) ) - .1 );\n    \n    c += vec3( 1, 2, 3 ) * .1 * g;\n    \n    for( ; i < 64.; i++ )\n        p = o + r * t,\n        d = df( p ),\n        //ca.x = sin( p.x + cos( p.y ) ) * .1,\n        t += d * .66667;\n    \n    if( d < 1e-3 ){\n        \n        ca.x += cos( T( .125 ) ) * .5;\n        ca.z += sin( T( .125 ) ) * .5;\n        \n        float dif = max(dot(ca, nrm(p) ), 0.0);\n\n        c += pow( dif, 2. ) * vec3( .1, .3, .4 );\n        \n        // c += tex( reflect( nrm( p * .1 ), vec3( p.z / 2. + .5 ) ) ) * pow( dif, 12. );\n\n        // spot\n        ca.z += .5;\n        float ss = S( p, ca, r, 5. );\n        ss *= g;\n        c += clamp( ss, 0., .3 );\n        \n        vec3 a = vec3( 0., .5, 0. );\n        a.x += cos( T( .125 ) );\n    \n        float sss = S( p, a, r, 17. );\n        sss *= dif;\n        c += clamp( vec3( sin( T( .125 ) ), 1, 3 ) * .555 * sss, 0., .7 );\n        \n    }\n    \n    c = clamp( c, 0., .8 );\n\n    \n    \n    c = mix(\n        c,\n        vec3( 0. ),\n        smoothstep( 0., 1.6, length( u * vec2( .5, 1. ) + vec2( 0., .1 ) ) - .01 ) * cos( iTime * .25 )\n    );\n    \n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 182, 219, 219, 319], [321, 321, 364, 364, 451], [452, 458, 506, 506, 766], [768, 768, 804, 804, 927], [929, 929, 970, 970, 1179], [1181, 1181, 1229, 1229, 1385], [1387, 1387, 1406, 1406, 1820], [1822, 1822, 1841, 1841, 2363], [2365, 2365, 2384, 2384, 2427], [2429, 2448, 2469, 2469, 2665], [2667, 2667, 2686, 2686, 2855], [2857, 2857, 2901, 2901, 2980], [2982, 2982, 3023, 3073, 4429]], "test": "untested"}
{"id": "msKBzt", "name": "FluidLight Rays", "author": "jackjackdev", "description": "God rays spinoff", "tags": ["rays"], "likes": 10, "viewed": 174, "published": 3, "date": "1698539351", "time_retrieved": "2024-07-30T17:25:33.391574", "image_code": "// FluidLight Rays\n// Based off of a shader by Danilo Guanabara (@Danguafer on shadertoy)\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<100;i++) {\n\t\tvec2 uv,p=fragCoord.yx/r;\n\t\tuv=p;\n\t\tp-= uv.x + .1;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(cos(z)+1.)*(cos(l*50.-z));\n\t\tc[i]=.01/length(mod(uv,1.)-.5);\n\t}\n\tfragColor=vec4(c/l*1.,t*2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 189, 189, 439]], "test": "untested"}
{"id": "cdtfWS", "name": "Cube Animation", "author": "Shane", "description": "A keyframe-based 3D textured cube animation rendered in realtime.", "tags": ["raymarching", "cube", "map", "animation", "bump", "material", "traversal"], "likes": 84, "viewed": 1046, "published": 3, "date": "1698500050", "time_retrieved": "2024-07-30T17:25:34.503601", "image_code": "/*\n\n    Cube Animation\n    --------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 2.6, coc = .6;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// Standard 2D rotation formula.\n//mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    // Retrieving the stored color.\n    //vec4 col = texture(iChannel0, uv);\n\n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Cube Animation\n    --------------\n    \n    As the title says, this is a cube animation. :) This is not a Blender \n    quality rendering by any stretch of the imagination, but it does at least \n    convey that feel. I probably wouldn't recommend the realtime pixelshader \n    environment for producing these kinds of animations, but I wanted to show \n    that it was possible.\n    \n    The code in this particular example looks a little overblown, partly due to\n    the amount of \"define\" options I included. However, most of it is just an \n    application of a series of rudimentary tasks. At its core, this is a bunch\n    of grid cells containing some decorated cubes that follow an animated \n    pattern sequence. The flat shaded non-textured version with no compiler \n    options is much, much shorter. In fact, I might post that later.\n    \n    Rolling a cube along a floor in a straight line is a simple enough exercise. \n    If you're comfortable with 3D rotations about pivot points and keyframing, \n    then rolling it through four quadrants of a square floor cell requires just \n    a little more effort. Starting from random quadrants and direction changes \n    add some extra code but is also easy... Then there's texturing; That last \n    bit can take your nice neat code and turn it into a difficult-to-follow mess. :)\n\n    \n    \n\n\tSimilar examples:\n   \n\t// There are not a lot of rolling textured dice examples on Shadertoy, \n    // but here's one. \n    Dice Leaping - Dr2\n    https://www.shadertoy.com/view/3st3WS\n    \n    // Byt3_m3chanic puts together a lot of interesting examples.\n    Dice Game | Die Die Die - byt3_m3chanic\n    https://www.shadertoy.com/view/Nl23Rw\n    \n    // A die following a 3D path. Needs an overhaul. :)\n    Marching Die - Shane\n\thttps://www.shadertoy.com/view/3sVBDd\n \n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n////// Variable Defines /////\n\n// Scene color - White: 0, Primary Colors: 1, Green: 2, Pink and Purple: 3.\n#define COLOR 1\n\n// Cube pattern curve type.\n// Circle: 0, Square: 1, Diamond: 2, Octagon: 3, Dodecahedron: 4.\n#define CTYPE 3\n\n// Floor pattern curve type.\n// Circle: 0, Square: 1, Diamond: 2, Octagon: 3, Dodecahedron: 4.\n#define CTYPE2 3\n\n\n// Pattern Offset: Zero or One. Other numbers won't work.\n#define OFFS 0. // Only \"0.\" or \"1.\" will work.\n\n// Reverse the pattern.\n//#define REVERSE\n\n// Subdide the square cells, or not.\n#define SUBDIV\n\n// Surface displacement: No displacement, resulting in flat surfaces, bump mapping, \n// which is cheaper, but not quite as effective as the real thing, or distance\n// based displacement, which is more expensive but more convincing. \n//\n// The default settings are a compromise. I've displaced the cube the expensive\n// way, and the floor the cheap way, since there wasn't a discernible difference.\n//\n// No displacement: 0, Bump map: 1, Distance map: 2\n#define SURF_DISP_CUBE 2\n#define SURF_DISP_FLOOR 1\n\n// Global scene object scale. Kind of redundant here, considering the\n// eventual scale I chose... All that extra work for nothing. :)\n#define GSCALE 1.\n\n/////////////////////\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat svObjID, objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n \n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    \n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n// Cube face texturing -- Hacked together quickly, but it'll work.\nvec3 texCube(sampler2D iCh, in vec3 p, in vec3 n){\n\n    \n    // Use the normal to determine the face. Z facing normals \n    // imply the XY plane, etc.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n    \n    // Reusing \"p\" for the color read.\n    p = texture(iCh, p.xy).xyz;\n \n    // Rough conversion from sRGB to linear.\n    return p*p;\n\n}\n\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/8.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p, in vec3 sc){ \n    return sc.z/2.;\n    //return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); \n}\n\n\n//////////\n// Cube mapping - Adapted from one of Fizzer's routines. \nvec4 cubeMap(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n\n    /*\n    vec3 idF = step(0., p)*2. - 1.;\n    vec3 faceID = (idF + 1.)/2. + vec3(0, 2, 4);\n    */    \n    \n    // Integer version.\n    ivec3 idF = ivec3(step(0., p))*2 - 1;\n    ivec3 faceID = (idF + 1)/2 + ivec3(0, 2, 4);\n    \n    \n    return f.x>.5? vec4(p.yz/p.x, idF.x, faceID.x) : \n           f.y>.5? vec4(p.xz/p.y, idF.y, faceID.y) : vec4(p.xy/p.z, idF.z, faceID.z); \n}\n\nfloat dist(vec2 p, int type){\n\n    \n    if(type == 0) return length(p); // Circle.\n\n    p = abs(p);\n    if(type == 1) return max(p.x, p.y); // Square.\n    if(type == 2) return abs(p.x + p.y)*.7071; // Diamond.\n    if(type == 3) return max(max(p.x, p.y), abs(p.x + p.y)*.7071); // Octagon.\n    if(type == 4){    \n        // Dodecahedron.\n        vec2 p2 = p*.8660254 + p.yx*.5;\n        p = vec2(max(p2.x, p2.y), max(p.y, p.x));\n        return max(p.x, p.y);\n    }\n}\n\n// lev: Cube level. A value of 1 means its been subdivided.\nfloat getPat(vec2 p, vec2 sc, vec2 id, float fID, int type, int sm){\n   \n   //p *= 2.;\n   \n   //p *= GSCALE;  \n   \n \n   sc *= 2.;\n   //if(sm==0) sc /=2.;\n   \n   vec2 oID = floor(p/(sc/2.));\n   \n    \n   id = id + floor(p/(sc/2.))/2.;\n   p = mod(p, sc/2.) - sc/4.;\n   sc/=2.; \n   \n  \n   \n   id += fID/12.;\n    \n  \n   float rnd = hash21(id + .06);\n   if(rnd<.5) p = rot2(3.14159/2.)*p;\n\n   float tF = type == 2? .7071 : 1.;\n   float d = dist(p - sc/2., type) - sc.x/2.*tF;\n   d = min(d, dist(p + sc/2., type) - sc.x/2.*tF);\n   \n   //float d = abs(p.x + p.y)*.7071;\n   //float d = length(p - (vec2(hash21(id + .1), hash21(id + .2)) - .5)*sc/4.);\n   \n   if(mod(oID.x + oID.y, 2.)<.5) d = -d;\n   if(rnd<.5) d = -d;\n\n   \n   // Extra pattern flipping for the small cubes. The large has four Truchet\n   // blocks per face, so doesn't need this.\n   if(sm==1) if(mod(fID, 2.)==1.) d = -d;\n\n   return d;\n\n}\n/////////////////\n\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){\n    \n    // Block offsets.\n    vec2 ipOffs = vec2(0);\n    // Row or column offset. Values like \"1/3\" would offset more\n    // haphazardly, but I wanted to maintain a little symmetry.\n    /*\n    const float offDst = .25; \n    if(mod(floor(p.y/sc.y), 2.)<.5){\n        p.x -= sc.x*offDst; // Row offset.\n        ipOffs.x += offDst;\n    }\n    */\n    /*\n    if(mod(floor(p.x/sc.x), 2.)<.5){\n        p.y -= sc.y*offDst; // Column offset.\n        ipOffs.y += offDst;\n    }\n    /*\n    float ii = floor(p.y/sc.y);\n    float offDst = mod(ii, 4.)/4.; \n    p.x -= sc.x*offDst; // Row offset.\n    ipOffs.x += offDst;\n    */\n    \n         \n    // Current block ID.\n    vec2 ip = floor(p/sc) + .5;\n    \n    #ifdef SUBDIV\n    // Random subdivision.\n    if(hash21(ip + .253)<.333){\n       sc /= 2.;\n       ip = floor(p/sc) + .5; \n    }\n    #endif\n    \n    // Local coordinates and cell ID.\n    return vec4(p - ip*sc, (ip + ipOffs)*sc);\n\n}\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 svSc, gSc; \nvec3 svP, gP;\n\n\n\n// Global overall position matrix.\nmat3 svM3, m3;\n\n// Total running time, tmID, and time segment.\nfloat tmTotal, tmID, tmSeg;\n\nmat3 aM3[12];\n\n// Quater rotation matrices around the X and Y axes.\nconst float ca = cos(3.14159/2.), sa = sin(3.14159/2.);\nconst mat3 mRYZ = mat3(1, 0, 0, 0, ca, sa, 0, -sa, ca);\nconst mat3 mRXZ = mat3(ca, 0, sa, 0, 1, 0, -sa, 0, ca);   \nconst mat3 mRYZN = mat3(1, 0, 0, 0, ca, -sa, 0, sa, ca);\nconst mat3 mRXZN = mat3(ca, 0, -sa, 0, 1, 0, sa, 0, ca); \n\n\nvoid posMat(){\n    \n    // Indentity matrix;\n    m3 = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n    // All 12 starting position matrices. If you were looping from\n    // last position to first, you'd need the inverse matrices:\n    // \"m3 *= inverse(A), or m3 = m3*A\".\n    for(int i=0; i<=11; i++){\n          \n        int iM4 = i&3;\n        if(iM4==3) m3 *= mRXZ;\n        else if(iM4==2) m3 *= mRYZ;\n        else if(iM4==1) m3 *= mRXZN;\n        else if(iM4==0) m3 *= mRYZN;\n        \n        aM3[i] = m3;\n    } \n}\n\n\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n    // Local coordinates.\n    vec2 p = q3.xy;\n\n\n    vec3 sc = vec3(GSCALE); // Scale.\n    // Local coordinates and cell ID.\n    vec4 p4 = getGrid(p, sc.xy); \n    p = p4.xy;\n    vec2 id = p4.zw;\n    \n    sc.z = sc.y;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p, q3.z))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - p)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .0015; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id, sc);\n    //h = (h*.975 + .025)*2.5;\n\n\n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    //sc.xy -= .05;//*(hash21(id)*.9 + .1);\n\n    // Lower box prism.\n    vec3 bxSc = sc/2. - .01;\n    vec3 q = vec3(p, q3.z + h/2.);\n    \n    vec3 svQ = q;\n    \n     \n    \n    // Keyframing: This breaks time into 12 equal segments lasting one second each.\n    // The time is also offset, depending on what cell the object is in.\n     \n    tmTotal = iTime + hash21(id + .17)*.25; // Moving slightly out of sync.\n    tmID = floor(tmTotal);\n    // Fractional time segment: Same as fract(tmTotal).\n    float fTm = tmTotal - tmID; // Range: [0. 1].\n    \n    tmSeg = mod(tmID + floor(hash21(id)*72.), 12.);//  + floor(hash21(grd.zw)*72.)\n\n    //posMat(tmSeg);\n    \n    // Using smoothstep to smoothly interpolate the time period between\n    // zero and one.\n    fTm = smoothstep(.25, .75, fTm);\n    \n    float ang;\n    \n    float reverse = hash21(id + .17)<.5? -1. : 1.;\n    \n    mat4x2 v = mat4x2(vec2(-1, 1), vec2(1), vec2(1, -1), vec2(-1));\n \n    // If traversing the quadrants in the reverse order, reverse the\n    // quadrant postions.\n    if(reverse<0.) v = mat4x2(vec2(-1, 1),  vec2(-1), vec2(1, -1), vec2(1));\n    \n \n    float tmSegM4 = mod(tmSeg, 4.);\n    \n    mat3 mA = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n       \n    for(int i=0; i<12; i++){\n     \n        if(tmSegM4 == float(i)){\n            \n            // Move to quadrant.\n            int j = i&3;\n            //int jp1 = (j + 1)&3;\n            q.xy -= v[j]*bxSc.xy/2.;\n\n            // The first rotation involves pivoting about the positive-Z, \n            // positive-X edge by 90 degrees in the counter clockwise direction.\n            ang = mix(0., -3.14159/2., fTm); // 90 degrees CCW.\n            vec2 piv = vec2(1); // Positive XZ edge.\n            if(j==1 || j==2){ ang = -ang; piv = vec2(-1, 1); }//piv = vec2(-1, 1);\n\n            // Reverse the angles, pivot points and XZ-YZ order, if going in reverse.\n            int YZFirst = 0;\n            if(reverse<0.){\n               piv.x = -piv.x;\n               ang = -ang;\n               YZFirst = 1;\n            }\n\n            // Pivot rotation matrix.\n            float cr = cos(ang), sr = sin(ang);\n            \n         \n            if((i&1)==YZFirst){\n                \n                // XZ pivot rotation matrix.\n                mA = mat3(cr, 0, sr, 0, 1, 0, -sr, 0, cr); \n            \n                // Left and right pivots. In particular, pivoting from quadrant\n                // zero to one, then back the other way from two to three.\n                //\n                q.xz -= piv*bxSc.xz/2.; // Move to the pivot point.\n                q = mA*q; // Rotation about the pivot point.\n                q.xz += piv*bxSc.xz/2.; // Move back to the center of rotationn.\n \n            \n            }\n            else {\n            \n                // YZ pivot rotation matrix.\n                mA = mat3(1, 0, 0, 0, cr, sr, 0, -sr, cr); \n            \n          \n                // Up and down pivots. In particular, pivoting from quadrant\n                // one to two, then back the other way from three to zero..\n                q.yz -= piv*bxSc.yz/2.;                  \n                q = mA*q;\n                q.yz += piv*bxSc.yz/2.;\n             \n            } \n \n            \n            break;\n        }\n    }\n\n    \n    // Set the global matrix to the correct position matrix.\n    // If we're reversing direction, reverse the indices... whilst\n    // accounting for the zero position staying the same... Sigh.\n    // I much prefer vertex\\UV, etc., pipelines when it comes to\n    // texturing. :)\n    int index = int(tmSeg);\n    m3 = reverse<0.? aM3[(12 - index)%12] : aM3[index];\n    \n    // Apply the precalculated position matrix to the current cell position.\n    q = m3*q;\n    \n    // Adding the pivot matrix to the stored position matrix. The pivot was \n    // already added to the position \"q\" above, but hasn't yet been added to\n    // the position matrix that is used for normal rotation.\n    m3 = m3*mA;\n \n    float d = sBoxS(q, bxSc/2., sqrt(bxSc.x)*.03);\n    /*\n    float ew = .02;\n    float edge = max(d, -sBoxS(q.xy, bxSc.xy/2. - ew, 0.));\n    edge = max(edge, -sBoxS(q.xz, bxSc.xz/2. - ew, 0.));\n    edge = max(edge, -sBoxS(q.yz, bxSc.yz/2. - ew, 0.));\n   \n    d += ew;\n    */\n    float edge = 1e5;\n\n \n    // Saving the box dimensions and local coordinates.\n    gSc = sc;//vec3(sc.xy, h);\n \n    gP = q;\n\n        \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, edge);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 svGID, gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n////////////// \n\n    // Using the Truchet pattern to displace the cube and\n    // floor surfaces.\n    \n    int type;\n    float tF, th, pat;\n    #if SURF_DISP_CUBE == 2\n    \n    vec3 txP = gP;\n\n    vec4 q3 = cubeMap(txP);\n    float faceID = q3.w;\n\n    type = CTYPE;\n    vec2 offs = vec2(.5*OFFS);\n    vec2 sc = gSc.xy/GSCALE;\n    int lev = 0;\n    if(gSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n    //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n    pat = getPat(q3.xy + offs, sc, gID.yz, faceID, type, lev);\n\n    tF = type == 2? .7071 : 1.;\n    th = .1*tF;//*sc.x/GSCALE*2.5;\n    if(offs.x>.01) th *= 2.;\n    //if(lev==2) th *= 4.;\n    pat = min(pat + th*1.5, abs(pat - th) - th);\n    #ifndef REVERSE\n    pat = -pat;\n    #endif  \n\n    //d4.x -= smoothstep(0., .1, min((pat + th/4.)*2., th))*.01 - .005;\n    d4.x -= smoothstep(0., th, pat + th*.65)*.01 - .005;\n    //d4.x -= smoothstep(0., th, pat + th*.5)*.01 - .005;\n    \n    #endif\n/////////////////\n \n    #if SURF_DISP_FLOOR == 2\n    type = CTYPE2;\n            \n    vec2 scl = vec2(GSCALE/2.);\n    vec2 q = p.xy;\n    if(type==1) q += scl/4.; // Move the pattern half a small cell for squares.\n    vec2 ip = (floor(q/scl) + .5)*scl;\n    // Grid color squares.\n    vec2 ip2 = floor(q/scl*4. + .5);\n    // Grid local coordinates and ID.\n    vec4 grd = vec4(q - ip, ip);\n \n\n    pat = getPat(grd.xy, scl/2., grd.zw, 0., type, 0);\n    tF = type == 2? .7071 : 1.;\n    #ifdef REVERSE\n    th = .015*tF*GSCALE;\n    #else\n    th = .05*tF*GSCALE;\n    #endif\n    \n    pat = min(pat + th*1.5, abs(pat - th) - th);\n    #ifdef REVERSE\n    pat = -pat;\n    #endif\n    \n    fl -= smoothstep(0., th/2., pat + th/4.)*.005 - .0025;\n    //fl -= smoothstep(0., .1, min((pat + th/4.)*2., th))*.01 - .005;\n     \n    #endif\n    \n///////////////// \n    // Overall object ID.\n    objID = d4.x<d4.w && d4.x<fl? 0. : d4.w<fl? 1. : 2.;\n    \n    // Combining the floor with the extruded image\n    return  min(min(d4.x, d4.w), fl);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.;//hash31(ro + rd)*.05;\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 64; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n    \n    \n    float bump = 0.;\n    \n    \n    #if SURF_DISP_CUBE == 1\n    if(svObjID==0.){\n        \n       \n        vec3 txP = p;   \n\n        vec4 q3 = cubeMap(txP);\n        float faceID = q3.w;\n\n        int type = CTYPE;\n        vec2 offs = vec2(.5*OFFS);\n        vec2 sc = svSc.xy/GSCALE;\n        int lev = 0;\n        if(gSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n        //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n        float pat = getPat(q3.xy + offs, sc, svGID.yz, faceID, type, lev);\n\n        float tF = type == 2? .7071 : 1.;\n        float th = .1*tF;//*sc.x/GSCALE*2.5;\n        if(offs.x>.01) th *= 2.;\n        //if(lev==2) th *= 4.;\n        pat = min(pat + th*1.5, abs(pat - th) - th);\n        #ifndef REVERSE\n        pat = -pat;\n        #endif   \n        \n        \n        /*\n        map(p);\n        vec3 txP = gP;//p;   \n\n        vec4 q3 = cubeMap(txP);\n        float faceID = q3.w;\n\n        int type = CTYPE;\n        vec2 offs = vec2(.5*OFFS);\n        vec2 sc = gSc.xy/GSCALE;\n        int lev = 0;\n        if(gSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n        //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n        float pat = getPat(q3.xy + offs, sc, gID.yz, faceID, type, lev);\n\n        float tF = type == 2? .7071 : 1.;\n        float th = .1*tF;//*sc.x/GSCALE*2.5;\n        if(offs.x>.01) th *= 2.;\n        //if(lev==2) th *= 4.;\n        pat = min(pat + th*1.5, abs(pat - th) - th);\n        #ifndef REVERSE\n        pat = -pat;\n        #endif \n        */\n\n \n        bump = smoothstep(0., th, pat + th*.65)*.01;\n        //bump = smoothstep(0., .1, min((pat + th/4.)*2., th));    \n    \n    \n    }\n    #endif\n    \n    #if SURF_DISP_FLOOR == 1\n    if(svObjID==2.){\n    \n        int type = CTYPE2;\n\n        vec2 scl = vec2(GSCALE/2.);\n        vec2 q = p.xy;\n        if(type==1) q += scl/4.; // Move the pattern half a small cell for squares.\n        vec2 ip = (floor(q/scl) + .5)*scl;\n        // Grid color squares.\n        vec2 ip2 = floor(q/scl*4. + .5);\n        // Grid local coordinates and ID.\n        vec4 grd = vec4(q - ip, ip);\n\n\n        float pat = getPat(grd.xy, scl/2., grd.zw, 0., type, 0);\n        float tF = type == 2? .7071 : 1.;\n        #ifdef REVERSE\n        float th = .015*tF*GSCALE;\n        #else\n        float th = .05*tF*GSCALE;\n        #endif\n\n        pat = min(pat + th*1.5, abs(pat - th) - th);\n        #ifdef REVERSE\n        pat = -pat;\n        #endif\n\n\n        bump = smoothstep(0., th/2., pat + th/4.)*.005;\n        //bump = smoothstep(0., .1, min((pat + th/4.)*2., th))*.01;\n    }\n    #endif\n    \n    return bump;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. \n// There's a six tap version (samples taken from either side of each axis), but this \n// works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the \n    // aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    // Bump mapping the moving cube surface requires some transformations\n    // prior to performing the calculations. It's annoying to code, but worth\n    // it, since it is way faster than displacing the surface inside the \n    // raymarched distance function.\n    vec3 v0 = e.xyy;\n    vec3 v1 = e.yxy;\n    vec3 v2 = e.yyx;\n    \n    if(svObjID==0.){\n       p = svP;\n       v0 = svM3*v0;\n       v1 = svM3*v1;\n       v2 = svM3*v2; \n       \n    } \n    \n    \n    \n    mat4x3 p4 = mat4x3(p, p - v0, p - v1, p - v2);\n    //mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n \n    vec4 b4;\n    for(int i = min(iFrame, 0); i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of \n    //cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some \n    // kind of orthogonal space fix using the Gram-Schmidt process, or something to that \n    // effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more \n    // bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\n///////////////////////////\n\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(3.14159265*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*3.14159265);\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/4. - .5, 0, -3); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.0, .1, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(1.5, 2, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Rotation.\n \trd.xy *= rot2(.2); \n    \n    /*    \n    // Mouse camera movement.\n    if(iMouse.z>1.){\n        rd.yz *= rot2(-.5*(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        rd.xz *= rot2(-.25*(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);\n    }\n    */\n \n    \n    // Calculate all 12 matrix positions.\n    posMat();\n \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    svSc = gSc;\n    svP = gP;\n\n    // Saving the 3D orientation matrix.\n    svM3 = m3;\n   \n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = normal(sp);\n        \n        // Bump mapping the surface.\n        #if (SURF_DISP_CUBE == 1) || (SURF_DISP_FLOOR == 1)\n        sn = doBumpMap(sp, sn, 1.);\n        #endif\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n                \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 2./(1. + lDist*.125);\n    \t\n        \n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 16.); \n           \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n\n        // Combining the above terms to procude the final color.\n        float matType = 0.; // Dielectric.\n        float reflectance = .5;\n        float roughness = .5;\n        \n        //float toneF = .0; // Grey toning. Not used.\n        \n        vec3 shade = vec3(.9, .95, 1); // Metal color shading.\n\n        // The boxes and edging.\n        if(svObjID<1.5){\n            \n \n            \n            \n            // Texture and normal. The texture position has been saved from \n            // the distance field. The normal position also needs to be \n            // rotated to the correct position.\n            vec3 txP = svP;\n            vec3 txN = svM3*sn;\n\n            // Cubemap texturing.\n            vec4 q3 = cubeMap(txP);\n            float faceID = q3.w; // Face ID.\n            // Cube texture.\n            vec3 tx = texCube(iChannel1, txP*1. + .5*0., txN);\n \n\n            // Coloring.\n            float cRnd = hash21(svGID.yz);\n            #if COLOR == 2\n            vec3 lCol = .5 + .45*cos(6.2831589*cRnd/6. + vec3(0, 1, 2).yxz*1.1 + .5);\n            #else\n            vec3 lCol = .5 + .45*cos(6.2831589*cRnd/6. + vec3(0, 1, 2)*1.25);\n            #endif\n\n            // Random grid cell number.\n            cRnd = hash21(svGID.yz + .21);\n\n            // Alternate coloring.\n            #if COLOR == 3\n            lCol = lCol.xzy;\n            if(cRnd<.5) lCol = lCol.zyx;\n            #else\n            if(cRnd<.35) lCol = lCol.zyx;\n            #endif\n   \n       \n            \n            // Running a diffuse gradient effect over the result.\n            #if COLOR == 3\n            lCol = mix(lCol, lCol.xzy, spec*.1);\n            #else\n            lCol = mix(lCol, lCol.zyx, spec*.125);\n            #endif\n            \n            // White.\n            #if COLOR == 0\n            lCol = vec3(.9)*dot(lCol, vec3(.299, .587, .114));\n            #endif\n           \n            #if COLOR == 2 || COLOR == 3\n            lCol *= sqrt(lCol);\n            #else\n            lCol *= lCol*1.5; \n            #endif\n  \n            // Color tweaking.\n            lCol /= 1./3. + dot(lCol, vec3(.299, .587, .114));\n            lCol *= (tx*2. + .5)*1.5;\n            \n            \n            \n            // Edge coloring. Not used here.\n            //if(svObjID>.5) objCol = vec3(.1);\n                      \n \n            // Using the cube face coordinates to calculate the cube pattern.\n            int type = CTYPE;\n            vec2 offs = vec2(.5*OFFS);\n            vec2 sc = svSc.xy/GSCALE;\n            int lev = 0;\n            if(svSc.x==GSCALE/2.){ offs += 1. + .5*OFFS; sc *= 4.; lev = 1; }\n            //else if(sc.x==GSCALE/4.){ sc *= 8.; lev = 2; }//offs += sc/2.; \n            float pat = getPat(q3.xy + offs, sc, svGID.yz, faceID, type, lev);\n             \n            float oPat = pat;\n            float tF = type == 2? .7071 : 1.;\n            float th = .1*tF;//*sc.x/GSCALE*2.5;\n            if(offs.x>.01) th *= 2.;\n            //if(lev==2) th *= 4.;\n            pat = min(pat + th*1.5, abs(pat - th) - th);\n            //pat = min(pat + th*1.5, abs(pat - th) - th);\n            #ifndef REVERSE\n            pat = -pat;\n            #endif\n            \n            // Appling the colors, shade, pattern and lines. -- Standard stuff.\n            objCol = vec3(1)*shade;\n            objCol *= tx*2. + .05;\n  \n            // The metallic part of the pattern.\n            objCol = mix(objCol*.75, objCol*.375, 1. - smoothstep(0., .015, pat));\n            \n            // Grey factor - Not used here.\n            //objCol = mix(objCol, vec3(1)*dot(objCol, vec3(.299, .587, .114)), toneF);\n        \n            // Reverse pattern option.\n            #ifdef REVERSE\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .015, -oPat + th*2.));\n            #else\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .015, oPat + th*1.5));\n            #endif\n\n            // Dark lines.\n            objCol = mix(objCol, objCol*.25, \n                         1. - smoothstep(0., .015, abs(pat + .03) - .015));\n             \n             \n            // Metal or dielectric material, depending on the section of the\n            // pattern we're in.\n            matType = mix(1., 0.,  1. - smoothstep(0., .02, oPat + th*1.5));\n           \n             \n            // Roughness factor: More for the metal.\n            float rghF = mix(2.5, 1.,  1. - smoothstep(0., .02, oPat + th*1.5));\n            // Adding texture-based roughness.\n            roughness = min(dot(tx*rghF, vec3(.299, .587, .114)), 1.);\n            reflectance = .5; // Reflectance.\n            \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            vec2 txP = sp.xy;\n            vec3 tx = getTex(iChannel1, txP*4. + .5);\n\n\n            // Background floor pattern.\n            \n            int type = CTYPE2;\n            vec2 scl = vec2(GSCALE/2.);\n            vec2 q = sp.xy;\n            if(type==1) q += scl/4.; // Move the pattern half a small cell for squares.\n            vec2 ip = (floor(q/scl) + .5)*scl;\n            // Grid color squares.\n            vec2 ip2 = floor(q/scl*4. + .5);\n            // Grid local coordinates and ID.\n            vec4 grd = vec4(q - ip, ip);\n  \n\n\n            // Calculating the background pattern.\n            float pat = getPat(grd.xy, scl/2., grd.zw, 0., type, 0);\n            float oPat = pat;\n            float tF = type == 2? .7071 : 1.;\n            #ifdef REVERSE\n            float th = .015*tF*GSCALE;\n            #else\n            float th = .05*tF*GSCALE;\n            #endif\n            pat = min(pat + th*1.5, abs(pat - th) - th);\n            #ifdef REVERSE\n            pat = -pat;\n            #endif\n            \n            /*\n            // Colored markings. Didn't work.\n            vec3 lCol = .5 + .45*cos(6.2831589*hash21(ip2)/6. + vec3(0, 1, 2)*1.25);\n\n            float cRnd = hash21(ip2 + .21);\n            // if(cRnd<.35) lCol = lCol.zyx;\n            lCol /= 1./3. + dot(lCol, vec3(.299, .587, .114));\n            // Running a diffuse gradient effect over the result.\n            lCol = mix(lCol, lCol.zyx, spec*.125);\n           \n            lCol *= tx*2. + .5;\n            lCol *= lCol*3.;\n            */\n\n            // Coloring.\n            vec3 lCol = vec3(.75);\n            lCol *= (tx*2. + .05)*shade;\n           \n            // Metallic texturing and shading, depending on pattern region.\n            objCol = vec3(.5)*(tx*2. + .05)*shade;\n            objCol = mix(objCol*.75, objCol*.375, 1. - smoothstep(0., .005, pat));\n   \n            // Reverse pattern option.\n            #ifdef REVERSE\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .005, (abs(oPat - th) - th)));\n            #else\n            objCol = mix(objCol, lCol, 1. - smoothstep(0., .005, oPat + th*1.5));\n            #endif           \n            \n            // Dark edges.\n            objCol = mix(objCol, objCol*.25, \n                         1. - smoothstep(0., .005, abs(pat + .01) - .005));\n  \n            \n            // Grey factor - Not used here.\n            //objCol = mix(objCol, vec3(1)*dot(objCol, vec3(.299, .587, .114)), toneF);\n       \n       \n            // Material type, reflectance and texture-based roughness.\n            //matType = mix(1., 0.,  1. - smoothstep(0., .005, oPat + th*1.5));\n            matType = 1.;\n            reflectance = .5;\n            roughness = min(dot(tx*2.5, vec3(.299, .587, .114)), 1.);\n           \n        }\n        \n        \n            \n        \n         \n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel2, rf.xzy*vec3(1, -1, -1)).xyz; rTx *= rTx;\n        float rF = svObjID==2.? 2.: 4.;\n        objCol = objCol + (objCol)*speR*dot(rTx, vec3(.299, .587, .114))*rF;\n \n \n        // Ambient light.\n        // I wanted to use a little more than a constant for ambient light, but \n        // without having to resort to sophisticated methods, then I remembered \n        // Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        float ambience = pow(length(sin(sn*2.)*.45 + .5)/sqrt(3.), 2.)*2.; // Studio.\n        //float ambience = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*\n        //                  smoothstep(-1., 1., -sn.z); // Outdoor.\n\n        \n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(objCol, sn, ld, -rd, matType, roughness, reflectance);\n        \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        col = (objCol*ambience*(sh*.5 + .5) + ct*(sh));\n        \n        \n        // Shading.\n        col *= ao*atten;\n        \n         \n\t\n\t}\n    \n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(0), smoothstep(.25, .9, t/FAR));\n \n    // For all the toning formulae out there, this one liner -- based on \n    // Reinhart, does a really good job. The figure on the end (3, in this case) \n    // regulates the high tones. Obviously, the higher the number, the less\n    // dramatic the toning.\n    col /= (1. + col/3.);   \n    \n     \n    /*\n    vec4 prev = texture(iChannel0, fragCoord/iResolution.xy);\n    col = mix(col, prev.xyz, 1./2.);\n    t = mix(t, prev.w, 1./2.);\n    */ \n   \n \n    // Store to the buffer.\n    fragColor = vec4((max(col, 0.)), t);\n    \n\t\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 871, 908, 954, 1695], [1818, 1818, 1872, 1899, 2266]], "test": "untested"}
{"id": "csGBRD", "name": "Convolution Reverb (Kinda)", "author": "MysteryPancake", "description": "My idea of convolution reverb, which is pasting an impulse every sample and multiplying it by that sample's amplitude.\nI added a time offset like in the fork. If you remove the offset it's more accurate, but sounds worse and needs more samples.", "tags": ["sound", "music", "convolution", "synthesis", "synth", "saw", "song", "reverb", "gpusound", "supersaw", "chords"], "likes": 22, "viewed": 712, "published": 3, "date": "1698463925", "time_retrieved": "2024-07-30T17:25:35.259580", "image_code": "// From https://www.shadertoy.com/view/cdXSWj\nvec3 drawTrack(vec2 uv, vec2 samp, float offset, vec3 color) {\n    float glow = min(1.0, 0.03 / abs(uv.y - samp.x * 0.05 - offset));\n    float line = min(1.0, 0.003 / abs(uv.y - samp.y * 0.05 - offset));\n    return line + glow * color * 0.4;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    Song song = getSong(iTime + (uv.x - 1.0) * SPB * 0.1, REVERB_SAMPLES / 4);\n    Song songNow = getSong(iTime, 0);\n    float boom = 1.0 - songNow.sidechain;\n    \n    // Draw foreground\n    vec3 col = drawTrack(uv, song.drums, 0.8 + boom * 0.1, vec3(1.0, 0.0, 0.0));\n    col += drawTrack(uv, song.bass, 0.6 + boom * 0.2, vec3(1.0, 1.0, 0.0));\n    col += drawTrack(uv, song.leads, 0.4 - boom * 0.2, vec3(0.0, 0.0, 1.0));\n    col += drawTrack(uv, song.reverb, 0.2 - boom * 0.1, vec3(0.5, 0.0, 1.0));\n    \n    // Draw background\n    vec2 center = uv - 0.5;\n    vec2 coolUv = fract(center / dot(center, center));\n    float dist = sin(iTime * 4.0 - length(coolUv - 0.5) * 24.0 - 8.0 * boom) * 0.5 + 0.5;\n    col += min(2.0, (0.05 + boom) / dist) * uv.yxx * (0.1 + boom);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time) {\n    Song song = getSong(time, REVERB_SAMPLES);\n    vec2 dry = (song.leads + song.bass) * song.sidechain + song.drums;\n    vec2 wet = song.reverb * song.sidechain;\n    return mix(dry, wet, WETNESS) * 0.45;\n}", "sound_inputs": [], "common_code": "const float BPM = 120.0;\nconst float SPB = 60.0 / BPM; // Seconds per beat\n\nconst float TUNING = 440.0;\nconst int MIDIOFFSET = 69;\n\nconst float TAU = 6.28318530;\n\nconst int REVERB_SAMPLES = 512;\nconst float WETNESS = 0.5;\n\n// MIDI note to frequency formula\nfloat noteFreq(int note) {\n\treturn TUNING * exp2(float(note - MIDIOFFSET) / 12.0);\n}\n\n// From https://www.shadertoy.com/view/clXSR7\nfloat waveSaw(float freq, float time) {\n    return fract(freq * time + 0.5) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Impulse for convolution, this will be sampled NUM_SAMPLES times\nvec2 impulse(float time) {\n    time *= iSampleRate;\n    return hash22(vec2(time * 452.3, time * 274.6)) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/tttfRj\nfloat noise(float s) {\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = smoothstep(0.0, 1.0, sf);\n    return mix(hash11(float(si)), hash11(float(si + 1)), sf) * 2.0 - 1.0;\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat coloredNoise(float time, float freq, float bandwidth) {\n    return sin(TAU * freq * fract(time)) * noise(time * bandwidth);\n}\n\n// From https://www.shadertoy.com/view/sls3WM\n// Sliding pitch sine wave, used for bass drop and kick\nfloat drop(float time, float df, float dftime, float freq) {\n    return sin(TAU * (freq * time - df * dftime * exp(-time / dftime)));\n}\n\n// From https://www.shadertoy.com/view/sls3WM\nfloat kick(float time) {\n    float body = drop(time, 512.0, 0.01, 60.0) * smoothstep(0.3, 0.0, time);\n    float click = coloredNoise(time, 8000.0, 2000.0) * smoothstep(0.007, 0.0, time);\n    return body * 2.0 + click * 1.5;\n}\n\nvec2 hats(float time) {\n    float falloff = (cos(time * TAU * 0.25 / SPB) + 2.5) * 8.0;\n    vec2 noise = hash22(vec2(time * iSampleRate, time * iSampleRate * 123.4)) * 2.0 - 1.0;\n    float volume = exp(-falloff * mod(time, SPB / 3.0));\n    return noise * volume;\n}\n\n// No optimization here, not feeling like it today\nfloat leadSynth(float time) {\n    const int notes[] = int[](\n        64,54,57,\n        64,54,57,\n        64,54,57,\n        62,52,57,\n        61,54,57,\n        61,54,57,\n        61,54,57,\n        59,57,52\n    );\n    float beatTime = 1.5 * time / SPB;\n    int note = notes[int(abs(beatTime)) % notes.length()];\n    float volume = step(fract(beatTime), 0.5 + sin(time * TAU * 0.125 / SPB) * 0.05);\n    return waveSaw(noteFreq(note), time) * volume;\n}\n\nfloat leadBass(float time) {\n    const int notes[] = int[](\n        38,38,38,\n        38,38,50,\n        38,38,38,\n        40,40,52,\n        42,42,42,\n        42,54,42,\n        42,42,54,\n        37,49,40\n    );\n    float beatTime = 1.5 * time / SPB;\n    int bass = notes[int(abs(beatTime)) % notes.length()];\n    float volume = step(fract(beatTime - 0.5), 0.4 + cos(time * TAU * 0.125 / SPB) * 0.1);\n    return waveSaw(noteFreq(bass), time) * volume;\n}\n\nstruct Song {\n    vec2 leads;\n    vec2 drums;\n    vec2 bass;\n    vec2 reverb;\n    float sidechain;\n};\n\nSong getSong(float time, int reverb) {\n    Song song;\n    song.reverb = vec2(0.0);\n    for (int i = 0; i < reverb; i++) {\n        float timeOffset = float(i) / iSampleRate;\n        \n        // Butcher the settings every 2nd time for variety\n        bool variety = mod(time - timeOffset, SPB * 64.0) > SPB * 32.0;\n        float offsetScale = variety ? 0.5 : 1.2;\n        float timeScale = variety ? 2.0 : 1.0;\n        \n        // Convolution reverb doesn't have a random time offset, but it sounds better with it\n        timeOffset += hash11(timeOffset * 126.7) * offsetScale;\n        \n        song.reverb += leadSynth(time * timeScale - timeOffset) * impulse(timeOffset);\n    }\n    song.reverb *= 0.105;\n    \n    song.leads = vec2(leadSynth(time));\n    song.bass = vec2(leadBass(time) * 1.3);\n    song.drums = hats(time) * 0.7 + kick(mod(time, SPB)) * 0.8;\n    song.sidechain = 0.3 + min(1.0, mod(time, SPB) * 6.0) * 0.7;\n    \n    return song;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 108, 108, 289], [291, 291, 346, 346, 1194]], "test": "untested"}
{"id": "DdVBR3", "name": "UFFFD barebones starter 2023", "author": "ufffd", "description": "simple shader with my opinionated set of starter functions and format", "tags": ["template"], "likes": 0, "viewed": 149, "published": 3, "date": "1698446973", "time_retrieved": "2024-07-30T17:25:36.012567", "image_code": "#define R (iResolution.xy)\n\nvoid mainImage( out vec4 color, in vec2 xy ) {\n    vec2 uv = xy/R;\n    vec2 uvc = (xy-R/2.)/R.y;\n\n    vec3 col = uvc.xyx;\n    #if DEBUG\n        col.b = 1.;\n    #endif\n    \n    if (keyDown(KEY_SPACEBAR))\n        col = vec3(1.);\n\n    color = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-- dev controls --//\n#define DEBUG 0\n#define SPEED 1.\n\n//-- constants --//\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n//-- time defines--//\n// T is time controlled by SPEED\n#define T (iTime*SPEED)\n// sT is sinusoidal time - ranges from 0 to 1 and back over time\n#define sT (tanh(fract(T)*PI*2.-PI)/2.+0.5 + floor(T))\n// mT is modulo time - from 0 to 1 cyclically over time\n#define mT (fract(T))\n\n//--smoothsteps--//\n#define S smoothstep\n#define SS(a,b,c) S(a-b,a+b,c)\n\n//--misc utility--//\n#define rot(a)      mat2( cos(a), -sin(a), sin(a), cos(a) )\nbool nearly(in float a, in float b) {return abs(a - b) < 0.001;}\nbool nearly(in float a, in float b, in float k) {return abs(a - b) < k;}\nfloat luminance(vec3 c) {return dot(c, vec3(.2126, .7152, .0722));}\n\n//--fabrice's hsv2rgb--//\nvec3 hsv2rgb_smooth( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}\nvec3 rgb2hsv(vec3 c){vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);float e = 1.0e-10;return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);}\n\n// normalized functions - return 0 to 1\nfloat nmod(in float x){return mod(x,1.);}\nfloat nsin(in float x){return sin(x)*0.5+0.5;}\nfloat nclamp(in float x){return clamp(x,0.,1.);}\nvec2 nclamp(in vec2 x){return clamp(x,0.,1.);}\nvec3 nclamp(in vec3 x){return clamp(x,0.,1.);}\nvec4 nclamp(in vec4 x){return clamp(x,0.,1.);}\n\n//--random & noise--//\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat noise(in vec2 p){vec2 ip = floor(p);vec2 u = fract(p);u = u*u*(3.0-2.0*u);float res = mix(mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);return res*res;}\nvec4 permute(vec4 x) {return mod((34.0 * x + 1.0) * x, 289.0);}\n//--hoskins hash--//// Hash without Sine\n// MIT License... Copyright (c)2014 David Hoskins.[license copy below]*/\nfloat hash11(float p){p = fract(p * .1031);p *= p + 33.33;p *= p + p;return fract(p);}\n\n//--Keyboard Controls *NOTE: requires iChannel3 be set to keyboard*--//\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define KEY_SPACEBAR 32\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* MIT License Copy:\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 74, 74, 284]], "test": "untested"}
{"id": "DdGBzc", "name": "Outline SDF with other SDF", "author": "fishy", "description": "Generic outlines by computing second SDF at the closest point to first SDF. Not perfect as it uses numerical derivatives to compute the closest point, leading to floating-point precision errors, but pretty close!", "tags": ["a"], "likes": 6, "viewed": 185, "published": 3, "date": "1698446148", "time_retrieved": "2024-07-30T17:25:36.763559", "image_code": "// Generic outlines by computing second SDF at the closest point to first SDF.\n// Not perfect as it uses numerical derivatives to compute the closest point,\n// leading to floating-point precision errors, but pretty close!\n//\n// Outline shape switches between rounded box and star shape\n//\n// Next thing to try perhaps would be to use analytic normals. All SDF functions\n// made by iq (except the outlining function)\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// signed distance to a quadratic bezier\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res );\n}\n\nfloat sdStar( in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat baseMap(vec2 uv)\n{\n    //return sdSegment(uv, vec2(-0.5, 0.2), vec2(0.5, 0));\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    return sdBezier(uv, v0, v1, v2);\n}\n\nmat2 rot(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\n// cursed macros to simulate functions as first-class types\n// pretty useful, I'll have to put these to use sometime else\n#define derivative(uv, eps, func) (vec2(func(uv + vec2(eps, 0)) - func(uv - vec2(eps, 0)), func(uv + vec2(0, eps)) - func(uv - vec2(0, eps)))/eps*0.5)\n#define closestPoint(uv, eps, func) (uv - derivative(uv, eps, func)*func(uv))\n\nfloat outlineMap(vec2 uv)\n{\n    if(int(iTime)/6 % 2 == 0)\n        return sdRoundedBox(uv, vec2(0.1), vec4(tanh(sin(iTime*3.1415926535)*3.0)*0.1));\n    return sdStar(uv, 0.1, 6, 2.0 + tanh(sin(iTime*3.1415926535)*3.0)*0.5);\n}\n\nfloat map(vec2 uv)\n{\n    vec2 cp = closestPoint(uv, 0.0001, baseMap);\n    return outlineMap(uv-cp);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m, float px)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.005\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float md = abs(map(m.xy));\n    vec3 col = mix(vec3(1.000,0.686,0.035), vec3(0.133,0.459,1.000), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(0), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(\n                distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH,\n                distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(0), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 1.5/iResolution.y;\n    \n    fragColor = vec4(colorSdf(uv, m, px),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdGBzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 472, 472, 629], [631, 631, 683, 683, 802], [804, 804, 829, 829, 848], [849, 849, 884, 884, 912], [914, 955, 1019, 1019, 2219], [2221, 2221, 2281, 2338, 2737], [2739, 2739, 2763, 2822, 3041], [3043, 3043, 3061, 3061, 3110], [3465, 3465, 3492, 3492, 3689], [3691, 3691, 3711, 3711, 3792], [3794, 3794, 3836, 3836, 4505], [4507, 4507, 4564, 4564, 4786]], "test": "untested"}
{"id": "cdcBRN", "name": "Shifting Carpet", "author": "TheBen27", "description": "Color-mapped RPS automata. Very resolution-dependent.\n\nR - reset\nA - increase resolution\nS - decrease resolution\n\nChange categories in Common\nChange starting pattern in Buffer B", "tags": ["animated", "automata", "rps"], "likes": 6, "viewed": 234, "published": 3, "date": "1698428696", "time_retrieved": "2024-07-30T17:25:37.514551", "image_code": "// DISPLAY\n\nfloat mirroredSmooth(float x, float c, float w) {\n    return clamp(smoothstep(1.0, 0.0, abs(x - c) / w), 0.0, 1.0);\n}\n\nvec3 colorFromValue(int value) {\n  float factor = float(value) / float(totalCategories);\n  const float center = 0.5;\n  const float spread = 0.1;\n  const float width = 0.4;\n  return vec3(\n      mirroredSmooth(factor, center - spread, width),\n      mirroredSmooth(factor, center, width),\n      mirroredSmooth(factor, center + spread, width)\n  );\n}\n\nint getValue(ivec2 pos) {\n    return int(texelFetch(iChannel0, pos, 0).r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(colorFromValue(getValue(ivec2(fragCoord))), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEY_A 65\n#define KEY_D 68\n#define KEY_R 82\n\n// STATE\n\nbool getKeyHeld(int code) {\n    return texelFetch(iChannel1, ivec2(code, 0), 0 ).x > 0.0;\n}\n\nbool getKeyPress(int code) {\n    return texelFetch(iChannel1, ivec2(code, 1), 0 ).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.0) {\n        return;\n    }\n    \n    int varIndex = int(fragCoord.x);\n    if (iFrame == 0) {\n        // initialize variables\n        if (varIndex == VAR_QUALITY) {\n            fragColor = vec4(2.0, 0.0, 0.0, 0.0);\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n        return;\n    }\n    \n    // Update variables\n    float last = getVar(iChannel0, varIndex);\n    float next = last;\n    \n    // Update quality\n    if (varIndex == VAR_QUALITY) {\n        if (getKeyPress(KEY_A)) {\n            next = max(1.0, last / 2.0);\n        } else if (getKeyPress(KEY_D)) {\n            next = min(32.0, last * 2.0);\n        }\n    }\n    \n    fragColor = vec4(next, 0.0, 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define VAR_QUALITY 1\n\n// CONFIGURATION\n\n// odd number\nconst int totalCategories = 111;\n\n// STATE\n\nfloat getVar(sampler2D sampler, int index) {\n    return texelFetch(sampler, ivec2(index, 0), 0).r;\n}\n\n// NOISE\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand1(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 getCellInfo(vec2 cellIndex) {\n    float x = rand(cellIndex);\n    float y = rand1(x);\n    float v = rand1(y);\n    \n    return vec3(x, y, v);\n}\n\nfloat voronoiDistance(vec2 a, vec2 b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nvec2 voronoi(vec2 uv) {\n    vec2 pos = uv;\n    vec2 innerPos = mod(pos, 1.0);\n    vec2 index = floor(pos);\n \n    float minDistance = 3.0;\n    float minValue = -1.0;\n    for (float x = -1.0; x <= 1.0; x += 1.0) {\n        for (float y = -1.0; y <= 1.0; y += 1.0) {\n            vec2 offset = vec2(x, y);\n            vec3 cellInfo = getCellInfo(index + offset);\n            vec2 cellPos = cellInfo.xy;\n            float cellValue = cellInfo.z;\n            float cellDistance = voronoiDistance(innerPos, cellPos + offset);\n            if (cellDistance < minDistance) {\n                minDistance = cellDistance;\n                minValue = cellValue;\n            }\n        }\n    }\n    return vec2(minDistance, minValue);\n}\n\n// INTEGER MODULO\n\nint pmod(int x, int m) {\n  return x - ((x / m) * m);\n}\n\nint umod(int x, int m) {\n  int positive = pmod(x, m);\n  int negative = m - pmod((-x), m);\n  return x >= 0 ? positive : negative;\n}\n\nivec2 umod2(ivec2 v, ivec2 m) {\n  return ivec2(umod(v.x, m.x), umod(v.y, m.y));\n}", "buffer_b_code": "// 0 - random\n// 1 - circle\n// 2 - stripes\n// 3 - voronoi value\n// 4 - voronoi distance\n#define START 1\n\n// CELLS\nconst int cellTimeStep = 1;\nconst int lossThreshold = -2;\n\nint getCellSize() {\n    return int(getVar(iChannel2, VAR_QUALITY));\n}\n\nint sampleValue(ivec2 coord) {\n    return int(texelFetch(iChannel0, coord, 0).r);\n}\n\nint battle(int self, int other) {\n  const int center = (totalCategories - 1) / 2;\n  int difference = self - center;\n  int newOther = umod(other - difference, totalCategories);\n  return sign(center - newOther);\n}\n\nint battleWithNeighbor(int value, ivec2 coord) {\n  return battle(value, sampleValue(coord));\n}\n\nint initialValue(ivec2 coord) {\n#if START==0\n    // noise\n    return int(float(totalCategories) * rand(vec2(coord) / iResolution.xy));\n#endif\n#if START==1\n    // circle\n    vec2 center = iResolution.xy / float(getCellSize()) / 2.0;\n    int dist = int(distance(vec2(coord), center));\n    return umod(dist, totalCategories);    \n#endif\n#if START==2\n    // stripes\n    return umod((coord.x + coord.y) / 4, totalCategories);\n#endif\n#if START==3\n    // voronoi value\n    // vec4(voronoi(4.0 * vec2(fragCoord / iResolution.xy)).y, 0.0, 0.0, 1.0);\n    return int(float(totalCategories) * voronoi(24.0 * vec2(coord) / iResolution.xy).y);\n#endif\n#if START==4\n    // voronoi distance\n    // vec4(voronoi(4.0 * vec2(fragCoord / iResolution.xy)).y, 0.0, 0.0, 1.0);\n    return int(float(totalCategories) * voronoi(12.0 * vec2(coord) / iResolution.xy).x);\n#endif\n}\n\nbool reset() {\n    // R key\n    return texelFetch( iChannel1, ivec2(82,0), 0 ).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord) / getCellSize();\n    \n    if (iFrame <= 1 || reset()) {\n      fragColor = vec4(initialValue(coord), 0.0, 0.0, 1.0);\n      return;\n    }\n    \n    if (umod(iFrame, cellTimeStep) != 0) {\n      fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n      return;\n    }\n    \n    int last = sampleValue(ivec2(fragCoord));\n    int score = 0;\n    for (int x = -1; x <= 1; x++) {\n      for (int y = -1; y <= 1; y++) {\n        if (x != 0 || y != 0) {\n          score += battleWithNeighbor(last, umod2(coord * getCellSize() + getCellSize() * ivec2(x, y), ivec2(iResolution)));\n        }\n      }\n    }\n    \n    int new = last;\n    if (score <= lossThreshold) {\n      new = umod(new - 1, totalCategories);\n    }\n    \n    fragColor = vec4(float(new), 0.0, 0.0, 1.0);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 61, 61, 129], [131, 131, 163, 163, 476], [478, 478, 503, 503, 554], [556, 556, 613, 613, 686]], "test": "untested"}
{"id": "msGfzy", "name": "Modular group cosets colouring", "author": "willwombell", "description": "Coset colouring of the modular group using a variety of colouring methods based on reflection counting. Mouse control alters the colouring functions and loop exit point on the IIS reflection method to help in understanding the computation process.", "tags": ["group", "hyperbolic"], "likes": 6, "viewed": 225, "published": 3, "date": "1698426661", "time_retrieved": "2024-07-30T17:25:38.347324", "image_code": "// Core code derived from zenzicubic's https://www.shadertoy.com/view/Ds3SDf\n\n// Functionality to adjust colouring method added along with controls\n// to alter the representation and movement. Some combinations result in\n// strange effects but I find the given setup to be the most fun.\n\n// Deep into the walk, adjusting the loop break point can result in a sharp\n// change due to the nature of the control parameterisation. Just time reset\n// if necessary.\n\n// Scale: Wide 5.0 Mid 2.4 Close 1.8\n\n// Parameters\n#define NUMITERS 5000\n#define PHI 1.61803398874989\n#define PI 3.14159265\n#define SCALE 5.4\n\n// Control\n#define SPLIT true\n#define FLIP true\n\n#define ROTATE true\n#define DISK true\n#define ZOOM true\n#define WALK true\n\n// Colouring function, choose 0 to 4\n#define COLOUR 0\n\n\n// Colouring coset parameters\nconst vec4 count_mixer = vec4(1,2,3,5);\nconst vec3 coset_div = vec3(2.,3.,5.);\n\n\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x, -z.y) / dot(z, z);\n}\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a, cinv(b));\n}\n\nvec3 eflip(vec2 p, vec2 ms) {\n    // Reflection counters\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    bool esc;\n    \n    for (int i = 0; i < NUMITERS; i++) \n    {\n        // Loop break controller\n        if (i > int((ms.x))) break;\n        \n        esc = true;\n        \n        // Reflection generation\n        if (length(p) < 1.) {\n            p = cinv(p);\n            c ++;\n            esc = false;\n        }\n        if ((p.x > 0.) && SPLIT) {\n            p.x *= -1.;\n            d ++;\n            esc = false;\n        }\n        if (p.x < -.5)\n        {\n            p.x = -1. - p.x;\n            e ++;\n            esc = false;\n        }\n        if ((p.x > .5) && FLIP)\n        {\n            p.x = 1. - p.x;\n            f ++;\n            esc = false;\n        }\n        \n        \n        if (esc) break;\n    }\n    \n    \n    float t = dot(vec4(c,d,e,f),count_mixer);\n    \n    float coset = ms.y*500.;\n    vec3 coset_vec = ms.y*coset_div;\n    \n    switch (COLOUR) {\n        // Coset rgb mixing\n        case 0:\n            return (0.5+0.5*cos(PI*vec3(float(t))/coset_vec));\n        // Scalar coset representation\n        case 1:\n            return vec3(0.5+0.5*cos(PI*float(t)/coset));\n        // Modular arithmetic representation\n        case 2:\n            return vec3(mod(float(t),coset)/float(coset));\n        // Random mixing\n        case 3:\n            return vec3(0.5/float((c+d)%2),\n                        0.4/float((d+e*f)%2),\n                        0.6/float((c*f+f-e)%3));\n        // Controlled random mixing\n        case 4:\n            return vec3(0.5*cos(ms.y)/float((c+d)%2),\n                        0.4*cos(3.*ms.y-0.2)/float((d+e*f)%2),\n                        0.6*cos(2.*ms.y+0.3)/float((c*f+f-e)%3));\n    }\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) \n{\n    vec2 z = SCALE*(coord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    \n    float t = 0.1*iTime;\n    mat2 rot = mat2(1,0,0,1);\n    \n    if (ROTATE) {\n        rot = mat2(cos(t), sin(t), -sin(t), cos(t));\n    }\n    if (DISK) {\n        z = z*rot;\n        z = cdiv(vec2(0., 1.) - vec2(z.y, -z.x), z - vec2(1., 0.));\n    }\n    if (ROTATE) {\n        z.x += cos(iTime);\n        z.y += pow(0.4*sin(iTime*PHI), 2.);\n    }\n    if (WALK) {\n        z.x += pow(iTime, 1.);\n    }\n    if (ZOOM) {\n        z.y /= pow(iTime, 2.);\n        z.x /= pow(iTime, 2.);\n    }\n    col = vec4(eflip(z, vec2(exp(7.*(-ms.x+0.5)),exp(7.*(ms.y)))), 0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[895, 895, 914, 914, 956], [957, 957, 984, 984, 1049], [1050, 1050, 1077, 1077, 1108], [1110, 1110, 1139, 1166, 2853], [2855, 2855, 2901, 2901, 3585]], "test": "untested"}
{"id": "csKfzy", "name": "Ditherbrot II: Mandeltraps", "author": "domrally", "description": "Generated by 60 color tones and the 17 shade patterns of the 8 by 8 bayer dither matrix.\nShift & click to explore!\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]", "tags": ["fractal", "julia", "mandelbrot", "pixel", "dither", "bit", "lofi", "explorer", "bayer", "ordered"], "likes": 23, "viewed": 437, "published": 3, "date": "1698417026", "time_retrieved": "2024-07-30T17:25:39.183089", "image_code": "/// by Dom Mandy in 2023\n\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 r = iResolution.xy,\n         m = 1.2 * (2. * iMouse.xy - r) / r.y;\n    i += i - r;\n\n    // low resolution\n    i = round((i + .5) / 8.) * 8.;\n    mat2 t, z = 1.2 * mat2(i, -i.y, i) / (r.y - .5);\n\n    // animation\n    vec2 n = .618 * vec2(cos(-iTime), sin(-iTime));\n    // shift\n    n = mix(n, z[0], texelFetch(iChannel1, ivec2(16, 0), 0).r);\n    // click\n    n = mix(n, m, max(0., sign(iMouse.z)));\n\n    float f, k, e = 9.;\n    for (; k++ <= 31.; f < e ? e = f, t = z : t) {\n        if (f > 4.) break;\n\n        f = determinant(\n            z = z * z + mat2(n, -n.y, n)\n        );\n    }\n\n    // proportional to distance\n    float d = k / 17.,\n          // hue angle\n          h = atan(t[0].y, t[0].x),\n          // ordered bayer\n          b = texelFetch(iChannel0, ivec2((i + r) / 8.) % 8, 0).r;\n    h = (step(b, .5 + .5 * h / 6.28) - .5) / 2. + round(6. * h / 3.14) * 3.14 / 6.;\n\n    // color mapping\n    vec3 v = vec3(h - 2.1, h, h + 2.1);\n\n    o = round(5. * vec4(.5 + .5 * cos(v), 1.)) / 5.;\n    o = step(b, d * d) * o;\n}\n\n\n/*\nREFERENCES\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n\nrefactoring\n\nshadertoyjiang & FabriceNeyret2 2023\nhttps://www.shadertoy.com/view/DdcBWX\n\nSnoopethDuckDuck 2023\nhttps://www.shadertoy.com/view/cs3BRj\n*/\n\n\n/*\nFURTHER READING\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\nhttps://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Ordered_dithering\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Spectral_sensitivity\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n*/\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 63, 63, 1096]], "test": "untested"}
{"id": "DsVfRV", "name": "Offworld Storage Facility", "author": "Shane", "description": "Using a mixture of raymarching and cell by cell traversal techniques to raymarch a pseudo random box subdivision in order to render a basic sci-fi looking scene in realtime.", "tags": ["raymarching", "grid", "voxel", "greeble", "subdivide"], "likes": 84, "viewed": 1380, "published": 3, "date": "1698413623", "time_retrieved": "2024-07-30T17:25:40.175436", "image_code": "/*\n\n    Offworld Storage Facility\n    -------------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n/*\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 3., coc = 2.5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n*/\n\n\n// IQ's float to float hash. I've added an extra sine wrapping modulo to\n// cater for my annoying AMD based system, which can't wrap sine with a \n// proper degree of accuracy.\nfloat hash11B(float x){ return fract(sin(mod(x, 6.2831853))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a heap of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// If you're interested in bokeh, Dave's function above and some of Shadertoy user, \n// Hornet's, are probably the one's you should be looking at. Xor has some cool simple \n// ones on here too.\n//\nvec4 bloom(sampler2D iCh, vec2 uv){\n\n\n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 3., coc = 2.5;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float ra = clamp(l/coc, 0., 2.);\n    //float ra = smoothstep(.1, .9, abs(uv.y - .5)*2.)*2.;\n    //float ra = mix(clamp(l/coc, 0., 2.), smoothstep(.3, 1., abs(uv.y - .5)*2.), .25);\n    //float ra = (smoothstep(.2, 1., length(uv - .5)));\n\n \n\n    // Standard Fibonacci distribution calculations, compliments of Dave Hoskins.\n    const int iter = 96;\n    float rad = 2.5;//max(2.*ra, .5); // Bokeh radius.\n    float r = 1.;\n\tvec4 tot = vec4(0), div = tot;\n    vec2 vangle = vec2(0., rad*.01/sqrt(float(iter)));\n    #define GA 2.3999632 // Golden angle.\n    const mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n    // Aspect ratio.\n    vec2 aspect = vec2(iResolution.y/iResolution.x, 1);\n    \n    \n\tfor (int i = 0; i<iter; i++){\n        \n        #if 1\n        \n        // Dave Hoskin's Fibonacci based scattering. Cheaper and much nicer, so\n        // it's set as the default.\n        // The approx increase in the scale of sqrt(0, 1, 2, 3...).\n        r += 1./r;\n\t    vangle = rot*vangle;\n        vec4 col = texture(iCh, uv - (r - 1.)*vangle*aspect, iResolution.y/450.*1.); \n        \n        #else\n        \n        // A hash based random distribution, for anyone who wants to try it.\n        //int ii = i%10; // For square bokeh.\n        //int jj = i/10;\n    \n        // Random offset contained within a disk or radius n.\n        float fi = float(i) + fract(iTime);\n        //vec2 fi = vec2(ii, jj) - 5. + fract(iTime);\n        vec2 rnd2 = vec2(hash11B(fi), hash11B(fi + .1)*6.2831);\n        vec2 offs = 6.*sqrt(rnd2.x)*vec2(cos(rnd2.y), sin(rnd2.y));\n        offs *= rad;\n        //offs = rad*(offs + (vec2(hash11B(fi), hash11B(fi + .21)) - .5));\n        vec4 col = texture(iCh, uv - offs/iResolution.xy, iResolution.y/450.*1.);  \n  \n        #endif\n         \n        // Thanks to Dave for figuring out how to tweak the colors to produce brighter \n        // contrast. It's common sense... once someone figures it out for you. :D \n        //\n        // Linear falloff -- Not always necessary, but I need things to fade out\n        // toward the edges. Nonlinear falloff is possible too.\n        col *= 1. - float(i)/float(iter); \n        vec4 bokeh = col*col;\n\t\ttot += bokeh*bokeh;\n\t\tdiv += bokeh;\n        \n\t}\n    \n    \n    // Mixing the original value with the bokeh tweaked value according\n    // to the depth of field and a hand tweaked brightness factor.\n    vec4 colOrig = texture(iCh, uv);\n\treturn colOrig + tot/div*2.*ra; //mix(colOrig, colOrig + tot/div*2., ra);///\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen oordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Uncomment the \"DpthFld\" function first.\n    //vec4 col = DpthFld(iChannel0, uv).xyzz;\n\n    \n    // A bloom function. A lot of it comes from Dave Hoskins's bokeh function.\n    // See the function above for a link to the original.\n    vec4 col = bloom(iChannel0, uv);\n    \n    // Retrieving the stored color only.\n    //vec4 col = texture(iChannel0, uv);\n\n\n    // Subtle vignette.\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2)); \n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Offworld Storage Facility\n    -------------------------\n    \n    Using a mixture of raymarching and cell by cell traversal techniques \n    to raymarch a pseudo random box subdivision in order to render a\n    basic sci-fi looking scene in realtime. The methods used here aren't \n    what I'd call common, but most are not new either.\n    \n    I love perusing static geometry-based sci-fi scenes rendered with \n    applications like Blender, Cinema 4D, etc. Of course, this scene\n    doesn't compare to the beauty and sheer complexity of some of the\n    imagery out there, but hopefully it conveys that it's possible to do \n    more in a pixelshader than rendering a bunch of perfectly aligned \n    flat cubes.\n    \n    The methods used have been described before, but for those not\n    familiar, this is a rendering of a basic 3D subdivided grid, with some\n    extra XYZ axes shuffling to give the appearance of haphazardness.\n    This is definitely not what I'd call a decent random 3D packing, but\n    it was simple to make and efficient enough for the purposes of this\n    realtime demonstration. By the way, with some basic tweaks, this \n    particular packing can look quite random in appearance.\n    \n    A standard raymarching algorithm has been used with the addition of \n    ray-to-cell wall boundary collisions performed in order to advance \n    the ray from cell to cell. This way, you can render artifact free \n    scenes with most of the benefits or raymarching. More importantly, \n    only one cell per pass need be rendered, which means it's much faster. \n    It also means that you can render in more detail without slowing down \n    your GPU.\n    \n    Anyway, the purpose of this example was to demonstrate a traversal of\n    a quasi random box scene in realtime, so not a lot of effort was put\n    into the design -- I'm not sure where I was going with this, but it \n    has subtle Quake 3 overtones. :)\n    \n    \n    \n    Related examples:\n    \n    // This is more of a sliced layer example, but it's still a 3D traversal \n    // of what I'd call an irregular grid and it uses a similar technique.\n    asymmetric blocks layers tower - jt\n    https://www.shadertoy.com/view/DdKBDh\n    \n    // IQ was using a similar technique to this before it was cool. :D\n    Cubescape  - iq\n\thttps://www.shadertoy.com/view/Msl3Rr \n    \n\n*/\n\n// Maximum scene distance.\n#define FAR  15.\n\n// Color scheme - Copper with lights: 0, Titanium with purple: 1\n#define SCHEME 0\n\n// Light type - Direct: 0, Point: 1\n#define LIGHT_TYPE 1\n\n// Object ID.\nint gOID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n \n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed \n    // on account of the fact that I'm not in the habit of questioning stuff written by \n    // Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture \n    // sample, represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like \n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nfloat ubox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n \n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){ \n    //return texture(iChannel2, p).x;\n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\nfloat hashV(vec2 a, float b){\n\n    vec3 p = vec3(a.x, b, a.y);\n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n\n}\n/*\n// This is IQ's WebGL 2 hash formula: I've modified it slightly to \n// take in the normal decimal floats that we're used to passing. It \n// works here, I think, but I'd consult the experts before using it.\n//\n// I remember reading through a detailed explanation of the C++ hash \n// we all used to use many years ago (which the following would be\n// similar to), but have long since forgotten why it works. By the \n// way Nimitz, and Dave Hoskins have formulae on Shadertoy that's worth\n// looking up.\n//\n// Integer Hash - III - IQ\n// https://www.shadertoy.com/view/4tXyWN\nfloat hash21(vec2 p){\n    \n    uvec2 q = floatBitsToUint(p);\n\tq = 1103515245U*((q>>1U)^q.yx);\n    uint n = 1103515245U*(q.x^(q.y>>3U));\n    return float(n)/float(0xffffffffU);\n}\n*/\n\n\n \n\nvec4 uTone(vec4 x){\n    return ((x*(x*.6 + .1) + .004)/(x*(x*.6 + 1.)  + .06) - .0667)*1.933526;    \n}\n\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nvec3 smin(vec3 a, vec3 b, float k){\n\n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nvec3 smax(vec3 a, vec3 b, float k){\n    \n   vec3 f = max(vec3(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 path(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 1., t);\n     \n    // Transcendental path moving around the XY plane.\n    float a = sin(t*.22);\n    float b = cos(t*.28);\n    return vec3(a*4. - b*1.5, (b*1.2 + a*1.), t);\n     \n    \n}\n\n\n/*\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ \n\n    //float h = getTex(iChannel0, p/32.).x; \n    float h = dot(getTex(iChannel0, p/32.), vec3(.299, .587, .114)); \n    float hv = min(h, abs(p.x)/8.);\n    return hv*8. + h*1. + .05;//h*.975 + .025;\n }\n */\n \n // The 3D distance field function to test voxels against. This is\n // just some 3D noise with a path guided tunnel running through it.\n float hm(vec3 p3){\n\n    // Path.\n    vec2 pth = path(p3.z).xy;\n    vec3 p = p3;\n    p.xy -= pth.xy;\n    \n    // Noise with a cylinder (wrapped around a path) taken out of it.\n    float tx = texture(iChannel2, p3/48.).x;\n    return max((tx - .5), -(length(p.xy/vec2(1, 1.5)) -  .85));\n\n}\n\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec3 hash23(vec3 f){\n    \n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n    \n    // See: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); \n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// Subdivided rectangle grid.\nvec3 getGrid(vec3 p, inout vec3 sc, inout vec3 id){\n    \n \n    // Block offsets.\n    vec3 ipOffs = vec3(0);\n    /*\n    // Alternate Y floor bricks.\n    if(mod(floor(p.y/sc.y) + floor(p.z/sc.z), 2.)<.5){\n        p.x -= sc.x/2.; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.x += .5; //*hash21(vec2(0, id.y))\n    }*/\n    \n    // X, Y and Z offsets.\n    vec3 ii = floor(p/sc);\n    //vec3 h3 = vec3(hash21(ii.xy), hash21(ii.yz), hash21(ii.zx))*.5 + .5;//\n    vec3 h3 = vec3(2./3.);//\n    \n    vec3 mp = mod(ii, 2.);//mod(floor(p/sc), 2.);\n    if(mp.x<.5 && mp.y>.5){\n        p.z -= sc.z/2.*h3.x; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.z += .5*h3.x; //*hash21(vec2(0, id.y))\n    } \n    if(mp.y<.5 && mp.z>.5){\n        p.x -= sc.x/2.*h3.y; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.x += .5*h3.y; //*hash21(vec2(0, id.y))\n    }\n    if(mp.z<.5 && mp.x>.5){\n        p.y -= sc.y/2.*h3.z; // Row offset. //*hash21(vec2(0, id.y))\n        ipOffs.y += .5*h3.z; //*hash21(vec2(0, id.y))\n    }    \n\n \n    // Original position.\n    vec3 oP = p;\n    \n    \n    // Block ID.\n    vec3 ip;\n    \n    //ip = floor(p/sc) + .5;\n    \n    //#define EQUAL_SIDES\n    \n    // Subdivide.\n    for(int i = 0; i<2; i++){\n        \n        // Current block ID.\n        ip = floor(p/sc) + .5;\n        float fi = float(i)*.0617; // Unique loop number.\n        #ifdef EQUAL_SIDES        \n        // Squares.\n        \n        // Random split.\n        if(hash31(ip*sc + .253 + fi)<.333){\n           sc /= 2.;\n           p = oP;\n           ip = floor(p/sc) + .5; \n        }\n        \n        #else\n        \n        // Powers of two rectangles.\n        \n        //vec3 h23 = hash23(ip*sc + .253 + fi);\n        // h42 = texture(iChannel2, ip*sc*113.619 + .253 + fi);\n        \n        // Random X-split.\n        if(hash31(ip*sc + .253 + fi)<.333){//3 && sc.x>1./8.\n        //if(h23.x<.333){\n           sc.x /= 2.;\n           p.x = oP.x;\n           ip.x = floor(p.x/sc.x) + .5;\n        }\n        // Random Y-split.\n        if(hash31(ip*sc + .453 + fi)<.333){ // && sc.y>1./8.\n        //if(h23.y<.333){\n           sc.y /= 2.;\n           p.y = oP.y;\n           ip.y = floor(p.y/sc.y) + .5;\n        }\n        // Random Z-split.\n        if(hash31(ip*sc + .653 + fi)<.333){ // && sc.y>1./8.\n        //if(h23.z<.333){\n           sc.z /= 2.;\n           p.z = oP.z;\n           ip.z = floor(p.z/sc.z) + .5;\n        }        \n        #endif\n         \n    }\n    \n    // Cell ID (id is an \"inout\" variable).\n    id = (ip + ipOffs)*sc;    \n     \n    \n    // Return the local coordinates.\n    return p - ip*sc;\n\n}\n\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec3 gID;\nvec3 gP;\n\n\nvec3 glow; // Glow.\n\nfloat map(vec3 q3){\n  \n\n\n    // Floor. You can barely see it, but it's down there.\n    float fl = abs(q3.y + .1 + 4.) - .1;\n  \n     \n    vec3 sc = vec3(.5, 1, .5); // Scale.\n \n     // Local coordinates and cell ID.\n    vec3 id; // The cell ID is an \"inout\" variable.\n    vec3 p3 = getGrid(q3, sc, id); \n    // 3D coordinates.\n    vec3 p = p3;\n    \n   \n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - p)/gRd;\n    //vec2 rC = (gDir.xz*sc.xz - p)/gRd.xz; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0001;\n    //gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The 3D distance field for that particular cell. \n    // See the \"hm\" function, above.\n    float h = hm(id);\n \n\n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    vec3 oSc = sc;\n    sc -= .03;//.1*(hash31(id + .09)*.8 + .2);\n    \n    // Saving the global scale.\n    gSc = sc;\n    \n    \n    \n    // Object distance, inner window object and window light.\n    float d = 1e5;\n    float innerD = 1e5;\n    float winLight = 1e5;\n    \n    \n    // If we're under the 3D distance field zero mark, render an object,\n    // and whatever else, in that cell.\n    if(h<0.){\n   \n\n        // Edge factor.\n        float ef = sqrt(min(min(oSc.x, oSc.y), oSc.z));\n        \n        d = sBoxS(p, vec3(sc.x, sc.y, sc.z)/2., ef*.04);\n        float oD = d;\n        innerD = d + .08;\n        vec3 win;\n        win.x = sBoxS(p, vec3(oSc)/vec3(3.5, 3.5, 2), ef*.04);\n        win.y = sBoxS(p, vec3(oSc)/vec3(2, 3.5, 3.5), ef*.04);\n        win.z = sBoxS(p, vec3(oSc)/vec3(3.5, 2, 3.5), ef*.04);\n        //win.z = sBoxS(p.xz, sc.xz/2., 0.);\n\n        \n\n        win = max(win, -innerD);\n        ////float tx = texture(iChannel2, q3*4.).x;\n        //win += tx*.002;\n\n        // Window frames.\n        d = min(d, min(min(win.x, win.y), win.z));\n        //d = min(d, win.y);\n        //d = min(d, win.z);\n\n\n\n        // Empty out the space in the windowed rooms.\n        d = max(d, -innerD);\n        innerD += .005;\n\n        \n        // Adding some very basic striated greeble lines. You could\n        // do much more interesting stuff than this.\n        vec3 q = p3;\n        q = mod(q, 1./16.) - .5/16.;\n         \n        // X-direction. Left and right box striations.\n        if(hash31(id + .11)<.35){\n            float lx = sBoxS(p.xy, oSc.xy/vec2(3.5) - ef*.06, 0.);\n            d = max(d, -lx);\n            winLight = min(winLight, lx);\n            /*vec2 q = p.xy;\n            d = max(d, -sBoxS(q, sc.xy/8., 0.));        \n            q = mod(q- sc.yz/12., sc.xy/3.) - sc.xy/3.;\n            d = max(d, -sBoxS(q , sc.xy/8., 0.));*/\n        }\n        else d = max(d, -max(abs(q.x) - .25/16., -oD));\n\n        // Z-direction box striations.\n        if(hash31(id + .21)<.35){\n           float lx = sBoxS(p.yz, oSc.yz/vec2(3.5) - ef*.06, 0.);\n            d = max(d, -lx);\n            winLight = min(winLight, lx);\n            /*vec2 q = p.yz;\n            d = max(d, -sBoxS(q, sc.yz/8., 0.));        \n            q = mod(q - sc.yz/12., sc.yz/3.) - sc.xy/3.;\n            d = max(d, -sBoxS(q , sc.yz/8., 0.));*/\n        }\n        else d = max(d, -max(abs(q.z) - .25/16., -oD));\n    \n    }\n    \n \n    // Object ID.\n    gOID = d<innerD && d<fl? 0 : innerD<fl? 1 : 2;\n    \n\n    // Minimum distance.\n    d = min(fl, d);\n\n\n    // If we've hit the light object, add some glow.\n    if(max(winLight, innerD - .1)<d){\n         float rnd = hash31(id + .06);\n         vec3 gCol = .5 + .47*cos(6.2831*rnd/12. + vec3(0, 1.2, 2) + 1.);//vec3(1, .2, .1)\n         glow += gCol/(.001 + dot(p, p)*256.); // Truchet cable lights.\n    }\n\n\n    // Saving the box dimensions and local coordinates.\n    //gSc = vec3(sc.x, h, sc.z);\n    gSc = vec3(sc.x, sc.y, sc.z);\n    gID = id;\n    gP = p;\n    \n \n    // Return the minimum distance.\n    return d;\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iNum) {\n    \n    float d, t = hash31(ro + rd + fract(iTime))*.05;\n    //const float tol = TOLERANCE;\n    vec2 dt = vec2(1e8, 0);\n    int i = 0;\n    \n    glow = vec3(0);\n\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd; \n\n    const int iter = 160;\n    for (i = 0; i<iter; i++) {\n       \n        d = map(ro + rd*t);\n        // IQ's clever edge desparkle trick. :)\n        if (d<dt.x) { dt = vec2(d, t); } \n\n        if (d < .001*(1. + t*.05) || t > FAR) { break; }\n\n        t += min(d*.7, gCD);\n        //t += min(min(d*.7, gCD), .1);\n    }\n    \n    \n    //t = min(t, FAR);\n    \n    if(i == iter - 1) { t = dt.y; }\n\n    iNum = i;\n\n    return min(t, FAR);\n}\n\nfloat softShadow(in vec3 ro, in vec3 ld, float lDist, in float k) {\n    \n    // Shadow value: Initialized to the maximum.\n    float sh = 1.;\n    // Cyberjax's suggestion, to avoid potential divide-by-zero conflicts.\n    float t = 1e-8; \n    \n    /*\n    #if LIGHT_TYPE == 1\n    ld = (ld - ro);\n    float lDist = length(ld);\n    ld /= max(lDist, .0001);\n    #endif\n    */\n\n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(ld)*.5;\n    gRd = ld; \n\n    for (int i = 0; i<48; i++){\n    \n        float d = map(ro + ld*t);\n        sh = min(sh, k*d/t);\n        if (sh<0. || t>lDist) break;\n        t += clamp(min(d, gCD), .01, .5);\n    }\n    \n    return max(sh, 0.); // Shadow range: [0, 1].\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, \n// or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale \n    // texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks \n    // to EvilRyu for reminding me why we perform this step. It's been a while, but I \n    // vaguely recall that it's some kind of orthogonal space fix using the Gram-Schmidt \n    // process. However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n} \n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p) {\n\t\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map\n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.002, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n    \n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += max(hr - d, 0.)*sca;\n        sca *= .75;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\n///////////////////////////\nconst float PI = 3.14159265;\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(PI*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);   \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .88, .6).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Roughness.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return col*(diff + vec3(.2, .4, 1)*spec*PI);\n  \n}\n////////////////////\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 light, inout float tt){\n \n  \n  int iter;\n  float t = rayMarch(ro, rd, iter);\n  tt = t;\n  \n\n  // Saving the cell ID, cell scale, and local coordinates.\n  vec3 svID = gID;\n  vec3 svSc = gSc;\n  vec3 svP = gP;\n  \n  // Glow.\n  vec3 svGlow = glow;\n  \n  // Object ID.\n  int svOID = gOID;\n  \n  // Dark fog color.\n  vec3 fog = mix(vec3(.7, 1, .5), vec3(.5, .7, 1), rd.y*.5 + .5)/64.;\n  \n  // Diferent color scheme fog.\n  #if SCHEME == 1\n  fog = fog.zxy*4.;\n  #endif\n  \n  // Initialize the scene background to the fog.\n  vec3 col = fog;\n   \n  \n  // If we've hit an object, color it in.\n  if (t < FAR) {\n  \n    // Hit point and normal.\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    \n    \n    // Texture base bump mapping.\n    n = texBump(iChannel1, p*2. + svID/4.*0., n, .005);///(1. + t/FAR)\n    \n    \n    // Light type: Point light or directional light.\n    #if LIGHT_TYPE == 1\n    vec3 ld = light - p; // Point light.\n    float lDist = length(ld);\n    ld /= max(lDist, .001);\n    float atten = 1./(1. + lDist*lDist*.5);\n    #else\n    float lDist = FAR; \n    vec3 ld = normalize(light); // Directional light.\n    float sDist = length(ld*FAR - t*rd)/FAR;\n    float atten = 1./(1. + sDist*sDist*.5);\n    #endif\n    \n    \n    // Shadow and AO.\n    float shd = softShadow(p + n*.0015, ld, lDist, 8.);\n    float ao = calcAO(p, n);\n    \n    // Texturing the surface.\n    float txSc = svOID==0? 1. : 1./3.;\n    vec3 tx = tex3D(iChannel1, (p + svID/4.*0.)*txSc, n);\n  \n   \n    // Material properties.\n    // Adding in some very artificial microfaceted surface roughness.\n    float matType = 1.; // Metallic.\n    float roughness = min(dot(tx, vec3(.299, .587, .114))*3., 1.);\n    float reflectance = .5;\n \n    \n    // Main object color. Some kind of copper, I guess.\n    vec3 oCol = vec3(.8, .6, .4)/3.;\n    \n    \n    #if SCHEME == 1\n    oCol = mix(oCol.yzx, oCol.yyy, .8); // Different color scheme.\n    #endif\n    \n    // Floor color.\n    if(svOID==2) oCol /= 2.;\n    \n    // Window light color. Obviously brighter.\n    if(svOID==1) oCol = vec3(4);\n  \n   \n    // Adding some texture to the color.\n    oCol *= tx*2. + .05;\n    \n    // Randomly shading various objects.\n    float h = hash31(svID + .12);\n    oCol *= h*.5 + .5;\n    \n \n    // Specular reflection. \n    vec3 hv = normalize(ld - rd); // Half vector.\n    vec3 ref = reflect(rd, n); // Surface reflection.\n    vec3 refTx = texture(iChannel3, ref).xyz; refTx *= refTx; // Cube map.\n    float spRef = pow(max(dot(hv, n), 0.), 5.); // Specular reflection.\n    float rf = 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .02));\n    rf *= (svOID == 0)? 32. : .1;\n    oCol += oCol*spRef*refTx.xxx*rf*1.;\n    \n    \n    // BRDF lighting.\n    vec3 ct = BRDF(oCol, n, ld, -rd, matType, roughness, reflectance);\n    \n    // Ambient light.\n    #if LIGHT_TYPE == 1\n    float amb = .4;\n    #else \n    float amb = .3; // A little less ambient light for direct lighting.\n    #endif\n    \n    // Applying lighting and shadows.\n    col = (oCol*amb*(shd*.5 + .5) + ct*shd); \n    \n     \n    #if SCHEME == 1\n    svGlow = svGlow.yzx; // Alternate color scheme.\n    #endif\n    \n    // Adding the window glow.\n    col += oCol*mix(svGlow.zyx, svGlow.yxz, min(length(svP/gSc), 1.))*4.;\n    \n    // AO and attenuation.\n    col *= ao*atten; \n    \n\n  }\n\n  // Applying the fog.\n  col = mix(col, fog, smoothstep(.3, .99, t/FAR));\n  \n  // Scene color.\n  return col;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n  vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n \n  \n  \t// Camera Setup.\n    float speed = 1.;\n    float tm = iTime*speed;\n    vec3 lk = path(tm + .25) + vec3(0, -.05, 0);  // \"Look At\" position. Look down a bit.\n    vec3 ro = path(tm);// + vec3(0, 1.5, 0); // Camera position, doubling as the ray origin.\n    \n    #if LIGHT_TYPE == 1\n    vec3 lp = path(tm + 3.25); // Light position, somewhere near the moving camera.\n   // Light position offset. Redundant here.\n    vec3 loffs =  vec3(0, 0, 0);\n    //vec2 a = sin(vec2(1.57, 0) - lp.z*1.57/10.);\n    //loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    lp += loffs;\n    #else\n    vec3 lp = -vec3(1, -4, -2); // Directional light option.\n    #endif\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 rd = normalize(fwd/FOV + uv.x*rgt + uv.y*up);\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2(path(lk.z).x/24.)*rd.xy; \n\n    float t;\n    vec3 col = render(ro, rd, lp, t);\n    \n    // Applying a bit of last minute Uncharted 2 toning.\n    col = uTone(col.xyzx).xyz;\n    //col = col/(1. + col/2.5); // Rough extended Reinhard toning.\n\n    \n    \n    #if 0\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./2.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), t), blend);\n    #else\n    fragColor = vec4(max(col, 0.), t);\n    #endif\n}\n", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1727, 1903, 1926, 1926, 1977], [1979, 2407, 2442, 2629, 5307], [5309, 5309, 5363, 5391, 5995]], "test": "untested"}
{"id": "csVBzV", "name": "spqr transparency", "author": "spqr", "description": "more tricks", "tags": ["a"], "likes": 3, "viewed": 146, "published": 3, "date": "1698413538", "time_retrieved": "2024-07-30T17:25:41.009207", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 ap = abs(p) - s;\n    return length(max(vec3(0.),ap)) + min( 0., max(ap.x,max(ap.y,ap.z)));\n\n\n}\n\n\nfloat tick(float t) {\n\n    float n = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return n + r;\n}\nfloat field (vec3 p, float scale) {\n\n\n   float tt = tick(iTime*.67);\n   scale *= .25;\n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n\n   float ball = box(p, pow(f1,sin(tt*1.617)*.5+.5) * vec3(.49));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\n\nfloat map (vec3 p){\n    p.xz *= rot(iTime*.1);\n \n    float thing = box(p, vec3(3));\n\n   // geo\n   \n    for (float i = 0.; i < 5.; i++) {\n       thing = max(thing, -field(p,pow(2.,i)));\n    }\n\n    return thing;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  // nav\n  \n  vec3 s = vec3 (0,0,-4);\n  s *= (sin(iTime*.3)*.5+.5)+.2;\n  vec3 t = vec3(0);\n  \n \n  \n  float tt = iTime * .3;\n  s.xz *= rot(tt*.4);\n  s.xy *= rot(tt*.5);\n  s.zy *= rot(tt*.7);\n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  \n  vec3 col = vec3(0);\n  \n  vec3 p = s;\n  \n  float dd = 0.;\n  \n  float side=sign(map(p));\n  int hit = 0;\n  for(int i = 0; i < 1000; i++) {\n  \n      float d=map(p)*side;\n      \n      if(d<0.01) {\n          hit++;\n          vec3 n = norm(p)*side;\n          vec3 l = normalize(vec3(-1));\n          \n      \n          vec3 h = normalize(l-r);\n          \n          float diff = max(0., dot(n,l));\n          float spec =( 0.4 + pow(max(0., dot(n,h)),100.));\n          \n          vec3 remaining = vec3(1) - col;\n          col += remaining  *  spec * .2 * (dd/10.);\n              \n          side = -side;\n          \n          d = .1;\n          if (hit >10) { break;}\n          \n      }\n      if ( dd > 10.) {\n          break;\n      }\n       \n      dd += d;\n      p+=r*d;\n  }\n  \n\n  \n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [91, 91, 114, 114, 163], [168, 168, 191, 191, 294], [297, 297, 324, 324, 406], [408, 408, 436, 436, 540], [543, 543, 564, 564, 725], [726, 726, 761, 761, 1076], [1078, 1078, 1097, 1097, 1289], [1290, 1290, 1309, 1309, 1429], [1432, 1432, 1489, 1489, 2784]], "test": "untested"}
{"id": "DdVBzV", "name": "Hinged Truchet - AA", "author": "FabriceNeyret2", "description": "Hinged hexagon truchet\nInspiration: [url]https://twitter.com/KeishiroUeki/status/1715924571180990920[/url]\nGolfing antialiased version of \"Hinged Truchet\" by fad. https://shadertoy.com/view/dsGBDR", "tags": ["hexagon", "tiling", "hex", "tile", "tessellation", "hinge"], "likes": 25, "viewed": 404, "published": 3, "date": "1698412708", "time_retrieved": "2024-07-30T17:25:41.855943", "image_code": "// Golfing antialiased version of \"Hinged Truchet\" by fad. https://shadertoy.com/view/dsGBDR\n\n#define S smoothstep//\n#define T S( Z, 9./R.y\n\nvoid mainImage(out vec4 O, vec2 I) {\n    float A = 1.05, Z, k,h, i=A,\n          a = S(Z,1., S(1.,Z, abs( 1. - mod(iTime/3.,2.) ) )) * A;      \n    mat2  M = mat2( 1.73, 1, 0, 2 ) * cos( a - A/2. );\n    vec2  R = iResolution.xy, \n          p = 3.* ( I+I - R ) / R.y,\n          b = inverse(M) * p,\n          c = fract(b),\n          d = b-c + step( ( clamp(3.*c, 1., 2.) - c ).yx, c+c );\n    O = 1.57*vec4(0,1,-1,0); //  vec4(0,33,11,0)  \n    a = max( c = abs( p = ( p - M*d ) * mat2(cos( a -2.*a*mod(d.x,2.) + O)) ), \n            .87*c.x + .5*c ).y - .87;\n    \n    for ( h = fract(1e4*sin(dot(d, R-13.))) < .5 ? h : A ; k < 7.; k += 2.094 ) // 2.1\n        i = min( i, length( p - cos( k+h+O.wz) ) -.5 );\n\n    O = mix( mix( 1.5 + ( dFdx(i) +2.*dFdy(i) )*R.y/22. * ( T, i) - .5 ),\n                  pow( max( 5.*abs(i) - 1., Z), .07 ) * ( a < -.2 ? .8 : .6),   \n                  T,abs(i)-.2)\n                ), \n             .3, T,a) )\n      * vec4(.11,.58,.67,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsVBzK", "name": "foveated gaussian blur", "author": "FabriceNeyret2", "description": "sigma ~ dist to mouse", "tags": ["blur", "gaussian", "foveated"], "likes": 14, "viewed": 384, "published": 3, "date": "1698407338", "time_retrieved": "2024-07-30T17:25:42.608930", "image_code": "  #define T(u) texelFetch(iChannel0, ivec2(u), 0 )                    // apply on texture\n//#define T(u) ( P = floor((u)/8.), vec4( mod(P.x+P.y,2.) ) )         \n\n#define gauss(v) exp(-.5*v*v)                                         // Gaussian\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          P = ( 2.*u - R ) / R.y,\n          M = iMouse.xy;\n          M = length(M)<10. ? .5*vec2(cos(iTime),sin(iTime))          // demo mode: simulate moving mouse\n                            : ( 2.*M - R ) / R.y;                     // mouse\n                            \n    float s = 10.*length(P-M), w,t;                                   // sigma ~ dist to mouse\n    int L = int(ceil(2.*s));\n    O *= w;\n    for (int y = -L; y <= L; y++ )                                    // filter window\n        for (int x = -L; x <= L; x++ )\n            t += w = gauss( length(vec2(x,y))/s ),                    // local & cumulated weight\n            O += w * T( u + vec2(x,y) );                              // weighted sum\n    O /= t;\n // O = sqrt(O);                                                      // for the checker, add final sRGB conversion\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 283, 283, 1162]], "test": "untested"}
{"id": "DdyBzw", "name": "Neural Network Filter", "author": "BenzeneRachel", "description": "A program to generate real-time images from a rudimentary randomized neural network. Click and drag to change the output. The instructions (comments in the code) should tell you what the important listed parameters mean so you can mess with it yourself!", "tags": ["experiment", "webcam", "microphone", "neuralnet"], "likes": 0, "viewed": 108, "published": 3, "date": "1698386506", "time_retrieved": "2024-07-30T17:25:43.365906", "image_code": "float rand(float co) { return sin(co*(91.3458) * 47453.5453); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int inputs = 8;\n    const int outputs = 3;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 cam = texture(iChannel0, uv).rgb;\n    vec3 mic = texture(iChannel1, uv).rgb*5.0;\n    uv = fragCoord/iResolution.xy-.5;\n    uv[0] *= iResolution.x/iResolution.y;\n    vec2 mv = iMouse.xy/iResolution.xy-.5;\n    mv[0] *= iResolution.x/iResolution.y;\n    \n    // !! INSTRUCTIONS ABOUT WHAT THE VARIABLES MEAN FOR PEOPLE WHO WANT TO MESS WITH THE CODE !!\n    // note: if a variable uses \"any real number,\" then ALWAYS use a decimal (example: \"5.\" or \"5.0\", but NOT \"5\")\n    // if a variable uses integer values only, do not use a decimal\n    // enjoy!\n    \n    // seed: any real number - the random seed that generates the network parameters\n    float seed = 7.;\n    \n    // layers: integer values only - is the number of hidden layers in the neural network (recommended: 3-10)\n    const int layers = 8;\n    \n    // density: integer values only - is the number of neurons per hidden layer (recommended: 3-10)\n    const int density = 8;\n    \n    // wr (weight range): any positive number - the range of possible values of weights from -wr to +wr (experiment!)\n    float wr = 3.*sin(iTime);\n   \n    // br (bias range): any positive number or zero - the range of possible values of biases from -br to +br (experiment!)\n    float br = 1.;\n    \n    // smoothness: any real number - the higher the smoothness value, the less discrete the output is (depends on the layers, density, wr, and br) \n    float smoothness = 20.0;\n    \n    // uv[0] and uv[1]: any real number - the input weights of the x and y values of the screen respectively (experiment!)\n    uv[0] *= 1.0;\n    uv[1] *= 1.0;\n    \n    // mv[0] and mv[0]: any real number - the input weights of the x and y coordinates of the mouse cursor respectively (recommended: 5.0)\n    mv[0] *= 5.0;\n    mv[1] *= 5.0;\n    \n    // cam[0], cam[1], and cam[2]: any real number - the input weights of the red, green, and blue components from the iChannel0 Webcam respectively (recommended: 1.0)\n    cam[0] *= 1.0;\n    cam[1] *= 1.0;\n    cam[2] *= 1.0;\n    \n    // mic[0]: any real number - the input weight from the iChannel1 Microphone (experiment!)\n    mic[0] *= 0.0;\n    \n    // I'm too lazy to comment consistently on the rest of my code so good luck past this point\n    float[layers*density] network;\n    float[] inpt = float[](uv[0],uv[1],mv[0],mv[1],cam[0],cam[1],cam[2],mic[0]);\n    vec3 col;\n    float x;\n    float outpt;\n    float ep;\n    float en;\n    for (int h = 0; h < density; h += 1)\n    //neural network input loop\n    {\n        x = rand(seed);\n        outpt = x*br;\n        seed += x;\n        for (int i = 0; i < inputs; i += 1)\n        {\n            x = rand(seed);\n            outpt += inpt[i]*x*wr;\n            seed += x;\n        }\n        ep = exp(outpt);\n        en = exp(-1.0*outpt);\n        network[h] = (ep-en)/(ep+en);\n    }\n    //neural network hidden layers loop\n    for (int h = 0; h < layers-1; h += 1)\n    {\n        for (int i = 0; i < density; i += 1)\n        {\n            x = rand(seed);\n            outpt = x*br;\n            seed += x; \n            for (int j = 0; j < density; j += 1)\n            {\n                x = rand(seed);\n                outpt += network[h*density+j]*x*wr;\n                seed += x;\n            }\n            ep = exp(outpt);\n            en = exp(-1.0*outpt);\n            network[(h+1)*density+i] = (ep-en)/(ep+en);\n        }\n    }\n    //neural network output loop\n    for (int h = 0; h < outputs; h += 1)\n    {\n        for (int i = 0; i < density; i += 1)\n        {\n            x = rand(seed);\n            outpt += network[density*(layers-1)+i]*x*wr;\n            seed += x;\n        }\n        ep = exp(outpt/smoothness);\n        en = exp(-1.0*outpt/smoothness);\n        col[h] = (ep-en)/(ep+en)+1.0/2.0;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 63]], "test": "untested"}
{"id": "DdyBzK", "name": "spqr domain trick 14", "author": "spqr", "description": "Now with transarency", "tags": ["a"], "likes": 6, "viewed": 228, "published": 3, "date": "1698384900", "time_retrieved": "2024-07-30T17:25:44.114903", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 ap = abs(p) - s;\n    return length(max(vec3(0.),ap)) + min( 0., max(ap.x,max(ap.y,ap.z)));\n\n\n}\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm( vec2 a)\n{\n    vec3 p = vec3(a,1.);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat field (vec3 p, float scale) {\n\n\n   float tt = iTime * .1;\n   scale *= .25;\n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n\n   float ball = box(p, pow(f1,sin(tt*.5)*.5+.5) * vec3(.49));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\n\nfloat map (vec3 p){\n    p.xz *= rot(iTime*.1);\n \n    float thing = box(p, vec3(3));\n\n   // geo\n   \n    for (float i = 0.; i < 4.; i++) {\n       thing = max(thing, -field(p,pow(2.,i)));\n    }\n\n    return thing;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  // nav\n  \n  vec3 s = vec3 (0,0,-4);\n  s *= (sin(iTime*.3)*.5+.5)+.2;\n  vec3 t = vec3(0);\n  \n  float tt = iTime * .3;\n  s.xz *= rot(tt*.4);\n  s.xy *= rot(tt*.5);\n  s.zy *= rot(tt*.7);\n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  \n  vec3 col = vec3(0);\n  \n  vec3 p = s;\n  \n  float dd = 0.;\n  \n  float side=sign(map(p));\n  \n  for(int i = 0; i < 400; i++) {\n  \n      float d=map(p)*side;\n      \n      if(d<0.001) {\n          vec3 n = norm(p)*side;\n          vec3 l = normalize(vec3(-1));\n          \n          if ( dot(n,l) < 0.) {\n              //l = -l;\n          }\n          vec3 h = normalize(l-r);\n          \n          float diff = max(0., dot(n,l));\n          float spec =( 0.4 + pow(max(0., dot(n,h)),100.));\n          \n          vec3 remaining = vec3(1) - col;\n         // col += pow(remaining * diff *  spec, vec3(2.));\n          col += remaining  *  spec * .2;\n              \n          side = -side;\n          \n          d = .1;\n          \n      }\n      if ( dd > 10.) {\n          break;\n      }\n       \n      dd += d;\n      p+=r*d;\n  }\n  \n\n  \n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyBzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [950, 950, 973, 973, 1068], [1070, 1070, 1097, 1097, 1179], [1181, 1181, 1209, 1209, 1313], [1314, 1314, 1336, 1336, 1426], [1427, 1427, 1448, 1448, 1739], [1741, 1741, 1761, 1761, 1944], [1945, 1945, 1974, 1974, 2002], [2003, 2003, 2038, 2038, 2345], [2347, 2347, 2366, 2366, 2558], [2559, 2559, 2578, 2578, 2698], [2700, 2700, 2720, 2720, 2817], [2819, 2819, 2860, 2860, 2906], [2907, 2907, 2929, 2929, 2986], [2987, 2987, 3011, 3011, 3149], [3152, 3152, 3209, 3209, 4547]], "test": "untested"}
{"id": "DdyBRV", "name": "Nestled Sine Onions", "author": "isaacchurchill", "description": "I know it would be more efficient to have each pixel just test what sine curve it's closest to, but then the regions where they all overlap wouldn't look the same.", "tags": ["2d", "sine", "rainbow", "onion"], "likes": 8, "viewed": 235, "published": 3, "date": "1698374897", "time_retrieved": "2024-07-30T17:25:44.869885", "image_code": "#define PI 3.14159265\n\nvec3 palette(float x)\n{\n    return 0.5 + 0.5 * cos(x + vec3(0,2,4));\n}\n\nvec3 graph(vec2 p)\n{\n    float t = iTime * 0.1;\n    vec3 col = vec3(0.0);\n    for (float y = -2.0; y <= 1.0; y += 0.05) {\n        float i = y + fract(t);\n        float dist = abs(p.y - i - cos(p.x * PI) * sin(i * PI) / PI);\n        float intensity = exp(dist * -50.0);\n        float highlight = exp(dist * -200.0);\n        col += palette(y * PI * 2.0 + t) * intensity + highlight;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    vec3 col = graph(p);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 46, 46, 93], [95, 95, 115, 115, 499], [501, 501, 558, 558, 682]], "test": "untested"}
{"id": "DdyBRK", "name": "lineDitherContinuous", "author": "natet", "description": "Dithering with line thicknesses, but with continuous line thickness instead of constant line thickness per box", "tags": ["dithering"], "likes": 0, "viewed": 152, "published": 3, "date": "1698363379", "time_retrieved": "2024-07-30T17:25:45.796407", "image_code": "//const float gridSize = iResolution.x*0.1;\n\nbool compare(float a, float b, float eta){\n    if(a > (b-eta) && a < (b+eta)){\n        return true;\n    } else {\n        return false;\n    }\n    \n}\n\nbool boxTest(vec2 pos, vec2 size, vec2 uv){\n    if(compare(uv.x,pos.x,size.x) && compare(uv.y,pos.y,size.y)){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float gridSize = iResolution.x*0.05;\n    \n    uv = fract(uv*gridSize);\n    \n    vec4 cam = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    float camVal = (cam.x+cam.y+cam.z)/6.0;\n\n    vec3 col;\n    \n    bool box = boxTest(vec2(0.5,0.5),vec2(camVal,1.0), uv);\n\n    // Output to screen\n    if(box){\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.0);\n    }\n    fragColor = vec4(col,1.0);\n        \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 87, 87, 192], [194, 194, 237, 237, 367], [369, 369, 426, 476, 939]], "test": "untested"}
{"id": "cdyBRK", "name": "circleDitherColour", "author": "natet", "description": "Dithering with different size circles, in colour (colours are offset slightly in screen space)", "tags": ["dithering"], "likes": 1, "viewed": 299, "published": 3, "date": "1698363300", "time_retrieved": "2024-07-30T17:25:46.608237", "image_code": "//const float gridSize = iResolution.x*0.1;\n\nbool circleTest(vec2 pos, vec2 size, vec2 uv){\n    if(distance(pos,uv) < size.x){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float gridSize = iResolution.x*0.05;\n    \n    uv = fract(uv*gridSize);\n    \n    vec4 cam = texture(iChannel0, floor((fragCoord/iResolution.xy)*gridSize)*(1.0/gridSize));\n\n    vec3 col = vec3(0.0);\n    \n    bool circleR = circleTest(vec2(0.7,0.7),vec2(cam.x*0.5), uv);\n    bool circleG = circleTest(vec2(0.3,0.5),vec2(cam.y*0.5), uv);\n    bool circleB = circleTest(vec2(0.7,0.3),vec2(cam.z*0.5), uv);\n\n    // Output to screen\n    if(circleR){\n        col.x = 1.0;\n    } else {\n        col.x = 0.0;\n    }\n    \n    if(circleG){\n        col.y = 1.0;\n    } else {\n        col.y = 0.0;\n    }\n    \n    if(circleB){\n        col.z = 1.0;\n    } else {\n        col.z = 0.0;\n    }\n    \n    fragColor = vec4(col,1.0);\n        \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdyBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 91, 91, 190], [192, 192, 249, 299, 1063]], "test": "untested"}
{"id": "DsGBRK", "name": "circleDitherGreyscale", "author": "natet", "description": "Dithering with different size circles, in greyscale", "tags": ["dithering"], "likes": 0, "viewed": 167, "published": 3, "date": "1698363095", "time_retrieved": "2024-07-30T17:25:47.456967", "image_code": "//const float gridSize = iResolution.x*0.1;\n\nbool circleTest(vec2 pos, vec2 size, vec2 uv){\n    if(distance(pos,uv) < size.x){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float gridSize = iResolution.x*0.05;\n    \n    uv = fract(uv*gridSize);\n    \n    vec4 cam = texture(iChannel0, floor((fragCoord/iResolution.xy)*gridSize)*(1.0/gridSize));\n    \n    float camVal = (cam.x+cam.y+cam.z)/6.0;\n\n    vec3 col;\n    \n    bool circle = circleTest(vec2(0.5,0.5),vec2(camVal), uv);\n\n    // Output to screen\n    if(circle){\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.0);\n    }\n    fragColor = vec4(col,1.0);\n        \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 91, 91, 190], [192, 192, 249, 299, 800]], "test": "untested"}
{"id": "csGBRK", "name": "boxDither", "author": "natet", "description": "Dithering with different size boxes", "tags": ["dithering"], "likes": 1, "viewed": 202, "published": 3, "date": "1698362933", "time_retrieved": "2024-07-30T17:25:48.283757", "image_code": "//const float gridSize = iResolution.x*0.1;\n\nbool compare(float a, float b, float eta){\n    if(a > (b-eta) && a < (b+eta)){\n        return true;\n    } else {\n        return false;\n    }\n    \n}\n\nbool boxTest(vec2 pos, vec2 size, vec2 uv){\n    if(compare(uv.x,pos.x,size.x) && compare(uv.y,pos.y,size.y)){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float gridSize = iResolution.x*0.05;\n    \n    uv = fract(uv*gridSize);\n    \n    vec4 cam = texture(iChannel0, floor((fragCoord/iResolution.xy)*gridSize)*(1.0/gridSize));\n    \n    float camVal = (cam.x+cam.y+cam.z)/6.0;\n\n    vec3 col;\n    \n    bool box = boxTest(vec2(0.5,0.5),vec2(camVal), uv);\n\n    // Output to screen\n    if(box){\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.0);\n    }\n    fragColor = vec4(col,1.0);\n        \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 87, 87, 192], [194, 194, 237, 237, 367], [369, 369, 426, 476, 968]], "test": "untested"}
{"id": "tlBXzW", "name": "Rotation Cube", "author": "glk7", "description": "Minimalist image of a cube that can be rotated with the mouse.", "tags": ["cube", "rotation"], "likes": 1, "viewed": 139, "published": 3, "date": "1698360810", "time_retrieved": "2024-07-30T17:25:49.141464", "image_code": "// Created by genis sole - 2023\n// License Creative Commons Attribution-NonCommercial 4.0 International.\n\nvec3 draw_cube(vec2 uv, float e, vec4 q)\n{\n    const vec4 p = vec4(1.0, -1.0, 0.0, 1.0);\n    \n\tvec3 b1 = quatRotate(q, p.yyy);\n    vec3 b2 = quatRotate(q, p.yyx);\n    vec3 b3 = quatRotate(q, p.xyx);\n    vec3 b4 = quatRotate(q, p.xyy);\n   \n   \tvec3 t1 = quatRotate(q, p.yxy);\n    vec3 t2 = quatRotate(q, p.yxx);\n    vec3 t3 = quatRotate(q, p.xxx);\n    vec3 t4 = quatRotate(q, p.xxy);\n    \n    const float zd = 10.0;\n    \n  \tb1.xy = b1.xy / (b1.z + zd);\n    b2.xy = b2.xy / (b2.z + zd);\n    b3.xy = b3.xy / (b3.z + zd);\n   \tb4.xy = b4.xy / (b4.z + zd);\n    \n    t1.xy = t1.xy / (t1.z + zd);\n    t2.xy = t2.xy / (t2.z + zd);\n    t3.xy = t3.xy / (t3.z + zd);\n    t4.xy = t4.xy / (t4.z + zd);\n    \n    float tp1 = dot(uv - t1.xy, normalize(t2.xy - t1.xy).yx * vec2(-1.0, 1.0));\n    float tp2 = dot(uv - t1.xy, normalize(t4.xy - t1.xy).yx * vec2(-1.0, 1.0));\n    float tp3 = dot(uv - t3.xy, normalize(t2.xy - t3.xy).yx * vec2(-1.0, 1.0));\n    float tp4 = dot(uv - t3.xy, normalize(t4.xy - t3.xy).yx * vec2(-1.0, 1.0));\n    \n    float bp1 = dot(uv - b1.xy, normalize(b2.xy - b1.xy).yx * vec2(-1.0, 1.0));\n    float bp2 = dot(uv - b1.xy, normalize(b4.xy - b1.xy).yx * vec2(-1.0, 1.0));\n    float bp3 = dot(uv - b3.xy, normalize(b2.xy - b3.xy).yx * vec2(-1.0, 1.0));\n    float bp4 = dot(uv - b3.xy, normalize(b4.xy - b3.xy).yx * vec2(-1.0, 1.0));\n    \n    float sp1 = dot(uv - b1.xy, normalize(t1.xy - b1.xy).yx * vec2(-1.0, 1.0));\n    float sp2 = dot(uv - b2.xy, normalize(t2.xy - b2.xy).yx * vec2(-1.0, 1.0));\n    float sp3 = dot(uv - b3.xy, normalize(t3.xy - b3.xy).yx * vec2(-1.0, 1.0));\n    float sp4 = dot(uv - b4.xy, normalize(t4.xy - b4.xy).yx * vec2(-1.0, 1.0));\n    \n    \n    float ty = min(min(-tp1, tp2), min(tp3, -tp4));\n    float by = min(min(bp1, -bp2), min(-bp3, bp4));\n    \n    float tx = min(min(tp1, -bp1), min(sp1, -sp2));\n    float bx = min(min(tp4, -bp4), min(sp3, -sp4));\n    \n    float tz = min(min(-tp2, bp2), min(-sp1, sp4));\n    float bz = min(min(-tp3, bp3), min(sp2, -sp3));\n    \n    return smoothstep(0.0, e*2.0, vec3(max(tx, bx), max(ty, by), max(tz, bz)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.x;\n    vec2 uv = (fragCoord - iResolution.xy*0.5)*e;\n\n    vec3 col = vec3(smoothstep(0.0, e*1.2, length(uv) - 0.2));\n    \n    float ff = min(1.0, step(3.0, iMouse.x) + step(3.0, iMouse.y));\n    vec4 q = mix(load(QUATROT), quatRandom(iTime * 0.3), 1.0 - ff);\n    \n    col += draw_cube(uv, e, q);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Created by genis sole - 2023\n// License Creative Commons Attribution-NonCommercial 4.0 International.\n\n\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n\nconst ivec2 PMOUSE = ivec2(1, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (any(greaterThan(fragCoord.xy, vec2(2.0, 1.0)))) return;\n   \t\n    fragColor = load(fragCoord);\n    \n    if (iTime == 0.0 || iFrame == 0) {\n        store(QUATROT, vec4(vec3(0.0), 1.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n    \n    vec2 m = (iMouse.xy - iResolution.xy*0.5)/iResolution.x;\n    \n    vec4 pm = load(PMOUSE).xyzw;\n    \n    vec4 q = load(QUATROT);\n\n    float e = 1.0/iResolution.x;\n    \n    if (any(greaterThan(iMouse.zw, vec2(0.0)))) {\n        if (pm.z == 0.0) pm.xy = m.xy;\n        \n        vec2 dm = (m.xy - pm.xy)*5.0 * step(length(m), vec2(0.2));\n        \n        vec4 invq = quatConjugate(q);\n        vec3 rx = quatRotate(invq, vec3(1.0, 0.0, 0.0));\n        vec3 ry = quatRotate(invq, vec3(0.0, 1.0, 0.0));\n        \n        vec4 qx = quat(rx, dm.y);\n        vec4 qy = quat(ry, -dm.x);\n        \n        q = quatMult(q, quatMult(qx, qy));\n        \n    \tstore(QUATROT, normalize(q));\n        store(PMOUSE, vec4(vec2(m.xy), 1.0, 1.0));\n    }\n    else if (pm.z != 0.0) {\n        store(PMOUSE, vec4(0.0));\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by genis sole - 2023\n// License Creative Commons Attribution-NonCommercial 4.0 International.\n\n\nconst ivec2 QUATROT = ivec2(0, 0);\n#define load(P) texelFetch(iChannel0, ivec2(P), 0)\n\nvec4 quat(vec3 axis, float rads) {\n    return vec4(sin(rads*0.5)*axis, cos(rads*0.5)); \n}\n\nvec4 quatMult(vec4 q1, vec4 q2) {\n    return vec4(q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz),\n                q1.w*q2.w - dot(q1.xyz, q2.xyz));\n}\n\nvec3 quatRotate(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatConjugate(vec4 q) {\n\treturn vec4(-q.xyz, q.w);    \n}\n\n//David Hoskins hash: https://www.shadertoy.com/view/4djSRW \nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z)*2.0 - 1.0;\n}\n\nfloat gnoise(float p) \n{\n    float i = floor(p);\n\tfloat f = fract(p);\n    \n    float a = dot(hash11(i), f);\n    float b = dot(hash11(i + 1.0), f - 1.0);\n    \n    float u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u);\n}\n\nvec4 quatRandom(float t)\n{\n    vec3 a = vec3(gnoise(t + 2.0) * 3.1, gnoise(t + 6.0) * 3.5, gnoise(t + 4.0) * 3.2);\n    float s = clamp((gnoise(t + 10.0) + 0.5), -1.0, 1.0);\n    return normalize(vec4(a * s, sqrt(1.0 - s*s))); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBXzW.jpg", "access": "api", "license": "cc-by-nc-3.0", "functions": [[106, 106, 148, 148, 2187], [2189, 2189, 2246, 2246, 2609]], "test": "untested"}
{"id": "mdVfRy", "name": "Quat_Flycam + English_Lane", "author": "ollj", "description": "𝐑𝐨𝐭𝐚𝐭𝐞= 𝐀𝐫𝐫𝐨𝐰𝐊𝐞𝐲𝐬 || 𝐃𝐫𝐚𝐠𝐌𝐨𝐮𝐬𝐞 +𝐖𝐑 (=roll) \n𝐒𝐭𝐫𝐚𝐟𝐞= 𝐄𝐒𝐃𝐅                                +𝐓𝐆 (=upDown)  \nhttps://www.shadertoy.com/view/fsXXzX\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs", "tags": ["forest", "cellular", "trees", "nature", "path", "roads", "devon"], "likes": 31, "viewed": 865, "published": 3, "date": "1698356809", "time_retrieved": "2024-07-30T17:25:50.892782", "image_code": "/*\nvec4 Mode0_NoBuffer_mainImage( vec2 fragCoord, float aTime, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1\n){vec4 ppd\n ;vec4 col = mainScene( fragCoord, aTime, aResolution, aFrame, aMouse, aChannel1, ppd )\n ;col.rgb = postProcess( col.rgb, fragCoord / aResolution.xy, ppd )\n ;return col;}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord\n){fragColor = Mode0_NoBuffer_mainImage( fragCoord, iTime, iResolution, iFrame, iMouse , iChannel1); }\n\n/**/\n\nfloat segment(vec2 P, vec2 A, vec2 B\n){vec2 g=B-A\n ;vec2 h=P-A\n ;return length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));}\n\n\n#define fra(u)(u-.5*iResolution.xy)/iResolution.y\n\nvec4 drawDragVector(vec2 u\n){if (iMouse.z<0.)return vec4(0)\n ;vec2 a=fra(abs(iMouse.xy))\n ;vec2 b=fra(abs(iMouse.zw))\n ;//float r=smoothstep(.01,0.,abs(length(b-u)-.02));//ring\n ;float r=min(   segment(u,a,b   )//line segment\n             ,abs(length(b-u)-.02)//ring\n             )\n ;r=smoothstep(.01,0.,r)*.3//thickness, transparency\n ;return vec4(r);}//premultiplied for porterDuff\n\nvoid mainImage(out vec4 o, in vec2 u){\n //o=mainImage2(o,u);                         //mainIimage is in THIS channel\n o=texture(iChannel2,u/iResolution.xy, -100.);//mainIimage is in Ichannel2\n o=sat(o);//may need to clamp for an overlayd line\n //o+=drawDragVector(u/iResolution.xy*iResolution.x);//almost sufficient for a white line overlay\n o=pdOver(drawDragVector(fra(u)),o);//proper porter duff overlay.\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//union of \n//https://www.shadertoy.com/view/fsXXzX (English Lane                       )\n//https://www.shadertoy.com/view/wl3yDs (reproject volume quaternion 2022-02)\n//mostly to improve camera controls\n\n//tags:\n//traceQuadratic,bezierPatch,Quaternioncamera,fly,aabv,bspline,bpatch,pqfm\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n\n\n//----- START  of parameters and common functions for camera controls\n//\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam]\n//- does not allow for roll (and thus it never gridlocks)\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;//\n\n\n//camera starting position\nconst vec4 posStart=vec4(0,1,0,1);\n//\n#if (camType==0) \n #define CAMERA_SPEED .05\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n \n //accelleration and drag must be set to the scene scaling\n #define setScale 5.\n \n const float\n // if (camera is closer than PHYSICS_RADIUS) apply pushing force PHYSICS_REPEL along surface-normal.\n  //set to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=.0000001 //-100.\n ,PHYSICS_REPEL=1.//normal(cameraPosition)*PHYSICS_REPEL= how much colisions push the camera away. \n                  //no normalize() happens outside of normal(), which you may add or remove\n                  //depending on how good your df is andOr how your collisions handle deformed fields.\n ,LIN_ACCE=setScale*4.5//linear accelleration\n ,ANG_ACCE=setScale*2.0//angular accelleration\n ,LIN_DRAG=setScale*1.0//linear  drag/friction\n ,ANG_DRAG=setScale*2.0//angular drag/friction\n;\n#endif\n\n\n\n\n//#endif\n//\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n//\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n//----- end of parameters and common functions for camera controls\n\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//essential for the quaternion-camera.\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n//return normalize(q) //unnecessary, as long as lenght(q) is close to 1.\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n//this shader solves for smooth qlerp: \n//https://www.shadertoy.com/view/DtyfRV\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n//below is a likely bad untested qlerp.\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n//\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\n//the above has better precision than the below, but the functions are hopefully identical.\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){\n//return qv2v(b*vec4(1,1,1,-1),v);//somehow this is not identical, fuck it all!\nv2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n\n//from https://www.shadertoy.com/view/wlSyzd\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qq2q(qinv(q),qq2q(v3(p,0.0),q)).xyz;}//inverse rotation\n//---end__ quaternion\n\n\n\n\n\n\n\n\n\n//#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\n//v0 ad(v1 a){return a.x+a.y;}\n//v0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//instead of doing imouse.zw=abs(imouse.zw) iMouseZwFix only changes sign when needed.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n  \n//checkerboard of https://www.shadertoy.com/view/4lySzc\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n\n//a matrix of quadraticFields, that share no prime factors, is a fast and simple hash.\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n//maybe see https://www.shadertoy.com/results?query=pqfm\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n\n\n\n\n\n\n\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//from   https://www.shadertoy.com/view/wdsSWS\n//.w=0 is fully transparent, .W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs wioth their alpha;\n//; a.xyz*=a.w\n//; b.xyz*=b.w\n//and the outputs of these functions will be already_premultiplied.\n//\n//else if(you to one last pdOver a nontransparent background) you must NOT premultiply the backbround!\n//pdver without premultiplied alpha, note that nonstransparent red+nontransparent green = nontransparendt yellow.\n//vec4 pdo(vec4 a,vec4 b){return vec4((a.xyz*a.w+b.xyz*b.w)/(a.xyz+b.w*(1.-a.w)),,a.w+b.w*(1.-a.w));}\n//these functions are with premultiplied alpha (better performance, easy to buffer)\n//\n//GENERAL alpha composition:  named after porterDuff\n//see https://en.wikipedia.org/wiki/Alpha_compositing\n//    https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent, .W=1 is fully visible\n//inputs should be x=sat(x), or you likely get [color inverted hazes], this version is still not haze-free?\n//\n//on premultiplication:\n//iff (you want to keep an alpha channel after a composition)  !!!!\n//You must FIRST premultiplay all inputs with their alpha.w :  !!!!\n//; a.xyz*=a.w                                                 !!!!\n//; b.xyz*=b.w                                                 !!!!\n//on general [premultiply], you may want to watch              !!!!\n//https://www.youtube.com/watch?v=XobSAXZaKJ8                  !!!!\n//\n//IFF you can discard the alpha channel after a SINGLE composition\n//, you may also skip the premultiply-multiplication in some cases.\n\n//ut() is a subroutine for alpha compositing:\n//#define ut(a,b) (a*(1.-b))   //this one liner is a lot less worksafe!\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}\n//below are the 5 alpha compositions:\nvec4 pdOut (vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+(a*b.w);}\nvec4 pdXor (vec4 a,vec4 b){return ut(b,a.w)+vec4(ut(a,b.w));}\nvec4 pdIn  (vec4 a,vec4 b){return vec4(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//the above ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//the above ommits 2 functions, that return a or b, for simplicity\n//end of basic part of alpha compositing (yep, thats ALL there is to it)\n//\n//start of extended alpha compositing \n//...adds interpolation+generalization to compositing (interpolating different types of compositing)\n//The below allows you to MIX(a,b,c) between any 2 or 4 types of alpha compositing, by the parameter [c]\n//pf() does unify all 5 pd-compositions (above) into 1 parametric function\n//pf() was a silly idea of smoothly cyling between 5 compositions\n//pf() was quickly obsoleted by pf()\n//pdOverAtop() and pdOutXor() are interpolating subroutines for pf()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\n//pf() has c set how we interpolate; c is range [0..4] and whole-bumber-c causes a [mix(a,b,0.)==a] result\n#define Over 0. //[c range 0..1 => over..atop]\n#define Atop 1. //[c range 1..2 => atop..out]\n#define Out  2. //[c range 2..3 =>  out..Xor]\n#define Xor  3. //[c range 3..4 =>  xor..In]\n#define In   4.\n//the ability to interpolate is just a side effect of using mix() to generalize.\n//pf() may actually only work well for c=floor(c) its not tested well.\nvec3 pf(vec4 a,float c,vec4 b\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\n//\n//pd() makes more sense than pf() for demoing interpolation of compositing\n//pd() does bilinear interpolatin over c.xy, as in https://www.shadertoy.com/view/wdsSWS\n//top    left  = Over\n//top    right = Xor\n//bottom left  = Atop\n//bottom right = Out \nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//clamping c.x to ensure bounds.\n ;return mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w);}\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// English Lane by Jerome Liard, April 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/fsXXzX\n//\n// You are walking and flying through an infinite English countryside.\n// Chill out and use the mouse to look around. \n// A single walk->fly cycle is about 50s.\n//\n// Shadertoy compilation time seems to be about 15s, thanks for your patience.\n\n// first lane index, at each walk-flight cycle we switch to next lane midair\n#define FIRST_LANE_INDEX 10.0\n\n// If the reprojection is janky please press the button that resets time to zero.\n//\n// I wanted to make a navigable countryside with paths inspired by paintings from Richard Thorn (see his book \"Down an English Lane\"), \n// and a little bit by Hiroshi Nagai and Tezuka Osamu's Jumping short anime (both life long inspirations).\n//\n// Creation of the initial patchwork and parameterized paths network:\n//\n//   - 2 perpendicular sets of regularly spaced parallel 1d lanes are used. \n//   - Each 1d lane has an id. The amplitude of each 1d lane must be such that they don't cross the previous or next 1d lane.\n//   - The horizonal set of parallel lanes have constant vertical center spacing.\n//   - The twist: the vertical set of parallel lanes can have their spacing set more freely based on which stab we are in the horizontal set.\n//     This helps generating complex branching patterns.\n//   - For each set of parallel lanes we simply use its local x coordinate as a parameter (used for garden brick wall and camera).\n//   - The intersections of lane stabs give us a cellular base for country patches, and for each patch we get an id, a distance to boundary, and parameterized borders.\n//\n// Trees and houses placement:\n//\n//   - Patches ids is used to decide what combination of things goes on the patch (trees, bushes, farms, walls, lawn...)\n//   - There are 3 layers of cellular placement for trees, bushes, and farms.\n//     - Bushes are too close to each other and must be soft blended, but 3x3 search is no-no so we do a \"4 or 5\" neighbours search (we only consider checkboard black cells).\n//     - For farms and trees we use randomly decimated jittered grid and actually only consider the current cell we are in, and hack marching to death to compensate.\n//   - Modeling:\n//     - Trees leaves volume have a base shape done with 2 spheres soft blended, then distored by 2 layers of packed 3d spheres tiling to blobify the leaves volume, and then some fine noise distortion on the surface.\n//       The use of densely packed sphere tiling is inspired by @Shane's Cellular Tiling https://www.shadertoy.com/view/4scXz2\n//     - Farms are randomized with gable and hipped roof, chimneys and colors very vaguely inspired by pictures of Devon.\n//\n// Marching:\n//\n//   - For patches, marching uses ghost steps nearby patch boundaries so that we don't check neighbour patches objects, only the patch we are in.\n//   - For trees and farms too, we force the raymarch to take ghost steps along their cell borders for x1 sdf eval.\n//     - This ghost point machinery is hacky and not perfect (esp on patches boundary where we don't have clean intersections) but still helps.\n//   - Because of all the cellular evals going on, to save height evals we use taylor expansion of the heightfield on local neiborhood.\n//   - Despite above efforts I had to resort to reprojection and still perf isn't great. \n//     Blurring the noise with reprojection also helps hide the general noisy lameness and gives better colors.\n//\n// Clouds are volumetric but baked in a spheremap at first frame and assumed distant.\n// Also had to turn view trace/shadow trace/scene gradient/cellular evals into loops to help compile time on the website, sometimes at the expense of runtime perfs.\n// As always some code, techniques, ideas from @iq, @Dave_Hoskins, @Shane, @FabriceNeyret2 are used in various places, \n// this shader also uses some spherical gaussian code from Matt Pettineo \n// (see comment for links to references).\n\n#define PI 3.141592654 // He does love his numbers\n#define FLT_MAX 1000000.0\n\n#define SQR2 1.414213562\n#define SQR3 1.732050807\n\n#define RED  vec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define WHITE vec3( 1, 1, 1 )\n#define BLACK vec3( 0, 0, 0 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define YELLOW vec3( 1, 1, 0 )\n#define AZURE vec3( 0.0, 0.5, 1.0 )\n\n#define VECTYPE(type) \\\ntype saturate(type x){return clamp( x, type(0.0), type(1.)); } \\\ntype smoothstep_unchecked( type x )   { return (x*x)*(type(3.)-x*2.);} \\\ntype smoothstep_unchecked_d( type x ) { return 6.*x*(type(1.)-x); }\nVECTYPE( float )\nVECTYPE( vec2 )\nVECTYPE( vec3 )\nVECTYPE( vec4 )\n//oh wow, this works, and this is Great.\n\n//parent library, unused outcommented.\n//float exp_decay( float x ){return 1. - exp( -x );}\n// cubic bump that goes through (0,0)->(1,0)\n// slope at x=0 is df0\n// slope at x=1 is df1\nfloat cubicbump(v0 x,v0 c,v0 a){a+=c;return x*(x*(x*a-a-c)+c); }\nfloat smoothbump(v0 a,v0 r,v0 x){return 1.-smoothstep_unchecked(min(abs(x-a),r)/r);}\n//smoothstep(x,center,radius)\nfloat smoothstep_c(v0 x,v0 c,v0 r){return smoothstep(c-r,c+r,x);}\n//smoothstep centered at 0\nfloat smoothband(v0 x,v0 r,v0 raa){return 1.-smoothstep_c(abs(x),r,raa );}\n// range s,e\nfloat smoothband(v0 x,v0 s,v0 e,v0 raa){return smoothband(x-(e+s)*.5,(e-s)*.5,raa);}\nvec2 perp(v1 v){return vec2( -v.y,v.x );}\nfloat calc_angle(vec2 v){return atan(v.y,v.x);} // range[-pi,pi]\n//float calc_angle( vec2 a,vec2 b){return calc_angle(vec2(dot(a,b),dot(perp(a),b))); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\n// variant of exp/log soft min and max that save a few instructions\nfloat smin_exp2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) / k; }\nfloat smax_exp2( float a, float b, float k ) { return -smin_exp2( -a, -b, k ); }\n// https://iquilezles.org/articles/smin\nfloat smin_pol( float a, float b, float k ) { float h = clamp( 0.5f + 0.5f * ( b - a ) / k, 0.0f, 1.0f ); return mix( b, a, h ) - k * h * ( 1.0 - h ); }\nfloat smax_pol( float a, float b, float k ) { return -smin_pol( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat min_( float x, float y, float z ) { return min( min( x, y ), z ); }\nfloat max_( float x, float y, float z ) { return max( max( x, y ), z ); }\nfloat nearest( float x ) { return floor( 0.5 + x ); }\nfloat nearest( float x, float spacing ) { return floor( 0.5 + x / spacing ) * spacing; }\nvec2 nearest( vec2 x, vec2 spacing ) { return floor( vec2( 0.5 ) + x / spacing ) * spacing; }\nfloat sum( vec4 v ) { return v.x + v.y + v.z + v.w; }\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\n\n// project this on line (O,d), d is assumed to be unit length\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_line( type P, type O, type d ) { return O + d * dot( P - O , d ) / dot(d, d ); } \\\ntype project_on_plane( type P, type O, type n ) { return P - n * dot( P - O , n ) / dot(n, n ); } \\\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n// https://iquilezles.org/articles/distance\n// fast and nice in most cases\n#define FAST_SIGNED_DISTANCE_TO_FUNC_11_ARG(s,p,f,a,e  \\\n){vec2 _p=p;float _e=e;float _y=f(_p.x, a)  \\\n ;float _dd=(f(_p.x+_e,a)-_y)*(1./_e)       \\\n ;s=(_p.y-_y)/sqrt(1.+_dd*_dd);}            \\\n\n//transform vec3 by mat4 (camera projection matrix)\nvec3 transform_vector(mat4 m, vec3 v){return (m*vec4( v,0)).xyz;}\n\nstruct bounds2 { vec2 pmin; vec2 pmax; };\nbounds2 mkbounds_unchecked( vec2 amin, vec2 amax ) { bounds2 ret; ret.pmin = amin; ret.pmax = amax; return ret; }\n\n#define REPEAT_FUNCTIONS( type ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float )\nREPEAT_FUNCTIONS( vec2 )\n\n// badly antialiased stripes\n// r is the half width of the stripes\n// raa is the half size of the edge/aa smoothstep (ex: pixel_size)\n// period is the distance between 2 consecutive stripes\n\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\n// triangular sin waves - you can drop in as a replacement for sin to get polygonized looks\nfloat tri_sin( float x ) { return (abs(fract((x-PI*0.5)/(PI*2.))-0.5)-0.25)*4.0; }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash11(float p) { p = fract(p * .1031); p *= p + 33.33; p *= p + p; return fract(p); }\nfloat hash12(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nfloat hash13(vec3 p3) { p3 = fract(p3 * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nvec2 hash22(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec2 hash23(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec3 hash31(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash32(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy + p3.yxx )*p3.zyx ); }\n\n//###############################################################################\n\n// iq's function munged for vec4, used in city shader...\n// https://www.shadertoy.com/view/XlXcW4 note: source has changed since then...\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference\n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\n\n// integer hashes\n// https://www.shadertoy.com/view/4tXyWN iq\n\nfloat hash1u2_4tXyWN( uvec2 x )\n{\n\tuvec2 q = 1103515245U * ( ( x >> 1U ) ^ ( x.yx  ) );\n\tuint  n = 1103515245U * ( ( q.x  ) ^ ( q.y >> 3U ) );\n\treturn float( n ) * ( 1.0 / float( 0xffffffffU ) );\n}\n\n// https://nullprogram.com/blog/2018/07/31/ Chris Wellons\n// https://www.shadertoy.com/view/WttXWX via Fabrice\n\nuint lowbias32(uint x) { x ^= x >> 16; x *= 0x7feb352dU; x ^= x >> 15; x *= 0x846ca68bU; x ^= x >> 16; return x; }\nfloat hash11u_lowbias32( uint x ) { return float( lowbias32( x ) ) / float( 0xffffffffU ); }\n\n#define V30 vec2( 0.866025403, 0.5 )\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\n// theta_vec is the unit vector for angle theta\n// phi_vec is the unit vector for angle phi\nvec3 zup_spherical_coords_to_vector( vec2 theta_vec, vec2 phi_vec ) { return vec3( theta_vec.y * phi_vec, theta_vec.x ); }\nvec3 zup_spherical_coords_to_vector( float theta, float phis ) { \nreturn zup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phis ) ); }\nvec3 zup_spherical_coords_to_vector( vec2 theta_phi ) { return zup_spherical_coords_to_vector( theta_phi.x, theta_phi.y ); }\n\n// note: n.xy==0 is undefined for phi, pleae handle in caller code\nvec2 vector_to_zup_spherical_coords( vec3 n )\n{\n\tfloat theta = safe_acos( n.z ); // note: vectors normalized with normalize() are not immune to -1,1 overflow which cause nan in acos\n\tfloat phis = calc_angle( n.xy  );\n\treturn vec2( theta, phis );\n}\n\nvec3 yup_spherical_coords_to_vector( vec2 theta, vec2 phis ) { return zup_spherical_coords_to_vector( theta, phis ).yzx ; }\nvec3 yup_spherical_coords_to_vector( float theta, float phis ) {\nreturn yup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phis ) ); }\n\n/*\nmat4 yup_spherical_coords_to_matrix( vec2 theta, vec2 phis , vec4 camRotQ, vec3 ro)\n{\n    mat3 omgSourceCamsuckedHARD=q2m(camRotQ);\n\treturn ( mat4( vec4( omgSourceCamsuckedHARD[0], 0.0 ), vec4( omgSourceCamsuckedHARD[1], 0.0 ), vec4( omgSourceCamsuckedHARD[2], 0.0 ), vec4(ro, 1 ) ) );\n}\n\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phis ,vec4 camRotQ,vec3 ro) { \n\n    mat3 omgSourceCamsuckedHARD=q2m(camRotQ);\n\treturn ( mat4( vec4( omgSourceCamsuckedHARD[0], 0.0 ), vec4( omgSourceCamsuckedHARD[1], 0.0 ), vec4( omgSourceCamsuckedHARD[2], 0.0 ), vec4(ro, 1 ) ) );\n}*/\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nmat3 mat3_rotation_x( vec2 v ) { return mat3( vec3( 1, 0, 0 ), vec3( 0, v.x, v.y ), vec3( 0, -v.y, v.x ) ); }\nmat3 mat3_rotation_z( vec2 v ) { return mat3( vec3( v.x, v.y, 0 ), vec3( -v.y, v.x, 0 ), vec3( 0, 0, 1 ) ); }\n\n// icdf for pdf a*exp(-a*x) (wikipedia Exponential distribution)\nfloat ed_icdf( float u, float a ) { return -log( 1. - u ) * ( 1.0 / a ); }\n\n#define INDEXHASHOFFSET3 vec3( 137.0, 53.0, 173 )\n\n#define LAYERED1(func,p,args) ((func(p*1.0,args)*0.5)                                                                                               *(1.0/(0.5)))\n#define LAYERED2(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25)                                                                         *(1.0/((0.5+0.25))))\n#define LAYERED4(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625)                          *(1.0/((0.5+0.25+0.125+0.0625))))\n#define LAYERED5(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625+func(p*16.0,args)*0.03125)*(1.0/((0.5+0.25+0.125+0.0625+0.03125))))\n\nfloat noise12( vec2 p, bool use_smooth\n){p -= 0.5\n ;vec2 p00 = floor( p )\n ;vec2 p10 = p00 + vec2( 1, 0 )\n ;vec2 p01 = p00 + vec2( 0, 1 )\n ;vec2 p11 = p00 + vec2( 1, 1 )\n ;float v00 = hash12( p00 )\n ;float v10 = hash12( p10 )\n ;float v01 = hash12( p01 )\n ;float v11 = hash12( p11 )\n ;vec2 f = fract( p ) // p-p00 but beware large values...\n ;if ( use_smooth ) f = smoothstep_unchecked( f )\n ;float A = v10 - v00\n ;float B = v01 - v00\n ;float C = ( v11 - v01 ) - A\n ;float D = v00\n ;//\treturn mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y ),\n ;return A * f.x + B * f.y + C * f.x * f.y + D;}\n\nfloat noise13( vec3 p, bool use_smooth\n){p -= 0.5\n ;vec3 p000 = floor( p ) + INDEXHASHOFFSET3\n ;float v000 = hash13( p000 )\n ;float v100 = hash13( p000 + vec3( 1, 0, 0 ) )\n ;float v010 = hash13( p000 + vec3( 0, 1, 0 ) )\n ;float v110 = hash13( p000 + vec3( 1, 1, 0 ) )\n ;float v001 = hash13( p000 + vec3( 0, 0, 1 ) )\n ;float v101 = hash13( p000 + vec3( 1, 0, 1 ) )\n ;float v011 = hash13( p000 + vec3( 0, 1, 1 ) )\n ;float v111 = hash13( p000 + vec3( 1, 1, 1 ) )\n ;vec3 f = fract( p ) // bilinear\n ;if ( use_smooth ) f = smoothstep_unchecked(f)\n ;return mix(mix(mix(v000,v100,f.x)\n                ,mix(v010,v110,f.x),f.y )\n            ,mix(mix(v001,v101,f.x)\n                ,mix(v011,v111,f.x),f.y),f.z);}\n\nvec3 noise33( vec3 p, bool use_smooth\n){p -= 0.5\n ;vec3 p000 = floor( p ) + INDEXHASHOFFSET3\n ;vec3 v000 = hash33( p000 )\n ;vec3 v100 = hash33( p000 + vec3( 1, 0, 0 ) )\n ;vec3 v010 = hash33( p000 + vec3( 0, 1, 0 ) )\n ;vec3 v110 = hash33( p000 + vec3( 1, 1, 0 ) )\n ;vec3 v001 = hash33( p000 + vec3( 0, 0, 1 ) )\n ;vec3 v101 = hash33( p000 + vec3( 1, 0, 1 ) )\n ;vec3 v011 = hash33( p000 + vec3( 0, 1, 1 ) )\n ;vec3 v111 = hash33( p000 + vec3( 1, 1, 1 ) )\n ;vec3 f = fract( p )// bilinear\n ;if ( use_smooth ) f = smoothstep_unchecked(f) // looks sharper in 3d\n ;return mix(mix(mix(v000,v100,f.x)\n                ,mix(v010,v110,f.x),f.y)\n            ,mix(mix(v001,v101,f.x)\n                ,mix(v011,v111,f.x),f.y),f.z );}\n\nfloat enoise13( vec3 p, float a, bool use_smooth\n){p -= 0.5\n ;vec3 p000 = floor( p ) + INDEXHASHOFFSET3\n ;vec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\tvec2 h000 = hash23( p000 );\n\tvec2 h100 = hash23( p100 );\n\tvec2 h010 = hash23( p010 );\n\tvec2 h110 = hash23( p110 );\n\tvec2 h001 = hash23( p001 );\n\tvec2 h101 = hash23( p101 );\n\tvec2 h011 = hash23( p011 );\n\tvec2 h111 = hash23( p111 );\n\tfloat v000 = ed_icdf( h000.x, a ) * h000.y;\n\tfloat v100 = ed_icdf( h100.x, a ) * h100.y;\n\tfloat v010 = ed_icdf( h010.x, a ) * h010.y;\n\tfloat v110 = ed_icdf( h110.x, a ) * h110.y;\n\tfloat v001 = ed_icdf( h001.x, a ) * h001.y;\n\tfloat v101 = ed_icdf( h101.x, a ) * h101.y;\n\tfloat v011 = ed_icdf( h011.x, a ) * h011.y;\n\tfloat v111 = ed_icdf( h111.x, a ) * h111.y;\n\tvec3 f = fract( p ); // bilinear\n\tif ( use_smooth ) f = smoothstep_unchecked(f); // looks sharper in 3d\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );}\n\n// prefix meaning: \n//  e stands for exponential distribution\n//  s stands for smoothstep interpolation\nfloat snoise12_( vec2 p, float args ) { return noise12( p, true ); }\nfloat snoise13_( vec3 p, float args ) { return noise13( p, true ); }\nvec3 noise33_( vec3 p, float args ) { return noise33( p, false ); }\nfloat enoise13_( vec3 p, float a ) { return enoise13( p, a, false ); }\nfloat sfbm1_12( vec2 p ) { return LAYERED1( snoise12_, p, -1.0); }\nfloat sfbm2_13( vec3 p ) { return LAYERED2( snoise13_, p, -1.0); }\nfloat sfbm2_13_leaf( vec3 p ) { return (noise13(p*0.8,true)+noise13(p*4.0,true)*0.6)/1.5;}\nfloat sfbm2_12( vec2 p ) { return LAYERED2( snoise12_, p, -1.0); }\nfloat efbm4_13( vec3 p, float arg ) { return LAYERED4( enoise13_, p, arg); }\nvec3 sfbm4_33( vec3 p ) { return LAYERED5( noise33_, p, -1.0); }\n\nstruct Ray {vec3 o;vec3 d;};\nRay mkray( vec3 o, vec3 d ){ Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\n\nvec3 get_view_dir( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp\n){return normalize( vec3( normalized_pos.x * aspect, normalized_pos.y, -tan_half_fovy_rcp ) );} // note: looking down z\n\n//note that htis has no znear clipping\n// note that we pass the reciprocal of tan_half_fovy\n// normalized_pos is (-1,1-)->(1,1)\nRay get_view_ray2(vec2 u,float a,float f, mat4 cam//normalized_pos,aspect,tan_half_fovy_rcp,camera\n){vec3 transformed=transform_vector(cam,get_view_dir(u,a,f))\n ;return mkray(cam[3].xyz,transformed);}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up\n){vec3 z = normalize( eye - center )\n ;vec3 x = normalize( cross( up, z ) )\n ;vec3 y = cross( z, x )\n ;return mat4( vec4(x,0.), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0));}\n\nvec2 sphere_trace( Ray ray, float radius, vec3 center\n){vec3 O = ray.o\n ;vec3 d = ray.d\n ;float tp = dot( center - O, d ) // O + d * tp = center projected on line (O,d)\n ;float h_sqr = lensqr( ( O + d * tp ) - center )\n ;float radius_sqr = radius * radius\n ;if ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ) // ray missed the sphere\n ;float dt = sqrt( radius_sqr - h_sqr ) // distance from P to In (near hit) and If (far hit)\n ;return vec2( tp - dt, tp + dt );} // record 2 hits In, If\n\nfloat plane_trace( vec3 ray_o, vec3 ray_d, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray_d, n ); return abs( ddotn ) > epsilon ? dot( base - ray_o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace( Ray ray, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray.d, n ); return abs( ddotn ) > epsilon ? dot( base - ray.o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : FLT_MAX; }\n// d is a unit direction, ray starts at 0,0,0 base is plane position along z, this is just a division...\nfloat plane_trace_z( vec3 d, float base, float epsilon ) { return abs( d.z ) > epsilon ? base / d.z : FLT_MAX; }\n\n// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 / r ) * x * x + r ); }\n// smooth bevel (like a soft_abs function)\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); return x > r ? x : her2( x, r ); }\n// max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return smax_exp2( a, b, k ); }\nfloat opI_soft2_pol( float a, float b, float k ) { return smax_pol( a, b, k ); }\nfloat opI_weld_quadric( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_weld_quadric( a - c, r ); }\n// min(a,b) = -max(-a,-b)\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_soft2_pol( float a, float b, float k ) { return -opI_soft2_pol( -a, -b, k ); }\nfloat opU_weld_quadric( float a, float b, float r ) { return -opI_weld_quadric( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opS_soft2( float a, float b, float k ) { return opI_soft2( -b, a, k ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\n// r can be zero\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r\n){vec2 h = ( ma - mi ) * 0.5\n ;p = abs( p - ( mi + ma ) * 0.5 )\n ;vec2 c = h - r\n ;float mask = maxcomp( step( c, p ) )\n ;return mix( maxcomp( p - c ), length( max( p - c, vec2( 0.0 ) ) ), mask ) - r;}\n\n// r can be zero\nfloat sd_bounds_range_round( vec3 p, vec3 mi, vec3 ma, float r\n){vec3 h = ( ma - mi ) * 0.5\n ;p = abs( p - ( mi + ma ) * 0.5 )\n ;vec3 c = h - r\n ;float mask = maxcomp(step( c, p ) )\n ;return mix( maxcomp( p - c ), length( max( p - c, vec3( 0.0 ) ) ), mask ) - r;}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n// those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\n\nfloat sd_sphere( vec3 p, vec3 center, float radius ) { return length( p - center ) - radius; }\nfloat sd_sphere( vec2 p, vec2 center, float radius ) { return length( p - center ) - radius; }\n\n// iq's https://www.shadertoy.com/view/Xds3zN modified for z up\nfloat sdCylinder( vec3 p, vec2 h\n){vec2 d = abs( vec2( length( p.xy ),p.z)) - h\n ;return min( max( d.x, d.y ), 0.0 ) + length( max( d, vec2( 0.0 ) ) );}\n\n//length(a)==sqrt(dot(a,a))\n#define dd(a) dot(a,a)\n// internal function in packed_spheres_tiling3d\nfloat pstil(vec3 p//packed_spheres_tiling3d_internal_layer\n){vec2 rh=vec2(1.,SQR3) // r=1  (normally h = spacing*0.5 * SQR3, and here spacing=2)\n ;vec2 c=rh*2. // cell size for each row\n ;return min(\n  dd(p-vec3((floor( p.xy    /c)+vec2(.5))*c   ,0)),\n  dd(p-vec3((floor((p.xy-rh)/c)+vec2(.5))*c+rh,0)));}//second row offset by rh\n\n// sdf of packed spheres of radius 1 (just add to distance for smaller radius...)\nfloat pst(vec3 p//packed_spheres_tiling3d\n){vec3 p0 = p\n ;float h=SQR3 // height of equilateral triangle of edge len 1+1=2\n ;float b=(1.-h*h)/(2.*h)\n ;float c=h+b\n ;float h3=sqrt(4.-c*c) // height of tetrahedra, also the spacing between layers, also the half period of each layer\n ;float h6=2.*h3//-1 mult\n ;float h1=.5/h3//-1 division\n ;p = p0\n ;p.z -=(floor((p.z+h3)*h1)+.5)*h6-h3 //repeat layer\n ;float d1=pstil(p) //;return d1 //early cop out\n ;p=p0\n ;p.y+=h+b // offset to overlap centers of first layer exactly\n ;p.z-=(floor(p.z*h1)+.5)*h6 //repeat layer\n ;float d2=pstil(p)\n ;//return d2\n ;//return opU(d1,d2)\n ;return sqrt(min(d1,d2))-1.f;}\n\n// r is sphere radius, distance between 2 spheres is spacing\n// r must be < spacing/2\nfloat pst( vec3 p, float r, float s\n){s *=.5;return pst(p*(1./s))*s+(s-r);}\n\n// r is sphere radius, distance between 2 spheres is 2*r\nfloat pst( vec3 p, float r\n){return pst(p*(1./r))*r;}\n\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n// the couple of following functions are copied from Matt Pettineo's spherical gaussian article, \n// I liked the soft look and ease of use of SG and ended up keeping to the end\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n\nstruct SG { vec3 Amplitude; vec3 Axis; float Sharpness; };\n\n// approximate integral on omega of sg(v)dv\nvec3 ApproximateSGIntegral( in SG sg ) { return 2. * PI * ( sg.Amplitude / sg.Sharpness ); }\n\nSG CosineLobeSG(vec3 d\n){SG c;c.Axis=d;c.Sharpness=2.133f;c.Amplitude=vec3(1.17f);return c;}\n\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-3-diffuse-lighting-from-an-sg-light-source/\nvec3 SGIrradianceFitted(SG lightingLobe,vec3 normal\n){float muDotN = dot( lightingLobe.Axis, normal )\n ;float lambda = lightingLobe.Sharpness\n ;float c0 = 0.36f\n ;float c1 = 1.0f / ( 4.0f * c0 )\n ;float eml  = exp( -lambda )\n ;float em2l = eml * eml\n ;float rl   = 1.0 / lambda\n ;float scale = 1.0f + 2.0f * em2l - rl\n ;float bias  = ( eml - em2l ) * rl - em2l\n ;float x  = sqrt( 1.0f - scale )\n ;float x0 = c0 * muDotN\n ;float x1 = c1 * x\n ;float n = x0 + x1\n ;float y = saturate( muDotN )\n ;if ( abs( x0 ) <= x1 ) y = n * n / x\n ;float result = scale * y + bias\n ;return result * ApproximateSGIntegral( lightingLobe );}\n\n// what am I doing\nvec3 SGDiffuseFitted( in SG lightingLobe, in vec3 normal, vec3 albedo\n){vec3 brdf = albedo / PI\n ;return SGIrradianceFitted( lightingLobe, normal ) * brdf;}\n\n\n//#define BUFFER_MODE 0\n//the tempral reprojection of the parent shader looked bad,\n//and i hope that i can take the TR of another shader instead.\n\n// iChannel0 is always Buf A\n// iChannel1 is always Buf B\n\n// note: glsl doesn't let us write if (1), so we write if (_1), note that occasionally compiler may fail to treat that as a static branch\n#define _1 true\n#define _0 false\n\n// skip space faster above bushes (and maybe other things if proves useful)\n// notes:\n//  - at higher res we can see that causes artifacts, see the bit that sets\n//    eval.terrain_warp and tweak hack constants there\n//  - this causes artifacts on trees's tracing... close to patch borders maybe? (messes with shadows sometimes)\n//  - this messes with bush shadows even when bush surface seems unchanged (shrinks shadows a bit)\n#define TERRAIN_WARP\n\n#define FORCE_LOOP +min(0,F)\n#define FORCE_LOOPF +min(0.0,float(aFrame))\n\n#define SHADOW_TINT_SATURATION 0.45 // [0,1]\n\n#define AO _0 // nice term, visible extra cost, but doesn't contribute much, so disable \n#define SHADOWS _1\n\n#define SUN _1\n#define SUN_GLARE _0 // could be interesting but needs more work\n\n#define GROUND_OCCLUSION _1 // first sdf is ground's base level so we get occlusion\n#define PATH _1 // cost peanuts\n#define GRAS _1 // cost peanuts\n#define BUSH _1 // a bit expensive\n#define TREE _1 // super expensive\n#define FARM _1 // cost a little bit\n#define BRICKWALL _1 // cost a little bit\n\n#define TAYLOR_HEIGHT_BUSH _1\n#define TAYLOR_HEIGHT_TREE _1\n#define TAYLOR_HEIGHT_FARM _0 // object is too large, causes a little bit too much distortion\n\n#define GHOST_STEPS_PATCH _1\n#define GHOST_STEPS_TREE _1 // visible extra cost, fixes the trees, but we start hitting iteration limit\n#define GHOST_STEPS_FARM _1 // little cost (large cells) and fixes farms, hits a little bit more max iterations far away\n// about GHOST_MAX_DIST:\n// introduced a second distance for bird views\n// having 2 thresh lets us fix bird view, but they get more expensive\n#define GHOST_MAX_DIST_FROM_T0 7.0\n#define GHOST_MAX_DIST_ABS 25.0\n// fixes weird grain that happens when using second threshold that goes further away... hack hack...\n#define GHOST_EPS 0.0001\n\n#define DISPLACE_PATH _1 // a bit expensive, actually\n#define DISPLACE_PATH_AMPL 0.002\n\n#define DISPLACE_PINE _1\n#define DISPLACE_TREE _1\n#define DISPLACE_BUSH _1\n#define DISPLACE_BUSH_FREQ 8.0\n\n// CLOUD_MODE\n//  0: no cloud\n//  1: trace cloud per pixel (for debug)\n//  2: cache trace cloud in B texture every frame and use that (for debug)\n// >3: cache trace cloud in B texture only first frame and use that (same cost as no cloud)\n#define CLOUD_MODE 3\n\n// the wind doesn't have much amplitude, and movement isn't smooth enough, but reprojection hides that a bit...\n#define WIND_BUSH _1\n#define WIND_TREE_AND_PINES _1\n\n#define FARM_WINDOWS _1\n\n#define SOFT_BLEND_BUSH _1\n#define SQUARE_BUSH_TEST _1 // some farms have nicely cut bushes arounds them\n\n#define MATID_NONE       0.0\n#define MATID_BUSH       1.0\n#define MATID_TRUNK      2.0\n#define MATID_HOUSE_TOP  3.0\n#define MATID_ROOF       4.0\n#define MATID_PINE       5.0\n#define MATID_BRICKWALL  6.0\n#define MATID_GRASS      7.0\n#define MATID_GROUND     8.0\n#define MATID_TREE       9.0\n#define MATID_WINDOW    10.0\n#define MATID_HOUSE_BOT 11.0\n\n#define BROWN (vec3(133,84,57)/255.0)\n#define COLOR_PATH1 BROWN\n#define COLOR_PATH2 (BROWN*0.8)\n#define COLOR_BUSH1 (0.8*vec3(0.07,0.3,0.05))\n#define COLOR_BUSH2 (0.55*vec3(0.12,0.6,0.2))\n#define COLOR_BUSH3 (0.55*vec3(0.1,0.35,0.09))\n#define COLOR_BUSH4 (0.82*vec3(0.18,0.39,0.06))\n#define COLOR_BUSH5 vec3(0.1,0.3,0.01) // rare color\n#define COLOR_TREE1 (vec3(0.1,0.35,0.09)*0.55)\n#define COLOR_TREE2 (vec3(0.1,0.45,0.08)*0.8)\n#define COLOR_TREE_SURF vec3(0.15,0.4,0.04)\n#define COLOR_GRASS vec3(0.1,0.35,0.09)\n#define COLOR_GRASS2 vec3(0.35,0.39,0.06)\n#define COLOR_MOWED_GRASS vec3(0.17,0.37,0.05)\n#define COLOR_MOWED_GRASS2 (COLOR_MOWED_GRASS* 0.6)\n#define COLOR_PINE (vec3(0.4,1.0,0.2)*0.2)\n#define COLOR_PINE2 (vec3(0.5,1.0,0.0)*0.32)\n#define COLOR_TRUNK (BROWN*0.5)\n#define COLOR_ROOF1 (vec3(0.6,0.2,0.3)*0.7)\n#define COLOR_ROOF2 (vec3(0.1,0.4,0.5)*0.7)\n#define COLOR_BRICKWALL mix(vec3(0.52,0.33,0.22),vec3(0.9,0.9,0.7),0.35)\n#define COLOR_HOUSE mix((vec3(1,1,1)*0.65),COLOR_BRICKWALL,0.1) // white is a bit too white so blend with brickwall color\n#define COLOR_HOUSE_BOTTOM (COLOR_HOUSE*0.7)\n\nstruct CellPoint{\n\tvec2 p;\n\tivec2 _pi; // some cell index to take a hash from\n\tfloat pradius; // point radius, small points can be closer to cell edges\n};\n\n// meaning of id varies, if 32bits floats we should be able to have exact ints up to 2^24=16777216\nstruct DistanceId { float d; float id;  };\n\nDistanceId MkDistanceId( float d, float id ) { DistanceId v; v.d = d; v.id = id; return v; }\n\nDistanceId MkDistanceId_16( float d, float id, float id_fraction )\n{\n\treturn MkDistanceId( d, float( int( id ) | ( int( id_fraction * 65535.0 ) << 5 ) ) );\n}\n\nDistanceId MkDistanceId_5_5_5( float d, float id, vec3 v ){\n\treturn MkDistanceId( d, float( int( id )\n\t\t\t\t\t\t\t\t   | ( int( v.x * 31.0 ) <<  5 )\n\t\t\t\t\t\t\t\t   | ( int( v.y * 31.0 ) << 10 )\n\t\t\t\t\t\t\t\t   | ( int( v.z * 31.0 ) << 15 ) ) );}\n\nvec2 DecodeId_16( DistanceId di ){\n\tint i = int( di.id );\n\treturn vec2( float( i&31 ), float( i >> 5 ) * ( 1.0 / 65535.0 ) );}\n\nfloat DecodeId( DistanceId di ){\n\tint i = int( di.id );\n\treturn float( i&31 );}\n\nvec4 DecodeId_5_5_5( DistanceId di ){\n\tint i = int( di.id );\n\treturn vec4( float( i&31 )\n\t\t\t\t , float( ( i >>  5 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 10 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 15 ) & 31 ) * ( 1.0 / 31.0 ) );}\n\n#if 0 \n// bogus build error on ? : in shadertoy\nDistanceId opUdi( DistanceId a, DistanceId b ) { return a.d < b.d ? a : b; }\n#else\nDistanceId opUdi( DistanceId a, DistanceId b ) { if ( a.d < b.d ) return a; return b; }\n#endif\n\n// some rough scale for the roads pattern\n// you need to tweak x spacing and y spacing of path slabs\n// and the x and y scale of the main path function\n#define LANEWIDTH 0.08\n\n// 0: sin waves\n//>1: sin waves with flat sections (default)\n// 2: constant (straight lines, rectangular layout)\n// 3: smooth noise\n#define LANE_FUNC 1\n\nvec2 PathNoise11sD( float x ){\n\tx -= 0.5;\n\tfloat fr = fract( x );\n\tint x0 = int( x - fr );\n\tuint i = uint( x0 );\n\tfloat y0 = hash11u_lowbias32( i );\n\tfloat y1 = hash11u_lowbias32( i + 1u );\n\tfloat f = smoothstep_unchecked( fr );\n\tfloat fd = smoothstep_unchecked_d( fr );\n\treturn vec2( mix( y0, y1, f ), ( y1 - y0 ) * fd );}\n\n// return lane's (y,y'), called a lot so make it cheap (this *does not* return world space y coord)\nvec2 wavyLaneFuncAndDerivative( float x, float lane_index\n#if LANE_FUNC==0\n){float a = mix( 0.5, 1.7, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\treturn vec2( ( sin( a * x ) + 1.0 ) * 0.5, 0.5 * a * cos( a * x ) );}\n#elif LANE_FUNC==1\n){// sin wave with soft straight sections so it's just all curvy\n\tfloat a = mix( 0.9, 2.0, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\tfloat z = ( 1.0 + sin( x * a ) ) * 0.5;\n\treturn vec2( z * z, a * z * cos( a * x ) );}\n#elif LANE_FUNC==2\n){return vec2( 0.5, 0 );}\n#else //LANE_FUNC==3\n){return PathNoise11sD( x - lane_index * 80.0 );}\n#endif\n\n\n#define PATH_SPACING_Y 1.0\n// used by camera, don't forget to offset by lane_index (regular wavyLaneFuncAndDerivative() doesn't care!)\nvec2 wavyLaneFuncAndDerivative_WORLD( float x, float l\n){return wavyLaneFuncAndDerivative(x,l)+vec2(l*PATH_SPACING_Y, 0 );}\n\n// this macro returns:\n//  - the vector to the closest point on a curve (the length of which gives a better distance than FAST_SIGNED_DISTANCE_TO_FUNC_11) \n//  - the tangent at that closest point\n// http://www.geometrie.tugraz.at/wallner/sproj.pdf\n// input:\n//  a_p               eval at pos\n//  a_funcd           is the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n//                    a_funcd can be a macro, it seems\n//                    returns the function value at t in .x and the derivative at t in .y\n//  a_funcd_arg       an argument passed to a_func\n//  a_cheap           num iterations, 2 should be enough, a_cheap==true only does 1 iteration\n//\n// output:\n//  a_ret   \t\t  a_ret.xy is vector to closest point on curve\n//                    a_ret.zw is the derivative (tangent at the closest point)\n//\n// note: we could get the sign from the first iteration\n\n\n#define CLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( a_ret, a_p, a_funcd, a_funcd_arg, a_cheap ) \\\n{ \\\n\tvec2 _p = a_p.xy, _c, _dc, _ev; \\\n\tfloat _t = _p.x; /* t0, could be a parameter if the user knows better */ \\\n\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t_c = vec2( _t, _ev.x ); \\\n\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\tif ( !(a_cheap) ) /* IMPORTANT: if num iteration is 2, an if test can behave much better than for loop */ \\\n\t{ \\\n\t\t/*#if 0*/ \\\n\t\t/*vec2 _q = project_on_line( _p.xy, _c, _dc );*/ \\\n\t\t/*_t += dot( _dc, _q - _c ) / dot( _dc, _dc );*/ \\\n\t\t/* simplifies to: */ \\\n\t\t/*#else*/ \\\n\t\t_t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); \\\n\t\t/*#endif*/ \\\n\t\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t\t_c = vec2( _t, _ev.x ); \\\n\t\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\n// return vector to closest point in .xy, derivative there in .zw\n// use cheap when you don't care about accurate distance or closest point\nvec4 sdWavyLane( vec2 p, float lane_index, bool cheap )\n{\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( ret, p, wavyLaneFuncAndDerivative, lane_index, cheap )\n\treturn ret;\n}\n\nstruct SceneIn\n{\n\t// constant during trace:\n//\tvec3 o;\n\tvec3 v;\n\tvec3 v_rcp; // for cell boundaries\n\tint trace_flags; // we can skip material related calculations during the traversal and enable only on shade\n\t// varying during trace:\n\tvec3 p;\n\tfloat t0; // warp start to hmax\n\tfloat t;\n};\n\nstruct ClosestPath\n{\n\tDistanceId patch_di; // patch id and distance (which is also the distance to paths)\n\tvec2 v2closest; // vector to closest patch boundary point, in world coords\n\tfloat curve_local_param; // the curve parameter, p.x in the local curve distance eval, so we can parametrixe space for making walls etc\n\t\t\t\t\t   // (since the path uses x and y directions we need to know which was used)\n};\n\nvec2 GetLocalCurvePoint( ClosestPath path ) { return vec2( path.curve_local_param, length( path.v2closest ) ); }\n\n// spacing must be >= 1 for the band to work\nClosestPath EvalClosestPathSlab( vec2 p, float spacing, bool cheap ){\n\tfloat id1 = floor( p.y / spacing );\n\tp.y = p.y - id1 * spacing;\n\tvec4 c1 = sdWavyLane( p, id1, cheap ); // should return in 0,spacing\n\tfloat d1 = cheap ? abs( c1.y ) : length( c1.xy );\n\tfloat s1 = sign( c1.y ); // this tells us if are above or below the curve (which adjacent curve to eval)\n\n\tfloat id2 = id1 - s1; // find the other 1d lane of the slab we are in: next or prev\n\tvec4 c2 = sdWavyLane( p + vec2( 0, s1 * spacing ), id2, cheap );\n\tfloat d2 = cheap ? abs( c2.y ) : length( c2.xy );\n\tfloat s2 = sign( c2.y );\n\n\tfloat m = s2 < 0.0 ? id1 : id1 - s1;\n\n\tClosestPath eval;\n\tif ( d1 < d2 ) { eval.patch_di.d = d1; eval.v2closest = c1.xy; }\n\telse           { eval.patch_di.d = d2; eval.v2closest = c2.xy; }\n\teval.patch_di.id = m;\n\teval.curve_local_param = p.x;\n\treturn eval;}\n\n// the lane curve is evaluated 4 times (twice per axis)\nClosestPath EvalClosestPath( vec2 p, bool cheap ){\n\t// horizonal lanes\n\t// PATH_SPACING_Y must be >= 1 for the band to work\n\tClosestPath ev1 = EvalClosestPathSlab( p, PATH_SPACING_Y, cheap );\n\n\t// vertical lanes\n\t// each horizontal stab can call a different set of vertical lanes which generates complex patterns\n\tvec2 p2 = perp( p ); // 90 degrees\n\t// important: spacing2 must be >= 1 for the band to work\n\tfloat spacing2 = ( 1.0 + 4.0 * ( sin( ev1.patch_di.id * 10.0 ) + 1.0 ) * 0.5 ); // spacinf of vertical lane can differ per horizontal stab which is key to complex branching patterns\n\tClosestPath ev2 = EvalClosestPathSlab( p2, spacing2, cheap );\n\tev2.v2closest = -perp( ev2.v2closest ); // put v2closest back to world coords (-90 degrees)\n\n\tClosestPath eval = ev1;\n\teval.patch_di.id *= ev2.patch_di.id; // get a unique id for this patch\n\tif ( ev2.patch_di.d < ev1.patch_di.d )\t{\n\t\teval.patch_di.d = ev2.patch_di.d;\n\t\teval.v2closest = ev2.v2closest;\n\t\teval.curve_local_param = ev2.curve_local_param;\t}\n\treturn eval;}\n\n// I hope you like magic constant\n#define MAX_TERRAIN_HEIGHT 0.74\n#define TALLEST_OBJECT_HEIGHT 0.645\n\nfloat sin_bumps_array( vec2 p ) { return sin( p.x ) * sin( p.y ) + 1.0; }\n\n// this function is called a lot so pick something simple\nfloat BaseGroundHeight( vec2 p  ){\n\tfloat h = sin_bumps_array( p.xy * ( 0.16 * PI ) ) * 0.5;\n\treturn h * h * MAX_TERRAIN_HEIGHT;} // sinbumps as is is too bumpy everywhere, we need also flatter areas, so square h\n\n\n// image was blue point juniper... end result is noise vomit\nfloat pine_tree_cross_section( float x, vec2 rh ) { x /= rh.y; return cubicbump( x, 3.0, -0.98 ) * rh.x; }\nfloat sdRevolutionPine( vec3 p, float r, float h ){\n\tvec2 p2d = vec2( ( p.z ), length( p.xy ) );\n\tif ( p2d.x >= h ) return length( p2d - vec2( h, 0 ) ); // don't forget to deal with endpoints...\n\tif ( p2d.x <= 0.0 ) return length( p2d - vec2( 0, 0 ) );\n\tfloat d; // note: we could use FAST_SIGNED_DISTANCE_TO_FUNCD_11_ARG but function is relatively cheap to eval so\n\tFAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( d, p2d, pine_tree_cross_section, vec2( r, h ), 1e-3 );\n\treturn d;} // note: this is already signed\n\nvec3 ApplyWind( vec3 pd, float aTime ) { return vec3( sin( aTime * 0.8 + pd.zx ) * 0.0003, 0 ); }\n\nfloat ddPineSurfLayer( vec3 p ){\n\tp *= 400.0;\n\tp.z *= 0.25;\n\tp.xy = rotate_with_angle( p.xy, p.z * 0.11 );\n\treturn ( ( tri_sin( p.x ) + tri_sin( p.y ) + tri_sin( p.z ) ) + 3. ) * ( 1. / 6. );} // normalize to 0,1\n\n\nfloat ddPineSurf( vec3 p ){\n\treturn ( ddPineSurfLayer( p ) + ddPineSurfLayer( vec3( rotate_with_angle( p.xy, 0.5 ), p.z ) * 0.5 ) )\n\t\t   * ( 1. / ( 2.5 ) );} // normalize to 0,1\n\n\nfloat sdDisplacePine( vec3 p, float d, float uheight ){\n\tif ( !DISPLACE_PINE ) return d;\n\tfloat dd_amp = 0.018;\n\tif ( d > dd_amp ) return d;\n\tdd_amp *= ddPineSurf( p );\n\treturn d + dd_amp;}\n\n#define TRACE_VIEW 1\n#define TRACE_SHADE 2\n#define TRACE_AO 4\n#define TRACE_SHADOW 16\n#define TRACE_HAS_DIRECTION 64 // note: it is faster to check flags than checking for v_rcp == 0 or whatnot (that might not been resolved to static)\n\nbool IsShadeTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADE ) != 0; }\nbool IsShadowTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADOW ) != 0; }\nbool HasDirection( int trace_flags ) { return ( trace_flags & TRACE_HAS_DIRECTION ) != 0; }\n\nDistanceId sdTreeLeaves( vec3 p, vec2 c, float cz, float trunk_height\n\t\t\t\t\t\t , float leaves_volume_base_radius\n\t\t\t\t\t\t , float leaves_volume_top_radius\n\t\t\t\t\t\t , int trace_flags\n\t\t\t\t\t\t , float color_rnd ){\n\tfloat d = FLT_MAX;\n\tvec3 c0 = vec3( c, cz + trunk_height * 0.7 );\n\tvec3 c1 = vec3( c, cz + trunk_height );\n\tfloat d0 = length( p - c0 ) - leaves_volume_base_radius;\n\tfloat d1 = length( p - c1 ) - leaves_volume_top_radius;\n\t// soft blend between 2 sphere for the base leaves volumes\n\tfloat k = leaves_volume_base_radius * 0.4;\n\td = opU_soft2_pol( d0, d1, k );\n//\treturn MkDistanceId( d, MATID_TREE );\n#define TREE_SDD 0.02 // upper bound for  amplitude of fine displacement on pines and trees\n\tfloat dd1 = 0.007;\n\tif ( d > dd1 + TREE_SDD ) return MkDistanceId( d, MATID_TREE ); // massive saving. only consider envelope displacement when we are close\n\tfloat d_envelope = d;\n\tbool blend = _1;\n\tfloat depth = 0.0;\n\tfloat uheight = 0.0;\n\tif ( _1 )\t{\n\t\t// make the leaves volume more bubbly by using 2 layers of *packed* 3d spheres regular tiling (non packed doesn't work well)\n\t\t// see @Shane's cellular tiling shaders/comments\n\n\t\tmat3 m3 =\n\t\t\tmat3_rotation_x( unit_vector2( radians( c.x * 200. ) ) ) *\n\t\t\tmat3_rotation_z( unit_vector2( radians( c.y * 200. ) ) );\n\n\t\tfloat dl1;\t\t{\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.3;\n\t\t\tfloat da1 = pst( p * m3, c1, c1 * 2.5 ); // more spacing gives more clustering/bumpiness\n\t\t\tda1 += smoothstep( cz + trunk_height * 0.75, cz + trunk_height, p.z ) * 0.007;\n\t\t\tdl1 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.3 )\n\t\t\t\t: opI( d_envelope, da1 );\t\t}\n\n\t\tfloat dl2;\t\t{\n\t\t\t// note: the second packed_spheres_tiling3d could just be global and evaluated 1 for the 3 trees\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.4;\n\t\t\tfloat da1 = pst( m3 * p, c1, c1 * 2.5 );\n\t\t\tdl2 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.25 )\n\t\t\t\t: opI( d_envelope, da1 );\t\t}\n\n\t\tfloat d_leaf_clusters = blend\n\t\t\t? opU_weld_quadric( dl1, dl2, leaves_volume_base_radius * 0.1 )\n\t\t\t: opU( dl1, dl2 );\n\n\t\td = blend\n\t\t\t? opU_weld_quadric( d_leaf_clusters, d_envelope + 0.02, leaves_volume_base_radius * 0.19 )\n\t\t\t: d_leaf_clusters;\n\n\t\tdepth = saturate( 1.0 / ( 1. + abs( d - d_envelope ) * 100. ) );\n\t\t\n\t\tfloat b = c0.z - leaves_volume_base_radius; // bottom most-ish\n\t\tfloat t = c1.z + leaves_volume_top_radius; // topmost-ish\n\t\tuheight = saturate( ( p.z - b )/( t - b ) ); // a 0-1 normalized height value for shading\n\t}\n\n\tif ( _1 )\t{\n\t\t// clip leaves volume's bottom with a wavy surface so it's not spherical things everywhere\n\t\tfloat clipsurf = ( ( c0.z - leaves_volume_base_radius * .6 )\n\t\t\t\t\t\t   + leaves_volume_base_radius * 0.1\n\t\t\t\t\t\t   * ( sin_bumps_array( p.xy * ( 13.0 * PI ) ) - 2.4 ) );\n\t\td = blend\n\t\t\t? opI_weld_quadric( d, -( p.z - clipsurf ), leaves_volume_base_radius * 0.15 )\n\t\t\t: opI( d, -( p.z - clipsurf ) );\t}\n\n\treturn MkDistanceId_5_5_5( d, MATID_TREE, saturate( vec3( depth, uheight, color_rnd ) ) );}\n\n// retrieve terrain height, using full eval or taylor expansion\nfloat CalcHeight( vec2 c, vec2 p, vec3 h_gradval, bool taylor_expansion_height ){\n\treturn taylor_expansion_height\n\t\t   ? h_gradval.z + dot( h_gradval.xy, c - p ) // h(p)=h(c)+(c-h).grad(c): taylor expansion to skip height evaluations \n\t\t   : BaseGroundHeight( c );}\n\nDistanceId sdGridObj_TreeOrPine( DistanceId di\n\t\t\t\t\t\t\t\t , vec3 p\n\t\t\t\t\t\t\t\t , CellPoint cr\n\t\t\t\t\t\t\t\t , float radius_fraction\n\t\t\t\t\t\t\t\t , float patch_id\n\t\t\t\t\t\t\t\t , inout vec3 color\n\t\t\t\t\t\t\t\t , SceneIn scenein\n\t\t\t\t\t\t\t\t , vec3 h_gradval, bool taylor_expansion_height ){\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\t// doesn't save enough vs extra test cost\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tvec2 n = perp( scenein.v.xy );\n\t\tvec2 o = scenein.o.xy;\n\t\tvec2 pp = project_on_plane( c, o, n );\n\t\tif ( lensqr( p.xy - pp ) > r * r ) return di;\n\t}\n#endif\n\tvec4 hhh = hash42_( cr._pi * 123 );\n\tvec3 tree_base_point = vec3( c, cz );\n\n\tfloat pine_dice_roll = hhh.x;\n\tfloat pine_probability = 0.7;\n\t\n\tif ( _1 && ( pine_dice_roll > pine_probability) )\n\t{\n\t\tfloat pine_radius_scale = mix( 0.65, 0.75, hhh.w ) * r;\n\t\tfloat pine_height = mix( 0.42, 0.56, hhh.z * hhh.z );\n\t\tfloat uheight = saturate( ( p.z - cz ) / pine_height );\n\t\tDistanceId pine_tree = MkDistanceId_5_5_5( \n\t\t\tsdDisplacePine( p - tree_base_point\n\t\t\t\t\t\t\t, sdRevolutionPine( p - tree_base_point, pine_radius_scale, pine_height ), uheight )\n\t\t\t, MATID_PINE, vec3( 0.0, uheight, ( ( hhh.x - pine_probability ) * ( 1.0 / ( 1.0 - pine_probability ) ) ) ) );\n\t\treturn opUdi( di, pine_tree );\n\t}\n\n\thhh.x *= 1.0/pine_probability; // back into [0,1]\n\tfloat aa = mix( 0.018, 0.012, hhh.y ); // trunk\n\tfloat trunk_height = aa * ( 1.1 * 1.0 / 0.018 ) * mix( 0.2, 0.35, hhh.z * hhh.z );\n\tfloat trunk_radius = aa * 0.8;\n\tfloat leaves_volume_top_radius = mix( 0.5, 0.7, hhh.w ) * r;\n\tfloat leaves_volume_base_radius = mix( 1.1, 1.35, hhh.y ) * leaves_volume_top_radius;\n\tDistanceId leaves = sdTreeLeaves( p, c, cz, trunk_height, leaves_volume_base_radius, leaves_volume_top_radius, scenein.trace_flags, hhh.x );\n\tfloat trunk_uheight = saturate( ( p.z - cz ) / trunk_height );\n\ttrunk_radius *= mix(0.8,1.2,pow2(1.0-saturate(trunk_uheight*3.5)));\n\tDistanceId trunk = MkDistanceId( sdCylinder( p - tree_base_point, vec2( trunk_radius, trunk_height ) ), MATID_TRUNK );\n\tif ( trunk.d < 0. ) leaves = trunk; // horrible hack to force trunk to be trunk inside leaves, as the leaves sdf has been hacked to death and union doesn't quite work anymore\n\treturn opUdi( di, opUdi( trunk, leaves  ) );\n}\n\n// function used to make roof tiles\n// a1 is the slope of curve going up (1.)\n// a2 is the slope of curve going down (-2.)\n// p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); return min( a1 * x, a2 * ( x - p ) ); }\n// roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return 0.1 * hard_waves( p.y, 0.3, -1.1, 0.024 ) + 0.001 * ( 1.0 - pow2( 1.0 - abs( sin( p.x * 200. ) ) ) ); }\n\nstruct WindowOrDoorArg{\n\tvec2 c; // cellsize\n\tvec2 g; // num cells\n\tfloat frame_width, border_height, border_depth, glass_depth, frame_depth;};\n\nvoid sdOneWindow( vec3 p, inout DistanceId eval, WindowOrDoorArg args ){\n\tfloat d_in = eval.d;\n\tvec2 c = args.c;\n\tvec2 g = args.g - vec2( 1 );\n\tp.x += ( args.g.x * 0.5 - 0.5 ) * c.x; // center on x...\n\tvec2 pmin = -c.xy * 0.5;\n\tvec2 pmax = c.xy * ( vec2( 0.5 ) + g );\n\t// window glass and frame\n\tvec3 pr = p;\n\tvec2 i = floor( ( pr.xy - ( -c * 0.5 ) ) / c ); // c the cell size\n\ti = clamp( i, vec2( 0, 0 ), g );\n\tpr.xy -= i * c;\n\tfloat d_glass = sd_bounds_half_size( pr, vec3( c * 0.5 - vec2( args.frame_width ) * 0.5, args.glass_depth ) );\n\teval.d = opS( eval.d, d_glass );\n\t// window general frame\n\tfloat d_frame = sd_bounds_range( p, vec3( pmin, -args.frame_depth ), vec3( pmax, args.frame_depth ) );\n\teval.d = opS( eval.d, d_frame ); // make the whole window sink a bit\n\t// window border\n\tif ( _1 ) eval.d = opI( d_in - args.border_depth // clamp vs inflated version of source block we are decorating\n\t\t\t\t\t\t\t, opU( eval.d\n\t\t\t\t\t\t\t\t   , sd_bounds_range( p\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmin.x, pmin.y - args.border_height, 0 )\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmax.x, pmin.y, args.border_depth ) ) ) );\n\tif ( -d_glass == eval.d ) eval.id = MATID_WINDOW;}// we used opS so we need -d_glass\n\n\nvoid addWindow( inout DistanceId eval, vec3 p, float is_chimney_face, float half_wall_width ){\n\tp.y += 0.016; // adjust windows height\n\tvec2 c = vec2( 0.07*mix(1.8,1.0,is_chimney_face), 0.07 ); // tile size\n\tvec2 window_size = vec2( 0.018, 0.02 ); // size of the object inside each tile, must be smaller than c\n\tfloat d_glass = FLT_MAX;\n\tvec2 i = floor( ( p.xy - ( -c.xy * 0.5 ) ) / c.xy ); // c the cell size\n\tfloat maxnum_cells = floor( (half_wall_width / c.x) - 0.5 ); // max num window that fit on this wall, assume p.x centered\n\tivec2 imin = ivec2( -maxnum_cells, 1 );\n\tivec2 imax = ivec2(  maxnum_cells, 1 );\n\ti = clamp( i, vec2(imin), vec2(imax) );\n\tp.xy -= i * c;\n\tWindowOrDoorArg args;\n\targs.c = window_size; // cellsize\n\targs.g = mix( vec2( 2, 2 ), vec2( 2, 2 ), is_chimney_face ); // window glass grid size\n\tfloat scl = 0.012;\n\targs.frame_width = 0.05 * scl;\n\targs.border_height = 0.3 * scl;\n\targs.border_depth = 0.2 * scl; // can't be bigger than d_house_bottom_inset\n\targs.glass_depth = 0.3 * scl;\n\targs.frame_depth = 0.1 * scl;\n\tsdOneWindow( p, eval, args );}\n\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2yface( vec3 p, vec2 orig ) { p.y = abs( p.y ); p.xy -= orig; p.xzy = p.xyz; p.x = -p.x; return p; }\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2xface( vec3 p, vec2 orig ) { p.x = abs( p.x ); p.xy -= orig; return p.yzx; }\n\n// note: tracing detail doesn't always work very well on heightfields so z proj/triplanar type of mapping isn't great for roof\n// instead we do more tedious evals, building roof local points + 3d detail on that etc\nDistanceId sdFarm( vec3 p, CellPoint cr,float patch_id,float r, float detail ){\n\tvec4 hh = hash42_( cr._pi);\n\tbool has_chimney = hh.y > 0.4;\n\tbool _x2chimney = _1;\n\tvec2 hs1 = vec2( 0.25, 0.083 );\n\tvec2 hs2 = vec2( 0.083, 0.18+hh.z*0.02 );\n\tfloat h = 0.0996;\n\tfloat bottom_block_inset = 0.00498;\n\tfloat bottom_block_inset2 = bottom_block_inset*(has_chimney?0.0:1.0);\n\tfloat roof_thickness = 0.00166;\n\tfloat chimney_side_len = 0.018+hh.z*0.002; // chimney side length\n\tfloat chimney_height = h + hs1.y + chimney_side_len;\n\tfloat chimney_bottom = h + hs1.y - 0.04;\n\tfloat roof_tile_scl = 2.5; \n\tfloat roof_tile_scl2 = 1.1; \n\tbool half_hipped = hh.z>0.5;\n\tfloat bottom_inflate = 0.001;\n\tvec2 hs1_in = hs1 - vec2( bottom_block_inset2, bottom_block_inset );\n\tvec2 hs2_in = hs2 - vec2( bottom_block_inset );\n\t// symmetric window plane\n\tfloat block1_chimney_wall_plane_x = hs1_in.x;\n\tfloat block1_wall_plane_y = hs1_in.y;\n\tfloat block2_wall_plane_y = hs2_in.y;\n\tvec3 ps = p; // store signed p\n\tvec3 pay = p; pay.y = abs( pay.y ); // symmetric around y\n\tvec3 pax = p; pax.x = abs( pax.x ); // symmetric around x\n\tfloat d_block1_bottom = FLT_MAX;\n\tfloat d_block1_roof = FLT_MAX;\n\tfloat d_block1_bottom2 = FLT_MAX;\t{\n\t\t// --- gable roof, 2 planes (v-shaped)\n\t\tbounds2 block1 = mkbounds_unchecked( -hs1, hs1 );\n\t\tfloat d_block1_footprint = sd_bounds_range( p.xy, block1.pmin.xy, block1.pmax.xy );\n\t\tvec3 roof1_top_point = vec3( hs1.x, 0, h + hs1.y );\n\t\t// p.yz is the gable roof cross section space point\n\t\tvec3 roof_plane_local_p = vec3( -dot( pay.yz - roof1_top_point.yz, perp( V45 ) ), p.x, dot( pay.yz - roof1_top_point.yz, V45 ) );\n\t\td_block1_bottom = opI( roof_plane_local_p.z, d_block1_footprint );\n\t\td_block1_bottom = opI( d_block1_bottom, pay.y -hs1_in.y );\n\t\td_block1_bottom = opI( d_block1_bottom, pax.x - block1_chimney_wall_plane_x );\n\t\td_block1_bottom = opI( d_block1_bottom, roof_plane_local_p.z + 0.002 );\n\t\t// add tile detail to gabble roof, hacky mess to be sorted\n\t\td_block1_roof = roof_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof_plane_local_p.yx * roof_tile_scl )* roof_tile_scl2;\n\t\td_block1_roof = opS( d_block1_roof, roof_plane_local_p.z + 0.002 );\n\t\td_block1_roof = opI( d_block1_roof, d_block1_footprint );\n\t\td_block1_bottom2 = opI(d_block1_footprint-bottom_inflate,p.z);\t}\n\tfloat d_chimney = FLT_MAX;\n\tif ( has_chimney )\t{\n\t\tvec2 chimney_c = vec2( hs1_in.x, 0 );\n\t\tbounds2 chimney_footprint_b = mkbounds_unchecked( chimney_c - vec2( chimney_side_len ), chimney_c + vec2( 0, chimney_side_len * 0.5 ) );\n\t\tfloat d_chimney_footprint = sd_bounds_range( _x2chimney ? abs( p.xy ) : p.xy, chimney_footprint_b.pmin.xy, chimney_footprint_b.pmax.xy );\n\t\td_chimney = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z -chimney_height ) );\n\t\tfloat d_chimney_hole = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z - chimney_height * 1.5 ) ) + 0.002;\n\t\td_chimney = opS( d_chimney, d_chimney_hole );\t}\n\tfloat d_block2_roof = FLT_MAX;\n\tfloat d_block2_bottom = FLT_MAX;\n\tfloat d_block2_bottom2 = FLT_MAX;\n\tif ( hh.x > 0.4 )\t{\n\t\t// --- hipped roof\n\t\tbounds2 block2 = mkbounds_unchecked( -hs2, hs2 );\n\t\tfloat d_block2_footprint = sd_bounds_range( p.xy, block2.pmin.xy, block2.pmax.xy );\n\t\t//return d_block1_roof;\n\t\td_block2_bottom = opI( d_block2_footprint + bottom_block_inset, ( p.z - h ) ); // block2 is inset equally on x and y \n\t\td_block2_bottom2 = opI(d_block2_footprint-bottom_inflate,p.z);\n\t\t\n\t\t//return d_block2_bottom;\n\t\tvec3 roof2_corner_point = vec3( hs2, h );\n\t\tvec3 roof2a_plane_local_p = vec3( p.y, -dot( pax.xz - roof2_corner_point.xz, perp( V45 ) ),dot( pax.xz - roof2_corner_point.xz, V45 ) );\n\t\tfloat roof2detail_a = roof2a_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2a_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\t// like the s1 one, exactly. just offset, can we factorize?\n\t\tvec3 roof2b_plane_local_p = vec3( p.x, -dot( pay.yz - roof2_corner_point.yz, perp( V45 ) ),dot( pay.yz - roof2_corner_point.yz, V45 ) );\n\t\tfloat roof2detail_b = roof2b_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2b_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\td_block2_roof = opI( roof2b_plane_local_p.z, roof2a_plane_local_p.z );\n\t\td_block2_roof = opI( roof2detail_a, roof2detail_b );\n\n\t\tif ( half_hipped )\t\t{\n\t\t\td_block2_roof = opI( d_block2_roof, p.y );\n\t\t\td_block2_bottom = opI( d_block2_bottom, p.y );\n\t\t\td_block2_bottom2 = opI( d_block2_bottom2, p.y );}}\n\tDistanceId bb1 = MkDistanceId( d_block1_bottom, MATID_HOUSE_TOP );\n\tDistanceId bb2 = MkDistanceId( d_block2_bottom, MATID_HOUSE_TOP );\n\tif ( FARM_WINDOWS )\t{\n\t\taddWindow( bb1, p2xface( p, vec2( hs1_in.x, 0.0 ) ), 1., hs1_in.y );\n\t\taddWindow( bb1, p2yface( p, vec2( 0, hs1_in.y ) ), 0., hs1_in.x );\n\t\taddWindow( bb2, p2yface( p, vec2( 0, hs2_in.y ) ), 0., hs2_in.x );\t}\n\tDistanceId roof_eval = MkDistanceId( opI( h - p.z, opU( d_block1_roof, d_block2_roof ) ), MATID_ROOF );\n\tDistanceId bottom_eval = MkDistanceId( d_chimney, MATID_HOUSE_TOP );\n\tbottom_eval = opUdi( bottom_eval, bb1 );\n\tbottom_eval = opUdi( bottom_eval, bb2 );\n\tDistanceId bottom2_eval = MkDistanceId( opU( d_block1_bottom2, d_block2_bottom2 ), MATID_HOUSE_BOT );\n\treturn opUdi( opUdi( roof_eval, bottom_eval ), bottom2_eval );}\n\nDistanceId sdGridObj_Farm( DistanceId di\n\t\t\t\t\t\t   , vec3 p\n\t\t\t\t\t\t   , CellPoint cr\n\t\t\t\t\t\t   , float radius_fraction\n\t\t\t\t\t\t   , float patch_id\n\t\t\t\t\t\t   , inout vec3 color\n\t\t\t\t\t\t   , SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, bool taylor_expansion_height ){\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\t\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\tif ( HasDirection( scenein.trace_flags ) \n\t\t && ( sphere_trace( mkray( scenein.p, scenein.v ), r, vec3( c, cz ) ).x == FLT_MAX ) )\t{\n\t\treturn di;\t}\n#endif\n\t// orient farm along terrain gradient to reduce sinking cases\n\tvec2 e = vec2( 1e-3, 0 );\n\tvec2 h_gradval_at_c = ( vec2( BaseGroundHeight( c.xy + e.xy ),\n\t\t\t\t\t\t\t\t  BaseGroundHeight( c.xy + e.yx ) ) - vec2( cz ) ) / e.x; // be careful to not divide by e since it has zero in .y\n\tfloat grad_len = length( h_gradval_at_c );\n\t#define FARMS_GRAD_LIMIT   _1 // don't place farms when slope is too strong\n\t#define FARMS_GRAD_ELEVATE _1 // elevate house so they don't sink into the ground, using the gradient\n\t#define FARMS_GRAD_ALIGN   _1 // align farm with terrain gradient instead of random rotation\n\tif ( FARMS_GRAD_LIMIT && ( grad_len > 0.17 ) ) return di;\n\tif ( FARMS_GRAD_ELEVATE ) cz += r * grad_len * 0.65;\n\t// move to local coords\n\tp.xy -= c;\n\tp.z -= cz;\n\tp.xy = rotate_with_unit_vector( p.xy, FARMS_GRAD_ALIGN && ( grad_len > 0.01 )\n\t\t\t\t\t\t\t\t\t? normalize( h_gradval_at_c ) \n\t\t\t\t\t\t\t\t\t: unit_vector2( hash1u2_4tXyWN( uvec2(cr._pi) ) * 2.0 * PI ) ); // random rotation\n\n\tif ( _0 ) return MkDistanceId( sd_sphere( p, vec3( 0 ), r ), MATID_HOUSE_TOP ); // try make the building fit inside the sphere\n\n\tDistanceId eval = sdFarm( p, cr,patch_id, r, 1.0 );\n\t\n\tif ( IsShadeTrace( scenein.trace_flags ) && ( DecodeId( eval ) == MATID_ROOF ) )\t{\n\t\teval = MkDistanceId_16( eval.d, MATID_ROOF, hash11( patch_id ) );\t} // same roof color for all houses in patch\n\treturn eval;}\n\nfloat sdBrickWall( vec3 p, ClosestPath path, float h\n){\tfloat wall_start_dist = LANEWIDTH * 0.5 + 0.005;\n\tfloat wall_thickness = 0.018;\n\tfloat wall_height = 0.05;\n\tfloat wall_radius = 0.008;\n\tfloat d = FLT_MAX;\n\tfor ( float k = 0.0; k < 2.0; k += 1.0 )\n\t{\n\t\tvec3 pl = p; // p local\n\t\tpl.xy = GetLocalCurvePoint( path );\n\t\tpl.y -= wall_start_dist + wall_thickness * 0.5;\n\t\tpl.z -= h;\n\t\tvec3 s = vec3( 0.01, 0.006, 0.006 );\n\t\tfloat spacing = 0.0015;\n\t\tvec3 c;\n\t\tc.xz = vec2( s.x + spacing, 2.0 * s.z + spacing );\n\t\tc.y = s.y + spacing;\n\t\tvec2 offset = -0.5 * c.xz;\n\t\tfloat o = 0.5 * k;\n\t\toffset.xy += o * c.xz;\n\t\tvec2 i;\n\t\ti = floor( ( pl.xz - offset ) / c.xz );\n\t\ti.y = min( i.y, 2.0 );\n\t\tpl.xz -= i * c.xz;\n\t\tpl.xz -= o * c.xz;\n\t\tfloat r = 0.002;\n\t\td = opU( d, sd_bounds_range_round( pl, -s * 0.5, s * 0.5, r ) );\n\t}\n\tif ( _1 ) d -= 0.003 * sfbm2_13( p * 80.0 );\n\treturn d;}\n\nfloat sdGrass( vec3 p, float h ) { return p.z - h; }\n\n// scene eval output\nstruct SceneOut{\n\tDistanceId object_di;\n\tfloat d_ghost; // can we optimize that and have less of those?\n\tfloat base_height; // base ground height\n\tClosestPath path;\n\tClosestPath test2d; // for 2d view mode\n\tvec3 color; // special color case for bushes (when id_fraction is not enough)\n#ifdef TERRAIN_WARP\n\t// this cuts bush evals massively\n\tfloat terrain_warp; // todo: move out of this struct, this is not part of returned information\n#endif\n};\n\nvoid SceneOutInit( inout SceneOut eval ) { eval.d_ghost = FLT_MAX; }\n\nvec3 get_bush_palette( vec2 uv ){\n\treturn mix( mix( mix( COLOR_BUSH1, COLOR_BUSH2, uv.x ), mix( COLOR_BUSH3, COLOR_BUSH4, uv.x ), uv.y )\n\t\t\t\t, COLOR_BUSH5, smoothband( uv.x, 0.49, 0.51, 0.01 ) );}\n\nbool is_white_cell( vec2 p_index ) { return ( int( p_index.x + p_index.y ) & 1 ) == 1; }\n\nvoid consider_close_point_hi(\ninout float d, vec2 index, float r\n, inout vec4 color, vec3 p, float cellsize\n, vec3 h_gradval, bool taylor_expansion_height, int trace_flags ){\n\tvec3 c;\n\tvec3 h = hash32( index );\n\tc.xy = ( index + h.xy ) * cellsize;\n\tc.z = CalcHeight( c.xy, p.xy, h_gradval, taylor_expansion_height ) + r * mix( -0.8, 1.3, h.z );\n\tfloat di = length( c - p ) - r;\n\td = min( d, di );\n\tif ( IsShadeTrace( trace_flags ) )\t{\n\t\tvec2 ch = hash22( index );\n\t\t// this is called only once in shade, knock yourself out\n\t\tfloat w = max( 1. - smoothstep( -r * 0.1, r * 0.25, di ), 1e-3 );\n\t\tcolor.xyz += get_bush_palette( ch ) * w;\n\t\tcolor.a += w;}}\n\nstruct CloseGridPointArgs { float cell_size, max_radius, radius_disparity; };\n\nstruct CloseGridPointArgsWithBand{\n\tCloseGridPointArgs args0;\n\tfloat band_start, band_end;\n\tbool taylor_expansion_height;};\n\n// 45 means we consider 4 or 5 neighbour (instead of 3x3) depending on whether we are on a white or a black cell (not perfect but covers lots of cases)\n// instead of giving the closest point this version does a little bit of extra calculation or each candidate for color blending on bushes\nfloat GetCloseGridPoints45( inout vec3 a_color, vec3 p, float cellsize\n, vec3 h_gradval, CloseGridPointArgsWithBand args, int trace_flags, int F){\n///..., frame\n\tfloat r = args.args0.max_radius * 0.8;\n\tvec2 p_index = floor( p.xy * ( 1.0 / cellsize ) );\n\n\tfloat d = FLT_MAX;\n\tvec4 color = vec4( 0.0 );\n#if 0\n\t// the unrolled code path is faster on my current view (70ms->68ms) but shader compilation prefers the loop (-1s)\n\tif ( is_white_cell( p_index ) )\t{\n\t\t//white cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}else{\n\t\t//black cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2( -1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n#else\n\tvec2 offset = vec2( 0, 1 ); // white cells check 4 canonical axis neigbours\n\tif ( !is_white_cell( p_index ) )\t{\n\t\tconsider_close_point_hi( d, p_index, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags ); // this cell, only checked if black\n\t\toffset = vec2( 1, 1 );\t} // black cells check the 4 diagonal neighbours\n\n\n\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\t{\n\t\tconsider_close_point_hi( d, p_index + offset, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\toffset = perp( -offset );\t} // go to next neighbour by rotating +90\n\n#endif\n\tif ( IsShadeTrace( trace_flags ) ) // skipping this test breaks the trees...\n\t\ta_color = color.xyz / color.a;\n\treturn d;}\n\n#define bush_max_radius 0.04\n// for bushes we do something symbolic looking, with a slight Hiroshi Nagai vibe \nvoid AddContributionBush(float groundz, inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t\t, vec3 h_gradval,  vec3 patch_id_hash\n\t\t\t\t\t\t\t, bool is_forest_patch, float aTime, int aFrame ){\n\tvec3 p = scenein.p;\n\tbool has_bushes = patch_id_hash.x > 0.2;\n\tbool has_cut_bushes = SQUARE_BUSH_TEST && ( !is_forest_patch && patch_id_hash.x > 0.62 );\n\n\tfloat bush_cell_size = 0.095;\n\n\tfloat bush_d_min = p.z - ( groundz + bush_max_radius*1.9 ); // upper bound for distance to bushes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // multiply by 2 else lots of bushes get cut... \n\n\t// note: whether we use > or <= has resulted in big difference in the past sometimes\n\tif ( !has_bushes\n\t\t || ( bush_d_min > eval.object_di.d )\n#ifdef TERRAIN_WARP\n\t\t || (\n\t\t\t  ( eval.terrain_warp != 0.0 ) &&\n\t\t\t  ( bush_d_min > 0.0 ) &&\n\t\t\t  ( bush_d_min < eval.terrain_warp ) ) // we know we can roughly traverse by eval.terrain_warp before hitting next bush\n#endif\n\t\t) return;\n\n\tfloat d = FLT_MAX;\n\tfloat id_fraction = 0.0;\n\tfloat freq = 1.0;\n\n\tif ( has_cut_bushes\n    ){\tfreq = DISPLACE_BUSH_FREQ;\n\t\t\n\t\t// patch section 2d point\n\t\tvec2 p_patch_section = vec2( eval.path.patch_di.d, p.z - eval.base_height );\n\t\tfloat d_square_bush = sd_bounds_range( p_patch_section, vec2( LANEWIDTH - 0.015, 0 ), vec2( LANEWIDTH + 0.02, 0.05 ) );\n\t\td = d_square_bush; // we distort so...\n\n\t\teval.color = COLOR_BUSH3;\n\t}\telse\t{\t\n       freq = DISPLACE_BUSH_FREQ;\n\n\t\t// this is a patch with bushes on the side\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = bush_cell_size;\n\t\targs.args0.max_radius = bush_max_radius;\n\t\targs.args0.radius_disparity = 0.4;\n\t\targs.band_start = LANEWIDTH * 0.5 + args.args0.max_radius * 0.5; // take a fraction of the radius so that some of the bushes overlap a bit with the path\n\t\targs.band_end = args.band_start + 0.18 + pow2( patch_id_hash.z ) * 0.3;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_BUSH;\n\t\td = GetCloseGridPoints45( eval.color, p, args.args0.cell_size * 0.5, h_gradval, args, scenein.trace_flags, aFrame );\n\t\tif ( SOFT_BLEND_BUSH ) d = opU_weld_quadric( p.z - eval.base_height, d, 0.027 );\n\t\t// clip bush vs path/walls (leak through walls is a happy accident)\n\t\tif ( _1 ) d = opS_soft2( d, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5, 100.0 );\n\t\tif ( _1 )\t\t{\n\t\t\t// fade bush inside patch\n\t\t\tfloat bf = ( sfbm1_12( p.xy * 18.0 ) - 0.5 ) * 0.33; // distort fade boundary\n\t\t\td = opS_soft2( d, args.band_end * ( 1. + bf ) - eval.path.patch_di.d, 30.0 );\t\t}\t}\n\n\tif ( DISPLACE_BUSH )\t{\n\t\tfloat dd = 0.0045; // need more displacement to see shadows...\n\t\tvec3 pd = p;\n\t\tif ( WIND_BUSH ) pd += ApplyWind( pd, aTime );\n\t\t // the test is < ..*3 because we INFLATE\n\t\tif ( d < dd * 3.0 ) d -= sfbm2_13( pd * vec3( 80.0, 80.0, 100 ) * freq ) * dd;\t}\n\teval.object_di = opUdi( eval.object_di, MkDistanceId_16( d, MATID_BUSH, id_fraction ));}\n\n// return closest cell point with a radius, no neighbour, used by farms and trees\n// max_radius must be less than cell_size*0.5\n// radius_disparity percentage in 0,1\n// grid_offset in 0,1, conceptually...\nvoid GetClosestGridPoint( inout CellPoint point, vec2 p\n, CloseGridPointArgs args0, float grid_offset, float hoffset\n){\tvec2 piss = floor( ( p - grid_offset ) / args0.cell_size );\n\tpoint._pi = ivec2( piss + vec2( hoffset ) );\n\tvec4 ph = hash42_( point._pi );\n//\tph.xy = vec2( 0.5 ); // debug\n\tpoint.pradius = args0.max_radius * ( 1.0 - args0.radius_disparity * ph.z );\n\tvec2 a = grid_offset + piss * args0.cell_size;\n\tvec2 b = a + vec2( args0.cell_size );\n\tpoint.p = mix( a + vec2( point.pradius ),\n\t\t\t\t   b - vec2( point.pradius ), ph.xy );} // important: +offset to put back in same space as p\n\n\n// used by farms and trees\nbool GetClosestGridPointWithPathBand_x1( inout CellPoint point\n\t\t\t\t\t\t\t\t\t\t , vec2 p\n\t\t\t\t\t\t\t\t\t\t , vec3 h_gradval\n\t\t\t\t\t\t\t\t\t\t , CloseGridPointArgsWithBand args\n\t\t\t\t\t\t\t\t\t\t , float grid_offset, float hoffset\n){\tGetClosestGridPoint( point, p, args.args0, grid_offset, hoffset );\n\t// we want to know if this point is within a band of the country patch we are currently in\n\tfloat distance_to_patch_border = abs( EvalClosestPath( point.p, true ).patch_di.d );\n\treturn ( distance_to_patch_border > args.band_start )\n\t\t&& ( distance_to_patch_border < args.band_end );}\n\nvoid SetSceneInDirection( inout SceneIn scenein, vec3 o, vec3 v, int trace_flags\n){\tscenein.v = v;\n\tscenein.v_rcp = vec3( 1.0 ) / v;\n//\tscenein.o = o;\n\tscenein.trace_flags = trace_flags | TRACE_HAS_DIRECTION;\n\tscenein.t0 = 0.0;}\n\nvoid SetSceneInDirectionless( inout SceneIn scenein, int trace_flags\n){\tscenein.v = vec3( 0.0 );\n\tscenein.v_rcp = vec3( 0.0 );\n//\tscenein.o = vec3( 0.0 );\n\tscenein.trace_flags = trace_flags;\n\tscenein.t0 = 0.0;}\n\nfloat ClampRayAgainstCurrentGridCell( vec3 p, vec3 v_rcp, vec3 cell_size, float cell_inflate_epsilon\n){\t// we know the direction therefore we only have to test one side of each axis\n\tvec3 s = sign( v_rcp );\n\tvec3 amin = floor( p / cell_size ) * cell_size;\n\tamin -= vec3( cell_inflate_epsilon ); // instead of adding that to d_ghost we clamp to cell_size + cell_inflate_epsilon\n\tvec3 a = amin + ( ( s + 1.0 ) * 0.5 ) * ( cell_size + 2.0 * vec3( cell_inflate_epsilon ) );\n\tvec3 t = ( a - p ) * v_rcp; // ray vs all closest box planes\n//\tt += FLT_MAX * ( 1.0 - abs( s ) ); // when sign is zero, push next hit at t=+infinite, v_rcp has been set to zero in that case\n\treturn min( min( t.x, t.y ), t.z );} // should be > 0 by construction\n\nbool CanGhostStep( SceneIn scenein, float maxdist_from_t0, float maxdist_abs\n){\treturn HasDirection( scenein.trace_flags )\n\t\t&& ( scenein.t < maxdist_abs ) // GHOST_MAX_DIST_ABS\n\t\t&& ( ( scenein.t - scenein.t0 ) < maxdist_from_t0 );} // GHOST_MAX_DIST_FROM_T0\n\n\nvoid GhostGridSteps( inout SceneOut eval, SceneIn scenein, float cell_size, float cell_inflate_epsilon \n){\tfloat dm = ClampRayAgainstCurrentGridCell( scenein.p, scenein.v_rcp\n\t\t\t\t\t\t\t\t\t\t\t   , vec3( cell_size, cell_size, 20.0 ), cell_inflate_epsilon );\n\t// note that this doesn't deal with diagonals which might cross another cell\n\teval.d_ghost = min( eval.d_ghost, max( dm, GHOST_EPS ) );}\n\n// used by farms and trees\n#define SD_OBJECT_CONTRIB( _di_, _object_sd_func_, _grid_offset_, _hoffset_ ) {\\\n\tCellPoint _cp_; \\\n\tif ( GetClosestGridPointWithPathBand_x1( _cp_, p.xy, h_gradval, args, _grid_offset_, _hoffset_ ) )\\\n\t\t_di_.object_di = _object_sd_func_( _di_.object_di, p, _cp_, radius_fraction, _di_.path.patch_di.id, eval.color, scenein, h_gradval, args.taylor_expansion_height );\\\n}\n\nvoid AddContributionTree( float groundz, \ninout SceneOut eval, SceneIn scenein\n, vec3 h_gradval,vec3 patch_id_hash, int aFrame, float aTime \n){\tvec3 p = scenein.p;\n\tfloat tree_max_radius = 0.15;\n\tCloseGridPointArgsWithBand args;\n\targs.args0.cell_size = 0.4;\n\targs.args0.max_radius = tree_max_radius;\n\targs.args0.radius_disparity = 0.1;\n\targs.band_start = args.args0.max_radius;\n\t// some patches are filled with trees, some other patches only have trees on the border\n#if 1\n\targs.band_end = patch_id_hash.x > 0.9 ? FLT_MAX : args.args0.max_radius * 3.0;\n#else\n\targs.band_end = FLT_MAX;\n#endif\n\targs.taylor_expansion_height = TAYLOR_HEIGHT_TREE;\n\n\tfloat grid_offset_step = 0.25; // this is wrong actually but creates a certain sparsity that is welcome\n\tvec3 grid_offsets = vec3( 0., 1.0, 2.0 ) * grid_offset_step * args.args0.cell_size;\n\tfloat radius_fraction = 1.0;\n#if 0\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.x, 000.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.y, 100.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.z, 200.0 );\n#else\n\t// this might be a bit faster (92->71!), also shadertoy compile time\n\tfor ( float f = 0.0 FORCE_LOOPF; f < 3.0; f += 1.0\n    ){SD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offset_step * args.args0.cell_size * f, 100.0 * f );}\n#endif\n\n\tfloat mat_id = DecodeId( eval.object_di );\n\t// displace all the trees at once...\n\tif ( DISPLACE_TREE && ( ( mat_id == MATID_TREE ) || ( mat_id == MATID_PINE ) )\n    ){\tvec3 pd = p;\n\t\tif ( WIND_TREE_AND_PINES ) pd += ApplyWind( pd, aTime );\n\t\tfloat is_pine = ( mat_id == MATID_PINE ) ? 1. : 0.;\t\t\n\t\tpd.z *= mix(1.,0.75,is_pine);\t\t\n\t\teval.object_di.d += sfbm2_13_leaf( pd * 80.0 * 2.2 ) * TREE_SDD * mix( 1., 0.4, is_pine ) * 0.8\n    ;}\n\tif ( GHOST_STEPS_TREE && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS )\n    ){// note: offset zero for all + smallest cell size fraction multiple should yield same result\n\t\tfloat cell_inflate_epsilon = 0.004; // tree\n\t\tGhostGridSteps( eval, scenein, grid_offset_step * args.args0.cell_size, cell_inflate_epsilon );}}\n\nvoid AddContributionFarm(float groundz, inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval,  vec3 patch_id_hash\n\t\t\t\t\t\t   , float cpmph ){\n                           //... cpmph == closest_path_middle_point_height\n\tvec3 p = scenein.p;\n\tbool is_farm_patch = patch_id_hash.x > 0.2;\n\n\tif ( !is_farm_patch ) return;\n\n\tif ( FARM )\n\t{\n\t\t// farms are sparse so use 1 cell\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = 1.2;\n\t\targs.args0.max_radius = 0.35;\n\t\targs.args0.radius_disparity = 0.3;\n\t\targs.band_start = args.args0.max_radius * 1.5;\n\t\targs.band_end = FLT_MAX;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_FARM;\n\t\tfloat radius_fraction = 0.8;\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_Farm, 0.0, 0.0 );\n\t\tif ( GHOST_STEPS_FARM && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t\t{\n\t\t\tfloat cell_inflate_epsilon = 0.004;\n\t\t\tGhostGridSteps( eval, scenein, args.args0.cell_size, cell_inflate_epsilon );\n\t\t}\n\t}\n\n\tif ( BRICKWALL && patch_id_hash.y > 0.7 ) // note: not all farm patch have a visible house on them...\n\t{\n\t\tDistanceId walls = MkDistanceId( sdBrickWall( p, eval.path, eval.base_height ), MATID_BRICKWALL );\n\t\teval.object_di = opUdi( eval.object_di, walls );\n\t}\n}\n\nvoid AddContributionGras(float groundz,  inout SceneOut eval, vec3 p, vec3 patch_id_hash )\n{\n\tfloat grass_height = ( groundz - 0.01 ) // make sure grass doesn't cover the path ground\n\t\t+ smoothstep( -0.02, 0.04, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5 ) * 0.0195;\n\tDistanceId grass = MkDistanceId_16( sdGrass( p, grass_height ), MATID_GRASS, patch_id_hash.z ); // each patch has slightly different colors\n\teval.object_di = opUdi( eval.object_di, grass );\n}\n\nvoid AddContributionPath( float groundz , inout SceneOut eval, SceneIn scenein)\n{\n\tvec3 p = scenein.p;\n\tfloat path_d_min = p.z - groundz;\n\n\tif ( !( path_d_min < eval.object_di.d ) ) return; // weird compiler horror happened depending how we write the if branch here\n\n\t// path is the most occluded thing so do it last\n\tDistanceId path_di = MkDistanceId_16( path_d_min // lower bound for bushes\n\t\t\t\t\t\t\t\t\t   , MATID_GROUND, ( 1.0 - smoothstep( 0.0, 0.05, eval.path.patch_di.d ) ) );\n\tif ( DISPLACE_PATH )\n\t{\n\t\t// this displacement is expensive, cull as much as we can, maybe we could just do that in shade\n\t\tfloat path_blend = 1.0 - smoothstep( 0.001, 0.008, eval.path.patch_di.d - LANEWIDTH * 0.5 );\n\t\tfloat distance_blend = 1.0 - smoothstep( 6.0, 7.0, scenein.t );\n\t\tfloat fade = path_blend * distance_blend;\n\t\tif ( fade > 0.0 ) // that cuts a bit\n\t\t{\n\t\t\t// so we can scale along road direction\n\t\t\tpath_di.d += fade * sfbm2_12( GetLocalCurvePoint( eval.path ) * vec2( 1, 2 ) * 80.0 ) * DISPLACE_PATH_AMPL;\n\t\t}\n\t}\n\n\teval.object_di = opUdi( eval.object_di, path_di );\n}\n\nSceneOut evalScene( SceneIn scenein, int F, float T//scenein,aFrame,aTime\n){vec3 p = scenein.p//+vec3(0,0,11)\n ;SceneOut eval\n ;SceneOutInit(eval)\n ;float groundz = BaseGroundHeight( p.xy )\n ;eval.base_height = groundz\n ;eval.path = EvalClosestPath( p.xy, false )\n ;vec3 h_gradval = vec3( 0.0, 0.0, groundz )\n ;\n #ifdef TERRAIN_WARP\n ;vec3 ground_normal\n #endif\n ;if(\n #ifdef TERRAIN_WARP\n _1 ||\n #endif\n\t// any of those need the height gradient at p\n TAYLOR_HEIGHT_BUSH ||\n TAYLOR_HEIGHT_TREE ||\n TAYLOR_HEIGHT_FARM\n ){vec2 e = vec2( 1e-3, 0)\n  ;float hx = BaseGroundHeight( p.xy + e.xy )\n  ;float hy = BaseGroundHeight( p.xy + e.yx )\n  ;h_gradval.xy = vec2( hx-eval.base_height,hy-eval.base_height)/e.x //beware that e.y=0.\n  #ifdef TERRAIN_WARP\n  ;vec3 px = vec3( p.xy + e.xy, hx )\n  ;vec3 py = vec3( p.xy + e.yx, hy )\n  ;vec3 pc = vec3( p.xy, eval.base_height )\n  ;ground_normal = normalize( cross( px - pc, py - pc ) )\n  #endif\n ;}\n #ifdef TERRAIN_WARP\n ;eval.terrain_warp = 0.\n ;if ( HasDirection( scenein.trace_flags ) \n ){float large_optimistic_step = 3.0\n  ;vec3 base = vec3( p.xy, eval.base_height + bush_max_radius*2.5 )\n  ;Ray warp_ray\n  ;warp_ray.o = scenein.p\n  ;warp_ray.d = scenein.v\n  ;float t2 = plane_trace( warp_ray, base, ground_normal, 1e-3 )\n  ;if (t2>0.\n  ){//if ( dot( ground_normal, scenein.v ) < 0 ) // if terrain is convex at ground_normal in trace direction?\n   ;eval.terrain_warp = min( t2, large_optimistic_step )\n  ;}}\n  #endif\n  ;// eval.path.patch_di.id is the patch id\n  ;// eval.path.patch_di.d is the distance to closest path\n  ;// the path we walk on is flat so we need the height of center of the road\n  ;vec2 closest_patch_border_point2 = p.xy + eval.path.v2closest // center of road\n  ;float cpmph = BaseGroundHeight( closest_patch_border_point2 ) // fences use\n  ;eval.test2d = eval.path\n  ;// upper bound for distance to ground, take into account displacement that might dig a little on paths\n  ;float d_ground_max = p.z - ( eval.base_height - DISPLACE_PATH_AMPL * 2.0 )\n  ;if ( GROUND_OCCLUSION ) eval.object_di = MkDistanceId( d_ground_max, MATID_GROUND ) // occlusion helps\n  ;else eval.object_di = MkDistanceId( FLT_MAX, MATID_NONE ) // enable PATH to get a ground\n  ;// hit the patch boundary tangent plane, this has 2 properties we want:\n  ;//  1- the closer we are to the boundary the more this approximates the hit point, sort of\n  ;//  2- if ray leaches the patch boundary, the hit point will be far away\n  ;//      -> that second one improves significantly the horrible artifact where we run out of points...\n  ;//  also ignore far away hits for perfs   \n  ;// todo: we don't need ghost steps if we are far above the ground! we can save a bit\n  ;if ( GHOST_STEPS_PATCH && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS )\n  ){vec3 base = vec3( p.xy + eval.path.v2closest, p.z )\n   ;vec3 normal = normalize( -vec3( eval.path.v2closest, 0 ) )\n   ;float t2 = plane_trace( p, scenein.v, base, normal, 1e-3 )\n   ;if ( t2 > 0.0 ) eval.d_ghost = min( eval.d_ghost, max( t2, GHOST_EPS ) )\n  ;}\n//\tvec3 patch_id_hash = hash31( eval.path.patch_di.id )\n ;vec3 patch_id_hash = hash42_( ivec2( int( eval.path.patch_di.id ) ) ).xyz// paranoid use of ints for important structural elements\n ;bool is_forest_patch = patch_id_hash.x > 0.65\n ;if (is_forest_patch\n  ){if(TREE)AddContributionTree(groundz,eval,scenein,h_gradval,patch_id_hash,F,T)\n  ;}else    AddContributionFarm(groundz,eval,scenein,h_gradval,patch_id_hash,cpmph)\n ;if (BUSH) AddContributionBush(groundz,eval,scenein,h_gradval,patch_id_hash,is_forest_patch,T,F )\n ;if (PATH) AddContributionPath(groundz,eval,scenein)\n ;if (GRAS )AddContributionGras(groundz,eval,p,patch_id_hash)\n ;return eval;}\n\n\n\nstruct TraceOutput{\n\tfloat t;\n\tfloat dist; // distance to surface (error)\n\tfloat shadow;}; // sun/main light occlusion\n\n\n\n\n#define MAX_ITERATIONS_VIEW 120\n#define MAX_ITERATIONS_SHADOW 40 // set this as small as you can with your lighting setting, even if shadow ray escape to sky quickly this results in big win\n#define TMAX_VIEW 80.0 // was 200 before\n#define TMAX_SHADOW 40.0 // reducing this doesn't help much\n#define TFRAC 0.8\n#define DBREAK 0.0025 // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\n\n\nTraceOutput traceScene( Ray ray, float shadow_sharpness, int trace_flags\n, int max_iterations, float tfrac\n, float tmaxmax, float dbreak, vec2 uv, vec2 fragCoord, int F, float aTime ){\n//...,iFraame,iTime\n\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfloat tmax = tmaxmax;{ // default to absolute max\n\t\t// clamp traced segment\n\t\tfloat hmax = MAX_TERRAIN_HEIGHT + TALLEST_OBJECT_HEIGHT; // there must be nothing above this height\n\t\tfloat thit = plane_trace_z( ray, hmax, 1e-4 );\n\t\tif ( thit > 0.0 )\t\t{\n\t\t\tif ( ray.o.z > hmax ) to.t = thit; // above hmax looking down\n\t\t\telse tmax = min( thit, tmaxmax ); // below hmax looking up, clamp at hmax\n\t\t}else if ( ray.o.z > hmax\n        ){\t\tto.t = tmaxmax * 1.1; // above hmax looking up, there is only sky\n//\t\t\treturn to; // don't branch here, that might be actually slower\n\t}}\n\n\tSceneIn scenein;\n\tSetSceneInDirection( scenein, ray.o, ray.d, trace_flags );\n\tscenein.t0 = to.t;\n    \n\t    //core raymarch loop:\n        //core raymarch loop:\n        //core raymarch loop:\n        //core raymarch loop:\n\tfor ( int i = 0 FORCE_LOOP; i < max_iterations; ++i \n    ){\tscenein.p = ray.o + to.t * ray.d;\n\t\tscenein.t = to.t;\n\t\tSceneOut eval = evalScene( scenein, F, aTime );\n\t\tfloat d = min( eval.object_di.d, eval.d_ghost );\n\t\t// note: ghost points might make us jump over solid tfrac points\n\t\tfloat is_ghost_step = ( d == eval.d_ghost ? 1.0 : 0.0 );\n\t\tto.dist = d;\n\t\t// important: do not move this block after the to.dist check!\n\t\tif ( IsShadowTrace( trace_flags )\n\t\t\t//&& ( is_ghost_step == 0.0 ) // creates ugly discontinuities\n\t\t\t)\n\t\t{\n\t\t\t// note: if eval.object_di.d < 0 we set shadow to 0 in effect\n\t\t\t// that catches the case where first point is inside an object (because shadow ray offset issues, ex: bush vs ground normal discontinuity)\n\t\t\t// for regular case if distance is neg it means we hit an object and so shadow = 0 too anyway\n\t\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\t\tto.shadow = min( to.shadow, shadow_sharpness * max( eval.object_di.d, 0.0 ) / ( to.t + 1e-4f ) );\n\t\t\t\n\t\t\tif ( to.shadow <= 0.01 ) break;\t\t}\n\n\t\t// warning: never stop on a ghost step!!\n\t\tif ( ( ( is_ghost_step == 0.0 ) && ( to.dist <= dbreak * to.t ) )\n\t\t\t || ( to.t > tmax ) ) break;\n\n\t\t// the amount by which we advance t: drop tfrac on ghost steps\n\t\tfloat dt = to.dist * mix( tfrac, 1.0, is_ghost_step );\n\n\t\tto.t += dt;\n\t}\n\n\tif ( to.t > tmax ) to.t = tmaxmax * 1.1;\n\n\treturn to;\n}\n\n#ifdef SHADERTOY_STANDALONE\n#define TIME_OF_DAY iSlider0\n#else\n#define TIME_OF_DAY 0.56\n#endif\n\nvec3 get_sun_direction(float aTime\n){\tfloat sun_elevation = radians( mix( -30.0, 90.0, TIME_OF_DAY ) ); // careful with z, long shadows make the tracing slower\n\treturn zup_spherical_coords_to_vector( unit_vector2( PI * 0.5 - sun_elevation )\n\t\t\t\t\t\t\t\t\t\t\t , _1 ? V45 : unit_vector2( 2.0 * PI * aTime / 3.0 ) );}\n\n#define cloud_re 3000.0\n#define cloud_r1 ((cloud_re)+8.0)\n#define cloud_r2 ((cloud_r1)+1.8)\n#define fake_earth_center vec3(0,0,-cloud_re)\n\nfloat cloudDensity( vec3 p \n){\tfloat sparsity = 0.07; // 0,1.x\n\tfloat freq = 0.2;\n\tfloat d = efbm4_13( p * freq, 1.0 + sparsity );\n\tfloat r = length( p - fake_earth_center );\n\tfloat r2 = length( p.xy );\n\tfloat c = smoothstep( 3., 5., r2 ); // cleanup singularity at north pole a little bit\n\td *= smoothstep( 0.4, 0.6, d * c ); // multiply d by c give best fade out\n\td = max( d, 0. );\n\td *= smoothstep( cloud_r1, cloud_r1 + 0.1, r )\n\t\t* ( 1.0 - smoothstep( cloud_r2 - 0.1, cloud_r2, r ) ); // altitude band\n\treturn d;}\n\n// make some ultra basic clouds out of thin air, we will bake them in a spheremap\nvec3 traceClouds( vec3 n, float aTime\n){\tvec3 sun_direction = get_sun_direction(aTime);\n\tRay ray = mkray( vec3( 0.0 ), n );\n\tvec2 vt1 = sphere_trace( ray, cloud_r1, fake_earth_center );\n\tvec2 vt2 = sphere_trace( ray, cloud_r2, fake_earth_center );\n\t//return vec4( vec3( 0.1*( t2.y - t1.y ) / ( r2 - r1 ) ), 0 );\n//\tfloat li = 1.0;\n\tfloat vlen = ( vt2.y - vt1.y );\n\tfloat vdt = vlen / 100.0;\n\tfloat vt = vt1.y;\n\tfloat vod = 0.0;\n\tfloat vod2 = 0.0;\n\tfloat c = 0.8;\n\t// view ray\n\tfor ( ; vt < vt2.y ; vt += vdt\n    ){\t\tvec3 p = ray.o + ray.d * vt;\n\t\tfloat pd = cloudDensity( p );\n\t\t{\n\t\t\t// sun ray\n\t\t\tRay lray = mkray( p, sun_direction );\n\t\t\tvec2 lt2 = sphere_trace( lray, cloud_r2, fake_earth_center );\n\t\t\tfloat llen = lt2.y;\n\t\t\tfloat ldt = llen / 5.0;\n\t\t\tfloat lt = ldt;\n\t\t\tfloat lod = 0.0;\n\t\t\tfor (; lt < llen; lt += ldt )\n\t\t\t{\n\t\t\t\tvec3 lp = lray.o + lray.d * lt;\n\t\t\t\tfloat lpd = cloudDensity( p );\n\t\t\t\tlod += vdt * lpd * c * 10.0;\n\t\t\t}\n\t\t\tvod2 += vdt * pd * exp( -lod -vod ); // inscatter\n\t\t}\n\t\tvod += vdt * pd * c; // absorption\n\t}\n\t// for compositing we do something like exp( -vod ) * distant_sky_color + vod2\n\treturn vec3( saturate(vod2), exp( -vod ), 0 );\n\t\n#define cloud_lowest_absorption_remap 0.6\n\t\n}\n\n// map theta to uv .5 r, we only keep the [0,PI/2] theta range\n#if 0\nfloat theta2r05( float theta ) { return theta *(1.0/PI) ; }\nfloat r052theta( float r ) { return r * PI; }\n#else\n// give more resolution to the horizon\nfloat theta2r05( float theta ) { return pow(saturate(theta*(1.0/(PI*0.5))),2.0) *0.5; }\nfloat r052theta( float r ) { return pow((r*2.0),0.5) *PI*0.5; }\n#endif\n\nvec3 get_cloud( vec3 v, sampler2D aChannel1, vec3 aResolution, float aTime\n){\tvec3 cloud = vec3(0.0);\n#if 0\n\tif ( CLOUD_MODE>0 ){\n\t\tvec2 sc = vector_to_zup_spherical_coords( v );\n\t\tif ( sc.x > PI * 0.5 ) return BLUE;\n\t\tvec2 uv = vec2( 0.5 ) + unit_vector2( sc.y ) * theta2r05( sc.x );\n\t\tuv.x *= aResolution.y / aResolution.x;\n\t\tcloud = CLOUD_MODE==1\n\t\t\t? traceClouds( v, aTime )\n\t\t\t: texture( aChannel1, uv ).xyz; // return the highres one here for debug, should match with sampled one\n\t}\n#endif\t\n\treturn cloud;} // debug\n\n\nfloat sFlarePeak( vec2 p, float da, float a, float a_offset\n){\ta += a_offset;\n\ta = floor( ( a / da ) + 0.5 ) * da;\n\tvec2 vv = unit_vector2( a - a_offset );\n\treturn abs( dot( p, perp( vv ) ) );}\n\nvec4 sunGlareCoords( mat4 cam, vec3 v, vec3 l\n){\tvec3 sy = normalize( cross( cam[0].xyz, l ) );\n\tvec3 sx = normalize( cross( l, sy ) );\n\treturn vec4( normalize( vec2( dot( v, sx ), dot( v, sy ) ) ), dot( v, l ), -cam[2].z );}\n\nvec3 sunGlare( vec4 ppd // xy: angle as unit vector z: dot(v,l)\n\t\t\t   , float solid_sun_disk_radius\n\t\t\t   , float ray_length // higher value = shorter length\n\t\t\t   , float ray_thickness\n\t\t\t   , float ray_thickness_disparity\n\t\t\t   , float n1 // can be arbitrarily large\n\t\t\t   , float n2 // there is a loop on n2 - the number of rays is n1*n2 so we have a trade off between the repeat in sFlarePeak (which can't do proper additive on rays) and the for loop (which can)\n\t\t\t   , float falloff_glare_attn\n\t\t\t   , float falloff_glare_p1\n\t\t\t   , float falloff_glare_p2\n\t\t\t   , bool falloff_glare_multiplicative\n){\tvec2 anglev = ppd.xy; // angle as unit vector\n\tfloat v_dot_l = ppd.z;\n\tfloat r = safe_acos( v_dot_l ) / PI; // could do without acos but it is a lot more easier to work with regular spacing\n\tvec2 p = anglev * r;\n\tfloat a = calc_angle( anglev );\n//\treturn vec3( stripes(r,0.02,0.001,0.001/2.0), stripes(degrees(a),10.,0.1,0.1/2.0),0.); // visualize polarcoords\n\tfloat v = 0.0;\n\tfloat d2 = max( r - solid_sun_disk_radius, 0. ); // falloff glare\n\tfloat da = 2.0 * PI / n1;\n\tfloat da2 = 2.0 * PI / ( n1 + n2 );\n\tfor ( float i = 0.; i < n2; ++i\n    ){  vec3 rr = hash31( i + 1. );\n\t\tfloat rda = rr.x * da2 * 0.1;\n\t\tfloat d1 = sFlarePeak( p, da, a, -i * da / n2 + rda );\n\t\tif ( r < solid_sun_disk_radius ) d1 = 0.;\n\t\tv += exp2( -d1 * d1 * ray_thickness * mix( 1.0-ray_thickness_disparity, 1.+ray_thickness_disparity, rr.y )\n\t\t\t\t   -d2 * ray_length * mix( 0.5, 1.5, rr.z ) );\t}\n\tfloat falloff_glare = falloff_glare_attn * ( 1.0 - powerful_scurve( d2, falloff_glare_p1, falloff_glare_p2 ) );\n\tv = falloff_glare_multiplicative ? v * falloff_glare : v + falloff_glare;\n\tv = min( v, 1. );\n\treturn vec3( v );}\n\n#define FOG_GROUND _1\n\n // set render to false for getting a value for lighting calculation as opposed to display\nvec3 get_top_sky_color( bool render ) {  return AZURE * ( render ? 0.6 : 1.0 ); }\nvec3 get_sky_horizon_color() { return mix( WHITE, AZURE, 0.4 ); }\nvec3 get_fog_color() { return mix( AZURE, WHITE, 0.15 ); }\n\n// return a v.z normalized so that horizon view direction is remapped to 0 and zenith is still 1\nfloat get_hacked_vz( vec3 v, float ez ){\n\tfloat zmin = -max(ez,0.)/(TMAX_VIEW*1.1); // z/f=zmin/1. where f=TMAX_VIEW*1.1\n\treturn max(0.,(v.z-zmin)/(1.-zmin));}\n\nvec3 get_sky( vec3 v, vec3 l, float ez, bool render ){\t\n\tfloat hz = get_hacked_vz( v, ez );\n\treturn mix( get_sky_horizon_color(), get_top_sky_color(render), pow( hz, 0.2 ));}\n\nvec3 get_sky_plus_clouds( vec3 v, vec3 l, float ez, sampler2D aChannel1, vec3 aResolution, float aTime\n){\tvec3 col = get_sky( v, l, ez, true );\n\tvec3 cloud = get_cloud( v, aChannel1, aResolution, aTime  );\n\tvec3 sky_with_clouds =  col * mix( cloud_lowest_absorption_remap, 1., cloud.y ) + vec3( cloud.x ); // composite clouds, col * absorption + scattering\n\treturn mix( col, sky_with_clouds, smoothstep( 0., 0.025, v.z ) );} // fade to sky on thin horizon band\n\n\n// e = eye pos, v = view vector, p = lit point, n = normal, l = sun direction\nvec3 shadeSample(in vec3 e\n, in vec3 v\n, mat4 cam\n, in vec3 p\n, in vec3 n //surface normal (for reflection)\n, vec3 l\n, float shadow\n, TraceOutput to\n, float ao\n, vec2 uv\n, SceneOut eval\n, bool sky\n, sampler2D aChannel1\n, vec3 aResolution\n, float aTime\n){vec3 col=vec3(0)\n ;vec3 sunI=vec3(2)\n ;vec3 top_sky_color = get_sky(vec3(0,0,1),l,e.z,false)\n ;SG sun_lobe=CosineLobeSG(l)\n ;sun_lobe.Amplitude*=sunI\n ;SG sky_lobe=CosineLobeSG(vec3(0,0,1))\n ;sky_lobe.Amplitude*=top_sky_color\n ;if(!sky\n ){vec3 scene_color=vec3(0)\n  ;float bush_factor=0.\n  ;float tree_factor=0.\n  ;float pine_factor=0.\n  ;vec3 sky_reflection=vec3(0)\n  ;vec2 mm=DecodeId_16(eval.object_di)\n  ;float matid=mm.x\n  ;float matid_f=mm.y // we can have color variations within an id\n  ;bush_factor=smoothbump(MATID_BUSH,.5,matid)\n  ;tree_factor=smoothbump(MATID_TREE,.5,matid)\n  ;pine_factor=smoothbump(MATID_PINE,.5,matid)\n  ;vec4 mm4=DecodeId_5_5_5(eval.object_di) // yzw = depth uheight color_rnd\n  ;float tree_ao=mix(.6,1.,smoothstep(0.,.5,mm4.z)) // make it very faint, doesn't fit the style\n  ;scene_color=vec3(0)\n  +bush_factor*eval.color\n  +tree_factor*mix(mix(COLOR_TREE1,COLOR_TREE2,mm4.w ),COLOR_TREE_SURF,0.*mm4.y*mm4.y*mm4.y)*tree_ao\n  +pine_factor*mix(COLOR_PINE,COLOR_PINE2,mm4.w)* tree_ao\n  +smoothbump(MATID_NONE     ,.5,matid)*MAGENTA\n  +smoothbump(MATID_TRUNK    ,.5,matid)*COLOR_TRUNK\n  +smoothbump(MATID_HOUSE_TOP,.5,matid)*COLOR_HOUSE\n  +smoothbump(MATID_HOUSE_BOT,.5,matid)*COLOR_HOUSE_BOTTOM\n  +smoothbump(MATID_BRICKWALL,.5,matid)*COLOR_BRICKWALL\n  +smoothbump(MATID_ROOF     ,.5,matid)*mix(COLOR_ROOF1,COLOR_ROOF2 ,matid_f)\n  +smoothbump(MATID_GRASS    ,.5,matid)*mix(COLOR_GRASS,COLOR_GRASS2,matid_f)\n  +smoothbump(MATID_GROUND   ,.5,matid)*mix(COLOR_PATH1,COLOR_PATH2 ,matid_f)\n  ;if(MATID_WINDOW == matid\n  ){scene_color=BLACK\n   ;vec3 vr=reflect(v,n)\n   ;vec3 refl_color=get_sky_plus_clouds(vr,l,p.z,aChannel1,aResolution,aTime)\n   ;refl_color=mix(COLOR_GRASS*mix(.2,1.,shadow),refl_color,smoothstep(-.03,0.,vr.z))\n   ;sky_reflection=refl_color*mix( .2,1.,pow(1.-saturate(dot(-v,n)),2.))\n  ;}\n  ;if(MATID_GRASS == matid\n        ){\tvec3 lf = sfbm4_33( p * 40.0 );\n\t\t\tfloat hf = sfbm1_12( p.xy * 2800.0 );\n\t\t\tif ( matid_f > ( 1. - 0.04 )  // mowed lawn, should be rare\n\t\t\t){\tfloat period = 0.07;\n\t\t\t\tfloat s = stripes( rotate_with_angle( p.xy, matid_f * 1000.0 ).x, period, period * 0.25, 0.004 );\n\t\t\t\tscene_color = mix( COLOR_MOWED_GRASS, COLOR_MOWED_GRASS2, saturate( s + ( lf.x - 0.38 ) * 1.5 ) );}\n\t\t\t// just apply some noise\n\t\t\tscene_color *= 1.0 - 0.2 * ( saturate( 1.0 - lf.y ) );\n\t\t\tscene_color *= saturate( 1.0 - 0.4 * hf * saturate( 1.0 - lf.y ) );\t\t}\n\t\tvec3 albedo = scene_color; // return albedo;\n\t\tcol += shadow * SGDiffuseFitted( sun_lobe, n, albedo );\n\t\t// this way of doing diffuse makes shadow color be different on ground than back of object resting on it which sucks\n\t\tif ( _1 ) col += mix( SGDiffuseFitted( sky_lobe, n, albedo ), top_sky_color, SHADOW_TINT_SATURATION )\n\t\t\t\t// add more sky ambient to tint shadow in blue? in a way that is not too hacky?\n\t\t\t\t* mix( 0.15, 0.02, shadow )\n\t\t\t\t* ao;\n\t\tcol += sky_reflection;\n\t\tfloat d = length( p - e );\n\t\tif ( FOG_GROUND ) col = mix( col, get_fog_color() * 0.8, ( 1. - exp( -0.1 * max( d - 6.1, 0. ) ) ) * 0.378 ); // fog\n\t}else{\n\t\tcol = get_sky_plus_clouds( v, l, e.z, aChannel1, aResolution, aTime );\n\t\tif ( SUN ){ // this sun is the one in the sky\n\t\t\tvec4 ppd = sunGlareCoords( cam, v, l );\n\t\t\tcol += sunGlare( ppd, 0.007, 280., 100000.0, 0.2, 20.0, 4.0, 0.3, 0.4, 8., false )\n\t\t\t\t* vec3( 0.8, 0.8, 0.5 ) * sunI;}}\n\t// note: we would like to do SUN_GLARE here, but reprojection only works on solid world pos or distance sky\n\treturn col;}\n\nvec3 postProcess( vec3 col, vec2 uv, vec4 ppd\n){if ( SUN_GLARE\n  ){col.xyz += 0.116 * sunGlare( ppd, 0., 7., 8000.0, 0.2, 8.0, 8.0, 0.3, 2., 2., true )\n\t\t\t* vec3( 1., 0.7, 0.2 ) * 2. // use warmer color for this glare\n\t\t\t* smoothstep( -0.15, 0.3, ppd.w )\n\t\t\t* (1.0-smoothstep( 0.78, 0.9, ppd.z ));}\n\tfloat exposure = 3.0; \n\t// maybe auto expose when staring straight at the sun? the sun is a bit saturated on the clouds\n\t//exposure = mix(exposure,1.,smoothstep(0.985,1.0,1.-ppd.z));\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.02 ) ) );\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.15 );\n\tcol *= vignette;\n\tcol = contrast( col, vec3( 1.06 ) );\n\tcol = gamma_correction_itu( col );\n\treturn col;}\n\nstruct CameraRet {vec3 eye; vec3 target; float roll; float pitch;};\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\n// a cubicstep function that takes 2 arbitrary end points and 2 (begin end) slopes\nfloat cubicstep2(float x, vec2 p0, vec2 p1, float s0, float s1\n){x -= p0.x\n ;p1 -= p0\n ;x = clamp( x, 0., p1.x )\n ;float x1_sqr = p1.x * p1.x\n ;vec3 eq1 = vec3( 3.0 * x1_sqr, 2.0 * p1.x, s1 - s0 )\n ;vec3 eq2 = vec3( x1_sqr * p1.x, x1_sqr, p1.y - s0 * p1.x )\n ;float a = ( eq1.y * eq2.z - eq1.z * eq2.y ) / ( eq1.y * eq2.x - eq1.x * eq2.y )\n ;float b = ( eq1.z - eq1.x * a ) / eq1.y\n ;return p0.y+((a*x+b)*x+s0)*x;}\n\n//read by GetCameraTransform by mainScene is read by buffA and mainImage\nmat4 getCam(vec4 camRotQ,vec3 ro\n){mat3 camRotM=q2m(camRotQ);//camera rotation mat3 from quaternion\n ;mat4 ccc=mat4(vec4(camRotM[0],0)\n               ,vec4(camRotM[1],0)\n               ,vec4(camRotM[2],0)\n               ,vec4(ro,1));  //this MAY result in fisheye, not sure\n               //note, that FoV for rayDirection is done later.\n ;mat4 look=lookat(vec3(0,0,1),vec3(1,0,1),vec3(0,0,1))//user friendly init for a mult\n ;return look*ccc;}\n\nstruct CameraData{mat4 camera;float fovy;}; // what we need to write for the reprojection\n\n//return normal (and materialID?) (and distanceFog data?)\nvec3 normal(SceneIn scenein,float e,int F,float T,inout SceneOut eval_for_shade){\n   #if 0\n   ;SceneIn scenein2 = scenein\n   ;scenein2.p = scenein.p+vec3(e,0,0);v.x=evalScene(scenein2,F,T).object_di.d\n   ;scenein2.p = scenein.p+vec3(0,e,0);v.y=evalScene(scenein2,F,T).object_di.d\n   ;scenein2.p = scenein.p+vec3(0,0,e);v.z=evalScene(scenein2,F,T).object_di.d\n   ;eval_for_shade=evalScene(scenein,F,T)\n   ;v.w eval_for_shade.object_di.d\n   #else\n   ;vec4 v; // center in .w, deltas in .xyz\n   ;for ( int i = 0 FORCE_LOOP; i < 4; ++i //apparently identical forced-loop of above\n   ){SceneIn scenein2 = scenein\n    ;if ( i != 3 ) scenein2.p[i] += e        // let's live dangerously and use vector component random access\n\t;eval_for_shade = evalScene( scenein2, F, T )// eval_for_shade contains material data at center, at the end of the loop\n\t;v[i] = eval_for_shade.object_di.d;}\n   #endif\n   ;return normalize(v.xyz-vec3(v.w))\n ;}\n\n//mainScene is read by buffA and mainImage\nvec4 mainScene(vec2 U,float T,vec3 R,int F,vec4 M,sampler2D aChannel1,out vec4 O\n//uv,iTime,iResolutionframe,imouse\n,vec4 camRotQ,vec3 ro//camRot,camPos\n){vec2 u=U.xy/R.xy\n ;vec4 fragColor=vec4(0)\n ;CameraData cam\n ;cam.fovy=.6\n ;cam.camera=getCam(camRotQ,ro);\n ;Ray view_ray=get_view_ray2((u-vec2(.5))*2.,R.x/R.y,1./cam.fovy,cam.camera)\n ;float ao = 1.0\n ;vec3 sun_direction = get_sun_direction( T )\n ;bool sky = false\n ;float shadow = 1.0\n ;TraceOutput to\n ;vec3 p2\n ;vec3 norm //surface normal\n ;SceneOut eval_for_shade\n ;SceneOutInit(eval_for_shade)\n ;Ray trace_ray=view_ray\n ;int trace_flags=TRACE_VIEW\n ;int max_iterations=MAX_ITERATIONS_VIEW\n ;float tmaxmax=TMAX_VIEW\n ;// force a loop on view ray, shadow ray to prevent shadertoy compilation abject unrolling horror\n ;for (int pass = 0 FORCE_LOOP;pass<(SHADOWS?2:1);++pass\n ){TraceOutput tmp_to = traceScene( trace_ray,5., trace_flags\n  ,max_iterations,TFRAC,tmaxmax,DBREAK,u, U, F, T )\n  ;if ( pass == 1\n  ){//shadow = ( tmp_to.t > TMAX_SHADOW ? 1 : 0 ); // check hard shadows\n   ;//shadow = tmp_to.shadow; // default soft shadows, don't work well with this scene\n   ;shadow = mix( 0.05, 1.0, smoothstep( 0.4, 0.6, tmp_to.shadow ) ) // take a threshold on default soft shadows, good for sunny setting\n   ;break;}\n  ;// only view rays make it here... \n  ;to = tmp_to\n  ;p2 = view_ray.o + to.t * view_ray.d\n  ;sky = to.t > TMAX_VIEW\n  ;if ( sky ) break\n  ;// only view rays that hit solid surfaces make it here...\n  ;// evaluate normal vector at hit point, we will also retrieve extra material calculations\n  ;SceneIn scenein\n  ;scenein.p = p2\n  ;SetSceneInDirectionless( scenein, TRACE_SHADE )\n  ;scenein.t = 0.0\n  ;{// to set this epsilon, set the camera at 1000 and check fence and terrain normal...\n   ;// it should look the same as 0,0,0...\n   ;float e = 1e-3 * 2.\n   \n   //surface normal calculation:\n   ;norm = normal( scenein, e,F, T,  eval_for_shade)    \n  ;}  \n  ;if ( AO\n  ){SceneIn scenein2 = scenein\n   ;SetSceneInDirection( scenein2, p2, norm, TRACE_AO )  // shouldn't change anything\n   ;// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n   ;float delta = 0.1\n   ;float a = 0.0\n   ;float b = 1.0\n   ;for ( int i = 0 FORCE_LOOP; i < 4; i++\n   ){float fi = float( i )\n    ;scenein2.p = p2 + norm * delta * fi\n    ;float d = evalScene(scenein2,F,T).object_di.d\n    ;a += ( delta * fi - d ) * b\n    ;b *=.5;}\n   ;ao = max( 1.0 - 1.8 * a, 0.0 );}\n  ;if(SHADOWS\n  ){// hack: use a different normal offset for trees as noise shadows are very sensitive to that\n   ;vec4 mm4 = DecodeId_5_5_5( eval_for_shade.object_di )\n   ;float tree_ao = 1.0\n   ;if ( (mm4.x == MATID_TREE) || (mm4.x == MATID_PINE)\n   ){tree_ao += 1.0 - smoothstep( 0.2, 0.5, mm4.z )\n    ;tree_ao -= smoothstep( -0.2, 0.0, dot( sun_direction, norm ) )\n    ;tree_ao = saturate( tree_ao );}\n   ;// note: because of surface noise, tweaking the shadow ray normal bias has a lot of impact on vegetation\n   ;// might want to tweak it per surface too\n   ;trace_ray = mkray( p2 + norm * mix( 0.004, 0.0005, tree_ao ), sun_direction ) // if bias is too small here tree shadows become shitty\n   ;trace_flags = TRACE_SHADOW\n   ;max_iterations = MAX_ITERATIONS_SHADOW\n   ;tmaxmax = TMAX_SHADOW\n ;}}\n //surface normal [norm] is known by now\n ;fragColor.rgb=shadeSample(view_ray.o,view_ray.d,cam.camera,p2,norm\n ,sun_direction,shadow,to,ao,u,eval_for_shade,sky,aChannel1,R,T)\n ;O=sunGlareCoords(cam.camera,view_ray.d,sun_direction)\n ;fragColor.a = to.t// write depth in .w to recover the world position in reprojection\n ;return fragColor;}\n\n\n//vec2 NumSubpixels( vec3 aResolution){return aResolution.xy / 2.0; }", "buffer_b_code": "//Camera Controller (quaternion 2022-02)\n//also contains the non-quaternion camera controller (toggle is [camType] in commontab):\n\n//lots of paramerets for this exist in the commontab\n\n/*\nto enable camera-to-object collisions\n, the normals() and setting() distance field (and all its subroutines)\nneed to either be duplicated into the camera-movement buffer\n, OR moved into the common-tab\nThis may be too excessive and it tends to cause WAY too many namespace conflicts to be worth it.\n\nthis is its own fragment-buffer-tab  \njust for convenience + simplicity + compatibility (quick copying of whole buffers)\n\ninstead, it could just overlay its 4 bottom left pixel\nof in the actual image of another buffer (ccopying from another image-tab)\nwhich sure makes enabling-of-collisions much simpler (no duped code needed in that case)\n*/\n\n// // simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n// // #define noRollCam     0\n// // quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n// // #define quaternionCam 1\n// // \n// // #define camType quaternionCam\n\n//note. for cvollision to work, this function needs df() and normal() functions\n//added to collide with a distanceField bacl along a surface normal\n//they are commented out in THIS shader\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n\n/*\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//esdf is mor comparible than wasd (especially with french layout)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n/**/\n//some shaders have ditfferent pyr or camera matrix setups (handedness, negative view directions...)\n//you first fis the mouse quaternion cam (.swively.xyz for the PYR function, and THEN you rebind the keys here...\n//because straving comes AFTER rotation (quaternion modifies  strave directions)\n\nconst ivec3 klp=ivec3(keyT ,keyD ,keyF).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyG ,keyE ,keyS).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyW) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyR);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n/**/\n\n\n//above is from quat source, BUT \"English lane\" camera is messy, so i rather rebing and reorder pyr.\n\n\n//constant code:\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n\n//convoluted structs wont EASILY give me what I need for colisions\n//and evalScene() is quite the big function\n//\n//SHOULD return distanceToSurface of point [u] to scene\n//BUT this bridge function fails to translate between structs, apparently.\n//it continuously collides\n//, likely because it constnatly returns too large values?\nfloat df(vec3 u){\n ;SceneIn scenein2\n ;int   F=iFrame\n ;float T=iTime\n ;return evalScene(scenein2,F,T).object_di.d;}\n\n//this still does not return a normal-useful for colisions...\n//return surface notmal of point [u] at scene\nvec3 normal(vec3 u\n){SceneIn scenein\n ;scenein.p = u\n ;float e=0.0001 //epsilon?\n ;int   F=iFrame\n ;float T=iTime\n ;SceneOut eval_for_shade;\n ;vec4 v=vec4(0)\n ;SceneIn scenein2 = scenein\n ;scenein2.p = scenein.p+vec3(e,0,0);v.x=evalScene(scenein2,F,T).object_di.d\n ;scenein2.p = scenein.p+vec3(0,e,0);v.y=evalScene(scenein2,F,T).object_di.d\n ;scenein2.p = scenein.p+vec3(0,0,e);v.z=evalScene(scenein2,F,T).object_di.d\n ;scenein2.p = scenein.p+vec3(0,0,0);v.w=evalScene(scenein2,F,T).object_di.d\n ;return normalize(v.xyz-vec3(v.w))\n// ;                                   v.w=eval_for_shade.object_di.d\n ;return normal(scenein,e,F,T, eval_for_shade);}\n\n#if (camType==0) \nvec4 cp0( //non quaternion camera\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0( //quaternion camers\n//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz//camPos\n;if(PHYSICS_RADIUS>-99.){// gating to skip the colision calculation that is likely disabled anyways.\n  //include the function that estimates the surface normal of the df() function above this \n  //to push the camera away, alogn the surfaceNormal to avoid collisions\n  //then remove the commentingPut line / * below and you have some physics\n  //, use constants to set scaling.\n \n /*  //collissions overridden cause its bugged\n \n  ;float d=.1//PHYSICS_RADIUS\n  //;d=length(df(r)) //include df() as distance field function here to collide the dcamera\n  //;if (d>0.)r.xyz+=vec3(0.,0,PHYSICS_REPEL)//push up workaround that works without normal()\n  ;if (df(r)<d)r+=vec3(.1)//to debug only the df() returned value\n  //;if (df(r)<d)r-=vec3(1)// normalize(normal(r))*d //push camera away, alons surface normal.\n  //optional collision , needs normal() of the df()\n\n  /**/ \n  //collisions need the df() and its normal() function to be also here, or shared in commontab.\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(  //non quaternion camera\n//return camera linear velocity.xyz a vec3 with speed.w as scalart, unaffected by change-of-direction\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else   \n  //quaternion camera\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //non quaternion camera\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else \n//quaternion camera\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n //;return normalize(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n ;return normalize(qq2q(eYPR2q(-iTimeDelta*get(camA1).yzx),get(camA0)));}\n#endif\n\n#if (camType==0) \n //non quaternion camera\nvec4 ca1(//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\n  //quaternion camera\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//keyL and keyP may be used to position 2 seperate light sources \n//at the current camera position, when the key L/P is pressed\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\n//2 buffers for 2 movable light sources\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous pos\n ;if(u==camA0p)return get(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//buffC.start\n//ichannel0=self\n//ichannel1=keyIn\n\n//this buffer has its own shitty cameraControls\n//, to be replaced by the camera control of BuffB\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\n//v3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\n//v3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\n//v3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\n//v3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\n//v2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\n\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//c1,c0 6 CW heights (orthogonal to triangle plane)\n//p1,p2,p3 corners of base triangle\n//res=resolution.x (screen width in oixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=v2(0,.3,.3);return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n  ;}};return v3(0,0,0,2);}//no intersection\n\n\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n \n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.\n\n\n//--- all above code used to be in a commontab\n\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;//v4iSect form may be return v3(S+a.y*E,a.y)\n //where S and E are baricentric.xyz and a.x (or a.y) are the closest root.\n ;//we basically only care for the .w parameter\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.x,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.z,.2));}//paint 6 CVs\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\nv2 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3){//position,direction, trianglecorners \n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0]),b=cos(pq[2])\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.\n ){\n  ;return v2(.5)//if(ray misses AABV)return grey!\n ;}\n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5))c.xyz=mix(c.xyz,cd,.2)//debug color output\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;return o.xyz;\n;}\n \nv2 scene(v2 o,v2 d\n){v2 //3 corners.xyx of a triangle\n//, that the bezier patch is pklaced above and below of\n//all ControllVectors only move in the .z direction.\n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);//.z==0. for simplicity/debugging\n ;return bezierPatch(o,d,p1,p2,p3)\n ;}//origin,direction\n\n\n//below code copied from https://www.shadertoy.com/view/DsKBDw\n//and then slowly modified to replace the camera, and to understand it more (compacting/aliasing...)\n \n// https://www.shadertoy.com/view/DsKBDw asymmetric blocks with portals reflections, 2023 by jt\n// based on https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d\n// Added reflections and stairs to https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d.\n// Thanks to Shane for suggesting the DDA-plugin / snap-to-voxel method & for the asymmetric blocks idea!\n\n// tags: 3d, random, reflections, t, blocks, portal, double, door, passage, connection, alternating, irregular, asymmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For correct ambient occlusion sample 2x2x2 voxels (slow!)\n//#define HIGH_QUALITY XXX CURRENTLY BROKEN DUE TO APPROXIMATE SDF AT PORTALS XXX\n\n/*\nfloat hash12(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);}\n\nvec2 hash22(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);}\n\nvec3 hash32(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);}\n\nvec3 hash33(vec3 p3){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);}\n*/\n\nstruct block{\n    vec4 center;\n    vec4 extent;\n    ivec2 id;\n    ivec2 id0;\n    ivec2 id1;\n    bool flag;};\n\nblock empty_block(){return block(vec4(0), vec4(0), ivec2(0), ivec2(0), ivec2(0), false);}\n\n#define block_offset 0.2\n#define wall_size 0.02\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror){\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // [0,1]\n    vec2 r = mix(vec2(block_offset), vec2(1.0 - block_offset), fract(hash22(vec2(t+d))))+vec2(d); // [constrained]\n    return choose?r.y:r.x;}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(ivec2 tile, vec2 local){ // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n\n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    if(flip){ // horizontal line goes through: swap vertical with horizontal\n        // swap components\n        local = local.yx;}\n    // vertical line goes through (on flip transpose for horizontal line)\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    float e = block_hash(tile,-X, 0,!flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n    vec4 vv0 =\n        vec4 (\n            // primary corner in (0,0) tile\n            c,d,\n            // secondary corner in (0,0) tile\n            c,e);\n    vec4 vv1 = vec4(\n            // primary corner in (X,Y) tile\n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip),\n            // secondary corner in (X,Y) tile\n            block_hash(tile,2*X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip) );\n\n    if(flip) tile = tile.yx;\n    vv0 += vec2(tile).xyxy;\n    vv1 += vec2(tile).xyxy;\n    ivec2 id = tile + ivec2(x,y);\n    ivec2 id0 = tile + ivec2(1-x,1-int(local.y < e));\n    ivec2 id1 = tile + ivec2(1-x,1-int(local.y < e));\n\n    if(flip)    { // horizontal line goes through: unswap vertical with horizontal\n        vv0 = vv0.yxwz;\n        vv1 = vv1.yxwz;\n        id = id.yx;\n        id0 = id0.yx;\n        id1 = id1.yx;}\n\n    bool flag = vv0.y > vv1.y;\n    // using abs in conversion to center-extend fixes order of min/max corners\n    return block((vv0+vv1)/2.0, abs(vv0-vv1)/2.0, id, id0, id1, flag);}\n\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll){\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n    return R * S * T;}\n\nfloat halfspace(vec3 p){return p.z + 1.0;}\n\nfloat sphere(vec3 p, float r){    return length(p) - r;}\n\nfloat approx_crossing(vec3 p, float r)\n{//return sphere(p, r);\n    return max(length(p.xz)-r, length(p.yz)-r);\n}\n\nfloat box(vec2 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 p0, vec3 p1){\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0);}\n\nfloat box(vec2 p, vec2 p0, vec2 p1, float r){ // min-max box with rounded corner\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0-r)-r;}\n\nfloat box(vec3 p, vec3 p0, vec3 p1, float r){ // min-max box with rounded corner\n    float d = box(p.xy, p0.xy, p1.xy, r);\n    vec2 w = vec2(d, abs(p.z-(p1.z+p0.z)/2.0) - (p1.z-p0.z)/2.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat dot2( in vec2 v ){return dot(v,v);}\n\nfloat cone(vec3 p, float h, float r1, float r2){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 q = vec2(length(p.xy), p.z);\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );}\n\n/*\nfloat cylinder(vec3 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n*/\nfloat cylinder(vec3 p, float r, float h){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat frame(vec2 p, vec2 s, float t){\n    return max(box(p, s),-box(p, s-t));}\n\nfloat frame(vec3 p, vec3 s, float t){\n    float d = frame(p.xy, s.xy, t);\n    // extrude https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p.z) - s.z);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat vmax(vec2 v){return max(v.x, v.y);}\n\nvoid pR45(inout vec2 p){p = (p + vec2(p.y, -p.x))*sqrt(0.5);}\n\nfloat pMod1(inout float p, float size){\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;}\n\n// https://www.shadertoy.com/view/Xs3GRB HG SDF in WebGL by tomkh,\n// implementation of http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n){\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));}\n\n#define dd(a) dot(a,a)\n/*\nfloat make_cylinder_grid(vec3 l, float r){\n  return sqrt(min(\n            min(dd(l.xz-vec2(1.0,0))-r,dd(l.xz-vec2(0.0,0))-r),\n            min(dd(l.yz-vec2(1.0,0))-r,dd(l.yz-vec2(0.0,0))-r)));}\n    \n/*\n    float d =min(\n            min(length(l.xz-vec2(1.0,0))-r,length(l.xz-vec2(0.0,0))-r),\n            min(length(l.yz-vec2(1.0,0))-r,length(l.yz-vec2(0.0,0))-r)        );\n    return d;}\n /**/\n\n/*\nfloat make_cuboid_grid(vec3 l, float r, float s){\n    float d =min(\n            min(box(l.xz-vec2(1.0,0),vec2(r,s)), box(l.xz-vec2(0.0,0),vec2(r,s))),\n            min(box(l.yz-vec2(1.0,0),vec2(r,s)), box(l.yz-vec2(0.0,0),vec2(r,s)))        );\n    return d;} /**/\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\nstruct result{\n    float dist;\n    vec4 color_specular;\n    bool flag;};\n\nresult combine(result a, result b){\n    if(a.dist < b.dist) return a;\n    return b;}\nresult remove(result a, result b){\n    if(a.dist > -b.dist) return a;\n    return result(-b.dist, b.color_specular, b.flag);}\n\nvec3 colorize(ivec2 id){\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    vec3 n = vec3(1,1,1);\n    color -= 0.5*dot(color,n)*n/dot(n,n); // remove part of component along diagonal\n    return color;}\n\nresult map(ivec2 v, vec3 l){ // unit grid: voxel = float(position), local = fract(position)\n    result res = result(DIST_MAX, vec4(vec3(1), 0), false);\n    block b = blocks_layout(v.xy, l.xy);\n    float h = 0.2;\n    //float h = 0.2+0.1 * hash12(vec2(b.id));\n    //float h0 = 0.1 * hash12(vec2(b.id0));\n    //float h1 = 0.1 * hash12(vec2(b.id1));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy-wall_size,h), wall_size), vec4(colorize(b.id), 0), false));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy,h/* *0.9*/), wall_size), vec4(vec3(1), 0), false));\n    vec2 vv0 = b.center.xy - b.extent.xy - vec2(v);\n    vec2 vv1 = b.center.xy + b.extent.xy - vec2(v);\n    vec2 w0 = b.center.zw - b.extent.zw - vec2(v);\n    vec2 w1 = b.center.zw + b.extent.zw - vec2(v);\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y), h), vec4(vec3(1),0), false));\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y)+0.05, 0.01), vec4(vec3(0.25),0), false));\n    \n/*\n    float cyl =\n        min\n        (\n            min\n            (\n                cylinder(l-vec3(v0.xy,0), h, 0.1),\n                cylinder(l-vec3(v1.xy,0), h, 0.1)\n            ),\n            min\n            (\n                cylinder(l-vec3(v0.x, v1.y,0), h, 0.1),\n                cylinder(l-vec3(v1.x, v0.y,0), h, 0.1)\n            )\n        );\n    res.dist = min(res.dist, cyl);\n*/\n    //if(true){{\n    if(!b.flag){{\n            vec3 c = vec3(vv1.x+w1.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv0.x+w0.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}else{{\n            vec3 c = vec3(vv0.x+w0.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv1.x+w1.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = combine(res, result(make_cuboid_grid(l-vec3(0,0,h*0.6), 0.05, 0.005), vec4(vec3(0.25),0), false));\n    //res = combine(res, result(l.z, vec3(1))); // floor\n    float f = l.z; // floor\n    float cone_south = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y-b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_north = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y+b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_west = cone(vec3(v,0)+l-vec3(b.center.x-b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_east = cone(vec3(v,0)+l-vec3(b.center.x+b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    //res.dist = min(res.dist, cone0);\n    f = fOpUnionStairs(f, min(min(cone_south, cone_east), min(cone_north, cone_west)), h, 10.0);\n    res = combine(res, result(f, vec4(1.-colorize(b.id), 1), true)); // floor\n    return res;}\n    \n#ifdef HIGH_QUALITY\n//for correct AO, we must sample 2x2x2 voxels, much slower\nresult map(vec3 p){\n    // I think kastorp originally suggested to sample only 2x2x2 instead of 3x3x3, thanks!\n    result d = result(DIST_MAX, vec4(vec3(0),0), false);\n    ivec2 s = ivec2(step(0.5, fract(p.xy)));\n    ivec2 o;\n    for(o.y = s.y-1; o.y < s.y+1; o.y++)\n        for(o.x = s.x-1; o.x < s.x+1; o.x++){\n            result r = map(ivec2(floor(p.xy))+o, vec3(fract(p.xy), p.z)-vec3(o,0));\n            if(r.dist < d.dist)\n                d = r;\n    }return d;}\n#else\n//much less taps \nresult map(vec3 p){return map(ivec2(floor(p.xy)), vec3(fract(p.xy), p.z));}\n#endif\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p){\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy*map(p + k.xyy*h).dist +\n                     k.yyx*map(p + k.yyx*h).dist +\n                     k.yxy*map(p + k.yxy*h).dist +\n                     k.xxx*map(p + k.xxx*h).dist);}\n\n// NOTE: Apparently sign fails on some systems! Thanks to spalmer for debugging this!\n// WORKAROUND FOR COMPILER ERROR on some systems\nvec2 sgn(vec2 v){return step(vec2(0), v) * 2.0 - 1.0;}\n\nresult trace(vec3 ro, vec3 rd, float t0, float t1){ // ray-march sdf handling discontinuities between voxels  (jt)\n    result h;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++) { // finite loop originally suggested by pyBlob to avoid stalling if ray parallel to surface just above EPSILON\n        vec3 p = ro + rd * t;\n        h = map(p);\n        if(h.dist < EPSILON)return result(t, h.color_specular, h.flag);\n\n        // NOTE: An extra step per block, use if sdf discontinuous between blocks\n        //       Could make this conditional by prefixing sth. like if(block_changed) // suggested by spalmer\n        // constrain step to blocks (voxel-snap ray-march plugin by jt, thanks to Shane for the idea!)\n        {\n            block b = blocks_layout(ivec2(floor(p.xy)), fract(p.xy));\n            // NOTE: assuming unit grid\n            // sgn(rd)*extent are the block walls in ray direction, fract(p) - center is position relative to center of block\n            //vec2 sd = (sgn(rd.xy)*b.extent.xy - (fract(p.xy) - (b.center.xy-floor(p.xy))))/rd.xy; // distances to block sides / walls\n            vec2 sd = (sgn(rd.xy)*b.extent.xy - p.xy + b.center.xy)/rd.xy; // distances to block sides / walls\n            vec2 n = step(sd.xy, sd.yx); // component true if corresponding wall is nearest (at most one component true) NOTE: originally I used lessThanEqual, min from fb39ca4/kzy then switched to step, min by iq\n            float skip = dot(sd, n) + EPSILON; // distance to next block: sum up all components, weighted by the nearest flag (assuming only one component is true this selects the nearest component)\n            h.dist = min(h.dist, skip); // constrain step to at most next block to handle sdf discontinuities between voxels\n        }t += h.dist;}\n    return result(t, h.color_specular, h.flag);} \n    // stop on running out of iterations\n    //return result(t1, vec4(0), false); // pass on running out of iterations\n\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\n//       Thanks to spalmer for pointing that out.\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1){\n    return trace(ro, rd, t0, t1).dist < t1 ? 0.0 : 1.0;}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k){\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)    {\n        float h = map(ro + rd*t).dist;\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }return res;}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).dist;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;}\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );}\n\nfloat checker(vec2 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi));}\n\nfloat checker(vec3 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi)*sin(p.z*pi));}\n\nvec3 material(vec3 p){\n    //return vec3(1.0-pow(0.5+0.5*sin(p.z*pi*10.0), 50.0))\n    return vec3(1.0)\n    //return mix(vec3(0.25), vec3(0.75), checker(p*2.0+0.5))\n;}\n\nvec3 sky(vec3 lightdir, vec3 d){// no particular meaning - just tweaked until it looks skyish\n    float v = 0.5*abs(d.z)+0.5;\n    return vec3(pow(1.0-v,2.0),1.0-v,v);}\n\n\nfloat sun(vec3 lightdir, vec3 rd){// sun with halo\n    float d = max(0.0, dot(rd, lightdir));\n    return smoothstep(0.998, 0.999, d) + exp(-pow((1.0-d)*500.0, 2.0));} \n\n\nvec3 pass(vec3 ro, vec3 rd, result r){\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,1),abs(-rd.z));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,0.5),sqrt(abs(rd.z)));\n    vec3 sky_color = sky(lightdir, rd);\n    sky_color += sun(lightdir, rd);\n    vec3 color = vec3(1);\n    if(r.dist < DIST_MAX){\n        color *= r.color_specular.xyz;\n        vec3 dst = ro + rd * r.dist;\n        vec3 n = normal(dst);\n        //color *= (n * 0.5 + 0.5);\n        //color *= material(dst);\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * r.dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0){\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular * r.color_specular.w;}\n\n        vec3 fog_color = sky_color;\n        color = mix(fog_color, vec3(color), exp(-pow(r.dist/20.0, 2.0))); // fog\n    }else{\n        color *= sky_color;\n    }return color;}\n\nfloat grey(vec3 color){return dot(color, vec3(1.0/3.0));}\n\nvoid scene2(vec3 ro, vec3 rd, inout vec4 fragColor){\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma\n\n\n//#define     noQuaterionCam_Use_DsKBDw_instead\n\n#ifdef        noQuaterionCam_Use_DsKBDw_instead\n//https://www.shadertoy.com/view/DsKBDw , modified to remain functional as \n//mainImage() instead of mainImage2()\n//while using a subroutine to work merged with quaternionCameras of\n//https://www.shadertoy.com/view/wtdyRs (oldest)\n//https://www.shadertoy.com/view/DsKBDw (newer)\nvoid mainImage(out vec4 fragColor, vec2 I){\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    //I = (4.0 * floor(I * 0.5) + 2.0 - R) / R.y; // integrated pixelize (speedup & looks cool) thanks to spalmer\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0));\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    ro.z += 0.0;\n    \n    scene2(ro,rd,fragColor);}\n    /*\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma*/\n\n#else\n\n//quaternion camera control canvas\nconst float FOV=1.;\nvoid mainImage(out v3 O,v1 U\n){vec4 q=get(camA0) //get camera rotation as quaternion\n ;mat3 cam=q2m(q)   //camera matrix from camera quaternion.\n ;vec2 uv=(U-0.5*iResolution.xy)/iResolution.y //scale uv to range [-1..1]\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))//rayDirection for uv from camera matrix \n ;vec3 ro=get(camP0).xyz\n \n //alternative scene of parent shader https://www.shadertoy.com/view/DsKBDw\n //kept here as example on how to modiy a shader to fit in here.\n //;O=v3(scene(ro,rd),1);//tracing a triangle,bend up+down by 3 sides, that are flat-triangle-orthogonal quadratic-beziers.\n //;return;\n \n //make a scene(rayorigin,raydirection) or scene2(rayorigin,raydirection,fragColor) function\n //that returns a fragment color for uv.xy[-1..1] \n ;vec4 fragColor=vec4(1);\n //scene2(get(camP0).xyz,rd,fragColor);\n ;vec4 ppd\n ;//Ray view_ray=Ray(rd,ro);\n ;vec4 col = mainScene( U, iTime, iResolution, iFrame,iMouse, iChannel2, ppd,q,ro);\n ;col.rgb=postProcess( col.rgb, U / iResolution.xy, ppd );\n O=col;\n ;} \n \n#endif", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[473, 473, 512, 512, 589], [643, 643, 672, 672, 996], [1028, 1028, 1066, 1144, 1436]], "test": "untested"}
{"id": "DsdBRf", "name": "REZGUI &BOUAKAZ", "author": "kolloss", "description": "TP  informatique graphique ", "tags": ["tpfinal"], "likes": 2, "viewed": 145, "published": 3, "date": "1698348549", "time_retrieved": "2024-07-30T17:25:51.930008", "image_code": "struct Ellipsoid {\n    vec3 center;\n    vec3 radius;\n    int i;// Texture Id\n};\nstruct Box {\n    vec3 min; // Minimum corner of the box\n    vec3 max; // Maximum corner of the box\n    int i;    // Texture Id\n};\n\nstruct Sphere {\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Cylinder {\n    vec3 start;  // Start point of the cylinder\n    vec3 end;    // End point of the cylinder\n    float radius;  // Radius of the cylinder\n    int i;        // Texture Id\n};\nstruct Torus {\n    vec3 center;   // Center of the torus\n    float majorRadius;  // Major radius of the torus\n    float minorRadius;  // Minor radius of the torus\n    int i;    // Color of the torus\n};\n\nstruct Capsule {\n    vec3 start;     // Start point of the capsule\n    vec3 end;       // End point of the capsule\n    float radius;   // Radius of the capsule\n    int i;          // Texture Id\n};\n\nstruct Plane {\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit {\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray {\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material {\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n    vec3 reflectivity; // Niveau de réflexion\n\n};\n\nfloat Checkers(in vec2 p) {\n    // Filter kernel\n    vec2 w = fwidth(p) + .001;\n    // Box box filter\n    vec2 i = 2. * (abs(fract((p - .5 * w) * .5) - .5) - abs(fract((p + .5 * w) * .5) - .5)) / w;\n    // xor pattern\n    return .5 - .5 * i.x * i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = i.x + i.y * 157.0 + i.z * 113.0;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fractalNoise(vec3 p, int octaves, float lacunarity, float persistence) {\n    float sum = 0.0;\n    float amplitude = 1.0;\n\n    for(int i = 0; i < octaves; i++) {\n        sum += noise(p) * amplitude;\n        p *= lacunarity;\n        amplitude *= persistence;\n    }\n\n    return sum;\n}\n\nvec3 marbleTexture(vec3 position, float scale, int octaves, float lacunarity, float persistence, vec3 color1, vec3 color2) {\n    vec3 p = position * scale;\n    float turbulence = fractalNoise(p, octaves, lacunarity, persistence);\n\n    // Adjust the contrast and brightness\n    float brightness = 0.5;\n    float contrast = 0.5;\n\n    // Interpolate between color1 and color2 based on turbulence\n    vec3 marbleColor = mix(color1, color2, turbulence);\n\n    // Apply contrast and brightness\n    marbleColor = mix(marbleColor - brightness, marbleColor + brightness, turbulence);\n\n    return marbleColor;\n}\n\n// Fonction de texture uniforme\nvec3 UniformTexture(vec3 p) {\n    return p; // Couleur RGB \n}\n\n// Fonction du Damier Volumique\nvec3 CheckerTexture(vec3 position, float checkerSize, vec3 Couleur1, vec3 Couleur2) {\n    float checkerValue = Checkers(position.xy / checkerSize);\n    return mix(Couleur1, Couleur2, checkerValue);\n}\n\nvec3 ConcentricColorTexture(vec3 position, vec3 center, vec3 innerColor, vec3 outerColor) {\n    // Calculez la distance entre le point et le centre\n    float distance = length(position - center);\n\n    // Normalisez la distance pour obtenir une valeur entre 0 et 1\n    float normalizedDistance = distance / max(length(innerColor), length(outerColor));\n\n    // Interpolez entre les couleurs intérieure et extérieure en fonction de la distance\n    vec3 color = mix(innerColor, outerColor, normalizedDistance);\n\n    return color;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i) {\n    vec3 diffuseColor = vec3(0.8, 0.5, 0.4);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n\n    if(i == 1) {\n        return Material(vec3(.8, .5, .4), vec3(.2, .2, .2), vec3(0.5, 0.5, 0.5), vec3(0.0, 1.0, 1.0));\n    }\n    if(i == 2) {\n        return Material(UniformTexture(vec3(.8, 0.0, 0.0)), vec3(.1, .1, .1), vec3(1., 1., 1.), vec3(1.0, 0.0, 0.0));// ROUGE \n\n    }\n    if(i == 3) {\n        return Material(UniformTexture(vec3(0.0, 1.0, 0.0)), vec3(.2, .2, .2), vec3(0.1, 0.1, 0.1), vec3(0.0, 1.0, 0.0));// Vert \n    }\n    if(i == 4) {\n        return Material(UniformTexture(vec3(0.0, 0.0, 1.0)), vec3(.2, .2, .2), vec3(0.1, 0.1, 0.1), vec3(0.0, 0.0, 1.0));// Bleu \n    }\n    if(i == 5) {\n        return Material(UniformTexture(vec3(1.0, 1.0, 1.0)), vec3(.2, .2, .2), vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5));// blanc grisatre \n    }\n    if(i == 6) {\n        return Material(CheckerTexture(p, 2.0, vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)), vec3(.2, .2, .2), vec3(0.5, 0.5, 0.5), vec3(0.0, 0.0, 0.0));//DAMIER NOIR ET BLANC \n    }\n    if(i == 7) {\n        // Utilisez ConcentricColorTexture pour calculer la couleur en fonction de la distance\n        return Material(ConcentricColorTexture(p, vec3(0.0, 0.0, 0.0), vec3(6.0, 0.0, 0.0), vec3(0.0, 0.0, 4.0)), vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5), vec3(1.0, 0.0, 1.0));\n    }\n\n    if(i == 8) {\n        // Créez une texture damier alternant entre la couleur diffuse et spéculaire\n        float checkerSize = 2.0;  // Taille du damier\n        float checkerValue = Checkers(p.xy / checkerSize);\n        if(checkerValue > 0.5) {\n            return Material(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.2), vec3(0.0, 0.0, .0), vec3(0.0, 0.0, 0.0)); // Diffuse\n        } else {\n            return Material(vec3(0.0, 0.0, .0), vec3(0.2, 0.2, 0.2), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)); // Spéculaire\n        }\n    }\n    if(i == 9) {\n                //4.0, 10, 3.0, 0.6\n        return Material(marbleTexture(p, 6.0, 20, 4.0, 0.6, vec3(0.858, 0.843, 0.698) ,vec3(0.937, 0.917, 0.839)), vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5), vec3(0.0, 0.0, 0.0));\n    } else if(i == 0) {\n        // compute checkboard\n        float f = Checkers(.5 * p.xy);\n        vec3 col = vec3(.4, .5, .7) + f * vec3(.1);\n        return Material(col, vec3(.1, .1, .1), vec3(0.3, 0.3, 0.3), vec3(1.0, 0.0, 0.0));\n    }\n    return Material(vec3(0), vec3(0), vec3(0), vec3(0));\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x) {\n    vec3 oc = ray.o - sph.c;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float d = b * b - c;\n    if(d > 0.) {\n        float t = -b - sqrt(d);\n        if(t > 0.) {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - sph.c), sph.i);\n\n            return true;\n        }\n    }\n    return false;\n\n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 oc = ray.o - ellipsoid.center;\n    vec3 invRadius = 1.0 / ellipsoid.radius;\n\n    vec3 rayDir = ray.d * invRadius;\n    vec3 rayOrigin = oc * invRadius;\n\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayDir, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if(discriminant > 0.0) {\n        float t0 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t0, t1);\n\n        if(t > 0.0) {\n            vec3 p = ray.o + ray.d * t;\n            vec3 normal = (p - ellipsoid.center) / ellipsoid.radius;\n\n            x = Hit(t, normalize(normal), ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool intersectTorus(Ray ray, Torus torus, out Hit hit) {\n    hit.t = -1.0;  // Initialize hit.t to a negative value to indicate no intersection\n\n    vec3 ro = ray.o - torus.center;\n    vec3 rd = ray.d;\n\n    float Ra2 = torus.majorRadius * torus.majorRadius;\n    float ra2 = torus.minorRadius * torus.minorRadius;\n\n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * rd.z * rd.z + k;\n    float k1 = k * n + Ra2 * ro.z * rd.z;\n    float k0 = k * k + Ra2 * ro.z * ro.z - Ra2 * ra2;\n\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n\n    if(h < 0.0) {\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    } else {\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\n\n    z = c2 - z;\n\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n\n    if(abs(d1) < 1.0e-4) {\n        if(d2 < 0.0) {\n            return false;  // No intersection\n        }\n        d2 = sqrt(d2);\n    } else {\n        if(d1 < 0.0) {\n            return false;  // No intersection\n        }\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        float t2 = -d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = t1;\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n\n    h = d1 * d1 - z - d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        float t2 = d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = min(result, t1);\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n    \n     if (result < 1e20) {\n    hit.t = result;  // Update the hit structure with the intersection depth\n\n    // Compute the normal vector\n    vec3 q = ray.o + ray.d * hit.t;\n    vec3 normal = normalize(vec3(\n        2.0 * (q.x - torus.center.x),\n        2.0 * (q.y - torus.center.y),\n        2.0 * (q.z - torus.center.z)\n    ));\n    hit.n = normal;\n\n    hit.i = torus.i;  // Assign the color or texture ID to the hit structure\n    return true;  // Intersection found\n}\n    \n    return false;  // No intersection\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit x) {\n    vec3 tMin = (box.min - ray.o) / ray.d;\n    vec3 tMax = (box.max - ray.o) / ray.d;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if(tNear > tFar || tFar < 0.0) {\n        return false;\n    }\n\n    float tHit = (tNear < 0.0) ? tFar : tNear;\n\n    vec3 hitPoint = Point(ray, tHit);\n    vec3 normal = vec3(0.0); // Initialize the normal vector to (0, 0, 0)\n\n    // Calculate normal based on which face of the box was hit\n    if(abs(hitPoint.x - box.min.x) < 0.0001) {\n        normal = vec3(-1.0, 0.0, 0.0); // Left face\n    } else if(abs(hitPoint.x - box.max.x) < 0.0001) {\n        normal = vec3(1.0, 0.0, 0.0); // Right face\n    } else if(abs(hitPoint.y - box.min.y) < 0.0001) {\n        normal = vec3(0.0, -1.0, 0.0); // Bottom face\n    } else if(abs(hitPoint.y - box.max.y) < 0.0001) {\n        normal = vec3(0.0, 1.0, 0.0); // Top face\n    } else if(abs(hitPoint.z - box.min.z) < 0.0001) {\n        normal = vec3(0.0, 0.0, -1.0); // Back face\n    } else if(abs(hitPoint.z - box.max.z) < 0.0001) {\n        normal = vec3(0.0, 0.0, 1.0); // Front face\n    }\n\n    x = Hit(tHit, normal, box.i);\n    return true;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if(t > 0.) {\n\n        x = Hit(t, vec3(0, 0, 1), pl.i);\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    // Initialize the hit to a default value\n    x = Hit(1000.0, vec3(0.0), -1);\n\n    // Check for intersection with the first sphere (start point)\n    Sphere sphere1 = Sphere(capsule.start, capsule.radius, capsule.i);\n    Hit sphereHit1;\n    bool hitSphere1 = IntersectSphere(ray, sphere1, sphereHit1);\n\n    // Check for intersection with the second sphere (end point)\n    Sphere sphere2 = Sphere(capsule.end, capsule.radius, capsule.i);\n    Hit sphereHit2;\n    bool hitSphere2 = IntersectSphere(ray, sphere2, sphereHit2);\n\n    // Check for intersection with the cylindrical part (the tube)\n    vec3 tubeDir = normalize(capsule.end - capsule.start);\n    vec3 oc = ray.o - capsule.start;\n    float a = dot(ray.d - dot(ray.d, tubeDir) * tubeDir, ray.d - dot(ray.d, tubeDir) * tubeDir);\n    float b = 2.0 * dot(ray.d - dot(ray.d, tubeDir) * tubeDir, oc - dot(oc, tubeDir) * tubeDir);\n    float c = dot(oc - dot(oc, tubeDir) * tubeDir, oc - dot(oc, tubeDir) * tubeDir) - capsule.radius * capsule.radius;\n\n    // Calculate the discriminant\n    float discriminant = b * b - 4.0 * a * c;\n\n    if(discriminant >= 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        // Check if t1 and t2 are within the bounds of the cylindrical part\n        float h1 = dot(ray.o + t1 * ray.d - capsule.start, tubeDir);\n        float h2 = dot(ray.o + t2 * ray.d - capsule.start, tubeDir);\n\n        if(t1 >= 0.0 && h1 >= 0.0 && h1 <= length(capsule.end - capsule.start)) {\n            if(t1 < x.t) {\n                vec3 hitPoint = Point(ray, t1);\n                vec3 normal = normalize(hitPoint - (capsule.start + h1 * tubeDir));\n                x = Hit(t1, normal, capsule.i);\n            }\n        }\n\n        if(t2 >= 0.0 && h2 >= 0.0 && h2 <= length(capsule.end - capsule.start)) {\n            if(t2 < x.t) {\n                vec3 hitPoint = Point(ray, t2);\n                vec3 normal = normalize(hitPoint - (capsule.start + h2 * tubeDir));\n                x = Hit(t2, normal, capsule.i);\n            }\n        }\n    }\n\n    // Check if there was an intersection with either of the spheres\n    if(hitSphere1 && sphereHit1.t < x.t) {\n        x = sphereHit1;\n    }\n\n    if(hitSphere2 && sphereHit2.t < x.t) {\n        x = sphereHit2;\n    }\n\n    return (hitSphere1 || hitSphere2 || x.t < 1000.0);\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit hit) {\n    // Initialize the hit to a default value\n    hit.t = 1000.0;\n    \n    vec3 cylinderAxis = normalize(cyl.end - cyl.start);\n    vec3 oc = ray.o - cyl.start;\n    \n    float a = dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, ray.d - dot(ray.d, cylinderAxis) * cylinderAxis);\n    float b = 2.0 * dot(ray.d - dot(ray.d, cylinderAxis) * cylinderAxis, oc - dot(oc, cylinderAxis) * cylinderAxis);\n    float c = dot(oc - dot(oc, cylinderAxis) * cylinderAxis, oc - dot(oc, cylinderAxis) * cylinderAxis) - cyl.radius * cyl.radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    float h1 = dot(ray.o + t1 * ray.d - cyl.start, cylinderAxis);\n    float h2 = dot(ray.o + t2 * ray.d - cyl.start, cylinderAxis);\n    \n    if (discriminant >= 0.0) {\n        if (t1 >= 0.0 && h1 >= 0.0 && h1 <= length(cyl.end - cyl.start) && t1 < hit.t) {\n            vec3 hitPoint = Point(ray, t1);\n            vec3 normal = normalize(hitPoint - (cyl.start + h1 * cylinderAxis));\n            hit = Hit(t1, normal, cyl.i);\n        }\n        \n        if (t2 >= 0.0 && h2 >= 0.0 && h2 <= length(cyl.end - cyl.start) && t2 < hit.t) {\n            vec3 hitPoint = Point(ray, t2);\n            vec3 normal = normalize(hitPoint - (cyl.start + h2 * cylinderAxis));\n            hit = Hit(t2, normal, cyl.i);\n        }\n    }\n    \n    float tTopCap = dot((cyl.start - ray.o), cylinderAxis) / dot(ray.d, cylinderAxis);\n    float distanceTopCap = distance(Point(ray, tTopCap), cyl.start);\n    \n    if (tTopCap >= 0.0 && distanceTopCap <= cyl.radius && tTopCap < hit.t) {\n        hit = Hit(tTopCap, cylinderAxis, cyl.i);\n    }\n    \n    float tBottomCap = dot((cyl.end - ray.o), -cylinderAxis) / dot(ray.d, -cylinderAxis);\n    float distanceBottomCap = distance(Point(ray, tBottomCap), cyl.end);\n    \n    if (tBottomCap >= 0.0 && distanceBottomCap <= cyl.radius && tBottomCap < hit.t) {\n        hit = Hit(tBottomCap, -cylinderAxis, cyl.i);\n    }\n    \n    return hit.t < 1000.0;\n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x) {\n    // Spheres\n    const Sphere sph1 = Sphere(vec3(0., 1., 2.), 1., 3);\n    const Sphere sph2 = Sphere(vec3(2., 0., 2.), 1., 3);\n    const Plane pl = Plane(vec3(0., 0., 1.), vec3(0., 0., 0.), 8);\n\n    // Ellipsoid\n    const Ellipsoid ell = Ellipsoid(vec3(4., -1., 1.), vec3(2., 2., 1.), 7);\n\n    // Torus\n    const Torus torus = Torus(vec3(-1.0, -2.0, 2.0), 1.0, 0.3, 5);\n\n    // Box\n    const Box box1 = Box(vec3(2.0, 2.0, 1.0), vec3(4.0, 4.0, 3.0), 9);\n\n    const Cylinder cyl = Cylinder(vec3(-3.0, 3.0, 5.0), vec3(-3.0, 3.0, 2.0), 1.0, 4);\n    const Capsule cap = Capsule(vec3(-1.0, 3.0, 4.0), vec3(1.0, 3.0, 4.0), 0.5, 2);\n\n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n    if(IntersectSphere(ray, sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectEllipsoid(ray, ell, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    // Check torus intersection\n    if(intersectTorus(ray, torus, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if(IntersectCylinder(ray, cyl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    // Check box intersection\n    if(IntersectBox(ray, box1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    if(IntersectCapsule(ray, cap, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    return ret;\n}\n\nvec3 Background(vec3 rd) {\n    return mix(vec3(.8, .8, .9), vec3(.7, .7, .8), rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m, vec3 n, vec3 p, vec3 viewDir) {\n    vec3 ambient = m.ambient;\n    vec3 diffuse = m.diffuse;\n    vec3 specular = m.specular;\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); // light direction\n    Hit temp;\n\n    // Calculate the normal and light direction\n    vec3 norm = normalize(n);\n\n    if(!Intersect(Ray(p + norm * 0.01, lightDir), temp)) {\n     // Calculate diffuse and specular terms\n        float diff = clamp(dot(norm, lightDir), 0., 1.);\n        vec3 reflectDir = -lightDir - 2.0 * dot(-lightDir, norm) * norm;\n        float spec = max(dot(reflectDir, viewDir), 0.0);\n\n    // Calculate the final color\n        vec3 ambientColor = ambient;\n        vec3 diffuseColor = diff * diffuse;\n        vec3 specularColor = spec * specular;\n\n        return ambientColor + diffuseColor + specularColor;\n\n    } else {\n\n        return vec3(.2, .2, .2);\n\n    }\n\n}\n\n// Hemisphere direction\n\nvec3 Hemisphere(int seed, vec3 n) {\n\n    float a = fract(sin(176.19 * float(seed)));// Uniform randoms\n\n    float b = fract(sin(164.19 * float(seed)));\n\n    float u = 2. * 3.1415 * a;// Random angle\n\n    float v = acos(2. * b - 1.);// Arcosine distribution to compensate for poles\n\n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v));// Direction\n\n    if(dot(d, n) < 0.) {\n        d = -d;\n    }// Hemishpere\n\n    return d;\n\n}\n\n// Ambient occlusion\n\n// p : Point\n\n// n : Normal\n\n// N : Number of samples\n\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    if(N == 0) {\n        return 1.0;  // No occlusion for N=0\n    }\n\n    float ao = 0.0;\n\n    for(int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // d dans la demi-sphere\n\n        // Create a shadow ray from the point to the sample point\n        Ray shadowRay;\n        shadowRay.o = p + 0.01 * n;\n        shadowRay.d = d;\n        \n        Hit hit;\n        bool hitSomething = Intersect(shadowRay, hit);\n\n        if(hitSomething && hit.t < 1000.) {\n            // The sample point is occluded, decrease ambient occlusion\n            ao += 1.0;\n        }\n    }\n\n    // Normalize the accumulated occlusion value to the range [0, 1]\n    ao = 1.0 - ao / float(N);\n\n    return ao;\n}\n\nvec3 Shade(Ray ray, int maxReflectionLevel, int N) {\n    vec3 accumulatedColor = vec3(0.0);\n\n    for(int reflectionLevel = 0; reflectionLevel <= maxReflectionLevel; reflectionLevel++) {\n        Hit x;\n        bool hitSomething = Intersect(ray, x);\n\n        if(!hitSomething) {\n            accumulatedColor += Background(ray.d);\n            break;\n        }\n\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n        vec3 norm = normalize(x.n);\n\n        // Calculate the base color (diffuse + ambient + specular)\n        vec3 baseColor = Color(mat, x.n, p, normalize(ray.o - p));\n\n        // Calculate ambient occlusion\n        float ambientOcclusion = AmbientOcclusion(p, x.n, N);\n\n        // Apply ambient occlusion to the base color\n        baseColor *= ambientOcclusion;\n\n        // Handle reflection\n        if(reflectionLevel < maxReflectionLevel && (mat.reflectivity.x > 0.0 || mat.reflectivity.y > 0.0 || mat.reflectivity.z > 0.0)) {\n            // Calculate the reflection direction\n            vec3 reflectDir = normalize(ray.d - 2.0 * dot(ray.d, norm) * norm);\n\n            // Create a reflected ray\n            ray.o = p + 0.01 * reflectDir; // Offset origin slightly to avoid self-intersection\n            ray.d = reflectDir;\n\n            // Accumulate reflected color\n            accumulatedColor += baseColor * mat.reflectivity;\n        } else {\n            accumulatedColor += baseColor;\n            break;\n        }\n    }\n\n    return accumulatedColor;\n}\n\n//Rotation\nRay RotateRay(Ray ray, float angle, vec3 axis) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n\n    vec3 ax = normalize(axis);\n    \n    mat3 rotation = mat3(\n        t * ax.x * ax.x + c, t * ax.x * ax.y - s * ax.z, t * ax.x * ax.z + s * ax.y,\n        t * ax.x * ax.y + s * ax.z, t * ax.y * ax.y + c, t * ax.y * ax.z - s * ax.x,\n        t * ax.x * ax.z - s * ax.y, t * ax.y * ax.z + s * ax.x, t * ax.z * ax.z + c\n    );\n    \n    ray.d = rotation * ray.d;\n    return ray;\n}\n\n//homothétie\nRay ScaleRay(Ray ray, vec3 scale) {\n    ray.d *= scale;\n    return ray;\n}\n\n//Transtlation\nRay TranslateRay(Ray ray, vec3 translation) {\n    ray.o += translation;\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    // Mouse control\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    Ray ray;\n\n    // Ray origin\n    vec3 ro = 12. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n    vec3 ta = vec3(0., 0., 1.5);\n    mat3 ca = setCamera(ro, ta);\n\n    // Ray\n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n    ray.o = ro;\n    ray.d = rd;\n\n    //ray = RotateRay(ray, radians(45.0), vec3(0.0, 0.0, 1.0));\n    //ray = TranslateRay(ray, vec3(1.0, 2.0, 3.0));\n    //ray = ScaleRay(ray, vec3(2.0, 2.0, 2.0));\n\n    // Reflection Level\n    int Reflection = 10;\n\n    //Render\n\n    vec3 col = Shade(ray, Reflection, 128);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1258, 1258, 1285, 1306, 1509], [1511, 1535, 1565, 1565, 1597], [1599, 1599, 1620, 1620, 1661], [1663, 1663, 1684, 1684, 2027], [2029, 2029, 2107, 2107, 2316], [2318, 2318, 2442, 2442, 2918], [2920, 2952, 2981, 2981, 3013], [3015, 3047, 3132, 3132, 3246], [3248, 3248, 3339, 3395, 3777], [3779, 3830, 3863, 3863, 6260], [6262, 6345, 6399, 6399, 6748], [6750, 6750, 6816, 6816, 7579], [7581, 7581, 7637, 7637, 10154], [10156, 10156, 10204, 10204, 11425], [11427, 11509, 11560, 11560, 11725], [11727, 11727, 11787, 11832, 14140], [14142, 14142, 14202, 14247, 16265], [16268, 16350, 16386, 16401, 17952], [17954, 17954, 17980, 17980, 18040], [18042, 18111, 18151, 18151, 18327], [18329, 18380, 18434, 18434, 19262], [19289, 19289, 19324, 19324, 19722], [19801, 19801, 19848, 19848, 20537], [20539, 20539, 20591, 20591, 22032], [22034, 22045, 22093, 22093, 22545], [22547, 22561, 22596, 22596, 22634], [22636, 22651, 22696, 22696, 22740], [22742, 22742, 22797, 22894, 23659]], "test": "untested"}
{"id": "DsVBzy", "name": "Red lava lamp", "author": "ianertson", "description": "Lava lamp", "tags": ["noise", "fire", "lava", "hash"], "likes": 2, "viewed": 126, "published": 3, "date": "1698344141", "time_retrieved": "2024-07-30T17:25:52.766771", "image_code": "#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n\n\nfloat line(vec2 p, vec2 a, vec2 b, float t) {\n    vec2 pa = p - a; vec2 ba = b - a;\n    return clamp(1.0-length(pa - clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0) * ba)/t, 0.0, 1.0);\n}\n\nfloat hash21(vec2 ip, float seed) {\n    uvec2 p = floatBitsToUint(ip);uint s = floatBitsToUint(seed);\n    uvec2 k = ~p;uint j = ~s;\n    p ^= p << 17U;p ^= p >> 13U;p += p.x * j + p.y;\n    p = p + ((p + k) << 3U);p ^= p << 5U;\n    return float(p.x + p.y) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv * lv * (3.0 - 2.0 * lv); \n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvoid mainImage(out vec4 O, in vec2 fc)\n{\n    vec2 uv = fc.xy / R.y;\n    vec3 col = vec3(0.0);\n    float cy = 0.3333;\n    float v = noise(uv*5.+T, 3.3212)*cy;\n    col += vec3(2.2, 0.63, 0.333)*line(uv, vec2(0.0, cy+v), vec2(R.x/R.y, cy+v), 0.01+0.04*noise(uv*40.+T, 1.132));\n    col = mix(col, vec3(1, 0, 0), smoothstep(0.0, cy, (v+cy)-uv.y));\n    col = pow(col, vec3(1.0/2.2));\n    O = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 135, 135, 271], [273, 273, 308, 308, 550], [552, 552, 585, 585, 848], [850, 850, 890, 890, 1253]], "test": "untested"}
{"id": "DdGyWK", "name": "Matrix Fractal", "author": "domrally", "description": "Sliced 4D fractal from the split-quaternions: Hypercomplex numbers identical to a 2 by 2 matrix. System has 1 euclidean part, 2 hyperbolic parts, & 1 imaginary part.\nClick to explore!\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "math", "4d", "orbit", "quaternion", "matrix", "hyperbolic", "split", "chaotic"], "likes": 10, "viewed": 295, "published": 3, "date": "1698339724", "time_retrieved": "2024-07-30T17:25:53.513773", "image_code": "/// by Dom Mandy in 2023\n\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 t,\n         r = iResolution.xy,\n         m = 2. * iMouse.xy - r;\n\n    // coordinates\n    i += i - r;\n    i *= 3. / r.x;\n    m *= 3. / r.x;\n    \n    // initialize euclidean-imaginary plane with coordinates\n    mat2 z = mat2(i, -i.y, i);\n\n    // controls\n    i = mix(i, m, max(0., sign(iMouse.z)));\n\n    // hyperbolic axes\n    mat2 c = mat2(0., 1., 1., 0.) * i.x\n           + mat2(1., 0., 0., -1.) * i.y\n           // euclidean axis\n           + mat2(1., 0., 0., 1.) * cos(iTime)\n           // imaginary axis\n           + mat2(0., 1., -1., 0.) * sin(iTime);\n    \n    // chaotic map\n    float f, k, e = 9e9;\n    for (; k++ < 9.; f < e ? e = f, t = z[0] : t) {\n        f = abs(determinant(\n            // the split-quaternion basis is isomorphic to the 2x2 matrices.\n            // this means we can use matrix operators like normal.\n            z = (z + c) * (z + c) / (z * z - c * c)\n        ));\n    }\n    \n    // map orbit trap\n    float h = atan(t.y, t.x) + iTime / 4.,\n          d = smoothstep(0., 2., pow(e, -.1));\n    \n    // color wheel\n    vec3 u = vec3(h - 2.1, h, h + 2.1),\n         v = .5 + .5 * cos(u);\n        \n    o = vec4(v * d, 1.);\n}\n\n\n/*\nREFERENCES\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n\nrefactoring\n\nshadertoyjiang & FabriceNeyret2 2023\nhttps://www.shadertoy.com/view/DdcBWX\n\nSnoopethDuckDuck 2023\nhttps://www.shadertoy.com/view/cs3BRj\n*/\n\n\n/*\nFURTHER READING\n\ngeometry\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\nhttps://en.wikipedia.org/wiki/Split-quaternion#Definition\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Spectral_sensitivity\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdGyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 63, 63, 1220]], "test": "untested"}
{"id": "cdKBzG", "name": "Fork PDE02563 - 2", "author": "lindealle", "description": "implementation", "tags": ["pde"], "likes": 1, "viewed": 92, "published": 3, "date": "1698335361", "time_retrieved": "2024-07-30T17:25:54.263768", "image_code": "vec2 grad(vec2 uv) {\n    // Compute the gradient of the. channel used for shading\n    \n    vec4 buffer_up = texture(iChannel0, vec2(uv.x, uv.y + 1.0 / iResolution.y));\n    vec4 buffer_down = texture(iChannel0, vec2(uv.x, uv.y - 1.0 / iResolution.y));\n    vec4 buffer_left = texture(iChannel0, vec2(uv.x + 1.0 / iResolution.x, uv.y));\n    vec4 buffer_right = texture(iChannel0, vec2(uv.x - 1.0 / iResolution.x, uv.y));\n    \n    // divide by 4, managable range\n    return vec2(buffer_left.y-buffer_right.y, buffer_up.y-buffer_down.y) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 g = grad(uv);\n    vec3 t1 = vec3(1,0,20.0*g.x);\n    vec3 t2 = vec3(0,1,20.0*g.y);\n    vec3 N = normalize(cross(t1,t2));\n    vec3 L = normalize(vec3(1,3,5));\n    float illum = (0.4+0.4*smoothstep(0.97,0.98, dot(N,L)) + 0.2 * max(0.0, dot(N,L)));\n\n    float substance = 2.0*texture(iChannel0, uv).g;\n    // Output to screen\n    fragColor = illum*vec4(0.8, 0.8, 0.1, 0.0) + (1.0-substance)*vec4(0.6, 0.4, 0.1, 0.0);\n\n   //fragColor = vec4(1.0)-vec4(1.0,0.8,0.6,0.0)*texture(iChannel0, uv).g;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 lap(vec2 uv) {\n    // Compute the Laplacian of all four elements of iChannel0\n\n    vec4 buffer = texture(iChannel0, uv);\n    vec4 buffer_up = texture(iChannel0, vec2(uv.x, uv.y + 1.0 / iResolution.y));\n    vec4 buffer_down = texture(iChannel0, vec2(uv.x, uv.y - 1.0 / iResolution.y));\n    vec4 buffer_left = texture(iChannel0, vec2(uv.x + 1.0 / iResolution.x, uv.y));\n    vec4 buffer_right = texture(iChannel0, vec2(uv.x - 1.0 / iResolution.x, uv.y));\n    \n    // divide by 4, managable range\n    return (buffer_up + buffer_down + buffer_left + buffer_right - 4.0 * buffer) / 4.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 BufferA = texture(iChannel0, uv);\n\n    // Suggested time step\n    float dt = 0.5;\n\n    /* Wave simulation constants */\n    float d = 0.999;\n    float c = 1.4;\n\n    /* Mitosis */\n    float Da = 1.0;\n    float Db = 0.5;\n    float k = 0.06507;\n    float f = 0.04938;\n    /**/\n       \n    float A = texture(iChannel0, uv).r;\n    float B = texture(iChannel0, uv).g;\n    \n    // INSERT CODE TO UPDATE A and B INSTEAD OF THE LINES BELOW ---> \n    \n    float Ap = A; // velocity\n    float Bp = B; // height\n    \n    // vec4 delta = d * c * c * lap(uv);\n    // Ap += delta.y * dt;\n    // Bp += Ap * dt;\n    \n    vec4 delta = lap(uv);\n    Ap += dt * (Da * delta.x - A*B*B + f*(1.0-A));\n    Bp += dt * (Db * delta.y + A*B*B - (k+f)*B);\n    \n    // <----------\n    \n    vec2 V = fragCoord - iMouse.zw;\n    if (iTime < 0.2)\n        fragColor = vec4(0, 0, 0, 0);\n    else\n        fragColor = exp(-0.1*dot(V,V)) * vec4(0,1.0,0,0) + vec4(Ap, Bp, 0.0, 0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 81, 540], [542, 542, 599, 649, 1194]], "test": "untested"}
{"id": "ddyBzy", "name": "2d thingy", "author": "Monetenbube", "description": "Based on this tutorial: https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["2d"], "likes": 0, "viewed": 311, "published": 3, "date": "1698331363", "time_retrieved": "2024-07-30T17:25:55.015757", "image_code": "//Based on this tutorial: https://www.youtube.com/watch?v=f4s1h2YETNY\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;  \n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n   \n    for (float i = 0.0; i < 4.0; i++) {\n   \n        uv = fract(uv * 1.5) - 0.5;\n    \n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(length(uv0) + iTime / 4.0);\n    \n        d = sin(d*8.0 + iTime*(0.9+i/4.0))/8.0;\n        d = abs(d);\n        d = pow(0.02 / d, 1.8);\n    \n        finalColor += col * d;\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddyBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 94, 94, 277], [280, 280, 337, 337, 873]], "test": "untested"}
{"id": "dsGBzy", "name": "[TDF16ms #0] Hello in T3 Puzzle", "author": "soma_arc", "description": "For TDF 16ms #0 GLSL Graphics compo.\nT3 Puzzle is the simplest tiling pattern maker in the world.\nCheck it out! https://www.tessellation.jp/t3puzzle", "tags": ["2d", "tessellation"], "likes": 7, "viewed": 167, "published": 3, "date": "1698331202", "time_retrieved": "2024-07-30T17:25:55.946271", "image_code": "const int SIZE_X = 40;\nconst int SIZE_Y = 12;\nconst int OBJ_SIZE = SIZE_X * SIZE_Y;\nconst int[OBJ_SIZE] tiles = int[](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 5, 1, 4, 1, 4, 1, 4, 1, 4, 1, 1, 0, 0, 0, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 6, 1, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 5, 6, 6, 5, 0, 0, 0, 3, 2, 4, 4, 1, 4, 1, 4, 1, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 5, 6, 6, 5, 0, 0, 0, 0, 0, 3, 2, 2, 6, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 3, 2, 4, 4, 6, 6, 5, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 5, 1, 4, 1, 4, 6, 3, 4, 4, 1, 4, 1, 1, 0, 0, 3, 2, 6, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 6, 3, 4, 4, 1, 4, 1, 4, 1, 1, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\nconst int SIZE_16MS_X = 45;\nconst int SIZE_16MS_Y = 12;\nconst int OBJ_SIZE_16MS = SIZE_16MS_X * SIZE_16MS_Y;\nconst int[OBJ_SIZE_16MS] tiles16ms = int[](0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 1, 0, 0, 0, 5, 1, 4, 1, 4, 1, 4, 1, 1, 0, 0, 0, 5, 1, 1, 0, 5, 1, 1, 0, 5, 1, 1, 0, 5, 1, 4, 1, 4, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 4, 1, 0, 0, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 3, 3, 5, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 4, 1, 0, 0, 3, 2, 4, 1, 3, 2, 4, 1, 3, 2, 4, 1, 0, 2, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 4, 1, 0, 0, 3, 2, 4, 1, 3, 2, 4, 1, 3, 6, 4, 1, 3, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 4, 1, 4, 1, 6, 5, 0, 0, 0, 3, 2, 2, 6, 2, 3, 2, 3, 2, 3, 5, 0, 3, 3, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 5, 1, 1, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 3, 2, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 4, 1, 4, 6, 6, 4, 1, 0, 0, 3, 2, 4, 4, 1, 4, 6, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 3, 3, 2, 3, 2, 3, 2, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\nconst int TILE_NONE = 0;\nconst int TILE_TOP = 1;\nconst int TILE_BOTTOM = 2;\nconst int TILE_TOP_RIGHT = 3;\nconst int TILE_BOTTOM_RIGHT = 4;\nconst int TILE_TOP_LEFT = 5;\nconst int TILE_BOTTOM_LEFT = 6;\n\nconst float PI = 3.14159265359;\nconst float PI_2 = PI * 0.5;\nconst float PI_3 = PI / 3.0;\n\nconst vec2 TRIANGLE_LEFT = vec2(0);\nconst vec2 TRIANGLE_RIGHT = vec2(1, 0);\nconst vec2 TRIANGLE_TOP = vec2(cos(PI_3), sin(PI_3));\nconst vec2 TRIANGLE_CENTER = (TRIANGLE_LEFT + TRIANGLE_RIGHT + TRIANGLE_TOP) / vec2(3);\nconst float TRIANGLE_HEIGHT = sin(PI_3);\nconst float TRIANGLE_EDGE_LENGTH = 1.0;\n\nconst mat2 ROT_120 = mat2(cos(2. * PI_3), -sin(2. * PI_3),\n                          sin(2. * PI_3), cos(2. * PI_3));\nconst mat2 ROT_120_REV = mat2(cos(2. * -PI_3), -sin(2. * -PI_3),\n                              sin(2. * -PI_3), cos(2. * -PI_3));\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nvec3 computeColor(const int tileType, vec2 p, const vec3 backgroundColor,\n                  const vec3 tileTopColor, const vec3 tileBottomColor) {\n    if(tileType == TILE_NONE) {\n        return backgroundColor;\n    } else if(tileType == TILE_TOP) {\n        if(p.y > TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_BOTTOM) {\n        if(p.y <= TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_TOP_RIGHT) {\n        vec2 np = ROT_120_REV * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y > TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_BOTTOM_RIGHT) {\n        vec2 np = ROT_120_REV * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y <= TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_TOP_LEFT) {\n        vec2 np = ROT_120 * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y > TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    } else if(tileType == TILE_BOTTOM_LEFT) {\n        vec2 np = ROT_120 * (p - TRIANGLE_CENTER) + TRIANGLE_CENTER;\n        if(np.y <= TRIANGLE_HEIGHT * 0.5) {\n            return tileTopColor;\n        }\n        return tileBottomColor;\n    }\n    return backgroundColor;\n}\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nint g_currentLine = 90;\nint getTile(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_Y <= y - translateY) {\n        //return TILE_NONE;\n        if(g_currentLine < x) {\n            return int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return TILE_NONE;\n        }\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_X;\n    if(0 <= index && index < OBJ_SIZE) {\n        //return int(random(vec2(float(x) + time, float(y) - time)) * 7.);//a[index];\n        //return a[index];\n        // if(tiles[index] == TILE_NONE) {\n        //     return TILE_NONE;\n        // }\n        if(g_currentLine < x) {\n            return tiles[index] + int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return tiles[index];\n        }\n        \n    }\n    return TILE_NONE;\n}\n\nint getTileRandom(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_Y <= y - translateY) {\n        //return TILE_NONE;\n        return TILE_NONE;\n    }\n\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_X;\n    if((0 <= index && index < OBJ_SIZE)) {\n        if(tiles[index] != TILE_NONE) {\n            for(int xx = -1 ; xx <= 1; xx++) {\n                for(int yy = -1 ; yy <= 1; yy++) {\n                    int ii = (x + xx - translateX * 2) + (y + yy - translateY) * SIZE_X;\n                    if((0 <= ii && ii < OBJ_SIZE)) {\n                        //return tiles[index] + int(mod(time * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n                        return int(mod(float(tiles[ii]) + (iTime * 5. + (random(vec2(x + xx, y + yy)) * 10.0)), 7.));\n                    }\n                }\n            }\n        }\n    }\n    return TILE_NONE;\n}\n\nint getTileRandom2(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_Y <= y - translateY) {\n        //return TILE_NONE;\n        return TILE_NONE;\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_X;\n    if(0 <= index && index < OBJ_SIZE) {\n        if(tiles[index] != TILE_NONE) {\n            //return tiles[index] + int(mod(time * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n            return int(mod(float(tiles16ms[index]) + (iTime * 5. + (random(vec2(x, y)) * 10.0)), 7.));\n        }\n    }\n\n    int index2 = (x - translateX * 2) + (y - translateY) * SIZE_16MS_X;\n    if(0 <= index2 && index2 < OBJ_SIZE_16MS) {\n        if(tiles16ms[index2] != TILE_NONE) {\n            //return tiles16ms[index2] + int(mod(time * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n            return int(mod(float(tiles16ms[index2]) + (iTime * 5. + (random(vec2(x, y)) * 10.0)), 7.));\n        }\n    }\n    \n    return TILE_NONE;\n}\n\nint getTileRandom16ms(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_16MS_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_16MS_Y <= y - translateY) {\n        //return TILE_NONE;\n        return TILE_NONE;\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_16MS_X;\n    if((0 <= index && index < OBJ_SIZE_16MS)) {\n        if(tiles16ms[index] != TILE_NONE) {\n            for(int xx = -1 ; xx <= 1; xx++) {\n                for(int yy = -1 ; yy <= 1; yy++) {\n                    int ii = (x + xx - translateX * 2) + (y + yy - translateY) * SIZE_16MS_X;\n                    if((0 <= ii && ii < OBJ_SIZE_16MS)) {\n                        return int(mod(float(tiles16ms[ii]) + (iTime * 5. + (random(vec2(x + xx, y + yy)) * 10.0)), 7.));\n                    }\n                }\n            }\n        }\n    }\n    return TILE_NONE;\n}\n\n\nint getTile16ms(const int x, const int y) {\n    const int translateX = 0;\n    const int translateY = 0;\n    //a[0] = int(mod(time * 5., 7.));\n\n    if(x - translateX * 2 < 0 || SIZE_16MS_X <= x - translateX * 2 ||\n       y - translateY < 0 || SIZE_16MS_Y <= y - translateY) {\n        //return TILE_NONE;\n        if(g_currentLine < x) {\n            return int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return TILE_NONE;\n        }\n    }\n    int index = (x - translateX * 2) + (y - translateY) * SIZE_16MS_X;\n    if(0 <= index && index < OBJ_SIZE_16MS) {\n        //return int(random(vec2(float(x) + time, float(y) - time)) * 7.);//a[index];\n        //return a[index];\n        // if(tiles[index] == TILE_NONE) {\n        //     return TILE_NONE;\n        // }\n        if(g_currentLine < x) {\n            return tiles16ms[index] + int(mod(iTime * 5. + floor(random(vec2(x, y)) * 10.0), 7.0));\n        } else {\n            return tiles16ms[index];\n        }\n        \n    }\n    return TILE_NONE;\n}\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 hsv2rgb(float h, float s, float v){\n    vec3 c = vec3(h, s, v);\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec4 gammaCorrect(vec4 rgba) {\n    return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),\n                rgba.a);\n}\n\nvec4 plane1 = vec4(0, 0, 0, 1); // (x, y, normalX, normalY)\nvec4 plane2 = vec4(0, 0, sin(PI_3), -cos(PI_3));\nvec4 plane3 = vec4(1, 0, -sin(2. * PI_3), cos(2. * PI_3));\nint IIS(vec2 pos) {\n    int invNum = 0;\n    for (int i = 0; i < 1000; i++) {\n        pos -= plane1.xy;\n        float dHalfPlane1 = dot(pos, plane1.zw);\n        if(dot(pos, plane1.zw) < 0. ) {\n            invNum++;\n            pos -= 2.0 * min(0., dHalfPlane1) * plane1.zw;\n            pos += plane1.xy;\n            continue;\n        }\n        pos += plane1.xy;\n\n        pos -= plane2.xy;\n        float dHalfPlane2 = dot(pos, plane2.zw);\n        if(dot(pos, plane2.zw) < 0. ) {\n            invNum++;\n            pos -= 2.0 * min(0., dHalfPlane2) * plane2.zw;\n            pos += plane2.xy;\n            continue;\n        }\n        pos += plane2.xy;\n\n        pos -= plane3.xy;\n        float dHalfPlane3 = dot(pos, plane3.zw);\n        if(dot(pos, plane3.zw) < 0. ) {\n            invNum++;\n            pos -= 2.0 * min(0., dHalfPlane3) * plane3.zw;\n            pos += plane3.xy;\n            continue;\n        }\n        pos += plane3.xy;\n    }\n\n    return invNum;\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sum = vec3(0);\n\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 pos = ((fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        pos *= 12.;\n        pos += vec2(14, 5);\n        \n        float a = TRIANGLE_TOP.y / TRIANGLE_TOP.x;\n        float x = pos.y / a;\n\n        float translatedX = mod(pos.x - x, 1.) + x;\n        float xIndex = floor(pos.x - x);\n\n        float yIndex = floor(pos.y / TRIANGLE_HEIGHT);\n\n        vec2 fundamentalPos = vec2(translatedX, pos.y) - TRIANGLE_TOP * yIndex;\n\n        xIndex *= 2.0;\n\n        fundamentalPos -= plane3.xy;\n        float dplane = dot(fundamentalPos, normalize(plane3.zw));\n        if(dplane < 0.) {\n            xIndex++;\n        }\n        fundamentalPos -= 2.0 * min(0., dplane) * plane3.zw;\n        fundamentalPos += plane3.xy;\n\n        float t = mod(iTime, 18.);\n        float strokeWeight = 3.;\n        //float strokeWeight = 0.01;\n        float startTime = 0.;\n        float durations = 3.;\n        strokeWeight = mix(2., 0., scene(t, startTime, durations));\n\n        startTime += durations;\n\n        durations = 8.;\n        g_currentLine = int(mix(-15., 80., scene(t, startTime, durations)));\n        startTime += durations;\n\n        startTime += 3.;\n        \n        durations = 3.;\n        strokeWeight += mix(0., 0.5, scene(t, startTime, durations));\n        startTime += durations;\n        if(abs(dot(fundamentalPos - plane1.xy, plane1.zw)) < strokeWeight ||\n           abs(dot(fundamentalPos - plane2.xy, plane2.zw)) < strokeWeight ||\n           abs(dot(fundamentalPos - plane3.xy, plane3.zw)) < strokeWeight) {\n            continue;\n        }\n\n        if(t < 10.) {\n            int tile = getTile(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        } else if(t < 10.5){\n            g_currentLine = -15;\n            int tile = getTileRandom(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n            \n        } else if(t < 11.){\n            g_currentLine = -15;\n            int tile = getTileRandom2(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        } else if(t < 11.5){\n            g_currentLine = -15;\n            int tile = getTileRandom16ms(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        } else {\n            int tile = getTile16ms(int(xIndex), int(yIndex));\n            sum += computeColor(tile, fundamentalPos, vec3(0.4),\n                                vec3(1, 0, 0), vec3(1));\n        }\n    }\n    vec3 col = (sum/SAMPLE_NUM);\n\n    fragColor = gammaCorrect(vec4(col, 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4175, 4205, 4253, 4253, 4294], [4296, 4296, 4323, 4323, 4363], [4364, 4364, 4393, 4393, 4429], [4431, 4431, 4462, 4462, 4569], [4571, 4571, 4599, 4599, 4635], [4637, 4637, 4783, 4783, 6135], [6138, 6138, 6162, 6162, 6269], [6295, 6295, 6334, 6334, 7295], [7297, 7297, 7342, 7342, 8334], [8336, 8336, 8382, 8382, 9443], [9445, 9445, 9494, 9494, 10414], [10417, 10417, 10460, 10460, 11449], [11451, 11540, 11581, 11581, 11873], [11875, 11875, 11915, 11915, 12118], [12164, 12164, 12194, 12194, 12404], [12574, 12574, 12593, 12593, 13532], [13564, 13564, 13621, 13621, 16586]], "test": "untested"}
{"id": "mdyBRG", "name": "Swetugg presentation shader", "author": "mrange", "description": "Hello this the result of the Swetugg live coding session called\n'Literally beautiful code' 2023-10-26 in Gothenburg, Sweden.\n\nThanks to the organizers for a great event and thanks to all that\nwatched me hack some shader code live.\n", "tags": ["2d"], "likes": 20, "viewed": 444, "published": 3, "date": "1698321023", "time_retrieved": "2024-07-30T17:25:56.700254", "image_code": "// CC0: Swetugg presentation shader\n\n// Hello this the result of the Swetugg live coding session called\n//  'Literally beautiful code' 2023-10-26 in Gothenburg, Sweden.\n\n// Thanks to the organizers for a great event and thanks to all that\n//  watched me hack some shader code live.\n\n// Here are some useful links to help you get started.\n\n// ShaderToy - A great place to code and learn together with a great\n//  community - You are here!\n\n// IQ Articles - A great resource by the great IQ, I visit this very often\n//  - https://iquilezles.org/articles\n\n// The Art of Code - A great YT channel by the great BigWings that \n//  helps you get started with very basics of shader programming\n//  - https://www.youtube.com/@TheArtofCodeIsCool\n\n// An Introduction Shader Art Coding - By the great kishimisu\n//  - https://www.youtube.com/@kishimisu\n\n// Windows Terminal Shader Gallery - You know you want shaders \n//  in windows terminal by me\n//   - https://github.com/mrange/windows-terminal-shader-gallery\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r ;\n}\n\nvec3 palette(float a) {\n  return 0.5+0.5*sin(vec3(0,1,2) + a);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat star5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  vec3 col = vec3(0.0, 0. ,0.0);\n  \n  for (int i=0; i<5;++i) { \n    vec2 p0 = p;\n    float itime = iTime+1.2*float(i);\n    p0.x += sin(itime);\n    float b = itime;\n    b = fract(b);\n    b -= 0.5;\n    b *= b;\n    b *= 2.0;\n    p0.y += b;\n  \n    p0 *= ROT(8.0*cos(itime));  \n    float d = star5(p0, 0.5, 0.5);\n    float od = abs(d)-0.015;\n    \n    if (d < 0.0) {\n      col = palette(itime-8.0*d);\n    }\n    \n    if (od < 0.0) {\n      col = vec3(q.y);\n    }\n  }\n  //col.x += sin(40.0*d);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1059, 1059, 1090, 1090, 1117], [1119, 1119, 1142, 1142, 1183], [1185, 1303, 1352, 1352, 1730], [1732, 1732, 1789, 1789, 2428]], "test": "untested"}
{"id": "csyfzG", "name": "Contour lines gradient", "author": "OzoneOnYou", "description": "Orig: My attempt to create contour lines. First implementation was using a laplace filter matrix, now using fwidth. Thanks for your help! \nMy edit: I made it colorful (based on density) and added some different AA. Overall nothing special.", "tags": ["filter", "gradient", "sinus", "matrix", "fwidth", "laplace"], "likes": 1, "viewed": 214, "published": 3, "date": "1698320449", "time_retrieved": "2024-07-30T17:25:57.449251", "image_code": "float wave(float x, float y, float k) \n{\n    return sin(10.0*x+10.0*y) / 5.0 +\n           sin(20.0*x*k+15.0*y*k) / 3.0 +\n           sin(4.0*x+10.0*y) / -4.0 +\n           sin(y) / 2.0 +\n           sin(x*x*y*20.0*k) + \n           sin(x * 20.0*k + 4.0) / 5.0 +\n           sin(y * 30.0*k) / 5.0 + \n    \t   sin(x) / 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 col1 = vec3(0.8, 0.1, 0.5);\n    const vec3 col2 = vec3(0.1, 0.1, 0.8);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy *= 2.;\n    uv.x += cos(iTime/100.)/4. - 0.5;\n    uv.y += sin(iTime/100.)*2. -0.5;\n    \n    \n    float z = wave(uv.x, uv.y, 1./10.) + 2.0;\n    \n    \n    z *= 2.0 * (sin(iTime/20.)+2.);\n    float d = fract(z);\n    if(mod(z, 2.0) > 1.) d = 1.-d;\n     \n    vec3 col;\n    for(float i=0.; i<3.; i++){\n        col += vec3(step(d/fwidth(z*3.), 0.5+(iResolution.x+iResolution.y)/2000. - (i+1.)/3.)*((i+1.)/2.));\n    }\n    \n    \n    col *= mix(col1, col2, fwidth(z*4.)+0.3);\n    fragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csyfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 317], [319, 319, 376, 376, 1065]], "test": "untested"}
{"id": "mdVBDm", "name": "┣┳┻┫ꓕTiles+Quaternion_cam", "author": "ollj", "description": "𝐑𝐨𝐭𝐚𝐭𝐞= 𝐀𝐫𝐫𝐨𝐰𝐊𝐞𝐲𝐬 || 𝐃𝐫𝐚𝐠𝐌𝐨𝐮𝐬𝐞 +𝐖𝐑 (=roll) \n𝐒𝐭𝐫𝐚𝐟𝐞= 𝐄𝐒𝐃𝐅                                 +𝐓𝐆 (=upDown)  \nhttps://www.shadertoy.com/view/DsKBDw\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs", "tags": ["fly", "quaternioncamera"], "likes": 6, "viewed": 223, "published": 3, "date": "1698305981", "time_retrieved": "2024-07-30T17:25:58.768723", "image_code": "//drag mouse for quaternion rotation\n//arrow keys to accellerate and roll\n\n//grandparent bezierPatch  : https://www.shadertoy.com/view/XsjSDt\n//grandparent flyQuaternion: https://www.shadertoy.com/view/MldczM\n//parent                   : https://www.shadertoy.com/view/ttjSzw\n//self                     : https://www.shadertoy.com/view/wlSyzd\n\n//A triangular cubic bezier patch, bound by 6 CV-heights, \n//is tranceable analytically with good performance and precision\n//for no good reason i never bothered to fix the camera of /XsjSDt, till now\n//and i notice that this shader sucks if the camera is inside the bezier-triangle-prism.\n\n//it works fine, as long as the patch is not too planar\n//any near-planar bezierPatch has a too small determinant which diminishes precision too much.\n//the first few milliseconds of this demo are near-planar\n\n//it works fine as long as the camera is not inside the bounding-prism (incl min&&max height) \n//of the bezier patch\n\n//But if the camera is inside the bezierPrism, the roots are in the wrong order. \n//and it seems to treat roots behind the camera as if they are infront of the camera??\n\n\n//BUT it always renders 2 patches, and their distance to each other is the distance of the camera to vec3(0)\n//, as if they are mirror images.\n//and they intersect when the camera is close to it.\n//, and they appear to swap places when you move over one of them.\n//and then you may confuse it for its mirror image.\n//unless you have the original inside its AABV\n\n//the open question here is, how to remove the mirror image solution?\n\n\n\nfloat segment(vec2 P, vec2 A, vec2 B){ \n    vec2 g=B-A;\n    vec2 h=P-A;\n    return length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));}\n\n#define fra(u)(u-.5*iResolution.xy)/iResolution.y\n\nvec4 drawDragVector(vec2 u){\n  if (iMouse.z<0.)return vec4(0);\n  vec2 a=fra(abs(iMouse.xy));\n  vec2 b=fra(abs(iMouse.zw));\n  //float r=smoothstep(.01,0.,abs(length(b-u)-.02));//ring\n  float r=min(   segment(u,a,b   )//line segment\n             ,abs(length(b-u)-.02)//ring\n             );\n  r=smoothstep(.01,0.,r)*.3;//thickness, transparency\n  return vec4(r);}//premultiplied for porterDuff\n\nvoid mainImage(out vec4 o, in vec2 u){\n //o=mainImage2(o,u);                         //mainIimage is in THIS channel\n o=texture(iChannel2,u/iResolution.xy, -100.);//mainIimage is in Ichannel2\n o=sat(o);//may need to clamp for an overlayd line\n //o+=drawDragVector(u/iResolution.xy*iResolution.x);//almost sufficient for a white line overlay\n o=pdOver(drawDragVector(fra(u)),o);//proper porter duff overlay.\n}\n\n//everything is in BuffA and common\n\n\n/*\n//Volumetric fractal explorer \n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scattering\n//Multibounce scattering\n//Approximate volumetric reprojection for temporal denoising\nvoid mainImage(out vec4 c,vec2 p\n){c=texture(iChannel0,p/iR.xy)\n ;c=1.07*tanh(pow(c/c.w,vec4(.6)))//this gamma correction is important\n ;}\n \n//MIT License\n//Copyright 2020 Mykhailo Moroz\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//assume as \"Do whatever you want\" License\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Camera Controller (quaternion 2022-02)\n//also contains the non-quaternion camera controller (toggle is [camType] in commontab):\n\n//lots of paramerets for this exist in the commontab\n\n/*\nto enable camera-to-object collisions\n, the normals() and setting() distance field (and all its subroutines)\nneed to either be duplicated into the camera-movement buffer\n, OR moved into the common-tab\nThis may be too excessive and it tends to cause WAY too many namespace conflicts to be worth it.\n\nthis is its own fragment-buffer-tab  \njust for convenience + simplicity + compatibility (quick copying of whole buffers)\n\ninstead, it could just overlay its 4 bottom left pixel\nof in the actual image of another buffer (ccopying from another image-tab)\nwhich sure makes enabling-of-collisions much simpler (no duped code needed in that case)\n*/\n\n// // simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n// // #define noRollCam     0\n// // quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n// // #define quaternionCam 1\n// // \n// // #define camType quaternionCam\n\n//note. for cvollision to work, this function needs df() and normal() functions\n//added to collide with a distanceField bacl along a surface normal\n//they are commented out in THIS shader\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//esdf is mor comparible than wasd (especially with french layout)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n\n//constant code:\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n#if (camType==0) \nvec4 cp0( //non quaternion camera\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0( //quaternion camers\n//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){// gating to skip the colision calculation that is likely disabled anyways.\n  //include the function that estimates the surface normal of the df() function above this \n  //to push the camera away, alogn the surfaceNormal to avoid collisions\n  //then remove the commentingPut line / * below and you have some physics\n  //, use constants to set scaling.\n  /*\n  ;float d=PHYSICS_RADIUS\n  ;d-=length(-df(r.xyz)) //include df() as distance field function here to collide the dcamera\n  //;if (d>0.)r.xyz+=vec3(0.,0,PHYSICS_REPEL)//push up workaround that works without normal()\n  ;if (d>0.)r.xyz+=normal(r)*d*PHYSICS_REPEL //push camera away, alons surface normal.\n  //optional collision , needs normal() of the df()\n\n  /**/ \n  //collisions need the df() and its normal() function to be also here, or shared in commontab.\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(  //non quaternion camera\n//return camera linear velocity.xyz a vec3 with speed.w as scalart, unaffected by change-of-direction\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else   \n  //quaternion camera\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //non quaternion camera\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else \n//quaternion camera\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n ;return normalize(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n#endif\n\n#if (camType==0) \n //non quaternion camera\nvec4 ca1(//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\n  //quaternion camera\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//keyL and keyP may be used to position 2 seperate light sources \n//at the current camera position, when the key L/P is pressed\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\n//2 buffers for 2 movable light sources\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous pos\n ;if(u==camA0p)return get(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//2022-02 union of \n//https://www.shadertoy.com/view/wlSyzd (quadratic bezier triangle   2022-01)\n//https://www.shadertoy.com/view/wl3yDs (reproject volume quaternion 2022-02)\n//mostly to improve camera controls\n\n//tags:\n//traceQuadratic,bezierPatch,Quaternioncamera,fly,aabv,bspline,bpatch,pqfm\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n\n\n\n\n\n//----- START  of parameters and common functions for camera controls\n//\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam]\n//- does not allow for roll (and thus it never gridlocks)\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;//\n//camera starting position\nconst vec4 posStart=vec4(-19,19,9,1);\n//\n#if (camType==0) \n #define CAMERA_SPEED .05\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n const float\n // if (camera is closer than PHYSICS_RADIUS) apply pushing force PHYSICS_REPEL along surface-normal.\n  //set to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=.0000001 //-100.\n ,PHYSICS_REPEL=1.//normal(cameraPosition)*PHYSICS_REPEL= how much colisions push the camera away. \n                  //no normalize() happens outside of normal(), which you may add or remove\n                  //depending on how good your df is andOr how your collisions handle deformed fields.\n ,LIN_ACCE=4.5//linear accelleration\n ,ANG_ACCE=2.//angular accelleration\n ,LIN_DRAG=1.//linear  drag/friction\n ,ANG_DRAG=2.//angular drag/friction\n;\n\n\n#endif\n//#endif\n//\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n//\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n//----- end of parameters and common functions for camera controls\n\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//essential for the quaternion-camera.\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n//return normalize(q) //unnecessary, as long as lenght(q) is close to 1.\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n//\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){\n//return qv2v(b*vec4(1,1,1,-1),v);//somehow this is not identical, fuck it all!\nv2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n\n//from https://www.shadertoy.com/view/wlSyzd\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qq2q(qinv(q),qq2q(v3(p,0.0),q)).xyz;}//inverse rotation\n//---end__ quaternion\n\n\n\n\n\n\n//load and save, originally from iq, modified\nv0 isInside(v1 p,v1 c){v1 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\n/*v3 load(int re){return texture(iChannel0,(.5+v1(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in v3 va, inout v3 o, in v1 u\n){if(isInside(u,v1(re,0))>.0)o=va;}//o=(isInside(u,v1(re,0))>.0)?va:o;}\n*/\n\n//#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\n//v0 ad(v1 a){return a.x+a.y;}\n//v0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//instead of doing imouse.zw=abs(imouse.zw) iMouseZwFix only changes sign when needed.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n  \n//checkerboard of https://www.shadertoy.com/view/4lySzc\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n\n//a matrix of quadraticFields, that share no prime factors, is a fast and simple hash.\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n//maybe see https://www.shadertoy.com/results?query=pqfm\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\n//- distance Field\n\n/*\n//mandelbulb fractal\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance, o.yzw are for orbittrap memory\n//w.xyz=uv    ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);}\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;o.x=0.25*log(w.w)*sqrt(w.w)/o.x;return o;}\nfloat mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;return 0.25*log(w.w)*sqrt(w.w)/o.x;}\n\n//float df (vec3 u){u=repeat(u);return mandelBulb (u);}\n//vec4  dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\n\nvec3 normal(in vec3 p\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n*/\n\n\n//damn, this is a fisheye cam that is just as complex.\n//in short i fail\n\n//getRayDir() lookAtCamera is 3* normalize(cross()), it seems to be a lazy and slow camera.\n//quatrernion alternatives exist:\n//https://www.shadertoy.com/view/wl3yDs\n//commontab has quaternion functions:\nvec3 getCam(vec3 ro, vec3 lookAt, vec2 uv\n){/*\n ;vec3 f = normalize(lookAt - ro)\n ,r = normalize(cross(vec3(0, 1, 0), f))\n ;return normalize(f + r * uv.x + cross(f, r) * uv.y);/**/\n ;\n ;vec4 quatUv=eYPR2q(vec3(uv,0.).zxy)//fragCoord.xy/iResolution*2.-1.) //uv.y not scaled by AspectRatio?\n ;lookAt=normalize(lookAt-ro)\n ;vec3 rayDirection=qv2v(quatUv,lookAt)*vec3(1,-1,1)\n ;return rayDirection;}\n /**/\n\nmat3 getCam(vec2 a// phi.x,theta.y\n){vec3 x_dir=vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y))\n ;vec3 y_dir=normalize(cross(x_dir,vec3(0,0,1)))\n ;vec3 z_dir=normalize(cross(x_dir,y_dir))\n ;return mat3(x_dir,y_dir,z_dir);}\n\nmat3 getCam(sampler2D s//buffer is a quaternion\n){return q2m(get2(camA0,s));}\n\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//from   https://www.shadertoy.com/view/wdsSWS\n//.w=0 is fully transparent, .W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs wioth their alpha;\n//; a.xyz*=a.w\n//; b.xyz*=b.w\n//and the outputs of these functions will be already_premultiplied.\n//\n//else if(you to one last pdOver a nontransparent background) you must NOT premultiply the backbround!\n//pdver without premultiplied alpha, note that nonstransparent red+nontransparent green = nontransparendt yellow.\n//vec4 pdo(vec4 a,vec4 b){return vec4((a.xyz*a.w+b.xyz*b.w)/(a.xyz+b.w*(1.-a.w)),,a.w+b.w*(1.-a.w));}\n//these functions are with premultiplied alpha (better performance, easy to buffer)\n//\n//GENERAL alpha composition:  named after porterDuff\n//see https://en.wikipedia.org/wiki/Alpha_compositing\n//    https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent, .W=1 is fully visible\n//inputs should be x=sat(x), or you likely get [color inverted hazes], this version is still not haze-free?\n//\n//on premultiplication:\n//iff (you want to keep an alpha channel after a composition)  !!!!\n//You must FIRST premultiplay all inputs with their alpha.w :  !!!!\n//; a.xyz*=a.w                                                 !!!!\n//; b.xyz*=b.w                                                 !!!!\n//on general [premultiply], you may want to watch              !!!!\n//https://www.youtube.com/watch?v=XobSAXZaKJ8                  !!!!\n//\n//IFF you can discard the alpha channel after a SINGLE composition\n//, you may also skip the premultiply-multiplication in some cases.\n\n//ut() is a subroutine for alpha compositing:\n//#define ut(a,b) (a*(1.-b))   //this one liner is a lot less worksafe!\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}\n//below are the 5 alpha compositions:\nvec4 pdOut (vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+(a*b.w);}\nvec4 pdXor (vec4 a,vec4 b){return ut(b,a.w)+vec4(ut(a,b.w));}\nvec4 pdIn  (vec4 a,vec4 b){return vec4(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//the above ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//the above ommits 2 functions, that return a or b, for simplicity\n//end of basic part of alpha compositing (yep, thats ALL there is to it)\n//\n//start of extended alpha compositing \n//...adds interpolation+generalization to compositing (interpolating different types of compositing)\n//The below allows you to MIX(a,b,c) between any 2 or 4 types of alpha compositing, by the parameter [c]\n//pf() does unify all 5 pd-compositions (above) into 1 parametric function\n//pf() was a silly idea of smoothly cyling between 5 compositions\n//pf() was quickly obsoleted by pf()\n//pdOverAtop() and pdOutXor() are interpolating subroutines for pf()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\n//pf() has c set how we interpolate; c is range [0..4] and whole-bumber-c causes a [mix(a,b,0.)==a] result\n#define Over 0. //[c range 0..1 => over..atop]\n#define Atop 1. //[c range 1..2 => atop..out]\n#define Out  2. //[c range 2..3 =>  out..Xor]\n#define Xor  3. //[c range 3..4 =>  xor..In]\n#define In   4.\n//the ability to interpolate is just a side effect of using mix() to generalize.\n//pf() may actually only work well for c=floor(c) its not tested well.\nvec3 pf(vec4 a,float c,vec4 b\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\n//\n//pd() makes more sense than pf() for demoing interpolation of compositing\n//pd() does bilinear interpolatin over c.xy, as in https://www.shadertoy.com/view/wdsSWS\n//top    left  = Over\n//top    right = Xor\n//bottom left  = Atop\n//bottom right = Out \nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//clamping c.x to ensure bounds.\n ;return mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w);}\n/**/", "buffer_c_code": "//buffC.start\n//ichannel0=self\n//ichannel1=keyIn\n\n//this buffer has its own shitty cameraControls\n//, to be replaced by the camera control of BuffB\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\n//v3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\n//v3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\n//v3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\n//v3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\n//v2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\n\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n/*\n//grandparent backup version to check errors\nv1 v2VertA = v1( 0.0, 4.0 ); \nv1 v2VertB = v1(-4.0,-4.0 );\nv1 v2VertC = v1( 4.0,-4.0 );\n#define D_BIAS 0.0001\nv2 CartToBary( v1 v2Cart ){\n    v1 w0 = v2VertB - v2VertA;\n    v1 w1 = v2VertC - v2VertA;\n    v1 w2 = v2Cart - v2VertA;\n    v0 d00 = dot(w0, w0);\n    v0 d01 = dot(w0, w1);\n    v0 d11 = dot(w1, w1);\n    v0 d20 = dot(w2, w0);\n    v0 d21 = dot(w2, w1);\n    v0 denom = d00 * d11 - d01 * d01;\n    v2 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    return v3Bary;}\nv3 BezierTriISect( const v2 v3CameraPos, const v2 v3LookDir, v2 CP_2, v2 CP_0 ){\n    v1 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    v1 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    v1 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    v1 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    v1 v2MinA = v1( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    v1 v2MinB = v1( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    v1 v2MinC = v1( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    v1 v2MaxA = v1( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    v1 v2MaxB = v1( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    v1 v2MaxC = v1( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    v0 fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    v2 v3Start, v3End;\n    if( bAValid && bBValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{       return v3( 0.0, 0.0, 0.0, 2.0 );    }       //no intersection!\n    v2 S = CartToBary( v3Start.xy );\n    v2 E = CartToBary( v3End.xy );\n    //Plug in eye ray and solve variables for root finding.\n    v2 ES = E - S;\n    v0 fA = dot( ES * ES, CP_2 ) + 2.0*dot( v2(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    v0 fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( v2((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    v0 fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( v2(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );    \n    //Actual root finding\n    v0 fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )    {\n        v0 fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        v0 fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )        {\n            if( fRootB >= 0.0 )                fRootA = min( fRootB, fRootA );\n            return v3( S + fRootA*ES, fRootA );        }\n        if( fRootB >= 0.0 && fRootB <= 1.0 )            return v3( S + fRootB*ES, fRootB );    }    \n    return v3(0.0, 0.0, 0.0, 2.0);}/**/\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//c1,c0 6 CW heights (orthogonal to triangle plane)\n//p1,p2,p3 corners of base triangle\n//res=resolution.x (screen width in oixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=v2(0,.3,.3);return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n  ;}};return v3(0,0,0,2);}//no intersection\n\n\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n \n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.\n\n\n//--- all above code used to be in a commontab\n\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;//v4iSect form may be return v3(S+a.y*E,a.y)\n //where S and E are baricentric.xyz and a.x (or a.y) are the closest root.\n ;//we basically only care for the .w parameter\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.x,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.z,.2));}//paint 6 CVs\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\nv2 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3){//position,direction, trianglecorners \n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0]),b=cos(pq[2])\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.\n ){\n  ;return v2(.5)//if(ray misses AABV)return grey!\n ;}\n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5))c.xyz=mix(c.xyz,cd,.2)//debug color output\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;return o.xyz;\n;}\n \nv2 scene(v2 o,v2 d\n){v2 //3 corners.xyx of a triangle\n//, that the bezier patch is pklaced above and below of\n//all ControllVectors only move in the .z direction.\n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);//.z==0. for simplicity/debugging\n ;return bezierPatch(o,d,p1,p2,p3)\n ;}//origin,direction\n\n\n//below code copied from https://www.shadertoy.com/view/DsKBDw\n//and then slowly modified to replace the camera, and to understand it more (compacting/aliasing...)\n \n// https://www.shadertoy.com/view/DsKBDw asymmetric blocks with portals reflections, 2023 by jt\n// based on https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d\n// Added reflections and stairs to https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d.\n// Thanks to Shane for suggesting the DDA-plugin / snap-to-voxel method & for the asymmetric blocks idea!\n\n// tags: 3d, random, reflections, t, blocks, portal, double, door, passage, connection, alternating, irregular, asymmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For correct ambient occlusion sample 2x2x2 voxels (slow!)\n//#define HIGH_QUALITY XXX CURRENTLY BROKEN DUE TO APPROXIMATE SDF AT PORTALS XXX\n\nfloat hash12(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);}\n\nvec2 hash22(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);}\n\nvec3 hash32(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);}\n\nvec3 hash33(vec3 p3){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);}\n\nstruct block{\n    vec4 center;\n    vec4 extent;\n    ivec2 id;\n    ivec2 id0;\n    ivec2 id1;\n    bool flag;};\n\nblock empty_block(){return block(vec4(0), vec4(0), ivec2(0), ivec2(0), ivec2(0), false);}\n\n#define block_offset 0.2\n#define wall_size 0.02\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror){\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // [0,1]\n    vec2 r = mix(vec2(block_offset), vec2(1.0 - block_offset), fract(hash22(vec2(t+d))))+vec2(d); // [constrained]\n    return choose?r.y:r.x;}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(ivec2 tile, vec2 local){ // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n\n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    if(flip){ // horizontal line goes through: swap vertical with horizontal\n        // swap components\n        local = local.yx;}\n    // vertical line goes through (on flip transpose for horizontal line)\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    float e = block_hash(tile,-X, 0,!flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n    vec4 vv0 =\n        vec4 (\n            // primary corner in (0,0) tile\n            c,d,\n            // secondary corner in (0,0) tile\n            c,e);\n    vec4 vv1 = vec4(\n            // primary corner in (X,Y) tile\n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip),\n            // secondary corner in (X,Y) tile\n            block_hash(tile,2*X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip) );\n\n    if(flip) tile = tile.yx;\n    vv0 += vec2(tile).xyxy;\n    vv1 += vec2(tile).xyxy;\n    ivec2 id = tile + ivec2(x,y);\n    ivec2 id0 = tile + ivec2(1-x,1-int(local.y < e));\n    ivec2 id1 = tile + ivec2(1-x,1-int(local.y < e));\n\n    if(flip)    { // horizontal line goes through: unswap vertical with horizontal\n        vv0 = vv0.yxwz;\n        vv1 = vv1.yxwz;\n        id = id.yx;\n        id0 = id0.yx;\n        id1 = id1.yx;}\n\n    bool flag = vv0.y > vv1.y;\n    // using abs in conversion to center-extend fixes order of min/max corners\n    return block((vv0+vv1)/2.0, abs(vv0-vv1)/2.0, id, id0, id1, flag);}\n\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll){\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n    return R * S * T;}\n\nfloat halfspace(vec3 p){return p.z + 1.0;}\n\nfloat sphere(vec3 p, float r){    return length(p) - r;}\n\nfloat approx_crossing(vec3 p, float r)\n{//return sphere(p, r);\n    return max(length(p.xz)-r, length(p.yz)-r);\n}\n\nfloat box(vec2 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 p0, vec3 p1){\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0);}\n\nfloat box(vec2 p, vec2 p0, vec2 p1, float r){ // min-max box with rounded corner\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0-r)-r;}\n\nfloat box(vec3 p, vec3 p0, vec3 p1, float r){ // min-max box with rounded corner\n    float d = box(p.xy, p0.xy, p1.xy, r);\n    vec2 w = vec2(d, abs(p.z-(p1.z+p0.z)/2.0) - (p1.z-p0.z)/2.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat dot2( in vec2 v ){return dot(v,v);}\n\nfloat cone(vec3 p, float h, float r1, float r2){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 q = vec2(length(p.xy), p.z);\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );}\n\n/*\nfloat cylinder(vec3 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n*/\nfloat cylinder(vec3 p, float r, float h){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat frame(vec2 p, vec2 s, float t){\n    return max(box(p, s),-box(p, s-t));}\n\nfloat frame(vec3 p, vec3 s, float t){\n    float d = frame(p.xy, s.xy, t);\n    // extrude https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p.z) - s.z);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat vmax(vec2 v){return max(v.x, v.y);}\n\nvoid pR45(inout vec2 p){p = (p + vec2(p.y, -p.x))*sqrt(0.5);}\n\nfloat pMod1(inout float p, float size){\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;}\n\n// https://www.shadertoy.com/view/Xs3GRB HG SDF in WebGL by tomkh,\n// implementation of http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n){\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));}\n\n#define dd(a) dot(a,a)\n/*\nfloat make_cylinder_grid(vec3 l, float r){\n  return sqrt(min(\n            min(dd(l.xz-vec2(1.0,0))-r,dd(l.xz-vec2(0.0,0))-r),\n            min(dd(l.yz-vec2(1.0,0))-r,dd(l.yz-vec2(0.0,0))-r)));}\n    \n/*\n    float d =min(\n            min(length(l.xz-vec2(1.0,0))-r,length(l.xz-vec2(0.0,0))-r),\n            min(length(l.yz-vec2(1.0,0))-r,length(l.yz-vec2(0.0,0))-r)        );\n    return d;}\n /**/\n\n/*\nfloat make_cuboid_grid(vec3 l, float r, float s){\n    float d =min(\n            min(box(l.xz-vec2(1.0,0),vec2(r,s)), box(l.xz-vec2(0.0,0),vec2(r,s))),\n            min(box(l.yz-vec2(1.0,0),vec2(r,s)), box(l.yz-vec2(0.0,0),vec2(r,s)))        );\n    return d;} /**/\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\nstruct result{\n    float dist;\n    vec4 color_specular;\n    bool flag;};\n\nresult combine(result a, result b){\n    if(a.dist < b.dist) return a;\n    return b;}\nresult remove(result a, result b){\n    if(a.dist > -b.dist) return a;\n    return result(-b.dist, b.color_specular, b.flag);}\n\nvec3 colorize(ivec2 id){\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    vec3 n = vec3(1,1,1);\n    color -= 0.5*dot(color,n)*n/dot(n,n); // remove part of component along diagonal\n    return color;}\n\nresult map(ivec2 v, vec3 l){ // unit grid: voxel = float(position), local = fract(position)\n    result res = result(DIST_MAX, vec4(vec3(1), 0), false);\n    block b = blocks_layout(v.xy, l.xy);\n    float h = 0.2;\n    //float h = 0.2+0.1 * hash12(vec2(b.id));\n    //float h0 = 0.1 * hash12(vec2(b.id0));\n    //float h1 = 0.1 * hash12(vec2(b.id1));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy-wall_size,h), wall_size), vec4(colorize(b.id), 0), false));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy,h/* *0.9*/), wall_size), vec4(vec3(1), 0), false));\n    vec2 vv0 = b.center.xy - b.extent.xy - vec2(v);\n    vec2 vv1 = b.center.xy + b.extent.xy - vec2(v);\n    vec2 w0 = b.center.zw - b.extent.zw - vec2(v);\n    vec2 w1 = b.center.zw + b.extent.zw - vec2(v);\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y), h), vec4(vec3(1),0), false));\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y)+0.05, 0.01), vec4(vec3(0.25),0), false));\n    \n/*\n    float cyl =\n        min\n        (\n            min\n            (\n                cylinder(l-vec3(v0.xy,0), h, 0.1),\n                cylinder(l-vec3(v1.xy,0), h, 0.1)\n            ),\n            min\n            (\n                cylinder(l-vec3(v0.x, v1.y,0), h, 0.1),\n                cylinder(l-vec3(v1.x, v0.y,0), h, 0.1)\n            )\n        );\n    res.dist = min(res.dist, cyl);\n*/\n    //if(true){{\n    if(!b.flag){{\n            vec3 c = vec3(vv1.x+w1.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv0.x+w0.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}else{{\n            vec3 c = vec3(vv0.x+w0.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv1.x+w1.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = combine(res, result(make_cuboid_grid(l-vec3(0,0,h*0.6), 0.05, 0.005), vec4(vec3(0.25),0), false));\n    //res = combine(res, result(l.z, vec3(1))); // floor\n    float f = l.z; // floor\n    float cone_south = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y-b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_north = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y+b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_west = cone(vec3(v,0)+l-vec3(b.center.x-b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_east = cone(vec3(v,0)+l-vec3(b.center.x+b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    //res.dist = min(res.dist, cone0);\n    f = fOpUnionStairs(f, min(min(cone_south, cone_east), min(cone_north, cone_west)), h, 10.0);\n    res = combine(res, result(f, vec4(1.-colorize(b.id), 1), true)); // floor\n    return res;}\n    \n#ifdef HIGH_QUALITY\n//for correct AO, we must sample 2x2x2 voxels, much slower\nresult map(vec3 p){\n    // I think kastorp originally suggested to sample only 2x2x2 instead of 3x3x3, thanks!\n    result d = result(DIST_MAX, vec4(vec3(0),0), false);\n    ivec2 s = ivec2(step(0.5, fract(p.xy)));\n    ivec2 o;\n    for(o.y = s.y-1; o.y < s.y+1; o.y++)\n        for(o.x = s.x-1; o.x < s.x+1; o.x++){\n            result r = map(ivec2(floor(p.xy))+o, vec3(fract(p.xy), p.z)-vec3(o,0));\n            if(r.dist < d.dist)\n                d = r;\n    }return d;}\n#else\n//much less taps \nresult map(vec3 p){return map(ivec2(floor(p.xy)), vec3(fract(p.xy), p.z));}\n#endif\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p){\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy*map(p + k.xyy*h).dist +\n                     k.yyx*map(p + k.yyx*h).dist +\n                     k.yxy*map(p + k.yxy*h).dist +\n                     k.xxx*map(p + k.xxx*h).dist);}\n\n// NOTE: Apparently sign fails on some systems! Thanks to spalmer for debugging this!\n// WORKAROUND FOR COMPILER ERROR on some systems\nvec2 sgn(vec2 v){return step(vec2(0), v) * 2.0 - 1.0;}\n\nresult trace(vec3 ro, vec3 rd, float t0, float t1){ // ray-march sdf handling discontinuities between voxels  (jt)\n    result h;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++) { // finite loop originally suggested by pyBlob to avoid stalling if ray parallel to surface just above EPSILON\n        vec3 p = ro + rd * t;\n        h = map(p);\n        if(h.dist < EPSILON)return result(t, h.color_specular, h.flag);\n\n        // NOTE: An extra step per block, use if sdf discontinuous between blocks\n        //       Could make this conditional by prefixing sth. like if(block_changed) // suggested by spalmer\n        // constrain step to blocks (voxel-snap ray-march plugin by jt, thanks to Shane for the idea!)\n        {\n            block b = blocks_layout(ivec2(floor(p.xy)), fract(p.xy));\n            // NOTE: assuming unit grid\n            // sgn(rd)*extent are the block walls in ray direction, fract(p) - center is position relative to center of block\n            //vec2 sd = (sgn(rd.xy)*b.extent.xy - (fract(p.xy) - (b.center.xy-floor(p.xy))))/rd.xy; // distances to block sides / walls\n            vec2 sd = (sgn(rd.xy)*b.extent.xy - p.xy + b.center.xy)/rd.xy; // distances to block sides / walls\n            vec2 n = step(sd.xy, sd.yx); // component true if corresponding wall is nearest (at most one component true) NOTE: originally I used lessThanEqual, min from fb39ca4/kzy then switched to step, min by iq\n            float skip = dot(sd, n) + EPSILON; // distance to next block: sum up all components, weighted by the nearest flag (assuming only one component is true this selects the nearest component)\n            h.dist = min(h.dist, skip); // constrain step to at most next block to handle sdf discontinuities between voxels\n        }t += h.dist;}\n    return result(t, h.color_specular, h.flag);} \n    // stop on running out of iterations\n    //return result(t1, vec4(0), false); // pass on running out of iterations\n\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\n//       Thanks to spalmer for pointing that out.\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1){\n    return trace(ro, rd, t0, t1).dist < t1 ? 0.0 : 1.0;}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k){\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)    {\n        float h = map(ro + rd*t).dist;\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }return res;}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).dist;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;}\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );}\n\nfloat checker(vec2 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi));}\n\nfloat checker(vec3 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi)*sin(p.z*pi));}\n\nvec3 material(vec3 p){\n    //return vec3(1.0-pow(0.5+0.5*sin(p.z*pi*10.0), 50.0))\n    return vec3(1.0)\n    //return mix(vec3(0.25), vec3(0.75), checker(p*2.0+0.5))\n;}\n\nvec3 sky(vec3 lightdir, vec3 d){// no particular meaning - just tweaked until it looks skyish\n    float v = 0.5*abs(d.z)+0.5;\n    return vec3(pow(1.0-v,2.0),1.0-v,v);}\n\n\nfloat sun(vec3 lightdir, vec3 rd){// sun with halo\n    float d = max(0.0, dot(rd, lightdir));\n    return smoothstep(0.998, 0.999, d) + exp(-pow((1.0-d)*500.0, 2.0));} \n\n\nvec3 pass(vec3 ro, vec3 rd, result r){\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,1),abs(-rd.z));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,0.5),sqrt(abs(rd.z)));\n    vec3 sky_color = sky(lightdir, rd);\n    sky_color += sun(lightdir, rd);\n    vec3 color = vec3(1);\n    if(r.dist < DIST_MAX){\n        color *= r.color_specular.xyz;\n        vec3 dst = ro + rd * r.dist;\n        vec3 n = normal(dst);\n        //color *= (n * 0.5 + 0.5);\n        //color *= material(dst);\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * r.dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0){\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular * r.color_specular.w;}\n\n        vec3 fog_color = sky_color;\n        color = mix(fog_color, vec3(color), exp(-pow(r.dist/20.0, 2.0))); // fog\n    }else{\n        color *= sky_color;\n    }return color;}\n\nfloat grey(vec3 color){return dot(color, vec3(1.0/3.0));}\n\nvoid scene2(vec3 ro, vec3 rd, inout vec4 fragColor){\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma\n\n\n//#define     noQuaterionCam_Use_DsKBDw_instead\n\n#ifdef        noQuaterionCam_Use_DsKBDw_instead\n//https://www.shadertoy.com/view/DsKBDw , modified to remain functional as \n//mainImage() instead of mainImage2()\n//while using a subroutine to work merged with quaternionCameras of\n//https://www.shadertoy.com/view/wtdyRs (oldest)\n//https://www.shadertoy.com/view/DsKBDw (newer)\nvoid mainImage(out vec4 fragColor, vec2 I){\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    //I = (4.0 * floor(I * 0.5) + 2.0 - R) / R.y; // integrated pixelize (speedup & looks cool) thanks to spalmer\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0));\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    ro.z += 0.0;\n    \n    scene2(ro,rd,fragColor);}\n    /*\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma*/\n\n#else\n\n//quaternion camera control canvas\nconst float FOV=1.;\nvoid mainImage(out v3 O,v1 U\n){vec4 q=get(camA0) //get camera rotation as quaternion\n ;mat3 cam=q2m(q)   //camera matrix from camera quaternion.\n ;vec2 uv=(U-0.5*iResolution.xy)/iResolution.y //scale uv to range [-1..1]\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))//rayDirection for uv from camera matrix \n ;vec3 ro=get(camP0).xyz\n \n //alternative scene of parent shader https://www.shadertoy.com/view/DsKBDw\n //kept here as example on how to modiy a shader to fit in here.\n //;O=v3(scene(ro,rd),1);//tracing a triangle,bend up+down by 3 sides, that are flat-triangle-orthogonal quadratic-beziers.\n //;return;\n \n //make a scene(rayorigin,raydirection) or scene2(rayorigin,raydirection,fragColor) function\n //that returns a fragment color for uv.xy[-1..1] \n ;vec4 fragColor=vec4(1);\n scene2(get(camP0).xyz,rd,fragColor);\n O.xyz=fragColor.xyz;\n ;} \n \n#endif", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1570, 1570, 1608, 1608, 1697], [1750, 1750, 1778, 1778, 2110], [2142, 2142, 2180, 2258, 2550]], "test": "untested"}
{"id": "dsVfDw", "name": "lineDither", "author": "natet", "description": "Dithering with line thicknesses", "tags": ["dithering"], "likes": 0, "viewed": 238, "published": 3, "date": "1698297185", "time_retrieved": "2024-07-30T17:25:59.562601", "image_code": "//const float gridSize = iResolution.x*0.1;\n\nbool compare(float a, float b, float eta){\n    if(a > (b-eta) && a < (b+eta)){\n        return true;\n    } else {\n        return false;\n    }\n    \n}\n\nbool boxTest(vec2 pos, vec2 size, vec2 uv){\n    if(compare(uv.x,pos.x,size.x) && compare(uv.y,pos.y,size.y)){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float gridSize = iResolution.x*0.05;\n    \n    uv = fract(uv*gridSize);\n    \n    vec4 cam = texture(iChannel0, floor((fragCoord/iResolution.xy)*gridSize)*(1.0/gridSize));\n    \n    float camVal = (cam.x+cam.y+cam.z)/6.0;\n\n    vec3 col;\n    \n    bool box = boxTest(vec2(0.5,0.5),vec2(camVal,1.0), uv);\n\n    // Output to screen\n    if(box){\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.0);\n    }\n    fragColor = vec4(col,1.0);\n        \n}\n", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 87, 87, 192], [194, 194, 237, 237, 367], [369, 369, 426, 476, 972]], "test": "untested"}
{"id": "msVfWw", "name": "Fractal Brown Motion variant 1", "author": "INCHMAN1900", "description": "Fractal Brown Motion variant", "tags": ["noise", "fractalbrownmotion"], "likes": 7, "viewed": 213, "published": 3, "date": "1698291340", "time_retrieved": "2024-07-30T17:26:00.327555", "image_code": "float random(vec2 st) {\n    return fract(sin(dot(st,vec2(397.523,591.5939)))*53426.79);\n}\n\nfloat noise(vec2 st) {\n    vec2 ip = floor(st);\n    vec2 fp = fract(st);\n    \n    float a = random(ip);\n    float b = random(ip + vec2(1., 0.));\n    float c = random(ip + vec2(0., 1.));\n    float d = random(ip + vec2(1., 1.));\n    \n    vec2 u = fp * fp * (3.0 - 2.0 * fp);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 2. - 1.;\n}\n\nfloat fbm(vec2 uv) {\n    int LOOP = 6;\n    float amplitude = 1.5;\n    float frequency = .5;\n    float ag = .5;\n    float fg = 2.;\n    \n    float n = 0.;\n    for (int i = 0; i < LOOP; i++) {\n        n += noise(vec2(uv + n) * frequency + iTime) * amplitude;\n        frequency *= fg;\n        amplitude *= ag;\n    }\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(fbm(uv * 30.)) * vec3(.8, .9, .85);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 89], [91, 91, 113, 113, 428], [430, 430, 450, 450, 757], [759, 759, 816, 816, 991]], "test": "untested"}
{"id": "mdVfWw", "name": "Pristine Grid", "author": "bgolus", "description": "Comparison of the \"pristine grid\" (left) method and iq's box filtered grid (right).\nhttps://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8", "tags": ["procedural", "2d", "grid"], "likes": 53, "viewed": 2273, "published": 3, "date": "1698291101", "time_retrieved": "2024-07-30T17:26:01.296964", "image_code": "// ##############################################################################################\n// ### ben golus ################################################################################\n// ##############################################################################################\n\n// This is a fork of iq's box filtered grid shadertoy to show a comparison between my\n// \"pristine grid\" and his implementation. His shader remains mostly untouched save a few minor\n// edits.\n// \n// * Closest sphere has been removed (actually just moved out of view).\n// * Inverted from black lines on white to white lines on black to make aliasing easier to see.\n//\n\n// Pristine grid from The Best Darn Grid Shader (yet)\n// https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8\n\nfloat pristineGrid( in vec2 uv, vec2 lineWidth)\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 uvDeriv = vec2(length(vec2(ddx.x, ddy.x)), length(vec2(ddx.y, ddy.y)));\n    bvec2 invertLine = bvec2(lineWidth.x > 0.5, lineWidth.y > 0.5);\n    vec2 targetWidth = vec2(\n      invertLine.x ? 1.0 - lineWidth.x : lineWidth.x,\n      invertLine.y ? 1.0 - lineWidth.y : lineWidth.y\n      );\n    vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n    vec2 lineAA = uvDeriv * 1.5;\n    vec2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n    gridUV.x = invertLine.x ? gridUV.x : 1.0 - gridUV.x;\n    gridUV.y = invertLine.y ? gridUV.y : 1.0 - gridUV.y;\n    vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n    grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n    grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\n    grid2.x = invertLine.x ? 1.0 - grid2.x : grid2.x;\n    grid2.y = invertLine.y ? 1.0 - grid2.y : grid2.y;\n    return mix(grid2.x, 1.0, grid2.y);\n}\n\n// version with explicit gradients for use with raycast shaders like this one\nfloat pristineGrid( in vec2 uv, in vec2 ddx, in vec2 ddy, vec2 lineWidth)\n{\n    vec2 uvDeriv = vec2(length(vec2(ddx.x, ddy.x)), length(vec2(ddx.y, ddy.y)));\n    bvec2 invertLine = bvec2(lineWidth.x > 0.5, lineWidth.y > 0.5);\n    vec2 targetWidth = vec2(\n      invertLine.x ? 1.0 - lineWidth.x : lineWidth.x,\n      invertLine.y ? 1.0 - lineWidth.y : lineWidth.y\n      );\n    vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n    vec2 lineAA = uvDeriv * 1.5;\n    vec2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n    gridUV.x = invertLine.x ? gridUV.x : 1.0 - gridUV.x;\n    gridUV.y = invertLine.y ? gridUV.y : 1.0 - gridUV.y;\n    vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n    grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n    grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\n    grid2.x = invertLine.x ? 1.0 - grid2.x : grid2.x;\n    grid2.y = invertLine.y ? 1.0 - grid2.y : grid2.y;\n    return mix(grid2.x, 1.0, grid2.y);\n}\n\n// comment this line out to see original black lines on white\n#define INVERT_MAT\n\n#ifdef INVERT_MAT\n#define BACKGROUND_VAL 0.0\n#else\n#define BACKGROUND_VAL 0.9\n#endif\n\n// ##############################################################################################\n// ##############################################################################################\n\n\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analiyically filtering a grid pattern (ie, not using supersampling or mipmapping.\n//\n// Info: https://iquilezles.org/articles/filterableprocedurals\n//  \n// More filtered patterns:  https://www.shadertoy.com/playlist/l3KXR1\n\n\n// --- analytically box-filtered grid ---\n\nconst float N = 10.0; // grid ratio\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n\t// filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  3.0,-2.5, 0.0, 0.0 );\nconst vec4 sc1 = vec4( -4.0, 2.0,-5.0, 2.0 );\nconst vec4 sc2 = vec4( -4.0, 2.0, 5.0, 2.0 );\nconst vec4 sc3 = vec4(-30.0, 8.0, 0.0, 8.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out int matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n    matid = -1;\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc1.xyz); \n\t\tmatid = 2;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc2.xyz); \n\t\tmatid = 3;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc3.xyz); \n\t\tmatid = 4;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec2 texCoords( in vec3 pos, int mid )\n{\n    vec2 matuv;\n    \n    if( mid==0 )\n    {\n        matuv = pos.xz;\n    }\n    else if( mid==1 )\n    {\n        vec3 q = normalize( pos - sc0.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n    }\n    else if( mid==2 )\n    {\n        vec3 q = normalize( pos - sc1.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc1.w;\n    }\n    else if( mid==3 )\n    {\n        vec3 q = normalize( pos - sc2.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc2.w;\n    }\n    else if( mid==4 )\n    {\n        vec3 q = normalize( pos - sc3.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc3.w;\n    }\n\n\treturn 8.0*matuv;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*sin(0.1*iTime);\n\tro = vec3( 5.0*cos(an), 0.5, 5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (2.0*pix-iResolution.xy) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 0.0;\n    \n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ;\n    int mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(BACKGROUND_VAL);\n\tif( mid!=-1 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = texCoords(     pos, mid );\n\t\tvec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;\n\t\tvec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytracer.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = texCoords( pos, mid );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\n        if( p.x<th ) mate = vec3(1.0)*(1.0 - pristineGrid( uv - vec2(0.05), ddx_uv, ddy_uv, vec2(1.0/N) ));\n        else         mate = vec3(1.0)*gridTextureGradBox( uv, ddx_uv, ddy_uv );\n        \n#ifdef INVERT_MAT\n        mate = 1.0 - mate;\n#endif\n            \n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(BACKGROUND_VAL), 1.0-exp( -0.00001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 1.0, 2.0, abs(p.x-th)/(2.0/iResolution.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[790, 790, 839, 839, 1794], [1796, 1874, 1949, 1949, 2854], [4594, 4608, 4673, 4691, 4992], [5412, 5412, 5475, 5475, 5698], [5700, 5700, 5758, 5758, 5866], [5868, 5868, 5922, 5922, 6108], [6709, 6709, 6804, 6820, 7918], [7920, 7920, 7960, 7960, 8600], [8603, 8603, 8648, 8648, 8759], [8761, 8761, 8832, 8832, 9389], [9793, 9793, 9862, 9862, 10232], [10234, 10234, 10291, 10291, 12749]], "test": "untested"}
{"id": "DdKBDw", "name": "Tonemapping comparisons", "author": "fishy", "description": "An experiment in tonemapping", "tags": ["color", "tonemapping", "tonemapper", "tonemap", "aces", "tmo"], "likes": 2, "viewed": 178, "published": 3, "date": "1698288135", "time_retrieved": "2024-07-30T17:26:02.051945", "image_code": "/*\n    Comparison of global tonemapping operators.\n    \n    Mouse to select an operator to show larger on top. Click on the red circle to\n    return.\n    \n    Options:\n        HUE_MODE:\n            When 0, instead of mapping the sine wave from -1 to 1 to 0 to 1,\n            it clips at 0 creating a sort of \"worst case\" for the Reinhard\n            operator which operatres purely per-component, making fully saturated values of\n            red, green, or blue look bad.\n            When 1, it maps the -1 to 1 range to 0 to 1 \"properly\"\n        \n        SHOW_MORE:\n            Show more operators\n        \n        IMAGE:\n            Instead of a rainbow, show a psychedelic oil-slick-like moving image\n    \n    From left to right:\n        when SHOW_MORE = 0:\n        Clipped values:\n            The simplest tonemapping operator which is no tonemapping operator, it just\n            clips values above 1 to 1 per-component.\n        Reinhard\n            Another simple tonemapping operator, this time performing the operation\n            x / (1.0 + x) per component.\n        ACES\n            From https://www.shadertoy.com/view/XsGfWV. Looks great!\n        My tonemapping operator\n            ACES-like.\n            Each component going out is a combination of the three, allowing proper desaturation\n            when used in combination with a Reinhard operator.\n            I think the blue and green components also desaturate in a nicer looking manner,\n            as the blue doesn't turn purple. Might also be cheaper as it only involves a single\n            matrix multiplication rather than the two the ACES tonemapper uses to transform from\n            RGB to XYZ and back. Also includes a contrast adjustment at the end to make it look\n            more like the ACES operator.\n            Plus, if you want to adjust the look, you can do so by changing the values in the\n            matrix.\n\n        when SHOW_MORE = 1:\n            Clipped values\n            Reinhard\n            Reinhard extended(?)\n                Instead of dividing by the components divide by the luminance\n            ACES\n            My tonemapping operator\n            Reinhard ACES\n                Like Reinhard but it mixes toward the luminance to achieve a similar look to ACES.\n                Also made by me.\n                Doesn't look super great IMO, might even be more expensive than the other one I\n                made.\n    \n    Also I didn't mean for this to become so large oops 😞\n*/\n\n#define HUE_MODE 0\n#define SHOW_MORE 0\n//#define IMAGE\n\n#define lum(x) dot(x, vec3(0.2126, 0.7152, 0.0722))\n\nvec3 gamma(vec3 c)\n{\n    return pow(c, vec3(0.4545));\n}\n\nvec3 clip(vec3 c)\n{\n    return clamp(c, 0.0, 1.0);\n}\n\nvec3 reinhard(vec3 c)\n{\n    return c / (1.0 + c);\n}\n\nvec3 reinhardExtended(vec3 c)\n{\n    return c / (1.0 + lum(c));\n}\n\nvec3 aces(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn clamp(m2 * (a / b), 0.0, 1.0);\t\n}\n\nvec3 reinhardAces(vec3 c)\n{\n    c = pow(c, vec3(1.5));\n    vec3 g = vec3(lum(c));\n    c = mix(g / (g + 1.0), c / (c + 1.0), exp2(-g*0.2));\n    return c;\n}\n\nvec3 reinhardSpill(vec3 c)\n{\n    c *= mat3(vec3(1.000, 0.100, 0.025),\n              vec3(0.075, 1.000, 0.050),\n              vec3(0.030, 0.050, 1.000));\n    c = 1.0 - exp(-c * 1.0);\n    return 3.0*c*c-2.0*c*c*c;\n}\n\nvec3 hue(float x)\n{\n#if HUE_MODE == 0\n    return max(vec3(0), sin((x+0.125+vec3(0.0, 0.33, 0.66)) * 6.2832));\n#else\n    return pow(sin((x+0.125+vec3(0.0, 0.33, 0.66)) * 6.2832)*0.5+0.5, vec3(3));\n#endif\n}\n\n#define TMO(a, f) case a: c = f (c); break;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n#if SHOW_MORE == 0\n#define TMO_COUNT 3.0\n#else\n#define TMO_COUNT 5.0\n#endif\n    \n#ifdef IMAGE\n    vec3 c = hue(noise(uv, iTime)*5.0) / pow(abs(uv.y-0.5)*5.0, 2.0);\n#else\n    vec3 c = hue(uv.x*TMO_COUNT+iTime*0.2);\n#endif\n    float v = abs(uv.y*2.0-1.0);\n    c /= v/(1.0-v);\n    int tmo = int(fract(uv.x)*(TMO_COUNT+1.0));\n    if(length(iMouse.xy) > 20.0 && uv.y > 0.5)\n    {\n        tmo = int(fract(m.x)*(TMO_COUNT+1.0));\n    }\n    \n    switch(tmo)\n    {\n        TMO(0, clip);\n#if SHOW_MORE == 1\n        TMO(1, reinhard)\n        TMO(2, reinhardExtended)\n        TMO(3, aces)\n        TMO(4, reinhardSpill)\n        TMO(5, reinhardAces)\n#else\n        TMO(1, reinhard)\n        TMO(2, aces)\n        TMO(3, reinhardSpill)\n#endif\n    }\n    \n    c = mix(c, vec3(1, 0, 0), smoothstep(20.0, 18.0, length(fragCoord.xy)));\n    fragColor = vec4(gamma(c),1.0);\n}", "image_inputs": [], "common_code": "// Noise taken from https://www.shadertoy.com/view/Nl3BRM (mine)\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    vec2 tlVal = hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat noise(vec2 uv, float t)\n{\n    uv *= 0.1;\n\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 100.0, 1.0, 1.0);\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 100.0, 1.0, 1.0);\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 10.0,  1.0, 1.0);\n    uv.x += fbm((uv + t*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + t*0.01) * 1.0 + 100.0,  1.0, 1.0)*5.0;\n\n    float value = fbm(uv * 20.0, 1.0, 1.0);\n\n    return value;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2598, 2598, 2618, 2618, 2653], [2655, 2655, 2674, 2674, 2707], [2709, 2709, 2732, 2732, 2760], [2762, 2762, 2793, 2793, 2826], [2828, 2828, 2850, 2850, 3271], [3273, 3273, 3300, 3300, 3427], [3429, 3429, 3457, 3457, 3642], [3644, 3644, 3663, 3663, 3848]], "test": "untested"}
{"id": "mdKfWw", "name": "fff---test", "author": "xxvxx", "description": "wqeqwe", "tags": ["test", "fff"], "likes": 7, "viewed": 428, "published": 3, "date": "1698286874", "time_retrieved": "2024-07-30T17:26:02.895689", "image_code": "\n#if HW_PERFORMANCE==0\n#define VIS_SAMPLES 1\n#else\n#define VIS_SAMPLES 4\n#endif\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\nfloat hash1( vec2  n ) { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nvec2  hash2( float n ) { return fract(43758.5453123*sin(vec2(n,n+1.0))); }\n\nfloat gAnimTime;\n\nfloat map( vec2 p ) \n{\n\tfloat f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;\n\tf *= sqrt( textureLod( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0, 0.0 ).x );\n\treturn 22.0*f;\n}\n\nvec3 calcNormal( in vec3 pos, in float ic )\n{\n\treturn mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\t\n\tvec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );\n\n    // traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<200; i++ ) \n\t{\n\n\t\tfloat ma = map(pos);\n\t\t\n        // intersect capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n            // cylinder\t\t\t\n\t\t\tfloat s = (-b - sqrt( h ))/a;\n\t\t\tif( s>0.0 && (ro.y+s*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = vec4( s, 0.0, pos );\n    \t\t\tbreak; \n\t\t\t}\n            // cap\t\t\t\n\t\t\ts = (ma - ro.y)/rd.y;\n\t\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t\t{\n\t\t\t\tres = vec4( s, 1.0, pos );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n        // step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\n\treturn res;\n}\n\nfloat castShadowRay( in vec3 ro, in vec3 rd )\n{\n\tvec2 pos = floor(ro.xz);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\tfloat t = -1.0;\n\tfloat res = 1.0;\n\t\n    // first step we check noching\t\n\tvec2 mm = step( dis.xy, dis.yx ); \n\tdis += mm * ris;\n    pos += mm * rs;\n\t\n    // traverse regular grid (2D)\t\n\tfor( int i=0; i<6; i++ ) \n\t{\n\t\tfloat ma = map(pos);\n\t\t\n        // test capped cylinder\t\t\n\t\tvec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );\n\t\tvec3  rc = ro - ce;\n\t\tfloat a = dot( rd.xz, rd.xz );\n\t\tfloat b = dot( rc.xz, rd.xz );\n\t\tfloat c = dot( rc.xz, rc.xz ) - 0.249;\n\t\tfloat h = b*b - a*c;\n\t\tif( h>=0.0 )\n\t\t{\n\t\t\tfloat t = (-b - sqrt( h ))/a;\n\t\t\tif( (ro.y+t*rd.y)<ma )\n\t\t\t{\n\t\t\t\tres = 0.0;\n    \t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm * ris;\n        pos += mm * rs;\n\t}\n\n\treturn res;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 200.0*sin( 0.01*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p += 100.0*sin( 0.02*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 15.0 + 4.0*sin(0.05*t);\n\t\n\t// collision\n\tfloat h;\n\th  = map( p+vec2(-1.0, 0.0) );\n\th += map( p+vec2( 1.0, 0.0) );\n\th += map( p+vec2( 0.0, 1.0) );\n\th += map( p+vec2( 0.0,-1.0) );\n\th /= 4.0;\n\th += 5.0;\n\ty = max( y, h );\n\n\treturn vec3( p.x, y, p.y );\n}\n\nvec4 texcyl( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, vec2(p.y,0.5+0.5*atan(n.x,n.z)/3.14) );\n\tvec4 y = texture( sam, p.xz );\n\treturn mix( x, y, abs(n.y) );\n}\n\nconst vec3 lig = normalize(vec3(-0.7,0.25,0.6));\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\t\n    float sun = clamp( dot( rd, lig ), 0.0, 1.0 );\n\n    vec3 bgcol = vec3(0.9,1.0,1.0) + 0.3*pow(sun,4.0);\n\n    // raytrace\n    vec3 col = bgcol;\n    vec4 res = raycast( ro, rd );\n    vec2 vos = res.zw;\n    float t = res.x;\n    if( t>0.0 )\n    {\n        vec3  pos = ro + rd*t;\n        float id  = hash1( vos );\n        vec3  nor = calcNormal( fract(pos)-0.5, res.y );\n        float h = map(vos);\n\n        // material color\t\t\t\n        vec3 mate = 0.55 + 0.45*sin( 2.0*id + 1.8 + vec3(0.0,0.5,1.0) );\n\n        vec3 uvw = pos - vec3(0.0,h,0.0);\n        vec3 tex = texcyl( iChannel3, 0.2*uvw + 13.1*hash1(id), nor ).xyz;\n        mate *= 0.2+4.0*tex*tex;\n        mate *= 0.02 + 0.98*smoothstep( 0.1,0.11, hash1(id) );\t\n\n        // material cheap/wrong bump\t\t\t \n        //vec3 bn = -1.0 + 2.0*texcyl( iChannel1, 0.2*uvw*vec3(1.0,0.2,1.0) + 13.1*hash1(id), nor ).xyz;\n        //nor = normalize(nor + 0.3*bn*(1.0-0.5*nor.y) );\n\n        // procedural occlusion\n        float occ = nor.y*0.75;\n        occ += 0.5*clamp( nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 1.0, 0.0)) );\n        occ += 0.5*clamp(-nor.x,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2(-1.0, 0.0)) );\n        occ += 0.5*clamp( nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0, 1.0)) );\n        occ += 0.5*clamp(-nor.z,0.0,1.0)*smoothstep( -0.5, 0.5, pos.y-map(vos+vec2( 0.0,-1.0)) );\n        occ = 0.2 + 0.8*occ;\n        occ *= pow( clamp((0.1+pos.y)/(0.1+map(floor(pos.xz))),0.0,1.0),2.0);\n        occ = occ*0.5+0.5*occ*occ;\n        float rim = pow( clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),5.0 );\n\n        //-------------\n        // lighitng\n        //-------------\n        float amb = 1.0;\n        //-------------\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z)) ), 0.0, 1.0 ) * clamp(1.0-pos.y/20.0,0.0,1.0);;\n        //-------------\n        float dif = dot( nor, lig );\n        if( dif>0.0 ) dif *= castShadowRay( pos, lig );\n        dif = max( dif, 0.0 );\n        float spe = pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0 ),3.0 );\n        //-------------\n        vec3 lin  = 3.00*vec3(1.0,1.0,1.0)*dif;\n             lin += 0.80*vec3(0.4,1.0,1.7)*amb*occ;\n             lin += 0.30*vec3(0.8,0.5,0.3)*bac*occ;\n\n        col = mate*lin + tex.x*1.5*(0.3+0.7*rim)*spe*dif;\n\n        // fog\n        float ff = 1.0 - smoothstep( 0.0, 1.0, pow(t/160.0,1.8) );\n        col = mix( col, bgcol, 1.0-ff );\n        \n    }\n    col += 0.2*pow(sun,8.0)*vec3(1.0,0.7,0.2);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\t\n    gAnimTime = iTime;\n    \n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n    #if VIS_SAMPLES<2\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 4.0*iTime + 50.0*mo.x;\n    #else\n\tfor( int a=0; a<VIS_SAMPLES; a++ )\n\t{\n\t\tvec4 rr = texture( iChannel1, (fragCoord.xy+floor(256.0*hash2(float(a))))/iChannelResolution[1].xy );\n        vec2 p = -1.0 + 2.0*(fragCoord.xy+rr.xz) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n\t\t#if VIS_SAMPLES>3\n        float time = 4.0*(iTime + 1.0*(0.4/24.0)*rr.w) + 50.0*mo.x;\n\t\t#else\n        float time = 4.0*(iTime) + 50.0*mo.x;\n\t\t#endif\n    #endif\t\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time+5.0 ); ta.y = ro.y - 5.5;\n        float cr = 0.2*cos(0.1*time*0.5);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        // dof\n        #if VIS_SAMPLES>2\n        vec3 fp = ro + rd * 17.0;\n        ro += (uu*(-1.0+2.0*rr.y) + vv*(-1.0+2.0*rr.w))*0.035;\n        rd = normalize( fp - ro );\n        #endif\n\n        // render\n        vec3 col = render( ro, rd );\n        \n\t\ttot += col;\n\t}\n\ttot /= float(VIS_SAMPLES);\n\n    // tone mapping\t\t\t\n    tot = tot*1.2/(1.0+tot);\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    tot = tot*tot*(3.0-2.0*tot);\n    \n\t// vignetting\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( tot, 1.0 );\n}    \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 cam = cameraPath( iTime );\n\n    gAnimTime = iTime*0.2;\n\n    vec3 ro = fragRayOri + cam + vec3(0.0,-2.0,0.0);\n    vec3 rd = fragRayDir*vec3(-1.0,1.0,-1.0);\n    vec3 col = render( ro, rd );\n\n    // gamma\t\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.44) );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 105, 105, 143], [144, 144, 168, 168, 227], [228, 228, 252, 252, 302], [322, 322, 344, 344, 511], [513, 513, 558, 558, 632], [634, 634, 674, 674, 1646], [1648, 1648, 1695, 1695, 2520], [2522, 2522, 2550, 2574, 2962], [2964, 2964, 3016, 3016, 3145], [3197, 3197, 3236, 3261, 5748]], "test": "untested"}
{"id": "mdGfDw", "name": "Chladni ispired pattern 2", "author": "GianC", "description": "Psychedelic Chladni ispired pattern", "tags": ["chlandni"], "likes": 2, "viewed": 125, "published": 3, "date": "1698265524", "time_retrieved": "2024-07-30T17:26:03.734446", "image_code": "#define PI 3.14159265359\nfloat modFloat(float a, float b) {\n  return a - b * floor(a / b);\n}\nvec4 invertColor(vec4 color) {\n    return vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, color.a);\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.0, 0.5*t, 0.5);\n    vec3 b = vec3(0.0, 0.5, 0.5*t);\n    vec3 c = vec3(0.2*t, 0.4*t, 0.1*t);\n    vec3 d = vec3(0.26,0.516,0.357);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n      vec2 uv0 = uv;\n\n    uv=fract(uv)-0.5;\n    float t=iTime/1.0;\n    for (float i = 0.0; i < 3.0; i++) {\n    float n= PI*(4.0+15.0*sin(t/20.0)*cos(t/10.0)+fragCoord[0]/50.0*cos(fragCoord[0]/50.0+t));\n    float m=PI*(2.0+12.0*sin(t/10.0)*cos(t/10.0)+fragCoord[1]/20.0*cos(t/10.0)*sin(fragCoord[0]/50.0+t/20.0));\n    float v= cos(n*uv0.x)* cos(m*uv0.y) - cos(m*uv0.x) *cos(n*uv0.y);\n    float th=step(0.1,v);\n    \n    // Time varying pixel color\n    vec3 col = palette(v);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n        invertColor(fragColor);\n}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 59, 59, 92], [93, 93, 123, 123, 196], [197, 197, 222, 222, 415], [417, 417, 474, 525, 1149]], "test": "untested"}
{"id": "mdKfDh", "name": "Julia Pentation Fractal Explorer", "author": "domrally", "description": "Click to explore! Uses the same formula as the Julia/Mandelbrot set, but with the pentation hyperoperation. \nn²↑₅ + i = nⁿ↑₄+i instead of n²↑₃ + i = nⁿ↑₂ + i = n*n+i\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "julia", "math", "mandelbrot", "interactive", "orbit", "quadratic", "iteration", "trap", "chaotic", "fractional", "hyperoperation", "pentation"], "likes": 4, "viewed": 149, "published": 3, "date": "1698257412", "time_retrieved": "2024-07-30T17:26:04.485438", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nComplex differential multiplication\n*/\nvec2 M(vec2 a, vec2 b) { \n    return vec2( \n        dot(a, vec2(b.x, -b.y)), \n        dot(a, b.yx)\n    ); \n}\nmat2 M(mat2 a, mat2 b) {\n    return mat2(\n        M(a[0], b[0]),\n        M(a[0], b[1]) + M(a[1], b[0])\n    );\n}\n\n\nvoid mainImage(out vec4 o, vec2 i) {\n    // fixed point f(1 + 0i) = 1 + 0i\n    mat2 z, a = mat2(vec2(1, 0), vec2(0));\n    \n    vec2 w, t, r = iResolution.xy,\n         m = 2. * iMouse.xy - r;\n    \n    // mandelbrot condition\n    z[0] = t = i = (i + i - r) / r.x;\n    // derivative of a variable is 1\n    z[1] = vec2(1);\n    \n    // julia iteration\n    float j, f, k = 9.;\n    for (m /= r.x; j++ < 99.; f < k ? k = f, t = z[0] : t) {\n        // n²↑₅ pentation is n^n^n..., n times.\n        // fractional iteration by taylor\n        // expansion around the fixed point.\n        mat2 c = z - a;\n        z += M(M(c, c), z) \n           + M(M(z, c) * 6. + z * 3.,\n               M(M(c, c), c) / 6.);\n        w = z[0];\n        \n        // controls\n        z[0] += mix(i, m, max(0., sign(iMouse.z)));\n        \n        // escape condition\n        f = dot(z[0], z[0]);\n        if (f > 4.) break;\n    }\n    \n    // proportional to distance\n    float d = log(sqrt(f)) * sqrt(f / dot(z[1], z[1])),\n          // grid\n          g = smoothstep(0., 4., length(cos(w))),\n          // hue angle\n          h = atan(t.y, t.x);\n\n    // color mapping\n    vec3 v = vec3(h - 2.1, h, h + 2.1);\n    \n    o = vec4(.5 + .5 * cos(v), 1.);\n    o = smoothstep(.1, .0, o * d + .1 * g);\n}\n\n\n/*\nREFERENCES\n\ndomain warping\n\ngcgac 2022\nhttps://www.shadertoy.com/view/NtyfWD\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n\nrefactoring\n\nshadertoyjiang & FabriceNeyret2 2023\nhttps://www.shadertoy.com/view/DdcBWX\n\nSnoopethDuckDuck 2023\nhttps://www.shadertoy.com/view/cs3BRj\n*/\n\n\n/*\nFURTHER READING\n\nhyperoperations\n\nhttps://en.wikipedia.org/wiki/Pentation\nhttps://en.wikipedia.org/wiki/Iterated_function#Fractional_iterates_and_flows,_and_negative_iterates\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Spectral_sensitivity\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 69, 93, 93, 177], [178, 178, 202, 202, 289], [292, 292, 328, 366, 1550]], "test": "untested"}
{"id": "ddVBDD", "name": "Fractal Brown Motion Variant", "author": "INCHMAN1900", "description": "Fractal Brown Motion variant", "tags": ["noise", "fractalbrownmotion"], "likes": 0, "viewed": 153, "published": 3, "date": "1698251203", "time_retrieved": "2024-07-30T17:26:05.242415", "image_code": "float random(vec2 st) {\n    return fract(sin(dot(st,vec2(397.523,591.5939)))*53426.79);\n}\n\nfloat noise(vec2 st) {\n    vec2 ip = floor(st);\n    vec2 fp = fract(st);\n    \n    float a = random(ip);\n    float b = random(ip + vec2(1., 0.));\n    float c = random(ip + vec2(0., 1.));\n    float d = random(ip + vec2(1., 1.));\n    \n    vec2 u = fp * fp * (3.0 - 2.0 * fp);\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 2. - 1.;\n}\n\nfloat fractalBrownMotion(vec2 uv) {\n    float n = abs(noise(vec2(uv.x, noise(uv) * 30. + iTime)));\n    return pow(1. - n, 3.) * 1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(fractalBrownMotion(uv*6.)) * vec3(noise(uv) + .8, .9, .9);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 89], [91, 91, 113, 113, 428], [430, 430, 465, 465, 564], [566, 566, 623, 623, 821]], "test": "untested"}
{"id": "ddVBDW", "name": "simplest vignette", "author": "jcyuan", "description": "a basic material for complex proj", "tags": ["vignette", "material"], "likes": 3, "viewed": 147, "published": 3, "date": "1698246516", "time_retrieved": "2024-07-30T17:26:06.064217", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float edge = .5 + .5 * pow(clamp(15. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), 0., 1.), .2);\n    \n    fragColor = vec4(vec3(edge), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddVBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 241]], "test": "untested"}
{"id": "DsKfDW", "name": "Siri Audio Wave", "author": "Peace", "description": "Siri wave", "tags": ["wave", "visualization", "audio", "siri"], "likes": 3, "viewed": 89, "published": 3, "date": "1698244669", "time_retrieved": "2024-07-30T17:26:06.958825", "image_code": " float gradient(float p)\n{\n    vec2 p0 = vec2(0.0,0.0);\n    vec2 p1 = vec2(0.7,0.1);\n    vec2 p2 = vec2(0.9,0.4);\n    vec2 p3 = vec2(0.99,1.25);\n    vec2 p4 = vec2(1.0,0.0);\n    if (p < p0.x) return p0.y;\n    if (p < p1.x) return mix(p0.y, p1.y, (p-p0.x) / (p1.x-p0.x));\n    if (p < p2.x) return mix(p1.y, p2.y, (p-p1.x) / (p2.x-p1.x));\n    if (p < p3.x) return mix(p2.y, p3.y, (p-p2.x) / (p3.x-p2.x));\n    if (p < p4.x) return mix(p3.y, p4.y, (p-p3.x) / (p4.x-p3.x));\n    return p4.y;\n}\n\nfloat waveN(vec2 uv, float a, vec2 s, vec2 t, vec2 f, vec2 h)\n{\n    float x = uv.x * 4.0 - 2.0;\n    x = exp(-x * x);\n    vec2 x1 = sin((iTime * 2.0 * s + t + uv.x) * f) * h * x * 2.0 * a;\n\n    float g = gradient(uv.y / (0.5 + x1.x + x1.y));\n    \n\treturn g * 0.25 * x;\n}\n\nfloat wave1(vec2 uv, float a)\n{\n    return waveN(uv, a, vec2(0.03,0.06), vec2(0.00,0.02), vec2(8.0,3.7), vec2(0.06,0.05));\n}\n\nfloat wave2(vec2 uv, float a)\n{\n    return waveN(uv, a, vec2(0.04,0.07), vec2(0.16,-0.37), vec2(6.7,2.89), vec2(0.06,0.05));\n}\n\nfloat wave3(vec2 uv, float a)\n{\n    return waveN(uv, a, vec2(0.035,0.055), vec2(-0.09,0.27), vec2(7.4,2.51), vec2(0.06,0.05));\n}\n\nfloat wave4(vec2 uv, float a)\n{\n    return waveN(uv, a, vec2(0.032,0.09), vec2(0.08,-0.22), vec2(6.5,3.89), vec2(0.06,0.05));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float audio = texelFetch(iChannel0, ivec2(0), 0).r;\n    float waves = wave1(uv, audio) + wave2(uv, audio) + wave3(uv, audio) + wave4(uv, audio);\n    \n\tfloat x = uv.x;\n\tfloat y = 1.0 - uv.y;\n    \n    vec3 bg = mix(vec3(0.05,0.05,0.3),vec3(0.1,0.65,0.85), (x+y)*0.55);\n    vec3 ac = vec3(1.0,1.0,1.0) * waves;\n    ac = 1.0 - ac;\n\n    fragColor = vec4(ac, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 487], [489, 489, 552, 552, 758], [760, 760, 791, 791, 884], [886, 886, 917, 917, 1012], [1014, 1014, 1045, 1045, 1142], [1144, 1144, 1175, 1175, 1271], [1273, 1273, 1330, 1330, 1745]], "test": "untested"}
{"id": "msVBWW", "name": "No self-shadowing test", "author": "ianertson", "description": "Shadows with almost no self-shadowing, without using skip id's.", "tags": ["3d", "test", "raymarch", "shadow", "shadows"], "likes": 4, "viewed": 144, "published": 3, "date": "1698244514", "time_retrieved": "2024-07-30T17:26:07.910281", "image_code": "#define R (iResolution.xy)\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n#define ZERO min(0, iFrame)\n#define NEAR 0.003\n#define FAR 32.0\n#define STEPS 100\n#define SHADOW_STEPS 8\n#define AMBIENT 0.07\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1)\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n};\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c);}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat planeSDF(vec3 p, vec2 s) {\n    return max(max(p.y, abs(p.x)-s.x), abs(p.z)-s.y)+\n    0.019*cos(p.x*10.+p.z*10.+iTime*10.) + \n    0.025*sin(p.x+p.z*10.+iTime*10.) + \n    0.025*exp(cos(p.x*p.z*10.+sin(iTime+p.x*3.14+p.z))-1.) - \n    0.025*exp(sin((iTime*2.2)+(p.x*10.-p.z*10.))-1.);\n}\n\n#define ID_BOX 0\n#define ID_GROUND 1\n\nfloat sdf(vec3 p, inout Data data) {\n    float box = boxSDF(pointRot(p - vec3(0, (0.19) + 0.25*(0.5+0.5*sin(iTime)), 0), vec3(iTime, iTime, 0)), vec3(0.1))-0.01;\n    float ground = planeSDF(p, vec2(2, 2));\n    \n    float d = FAR;\n    if (box < d) { d = box; data.id = ID_BOX; }\n    if (ground < d) { d = ground; data.id = ID_GROUND; }\n    \n    return d/1.1;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(d) >= FAR) return false;\n        \n        d += next;\n    }\n    \n    vec3 p = data.p = ro+rd*d;\n    data.d = d;\n    vec2 e = vec2(0.003, 0.0);\n    data.n = normalize(sdf(p, data) - vec3(\n        sdf(p - e.xyy, data),\n        sdf(p - e.yxy, data),\n        sdf(p - e.yyx, data)\n    ));\n    \n    \n    return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, in Data data, in Light light) {\n    vec3 L = normalize(light.p);\n    vec3 N = data.n;\n    ro = data.p + N*NEAR*3.;\n    rd = L;\n    \n    float d = 2.5*max(0.0, -dot(N, L));\n    \n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float r = float(i) / float(SHADOW_STEPS);\n        p += N * (1.0/(1.0 + r))*0.1;\n        float next = sdf(p, data);\n        \n        if (abs(next) <= NEAR || abs(d) >= FAR) break;\n        \n        d += next;\n    }\n    \n    float s = (d / (1.0 + d));\n    return clamp(smoothstep(0.0, 0.5, s*s), AMBIENT*2., 1.0);\n}\n\n\nvec3 getColor(in Data data) {\n    switch (data.id) {\n        case ID_BOX: return vec3(1, 0, 0); break;\n        default: return vec3(1.0); break;\n    }\n    \n    return vec3(1.0);\n}\n\nvec3 forEachLight(vec3 ro, vec3 rd, inout Data data, in Light light) {\n    vec3 L = normalize(light.p);\n    vec3 N = data.n;\n    vec3 ref = reflect(L, N);\n    float NdotL = max(AMBIENT, dot(N, L));\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 16.0);\n    float shadow = NdotL <= (AMBIENT*0.03) ? AMBIENT : getShadow(ro, rd, data, light);\n    vec3 diffuse = getColor(data) / M_PI;\n    return (NdotL * light.c + spec)*shadow*diffuse;\n}\n\nvec3 render(vec3 ro, vec3 rd, inout Data data) {\n    Light light = Light(vec3(1, 2., -3.), vec3(0.97, 0.69, 0.51), 2.0);\n    vec3 L = normalize(light.p);\n    float VdotL = max(0.0, dot(rd, L));\n    vec3 col = vec3(0.0);\n    col += pow(VdotL, 4.)*light.c;\n    if (march(ro, rd, data)) {\n        col += forEachLight(ro, rd, data, light);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 O, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy - 0.5 * R.xy) / R.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0, 0.2, -1.);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z < 0.01) {\n        m.x = (iTime+4.0)*0.09;\n        m.y = -0.09;\n    }\n    \n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    ro.yz *= rot(m.y*TAU);\n    ro.xz *= rot(m.x*TAU);\n    \n\n    \n    Data data = NEW_DATA;\n    col += render(ro, rd, data);\n    float depth = data.d / FAR;\n    col += smoothstep(0.02, 0.2, depth);\n    col += col*col;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 374, 393, 393, 456], [458, 458, 495, 495, 577], [579, 579, 609, 609, 697], [699, 699, 731, 731, 987], [1027, 1027, 1063, 1063, 1386], [1388, 1388, 1435, 1435, 1936], [1938, 1938, 2003, 2003, 2543], [2546, 2546, 2575, 2575, 2725], [2727, 2727, 2797, 2797, 3184], [3186, 3186, 3234, 3234, 3550], [3552, 3552, 3592, 3592, 4240]], "test": "untested"}
{"id": "cl2yD3", "name": "Near Miss Edge Detection", "author": "tristanantonsen", "description": "simple outline tests, trying to capture edges that are in front of other bodies too", "tags": ["raymarching", "outline"], "likes": 3, "viewed": 46, "published": 3, "date": "1698244036", "time_retrieved": "2024-07-30T17:26:08.780953", "image_code": "// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r) {\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU - PI);\n    p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nfloat body1(vec3 p) {\n    float f = 0.5;\n    float r = 0.1;\n    float R = 0.375;\n    \n    float d = sdSphere(p, vec3(0.45 * sin(f * iTime), 0.5 * cos(f * iTime + PI / 2.), 0.), R);\n    return d;\n}\n\nfloat body2(vec3 p) {\n    float f = 0.5;\n    float R = 0.375;\n    \n    vec3 center = p - vec3(0.45 * cos(f * iTime), 0.5 * sin(f * iTime), 0.);\n    center = rotY(center, 0.25 * iTime);\n    center = rotX(center, 0.25 * iTime);\n    \n    float d = sdRoundedBox(center, vec3(0.3), 0.05);\n    return d;\n}\n\nfloat body3(vec3 p) {\n    float f = 0.5;\n    float R = 0.375;\n    \n    vec3 center = p - vec3(0.5 * cos(f * iTime));\n    center = rotZ(center, 0.25 * iTime);\n    float d = sdRoundedCylinder(center, 0.125, 0.1, 0.5);\n    \n    return d;\n}\n\nvec2 map(vec3 p) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec2 res;\n    p = rotY(p, -2.*m.x);\n    float r = 0.1;\n    \n    float s1 = sdSphere(p, vec3(-0.625, -0.25, 0.), 0.625);\n    res = vec2(s1, 0.0); // id to track color\n     \n    float s2 = sdSphere(p, vec3(0.625, 0.25, 0.), 0.625);\n    if (s2 < res.x) { res.y = 1.0; };\n    res.x = opSmoothUnion(res.x, s2, r);\n\n\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    float lastDist = 0.;\n    float dir = -1.0;\n    bool inc = false;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        \n        float dd = ds.x - lastDist;\n        \n        lastDist = ds.x;\n        \n        if (sign(dd) > 0.) {\n            minDist = min(minDist, ds.x);\n        };\n        \n        mat = ds.y;\n        \n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\nvec2 array(vec2 p, vec2 spacing) {\n\n    return mod(p, spacing);\n\n}\n\nfloat Circle(vec2 p, vec2 c, float r) {\n    return length(p-c) - r;\n}\n\nfloat dots(vec2 p, float spacing, float rad, float fac) {\n\n    //float spacing = 0.04;\n    //float rad = 0.2 * spacing;\n    \n    vec2 r = array(p, vec2(spacing));\n    \n    float c = Circle(r, vec2(spacing * 0.5), rad);\n    \n    return c - fac;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 0., -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        if (d.y == 0.0) color = vec3(0.2,0.8,1.);\n        if (d.y == 1.0) color = vec3(0.8,0.2,1.);\n        if (d.y == 2.0) color = vec3(0.8,0.,0.);\n        color *= illumination; \n        \n\n        // halftone\n        //float spacing = 0.025;\n        //vec2 uv2 = (fragCoord - 0.5*iResolution .xy)/iResolution.y;\n        //float shadeFac = 0.5*(N.z+1.);\n        //float dotMax = 0.01;\n        //float dotFac = dotMax*smoothstep(0.0,0.3, shadeFac);\n        //float minRad = 0.2 * spacing; \n        //float dts = dots(uv2, spacing, minRad, dotFac);\n        //dts *= 255.;\n        \n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n         \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.3;        \n       \n        fragColor = vec4(color, 1.0);\n        \n    }\n                \n        // outline\n        \n        if (d.z < 0.015 && d.z > SURF_DIST) {\n            vec3 outlineColor = vec3(0.0,0.,0.);\n            color = mix(color, outlineColor, smoothstep(1., 0., d.z));\n            fragColor = vec4(color, 1.0);\n        };\n        \n        \n         \n        \n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl2yD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 310, 352, 352, 388], [390, 390, 433, 433, 463], [465, 465, 510, 510, 602], [604, 604, 650, 650, 759], [761, 761, 825, 825, 946], [1097, 1097, 1133, 1133, 1154], [1156, 1156, 1197, 1257, 1284], [1285, 1285, 1327, 1327, 1353], [1355, 1355, 1405, 1405, 1504], [1505, 1505, 1561, 1561, 1661], [1662, 1662, 1718, 1718, 1817], [1964, 1964, 1992, 1992, 2142], [2144, 2144, 2172, 2172, 2322], [2324, 2324, 2352, 2352, 2502], [2503, 2503, 2532, 2532, 2699], [2859, 2859, 2880, 2880, 3055], [3057, 3057, 3078, 3078, 3356], [3358, 3358, 3379, 3379, 3594], [3596, 3596, 3614, 3627, 4025], [4027, 4027, 4060, 4060, 4669], [4671, 4671, 4694, 4694, 5028], [5030, 5030, 5075, 5102, 5703], [5705, 5705, 5739, 5739, 5771], [5773, 5773, 5812, 5812, 5842], [5844, 5844, 5901, 5963, 6090], [6093, 6093, 6150, 6200, 8254]], "test": "untested"}
{"id": "DsVfWW", "name": "Changing Loops", "author": "Jaysmito101", "description": "Changing Loops", "tags": ["fractal", "loops", "repetation"], "likes": 1, "viewed": 184, "published": 3, "date": "1698233527", "time_retrieved": "2024-07-30T17:26:09.536932", "image_code": "vec3 palette( in float t )\n{\n    vec3 a = vec3(1.0, 1.0, 1.0);   // Set a to pure white for brightness.\n    vec3 b = vec3(0.7, 0.9, 1.0);   // Adjust b for neon-like colors.\n    vec3 c = vec3(2.0, 2.0, 2.0);   // Increase c for faster oscillation.\n    vec3 d = vec3(0.0, 0.2, 0.4);   // Adjust d for the desired phase.\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nfloat rand(vec2 st) \n{\n    return fract(sin(dot(st, vec2(12.1524, 78.46584))) * 45434.56454);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Smooth random values at four corners of the cell\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Interpolate between those random values\n    vec2 u = f * f * (3.0 - 2.0 * f); // Smooth interpolation function\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    uv += (10.0 * vec2(sin(iTime * 0.01), cos(iTime * 0.01)));\n    uv = abs(uv) + noise(uv * 5.0 + sin(iTime)) * 0.1;\n    uv *= vec2(1.0) + noise(uv) * 0.01;\n    \n\n\n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n\n\n    for (float i = 0.0; i < 3.0; i ++)\n    {\n        uv = fract(uv * 1.5) - 0.5;\n    \n        float r = abs(sin((abs(sin(iTime)) + 1.0) * 1.5));\n        float f = (length(uv * 3.0) - r) - 0.1;\n    \n    \n        float tm = iTime;\n        f = abs(sin(f + tm * 0.51) - cos(f + tm * 0.5)) * 4.5;\n    \n        f = pow(0.1 / f, 1.9);\n        \n        col += palette(noise(vec2(\n                            fract(length(uv) + sin(iTime * 0.7416)),\n                            fract(1.0 / length(uv) + sin(iTime * 0.476))\n                        ))) * f;\n    }\n\n    col = aces(col);\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 368], [370, 422, 441, 441, 632], [634, 634, 656, 656, 729], [731, 731, 753, 753, 1201], [1204, 1204, 1261, 1261, 2191]], "test": "untested"}
{"id": "cdVfW1", "name": "Encircling Rectangles=┣┳┻┫ꓕTiles", "author": "ollj", "description": "randomly alternating 𝈩ꓕ-crossing (asymmetric/irregular)\namplitude set by point-distance (ripples/hotspot).\nClick to show grid & to control spot.\n\nIntended for lookup with floats.", "tags": ["grid", "random", "animated", "animation", "t", "blocks", "double", "morph", "spot", "regular", "alternating", "irregular", "asymmetric", "symmetric"], "likes": 13, "viewed": 240, "published": 3, "date": "1698183080", "time_retrieved": "2024-07-30T17:26:10.550223", "image_code": "#define RipplesOscillate\n//oscillate between circle and ripples, for eccect-amplitude\n\n#define innerCircleRadius 2.5\n#define transitionRadius  5.\n//outerCircleradius=innerCircleRadius+transitionRadius\n//negative innerCircleRadius -> lower peak, aborted transition\n//negative transitionRadius  -> valley instead of hill\n//transitionRadius also limits==sets to/by how much ANY rectangle is stretched|squashed\n//as long as transitionRadius!=0, triangles will never be squashed down to 0.\n\n//#define linearMixOnly\n//define in to have it soimple, fast, linear only (unclamped)\n//undefine to add at least 50% smoothstep (only smoothstep is clamped)\n\n// https://www.shadertoy.com/view/mdyfD1 asymmetric blocks w regular spot, 2023 by jt\n// based on https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified float\n\n// Change the regularity in the pattern of\n// random-blocks-by-alternating-double-T-crossings\n// (aka asymmetric/irregular)\n// based on distance to \"spotlight\" position.\n// This implementation is intended for lookup with floats.\n// Click to show grid & control spot.\n// Click to lower left returns to demo mode.\n\n// This can be used to place windows into walls of asymmetric blocks:\n// see https://www.shadertoy.com/view/dtl3Wf Asymmetric Blocks Wall\n\n// tags: random, t, blocks, double, alternating, irregular, asymmetric, morph, grid, animation, animated, regular, symmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define time_scale 10.0\n\n#define pi 3.1415926\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2,\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x) // calculate two hashes in parallel\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n//// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\n//// perhaps the best ever devised for this op count, great distribution and cycle\n//uint lowbias32(uint x)\n//{\n//    x ^= x >> 16;\n//    x *= 0x7feb352du;\n//    x ^= x >> 15;\n//    x *= 0x846ca68bu;\n//    x ^= x >> 16;\n//    return x;\n//}\n\n#define HASH(u) triple32(u)\n//#define HASH(u) lowbias32(u)\n\nuint uhash(ivec2 v, bool choose)\n{\n//return uvec2(0u); // verify grid alignment\n    return HASH((uint(v.x)*2u+uint(choose) + HASH(uint(v.y)*2u+uint(choose))) /*+ uint(iFrame / 120)*/);\n}\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nstruct block\n{\n    vec2 center;\n    vec2 extent;\n    ivec2 id;\n};\n\n#define RES 8\n\n#define scale (float(RES*7))\n\n//to get a smoothstepped grid: uv=smoothstep(-.1,.1,ss2t(fract(uv*gridSize/iResolution.xy)))\n//ss2t() turns a seesaw wave to triangle wave\n#define ss2t(a) a=abs(a*2.-1.)\n\n\n#define applyRadii(a) a=clamp((a-innerCircleRadius)/transitionRadius,0., 1.0)\n\nfloat spot(vec2 v)\n{\n   bool demo = !any(greaterThan(vec2(iMouse), vec2(10))); //= iMouse.z <0.;\n    //bool demo = any(lessThan(vec2(iMouse), vec2(10)));\n    float speed=pi*3.;\n    if(demo)\n        v -= vec2(cos(speed*iTime/time_scale)\n                , sin(speed*iTime/time_scale) )*scale/vec2(RES);\n    else\n    {\n        // hacky screenspace mouse\n        vec2 R = iResolution.xy;\n        vec2 m = iMouse.xy;\n        m = (2.0 * m - R) / R.y;\n        v -= m * scale/float(RES);\n    }\n\n\n    float r=length(v);//a circle pattern for effect-strenght\n        \n        \n    #ifdef RipplesOscillate\n      \n    float R=r;\n    R*=.2;\n    R=fract(R);\n    R=ss2t(R);\n    R*=9.;\n    applyRadii(r);\n    applyRadii(R);\n    r=mix(R,r,-cos(iTime*.5)*.5+.5);\n\n    #else\n\n    applyRadii(r);\n\n     #endif\n    \n    return r;\n}\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror)\n{\n    float m = 1.0;\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //if(all(lessThanEqual(abs(t+d), ivec2(2))))\n    //if(length(vec2(t+d)) < 2.5)\n    //    //return float(choose?d.y:d.x);\n    //    m = 0.;\n    m = spot(vec2(t+d));\n\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // float hash\n    //return choose?r.y:r.x;\n    float r = fract(float(uhash(t+d, choose) % uint(RES))/float(RES))+float(choose?d.y:d.x); // integer hash with fixed resolution\n    \n    float h=float(choose?d.y:d.x);\n    \n    #ifdef linearMixOnly\n    h= mix(h+1.,h-1.,m*.5)*.5;\n    #else \n    //at least 50% smoothstep. the final result is clamped afterwards (discontinuity)\n    h= mix(h+1.,h-1.,m*.5)*.5;\n    h+=smoothstep(0.,.5,h)*.5;  //dodo: i fail to get 100% smoothtep?\n    #endif\n    //becausde smoothstep includes a clamp that mix() does not have\n    //and that clamping causes artefacts.\n    return h;\n}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(vec2 p) // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n{\n    ivec2 tile = ivec2(floor(vec2(p))); // global coordinates of tile\n    vec2 local = fract(p);\n\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n    \n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n       \n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    \n    if(flip) // horizontal line goes through: swap vertical with horizontal\n    {\n        // swap components\n        local = local.yx;\n    }\n\n    // vertical line goes through (on flip transpose for horizontal line)\n\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n\n    vec2 v0 =\n        vec2\n        (\n            // primary corner in (0,0) tile\n            c,\n            d\n        );\n\n    vec2 v1 =\n        vec2\n        (\n            // primary corner in (X,Y) tile\n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip)\n        );\n\n    if(flip) tile = tile.yx;\n\n    v0 += vec2(tile);\n    v1 += vec2(tile);\n\n    ivec2 id = tile + ivec2(x,y);\n\n    if(flip) // horizontal line goes through: unswap vertical with horizontal\n    {\n        v0 = v0.yx;\n        v1 = v1.yx;\n        id = id.yx;\n    }\n\n    bool flag = v0.y > v1.y;\n\n    // fix order of min/max corners\n    vec2 center = (v0.xy+v1.xy)/2.0;\n    vec2 extent = abs(v0.xy-v1.xy)/2.0;\n\n    return block(center, extent, id);\n}\n\nvec3 hash32(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) // https://iquilezles.org/articles/distfunctions2d/\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 colorize(ivec2 id)\n{\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    return color;\n}\n\n\n\n//i forgot how to use p,mod here, and remembered, all I need is ss2t() instead:\n/*\n#define vec1 float\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n/*\n//hg_sdf pmod extensions of https://www.shadertoy.com/view/4ttyDN\n//problem, pMod alone has no good efficient interval bound with gradients outside of the bound interval\n//pmodInterval() exists, but it has (numerically) bad branches.\n//pModr() fixes this\n//[s] sets period-length, n sets number of [c0 discontinuities] == [tileBorderCount]\nfloat pmod(inout float u,float s){float r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \nvec2 pmod(inout vec2 u,vec2 s){vec2 r=floor(u/s+.5);u=fract(u/s+.5)*s;return r;} //http://mercury.sexy/hg_sdf/                 \n//vec2 pMod(vec1 u,vec1 s){return vec2( ff(u/s+.5)*vec2(s,1));}//silly variant\nvec1 pModr(inout vec1 p,vec1 s,vec1 n//n==number of repeats (discontinuities), where the smallest discontinuity is at [s]\n){float q=p,f=pmod(q,s);p=p+.5*s;vec2 r=vec2(mix(mix(q,p-s*n,step(n,f)),p,step(f,0.)),clamp(f,0.,n))\n ;p=r.x;return r.y;}\n//for u<0 and u>s*n the space condinues linearily, without repetition, this is different from hg_sdf.\n//it also does not set a start, you must just shift u instead\nfloat pModR(inout float p,vec1 s,vec1 n){float r=pModr(p,s,n);p-=s*.5;return r;}//offset the output for more utility.\n//minor flaw; for s==0. special linear case, it still splits a line in 2 segments.\n*/\n\n//i failed to use euclideanbeat instead of ss2t()\n//Because i could not get the scaling right.\n//,euclideanbeat is THE best hairline-grid function\n//,because its hauirlines do not vanish on smaller respolutions (unless used wrongly)\n\nvoid mainImage(out vec4 fragColor, in vec2 p){\n    vec2 R = iResolution.xy;\n    vec2 P=p;\n    p = (2.0 * p - R) / R.y;\n    //p+=.2;\n    vec2 m = iMouse.xy;\n    m = (2.0 * m - R) / R.y;\n\n    block b = blocks_layout(p*scale/vec2(RES));\n    b.center *= float(RES);\n    b.extent *= float(RES);\n\n    vec3 color = colorize(b.id);\n    //color *= spot(p*scale/vec2(RES));\n    color = max(color, 1.0-spot(p*scale/vec2(RES)));\n    //color = mix(vec3(color.x+color.y+color.z)/3.0, color, spot(p*scale/vec2(RES)));\n    //color = mix(1.0-color, color, spot(p*scale/vec2(RES)));\n    \n    // differences between pixel-position and corners\n    vec2 q0 = p-vec2(b.center-b.extent)/scale;\n    vec2 q1 = p-vec2(b.center+b.extent)/scale;\n    // visualize edges\n    color = min(color, vec3(smoothstep(0.005, 0.01,+q0.x)));\n    color = min(color, vec3(smoothstep(0.005, 0.01,+q0.y)));\n    color = min(color, vec3(smoothstep(0.005, 0.01,-q1.x)));\n    color = min(color, vec3(smoothstep(0.005, 0.01,-q1.y)));\n\n    if(iMouse.z > 0.0)\n    {\n        //snoothed grid!\n        vec2 q = fract(p*scale/float(RES)+.5);\n        q=ss2t(q);\n        q*=2.;//optionally steeper slope dims the gradient out faster, leaving  a black square instead of a black dot.\n        q=smoothstep(-.1,.1, q);//essential for smaller resolutions\n        //q=sqrt(q);   //optionally more exponential\n        color += vec3(1.0-min(q.x, q.y)); //ADD grid+background\n        \n        /*\n        #ifdef checkerboard \n        lazy slow GLOBAL checkerboard\n        vec2 r = p*scale/2.0;\n        color *= mix(0.5, 1.0, step(0.0, sin(r.x*pi*2.0)*sin(r.y*pi*2.0))); // checker\n        #endif \n        /**/\n    }\n    \n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2523, 2674, 2733, 2733, 2887], [3257, 3257, 3291, 3336, 3443], [3445, 3445, 3541, 3541, 3677], [4042, 4042, 4062, 4062, 4851], [4853, 4853, 4920, 4920, 5815], [5817, 6243, 6352, 6352, 8659], [8661, 8661, 8757, 8757, 8896], [8898, 8898, 8986, 8986, 9105], [9107, 9107, 9132, 9132, 9243], [11125, 11125, 11171, 11171, 12839]], "test": "untested"}
{"id": "DsVBWh", "name": "Beat", "author": "LilyIsTrans", "description": "Based off https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["trippy"], "likes": 1, "viewed": 230, "published": 3, "date": "1698180235", "time_retrieved": "2024-07-30T17:26:11.366042", "image_code": "\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.4, 0.6);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 0.9, 1.0);\n    vec3 d = vec3(0.263, 0.416,0.557);\n\n\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat sdfCircle(vec2 uv) {\n    return length(uv) - 0.5;\n}\n\nfloat sdfHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdfHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdf(vec2 uv) {\n    return sdfHexagram(uv, 1.0);\n}\n\nfloat beat(float t) {\n    return t + ((sin(t * 8.0) + sin(t * 6.0) + sin(t * 18.0)) / 2.0) * ((sin(t * 0.01) + 1.0) / 2.0);\n}\n\nconst float PHI = (1.0 + sqrt(5.0)) / 2.0;\n\nvec2 rotate(vec2 u, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    mat2 R = mat2(c, s, -s, c);\n    \n    return R * u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv = rotate(uv, iTime / 7.0);\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    const float PI = 3.14159265;\n    vec3 modTime = vec3(sin(sdf(uv) - iTime), sin(sdf(uv) - iTime - 2.0 * PI / 3.0), sin(sdf(uv) - iTime - 4.0 * PI / 3.0)) - iTime;\n    const float iterations = 3.0;\n    \n    float beatTime = (sin(length(uv) * 6.0 - beat(iTime)));\n    \n    for (float i = 0.0; i < iterations; ++i)\n    {\n        uv = fract(uv * PHI) - 0.5;\n\n        float d = (sdfHexagram(uv, i) * exp(-sdfHexagon(uv0, sin(iTime))));\n        vec3 col = palette(iTime*0.4 + sdf(uv0) + sdf(uv) + i*0.4);\n\n        d = abs(sin(d * 8.0 + beatTime*0.6) / 8.0);\n        d = pow(0.01 / d, 1.2);\n\n\n\n        finalColor += col * d / iterations;\n    }\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "buffer_a_code": "float beat(float t) {\n    return t + (sin(t * 8.0) / 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    fragColor = vec4(vec3(sin(length(uv) * length(uv) * 6.0 - beat(iTime))), 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 211], [214, 214, 240, 240, 271], [273, 273, 316, 316, 506], [508, 508, 552, 552, 793], [795, 795, 815, 815, 850], [852, 852, 873, 873, 977], [1023, 1023, 1057, 1057, 1166], [1168, 1168, 1225, 1225, 2075]], "test": "untested"}
{"id": "DsKfDh", "name": "Line hologram", "author": "ianertson", "description": "Just an experiment", "tags": ["2d", "lines", "hologram"], "likes": 6, "viewed": 192, "published": 3, "date": "1698180083", "time_retrieved": "2024-07-30T17:26:12.204800", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 center = (iResolution.xy*0.5)/iResolution.y;\n    vec2 start = center;\n    vec2 end = center+0.33333*vec2(cos(iTime), sin(iTime));\n    float f = smoothstep(0.5, 0.0, distance(uv, end));\n    start = mix(\n    start,start+end*vec2(cos(iTime+uv.x+60.*iTime*uv.y), sin(iTime+uv.y+60.*iTime*uv.x)),f);\n    float pf = dot(uv, start-end);\n    vec3 gc = vec3(abs(pf), f, abs(f-pf));\n    vec2 pa = uv - start; vec2 ba = end - start; \n    fragColor = vec4(clamp(1.0 - length(pa - ba * clamp(\n        dot(pa, ba) / dot(ba, ba), 0.0, 1.0))/0.05, 0.0, 1.0)*mix(vec3(1.0), gc, f),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 677]], "test": "untested"}
{"id": "dsyBW1", "name": "Flatstep 1st Order Distance AA", "author": "domrally", "description": "A flat sigmoid extracted from domrally's flat & smooth periodic functions. The endpoints are straight lines.\ns = .5 - .5 * erf atanh cos tπ\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["flat", "math", "antialiasing", "derivative", "smoothstep", "dual", "interpolation", "smooth", "sigmoid", "differential", "squoval"], "likes": 2, "viewed": 178, "published": 3, "date": "1698175308", "time_retrieved": "2024-07-30T17:26:12.955791", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\ndomrally's flatstep function.\nKinda like a smoothest-step or ∞ degree hermite interpolation.\n*/\nvec2 flatstep(float a, float b, float x) {\n    vec2 f;\n    float t = clamp((x - a) / (b - a), 9e-8, 1. - 9e-8),\n          c = cos(3.14 * t),\n          h = atanh(c),\n          H = h * h;\n\n    // error function method by Sergei Winitzki using Padé approximations\n    f[0] = .5 - .5 * sign(h) * sqrt(1. - exp(-H * (.1 * H + 1.27) / (.1 * H + 1.)));\n    // derivative\n    f[1] = sin(t) * exp(-H) / (c * c - 1.);\n\n    return f;\n}\n\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 r = iResolution.xy,\n         f = flatstep(.5, r.x - .5, i.x + .5);\n\n    // 1st order gradient based distance approximation\n    float d = abs((f.x + .326 - 1.6 * i.y / r.y) / (4. + f.y * f.y));\n    // antialiasing\n    o = vec4(smoothstep(1.5 / r.y, 0., max(0., d - 6. / r.y)));\n    // ripples\n    o += vec4((.4 + .1 * cos(d * 2e2 - iTime)) / (1. + 9. * d), 0, 0, 1);\n}\n\n\n/*\nREFERENCES\n\nvisuals inspired by iq\nhttps://www.shadertoy.com/playlist/MXdSRf\n*/\n\n\n/*\nFURTHER READING\n\nsmoothing\n\nhttps://en.wikipedia.org/wiki/Mollifier\nhttps://en.wikipedia.org/wiki/Smoothstep\nhttps://en.wikipedia.org/wiki/Flat_function\nhttps://en.wikipedia.org/wiki/Bump_function\nhttps://en.wikipedia.org/wiki/Sigmoid_function\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Non-analytic_smooth_function\nhttps://en.wikipedia.org/wiki/Smoothness#Smooth_partitions_of_unity\nhttps://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 128, 170, 170, 553], [556, 556, 592, 592, 969]], "test": "untested"}
{"id": "csGfD1", "name": "BLF Wind Field 3D", "author": "iY0Yi", "description": "just implemented an editable simple vector field thingy.\ni don't know about vector field at all, so this must be incorrect tho. but fun :-)", "tags": ["maptoy"], "likes": 14, "viewed": 242, "published": 3, "date": "1698162929", "time_retrieved": "2024-07-30T17:26:13.898271", "image_code": "// https://iquilezles.org/articles/distfunctions/\nvec3 opLimitedRepetition( in vec3 p, in float s, in vec3 l){\n    return p - s*clamp(round(p/s),-l,l);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nvec2 pRot(inout vec2 p, float a){\n  p=cos(a)*p+sin(a)*vec2(p.y, -p.x);\n  return p;\n}\n\nstruct WindSource{\n    vec3 pos;\n    vec3 dir;\n    float str;\n};\n\nWindSource ws0;\nWindSource ws1;\nWindSource ws2;\nWindSource ws3;\nvec3 gWindDir;\nconst vec3 gBASE_DIR = vec3(-1,0,0);\n\nvec2 calcWindRot(vec3 p){\n    vec3 dir = gBASE_DIR;\n    dir = mix(ws0.dir, dir, smoothstep(0., ws0.str, distance(p, ws0.pos)));\n    dir = mix(ws1.dir, dir, smoothstep(0., ws1.str, distance(p, ws1.pos)));\n    dir = mix(ws2.dir, dir, smoothstep(0., ws2.str, distance(p, ws2.pos)));\n    dir = mix(ws3.dir, dir, smoothstep(0., ws3.str, distance(p, ws3.pos)));\n    gWindDir = dir;\n    float z = atan(dir.y, dir.x);\n    float y = atan(dir.z, dir.x);\n    return vec2(z,y);\n}\n\nfloat map(vec3 p){\n    p*=5.;\n    vec3 ip = floor(p);\n    vec2 ca = calcWindRot(ip);\n    \n    vec3 q = p;\n    q = opLimitedRepetition(q+.5, 1., vec3(10));\n    \n    float a = .1*PI;\n    float h = .75;\n    pRot(q.yx, PI*.5);\n    \n    pRot(q.xy, ca.x);\n    pRot(q.xz, ca.y);\n    \n    q.y-=h*.5;\n    float d = sdCone(q, vec2(sin(a),cos(a)), h);\n    d*=.5;\n    \n    #define DEF vec3(-1,0,0)\n    float dif = dot(DEF, gWindDir);\n    if(dif>.75)BLUE(d);\n    if(dif>.5 && dif<.75)GREEN(d);\n    if(dif<.5 && dif>-.5)YELLOW(d);\n    if(dif<-.5 && dif>-.75)ORANGE(d);\n    if(dif<-.75)RED(d);\n    return d/5.;\n}\n\nvoid initWind(){\n    ws0 = WindSource(vec3(cos(iTime*.75+5.),cos(iTime*.75),sin(iTime+5.))*15., vec3(sin(iTime*2.),0,cos(iTime*2.)), 20.);\n    ws1 = WindSource(vec3(-sin(iTime*.25),0,-1)*5., vec3(0,0,1), (sin(iTime*.75+PI*.5)*.5+.5)*30.+10.);\n    ws2 = WindSource(vec3(-1,cos(iTime*.5),-1)*10., vec3(cos(iTime*.5+PI),cos(iTime*.25+PI),-1), 40.);\n    ws3 = WindSource(vec3(sin(iTime+15.),sin(iTime*.25+PI),cos(iTime+15.))*15., vec3(1,0,0), 20.);\n}\n\nvoid update(){\n    initWind();\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uniform vec3 iWheel;\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\nfloat opUniS(float a,float b,float r){\n\tfloat h = max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y=abs(p.y);\n  p.y-=clamp(p.y,0.,h);\n  return length(p)-r;\n}\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 30.\n#define STEP_MAX 100\n\n// Markers: 8 colors\n#define cRED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define cGREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define cPURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define cYELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define cORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define cCOBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define cBLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define cBLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\nfloat tRED = 1.;\nfloat tGREEN = 1.;\nfloat tPURPLE = 1.;\nfloat tYELLOW = 1.;\nfloat tORANGE = 1.;\nfloat tCOBALT = 1.;\nfloat tBLUE = 1.;\nfloat tBLACK = 1.;\n#define RED(v) tRED = step(DIST_MIN*10., v)\n#define GREEN(v) tGREEN = step(DIST_MIN*10., v)\n#define PURPLE(v) tPURPLE = step(DIST_MIN*10., v)\n#define YELLOW(v) tYELLOW = step(DIST_MIN*10., v)\n#define ORANGE(v) tORANGE = step(DIST_MIN*10., v)\n#define COBALT(v) tCOBALT = step(DIST_MIN*10., v)\n#define BLUE(v) tBLUE = step(DIST_MIN*10., v)\n#define BLACK(v) tBLACK = step(DIST_MIN*10., v)\n\n#define INIT_CAM_POS vec3(2,-1,2)*2.\n#define CAM_DIST 15.\n#define CAM_INIT_SCALE 3.\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(1,.95,.9)*.8)\n#define THM_GRID (vec3(.1,.2,.25)*1.7)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(1)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\n#define render() \\\nbool isTurntable = true;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nfloat char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;}\\\n    return 0.;\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=min(0,iFrame); i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=min(0,iFrame); i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED+PI*.25), 1, cos(iTime*TURN_TABLE_SPEED+PI*.25))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST+iWheel.y*.0005;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz)*1.5;\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz);\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(4.2)), g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col*= (tRED<.5)?cRED:vec3(1);\\\n    col*= (tGREEN<.5)?cGREEN:vec3(1);\\\n    col*= (tPURPLE<.5)?cPURPLE:vec3(1);\\\n    col*= (tYELLOW<.5)?cYELLOW:vec3(1);\\\n    col*= (tORANGE<.5)?cORANGE:vec3(1);\\\n    col*= (tCOBALT<.5)?cCOBALT:vec3(1);\\\n    col*= (tBLUE<.5)?cBLUE:vec3(1);\\\n    col*= (tBLACK<.5)?cBLACK:vec3(1);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(2.2)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x<.5;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    update();\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(1.-THM_GRID,vec3(2.2)),1);\\\n    drawDebug(fragColor);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n  \n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 110, 110, 153], [155, 155, 196, 330, 665], [667, 667, 700, 700, 751], [936, 936, 961, 961, 1403], [1405, 1405, 1423, 1423, 2002], [2004, 2004, 2020, 2020, 2450], [2452, 2452, 2466, 2466, 2484]], "test": "untested"}
{"id": "csVBDz", "name": "Granular Vibration 2", "author": "dr2", "description": "Simulation of a vertically vibrated granular layer - extended to 3D", "tags": ["collision", "dynamics", "physics", "grain"], "likes": 17, "viewed": 285, "published": 3, "date": "1698137810", "time_retrieved": "2024-07-30T17:26:15.183834", "image_code": "// \"Granular Vibration 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n For further information refer to the scientific and technical\n literature on granular media and flow (note that the rotational\n motion is not really necessary but is included to enhance the\n imagery); also see comments in \"Granular Vibration\".\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Maxv3 (vec3 p);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nvec3 ltPos, vnBall, hbSize, hbPos, vnBlk;\nfloat dstFar, hbMarg, baseUp;\nint nFrame, nBall, idObj, idBall, txOff;\nconst int idFrm = 1, idSup = 2, idFlr = 3, idWal = 4;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  q = p;\n  d = q.y;\n  DMIN (idFlr);\n  d = 10. - q.z;\n  DMIN (idWal);\n  q.x = abs (q.x) - hbSize.x - 2.;\n  d = min (PrCylDf (vec3 (q.xz, q.y - baseUp), 0.2, hbSize.y + 2.),\n     PrCylDf (vec3 (q.xz, q.y - 0.1), 1.5, 0.1));\n  DMIN (idSup);\n  q = p;\n  q.y -= baseUp;\n  q = abs (q - hbPos);\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.1),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.1)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.1));\n  DMIN (idFrm);\n  d = PrCylDf (vec3 (abs (q.xy) - hbSize.xy - vec2 (1., - hbMarg - 0.1), q.z).yzx, 0.2, 1.2);\n  DMIN (idSup);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.46 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.49 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  return step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rg, ltDir;\n  float dstBall, dstObj, db, att, sh;\n  db = BlkHit (ro - hbPos - vec3 (0., baseUp, 0.), rd);\n  dstBall = (db < dstFar) ? BallHit (ro - vec3 (0., baseUp, 0.), rd) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idFrm) {\n        col4 = vec4 (0.85, 0.8, 0.8, 0.1);\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      } else if (idObj == idFlr) {\n        col4 = vec4 (0.3, 0.3, 1., 0.05);\n        rg = ShGrid (ro.xz, vec2 (0.2), 0);\n        col4.rgb *= rg.y;\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n      } else if (idObj == idWal) {\n        col4 = vec4 (0.4, 0.4, 0.3, 0.05);\n        rg = ShGrid (ro.xy, vec2 (0.2, 0.3), 1);\n        col4 *= rg.y;\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      }\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (HsvToRgb (vec3 (fract (33. * float (idBall) / float (nBall) +\n         0.5 * BallChqr (idBall, vnBall)), 1., 1.)), 0.2);\n    }\n    ltDir = normalize (ltPos - ro);\n    att = smoothstep (0., 0.02, dot (ltDir, normalize (ltPos)) - 0.9);\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir, dstFar),\n       0.5 + 0.5 * BallHitSh (ro - vec3 (0., baseUp, 0.), ltDir, 60.));\n    col = att * (col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n  } else {\n    col = vec3 (0.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, ro, rd;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  asp = canvas.x / canvas.y;\n  txOff = 2;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  stDat = Loadv4 (1);\n  hbPos = stDat.xyz;\n  nBall = int (stDat.w);\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * mPtr.y;\n  } else {\n    az = 0.;\n    el = 0.;\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  az = clamp (az, -0.45 * pi, 0.45 * pi);\n  zmFac = 4.5;\n  vuMat = StdVuMat (el, az);\n  hbMarg = 0.4;\n  baseUp = hbSize.y + 2.;\n  ro = vuMat * vec3 (0., baseUp + 6., -3. * hbSize.x);\n  dstFar = 1000.;\n  ltPos = 200. * vec3 (-0.3, 0.3, -1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Granular Vibration 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, hbPos;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n// (dynamics from \"Balls In Motion 2\")\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rm -= hbPos;\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 1.;\n  fDamp = 0.005;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am.y -= grav;\n  am -= fDamp * vm;\n  wam -= fDamp * wm;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp, diam, amp, freq;\n  int mId, pxId, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (64, 4, 2);\n  txOff = 2;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    hbSize.y *= 4.;\n    hbSize.z *= 0.9;\n    hbPos = vec3 (0.);\n    nStep = 0.;\n    nBall = nbMax;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    hbPos = stDat.xyz;\n    nBall = int (stDat.w);\n  }\n  dt = 0.01;\n  freq = 0.5;\n  amp = 2.;\n  hbPos.y = amp * sin (2. * pi * freq * nStep * dt);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (hbPos, float (nBall));\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Granular Vibration 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, hbPos;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n// (dynamics from \"Balls In Motion 2\")\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rm -= hbPos;\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricT = 10.;\n  fricS = 1.;\n  fDamp = 0.005;\n  grav = 5.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am.y -= grav;\n  am -= fDamp * vm;\n  wam -= fDamp * wm;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp, diam, amp, freq;\n  int mId, pxId, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (64, 4, 2);\n  txOff = 2;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    hbSize.y *= 4.;\n    hbSize.z *= 0.9;\n    hbPos = vec3 (0.);\n    nStep = 0.;\n    nBall = nbMax;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    hbPos = stDat.xyz;\n    nBall = int (stDat.w);\n  }\n  dt = 0.01;\n  freq = 0.5;\n  amp = 2.;\n  hbPos.y = amp * sin (2. * pi * freq * nStep * dt);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (hbPos, float (nBall));\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVBDz.jpg", "access": "api", "license": "cc-by-nc-sa-2.0", "functions": [[973, 973, 995, 995, 1722], [1724, 1724, 1757, 1757, 1940], [1942, 1942, 1963, 1963, 2219], [2221, 2221, 2270, 2270, 2512], [2514, 2514, 2548, 2548, 2978], [2980, 2980, 3027, 3027, 3404], [3406, 3406, 3448, 3448, 3582], [3584, 3584, 3617, 3617, 3929], [3931, 3931, 3971, 3971, 4345], [4347, 4347, 4382, 4382, 6052], [6054, 6054, 6107, 6107, 7384], [7386, 7386, 7432, 7432, 7479], [7481, 7481, 7523, 7523, 7574], [7576, 7576, 7600, 7600, 7916], [7918, 7918, 7940, 7940, 7978], [7980, 7980, 8002, 8002, 8040], [8042, 8042, 8078, 8078, 8284], [8286, 8286, 8316, 8316, 8429], [8431, 8431, 8455, 8455, 8577], [8671, 8671, 8696, 8696, 8819]], "test": "untested"}
{"id": "DsKfWz", "name": "Shrinking", "author": "INCHMAN1900", "description": "practice", "tags": ["noise", "animation"], "likes": 2, "viewed": 159, "published": 3, "date": "1698136481", "time_retrieved": "2024-07-30T17:26:15.984693", "image_code": "#define PI 3.141592653\n#define res iResolution.xy\n\nfloat random(float x) {\n    return fract(sin(193.5113+x*7532.439)*395.5349);\n}\n\nfloat noise(float x) {\n    float i=floor(x);\n    float f=fract(x);\n    return smoothstep(random(i),random(i+1.),f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/res;\n    uv-=.5;\n    uv.x*=res.x/res.y;\n    float dist=length(uv);\n    float rt=noise(dist*20.+iTime*.5)*PI*2.;\n    uv=mat2(cos(rt),-sin(rt),sin(rt),cos(rt))*uv;\n    float angle=atan(uv.y,uv.x)+PI;\n    vec3 col = vec3(.6-dist,angle/PI*.5*.4,ceil(dist*10.)*0.1*.4+.3);\n    fragColor = vec4(1.-col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 74, 74, 129], [131, 131, 153, 153, 248], [250, 250, 307, 357, 685]], "test": "untested"}
{"id": "ddyBWz", "name": "Projection Alignment Grid", "author": "matthewwachter", "description": "A test pattern grid generator for projection and led displays. Lots of defines for color and shape parameters.\n\nWorks best with even resolutions.", "tags": ["grid", "sdf", "projection", "testpattern", "alignment"], "likes": 4, "viewed": 232, "published": 3, "date": "1698127802", "time_retrieved": "2024-07-30T17:26:16.803504", "image_code": "// background color\n#define bg_c vec4(0.0, 0.0, 0.0, 1.0)\n\n// grid color\n#define grid_c vec4(.5, .5, .5, 1.0)\n\n// grid line width\n#define grid_w 2.0\n\n// grid vertical divisions\n// grid cross\n#define grid_s vec2(9.0, 0.0)                     \n\n// circlegrid color\n#define circlegrid_c vec4(0.5)\n\n// circlegrid line width\n// circlegrid size\n// circlegrid offset x\n// circle grid offset y\n#define circlegrid_s vec4(1.0, .25, 0.0, 0.0)\n\n// circle color\n#define circle_c vec4(1.0)\n\n// circle line width\n#define circle_w 2.0\n\n// TL to BR diagonal color\n#define diag1_c vec4(.5, 1.0, .75, 1.0)\n\n// BL to TR diagonal color\n#define diag2_c vec4(1.0, .5, .666, 1.0)\n\n// diagonal line width\n#define diag_w 2.0\n\n// horizontal centerline color\n#define centerh_c vec4(1.0, 1.0, .5, 1.0)\n\n// vertical centerline color\n#define centerv_c vec4(1.0, 1.0, .5, 1.0)\n\n// center line width\n#define center_w 2.0\n\n// rainbow line width\n// rainbow alpha\n// rainbow period\n// rainbow offset\n#define rainbow_s vec4(3.0, 1.0, 2.0, .17)\n\n// border color\n#define border_c vec4(.5, 1.0, .5, 1.0)\n\n// border line width\n#define border_w 2.0\n\n// logo color 1\n#define logo_c1 vec4(0.0, 0.0, 0.0, 1.0)\n\n// logo color 2\n#define logo_c2 vec4(1.0, 1.0, 1.0, 1.0)\n\n// logo color 3\n#define logo_c3 vec4(.5, 0.5, 0.5, 1.0)\n\n// logo type\n// logo size\n#define logo_s vec2(0.0, .1)\n\n// grid\nvoid grid(vec2 p, float px_size, inout vec4 fragColor)\n{\n    float gc = (1.0 - grid_s.y)*.5;\n    vec2 grid = p - round(p*grid_s.x)/grid_s.x;\n    grid *= grid_s.x;\n    float d = min(abs(grid.x), abs(grid.y));\n    vec2 cross = vec2(step(gc, abs(grid.x)), step(gc, abs(grid.y)));\n    d += max(cross.x, cross.y);\n    stroke(d, grid_c, fragColor, grid_s.x*grid_w*px_size);\n}\n\n// circle grid\nvoid circleGrid(vec2 p, float px_size, inout vec4 fragColor)\n{\n    p -= circlegrid_s.zw/grid_s.x;\n    vec2 cell = mod(p * vec2(grid_s.x), 1.0);\n    vec2 center = mod(vec2(.5), 1.0);\n    float radius = circlegrid_s.y;\n    vec2 dist = cell - center;\n    float d = length(dist) - radius;\n    strokeAA(d, circlegrid_c, fragColor, circlegrid_s.x*grid_s.x * px_size, length(fwidth(p*grid_s.x)));\n}\n\n// circle\nvoid circle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\n{\n    center = center + round(p);\n    \n    float d = length(p - center) - radius;\n    strokeAA(d, c, fragColor, circle_w * px_size, length(fwidth(p)));\n}\n\n// rainbow circle\nvoid rainbowCircle(vec2 p, vec2 center, float radius, vec4 c, float px_size, inout vec4 fragColor)\n{\n\tvec2 pq = vec2(atan(p.x, p.y) / TAU*rainbow_s.z + rainbow_s.w, length(p));\n\tfloat d = length(p - center) - radius;\n\tc = vec4(hsv2rgb(vec3(pq.x, 1., 1.)), 1.0);\n\tstrokeAA(d, c, fragColor, rainbow_s.x * px_size, length(fwidth(p)));\n}\n\n// horizontal center line\nvoid centerH(vec2 p, float px_size, inout vec4 fragColor)\n{\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\n    p = mod(p, 1.0)-.5;\n    stroke(abs(p.x), centerh_c, fragColor, center_w*px_size);\n}\n\n// vertical center line\nvoid centerV(vec2 p, float px_size, inout vec4 fragColor)\n{\n    stroke(abs(p.y), centerv_c, fragColor, center_w*px_size);\n    p = mod(p, 1.0)-.5;\n    stroke(abs(p.y), centerh_c, fragColor, center_w*px_size);\n}\n\n// diagonal lines\nvoid diagonals(vec2 p, float px_size, float aspect, inout vec4 fragColor)\n{\n\tp += .5;\n\tp = mod(p, 1.0);\n\t//p = p - floor(p);\n\n\tfloat dist = abs(p.x - p.y);\n\tstrokeAA(dist, diag1_c, fragColor, diag_w*px_size, length(fwidth(p)));\n\t\n\tdist = abs(p.x + p.y)-1.0;\n\tstrokeAA(dist, diag2_c, fragColor, diag_w*px_size, length(fwidth(p)));\n\t//fragColor = vec4(vec3(dist), 1.0);\n}\n\n// render border\nvoid border(vec2 p, vec2 res, inout vec4 fragColor)\n{\n\tfloat d = min(min(p.x, 1.0-p.x)*res.x, min(p.y, 1.0-p.y)*res.y);\n\tfragColor = mix(fragColor, border_c, 1.0-step(border_w, d));\n}\n\n\n// mw logo\nvoid mwLogo(vec2 p, vec2 offset, float scale, float aspect, float px_size, inout vec4 fragColor)\n{\n\tp -= offset;\n\tp.y *= .6;\n\tp /= scale;\n\t\n\t\n\tfloat w = 20.0 * px_size;\n\t\n\tvec2 ra =vec2(0.5,0.5);\n\tfloat d1 = sdRhombus( vec2(p.x + .5, p.y), ra );\n\tfloat d2 = sdRhombus( vec2(p.x - .5, p.y), ra );\n\tfragColor = mix(fragColor, vec4(vec3(pow(min(d1+.95, d2+.95), 8.0)), 1.0)*logo_c3, (1.0-step(0.0, min(d1, d2)))*logo_c3.a);\n\tstrokeAA(min(d1, d2), logo_c2, fragColor, w, length(fwidth(p)));\n\tstrokeAA(min(d1+.1, d2+.1), logo_c2 * vec4(0.8), fragColor, w, length(fwidth(p)));\n\tstrokeAA(min(d1+.2, d2+.2), logo_c2 * vec4(0.6), fragColor, w, length(fwidth(p)));\n\tstrokeAA(min(d1+.3, d2+.3), logo_c2 * vec4(0.4), fragColor, w, length(fwidth(p)));\n\t\n\tfloat d3 = sdSegment(p, vec2(1.0, 0.0), vec2(-1.0, 0.0));\n\tstrokeAA(d3, logo_c2, fragColor, w, length(fwidth(p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 vUV = fragCoord/iResolution.xy;\n    \n    \n    // resolution\n    vec2 res = iResolution.xy;\n    \n    // aspect ratio\n    float aspect = res.x / res.y;\n\t\n\t// -.5 to .5 coordinate space\n\tvec2 p = vUV.st-.5;\n\t\n\tvec2 logo_offset = vec2(0.0, 0.0);\n\t\n\t// pixel size\n\tfloat px_size = 0.0;\n\t\n\t// alignment for different aspect ratios\n\tif (aspect > 1.0)\n\t{\n\t\tp.x *= aspect;\n\t\tlogo_offset.x = (aspect>1.0+logo_s.y*2.0)?.5 : .25;\n\t\tpx_size = 1.0/res.y;\n\t} else {\n\t\tp.y /= aspect;\n\t\tlogo_offset.y = (aspect<1.0-logo_s.y*2.0)?.5 : .25;\n\t\tpx_size = 1.0/res.x;\n\t} \n\t\n\n\t\n\t// background color\n\tfragColor = bg_c;\n\t\n\t// square grid\n\tgrid(p, px_size, fragColor);\n\t\n\t// circle grid\n\tcircleGrid(p, px_size, fragColor);\n\t\n\t// big circles\n    circle(p, vec2(0), 0.5, circle_c, px_size, fragColor);\n    \n    // diagonal lines\n    diagonals(p, px_size, aspect, fragColor);\n    \n    // vertical center lines\n\tcenterV(p, px_size, fragColor);\n\t\n\t// horizontal center lines\n\tcenterH(p, px_size, fragColor);\n\t\n\t// rainbow circle\n    rainbowCircle(p, vec2(0), .333, vec4(1.0), px_size, fragColor);\n\n\t// border lines\n    //vec2 b_pos = vec2(vUV.x * aspect, vUV.y);\n    //b_pos = vUV.xy * res;\n    border(vUV.st, res, fragColor);\n    \n\n    // mw logo\n\tmwLogo(p, logo_offset, logo_s.y, aspect, px_size, fragColor);\n\tmwLogo(p, -logo_offset, logo_s.y, aspect, px_size, fragColor);\n\n\t\n\t//pxGrid(p, px_size, fragColor);\n}", "image_inputs": [], "common_code": "// Íñigo Quílez\n// https://iquilezles.org/articles/distfunctions2d/\n\n#define     TAU 6.28318530717958647 // pi * 2\n#define     PI  3.14159265358979323 // pi\n\n// hsv to rgb\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n  rgb = rgb * rgb * (3. - 2. * rgb);\n  return c.z * mix(vec3(1.), rgb, c.y);\n}\n\n// sd polygon\nconst int N = 8;\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// sd segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// sd box\nfloat sdBox( vec2 p, vec2 b, vec2 o)\n{\n    p -= o;\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// sd circle\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n// sd rhombus\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n// sd distorted pill\nfloat sdDistortedPill(vec2 p, vec2 start, vec2 end, float radius, float power, float depth)\n{\n    p = -p;\n    vec2 dir = normalize(end - start);\n\n    vec2 localP = p - start;\n    float proj = dot(localP, dir);\n    float perpProj = dot(localP, vec2(-dir.y, dir.x));\n\n    float alongLine = clamp(proj, 0.0, length(end - start));\n    vec2 closestPoint = start + dir * alongLine;\n\n    float d = length(p - closestPoint) - radius;\n\n    float frequency = PI / length(end - start);\n    float sind = sin(frequency * alongLine);\n    sind = pow(sind, power);\n    sind *= depth*radius;\n    \n    return d + sind;\n}\n\n\n// stroke edge\nvoid stroke(float d, vec4 c, inout vec4 fragColor, float w)\n{\n    float m = 1.0-step(.5*w, abs(d));\n    fragColor = mix(fragColor, c, m*c.a);\n}\n\n// stroke edge with anti-aliasing\nvoid strokeAA(float d, vec4 c, inout vec4 fragColor, float w, float aa)\n{\n    float m = smoothstep(0.5 * (w + aa), 0.5 * (w - aa), abs(d));\n    fragColor = mix(fragColor, c, m*c.a);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1337, 1345, 1401, 1401, 1714], [1716, 1731, 1793, 1793, 2122], [2124, 2134, 2227, 2227, 2379], [2381, 2399, 2499, 2499, 2732], [2734, 2760, 2819, 2819, 2969], [2971, 2995, 3054, 3054, 3204], [3206, 3224, 3299, 3299, 3593], [3595, 3612, 3665, 3665, 3795], [3798, 3809, 3907, 3907, 4667], [4669, 4669, 4726, 4762, 6153]], "test": "untested"}
{"id": "dsGBDR", "name": "Hinged Truchet", "author": "fad", "description": "Hinged hexagon truchet\nInspiration: [url]https://twitter.com/KeishiroUeki/status/1715924571180990920[/url]\nSee also: [url=/view/msGBWR]textured hinged hexagon tiling[/url]", "tags": ["hexagon", "tiling", "hex", "tile", "tessellation", "hinge"], "likes": 25, "viewed": 314, "published": 3, "date": "1698108368", "time_retrieved": "2024-07-30T17:26:17.713072", "image_code": "const float PI = 3.1415927;\n\nvoid mainImage(out vec4 O, vec2 I) {\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0 * I - R) / R.y * 3.0;\n    float t = 1.0 - abs(1.0 - mod(iTime / 3.0, 2.0));\n    float a = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t)) * PI / 3.0;\n    mat2 A = mat2(sqrt(3.0), 1.0, 0.0, 2.0);\n    vec2 b = inverse(A) * p / cos(a - PI / 6.0);\n    vec2 c = fract(b);\n    vec2 d = floor(b) + step((clamp(3.0 * c, 1.0, 2.0) - c).yx, 2.0 * c);\n    vec2 e = p - A * d * cos(a - PI / 6.0);\n    a = mod(d.x, 2.0) == 1.0 ? -a : a;\n    e = mat2(cos(a), sin(a), -sin(a), cos(a)) * e;\n    vec2 f = abs(e);\n    float g = max(f.y, sqrt(0.75) * f.x + 0.5 * f.y) - sqrt(0.75);\n    float h = fract(sin(dot(d, vec2(12.9898, 78.233))) * 43758.5453);\n    h = step(0.5, h) * PI / 3.0;\n    float i = distance(e, vec2(cos(h), sin(h)));\n    h += PI * 2.0 / 3.0;\n    i = min(i, distance(e, vec2(cos(h), sin(h))));\n    h += PI * 2.0 / 3.0;\n    i = min(i, distance(e, vec2(cos(h), sin(h))));\n    i = abs(i - 0.5);\n    float j = dot(normalize(vec2(dFdx(i), dFdy(i))), normalize(vec2(1.0, 2.0)));\n    \n    if (g < 0.0) {\n        O = vec4(0.8);\n        \n        if (g > -0.2) {\n            O = vec4(0.6);\n        }\n        \n        if (i < 0.2) {\n            O = vec4(1.5 + 0.3 * j);\n        } else {\n            O *= pow(min((i - 0.2) / 0.2, 1.0), 0.07);\n        }\n    } else {\n        O = vec4(0.3);\n    }\n    \n    O *= vec4(0.114,0.576,0.667,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 65, 65, 1435]], "test": "untested"}
{"id": "msGBWR", "name": "Hinged Hexagon UV", "author": "fad", "description": "Hinged hexagon tiling with UV mapping\nSee also: [url=/view/dsGBDR]truchet version[/url]", "tags": ["texture", "map", "mapping", "tiling", "hex", "tessellation", "hinge"], "likes": 7, "viewed": 231, "published": 3, "date": "1698108361", "time_retrieved": "2024-07-30T17:26:18.827093", "image_code": "const float PI = 3.1415927;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - R) / R.y * 4.0;\n    float t = 1.0 - abs(1.0 - mod(iTime / 3.0, 2.0));\n    float a = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t)) * PI / 3.0;\n    mat2 A = mat2(sqrt(3.0), 1.0, 0.0, 2.0);\n    vec2 b = inverse(A) * p / cos(a - PI / 6.0);\n    vec2 c = fract(b);\n    vec2 d = floor(b) + step((clamp(3.0 * c, 1.0, 2.0) - c).yx, 2.0 * c);\n    vec2 e = p - A * d * cos(a - PI / 6.0);\n    a = mod(d.x + d.y, 2.0) == 1.0 ? -a : a; // use anything to determine spin direction!\n    e = mat2(cos(a), sin(a), -sin(a), cos(a)) * e;\n    vec2 uv = e + A * sqrt(0.75) * d;\n    uv = (uv / 4.0 * R.y + R) / 2.0 / R;\n    vec2 f = abs(e);\n    float g = max(f.y, sqrt(0.75) * f.x + 0.5 * f.y) - sqrt(0.75);\n    fragColor = step(g, 0.0) * texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 81, 81, 884]], "test": "untested"}
{"id": "dsGBWR", "name": "unreachable code for naga panic", "author": "jakel101", "description": "This shader serves as a minimal example where naga panics during wgsl to spv translation. \nOriginal shader where this was found: https://www.shadertoy.com/view/NsffD2", "tags": ["bug", "error", "reproduction"], "likes": 1, "viewed": 134, "published": 3, "date": "1698104571", "time_retrieved": "2024-07-30T17:26:19.657872", "image_code": "// step 1: a funciton with an inout input and some other return value\nfloat fn(inout float a) {\n    a += 0.1;\n    return 0.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // step 2: first variable that is vec2/vec3 (float works)\n    vec2 cd = vec2(0.3, 0.4);\n    \n    // step 3: second variable is assigned to the return value, using first variable as args.\n    float e = fn(cd.x);\n    \n    // Output to screen\n    fragColor = vec4(e);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 95, 95, 127], [129, 129, 186, 248, 457]], "test": "untested"}
{"id": "csdyWM", "name": "thoth", "author": "dqvid", "description": "?", "tags": ["3drenderer"], "likes": 1, "viewed": 92, "published": 3, "date": "1698098929", "time_retrieved": "2024-07-30T17:26:20.423824", "image_code": "#define RAM_SIZE 128.0\n\nfloat fade(float value, float start, float end)\n{\n    return (clamp(value,start,end)-start)/(end-start);\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec3 Xrm(vec3 v, float t) {\n    return v*mat3(\n        1, 0, 0,\n        0, cos(t), sin(t),\n        0, sin(t), cos(t));\n}\n    \nvec3 Yrm(vec3 v, float t) {\n    return v*mat3(\n        cos(t), 0, sin(t),\n        0, 1, 0,\n        sin(t), 0, cos(t)\n    );\n}\n\nvec3 Zrm(vec3 v, float t) {\n    return v*mat3(\n        cos(t), sin(t), 0,\n        -sin(t), cos(t), 0,\n        0, 0, 1);\n}\n\nfloat remap01(float a, float b, float c) {\n    return (c-a)/(b-a);\n}\n\nvec4 rayTriangleIntersection(vec3 ro, vec3 rd, mat3 triangle) {\n    vec3 a = triangle[0];\n    vec3 b = triangle[1];\n    vec3 c = triangle[2];\n\n    \n    vec3 ab = b-a;\n    vec3 ac = c-a;\n    vec3 vn = cross(ab, ac);\n    \n    float vn_dot_rd = dot(vn, rd);\n    float vn_dot_ps = dot(vn, a-ro);\n    float t = vn_dot_ps / vn_dot_rd;\n    \n    vec3 vip = ro+rd*t;\n\n    vec3 bc = c-b;\n    vec3 ca = a-c;\n    \n    vec3 a_vip = vip-a;\n    vec3 b_vip = vip-b;\n    vec3 c_vip = vip-c;\n    \n    vec3 atest = cross(ab, a_vip);\n    vec3 btest = cross(bc, b_vip);\n    vec3 ctest = cross(ca, c_vip);\n    \n    return vec4(dot(atest,vn), dot(btest,vn), dot(ctest,vn), t);\n}\n\nint drawQuadrilateral(vec3 ro, vec3 rd, mat4x3 points) {\n    int t;\n    vec4 inter = rayTriangleIntersection(ro, rd, mat3(\n        points[0],\n        points[1],\n        points[2]\n    ));\n    if (inter.x > 0. && inter.y > 0. && inter.z > 0.) t = 1;\n    inter = rayTriangleIntersection(ro, rd, mat3(\n        points[0],\n        points[3],\n        points[2]\n    ));\n    if (inter.x > 0. && inter.y > 0. && inter.z > 0.) t = 1;\n    inter = rayTriangleIntersection(ro, rd, mat3(\n        points[0],\n        points[1],\n        points[3]\n    ));\n    if (inter.x > 0. && inter.y > 0. && inter.z > 0.) t = 1;\n    inter = rayTriangleIntersection(ro, rd, mat3(\n        points[1],\n        points[3],\n        points[2]\n    ));\n    if (inter.x > 0. && inter.y > 0. && inter.z > 0.) t = 1;\n    return t;\n}\n\nint drawRect(vec3 ro, vec3 rd, vec3 pos, vec2 size) {\n    return drawQuadrilateral(ro, rd, mat4x3(\n        vec3(pos),\n        vec3(pos.xy, pos.z+size.y),\n        vec3(pos.x, pos.yz+size),\n        vec3(pos.x, pos.y+size.x, pos.z)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float slice = iResolution.x/RAM_SIZE;\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    // Camera\n    vec3 ro = vec3(-1, uv);\n    vec3 rd = normalize(vec3(1, 0, 0));\n    \n    vec3 accent = vec3(abs(sin(iTime/40.))*.7,abs(sin(iTime/20.))*.7,abs(sin(iTime/60.))*.7);\n    col = accent;\n    \n    vec3 pos = vec3(0,-.7725,-.375);\n    vec2 size = vec2(.747,.75);\n    if (drawRect(ro, rd, pos, size) > 0) col = vec3(.15)+accent;\n    \n    pos = vec3(0,.025,-.375);\n    if (drawRect(ro, rd, pos, size) > 0) col = vec3(.15)+accent;\n\n    pos = vec3(0,-.7225,-.075);\n    size = vec2(.65,.15);\n    if (drawRect(ro, rd, pos, size) > 0) col = accent;\n    \n    pos = vec3(0,.025,-.075);\n    size = vec2(.3485,.15);\n    if (drawRect(ro, rd, pos, size) > 0) col = accent;\n    \n    pos = vec3(0,.425,-.075);\n    size = vec2(.3485,.45);\n    if (drawRect(ro, rd, pos, size) > 0) col = accent;\n\n    if (abs(uv.y) > .42555 || abs(uv.x/iResolution.x*iResolution.y*2.) > .92555) col = vec3(1)-accent;\n\n    // Player\n    vec4 sphere = texture(iChannel0, vec2(0));\n\n    \n    float t = dot(sphere.xyz-ro, rd);\n    vec3 r = ro+rd*t;\n    \n    float y = length(sphere.xyz - r);\n    \n    if (y < sphere.w) {\n        col = vec3(1);\n    }\n    \n    // Sphere enemy 1\n    sphere = texture(iChannel0, vec2(2./RAM_SIZE, 0));\n    \n    t = dot(sphere.xyz-ro, rd);\n    r = ro+rd*t;\n    \n    y = length(sphere.xyz - r);\n    \n    if (y < sphere.w) {\n        col = vec3(rand(uv+iTime*.00000006)*2.-1.97)*30.;\n    }\n    \n    // Vertex 1\n    ro = vec3(-1, uv);\n    rd = normalize(vec3(1, 0, 0));\n    \n    vec3 a = vec3(0,-.0625,.0625);\n    vec3 b = vec3(0,-.0625,-.0625);\n    vec3 c = vec3(0,0,-.125);\n    vec3 d = vec3(0,0,0);\n    \n    mat4x3 quad = mat4x3(a,b,c,d);\n\n    int inter = drawQuadrilateral(ro, rd, quad);\n        // if (inter > 0) col = vec3(1.5)-accent*2.;\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // if (length(data) > 0.) col = vec3(data);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35770, "src": "https://soundcloud.com/dqvid-437164529/impulseandtrail-01-thoth-ost/s-EnoFfUpxw4n?si=e922f1eabe4146dabdeb02263c068617&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "#define RAM_SIZE 128.\n#define G 6.6743*pow(10., -8.)\n\nint up = 87;\nint down = 83;\nint left = 65;\nint right = 68;\n\nfloat fade(float value, float start, float end)\n{\n    return (clamp(value,start,end)-start)/(end-start);\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec4 sphereEnemy(vec4 col, vec2 dataPos) {\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.x;\n    vec4 col = texture(iChannel1, uv);\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 fieldSize = iResolution.xy*.5 - vec2(iResolution.x*.1025*.5, iResolution.y*.2*.5);\n    fieldSize /= iResolution.y;\n    \n    float slice = iResolution.x/RAM_SIZE;\n    \n    if (fragCoord.x < slice) {\n        if (iFrame == 0) col = vec4(vec3(0),.025);\n        vec2 velocity = vec2(0);\n\n        velocity.x = texelFetch( iChannel0, ivec2(right, 0), 0 ).x - texelFetch( iChannel0, ivec2(left, 0), 0 ).x;\n        velocity.y = texelFetch( iChannel0, ivec2(up, 0), 0 ).x - texelFetch( iChannel0, ivec2(down, 0), 0 ).x;\n\n        if (length(velocity) > .0) col.yz += normalize(velocity)*iResolution.x/(1./.008)/iResolution.y;\n\n        col.y = clamp(col.y, -fieldSize.x, fieldSize.x);\n        \n        col.z = clamp(col.z, -fieldSize.y, fieldSize.y);\n    }\n    \n    if (!(fragCoord.x < 3.*slice) && fragCoord.x < 4.*slice) {\n        if (iFrame == 0) col = vec4(vec3(0),0);\n        vec4 player = texture(iChannel1, vec2(0, 0));\n        vec4 enemy = texture(iChannel1, vec2(2./RAM_SIZE, 0));\n        \n        vec3 r = player.xyz - enemy.xyz;\n        \n        vec3 vel = normalize(r)/pow(length(r),2.)*G*500.;\n        \n        if (length(r-vel) > player.w+enemy.w) col.xyz += vel;\n    }\n    \n    if (!(fragCoord.x < 1.*slice) && fragCoord.x < 2.*slice) {\n        if (iFrame == 0) col = vec4(0,-.4,0,.075)*4.;\n        vec4 player = texture(iChannel1, vec2(0, 0));\n        \n        vec3 r = player.xyz - col.xyz;\n        \n        vec3 vel = texture(iChannel1, vec2(3./RAM_SIZE, 0)).xyz;\n        \n        col.xyz += vel;\n    }\n    \n    vec4 player = texture(iChannel1, vec2(0, 0));\n    vec4 enemy = texture(iChannel1, vec2(2./RAM_SIZE, 0));\n    \n    vec3 vel = texture(iChannel1, vec2(3./RAM_SIZE, 0)).xyz;\n    \n    vec3 r = player.xyz-enemy.xyz;\n    \n    if (length(r) < enemy.w+player.w) {\n        if (fragCoord.x < slice) col.xyz = vec3(0);\n        if (!(fragCoord.x < 1.*slice) && fragCoord.x < 2.*slice) col.yz = vec2(rand(iTime)-.5, rand(iTime+1.)-.5)*4.+.2;\n        if (!(fragCoord.x < 3.*slice) && fragCoord.x < 4.*slice) col.xyz = vec3(0);\n    }\n    \n    if (abs((enemy.xyz+vel).y) > fieldSize.x-enemy.w/2.) {\n        if (!(fragCoord.x < 1.*slice) && fragCoord.x < 2.*slice) \n            col.xyz -= normalize(vec3(0, enemy.y, 0)) * (abs(enemy.y) - fieldSize.x + enemy.w);\n        if (!(fragCoord.x < 3.*slice) && fragCoord.x < 4.*slice) \n            col.xyz = reflect(col.xyz, normalize(vec3(0, -enemy.y, 0)));\n    }\n    \n    if (abs((enemy.xyz+vel).z) > fieldSize.y-enemy.w/2.) {\n        if (!(fragCoord.x < 1.*slice) && fragCoord.x < 2.*slice) \n            col.xyz -=  normalize(vec3(0, 0, enemy.z)) * (abs(enemy.z) - fieldSize.y + enemy.w);\n        if (!(fragCoord.x < 3.*slice) && fragCoord.x < 4.*slice) \n            col.xyz = reflect(col.xyz, normalize(vec3(0, 0, -enemy.z)));\n    }\n    \n    fragColor = col;\n}\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 73, 73, 130], [132, 132, 154, 154, 202], [203, 203, 223, 223, 291], [292, 292, 312, 312, 345], [347, 347, 374, 374, 467], [473, 473, 500, 500, 598], [600, 600, 627, 627, 721], [723, 723, 765, 765, 791], [793, 793, 856, 856, 1448], [1450, 1450, 1506, 1506, 2238], [2240, 2240, 2293, 2293, 2478], [2480, 2480, 2537, 2537, 4570]], "test": "untested"}
{"id": "csGfDz", "name": "Fork Trippy Wal LilyIsTran 314", "author": "LilyIsTrans", "description": "Based off https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["trippy"], "likes": 2, "viewed": 136, "published": 3, "date": "1698098809", "time_retrieved": "2024-07-30T17:26:21.256598", "image_code": "\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416,0.557);\n\n\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat sdfCircle(vec2 uv) {\n    return length(uv) - 0.5;\n}\n\nfloat sdfHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdfHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdf(vec2 uv) {\n    return sdfHexagram(uv, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    const float PI = 3.14159265;\n    vec3 modTime = vec3(sin(length(uv) - iTime), sin(length(uv) - iTime - 2.0 * PI / 3.0), sin(length(uv) - iTime - 4.0 * PI / 3.0)) - iTime;\n    \n    for (float i = 0.0; i < 3.0; ++i)\n    {\n        uv = fract(uv * 1.618) - 0.5;\n\n        vec3 d = vec3(sdfHexagon(uv, sin(iTime)) * exp(-sdfHexagram(uv0, sin(iTime))));\n        vec3 col = palette(iTime*0.4 + sdf(uv0) + sdf(uv) + i*0.4);\n\n        d = abs(sin(d * 8.0 + modTime*0.6) / 8.0);\n        d = vec3(pow(0.01 / d.x, 1.2), pow(0.01 / d.y, 1.2), pow(0.01 / d.z, 1.2));\n\n\n\n        finalColor += col * d;\n    }\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 211], [214, 214, 240, 240, 271], [273, 273, 316, 316, 506], [508, 508, 552, 552, 793], [795, 795, 815, 815, 850], [853, 853, 910, 910, 1674]], "test": "untested"}
{"id": "msVBzw", "name": "Siri AI Orb", "author": "Peace", "description": "Siri AI orb visualization", "tags": ["colorful", "sphere", "orb", "shiny", "ai", "sir"], "likes": 3, "viewed": 164, "published": 3, "date": "1698094940", "time_retrieved": "2024-07-30T17:26:22.111312", "image_code": "#define TAU 6.28318530718\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p) {\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\t\n}\n\nfloat fbm(vec2 p, int octaves) {\n\tfloat s = 0.0;\n\tfloat m = 0.0;\n\tfloat a = 0.5;\n\t\n\tif (octaves >= 1)\n\t{\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\t\n\tif (octaves >= 2)\n\t{\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\t\n\tif (octaves >= 3)\n\t{\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\t\n\tif (octaves >= 4)\n\t{\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= 2.0;\n\t}\n\treturn s / m;\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(TAU * (c * t + d));\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.5;\n    float t = iTime;\n\n    float l = dot(uv, uv);\n    fragColor = vec4(0);\n    if (l > 2.5)\n        return;\n    float sm = smoothstep(1.02, 0.98, l);\n    float d = sm * l * l * l * 2.0;\n    vec3 norm = normalize(vec3(uv.x, uv.y, .7 - d));\n    float nx = fbm(uv * 2.0 + t * 0.4 + 25.69, 4);\n    float ny = fbm(uv * 2.0 + t * 0.4 + 86.31, 4);\n    float n = fbm(uv * 3.0 + 2.0 * vec2(nx, ny), 3);\n    vec3 col = vec3(n * 0.5 + 0.25);\n    float a = atan(uv.y, uv.x) / TAU + t * 0.1;\n    col *= pal(a, vec3(0.3),vec3(0.5, 0.5, 0.5),vec3(1),vec3(0.0,0.8,0.8));\n    col *= 2.0;  \n    vec3 cd = abs(col);\n    vec3 c = col * d;\n    c += (c * 0.5 + vec3(1.0) - luma(c)) * vec3(max(0.0, pow(dot(norm, vec3(0, 0, -1)), 5.0) * 3.0));\n    float g = 1.5 * smoothstep(0.6, 1.0, fbm(norm.xy * 3.0 / (1.0 + norm.z), 2)) * d;\n    c += g;\n    col = c + col * pow((1.0 - smoothstep(1.0, 0.98, l) - pow(max(0.0, length(uv) - 1.0), 0.2)) * 2.0, 4.0);\n    float f = fbm(normalize(uv) * 2. + t, 2) + 0.1;\n    uv *= f + 0.1;\n    uv *= 0.5;\n    l = dot(uv, uv);\n    vec3 ins = normalize(cd) + 0.1;\n    float ind = 0.2 + pow(smoothstep(0.0, 1.5, sqrt(l)) * 48.0, 0.25);\n    ind *= ind * ind * ind;\n    ind = 1.0 / ind;\n    ins *= ind;\n    col += ins * ins * sm * smoothstep(0.7, 1.0, ind);\n    col += abs(norm) * (1.0 - d) * sm * 0.25;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 47, 47, 114], [116, 116, 137, 137, 345], [347, 347, 379, 379, 772], [774, 774, 825, 825, 870], [872, 872, 896, 896, 946], [948, 948, 1005, 1005, 2467]], "test": "untested"}
{"id": "msVBzm", "name": "Quick hack for a twitch buddy", "author": "mrange", "description": "Watched a twitch stream that showed some concept art for the stream\nI thought: I could shaderify that for fun!\nThis was a quick remix of existing shaders\n", "tags": ["twitch"], "likes": 33, "viewed": 421, "published": 3, "date": "1698088518", "time_retrieved": "2024-07-30T17:26:23.026864", "image_code": "// CC0: Quick hack for a twitch buddy\n//  Watched a twitch stream that showed some concept art for the stream\n//  I thought: I could shaderify that for fun!\n//  This was a quick remix of existing shaders\n\n#define RESOLUTION      iResolution\n\n// License: Unknown, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n      \n  fragColor = fxaa(iChannel0, q, sqrt(2.0)/RESOLUTION.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// CC0: Quick hack for a twitch buddy\n//  Watched a twitch stream that showed some concept art for the stream\n//  I thought: I could shaderify that for fun!\n//  This was a quick remix of existing shaders\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float PI                  = acos(-1.)   ;\nconst float TAU                 = 2.0*PI      ;\nconst float PI_2                = 0.5*PI      ;\nconst float TOLERANCE           = 1.0E-4      ;\nconst float MAX_RAY_LENGTH      = 20.         ;\nconst float NORM_OFF            = 0.005       ;\nconst float MAX_RAY_MARCHES     = 40.0        ;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff      = 0.;\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.57, 0.70, 0.25));\nconst vec3 sunDir     = normalize(vec3(0.0, 0.0, 1.0)) ;\n\nfloat g_anim;\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors/\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat twistedBoxTorus(vec3 p, vec3 d) {\n  vec2 q = vec2(length(p.xz) - d.x, p.y);\n  float a = atan_approx(p.x, p.z);\n  mat2 r = ROT(a+g_anim);\n  return box(r*q, vec2(d.y))-d.z;\n}\n\nfloat df(vec3 p) {\n  vec3 p0 = p.yzx;\n  float d = twistedBoxTorus(p0, vec3(2.5, 0.5, 0.075));\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float t     = 0.0;\n  vec2 nti = vec2(MAX_RAY_MARCHES,0);\n\n  float i;\n  for (i = 0.0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) break;\n    float d = df(ro + rd*t);\n    if (d<nti.x) nti = vec2(d,t);\n    if (d < TOLERANCE) break;\n    t += d;\n  }\n\n  if(i==MAX_RAY_MARCHES) t = nti.y;\n\n  return t;\n}\n\n\nvec3 normal(vec3 pos) {\n  vec2 eps = vec2(NORM_OFF, 0.0);\n  return normalize(vec3(\n      df(pos+eps.xyy)-df(pos-eps.xyy)\n    , df(pos+eps.yxy)-df(pos-eps.yxy)\n    , df(pos+eps.yyx)-df(pos-eps.yyx))\n    );\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  col += 1E-2*(skyCol*skyCol)/(1.0001+dot(rd, sunDir));\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), -5.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp0 > 0.0) {\n    col += 0.85*(skyCol)*exp(-0.5*(length((ro + tp0*rd).xz)));\n  }\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return col;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n  float te = rayMarch(ro, rd);\n  if (te < MAX_RAY_LENGTH) {\n    vec3 ep = ro+rd*te;\n    vec3 en = normal(ep);\n    vec3 er = reflect(rd, en);\n\n    float fre = 1.0+dot(rd,en);\n    fre *= fre;\n    col += skyCol*0.125;\n    col += mix(0.5, 2.0, fre)*render0(ep, er);\n  } else {\n    col += render0(ro,rd);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  g_anim = 0.125*TIME;\n  const float fov = tan(TAU/6.);\n  const vec3 ro = vec3(0.0, 0.1, 8.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  const vec3 ww = normalize(la - ro);\n  const vec3 uu = normalize(cross(up, ww));\n  const vec3 vv = (cross(ww,uu));\n\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render1(ro, rd);\n  col -= 0.05*length(pp);\n  col = aces_approx(col);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 320, 369, 468, 2511], [2513, 2513, 2570, 2570, 2674]], "test": "untested"}
{"id": "dsKfRw", "name": "Tiling Voronoi", "author": "junithebuncat", "description": "Just a tiling voronoi function I can use as a basis for other things.", "tags": ["voronoi", "tiling"], "likes": 0, "viewed": 132, "published": 3, "date": "1698077196", "time_retrieved": "2024-07-30T17:26:23.929451", "image_code": "\n/////////////////////\n\nvec2 hash2(vec2 uv){\n    vec2 p = vec2(dot(uv,vec2(123.123,456.456)),dot(uv,vec2(1337.1337,0613.0713)));\n    return fract(sin(p)*1234.1234);\n}\n\nvec4 voronoi(vec2 uv, float scale, float seed){\n    vec2 tv= fract(uv) * scale;\n    vec2 ti = floor(tv);\n    vec2 tf = fract(tv);\n    float m_dist = 2.;\n    vec2 m_point;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y<=1; y++){\n            vec2 off = vec2(float(x),float(y));\n            vec2 p = hash2(mod(ti + off,scale)+seed);\n            vec2 diff = off + p - tf;\n            float dist = length(diff);\n            if(dist < m_dist) {\n            m_dist = dist;\n            m_point = p;\n            }\n        }\n    }\n    return vec4(fract(m_point.r*seed));\n}\n\n////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= abs(sin(iTime/10.))+1.;\n    // Output to screen\n    fragColor = voronoi(uv, 10., 123.457);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 44, 44, 166], [168, 168, 215, 215, 743], [767, 767, 824, 874, 1018]], "test": "untested"}
{"id": "DsVfRm", "name": "watercolour Moss", "author": "gustav", "description": "watercolour moss thingy i made for a backround", "tags": ["simplex"], "likes": 2, "viewed": 162, "published": 3, "date": "1698071260", "time_retrieved": "2024-07-30T17:26:24.845003", "image_code": "const float PERLIN_SEED = 0.;\n\nfloat random(vec2 xy) {\n    return fract(sin(dot(xy, vec2(12.9898 - PERLIN_SEED, 78.233 + PERLIN_SEED))) * 43758.5453 + PERLIN_SEED);\n}\n\nfloat interpolate(float a, float b, float x) {\n    return mix(a, b, (1.0 - cos(x * 3.1415927)) * 0.5);\n}\n\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    float m = step(a.y, a.x);\n    vec2 o = vec2(m, 1.0 - m);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n    return dot(n, vec3(70.0));\n}\n\n\nfloat perlinNoise(vec2 uv) {\n    \n    float f = 0.0;\n    for (int i = 0; i < 8; i++) {\n        f += pow(0.5, float(i)) * noise(uv);\n        mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n        uv = m * uv;\n    }\n    return 0.5 + 0.5 * f;\n}\n\n\n\nconst mat4 FOREGROUND_COLORS = mat4(\n    34.0, 34.0, 42.0, 256.0,\n    232.0, 141.0, 122.0, 256.0,\n    90.0, 188.0, 94.0, 256.0,\n    161.0, 90.0, 188.0, 256.0\n) / 256.0;\n\nconst vec4 BACKGROUND_COLOR = vec4(0., 255., .0, 255.) / 256.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy / iResolution.xy) * 5.3;\n    float seed = 1.0;\n\n    float r = perlinNoise(p + iTime * 0.03);\n    vec4 fgColor = FOREGROUND_COLORS[0];\n\n    float noiseScale = 0.054 + 0.075 * mod(seed, 3.0);\n    float numLayers = 2.0 + 2.0 * mod(seed, 5.0);\n    seed *= numLayers;\n    float v = 0.0;\n\n    for (float i = 0.0; i < numLayers; i++) {\n        v += step(0.7, noiseScale * perlinNoise(p + vec2(i + seed)) + r) / numLayers;\n        noiseScale += 0.5;\n    }\n\n    vec4 finalColor = mix(FOREGROUND_COLORS[0] * 1.6, fgColor, v);\n\n    seed = 8.0;\n    r = perlinNoise(p + 20.0 + iTime * 0.03);\n    fgColor = FOREGROUND_COLORS[0];\n\n    noiseScale = 0.054 + 0.075 * mod(seed, 3.0);\n    numLayers = 8.0 + 2.0 * mod(seed, 5.0);\n    seed *= numLayers;\n    v = 0.0;\n\n    for (float i = 0.0; i < numLayers; i++) {\n        v += step(0.3, noiseScale * perlinNoise(p + vec2(i + seed)) + r) / numLayers;\n        noiseScale += 0.05;\n    }\n\n    fragColor = mix(BACKGROUND_COLOR, finalColor, v);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 54, 54, 166], [168, 168, 214, 214, 272], [275, 275, 294, 294, 421], [423, 423, 447, 447, 918], [921, 921, 949, 949, 1151], [1390, 1390, 1445, 1445, 2441]], "test": "untested"}
{"id": "mdKBzW", "name": "Weird Raymarch", "author": "AndreCorrea", "description": "first raymarch implementation, set a stepsize bigger than 0.9 and got this funny result", "tags": ["raymarching", "fractal", "sdf", "cube", "sphere"], "likes": 4, "viewed": 173, "published": 3, "date": "1698070377", "time_retrieved": "2024-07-30T17:26:25.667803", "image_code": "\n\nprecision mediump float;\n\nconst int MAX_MARCHING_STEPS = 100;\nconst float THRESHOLD = 0.00000001;\n\n\nfloat sdSphere(vec3 p,vec3 c,float r) {\n  c.x = sin(iTime) * 0.1;\n  c.y = cos(iTime) * 0.1;\n  c.z = sin(iTime) * 0.1; \n  return length(p - c) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat stepSize =4.0;\n\nvec3 repeat(vec3 p){\n  float s = 3.1415927;\n  p.x = p.x - s*round(p.x/s);\n  p.y = p.y - s*round(p.y/s);\n  p.z = p.z - s*round(p.z/s);\n  return p;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat scene(vec3 p) {\n\n  p = repeat(p);\n  float box = sdRoundBox(p, vec3(0.1, 0.1, 0.1), 0.1);\n  float sphere = sdSphere(p, vec3(0, 0, 0), 0.25);\n  float d = opSmoothUnion(box, sphere, 0.1);\n  return sin(iTime*d*0.1);\n}\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.00001; // Adjust as needed\n    \n    float dx = (scene(p + vec3(eps, 0, 0)) - scene(p - vec3(eps, 0, 0))) / (2.0 * eps);\n    float dy = (scene(p + vec3(0, eps, 0)) - scene(p - vec3(0, eps, 0))) / (2.0 * eps);\n    float dz = (scene(p + vec3(0, 0, eps)) - scene(p - vec3(0, 0, eps))) / (2.0 * eps);\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 march(vec3 cam, vec3 dir) {\n  float totalDistance = 0.0;\n  vec3 currentPos = cam;\n  vec3 fogColor = vec3(0.8, 0.8, 0.8); // Adjust as needed\n  float fogDensity = 0.05; // Adjust as needed\n  vec3 col = vec3(0.0);\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\n    float dist = scene(currentPos);\n    if ((dist < THRESHOLD)&&(length(currentPos)>0.1)) {\n      vec3 normal = calcNormal(currentPos);\n      vec3 lightDir = normalize(vec3(-1.0, -1.0, -1.0)); \n\n      float lightIntensity = max(dot(normal, -lightDir), 0.0);\n      vec3 ambientLight = vec3(0.2, 0.2, 0.2);\n      vec3 col = vec3(1.0, 1.0, 1.0) * lightIntensity + ambientLight; \n      return col;\n    }\n    totalDistance += dist;\n    currentPos += dir * stepSize;\n  }\n\n\n  return col;\n}\n\nfloat zoomFactor = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1, 1);\n    vec3 col = vec3(1);\n\n    // Define camera position and direction\n\n    vec3 dir = normalize(vec3(uv, 1));\n\n    // Get mouse rotation\n\n\n    float rotX = iMouse.y / iResolution.y * 8.; // Adjust the sensitivity as needed\n    float rotY = iMouse.x / iResolution.x * 8.;\n    rotY += iTime * 0.1;\n\n    vec3 cam = vec3(0, 0, 0.0);\n    mat3 rotationMatrix = mat3(\n        cos(rotY), 0, sin(rotY),\n        0, 1, 0,\n        -sin(rotY), 0, cos(rotY)\n    ) * mat3(\n        1, 0, 0,\n        0, cos(rotX), -sin(rotX),\n        0, sin(rotX), cos(rotX)\n    );\n\n    cam = rotationMatrix * cam;\n    dir = normalize(rotationMatrix * dir);\n\n    col = march(cam, dir);\n\n    fragColor = vec4(col, 1.0); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 141, 141, 250], [252, 252, 297, 297, 388], [414, 414, 434, 434, 561], [563, 563, 615, 615, 714], [716, 716, 737, 737, 935], [937, 937, 962, 962, 1323], [1325, 1325, 1357, 1357, 2075], [2102, 2102, 2159, 2159, 2978]], "test": "untested"}
{"id": "DdKBRm", "name": "vhs.glsl", "author": "src3453", "description": "vhs filter written in GLSL", "tags": ["vhs", "ntsc", "artifact"], "likes": 10, "viewed": 857, "published": 3, "date": "1698069288", "time_retrieved": "2024-07-30T17:26:26.438742", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 画像の解像度を取得\n    vec2 resolution = iResolution.xy;\n\n    // ピクセルのUV座標を取得\n    vec2 uv = fragCoord / resolution;\n\n    // テクスチャからピクセルカラーを取得\n    // 畳み込みフィルタのカーネルを定義\n    float kernel[9];\n    kernel[0] = -4.0 / 9.0;\n    kernel[1] = -3.0 / 9.0;\n    kernel[2] = -2.0 / 9.0;\n    kernel[3] = -1.0 / 9.0;\n    kernel[4] = 0.0 / 9.0;\n    kernel[5] = 1.0 / 9.0;\n    kernel[6] = 2.0 / 9.0;\n    kernel[7] = 3.0 / 9.0;\n    kernel[8] = 4.0 / 9.0;\n\n    vec3 convolvedColor = vec3(0.0);\n\n    // hsyncジッターを計算\n    float hsync = floor(noise(vec2(uv.g*50.0,0.0),iTime*5.5383)*3.0);\n    // 畳み込み演算を実行\n    for (int i = -4; i <= 4; i++) {\n        for (int j = -0; j <= 0; j++) {\n            vec2 offset = vec2(float(i), float(j));\n            convolvedColor += texture(iChannel0, uv + (offset + vec2(hsync,0.0)) / resolution).rgb * kernel[(i + 5)  + (j + 1)];\n        }\n    }\n    // テクスチャからピクセルカラーを取得\n    vec3 originalColor = convolvedColor;\n\n    fragColor = vec4(originalColor,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float random(vec2 st, float seed){\n    return fract(sin(seed+dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n\n//参考:https://thebookofshaders.com/11/\nfloat noise (in vec2 st, float seed) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i,seed);\n    float b = random(i + vec2(1.0, 0.0),seed);\n    float c = random(i + vec2(0.0, 1.0),seed);\n    float d = random(i + vec2(1.0, 1.0),seed);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 画像の解像度を取得\n    vec2 resolution = iResolution.xy;\n\n    // ピクセルのUV座標を取得\n    vec2 uv = fragCoord / resolution;\n\n    // テクスチャからピクセルカラーを取得\n    vec3 originalColor = texture(iChannel0, uv).rgb;\n    // YCbCr変換\n    float Y = 0.299 * originalColor.r + 0.587 * originalColor.g + 0.114 * originalColor.b;\n    float Cb = 0.564 * (originalColor.b - Y);\n    float Cr = 0.713 * (originalColor.r - Y);\n    \n    vec3 diff = texture(iChannel0, uv+vec2(1.0/resolution.x,0)).rgb - texture(iChannel0, uv).rgb;\n    float diffY = 0.299 * diff.r + 0.587 * diff.g + 0.114 * diff.b;\n\n    // 色相信号にノイズを追加\n    float hueNoise1 = noise(vec2(uv.r*50.0,uv.g*50.0),iTime*5.5383) * 0.1-0.05; // ノイズの範囲を調整\n    float hueNoise2 = noise(vec2(uv.r*50.0,uv.g*50.0),iTime*2.2546) * 0.1-0.05; // ノイズの範囲を調整\n    float hueNoise3 = noise(vec2(uv.r*5.0,uv.g*30.0),iTime*6.4623) * 0.15-0.075; // ノイズの範囲を調整\n    float hueNoise4 = noise(vec2(uv.r*5.0,uv.g*30.0),iTime*8.4352) * 0.15-0.075; // ノイズの範囲を調整\n    // 色相情報にノイズを加える\n    Cr += hueNoise1;\n    Cb += hueNoise2;\n    Cr += hueNoise3;\n    Cb += hueNoise4;\n    \n    //エンファシス\n    Cb *= 1.5;\n    Cr *= 1.5;\n    Y  *= 0.75;\n    \n    //クロスカラー\n    Cb = Cb + cos(fragCoord.x) * diffY;\n    Cr = Cr + sin(fragCoord.x) * diffY;\n    \n    // YCbCrからRGBに戻す\n    float R = Y + 1.403 * Cr;\n    float G = Y - 0.344 * Cb - 0.714 * Cr;\n    float B = Y + 1.773 * Cb;\n    \n    fragColor = vec4(R,G,B,1.0);\n\n   \n}\n", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //TODO lowpass実装する\n    fragColor = texture(iChannel0,fragCoord / iResolution.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 92, 1188]], "test": "untested"}
{"id": "Ddyfzm", "name": "Yukawa Potential Visualize", "author": "minHieu", "description": "fe", "tags": ["brownianmotion", "randomwalk"], "likes": 7, "viewed": 194, "published": 3, "date": "1698042868", "time_retrieved": "2024-07-30T17:26:27.358283", "image_code": "float get_t() {\n  return 20.*(float(iFrame)*0.005);\n}\n\nvec4 drawBoundary(vec2 uv, vec2 p, vec4 oldCol) {\n    vec2 uv_ = uv - p;\n    float r = length(uv_);\n    float theta = atan(uv_.x, uv_.y);\n    \n    vec4 col = oldCol;\n    if (r > 0.3 && r < 0.305 && sin(40.*theta) > 0.5)\n        col = vec4(0.); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = normalize_uv(fragCoord, iResolution.xy);\n    \n    vec4 white = vec4(1.0);\n    vec4 black = vec4(0.0);\n    vec4 green = vec4(0.0476, 0.680, 0.0898,1.0);\n    \n    fragColor = white;\n    if (length(uv-vec2(0.9,0.5)) < 0.3){\n        float mu = length(uv-vec2(0.9,0.5));\n        float sigma = 0.13;\n\n        float g = exp(-(mu*mu)/(2.*sigma*sigma));\n        fragColor = (1.-g)*white + g*green;\n    }\n    \n    fragColor = drawBoundary(uv, vec2(0.9, 0.5), fragColor);\n    fragColor = drawBoundary(uv, vec2(0.1, 0.5), fragColor);\n\n    if (length(uv-vec2(0.1,0.5)) < 0.3){\n        vec2 trace  = texelFetch(iChannel0, ivec2(0,0), 0).xy;\n        float w = min(texelFetch(iChannel1, ivec2(fragCoord), 0).x, 1.);\n        fragColor = w*green + (1.-w)*white;\n        \n        for (int i=0; i < 10; i++) {\n            vec2 walker = texelFetch(iChannel0, ivec2(0,i), 0).xy;\n            float r = length(uv-walker);\n            if (r < 0.01) \n                fragColor = green;\n            if (r > 0.01 && r < 0.015) \n                fragColor = black;\n        }\n    }\n    \n    // fragColor = vec4(1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\nconst float PI2 = 6.28319;\n\n// misc function \nfloat get_t(float f) {\n  return 20.*fract(float(f)*0.005);\n}\n\n// from Alex Jacobson's Curve Inflation \n// https://www.shadertoy.com/view/7tyyzW\nint  seed = 1;\nvoid srand(int s) {\n    seed = s;\n}\nint randi(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\nfloat rand(void) {\n    return float(randi())/32767.0;\n}\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\nvec2 rand_circ(void) {\n    float theta = PI2*rand();\n    return vec2(cos(theta),sin(theta));\n}\n\nvec2 normalize_uv(vec2 in_uv, vec2 res) {\n    vec2 uv = in_uv/res.xy;\n    if (res.x > res.y) {\n        uv.x *= res.x / res.y;\n        uv.x += .5 * (1. - res.x / res.y);\n    } else {        \n        uv.y *= res.y / res.x;\n        uv.y += .5 * (1. - res.y / res.x);\n    }\n    return uv;\n}", "buffer_a_code": "float get_t() {\n  return 40.*(float(iFrame)*0.005);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x + hash(q.y + hash(iFrame))));\n    \n    vec2 x = normalize_uv(fragCoord, iResolution.xy);\n    float dt = 0.00005;\n    vec2 W = 2.*vec2(rand(),rand())-vec2(1.);\n    vec2 dx = vec2(0.)*dt + sqrt(2.)*sqrt(dt)*W; \n    \n    if (get_t() < 0.3)\n        fragColor = vec4(vec2(0.1,0.5),0.0,1.0);\n    else {\n        vec2 prev_x = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n        fragColor = vec4(prev_x + dx,0.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float get_t() {\n  return 20.*(float(iFrame)*0.005);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = normalize_uv(fragCoord, iResolution.xy);\n    \n    fragColor = vec4(0.0);\n    \n    \n    for (int i=0; i < 10; i++) {\n        vec2 walker = texelFetch(iChannel0, ivec2(0,i), 0).xy;\n\n        if (length(uv-walker) < 0.005) {\n            fragColor = vec4(0.03);\n        }\n    }\n    \n    vec4 prev_col = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = fragColor += prev_col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ddyfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 104, 104, 322], [324, 324, 381, 381, 1483]], "test": "untested"}
{"id": "csGfRm", "name": "Trippy Wallpaper Nonsense", "author": "LilyIsTrans", "description": "Based off https://www.youtube.com/watch?v=f4s1h2YETNY", "tags": ["trippy"], "likes": 2, "viewed": 165, "published": 3, "date": "1698029758", "time_retrieved": "2024-07-30T17:26:28.120246", "image_code": "\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416,0.557);\n\n\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat sdfCircle(vec2 uv) {\n    return length(uv) - 0.5;\n}\n\nfloat sdfHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdfHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdf(vec2 uv) {\n    return sdfHexagram(uv, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    float modTime = sin(length(uv) - iTime) + iTime;\n    \n    for (float i = 0.0; i < 3.0; ++i)\n    {\n        uv = fract(uv * 1.618) - 0.5;\n\n        float d = sdf(uv) * exp(-sdf(uv0));\n        vec3 col = palette(modTime*0.4 + sdf(uv0) + sdf(uv) + i*0.4);\n\n        d = abs(sin(d * 8.0 + modTime*0.6) / 8.0);\n        d = pow(0.01 / d, 1.2);\n\n\n\n        finalColor += col * d;\n    }\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 211], [214, 214, 240, 240, 271], [273, 273, 316, 316, 506], [508, 508, 552, 552, 793], [795, 795, 815, 815, 850], [853, 853, 910, 910, 1458]], "test": "untested"}
{"id": "cdyBRw", "name": "Audio Line", "author": "Peace", "description": "Audio Line", "tags": ["line", "audio"], "likes": 2, "viewed": 63, "published": 3, "date": "1698017915", "time_retrieved": "2024-07-30T17:26:28.883206", "image_code": "const float PI = 3.14159265358;\n\nfloat rand(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat noiseStack(vec3 pos,int octaves,float falloff){\n\tfloat n = noise(vec3(pos));\n\tfloat off = 1.0;\n\tif (octaves>1) {\n\t\tpos *= 2.0;\n\t\toff *= falloff;\n\t\tn = (1.0-off)*n + off*noise(vec3(pos));\n\t}\n\tif (octaves>2) {\n\t\tpos *= 2.0;\n\t\toff *= falloff;\n\t\tn = (1.0-off)*n + off*noise(vec3(pos));\n\t}\n\tif (octaves>3) {\n\t\tpos *= 2.0;\n\t\toff *= falloff;\n\t\tn = (1.0-off)*n + off*noise(vec3(pos));\n\t}\n\treturn (1.0+n)/2.0;\n}\n\nvec2 noiseStackUV(vec3 pos,int octaves,float falloff,float diff){\n\tfloat displaceA = noiseStack(pos,octaves,falloff);\n\tfloat displaceB = noiseStack(pos+vec3(3984.293,423.21,5235.19),octaves,falloff);\n\treturn vec2(displaceA,displaceB);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res;\n\n    const float w = 0.05; // Line Width\n    const vec3 c = vec3(0, 0.05, 1); // Line Color\n    \n    \n    vec3 col = vec3(0);\n    float audio = texelFetch(iChannel0, ivec2(0), 0).r;\n    float y = sin((-iTime * 0.5 + uv.x) * PI) / (2.0 + uv.x * uv.x * 8.0) * audio;\n    float vy = uv.y + 0.4;\n    \n    float d1 = smoothstep(w, 0.0, abs(vy - y));\n    col += c * d1;\n    col += d1 * d1 * d1 * d1 * 0.5;\n    \n    float d2 = smoothstep(w, 0.0, abs(vy + y));\n    col += c * d2;\n    col += d2 * d2 * d2 * d2 * 0.5;\n    \n    float d3 = smoothstep(w, 0.0, abs(vy - y * 0.5));\n    col += c * d3 * 0.3;\n    col += d3 * d3 * d3 * d3 * 0.2;\n    \n    float d4 = smoothstep(w, 0.0, abs(vy + y * 0.5));\n    col += c * d4 * 0.3;\n    col += d4 * d4 * d4 * d4 * 0.2;\n    \n    // Sparks\n    const float up_flow = 8.0;\n\tfloat spark_grid_size = min_res / 20.0;\n    float rt = iTime * 0.5;\n\tvec2 spark_uv = fragCoord - spark_grid_size * vec2(0, up_flow * rt);\n\tspark_uv -= spark_grid_size * noiseStackUV(0.01 * vec3(spark_uv, 30.0 * iTime), 1, 0.4, 0.1);\n\tif (mod(spark_uv.y / spark_grid_size, 2.0) < 1.0) spark_uv.x += 0.5 * spark_grid_size;\n\tvec2 spark_grid_idx = vec2(floor(spark_uv / spark_grid_size));\n\tfloat spark_random = rand(spark_grid_idx);\n\tfloat spark_life = min(10.0 * (1.0 - min((spark_grid_idx.y) / (24.0 - 20.0 * spark_random), 1.0)), 1.0) * (0.6 + 0.45 * audio);\n\tvec3 sparks = vec3(0);\n\tif (spark_life > 0.0) {\n\t\tfloat spark_size = spark_random * 0.3;\n\t\tfloat spark_radians = 999.0 * spark_random * 2.0 * PI + 2.0 * iTime;\n\t\tvec2 spark_circular = vec2(sin(spark_radians), cos(spark_radians));\n\t\tvec2 spark_off = (0.5 - spark_size) * spark_grid_size * spark_circular;\n\t\tvec2 spark_modulus = mod(spark_uv + spark_off, spark_grid_size) - 0.5 * vec2(spark_grid_size);\n\t\tfloat spark_length = length(spark_modulus);\n\t\tfloat sparks_gray = max(0.0, 1.0 - spark_length / (spark_size * spark_grid_size));\n\t\tsparks = spark_life * sparks_gray * c + pow(spark_life * sparks_gray, 4.0);\n\t}\n    sparks *= smoothstep(-0.4, -0.0, uv.y);\n    sparks *= smoothstep(1.0, 0.0, uv.y);\n    col += sparks;\n    \n    col *= 1.0 - abs(fragCoord.x / iResolution.x * 2.0 - 1.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdyBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 54, 54, 121], [123, 123, 146, 146, 193], [194, 194, 215, 215, 262], [263, 263, 282, 282, 323], [325, 325, 346, 346, 837], [839, 839, 892, 892, 1247], [1249, 1249, 1314, 1314, 1485], [1487, 1487, 1544, 1544, 3837]], "test": "untested"}
{"id": "msKBRW", "name": "Siri AI", "author": "Peace", "description": "Siri Wave", "tags": ["wave", "siri"], "likes": 2, "viewed": 92, "published": 3, "date": "1698012501", "time_retrieved": "2024-07-30T17:26:29.668108", "image_code": "const float PI = 3.14159265358;\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    float h = clamp(0.5 + 0.5 * (a.w - b.w) / k, 0.0, 1.0);\n    return mix(a, b, h) - k * h * (1.0 - h);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n        \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.5;\n    float t = iTime;\n    const float w = 0.01; // Line Width\n    const float f = 1.0; // Frequency\n    const float b = 60.0; // Bands\n    float amp = 0.8 * texelFetch(iChannel0, ivec2(0), 0).r; // Amplitude\n\n    float xd = abs(uv.x);\n    float falloff = (1.0 - exp(-xd * xd) + uv.x * uv.x * 0.05);\n    vec4 d = vec4(vec3(0), 999999.0);\n    float off = t * 2.0;\n    float fm = (1.0 + 0.3 * sin(t));\n    float x = uv.x * PI * f * fm - off;\n    vec4 y1 = vec4(vec3(1.0, 0.0, 0.0), sin(x));\n    vec4 y2 = vec4(vec3(0.0, 0.7, 1.0), sin(x + 1.0) * 0.5);\n    vec4 y3 = vec4(vec3(1.0, 0.0, 1.0), sin(x + 1.8) * 1.1);\n    vec4 y4 = vec4(vec3(0.0, 1.0, 1.0), sin(x + 3.0) * 0.7);\n    float am = amp / (1.0 + xd * xd * 4.0);\n    for (float i = 0.0; i <= 1.001; i += 1.0 / b) {\n        vec4 yy1 = mix(y1, y2, i);\n        vec4 yy2 = mix(y3, y4, i);\n        vec4 y = mix(yy1, yy2, i);\n        y.w = abs(uv.y - y.w * am) - w + falloff * 0.05;\n        y.rgb *= y.rgb;\n        d = smin(y, d, 0.05);\n    }\n    float a = 0.01;\n    float c = smoothstep(a, -a, d.w);\n    vec3 col = d.rgb * sqrt(c) * 0.5;\n    col += pow(luma(col), 0.3) * 1.0;\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 69, 69, 176], [178, 178, 202, 202, 252], [262, 262, 317, 317, 1599]], "test": "untested"}
{"id": "DdyfzD", "name": "Nyan Dot Writer", "author": "misol101", "description": "Colorful version!\n\nENTER to restart.", "tags": ["2d", "text", "dots", "dot", "transform", "multipass", "writer"], "likes": 8, "viewed": 201, "published": 3, "date": "1698005808", "time_retrieved": "2024-07-30T17:26:30.617569", "image_code": "float FPS = 10.f;\nivec2 AtlasSize = ivec2(6, 1);\nivec2 FrameSize = ivec2(40.f, 32.f);\n\nvoid getNyan( inout vec4 fragColor, in vec2 uv ) {\n    int frame = int(floor(iTime*FPS));\n    int frameNum = frame % (AtlasSize.x * AtlasSize.y);\n    ivec2 currentFramePosition = ivec2(frameNum % AtlasSize.x, frameNum / AtlasSize.x);\n    \n    vec4 color = texture(iChannel1, uv/vec2(AtlasSize) + vec2(currentFramePosition*FrameSize)/iChannelResolution[1].xy);\n    if (color.w > 0.9) fragColor = color*color*1.55;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 v3 = texelFetch( iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)), 0 ).xyz;\n\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    vec3 white = abs(uv.y) < 0.43 && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? vec3(0.8,1,1) : vec3(0.);\n    fragColor = vec4( v3 + white, 1.0 );\n\n    ivec2 r = ivec2(iResolution.xy);\n    ivec4 npos = ivec4(texelFetch(iChannel2, ivec2(2,0), 0 ));\n\n    vec2 sp = getStartPos(npos.y, iResolution.xy, iTime);\n    if (int(texelFetch(iChannel2, ivec2(1,0), 0 ).x) == 1) { sp = vec2(float(int(npos.x)%r.x), iResolution.y - float(int(npos.x)/r.x)); }\n        \n    vec2 pos = (sp/iResolution.y) - 0.5;\n    pos.x += (1. - iResolution.x/iResolution.y) * 0.5;\n\n    vec2 siz = vec2(0.077,0.067);\n    if (abs(uv.x-pos.x) < siz.x && abs(uv.y-pos.y)< siz.y) {\n        vec2 uv2 = ((uv-pos)/siz*0.5 + 0.5);\n        getNyan(fragColor, uv2);\n    }\n}\n", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// send away dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (readKey(KEY_ENTER)) { fragColor=vec4(0); return; }\n    if (int(texelFetch(iChannel1, ivec2(0,0), 0).w) != int(iResolution.x)) { fragColor=vec4(0); return; }\n    \n    int pxi = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - 3;\n    if (pxi > NOF_DOTS) discard;\n\n    ivec2 r = ivec2(iResolution.xy);\n\n    if (ivec2(0,0) == ivec2(fragCoord)) {\n        ivec4 val = ivec4(texelFetch(iChannel0, ivec2(0,0), 0 ));\n        int tv = (1-int(texelFetch(iChannel0, ivec2(1,0), 0 ).x))*2-1;\n        if (iFrame < 2) {\n            val = ivec4(0);\n        } else {\n            int v=val[DOTS_PER_FRAME-1];\n            for (int j = 0; j<DOTS_PER_FRAME; j++) {\n                for (int i = 0; i < 5000; i++) { // search for lit pixel\n                    v+=1*tv;\n                    vec2 p=vec2(v%r.x,r.y-v/r.x);\n\n                    if (texelFetch(iChannel1,ivec2(p),0).x > 0.1) {\n                        break;\n                    }\n                }\n                val[j] = v;\n            }\n        }\n        fragColor = vec4(val);\n        return;\n    }\n\n    if (ivec2(1,0) == ivec2(fragCoord)) {\n        ivec4 val = ivec4(texelFetch(iChannel0, ivec2(0,0), 0 ));\n        int tv =  int(texelFetch(iChannel0, ivec2(1,0), 0 ).x);\n        if (iFrame < 2) {\n            tv = 0;\n        } else {\n            if (val.x > int(iResolution.x*iResolution.y)+5000*NOF_STEPS*3) tv=1;\n            if (val.x < 0) tv=0;\n        }\n        fragColor = vec4(tv);\n        return;\n    }\n    if (ivec2(2,0) == ivec2(fragCoord)) {\n        fragColor = texelFetch(iChannel0, ivec2(0,0), 0 );\n        return;\n    }\n\n    vec2 sp=vec2(0), ep=vec2(0);\n    int dotFound = -1;\n    for (int i=0; i<DOTS_PER_FRAME; i++) {\n        if ((pxi+i*(NOF_STEPS+1)) % NOF_DOTS == iFrame % NOF_DOTS)\n            dotFound = i;\n    }\n\n    if (dotFound >= 0) { // initialize new dot\n        int i = int(texelFetch(iChannel0, ivec2(0,0), 0 )[dotFound]);\n        vec2 p=vec2(i%r.x,r.y-i/r.x);\n\n        if (texelFetch(iChannel1,ivec2(p),0).x > 0.1) {\n            sp = getStartPos(i, iResolution.xy, iTime);\n            ep = p;\n            if (int(texelFetch(iChannel0, ivec2(1,0), 0 ).x) == 1) { ep=sp; sp=p; }\n        }\n        fragColor = vec4(sp, ep);\n    }\n    else { // update active dot\n        vec4 cs = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n        int count = (int(cs.w) >> 12) + 1;\n        int ai = int(cs.w) & 4095;\n        cs.w = float((count<<12) | ai);\n        vec2 ep = vec2(cs.z, ai);\n        \n        if (count >= NOF_STEPS) {\n            cs.x=ep.x; cs.y=ep.y; cs.w=float((NOF_STEPS<<12) | ai);\n        } else {\n            vec2 cp = cs.xy;\n            vec2 ap = (ep-cp)/(float(NOF_STEPS)-float(count));\n            cs.x += ap.x;\n            cs.y += ap.y;\n        }\n        fragColor = cs;\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int NOF_STEPS = 120;\n\nconst int DOTS_PER_FRAME = 4; // 1-4, higher value writes faster\n\nconst int NOF_DOTS = (NOF_STEPS + 1) * DOTS_PER_FRAME;\n\nconst int NOF_REGIONS = 9; // 2-9\nconst int BPC = NOF_REGIONS * NOF_REGIONS /4 + 1;\n\n#define LARGE_DOTS\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_D     = 68;\n\n#define readKey(key) (texelFetch( iChannel3, ivec2(key, 0), 0).x > .5)\n#define readKeyToggle(key) (texelFetch( iChannel3, ivec2(key, 2), 0).x > .5)\n\nconst vec4 rainbow[6] = vec4[]( vec4(1,0,0,0), vec4(1,0.66,0,0), vec4(1,1,0,0), vec4(0,1,0,0), vec4(0,0.6,1,0), vec4(1,0.3,1,0) );\n\nvec2 getStartPos(int i, vec2 resolution, float time) {\n    vec2 sp;\n    float progr = float(i / int(resolution.x)) / resolution.y;\n    if (progr > 0.7)\n        sp = vec2(resolution.x*0.5+sin(time*8.)*(resolution.x*0.25), resolution.y*0.82);\n    else if (progr > 0.4)\n        sp = vec2(0.55*resolution.x+sin(time*3.)*(resolution.x*0.1), 0.44*resolution.y+cos(time*3.)*(resolution.y*0.16));\n    else\n        sp = vec2(resolution.x*0.5+sin(time*6.)*(resolution.x*0.19), resolution.y*0.2);\n    return sp;\n}", "buffer_b_code": "// check which regions have dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int pxi = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - 3;\n    if (pxi > NOF_DOTS) discard;\n    \n    if (ivec2(0,0)==ivec2(fragCoord)) {\n\n        int xd=int(iResolution.x) / NOF_REGIONS + 1;\n        int yd=int(iResolution.y) / NOF_REGIONS + 1;\n        ivec2 r = ivec2(iResolution.xy);\n\n        ivec4 regions = ivec4(0);\n        for (int i=3; i<NOF_DOTS+3; i++) {\n            ivec2 p=ivec2(i%r.x,i/r.x); \n            vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n            \n            int xr=int(px.x) / xd;\n            int yr=int(px.y) / yd;\n            int reg = xr + yr * NOF_REGIONS;\n            int cp = reg / BPC;\n            int bp = reg % BPC;\n            regions[cp] |= (1<<bp);\n        }\n        fragColor = vec4(regions);\n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// draw dots in place and fade old ones\n\nconst float END_VAL = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (readKey(KEY_ENTER)) { fragColor=vec4(0); return; }\n    if (int(texelFetch(iChannel2, ivec2(0,0), 0).w) != int(iResolution.x)) { fragColor=vec4(0); return; }\n\n    ivec2 r = ivec2(iResolution.xy);\n\n    float cellx = iResolution.x / 32.;\n    vec4 rcol = rainbow[int(fragCoord.x/cellx) % 6];\n\n    vec4 org = max(vec4(0.),texelFetch(iChannel1, ivec2(fragCoord), 0 ) - vec4(vec3(0.15),0.));\n    \n    if (org.w >= END_VAL) { // keep this finished dot, unless it is one of our current start dots when reversing\n        bool isInit = false;\n        ivec4 inits = ivec4(texelFetch(iChannel0, ivec2(2,0), 0 ));\n        for (int i=0; i<DOTS_PER_FRAME; i++) {\n            if(ivec2(fragCoord)==ivec2(inits[i]%r.x,r.y-inits[i]/r.x))\n                isInit = true;\n        }\n        fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ).xyz*rcol.xyz, isInit ? 0. : END_VAL);\n        return;\n    }\n\n    vec4 regions = texelFetch(iChannel0, ivec2(0,0), 0 ); //regions = vec4(2097151.0);\n    int xd=int(iResolution.x) / NOF_REGIONS + 1;\n    int xr=int(fragCoord.x) / xd;\n    int yd=int(iResolution.y) / NOF_REGIONS + 1;\n    int yr=int(fragCoord.y) / yd;\n    int reg = xr + yr * NOF_REGIONS;\n    int cp = reg / BPC;\n    int bp = reg % BPC;\n    if ((int(regions[cp]) & (1<<bp)) == 0) {\n        fragColor = org;\n        if (readKeyToggle(KEY_D)) fragColor = vec4(0.5); // see skipped regions\n        return;\n    }\n\n    float hitadd = 1.0;\n    int ended = 0;\n\n    for (int i=3; i<NOF_DOTS+3; i++) {\n        ivec2 p=ivec2(i%r.x,i/r.x); \n        vec4 pxzw = texelFetch(iChannel0, p, 0 );\n        vec2 px = pxzw.xy;\n#ifdef LARGE_DOTS\n        if (distance(px,fragCoord) < 2.5) {\n            if ((int(pxzw.w) >> 12) >= NOF_STEPS) { if (ended==0) ended=1; if (ivec2(px) == ivec2(fragCoord)) ended = 2; }\n#else\n        if (ivec2(px) == ivec2(fragCoord)) {\n            if ((int(pxzw.w) >> 12) >= NOF_STEPS) ended = 2;\n#endif\n            vec4 my_rcol = rainbow[int(pxzw.z/cellx) % 6];\n            org = hitadd * my_rcol;\n            // break; // slows things down, a lot...\n        }\n    }\n    if (ended > 0) { fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ).xyz * rcol.xyz, ended == 1 ? org.w : END_VAL); return; }\n    vec4 cols[2] = vec4[]( vec4(0,0,1,0),vec4(0,1,0,0) );\n    fragColor = min(vec4(1.),org);\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// text to write\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(0,0)==ivec2(fragCoord)) {\n        fragColor=vec4(0,0,0,iResolution.x); return;\n    }\n\n    fragColor = vec4(0.);\n    vec2 UO = 18.*(fragCoord)/iResolution.y;\n    vec2 U;\n\n    U = UO;\n    U.x -= 3.;\n    if (U.x >= 0. && U.x <= 6. && U.y >= 14. && U.y <= 15.) {\n        int i = int[](28,78,89,65,78,28)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n    U = UO;\n    U.x -= 3.;\n    if (U.x >= 0. && U.x <= 13. && U.y >= 13. && U.y <= 14.) {\n        int i = int[](99,111,110,115,116,114,117,99,116,105,111,110,33)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n    U = UO;\n    U.x -= 22.;\n    if (U.x >= 0. && U.x <= 7. && U.y >= 12. && U.y <= 14.) {\n        int i;\n        switch(int(U.y-12.)) {\n            case 1: i = int[](82,65,73,78,66,79,87)[int(U)]; break;\n            case 0: i = int[](32,80,79,87,69,82,32)[int(U)]; break;\n        }\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n    \n    U = UO;\n    U.x -= 7.;\n    if (U.x >= 0. && U.x <= 4. && U.y >= 6. && U.y <= 10.) {\n        int i;\n        switch(int(U.y-6.)) {\n            case 3: i = int[](32,78,89,32)[int(U)]; break;\n            case 2: i = int[](33,32,32,65)[int(U)]; break;\n            case 1: i = int[](84,32,32,78)[int(U)]; break;\n            case 0: i = int[](32,65,67,32)[int(U)]; break;\n        }\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n    U = UO;\n    U.x -= 15.;\n    if (U.x >= 0. && U.x <= 14. && U.y >= 3. && U.y <= 4.) {\n        int i = int[](32,32,32,32,32,32,32,82,101,112,101,97,116,29)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.05 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n}\n", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 137, 137, 501], [503, 503, 560, 560, 1444]], "test": "untested"}
{"id": "csKfzW", "name": "weird Raymarch", "author": "AndreCorrea", "description": "first raymarch implementation, set a stepsize bigger than 0.9 and got this funny result", "tags": ["raymarching", "fractal", "sdf", "cube", "sphere"], "likes": 2, "viewed": 186, "published": 3, "date": "1697989208", "time_retrieved": "2024-07-30T17:26:31.458321", "image_code": "\n\nprecision mediump float;\n\nconst int MAX_MARCHING_STEPS = 100;\nconst float THRESHOLD = 0.00000001;\n\nfloat sdSphere(vec3 p,vec3 c,float r) {\n  c.x = sin(iTime) * 0.1;\n  c.y = cos(iTime) * 0.1;\n  c.z = sin(iTime) * 0.1; \n  return length(p - c) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat stepSize =4.0;\n\nvec3 repeat(vec3 p){\n  float s = 3.0;\n  p.x = p.x - s*round(p.x/s);\n  p.y = p.y - s*round(p.y/s);\n  p.z = p.z - s*round(p.z/s);\n  return p;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat scene(vec3 p) {\n\n  p = repeat(p);\n  float box = sdRoundBox(p, vec3(0.1, 0.1, 0.1), 0.1);\n  float sphere = sdSphere(p, vec3(0, 0, 0), 0.25);\n  float d = opSmoothUnion(box, sphere, 0.1);\n  return d;\n}\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.00001; // Adjust as needed\n    \n    float dx = (scene(p + vec3(eps, 0, 0)) - scene(p - vec3(eps, 0, 0))) / (2.0 * eps);\n    float dy = (scene(p + vec3(0, eps, 0)) - scene(p - vec3(0, eps, 0))) / (2.0 * eps);\n    float dz = (scene(p + vec3(0, 0, eps)) - scene(p - vec3(0, 0, eps))) / (2.0 * eps);\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 march(vec3 cam, vec3 dir) {\n  float totalDistance = 0.0;\n  vec3 currentPos = cam;\n  vec3 fogColor = vec3(0.8, 0.8, 0.8); // Adjust as needed\n  float fogDensity = 0.05; // Adjust as needed\n  vec3 col = vec3(0.0);\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\n    float dist = scene(currentPos);\n    if ((dist < THRESHOLD)&&(length(currentPos)>0.1)) {\n      vec3 normal = calcNormal(currentPos);\n      vec3 lightDir = normalize(vec3(-1.0, -1.0, -1.0)); \n\n      float lightIntensity = max(dot(normal, -lightDir), 0.0);\n      vec3 ambientLight = vec3(0.2, 0.2, 0.2);\n      vec3 col = vec3(1.0, 1.0, 1.0) * lightIntensity + ambientLight; \n      return col;\n    }\n    totalDistance += dist;\n    currentPos += dir * stepSize;\n  }\n\n\n  return col;\n}\n\nfloat zoomFactor = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1, 1);\n    vec3 col = vec3(1);\n\n    // Define camera position and direction\n\n    vec3 dir = normalize(vec3(uv, 1));\n\n    // Get mouse rotation\n\n\n    float rotX = iMouse.y / iResolution.y * 8.; // Adjust the sensitivity as needed\n    float rotY = iMouse.x / iResolution.x * 8.;\n    rotY += iTime * 0.1;\n\n    vec3 cam = vec3(0, 0, 0.0);\n    mat3 rotationMatrix = mat3(\n        cos(rotY), 0, sin(rotY),\n        0, 1, 0,\n        -sin(rotY), 0, cos(rotY)\n    ) * mat3(\n        1, 0, 0,\n        0, cos(rotX), -sin(rotX),\n        0, sin(rotX), cos(rotX)\n    );\n\n    cam = rotationMatrix * cam;\n    dir = normalize(rotationMatrix * dir);\n\n    col = march(cam, dir);\n\n    fragColor = vec4(col, 1.0); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 140, 140, 249], [251, 251, 296, 296, 387], [413, 413, 433, 433, 554], [556, 556, 608, 608, 707], [709, 709, 730, 730, 913], [915, 915, 940, 940, 1301], [1303, 1303, 1335, 1335, 2053], [2080, 2080, 2137, 2137, 2956]], "test": "untested"}
{"id": "ddf3zl", "name": "Retro video feedback", "author": "ruudhelderman", "description": "Inspired by a pre-CGI video effect, popular in the 1970s.\nhttps://en.wikipedia.org/wiki/Video_feedback\nThanks @iq for the excellent chromakey; I only needed to change one line of code to achieve this effect!", "tags": ["2d", "video", "retro", "feedback"], "likes": 7, "viewed": 181, "published": 3, "date": "1697988484", "time_retrieved": "2024-07-30T17:26:32.522476", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Original shader: https://www.shadertoy.com/view/XsfGzn\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define METHOD 2  // try method 1 and method 2\n\n// These 3 lines added by @ruudhelderman\nconst float fade = 0.98;\nconst float scale = 0.98;\nconst vec2 origin = vec2(0.1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    // This line modified by @ruudhelderman\n\tvec3 bg = texture( iChannel0, (q-origin)*scale+origin ).xyz * fade;\n    \n\tvec3 fg = texture( iChannel1, q ).xyz;\n    \n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );\n    \n#if METHOD==1\n    \n\tfloat ll = length( fg );\n    fg.g = min( fg.g, maxrb*0.8 );\n    fg = ll*normalize(fg);\n\n#else    \n\n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n\n#endif\n    \n    fragColor = vec4( mix(fg, bg, k), 1.0 );\n}\n", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddf3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]], "test": "untested"}
{"id": "csKBRW", "name": "Triangle cat", "author": "NinjaKoala", "description": "Cat made of triangles, partly script generated", "tags": ["2d", "triangles", "cat"], "likes": 15, "viewed": 318, "published": 3, "date": "1697981721", "time_retrieved": "2024-07-30T17:26:33.647468", "image_code": "float line_width = .00003;\n\nvec3 col1 = vec3(.86,.67,.15);\nvec3 col2 = vec3(.88,.52,.49);\nvec3 col3 = vec3(.93,.9,.83);\n\nvec4 dmin(vec4 a, vec4 b){\n\tif(a.w < b.w){\n\t\treturn a;\n\t}\n\treturn b;\n}\n\nfloat sd_triangle_sq(vec2 p, vec2 p0, vec2 p1, vec2 p2){\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -d.x*sign(d.y);\n}\n\nvec4 meta_triangle_sq0(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec3 col){\n\treturn vec4(col,sd_triangle_sq(p,p0,p1,p2));\n}\n\nvec4 meta_triangle_sq1(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec3 col){\n\tvec2 mid = (p0 + p1 + p2) / 3.;\n\n\tvec4 dis = meta_triangle_sq0(p,p0,mid,p1,col);\n\tdis = dmin(dis,meta_triangle_sq0(p,p1,mid,p2,col1));\n\tdis = dmin(dis,meta_triangle_sq0(p,p2,mid,p0,col3));\n\n\treturn dis;\n}\n\nvec4 meta_triangle_sq2(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec3 col){\n\tvec2 mid = (p0 + p1 + p2) / 3.;\n\n\tvec4 dis = meta_triangle_sq1(p,p0,mid,p1,col);\n\tdis = dmin(dis,meta_triangle_sq1(p,p1,mid,p2,col1));\n\tdis = dmin(dis,meta_triangle_sq1(p,p2,mid,p0,col2));\n\n\treturn dis;\n}\n\nvec4 path0_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0179623,0.00936169),\n\t                      vec2(0.0220308,-0.0124873),\n\t                      vec2(0.00980874,-0.0151035),\n\t                      col2*.9);\n}\n\nvec4 path1_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0363569,0.0124007),\n\t                      vec2(0.0257797,0.0249162),\n\t                      vec2(0.0269433,0.0268374),\n\t                      col2);\n}\n\nvec4 path2_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0294366,-0.0246947),\n\t                      vec2(0.0325496,-0.0216892),\n\t                      vec2(0.0329377,-0.0258093),\n\t                      col3*1.1);\n}\n\nvec4 path3_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0294366,-0.0246947),\n\t                      vec2(0.0263273,-0.0242435),\n\t                      vec2(0.0325496,-0.0216892),\n\t                      col1);\n}\n\nvec4 path4_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0325496,-0.0216892),\n\t                      vec2(0.0347602,-0.0238945),\n\t                      vec2(0.0329377,-0.0258093),\n\t                      col2);\n}\n\nvec4 path5_dis_sq(vec2 uv){\n\treturn meta_triangle_sq2(uv,vec2(0.0263273,-0.0242435),\n\t                      vec2(0.0220308,-0.0124873),\n\t                      vec2(0.0325496,-0.0216892),\n\t                      col3*1.1);\n}\n\nvec4 path6_dis_sq(vec2 uv){\n\treturn meta_triangle_sq2(uv,vec2(0.0220308,-0.0124873),\n\t                      vec2(0.0359069,-0.0054175),\n\t                      vec2(0.0325496,-0.0216892),\n\t                      col1*.9);\n}\n\nvec4 path7_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.00123764,-0.0149651),\n\t                      vec2(0.000524226,0.0108334),\n\t                      vec2(0.00980874,-0.0151035),\n\t                      col2*1.1);\n}\n\nvec4 path8_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0231417,0.0106336),\n\t                      vec2(0.0231899,0.0116497),\n\t                      vec2(0.0363569,0.0124007),\n\t                      col2);\n}\n\nvec4 path9_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.00297611,-0.0187959),\n\t                      vec2(-0.00123764,-0.0149651),\n\t                      vec2(0.00500181,-0.0201989),\n\t                      col1);\n}\n\nvec4 path10_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.00123764,-0.0149651),\n\t                      vec2(0.00980874,-0.0151035),\n\t                      vec2(0.00500181,-0.0201989),\n\t                      col2*.9);\n}\n\nvec4 path11_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.00500181,-0.0201989),\n\t                      vec2(0.00873371,-0.0243717),\n\t                      vec2(0.00657129,-0.0273437),\n\t                      col3*.9);\n}\n\nvec4 path12_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.00873371,-0.0243717),\n\t                      vec2(0.0111582,-0.0241191),\n\t                      vec2(0.012396,-0.0269989),\n\t                      col2*1.1);\n}\n\nvec4 path13_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.00873371,-0.0243717),\n\t                      vec2(0.012396,-0.0269989),\n\t                      vec2(0.00657129,-0.0273438),\n\t                      col3);\n}\n\nvec4 path14_dis_sq(vec2 uv){\n\treturn meta_triangle_sq2(uv,vec2(0.00500181,-0.0201989),\n\t                      vec2(0.00657129,-0.0273437),\n\t                      vec2(-0.00297611,-0.0187959),\n\t                      col1*.9);\n}\n\nvec4 path15_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0147963,-0.0120771),\n\t                      vec2(-0.0101541,-0.00734736),\n\t                      vec2(-0.0100464,-0.0167912),\n\t                      col2);\n}\n\nvec4 path16_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(-0.0101541,-0.00734736),\n\t                      vec2(-0.0108966,-0.00241129),\n\t                      vec2(-0.00123764,-0.0149651),\n\t                      col2);\n}\n\nvec4 path17_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0147963,-0.0120771),\n\t                      vec2(-0.0100464,-0.0167912),\n\t                      vec2(-0.015787,-0.0188029),\n\t                      col1);\n}\n\nvec4 path18_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0154924,-0.0256737),\n\t                      vec2(-0.0116993,-0.0217696),\n\t                      vec2(-0.00943781,-0.0254067),\n\t                      col2);\n}\n\nvec4 path19_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0116993,-0.0217696),\n\t                      vec2(-0.00948755,-0.0231784),\n\t                      vec2(-0.00943781,-0.0254067),\n\t                      col3);\n}\n\nvec4 path20_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.015787,-0.0188029),\n\t                      vec2(-0.0116993,-0.0217696),\n\t                      vec2(-0.0154924,-0.0256737),\n\t                      col1);\n}\n\nvec4 path21_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0100464,-0.0167912),\n\t                      vec2(-0.0116993,-0.0217696),\n\t                      vec2(-0.015787,-0.0188029),\n\t                      col2*.9);\n}\n\nvec4 path22_dis_sq(vec2 uv){\n\treturn meta_triangle_sq2(uv,vec2(-0.0101541,-0.00734736),\n\t                      vec2(-0.00123764,-0.0149651),\n\t                      vec2(-0.0100464,-0.0167912),\n\t                      col3*1.1);\n}\n\nvec4 path23_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(-0.0108966,-0.00241129),\n\t                      vec2(-0.00871265,0.00695555),\n\t                      vec2(0.000524226,0.0108334),\n\t                      col1*.9);\n}\n\nvec4 path24_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(-0.0326361,0.0120918),\n\t                      vec2(-0.0318589,0.00908331),\n\t                      vec2(-0.0363569,0.0133709),\n\t                      col2*.9);\n}\n\nvec4 path25_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0108966,-0.00241129),\n\t                      vec2(0.000524226,0.0108334),\n\t                      vec2(-0.00123764,-0.0149651),\n\t                      col3);\n}\n\nvec4 path26_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0318589,0.00908331),\n\t                      vec2(-0.0352502,0.00573981),\n\t                      vec2(-0.0363569,0.0133709),\n\t                      col1*.9);\n}\n\nvec4 path27_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0363569,0.0133709),\n\t                      vec2(-0.0344697,0.0140319),\n\t                      vec2(-0.0326361,0.0120918),\n\t                      col2);\n}\n\nvec4 path28_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(-0.0260215,0.00182615),\n\t                      vec2(-0.0184877,0.00137488),\n\t                      vec2(-0.0191593,-0.00497752),\n\t                      col3*.9);\n}\n\nvec4 path29_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.00871265,0.00695555),\n\t                      vec2(-0.0108966,-0.00241129),\n\t                      vec2(-0.0184877,0.00137488),\n\t                      col1);\n}\n\nvec4 path30_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0302895,0.00551014),\n\t                      vec2(-0.0352502,0.00573981),\n\t                      vec2(-0.0318589,0.00908331),\n\t                      col2);\n}\n\nvec4 path31_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0302414,-0.00179132),\n\t                      vec2(-0.0302895,0.00551014),\n\t                      vec2(-0.0260215,0.00182615),\n\t                      col3*1.1);\n}\n\nvec4 path32_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0302414,-0.00179132),\n\t                      vec2(-0.0352502,0.00573981),\n\t                      vec2(-0.0302895,0.00551014),\n\t                      col2);\n}\n\nvec4 path33_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0302414,-0.00179132),\n\t                      vec2(-0.0260215,0.00182615),\n\t                      vec2(-0.0191593,-0.00497752),\n\t                      col2);\n}\n\nvec4 path34_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(-0.0191593,-0.00497752),\n\t                      vec2(-0.0184877,0.00137488),\n\t                      vec2(-0.0108966,-0.00241129),\n\t                      col3);\n}\n\nvec4 path35_dis_sq(vec2 uv){\n\treturn meta_triangle_sq2(uv,vec2(0.0231899,0.0116497),\n\t                      vec2(0.0257797,0.0249162),\n\t                      vec2(0.0363569,0.0124007),\n\t                      col2);\n}\n\nvec4 path36_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.00980874,-0.0151035),\n\t                      vec2(0.000524226,0.0108334),\n\t                      vec2(0.0129044,0.0101774),\n\t                      col2);\n}\n\nvec4 path37_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0179623,0.00936169),\n\t                      vec2(0.00980874,-0.0151035),\n\t                      vec2(0.0129044,0.0101774),\n\t                      col2);\n}\n\nvec4 path38_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0359069,-0.0054175),\n\t                      vec2(0.0220308,-0.0124873),\n\t                      vec2(0.0231417,0.0106336),\n\t                      col1*.9);\n}\n\nvec4 path39_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0231417,0.0106336),\n\t                      vec2(0.0220308,-0.0124873),\n\t                      vec2(0.0179623,0.00936169),\n\t                      col2);\n}\n\nvec4 path40_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0359069,-0.0054175),\n\t                      vec2(0.0231417,0.0106336),\n\t                      vec2(0.0363569,0.0124007),\n\t                      col3*.9);\n}\n\nvec4 path41_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0193653,0.0127641),\n\t                      vec2(0.0191717,0.0143091),\n\t                      vec2(0.0231899,0.0116497),\n\t                      col2);\n}\n\nvec4 path42_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0199339,0.0170546),\n\t                      vec2(0.0231899,0.0116497),\n\t                      vec2(0.0191717,0.0143091),\n\t                      col2*1.1);\n}\n\nvec4 path43_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0199339,0.0170546),\n\t                      vec2(0.0191717,0.0143091),\n\t                      vec2(0.0182145,0.0152456),\n\t                      col1);\n}\n\nvec4 path44_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0224697,0.0229853),\n\t                      vec2(0.0199339,0.0170546),\n\t                      vec2(0.0199908,0.0195987),\n\t                      col1*1.1);\n}\n\nvec4 path45_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0224697,0.0229853),\n\t                      vec2(0.0231899,0.0116497),\n\t                      vec2(0.0199339,0.0170546),\n\t                      col2);\n}\n\nvec4 path46_dis_sq(vec2 uv){\n\treturn meta_triangle_sq0(uv,vec2(0.0224697,0.0229853),\n\t                      vec2(0.0257797,0.0249162),\n\t                      vec2(0.0231899,0.0116497),\n\t                      col1*.9);\n}\n\nvec4 path47_dis_sq(vec2 uv){\n\treturn meta_triangle_sq1(uv,vec2(0.0219064,0.0273438),\n\t                      vec2(0.0257797,0.0249162),\n\t                      vec2(0.0224697,0.0229853),\n\t                      col2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tuv.x += .09;\n\n\tfloat border = 1./iResolution.y;\n\n\tfloat zoom = .08;\n\n\tuv*=zoom;\n\tborder*=zoom;\n\n\tvec4 dis_sq = vec4(1000);\n\n\tvec3 color = col3;\n\n\tif(all(lessThan(uv,vec2(0.0363569,0.0273438)+border)) && all(greaterThan(uv,vec2(-0.0363569,-0.0273438)-border))){\n\t\tdis_sq=dmin(dis_sq,path0_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path1_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path2_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path3_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path4_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path5_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path6_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path7_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path8_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path9_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path10_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path11_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path12_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path13_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path14_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path15_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path16_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path17_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path18_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path19_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path20_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path21_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path22_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path23_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path24_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path25_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path26_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path27_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path28_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path29_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path30_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path31_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path32_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path33_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path34_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path35_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path36_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path37_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path38_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path39_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path40_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path41_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path42_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path43_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path44_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path45_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path46_dis_sq(uv));\n\t\tdis_sq=dmin(dis_sq,path47_dis_sq(uv));\n\t}\n\n\tfloat dis = abs(mod(dot(uv,normalize(vec2(1))),.02)-.01)-.005;\n\tcolor = mix(col1*.3+.7*color,color,smoothstep(-border,border,dis));\n\n\tdis=sign(dis_sq.w)*sqrt(abs(dis_sq.w));\n\tvec3 cur_col = dis_sq.rgb;\n\n\tcolor = mix(cur_col,color,smoothstep(-border,border,dis));\n\n\tcolor = mix(vec3(0),color,smoothstep(-border,border,abs(dis)-line_width));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 147, 147, 191], [193, 193, 249, 249, 808], [810, 810, 878, 878, 926], [928, 928, 996, 996, 1202], [1204, 1204, 1272, 1272, 1478], [1480, 1480, 1507, 1507, 1702], [1704, 1704, 1731, 1731, 1919], [1921, 1921, 1948, 1948, 2143], [2145, 2145, 2172, 2172, 2363], [2365, 2365, 2392, 2392, 2583], [2585, 2585, 2612, 2612, 2807], [2809, 2809, 2836, 2836, 3030], [3032, 3032, 3059, 3059, 3258], [3260, 3260, 3287, 3287, 3475], [3477, 3477, 3504, 3504, 3700], [3702, 3702, 3730, 3730, 3928], [3930, 3930, 3958, 3958, 4155], [4157, 4157, 4185, 4185, 4380], [4382, 4382, 4410, 4410, 4602], [4604, 4604, 4632, 4632, 4830], [4832, 4832, 4860, 4860, 5055], [5057, 5057, 5085, 5085, 5282], [5284, 5284, 5312, 5312, 5505], [5507, 5507, 5535, 5535, 5730], [5732, 5732, 5760, 5760, 5956], [5958, 5958, 5986, 5986, 6179], [6181, 6181, 6209, 6209, 6405], [6407, 6407, 6435, 6435, 6635], [6637, 6637, 6665, 6665, 6864], [6866, 6866, 6894, 6894, 7089], [7091, 7091, 7119, 7119, 7315], [7317, 7317, 7345, 7345, 7541], [7543, 7543, 7571, 7571, 7762], [7764, 7764, 7792, 7792, 7990], [7992, 7992, 8020, 8020, 8216], [8218, 8218, 8246, 8246, 8440], [8442, 8442, 8470, 8470, 8669], [8671, 8671, 8699, 8699, 8894], [8896, 8896, 8924, 8924, 9120], [9122, 9122, 9150, 9150, 9346], [9348, 9348, 9376, 9376, 9564], [9566, 9566, 9594, 9594, 9786], [9788, 9788, 9816, 9816, 10007], [10009, 10009, 10037, 10037, 10230], [10232, 10232, 10260, 10260, 10450], [10452, 10452, 10480, 10480, 10672], [10674, 10674, 10702, 10702, 10890], [10892, 10892, 10920, 10920, 11112], [11114, 11114, 11142, 11142, 11330], [11332, 11332, 11360, 11360, 11552], [11554, 11554, 11582, 11582, 11770], [11772, 11772, 11800, 11800, 11991], [11993, 11993, 12021, 12021, 12209], [12211, 12211, 12265, 12265, 14954]], "test": "untested"}
{"id": "DsGyRK", "name": "Blob vs Blob", "author": "ruudhelderman", "description": "Very simple 2D plasma effect. The shades give it a slight 3D look.\n\nhttps://cineshader.com/view/DsGyRK\n", "tags": ["2d", "plasma", "cineshader"], "likes": 3, "viewed": 814, "published": 3, "date": "1697970911", "time_retrieved": "2024-07-30T17:26:34.408434", "image_code": "// Blob vs Blob\n// by Ruud Helderman, October 2023 - MIT License\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalize screen coordinates\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / (iResolution.x + iResolution.y);\n    \n    // scale; center bulge\n    uv *= 24.0 - 6.0 / (0.4 + dot(uv, uv));    // alt: uv *= 12.0 * inversesqrt(1.0 - dot(uv, uv));\n    \n    // horizontal drift\n    uv.x += iTime;\n    \n    // squirming shapes\n    uv = sin(uv + sin(1.4 * uv.yx + 0.6 * sin(1.9 * uv + iTime)));\n    \n    // color cycling\n    vec3 color = sin(vec3(0, 2.1, 4.2) - 0.2 * iTime);\n    \n    // shades\n    color *= 1.0 - dot(uv, uv);    // alt: color *= 1.0 - length(uv);\n    \n    // depth for cineshader.com\n    float alpha = 0.25 * length(color);\n    \n    // output\n    fragColor = vec4(color, alpha);    // alt: fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGyRK.jpg", "access": "api", "license": "mit", "functions": [[66, 66, 121, 157, 868]], "test": "ok"}
{"id": "mdGfRW", "name": "color changing shader", "author": "kksndks", "description": "simple shader", "tags": ["simple"], "likes": 1, "viewed": 131, "published": 3, "date": "1697970513", "time_retrieved": "2024-07-30T17:26:35.293068", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(cos(uv.y + iTime + uv.x * 1.0), cos(0.2 * iTime), sin(uv.x + iTime + uv.y));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 301]], "test": "untested"}
{"id": "cdyfzD", "name": "Hinged Squares + truchets", "author": "FabriceNeyret2", "description": "inspiration: https://twitter.com/KeishiroUeki/status/1715924571180990920\nadapting + golfing from \"Hinged Squares\" by fad. https://shadertoy.com/view/DddBzM", "tags": ["grid", "texture", "uv", "animation", "square", "squares", "tesselation", "reproduction", "truchets", "hinged"], "likes": 12, "viewed": 227, "published": 3, "date": "1697966950", "time_retrieved": "2024-07-30T17:26:36.165735", "image_code": "// Fork of \"Hinged Squares\" by fad. https://shadertoy.com/view/DddBzM\n// + inspiration from https://twitter.com/KeishiroUeki/status/1715924571180990920\n\n// -6 by zlonka\n\n#define S(v) smoothstep( 12./R.y, 0., v )   \n\nvoid mainImage(out vec4 O, vec2 I) {\n    float P = 3.14, g=.5,\n          a = smoothstep(0.,1., smoothstep(g,0., abs( fract(iTime/4.) - g ) )) * P * g,\n          c = cos(a),\n          s = sin(a),\n          b = c + s;\n    vec2  R = iResolution.xy,\n          p = 8.* ( I+I - R ) / R.y / b,\n          d = mat2(c, s, -s, c)  * asin(cos(p)) * b / P,\n          D = abs(d),\n    q = cos(1e3*sin(dot(ceil(p/P),R-57.))) > .0 ? vec2(-d.y,d) : d;    // random PI/2 turn\n    O =  ( g + S( abs( length( q - g*sign(q.x+q.y) ) -g ) - .05 ) )    // truchet\n        * S( max(D.xxxx, D.y) - g );                                   // tile\n}\n\n\n\n\n\n/** // 390 chars\n\n#define S(v) smoothstep( 12./R.y, 0., v )   \n\nvoid mainImage(out vec4 O, vec2 I) {\n    float PI = 3.14,\n          a = smoothstep(0.,1., smoothstep(.5,0., abs( fract(iTime/4.) - .5 ) )) * PI/2.,\n          c = cos(a),\n          s = sin(a),\n          b = c + s;\n    vec2  R = iResolution.xy,\n          p = 8.* ( I+I - R ) / R.y / b,\n          d = mat2(c, s, -s, c)  * asin(cos(p)) * b / PI,\n          D = abs(d),\n    q = cos(1e3*sin(dot(ceil(p/PI),R-57.))) > .0 ? vec2(-d.y,d) : d;      // random PI/2 turn\n    O =  ( .5 + S( abs( length( q - .5*sign(q.x+q.y) ) -.5 ) - .05 ) )    // truchet\n        * S( max(D.xxxx, D.y) - .5 );                                     // tile\n}\n\n/**/\n\n\n\n\n\n\n/** // 414 chars\n\n#define S(v) smoothstep( 12./R.y, 0., v )   \n\nvoid mainImage(out vec4 O, vec2 I) {\n    float PI = 3.14,\n          a = smoothstep(0.,1., smoothstep(1.,0., abs( mod( iTime/2., 2.) - 1. ) )) * PI/2.,\n          c = cos(a),\n          s = sin(a),\n          b = c + s;\n    vec2  R = iResolution.xy,\n          p = 8.* ( I+I - R ) / R.y / b,\n          d = mat2(c, s, -s, c)  * asin(cos(p)) * b / PI,\n          D = abs(d),\n          q = ceil( p / PI ) + .5-d;   // q += .5 - d * cos(PI*q) for global mapping\n    q = fract( fract(1e4*sin(dot(ceil(q),R-57.))) > .5 ? vec2(-q.y,q) : q ); // random PI/2 turn\n    O =  ( .5 + S( abs( length( q.x+q.y > 1. ? 1.-q : q ) -.5 ) - .05 ) )    // truchet\n        * S( max(D.xxxx, D.y) - .5 );                                        // tile\n}\n\n\n\n\n\n\n/** // 422 chars\n\n#define S(v) smoothstep( 12./R.y, 0., v )      //\n#define L(q) S( abs( length(q) -.5 ) - .05 )\n\nvoid mainImage(out vec4 O, vec2 I) {\n    float PI = 3.14,\n          a = smoothstep(0.,1., smoothstep(1.,0., abs( mod( iTime/2., 2.) - 1. ) )) * PI/2.,\n          c = cos(a),\n          s = sin(a),\n          b = c + s;\n    vec2  R = iResolution.xy,\n          p = ( I+I - R ) / R.y * 8. / b,\n          d = mat2(c, s, -s, c)  * asin(cos(p)) * b / PI,\n          D = abs(d),\n          q = ceil( p / PI ) + .5-d;   // q += .5 - d * cos(PI*q) for global mapping\n    q = fract( fract(1e4*sin(dot(ceil(q),R-57.))) > .5 ? vec2(-q.y,q) : q );\n    O = ( .5 + L(q) + L(q-1.) ) * S( max(D.xxxx, D.y) - .5 );\n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdyfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 252, 252, 835]], "test": "untested"}
{"id": "mdcBW7", "name": "Sum Tetrabrot II Julia Explorer", "author": "domrally", "description": "Click to explore! Generated using the same formula as the Julia/Mandelbrot set, but using the tetration hyperoperation. \nz²↑₄ + i = z^z+i instead of z²↑₃ + i = z*z+i\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "julia", "mandelbrot", "interactive", "orbit", "quadratic", "trap", "explorer", "chaotic", "tetration", "hyperoperation"], "likes": 5, "viewed": 227, "published": 3, "date": "1697955233", "time_retrieved": "2024-07-30T17:26:37.150103", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nhttps://en.wikipedia.org/wiki/Tetration\n*/\nvec2 T(vec2 v) {\n    // https://mathworld.wolfram.com/ComplexExponentiation.html\n    float d = dot(v, v),\n          a = atan(v.y, v.r),\n          t = dot(v, vec2(a, log(d) / 2.));\n        \n    return exp(-a * v.y) * pow(d, v.r / 2.) * vec2(cos(t), sin(t));\n}\n\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    // https://en.wikipedia.org/wiki/Orbit_trap\n    vec2 z, t, w, \n         R = iResolution.xy,\n         M = 2. * iMouse.xy - R;\n    z = t = i = 2. * (i + i - R) / R.x;\n    float j, f, r = 9.;\n    \n    // https://en.wikipedia.org/wiki/Julia_set\n    for (M = 2. * M / R.x; j++ < 48.; f < r ? r = f, t = z : t)\n        f = dot(z, z = \n            mix(i, M, max(0., sign(iMouse.z)))\n            + (w = T(z))\n        );\n    \n    // nonlinearly proportional to distance\n    float d = 3. * sqrt(r) + exp(-length(z)),\n          // grid\n          g = smoothstep(0., 4., length(fract(w))),\n          // hue angle\n          // https://en.wikipedia.org/wiki/Argument_(complex_analysis)\n          h = atan(t.y, t.x) + iTime / 4.;\n    \n    // normal map\n    vec3 n = normalize(cross(dFdx(vec3(i, d)), dFdy(vec3(i, d)))),\n         // light ray\n         e = normalize(vec3(1, -1, -1)),\n         // https://en.wikipedia.org/wiki/Color_wheel\n         v = vec3(h - 2.1, h, h + 2.1);\n    // https://en.wikipedia.org/wiki/Phong_reflection_model\n    float l = (max(0., dot(e, n)),\n            + max(0., dot(reflect(e, n), vec3(0, 0, -1)))\n    ) / 2.;\n    \n    // https://en.wikipedia.org/wiki/Versine#Definitions\n    o = vec4(.5 + .5 * cos(v), 1.);\n    \n    o = smoothstep(.0, .6, l * o + g);\n}\n\n\n/*\nREFERENCES\n\ndomain warping\n\ngcgac 2022\nhttps://www.shadertoy.com/view/NtyfWD\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n\nrefactoring\n\nshadertoyjiang & FabriceNeyret2 2023\nhttps://www.shadertoy.com/view/DdcBWX\n\nSnoopethDuckDuck 2023\nhttps://www.shadertoy.com/view/cs3BRj\n*/\n\n\n/*\nFURTHER READING\n\nhyperoperations\n\nhttps://en.wikipedia.org/wiki/Tetration\nhttps://en.wikipedia.org/wiki/Iterated_function#Fractional_iterates_and_flows,_and_negative_iterates\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Spectral_sensitivity\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 73, 89, 153, 331], [334, 334, 370, 418, 1644]], "test": "untested"}
{"id": "dsKfR1", "name": "ForestFire AVA", "author": "ai22m030", "description": "Fores fire simulation", "tags": ["fire"], "likes": 1, "viewed": 138, "published": 3, "date": "1697938304", "time_retrieved": "2024-07-30T17:26:38.514455", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frameCount = float(iFrame);\n\n    // Use modulo on iTime to determine which buffer to display\n    if(mod(frameCount, 2.0) == 1.0)\n    {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy); // Display Buf A\n    }\n    else\n    {\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy); // Display Buf B\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) // only seed the initial state on the first frame\n    {\n        float isTree = step(0.7, rand(fragCoord)); // roughly 70% chance to be a tree\n        fragColor = vec4(0.0, isTree, 0.0, 1.0); // Trees are green\n        return;\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample the current state of the pixel\n    vec3 currentState = texture(iChannel0, uv).rgb;\n    \n    // Get the states of Von Neumann neighbors (Up, Down, Left, Right)\n    vec3 up = texture(iChannel0, mod(uv + vec2(0.0, 1.0/iResolution.y), 1.0)).rgb;\n    vec3 down = texture(iChannel0, mod(uv - vec2(0.0, 1.0/iResolution.y), 1.0)).rgb;\n    vec3 left = texture(iChannel0, mod(uv - vec2(1.0/iResolution.x, 0.0), 1.0)).rgb;\n    vec3 right = texture(iChannel0, mod(uv + vec2(1.0/iResolution.x, 0.0), 1.0)).rgb;\n    \n    // Parameters\n    float p = 0.01; // probability for a tree to catch fire if no neighbor is burning\n    float g = 0.001; // Base probability for an empty cell to grow a tree\n    \n    // Check for fire in the neighborhood\n    bool fireNearby = up.r > 0.5 || down.r > 0.5 || left.r > 0.5 || right.r > 0.5;\n    \n    vec3 nextState = currentState;\n    \n    // Fire logic\n    if(currentState.r == 1.0) // Currently on fire\n    {\n        nextState = vec3(0.0, 0.0, 0.0); // Becomes empty\n    }\n    \n    if(currentState.g == 1.0) // Currently a tree\n    {\n        if(fireNearby)\n        {\n            nextState = vec3(1.0, 0.0, 0.0); // Set on fire\n        }\n    }\n    \n    if(currentState.g == 0.0 && currentState.r == 0.0)\n    {\n        if(rand(fragCoord.xy + vec2(iTime) * (iResolution.y + iResolution.x)) < p)\n        {\n            nextState = vec3(1.0, 0.0, 0.0);\n        }\n        else if(rand(fragCoord.xy + vec2(iTime) * (iResolution.x + iResolution.z)) < g) // Empty space grows a tree with chance g at intervals\n        {\n            nextState = vec3(0.0, 1.0, 0.0); // Grow tree\n        }\n    }\n    \n    \n    fragColor = vec4(nextState, 1.0);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float rand(float co) { return fract(sin(co * (91.3458)) * 47453.5453); }\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co) { return rand(co.xy + rand(co.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinate to range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample the current state of the pixel\n    vec3 currentState = texture(iChannel0, uv).rgb;\n    \n    // Get the states of Von Neumann neighbors (Up, Down, Left, Right)\n    vec3 up = texture(iChannel0, mod(uv + vec2(0.0, 1.0 / iResolution.y), 1.0)).rgb;\n    vec3 down = texture(iChannel0, mod(uv - vec2(0.0, 1.0 / iResolution.y), 1.0)).rgb;\n    vec3 left = texture(iChannel0, mod(uv - vec2(1.0 / iResolution.x, 0.0), 1.0)).rgb;\n    vec3 right = texture(iChannel0, mod(uv + vec2(1.0 / iResolution.x, 0.0), 1.0)).rgb;\n    \n    // Parameters\n    float p = 0.01; // probability for a tree to catch fire if no neighbor is burning\n    float g = 0.001; // Base probability for an empty cell to grow a tree\n    \n    // Check for fire in the neighborhood\n    bool fireNearby = up.r > 0.5 || down.r > 0.5 || left.r > 0.5 || right.r > 0.5;\n    \n    vec3 nextState = currentState;\n    \n    // Fire logic\n    if(currentState.r == 1.0) // Currently on fire\n    {\n        nextState = vec3(0.0, 0.0, 0.0); // Becomes empty\n    }\n    \n    if(currentState.g == 1.0) // Currently a tree\n    {\n        if(fireNearby)\n        {\n            nextState = vec3(1.0, 0.0, 0.0); // Set on fire\n        }\n    }\n    else if(mod(iTime, 1.0) < 0.1 && rand(fragCoord.xy + vec2(iTime)) < g) // Empty space grows a tree with chance g at intervals\n    {\n        nextState = vec3(0.0, 1.0, 0.0); // Grow tree\n    }\n    \n    fragColor = vec4(nextState, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 397]], "test": "untested"}
{"id": "ddKfR1", "name": "Cyberpunk 2077 Militarism SDF", "author": "MakiXx", "description": "I collected \"Coral cutout bodysuit\" in-game and really liked the pattern", "tags": ["sdf", "pattern", "cyberpunk"], "likes": 15, "viewed": 278, "published": 3, "date": "1697937064", "time_retrieved": "2024-07-30T17:26:39.359196", "image_code": "// const float Deg2Rad = 0.017453292519943295;\n\nconst float Ratio30Deg = 0.577350269189626; // tan(30deg) / 1\n\nfloat line(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - h * ba);\n}\n\nfloat hut(in vec2 p, in float size, in float flip, in float lines) {\n\tvec2 mid = vec2(size * 0.5, size * 0.5 * Ratio30Deg * flip);\n\n\tif (lines < 1.5) {\n\t\treturn line(p, vec2(0, 0), mid);\n\t} else {\n\t\treturn min(\n\t\t\tline(p, vec2(0, 0), mid),\n\t\t\tline(p, mid, vec2(size, 0))\n\t\t);\n\t}\n}\n\nfloat tripleHut(in vec2 p, in float flip, in float lines) {\n\treturn min(\n\t\tmin(\n\t\t\thut(p, 8.0, flip, lines),\n\t\t\thut(p - vec2(1.0, -Ratio30Deg * flip), 6.0, flip, lines)\n\t\t), \n\t\thut(p - vec2(2.0, -Ratio30Deg * 2.0 * flip), 4.0, flip, lines)\n\t);\n}\n\nfloat completeSquigle(in vec2 p, in float innerSpacing) {\n\tfloat d = tripleHut(p, 1.0, 2.0);\n\td = min(d, tripleHut(p - vec2(6, -innerSpacing), -1.0, 2.0));\n\n\t// lines going down\n\td = min(d, line(p, vec2(8, 0), vec2(8, -innerSpacing + Ratio30Deg * 2.0)));\n\td = min(d, line(p, vec2(7, -Ratio30Deg), vec2(7, -innerSpacing + Ratio30Deg)));\n\td = min(d, line(p, vec2(6, -Ratio30Deg * 2.0), vec2(6, -innerSpacing)));\n\t\n\t// lines going back up\n\td = min(d, line(p, vec2(12, 0), vec2(12, -innerSpacing + Ratio30Deg * 2.0)));\n\td = min(d, line(p, vec2(13, -Ratio30Deg), vec2(13, -innerSpacing + Ratio30Deg)));\n\td = min(d, line(p, vec2(14, -Ratio30Deg * 2.0), vec2(14, -innerSpacing)));\n\n\t// last triple hut\n\td = min(d, tripleHut(p - vec2(12, 0), 1.0, 1.0));\n\n\treturn d;\n}\n\nfloat repeatablePattern(in vec2 p, in float innerSpacing) {\n\tfloat d = completeSquigle(p + vec2(0, 0), innerSpacing);\n\t\n\td = min(d, tripleHut(p + vec2(0, innerSpacing + Ratio30Deg * 6.0), 1.0, 2.0));\n\td = min(d, tripleHut(p - vec2(6, Ratio30Deg * 6.0), -1.0, 2.0));\n\n\t// rest of the lines\n\n\tfloat yTop = Ratio30Deg * 6.0;\n\tfloat yBottom = -innerSpacing - Ratio30Deg * 6.0;\n\n\td = min(d, line(p, vec2(0, yTop), vec2(0, yBottom)));\n\n\td = min(d, line(p, vec2(1, yTop), vec2(1, yTop - Ratio30Deg * 5.0)));\n\td = min(d, line(p, vec2(1, yTop - Ratio30Deg * 7.0), vec2(1, yBottom + Ratio30Deg)));\n\n\td = min(d, line(p, vec2(2, yTop), vec2(2, yTop - Ratio30Deg * 4.0)));\n\td = min(d, line(p, vec2(2, yTop - Ratio30Deg * 8.0), vec2(2, yBottom + Ratio30Deg * 2.0)));\n\n\td = min(d, line(p, vec2(3, yTop), vec2(3, yTop - Ratio30Deg * 3.0)));\n\td = min(d, line(p, vec2(3, yTop - Ratio30Deg * 7.0), vec2(3, yBottom + Ratio30Deg * 3.0)));\n\n\td = min(d, line(p, vec2(4, yTop), vec2(4, yTop - Ratio30Deg * 2.0)));\n\td = min(d, line(p, vec2(4, yTop - Ratio30Deg * 6.0), vec2(4, yBottom + Ratio30Deg * 4.0)));\n\n\td = min(d, line(p, vec2(5, yTop), vec2(5, yTop - Ratio30Deg * 3.0)));\n\td = min(d, line(p, vec2(5, yTop - Ratio30Deg * 7.0), vec2(5, yBottom + Ratio30Deg * 3.0)));\n\n\td = min(d, line(p, vec2(6, yTop), vec2(6, yTop - Ratio30Deg * 4.0)));\n\td = min(d, line(p, vec2(6, yBottom + Ratio30Deg * 6.0), vec2(6, yBottom + Ratio30Deg * 2.0)));\n\n\td = min(d, line(p, vec2(7, yTop - Ratio30Deg), vec2(7, yTop - Ratio30Deg * 5.0)));\n\td = min(d, line(p, vec2(7, yBottom + Ratio30Deg * 5.0), vec2(7, yBottom + Ratio30Deg)));\n\n\td = min(d, line(p, vec2(8, yTop - Ratio30Deg * 2.0), vec2(8, yTop - Ratio30Deg * 6.0)));\n\td = min(d, line(p, vec2(8, yBottom + Ratio30Deg * 4.0), vec2(8, yBottom)));\n\n\td = min(d, line(p, vec2(9, yTop - Ratio30Deg * 3.0), vec2(9, yBottom + Ratio30Deg * 7.0)));\n\td = min(d, line(p, vec2(9, yBottom + Ratio30Deg * 3.0), vec2(9, yBottom)));\n\n\td = min(d, line(p, vec2(10, yTop - Ratio30Deg * 4.0), vec2(10, yBottom + Ratio30Deg * 6.0)));\n\td = min(d, line(p, vec2(10, yBottom + Ratio30Deg * 2.0), vec2(10, yBottom)));\n\n\td = min(d, line(p, vec2(11, yTop - Ratio30Deg * 3.0), vec2(11, yBottom + Ratio30Deg * 7.0)));\n\td = min(d, line(p, vec2(11, yBottom + Ratio30Deg * 3.0), vec2(11, yBottom)));\n\n\td = min(d, line(p, vec2(12, yTop - Ratio30Deg * 2.0), vec2(12, yTop - Ratio30Deg * 6.0)));\n\td = min(d, line(p, vec2(12, yBottom + Ratio30Deg * 4.0), vec2(12, yBottom)));\n\n\td = min(d, line(p, vec2(13, yTop - Ratio30Deg), vec2(13, yTop - Ratio30Deg * 5.0)));\n\td = min(d, line(p, vec2(13, yBottom + Ratio30Deg * 5.0), vec2(13, yBottom + Ratio30Deg)));\n\n\td = min(d, line(p, vec2(14, yTop), vec2(14, yTop - Ratio30Deg * 4.0)));\n\td = min(d, line(p, vec2(14, yBottom + Ratio30Deg * 6.0), vec2(14, yBottom + Ratio30Deg * 2.0)));\n\n\treturn d;\n}\n\nfloat infinitePattern(in vec2 p)\n{\n\tfloat innerSpacing = Ratio30Deg * 10.0; // hexagon!\n\n\tvec2 size = vec2(12.0, innerSpacing + Ratio30Deg * 6.0);\n\tvec2 pos = vec2(-8.0, innerSpacing * 0.5);\n\n\t// repeat\n    vec2 q = p - size * round(p/size);\n\tq -= pos;\n\n\t// vec2 q = p + vec2(10,0);\n\n\tfloat d = repeatablePattern(q, innerSpacing);\n\t\n\treturn d;\n}\n\n// snoise minified\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}float snoise(vec3 v){ const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i  = floor(v + dot(v, C.yyy) );vec3 x0 =   v - i + dot(i, C.xxx) ;vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min( g.xyz, l.zxy );vec3 i2 = max( g.xyz, l.zxy );vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;      i = mod289(i); vec4 p = permute( permute( permute(  i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))  + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));float n_ = 0.142857142857; vec3  ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_ );    vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0)*2.0 + 1.0;vec4 s1 = floor(b1)*2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;vec3 p0 = vec3(a0.xy,h.x);vec3 p1 = vec3(a0.zw,h.y);vec3 p2 = vec3(a1.xy,h.z);vec3 p3 = vec3(a1.zw,h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);m = m * m;return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );}\n\nvec3 gnomeDarkStripes(in float t)\n{\n    // t 0 to 1 -> 1 to 0 to 1\n    t = abs((mod(t, 1.0) * 2.0) - 1.0);\n\n    vec3 a = vec3(0x24, 0x1F, 0x31) / 255.0;\n    vec3 b = vec3(0x30, 0x22, 0x3B) / 255.0;\n    vec3 c = vec3(0x4E, 0x25, 0x4A) / 255.0;\n    vec3 d = vec3(0x56, 0x24, 0x4B) / 255.0;\n    vec3 e = vec3(0x5F, 0x24, 0x4C) / 255.0;\n    vec3 f = vec3(0x67, 0x23, 0x4D) / 255.0;\n    vec3 g = vec3(0x70, 0x23, 0x4E) / 255.0;\n    vec3 h = vec3(0x92, 0x1F, 0x48) / 255.0;\n    vec3 i = vec3(0xAF, 0x24, 0x38) / 255.0;\n    vec3 j = vec3(0xB3, 0x29, 0x31) / 255.0;\n    vec3 k = vec3(0xB8, 0x2E, 0x2A) / 255.0;\n    vec3 l = vec3(0xBC, 0x33, 0x23) / 255.0;\n    vec3 m = vec3(0xC1, 0x38, 0x1D) / 255.0;\n    vec3 n = vec3(0xC6, 0x46, 0x00) / 255.0;\n    vec3 o = vec3(0xE6, 0x61, 0x00) / 255.0;\n\n    float x = mod(t, 1.0); // * 15\n\n    float y = 310.0 / 2810.0;\n    if (x < y) return a;\n    y += 310.0 / 2810.0;\n    if (x < y) return b;\n    y += 80.0 / 2810.0;\n    if (x < y) return c;\n    y += 80.0 / 2810.0;\n    if (x < y) return d;\n    y += 80.0 / 2810.0;\n    if (x < y) return e;\n    y += 80.0 / 2810.0;\n    if (x < y) return f;\n    y += 310.0 / 2810.0;\n    if (x < y) return g;\n    y += 310.0 / 2810.0;\n    if (x < y) return h;\n    y += 80.0 / 2810.0;\n    if (x < y) return i;\n    y += 80.0 / 2810.0;\n    if (x < y) return j;\n    y += 80.0 / 2810.0;\n    if (x < y) return k;\n    y += 80.0 / 2810.0;\n    if (x < y) return l;\n    y += 310.0 / 2810.0;\n    if (x < y) return m;\n    y += 310.0 / 2810.0;\n    if (x < y) return n;\n\n    return o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    // for rendering to texture\n    //\n    // vec2(12.0, 9.23760430703);\n    // * 13 or 80\n    // vec2(960, 739.0083445624);\n    // can render sdf to 960x739 texture\n    //\n    \n    /*\n    {\n        vec2 size = vec2(6.75, Ratio30Deg * 10.0 + Ratio30Deg * 6.0);\n        uv *= size;    \n        uv += vec2(-2.0,0);\n        \n        float dist = infinitePattern(uv);\n        \n        //fragColor = vec4(vec3(dist * 2.0), 1.0);\n        //return;\n        \n        dist -= 0.16;\n        \n        //vec2 ddist = vec2(dFdx(dist), dFdy(dist));\n        //float pixelDist = dist / length(ddist);\n        //float alpha = clamp(0.5 - pixelDist, 0.0, 1.0); \n        \n        float alpha = dist < 0.0 ? 1.0 : 0.0;\n        \n        fragColor = vec4(vec3(alpha), 1.0);\n        return;\n    }\n    */\n    \n    // testing\n\n    /*\n    {\n        uv *= 24.0;    \n        uv += vec2(-2.0,0);\n        \n        float dist = infinitePattern(uv);\n    \n        vec3 col = vec3(1.0) - sign(dist) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-3.0 * abs(dist));\n        col *= 0.8 + 0.2 * cos(120.0 * dist);\n        col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(dist)));\n\n        fragColor = vec4(col, 1);\n        return;\n\t}\n    */\n    \n    uv *= 16.0;\n\tuv += vec2(iTime, sin(iTime * 0.5) * 0.5);\n\n\tfloat dist = infinitePattern(uv);\n    dist -= 0.12;\n    \n    vec2 ddist = vec2(dFdx(dist), dFdy(dist));\n    float pixelDist = dist / length(ddist);\n    float alpha = clamp(0.5 - pixelDist, 0.0, 1.0); \n\n\tfloat n = snoise(vec3(uv * 0.1, iTime * 0.1)) * 0.5 + 0.5;\n\n\tvec3 color = gnomeDarkStripes(n * 1.0);\n\n\tfragColor = vec4(mix(\n        mix(vec3(gnomeDarkStripes(0.5)), vec3(0), 0.5),\n        color,\n        alpha\n    ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 156, 156, 278], [280, 280, 348, 348, 560], [562, 562, 621, 621, 807], [809, 809, 866, 866, 1568], [1570, 1570, 1629, 1629, 4386], [4388, 4388, 4422, 4422, 4733], [4735, 4754, 4775, 4775, 4820], [4820, 4820, 4841, 4841, 4886], [4886, 4886, 4908, 4908, 4942], [4942, 4942, 4969, 4969, 5017], [5017, 5017, 5038, 5038, 6419], [6421, 6421, 6456, 6487, 7954], [7956, 7956, 8011, 8011, 9788]], "test": "untested"}
{"id": "dsKcWy", "name": "physarum-decomposition-fork", "author": "shrugbread", "description": "This addition makes a food buffer for the agents to avoid and carve into\nusing the custom texture extension Channel1 in Buff C.\nbased on the shader https://www.shadertoy.com/view/tlKGDh \nmouse for add particles\nspacebar for clear the screen", "tags": ["voronoi", "experiment", "tracking"], "likes": 4, "viewed": 153, "published": 3, "date": "1697936960", "time_retrieved": "2024-07-30T17:26:40.275746", "image_code": "// made by \n// Forked From Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Voronoi Tracking Experiment 1\n\n// based on the shader https://www.shadertoy.com/view/tlKGDh of michael0884\n\n// use mouse for add particles\n// use spacebar for clear the screen\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1\n    , ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getFood(vec2 p) \n{\n    return texelFetch(iChannel2  , ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromoneInv(vec2 p)\n{\n\treturn getPheromone(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 100.0 / min(iResolution.x, iResolution.y);\n\tfloat f = getPheromoneInv(fragCoord).x;\n\tfloat fx = (f-getPheromoneInv(fragCoord + vec2(1,0)).x)/e;\n\tfloat fy = (f-getPheromoneInv(fragCoord + vec2(0,1)).x)/e;\n\tvec3 n = normalize(vec3(0,0,1) - vec3(fx,fy,0.0));\n\t\n\tfloat diff = max(dot(vec3(0.,1,1), n), 0.0);\n\tfloat spec = pow(max(dot(normalize(lightDirection), reflect(vec3(0,0,1),n)), 0.0), specularPower);\n\n    fragColor.rgb = lightDiffuse * diff + lightSpecular* spec; \n\tfragColor.rgb *= 1.7;\n\n    fragColor.rgba -= getFood(fragCoord)*0.3;\n    fragColor.rgba*= 1.2;\n\n    //fragColor.a =0.5;\n\n    //fragColor = getPheromone(fragCoord);\n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 getFood(vec2 p)\n{\n\treturn texelFetch(iChannel2, ivec2(loop(p, iResolution.xy)), 0);\n}\n\n\nvec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid SelectIfNearestNeighbor(inout vec4 pnb, vec2 p, vec2 dx)\n{\n    vec4 p_nb = getParticle(p + dx);\n    \n\tif(length(loop_d(p_nb.xy - p, iResolution.xy)) < length(loop_d(pnb.xy - p, iResolution.xy)))\n    {\n        pnb = p_nb;\n    }\n}\n\nvoid SearchForNearestNeighbor(inout vec4 pnb, vec2 p, float ring)\n{\n\t// sides\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,0));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(0,ring));\n\t\n\t// corners\n\tSelectIfNearestNeighbor(pnb, p, vec2(-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring,-ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(-ring,ring));\n    SelectIfNearestNeighbor(pnb, p, vec2(ring));\n}\n\nvoid EmitParticle(vec2 g, inout vec4 p)\n{\n    float emissionProbability = 0.01; // Adjust this value to control emission rate\n    \n    float agentTrailDistanceThreshold = rand2(g) ;\n\n   // Generate a random number between 0 and 1\n    float randAngle = Random(g + p.xy).x * 6.28318;\n    p.xy = g; // pos\n    p.z = randAngle; // angle\n    float rand = Random(g + p.xy).x;\n    \n    // sensor angle and activation\n    p.w = agentTrailDistanceThreshold;\n\n    p.w = mix(sensor_angle_rad_inf, sensor_angle_rad_sup, rand);\n\n}\n\nvoid MoveParticle(inout vec4 p)\n{\n    // left sensor\n\tfloat an = p.z + p.w;\n    vec2 sleft = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    // right sensor\n\tan = p.z - p.w;\n    vec2 sright = p.xy + sensor_distance * vec2(cos(an), sin(an));\n    \n    float diff_angle_f = getFood(sleft).x - getFood(sright).x;\n    float diff_angle_p = getPheromone(sleft).x -  getPheromone(sright).x;\n    \n    float diff_angle = diff_angle_p;\n\t\n    p.z += dt * sensor_strength * tanh(1.*diff_angle_f );\n    p.z += dt * sensor_strength * tanh(0.3 *diff_angle );\n    \n\tp.xy += dt * particle_speed * vec2(cos(p.z), sin(p.z));\n\tp.xy = loop(p.xy, iResolution.xy);\n}\n\nvoid PaintByMouse(vec2 g, inout vec4 p)\n{\n\tif (iMouse.z > 0.0)\n\t{\n\t\tif (length(g - iMouse.xy) < uMouseRadius)\n\t\t{\n\t\t\tEmitParticle(g, p);\n\t\t}\n\t}\n}\n\nvoid mainImage( out vec4 fragParticles, in vec2 fragCoord )\n{\n\tfragParticles = getParticle(fragCoord);\n\t\n\tSearchForNearestNeighbor(fragParticles, fragCoord, 1.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 2.0);\n    SearchForNearestNeighbor(fragParticles, fragCoord, 3.0);\n\t\n\tMoveParticle(fragParticles);\n\tPaintByMouse(fragCoord,  fragParticles);\n\n\tif (iFrame < 1) // reset \n\t{\n\t\tfragParticles = vec4(0);\n        \n        // start shape\n        vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n        uv.y += sin(uv.x * 5.0) * 0.3;\n        uv.x = mod(uv.x, 0.1);\n        float st = 5.0 / iResolution.y;\n        if (length(uv) < st)\n            EmitParticle(fragCoord, fragParticles);\n\t}\n    \n    if (reset(iChannel3))\n        fragParticles = vec4(0);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Created by Stephane Cuillerdier - Aiekick/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define dt 0.25\n\n// mouse\nconst float uMouseRadius = 2.0;\n\n// particle\nconst float particle_speed = 3.;\n\n// pheromones\nconst float gauss_coef =1.;\nconst float decay = 0.05;\n\n//Mouth/Food\nconst float maxTrailDistanceThreshold = 1.;\n\n// sensor\nconst float sensor_strength = 20.;\nconst float sensor_distance = 3.0;\nconst float sensor_angle_rad_inf = 1.0;\nconst float sensor_angle_rad_sup = 1.8;\n\n// shading\nconst vec3 lightDiffuse = vec3(0.,0.,0);\nconst vec3 lightSpecular = vec3(1.000,0.894,0.600);\nconst vec3 lightDirection = vec3(0.08,-0.24,-0.58);\nconst float specularPower = 10.0;\n\n// borderless \n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 loop_d(vec2 p, vec2 s){\n\treturn mod(p + s * 0.5, s) - s * 0.5;\n}\n\nvec2 loop(vec2 p, vec2 s){\n\treturn mod(p, s);\n}\n\nfloat rand2 (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nvec2 Random(vec2 p){\n\tvec3 a = fract(p.xyx * vec3(123.34,234.35,345.65));\n\ta += dot(a, a + 34.45);\n\treturn fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nbool reset(sampler2D sam) {\n    return texture(sam, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}", "buffer_b_code": "vec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getPheromone(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvoid DiffusePheromones(vec2 g, inout vec4 fragPheromone)\n{\n    // laplacian\n\tfloat v = 0.0;\n    v += getPheromone(g + vec2(-1, 0)).x; // l\n\tv += getPheromone(g + vec2( 0, 1)).x; // t\n\tv += getPheromone(g + vec2( 1, 0)).x; // r\n\tv += getPheromone(g + vec2( 0,-1)).x; // b\n\tv -= 4.0* fragPheromone.x;\n    \n\tfragPheromone += dt * v;\n}\n\nvoid mainImage( out vec4 fragPheromone, in vec2 fragCoord )\n{\n    fragPheromone = getPheromone(fragCoord);\n    \n    DiffusePheromones(fragCoord, fragPheromone);\n\t\n\t// write pheromones for each particles\n\tvec4 p = getParticle(fragCoord);\n\tif (p.w > 0.0)\n\t{\n\t\tfloat gauss = exp(-pow(length(fragCoord - p.xy)/gauss_coef,2.));\n\t\tfragPheromone += dt * gauss;\n\t}\n\t\n\t// dissipation  \n\tfragPheromone -= dt * decay * fragPheromone;\n    \n    if (iFrame < 1 || reset(iChannel3)) // reset \n\t\tfragPheromone = vec4(0);\n }", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 getParticle(vec2 p)\n{\n\treturn texelFetch(iChannel0, ivec2(loop(p, iResolution.xy)), 0);\n}\n\nvec4 getFood(vec2 p)\n{\n\treturn texelFetch(iChannel1, ivec2(loop(p, iResolution.xy)), 0);\n\n}\nvoid mainImage(out vec4 fragFood, in vec2 fragCoord)\n{\n    // Fetch the existing pixel color from buffer C\n    vec4 existingColor = texelFetch(iChannel1 , ivec2(fragCoord), 0);\n    vec4 overwriteColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    // Get the position of the particle at this pixel in buffer A\n    vec4 particle = getParticle(fragCoord);\n \n    // Check if the particle is active \n    if (particle.w > 1.0)\n    {\n        // Calculate the distance between the current pixel and the particle\n        float distance = length(fragCoord - particle.xy);\n\n        // Set a trail distance threshold\n        \n        float agentTrailDistance = particle.w*3.;\n        \n        float trailDistanceThreshold = 3.;\n        \n        // Set a trail opacity\n        float trailOpacity = 0.04;\n\n        // Only update the pixel if it's within the trail distance threshold\n        if (distance < agentTrailDistance)\n        {\n            if (reset(iChannel1))\n            fragFood = mix(overwriteColor, vec4(0), trailOpacity);\n             else{\n            fragFood = mix(overwriteColor, vec4(0), trailOpacity);\n            }\n        }\n        else\n        {\n            // If the pixel is outside the trail distance, retain the existing color\n            fragFood = overwriteColor;\n        }\n    }\n    else\n    {\n        // If no particle, retain the existing pixel color\n        fragFood = existingColor;\n    }\n    \n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKcWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[330, 330, 357, 357, 430], [432, 432, 455, 455, 528], [530, 530, 560, 560, 587], [589, 589, 646, 646, 1301]], "test": "untested"}
{"id": "DdVfR1", "name": "Mip vs Noise Blur (1 Sample)", "author": "gehtsiegarnixan", "description": "This demo compares the very cheap single sample blurs with each other. On the left is mip blur and on the right is dithered blur. ", "tags": ["noise", "blur", "cheap", "cheap", "dither", "mip", "gauss"], "likes": 1, "viewed": 251, "published": 3, "date": "1697923920", "time_retrieved": "2024-07-30T17:26:41.200274", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is more of an experiment. This compares Mip blur to dither blur, \nboth of which are extremely cheap with a single sample. \n\nThe right side uses dithering to offset the UV coordinates of the textures. \nIf you use Temporal Anti-Aliasing (TAA), it will automatically denoise your \nblur, giving you a cheap blur. Curiously, the hash functions look actually \nbetter for once compared to the dither functions from Valve or COD. This \ncould be useful if you can't use Mips.\n\nThe left side is mip blur where we simply use the stored mip level to blur \nthe textures. I would suggest using this one if you need a very cheap blur.\n\nThis demo includes mouse controls to adjust the noise strength and border.\nAlso, you can adjust the quasi motion blur sample count in the parameters \nbelow. \n\nI am not the first to try these, here is a noise blur from eliasku:\nhttps://www.shadertoy.com/view/7lGBzd\n\nAnd here is a Mip blur from the one and only IQ:\nhttps://www.shadertoy.com/view/4slGWn\n*/\n\n// The number of previous samples looked at to blur result, with a similar \n// effect to Temporal Anti-Aliasing (TAA) which you should use instead.\n#define TEMPORALBLUR 8\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nvec2 ScreenSpaceDither22(vec2 vScreenPos, float time) {\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + time); \n    return fract( vDither / vec2(103.0, 71.0));\n}\n\n// Function that uses dithering to blur an image\nvec3 ditherblur(vec2 uv, vec2 fragCoord, float time, float blurStrength) {\n\n    // Sample your noise with animation, and scale to vector\n    vec2 dither = ScreenSpaceDither22(fragCoord,time) -0.5;\n    \n    // Calculate noisy UVs\n    vec2 noisyUV = fract(uv - dither * blurStrength);\n    \n    // Calulate the buffer size\n    vec2 texSize = vec2(textureSize(iChannel0, 0));\n    ivec2 texelCoord = ivec2(noisyUV * texSize);\n\n    // sample texels with random offsets   \n    vec3 color = texelFetch(iChannel0, texelCoord, 0).xyz;\n\n    return color;\n}\n\n// Blurs an image using the mip level, blurstrength is in UV scale\nvec3 mipBlur(vec2 uv, float blurStrength) {\n    // Sample texture resolution\n    vec2 texSize = vec2(textureSize(iChannel0, 0));\n    \n    // Find out the max mip level\n    float maxMipLevel = log2(max(texSize.x, texSize.y));\n    \n    // Calculate pixel range of the blur\n    float blurPixelRange = max(texSize.x, texSize.y) * blurStrength;\n    \n    // Calculate mip level based on blur pixel range\n    float mipLevel = log2(blurPixelRange);\n    \n    // Sample texture\n    vec3 color = textureLod(iChannel0, uv, mipLevel).xyz;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Enable mouse controls when clicked, otherwise animate\n    float border;\n    float blurStrength;\n    if (iMouse.x > 0.0) {\n        // Mouse controls\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        border = mouse.x;\n        blurStrength = mix(0.0, 0.1, pow(mouse.y,2.));\n    } else {\n        // Animation\n        border = sin(iTime * 0.5) *0.5+0.5;\n        blurStrength = mix(0.0, 0.1, pow(cos(iTime * 0.3) *0.5+0.5,2.));\n    }\n    \n    // Correct blur for non-square aspect ratio\n    blurStrength *= iResolution.x/iResolution.y;   \n\n    // Alternate between mip blur and dithered blur\n    vec3 color;\n    if (uv.x > border) {\n        // Right dithered\n        #if TEMPORALBLUR <= 1\n            // We just take a single sample from the blurred function.\n            color += ditherblur(uv, fragCoord, iTime, blurStrength);\n        #else\n            // We take multiple samples from the ditheredSample function and average them.\n            // This is normally done automatically by your TAA or motion blur\n            for(int i = 0; i < TEMPORALBLUR; i++) {\n                color += ditherblur(uv, fragCoord, iTime - float(i), blurStrength);\n            }\n            color /= float(TEMPORALBLUR);\n        \n        #endif\n    } else {\n        // Left mip blur\n        color += mipBlur(uv, blurStrength).xyz;\n    }\n    \n    // Add a dividing line\n    color -= step(abs(uv.x - border), 0.002);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVfR1.jpg", "access": "api", "license": "mit", "functions": [[2238, 2423, 2478, 2478, 2599], [2601, 2650, 2724, 2786, 3195], [3197, 3264, 3307, 3340, 3809], [3811, 3811, 3867, 3917, 5428]], "test": "untested"}
{"id": "cstBDs", "name": "tile animation", "author": "kojdj0811", "description": "tile animation\n\nArt shader.Cineshader support\n[url] https://cineshader.com/view/cstBDs", "tags": ["pattern", "tile", "cineshader", "tileanimation"], "likes": 8, "viewed": 513, "published": 3, "date": "1697914547", "time_retrieved": "2024-07-30T17:26:42.158711", "image_code": "#define tileScale 4.0\n#define localOrigin vec2(0.5)\n#define worldOrigin vec2(0.0)\n\n#define random(p)        fract(sin(dot(p, vec2(123.456, 456.789))) * 789123.123)\n#define pingpong(x)      fract( mod(x,2.0) < 1.0 ? x : -(x) )\n#define dot2(v)          return dot(v,v);\n\n// https://easings.net/\n#define easeOutExpo(x) ( x == 1.0 ? 1.0 : 1.0 - exp2(-(x)/0.1) )\nfloat easeOutBack(float x) {\n    float c1 = 1.70158 * 5.0;\n    float c3 = c1 + 1.1;\n    float c4 = abs(x - 1.0);\n    float c5 = x - 1.0;\n\n    return 1.0 + c3 * c5*c5*c5 + c1 * c4*c4;\n}\n\nfloat easeInOutCirc(float x) {\n    float c1 = 2.0 * x;\n    float c2 = abs(-2.0 * x + 2.0);\n\n    return x < 0.5\n        ? (1.0 - sqrt(abs(1.0 - c1*c1))) / 2.0\n        : (sqrt(abs(1.0 - c2*c2)) + 1.0) / 2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n\tuv = tileScale*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\n    // reference for other projects\n    vec2 scaledUv = uv * tileScale;\n    vec2 tileUv = fract(scaledUv);\n    vec2 tileIndexXY = floor(scaledUv);\n    float tileIdex = tileIndexXY.x + tileIndexXY.y*tileScale;\n    float distToTile = distance(worldOrigin, tileIndexXY) / tileScale;\n\n    float checkPattern = (mod(tileIndexXY.x, 2.0) == 0.0 ? 1.0 : 0.0) == (mod(tileIndexXY.y, 2.0) <= 0.0 ? 1.0 : 0.0) ? 1.0 : 0.0;\n\n    float beat = 1.35;\n    float animationSpeed_circleScale = (floor(iTime*beat) + easeOutBack(fract(iTime*beat))) * 0.8;\n\n    float randomViaTileXYandDistToTile = mix(random(tileIndexXY), distToTile, 0.3);\n    float circleRadius = 0.5 * easeOutExpo(pingpong(animationSpeed_circleScale + (randomViaTileXYandDistToTile*2.0-1.0)));\n    circleRadius = pow(circleRadius, 1.1);\n\n    float circle = mix(0.0, 1.0, smoothstep(tileScale*7.5/iResolution.y, 0.0, distance(tileUv, localOrigin) - circleRadius));\n\n    vec4 normal = vec4(vec3(circle), 1.0);\n    vec4 check = vec4( mix( checkPattern, 1.0-checkPattern, smoothstep(tileScale*7.5/iResolution.y, 0.0, distance(tileUv, localOrigin)-circleRadius) ) );\n\n\tvec3 col = mix(normal, check, easeInOutCirc(pingpong(iTime*beat*2.0))).xyz;\n    fragColor = vec4(col, 0.2+length(col)*0.05);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cstBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 386, 386, 542], [544, 544, 574, 574, 751], [754, 754, 811, 811, 2204]], "test": "untested"}
{"id": "ms3fWs", "name": "Liquid Box 2", "author": "michael0884", "description": "Added normal estimate from the anisotropic kernels. Normals modulated with waves. And full internal reflection, i.e. second bounce)\nThis is getting pretty expensive aaaa", "tags": ["particle", "sph"], "likes": 45, "viewed": 886, "published": 3, "date": "1697912365", "time_retrieved": "2024-07-30T17:26:43.494141", "image_code": "// Fork of \"Anisotropic surface reconstruct\" by michael0884. https://shadertoy.com/view/csdfD2\n// 2023-10-20 00:14:26\n\n// Fork of \"3D Water Box\" by michael0884. https://shadertoy.com/view/dscfRf\n// 2023-10-16 20:53:25\n\n#define SHADOWS \n#define REFRACT\n#define REFLECT\n\nconst vec3 light = 2.0*vec3(1.0,1.0,1.0);\nconst vec3 absorb = vec3(0.773,0.910,0.969);\nconst vec3 albedo = vec3(0.000,0.031,0.059);\nconst vec3 F0 = vec3(0.04);\nconst float roughness = 0.1;\nconst float IOR = 1.33;\n\n#define RADIUS 1.0\n\n#define FOV 3.\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvoid iEllipsoid(inout Ray ray, in vec3 p, in vec3 r, in vec4 q)\n{\n    vec3 ro = ray.ro - p;\n    ro = qrot(ro, conj_q(q));\n    vec3 rd = qrot(ray.rd, conj_q(q));\n    \n    vec3 r2 = r*r;\n    float a = dot( rd, rd/r2 );\n\tfloat b = dot( ro, rd/r2 );\n\tfloat c = dot( ro, ro/r2 );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return;\n    \n\tfloat t = (-b - sqrt( h ))/a;\n    if(t >= ray.td || t < 0.0) return;\n    ray.normal = qrot(normalize( (ro + t * rd)/r2 ), q);\n    ray.color = vec3(1.);\n    ray.td = t;\n}\n\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    vec4 packed = LOAD3D(ch0, p);\n    Particle p0, p1;\n    unpackParticles(packed, p, p0, p1);\n    \n    if(p0.mass + p1.mass == 0u) return;\n    Covariance c0, c1;\n    unpackCovariance(LOAD3D(ch2, p), c0, c1);\n\n    if(p0.mass > 0u) iEllipsoid(ray, p0.pos, RADIUS*c0.s, c0.q);\n    if(p1.mass > 0u) iEllipsoid(ray, p1.pos, RADIUS*c1.s, c1.q);\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec4 rho = voxel(ch1, p);\n    if(rho.z < 1e-3) return;\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\n\nfloat Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nfloat Shadow(vec3 p)\n{\n    float optical_density = trilinear(ch2, p).x;\n    return exp(-optical_density)+0.05;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n\nvec3 refractFull(vec3 rd, vec3 n, float ior)\n{\n    vec3 refr = refract(rd, n, ior);\n    if(length(refr) < 0.5)\n    {\n        return reflect(rd, n);\n    }\n    else return refr;\n}\n\n#define ISO_VALUE 0.2\n#define STEP_SIZE 0.5\n\nfloat TraceDensity(vec3 ro, vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(1.0))) || any(greaterThan(p, size3d - 1.0))) return dens;\n        float d = smoothstep(ISO_VALUE*0.8, ISO_VALUE, Density(p));\n        dens += d * 1.0;\n        td += 1.0;\n    }\n    return dens;\n}\n\n\nfloat TraceDensityMedium(vec3 ro, inout vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    float de = 0.0;\n    float pde = 0.0;\n    bool bounced = false;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(0.0))) || any(greaterThan(p, size3d))) return dens;\n        float ldens = Density(p);\n        float d = smoothstep(ISO_VALUE*0.9, ISO_VALUE*1.1, ldens);\n        dens += d * STEP_SIZE;\n        pde = de;\n        de = ldens - ISO_VALUE;\n        if(pde > 0.0 && de < 0.0 && !bounced && td > 2.5)\n        {\n            float std = td - STEP_SIZE*(de/(de-pde));\n            vec3 sp = ro + rd*std;\n            vec3 normal = normalize(calcNormal(sp, 0.5).xyz);\n            ro = sp;\n            rd = refractFull(rd, normal, IOR);\n            td = 0.0;\n            bounced = true;\n        }\n        td += STEP_SIZE;\n    }\n    return dens;\n}\n\n\nvec3 ParticleGrad(Particle p_, Covariance c, vec3 p)\n{\n    if(p_.mass == 0u) return vec3(0.0);\n    vec3 dx = p_.pos - p;\n    float v = length(p_.vel);\n    vec3 vdir = p_.vel/max(v, 1e-5);\n    vec3 vn0 = cross(vdir, vec3(0,0,1));\n    vec3 vn1 = cross(vdir, vn0);\n    float wave = 1.0 + 0.0*min(3.0*v*v, 3.0)*sin(2.5*dot(vn0, dx))*sin(2.5*dot(vn1, dx));\n    vec3 gaussian = Gaussian3DCov(dx, 1.2*c.s, c.q);\n    return float(p_.mass)*gaussian*wave;\n}\n\nvec3 ParticleGradient(vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec3 grad = vec3(0.0);\n\n    range(i, -3, 3) range(j, -3, 3) range(k, -3,3)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n\n        //load the particles\n        vec4 packed = LOAD3D(ch0, p1);\n        Particle p0_, p1_;\n\n        unpackParticles(packed, p1, p0_, p1_);\n\n        if(p0_.mass + p1_.mass == 0u) continue;\n        Covariance c0, c1;\n        unpackCovariance(LOAD3D(ch2, p1), c0, c1);\n        \n        grad += ParticleGrad(p0_, c0, p);\n        grad += ParticleGrad(p1_, c1, p);\n    }\n\n    return grad;\n}\n\n\nfloat DE(vec3 p)\n{\n    return ISO_VALUE - Density(p);\n}\n\nfloat TraceIsoSurface(Ray ray, float mint, float inside)\n{\n    const int step_count = 300;\n    float td = mint;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = ray.ro + ray.rd * td;\n        if(!all(lessThanEqual(p, size3d)) || !all(greaterThanEqual(p, vec3(0.))))\n        {\n            return ray.td;\n        }\n        float d = inside*4.0*DE(p);\n        if(d < 0.0)\n        {\n            return td;\n        }\n        td += d;\n    }\n    return td;\n}\n\nvec3 Background(vec3 rd)\n{\n    vec3 col = texture(iChannel3,  rd.yzx).xyz;\n    return 2.0*pow(col, vec3(2.0)) + 0.0*col*exp(15.0*(length(col) - 1.45));\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*sqr( sqr(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\n\nvec3 PBR(vec3 P, vec3 V, vec3 L, vec3 Lcol, vec3 N, vec3 color, vec3 absorb)\n{\n    vec3 Re = reflect(-V, N);\n    vec3 Rf = refract(-V, N, 1.0/1.33);\n    vec3 H = normalize(V + L);\n    float NdotL = max(dot(N, L), 2e-3);\n    float NdotV = max(dot(N, V), 2e-3);\n\n    #ifdef SHADOWS\n    float dens = TraceDensity(P+L*2.0, L);\n    float shadow = exp(-dens);\n    float ambient = 0.4*exp(-0.3*dens) + 0.1*exp(-0.1*dens) + 0.05*exp(-0.05*dens);\n    #else\n    float shadow = 1.0;\n    float ambient = 0.3;\n    #endif\n    \n    #ifdef REFRACT\n    float refrDens = TraceDensityMedium(P, Rf);\n    vec3 refraction = Background(Rf) * exp(-0.5*refrDens*(1.0 - absorb));\n    #else\n    vec3 refraction = vec3(0.0);\n    #endif\n    \n    #ifdef REFLECT\n    float reflDens = TraceDensity(P, Re);\n    vec3 reflection = Background(Re) * exp(-0.5*reflDens*(1.0 - absorb));\n    #else\n    vec3 reflection = (1.0 - roughness)*Background(Re);\n    #endif\n    \n    float selfshadow = G_ggx(NdotL,roughness)*G_ggx(NdotV,roughness)/max(4.0*NdotL*NdotV,1e-3);\n    float specular = selfshadow*NDF_ggx(H, N, roughness) * NdotL;\n    \n    vec3 Lbright = shadow * Lcol;\n    \n    vec3 refr = Lbright * color * NdotL / PI + refraction;\n    vec3 relf = Lbright * specular + reflection;\n    vec3 ambi = ambient * color * (0.7*NdotL + 0.3);\n    \n    vec3 kS = fresnel(V, N, F0);\n    vec3 kD = 1.0 - kS;\n    return (ambi + refr) * kD + relf * kS;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{    \n    InitGrid(iResolution.xy);\n    \n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.04 + 0.05*iTime, -0.5);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.4;\n    vec3 ro = vec3(size3d)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n    \n    \n\n    vec2 tdBox = iBox(ro - vec3(size3d)*0.5, rd, 0.5*vec3(size3d));\n    col.xyz =Background(rd);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x+0.5, 0.0);\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n        int i = 0;\n        for(; i < 200; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n            td += 1.5;\n            if(td > tdBox.y-1.0)\n            {\n                break;\n            }\n            if(ray.td < tdBox.y-1.0)\n            {\n                break;\n            }\n        }\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal = normalize(ParticleGradient(p0));\n            vec3 normal1 = -normalize(calcNormal(p0, 0.5).xyz);\n            //normal =  -normalize(mix(-ray.normal, normal1, NORMAL_SMOOTHNESS));\n            \n            col.xyz = PBR(p0, -ray.rd, light_dir, light, normal, albedo, absorb);\n        }\n        \n        //col.xyz = 0.01*vec3(1,1,1)*TraceDensity(ro + rd*max(tdBox.x+0.001,0.0), rd);\n    }\n    \n    col.xyz = 1.0 - exp(-2.5*pow(col.xyz,vec3(1.0/1.3)));\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define R iResolution.xy\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.741,1.000,0.580))\n\n#define initial_particle_density 1u\n#define dt 1.\n#define rest_density 0.5\n#define gravity 0.01\n\n#define PRESSURE 2.5\n#define PRESSURE_RAD 0.85\n#define VISCOSITY 0.65\n#define SPIKE_KERNEL 0.6\n#define SPIKE_RAD 0.75\n\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 1.0\n#define cooling 0.0\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\nfloat cub(float x)\n{\n    return x*x*x;\n}\n\nvec3 quaternionAxis(vec4 q)\n{\n    return normalize(q.xyz);\n}\n\nfloat quaternionAngle(vec4 q)\n{\n    return atan(length(q.xyz), q.w) * 2.0;\n}\n\nvec3 quaternionToAxisAngle(vec4 q)\n{\n    return quaternionAxis(q) * quaternionAngle(q);\n}\n\nvec4 axisAngleToQuaternion(vec3 aa)\n{\n    float angle = length(aa);\n    vec3 axis = normalize(aa);\n    return vec4(axis * sin(angle * 0.5), cos(angle * 0.5));\n}\n\nvec3 qrot(vec3 x, vec4 q)\n{\n    return x + 2.0 * cross(cross(x, q.xyz) + q.w * x, q.xyz);\n}\n\nvec4 conj_q(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nfloat Pressure(float rho)\n{\n    return (rho/rest_density - 1.0)/max(rho*rho, 0.001);\n}\n\nfloat Gaussian(float r, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    return norm * exp(-0.5*sqr(r/d));\n}\n\nvec3 GaussianGrad(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return - (norm/sqr(d)) * exp(-0.5*sqr(r/d)) * dx;\n}\n\nvec4 GaussianGrad2(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return norm * exp(-0.5*sqr(r/d)) * vec4(-dx /sqr(d), 1.0);\n}\n\nfloat Gaussian1D(float x, float d)\n{\n    float norm = 1.0/(d*sqrt(TWO_PI));\n    return norm * exp(-0.5*sqr(x/d));\n}\n\nfloat Gaussian1DGrad(float x, float d)\n{\n    float norm = 1.0/(d*sqrt(TWO_PI));\n    return - (norm/sqr(d)) * exp(-0.5*sqr(x/d)) * x;\n}\n\nvec2 Gaussian1DGrad2(float x, float d)\n{\n    d = max(d, 0.1);\n    float norm = 1.0/(d*sqrt(TWO_PI));\n    return norm * exp(-0.5*sqr(x/d)) * vec2(-x /sqr(d), 1.0);\n}\n\nfloat Gaussian3D(vec3 dx, vec3 d)\n{\n    return Gaussian(dx.x, d.x) * Gaussian(dx.y, d.y) * Gaussian(dx.z, d.z);\n}\n\nvec3 Gaussian3DGrad(vec3 dx, vec3 d)\n{\n    vec2 gx = Gaussian1DGrad2(dx.x, d.x);\n    vec2 gy = Gaussian1DGrad2(dx.y, d.y);\n    vec2 gz = Gaussian1DGrad2(dx.z, d.z);\n    return vec3(gx.x * gy.y * gz.y, gx.y * gy.x * gz.y, gx.y * gy.y * gz.x);\n}\n\nvec3 Gaussian3DCov(vec3 dx, vec3 d, vec4 q)\n{\n    vec3 x = qrot(dx, conj_q(q));\n    vec3 g = Gaussian3DGrad(x, d);\n    return qrot(g, q);\n}\n\n\n#define KERNEL_POLY6_NORMALIZATION (315.0 / (64.0 * PI))\n#define KERNEL_SPIKE_NORMALIZATION (45 / PI)\n#define KERNEL_RADIUS 1.0\n\nfloat KernelPoly6(float r, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    return (r <= d) ? c * cub(sqr(d) - sqr(r)) : 0.0;\n}\n\nvec3 KernelPoly6Grad(vec3 dx, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    float r = length(dx);\n    return (r <= d) ? clamp(-6.0 * c * sqr(sqr(d) - sqr(r)), -3.0, 0.0) * dx : vec3(0.0);\n}\n\n#define GD(x, R) Gaussian(length(x),R)\n#define GGRAD(x, R) GaussianGrad(x, R)\n#define GGRAD2(x,R) GaussianGrad2(x, R)\n//#define GD(x, R) 12.0*KernelPoly6(length(x),R*4.0/2.0)\n//#define GGRAD(x, R) 12.0*KernelPoly6Grad(x, R*4.0/2.0)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//3d slice aspect ratio \n#define ar vec2(1.0,0.5)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    p3d = clamp(p3d, vec3(0.0), size3d);\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\n//#define pixel(a, p, s) texture(a, (p+0.5)/vec2(s))\n\nvec4 pixel(sampler2D ch, vec2 pos)\n{\n    vec2 d = pos - floor(pos);\n    vec4 p00 = texelFetch(ch, ivec2(pos), 0);\n    vec4 p01 = texelFetch(ch, ivec2(pos) + ivec2(0, 1), 0);\n    vec4 p10 = texelFetch(ch, ivec2(pos) + ivec2(1, 0), 0);\n    vec4 p11 = texelFetch(ch, ivec2(pos) + ivec2(1, 1), 0);\n    return mix(mix(p00, p01, d.y), mix(p10, p11, d.y), d.x);\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 udir(vec2 rng)\n{\n    float phi = 2.*PI*rng.x;\n    float ctheta = 2.*rng.y-1.;\n    float stheta = sqrt(1.0-ctheta*ctheta);\n    return vec3(cos(phi)*stheta, sin(phi)*stheta, ctheta);\n}\n\nstruct Covariance\n{\n    vec4 q;\n    vec3 s;\n};\n\nstruct Particle \n{\n    uint mass;\n    vec3 pos;\n    vec3 vel;\n    vec3 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    uvec3 sv = uvec3(round(clamp(v*scale, -1.0, 1.0) * 255.0) + 255.0);\n    uint packed = uint(exp + 15) | (sv.x << 5) | (sv.y << 14) | (sv.z << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nuint packmasspos(uint mass, vec3 p0)\n{\n    uvec3 pos0 = uvec3(clamp(p0, 0.0, 1.0) * 255.0);\n    return mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n}\n\nuint packMassPos(uint mass, vec3 pos)\n{\n    uvec3 pos0 = uvec3(clamp(pos, 0.0, 1.0) * 255.0); // Assuming pos range [0, 1] in a cell\n    uint data1 = mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n    return data1;\n}\n\nvoid unpackMassPos(uint packed, out uint mass, out vec3 pos)\n{\n    mass = packed & 0xFFu;\n    uvec3 pos0 = uvec3((packed >> 8) & 0xFFu, (packed >> 16) & 0xFFu, (packed >> 24) & 0xFFu);\n    pos = vec3(pos0) / 255.0;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec3 pos)\n{\n    p0.pos -= pos;\n    p1.pos -= pos;\n\n    uvec4 data = uvec4(\n        packMassPos(p0.mass, p0.pos),\n        packMassPos(p1.mass, p1.pos),\n        packvec3(p0.vel),\n        packvec3(p1.vel)\n    );\n\n    return uintBitsToFloat(data);\n}\n\nvoid unpackParticles(vec4 packed, vec3 pos, out Particle p0, out Particle p1)\n{\n    uvec4 data = floatBitsToUint(packed);\n    \n    unpackMassPos(data.x, p0.mass, p0.pos);\n    unpackMassPos(data.y, p1.mass, p1.pos);\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    p0.vel = unpackvec3(data.z);\n    p1.vel = unpackvec3(data.w);\n}\n\nvec4 packCovariance(Covariance c0, Covariance c1)\n{\n    uvec4 data;\n    data.x = packvec3(c0.s);\n    data.y = packvec3(quaternionToAxisAngle(c0.q));\n    data.z = packvec3(c1.s);\n    data.w = packvec3(quaternionToAxisAngle(c1.q));\n\n    return uintBitsToFloat(data);\n}\n\nvoid unpackCovariance(vec4 fdata, out Covariance c0, out Covariance c1)\n{\n    uvec4 data = floatBitsToUint(fdata);\n    c0.s = unpackvec3(data.x);\n    c0.q = axisAngleToQuaternion(unpackvec3(data.y));\n    c1.s = unpackvec3(data.z);\n    c1.q = axisAngleToQuaternion(unpackvec3(data.w));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec3 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    vec3 pos = p1.pos;\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec3 dir = udir(hash23(pos));\n    p1.pos = pos - dir*5e-3;\n    p2.pos = pos + dir*5e-3;\n    p2.vel = p1.vel;\n}\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    if(incoming.mass == 0u || p.mass == 0u) return;\n\n    vec3 dx = incoming.pos - p.pos;\n    vec3 ggrad = GGRAD(dx, PRESSURE_RAD);\n    if(length(ggrad) < 1e-5) return;\n    \n    vec3 dv = incoming.vel - p.vel;\n    float d = length(dx);\n    vec3 dir = dx / max(d, 1e-3);\n    \n    float rho0 = p.density;\n    float rho1 = incoming.density;\n    float mass0 = float(p.mass);\n    float mass1 = float(incoming.mass);\n  \n    \n    float pressure = 0.5*p.density*(Pressure(p.density) + Pressure(incoming.density));\n    vec3 F_SPH = - PRESSURE * pressure * ggrad;\n    vec3 F_VISC = VISCOSITY * dot(dir, dv) * ggrad;\n    vec3 F_SPIKE = SPIKE_KERNEL * GD(d, SPIKE_RAD) * dir;\n   \n    p.force += - (F_SPH + F_VISC + F_SPIKE) * mass1;\n    \n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid IntegrateParticle(inout Particle p, vec3 pos, vec2 iR, vec4 iM, float time)\n{\n    if(p.mass == 0u) return;\n    p.force = p.force;/// max(0.0001, float(p.mass));\n    p.force += gravity*vec3(0.4*sin(1.5*time), 0.2*cos(0.75*time), -1.0); //gravity\n    \n\n    vec4 border = border_grad(p.pos);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    p.force += force_boundary*bound*dt;\n    //p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    //if(iM.z > 0.)\n    //{\n    //    vec3 dx = pos - vec3(iM.xy, 0.0);\n    //    p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    //}\n        \n    p.vel += p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}\n\nvoid InitGrid(vec2 iR)\n{\n    SCALE = floor(ar*pow(iR.x*iR.y,0.1666666));\n    size3d = vec3(floor(iR.xy/SCALE), SCALE.x*SCALE.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1;\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 pos1 = pos + vec3(i, j, k);\n        if(!all(lessThanEqual(pos1, size3d)) || !all(greaterThanEqual(pos1, vec3(0.0))))\n        {\n            continue;\n        }\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming, float rad)\n{\n    if(incoming.mass == 0u) return;\n    float d = distance(p.pos, incoming.pos);\n    float mass = float(incoming.mass);\n    p.density += mass*GD(d,rad);\n}\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        if(i == 0 && j == 0 && k == 0) continue;\n        vec3 pos1 = pos + vec3(i, j, k);\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n        if(p0.mass > 0u)\n        {\n            AddDensity(p0, p0_, KERNEL_RADIUS);\n            AddDensity(p0, p1_, KERNEL_RADIUS);\n        }\n        if(p1.mass > 0u)\n        {\n            AddDensity(p1, p0_, KERNEL_RADIUS);\n            AddDensity(p1, p1_, KERNEL_RADIUS);\n        }\n        \n        AddDensity(pV, p0_, 1.0);\n        AddDensity(pV, p1_, 1.0);\n    }\n\n    if(p0.mass > 0u)\n    {\n        AddDensity(p0, p0, KERNEL_RADIUS);\n        AddDensity(p0, p1, KERNEL_RADIUS);\n    }\n    if(p1.mass > 0u)\n    {\n        AddDensity(p1, p0, KERNEL_RADIUS);\n        AddDensity(p1, p1, KERNEL_RADIUS);\n    }\n    AddDensity(pV, p0, 1.0);\n    AddDensity(pV, p1, 1.0);\n\n    fragColor = vec4(p0.density, p1.density, pV.density, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define EMITTER_POS vec3(0.1,0.5,0.5)\n#define EMITTER_RAD 4.0\n#define EMITTER_VEL vec3(1.0, 0.0, 0.0)\n#define EMITTER_NUM 1\n\n#define VOID_POS vec3(0.8,0.5,0.1)\n#define VOID_RAD 12.0\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = voxel(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = voxel(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse, iTime);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse, iTime);\n        \n        if(isKeyPressed(KEY_UP))\n        {\n            float void_d = distance(p0.pos, size3d*VOID_POS);\n            if(void_d < VOID_RAD)\n            {\n                p0.mass = 0u;\n            }\n        }\n    \n        if(!isKeyPressed(KEY_LEFT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(dx.y, -dx.x, 0.0)*0.003;\n        }\n        \n        if(isKeyPressed(KEY_RIGHT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(-dx.y, dx.x, 0.0)*0.003;\n        }\n    }\n    \n        \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.4*size3d.x && pos.x > 0.0*size3d.x && \n           pos.y < 0.85*size3d.y && pos.y > 0.15*size3d.y &&\n           pos.z < 0.85*size3d.z && pos.z > 0.15*size3d.z)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos;\n        p0.vel = vec3(0.0);\n        p1.pos = pos;\n        p1.vel = vec3(0.0);\n    }\n\n    if(all(equal(p0.pos, p1.pos)))\n    {\n        p1.pos += 1e-2;\n    }\n    \n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tfloat emitter_d = distance(pos, size3d*EMITTER_POS);\n        if(emitter_d < EMITTER_RAD && int(pos.y) % 2 == 0 && int(pos.z) % 2 == 0 && int(pos.x) % 2 == 0)\n        {\n            Particle emit;\n            emit.pos = pos;\n            emit.mass = 1u;\n            emit.vel = EMITTER_VEL;\n            \n            BlendParticle(p0, emit);\n        }\n    }\n    \n        \n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#undef R\n\n\n#define GAMMA 5.8284271247\n#define C_STAR 0.9238795325\n#define S_STAR 0.3826834323\n#define SVD_EPS 0.0000001\n\nvec2 approx_givens_quat(float s_pp, float s_pq, float s_qq) {\n    float c_h = 2.0 * (s_pp - s_qq);\n    float s_h2 = s_pq * s_pq;\n    float c_h2 = c_h * c_h;\n    if (GAMMA * s_h2 < c_h2) {\n        float omega = 1.0f / sqrt(s_h2 + c_h2);\n        return vec2(omega * c_h, omega * s_pq);\n    }\n    return vec2(C_STAR, S_STAR);\n}\n\n// the quaternion is stored in vec4 like so:\n// (c, s * vec3) meaning that .x = c\nmat3 quat_to_mat3(vec4 quat) {\n    float qx2 = quat.y * quat.y;\n    float qy2 = quat.z * quat.z;\n    float qz2 = quat.w * quat.w;\n    float qwqx = quat.x * quat.y;\n    float qwqy = quat.x * quat.z;\n    float qwqz = quat.x * quat.w;\n    float qxqy = quat.y * quat.z;\n    float qxqz = quat.y * quat.w;\n    float qyqz = quat.z * quat.w;\n\n    return mat3(1.0f - 2.0f * (qy2 + qz2), 2.0f * (qxqy + qwqz), 2.0f * (qxqz - qwqy),\n        2.0f * (qxqy - qwqz), 1.0f - 2.0f * (qx2 + qz2), 2.0f * (qyqz + qwqx),\n        2.0f * (qxqz + qwqy), 2.0f * (qyqz - qwqx), 1.0f - 2.0f * (qx2 + qy2));\n}\n\nmat3 symmetric_eigenanalysis(mat3 A) {\n    mat3 S = transpose(A) * A;\n    // jacobi iteration\n    mat3 q = mat3(1.0f);\n    for (int i = 0; i < 5; i++) {\n        vec2 ch_sh = approx_givens_quat(S[0].x, S[0].y, S[1].y);\n        vec4 ch_sh_quat = vec4(ch_sh.x, 0, 0, ch_sh.y);\n        mat3 q_mat = quat_to_mat3(ch_sh_quat);\n        S = transpose(q_mat) * S * q_mat;\n        q = q * q_mat;\n\n        ch_sh = approx_givens_quat(S[0].x, S[0].z, S[2].z);\n        ch_sh_quat = vec4(ch_sh.x, 0, -ch_sh.y, 0);\n        q_mat = quat_to_mat3(ch_sh_quat);\n        S = transpose(q_mat) * S * q_mat;\n        q = q * q_mat;\n\n        ch_sh = approx_givens_quat(S[1].y, S[1].z, S[2].z);\n        ch_sh_quat = vec4(ch_sh.x, ch_sh.y, 0, 0);\n        q_mat = quat_to_mat3(ch_sh_quat);\n        S = transpose(q_mat) * S * q_mat;\n        q = q * q_mat;\n\n    }\n    return q;\n}\n\nvec2 approx_qr_givens_quat(float a0, float a1) {\n    float rho = sqrt(a0 * a0 + a1 * a1);\n    float s_h = a1;\n    float max_rho_eps = rho;\n    if (rho <= SVD_EPS) {\n        s_h = 0.0;\n        max_rho_eps = SVD_EPS;\n    }\n    float c_h = max_rho_eps + a0;\n    if (a0 < 0.0) {\n        float temp = c_h - 2.0 * a0;\n        c_h = s_h;\n        s_h = temp;\n    }\n    float omega = 1.0f / sqrt(c_h * c_h + s_h * s_h);\n    return vec2(omega * c_h, omega * s_h);\n}\n\nstruct QR_mats {\n    mat3 Q;\n    mat3 R;\n};\n\nQR_mats qr_decomp(mat3 B) {\n    QR_mats qr_decomp_result;\n    mat3 R;\n    // 1 0\n    // (ch, 0, 0, sh)\n    vec2 ch_sh10 = approx_qr_givens_quat(B[0].x, B[0].y);\n    mat3 Q10 = quat_to_mat3(vec4(ch_sh10.x, 0, 0, ch_sh10.y));\n    R = transpose(Q10) * B;\n\n    // 2 0\n    // (ch, 0, -sh, 0)\n    vec2 ch_sh20 = approx_qr_givens_quat(R[0].x, R[0].z);\n    mat3 Q20 = quat_to_mat3(vec4(ch_sh20.x, 0, -ch_sh20.y, 0));\n    R = transpose(Q20) * R;\n\n    // 2 1\n    // (ch, sh, 0, 0)\n    vec2 ch_sh21 = approx_qr_givens_quat(R[1].y, R[1].z);\n    mat3 Q21 = quat_to_mat3(vec4(ch_sh21.x, ch_sh21.y, 0, 0));\n    R = transpose(Q21) * R;\n\n    qr_decomp_result.R = R;\n\n    qr_decomp_result.Q = Q10 * Q20 * Q21;\n    return qr_decomp_result;\n}\n\nstruct SVD_mats {\n    mat3 U;\n    mat3 Sigma;\n    mat3 V;\n};\n\nSVD_mats svd(mat3 A) {\n    SVD_mats svd_result;\n    svd_result.V = symmetric_eigenanalysis(A);\n\n    mat3 B = A * svd_result.V;\n\n    // sort singular values\n    float rho0 = dot(B[0], B[0]);\n    float rho1 = dot(B[1], B[1]);\n    float rho2 = dot(B[2], B[2]);\n    if (rho0 < rho1) {\n        vec3 temp = B[1];\n        B[1] = -B[0];\n        B[0] = temp;\n        temp = svd_result.V[1];\n        svd_result.V[1] = -svd_result.V[0];\n        svd_result.V[0] = temp;\n        float temp_rho = rho0;\n        rho0 = rho1;\n        rho1 = temp_rho;\n    }\n    if (rho0 < rho2) {\n        vec3 temp = B[2];\n        B[2] = -B[0];\n        B[0] = temp;\n        temp = svd_result.V[2];\n        svd_result.V[2] = -svd_result.V[0];\n        svd_result.V[0] = temp;\n        rho2 = rho0;\n    }\n    if (rho1 < rho2) {\n        vec3 temp = B[2];\n        B[2] = -B[1];\n        B[1] = temp;\n        temp = svd_result.V[2];\n        svd_result.V[2] = -svd_result.V[1];\n        svd_result.V[1] = temp;\n    }\n\n    QR_mats QR = qr_decomp(B);\n    svd_result.U = QR.Q;\n    svd_result.Sigma = QR.R;\n    return svd_result;\n}\n\nstruct UP_mats {\n    mat3 U;\n    mat3 P;\n};\n\nUP_mats SVD_to_polar(SVD_mats B) {\n    UP_mats polar;\n    polar.P = B.V * B.Sigma * transpose(B.V);\n    polar.U = B.U * transpose(B.V);\n    return polar;\n}\n\nUP_mats polar_decomp(mat3 A) {\n    SVD_mats B = svd(A);\n    UP_mats polar;\n    polar.P = B.V * B.Sigma * transpose(B.V);\n    polar.U = B.U * transpose(B.V);\n    return polar;\n}\n\nvec3 safeDiv(vec3 a, vec3 b) {\n    return sign(b) * a / (abs(b) + 1e-4);\n}\n\nvec3 safeDiv(vec3 a, float b)\n{\n    return sign(b)* a / (abs(b) + 1e-4);\n}\n\nvec4 quaternion(vec3 axis, float angle) {\n    return vec4(axis * sin(angle * 0.5), cos(angle * 0.5));\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz), a.w * b.w - dot(a.xyz, b.xyz));\n}\n\nmat3 unit(float a) {\n    return mat3(a, 0, 0, 0, a, 0, 0, 0, a);\n}\n\nmat3 q2m(vec4 q) {\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a * q.w, v = q.xyx * a.xxy * q.w;\n    mat3 m = mat3(0, u.x, u.y, u.z, 0, v.x, v.y, v.z, 0) + unit(0.5) + outerProduct(q.xyz, q.xyz) * (1.0 - unit(1.0));\n    q *= q;\n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\nvec4 m2q(mat3 m) {\n    vec4 q;\n    q.w = sqrt(max(0.0, 1.0 + m[0][0] + m[1][1] + m[2][2])) / 2.0;\n    q.x = sqrt(max(0.0, 1.0 + m[0][0] - m[1][1] - m[2][2])) / 2.0;\n    q.y = sqrt(max(0.0, 1.0 - m[0][0] + m[1][1] - m[2][2])) / 2.0;\n    q.z = sqrt(max(0.0, 1.0 - m[0][0] - m[1][1] + m[2][2])) / 2.0;\n\n    q.x = abs(q.x) * sign(m[2][1] - m[1][2]);\n    q.y = abs(q.y) * sign(m[0][2] - m[2][0]);\n    q.z = abs(q.z) * sign(m[1][0] - m[0][1]);\n    \n    return q;\n}\n\nfloat KernelW(float r, float d)\n{\n    return (r>d)?0.0:(1.0 - cub(r/d));\n}\n\n\nvoid UpdateC(inout mat3 C, vec4 pos, Particle p, inout float N)\n{\n    if(p.mass == 0u) return;\n    \n\tvec3 dx = pos.xyz - p.pos;\n    float d = length(dx);\n    float mass = float(p.mass);\n    float K = mass * KernelW(d, 3.0);\n    if(K>0.0) N++;\n\tC += outerProduct(dx, dx) * K;\n}\n\nvoid UpdatePos(inout vec4 pos, Particle a, Particle p)\n{\n    if(a.mass == 0u || p.mass == 0u) return;\n\n    vec3 dx = a.pos - p.pos;\n    float d = length(dx);\n    float mass = float(p.mass);\n    float K = mass * KernelW(d, 3.0);\n    \n\tpos += K * vec4(p.pos, 1.0);\n}\n\n#define kr 4.0\n#define ks 1400.0\n#define kn 0.5\n#define Ne 6.0\n\nvec3 FixScale(vec3 scale, float N)\n{\n    if(N <= Ne) return kn*vec3(1.0);\n    scale.y = max(scale.y, scale.x/kr);\n    scale.z = max(scale.z, scale.x/kr);\n    return ks*scale;\n}\n\nCovariance GetCovariance(mat3 C, float N) {\n    Covariance cov;\n\n    SVD_mats svd = svd(C);\n    //get rotaion\n    cov.q = m2q(svd.U);\n    //get scale\n    cov.s = vec3(svd.Sigma[0][0], svd.Sigma[1][1], svd.Sigma[2][2]);\n    //normalize scale\n    cov.s = FixScale(cov.s, N);\n    cov.s /= cov.s.x;\n    //invert scale\n    //cov.s = 1.0/cov.s;\n    return cov;\n    \n}\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass > 0u || p1.mass >0u)\n    {\n        vec4 x0 = vec4(0.00001);\n        vec4 x1 = x0;\n        float N0 = 0.0;\n        float N1 = 0.0;\n        range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n        {\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n         \n            UpdatePos(x0, p0, p0_);\n            UpdatePos(x1, p1, p0_);\n            UpdatePos(x0, p0, p1_);\n            UpdatePos(x1, p1, p1_);\n        }\n    \n        mat3 C0 = mat3(0.0);\n        mat3 C1 = C0;\n        x0 = x0/x0.w;\n        x1 = x1/x1.w;\n\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n            UpdateC(C0, x0, p0_, N0);\n            UpdateC(C1, x1, p0_, N1);\n            UpdateC(C0, x0, p1_, N0);\n            UpdateC(C1, x1, p1_, N1);\n        }\n\n        UpdateC(C1, x1, p0, N1);\n        UpdateC(C0, x0, p1, N0);\n    \n\n        Covariance Cov0 = GetCovariance(C0, N0);\n        Covariance Cov1 = GetCovariance(C1, N1);\n\n        fragColor = packCovariance(Cov0, Cov1);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3fWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[518, 518, 547, 547, 939], [941, 941, 977, 977, 1088], [1204, 1204, 1269, 1269, 1703], [1706, 1706, 1761, 1761, 2100], [2103, 2103, 2142, 2168, 2510], [2770, 2770, 2793, 2793, 2827], [2829, 2829, 2851, 2851, 2941], [2943, 2943, 2978, 2978, 3184], [3187, 3187, 3233, 3233, 3364], [3411, 3411, 3449, 3449, 3788], [3791, 3791, 3841, 3841, 4683], [4686, 4686, 4740, 4740, 5133], [5736, 5736, 5754, 5754, 5791], [5793, 5793, 5851, 5851, 6257], [6259, 6259, 6285, 6285, 6412], [6414, 6414, 6453, 6453, 6517], [6519, 6519, 6563, 6563, 6675], [6677, 6677, 6716, 6716, 6820], [6823, 6823, 6901, 6901, 8226], [8229, 8229, 8280, 8280, 9889]], "test": "untested"}
{"id": "md3BDs", "name": "White furnace test example", "author": "Zavie", "description": "If the image is empty, it's working.\n\nWritten to illustrate the article:\nhttps://lousodrome.net/blog/light/2023/10/21/the-white-furnace-test/\n", "tags": ["pathtracing", "whitefurnacetest"], "likes": 32, "viewed": 24109, "published": 3, "date": "1697863295", "time_retrieved": "2024-07-30T17:26:44.335890", "image_code": "/*\n\nThis shader demonstrates the white furnace test.\n\nWritten to illustrate the article:\nhttps://lousodrome.net/blog/light/2023/10/21/the-white-furnace-test/\n\nIt's not just an expensive way to render an empty screen,\nbut a rendering test showing that the Monte Carlo\nintegration is done correctly.\n\nWhen the scene appears empty, it is in fact rendering a\nsingle white sphere in a uniformly lit environment.\nAdditional smaller spheres are rendered to darken or\nlighten the edges of the white sphere and thus make it\n\"appear\". Similarly, it becomes visible when using a non\nuniform environment.\n\nThe material used is a Lambert BRDF, which is perfectly\nenergy conserving, to illustrate well the effect of the\nwhite furnace.\n\nLicense: CC BY 4.0\n\n--\nZavie\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenCoord = fragCoord.xy / iResolution.xy;\n    float gamma = 2.2;\n    vec3 radiance = texture(iChannel0, screenCoord).rgb;\n    vec3 rgb = pow(clamp(radiance, 0., 1.), vec3(1.0 / gamma));\n\tfragColor = vec4(rgb, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\nThis shader demonstrates the white furnace test.\n\nWritten to illustrate the article:\nhttps://lousodrome.net/blog/light/2023/10/21/the-white-furnace-test/\n\nIt's not just an expensive way to render an empty screen,\nbut a rendering test showing that the Monte Carlo\nintegration is done correctly.\n\nWhen the scene appears empty, it is in fact rendering a\nsingle white sphere in a uniformly lit environment.\nAdditional smaller spheres are rendered to darken or\nlighten the edges of the white sphere and thus make it\n\"appear\". Similarly, it becomes visible when using a non\nuniform environment.\n\nThe material used is a Lambert BRDF, which is perfectly\nenergy conserving, to illustrate well the effect of the\nwhite furnace.\n\nLicense: CC BY 4.0\n\n--\nZavie\n\n*/\n\n// Set to 1 for an incorrect integration, and see how it\n// that error is revealed by the test.\n#define SIMULATE_INCORRECT_INTEGRATION 0\n\n#define SAMPLES_PER_FRAME 2\n#define MAX_DEPTH 10\n\n// Set to 1 to accumulate samples over multiple frames.\n#define ENABLE_ACCUMULATION 1\n#define MAX_ACCUMULATION_SAMPLES 40\n\n// Set to 1 to add two coloured spheres on the sides,\n// thus revealing the white sphere in the center.\n#define SHOW_COLORED_SPHERES 1\n\n// Set to 1 so the environement is not uniform,\n// thus revealing the white sphere in the center.\n#define SHOW_NON_UNIFORM_ENVIRONMENT 1\n\n// Set SAMPLING to either UNIFORM_SAMPLING or COSINE_SAMPLING.\n#define UNIFORM_SAMPLING 1\n#define COSINE_SAMPLING 2\n#define SAMPLING COSINE_SAMPLING\n\n#define PI acos(-1.)\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 e;\t\t// luminance\n    vec3 c;\t\t// diffuse color\n    float f0;\t// specular color (monochrome)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(0.), vec3(0.), 0.));\n\nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0 >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    Sphere snowBall = Sphere(1., vec3(0.0), Material(vec3(0.0), vec3(1.0), 0.04));\n\n    Hit hit = noHit;\n    compare(hit, intersectSphere(snowBall, r));\n\n#if SHOW_COLORED_SPHERES\n    float t = abs(fract(iTime * 0.1 - 0.5) * 2.0 - 1.0);\n    if (t > 0.5)\n    {\n        Sphere redSphere = Sphere(0.45, vec3(-1.4, 0.6, 0.0), Material(vec3(0.0), vec3(0.8, 0.1, 0.02), 0.04));\n        compare(hit, intersectSphere(redSphere, r));\n    }\n    if (t > 0.75)\n    {\n        Sphere whiteSphere = Sphere(0.45, vec3(-1.4, -0.6, 0.0), Material(vec3(0.0), vec3(1.0), 0.04));\n        compare(hit, intersectSphere(whiteSphere, r));\n    }\n    if (t > 0.8)\n    {\n        Sphere glowingSphere = Sphere(0.45, vec3(1.5, 0.0, 0.0), Material(vec3(0.25, 0.7, 1.0), vec3(0.8), 0.04));\n        compare(hit, intersectSphere(glowingSphere, r));\n    }\n#endif\n\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Lights\n\nvec3 environmentLight(vec3 d)\n{\n    vec3 uniformEnv = vec3(0.5);\n\n#if SHOW_NON_UNIFORM_ENVIRONMENT\n    float t = abs(fract(iTime * 0.05 - 0.75) * 2.0 - 1.0);\n\n    if (d.x * 0.5 + 0.5 < clamp(t * 2.0 - 1.0, 0.0, 1.0))\n    {\n        return texture(iChannel1, d).rgb;\n    }\n#endif\n\n    return uniformEnv;\n}\n\n// ---8<----------------------------------------------------------------------\n// Random number generator\n\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d16(uvec3 v)\n{\n    v = v * 12829u + 47989u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n\tv >>= 16u;\n\n    return v;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    return v;\n}\n\nuvec3 seed = uvec3(0);\nvoid initSeed(vec2 fragCoord)\n{\n    // FIXME: how to eliminate time glitches?\n    seed = uvec3(fragCoord, iTime * 1e5);\n    seed.zy ^= pcg2d(seed.xz);\n}\n\nfloat rand1()\n{\n    seed = seed.yzx;\n    seed.x = pcg(seed.x);\n    return float(seed.x) * (1.0 / float(0xffffffffu));\n}\n\nvec2 rand2()\n{\n    seed = seed.yzx;\n    seed.xy = pcg2d(seed.xy);\n    return vec2(seed.xy) * (1.0 / float(0xffffffffu));\n}\n\nvec3 rand3()\n{\n    seed = pcg3d(seed);\n    return vec3(seed) * (1.0 / float(0xffffffffu));\n}\n\n// ---8<----------------------------------------------------------------------\n// Sampling\n\nfloat VanDerCorput(int i)\n{\n\tuint b =  (uint(i) << 16u) | (uint(i) >> 16u);\n\tb = (b & 0x55555555u) << 1u | (b & 0xaaaaaaaau) >> 1u;\n\tb = (b & 0x33333333u) << 2u | (b & 0xccccccccu) >> 2u;\n\tb = (b & 0x0f0f0f0fu) << 4u | (b & 0xf0f0f0f0u) >> 4u;\n\tb = (b & 0x00ff00ffu) << 8u | (b & 0xff00ff00u) >> 8u;\n\treturn float(b) * 2.3283064365386963e-10; // / 0x100000000\n}\n\n//\n// [Wong 1997] Sampling with Hammersley and Halton Points\n//\nvec2 Hammersley(int i, int N)\n{\n\treturn vec2(float(i) / float(N), VanDerCorput(i));\n}\n\nmat3 basis(vec3 N)\n{\n    // Hugues-Möller algorithm:\n    vec3 a = abs(N);\n\n    vec3 T;\n    if (a.x <= a.y && a.x <= a.z)\n    {\n        T = vec3(0, -N.z, N.y);\n    }\n    else if (a.y <= a.x && a.y <= a.z)\n    {\n        T = vec3(-N.z, 0, N.x);\n    }\n    else\n    {\n        T = vec3(-N.y, N.x, 0);\n    }\n    T = normalize(T);\n    vec3 B = normalize(cross(N, T));\n\n    return mat3(T, B, N);\n}\n\nvec3 sphericalToCathesian(float phi, float sinTheta, float cosTheta)\n{\n\treturn vec3(\n\t\tsinTheta * cos(phi),\n\t\tsinTheta * sin(phi),\n\t\tcosTheta);\n}\n\nvec3 uniformSample(vec2 Xi)\n{\n    float phi = 2. * PI * Xi.x;\n    float cosTheta = Xi.y;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n\treturn sphericalToCathesian(phi, sinTheta, cosTheta);\n}\n\nvec3 cosineSample(vec2 Xi)\n{\n    float phi = 2. * PI * Xi.x;\n    float sqrSinTheta = Xi.y;\n    float sinTheta = sqrt(sqrSinTheta);\n    float cosTheta = sqrt(1. - sqrSinTheta);\n\treturn sphericalToCathesian(phi, sinTheta, cosTheta);\n}\n\n// ---8<----------------------------------------------------------------------\n\nvec3 BRDF_Lambert(Material m, vec3 N, vec3 L, vec3 E)\n{\n    return m.c / PI;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\n    for (int depth = 0; depth < MAX_DEPTH; ++depth)\n    {\n        Hit hit = intersectScene(r);\n\t\tif (hit == noHit)\n        {\n            acc += mask * environmentLight(r.d);\n            break;\n        }\n\n        vec3 N = hit.n;\n        vec3 E = -r.d;\n        mat3 TStoWS = basis(N);\n\n        vec2 Xi = rand2();\n\n        acc += mask * hit.m.e;\n\n#if SAMPLING == UNIFORM_SAMPLING\n        vec3 L = TStoWS * uniformSample(Xi);\n        float ndotl = clamp(dot(N, L), 0.0, 1.0);\n\n#if SIMULATE_INCORRECT_INTEGRATION\n        // Oh no, we forgot that an hemisphere is 2Pi!\n        // The result appears too dark.\n        mask *= BRDF_Lambert(hit.m, N, E, L) * ndotl * PI;\n#else\n        mask *= BRDF_Lambert(hit.m, N, E, L) * ndotl * 2. * PI;\n#endif\n#elif SAMPLING == COSINE_SAMPLING\n        vec3 L = TStoWS * cosineSample(Xi);\n\n#if SIMULATE_INCORRECT_INTEGRATION\n        // Oh no, we forgot to change the integrand based on the sampling distribution!\n        // The result appears too bright.\n        float ndotl = clamp(dot(N, L), 0.0, 1.0);\n        mask *= BRDF_Lambert(hit.m, N, E, L) * ndotl * 2. * PI;\n#else\n        float ndotl_divided_by_pdf = PI;\n        mask *= BRDF_Lambert(hit.m, N, E, L) * ndotl_divided_by_pdf;\n#endif\n#endif // SAMPLING\n\n        if (dot(mask, mask) < 1e-3)\n        {\n            break;\n        }\n\n        r = Ray(hit.t * r.d + r.o + 1e-3 * L, L);\n\t}\n\treturn acc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenCoord = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (screenCoord * 2.0 - 1.0) * vec2(1., iResolution.y / iResolution.x);\n    vec2 duv = uv / iResolution.xy;\n    initSeed(fragCoord);\n\n    vec3 camPos = vec3(0.0, 0.0, -10.0);\n    vec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES_PER_FRAME + min(0, iFrame); ++i)\n    {\n        vec3 rd = normalize(vec3(uv + duv * Hammersley(i, SAMPLES_PER_FRAME), 5.0));\n\t\tcolor += radiance(Ray(camPos, rd));\n    }\n    \n#if ENABLE_ACCUMULATION\n    vec4 accum = texture(iChannel0, screenCoord);\n    float prev_samples = min(accum.a, float(MAX_ACCUMULATION_SAMPLES - SAMPLES_PER_FRAME));\n    float samples = prev_samples + float(SAMPLES_PER_FRAME);\n\tfragColor = vec4((accum.rgb * prev_samples + color) / samples, samples);\n#else\n    color /= float(SAMPLES_PER_FRAME);\n\tfragColor = vec4(color, 1.);\n#endif\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3BDs.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[756, 756, 813, 813, 1042]], "test": "untested"}
{"id": "mdKfRR", "name": "Flat Sigmoid (flatstep)", "author": "domrally", "description": "A flat sigmoid extracted from domrally's flat & smooth periodic functions. The endpoints are straight lines.\ns = .5 - .5 * erf atanh cos tπ\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["flat", "math", "smoothstep", "cosine", "interpolation", "smooth", "sigmoid", "errorfunction", "pade", "squoval", "hyperbolictangent"], "likes": 1, "viewed": 199, "published": 3, "date": "1697849215", "time_retrieved": "2024-07-30T17:26:45.237480", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\ndomrally's flatstep function.\nKinda like a smoothest-step or ∞ degree hermite interpolation.\n*/\nfloat flatstep(float a, float b, float x) {\n    float t = clamp((x - a) / (b - a), 9e-8, 1. - 9e-8),\n          h = atanh(cos(3.14 * t)),\n          H = h * h;\n\n    // error function method by Sergei Winitzki using Padé approximations\n    return .5 - .5 * sign(h) * sqrt(1. - exp(-H * (.1 * H + 1.27) / (.1 * H + 1.)));\n}\n\n\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 R = iResolution.xy;\n    float f = flatstep(.5, R.x - .5, i.x + .5);\n    \n    o = vec4(flatstep(7. / R.y, 0., abs(.2 + .6 * f - i.y / R.y)));\n}\n\n\n/*\nFURTHER READING\n\nhttps://en.wikipedia.org/wiki/Mollifier\nhttps://en.wikipedia.org/wiki/Smoothstep\nhttps://en.wikipedia.org/wiki/Flat_function\nhttps://en.wikipedia.org/wiki/Bump_function\nhttps://en.wikipedia.org/wiki/Sigmoid_function\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Non-analytic_smooth_function\nhttps://en.wikipedia.org/wiki/Smoothness#Smooth_partitions_of_unity\nhttps://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 128, 171, 171, 448], [451, 451, 487, 487, 639]], "test": "untested"}
{"id": "mdKfzR", "name": "Year of Truchets #057", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n", "tags": ["raymarching", "truchet", "pattern"], "likes": 53, "viewed": 545, "published": 3, "date": "1697847851", "time_retrieved": "2024-07-30T17:26:46.005426", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #057\n    10/20/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.323); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv),f = fract(uv);\n    float a = hash21(i),b = hash21(i+vec2(1,0)),c = hash21(i+vec2(0,1)),d = hash21(i+vec2(1,1));\n    vec2 u = f*f*(3.-2.*f);\n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n}\n\nfloat box(vec3 p, vec3 s) {p=abs(p)-s;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}\n\nvec3 hit=vec3(0),hitPoint,gid,sid,speed=vec3(0);\nfloat wtime;\n\nconst float size = 1.3;\nconst float hlf = size/2.;\nconst float dbl = size*2.;\n          \nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    vec3 ps = p, q;\n    \n    p += speed;\n\n    float id,nz=0.;\n    for(int i = 0; i<2; i++) {\n\n        float cnt = i<1 ? size : dbl;\n        q = vec3(p.x-cnt,p.yz);\n        id = floor(q.x/dbl) + .5;\n        q.x -= (id)*dbl;\n        float qf = (id)*dbl + cnt;\n\n        vec2 nvec = i==1 ? vec2((qf*2.35)+wtime,q.z*.145): vec2(q.z*.185,(qf*5.175)+wtime);\n        nz = noise(nvec);\n        \n        float dz = nz*1.25;\n        float tz = dz+dz*sin(q.z*.55);\n        tz += dz+dz*cos(q.x*.35);\n        q.y += tz;\n\n        float d = box(q,vec3(.52,.52,50))-.05;\n\n        if(d<res.x){\n            res = vec2(d,1.);\n            hitPoint = q;\n            gid = vec3(qf,nz,float(i));\n        }\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd){\n\tfloat d = 0.,m = 0.;\n    for(int i=0;i<90;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<30?ray.x*.4:ray.x*.8;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 hue(float t){ \n    t+=50.;\n    return .65+.45*cos(13.+PI2*t*(vec3(.25,.11,.99)*vec3(.95,.97,.98))); \n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m = ray.y;\n    d = ray.x;\n\n    if(d<MAX_DIST)\n    {\n        sid = gid;\n        hit = hitPoint;\n        \n        vec3 p = ro + rd * d,\n             n = normal(p,d);\n             \n        vec3 lpos =vec3(-10.,5,-12.),\n             l = normalize(lpos-p),\n             h = vec3(0), \n             h2 = vec3(0);\n        \n        float shdw = 1.,\n              diff = clamp(dot(n,l),0.,1.);\n              \n        for( float t=.1; t < 11.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 11.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>11. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float bnd = hash21(sid.xx);\n        float snd = fract(bnd*321.7) *3.-1.5;\n\n        vec3 aN = abs(n);\n        ivec3 idF = ivec3(n.x<-.25? 0 : 5, n.y<-.25? 1 : 4, n.z<-.25? 2 : 3);\n        int face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n        \n        vec2 hpp;\n        if( face == 0 ){  \n            hpp = hit.zy; \n            hpp.x+=T*snd;\n        } else {\n            hpp = hit.xz; \n            hpp.y+=T*snd;\n        }\n        vec2 dv = fract(hpp*2.)-.5,\n             id = floor(hpp*2.);\n\n        float ch = mod(id.x+id.y,2.)*2.-1.;\n        float px = 12./R.x;\n\n        float rnd = hash21(id+sid.xx);\n        \n        if(rnd<.45) dv.x = -dv.x;\n\n        vec2 gx = length(dv-.5)<length(dv+.5) ? vec2(dv-.5) : vec2(dv+.5);\n        float cx = length(gx)-.5;\n        \n        if(rnd>.65 && bnd<.75) cx = min(length(dv.x)-.005,length(dv.y)-.005);\n  \n        if (bnd<.25) cx = abs(cx)-.25;\n        if (bnd>.75) {\n            cx = (ch>.5 ^^ rnd<.45) ? smoothstep(px,-px,cx):smoothstep(-px,px,cx);\n        } else {\n            cx = smoothstep(px,-px, bnd>.7 ? abs(cx)-.2 : abs(cx)-.1 );\n        }\n    \n        h2 = vec3(.5);\n        h  = hue((T*.1)+(floor(sid.z+sid.y)-(hit.z*.085)-(p.x*.1)));\n        \n        h = mix(h,h2,cx);\n        ref = mix(vec3(0),vec3(.5),cx);\n \n        C = diff * h;\n        \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    } \n    \n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    wtime=T*.4;\n    speed = vec3(T*.45,0,0);\n    \n    float zoom = 11.;\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(uv*zoom,-(zoom+7.));\n    vec3 rd = vec3(0.,0.,1.);\n\n    //camera\n    mat2 rx = rot(-.6), ry = rot(.6);\n    \n    ro.yz *= rx, ro.xz *= ry;\n    rd.yz *= rx, rd.xz *= ry;\n\n    // reflection loop (@BigWings)\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(1);\n    vec4 FC = vec4(0);\n    \n    float d =0., a = 0., bnc = 2.;\n    for(float i=0.; i<bnc; i++) {\n        vec3 pass = render(ro, rd, ref, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n         if(i==0.) FC = vec4(vec3(.025),exp(-.000005*d*d*d*d));\n    }\n    \n    C = mix(C,FC.rgb,1.-FC.w);\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdKfzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[433, 433, 454, 454, 509], [510, 510, 528, 528, 573], [575, 575, 601, 601, 828], [830, 830, 857, 857, 924], [1078, 1078, 1099, 1099, 1834], [1836, 1836, 1866, 1866, 2105], [2107, 2107, 2138, 2138, 2353], [2355, 2355, 2373, 2373, 2462], [4683, 4683, 4724, 4724, 5461]], "test": "untested"}
{"id": "dsKfRR", "name": "Random Blue", "author": "soimn", "description": "Somewhat interesting result of a bad attempt at random number generation", "tags": ["rng"], "likes": 2, "viewed": 153, "published": 3, "date": "1697842442", "time_retrieved": "2024-07-30T17:26:46.841192", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord*(vec2(1200.0/iResolution.x, 675.0/iResolution.y));\n\n    int v = 23659;\n    v *= int(coord.x)/14;\n    v += (iFrame*2)/3;\n    v *= int(coord.y)/13;\n    v *= int(2.0*sin(coord.y));\n\n    // LCG constants from https://en.wikipedia.org/wiki/Linear_congruential_generator\n    float vf = intBitsToFloat(0x3F000000 | ((1664525*v + 1013904223) >> 9));\n\n    float w = abs(mix(sin(4.0*iTime + coord.x/32.0), sin(6.0*iTime + coord.x/64.0), 0.4));\n\n    fragColor = vec4(0.2 + 0.1*sin(2.0*fragCoord.x), 0.4, 1.0, 1.0)*vec4(vf);\n    fragColor += (vec4(vf > 0.7 ? 1.0 : 0.0) + 0.1*vec4(vf > 0.68 ? 1.0 : 0.0))*0.5*w;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 686]], "test": "untested"}
{"id": "Dts3z4", "name": "Projective Box", "author": "mla", "description": "A plain box, rotating in projective 3-space, so splitting up into two parts when it is bisected by the plane at infinity.\n\nMouse rotates, up/down to zoom. Also a,f,g,n,t.", "tags": ["box", "projective"], "likes": 11, "viewed": 252, "published": 3, "date": "1697800063", "time_retrieved": "2024-07-30T17:26:47.735800", "image_code": "// Projective Box, mla, 2023\n//\n// Draw a 3d box undergoing projective transformation, ie. a 4x4 matrix acting\n// on homogeneous coordinates. In particular, this means that the box can\n// be bisected by the plane at infinity and appear as two parts.\n//\n// A fairly dumb raytracing approach - compute analytic intersection with\n// the six box sides and find nearest. Cleverer ideas welcome.\n//\n// There is a check that the normals are correctly calculated from the\n// R4 coordinates - compute normals for two nearby points and assert if\n// they are signicantly different (this of course happens when they are\n// separated by an edge).\n//\n// a: centre view\n// f: fog\n// g: grid\n// n: check normals\n// t: texture\n\nfloat sgn(float x) {\n  if (x <= 0.0) return -1.0;\n  else return 1.0;\n}\n\n// Return distance to x plane, also uv and the plane itself\nfloat xplane(vec4 p, vec4 r, float w, out vec2 uv, out vec4 plane) {\n  plane = vec4(1,0,0,w);\n  float t = -dot(p,plane)/dot(r,plane);\n  vec4 q = p+t*r;\n  uv = vec2(-sgn(w),1)*q.yz/q.w;\n  return t;\n}\n\n// Same for y and z planes\nfloat yplane(vec4 p, vec4 r, float w, out vec2 uv, out vec4 plane) {\n  plane = vec4(0,1,0,w);\n  float t = -dot(p,plane)/dot(r,plane);\n  vec4 q = p+t*r;\n  uv = vec2(-sgn(w),1)*q.zx/q.w;\n  return t;\n}\n\nfloat zplane(vec4 p, vec4 r, float w, out vec2 uv, out vec4 plane) {\n  plane = vec4(0,0,1,w);\n  float t = -dot(p,plane)/dot(r,plane);\n  vec4 q = p+t*r;\n  uv = vec2(-sgn(w),1)*q.xy/q.w;\n  return t;\n}\n\nfloat iBox(vec4 p, vec4 r, out vec2 uv, out vec4 plane) {\n  float t = 1e8;\n  for (float w = -1.0; w <= 1.0; w += 2.0) {\n    float t1; vec2 uv1; vec4 plane1;\n    t1 = xplane(p,r,w,uv1,plane1);\n    if (t1 > 0.0 && t1 < t && max(abs(uv1.x),abs(uv1.y)) < 1.0) {\n      t = t1; uv = uv1; plane = plane1;\n    }\n    t1 = yplane(p,r,w,uv1,plane1);\n    if (t1 > 0.0 && t1 < t && max(abs(uv1.x),abs(uv1.y)) < 1.0) {\n      t = t1; uv = uv1; plane = plane1;\n    }\n    t1 = zplane(p,r,w,uv1,plane1);\n    if (t1 > 0.0 && t1 < t && max(abs(uv1.x),abs(uv1.y)) < 1.0) {\n      t = t1; uv = uv1; plane = plane1;\n    }\n  }\n  if (t == 1e8) return -1.0;\n  return t;\n}\n\nbool dorotate = true;\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.xz = rotate(p.xz,iTime*0.15);\n  }\n  return p;\n}\n\nfloat scene(vec4 p, vec4 r, out vec2 uv, out vec3 normal) {\n  vec3 axis = normalize(vec3(1));\n  float theta = iTime*0.1; \n  mat4 m = qmat(vec4(-sin(theta)*axis,cos(theta)));\n  //m = mat4(1);\n  //m = mat4(1,0,1,1, 1,1,0,0, 0,0,1,0, 0,0,0,1);  \n  p = m*p;\n  r = m*r;\n  vec4 plane;\n  float t = iBox(p,r,uv,plane);\n  normal = plane*mat3x4(m);\n  normal = normalize(normal);\n  return t;\n}\n\nfloat sphere(vec3 ro, vec3 rd, vec3 c, float r) {\n  ro -= c;\n  ro -= dot(ro,rd)*rd;\n  float d = length(ro);\n  return smoothstep(0.0,fwidth(d),d-r);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float AA = 1.0;\n  float camera = 4.0;\n  if (key(CHAR_A)) camera = 0.1;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 ro = vec3(0,0,camera);\n  ro = transform(ro);\n  vec3 light = vec3(0,0,2);\n  light = transform(light);\n  vec3 aacol = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,-2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      vec3 normal;\n      vec3 bgcol = vec3(0);\n      vec3 col = bgcol;\n      float t = scene(vec4(ro,1),vec4(rd,0),uv,normal);\n      if (t > 0.0) {\n        col = vec3(0.5);\n        if (!key(CHAR_T)) col = texture(iChannel0,0.5*(uv)+0.5).rgb;\n        if (!key(CHAR_G)) {\n          float lwidth = 0.01;\n          vec2 tuv = abs(uv);\n          tuv = fract(tuv);\n          tuv = min(tuv,1.0-tuv);\n          float ldist = min(tuv.x,tuv.y)-lwidth;\n          tuv = 4.0*uv;\n          tuv -= round(tuv);\n          tuv = abs(tuv);\n          tuv /= 4.0;\n          ldist = min(ldist,min(tuv.x,tuv.y)-0.5*lwidth);\n          col *= smoothstep(0.0,fwidth(ldist),ldist);\n        }\n        if (dot(rd,normal) > 0.0) normal = -normal;\n        float ambient = 0.2;\n        vec3 lightdir = normalize(light); // Light at infinity\n        float diffuse = max(0.0,dot(normal,lightdir));\n        //col = vec3(0.5);\n        col *= ambient+0.8*diffuse;\n        float fog = 2.0*atan(0.25*t)/PI;\n        if (!key(CHAR_F)) col = mix(col,bgcol,fog);\n      }\n      if (key(CHAR_N)) {\n        // Sanity check for normals\n        vec3 rd0 = normalize(transform(vec3(0,0,-2)));\n        vec3 normal0, normal1;\n        float t0 = scene(vec4(ro,1),vec4(rd0,0),uv,normal0);\n        if (t0 > 0.0) {\n          vec3 rd1 = normalize(transform(vec3(0,0.1,-2)));\n          float t1 = scene(vec4(ro,1),vec4(rd1,0),uv,normal1);\n          assert(length(normal0-normal1) < 1e-4);\n          vec3 p0 = ro+t0*rd0;\n          vec3 p1 = ro+t1*rd1;\n          col *= sphere(ro,rd,p0,0.01);\n          col *= sphere(ro,rd,p1,0.01);\n          assert(abs(dot(normal0,p1-p0)) < 1e-4);\n        }\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545)); // gamma correction\n  if (alert) aacol.r = 1.0;\n  fragColor = vec4(aacol,1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nint assert(bool b) {\n  if (!b) alert = true;\n  return 0;\n}\n\n// Rotation matrices, nb: column major.\n// Matrix from quaternion\nmat3 qrot(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  return 2.0*mat3(0.5-y*y-z*z, x*y+z*w,     x*z-y*w,\n                  x*y-z*w,     0.5-x*x-z*z, y*z+x*w,\n                  x*z+y*w,     y*z-x*w,     0.5-x*x-y*y);\n}\n\n// Quaternion multiplication as a matrix.\n// This is a \"Clifford translation\" in R4\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  return mat4( w, z,-y,-x, \n               -z, w, x,-y,\n               y,-x, w,-z,\n               x, y, z, w);\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\nconst int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\nconst int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\nfloat PI = 3.14159265;", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    float w1 = keystate(i,2).x;\n    if (keystate(KEY_ALT,0).x == 0.0 && w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dts3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[711, 711, 731, 731, 781], [783, 843, 911, 911, 1041], [1043, 1070, 1138, 1138, 1268], [1270, 1270, 1338, 1338, 1468], [1470, 1470, 1527, 1527, 2114], [2138, 2138, 2165, 2165, 2454], [2456, 2456, 2515, 2515, 2838], [2840, 2840, 2889, 2889, 2989], [2991, 2991, 3043, 3043, 5358]], "test": "untested"}
{"id": "mstfDs", "name": "Buffered 2D Noise", "author": "virmoesiae", "description": "Experimenting with buffering fractional brownian motion noise in 2D. If extended to 3D, this can result in massive performance gains when e.g., adding noise to SDFs (sampling a pre-computed noise vs recalculating it at every step is a huge deal)", "tags": ["noise", "fbm", "warping", "buffers", "bufferednoise"], "likes": 3, "viewed": 218, "published": 3, "date": "1697799479", "time_retrieved": "2024-07-30T17:26:48.614450", "image_code": "/*  \n    Would you like a free, off-line, stand-alone shader \n    editor of the likes of ShaderToy in less than 9 MB?\n    If so, come get your free copy of ShaderThing at:\n    >>> https://github.com/virmodoetiae/shaderthing <<<\n*/\n\n// More info on what this is about in BufferA header description\n\n// Buffered fbm\nfloat bfbm(vec2 x)\n{\n    return texture(iChannel0, x).r;\n}\n\n// Inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    // Because of the tiled nature of bfbm, I need to be\n    // carful when it comes to sizing the sampling coordinate\n    // x, if I want to avoid evident non-randomness in the\n    // result due to tiling\n    x*=.25;\n    vec2 a = vec2(bfbm(2.*x+iTime/7.), 2.3*bfbm(.2*x+iTime/8.));\n    float b = bfbm(x+.25*a-.1*iTime);\n    vec2 c = vec2(bfbm(.5*x+2.*b), bfbm(x+.25*a));\n    return pow(bfbm(x+.75*c), 1./1.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/100.));\n    fragColor = vec4(vec3(pattern(3.*uv-d)), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float random(vec2 x)\n{\n    return fract(138912.*sin(dot(x, vec2(138.9, 191.2))));\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Should be faster, (albeit more biased?), \n// than the standard Perlin noise. Easily extandable to 3D\nfloat triNoise(vec2 x)\n{\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = random(l+s*e.yx);\n    float b = random(l+s*e.yx+e.xy);\n    float c = random(l+s*e.xy+(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    r *= r*(3.-2.*r); // Same cubic profile as smoothstep\n    return mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise\nfloat fbm(vec2 x)\n{\n    float n = 0.;\n    float A = 0.;\n    vec2 af = vec2(1., 2.);\n    for (int i=0; i<10; i++)\n    {\n        // Rotate each octave\n        float s = sin(float(2*i));\n        float c = cos(float(2*i));\n        mat2 m = mat2(c, s, -s, c);\n        n += af.x*triNoise(af.y*m*x);\n        A += af.x;\n        af *= vec2(.45,2.);\n    }\n    return n/A;\n}", "buffer_a_code": "// Here, the fbm noise is compute once and once only, and then\n// used by all other applications (e.g., but not done here, an SDF).\n// This can result in massive performance gains, but the main issue\n// is that this pre-computed noise will only be 'random' within a\n// tileable region of the buffer. This introduces some annoying\n// limitations to its usage, but if sampled carefully, it can be\n// a game-changer for very noise-heavy shaders\n\n// Keep in mind that this is buffered 2D noise. For 3D, you would \n// either need to use a Cubemap buffer, or devise a \n// continuous/seamless 3D-to-2D mapping\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make the noise tileable\n    // If only ShaderToy allowed a mirror & repeat wrap option for\n    // the channel, I wouldn't have to do this, which unfortunately\n    // also reduces the actual size of the 'random' part of the\n    // texture by a factor of 4\n    if (uv.x>.5)\n        uv.x = 1.-uv.x;\n    if (uv.y>.5)\n        uv.y = 1.-uv.y;\n    \n    // Totally not necessary, just a smoothing of uv in [0.,.5]\n    // which by extensions ends up also smoothing the fbm\n    uv*=uv*(3.-4.*uv); \n    \n    // Calc fbm and store\n    float n = fbm(uv+.1); // The .1 is also totally not necessary\n    fragColor = vec4(n,1.,1.,1.);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 314, 334, 334, 372], [374, 427, 450, 656, 863], [865, 865, 922, 922, 1074]], "test": "untested"}
{"id": "mdVyzz", "name": "_RayMarching Primitives2", "author": "hyrofumi", "description": "RayMarching Primitives", "tags": ["raymarching"], "likes": 4, "viewed": 196, "published": 3, "date": "1697790770", "time_retrieved": "2024-07-30T17:26:49.610787", "image_code": "// Constants\n#define PI 3.1415925359\n#define MAX_STEPS 100// Mar Raymarching steps\n#define MAX_DIST 100.// Max Raymarching distance\n#define SURF_DIST .01// Surface Distance\n\n// GetDist\nfloat GetDist(vec3 p) {\n    float d=0.;\n    \n    vec3 bPos = p + vec3(0, sin(iTime * 0.25), 0);\n    bPos.xy *= Rotate(iTime * 0.25);\n    bPos.xz *= Rotate(iTime * 0.5);\n    \n    \n    d = roundBoxSDF(bPos, vec3(.5, .5, .5), .1);\n    // d = boxSDF(bPos, vec3(0.1));\n    \n    // Plane\n    float planeDist = p.y;\n    d = smoothUnionSDF(d, planeDist, smoothstep(1.,0.,p.y));\n    \n    return d;\n}\n\n// RayMarch\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n    float dO=0.;//Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd*dO;\n        float ds = GetDist(p);// ds is Distance Scene\n        dO += ds;\n        if(dO>MAX_DIST||ds<SURF_DIST)\n        break;\n    }\n    return dO;\n}\n\n// GetNormal\nvec3 GetNormal(vec3 p) { \n  float d = GetDist(p); // Distance\n  vec2 e = vec2(.01,0); // Epsilon\n \n  vec3 n = d - vec3(\n    GetDist( p - e.xyy),  // e.xyy is the same as vec3(.01,0,0).\n    GetDist( p - e.yxy),\n    GetDist( p - e.yyx));\n \n  return normalize(n);\n}\n \n // GetLight\nfloat GetLight(vec3 p) { \n  // Directional light\n  vec3 lightPos = vec3(5.*sin(iTime),5.,5.0*cos(iTime)); // Light Position\n  vec3 l = normalize(lightPos - p); // Light Vector\n  vec3 n = GetNormal(p); // Normal Vector\n   \n  float dif = dot(n, l); // Diffuse light\n  dif = clamp(dif, 0., 1.); // Clamp so it doesnt go below 0\n \n  // Shadows\n  float d = RayMarch(p+n*SURF_DIST*2., l); \n \n  if(d<length(lightPos-p)) dif *= .1;\n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\n\n    vec3 ro = vec3(0, 1, -3.5);// Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv2 ,1));// Ray Direction\n    \n    float d = RayMarch(ro,rd);// Distance\n    \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // Diffuse lighting\n\n    vec3 color = vec3(dif);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Round Box - exact\nfloat roundBoxSDF( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Box - exact \nfloat boxSDF( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 Rotate(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n/////////////////////////////\n// Smooth blending operators\n/////////////////////////////\n \nfloat smoothIntersectSDF(float distA, float distB, float k ) {\n  float h = clamp(0.5 - 0.5*(distA-distB)/k, 0., 1.);\n  return mix(distA, distB, h ) + k*h*(1.-h); \n}\n \nfloat smoothUnionSDF(float distA, float distB, float k ) {\n  float h = clamp(0.5 + 0.5*(distA-distB)/k, 0., 1.);\n  return mix(distA, distB, h) - k*h*(1.-h); \n}\n \nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n  float h = clamp(0.5 - 0.5*(distA+distB)/k, 0., 1.);\n  return mix(distA, -distB, h ) + k*h*(1.-h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 185, 208, 208, 575], [577, 589, 622, 622, 871], [873, 886, 910, 910, 1148], [1152, 1164, 1188, 1212, 1603], [1605, 1605, 1662, 1712, 2120]], "test": "untested"}
{"id": "csdBWs", "name": "Dewdrops", "author": "wyatt", "description": "Shallow 3D continuous fluid simulation with caustic and reflections", "tags": ["fluid"], "likes": 18, "viewed": 449, "published": 3, "date": "1697788180", "time_retrieved": "2024-07-30T17:26:50.558253", "image_code": "Main {\n\n    Q = texture(iChannel3,U/R);\n    lights;\n    vec2 u = U/N;\n    \n    \n    for (float i = 0.; i < N*N; i++) {\n        vec2 v = u;\n        vec3 p = vec3(u,i);\n        v -= .5*R3.xy;\n        v *= 1.+0.05*i/N/N;\n        v += .5*R3.xy;\n        if (R3.y-v.y<1.||R3.x-v.x<1.||v.y<1.||v.x<1.) continue;\n        v = v+R3.xy*vec2(mod(i,N),floor(i/N));\n        \n        vec4 q = texture(iChannel1,v/R);\n        vec4 tx = light(p,q.xyz);\n        Q += 5.*q.w*pow(tx,vec4(1))/N/N;\n    \n    }\n    Q += .2;\n    //Q = texture(iChannel0,U/R).wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define N (4.)\n#define R3 vec3(R/N,N*N)\n#define _3D(U) vec3(mod((U)-.5,R3.xy),floor(((U).x-.5)*N/R.x)+N*floor(((U).y-.5)*N/R.y))\n#define _2D(V) (.5+floor((V).xy+R/N*vec2(mod((V).z,N),floor((V).z/N))))\n#define A(V) texelFetch(iChannel0,ivec2(_2D(V)),0)\n#define B(V) texelFetch(iChannel1,ivec2(_2D(V)),0)\n\n#define vel(v) .5*(v)*inversesqrt(1.+dot(v,v))\n\n#define inside(v) ((v).x>=0.&&(v).y>=0.&&(v).z>=0.&&(v).x<R3.x&&(v).y<R3.y&&(v).z<R3.z)\n\nfloat ln (vec3 p, vec3 a, vec3 b) { \n    return length(p-a-(b-a)*(dot(p-a,b-a)/dot(b-a,b-a)));\n}\n\nvec3 L1; vec3 L2;\n#define lights L1 = R3*vec3(.3,.5,3); L2 = R3*vec3(.7,.5,3);\nvec4 light ( vec3 p, vec3 d) {\n    vec4 o = vec4(0);\n    {\n        float l = ln(p+d,p,L1);\n        o += vec4(3,2,1,1)*exp(-32.*l*l);\n    }{\n        float l = ln(p+d,p,L2);\n        o += vec4(1,2,3,1)*exp(-32.*l*l);\n    }\n    return o;\n}\n\nvec3 hash44(vec4 p)\n{\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\tuvec4 q = uvec4(ivec4(p)) * UI4;\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*UI4;\n\treturn vec3(q) * UIF;\n}", "buffer_a_code": "Main {\n\n    vec3 V = _3D(U);\n    Q = A(V);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    if (x!=0||y!=0||z!=0) {\n    //if (abs(x)!=abs(y)&&abs(y)!=abs(z)) {\n    \n        vec3 v = vec3(x,y,z);\n        vec4 q = A(V+v);\n        if (inside(V+v))\n        Q.xyz += .005*q.w*(1.-q.w)*v/dot(v,v)/length(v);\n    }\n    Q.y -= .0003*(1.-length(V.xy-.5*R3.xy)/R3.y);\n    Q.z -= .0002;\n    //Q.xyz *= .9999;\n    if (V.z < 2.) Q.xyz *= .9975;\n    if (iFrame < 1) {\n        \n        Q.w = .02+.005*(sin(.2*(V.x-V.y))+sin(.2*(V.y+V.x)));\n    \n    }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\n    vec3 V = _3D(U);\n    Q = A(V);\n    vec4 dQ = vec4(0);\n    #define K (1./26.)\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++) \n    if (x!=0||y!=0||z!=0) {\n    \n        vec3 v = vec3(x,y,z);\n        vec3 W = V+v;\n        W.y = mod(W.y,R3.y);\n        vec4 q = A(W);\n        \n        vec3 a = vel(Q.xyz),\n             b = vel(q.xyz)+v;\n        float ab = dot(v,b-a);\n        if (inside(W)&&abs(ab)>0.) {\n            float i = dot(v,(0.5*v-a))/ab;\n            float j = .525;\n            float k = .525;\n            float wa = K*Q.w*min(i,j)/j;\n            float wb = K*q.w*max(k+i-1.,0.)/k;\n            dQ += vec4(Q.xyz,1)*wa+vec4(q.xyz,1)*wb;\n        } else {\n            dQ += K*Q.w*vec4(Q.xyz,1);\n        }\n        \n    }\n\n    if (dQ.w>0.) dQ.xyz /= dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    \n    vec3 V = _3D(U);\n    \n    vec4 dx = A(V+vec3(1,0,0)) -  A(V-vec3(1,0,0)) ;\n    vec4 dy = A(V+vec3(0,1,0)) -  A(V-vec3(0,1,0)) ;\n    vec4 dz = A(V+vec3(0,0,1)) -  A(V-vec3(0,0,1)) ;\n    \n    float w = (dx.w+dy.w+dz.w);\n    Q = vec4(dx.w,dy.w,dz.w,w*w);\n    if (length(Q.xyz) == 0.) Q = vec4(0) ; else\n    Q.xyz = normalize(Q.xyz);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    \n    Q = texture(iChannel3,U/R)*.95;\n    lights;\n    for (int i = 0; i < 15;  i++) {\n        vec3 h = hash44(vec4(U,i,iFrame));\n        h.x *= 6.24;\n        h.y *= 3.1;\n        vec3 d = vec3(sin(h.x)*cos(h.y),sin(h.x)*sin(h.y),cos(h.x));\n        d.z = abs(d.z);\n        vec3 p = vec3(U/N,0);\n        for (float j = 0.; j < 10.; j++) {\n            if (p.x < 0.||p.y< 0.||p.z<0.||R3.x-p.x<0.||R3.y-p.y<0.||R3.z-p.z<0.)break;\n            vec4 q = A(floor(p));\n            p += 1.*d;\n            d -= .5*q.w*q.xyz;\n            d = normalize(d);\n        }\n        Q += .02*light(p,d);\n    }\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mscfDl", "name": "Complementary Flow Adjusted", "author": "fishy", "description": "Added different tonemapping, dithering, more contrast-y coloring", "tags": ["blur", "buffer", "trails", "substep"], "likes": 10, "viewed": 347, "published": 3, "date": "1697758602", "time_retrieved": "2024-07-30T17:26:51.419950", "image_code": "#define desat(x) vec3(dot(x, vec3(0.2126, 0.7152, 0.0722)))\n#define DITHER(i) texture(iChannel1, uv * iResolution.xy / iChannelResolution[1].xy)[i]\n\nvec3 tonemap(vec3 c)\n{\n    vec3 g = desat(c);\n    c = mix(g / (g + 1.0), c / (c + 1.0), exp2(-g*0.2));\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel0, uv).rgb;\n    c = tonemap(pow(c, vec3(3)));\n    fragColor = vec4(pow(c+(DITHER(iFrame % 4)-0.5)/128.0, vec3(1)/2.2), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SUBSTEPS 8.0\n\n#define COLOR_0 vec3(1.000,0.525,0.000)\n#define COLOR_1 (1.0-COLOR_0)\n\nvec2 curve(float t, float k)\n{\n    return vec2(sin(t) - cos(t + k), cos(3.0*t) + sin(4.0 * - k))*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 store = texture(iChannel0, fragCoord/iResolution.xy, 0.1).rgb;\n    \n    for(float i = 0.0; i < SUBSTEPS; i++)\n    {\n        float offset = i / SUBSTEPS * max(0.0, iTimeDelta);\n        float t = max(0.0001, iTime) * 0.5;\n        float k = max(0.0001, iTime) * 0.25;\n        float p0 = 0.3/distance(uv, curve(t + offset, k + offset));\n        float p1 = 0.3/distance(uv, curve(t + offset + 0.5, k + offset + 0.5));\n\n        vec3 col = COLOR_0 * p0 + COLOR_1 * p1;\n\n        store = mix(col, store, pow(0.5, max(0.0, iTimeDelta) / SUBSTEPS));\n    }\n    \n    fragColor = vec4(store, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscfDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 171, 171, 267], [269, 269, 326, 326, 520]], "test": "untested"}
{"id": "cdcBWs", "name": "Pop Shift", "author": "QuantumSuper", "description": "Auto-VJ with glowing symbols and pixelations. Reactive to sound.\n\n - Use with music in iChannel0 -", "tags": ["2d", "music", "glitch"], "likes": 14, "viewed": 335, "published": 3, "date": "1697741517", "time_retrieved": "2024-07-30T17:26:52.284638", "image_code": "// Pop Shift 0.31.231019 by QuantumSuper\n// auto-vj with glowing symbols in front of a pixelated background and with glitching uv coordinates \n// \n// - use with music in iChannel0 -\n\n#define isVdj false\n#define PI 3.14159265359 \n#define aTime 2.5*iTime\n#define getDat(addr) texelFetch( iChannel0, ivec2(addr,0), 0).x\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\tif (isVdj) for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvec3 getCol(float id){ //color definitions, for triplets\n    vec3 setCol = vec3(0);\n    id = mod(id,15.);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    else if (id<13.) setCol = vec3(173,  0, 27); //matrix red\n    else if (id<14.) setCol = vec3( 28,142, 77); //matrix green\n    else if (id<15.) setCol = vec3( 66,120, 91); //matrix green 2\n    return setCol/256.;\n}\n\nfloat sdCircle( vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b;\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    uv *= .6 + .5*getDat(dot(floor((uv+1.)/.1),vec2(1,10))+24.); //pixel shift\n    float widthF = (isVdj)? 9. : 1.;\n\n    vec3 r3 = vec3(getDat(0),getDat(1),getDat(2));\n    vec3 col = (.3+.5*pow(fft.x,9.)) * (r3*r3*r3*r3*r3*vec3(3,1,5)*.005+.01) * widthF / abs(vec3( //draw glowing symbols\n        sdCircle( uv, .27*r3.x),\n        sdEquilateralTriangle( uv/(.1/r3.y+.001)) * .1/r3.y,\n        sdBox( uv, vec2(.35*r3.z))) );\n    \n    uv /= (.3+.7*pow(fft.w,.5)); //background zoom\n    col = (col*4.+.6) * vec3(.5*fft.z+.2) * getDat((floor(abs(uv.y)*22.)+floor(abs(uv.x)*22.)/22.)/22.*512.); //pixel background\n        \n    float colId = 3. * floor(mod(aTime/16.,5.)); //color set id \n    col = mat3( getCol( colId+0.), getCol( colId+1.), getCol( colId+2.)) * col; //remap colors\n    col *= abs( cos( .06*iTime + PI/vec3(.5,2.,4.) + ffts.xyz*PI)); //color shift \n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 34949, "src": "https://soundcloud.com/xxltechno/xxl-invites-070-meltx", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[369, 369, 388, 479, 1610], [1612, 1612, 1634, 1668, 2701], [2703, 2703, 2736, 2736, 2762], [2764, 2764, 2793, 2852, 2932], [2934, 2934, 2970, 3029, 3233], [3236, 3236, 3291, 3291, 4353]], "test": "untested"}
{"id": "mdcfDj", "name": "[ConcoursJFIG2023] Toriversaire", "author": "PlathC", "description": "My submission for the JFIG 2023 Shadertoy contest.", "tags": ["torus", "pathtracer", "svgf", "concoursjfig2023", "jfig23"], "likes": 5, "viewed": 283, "published": 3, "date": "1697739836", "time_retrieved": "2024-07-30T17:26:55.550905", "image_code": "// Based on Single-pass gaussian blur - fast \n// By FabriceNeyret2 \n// Reference: https://www.shadertoy.com/view/ltScRG\nconst int   Samples  = 8; // Actual sample count is Samples / (2^(LODLevel))\nconst int   LODLevel = 1;\nconst float Sigma    = float(Samples) * .25;\n\nfloat gaussian(vec2 i) \n{\n    i /= Sigma;\n    return exp(-.5 * dot(i, i) ) / (Tau * Sigma * Sigma);\n}\n\nvec4 bloom(sampler2D channel, vec2 uv) \n{\n    vec4 color    = vec4(0.);\n    int  sampleNb = Samples / (1 << LODLevel);\n    vec2 stepSize = 1. / iChannelResolution[1].xy;\n    float sLOD    = float(1 << LODLevel);\n    for(int i = 0; i < sampleNb; i++)\n    {\n        for(int j = 0; j < sampleNb; j++)\n        {\n            vec2 delta       = vec2(i, j) * sLOD - float(Samples) * .5;\n            vec2 coordinates = uv + stepSize * delta;\n            \n            vec4 sampleData  = textureLod(channel, coordinates , float(LODLevel) );\n            vec3 sampleColor = sampleData.rgb * float(sampleData.w < 0.);\n            \n            color += gaussian(delta) * vec4(sampleColor, 1.);\n        }\n    }\n    \n    return color / color.a;\n}\n\n// ACES tonemapping from romainguy's shader\n// Reference: https://www.shadertoy.com/view/llXyWr\nvec3 ACESFilm( vec3 x )\n{\n\tfloat a = 2.51f;\n\tfloat b = 0.03f;\n\tfloat c = 2.43f;\n\tfloat d = 0.59f;\n\tfloat e = 0.14f;\n\treturn clamp( ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e ), vec3( 0.f ), vec3( 1.f ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec4 color = vec4(0.);\n    \n    vec2 uv = fragCoord + .5;\n    uv = uv - iResolution.xy * .5;\n    uv = uv / iResolution.y;\n\n    // Chromatic aberration on sides of the image while preserving candles\n    vec3 offset = max(0., length(uv - vec2(.25, 0.1)) - .2) * (vec3(8.5, 5.9, .8) / 1280. * iResolution.x);\n    color.r = texture(iChannel0, (fragCoord + offset.x) / iResolution.xy).r;\n    color.g = texture(iChannel0, (fragCoord + offset.y) / iResolution.xy).g;\n    color.b = texture(iChannel0, (fragCoord + offset.z) / iResolution.xy).b;\n    \n    // Apply bloom only if pixel is non emissive\n    vec4 bloom = bloom(iChannel0, fragCoord / iResolution.xy);\n    color     += bloom * 1.1;\n    color.rgb *= 1.5;\n    \n    // Tonemapping & Gamma Correction\n    fragColor = vec4(pow(ACESFilm(color.rgb), vec3(1. / 2.2)), 1.f);\n    \n    uv = (fragCoord / iResolution.xy - .5) * 2.;\n    bool startAnimation = abs(uv.y) > min(iTime * .6, .8) || abs(uv.x) > min(iTime * .75, 1.);\n    bool endAnimation   = (1. - abs(uv.x)) <= clamp(iTime * .25 - 39. / 4., 0., 1.)\n                       || (1. - abs(uv.y)) <= clamp(iTime * .25 - 39. / 4., 0., 1.);\n    if(startAnimation || endAnimation) \n    {\n        fragColor = vec4(vec3(0.), 1.f);\n        return;\n    }\n    \n    // Vignette\n    fragColor *= 1. - .2 * dot(uv, uv); \n    \n    // Overlay\n    vec4 overlay  = texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb, overlay.rgb, overlay.w);\n    fragColor.w = 1.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Pi  = 3.1415;\nconst float Tau = 2. * Pi;\n\n// Override iTime to make the shader loop\nfloat getTime(float time) {\n    return mod(time, 43.); \n}\n#define iTime getTime(iTime)\n#define rgb(c1, c2, c3) vec3(c1, c2, c3) / 255.\n\nfloat length2(vec3 v) {return dot(v,v);}\n\nvec4 quat(float angle, vec3 axis) \n{\n\tfloat halfAngle = angle / 2.;\n\treturn vec4(\n\t\taxis.x * sin(halfAngle),\n\t\taxis.y * sin(halfAngle),\n\t\taxis.z * sin(halfAngle),\n\t\tcos(halfAngle)\n\t);\n}\n\n// Based on GLM implementation\nvec3 mul(vec4 quat, vec3 point)\n{\n\tvec3 quatVector = vec3(quat.x, quat.y, quat.z);\n\tvec3 uv = cross(quatVector, point);\n\tvec3 uuv = cross(quatVector, uv);\n\n\treturn point + ((uv * quat.w) + uuv) * 2.;\n}\n\nvec4 conjugate(vec4 quat) { return vec4(-quat.x, -quat.y, -quat.z, quat.w); }\n\nvoid rotate(inout vec2 v, float angle) \n{\n    mat2 matrix = mat2(\n        cos(angle),  sin(angle),\n        -sin(angle), cos(angle)\n    );\n    \n    v = v * matrix;\n}\n\n// Both n and ref must be normalized\nvec4 toLocal(vec3 n, vec3 ref)\n{\n    if (dot(n, ref) < -1.f + 1e-4f)\n        return vec4(1.f, 0.f, 0.f, 0.f);\n\n    float angle = 1.f + dot(n, ref); // sqrt(length2(n) * length2(ref)) + dot( input, up );\n    vec3  axis  = cross(n, ref);\n    return normalize(vec4(axis, angle));\n}\n\nvec4 toLocalZ(vec3 n) { return toLocal(n, vec3(0., 0., 1.)); }\n\n// Ref: https://en.wikipedia.org/wiki/Relative_luminance\nfloat getLuminance(vec3 rgb)\n{\n    return rgb.x * 0.2126f + rgb.y * 0.7152f + rgb.z * 0.0722f;\n}\n\nfloat getDiskArea(float radius) \n{\n    return Pi * radius * radius;\n}\n\nvec3 polarToCartesian(vec2 angles) \n{\n    return vec3(\n        sin(angles.x) * cos(angles.y),\n        sin(angles.x) * sin(angles.y),\n        sin(angles.x)\n    );\n}\n\n// Mod polar from HG_SDF: A glsl library for building signed distance functions\n// By Korndörfer Johann, Keinert Benjamin, Ganse Urs, Sänger Michael, Ley Simon, \n// Burkhardt Konstanze, Spuler Mario and Heusipp Jörn\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*Pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n    \n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n//-- Geometric primitives\n\n// Primitives from Inigo Quilez's library\n// Reference: https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n    return normalize( pos*(dot(pos,pos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// GLSL Torus Knot from Syntopia and DarkBeam\n// Reference: https://www.fractalforums.com/new-theories-and-research/not-fractal-but-funny-trefoil-knot-routine/15/\nfloat deTorusKnot(vec3 p, vec3 r, vec2 c, float polyfoldOrder) \n{\n\tfloat mobius = (c.x + c.y/polyfoldOrder) * atan(p.y,p.x);\n\tp.x = length( p.xy ) - r.x;\n\trotate(p.xz, mobius);\t\n\t\n    float m     = polyfoldOrder / Tau;\n\tfloat angle = floor(.5 + m * (Pi/2. - atan(p.x,p.z))) / m;\n    \n\trotate(p.xz, angle);\n\tp.x = p.x - r.z;\n\t\n    return (length(p.xz)-r.y) * .8; // Slightly overestimated when radius is small\n}\n\n//-- Random\n// Reference: https://www.shadertoy.com/view/XlGcRh\n// Hash Functions for GPU Rendering. Mark Jarzynski, & Marc Olano (2020).\n// Journal of Computer Graphics Techniques (JCGT), 9(3), 20–38.\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    return v;\n}\n\nvec4 prng(inout uvec4 p)\n{\n    p.w++;\n    return vec4(pcg4d(p)) * (1.0/float(0xffffffffu));\n}\n\n//-- Hashes\n// From: Quality hashes collection WebGL2 by nimitz \n// Reference: https://www.shadertoy.com/view/Xt3cDn\n// Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash11(uint x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 getBlueNoise(vec2 fragCoord, int frame, sampler2D sampler) \n{\n    // Reference: https://www.shadertoy.com/view/tlySzR\n    ivec2 p = ivec2(fragCoord);\n    p = (p+frame*ivec2(113,127)) & 1023;\n    return texelFetch(sampler, p, 0);\n}\n\n//-- Sampling utils\n// Sampling Transformations Zoo\n// Peter Shirley, Samuli Laine, David Hart, Matt Pharr, Petrik Clarberg,\n// Eric Haines, Matthias Raab, and David Cline\n// NVIDIA\nvec3 sampleCosine(vec2 u)\n{\n    // 16.6.1 COSINE-WEIGHTED HEMISPHERE ORIENTED TO THE Z-AXIS\n    float a = sqrt(u.x);\n    float b = 2. * Pi * u.y;\n\n    return vec3(a * cos(b), a * sin(b), sqrt(1.0f - u.x));\n}\nvec3 sampleCone(float cosThetaMax, vec2 u, inout float pdf)\n{\n    // 16.6.3 DIRECTIONS IN A CONE\n    float cosTheta = (1. - u.x) + u.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u.y * 2. * Pi;\n    \n    pdf = 1. / (Tau * (1. - cosThetaMax));\n    return vec3( \n        cos(phi) * sinTheta,\n        sin(phi) * sinTheta,\n        cosTheta\n    );\n}\n\n// Stratified Sampling of 2-Manifolds, Jim Arvo\n// SIGGRAPH Course Notes 2001\n// Found: https://twitter.com/keenanisalive/status/1529490555893428226?s=20&t=mxRju6YioMmlMOJ1fDVBpw\nvec2 sampleCircle(vec2 u)\n{\n    float  r     = u.x;\n    float  theta = u.y * 2. * Pi;\n    return sqrt(r) * vec2(cos(theta), sin(theta));\n}\nvec3 sampleDisk(float height, float radius, vec2 u) \n{\n    vec2 pd = sampleCircle(u);\n    return vec3(pd.x * radius, height, pd.y * radius);\n}\n\n//-- Ray\nstruct Material\n{\n    vec3 baseColor;\n    vec3 emission;\n};\n\nMaterial defaultMaterial() \n{\n    Material material;\n    material.baseColor = vec3(1., 0., 1.);\n    material.baseColor = vec3(0.);\n    \n    return material;\n}\n\nMaterial getMaterial(uint hashOffset)\n{\n    float hash = hash11(hashOffset);\n\n    Material material  = defaultMaterial();\n    material.baseColor = hash31(hashOffset);\n    material.emission  = float(mod(hash * 6., 6.) > 5.) * hash31(hashOffset + 2u);\n    \n    return material;\n}\n\nstruct HitInfo\n{\n    float    t;\n    vec3     normal;\n};\n\nHitInfo defaultHitInfo() \n{\n    return HitInfo(-1., vec3(0.));\n}\n\nstruct LightSample \n{\n    vec3  position;\n    vec3  wi;\n    vec3  intensity;\n    float pdf;\n};\n\n// A Fast and Robust Method for Avoiding Self-Intersection, Carsten Wächter and Nikolaus Binder, NVIDIA\n// Reference: https://github.com/Apress/ray-tracing-gems/blob/master/Ch_06_A_Fast_and_Robust_Method_for_Avoiding_Self-Intersection/offset_ray.cu\nvec3 offsetRay(vec3 p, vec3 n)\n{\n    const float origin      = 1.0f / 32.0f;\n    const float float_scale = 1.0f / 65536.0f;\n    const float int_scale   = 256.0f;\n\n    ivec3 of_i = ivec3(int_scale * n.x, int_scale * n.y, int_scale * n.z);\n\n    vec3 p_i = vec3(intBitsToFloat(floatBitsToInt(p.x) + ((p.x < 0.) ? -of_i.x : of_i.x)),\n                    intBitsToFloat(floatBitsToInt(p.y) + ((p.y < 0.) ? -of_i.y : of_i.y)),\n                    intBitsToFloat(floatBitsToInt(p.z) + ((p.z < 0.) ? -of_i.z : of_i.z)));\n\n    return vec3(abs(p.x) < origin ? p.x + float_scale * n.x : p_i.x,\n                abs(p.y) < origin ? p.y + float_scale * n.y : p_i.y,\n                abs(p.z) < origin ? p.z + float_scale * n.z : p_i.z);\n}\n\n//-- Materials\n// For all functions, ro and rd are transformed s.t. n = (0., 0., 1.)\nvec3 evalLambertian(const Material material)\n{\n    return material.baseColor / Pi;\n}\n\nvec3 sampleLambertian(const vec3 wo, const vec2 u)\n{\n    vec3 wi = sampleCosine(u);\n    if (wo.z < 0.)\n        wi.z *= -1.;\n    return wi;\n}\n\nfloat getPdfLambertian(const vec3 wo, const vec3 wi) { return wo.z * wi.z > 0. ? abs(wi.z) / Pi : 0.; }\n\n//-- RGB to XYZ to LAB by mattatz\n// Reference: https://gist.github.com/mattatz/44f081cac87e2f7c8980\nvec3 rgb2xyz( vec3 c ) {\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    const mat3 mat = mat3(\n\t\t0.4124, 0.3576, 0.1805,\n        0.2126, 0.7152, 0.0722,\n        0.0193, 0.1192, 0.9505 \n\t);\n    return 100.0 * (tmp * mat);\n}\n\nvec3 xyz2lab( vec3 c ) {\n    vec3 n = c / vec3(95.047, 100, 108.883);\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgb2lab( vec3 c ) {\n    vec3 lab = xyz2lab( rgb2xyz( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 lab2xyz( vec3 c ) {\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 xyz2rgb( vec3 c ) {\n\tconst mat3 mat = mat3(\n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n\t);\n    vec3 v = (c / 100.0 * mat);\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 lab2rgb( vec3 c ) {\n    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\n// RGB to HSV by anastadunbar\n// Reference: https://www.shadertoy.com/view/XljGzV\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Random color in HSV color space to keep a uniform palette\nvec3 rndColor(uint s) \n{\n    vec3 rnd = hash31(s);\n    return hsv2rgb(vec3(.5 + mod(rnd.x, .5), .8, .7 ));\n}\n\n//-- Text rendering utils based on FabriceNeyret2's shader\n// Reference: https://www.shadertoy.com/view/llySRh\n#define letter(id) (64 + id)\n#define number(id) (48 + id)\n#define space(uv)  uv.x -= .5;\n\nstruct DrawChar {\n    int  id;\n    vec2 position;\n    vec2 dx;\n    vec2 dy;\n};\n\nDrawChar defaultDrawChar() { return DrawChar(-1, vec2(-1.), vec2(-1.), vec2(-1.)); }\n\nvoid writeChar( int id, inout vec2 uv, inout DrawChar char ) \n{\n    uv.x -= .5;\n\n    vec2 dFdx = dFdx( uv / 16. ), dFdy = dFdy( uv / 16. );\n    if ( uv.x > .25 && uv.x < .75 && uv.y > .1 && uv.y < .85 )\n        char = DrawChar( id, uv, dFdx, dFdy );\n}\n\nvec4 drawChar( DrawChar char, sampler2D charTexture ) \n{\n    if( char.id < 0 )\n        return vec4(0,0,0,1e5);\n        \n    vec2 uv = char.position / 16. + fract( vec2(char.id, 15 - char.id / 16) / 16. );\n    return textureGrad( charTexture, uv, char.dx, char.dy );\n}\n\n//-- Textures utils\nvec2 toroidalMapping(vec3 p, vec2 r, float k) \n{\n    // Toroidal mapping\n    // Reference: https://www.shadertoy.com/view/sdd3R4\n    float a = atan(p.z, p.x + 1e-15);\n    float b = atan(p.y, (length(p.xz) - r.x) + 1e-15);\n    return vec2(mod(k * r.x * a / Pi, r.x), mod(1. + k * r.y * b / Tau, r.y));\n}\n\nfloat draw(float d, float w) { return smoothstep(.15, -.15, (length(w - d) - 2.5e-2)); }\nfloat truchetLabyrinth(vec2 uv) \n{\n    float Width = 11.;\n    \n    const float Radius    = .5;\n    const float LineWidth = 1e-2;\n    \n    vec2 id = uv * Width;\n    uv      = mod(uv, vec2(1. / Width)) * Width ;\n    \n    // Random tile orientation\n    float angle = Pi*.5 * floor(hash13(uvec3(id.x, id.y, 1)) * 3.);\n    uv -= .5;\n    rotate(uv, angle);\n    uv += .5;\n    \n    // [0, 1] -> [-1, 1]\n    uv *= 2.;\n    uv -= 1.;\n    \n    // Draw middle line\n    float l = abs(dot(uv, vec2(1.))) ;\n    return draw(abs(l * .5) - 1e-1, LineWidth);\n}\n\nfloat truchetArcs(vec2 uv) \n{       \n    float Width           = 9.;\n    const float Radius    = .5;\n    const float LineWidth = 1e-1;\n\n    // Tiling\n    vec2 id = uv * Width;\n    uv      = mod(uv, vec2(1. / Width)) * Width ;\n\n    // Random tile orientation\n    float angle = Pi*.5 * floor(hash13(uvec3(id.x, id.y, 2)) * 3.);\n    uv -= .5;\n    uv  = mat2(\n        cos(angle), -sin(angle), \n        sin(angle), cos(angle)\n    ) * uv;\n    uv += .5;\n    \n    // Draw circle parts\n    float l = length(uv - vec2(1.)) - Radius;\n    l = min(l, length(uv - vec2(0.)) - Radius);\n    \n    return draw(abs(l * 2.5), LineWidth);\n}\n\nvec3 jfig(vec2 uv, sampler2D charTexture) \n{\n    const vec3 MainColor      = vec3( 0.67, 0.81, 0.34 );\n    const vec3 SecondaryColor = vec3( .5 );\n    const vec3 Background     = vec3( 0. );\n    \n    // [0, 1] -> [-1, 1] & Scale\n    uv = uv * 2. - 1.;\n    uv *= 1.8;\n    \n    // Logo\n    float d  = length(uv) - 1.;    \n    float d2 = length(uv - vec2(.7, -.5)) - .25;\n    float d3 = length(uv - vec2(1.1, -.75)) - .125;\n    \n    vec3 color = Background;\n    if(-.3 < d && d < 0. && abs(-uv.x + uv.y) > 0.1 && abs(-uv.x - uv.y) > 0.1)\n        color = mix(MainColor, SecondaryColor, float(-uv.x + uv.y > 0.));\n    \n    if(d2 < 0.05)\n        color = mix(MainColor, Background, float(d2 > 0.));\n    else if(d3 < 0.)\n        color = MainColor;\n\n    // Text part: \"AFIG 30 ANS\"\n    DrawChar char  = defaultDrawChar();\n    vec2 textStart = uv * .81 - vec2(-1.05, 0.2);\n    vec2 charUv    = textStart * 0.78 - vec2(1.01, -.32);\n    \n#define writeLetter( id ) writeChar( letter( id ), charUv, char ) \n#define writeNumber( id ) writeChar( number( id ), charUv, char ) \n    writeLetter( 1 ); writeLetter( 6 ); writeLetter( 9 ); writeLetter( 7 );\n    \n    charUv = ( textStart * 1.07 - vec2(1.65, -1.2) );\n    writeNumber(3); writeNumber(0); charUv.x -= .2; writeLetter( 1 ); writeLetter( 14 ); writeLetter( 19 );\n#undef writeLetter\n#undef writeNumber\n    \n    color += float(drawChar(char, charTexture).x > 0.5) * MainColor;\n    return color;\n}\n\n//-- Reprojection utils\nvec2 getUV(vec3 position, vec2 resolution, vec3 mouse, int frame, float time, sampler2D noiseTexture)\n{\n    vec4 rotation = normalize(quat( time * .2, vec3(0., 1., 0.)));\n    vec3 ro = vec3( 5.75, 0., sin(time) * .2);\n    ro      = mul(rotation, ro);\n    \n    vec3 rd  = normalize(position - ro);\n    \n    if( mouse.z > 0. )\n    {\n        float moveSize = -mouse.x / resolution.x;\n        rotation = normalize(quat(Pi - moveSize * Tau, vec3(0., 1., 0.)));\n        rd       = mul(conjugate(rotation), rd);\n    }\n    \n    rotation = normalize(quat(1.15 * Pi + time * .2, vec3(0., 1., 0.)));\n    rd       = mul(conjugate(rotation), rd);\n    \n    const float focalLength = tan(Pi * .25);\n    \n    // Reference: https://www.shadertoy.com/view/wtcXz4\n    vec2 uv2 = rd.xy * focalLength / rd.z;\n    \n    // 4. [ -.5, .5 ] -> [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5] \n    uv2 = uv2 * resolution.y;\n    \n    // 3. [vec2(.5), iResolution.xy + .5] -> [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5]\n    uv2 = uv2 + resolution.xy * .5;\n    \n    // 2. Apply jittering [vec2(0), iResolution.xy]  \n    vec2 jitter = getBlueNoise(uv2, frame, noiseTexture).xy;\n    uv2         = uv2 - (jitter * .5 - .5);\n    \n    // 1. Center of pixels [vec2(0), iResolution.xy] -> [vec2(0.5), iResolution.xy + .5] \n    uv2 = uv2 - .5;\n        \n    return uv2;\n}\n\nvoid getCamera(vec2 fragCoord, vec2 resolution, vec3 mouse, int frame, float time, sampler2D noiseTexture, out vec3 ro, out vec3 rd) \n{    \n    // 1. Center of pixels [vec2(0), iResolution.xy] -> [vec2(0.5), iResolution.xy + .5] \n    vec2 uv = fragCoord + .5;\n    \n    // 2. Apply jittering [vec2(0), iResolution.xy]  \n    vec2 jitter = getBlueNoise(fragCoord, frame, noiseTexture).xy;\n    uv = fragCoord + (jitter * .5 - .5);\n\n    // 3. [vec2(.5), iResolution.xy + .5] -> [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5]\n    uv = uv - resolution.xy * .5;\n    \n    // 4. [vec2(-iResolution.xy * .5 + .5), iResolution.xy * .5 + .5] -> [ -.5, .5 ]\n    uv = uv / resolution.y;\n    \n    const float focalLength = tan(Pi * .25);\n    \n    rd = normalize(vec3(uv, focalLength));\n    ro = vec3( 5.75, 0., sin(time) * .2);\n    \n    vec4 rotation = normalize(quat(time * .2, vec3(0., 1., 0.)));\n    ro = mul(rotation, ro);\n    \n    rotation = normalize(quat(1.15 * Pi + time * .2, vec3(0., 1., 0.)));\n    rd = mul(rotation, rd);\n    \n    if( mouse.z > 0. )\n    {\n        float moveSize = -mouse.x / resolution.x;\n        rotation = normalize(quat(Pi - moveSize * Tau, vec3(0., 1., 0.)));\n        rd       = mul(rotation, rd);\n    }\n}\n", "buffer_a_code": "// -- Pathtracing pass\n\nconst float SampleNb = 1.;\nconst int   BounceNb = 2;\n\nconst float ReprojectionRadius       = 2.;\nconst float ReprojectionWeightMoving = .1;\nconst float ReprojectionMaxDistance  = 25.;\n\n// The scene evaluation is split into two parts: Candles and Neons. \n// These evaluations are themselves defined by three functions: light sampling, \n// distance estimation, and material evaluation.\n\n// Neons part\nLightSample sampleLightNeon(vec3 p, vec4 u) \n{\n    vec3  position, wi, strength;\n    float pdf;\n    if( u.x > 0.5 ) \n    {\n        // Fake candle's fire light with spherical light above them\n        const float repetitions = 30.;\n        const float start       = -6. * Pi;\n        float stepSize          = 2.*Pi/repetitions;\n\n        // pModPolar id and sample neighborhing lights\n        float angle = atan(p.z, p.x + 1e-15) + stepSize * .5 + stepSize * .5 * (2. * u.y - 1.);\n        float r     = length(p);\n        float id    = floor(angle/stepSize);\n        if (abs(id) >= (repetitions/2.)) id = abs(id);\n\n        strength = 100. * rndColor(floatBitsToUint(id) + 10u);\n\n        position      = vec3(cos(angle) * 4.5, .65, sin(angle) * 4.5);\n        vec3 n        = normalize(position - p);\n        vec4 rotation = toLocalZ(n);\n\n        const float Radius = .1;\n        float sinThetaMax2 = Radius * Radius / max(1e-4, length2(p - position));\n        float cosThetaMax  = sqrt(max(0., 1. - sinThetaMax2));\n\n        wi = mul(conjugate(rotation), sampleCone(cosThetaMax,  u.zw, pdf));\n    }\n    else \n    {\n        const float Radius = 1.;\n        \n        vec4 rotation = normalize(quat( Pi/3. + iTime * .2, vec3(0., 1., 0.)));\n        position      = vec3( 6., 0., 0.);\n        position      = mul(rotation, position);\n        vec3 n        = normalize(position - p);\n        rotation      = toLocalZ(n);\n        strength      = 5. * normalize(p - position);\n\n        // Spherical light sampling from PBRT\n        // By: Matt Pharr, Wenzel Jakob, Greg Humphreys\n        // Reference: https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#fragment-Computecoordinatesystemforspheresampling-0\n        float sinThetaMax2 = Radius * Radius / max(1e-4, length2(p - position));\n        float cosThetaMax  = sqrt(max(0., 1. - sinThetaMax2));\n\n        wi = mul(conjugate(rotation), sampleCone(cosThetaMax,  u.zw, pdf));\n    }\n                        \n    return LightSample(position, wi, strength, pdf);\n}\n\nfloat sdSceneNeon(vec3 position) \n{\n    vec3  r = vec3(5., (abs(sin(iTime)) * 1. + 2.) * 0.02, 2.);\n    vec2  c = vec2(3. + 1. * abs(sin(iTime  * .5)), 5.);\n    float t = 45.;\n    float d = deTorusKnot(position.xzy, r, c, t);\n    \n    // Toroidal mapping\n    // Reference: https://www.shadertoy.com/view/sdd3R4\n    float R0 = 5., R1 = 2., k = 5.;\n    float a  = atan(position.z, position.x + 1e-15);\n    float dr = length(position.xz)-R0;\n    float b  = atan(position.y, dr + 1e-15);\n\n    float u = mod( k * R0 * a / Tau, Pi * .5);\n    float v = k * R1 * b/6.283;\n    vec2 uv = vec2( 1. - (.1 + u), .25 +v);\n    if(abs(position.y) < .45 && dr > 1.) \n        d = abs(sdTorus(position, vec2(5., 2.)));\n        \n    // Candles repetition\n    const float repetitions = 30.;\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    rotate(position.xz, iTime);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.03;\n    \n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n        \n    return min(d, d1);\n}\n\nMaterial sceneMaterialNeon(vec3 position) \n{\n    Material material = defaultMaterial();\n\n    vec3 pp = position;\n    \n    vec3  r = vec3(5., (abs(sin(iTime)) * 2. + 2.) * 0.02, 2.);\n    vec2  c = vec2(2. + 2. * abs(sin(iTime  * .5)), 5.);\n    float t = 45.;\n    float d = deTorusKnot(pp.xzy, r, c, t);\n    \n    material.baseColor = vec3(.7, .5, .5);\n    material.emission  = vec3(.0);\n    \n    // Toroidal mapping\n    // Reference: https://www.shadertoy.com/view/sdd3R4\n    float R0 = 5., R1 = 2., k = 5.;\n    float a  = atan(pp.z, pp.x + 1e-15);\n    float dr = length(pp.xz) - R0;\n    float b  = atan(pp.y, dr + 1e-15);\n\n    float u = mod( k * R0 * a / Tau, Pi );\n    float v = k * R1 * b / Tau;\n    vec2 uv = vec2( 2. - (.1 + u), .25 +v);\n    if(abs(pp.y) < .45 && dr > 1.) \n    {\n        d = abs(sdTorus(pp, vec2(5., 2.)));\n        \n        vec3 color         = jfig(uv + .25, iChannel3);\n        material.baseColor = color;\n        material.emission  = .5 * color;\n    }\n    \n    // Candles repetition\n    const float repetitions = 30.;\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    rotate(position.xz, iTime);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.03 + .3 * (hash11(floatBitsToUint(17. + id)) * 2. - 1.);\n    \n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n    if(d1 < d)\n    {\n        d = d1;\n        \n        material.baseColor = rndColor(floatBitsToUint(id) + 10u);\n        material.emission  = float(position.y > 0.1) * rndColor(floatBitsToUint(id) + 10u);\n    }\n        \n    return material;\n}\n\nLightSample sampleLightCandles(vec3 p, vec4 u) \n{\n    vec3  position, wi, strength;\n    float pdf;\n\n    // Fake candle's fire light with spherical light above them\n    const float repetitions = 30.;\n    const float start       = -6. * Pi;\n    float stepSize          = 2.*Pi/repetitions;\n\n    // pModPolar id and sample neighborhing lights\n    float angle    = atan(p.z, p.x + 1e-15) + stepSize/2. + stepSize * (u.y * 2. - 1.);\n    float r        = length(p);\n    float id       = floor(angle/stepSize);\n    if (abs(id) >= (repetitions/2.)) id = abs(id);\n\n    strength = 300. * rndColor(floatBitsToUint(id) + 10u);\n\n    position      = vec3(cos(angle) * 4., .5 + .5 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.) + .2 * sin(iTime + 2. * hash11(floatBitsToUint(id))), sin(angle) * 4.25);\n    vec3 n        = normalize(position - p);\n    vec4 rotation = toLocalZ(n);\n\n    // Spherical light sampling from PBRT\n    // By: Matt Pharr, Wenzel Jakob, Greg Humphreys\n    // Reference: https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#fragment-Computecoordinatesystemforspheresampling-0\n    const float Radius = .05;\n    float sinThetaMax2 = Radius * Radius / max(1e-4, length2(p - position));\n    float cosThetaMax  = sqrt(max(0., 1. - sinThetaMax2));\n\n    wi = mul(conjugate(rotation), sampleCone(cosThetaMax,  u.zw, pdf));\n                        \n    return LightSample(position, wi, strength, pdf);\n}\n\n// Truchet Candles\nfloat sdSceneCandles(vec3 position)\n{\n    // Environment\n    vec2 torusDimensions = vec2(5., 2.);\n    float d = abs(sdTorus(position, torusDimensions));\n    \n    // Logo rolling sphere from torus parametrization\n    float sphereRadius = .5;\n    float phi          = -.75 * (iTime - 10.);\n    float theta        = 2. * (iTime - 10.);\n    vec3 spherePosition = vec3(\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n        (torusDimensions.y - sphereRadius) * sin(theta),\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n    );\n\n    d = min(d, length(position - spherePosition) - sphereRadius);\n\n    for(float i = 0.; i < 3.; i++) \n    {\n        sphereRadius = .2;\n        phi          = -.75 * (iTime - 10. - i * .3);\n        theta        = 2. * (iTime - 10. - i * .3);\n        spherePosition = vec3(\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n            (torusDimensions.y - sphereRadius) * sin(theta),\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n        );\n\n        d = min(d, length(position - spherePosition) - sphereRadius);\n    }\n\n    // Candles repetition\n    const float repetitions = 30.;\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    rotate(position.xz, iTime);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.005;\n    \n    // Holder\n    float holderRadius = radius * hash11(floatBitsToUint(id));\n    float holderHeight = .06 * hash11(floatBitsToUint(id));\n    float holder = sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    );\n        \n    holderRadius = radius + .1;\n    holderHeight = .01;\n    d = min(d, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    ));\n    d = min(d, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight * 6., \n        holderRadius * .5\n    ));\n    \n    // Candle\n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n    \n    // Twisted effect from a box\n    vec4 qq = quat( 15. * position.y, vec3(0., 1., 0.));\n    vec3 q  = mul(qq, position);\n    \n    radius *= 5. + 4. * (hash11(floatBitsToUint(15. + id)) * 2. - 1.);\n    float d2 = sdBox(q, vec3(radius, height - .07, radius));\n    d2 -= .02; // Smoothen corners\n    \n    float candle = opSmoothUnion(d1, d2, .1);\n    d            = min(d, candle);\n    \n    // Flame\n    position.xz += .002 * sin(position.y * 2. + 10. * iTime + 10. * id);\n    float oscillatingSphere = length(position - vec3(0., height, 0.)) - 0.015 - sin(iTime) * 0.005;\n    float dFire             = opSmoothUnion(\n        sdCappedCylinder(position - vec3(0., height, 0.), .05, .005 ), \n        oscillatingSphere, \n        0.05\n    );\n    \n    return min(d, dFire);\n}\n\nMaterial sceneMaterialCandles(vec3 position) \n{\n    vec2 torusDimensions = vec2(5., 2.);\n    float d = abs(sdTorus(position, torusDimensions));\n    \n    Material material  = defaultMaterial();\n    material.baseColor = vec3(.7, .5, .5);\n    material.emission  = vec3(.0);\n    \n    vec2 uv = toroidalMapping(position, torusDimensions, 1.);\n    \n    // Angular repetition\n    const float repetitions = 30.;\n    float stepSize = 2. * Pi / repetitions;\n    float angle    = atan(position.z, position.x + 1e-15) + stepSize *.5;\n\n    // Rotating textures\n    const float start = -5.5 * Pi;\n    float generalTransition = sin((start + angle + iTime) * .2);\n    float textureTransition = (sin(start + angle + iTime) * 2. ) * 2. - 2.;\n\n    float s = smoothstep( -3.,  3., textureTransition );\n    uv = vec2(uv.x, s + uv.y) * 2.;\n    \n    // Procedural texturing\n    float t = mix(\n        truchetLabyrinth(uv),\n        truchetArcs(uv),\n        float(textureTransition < 0.)\n    );\n    \n    vec3 color1 = mix(\n        rgb(205,   3,  6),\n        rgb(155,   3, 175.),\n        float(textureTransition < 0.)\n    );\n\n    vec3 color2 = rgb(231, 167, 30);\n    if(generalTransition < 0.) \n    {\n        // Transition between textures\n        t = mix(t, 1., float(abs(textureTransition) < 0.05));\n\n        material.baseColor = mix(color1, color2, t);\n        material.emission  = abs(sin(iTime)) * .5 * mix(vec3(0.), color2, t);\n\n    }\n    else if(generalTransition < 0.001) // Transition between textures\n    {\n        material.baseColor = color2;\n        material.emission  = color2;\n    }\n    \n    // Logo rolling sphere from torus parametrization\n    float sphereRadius  = .5;\n    float phi           = -.75 * (iTime - 10.);\n    float theta         = 2. * (iTime - 10.);\n    vec3 spherePosition = vec3(\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n        (torusDimensions.y - sphereRadius) * sin(theta),\n        (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n    );\n\n    float dSphere = length(position - spherePosition) - sphereRadius;\n    if(dSphere < d)\n    {\n        d = dSphere;\n        \n        material.baseColor = vec3(.5);\n        material.emission  = vec3(.5);\n    }\n\n    for(float i = 0.; i < 3.; i++) \n    {\n        sphereRadius = .2;\n        phi          = -.75 * (iTime - 10. - i * .3);\n        theta        = 2. * (iTime - 10. - i * .3);\n        spherePosition = vec3(\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * cos(phi),\n            (torusDimensions.y - sphereRadius) * sin(theta),\n            (torusDimensions.x + (torusDimensions.y - sphereRadius) * cos(theta)) * sin(phi)\n        );\n\n        dSphere = min(dSphere, length(position - spherePosition) - sphereRadius);\n    }\n\n    if(dSphere < d)\n    {\n        d = dSphere;\n        \n        material.baseColor = vec3(0.67, 0.81, 0.34);\n        material.emission  = vec3(0.1, 0.8, 0.1);\n    }\n    \n    // Candles repetition\n    float id     = pModPolar(position.xz , repetitions);\n    position.y  -= .2 * sin(iTime * 2. + 2. * hash11(floatBitsToUint(id)));\n    position.xz -= vec2(4.5 , 0.);\n    \n    // A single candle\n    float height = .3  + .15 * (hash11(floatBitsToUint(16. + id)) * 2. - 1.);;\n    float radius = 0.005;\n    \n    // Holder\n    float holderRadius = radius * hash11(floatBitsToUint(id));\n    float holderHeight = .06 * hash11(floatBitsToUint(id));\n    float holder = sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    );\n    \n    holderRadius = radius + .1;\n    holderHeight = .01;\n    holder = min(holder, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight, \n        holderRadius\n    ));\n    holder = min(holder, sdCappedCylinder(\n        position + vec3(0., height * .5 + holderHeight, 0.), \n        holderHeight * 6., \n        holderRadius * .5\n    ));\n    if( holder < d )\n    {\n        d = holder;\n        material.baseColor = rndColor(floatBitsToUint(id) + 10u);\n        material.emission  = vec3(0.);\n    }\n    \n    // Candle\n    position.y -= .1;\n    float d1 = sdCappedCylinder(position, height, radius * 3. );\n    \n    // Twisted effect from a box\n    vec4 qq = quat( 15. * position.y, vec3(0., 1., 0.));\n    vec3 q  = mul(qq, position);\n    \n    radius *= 5. + 4. * (hash11(floatBitsToUint(15. + id)) * 2. - 1.);\n    float d2 = sdBox(q, vec3(radius, height - .07, radius));\n    d2 -= .02; // Smoothen corners\n    \n    float candle = opSmoothUnion(d1, d2, .1);\n    if(candle < d)\n    {\n        d = candle;\n        material.baseColor = vec3(1.);\n        material.emission  = vec3(0.);\n    }\n    \n    position.xz += .002 * sin(position.y * 2. + 10. * iTime + 10. * id);\n    float oscillatingSphere = length(position - vec3(0., height, 0.)) - 0.015;\n    float dFire             = opSmoothUnion(\n        sdCappedCylinder(position - vec3(0., height, 0.), .05, .005 ), \n        oscillatingSphere, \n        0.05\n    );\n    if(dFire < d)\n    {\n        d = dFire;\n        material.baseColor = rndColor(floatBitsToUint(id) + 10u);\n        material.emission  = .5 * rndColor(floatBitsToUint(id) + 10u);\n    }\n    \n    return material;\n}\n\n// Mixup geometry\nbool isNeon(vec3 position) \n{\n    const float repetitions = 30.;\n    float stepSize = 2. * Pi / repetitions;\n    float angle    = atan(position.z, position.x + 1e-15) + stepSize *.5;\n    \n    const float start = -7. * Pi;\n    return sin((start + angle + max(iTime, 15.)) * .3) > 0.;\n}\n\nbool isBound(vec3 position) {\n    const float repetitions = 30.;\n    float stepSize = 2. * Pi / repetitions;\n    float angle    = atan(position.z, position.x + 1e-15) + stepSize *.5;\n    \n    const float start = -7. * Pi;\n    return abs(sin((start + angle + max(iTime, 15.)) * .3)) < 1e-2;\n}\n\n// General scene functions\nLightSample sampleLight(vec3 position, vec4 u)\n{\n    if(isNeon(position))\n        return sampleLightNeon(position, u);\n\n    return sampleLightCandles(position, u);\n}\n\nfloat sdScene(vec3 position) \n{\n    if(isNeon(position))\n        return sdSceneNeon(position);\n    return sdSceneCandles(position);\n}\n\nMaterial sceneMaterial(vec3 position) \n{    \n    Material material;\n    if(isNeon(position))\n        material = sceneMaterialNeon(position);\n    else \n        material = sceneMaterialCandles(position);\n\n    if(isBound(position))\n        material.emission = vec3(0.6, 1., 1.);\n        \n    return material;\n}\n\n// Map normal estimation\n// by Inigo Quilez\n// Reference: https://iquilezles.org/articles/normalsSDF\nconst float stepSize = 0.00001;\nvec3 normal(vec3 pos)\n{\n    const vec2 e = vec2(1.0, -1.0) * 0.5773 * stepSize;\n    return normalize( e.xyy*sdScene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdScene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdScene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sdScene( pos + e.xxx ) );\n}\n\n// Sphere tracing\nHitInfo trace(vec3 ro, vec3 rd, float tMax) \n{\n    HitInfo hitInfo   = defaultHitInfo();\n    bool  hit         = false;\n    float t           = 0.;\n    vec3  p           = vec3(0.);\n    for(int i = 0; i < 150 && t < tMax; i++)\n    {\n        float d = sdScene(p = ro + rd * t);\n        t      += max(abs(d), stepSize);\n        \n        // Hit offset depending on depth. Less precision when far away\n        if(d < 2e-3 * t) \n        {\n            hitInfo.t = t;\n            break;\n        }\n    }\n    \n    if( hitInfo.t > 0. )\n        hitInfo.normal = normal(p);        \n    \n    return hitInfo;\n}\n\n// Pathtracing integrator\nvec3 render(vec2 fragCoord, int frame, inout HitInfo firstHit)\n{\n    vec4 alea = getBlueNoise(fragCoord, frame, iChannel2);\n\n    vec3 ro, rd;\n    getCamera(fragCoord, iResolution.xy, iMouse.xyz, frame, iTime, iChannel2, ro, rd);\n\n    vec3 throughput = vec3(1.);\n    vec3 finalColor = vec3(0.);\n    firstHit.t = -1.;\n    \n    float bound = 15.;\n    for(int b = 0; b < BounceNb; b++) \n    {\n        HitInfo hit = trace(ro, rd, bound);\n        if(hit.t < 0.) \n            break;\n        \n        if( b == 0 ) \n            firstHit = hit;\n        \n        vec3 position = ro + rd * hit.t;\n        vec3 n        = hit.normal;\n        n            *= sign(dot(n, -rd));\n\n        Material material = sceneMaterial(position);\n        finalColor += throughput * material.emission;\n        \n\n        vec3 pposition = offsetRay(position, hit.normal);\n        vec4 transform = toLocalZ(hit.normal);\n        hit.normal     = vec3(0., 0., 1.);\n        \n        vec3 woLocal   = normalize(mul(transform, -rd));\n        vec3 direct    = vec3( 0. );\n\n        // Direct lighting\n        {\n            LightSample lightSample = sampleLight(pposition, alea);\n            \n            vec3  wiLocal  = normalize(mul(transform, lightSample.wi));\n            float cosTheta = wiLocal.z;\n            if(lightSample.pdf > 0. && cosTheta > 0.) \n            {\n                if(trace(pposition + lightSample.wi * 1e-1, lightSample.wi, length(pposition - lightSample.position)).t < 0.) \n                {\n                    vec3 brdf = min(evalLambertian(material) * cosTheta, vec3(1.));\n                    direct   += brdf * lightSample.intensity / max(1e-4, lightSample.pdf);\n                }\n            }            \n        }\n        finalColor += throughput * direct;\n\n        vec3  weight        = evalLambertian( material );\n        vec3  wiLocal       = sampleLambertian( woLocal, alea.wx );\n        float scatteringPdf = getPdfLambertian( woLocal, wiLocal );\n                \n        float cosTheta = abs(woLocal.z);\n        throughput    *= clamp(weight * cosTheta / max(1e-4, scatteringPdf), vec3(0.), vec3(1.));\n\n        if(any(isinf(throughput)) || any(isnan(throughput)) )\n            return vec3(0., 0., 0.);\n    \n        float luminance = getLuminance(throughput);\n        if(luminance == 0. )\n            return vec3(0.);\n\n        rd   = normalize(mul(conjugate(transform), wiLocal));\n        ro   = offsetRay(position, n);\n        alea = getBlueNoise(fragCoord, frame, iChannel2);\n    }\n\n    return clamp(finalColor, vec3(0.), vec3(1.));\n}\n\nfloat sampleDistance(vec3 position, vec3 color, vec3 position2, vec3 color2) \n{\n    vec3 colorDistance = rgb2lab(color) - rgb2lab(color2);\n    return .001*length(position - position2) + .01*dot(colorDistance, colorDistance);\n}\n\n// #define DEBUG\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    \n#ifdef DEBUG\n    int frame = 0 * int(iFrame);\n\n    vec3 ro, rd;\n    getCamera(fragCoord, iResolution.xy, iMouse.xyz, frame, iTime, iChannel2, ro, rd);\n\n    HitInfo hit = trace(ro, rd, 100.);\n    \n    fragColor.rgb = hit.normal * .5 + .5;\n    fragColor.w   = 1.;\n    return;\n#else    \n    vec4 data = vec4(0.);\n    HitInfo hit = defaultHitInfo();\n    for (float i = 0.; i < SampleNb; i++) \n        data.rgb += render(fragCoord, int(float(iFrame) * SampleNb + i), hit) / SampleNb;\n    data.rgb = clamp(data.rgb, vec3(0.), vec3(1.));\n    \n    int currentFrame = int(float(iFrame) * SampleNb + SampleNb - 1.);\n\n    vec3 ro, rd;\n    getCamera(fragCoord, iResolution.xy, iMouse.xyz, currentFrame, iTime, iChannel2, ro, rd);\n    \n    vec3 position     = ro + rd * hit.t;\n    Material material = sceneMaterial(position);\n    \n    vec2 mouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 1), 0).w,\n        texelFetch(iChannel0, ivec2(0, 2), 0).w\n    );\n    int previousFrame = int(float(iFrame - 1) * SampleNb + SampleNb - 1.);\n    vec2 fragCoord2   = getUV( position, iResolution.xy, iMouse.xyz, previousFrame, iTime, iChannel2 );\n    \n    float type       = (any(greaterThan(material.emission, vec3(0.))) ? -1. : 1.);\n    bool wasRendered = all(lessThan(fragCoord2, iResolution.xy)) \n                    && all(greaterThan(fragCoord2, vec2(0.)));\n    \n    \n    vec2 lastResolution  = texelFetch(iChannel0, ivec2(1), 0).rg;\n    bool lastBufferValid = iFrame > 0 && all(equal(lastResolution, iResolution.xy));\n    if(hit.t > 0. && wasRendered) \n    {\n        // Reproject from best sample in neighboring pixels\n        vec2  coordinates     = vec2(0.);\n        float closestDistance = 1000000.;\n        vec3  closestSample   = vec3(0.);\n        \n        vec3 minColor = vec3( 1000.);\n        vec3 maxColor = vec3(-1000.);\n        \n        float radius = max(4., (ReprojectionRadius / 1280.) * iResolution.x);\n        for(float x = -radius; x <= radius; x++)\n        {\n            for(float y = -radius; y <= radius; y++)\n            {\n                vec2 sampleUv = fragCoord2 + vec2(x, y);\n\n                vec3 rro, rrd;\n                getCamera(sampleUv, iResolution.xy, iMouse.xyz, previousFrame, iTime, iChannel2, rro, rrd);\n                \n                vec4  cSample      = texelFetch( iChannel1, ivec2(sampleUv), 0 );\n                vec3  sampleColor  = cSample.rgb;\n                float previousT    = cSample.w;\n                float previousType = sign(cSample.w);\n                previousT          = abs(previousT);\n                vec3  previousP    = rro + rrd * previousT;\n                \n                float currentDistance = sampleDistance(position, data.rgb, previousP, sampleColor);\n                if(currentDistance < closestDistance)\n                {\n                    coordinates     = sampleUv;\n                    closestDistance = currentDistance; \n                    closestSample   = sampleColor;\n                }\n                \n                minColor = min(minColor, sampleColor);\n                maxColor = max(maxColor, sampleColor);\n            }\n        }\n        \n        // Do not reproject if closest sample is too far away\n        //if(closestDistance < ReprojectionMaxDistance)\n        {\n            // Limit ghosting\n            closestSample = clamp(closestSample, minColor, maxColor);\n            \n            // Moving average\n            vec4  cSample     = texelFetch( iChannel1, ivec2(coordinates), 0 );\n            vec3  sampleColor = clamp(cSample.rgb, minColor, maxColor);\n            data.rgb = mix((closestSample*.7+sampleColor*.3), data.rgb, ReprojectionWeightMoving);\n        }\n    }\n\n    // Tag emissive materials for denoise pass\n    data.w = hit.t > 0. ? hit.t * type : 0.;\n    fragColor = data;\n    \n    if(dot(fragCoord, fragCoord) < 1e-4)\n        fragColor.rg = iResolution.xy;\n\n#endif\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// -- Denoising pass \n// Mostly combining the following papers\n\n// Edge-Avoiding À-Trous Wavelet Transform for fast Global Illumination Filtering\n// High Performance Graphics 2010,  Holger Dammertz, Daniel Sewtz, Johannes Hanika, Hendrik P.A. Lensch\n\n// SPATIOTEMPORAL VARIANCE - RECONSTRUCTION FOR PATH REAL GLOBAL ILLUMINATION\n// https://www.highperformancegraphics.org/wp-content/uploads/2017/Papers-Session1/HPG2017_SpatiotemporalVarianceGuidedFiltering.pdf\n\n// Nice additional reference from Lesley Lay: https://www.youtube.com/watch?v=_NwJd0pg4Fo\n\n// Evaluation weights from ASVGF implementation\n// Gradient Estimation for Real-Time Adaptive Temporal Filtering\n// Christoph Schied, Christoph Peters, and Carsten Dachsbacher\n// Reference: https://cg.ivd.kit.edu/atf.php\nvec2  offsets[24] = vec2[](vec2(-2, -2), vec2(-2, -1), vec2(-2,  0), vec2(-2,  1), vec2(-2,  2), vec2(-1, -2), vec2(-1, -1), vec2(-1,  0), vec2(-1,  1), vec2(-1,  2), vec2( 0, -2), vec2( 0, -1), vec2( 0,  1), vec2( 0,  2), vec2( 1, -2), vec2( 1, -1), vec2( 1,  0), vec2( 1,  1), vec2( 1,  2), vec2( 2, -2), vec2( 2, -1), vec2( 2,  0), vec2( 2,  1), vec2( 2,  2));\nfloat weights[24] = float[](1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 6.0, 2.0 / 3.0, 2.0 / 3.0, 1.0 / 6.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0);\n\n// Reprojection\nvec3 getPosition(ivec2 fragCoord, float frameId, float depth) \n{\n    vec2 mouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 1), 0).w,\n        texelFetch(iChannel0, ivec2(0, 2), 0).w\n    );\n    \n    vec3 ro, rd;\n    getCamera(vec2(fragCoord), iResolution.xy, iMouse.xyz, int(frameId), iTime, iChannel1, ro, rd);\n    \n    return ro + rd * depth;\n}\n\n// Filtering\nvoid evaluate(inout vec3 sum, inout float cumW, vec3 color, vec3 position, float type, float frameId, float stepWidth, vec2 fragCoord, vec2 offset, float kernelValue)\n{\n    vec2 uv = fragCoord + offset * stepWidth; \n    \n    vec4  sampleData  = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3  sampleColor = sampleData.rgb;\n    \n    float sampleDepth = sampleData.w;\n    float sampleType  = sign(sampleDepth);\n    \n    sampleDepth = abs(sampleDepth);\n        \n    // Weights from cornusammonis's shader\n    // Reference: https://www.shadertoy.com/view/ldKBRV\n    float cPhi = 0.5;\n    float pPhi = 0.25;\n\n    vec3 samplePosition = getPosition(ivec2(fragCoord), frameId, sampleDepth);\n    vec3  positionDiff  = position - samplePosition;\n    float positionDist  = dot(positionDiff, positionDiff);\n    if(sampleDepth == 0. || sampleType != type)\n        return;\n\n    vec3  colorDiff = rgb2lab(color) - rgb2lab(sampleColor);\n    float colorDist = dot(colorDiff, colorDiff);\n    float wc        = min(exp(-colorDist / cPhi), 1.);\n\n    float wp           = min(exp(-positionDist / pPhi ), 1.);\n    float weight       = wc * wp; \n\n    sum  += sampleColor * weight * kernelValue; \n    cumW += weight * kernelValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    int   seed    = iFrame;\n    float frameId = float(iFrame);\n    vec4  buffer  = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n    float depth   = buffer.w;\n    float type    = sign(depth);\n    depth         = abs(depth);\n    \n    // Only filter pixels with an intersection\n    if(depth > 0.)\n    {\n        vec3  sum  = vec3(0.0);\n        float cumW = 0.0;\n        \n        vec3 position = getPosition(ivec2(fragCoord), frameId, depth);\n        vec3 color    = buffer.rgb;\n\n        // Random step width from: https://www.shadertoy.com/view/ldKBRV\n        float size   = (2. / 1280.) * iResolution.x;\n        float offset = (0. / 1280.) * iResolution.x;\n        float stepWidth = getBlueNoise(vec2( fragCoord.x + 3. + iTime * 2., fragCoord.y * 4. + iTime), seed, iChannel1).x * size + offset;\n        for(int i = 0; i < 24; i++)\n        {\n            vec2  offset = offsets[i];\n            float weight = weights[i];\n            evaluate(sum, cumW, color, position, type, frameId, stepWidth, fragCoord, offset, weight);\n        }\n\n        buffer.rgb = clamp(sum / cumW, vec3(0.), vec3(1.));\n    }\n    \n    fragColor = buffer;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// -- Denoising pass \n// Mostly combining the following papers\n\n// Edge-Avoiding À-Trous Wavelet Transform for fast Global Illumination Filtering\n// High Performance Graphics 2010,  Holger Dammertz, Daniel Sewtz, Johannes Hanika, Hendrik P.A. Lensch\n// https://github.com/LWJGL/lwjgl3-demos/blob/main/src/org/lwjgl/demo/opengl/raytracing/tutorial/Tutorial8.java#L899\n\n// SPATIOTEMPORAL VARIANCE - RECONSTRUCTION FOR PATH REAL GLOBAL ILLUMINATION\n// https://www.highperformancegraphics.org/wp-content/uploads/2017/Papers-Session1/HPG2017_SpatiotemporalVarianceGuidedFiltering.pdf\n\n// Nice additional reference from Lesley Lay: https://www.youtube.com/watch?v=_NwJd0pg4Fo\n\n// Evaluation weights from ASVGF implementation\n// Gradient Estimation for Real-Time Adaptive Temporal Filtering\n// Christoph Schied, Christoph Peters, and Carsten Dachsbacher\n// Reference: https://cg.ivd.kit.edu/atf.php\nvec2  offsets[24] = vec2[](vec2(-2, -2), vec2(-2, -1), vec2(-2,  0), vec2(-2,  1), vec2(-2,  2), vec2(-1, -2), vec2(-1, -1), vec2(-1,  0), vec2(-1,  1), vec2(-1,  2), vec2( 0, -2), vec2( 0, -1), vec2( 0,  1), vec2( 0,  2), vec2( 1, -2), vec2( 1, -1), vec2( 1,  0), vec2( 1,  1), vec2( 1,  2), vec2( 2, -2), vec2( 2, -1), vec2( 2,  0), vec2( 2,  1), vec2( 2,  2));\nfloat weights[24] = float[](1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 6.0, 2.0 / 3.0, 2.0 / 3.0, 1.0 / 6.0, 1.0 / 9.0, 4.0 / 9.0, 2.0 / 3.0, 4.0 / 9.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 6.0, 1.0 / 9.0, 1.0 / 36.0);\n\n// Reprojection\nvec3 getPosition(ivec2 fragCoord, float frameId, float depth) \n{\n    vec2 mouse = vec2(\n        texelFetch(iChannel0, ivec2(0, 1), 0).w,\n        texelFetch(iChannel0, ivec2(0, 2), 0).w\n    );\n    \n    vec3 ro, rd;\n    getCamera(vec2(fragCoord), iResolution.xy, iMouse.xyz, int(frameId), iTime, iChannel1, ro, rd);\n    \n    return ro + rd * depth;\n}\n\n// Filtering\nvoid evaluate(inout vec3 sum, inout float cumW, vec3 color, vec3 position, float type, float frameId, float stepWidth, vec2 fragCoord, vec2 offset, float kernelValue)\n{\n    vec2 uv = fragCoord + offset * stepWidth; \n    \n    vec4  sampleData  = texelFetch(iChannel0, ivec2(uv), 0);\n    vec3  sampleColor = sampleData.rgb;\n    \n    float sampleDepth = sampleData.w;\n    float sampleType  = sign(sampleDepth);\n    \n    sampleDepth = abs(sampleDepth);\n    \n    vec3 samplePosition = getPosition(ivec2(fragCoord), frameId, sampleDepth);\n    vec3  positionDiff  = position - samplePosition;\n    float positionDist  = dot(positionDiff, positionDiff);\n\n    if(sampleDepth == 0. || sampleType != type)\n        return;\n        \n    // Weights from cornusammonis's shader\n    // Reference: https://www.shadertoy.com/view/ldKBRV\n    float cPhi = 0.5;\n    float pPhi = 0.25;\n\n    vec3  colorDiff = rgb2lab(color) - rgb2lab(sampleColor);\n    float colorDist = dot(colorDiff, colorDiff);\n    float wc        = min(exp(-colorDist / cPhi), 1.);\n\n    float wp           = min(exp(-positionDist / pPhi ), 1.);\n    float weight       = wc * wp; \n\n    sum  += sampleColor * weight * kernelValue; \n    cumW += weight * kernelValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    int   seed    = iFrame;\n    float frameId = float(iFrame);\n    vec4  buffer  = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n    float depth   = buffer.w;\n    float type    = sign(depth);\n    depth         = abs(depth);\n    \n    // Only filter pixels with an intersection\n    if(depth > 0.)\n    {\n        vec3  sum  = vec3(0.0);\n        float cumW = 0.0;\n        \n        vec3 position = getPosition(ivec2(fragCoord), frameId, depth);\n        vec3 color    = buffer.rgb;\n\n        // Random step width from: https://www.shadertoy.com/view/ldKBRV\n        float size   = (4. / 1280.) * iResolution.x;\n        float offset = (0. / 1280.) * iResolution.x;\n        float stepWidth = 2.;//getBlueNoise(vec2( fragCoord.x + 3. + iTime * 2., fragCoord.y * 5. + iTime), seed, iChannel1).x * size + offset;        \n        for(int i = 0; i < 24; i++)\n        {\n            vec2  offset = offsets[i];\n            float weight = weights[i];\n            evaluate(sum, cumW, color, position, type, frameId, stepWidth, fragCoord, offset, weight);\n        }\n\n        buffer.rgb = clamp(sum / cumW, vec3(0.), vec3(1.));\n    }\n    \n    fragColor = buffer;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// -- 2D Pass for first screen display\nfloat draw(float x, float x0, float r) { return smoothstep( .01, .0,  abs(x-x0)-r/2.); }\n\nfloat artDecoStraight(vec2 uv)\n{\n    const float Width = 4.;\n    \n    // Rhomb\n    vec2 o = uv;\n    uv.x = o.y + 2. * o.x; \n    uv.y = o.y - 2. * o.x; \n\n    // Repeat\n    vec2 id = floor(uv * Width); \n    uv      = mod(uv * Width, 1.);\n            \n    // Angular repetition\n    uv = uv * 2.;\n    float Repetitions = 36.;\n    float angle = Tau / Repetitions;\n\n    float a  = atan(uv.y, uv.x) + angle/2.;\n\tfloat r  = length(uv);\n\tfloat c  = floor(a/angle);\n\ta        = mod(a,angle) - angle/2.;\n\tvec2 uv2 = vec2(cos(a), sin(a))*r;\n    \n    // The line is drawn for every section of the disk\n    float d = 1. - draw(abs(a) - .05, .1, .2);\n    return d * clamp(length(uv) - .5, 0., 2.);\n\n}\n\n#define rgb(c1, c2, c3) vec3(c1, c2, c3) / 255.\nconst vec3 MainColor      = rgb(251, 217, 130);\nconst vec3 SecondaryColor = rgb(195,  90, 76);\nconst vec3 ThirdColor     = rgb(255, 255, 190);\n\nconst float ReprojectionWeight = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n    \n    int  seed            = int(iFrame);\n    vec2 lastResolution  = texelFetch(iChannel0, ivec2(0), 0).xy;\n    bool lastBufferValid = length(lastResolution - iResolution.xy) < 1e-1;\n    vec4 previous        = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    vec2 uv  = ((fragCoord + .5) / iResolution.y);\n    vec2 uuv = ((fragCoord + .5) / iResolution.xy);\n    vec4 alea      = getBlueNoise(vec2(fragCoord), seed, iChannel2);\n    vec2 jittering = (alea.xy * 1.5 - 1.) / iResolution.xy;\n    uv            += jittering;\n    uuv           += jittering;\n    \n    // Top and bottom parts\n    float slider = max(iTime * .5 - 3., 0.);\n    if( abs( uuv.y - .5 ) - ( .18 + slider ) > 0.)\n        fragColor.rgb = mix(SecondaryColor, ThirdColor, artDecoStraight(uv));\n    \n    // Centered lines \n    fragColor.rgb = mix(fragColor.rgb, SecondaryColor, float(abs(abs(uv.y - .5 ) - (.16 + slider) ) < 5e-3));\n    fragColor.rgb = mix(fragColor.rgb, SecondaryColor, float(abs(abs(uv.y - .5 ) - (.18 + slider) ) < 5e-3));\n\n    // Temporal accumulation + smooth apparition effect\n    if(abs(uuv.y - .5) - (.15 + slider) > 0. && iTime > 0.1 && lastBufferValid)\n        fragColor = mix(previous, fragColor, ReprojectionWeight);\n\n    // Tag rendered pixels\n    fragColor.w = float(dot(fragColor.rgb, fragColor.rgb) > 0.);\n\n    // Text\n    #define writeLetter( id ) writeChar( letter( id ), charUv, char ) \n    #define writeNumber( id ) writeChar( number( id ), charUv, char ) \n    \n    DrawChar char = defaultDrawChar();\n    float text1 = uv.x * uv.y * .5 + iTime * .5 - 1.;\n    float text2 = uv.x * uv.y * .5 + iTime * .5 - 2.1;\n    if(text1 < 1.)\n    {\n        // \"JFIG 2023\"\n        vec2 charUv = ( uv - vec2(-.03, .345)) * 3.25; writeLetter(10); writeLetter(6); writeLetter(9); writeLetter(7); \n        charUv.x -= .5;                                writeNumber(2); writeNumber(0); writeNumber(2); writeNumber(3);\n    }\n    else if(text2 > 0. && text2 < 1.2)\n    {\n        // \"AFIG 30 ANS\"  \n        vec2 charUv = (uv - vec2(.055, .42) ) * 4.; writeLetter(1); writeLetter(6); writeLetter(9); writeLetter(7);\n        charUv      = (uv - vec2(.665, .32) ) * 4.; writeNumber(3); writeNumber(0); charUv.x-=.25;  writeLetter(1); writeLetter(14); writeLetter(19);\n    }\n    \n    // Render text\n    vec4 text = drawChar(char, iChannel1);\n    if(text.x > 0.)\n    {\n        // Normalization of the text sdf from Marble Marcher: SE\n        // Reference: https://www.shadertoy.com/view/3lKyDR\n        float sdf = (text.w - .5 + 1. / 256.) * 75.;\n                \n        fragColor.rgb = MainColor;\n        fragColor.w   = smoothstep(.1, .0, sdf );\n        \n        if(iTime > 0.1 && lastBufferValid) \n        {\n            fragColor.rgb = mix(previous.rgb, fragColor.rgb, ReprojectionWeight);\n            fragColor.w   = mix(previous.w,   fragColor.w,   ReprojectionWeight);\n        }\n    }\n    \n    slider = clamp(iTime * .25 - 36. / 4., 0., 1.);\n    if( abs( uuv.y - .5 ) - (1. - slider) >= 0. ){\n        fragColor.rgb = mix(SecondaryColor, ThirdColor, artDecoStraight(uv) * 1.5);\n        fragColor.w   = 1.;\n        \n        if(iTime > 0.1 && lastBufferValid)\n            fragColor = mix(previous, fragColor, ReprojectionWeight);\n    }\n    \n    if(fragCoord.x < 1. && fragCoord.y < 1.)\n        fragColor.rg = iResolution.xy;\n}\n", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 294, 294, 370], [372, 372, 413, 413, 1102], [1104, 1200, 1225, 1225, 1411], [1413, 1413, 1470, 1470, 2964]], "test": "untested"}
{"id": "DdcBWX", "name": "Orbit Trap Golf 2̶0̶2̶ 156", "author": "domrally", "description": "Minimizing the code to render a mandelbrot with orbit traps.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["mandelbrot", "orbit", "trap", "short", "golf"], "likes": 4, "viewed": 198, "published": 3, "date": "1697733790", "time_retrieved": "2024-07-30T17:26:56.562201", "image_code": "/*\n156 characters: FabriceNeyret2\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 R = iResolution.xy, z;\n    float f, r = 9., n;\n\n    for ( i += i - R; n++ < 31.; f < r ? r=f, o = vec4(z,-z.y,z) : o ) \n        f = dot( z = mat2(z,-z.y,z)*z + 2.*i / R.x, z );\n}\n\n\n/*\n188 characters: shadertoyjiang\n*\nvoid mainImage(out vec4 o, vec2 i) {\n    o.xyz = iResolution;\n    mat2 z, t;\n    float f, r = 9.;\n    \n    for (i += i - o.xy; o.z++ < 31.;) {\n        z = z * z + 2. * mat2(i, -i.y, i) / o.x;\n        \n        r = min(r, f = determinant(z));\n        t = (t - z) * float(r != f) + z;\n    }\n    \n    o = vec4(t);\n}\n*/\n\n\n/*\n202 characters: domrally\n*\nvoid mainImage(out vec4 o, vec2 i) {\n    o.xyz = iResolution;\n    mat2 z, t;\n    float r = 9.;\n    \n    for (i += i - o.xy; o.z++ < 31.;) {\n        // represent complex operations in matrix form\n        z = z * z + 2. * mat2(i, -i.y, i) / o.x;\n        \n        // measure shortest approach distance\n        float f = determinant(z);\n        r = min(r, f);\n        t = t * float(r != f) + float(r == f) * z;\n    }\n    \n    // we can convert from mat2 to vec4 \n    // since they both have 4 floats\n    o = vec4(t);\n}\n*/\n\n\n/*\nREFERENCES\n\nmatrices\n\nakohdr 2021\nhttps://www.shadertoy.com/view/7tVGzh\n\ngolf\n\nhosted by incription (91 chars!)\nhttps://www.shadertoy.com/view/slyGz1\n\nhosted by FabriceNeyret2\nhttps://www.shadertoy.com/view/4sK3Dz\n\nhosted by isaacchurchill\nhttps://www.shadertoy.com/view/tt2cz1\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n*/\n\n\n/*\nFURTHER READING\n\nminimization\n\nhttps://en.wikipedia.org/wiki/Code_golf\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Spectral_sensitivity\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdcBWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 73, 73, 261]], "test": "untested"}
{"id": "msdBWX", "name": "3-Point 2D Noise", "author": "virmoesiae", "description": "A 2D noise implementation that only requires 3 random number calls and 2 mix calls, compared to a typical 4-point 2D noise that requires 4 random number calls and 3 mix calls. Hopefully it's faster than the 4-point one\n", "tags": ["noise", "fbm", "3pointnoise"], "likes": 10, "viewed": 273, "published": 3, "date": "1697732007", "time_retrieved": "2024-07-30T17:26:57.572499", "image_code": "/*\n    AD BY VIRMODOETIAE, a.k.a VIRMOESIAE ---------------------------\n    \n    Do you like shaders? Would you like to toy with them offline?\n    Would you like an interactive UI to play around with your shader\n    variables/uniforms in real-time without compilation? Would you\n    like to have a layer-based shader blending, without having to\n    pass through obscure buffers all the time? Would like to export\n    your shaders directly as GIFs?\n    Would you like a stand-alone executable (currently for Windows-\n    only, but the source code is cross-platform) in less than 9MB?\n    \n    Then, my dear friend, come get your free copy of:\n        \n    >>> SHADERTHING <<<\n   \n    a live, offline, GUI-based shader editor developed by me,\n    virmodoetiae (a.k.a, virmoesiae) freely obtainable at:\n    \n        https://github.com/virmodoetiae/shaderthing\n    \n    For the release, head to :\n    \n        https://github.com/virmodoetiae/shaderthing/releases\n    \n    Everything, including the source code, is available under a \n    very permissive libz/libpng license, so you can really do\n    almost anything you want with it!\n    \n    Please note that currently no tutorials are available, but the\n    core usage should be intuitive to most ShaderToy users.\n    \n    Enjoy!\n*/\n\n// Swap with other noise implementations to check for differences\n// (best seen when VIEW is set to fbm). The novel implementations\n// are triValueNoise and triGradNoise\n#define NOISE triValueNoise\n//#define NOISE triGradNoise\n//#define NOISE quadValueNoise\n//#define NOISE quadGradNoise\n\n#define VIEW pattern\n//#define VIEW fbm\n\n// My take on the pseudo-random number thing\nfloat random(vec2 x)\n{\n    return fract(138912.*sin(dot(x, vec2(138.9, 191.2))));\n}\n\n// From iq\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Your average 4-point value noise implementation\nfloat quadValueNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn \n        mix\n        (\n            mix(random(b),        random(b + d.yx), f.x), \n            mix(random(b + d.xy), random(b + d.yy), f.x), \n            f.y\n        );\n}\n\n// Your average 4-point, Perlin-like noise implementation\nfloat quadGradNoise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 r = fract(n);\n    vec2 l = floor(n);\n    vec2 f = r*r*(3.0-2.0*r);\n\treturn \n        .5+.5*mix\n        (\n            mix\n            (\n                dot(random2(l), r),        \n                dot(random2(l + d.yx), r-d.yx), \n                f.x\n            ), \n            mix\n            (\n                dot(random2(l + d.xy), r-d.xy), \n                dot(random2(l + d.yy), r-d.yy), \n                f.x\n            ), \n            f.y\n        );\n}\n\n// A 2D noise implementation I came up with that requires \n// one less call to the pseudo-random number generator and\n// one less mixing. Easily extandable to 3D\nfloat triValueNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = random(l+s*e.yx);\n    float b = random(l+s*e.yx+e.xy);\n    float c = random(l+s*e.xy+(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    r *= r*(3.-2.*r); // Same cubic profile as smoothstep\n    return mix(mix(a, b, r.x), c, r.y);\n}\n\n// Same as before but using gradients, much smoother\nfloat triGradNoise(vec2 x)\n{\n    x.y *= 1.1547;\n    x.x -= 0.5*x.y;\n    vec2 l = floor(x);\n    vec2 r = fract(x);\n    float s = float(int(r.x+r.y > 1.));\n    vec2 e = vec2(1.,0.);\n    float a = dot(random2(l+s*e.yx), r-s*e.yx);\n    float b = dot(random2(l+s*e.yx+e.xy), r-s*e.yx-e.xy);\n    float c = dot(random2(l+s*e.xy+(1.-s)*e.yx), r-s*e.xy-(1.-s)*e.yx);\n    r.y = s+r.y*(1.-2.*s);\n    r.x = (r.x-s*r.y)/(1.-r.y);\n    // Quintic profile to have null second derivate at \n    // boundaries\n    r *= 6.*r*r*r*r-15.*r*r*r+10.*r*r; \n    return .5+.5*mix(mix(a, b, r.x), c, r.y);\n}\n\n// Fractional Brownian Motion noise to test the \n// single-octave noise function\nfloat fbm(vec2 x)\n{\n    float n = 0.;\n    float A = 0.;\n    vec2 af = vec2(1., 2.);\n    for (int i=0; i<4; i++)\n    {\n        // Rotate each octave\n        float s = sin(float(2*i));\n        float c = cos(float(2*i));\n        mat2 m = mat2(c, s, -s, c);\n        n += af.x*NOISE(af.y*m*x);\n        A += af.x;\n        af *= vec2(.4,2.);\n    }\n    return n/A;\n}\n\n// A warp-based pattern inspired by https://iquilezles.org/articles/warp/\nfloat pattern(vec2 x)\n{\n    vec2 a = vec2(fbm(x)+iTime/15., fbm(x+vec2(2.2,0.)));\n    float b = fbm(x+a+iTime/10.);\n    vec2 c = vec2(fbm(x+b), fbm(a-vec2(1.7,0.)));\n    return fbm(x+.5*c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 d = 3.*vec2(2.+cos(iTime/10.), 3.+sin(iTime/10.));\n    fragColor = vec4(vec3(VIEW(2.*uv+d)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdBWX.jpg", "access": "api", "license": "libpng", "functions": [[1611, 1656, 1678, 1678, 1739], [1741, 1752, 1774, 1774, 1913], [1915, 1966, 1997, 1997, 2278], [2280, 2338, 2368, 2368, 2865], [2867, 3029, 3058, 3058, 3481], [3483, 3536, 3564, 3564, 4114], [4116, 4197, 4216, 4216, 4555], [4557, 4631, 4654, 4654, 4822], [4824, 4824, 4881, 4881, 5029]], "test": "ok"}
{"id": "dddfDX", "name": "Jwibullori w/MouseColorAdjust", "author": "timmaffett", "description": "Mouse X = Hue\nMouse Y = Saturation  (and size of spinner)\n@catking562 's Jwibullori  with\nadded customizable color from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW", "tags": ["shader"], "likes": 12, "viewed": 441, "published": 3, "date": "1697725122", "time_retrieved": "2024-07-30T17:26:58.616708", "image_code": "// Fork of \"Jwibullori\" by catking562. https://shadertoy.com/view/cs3fzl\n// 2023-10-19 13:50:10\n\n#define PI  3.14159265359\n\n\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n    //float size = 0.02;\n    float sx = iResolution.x;\n    float sy = iResolution.y;\n    float s = sqrt(sx*sx+sy*sy);\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n \n //change size of spinner from mouse Y\n vec2 mouse = (iMouse.xy == vec2(0.)) ? vec2(0.5) : iMouse.xy/iResolution.xy;   \n    uv *= 1.0+(0.5-mouse.y);\n    \n    float j = 0.0;\n    //while(size>=0.001) {\n    for(float size=0.02;size>=0.001;size-=0.0001) {\n        float x = (cos(iTime*5.0+size*150.0)*s/10.0)/sx;\n        float y = (sin(iTime*5.0+size*150.0)*s/10.0)/sy;\n        float dx = uv.x-x;\n        float dy = uv.y-y;\n        float k = sqrt(dx*dx+dy*dy);\n        j += (size/k)/100.0;\n        //size-=0.0001;\n    }\n    \n    float red = cos(PI*(j-1.0/3.0)*3.0/2.0);\n\n    if(iMouse.xy == vec2(0.)) {\n        float green = cos(PI*(j-2.0/3.0)*3.0/2.0);\n        float blue = cos(PI*(j-1.0)*3.0/2.0);\n        fragColor = vec4(red, green, blue, 1);\n    } else {\n        \n        vec4 mouseColor = hsv2rgb(vec3(mouseUV.x, mouseUV.y, 1.0));\n        \n //#define SINGLECOLOR\n #ifdef SINGLECOLOR\n         float green=red, blue=red;\n #else\n        float green = cos(PI*(j-(2.0*mouseUV.y)/3.0)*3.0/2.0);\n        float blue = cos(PI*(j-(1.0*mouseUV.x))*3.0/2.0);\n #endif\n        fragColor = vec4(red, green, blue, 1.) * mouseColor;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 161, 161, 209], [210, 210, 245, 245, 291], [293, 293, 318, 318, 665], [666, 666, 690, 690, 852], [855, 855, 912, 912, 2265]], "test": "untested"}
{"id": "ddtfWX", "name": "Shader Gallery", "author": "Peace", "description": "Shader gallery to keep my favorites", "tags": ["shader", "gallery"], "likes": 6, "viewed": 357, "published": 3, "date": "1697722490", "time_retrieved": "2024-07-30T17:26:59.553204", "image_code": "const float SMOOTHNESS = 0.5;\nconst vec3 BLOB_COL_BASE = vec3(1.0, 0.11, 0.8);\nconst vec3 BLOB_COL_GLOW = vec3(1.0, 0.9, 0.0);\nconst float ROWS = 6.0;\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat rand(int i, float lo, float hi) {\n    return (hi - lo) * 0.5 * (sin(float(997*i)) + 1.) + lo;\n}\n\nvec4 perm(vec4 x) { x = ((x * 34.0) + 1.0) * x; return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * 0.02439024);\n    vec4 o2 = fract(k4 * 0.02439024);\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat rand1d(float n) { return fract(sin(n) * 43758.5453123); }\n\nfloat noise1d(float p) \n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand1d(fl), rand1d(fl + 1.0), fc);\n}\n\nfloat blob(vec2 uv, vec2 pos, float n, float radius, float period, int index) \n{ \n    float time = iTime * 0.3 + float(index) * 684.7291;\n    int i = int(time / period);\n    float t = mod(time, period) / period;\n    \n    pos.y = smoothstep(0., .4, t)*2.-1.;\n    pos.y = mix(pos.y, -1., smoothstep(.5, .8, t)) * (ROWS - 1.0);\n    \n    vec2 p = uv - pos + n;\n    return length(p) - radius;\n}\n\nfloat sdf(vec2 uv) \n{\n    float d = 9999999.;\n    float n = noise(vec3(uv, iTime * .2) * 0.7) * 0.7;\n    for (float i = -ROWS; i <= ROWS; i += 1.0) \n    {\n        float r = noise1d(i+iTime*0.2);\n        d = smin(d, blob(uv, vec2(i * iResolution.x / iResolution.y * 0.8, 0.0), n, (0.7 + r*2.) * 0.8, 8.0 + abs(rand1d(i)) * 8.0, int(i)), SMOOTHNESS);\n    }\n    return d;\n}\n\nfloat specular(vec3 light_dir, vec3 normal) {\n    light_dir = normalize(light_dir);\n    vec3 view_dir = vec3(0,0,-1);\n    vec3 halfway = normalize(light_dir + view_dir);\n    float s = max(0.0, dot(normal, halfway));\n    return s * s * s * s * s * s;\n}\n\nconst uint MAX_RAY_MARCH_STEPS = 32u;\nconst float MAX_DISTANCE = 1.0;\nconst float SURFACE_DISTANCE = 0.01;\nconst float HALF_PI = 1.57079632679;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Camera\n{\n    Ray ray;\n    float fov;\n};\nCamera camera;\n\nstruct Hit\n{\n    float dist;\n    float min_dist;\n    vec3 point;\n    vec3 normal;\n};\n    \nfloat specularBlinnPhong(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    return max(0.0, dot(normal, normalize(light_dir + ray_dir)));\n}\n\nfloat fbm(vec3 p)\n{\n    return (noise(p * 1.4) + noise(p * 2.25 + 16.791) * 0.6 + noise(p * 3.375 - 31.613) * .35) * 0.6;\n}\n\nfloat SDF(vec3 point, float seed)\n{\n    return (dot(point, point) - 0.16 - fbm(vec3(point.xy, iTime * 0.25 + point.z) + seed) * 0.25) * 0.7;\n}\n\nHit raymarch(Ray ray, float seed)\n{\n    Hit hit;\n    hit.dist = 0.0;\n    hit.min_dist = MAX_DISTANCE;\n    hit.normal = vec3(0);\n    for (uint i = 0u; i < MAX_RAY_MARCH_STEPS; ++i)\n    {\n        hit.point = ray.pos + ray.dir * hit.dist; \n        float sdf = SDF(hit.point, seed);\n        hit.min_dist = min(hit.min_dist, sdf);\n        hit.dist += sdf;\n        if (hit.dist >= MAX_DISTANCE)\n            return hit;\n        if (abs(sdf) <= SURFACE_DISTANCE)\n        {\n            vec2 e = vec2(0.002, 0.0);\n            hit.normal = normalize(sdf - vec3(SDF(hit.point - e.xyy, seed), SDF(hit.point - e.yxy, seed), SDF(hit.point - e.yyx, seed)));\n            return hit;\n        }\n    }\n    \n    return hit;\n}\n\nvec4 getColor(Ray ray, vec3 color, float seed)\n{\n    vec3 col = vec3(0);\n    Hit hit = raymarch(ray, seed);\n    if (hit.normal != vec3(0))\n    {\n        vec3 n = abs(hit.normal + vec3(0, 0, 0.5));\n        col = normalize(color + n * n);\n        col += pow(specularBlinnPhong(normalize(vec3(100, 100, -100) - hit.point), normalize(camera.ray.pos - hit.point), hit.normal), 32.0) * 0.5;\n    }\n    else\n    {\n        col = vec3(pow(max(0.0, 1.0 - hit.min_dist), 16.0)) * color;\n        hit.dist = MAX_DISTANCE + 1.0 - max(0.0, 1.0 - hit.min_dist);\n    }\n    return vec4(col, hit.dist);\n}\n\nvec3 first(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;    \n    camera.fov = 90.0;\n    camera.ray.pos = vec3(0, 0, -1);\n    camera.ray.dir = vec3(0, 0, 1);\n    float fov = tan(HALF_PI - radians(camera.fov) * 0.5);\n    camera.ray.dir = normalize(vec3(uv, fov));\n    \n    vec4 c1 = getColor(camera.ray, vec3(1, 0.35, 1), 0.0);\n    vec4 c2 = getColor(camera.ray, vec3(0.1, 0.5, 1.0), 1000.612);\n    \n    if (c1.w > c2.w) { vec4 temp = c1; c1 = c2; c2 = temp; }\n    \n    if (c1.w >= MAX_DISTANCE)\n    {\n        fragColor = vec4(mix(c1.rgb, c2.rgb, 0.5), 1);\n        return fragColor.rgb;\n    }\n    \n    fragColor.rgb = c1.rgb;\n    if (c2.w < MAX_DISTANCE) fragColor.rgb = mix(fragColor.rgb, c2.rgb, 0.5);\n    fragColor.rgb = sqrt(fragColor.rgb * 1.1 - .1);\n    return fragColor.rgb;\n}\n\nvec3 second(out vec4 fragColor, in vec2 fragCoord)\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * ROWS;\n    vec3 uvn = normalize(vec3(uv, 1.0));\n    \n    float d = sdf(uv); \n    vec2 e = vec2(8.0, 0);\n    float nx = (sdf(uv - e.xy) - sdf(uv + e.xy)) / (2.0 * e.x);\n    float ny = (sdf(uv - e.yx) - sdf(uv + e.yx)) / (2.0 * e.x);\n    vec3 n = normalize(vec3(nx, ny, -1.));\n    float m = smoothstep(0.0, 0.0 - fwidth(uv).y * 2., d);\n    float s = noise(vec3(uv, iTime * .5 + 630.737551) * 1.0) * 0.5;\n    float spec = max(0.0, uvn.y) * specular(vec3(uvn.x,-3.,0.0), n);\n    spec += min(1.0, 1.-uvn.y) * specular(vec3(uvn.x,3.,0.0), n);\n    spec = spec / (spec + 1.0) * 1.5;\n    vec3 col = spec * spec * (BLOB_COL_GLOW * 0.3 + 0.7) + mix(BLOB_COL_BASE, BLOB_COL_GLOW, spec);\n    col -= max(0.0, 1.- pow(abs(-d), 0.25)) * 0.7;\n    fragColor = vec4(col * m + BLOB_COL_BASE * (1.0 - m) / (6.0 + d), 1.0);\n    return fragColor.rgb;\n}\n\nconst float OPACITY = 0.2;\nconst vec3 HALO_COL = vec3(0.2, 0.6, 1.0);\nconst vec3 EDGE1_COL = vec3(1.0, 0.68, 0.66);\nconst vec3 EDGE2_COL = vec3(1.0, 0.3, 0.2);\nconst vec3 BACKGROUND_COL = vec3(0, 0, 0.11);\n\nvec2 rot(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvec3 circle(vec2 uv, float off) \n{\n    vec3 col = HALO_COL;\n    float t = iTime * 0.5 + off;\n    float rt = t * 0.4;\n    float f = fwidth(uv).y * 4.0;\n    uv = rot(uv, 6.2831853 * (noise1d(rt - 6816.6) * 0.5 + noise1d(rt * 1.25 - 3743.16) * 0.4 + noise1d(rt * 1.5 + 1741.516) * 0.3));\n    float n = noise(vec3(uv * 1.2, t)) * 0.2 + noise(vec3(-uv * 1.7, t)) * 0.15 + noise(vec3(uv * 2.2, t)) * 0.1;\n    float d = dot(uv, uv);\n    float hd = d + n;\n    col = pow(vec3(hd), vec3(3.5, 3.5, 2.0)) * HALO_COL * smoothstep(1.0, 1.0 - f, hd);\n    float cd = d * hd * hd * smoothstep(1.0, 1.0 - f, hd) * 1.25;\n    col += cd * cd * mix(EDGE1_COL, EDGE2_COL, pow(hd, 8.0)) - (cd * cd * cd) * col;\n    col = mix(BACKGROUND_COL, col, smoothstep(1.0, 1.0 - f, hd));\n    return col;\n}\n\nvec3 third( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.1;\n    \n    vec3 col = mix(mix(mix(mix(\n    circle(uv, 0.0), \n    circle(uv, 1000.0), OPACITY), \n    circle(uv, 2000.0), OPACITY), \n    circle(uv, 3000.0), OPACITY), \n    circle(uv, 4000.0), OPACITY);\n    return col;\n}\n\n#define MAX_RAY_MARCH_STEPS 32\n#define MAX_DISTANCE 4.0\n#define SURFACE_DISTANCE 0.002\n\nstruct Hit2\n{\n    float dist;\n    float closest_dist;\n    vec3 p;\n};\n    \nfloat specularBlinnPhong2(vec3 light_dir, vec3 ray_dir, vec3 normal)\n{\n    vec3 halfway = normalize(light_dir + ray_dir);\n    return max(0.0, dot(normal, halfway));\n}\n\nfloat SDF(vec3 point)\n{\n    vec3 p = vec3(point.xy, iTime * 0.3 + point.z);\n    float n = (noise(p) + noise(p * 2.0) * 0.5 + noise(p * 4.0) * 0.25) * 0.57;\n    return length(point) - 0.35 - n * 0.3;\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec2 e = vec2(0.002, 0.0);\n    return normalize(SDF(point) - vec3(SDF(point - e.xyy), SDF(point - e.yxy), SDF(point - e.yyx)));\n}\n\nHit2 raymarch(vec3 p, vec3 d)\n{\n    Hit2 hit;\n    hit.closest_dist = MAX_DISTANCE;\n    for (int i = 0; i < MAX_RAY_MARCH_STEPS; ++i)\n    {\n        float sdf = SDF(p);\n        p += d * sdf; \n        hit.closest_dist = min(hit.closest_dist, sdf);\n        hit.dist += sdf;\n        if (hit.dist >= MAX_DISTANCE || abs(sdf) <= SURFACE_DISTANCE)\n            break; \n    }\n    \n    hit.p = p;\n    return hit;\n}\n\nvec3 fourth(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    fragColor = vec4(0, 0, 0, 1);\n    if (dot(uv, uv) > 1.0) return fragColor.rgb;\n    vec3 pos = vec3(0, 0, -1);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    Hit2 hit = raymarch(pos, dir);\n    fragColor = vec4(pow(max(0.0, 1.0 - hit.closest_dist), 32.0) * (max(0.0, dot(uv, vec2(0.707))) * vec3(0.3, 0.65, 1.0) + max(0.0, dot(uv, vec2(-0.707))) * vec3(0.6, 0.35, 1.0) + vec3(0.4, 0.5, 1.0)), max(0.0, hit.closest_dist));\n    if (hit.closest_dist >= SURFACE_DISTANCE)\n        return fragColor.rgb;\n    vec3 normal = getNormal(hit.p);\n\n    vec3 ray_dir = normalize(pos - hit.p);\n    float facing = max(0.0, sqrt(dot(normal, vec3(0.707, 0.707, 0))) * 1.5 - dot(normal, -dir));\n    fragColor = mix(vec4(0), vec4(0.3, 0.65, 1.0, 1.0), 0.75 * facing * facing * facing);\n    \n    facing = max(0.0, sqrt(dot(normal, vec3(-0.707, -0.707, 0))) * 1.5 - dot(normal, -dir));\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.6, 0.35, 1.0, 1.0), 0.75 * facing * facing * facing);\n    \n    facing = max(0.0, sqrt(dot(normal, vec3(0.0, 0.0, -1.0))) * 1.5 - dot(normal, -dir));\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.4, 0.5, 1.0, 1.0), 0.5 * facing * facing * facing);\n    \n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.4, 0.625, 1.0, 1.0), pow(specularBlinnPhong(normalize(vec3(600, 800, -500) - hit.p), ray_dir, normal), 12.0) * 1.0);\n    fragColor = vec4(fragColor.rgb, 0) + mix(vec4(0), vec4(0.6, 0.5625, 1.0, 1.0), pow(specularBlinnPhong(normalize(vec3(-600, -800, -00) - hit.p), ray_dir, normal), 16.0) * 0.75);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.25));\n    return fragColor.rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float SMOOTH = 0.15;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 a = first(fragColor, fragCoord * 2.0 - vec2(iResolution.x, 0));\n    vec3 b = second(fragColor, fragCoord * 2.0);\n    vec3 m1 = mix(a, b, smoothstep(0.5 + SMOOTH, 0.5 - SMOOTH, uv.x));\n     \n    vec3 c = third(fragColor, fragCoord * 2.0 - vec2(0, iResolution.y));\n    vec3 d = fourth(fragColor, fragCoord * 2.0 - vec2(iResolution.x, iResolution.y));\n    vec3 m2 = mix(d, c, smoothstep(0.5 + SMOOTH, 0.5 - SMOOTH, uv.x));\n    \n    fragColor.rgb = mix(m2, m1, smoothstep(0.5 + SMOOTH, 0.5 - SMOOTH, uv.y));\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 152, 191, 191, 271], [273, 273, 312, 312, 374], [376, 376, 395, 395, 470], [472, 472, 493, 493, 980], [982, 982, 1005, 1005, 1045], [1047, 1047, 1072, 1072, 1165], [1167, 1167, 1247, 1247, 1556], [1558, 1558, 1579, 1579, 1928], [1930, 1930, 1975, 1975, 2181], [2526, 2526, 2595, 2595, 2663], [2665, 2665, 2684, 2684, 2788], [2790, 2790, 2825, 2825, 2932], [2934, 2934, 2969, 2969, 3638], [3640, 3640, 3688, 3688, 4224], [4226, 4226, 4277, 4277, 5068], [5070, 5070, 5122, 5122, 6067], [6276, 6276, 6304, 6304, 6388], [6390, 6390, 6424, 6424, 7160], [7162, 7162, 7215, 7215, 7552], [7716, 7716, 7786, 7786, 7882], [7884, 7884, 7907, 7907, 8084], [8086, 8086, 8114, 8114, 8248], [8250, 8250, 8281, 8281, 8653], [8655, 8655, 8707, 8707, 10406], [10408, 10408, 10463, 10463, 11074]], "test": "untested"}
{"id": "cdccRj", "name": "what?͏", "author": "01000001", "description": "uhhhhhhhhhh I was trying to do voronoi tracking...", "tags": ["thingy"], "likes": 1, "viewed": 38, "published": 3, "date": "1697721224", "time_retrieved": "2024-07-30T17:27:00.628329", "image_code": "void mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    O = texture(iChannel0, uv);\n    \n    float minD = 2.;\n    float x = 0.;\n    for (float i = 0.; i<r.x; i++){\n        x = length(texture(iChannel0, texture(iChannel1, uv).xy/scale).xy - uv);\n        if (x < minD){\n            minD = x;\n        }\n    }\n    \n    O = vec4(1);\n    O*= smoothstep(.0, 10./r.x, minD);\n    \n    O = texture(iChannel1, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Particle buffer\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (uv.x * scale > 1. || uv.y * scale > 1.) return;\n    \n    if (iFrame < 30){\n        O.xy = uv;\n        O.zw = normalize(hash(uvec3(U, iDate.w)).xy*2.-1.);\n    } else {\n        \n        O = texture(iChannel0, uv);\n        \n        vec2 pos = O.xy;\n        vec2 vel = O.zw;\n        \n        // Replace vel with direction and constant speed later for boids\n        // Keep vel for pbd physics :eyes:\n        \n        \n        pos += vel*1e-3;\n        \n        pos.x -= floor(pos.x);\n        pos.y -= floor(pos.y);\n        \n        O = vec4(pos, vel);\n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Voronoi buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (iFrame < 20){\n        O = vec4(0);\n        O.xy = uv;\n        return;\n    }\n    \n    \n    O = texture(iChannel1, uv);\n    // xy is data location of my particle\n    \n    vec2 myParticle = texture(iChannel0, O.xy/scale).xy;\n    \n    \n    for (int i = 0; i < 8; i++){\n        vec2 samp = mod(O.xy\n            + (circleSample(uvec3(U, iDate.w*1000.))*2.-1.\n            +  circleSample(uvec3(U, iDate.w*2000.))*2.-1.\n            +  circleSample(uvec3(U, iDate.w*3000.))*2.-1.)*.001\n        ,1.);\n            \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n\n        if (length(newParticle - uv) < length(myParticle - uv)){\n            O = vec4(0);\n            O.xy = samp;\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float scale = 10.;\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v;\n    for(v=hash(x+uint(v*1e9)).xy*2.-1.;\n        dot(v,v)<1.;)\n    return v;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdccRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 444]], "test": "untested"}
{"id": "cdtfDX", "name": "Kaleidoscope on crack", "author": "mashedpotato", "description": "first project\n", "tags": ["2d", "designs"], "likes": 4, "viewed": 238, "published": 3, "date": "1697708072", "time_retrieved": "2024-07-30T17:27:01.490026", "image_code": "vec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    return rotationMatrix * p;\n}\n\nvec3 palette(float t) {\n    // Create time-varying coefficients for a, b, c, and d\n    vec3 a = vec3(0.488 * cos(t), -0.212 * sin(0.5*t), 0.528 * cos(2.0 * t));\n    vec3 b = vec3(0.298 * sin(0.5 * t), 0.738 * cos(t), -0.112 * sin(t));\n    vec3 c = vec3(-1.942 * cos(1.5 * t), -2.312 * sin(t), -3.142 * cos(0.3 * t));\n    vec3 d = vec3(1.098 * sin(0.7 * t), -1.982 * cos(t), 0.667 * sin(2.0 * t));\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n\n    // Apply a rotation to uv based on time (iTime)\n    float rotationAngle = 0.1*iTime; // You can adjust the rotation speed as needed\n    uv = rotate(uv, rotationAngle);\n\n    vec3 finalcolor = vec3(0.0);\n\n    for (float i = 0.0; i < 4.0; i++) {\n        uv = uv *(2.2+ 1.4*cos(0.1*iTime));\n        uv = fract(uv);\n        uv = uv - 0.5;\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + 0.4 * i + 0.4*iTime );\n\n        d = sin(8.0 * d + iTime) / 8.0;\n        d = abs(d);\n\n        //d = pow(smoothstep(0.0, 0.1, d),1.8);\n        d = pow(0.01 / d, 1.8);\n        //d = pow(5.0*exp(-d), 1.8);\n\n        finalcolor += col * d;\n    }\n\n    fragColor = vec4(finalcolor, 1.0);\n}\n  \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 164], [166, 166, 189, 248, 612], [616, 616, 671, 721, 1519]], "test": "untested"}
{"id": "cl33Dr", "name": "Type 2 Hexagonal Tilings", "author": "mla", "description": "Hexagon tilings of the second kind, with four aspects of the base tile, two being mirror images.\nAnimation mode by default, press 'a' to turn off & use mouse to set control points.\n\n<mouse>,<up/down>,c,g,p,q,r,s,x,z also do things.", "tags": ["hexagon", "tilings"], "likes": 12, "viewed": 222, "published": 3, "date": "1697696295", "time_retrieved": "2024-07-30T17:27:02.379646", "image_code": "// Type 2 Hexagonal Tilings\n//\n// There are 3 types of convex monohedral hexagonal tilings, see:\n// https://en.wikipedia.org/wiki/Hexagonal_tiling#Monohedral_convex_hexagonal_tilings\n// or eg. Grunbaum and Shepard for details, and the same constructions\n// works for non-convex tiles as well (though there may be non-convex tilings\n// that are not constructible in this way).\n//\n// This shader constructs a Type 2 tiling based on a rectangular\n// repeating unit, and using two control points within the unit to\n// construct the tiling (zooming in and using 'g' to see the underlying grid\n// will probably be more useful than me trying to explain it). For\n// some positions of the control points, the tile boundary intersects\n// itself, or the tile is incompletely drawn (a limitation of doing this\n// in a fragment shader).\n//\n// The resulting tiling consists of translations and rotations of the\n// basic tile and its mirror image.\n//\n// Various subtypes of tiling are possible, eg. if one or more sides of the basic\n// tile has length zero, or a corner angle is 180°, then the tiling is in fact\n// of pentagons, quadrilaterals or triangles. Keys q,r,s show some possibilities.\n//\n// If the edges of the tile are replaced with curves with appropriate symmetry,\n// then we have tiling satisfying a criterion similar to the 'Conway criterion'\n// for Type 1 Tilings: https://en.wikipedia.org/wiki/Conway_criterion\n//\n// By varying the control point positions across the image we can do\n// 'parquet deformations' - currently just a displacement to the two\n// control points. Better ways are possible I'm sure.\n//\n// <mouse>: drag control points when not in animation mode\n// <up/down>: zoom in & out\n// a: animation\n// c: colouring\n// g: show grid\n// p: show grid parity\n// q,r,s: use special values for the control points\n// x: don't show control points\n// z: extra zoom out\n\n// Point reflect p in q\nvec2 pointreflect(vec2 p, vec2 q) {\n  return 2.0*q - p;\n}\n\n// Vertical glide reflection\nvec2 vglide(vec2 q, vec2 a) {\n  return vec2(a.x-q.x,a.y+q.y);\n}\n\nint wind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.y <= 0.0) {\n    if (r.y > 0.0 && t > 0.0) return 1;\n  } else {\n    if (r.y <= 0.0 && t < 0.0) return -1;\n  }\n  return 0;\n}\n\nfloat vmin(vec2 p) {\n  return min(p.x,p.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  setscale();\n  vec2 p = map(fragCoord);\n  float px = 1.4*2.0*scale/iResolution.y;\n  vec2 a = getselection(0); // rectangle corner\n  p /= a;\n  ivec2 ix = ivec2(floor(p));\n  p = mod(p+1.0,2.0)-1.0;\n  p *= a;\n  bool parity = p.x < 0.0 == p.y < 0.0;\n  ivec2 inc = ivec2(1);\n  if (p.y < 0.0) { \n    p = -p; inc = -inc;\n  }\n  if (p.x < 0.0) {\n    p.x = a.x+p.x;\n    p.y = a.y-p.y;  \n    inc.y = -inc.y;\n  }\n  // q0,q,r,r0\n  vec2 q = getselection(1);\n  vec2 r = getselection(2);\n  if (!key(CHAR_A)) {\n    // Keep control points within two rectangle units. \n    float t = 0.5*iTime;\n    q = mod(vec2(0.5,0.8)+0.618*t*vec2(1,0.618),2.0*a*vec2(1,2));\n    q = min(q,2.0*a*vec2(1,2)-q);\n    q.y -= a.y;\n    r = mod(vec2(0.8,0.2)+t*vec2(1,0.618),2.0*a*vec2(1,2));\n    r = min(r,2.0*a*vec2(1,2)-r);\n    r.y -= a.y;\n  }\n  if (!key(CHAR_D)) {\n    vec2 off = 0.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    q += off;\n    r += off.yx;\n  }\n  if (key(CHAR_Q)) q = vec2(0);\n  if (key(CHAR_R)) r = vec2(a.x,0);\n  if (key(CHAR_S)) r = q;\n  vec2 q0 = pointreflect(q,vec2(0));\n  vec2 r0 = pointreflect(r,vec2(a.x,0));\n  vec2 Q0 = vglide(q0,a), Q = vglide(q,a);\n  vec2 R = vglide(r,a), R0 = vglide(r0,a);\n  vec2 R1 = r + vec2(0,2.0*a.y);\n  vec2 q1 = Q - vec2(0,2.0*a.y);\n\n  float d = 1e8;\n  d = min(d,segment(p,q0,q));\n  d = min(d,segment(p,q,r));\n  d = min(d,segment(p,r,r0));\n  d = min(d,segment(p,Q0,Q));\n  d = min(d,segment(p,Q,R));\n  d = min(d,segment(p,R,R0));\n  d = min(d,segment(p,q,R));\n  d = min(d,segment(p,Q,R1));\n  d = min(d,segment(p,q1,r));\n  \n  // Next seven are just drawn as lines to fill in some\n  // gaps, we don't use these segments as boundaries.\n  d = min(d,segment(p,r0,Q0));\n  d = min(d,segment(p,r0,q0+vec2(2.0*a.x,0)));\n  d = min(d,segment(p,Q0,R0+vec2(2.0*a.x,0)));\n\n  d = min(d,segment(p,q0,R0-vec2(0,2.0*a.y)));\n  d = min(d,segment(p,q0,r0-vec2(2.0*a.x,0)));\n\n  d = min(d,segment(p,R0,q0+vec2(0,2.0*a.y)));\n  d = min(d,segment(p,R0,Q0-vec2(2.0*a.x,0)));\n  \n  // Check for which region p is in. There are\n  // some redundant calls to wind() here (since\n  // wind(p,q,r) = -wind(p,r,q), more or less).\n  int k = wind(p,r0,r)+wind(p,r,q1);\n  if (k > 0) ix += inc*ivec2(1,-1);\n  k = wind(p,q1,r)+wind(p,r,q)+wind(p,q,q0);\n  if (k > 0) ix.y -= inc.y;\n  k = wind(p,q0,q)+wind(p,q,R)+wind(p,R,R0);\n  if (k > 0) ix.x -= inc.x;\n  k = wind(p,R0,R)+wind(p,R,Q)+wind(p,Q,R1);\n  if (k > 0) ix.y += inc.y;\n  k = wind(p,R1,Q)+wind(p,Q,Q0);\n  if (k > 0) ix += inc;\n\n  vec3 col = vec3(1,1,0.8);\n  float h = rand(ix); // float(ix.x+ix.y)/32.0;\n  if (!key(CHAR_C)) col = hsv2rgb(h,0.4,1.0);\n\n  if (key(CHAR_P) && parity) col *= 0.9;\n  col *= smoothstep(0.0,px,d-0.01);\n  if (key(CHAR_G)) {\n    vec2 tmp = min(p,a-p);\n    col *= smoothstep(0.0,px,vmin(min(p,a-p)));\n  }\n  if (!key(CHAR_X)) {\n    // Show the control points\n    float d = 1e8;\n    vec2 p = map(fragCoord);\n    d = min(d,distance(p,a));\n    d = min(d,distance(p,q));\n    d = min(d,distance(p,r));\n    col *= smoothstep(0.0,px,d-0.06);\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat scale = 2.0;\n\nconst float PI = 3.1415927;\n\n#define map(screen) (scale*(2.0*screen-iResolution.xy)/iResolution.y)\n\nint nselections = 3;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(1.5,1);\n  if (i == 1) return vec2(1.0,0.5);\n  if (i == 2) return vec2(1.0,-0.4);\n  return vec2(0);\n}\n\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define setscale() (scale *= !key(CHAR_Z) ? 1.0 : 2.0)\n#define setscale() \\\n  (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))), \\\n   scale *= key(CHAR_Z) ? 2.0 : 4.0)\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);       \n  return v * mix(vec3(1.0),rgb,s);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nint idiv(int a,int b) {\n  return a >= 0 ? a/b : -((-a+b-1)/b);\n}\n\nint imod(int a, int b) {\n  int d = idiv(a,b);\n  return a-d*b;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "buffer_a_code": "#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.xyz = vec3(initselection(i-1),1234); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cl33Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1875, 1899, 1934, 1934, 1956], [1958, 1987, 2016, 2016, 2050], [2052, 2052, 2086, 2121, 2323], [2325, 2325, 2345, 2345, 2370], [2372, 2372, 2424, 2424, 5504]], "test": "untested"}
{"id": "cdcBDX", "name": "2D analytical AA", "author": "FordPerfect", "description": "Exact solution to \"square-halfplane\" coverage, plus some approximations.\nClick on colored circle to select a function.\nHold the mouse button to see a (scaled) plot of the error, rather than of the function itself.\nPlots are for 0° to 45° in 5° intervals.", "tags": ["antialiasing", "coverage"], "likes": 13, "viewed": 295, "published": 3, "date": "1697674913", "time_retrieved": "2024-07-30T17:27:03.153578", "image_code": "// Public Domain under http://unlicense.org, see link for details.\n\n// Consider the following problem: \"what fraction of [-1;+1]x[-1;+1] square\n// is covered by A*x+B*y+C>=0 halfplane?\". Assuming, without loss of\n// generality, that A>=B>=0, the exact solution is:\n//     0                   , if C<=-(A+B)\n//     (A+B+C)^2/(8*A*B)   , if -(A+B)<=C<=-(A-B)\n//     0.5+0.5*C/max(A,B)  , if |C|<=(A-B)\n//     1-(A+B-C)^2/(8*A*B) , if +(A-B)<=C<=+(A+B)\n//     1                   , if C>=+(A+B)\n// Note that coverage(A,B,C)=coverage(B,A,C)=coverage(-A,B,C)=coverage(A,-B,C)=1-coverage(A,B,-C).\n//\n// You can use this to approximate anti-aliasing for some SDF-like function.\n// If you know function f() and its derivatives f'x() and f'y() (or can\n// approximate them), then the part of a rectangle (\"pixel\") [x-w/2;x+w/2]*[y-h/2;y+h/2],\n// covered by f(x)<0 can be approximated as the above problem with\n//     A=w*f'x(x,y)\n//     B=h*f'y(x,y)\n//     C=-2*f(x,y)\n//\n// Of course, you are not *required* to do the anti-aliasing this way. E.g using\n// gaussian (i.e. erf) has its appeal (despite infinite support).\n//\n// Accuracy of some approximations (see https://godbolt.org/z/z38xPesd3):\n//   Linf     - infiniy norm (i.e. max. abs. error)\n//   RMS      - root mean square error\n//   Inside   - max. error when wrongly returning {0,1}\n//   Outside  - max. error when wrongly returning (0;1)\n// Note: A, B, C are uniformly distributed in [-1;+1]x[-1;+1]x[-sqrt(2);+sqrt(2)].\n// This affects computed RMS.\n// | Color     | Function            | Linf        | RMS         | Inside      | Outside     |\n// |-----------|---------------------|-------------|-------------|-------------|-------------|\n// | Gray      |cov_exact            |  0.00000000 |  0.00000000 |  0.00000000 |  0.00000000 |\n// |           |cov_msaa< 1>         |  0.49999636 |  0.20408611 |  0.49999636 |  0.00000000 |\n// | Violet    |cov_msaa< 2>         |  0.24952590 |  0.07040552 |  0.24723244 |  0.00000000 |\n// |           |cov_msaa< 4>         |  0.12452590 |  0.02481787 |  0.12280673 |  0.00000000 |\n// |           |cov_msaa< 8>         |  0.06172752 |  0.00875571 |  0.06071138 |  0.00000000 |\n// |           |cov_msaa<16>         |  0.03047752 |  0.00309934 |  0.02749920 |  0.00000000 |\n// |           |cov_msaa<32>         |  0.01511553 |  0.00110750 |  0.01278222 |  0.00000000 |\n// |           |cov_msaa<64>         |  0.00719970 |  0.00038004 |  0.00280529 |  0.00000000 |\n// | Cyan      |cov_step             |  0.49999636 |  0.20408611 |  0.49999636 |  0.00000000 |\n// | Yellow    |cov_lin              |  0.12499946 |  0.06321841 |  0.00000000 |  0.00000000 |\n// | Pink      |cov_smooth           |  0.09602143 |  0.02111146 |  0.00000000 |  0.00000000 |\n// | Blue      |cov_mix              |  0.03703614 |  0.01561240 |  0.00000000 |  0.00000000 |\n// | Green     |cov_sqrt             |  0.04289210 |  0.01701449 |  0.04265356 |  0.00000000 |\n// | Magenta   |cov_smoothsqrt       |  0.03111339 |  0.00881568 |  0.00494635 |  0.03111339 |\n// | Orange    |cov_erf              |  0.04798281 |  0.01579871 |  0.00000000 |  0.04736865 |\n// |           |cov_tanh             |  0.05639169 |  0.02119081 |  0.00000000 |  0.05517477 |\n// |           |cov_atan             |  0.09770226 |  0.05461564 |  0.00000000 |  0.09770226 |\n// | L. blue   |cov_si               |  0.08948976 |  0.04159512 |  0.00000000 |  0.08948976 |\n\n//==============================================================================\n// Some constants and special functions.\n\n#define pi 3.14159265358979\n\n// From Abramowitz and Stegun. Max. abs. error ~5e-4,\n// which is somewhat better than https://www.shadertoy.com/view/7dXXDN\n// which has max. abs. error ~3.6e-3 using Bürmann series.\nfloat erf(float x)\n{\n    float y=abs(x),t=1.0+y*(0.278393+y*(0.230389+y*(0.000972+y*0.078108)));\n    return sign(x)*(1.0-1.0/((t*t)*(t*t)));\n}\n\n// From Abramowitz & Stegun.\n// Max. abs. error ~1e-6.\nfloat Si(float x)\n{\n    // Adapted from https://github.com/GalSim-developers/GalSim/blob/releases/2.5/src/math/Sinc.cpp\n    // NOTE: this is based on #ifdef'd out version.\n    float x2=x*x;\n    if(x2<1.0) return x*(1.0+x2*(-0.0555555556+x2*(0.00166666667+x2*-2.83446712e-05)));\n    return ((pi/2.0)*((x>0.0)?1.0:-1.0)\n        - (38.102495+x2*(335.677320+x2*(265.187033+x2*(38.027264+x2))))\n        / (x*(157.105423+x2*(570.236280+x2*(322.624911+x2*(40.021433+x2)))))*cos(x)\n        - (21.821899+x2*(352.018498+x2*(302.757865+x2*(42.242855+x2))))\n        / (x2*(449.690326+x2*(1114.978885+x2*(482.485984+x2*(48.196927+x2)))))*sin(x));\n}\n\n//==============================================================================\n// Coverage functions.\n\nfloat cov_exact(float A,float B,float C)\n{\n    A=abs(A);B=abs(B);\n    float s=A+B,d=abs(A-B),m=abs(C);\n    if     (m<=d) return 0.5+0.5*C/max(A,B);\n    else if(m>=s) return step(0.0,C);\n    else          return abs(step(0.0,C)-(s-m)*(s-m)/(8.0*A*B));\n}\n\n#define MSAA 2\nfloat cov_msaa(float A,float B,float C)\n{\n    float ret=0.0;\n    for(int i=0;i<MSAA;++i) for(int j=0;j<MSAA;++j)\n    {\n        float x=2.0*(float(i)+0.5)/float(MSAA)-1.0;\n        float y=2.0*(float(j)+0.5)/float(MSAA)-1.0;\n        ret+=step(0.0,A*x+B*y+C);\n    }\n    return ret/float(MSAA*MSAA);\n}\n\nfloat cov_step(float A,float B,float C)\n{\n    return step(0.0,C);\n}\n\nfloat cov_lin(float A,float B,float C)\n{\n    return clamp(0.5*(1.0+C/(abs(A)+abs(B))),0.0,1.0);\n}\n\nfloat cov_smooth(float A,float B,float C)\n{\n    return smoothstep(-1.0,1.0,C/(abs(A)+abs(B)));\n}\n\n// This is mix(smooth,lin,factor).\nfloat cov_mix(float A,float B,float C)\n{\n#if 0\n    // 2-division version.\n    // NOTE: we would need an extra abs, if we were raising\n    // m to an odd power. Powers 2 (which we use), 3, and 4\n    // give about equal accuracy.\n    float s=abs(A)+abs(B),t=clamp(C/s,-1.0,+1.0),m=(abs(A)-abs(B))/s;\n    t*=1.0+0.5*(1.0-t*t)*(1.0-m*m);\n    return 0.5+0.5*t;\n#else\n    // 1-division version.\n    // May overflow/underflow for |A|,|B| outside of [1e-6,1e+6].\n    // May be slightly more accurate near |C|=|A|+|B|.\n    float s=abs(A)+abs(B),s2=s*s,s4=s2*s2,c=clamp(C,-s,+s);\n    return (s+c)*(0.5*s4+c*(s-c)*abs(A*B))/(s4*s);\n#endif\n}\n\nfloat cov_sqrt(float A,float B,float C)\n{\n    return clamp(0.5*(1.0+C/sqrt(A*A+B*B)),0.0,1.0);\n}\n\nfloat cov_smoothsqrt(float A,float B,float C)\n{\n    // NOTE: the factor is (probably) 2/pi in terms\n    // of pixel distance, but since we work in\n    // terms of on 2x2 square ([-1;+1]x[-1;+1]),\n    // it is doubled.\n    float d=4.0/pi;\n    return smoothstep(-d,+d,C/sqrt(A*A+B*B));\n}\n\n// NOTE: tanh and atan are similar to erf,\n// but have worse max. error.\nfloat cov_erf(float A,float B,float C)\n{\n#if 1\n    // Constant numerically tuned to minimize Linf error.\n    return 0.5+0.5*erf(1.1765*C/sqrt(A*A+B*B));\n#else\n    // Linf error is ~7.8% vs ~4.8% for the above version.\n    // NOTE: 0.5+0.5*tanh(sqrt(2.0)*C/sqrt(A*A+B*B)) is ~5.7%.\n    return 0.5+0.5*erf(C/sqrt(A*A+B*B));\n#endif\n}\n\nfloat cov_si(float A,float B,float C)\n{\n    // NOTE: We work in terms of on 2x2 square ([-1;+1]x[-1;+1]),\n    // so the radius is doubled.\n    float R=2.0;\n    float d=C/sqrt(A*A+B*B);\n    return 0.5+Si(pi*d/R)/pi;\n}\n\n//==============================================================================\n// Dispatcher\n\nfloat coverage(float A,float B,float C,int id)\n{\n    switch(id)\n    {\n        case 0: return cov_exact     (A,B,C);\n        case 1: return cov_msaa      (A,B,C);\n        case 2: return cov_step      (A,B,C);\n        case 3: return cov_lin       (A,B,C);\n        case 4: return cov_smooth    (A,B,C);\n        case 5: return cov_mix       (A,B,C);\n        case 6: return cov_sqrt      (A,B,C);\n        case 7: return cov_erf       (A,B,C);\n        case 8: return cov_smoothsqrt(A,B,C);\n        case 9: return cov_si        (A,B,C);\n#define NUM_CASES 10 // Need to update when adding new functions!\n    }\n    return 0.0;\n}\n\n//==============================================================================\n// Helper functions\n\nvec3 linear2srgb(vec3 rgb)\n{\n    return mix(12.92*rgb,1.055*pow(rgb,vec3(1.0/2.4))-0.055,step(0.0031308,rgb));\n}\n\nvec3 palette(int id)\n{\n    return id==0?vec3(0.5):0.5+0.5*cos(8.0*float(id)+vec3(0.0,2.0,4.0));\n}\n\n//==============================================================================\n// Main program\n\n// Returns function in z, and derivatives in xy.\nvec3 f(vec2 d)\n{\n    float l=length(d);\n    float D=2.0,R=16.0;\n    return vec3(\n        2.0*d-2.0*R*normalize(d),\n        (l-(R-0.5*D))*(l-(R+0.5*D)));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    float W=iResolution.x;\n    float H=iResolution.y;\n    float M=max(W-H,0.25*H);\n    float R=10.0;\n    float G=1.0/32.0;\n    float S=8.0;\n    float D=(W-M)/float(NUM_CASES);\n    int id=int(abs(iMouse.x)/D)%NUM_CASES;\n    vec2 uv=fragCoord.xy/H;\n    vec2 xy=(floor(H*(2.0*uv-1.0)/(2.0*S))+0.5);\n    vec2 c=R*vec2(cos(0.73*iTime),sin(0.37*iTime));\n    vec2 d=xy-c;\n    vec3 F=f(d);\n    float A=F.x,B=F.y,C=-2.0*F.z;\n    float a=coverage(A,B,C,id);\n    vec3 color=vec3(a);\n    color.g+=G*step(1.0,mod(xy.x+xy.y,2.0))*exp(-16.0*(S*S/(H*H))*dot(xy,xy));\n    if(uv.x*H<W-M&&uv.y*H<D)\n    {\n        float x=uv.x/((W-M)/H),y=uv.y/(D/H);\n        x*=float(NUM_CASES);\n        int idx=int(x);\n        x=fract(x);\n        vec2 d=D*(2.0*vec2(x,y)-1.0)-c;\n        vec3 F=f(d);\n        float A=F.x,B=F.y,C=-2.0*F.z;\n        float a=coverage(A,B,C,idx);\n        color=mix(color,palette(idx),a);\n        if(id==idx) color=mix(color,palette(idx),exp(-0.25*D*D*x*(1.0-x)*y*(1.0-y)));\n    }\n    if(uv.x*H>W-M)\n    {\n        float angle=(3.14159265358979/4.0)*(floor(10.0*uv.y)/10.0);\n        float A=cos(angle),B=sin(angle);\n        float e=0.1;\n        float x=(H*uv.x-(W-M))/M,y=fract(10.0*uv.y)*(1.0+2.0*e)-e;\n        float h=0.1*H/M;\n        x=(1.0+h)*x-h;\n        if(x>=0.0)\n        {\n            float v0=cov_exact(A,B,sqrt(2.0)*(2.0*x-1.0))-y;\n            float v1=coverage(A,B,sqrt(2.0)*(2.0*x-1.0),id)-y;\n            float v=0.5+5.0*(v1-v0)-y;\n            if(y>=0.0&&y<=1.0) color=mix(color,vec3(0.125),0.75);\n            if(sign(iMouse.z)<0.0)\n                color+=exp(-1e-2*H*H*v1*v1)*palette(id)+exp(-1e-2*H*H*v0*v0)*0.5;\n            else\n                color+=exp(-1e-2*H*H*v*v)*palette(id);\n        }\n        else\n        {\n            x=x/h+1.0;\n            x=(2.0*x-1.0)/(1.0+e);\n            y=2.0*y-1.0;\n            if(abs(x)<1.0&&abs(y)<1.0)\n            {\n                color=mix(color,vec3(0.25+0.5*step(A*x+B*y,0.0)),0.75*exp(-2.0*(x*x+y*y)));\n            }\n        }\n    }\n    color=linear2srgb(color);\n    fragColor=vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcBDX.jpg", "access": "api", "license": "public-domain", "functions": [[3555, 3740, 3760, 3760, 3882], [3884, 3939, 3958, 4110, 4574], [4681, 4681, 4723, 4723, 4933], [5249, 5249, 5290, 5290, 5316], [5318, 5318, 5358, 5358, 5415], [5417, 5417, 5460, 5460, 5513], [5515, 5550, 5590, 5590, 6179], [6181, 6181, 6222, 6222, 6277], [6279, 6279, 6326, 6496, 6564], [6566, 6639, 6679, 6679, 6969], [6971, 6971, 7010, 7109, 7187], [7285, 7285, 7333, 7333, 7904], [8008, 8008, 8036, 8036, 8120], [8122, 8122, 8144, 8144, 8219], [8319, 8368, 8384, 8384, 8522], [8524, 8524, 8578, 8578, 10622]], "test": "untested"}
{"id": "csdfD2", "name": "Anisotropic surface reconstruct", "author": "michael0884", "description": "https://cs.nyu.edu/exact/doc/anisotropic.pdf\nThis is the method Nvidia used for their Physics liquid sims. Unfortunately my implementation is a bit janky and quite slow too. :sad:", "tags": ["particle", "sph"], "likes": 138, "viewed": 4460, "published": 3, "date": "1697668273", "time_retrieved": "2024-07-30T17:27:04.146921", "image_code": "// Fork of \"3D Water Box\" by michael0884. https://shadertoy.com/view/dscfRf\n// 2023-10-16 20:53:25\n\n#define SHADOWS \n#define REFRACT\n#define REFLECT\n\nconst vec3 light = 2.0*vec3(1.0,1.0,1.0);\nconst vec3 absorb = vec3(0.584,0.843,0.953);\nconst vec3 albedo = vec3(0.000,0.000,0.000);\nconst vec3 F0 = vec3(0.05);\nconst float roughness = 0.065;\n\n#define RADIUS 0.8\n#define NORMAL_SMOOTHNESS 0.72\n\n#define FOV 3.\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nvec3 qrot(vec3 x, vec4 q)\n{\n    return x + 2.0 * cross(cross(x, q.xyz) + q.w * x, q.xyz);\n}\n\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvec4 conj_q(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvoid iEllipsoid(inout Ray ray, in vec3 p, in vec3 r, in vec4 q)\n{\n    vec3 ro = ray.ro - p;\n    ro = qrot(ro, conj_q(q));\n    vec3 rd = qrot(ray.rd, conj_q(q));\n    \n    vec3 r2 = r*r;\n    float a = dot( rd, rd/r2 );\n\tfloat b = dot( ro, rd/r2 );\n\tfloat c = dot( ro, ro/r2 );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return;\n    \n\tfloat t = (-b - sqrt( h ))/a;\n    if(t >= ray.td || t < 0.0) return;\n    ray.normal = qrot(normalize( (ro + t * rd)/r2 ), q);\n    ray.color = vec3(1.);\n    ray.td = t;\n}\n\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    vec4 packed = LOAD3D(ch0, p);\n    Particle p0, p1;\n    unpackParticles(packed, p, p0, p1);\n    \n    if(p0.mass + p1.mass == 0u) return;\n    Covariance c0, c1;\n    unpackCovariance(LOAD3D(ch2, p), c0, c1);\n\n    if(p0.mass > 0u) iEllipsoid(ray, p0.pos, RADIUS*c0.s, c0.q);\n    if(p1.mass > 0u) iEllipsoid(ray, p1.pos, RADIUS*c1.s, c1.q);\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec4 rho = voxel(ch1, p);\n    if(rho.z < 1e-3) return;\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\n\nfloat Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n\n\n#define ISO_VALUE 0.2\n#define STEP_SIZE 1.0\n#define IOR 1.333\n\nvec3 refractFull(vec3 rd, vec3 n, float ior)\n{\n    vec3 refr = refract(rd, n, ior);\n    if(length(refr) < 0.5)\n    {\n        return reflect(rd, n);\n    }\n    else return refr;\n}\n\nfloat TraceDensity(vec3 ro, vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    for(int i = 0; i < 40; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(1.0))) || any(greaterThan(p, size3d - 1.0))) return dens;\n        float d = Density(p);\n        dens += d * 4.0;\n        td += 4.0;\n    }\n    return dens;\n}\n\n\nfloat TraceDensityMedium(vec3 ro, inout vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    float de = 0.0;\n    float pde = 0.0;\n    bool bounced = false;\n    for(int i = 0; i < 60; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(0.0))) || any(greaterThan(p, size3d))) return dens;\n        float ldens = Density(p);\n        float d = smoothstep(ISO_VALUE*0.9, ISO_VALUE*1.1, ldens);\n        dens += d * STEP_SIZE;\n        pde = de;\n        de = ldens - ISO_VALUE;\n        if(pde > 0.0 && de < 0.0 && !bounced && td > 4.0)\n        {\n            float std = td - STEP_SIZE*(de/(de-pde));\n            vec3 sp = ro + rd*std;\n            vec3 normal = normalize(calcNormal(sp, 0.5).xyz);\n            ro = sp;\n            rd = refractFull(rd, normal, IOR);\n            td = 0.0;\n            bounced = true;\n        }\n        td += STEP_SIZE;\n    }\n    return dens;\n}\n\n\nvec3 Background(vec3 rd)\n{\n    vec3 col = texture(iChannel3,  rd.yzx).xyz;\n    return 2.0*pow(col, vec3(2.0)) + col*exp(15.0*(length(col) - 1.45));\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*sqr( sqr(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\n\nvec3 PBR(vec3 P, vec3 V, vec3 L, vec3 Lcol, vec3 N, vec3 color, vec3 absorb)\n{\n    vec3 Re = reflect(-V, N);\n    vec3 Rf = refract(-V, N, 1.0/1.33);\n    vec3 H = normalize(V + L);\n    float NdotL = max(dot(N, L), 2e-3);\n    float NdotV = max(dot(N, V), 2e-3);\n\n    #ifdef SHADOWS\n    float dens = TraceDensity(P+L*2.0, L);\n    float shadow = exp(-dens);\n    float ambient = 0.4*exp(-0.3*dens) + 0.1*exp(-0.1*dens) + 0.05*exp(-0.05*dens);\n    #else\n    float shadow = 1.0;\n    float ambient = 0.3;\n    #endif\n    \n    #ifdef REFRACT\n    float refrDens = TraceDensityMedium(P, Rf);\n    vec3 refraction = Background(Rf) * exp(-0.5*refrDens*(1.0 - absorb));\n    #else\n    vec3 refraction = vec3(0.0);\n    #endif\n    \n    #ifdef REFLECT\n    float reflDens = TraceDensity(P, Re);\n    vec3 reflection = Background(Re) * exp(-0.5*reflDens*(1.0 - absorb));\n    #else\n    vec3 reflection = (1.0 - roughness)*Background(Re);\n    #endif\n    \n    float selfshadow = G_ggx(NdotL,roughness)*G_ggx(NdotV,roughness)/max(4.0*NdotL*NdotV,1e-3);\n    float specular = selfshadow*NDF_ggx(H, N, roughness) * NdotL;\n    \n    vec3 Lbright = shadow * Lcol;\n    \n    vec3 refr = Lbright * color * NdotL / PI + refraction;\n    vec3 relf = Lbright * specular + reflection;\n    vec3 ambi = ambient * color * (0.7*NdotL + 0.3);\n    \n    vec3 kS = fresnel(V, N, F0);\n    vec3 kD = 1.0 - kS;\n    return (ambi + refr) * kD + relf * kS;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{    \n    InitGrid(iResolution.xy);\n    \n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.04 + 0.05*iTime, -0.5);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.4;\n    vec3 ro = vec3(size3d)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n\n    vec2 tdBox = iBox(ro - vec3(size3d)*0.5, rd, 0.5*vec3(size3d));\n    col.xyz = Background(rd);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x+0.5, 0.0);\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n        int i = 0;\n        bool stop = false;\n        for(; i < 200; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n            td += 1.5;\n            if(td > tdBox.y-1.0)\n            {\n                break;\n            }\n            if(stop) break;\n            if(ray.td < tdBox.y-1.0)\n            {\n                stop = true;\n            }\n        }\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal1 = normalize(calcNormal(p0, 0.5).xyz);\n            vec3 normal =  -normalize(mix(-ray.normal, normal1, NORMAL_SMOOTHNESS));\n            \n            col.xyz = PBR(p0, -ray.rd, light_dir, light, normal, albedo, absorb);\n        }\n    }\n    \n    col.xyz = 1.0 - exp(-2.5*pow(col.xyz,vec3(1.0/1.3)));\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define R iResolution.xy\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.741,1.000,0.580))\n\n#define initial_particle_density 1u\n#define dt 1.\n#define rest_density 0.5\n#define gravity 0.01\n\n#define PRESSURE 2.5\n#define PRESSURE_RAD 0.85\n#define VISCOSITY 0.65\n#define SPIKE_KERNEL 0.5\n#define SPIKE_RAD 0.75\n#define force_boundary 5.0\n#define max_velocity 1.0\n\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\nfloat cub(float x)\n{\n    return x*x*x;\n}\n\nfloat Pressure(float rho)\n{\n    return (rho/rest_density - 1.0)/max(rho*rho, 0.001);\n}\n\nfloat Gaussian(float r, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    return norm * exp(-0.5*sqr(r/d));\n}\n\nvec3 GaussianGrad(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return - (norm/sqr(d)) * exp(-0.5*sqr(r/d)) * dx;\n}\n\nvec4 GaussianGrad2(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return norm * exp(-0.5*sqr(r/d)) * vec4(-dx /sqr(d), 1.0);\n}\n\n#define KERNEL_POLY6_NORMALIZATION (315.0 / (64.0 * PI))\n#define KERNEL_SPIKE_NORMALIZATION (45 / PI)\n#define KERNEL_RADIUS 1.0\n\nfloat KernelPoly6(float r, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    return (r <= d) ? c * cub(sqr(d) - sqr(r)) : 0.0;\n}\n\nvec3 KernelPoly6Grad(vec3 dx, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    float r = length(dx);\n    return (r <= d) ? clamp(-6.0 * c * sqr(sqr(d) - sqr(r)), -3.0, 0.0) * dx : vec3(0.0);\n}\n\n#define GD(x, R) Gaussian(length(x),R)\n#define GGRAD(x, R) GaussianGrad(x, R)\n#define GGRAD2(x,R) GaussianGrad2(x, R)\n//#define GD(x, R) 12.0*KernelPoly6(length(x),R*4.0/2.0)\n//#define GGRAD(x, R) 12.0*KernelPoly6Grad(x, R*4.0/2.0)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//3d slice aspect ratio \n#define ar vec2(1.0,0.5)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    p3d = clamp(p3d, vec3(0.0), size3d);\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\n//#define pixel(a, p, s) texture(a, (p+0.5)/vec2(s))\n\nvec4 pixel(sampler2D ch, vec2 pos)\n{\n    vec2 d = pos - floor(pos);\n    vec4 p00 = texelFetch(ch, ivec2(pos), 0);\n    vec4 p01 = texelFetch(ch, ivec2(pos) + ivec2(0, 1), 0);\n    vec4 p10 = texelFetch(ch, ivec2(pos) + ivec2(1, 0), 0);\n    vec4 p11 = texelFetch(ch, ivec2(pos) + ivec2(1, 1), 0);\n    return mix(mix(p00, p01, d.y), mix(p10, p11, d.y), d.x);\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 udir(vec2 rng)\n{\n    float phi = 2.*PI*rng.x;\n    float ctheta = 2.*rng.y-1.;\n    float stheta = sqrt(1.0-ctheta*ctheta);\n    return vec3(cos(phi)*stheta, sin(phi)*stheta, ctheta);\n}\n\nstruct Covariance\n{\n    vec4 q;\n    vec3 s;\n};\n\nstruct Particle \n{\n    uint mass;\n    vec3 pos;\n    vec3 vel;\n    vec3 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    uvec3 sv = uvec3(round(clamp(v*scale, -1.0, 1.0) * 255.0) + 255.0);\n    uint packed = uint(exp + 15) | (sv.x << 5) | (sv.y << 14) | (sv.z << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nuint packmasspos(uint mass, vec3 p0)\n{\n    uvec3 pos0 = uvec3(clamp(p0, 0.0, 1.0) * 255.0);\n    return mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n}\n\nuint packMassPos(uint mass, vec3 pos)\n{\n    uvec3 pos0 = uvec3(clamp(pos, 0.0, 1.0) * 255.0); // Assuming pos range [0, 1] in a cell\n    uint data1 = mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n    return data1;\n}\n\nvoid unpackMassPos(uint packed, out uint mass, out vec3 pos)\n{\n    mass = packed & 0xFFu;\n    uvec3 pos0 = uvec3((packed >> 8) & 0xFFu, (packed >> 16) & 0xFFu, (packed >> 24) & 0xFFu);\n    pos = vec3(pos0) / 255.0;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec3 pos)\n{\n    p0.pos -= pos;\n    p1.pos -= pos;\n\n    uvec4 data = uvec4(\n        packMassPos(p0.mass, p0.pos),\n        packMassPos(p1.mass, p1.pos),\n        packvec3(p0.vel),\n        packvec3(p1.vel)\n    );\n\n    return uintBitsToFloat(data);\n}\n\nvoid unpackParticles(vec4 packed, vec3 pos, out Particle p0, out Particle p1)\n{\n    uvec4 data = floatBitsToUint(packed);\n    \n    unpackMassPos(data.x, p0.mass, p0.pos);\n    unpackMassPos(data.y, p1.mass, p1.pos);\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    p0.vel = unpackvec3(data.z);\n    p1.vel = unpackvec3(data.w);\n}\n\nvec3 quaternionAxis(vec4 q)\n{\n    return normalize(q.xyz);\n}\n\nfloat quaternionAngle(vec4 q)\n{\n    return atan(length(q.xyz), q.w) * 2.0;\n}\n\nvec3 quaternionToAxisAngle(vec4 q)\n{\n    return quaternionAxis(q) * quaternionAngle(q);\n}\n\nvec4 axisAngleToQuaternion(vec3 aa)\n{\n    float angle = length(aa);\n    vec3 axis = normalize(aa);\n    return vec4(axis * sin(angle * 0.5), cos(angle * 0.5));\n}\n\nvec4 packCovariance(Covariance c0, Covariance c1)\n{\n    uvec4 data;\n    data.x = packvec3(c0.s);\n    data.y = packvec3(quaternionToAxisAngle(c0.q));\n    data.z = packvec3(c1.s);\n    data.w = packvec3(quaternionToAxisAngle(c1.q));\n\n    return uintBitsToFloat(data);\n}\n\nvoid unpackCovariance(vec4 fdata, out Covariance c0, out Covariance c1)\n{\n    uvec4 data = floatBitsToUint(fdata);\n    c0.s = unpackvec3(data.x);\n    c0.q = axisAngleToQuaternion(unpackvec3(data.y));\n    c1.s = unpackvec3(data.z);\n    c1.q = axisAngleToQuaternion(unpackvec3(data.w));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec3 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    vec3 pos = p1.pos;\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec3 dir = udir(hash23(pos));\n    p1.pos = pos - dir*5e-3;\n    p2.pos = pos + dir*5e-3;\n    p2.vel = p1.vel;\n}\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    if(incoming.mass == 0u || p.mass == 0u) return;\n\n    vec3 dx = incoming.pos - p.pos;\n    vec3 ggrad = GGRAD(dx, PRESSURE_RAD);\n    if(length(ggrad) < 1e-5) return;\n    \n    vec3 dv = incoming.vel - p.vel;\n    float d = length(dx);\n    vec3 dir = dx / max(d, 1e-3);\n    \n    float rho0 = p.density;\n    float rho1 = incoming.density;\n    float mass0 = float(p.mass);\n    float mass1 = float(incoming.mass);\n  \n    \n    float pressure = 0.5*p.density*(Pressure(p.density) + Pressure(incoming.density));\n    vec3 F_SPH = - PRESSURE * pressure * ggrad;\n    vec3 F_VISC = VISCOSITY * dot(dir, dv) * ggrad;\n    vec3 F_SPIKE = SPIKE_KERNEL * GD(d, SPIKE_RAD) * dir;\n   \n    p.force += - (F_SPH + F_VISC + F_SPIKE) * mass1;\n    \n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid IntegrateParticle(inout Particle p, vec3 pos, vec2 iR, vec4 iM, float time)\n{\n    if(p.mass == 0u) return;\n    p.force = p.force;/// max(0.0001, float(p.mass));\n    p.force += gravity*vec3(0.4*sin(1.5*time), 0.2*cos(0.75*time), -1.0); //gravity\n    \n\n    vec4 border = border_grad(p.pos);\n    vec3 bound =5.*normalize(border.xyz)*exp(-0.3*border.w*border.w);\n    p.force += force_boundary*bound*dt;\n    //p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    //if(iM.z > 0.)\n    //{\n    //    vec3 dx = pos - vec3(iM.xy, 0.0);\n    //    p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    //}\n        \n    p.vel += p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}\n\nvoid InitGrid(vec2 iR)\n{\n    SCALE = floor(ar*pow(iR.x*iR.y,0.1666666));\n    size3d = vec3(floor(iR.xy/SCALE), SCALE.x*SCALE.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1;\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 pos1 = pos + vec3(i, j, k);\n        if(!all(lessThanEqual(pos1, size3d)) || !all(greaterThanEqual(pos1, vec3(0.0))))\n        {\n            continue;\n        }\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming, float rad)\n{\n    if(incoming.mass == 0u) return;\n    float d = distance(p.pos, incoming.pos);\n    float mass = float(incoming.mass);\n    p.density += mass*GD(d,rad);\n}\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        if(i == 0 && j == 0 && k == 0) continue;\n        vec3 pos1 = pos + vec3(i, j, k);\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n        if(p0.mass > 0u)\n        {\n            AddDensity(p0, p0_, KERNEL_RADIUS);\n            AddDensity(p0, p1_, KERNEL_RADIUS);\n        }\n        if(p1.mass > 0u)\n        {\n            AddDensity(p1, p0_, KERNEL_RADIUS);\n            AddDensity(p1, p1_, KERNEL_RADIUS);\n        }\n        \n        AddDensity(pV, p0_, 1.0);\n        AddDensity(pV, p1_, 1.0);\n    }\n\n    if(p0.mass > 0u)\n    {\n        AddDensity(p0, p0, KERNEL_RADIUS);\n        AddDensity(p0, p1, KERNEL_RADIUS);\n    }\n    if(p1.mass > 0u)\n    {\n        AddDensity(p1, p0, KERNEL_RADIUS);\n        AddDensity(p1, p1, KERNEL_RADIUS);\n    }\n    AddDensity(pV, p0, 1.0);\n    AddDensity(pV, p1, 1.0);\n\n    fragColor = vec4(p0.density, p1.density, pV.density, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define EMITTER_POS vec3(0.1,0.5,0.5)\n#define EMITTER_RAD 4.0\n#define EMITTER_VEL vec3(1.0, 0.0, 0.0)\n#define EMITTER_NUM 1\n\n#define VOID_POS vec3(0.8,0.5,0.1)\n#define VOID_RAD 12.0\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = voxel(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = voxel(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse, iTime);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse, iTime);\n        \n        if(isKeyPressed(KEY_UP))\n        {\n            float void_d = distance(p0.pos, size3d*VOID_POS);\n            if(void_d < VOID_RAD)\n            {\n                p0.mass = 0u;\n            }\n        }\n    \n        if(!isKeyPressed(KEY_LEFT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(dx.y, -dx.x, 0.0)*0.003;\n        }\n        \n        if(isKeyPressed(KEY_RIGHT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(-dx.y, dx.x, 0.0)*0.003;\n        }\n    }\n    \n        \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.4*size3d.x && pos.x > 0.0*size3d.x && \n           pos.y < 0.85*size3d.y && pos.y > 0.15*size3d.y &&\n           pos.z < 0.85*size3d.z && pos.z > 0.15*size3d.z)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos;\n        p0.vel = vec3(0.0);\n        p1.pos = pos;\n        p1.vel = vec3(0.0);\n    }\n\n    if(all(equal(p0.pos, p1.pos)))\n    {\n        p1.pos += 1e-2;\n    }\n    \n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tfloat emitter_d = distance(pos, size3d*EMITTER_POS);\n        if(emitter_d < EMITTER_RAD && int(pos.y) % 2 == 0 && int(pos.z) % 2 == 0 && int(pos.x) % 2 == 0)\n        {\n            Particle emit;\n            emit.pos = pos;\n            emit.mass = 1u;\n            emit.vel = EMITTER_VEL;\n            \n            BlendParticle(p0, emit);\n        }\n    }\n    \n        \n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#undef R\n\n\n#define GAMMA 5.8284271247\n#define C_STAR 0.9238795325\n#define S_STAR 0.3826834323\n#define SVD_EPS 0.0000001\n\nvec2 approx_givens_quat(float s_pp, float s_pq, float s_qq) {\n    float c_h = 2.0 * (s_pp - s_qq);\n    float s_h2 = s_pq * s_pq;\n    float c_h2 = c_h * c_h;\n    if (GAMMA * s_h2 < c_h2) {\n        float omega = 1.0f / sqrt(s_h2 + c_h2);\n        return vec2(omega * c_h, omega * s_pq);\n    }\n    return vec2(C_STAR, S_STAR);\n}\n\n// the quaternion is stored in vec4 like so:\n// (c, s * vec3) meaning that .x = c\nmat3 quat_to_mat3(vec4 quat) {\n    float qx2 = quat.y * quat.y;\n    float qy2 = quat.z * quat.z;\n    float qz2 = quat.w * quat.w;\n    float qwqx = quat.x * quat.y;\n    float qwqy = quat.x * quat.z;\n    float qwqz = quat.x * quat.w;\n    float qxqy = quat.y * quat.z;\n    float qxqz = quat.y * quat.w;\n    float qyqz = quat.z * quat.w;\n\n    return mat3(1.0f - 2.0f * (qy2 + qz2), 2.0f * (qxqy + qwqz), 2.0f * (qxqz - qwqy),\n        2.0f * (qxqy - qwqz), 1.0f - 2.0f * (qx2 + qz2), 2.0f * (qyqz + qwqx),\n        2.0f * (qxqz + qwqy), 2.0f * (qyqz - qwqx), 1.0f - 2.0f * (qx2 + qy2));\n}\n\nmat3 symmetric_eigenanalysis(mat3 A) {\n    mat3 S = transpose(A) * A;\n    // jacobi iteration\n    mat3 q = mat3(1.0f);\n    for (int i = 0; i < 5; i++) {\n        vec2 ch_sh = approx_givens_quat(S[0].x, S[0].y, S[1].y);\n        vec4 ch_sh_quat = vec4(ch_sh.x, 0, 0, ch_sh.y);\n        mat3 q_mat = quat_to_mat3(ch_sh_quat);\n        S = transpose(q_mat) * S * q_mat;\n        q = q * q_mat;\n\n        ch_sh = approx_givens_quat(S[0].x, S[0].z, S[2].z);\n        ch_sh_quat = vec4(ch_sh.x, 0, -ch_sh.y, 0);\n        q_mat = quat_to_mat3(ch_sh_quat);\n        S = transpose(q_mat) * S * q_mat;\n        q = q * q_mat;\n\n        ch_sh = approx_givens_quat(S[1].y, S[1].z, S[2].z);\n        ch_sh_quat = vec4(ch_sh.x, ch_sh.y, 0, 0);\n        q_mat = quat_to_mat3(ch_sh_quat);\n        S = transpose(q_mat) * S * q_mat;\n        q = q * q_mat;\n\n    }\n    return q;\n}\n\nvec2 approx_qr_givens_quat(float a0, float a1) {\n    float rho = sqrt(a0 * a0 + a1 * a1);\n    float s_h = a1;\n    float max_rho_eps = rho;\n    if (rho <= SVD_EPS) {\n        s_h = 0.0;\n        max_rho_eps = SVD_EPS;\n    }\n    float c_h = max_rho_eps + a0;\n    if (a0 < 0.0) {\n        float temp = c_h - 2.0 * a0;\n        c_h = s_h;\n        s_h = temp;\n    }\n    float omega = 1.0f / sqrt(c_h * c_h + s_h * s_h);\n    return vec2(omega * c_h, omega * s_h);\n}\n\nstruct QR_mats {\n    mat3 Q;\n    mat3 R;\n};\n\nQR_mats qr_decomp(mat3 B) {\n    QR_mats qr_decomp_result;\n    mat3 R;\n    // 1 0\n    // (ch, 0, 0, sh)\n    vec2 ch_sh10 = approx_qr_givens_quat(B[0].x, B[0].y);\n    mat3 Q10 = quat_to_mat3(vec4(ch_sh10.x, 0, 0, ch_sh10.y));\n    R = transpose(Q10) * B;\n\n    // 2 0\n    // (ch, 0, -sh, 0)\n    vec2 ch_sh20 = approx_qr_givens_quat(R[0].x, R[0].z);\n    mat3 Q20 = quat_to_mat3(vec4(ch_sh20.x, 0, -ch_sh20.y, 0));\n    R = transpose(Q20) * R;\n\n    // 2 1\n    // (ch, sh, 0, 0)\n    vec2 ch_sh21 = approx_qr_givens_quat(R[1].y, R[1].z);\n    mat3 Q21 = quat_to_mat3(vec4(ch_sh21.x, ch_sh21.y, 0, 0));\n    R = transpose(Q21) * R;\n\n    qr_decomp_result.R = R;\n\n    qr_decomp_result.Q = Q10 * Q20 * Q21;\n    return qr_decomp_result;\n}\n\nstruct SVD_mats {\n    mat3 U;\n    mat3 Sigma;\n    mat3 V;\n};\n\nSVD_mats svd(mat3 A) {\n    SVD_mats svd_result;\n    svd_result.V = symmetric_eigenanalysis(A);\n\n    mat3 B = A * svd_result.V;\n\n    // sort singular values\n    float rho0 = dot(B[0], B[0]);\n    float rho1 = dot(B[1], B[1]);\n    float rho2 = dot(B[2], B[2]);\n    if (rho0 < rho1) {\n        vec3 temp = B[1];\n        B[1] = -B[0];\n        B[0] = temp;\n        temp = svd_result.V[1];\n        svd_result.V[1] = -svd_result.V[0];\n        svd_result.V[0] = temp;\n        float temp_rho = rho0;\n        rho0 = rho1;\n        rho1 = temp_rho;\n    }\n    if (rho0 < rho2) {\n        vec3 temp = B[2];\n        B[2] = -B[0];\n        B[0] = temp;\n        temp = svd_result.V[2];\n        svd_result.V[2] = -svd_result.V[0];\n        svd_result.V[0] = temp;\n        rho2 = rho0;\n    }\n    if (rho1 < rho2) {\n        vec3 temp = B[2];\n        B[2] = -B[1];\n        B[1] = temp;\n        temp = svd_result.V[2];\n        svd_result.V[2] = -svd_result.V[1];\n        svd_result.V[1] = temp;\n    }\n\n    QR_mats QR = qr_decomp(B);\n    svd_result.U = QR.Q;\n    svd_result.Sigma = QR.R;\n    return svd_result;\n}\n\nstruct UP_mats {\n    mat3 U;\n    mat3 P;\n};\n\nUP_mats SVD_to_polar(SVD_mats B) {\n    UP_mats polar;\n    polar.P = B.V * B.Sigma * transpose(B.V);\n    polar.U = B.U * transpose(B.V);\n    return polar;\n}\n\nUP_mats polar_decomp(mat3 A) {\n    SVD_mats B = svd(A);\n    UP_mats polar;\n    polar.P = B.V * B.Sigma * transpose(B.V);\n    polar.U = B.U * transpose(B.V);\n    return polar;\n}\n\nvec3 safeDiv(vec3 a, vec3 b) {\n    return sign(b) * a / (abs(b) + 1e-4);\n}\n\nvec3 safeDiv(vec3 a, float b)\n{\n    return sign(b)* a / (abs(b) + 1e-4);\n}\n\nvec4 quaternion(vec3 axis, float angle) {\n    return vec4(axis * sin(angle * 0.5), cos(angle * 0.5));\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz), a.w * b.w - dot(a.xyz, b.xyz));\n}\n\nmat3 unit(float a) {\n    return mat3(a, 0, 0, 0, a, 0, 0, 0, a);\n}\n\nmat3 q2m(vec4 q) {\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a * q.w, v = q.xyx * a.xxy * q.w;\n    mat3 m = mat3(0, u.x, u.y, u.z, 0, v.x, v.y, v.z, 0) + unit(0.5) + outerProduct(q.xyz, q.xyz) * (1.0 - unit(1.0));\n    q *= q;\n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\nvec4 m2q(mat3 m) {\n    vec4 q;\n    q.w = sqrt(max(0.0, 1.0 + m[0][0] + m[1][1] + m[2][2])) / 2.0;\n    q.x = sqrt(max(0.0, 1.0 + m[0][0] - m[1][1] - m[2][2])) / 2.0;\n    q.y = sqrt(max(0.0, 1.0 - m[0][0] + m[1][1] - m[2][2])) / 2.0;\n    q.z = sqrt(max(0.0, 1.0 - m[0][0] - m[1][1] + m[2][2])) / 2.0;\n\n    q.x = abs(q.x) * sign(m[2][1] - m[1][2]);\n    q.y = abs(q.y) * sign(m[0][2] - m[2][0]);\n    q.z = abs(q.z) * sign(m[1][0] - m[0][1]);\n    \n    return q;\n}\n\nfloat KernelW(float r, float d)\n{\n    return (r>d)?0.0:(1.0 - cub(r/d));\n}\n\n\nvoid UpdateC(inout mat3 C, vec4 pos, Particle p, inout float N)\n{\n    if(p.mass == 0u) return;\n    \n\tvec3 dx = pos.xyz - p.pos;\n    float d = length(dx);\n    float mass = float(p.mass);\n    float K = mass * KernelW(d, 3.0);\n    if(K>0.0) N++;\n\tC += outerProduct(dx, dx) * K;\n}\n\nvoid UpdatePos(inout vec4 pos, Particle a, Particle p)\n{\n    if(a.mass == 0u || p.mass == 0u) return;\n\n    vec3 dx = a.pos - p.pos;\n    float d = length(dx);\n    float mass = float(p.mass);\n    float K = mass * KernelW(d, 3.0);\n    \n\tpos += K * vec4(p.pos, 1.0);\n}\n\n#define kr 4.0\n#define ks 1400.0\n#define kn 0.5\n#define Ne 6.0\n\nvec3 FixScale(vec3 scale, float N)\n{\n    if(N <= Ne) return kn*vec3(1.0);\n    scale.y = max(scale.y, scale.x/kr);\n    scale.z = max(scale.z, scale.x/kr);\n    return ks*scale;\n}\n\nCovariance GetCovariance(mat3 C, float N) {\n    Covariance cov;\n\n    SVD_mats svd = svd(C);\n    //get rotaion\n    cov.q = m2q(svd.U);\n    //get scale\n    cov.s = vec3(svd.Sigma[0][0], svd.Sigma[1][1], svd.Sigma[2][2]);\n    //normalize scale\n    cov.s = FixScale(cov.s, N);\n    cov.s /= cov.s.x;\n    //invert scale\n    //cov.s = 1.0/cov.s;\n    return cov;\n    \n}\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass > 0u || p1.mass >0u)\n    {\n        vec4 x0 = vec4(0.00001);\n        vec4 x1 = x0;\n        float N0 = 0.0;\n        float N1 = 0.0;\n        range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n        {\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n         \n            UpdatePos(x0, p0, p0_);\n            UpdatePos(x1, p1, p0_);\n            UpdatePos(x0, p0, p1_);\n            UpdatePos(x1, p1, p1_);\n        }\n    \n        mat3 C0 = mat3(0.0);\n        mat3 C1 = C0;\n        x0 = x0/x0.w;\n        x1 = x1/x1.w;\n\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n            UpdateC(C0, x0, p0_, N0);\n            UpdateC(C1, x1, p0_, N1);\n            UpdateC(C0, x0, p1_, N0);\n            UpdateC(C1, x1, p1_, N1);\n        }\n\n        UpdateC(C1, x1, p0, N1);\n        UpdateC(C0, x0, p1, N0);\n    \n\n        Covariance Cov0 = GetCovariance(C0, N0);\n        Covariance Cov1 = GetCovariance(C1, N1);\n\n        fragColor = packCovariance(Cov0, Cov1);\n    }\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 437, 437, 829], [831, 831, 867, 867, 978], [980, 980, 1007, 1007, 1071], [1188, 1188, 1209, 1209, 1241], [1243, 1243, 1308, 1308, 1742], [1745, 1745, 1800, 1800, 2139], [2142, 2142, 2181, 2207, 2549], [2809, 2809, 2832, 2832, 2866], [2869, 2869, 2904, 2904, 3110], [3177, 3177, 3223, 3223, 3354], [3356, 3356, 3394, 3394, 3694], [3697, 3697, 3747, 3747, 4588], [4591, 4591, 4617, 4617, 4740], [4742, 4742, 4781, 4781, 4845], [4847, 4847, 4891, 4891, 5003], [5005, 5005, 5044, 5044, 5148], [5151, 5151, 5229, 5229, 6554], [6557, 6557, 6608, 6608, 8116]], "test": "untested"}
{"id": "msdBDj", "name": "HSVMetabal chuffrey", "author": "chuffrey", "description": "https://en.wikipedia.org/wiki/Metaballs\nhttps://www.rapidtables.com/convert/color/hsv-to-rgb.html\nhttps://en.wikipedia.org/wiki/Ordered_dithering\n\n", "tags": ["animation"], "likes": 3, "viewed": 136, "published": 3, "date": "1697662120", "time_retrieved": "2024-07-30T17:27:05.230025", "image_code": "struct Ball {\n    vec2 pos; // position in px\n    vec2 cen; // center of orbit in px\n    vec2 rad; // orbital radius\n    vec2 chg; // phase change in radians\n    vec2 spd; // oribtal speed in radians per second\n};\n\nvoid updateBall(inout Ball b) {\n    vec2 o = vec2(cos(b.chg.x + b.spd.x * iTime),\n                  sin(b.chg.y + b.spd.y * iTime));\n    b.pos = b.cen + o * b.rad;\n}\n\nconst float radius = .250f;\n\nBall[] balls = Ball[] (\n    Ball(vec2(1),vec2(2,2.50),vec2(8.0,1.40),vec2(0.1),vec2(1.0,1.1)),\n    Ball(vec2(1),vec2(4,6.50),vec2(1.10,1.50),vec2(0.5),vec2(0.9,0.5)),\n    Ball(vec2(1),vec2(5,4.50),vec2(1.20,1.20),vec2(0.2),vec2(1.5,1.0)),\n    Ball(vec2(1),vec2(8,4.75),vec2(1.40,0.70),vec2(1.2),vec2(1.2,0.9)),\n    Ball(vec2(1),vec2(13,2.75),vec2(9.0,1.40),vec2(3.1),vec2(0.7,1.3)),\n    Ball(vec2(1),vec2(12.5,6.45),vec2(8.5,1.10),vec2(4.3),vec2(0.9,1.5)),\n    \n    Ball(vec2(1),vec2(2.10,2.30),vec2(1.10,0.60),vec2(3.2),vec2(1.2,0.7)),\n    Ball(vec2(1),vec2(4.30,6.70),vec2(0.90,0.80),vec2(4.2),vec2(1.9,0.4)),\n    Ball(vec2(1),vec2(5.40,4.40),vec2(1.20,0.90),vec2(2.1),vec2(0.7,1.2)),\n    Ball(vec2(1),vec2(8.50,3.30),vec2(0.75,0.85),vec2(4.2),vec2(0.9,0.4)),\n    Ball(vec2(1),vec2(1.370,2.45),vec2(1.24,1.20),vec2(2.1),vec2(0.4,1.8)),\n    Ball(vec2(1),vec2(1.250,6.85),vec2(2.25,0.75),vec2(2.7),vec2(1.2,1.0))\n);\n\nconst int ballCt = 12;\n\nvec3 hsvToRgb(vec3 hsv) {\n    float c = hsv.y * hsv.z;\n    float x = c * (1.0 - abs(mod(hsv.x / 60.0, 2.0) - 1.0));\n    float m = hsv.z - c;\n    int bin = int(mod(floor(hsv.x / 60.0),6.0));\n    vec3 rgb;\n    switch (bin) {\n        case 0: rgb = vec3(c,x,0.0); break;\n        case 1: rgb = vec3(x,c,0.0); break;\n        case 2: rgb = vec3(0.0,c,x); break;\n        case 3: rgb = vec3(0.0,x,c); break;\n        case 4: rgb = vec3(x,0.0,c); break;\n        case 5: rgb = vec3(c,0.0,x); break;\n    }\n    rgb + m;\n    return rgb;\n}\n\nconst float[] dither = float[] (\n     0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0,  4.0/16.0, 14.0/16.0,  6.0/16.0,\n     3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0,  7.0/16.0, 13.0/16.0,  5.0/16.0\n);\nconst int ditherSize = 16;\n\nconst float pxf = 8.0; // pixelation factor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ires = ivec2( // integer pixelized resolution size\n        trunc(iResolution.x / pxf),\n        trunc(iResolution.y / pxf));\n        \n    ivec2 ifc = ivec2( // integer pixelized frag coord\n        trunc(fragCoord.x / pxf),\n        trunc(fragCoord.y / pxf));\n    \n    vec2 efc = vec2(ifc) / vec2(ires) * vec2(16,9); // effective coordinate (0,0) -> (16,9) space.\n    float sum = 0.0;\n    for (int i=0; i<ballCt; i++) {\n        updateBall(balls[i]);\n        sum += radius / distance(efc, balls[i].pos);\n    }\n\n    int ditherX = int(mod(float(ifc.x), 4.0));\n    int ditherY = int(mod(float(ifc.y), 4.0));\n    \n    float ditherThresh = dither[ditherY * 4 + ditherX];\n    \n    vec3 hsv = vec3(\n        round(mod(sum,1.0)*16.0)/16.0*360.0,\n        1.0,step(ditherThresh,sum));\n    \n    \n    // Output to screen\n    fragColor = vec4(hsvToRgb(hsv),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 246, 246, 380], [1352, 1352, 1377, 1377, 1875], [2155, 2176, 2233, 2233, 3090]], "test": "untested"}
{"id": "dsGyWz", "name": "HSVMetaballs", "author": "chuffrey", "description": "https://en.wikipedia.org/wiki/Metaballs\nhttps://www.rapidtables.com/convert/color/hsv-to-rgb.html\nhttps://en.wikipedia.org/wiki/Ordered_dithering\n\n", "tags": ["animation"], "likes": 6, "viewed": 136, "published": 3, "date": "1697661541", "time_retrieved": "2024-07-30T17:27:06.125632", "image_code": "struct Ball {\n    vec2 pos; // position in px\n    vec2 cen; // center of orbit in px\n    vec2 rad; // orbital radius\n    vec2 chg; // phase change in radians\n    vec2 spd; // oribtal speed in radians per second\n};\n\nvoid updateBall(inout Ball b) {\n    vec2 o = vec2(cos(b.chg.x + b.spd.x * iTime),\n                  sin(b.chg.y + b.spd.y * iTime));\n    b.pos = b.cen + o * b.rad;\n}\n\nconst float radius = 25.0f;\n\nBall[] balls = Ball[] (\n    Ball(vec2(1),vec2(200,250),vec2(80,140),vec2(0.1),vec2(1.0,1.1)),\n    Ball(vec2(1),vec2(400,650),vec2(110,150),vec2(0.5),vec2(0.9,0.5)),\n    Ball(vec2(1),vec2(500,450),vec2(120,120),vec2(0.2),vec2(1.5,1.0)),\n    Ball(vec2(1),vec2(800,475),vec2(140,70),vec2(1.2),vec2(1.2,0.9)),\n    Ball(vec2(1),vec2(1300,275),vec2(90,140),vec2(3.1),vec2(0.7,1.3)),\n    Ball(vec2(1),vec2(1250,645),vec2(85,110),vec2(4.3),vec2(0.9,1.5)),\n    \n    Ball(vec2(1),vec2(210,230),vec2(110,60),vec2(3.2),vec2(1.2,0.7)),\n    Ball(vec2(1),vec2(430,670),vec2(90,80),vec2(4.2),vec2(1.9,0.4)),\n    Ball(vec2(1),vec2(540,440),vec2(120,90),vec2(2.1),vec2(0.7,1.2)),\n    Ball(vec2(1),vec2(850,330),vec2(75,85),vec2(4.2),vec2(0.9,0.4)),\n    Ball(vec2(1),vec2(1370,245),vec2(124,120),vec2(2.1),vec2(0.4,1.8)),\n    Ball(vec2(1),vec2(1250,685),vec2(225,75),vec2(2.7),vec2(1.2,1.0))\n);\n\nconst int ballCt = 12;\n\nvec3 hsvToRgb(vec3 hsv) {\n    float c = hsv.y * hsv.z;\n    float x = c * (1.0 - abs(mod(hsv.x / 60.0, 2.0) - 1.0));\n    float m = hsv.z - c;\n    int bin = int(mod(floor(hsv.x / 60.0),6.0));\n    vec3 rgb;\n    switch (bin) {\n        case 0: rgb = vec3(c,x,0.0); break;\n        case 1: rgb = vec3(x,c,0.0); break;\n        case 2: rgb = vec3(0.0,c,x); break;\n        case 3: rgb = vec3(0.0,x,c); break;\n        case 4: rgb = vec3(x,0.0,c); break;\n        case 5: rgb = vec3(c,0.0,x); break;\n    }\n    rgb + m;\n    return rgb;\n}\n\nconst float[] dither = float[] (\n     0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0,  4.0/16.0, 14.0/16.0,  6.0/16.0,\n     3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0,  7.0/16.0, 13.0/16.0,  5.0/16.0\n);\nconst int ditherSize = 16;\n\nconst float pxf = 8.0; // pixelation factor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ires = ivec2( // integer pixelized resolution size\n        trunc(iResolution.x / pxf),\n        trunc(iResolution.y / pxf));\n        \n    ivec2 ifc = ivec2( // integer pixelized frag coord\n        trunc(fragCoord.x / pxf),\n        trunc(fragCoord.y / pxf));\n    \n    vec2 efc = vec2(ifc) * pxf;\n    float sum = 0.0;\n    for (int i=0; i<ballCt; i++) {\n        updateBall(balls[i]);\n        sum += radius / distance(efc, balls[i].pos);\n    }\n\n    int ditherX = int(mod(float(ifc.x), 4.0));\n    int ditherY = int(mod(float(ifc.y), 4.0));\n    \n    float ditherThresh = dither[ditherY * 4 + ditherX];\n    \n    vec3 hsv = vec3(\n        round(mod(sum,1.0)*16.0)/16.0*360.0,\n        1.0,step(ditherThresh,sum));\n    \n    \n    // Output to screen\n    fragColor = vec4(hsvToRgb(hsv),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 246, 246, 380], [1312, 1312, 1337, 1337, 1835], [2115, 2136, 2193, 2193, 2983]], "test": "untested"}
{"id": "dddBDj", "name": "Fork Damaged VC milana 082", "author": "milana", "description": "Simulating a damaged VCR playing a video", "tags": ["chromaticaberration"], "likes": 1, "viewed": 144, "published": 3, "date": "1697661191", "time_retrieved": "2024-07-30T17:27:06.995306", "image_code": "float sawtooth_wave(float x, float freq, float amp) {\n    return (x * freq - floor(x * freq)) * amp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Hint, it's a few lines of code, and makes use of a tan function :)\n    vec2 warpedUv = uv;\n\n    float stripeBottom = 5.f + sawtooth_wave(iTime, 0.1, iResolution.y);\n    float stripeTop = 80.f + sawtooth_wave(iTime, 0.1, iResolution.y);\n    \n    float dist = abs(fragCoord.y - stripeTop);\n    \n    if (fragCoord.y > stripeBottom && fragCoord.y < stripeTop) {\n        warpedUv += 0.01 * dist * tan(fragCoord.y);\n    }\n    \n    vec2 offset1 = vec2(0.03);\n    vec2 offset2 = vec2(0.015);\n    vec2 offset3 = vec2(0.0);\n    \n    float r = texture(iChannel0, warpedUv + offset1).r;\n    float g = texture(iChannel0, warpedUv + offset2).g;\n    float b = texture(iChannel0, warpedUv + offset3).b;\n                          \n    vec3 col = vec3(r, g, b);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 102], [104, 104, 161, 211, 1065]], "test": "untested"}
{"id": "ddtBDj", "name": "Fork color puzz milana 164", "author": "milana", "description": "Simple colored line effect", "tags": ["color"], "likes": 1, "viewed": 124, "published": 3, "date": "1697660460", "time_retrieved": "2024-07-30T17:27:07.896895", "image_code": "// Green screen function from @iq \n\n// :D :D :D\nvec4 compositeGreenScreenTexture(vec2 uv, vec4 background)\n{\n\n     vec4 tex = texture(iChannel0, uv);\n        \n     float maxrb = max( tex.r, tex.b );\n     float k = clamp( (tex.g-maxrb)*5.0, 0.0, 1.0 );\n\n     float ll = length( tex );\n     tex.g = min( tex.g, maxrb*0.8 );\n     tex = ll*normalize(tex);\n\n     return mix(tex, background, k);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // float r = 0.0;\n    // float g = 0.0;\n    // float b = 0.0;\n    // vec4 col = vec4(r, g, b, 1.0);\n    \n    // Output to screen\n    // fragColor = col;\n    \n    // Rotate UV\n    float angle = -3.14 / 4.f;\n    uv = mat2(cos(angle), \n              -sin(angle), \n              sin(angle), \n              cos(angle)) * uv;\n    \n    // Scale UV\n    uv *= 30.f;\n\n    // Time varying pixel color\n    float r = cos(uv.y);\n    float g = cos(uv.y + iTime);\n    float b = cos(uv.y - iTime);\n    vec4 col = vec4(r, g, b, 1.0);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 48, 108, 108, 392], [394, 394, 451, 501, 1146]], "test": "untested"}
{"id": "DsdfDj", "name": "Squoval Radius", "author": "domrally", "description": "Shape has 4 flat points on the sides, so those points can weld seamlessly to the lines.\nIMPLICIT\ntanh² erf⁻¹ x + tanh² erf⁻¹ y = 1\nPARAMETRIC\nx = erf atanh cos t\ny = erf atanh sin t\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["flat", "smooth", "squircle", "short", "radius", "errorfunction", "pade", "squoval", "hyperbolictangent"], "likes": 1, "viewed": 173, "published": 3, "date": "1697654588", "time_retrieved": "2024-07-30T17:27:08.978005", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nBased on domrally's Squoval project.\n    https://domrally.github.io/squoval\nAsymptotically smooth & periodically flat functions.\n    https://en.wikipedia.org/wiki/Smoothness\n    https://en.wikipedia.org/wiki/Flat_function\n*/\nvoid mainImage(out vec4 o, vec2 i)\n{\n    vec2 R = iResolution.xy;\n    i += i - R;\n    float r = min(R.x, R.y);\n    float k = 4. * (.5 + .5 * cos(iTime));\n    k *= k;\n\n    // Inverse error function method by Sergei Winitzki using Padé approximations\n    vec2 x = max(vec2(.01), (1. + k) * 1.2 * abs(i) / r - k),\n         c = log(1. - x * x),\n         b = 4.33 + c / 2.,\n         a = sqrt(b * b - c / .147),\n         z = tanh(sign(x) * sqrt(a - b));\n    z *= z;\n    float d = 1. - z.x - z.y;\n    \n    o = vec4(smoothstep(0., (25. + k * k) / r, d));\n}\n\n\n/*\nREFERENCES:\n\nRounded Squares.\nhttps://en.wikipedia.org/wiki/Squircle\nhttps://en.wiktionary.org/wiki/roundrect\nhttps://en.wikipedia.org/wiki/Superellipse\n\nSmoothing.\nhttps://en.wikipedia.org/wiki/Mollifier\nhttps://en.wikipedia.org/wiki/Smoothness\nhttps://en.wikipedia.org/wiki/Flat_function\nhttps://en.wikipedia.org/wiki/Bump_function\nhttps://en.wikipedia.org/wiki/Non-analytic_smooth_function\nhttps://en.wikipedia.org/wiki/Smoothness#Smooth_partitions_of_unity\nhttps://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 255, 291, 291, 804]], "test": "untested"}
{"id": "DdtBW2", "name": "Rainbow Bullseye Ripples v1", "author": "de_rock", "description": "Rainbow Bullseye Ripples v1", "tags": ["circlecirclesbullseyerainbow"], "likes": 2, "viewed": 141, "published": 3, "date": "1697652308", "time_retrieved": "2024-07-30T17:27:10.014234", "image_code": "vec3 palette(float t) {\n    float sinTime = sin(t);\n    float cosTime = cos(t);\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.269, 0.417, 0.557);\n\n    // Earthy gradient colors\n    vec3 earthyColor1 = vec3(0.584, 0.376, 0.184); // Brown\n    vec3 earthyColor2 = vec3(0.678, 0.631, 0.318); // Khaki\n    vec3 earthyColor3 = vec3(0.251, 0.349, 0.156); // Olive Green\n\n    float gradientFactor = 0.5 + 0.5 * sinTime;\n\n    vec3 colorShift = vec3(sinTime, cosTime, sinTime * cosTime);\n    return mix(\n        a - b * cos(6.28318 * (c * t + d)) + colorShift,\n        mix(earthyColor1, mix(earthyColor2, earthyColor3, gradientFactor), gradientFactor),\n        0.5\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / max((iResolution.x * sin(2.0) - iTime) + cos(iTime / 9.0), iResolution.y + cos(iTime / 9.0));\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n\n    float rotationSpeed = 0.0; // Adjust the rotation speed\n    float rotationAngle = -sin(iTime * rotationSpeed); // Smooth rotation angle\n\n    float aspect = iResolution.x / iResolution.y;\n    float timeFactor = iTime / 5.0; // Adjust the time factor for the evolution\n\n    float xBlend = fragCoord.x / iResolution.x; // Blending factor based on x-coordinate\n    float yBlend = 1.0 - xBlend; // Blending factor for the opposite direction\n\n    for (float i = 0.0; i < 4.0; i++) {  // Iterate four times for quad-mirroring\n        // Apply rotation\n        uv = mat2(cos(rotationAngle), -sin(rotationAngle), -sin(rotationAngle), tan(rotationAngle)) * uv;\n\n        // Deform the UV coordinates over time from a circle to a rectangle\n        uv.x = mix(uv.x, sign(uv.x) * (2.0 - abs(sin(timeFactor + uv.x))), abs(cos(timeFactor + uv.y) * 0.5));\n        uv.y = mix(uv.y, sign(uv.y) * (2.0 - abs(cos(timeFactor + uv.y))), abs(sin(timeFactor + uv.x) * 0.5));\n\n        uv = fract(uv * 2.5) - 0.5;\n\n        float d = length(uv) * exp(+length(uv0));\n\n        vec3 col = pow(palette(length(uv0) + iTime / 2.1), vec3(1.5)); // Adjust the power factor for contrast\n\n        d = sin(d * 16.0 - cos(iTime)) / 8.0;\n        d = abs(d);\n\n        d = 0.05 / d;\n\n        float threshold = 2.0; // Adjust the threshold for contrast\n        vec3 blendedColor = mix(vec3(0.0), col, step(threshold, d));\n\n        // Apply blending along the x-axis\n        finalColor += blendedColor * xBlend;\n\n        // Apply blending in the opposite direction along the x-axis\n        finalColor += blendedColor * yBlend;\n\n        // Reflect across the x-axis and y-axis\n        if (mod(i, 2.0) == 0.0) {\n            uv = vec2(uv.x, -uv.y);\n        }\n        if (i >= 2.0) {\n            uv = vec2(-uv.x, uv.y);\n        }\n    }\n\n    fragColor = vec4(finalColor, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 739], [741, 741, 796, 796, 2827]], "test": "untested"}
{"id": "mscBW2", "name": "Fork naked nyan IwakuraRei 736", "author": "IwakuraRein", "description": "homegirl needs a rainbow!", "tags": ["nyan"], "likes": 0, "viewed": 114, "published": 3, "date": "1697643717", "time_retrieved": "2024-07-30T17:27:10.860970", "image_code": "#define X_MIN 0.0\n#define X_MAX 0.8\n#define Y_MIN 0.42\n#define Y_MAX 0.65\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 origUV = fragCoord.xy / iResolution.xy;\n    \n    uv *= 2.;\n    uv -= vec2(2.5, 0.5);\n    uv = clamp(uv, 0., 1.);\n\t\n\tfloat frame = floor( mod( iTime*10.0, 6.0 ) );\n\n    //vec2 offset = vec2(0.2);\n    //float scale = 3.;\n    \n\tfloat nyanWidthUV = 40.0/256.0;\n\tuv.x = (uv.x + frame)*nyanWidthUV;\n    \n    \n\tvec4 nyan = texture( iChannel0, uv );\n\tvec3 col = nyan.xyz * nyan.a;\n    \n    float x = origUV.x - X_MIN; x /= X_MAX - X_MIN;\n    if (x >= 0.0 && x <= 1.0 && nyan.a == 0.0)\n    {\n        x += iTime * 0.1;\n        x = x * 5.0 - trunc(x * 5.0) - 0.5;\n        if (x>0.0) origUV.y += 0.02;\n        else origUV.y -= 0.02;\n        float y = origUV.y - Y_MIN; y /= Y_MAX - Y_MIN;\n        if (y >= 0.0 && y <= 1.0)\n        {\n            col.r = 1.0;\n            col.g = sin((y+iTime*0.1)*20.0);\n            col.b = sin((y-iTime*0.1)*20.0);\n        }\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 132, 132, 1075]], "test": "untested"}
{"id": "ddcfWj", "name": "Fork Damaged VC IwakuraRei 066", "author": "IwakuraRein", "description": "Simulating a damaged VCR playing a video", "tags": ["chromaticaberration"], "likes": 0, "viewed": 143, "published": 3, "date": "1697643711", "time_retrieved": "2024-07-30T17:27:11.767546", "image_code": "#define OFFSET_X 0.02\n#define OFFSET_Y 0.0\n#define PULSE_SIZE 0.1\n#define INV_PULSE_SIZE 10.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Hint, it's a few lines of code, and makes use of a tan function :)\n    float pulseY = iTime*0.3 - trunc(iTime*0.3);\n    bool insidePulse = false;\n    if (uv.y > pulseY && uv.y - pulseY < PULSE_SIZE)\n    {\n        insidePulse = (uv.y > pulseY && uv.y - pulseY < PULSE_SIZE);\n    }\n    if (insidePulse)\n    {\n        float dy = (uv.y-pulseY) * INV_PULSE_SIZE - 0.5;\n        if (sin(dy*200.0) > 0.0) uv.y +=dy*0.1;\n    }\n    \n    vec2 offset1 = vec2(OFFSET_X, OFFSET_Y);\n    vec2 offset2 = vec2(0.);\n    vec2 offset3 = vec2(-OFFSET_X, OFFSET_Y);\n    \n    float r = texture(iChannel0, uv + offset1).r;\n    float g = texture(iChannel0, uv + offset2).g;\n    float b = texture(iChannel0, uv + offset3).b;\n                          \n    vec3 col = vec3(r, g, b);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 153, 203, 1068]], "test": "untested"}
{"id": "ms3fWj", "name": "Fork color puzz IwakuraRei 046", "author": "IwakuraRein", "description": "Simple colored line effect", "tags": ["color"], "likes": 0, "viewed": 116, "published": 3, "date": "1697640054", "time_retrieved": "2024-07-30T17:27:12.776848", "image_code": "// Green screen function from @iq \n\n// :D :D :D\nvec4 compositeGreenScreenTexture(vec2 uv, vec4 background)\n{\n\n     vec4 tex = texture(iChannel0, uv);\n        \n     float maxrb = max( tex.r, tex.b );\n     float k = clamp( (tex.g-maxrb)*5.0, 0.0, 1.0 );\n\n     float ll = length( tex );\n     tex.g = min( tex.g, maxrb*0.8 );\n     tex = ll*normalize(tex);\n\n     return mix(tex, background, k);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float r = pow(sin((0.5-uv.y-uv.x)*24.0), 1.0);\n    float g = pow(sin((0.5-uv.y-uv.x)*24.0-iTime), 1.0);\n    float b = pow(sin((0.5-uv.y-uv.x)*24.0+iTime), 1.0);\n    vec4 col = vec4(r, g, b, 1.0);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ms3fWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 48, 108, 108, 392], [394, 394, 451, 501, 826]], "test": "untested"}
{"id": "mtdGWM", "name": "Type 1 Hexagonal Tilings", "author": "mla", "description": "Hexagonal tilings of the first kind. Tiles have parallel sides and the tiling is symmetric under 180° rotations.\nAnimation mode by default. Press 'a' for manual control.\n\n<mouse>,<up/down>,d,g,q,r,s,x,z also do things.", "tags": ["hexagon", "tilings"], "likes": 11, "viewed": 182, "published": 3, "date": "1697635420", "time_retrieved": "2024-07-30T17:27:14.138207", "image_code": "// Type 1 Hexagonal Tilings, mla, 2023\n//\n// There are 3 types of convex monohedral hexagonal tilings, see:\n// https://en.wikipedia.org/wiki/Hexagonal_tiling#Monohedral_convex_hexagonal_tilings\n// or eg. Grunbaum and Shepard for details, and the same constructions\n// works for non-convex tiles as well (though there may be non-convex tilings\n// that are not constructible in this way).\n//\n// This shader constructs a Type 1 tiling based on a parallelogrammic\n// repeating unit, and using two control points within the unit to\n// construct the tiling (zooming in and using 'g' to see the underlying grid\n// will probably be more useful than me trying to explain it). For\n// some positions of the control points, the tile boundary intersects\n// itself, or the tile is incompletely drawn (a limitation of doing this\n// in a fragment shader).\n//\n// The resulting tiling consists of translations and 180° rotations of the\n// basic tile, there are no reflections.\n//\n// If the edges of the tile are replaced with curves with appropriate symmetry,\n// then we have tiling satisfying the 'Conway criterion':\n// https://en.wikipedia.org/wiki/Conway_criterion\n//\n// By varying the control point positions across the image we can do\n// 'parquet deformations' - currently just a displacement to the two\n// control points. Better ways are possible I'm sure.\n//\n// Controls:\n// <mouse>: if not in animation mode drag the control points.\n// <up/down>: zoom in and out\n// a: animation mode\n// d: parquet deformation\n// g: show underlying grid\n// q,r,s: use special values for the control points\n// x: don't show control points\n// z: extra zoom out\n\n// Point reflect p in q\nvec2 pointreflect(vec2 p, vec2 q) {\n  return 2.0*q - p;\n}\n\nint wind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation, extending ray\n  // vertically.\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.x <= 0.0) {\n    if (r.x > 0.0 && t > 0.0) return 1;\n  } else {\n    if (r.x <= 0.0 && t < 0.0) return -1;\n  }\n  return 0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  setscale();\n  vec2 p = map(fragCoord);\n  vec2 p0 = p;\n  float px = fwidth(length(p));\n  vec2 a = getselection(0); // Parallelogram corner\n  vec2 A = vec2(1,0);\n  vec2 B = a;\n  vec2 C = vec2(a.x-1.0,a.y);\n  vec2 D = vec2(0);\n  mat2 M = mat2(A,C);\n  mat2 Minv = inverse(M);\n  vec2 E = 0.5*(A+B);\n  vec2 H = 0.5*(C+D);\n  vec2 K = getselection(1);\n  vec2 J = getselection(2);\n  p = Minv*p;\n  ivec2 ix = ivec2(floor(p));\n  ivec2 inc = ivec2(1);\n  p += 1.0;\n  p = mod(p,2.0);\n  p -= 1.0;\n  if (p.x < 0.0) p = -p, inc = -inc;\n  if (p.y < 0.0) p.y += 1.0;\n  p = M*p;\n  if (!key(CHAR_A)) {\n    vec2 q = 2.0*fract(0.5+(0.2*iTime)*vec2(1,0.618));\n    q = min(q,2.0-q);\n    K = M*q;\n    q = 2.0*fract(0.5+(0.1618*iTime)*vec2(0.618,1));\n    q = min(q,2.0-q);\n    J = M*q;\n  }\n  if (!key(CHAR_D)) {\n    J += 0.025*p0;\n    K += 0.025*p0.yx;\n  }\n  if (key(CHAR_Q)) K = C;\n  if (key(CHAR_R)) J = B;\n  if (key(CHAR_S)) J = K;\n  float d = 1e8;\n  d = min(d,segment(p,J,K));\n  vec2 J1 = pointreflect(J,B);\n  d = min(d,segment(p,J,J1));\n  vec2 J0 = pointreflect(J,E);\n  d = min(d,segment(p,J,J0));\n  d = min(d,segment(p,J0,pointreflect(J0,A)));\n  vec2 K0 = pointreflect(K,H);\n  d = min(d,segment(p,K,K0));\n  d = min(d,segment(p,K0,pointreflect(K0,D)));\n  vec2 K1 = pointreflect(K,C);\n  d = min(d,segment(p,K,K1));\n\n  // Check for which region p is in. There are\n  // some redundant calls to wind() here (since\n  // wind(p,q,r) = -wind(p,r,q), more or less).\n  int k;\n  k = wind(p,K0,K)+wind(p,K,K1)+wind(p,K1,K0);\n  if (k > 0) ix.x -= inc.x;\n  k = wind(p,K1,K)+wind(p,K,J)+wind(p,J,J1)+wind(p,J1,K1);\n  if (k > 0) ix.y += inc.y;\n  k = wind(p,J1,J)+wind(p,J,J0)+wind(p,J0,J1);\n  if (k > 0) ix.x += inc.x;\n  vec3 col = vec3(1,1,0.8);\n  if (!key(CHAR_C)) col = hsv2rgb(rand(ix+1),0.4,1.0);\n  col *= smoothstep(0.0,px,d-0.01);\n  if (key(CHAR_G)) {\n    d = 1e8;\n    d = min(d,line(p,A,B));\n    d = min(d,line(p,B,C));\n    d = min(d,line(p,C,D));\n    d = min(d,line(p,D,A));\n    col *= smoothstep(0.0,px,d);\n  }\n  if (!key(CHAR_X)) {\n    // Show the control points\n    float d = 1e8;\n    d = min(d,distance(p0,a));\n    d = min(d,distance(p0,K));\n    d = min(d,distance(p0,J));\n    col *= smoothstep(0.0,px,d-0.06);\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat scale = 2.5;\nconst float PI = 3.1415927;\n\n#define map(screen) (scale*(2.0*screen-iResolution.xy)/iResolution.y)\n\nint nselections = 3;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(1.2,1);\n  if (i == 1) return vec2(0.3,0.3);\n  if (i == 2) return vec2(0.8,0.4);\n  return vec2(0);\n}\n\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define setscale() \\\n  (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))), \\\n   scale *= key(CHAR_Z) ? 1.0 : 2.0)\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);       \n  return v * mix(vec3(1.0),rgb,s);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}\n\nint idiv(int a,int b) {\n  return a >= 0 ? a/b : -((-a+b-1)/b);\n}\n\nint imod(int a, int b) {\n  int d = idiv(a,b);\n  return a-d*b;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "buffer_a_code": "#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.xyz = vec3(initselection(i-1),1234); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtdGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1634, 1658, 1693, 1693, 1715], [1717, 1717, 1751, 1818, 2020], [2022, 2022, 2074, 2074, 4353]], "test": "untested"}
{"id": "mddfDB", "name": "Lincian_test", "author": "Lincac", "description": "Why is my cloud box rendering like this? I followed the online learning process, but the results were different from others. Can someone help me", "tags": ["test"], "likes": 1, "viewed": 80, "published": 3, "date": "1697629253", "time_retrieved": "2024-07-30T17:27:16.672432", "image_code": "vec3 box_min = vec3(-2.3,-1.3,-1.9);\nvec3 box_max = vec3(2.1,2.6,2.2);\nconst float kPI = 3.1415926;\n\nvec3 getSkyColor(vec3 dir){\n    float t = (dir.y + 1.0) * 0.5;\n    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);\n}\n\nfloat getHeightPercent(vec3 pos)\n{\n    return (pos.y - box_min.y) / (box_max.y - box_min.y);\n}\n\nvec2 getUV(vec3 pos)\n{\n    return (pos.xz  / box_max.xz) * 0.5 + 0.5;\n}\n\nfloat remap(float originalValue, float originalMin, float originalMax, float newMin, float newMax)\n{\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat hgPhase(float g, float cosTheta)\n{\n    float numer = 1.0f - g * g;\n    float denom = 1.0f + g * g + 2.0f * g * cosTheta;\n    return numer / (4.0f * kPI * denom * sqrt(denom));\n}\n\nfloat dualLobPhase(float g0, float g1, float w, float cosTheta)\n{\n    return mix(hgPhase(g0, cosTheta), hgPhase(g1, cosTheta), w);\n}\n\nbool hitbox(vec3 ro,vec3 rd,inout vec3 start,inout vec3 end)\n{\n    vec3 t1 = (box_min - ro) / rd;\n    vec3 t2 = (box_max - ro) / rd;\n    \n    vec3 tmin = min(t1,t2);\n    vec3 tmax = max(t1,t2);\n    \n    float entt = max(tmin.x,max(tmin.y,tmin.z));\n    float outt = min(tmax.x,min(tmax.y,tmax.z));\n    \n    if(entt > outt || outt < 0.) return false;\n    \n    start = ro + entt * rd;\n    end   = ro + outt * rd;\n    \n    return true;\n}\n\n#define STRATUS_GRADIENT vec4(0.0, 0.1, 0.2, 0.3)\n#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)\n#define CUMULUS_GRADIENT vec4(0.00, 0.1625, 0.88, 0.98)\nfloat getDensityForCloud(float heightFraction, float cloudType)\n{\n\tfloat stratusFactor = 1.0 - clamp(cloudType * 2.0, 0.0, 1.0);\n\tfloat stratoCumulusFactor = 1.0 - abs(cloudType - 0.5) * 2.0;\n\tfloat cumulusFactor = clamp(cloudType - 0.5, 0.0, 1.0) * 2.0;\n\n\tvec4 baseGradient = stratusFactor * STRATUS_GRADIENT + stratoCumulusFactor * STRATOCUMULUS_GRADIENT + cumulusFactor * CUMULUS_GRADIENT;\n\treturn smoothstep(baseGradient.x, baseGradient.y, heightFraction) - smoothstep(baseGradient.z, baseGradient.w, heightFraction);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat getDensity(vec3 pos)\n{\n    float height = getHeightPercent(pos);\n    if(height < 0.0 || height > 1.0){\n\t\treturn 0.0;\n\t}\n    \n    vec2 uv = getUV(pos);\n    vec2 mv_uv = getUV(pos \n    + height * normalize(vec3(0.5, 0.5,0)) * 2.\n    + normalize(vec3(0.5, 0.5,0)) * iTime * 0.5);\n\n    vec4 density = texture(iChannel0,vec3(mv_uv / 2.,height));\n    float fbm = dot(density.gba, vec3(0.625, 0.25,0.125));\n    float base_cloud = remap(density.r, -(1.0 - fbm), 1., 0.0 , 1.0);\n    \n    float density2 = getDensityForCloud(height, 1.);\n\tbase_cloud *= (density2 / height);\n    \n    vec3 erodeCloudNoise = texture(iChannel1, vec3(mv_uv, height)).rgb;\n    float highFreqFBM = dot(erodeCloudNoise, vec3(0.625, 0.25, 0.125));\n    float highFreqNoiseModifier = mix(highFreqFBM, 1.0 - highFreqFBM, height);\n    base_cloud = base_cloud - highFreqNoiseModifier * (1.0 - base_cloud);\n    \n    return base_cloud - length(pos) ;\n    \n}\n\nfloat LightRayMarch(vec3 start,float ds)\n{\n    vec3 dir = normalize(vec3(1,0.8,-1.));\n    vec3 marchDir = ds * normalize(dir);\n    float sigma_ds = -ds;\n    \n    float T = 1.0;\n    vec3 pos = start;\n    \n    for(int i=0;i<6;i++)\n    {\n        float density = getDensity(pos);\n        if(density > .0)\n        {\n            T *= exp(density * sigma_ds);\n        }\n    }\n    \n    return T;\n}\n\nvec4 RayMarch(vec3 start,vec3 end,vec3 bg,vec2 fragcoord)\n{\n    vec3 path = end - start;\n    float len = length(path);\n    float ds  =  len / 32.;\n    vec3 marchDir = ds * normalize(path);\n    \n    float sigma_ds = -ds;\n    \n    vec3 scattering = vec3(0,0,0);\n    float VoL = dot(normalize(path),normalize(vec3(1,0.8,-1.)));\n    float T  = 1.0;\n    \n    vec3 pos = start;\n    for(int i=0;i<32;i++)\n    {\n        float density = getDensity(pos);\n        if(density > 0.)\n        {\n            float ds_Trans = exp(density * sigma_ds);\n            \n            float light_ds = LightRayMarch(pos,ds * 0.1);\n            float sunPhase = dualLobPhase(0.5, -0.5, 0.2, -VoL);\n            vec3 stepScattering = vec3(1,1.,0.9)*7. * ds_Trans * sunPhase * light_ds;\n            vec3 sigmaS = vec3(density);\n            scattering += stepScattering * T * (sigmaS * ds);\n            \n            T *= ds_Trans;\n        }\n        if(T < 1e-1) break;\n        pos += marchDir;\n    }\n    \n    vec3 finalColor = T * bg + scattering;\n    \n    return vec4(finalColor,T);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0,0.0,5.0);\n    vec3 rd = normalize(vec3(uv,-1.0));\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 v = -1.0 + 2.0*q;\n    v.x *= iResolution.x/ iResolution.y;\n    \n    #if 0\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n    #else\n\tvec2 mo = vec2(iTime*.1,cos(iTime*.25)*3.);\n\t#endif\n\n    // camera by iq\n    vec3 org = 5.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7-1.0*(mo.y-1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - org);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 dir = normalize( v.x*uu + v.y*vv + 1.5*ww );\n\tvec4 color=vec4(.0);\n    \n    vec3 start;\n    vec3 end;\n    vec3 bg  = getSkyColor(rd);\n    vec4 col = vec4(bg,0);\n    if(hitbox(ro,rd,start,end))\n    {\n\n        //float density = getDensity(start);\n        //col.rgb = vec3(density,density,density);\n\n        col = RayMarch(start,end,bg,fragCoord);\n        col.rgb = mix(col.rgb,bg,col.a);\n    }\n\n    fragColor = vec4(col.rgb,1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 235], [237, 237, 271, 271, 331], [333, 333, 355, 355, 404], [406, 406, 506, 506, 610], [612, 612, 652, 652, 795], [797, 797, 862, 862, 929], [931, 931, 993, 993, 1364], [1532, 1532, 1597, 1597, 2055], [2057, 2057, 2109, 2109, 2208], [2210, 2210, 2238, 2238, 3131], [3133, 3133, 3175, 3175, 3522], [3524, 3524, 3583, 3583, 4577], [4579, 4579, 4636, 4636, 5741]], "test": "untested"}
{"id": "mdcfDS", "name": "sparkly fractal audio visualizer", "author": "lauriparonen", "description": "based on this tutorial: https://www.youtube.com/watch?v=f4s1h2YETNY\nas well as this shader: https://www.shadertoy.com/view/wd3XzS", "tags": ["psychedelic", "visualizer"], "likes": 1, "viewed": 209, "published": 3, "date": "1697624804", "time_retrieved": "2024-07-30T17:27:17.611920", "image_code": "/*  audio processing logic borrowed from https://www.shadertoy.com/view/wd3XzS */\nfloat sigmoid(float x)\n{\n    return 1. / (1. + exp(x));\n}\n   \nvec3 sigmoid(vec3 xyz)\n{\n    return vec3(sigmoid(xyz.x), sigmoid(xyz.y), sigmoid(xyz.z));\n}\n\nfloat sampleAt(float f)\n{\n    return texture(iChannel0, vec2(f / 16.0, 0)).x;\n}\n\nfloat sampleMultiple(float f)\n{\n    float delta = .1;\n    return 0.1 * (sampleAt(f - 2. * delta) + sampleAt(f - delta) + sampleAt(f) + sampleAt(f + delta) + sampleAt(f + 2. * delta));\n}\n\n\nvec3 palette( in float t )\n{\n    /* \n        gotten from http://dev.thi.ng/gradients/\n        find a gradient you like and change the values of the four vectors\n        respectively to the values of the vector of coefficients on the page\n        \n        e.g.: \n        \n        [[0.500 0.500 0.500] [0.500 0.500 0.500] [1.000 1.000 1.000] [0.000 0.333 0.667]]\n              \n        —>\n              \n        vec3 a = vec3(0.500, 0.500, 0.500);\n        vec3 b = vec3(0.500, 0.500, 0.500);\n        vec3 c = vec3(1.000, 1.000, 1.000);\n        vec3 d = vec3(0.000, 0.333, 0.667);\n        \n    */\n    \n    vec3 a = vec3(0.678, -1.502, 0.388);\n    vec3 b = vec3(-0.252, 0.054, 0.450);\n    vec3 c = vec3(-2.892, 2.168, 0.930);\n    vec3 d = vec3(-1.252, -0.918, -1.582);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat MAX_ITER = 3.5; // edit this value to alter the complexity of the figure\n                      // large number -> lots of details\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;  \n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < MAX_ITER; i++) { \n    \n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n        \n        float amplitude = sampleMultiple(d * d);\n\n        d -= .8 * amplitude;\n        \n        vec3 col = palette(length(uv0) + sampleMultiple(1.0));\n        \n        float weird = sigmoid(abs(uv.x) * abs(uv.y));\n\n        float speed = 3. * amplitude * sin(sampleMultiple(d) * weird * 0.05) * 0.1;\n\n        float brightness = 1.5 * amplitude * sigmoid(sin(d * d * 16. - speed * iTime + 2. * speed * amplitude));\n\n        //d += sin(d*15. + iTime)/15.; \n        d += sin(d*0.1 + sampleMultiple(1.0)/10.);\n        d = abs(d);\n\n        d = 0.02 / d;\n\n        col *= brightness;\n\n        finalColor += col * d;\n        \n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 34945, "src": "https://soundcloud.com/lamiatunes/altus-i", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 106, 106, 139], [144, 144, 168, 168, 235], [237, 237, 262, 262, 316], [318, 318, 349, 349, 503], [506, 506, 534, 1101, 1320], [1459, 1459, 1516, 1516, 2457]], "test": "untested"}
{"id": "cdyyzy", "name": "Tennis ball mapping", "author": "gehtsiegarnixan", "description": "I made this spheremapping function to map a 2D texture onto a sphere without edges and even pixel density using only 2 texture sampels. This uses the SDF of a tennis ball to merge the two samples.", "tags": ["3d", "uv", "sphere", "normal", "mapping", "seamless", "seamless", "tennis", "spheremap", "tennisball", "tbn"], "likes": 7, "viewed": 224, "published": 3, "date": "1697620597", "time_retrieved": "2024-07-30T17:27:18.665104", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI created this algorithm to seamlessly tile a texture over a sphere \nwith little distortions and no edges. It uses only 2 texture lookups.\n\nThis works by having 2 spheremappings. One is rotated so the edges of the \nspheremapping do not meet. I created a mask the blend between the edges\nthat has the same pattern as a tennisball. This mapping includes normals \ntoo. The blend region is currently hidden by the glue-line, but you can \nmake it visible by enabling SHOWBLEND. \n\nThere are several global constants below to enable debug views of the\nmapping and mouse controls to look around.\n\nSee also my demo for tangent space matrix of spheremaps:\nhttps://www.shadertoy.com/view/ctXfDS\n*/\n\n// enables debug grid where the two mappings blend with each other\n// Green and Red are the upper and lower bounds of the weights\n// Blue and White is the edge where one tiling breaks\n//#define SHOWBLEND\n#define LINETHICKNESS 0.02\n\n// 1 no contrast, higher values increase contrast\n#define CONTRAST 16.0\n\n// enable to show the alpha/weights otherwise shows textures\n//#define SHOWALPHA\n\n// Signed distance function of a tennis ball, the glueline would be at 0.5\n#define TWO_OVER_PI 0.6366197724 // 2. / PI\nfloat tennisballSDF (vec3 normal) {   \n    // Prevent floating point errors\n    normal = clamp(normal, -1., 1.);\n    \n    // combine halfs of SDF\n    float tennisballSDF;\n    if (normal.x > 0.) {\n        // poles\n        tennisballSDF = 1.- acos(abs(normal.z)) * TWO_OVER_PI; \n    } else {\n        // seam of the edge between poles\n        tennisballSDF = acos(abs(normal.y)) * TWO_OVER_PI; \n    }\n    return tennisballSDF;    \n}\n\n//Spherical mapping\nvec2 sphereMap(vec3 normal) {\n    // merkator projection\n    float u = 0.5 + atan(normal.y, normal.x) / (2.*3.1415);\n    float v = 0.5 + asin(normal.z) / 3.1415;\n    return vec2(u, v);\n}\n\n// TBN Matrix for the spheremapping above\nmat3 sphereTBNMatrix(vec3 normal) {\n    // vec3 poleAxis = vec3(0,0,1.);\n    // vec3 tangent = normalize(cross(poleAxis, normal));\n    vec3 tangent = safeNormalize(vec3(-normal.y, normal.x, 0.), vec3(1,0,0));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\n// simple spheremap texture sampler\nmaterialVal sphereMapSample(sampler2D tex, vec3 normal, float scale) {\n    // sample spheremap\n    vec2 uv = sphereMap(normal);\n    \n    // so UVs are ~equal scale, as X is circumfrence, but Y is only half\n    uv.x *= 2.; \n    \n    // apply scale\n    uv *= scale;    \n    \n    // sample tbn matrix\n    mat3 tbn = sphereTBNMatrix(normal);  \n    \n    // sample texture, since we hide the seam we can ignore mips\n    vec3 color = texture(tex, uv).xyz;\n\n    // sample normal, if you can obviously use a normal texture instead\n    vec3 tsNormal = HeightToNormal(tex, uv, iChannelResolution[0].xy, 4.0);\n    // translate normals to world space\n    vec3 wsNormal = tbn * tsNormal;\n\n    // pack everything into a struct\n    return materialVal(color, wsNormal, 0.);\n}\n\nmaterialVal tennisballmap(sampler2D tex, vec3 normal, float scale, float contrast) {    \n    // rotated spheremap to align with tennisball other side\n    vec3 rotatedNormal = vec3(-normal.x, normal.z, normal.y); \n\n    // sample textures\n    materialVal sphereA = sphereMapSample(tex, normal, scale);\n    materialVal sphereB = sphereMapSample(tex, rotatedNormal, scale);\n\n    // sample blend weight\n    float alpha = tennisballSDF(normal);\n    \n    // increase contrast of tennisball mask\n    float contrastAlpha = straightContrast(alpha, contrast);\n\n    #ifdef SHOWALPHA\n        // show alpha/weights with best colormap for better readability\n        vec3 col = viridis(contrastAlpha);\n    #else    \n        // interpolate between mappings to remove edges and poles\n        vec3 col = mix(sphereA.color, sphereB.color, contrastAlpha);\n    #endif\n        \n    // since sphere B is rotated its normals need to be rotated as well\n    vec3 wsNormalB = vec3(-sphereB.normal.x, sphereB.normal.z, sphereB.normal.y);\n    \n    // interpolate normals, Slerp may be better, but I can't tell the differene\n    vec3 wsNormal = normalize(mix(sphereA.normal, wsNormalB, contrastAlpha));\n    \n    #ifdef SHOWBLEND\n        // overlaying the edges of the alpha mask\n        vec2 blend = step(abs(vec2(contrastAlpha, 1.-contrastAlpha)-0.1), vec2(LINETHICKNESS));\n\n        // edge of the mappings\n        float edgeA = step(alpha, LINETHICKNESS);;\n        float edgeB = step(tennisballSDF(rotatedNormal), LINETHICKNESS);\n\n        // join color\n        col = max(max(col, vec3(blend, edgeA)), vec3(edgeB));\n    #endif\n    \n    // pack everything into a struct\n    return materialVal(col, wsNormal, alpha);\n}\n\n// samples tennisball textures and applies tennis ball colors\nmaterialVal tennisball(sampler2D tex, vec3 normal, float scale, float contrast) {\n    // sample textures\n    materialVal ball = tennisballmap(tex, normal, scale, contrast);\n   \n    // center the mask on the line at 0.5\n    float line = abs(ball.mask-0.5)*2.;\n    \n    // calculate a little dark line around the glue edge\n    float glueWidth = 0.08;\n    float tintWidth = 0.04;\n    float tint = smoothstep(glueWidth + tintWidth, glueWidth - tintWidth, line);\n    \n    // define ball colors\n    vec3 glueColor = vec3(0.824,0.827,0.749) * tint;\n    vec3 feltColor = vec3(0.937,0.953,0.086) - (ball.color * 0.5);\n    \n    // caluclate smoothstep for weight between glue and felt\n    float stepWidth = 0.02;\n    float alpha = smoothstep(glueWidth - stepWidth,glueWidth + stepWidth, line);\n    \n    // blend colors\n    vec3 color = mix(glueColor, feltColor, alpha);\n    \n    // interpolate normals, Slerp may be better, but I can't tell the differene\n    vec3 wsNormal = normalize(mix(normal, ball.normal, alpha));\n    \n    return materialVal(color, wsNormal, ball.mask);\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    vec2 cursor;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n        \n                // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.y;\n        vec2 coords = fragCoord / iResolution.y;\n        \n        // Generate Mouse coursor, x = mouse color, y = mouse weight \n        float mouseSize = 0.02;\n        float mouseDist = length(coords - mouse); \n        float aa = fwidth(mouseDist); // cheap anti-aliasing factor\n        cursor.x = smoothstep(mouseSize*0.5 + aa, mouseSize*0.5 - aa, mouseDist);\n        cursor.y = smoothstep(mouseSize + aa, mouseSize - aa, mouseDist);\n        \n    } else {\n        mx = mm2(-iTime*.5+um.x*5.);\n        my = mm2(iTime*0.2+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n    \n    vec3 lightDir = normalize(vec3(1,0,1));\n  \n    // alternate between backgroudn and sphere mapping\n    vec3 colorA;\n    if (t.x > 0.) {\n        // Sphere mapping\n    \tvec3 normal = ro+rd*t.x;\n                \n        #if defined(SHOWBLEND) || defined(SHOWALPHA)\n            // sample albedo textures\n            materialVal cube = tennisballmap(iChannel0, normal, 5., CONTRAST);\n        \n            colorA = cube.color;\n        #else\n            // sample albedo textures\n            materialVal cube = tennisball(iChannel0, normal, 5., CONTRAST);\n            \n            // Apply lighting to show the normals too\n            colorA = phongLighting(cube.color, cube.normal, ro, lightDir);\n        #endif\n        \n    } \n    \n    // Background mapping\n    vec3 normal = rd;\n\n    // make tennisball sdf\n    float alpha = tennisballSDF(normal);\n\n    // increase contrast a bit\n    alpha = straightContrast(1.-alpha, 1.5);\n\n    // apply best colormap\n    vec3 albedo = viridis(alpha);\n    \n    #if defined(SHOWBLEND) || defined(SHOWALPHA)\n        // make color a bit darker for better contrast with sphere\n        vec3 colorB = pow(albedo, vec3(1.5));\n        \n    #else\n        // simple sun with halo\n        vec3 sun = sun(normal, lightDir);\n\n        // combine albedo and sunlight\n        vec3 colorB  = albedo + sun;\n    #endif\n    \n    // Smooth blending of ball with background\n    vec3 color = mix(colorA, colorB, smoothstep(0.02, 0.0, t.y));\n    \n    // Add mouse cursor\n    color = mix(color, vec3(cursor.x), cursor.y);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_________________________GENERIC FUNCTIONS_____________________________________\n#define SUN_COLOR vec3(0.894,0.702,1.000)\n\n// Struct to hold material values\nstruct materialVal {\n    vec3 color;\n    vec3 normal;\n    float mask;\n};\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.35;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.5;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 16.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\n#define ONE_OVER_PI 0.3183098861836\nvec3 sun(vec3 normal, vec3 lightDir) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Prevent Nan errors with fron acos\n    NdotL = clamp(NdotL, -1., 1.);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) * ONE_OVER_PI;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 50.0) * 3.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// Linearly increases contrast of Alpha\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat straightContrast(float alpha, float contrast) {\n    return clamp(contrast * (alpha - 0.5) + 0.5, 0., 1.);\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(sampler2D tex, vec2 uv, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(tex, uv).x;\n    float h1 = texture(tex, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(tex, uv + s * vec2(0,textureOffset)).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return safeNormalize(vec3(xy * strength, 1.0), vec3(0,0,1));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdyyzy.jpg", "access": "api", "license": "mit", "functions": [[2277, 2277, 2312, 2352, 2706], [2708, 2728, 2757, 2784, 2914], [2916, 2958, 2993, 3088, 3258], [3260, 3296, 3366, 3390, 4054], [4056, 4056, 4140, 4205, 5742], [5744, 5806, 5887, 5910, 6873], [7020, 7020, 7041, 7041, 7093], [7095, 7095, 7133, 7133, 7303], [7305, 7305, 7362, 7362, 10063]], "test": "untested"}
{"id": "cddfWB", "name": "Life of Game (Copy)", "author": "tooboi710", "description": "ca shader", "tags": ["ca"], "likes": 1, "viewed": 117, "published": 3, "date": "1697602433", "time_retrieved": "2024-07-30T17:27:19.540763", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Borrowed from someone on here not mine using for personal project\n\n#define lookup(pos) texture(iChannel0,pos).x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invResolution = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * invResolution;\n    \n    float prevState = texture(iChannel0,uv).x;\n    \n    float e = 0.;\n    e += lookup(uv + vec2( 0., 1.) * invResolution);\n    e += lookup(uv + vec2( 0.,-1.) * invResolution);\n    e += lookup(uv + vec2( 1., 0.) * invResolution);\n    e += lookup(uv + vec2(-1., 0.) * invResolution);\n    e += lookup(uv + vec2( 1., 1.) * invResolution);\n    e += lookup(uv + vec2( 1.,-1.) * invResolution);\n    e += lookup(uv + vec2(-1., 1.) * invResolution);\n    e += lookup(uv + vec2(-1.,-1.) * invResolution);\n    if( e == 2. && prevState == 1. || e == 3. )\n    \tfragColor= vec4(1.);\n    else\n    \tfragColor= vec4(0.);\n    \n    if(iMouse.z > .5)\n    \tfragColor= max(fragColor,vec4(step(length(iMouse.xy - fragCoord),25.)));\n    else if (iFrame < 10)\n        fragColor = vec4(step(length(vec2(.5) - uv),.1));\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 137]], "test": "untested"}
{"id": "DstfDS", "name": "Squoval Grid", "author": "domrally", "description": "x = erf atanh cos t\ny = erf atanh sin t\nThe grid helps show the flat properties of the curve.\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["flat", "smooth", "errorfunction", "pade", "squoval", "hyperbolictangent"], "likes": 2, "viewed": 135, "published": 3, "date": "1697595184", "time_retrieved": "2024-07-30T17:27:20.420411", "image_code": "/*\nBased on domrally's Squoval project.\n    https://domrally.github.io/squoval\nAsymptotically smooth & periodically flat functions.\n    https://en.wikipedia.org/wiki/Smoothness\n    https://en.wikipedia.org/wiki/Flat_function\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    vec2 R = iResolution.xy;\n    float r = min(R.x, R.y);\n    vec2 uv = i / r;\n    vec2 x = 2.1 * abs(fract(4. * uv) - .5);\n\n    /*\n    Inverse error function method by Sergei Winitzki using Padé approximations\n        https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions    \n    */\n    vec2 c = log(1. - x * x),\n         b = 4.33 + c / 2.,\n         a = sqrt(b * b - c / .147),\n         z = tanh(sign(x) * sqrt(a - b));\n    z *= z;\n    float d = 1. - z.x - z.y;\n        \n    vec3 color = pow(.6 + .25 * cos(iTime + 9. * floor(4. * uv.xyx) / 4. + vec3(0, 2, 4)), vec3(2.2));\n    o.rgb = color * smoothstep(0., 9. * 4. * 2.1 / r, d);\n    o.a = 1.;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 228, 264, 264, 945]], "test": "untested"}
{"id": "Ds3BW8", "name": "Two Square Hinged Tiling UV", "author": "fad", "description": "Drag your mouse to change the size of the small squares\nSee also: [url=/view/cd3fDr]untextured version[/url]", "tags": ["texture", "uv", "mapping", "tessellation", "parallelogram", "hinge"], "likes": 13, "viewed": 265, "published": 3, "date": "1697587761", "time_retrieved": "2024-07-30T17:27:21.302053", "image_code": "const float PI = 3.1415927;\n\nvoid mainImage(out vec4 O, vec2 I) {\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0 * I - R) / R.y * 5.0;\n    float t = 1.0 - abs(1.0 - mod(iTime / 2.0, 2.0));\n    float a = (smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t)) - 0.5) * PI;\n    float b = iMouse.z > 0.0 ? mix(0.2, 1.5, iMouse.x / R.x) : 0.6;\n    vec4 T = vec4(cos(a), -cos(a), sin(a), -sin(a));\n    vec3 o = vec3(0.0, 1.0, -1.0);\n    mat2 A = mat2((T.xyxx + T.zzwz) * b + o.yzyy);\n    vec4 Q = 2.0 * round(((inverse(A) * p).xyxy + o.xxyy) / 2.0) - o.xxyy;\n    vec4 d = abs(vec4(A * mat2(Q)) - p.xyxy);\n    vec2 e = max(d.xz, d.yw);\n    vec4 f = abs(vec4(mat2(T.xwzx) * (mat2(p, p) - A * mat2(Q.xwzy))));\n    vec2 g = max(f.xz, f.yw);\n    vec2 uv = min(e.x, e.y) <= 1.0\n        ? p - (A + mat2(b * o.yyzy + o.zyzz)) * (e.x < e.y ? Q.xy : Q.zw)\n        : mat2(T.wyxw) * p +\n          mat2(T.xxyx + T.zwzz + o.yzyy) * (g.x < g.y ? Q.xw : Q.zy);\n    uv = (uv / 5.0 * R.y + R) / 2.0 / R;\n    O = min(e.x, e.y) <= 1.0 || min(g.x, g.y) <= b\n        ? texture(iChannel0, uv)\n        : vec4(0.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3BW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 65, 65, 1078]], "test": "untested"}
{"id": "dscBWB", "name": "Mandelbrot___", "author": "danzabarr", "description": "Mandelbrot", "tags": ["mandelbrot"], "likes": 2, "viewed": 124, "published": 3, "date": "1697579195", "time_retrieved": "2024-07-30T17:27:22.288416", "image_code": "\nconst float ITERATIONS = 250.0;\n\n\n// Convert a vec3 from hsv to rgb colour space\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat mandelbrot(float r, float i)\n{\n    float zr = 0.0;\n    float zi = 0.0;\n    float n = 0.0;\n    while(zr * zr + zi * zi <= 4.0 && n < ITERATIONS)\n    {\n\n        float temp = zr * zr - zi * zi;\n        zi = zr * zi + zi * zr + i;\n        zr = temp + r;\n\n        n += 1.0;\n    }\n\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  // Centered and aspect-corrected\n\n\n    z /= iTime;\n    z += vec2(-1.0, -.3);\n\n    float m = mandelbrot(z.x, z.y);\n    float c = 1.0 - m / ITERATIONS;\n\n    vec3 hsv = vec3(pow(c, 2.2), 1.0, c);\n\n    vec3 col = hsv2rgb(hsv);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 82, 104, 104, 273], [276, 276, 312, 312, 573], [575, 575, 632, 632, 955]], "test": "untested"}
{"id": "cdcBWB", "name": "Simple Anti aliasing of d field", "author": "mrange", "description": "CC0: Simple Anti aliasing of distance field border demonstration\n For my friends in the Captain Coder discord\n", "tags": ["2d"], "likes": 8, "viewed": 312, "published": 3, "date": "1697567177", "time_retrieved": "2024-07-30T17:27:23.187014", "image_code": "// CC0: Simple Anti aliasing of distance field border demonstration\n//  For my friends in the Captain Coder discord\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // q is normalize to range [0,1]\n    vec2 q = fragCoord/iResolution.xy;\n\n    // p is in range [-1,1]\n    vec2 p = -1.0+2.0*q;\n    // Adjust for screen ratio, so that the circle actually looks like circle.\n    p.x *= iResolution.x/iResolution.y;\n\n    // From FabriceNeyrat2 in the comments\n    //  A shorter way to compute p adjusted for screen resolution and ratio\n    // vec2 p = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    // Uses the size of the pixel to determine an aa factor\n    float aa = sqrt(2.0)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    // Circle distance field\n    float d = length(p) - 0.5;\n    // Create a thin outline\n    float od = abs(d-0.05)-aa;\n\n    // Smoothstep the distance field combined with the aa factor to create\n    //  a smooth border with little aliasing.\n    col = mix(col, vec3(1.0), smoothstep(aa, -aa, d));\n    // And the outline\n    col = mix(col, vec3(1.0), smoothstep(aa, -aa, od));\n\n    // Approximative linear RGB to sRGB conversion.\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 116, 173, 210, 1226]], "test": "untested"}
{"id": "cdtBzf", "name": "GA2-fract-001", "author": "f_x", "description": "ga", "tags": ["ga"], "likes": 1, "viewed": 126, "published": 3, "date": "1697565477", "time_retrieved": "2024-07-30T17:27:24.070651", "image_code": "\nfloat band(int hz) { \n    int ix = int(float(hz)/23.); \n    return texelFetch( iChannel0, ivec2(ix,0), 0 ).x; \n}\n\nfloat it() {\n    return iTime * 1.2;\n}\n\nvec2 init(vec2 fragCoord, vec2 res) {\n    float ratio = res.y/res.x;\n    vec2 mr = vec2(min(res.x, res.y));\n    vec2 uv = (fragCoord/mr) + vec2(-0.5/ratio, -0.5);\n    return uv;\n}\n\nvec2 sq(vec2 c) {\n    float re = c.x*c.x - c.y*c.y;\n    float im = 2.*c.x*c.y;\n    return vec2(re,im);\n}\n\nfloat amount(vec2 c) {\n    return sqrt(c.x*c.x + c.y*c.y);\n}\n\nint mandel(vec2 c0, vec2 c00, int maxIter) {\n    vec2 c = sq(c0);\n    \n    int iter;\n    for (iter=0;iter < maxIter && amount(c) < 4.; iter++) {\n        c = sq(c - c00);\n    }\n    \n    return iter;\n}\n\nfloat sinp(int n) {\n    return sinp(float(n));\n}\n\nfloat nn(int n) {\n    if (n < 8) return float(n);\n    return float(n) + band(80)*200.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = init(fragCoord,iResolution.xy*.1) - vec2(7.3, 3.8);\n    uv.x += sin(it());\n    uv.y += cos(it());\n    GA2 p = ga(.5, uv.x, uv.y, .8);\n    GA2 q = ga(\n        uv.x*band(400)*8., \n        sin(it()) * band(400)*18.,\n        cos(it()) * band(400)*18., \n        uv.y*band(400)*8.);\n\n    GA2 s = invert(mul(mul(band(100),p),q));\n\n    uv = toVec2(s);\n\n    int N = 100;\n    \n    float ra = band(200)*.01;\n    float rb = band(200)*(.35-band(4000))*.09;//sin(iTime * 1.037) * 0.08;\n    \n    int n = mandel(uv.yx, vec2(.57+ra, .57+rb), N);\n    \n    vec3 col = n == N ? vec3(0) : vec3(\n        sinp(nn(n) / 43.), \n        sinp(nn(n) / 27.)/2., \n        sinp(nn(n) * .2)\n    );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "const int Idx_GA2_scalar = 0;\nconst int Idx_GA2_e1 = 1;\nconst int Idx_GA2_e2 = 2;\nconst int Idx_GA2_e12 = 3;\n\nstruct GA2 {\n    float scalar;\n    float e1;\n    float e2;\n    float e12;\n};\n\nGA2 fromArray(float X[4]){\n    return GA2(X[0], X[1], X[2], X[3]);\n}\n\nvoid toArray(GA2 X, inout float X_ary[4]){\n    X_ary[0] = X.scalar;\n    X_ary[1] = X.e1;\n    X_ary[2] = X.e2;\n    X_ary[3] = X.e12;\n}\n\nvoid zero(inout float X[4]){\n    X[0] = 0.0;\n    X[1] = 0.0;\n    X[2] = 0.0;\n    X[3] = 0.0;\n}\n\nGA2 add(GA2 X, GA2 Y){\n    return GA2(X.scalar + Y.scalar, X.e1 + Y.e1, X.e2 + Y.e2, X.e12 + Y.e12);\n}\n\nGA2 add(GA2 X, GA2 Y, GA2 Z){\n    return add(add(X, Y), Z);\n}\n\nGA2 add(GA2 X, GA2 Y, GA2 Z, GA2 P){\n    return add(add(add(X, Y), Z), P);\n}\n\n#define ONE_GA2 GA2(1.0, 0.0, 0.0, 0.0)\n\nGA2 mul(float a, GA2 X){\n    return GA2(X.scalar*a, X.e1*a, X.e2*a, X.e12*a);\n}\n\nGA2 sub(GA2 X, GA2 Y){\n    return GA2(X.scalar - Y.scalar, X.e1 - Y.e1, X.e2 - Y.e2, X.e12 - Y.e12);\n}\n\n#define ZERO_GA2 GA2(0.0, 0.0, 0.0, 0.0)\n\n\n\nGA2 mul(int a, GA2 X){\n    return mul(float(a), X);\n}\n\nGA2 mul(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2 - X.e2*Y.e12 + X.scalar*Y.e1, X.e1*Y.e12 - X.e12*Y.e1 + X.e2*Y.scalar + X.scalar*Y.e2, X.e1*Y.e2 + X.e12*Y.scalar - X.e2*Y.e1 + X.scalar*Y.e12);\n}\n\nGA2 scalar_GA2(float a){\n    return mul(a, ONE_GA2);\n}\n\nGA2 mul(GA2 X, GA2 Y, GA2 Z){\n    return mul(mul(X, Y), Z);\n}\n\nGA2 involve(GA2 X){\n    return GA2(X.scalar, -X.e1, -X.e2, X.e12);\n}\n\nGA2 inner(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2, X.e12*Y.e2 - X.e2*Y.e12, X.e1*Y.e12 - X.e12*Y.e1, 0.0);\n}\n\nGA2 lcontract(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2 + X.scalar*Y.scalar, -X.e2*Y.e12 + X.scalar*Y.e1, X.e1*Y.e12 + X.scalar*Y.e2, X.scalar*Y.e12);\n}\n\nGA2 outer(GA2 X, GA2 Y){\n    return GA2(X.scalar*Y.scalar, X.e1*Y.scalar + X.scalar*Y.e1, X.e2*Y.scalar + X.scalar*Y.e2, X.e1*Y.e2 + X.e12*Y.scalar - X.e2*Y.e1 + X.scalar*Y.e12);\n}\n\n#define I_GA2 GA2(0.0, 0.0, 0.0, 1.0)\n\nGA2 rcontract(GA2 X, GA2 Y){\n    return GA2(X.e1*Y.e1 - X.e12*Y.e12 + X.e2*Y.e2 + X.scalar*Y.scalar, X.e1*Y.scalar + X.e12*Y.e2, -X.e12*Y.e1 + X.e2*Y.scalar, X.e12*Y.scalar);\n}\n\nGA2 reverse(GA2 X){\n    return GA2(X.scalar, X.e1, X.e2, -X.e12);\n}\n\n\n\nGA2 conjugate(GA2 X){\n    return reverse(involve(X));\n}\n\nGA2 outer(GA2 X, GA2 Y, GA2 Z){\n    return outer(outer(X, Y), Z);\n}\n\nGA2 invert(GA2 X){\n    return mul(1.0/lcontract(X,conjugate(X)).scalar, conjugate(X));\n}\n\nGA2 div(GA2 X, GA2 Y){\n    return mul(X, invert(Y));\n}\n\nGA2 dual(GA2 X){\n    return div(X, I_GA2);\n}\n\nvec4 toVec4(GA2 p) {\n    return vec4(p.scalar, p.e1, p.e2, p.e12);\n}\n\nvec2 toVec2(GA2 p) {\n    return vec2(p.e1, p.e2);\n}\n\nGA2 ga(float scale, float e1, float e2, float e12) {\n    return fromArray(float[](scale, e1, e2, e12));\n}\n\n\nfloat sinp(float x) {\n    return (1.+sin(x))/2.;\n}\nfloat cosp(float x) {\n    return (1.+sin(x))/2.;\n}\n\nvec4 colors(GA2 s){\n    float a = s.e1 ;\n    float b = s.e12;\n    float c = s.e2 ;\n    \n    vec3 colors = vec3(a,b,c)*s.scalar/-2.;\n    \n    return vec4(colors, 1.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 113], [115, 115, 127, 127, 153], [155, 155, 192, 192, 334], [336, 336, 353, 353, 440], [442, 442, 464, 464, 502], [504, 504, 548, 548, 703], [705, 705, 724, 724, 753], [755, 755, 772, 772, 843], [845, 845, 902, 902, 1615]], "test": "untested"}
{"id": "Ds3fDS", "name": "remix3Claude2", "author": "Sergeindamix", "description": "https://claude.ai/chat/96c9649e-0955-4449-b0f8-9187b5fb50b3", "tags": ["fractal", "circles", "color"], "likes": 1, "viewed": 106, "published": 3, "date": "1697564926", "time_retrieved": "2024-07-30T17:27:24.824635", "image_code": "#define PI 3.141592653589793\n\nfloat random(vec2 uv){\nreturn fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\nvec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\nuv.x *= iResolution.x/iResolution.y;\n\n// Animación del tiempo\nfloat time = iTime * 0.5;\n\n// Patrón 1\nvec2 p1 = fract(sin(uv + time) * 10.0);\n\n// Patrón 2\nvec2 p2 = fract(uv * 5.0 + sin(time + 100.0));\n\n// Combinar patrones\n\nvec2 p = mix(p1, p2, 0.5);\np += random(fragCoord + vec2(time)) * 0.1;\n\n// Animación de la distancia\nfloat d = length(p);\nd += sin(d * 3.0 + time) * 0.5;\n\nfloat cosValue = cos(d * 2.0 + p.x + time);\nvec3 col = 0.5 + 0.5 * vec3(cosValue);\n\n// Agregar variación de color\ncol += random(fragCoord) * 0.2;\n\nfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3fDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 118], [120, 120, 174, 174, 785]], "test": "untested"}
{"id": "Ds3BzS", "name": "Uniplanar with Normals (Dither)", "author": "gehtsiegarnixan", "description": "Triplanar mapping version that uses a single sample with the help of dithering. This shader includes normal mapping using tangent space matrixes. ", "tags": ["3d", "texture", "triplanar", "uv", "normal", "mapping", "tbn"], "likes": 6, "viewed": 294, "published": 3, "date": "1697564382", "time_retrieved": "2024-07-30T17:27:25.901755", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a small demonstration of how to implement uniplanar mapping with accurate \nnormals. This is a variation of standard triplanar mapping that uses dithering to\nonly require one sample. This effect looks virtually identical to triplanar mapping,\nespecially when temporal anti-aliasing is also used, while being ~3x faster.\n\nSeveral global constants are defined below to enable debug views of the\nmapping, as well as mouse controls for navigation.\n\nThis method was introduced by Far Cry 5:\nhttps://www.gdcvault.com/play/1025480/Terrain-Rendering-in-Far-Cry\n\nSee here how the same shader looks with triplanar mapping: \nhttps://www.shadertoy.com/view/mdcBz8\n*/\n\n// The number of previous samples looked at to blur result, with a similar effect to\n// Temporal Anti-Aliasing (TAA) which you should use instead if you can.\n#define TEMPORALBLUR 8 \n\n// A value of 1 means no contrast, higher values increase contrast\n#define CONTRAST 16.0\n\n// This visualizes the blend region between the two cubemappings\n// Green, Red and Blue represent the lower bounds of the weights\n//#define SHOWGRID\n#define LINETHICKNESS 0.01\n\n// Valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// Input in pixels (i.e., not normalized UV)\nfloat ScreenSpaceDither12(vec2 vScreenPos, float time)\n{\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + time); \n    return fract( vDither / 103.0);\n}\n\n// Structure to hold material properties\nstruct materialValues {\n    vec3 color;\n    vec3 normal;\n};\n\n// Uniplanar mapping\nmaterialValues uniplanar(sampler2D tex, vec3 normal, vec2 fragCoord, \n                         float time, float scale, float contrast) {\n    // Weights/Alpha for interpolation\n    vec3 weights = abs(normal);\n\n    // Increase contrast of weights for sharper transitions\n    weights = smoothContrast(weights, contrast);\n\n    // Calculate sign for flipping sides\n    vec3 sgn = sign(normal);\n    \n    // Scale coordinates. Replace normal with world coordinates if not a sphere\n    vec3 uvwC = normal * scale;\n    \n    // Sample dither noise\n    float dither = ScreenSpaceDither12(fragCoord, time);\n    \n    // Smooth contrast creates artifacts in the dither. Clamping removes them\n    dither = clamp(dither, 0.01, 0.99);\n\n    // Mip calculation as the automatic ones don't work\n    vec3 duvwdx = dFdx(uvwC);\n    vec3 duvwdy = dFdy(uvwC);\n\n    // \"Interpolate\" the UVs using dither\n    vec2 uv;\n    vec2 duvdx; \n    vec2 duvdy;\n    mat3 tbn;\n    // The weights are grouped cumulatively, and if the dither value is within one \n    // cumulative section for one of the weights, that weight is selected.\n    if (weights.x > dither) {\n        // X-axis Side\n        // Coordinate projections all right side up with slightly different offsets\n        uv = vec2(uvwC.y * sgn.x, uvwC.z) + 0.25;\n        \n        // Partial derivative measures UV rate of change, so mirroring and offset are irrelevant.\n        duvdx = duvwdx.yz; \n        duvdy = duvwdy.yz;\n        \n        // Tangent is the direction of uvX.x in world space\n        vec3 tangentX = safeNormalize(cross(normal, vec3(0,0,-1)), vec3(0,sgn.x,0));   \n        \n        // Bitangent is the direction of uvY.y in world space.\n        vec3 bitangentX = cross(normal, vec3(0,sgn.x,0));\n        \n        // Tangent Bitangent Normal matrix to translate normal textures to world space normals.\n        tbn = mat3(tangentX, \n                   bitangentX, \n                   normal); // Normal vector straight up from the surface.\n                   \n    } else if (1.-weights.z > dither) { // Because sum of all weights is 1, so 1-z = sum of xy.\n        // Y-axis Side\n        uv = vec2(-uvwC.x * sgn.y, uvwC.z) + 0.5;\n        duvdx = duvwdx.zx;\n        duvdy = duvwdy.zx;\n       \n        // TBN matric for the Y sides\n        vec3 tangentY = safeNormalize(cross(normal, vec3(0,0,-1)), vec3(-sgn.y,0,0));\n        vec3 bitangentY = cross(normal, vec3(-sgn.y,0,0));\n        tbn = mat3(tangentY,\n                   bitangentY,\n                   normal);\n    } else {\n        // Z-axis Side \n        uv = vec2(uvwC.x * sgn.z, uvwC.y) + 0.75;        \n        duvdx = duvwdx.xy;\n        duvdy = duvwdy.xy;\n        \n        // TBN matric for the Z sides\n        vec3 tangentZ = safeNormalize(cross(normal, vec3(0,-1,0)), vec3(sgn.z,0,0));\n        vec3 bitangentZ = cross(normal, vec3(sgn.z,0,0));\n        tbn = mat3(tangentZ,\n                   bitangentZ,\n                   normal);\n    }\n\n    // Sample textures for cardinal directions.\n\tvec3 color = textureGrad(tex, uv, duvdx, duvdy).xyz;\n    \n    // Sample normal. If possible use a normal texture instead in tangent space.\n    vec3 tsNormal = heightToNormal(tex, uv, duvdx, duvdy, \n                                  iChannelResolution[0].xy, 5.0);\n      \n    // Translate normals to world space.\n    vec3 normalWS = tbn * tsNormal;          \n    \n    #ifdef SHOWGRID\n        // Overlaying the edges of the alpha mask.\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        color = max(mask, color);\n    #endif\n    return materialValues(color, normalWS);\n}\n\n// used as part for variantance restoration see triplanar version for proper use\n// NB: trick published in https://hal.inria.fr/inria-00536064v2\nfloat getSquaredAlphaSum(vec3 normal, float contrast) {\n    // Weights/Alpha for interpolation\n    vec3 weights = abs(normal);\n\n    // Increase contrast of weights for sharper transitions\n    weights = smoothContrast(weights, contrast);\n    \n    // partial value used in main\n    float squaredAlphaSum = weights.x * weights.x +\n                            weights.y * weights.y +\n                            weights.z * weights.z ; // = dot(weights, weights)\n                            \n    return squaredAlphaSum; \n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    vec2 cursor;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);   \n    } else {\n        mx = mm2(-iTime*.1+um.x*5.);\n        my = mm2(iTime*0.05+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n\n    vec3 lightDir = normalize(vec3(1,0,1));\n\n    // Alternate between background and sphere mapping\n    vec3 color;\n    if (t.x > 0.) {\n        // Sphere mapping\n    \tvec3 normal = ro + rd * t.x;\n        \n        #if TEMPORALBLUR <= 1\n            // We just take a single sample from the ditheredSample function.\n            materialValues planar = uniplanar(iChannel0, normal, \n                    fragCoord, iTime, 0.7, CONTRAST);\n        #else\n            // We take multiple samples from the ditheredSample function and average them.\n            // This is normally done automatically by your TAA or motion blur\n            materialValues planar;\n            for(int i = 0; i < TEMPORALBLUR; i++) {\n                // subtracting from time offset\n                materialValues tempPlanar = uniplanar(iChannel0, normal, \n                    fragCoord, iTime - float(i), 0.7, CONTRAST);\n                \n                // collect values \n                planar.color += tempPlanar.color;\n                planar.normal += tempPlanar.normal;\n            }\n            planar.color /= float(TEMPORALBLUR);\n            \n            // Variance restoration with normalization (very visible in the Stars)\n            float squaredAlphaSum = getSquaredAlphaSum(normal, CONTRAST);\n                        \n            // Sampling mips lowest level to get the mean. Could be a constant if known.\n            vec3 mean = vec3(0.576,0.455,0.404); // textureLod(tex, uvX, 12.).xyz; \n\n            // Variance restoration with normalization (very visible in the Stars)\n            planar.color = mean + (planar.color - mean) / sqrt(squaredAlphaSum);\n\n            // technically wrong but looks the same as Slerp\n            planar.normal = normalize(planar.normal / float(TEMPORALBLUR)); \n        #endif\n\n        #ifdef SHOWGRID\n            // Show unlit color\n            color = planar.color;\n        #else\n            // Apply lighting to show the normals too\n            color = phongLighting(planar.color, planar.normal, ro, lightDir);\n        #endif       \n    } else {\n        // Background mapping\n        vec3 normal = rd;       \n        \n        // Sample albedo textures for stars\n        // disabling dithering as the edge is invisible anyway with stars\n        materialValues planar = uniplanar(iChannel1, normal, vec2(1), 0., 2., CONTRAST);\n        \n        #ifdef SHOWGRID\n            // Show unlit color\n            color = planar.color;\n        #else        \n            // Make stars less bright\n            float stars = pow(planar.color.x * planar.color.y * planar.color.z,2.);\n            vec3 albedo = planar.color * stars; // Make stars colorful\n            \n            // Create sun with halo\n            vec3 sun = sun(normal, lightDir);\n\n            // Combine stars albedo and sunlight\n            color = max(albedo - sun, 0.) + sun;\n        #endif \n    }\n    \n    #ifndef SHOWGRID\n        // Fresnel mask for atmosphere\n        float fresnel = pow(clamp(1.-abs(t.y), 0., 1.), 32.);\n        color = mix(color, vec3(0.404,0.302,0.275), fresnel);\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_________________________GENERIC FUNCTIONS_____________________________________\n#define SUN_COLOR vec3(1.0, 0.9, 0.7)\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.15;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.0;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\n#define ONE_OVER_PI 0.3183098861836\nvec3 sun(vec3 normal, vec3 lightDir) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Prevent Nan errors with fron acos\n    NdotL = clamp(NdotL, -1., 1.);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) * ONE_OVER_PI;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 25.0) * 2.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// This function creates a simple sun with a halo effect.\n#define ONE_OVER_PI 0.3183098861836\nvec3 sunSpace(vec3 normal, vec3 lightDir) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Prevent Nan errors with fron acos\n    NdotL = clamp(NdotL, -1., 1.);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) * ONE_OVER_PI;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 12.0) * 2.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 heightToNormal(sampler2D tex, vec2 uv, vec2 duvdx, vec2 duvdy, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = textureGrad(tex, uv, duvdx, duvdy).x;\n    float h1 = textureGrad(tex, uv + s * vec2(textureOffset,0), duvdx, duvdy).x;\n    float v1 = textureGrad(tex, uv + s * vec2(0,textureOffset), duvdx, duvdy).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return safeNormalize(vec3(xy * strength, 1.0), vec3(0,0,1));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3BzS.jpg", "access": "api", "license": "mit", "functions": [[2196, 2384, 2440, 2440, 2549], [2653, 2674, 2811, 2850, 6246], [6248, 6393, 6448, 6487, 6911], [7058, 7058, 7079, 7079, 7131], [7133, 7133, 7171, 7171, 7341], [7343, 7343, 7400, 7400, 11083]], "test": "untested"}
{"id": "DdcBDS", "name": "remix2Claude2", "author": "Sergeindamix", "description": "https://claude.ai/chat/96c9649e-0955-4449-b0f8-9187b5fb50b3", "tags": ["lights"], "likes": 0, "viewed": 98, "published": 3, "date": "1697564205", "time_retrieved": "2024-07-30T17:27:26.794369", "image_code": "#define ROT(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat tunnel(vec2 uv) {\nfloat r = pow(pow(abs(uv.x),18.0)+pow(abs(uv.y),10.0), 1.8/28.0);\nreturn r;\n}\n\nvec2 texture(vec2 uv) {\nuv = fract(2.0*uv) - 0.5;\nreturn uv;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\nvec2 uv = (fragCoord.xy/iResolution.xy) * 2.0 - 1.0;\n\n// tunnel effect\nfloat r = tunnel(uv);\n\n// rotating\nuv *= ROT(iTime);\n\n// texturing\nvec2 tex = texture(uv);\n\n// lighting\nvec3 col = vec3(uv, 0.0) + 0.12;\n\n// apply tunnel\n\ncol *= 1.0/r;\n\n// final color\nfragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdcBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 74, 74, 152], [154, 154, 177, 177, 217], [219, 219, 274, 274, 562]], "test": "untested"}
{"id": "cdcBDS", "name": "remixClaude2", "author": "Sergeindamix", "description": "https://claude.ai/chat/96c9649e-0955-4449-b0f8-9187b5fb50b3", "tags": ["kaleidoscope"], "likes": 0, "viewed": 87, "published": 3, "date": "1697563972", "time_retrieved": "2024-07-30T17:27:27.679004", "image_code": "#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define smoothstep(a, b, x) mix(a, b, smoothstep(0.0, 1.0, (x - a) / (b - a)))\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdCircle(in vec2 p, in float r) {\nreturn length(p) - r;\n}\n\nfloat sdSquare(in vec2 p, in float r) {\nvec2 d = abs(p) - vec2(r);\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\nvec2 q = fragCoord/iResolution.xy;\nq = -1.0 + 2.0*q;\nq.x = abs(q.x);\n\nfloat time = mod(iTime, 10.0); // loop 0 a 10\n\nfloat transition = 0.0;\nif (time < 5.0) {\ntransition = smoothstep(0.0, 5.0, time);\n} else {\ntransition = smoothstep(5.0, 0.0, time - 5.0); // invertido\n}\n\nfloat d;\nif (time < 5.0) {\nd = mix(sdCircle(q, 0.5), sdSquare(q, 0.5), transition);\n} else {\nd = mix(sdSquare(q, 0.5), sdCircle(q, 0.5), transition);\n}\n\nvec3 col = vec3(0.0);\nif (d < 0.0) {\ncol = 0.5 + sin(vec3(0.0, 1.0, 2.0) + d*10.0);\n}\n\ncol += sin(d*10.0);\nfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 191, 191, 400], [403, 403, 442, 442, 466], [468, 468, 507, 507, 590], [592, 592, 649, 649, 1211]], "test": "untested"}
{"id": "7tf3Ds", "name": "Real and Complex Projective Maps", "author": "mla", "description": "Overlay a complex one-dimensional and real two-dimensional projective map where the two maps agree on the unit circle in the complex plane. Use keys 1 and 2 to see the maps separately.", "tags": ["complex", "projective", "homography", "real", "collineation"], "likes": 11, "viewed": 201, "published": 3, "date": "1697556625", "time_retrieved": "2024-07-30T17:27:28.441965", "image_code": "// Real and Complex Projective Maps, mla, 2023\n//\n// Overlay a complex one-dimensional and real two-dimensional projective map\n// where the two maps agree on the unit circle in the complex plane. The maps\n// are generated from the red, blue and green points on the circle and their\n// projections to the real line.\n//\n// Controls:\n//\n// <mouse>: move blue and green points on the circle\n// '1': hide real map\n// '2': hide complex map\n// 'd': don't highlight unit disc\n//\n// A one dimensional (real or complex) projective map can be defined by \n// giving three pairs of corresponding points (see rproject2()), \n// and a two dimensional (real) map by giving four pairs.\n//\n// Take three points on the unit circle (in the complex plane) \n// and stereographically map them to the real line, where they\n// can be paired with the points 0,1,∞ to define a map on the real\n// line. This map can then be extended to a Mobius transformation \n// of the whole complex plane, that leaves the real line\n// invariant, and so also leaves the unit circle invariant under inverse\n// stereographic projection.\n//\n// Alternatively, -1 on the real line can be mapped back to the circle\n// and used with the original three points to define a 2-dimensional (real) \n// projective map that also leaves the unit circle invariant (and in fact\n// is the same map as the first when restricted to the unit circle).\n//\n// Anyway, the result is that we have two projective maps, a one-dimensional\n// complex map, and a two-dimensional real map, that agree on the unit\n// circle, and here they are shown overlaid, together with the generating\n// circle points and their projections (the yellow point is the one mapped\n// to -1).\n\n// Project from (0,1) to y = 0 plane\n// We could just use an inversion (for both ways)\n// Return homogeneous coordinates\nvec2 stereographic(vec2 z) {\n  return vec2(z.x,1.0-z.y);\n}\n\n// Inverse projection from y = 0 (as a homogeneous coordinate) to unit sphere\n// with (0,1) as projection point.\nvec2 istereographic(vec2 z) {\n  if (z.y == 0.0) return vec2(0,1);\n  // |k(x,0)+(1-k)(0,1)| = |kx,1-k| = 1 => k²x²+1-2k+k² = 1 => k(x²+1) = 2\n  float x = z.x/z.y;\n  float k = 2.0/(x*x+1.0);\n  return vec2(k*x,1.0-k);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  vec3 p3a = m*p3;\n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if collinear\n  m[0] /= p3a[0];\n  m[1] /= p3a[1];\n  m[2] /= p3a[2];\n  m = transpose(m);\n  return m;\n}\n\n// Return 2x2 matrix that maps p0,p1,p2 to (1,0),(0,1) and (1,1)\nmat2 rproject2(vec2 p0, vec2 p1, vec2 p2) {\n  mat2 m = inverse(mat2(p0,p1)); // column major!\n  vec2 p2a = m*p2;\n  // Then scale each row so the unit point (1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p2a[0];\n  m[1] /= p2a[1];\n  m = transpose(m);\n  return m;\n}\n\nvec2 circle(float t) {\n  // Origin at north pole is convenient\n  return vec2(sin(t),cos(t));\n}\n\n// Screen coords to P2 coords\nvec2 map(vec2 p) {\n  return (2.0*p - iResolution.xy) / iResolution.y;\n}\n\n// Invert unit circle to upper half plane\n// Centre of inversion (0,-1), r² = 2\nvec2 cayley(vec2 z) {\n  z -= vec2(0,1);\n  z *= 2.0/dot(z,z);\n  z += vec2(0,1);\n  return z;\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  if (a == b) return 1e8;\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}\n\n// color = point(color,z,p,vec3(1,0,0));\nvec3 point(vec3 color, vec2 z, vec2 p, vec3 pcolor, float px) {\n  z -= p;\n  color *= 0.4+0.6*smoothstep(0.0,px,length(z)-0.03);\n  color = mix(pcolor,color,0.4+0.6*smoothstep(0.0,px,length(z)-0.02));\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = 1.1*map(fragCoord.xy);\n  vec2 mouse = vec2(1,0.5); // Identity\n  if (iMouse.x > 0.0) mouse = map(iMouse.xy);\n  float a = 0.0;\n  a = 0.2*iTime;\n  float b = PI*mouse.x;\n  float c = PI*mouse.y;\n  vec2 p = circle(a);\n  vec2 q = circle(b);\n  vec2 r = circle(c);\n  // p1 etc. are 1d homogeneous\n  vec2 p1 = stereographic(p);\n  vec2 q1 = stereographic(q);\n  vec2 r1 = stereographic(r);\n  // h is homography on (real) line: p1,q1,r1,=> (1,0),(0,1),(1,1)\n  // and extends to the complex plane, with the real axis preserved\n  mat2 h = rproject2(p1,q1,r1);\n  // The fourth point, parameter -1\n  vec2 s1 = inverse(h)*vec2(1,-1); // On the line\n  vec2 s = istereographic(s1);     // On the circle\n  // Now p,q,r,s are base points for collineation\n  // m takes p,q,r,s to points (1,0,0),(0,1,0),(0,0,1),(1,1,1)\n  mat3 m = rproject(vec3(p,1),vec3(q,1),vec3(r,1),vec3(s,1));\n\n  // n takes compass points to unit points\n  vec3 p0 = vec3(0,1,1);  // = istereographic(vec2(1,0));\n  vec3 q0 = vec3(0,-1,1); // = istereographic(vec2(0,1));\n  vec3 r0 = vec3(1,0,1);  // = istereographic(vec2(1,1));\n  vec3 s0 = vec3(-1,0,1); // = istereographic(vec2(1,-1));\n  mat3 n = rproject(p0,q0,r0,s0); // n is a constant transformation\n\n  // combine, since the four point pairs are those of a homography on the circle,\n  // this results in a transformation that leaves the unit circle invariant.\n  m = inverse(n)*m;\n\n  vec3 color = vec3(0);\n  int k = 0;\n  if (!key(CHAR_0+1)) {\n    vec3 p = m*vec3(z,1);\n    vec2 w = p.xy/p.z;;\n    color += texture(iChannel0,0.5*w+0.5).xyz;\n    k++;\n  }\n  if (!key(CHAR_0+2)) {\n    // Map to half plane & apply a real parameter Mobius transformation\n    // (so preserving the real axis).\n    vec2 w = cayley(z);\n    {\n      float a = h[0][0];\n      float b = h[1][0];\n      float c = h[0][1];\n      float d = h[1][1];\n      // Negative discriminant means inside/outside are flipped.\n      //assert(a*d-b*c > 0.0);\n      w = cdiv(a*w+vec2(b,0),c*w+vec2(d,0));\n    }\n    // Back to unit circle\n    w = cayley(w);\n    color += texture(iChannel0,0.5*w+0.5).xyz;\n    k++;\n  }\n  if (k == 0) color = vec3(1,1,0.5);\n  else if (k > 1) color /= float(k);\n  if (!key(CHAR_D) && length(z) > 1.0) color *= 0.5;\n\n  float px = 1.2*fwidth(z.x);\n  float d = 1e8;\n  d = min(d,abs(length(z)-1.0));\n  d = min(d,line(z,vec2(0,1),p));\n  d = min(d,line(z,vec2(0,1),q));\n  d = min(d,line(z,vec2(0,1),r));\n  d = min(d,line(z,vec2(0,1),s));\n  d = min(d,abs(z.y));\n  color *= 0.4+0.6*smoothstep(0.0,px,d-0.005);\n\n  color = point(color,z,vec2(0,1),vec3(1),px);\n  color = point(color,z,p,vec3(1,0,0),px);\n  color = point(color,z,vec2(p1.x/p1.y,0),vec3(1,0,0),px);\n  color = point(color,z,q,vec3(0,1,0),px);\n  color = point(color,z,vec2(q1.x/q1.y,0),vec3(0,1,0),px);\n  color = point(color,z,r,vec3(0,0,1),px);\n  color = point(color,z,vec2(r1.x/r1.y,0),vec3(0,0,1),px);\n  color = point(color,z,s,vec3(1,1,0),px);\n  color = point(color,z,vec2(s1.x/s1.y,0),vec3(1,1,0),px);\n\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265359;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nconst int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\nconst int CHAR_D = 68;\n\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1699, 1820, 1848, 1848, 1878], [1880, 1993, 2022, 2022, 2213], [2215, 2403, 2454, 2561, 2847], [2849, 2914, 2957, 2957, 3224], [3226, 3226, 3248, 3288, 3320], [3322, 3352, 3370, 3370, 3423], [3425, 3506, 3527, 3527, 3598], [3600, 3600, 3639, 3639, 3740], [3742, 3742, 3778, 3778, 3879], [3881, 3922, 3985, 3985, 4138], [4140, 4140, 4197, 4197, 7246]], "test": "untested"}
{"id": "ddtBzl", "name": "Metaballs V2", "author": "MrNissenDK", "description": "I was working on something else but to test the randomness I started to create these metaballs", "tags": ["metaballs", "colorful", "random"], "likes": 2, "viewed": 224, "published": 3, "date": "1697550565", "time_retrieved": "2024-07-30T17:27:29.355521", "image_code": "#define numOfPoints 30\n#define seed (35487457)\n#define a (1103515245)\n#define c (12345)\n#define m (1<<31)\nfloat rand(int i) {\n    uint ui = uint(i);\n    uint ua = uint(a);\n    uint uc = uint(c);\n    uint useed = uint(seed);\n    ui += ua + useed;\n    float v = float(ua * ui + uc + useed + useed);\n    if (v == 0.) v = 1.;\n    return abs(float(ui) / v);\n}\nfloat rand(float i) {\n    float k = i;\n    if (i == 0.) k = 1.;\n    int i2 = int(i * 10000.0 + 500. / k);\n    return (rand(int(i)) + rand(i2)) / 2.0;\n}\nvec3 hash23(vec2 src) {\n    vec3 randV = vec3(rand(src.x), rand(src.y), rand(src.x * src.y + src.x + src.y + 8912.2793));\n    randV += dot(randV, randV+vec3(3799.6274,9567.3518,8575.2724));\n    \n    return fract(randV);\n}\nvec2 hash32(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y)) + vec2(rand(src.z), rand(src.z + 9463.9522));\n    randV += dot(randV, randV+vec2(8183.0119,4912.9833));\n    \n    return fract(randV);\n}\nfloat d(vec2 p0, vec2 p1) {\n    return sqrt(pow(p0.x - p1.x, 2.0) + pow(p0.y - p1.y, 2.0));\n}\n\nvec2 closest(vec2 points[numOfPoints], vec2 pos) {\n    int current = 0;\n    float l = d(pos, points[0]);\n    for(int i = 1; i < numOfPoints; i++) {\n        float nLen = d(pos, points[i]);\n        if( l < nLen ) {\n            l = nLen;\n            current = i;\n        }\n    }\n    return points[current];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y);\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(0);//hash23(fragCoord);\n    for(int i = 0; i < numOfPoints; i++) {\n        vec2 pointBase = vec2(float(i) + 6939.9375, float(numOfPoints - i) + 539.2171);\n        float time = iTime / 5.;\n        float t = fract(time);\n        vec2 prev = hash32(vec3(pointBase, floor(time)));\n        vec2 next = hash32(vec3(pointBase, ceil(time)));\n        vec2 point = (prev + ((next - prev) * t)) * iResolution.xy;\n        float dist = d(point, fragCoord);\n        \n        vec3 col1 = hash23(prev);\n        vec3 col2 = hash23(next);\n        \n        if(dist < 100.) col += (col1 + ((col2 - col1) * t))  * smoothstep(1., 0., dist / 100.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddtBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 125, 125, 354], [355, 355, 376, 376, 506], [507, 507, 530, 530, 728], [729, 729, 752, 752, 936], [937, 937, 964, 964, 1030], [1032, 1032, 1082, 1082, 1337], [1339, 1339, 1396, 1396, 2215]], "test": "untested"}
{"id": "DstfRl", "name": "Line tunel", "author": "Chalouek", "description": "my first shader on shadertoy", "tags": ["rainbow"], "likes": 4, "viewed": 175, "published": 3, "date": "1697549902", "time_retrieved": "2024-07-30T17:27:30.153388", "image_code": "const float pi = 3.14159265358979323846264338327950288;\n\nfloat mapmove(vec2 uv, float speed)\n{\n\n    float map = pow(abs(uv.x-0.5),0.1)*pi;\n    map *= 10.;\n    map -= iTime*speed;\n    return map;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float ctrst = exp(uv.y+1./2.);\n\n    vec3 col2 = vec3(sin(mapmove(uv,2.)),sin(mapmove(uv,3.)),sin(mapmove(uv,9.)));\n    col2 += ctrst/2.;\n    col2 /= ctrst;\n    // Output to screen\n    fragColor = vec4(col2,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 94, 94, 196], [198, 198, 255, 255, 512]], "test": "untested"}
{"id": "mdcBz8", "name": "Triplanar with Normals", "author": "gehtsiegarnixan", "description": "Generic tripalanr Mapping with Normals using tangent space matrixes. ", "tags": ["3d", "texture", "triplanar", "uv", "normal", "mapping", "tbn"], "likes": 11, "viewed": 298, "published": 3, "date": "1697541528", "time_retrieved": "2024-07-30T17:27:30.977185", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a small demonstration of how to implement triplanar mapping with accurate \nnormals. I noticed that other implementations lacked clear explanations for their \nnormal to world space mathematics or comments. Therefore, I derived it from scratch \nby constructing the tangent space matrices for the three projections. This mapping \nalso ensures that all textures are oriented correctly.\n\nSeveral global constants are defined below to enable debug views of the\nmapping, as well as mouse controls for navigation.\n\nSee here for a detailed view of the TBN matrix for triplanar:\nhttps://www.shadertoy.com/view/md3BzS\n\nSee here how to make this ~3x faster while looking the same: \nhttps://www.shadertoy.com/view/Ds3BzS\n*/\n\n// A value of 1 means no contrast, higher values increase contrast\n#define CONTRAST 16.0\n\n// This visualizes the blend region between the two cubemappings\n// Green, Red and Blue represent the upper and lower bounds of the weights\n//#define SHOWGRID\n#define LINETHICKNESS 0.01\n\n// Structure to hold material properties\nstruct materialValues {\n    vec3 color;\n    vec3 normal;\n};\n\n// Triplanar mapping\nmaterialValues triplanar(sampler2D tex, vec3 normal, float scale, float contrast) {   \n    // Calculate sign for flipping sides\n    vec3 sgn = sign(normal);\n    \n    // Scale coordinates. Replace normal with world coordinates if not a sphere\n    vec3 uvwC = normal * scale;\n    \n    // Coordinate projections all right side up with slightly different offsets\n    vec2 uvX = vec2(uvwC.y * sgn.x, uvwC.z) + 0.25; \n    vec2 uvY = vec2(-uvwC.x * sgn.y, uvwC.z) + 0.5; \n    vec2 uvZ = vec2(uvwC.x * sgn.z, uvwC.y) + 0.75; \n\n    // Sample textures for cardinal directions\n\tvec3 colorX = texture(tex, uvX).xyz;\n\tvec3 colorY = texture(tex, uvY).xyz;\n\tvec3 colorZ = texture(tex, uvZ).xyz;\n    \n    // Sample normal, if possible use a normal texture instead in tangent space\n    vec3 tsNormalX = heightToNormal(tex, uvX, iChannelResolution[0].xy, 5.0);\n    vec3 tsNormalY = heightToNormal(tex, uvY, iChannelResolution[0].xy, 5.0);\n    vec3 tsNormalZ = heightToNormal(tex, uvZ, iChannelResolution[0].xy, 5.0);\n    \n    // Tangent is the direction of uvX.x in world space\n    vec3 tangentX = safeNormalize(cross(normal, vec3(0,0,-1)), vec3(0,sgn.x,0));  \n    \n    // Bitangent is the direction of uvY.y in world space. Is not perpendicular to tangent!\n    vec3 bitangentX = cross(normal, vec3(0,sgn.x,0));\n    \n    // Tangent Bitangent Normal (tbn) matrix to translate normal textures to world space normals\n    mat3 tbnX = mat3(tangentX, \n                     bitangentX, \n                     normal); // Normal vector straight up from the surface\n                     \n    // TBN matric for the Y sides\n    vec3 tangentY = safeNormalize(cross(normal, vec3(0,0,-1)), vec3(-sgn.y,0,0));\n    vec3 bitangentY = cross(normal, vec3(-sgn.y,0,0));\n    mat3 tbnY = mat3(tangentY,\n                     bitangentY,\n                     normal);\n                     \n    // TBN matric for the Z sides\n    vec3 tangentZ = safeNormalize(cross(normal, vec3(0,-1,0)), vec3(sgn.z,0,0));\n    vec3 bitangentZ = cross(normal, vec3(sgn.z,0,0));\n    mat3 tbnZ = mat3(tangentZ,\n                     bitangentZ,\n                     normal);\n    \n    // Translate normals to world space\n    vec3 wsNormalX = tbnX * tsNormalX;\n    vec3 wsNormalY = tbnY * tsNormalY;\n    vec3 wsNormalZ = tbnZ * tsNormalZ;\n        \n    // Weights/Alpha for interpolation\n    vec3 weights = abs(normal);\n    \n    // Increase contrast of weights for sharper transitions\n    weights = smoothContrast(weights, contrast);\n    \n    // Color interpolation\n    vec3 color = colorX * weights.x + \n                 colorY * weights.y + \n                 colorZ * weights.z;\n    \n    // Interpolate normals. Slerp may be better but the difference is not noticeable.\n    vec3 normalWS = normalize(wsNormalX * weights.x + \n                              wsNormalY * weights.y + \n                              wsNormalZ * weights.z);\n        \n    // NB: trick published in https://hal.inria.fr/inria-00536064v2\n    // Deeper conservation: see histogram-preserving here: https://hal.inria.fr/hal-01824773\n    // Modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \n    float squaredAlphaSum = weights.x * weights.x +\n                            weights.y * weights.y +\n                            weights.z * weights.z ; // = dot(weights, weights)         \n            \n    // Sampling mips lowest level to get the mean. Can be a constant if known.\n    vec3 mean = textureLod(tex, uvX, 12.).xyz;//  vec3(0.576,0.455,0.404);\n\n    // Variance restoration with normalization (very visible in the Stars)\n    color = mean + (color - mean) / sqrt(squaredAlphaSum);\n    \n    #ifdef SHOWGRID\n        // Overlaying the edges of the alpha mask\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        color = max(mask, color);\n    #endif\n    return materialValues(color, normalWS);\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n    } else {\n        mx = mm2(-iTime*.1+um.x*5.);\n        my = mm2(iTime*0.05+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n\n    vec3 lightDir = normalize(vec3(1,0,1));\n\n    // Alternate between background and sphere mapping\n    vec3 color;\n    if (t.x > 0.) {\n        // Sphere mapping\n    \tvec3 normal = ro + rd * t.x;\n        \n        // Sample albedo textures\n        materialValues planar = triplanar(iChannel0, normal, 0.7, CONTRAST);\n        \n        #ifdef SHOWGRID\n            // Show unlit color\n            color = planar.color;\n        #else\n            // Apply lighting to show the normals too\n            color = phongLighting(planar.color, planar.normal, ro, lightDir);\n        #endif       \n    } else {\n        // Background mapping\n        vec3 normal = rd;       \n        \n        // Sample albedo textures\n        materialValues planar = triplanar(iChannel1, normal, 2., CONTRAST);\n        \n        #ifdef SHOWGRID\n            // Show unlit color\n            color = planar.color;\n        #else        \n            // Make stars less bright\n            float stars = pow(planar.color.x * planar.color.y * planar.color.z,2.);\n            vec3 albedo = planar.color * stars; // Make stars colorful\n            \n            // Create sun with halo\n            vec3 sun = sun(normal, lightDir);\n\n            // Combine stars albedo and sunlight\n            color = max(albedo - sun, 0.) + sun;\n        #endif \n    }\n    \n    #ifndef SHOWGRID\n        // Fresnel mask for atmosphere\n        float fresnel = pow(clamp(1.-abs(t.y), 0., 1.), 32.);\n        color = mix(color, vec3(0.404,0.302,0.275), fresnel);\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_________________________GENERIC FUNCTIONS_____________________________________\n#define SUN_COLOR vec3(1.0, 0.9, 0.7)\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.15;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.0;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\n#define ONE_OVER_PI 0.3183098861836\nvec3 sun(vec3 normal, vec3 lightDir) {\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Prevent Nan errors with fron acos\n    NdotL = clamp(NdotL, -1., 1.);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) * ONE_OVER_PI;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 25.0) * 2.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 heightToNormal(sampler2D tex, vec2 uv, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(tex, uv).x;\n    float h1 = texture(tex, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(tex, uv + s * vec2(0,textureOffset)).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return safeNormalize(vec3(xy * strength, 1.0), vec3(0,0,1));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcBz8.jpg", "access": "api", "license": "mit", "functions": [[2182, 2203, 2286, 2330, 6048], [6195, 6195, 6216, 6216, 6268], [6271, 6271, 6309, 6309, 6479], [6481, 6481, 6538, 6538, 8634]], "test": "untested"}
{"id": "md3BzS", "name": "Tanget Space Matrix Triplanar", "author": "gehtsiegarnixan", "description": "I made this tangent space matirx from scratch for triplanar mapping. ", "tags": ["3d", "derivative", "mapping", "cubemapping", "matrix", "tangent", "cubesphere", "finitedifference", "tangentspace", "tbn"], "likes": 5, "viewed": 172, "published": 3, "date": "1697541513", "time_retrieved": "2024-07-30T17:27:31.836886", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis demo shows the process of translating a vector between tangent \nand world space for sphere mapping without relying on any vertices.\nThis methodology proves particularly valuable for tasks like \ntranslating wind directions between world and tangent space.\n\nTo achieve this, it is necessary to generate the normal, tangent, \nand bitangent vectors corresponding to your mapping. The normal \nvector points upwards from the surface of the mapping, while the \ntangent vector aligns with the +X direction of your UV mapping in \nworld space. Similarly, the bitangent vector corresponds to the +Y \ndirection of your UV mapping.\n\nThese vectors are combined within a 3x3 matrix. When this matrix is \nmultiplied by a vector, it effectively transforms the vector to \nworld space. Conversely, the inverse of this matrix facilitates the \ntranslation of a vector from world space back to the tangent space \nof your mapping.\n\nThe visual representation is a fusion of a flow plot, which showcases \n3D coordinates in world space on a surface by displacing flowlines. \nThe wind direction is oriented perpendicular to this surface, \nmimicking the behavior of water waves. The arrows within the plot \nare in tangent space, indicating the direction of the vector in \ntangent space.\n\nSee here how the quiverplot works:\nhttps://www.shadertoy.com/view/dssyzf\n\nSee here for an application of triplanar mapping:\nhttps://www.shadertoy.com/view/mdcBz8\n\nThis plot has mouse controls to look around. Play with the constants\nbelow to edit the visualized vectors.\n*/\n\n// Define your custom direction here\n//#define DIRECTION vec3(1.,0.,0.)\n\n// enable DIRECTION is worldspace, disable DIRECTION is tangent space\n#define DIRECTIONIWORLDSPACE\n\n// triplanar mapping without blending\nvec3 triplanar(vec3 normal, vec3 direction) {           \n    // Calculate sign for flipping sides\n    vec3 sgn = sign(normal);\n    \n    // Weights/Alpha for interpolation\n    vec3 weights = abs(normal);\n\n    // switch between sides instead of interpolating\n    vec2 uv;\n    mat3 tbn;\n    // The weights are grouped cumulatively, and if the dither value is within one \n    // cumulative section for one of the weights, that weight is selected.\n    if (weights.x > weights.y && weights.x > weights.z) {\n        // X-axis Side\n        // Coordinate projections all right side up\n        uv = vec2(normal.y * sgn.x, normal.z) + 0.5;\n        \n        // Tangent is the direction of uvX.x in world space\n        vec3 tangentX = safeNormalize(cross(normal, vec3(0,0,-1)), vec3(0,sgn.x,0));   \n        \n        // Bitangent is the direction of uvY.y in world space.\n        vec3 bitangentX = cross(normal, vec3(0,sgn.x,0));\n        \n        // Tangent Bitangent Normal matrix to translate normal textures to world space normals.\n        tbn = mat3(tangentX, \n                   bitangentX, \n                   normal); // Normal vector straight up from the surface.\n                   \n    } else if (weights.y > weights.z) { // Because sum of all weights is 1, so 1-z = sum of xy.\n        // Y-axis Side\n        uv = vec2(-normal.x * sgn.y, normal.z) + 0.5;\n       \n        // Tangent is the direction of uvY.x in world space\n        vec3 tangentY = safeNormalize(cross(normal, vec3(0,0,-1)), vec3(-sgn.y,0,0));\n        \n        // Bitangent is the direction of uvY.y in world space\n        vec3 bitangentY = cross(normal, vec3(-normal.y,0,0));\n        \n        // Join vectors into TBN matrix\n        tbn = mat3(tangentY,\n                   bitangentY,\n                   normal);\n    } else {\n        // Z-axis Side \n        uv = vec2(normal.x * sgn.z, normal.y) + 0.5;        \n        \n        // Tangent is the direction of uvZ.x in world space\n        vec3 tangentZ = safeNormalize(cross(normal, vec3(0,-1,0)), vec3(sgn.z,0,0));\n\n        // Bitangent is the direction of uvZ.y in world space\n        vec3 bitangentZ = cross(normal, vec3(sgn.z,0,0));\n        \n        // Join vectors into TBN matrix\n        tbn = mat3(tangentZ,\n                   bitangentZ,\n                   normal);\n    }\n\n    #ifdef DIRECTIONIWORLDSPACE\n        // translate world space vector to tangent space\n        vec3 directionWS = direction;\n        vec2 directionTS = vec3(inverse(tbn) * direction).xy;\n    #else\n        // translate tangent space vector to world space\n        vec3 directionWS = tbn * direction;\n        vec2 directionTS = direction.xy;\n    #endif\n        \n    // quiver plot in tangent space\n    float arrowscale = 10.;\n    float tsPlot = quiverPlot(uv, directionTS, arrowscale);   \n    \n    // World Space flow plot\n    float time = iTime * 0.25;\n    vec3 wsPlot = flowPlot(normal, directionWS, time);\n\n    return max(wsPlot, vec3(tsPlot));\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx = mm2(um.x*5.);\n    mat2 my = mm2(um.y*5.);\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float t = iSphere(ro,rd);\n    \n    // nice spinning animation while unset\n    #ifdef DIRECTION\n        vec3 direction = DIRECTION;\n    #else\n        float time = iTime * 0.5;\n        float c = cos(time);\n        float s = sin(time);\n        vec3 direction = vec3(c*s,s*s,c);\n    #endif\n    \n    vec3 col;\n    \n    if (t > 0.)\n    {\n        // Sphere mapping\n    \tvec3 pos = ro+rd*t;\n    \tcol = triplanar(pos, direction);\n    } else {\n        // Background mapping\n        vec3 pos = rd;  \n        col = direction;\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Generic Functions _________________________________________\n\n// Safe Normalization avoiding division by zero with alternate\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec3 safeNormalize(vec3 vector, vec3 alternate) {\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(vector, vector);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n        // If so, normalize the vector resuing the squared length\n        return vector / sqrt(lenSq);\n        \n    } else {\n        // Otherwise, return a alternate vector\n        return alternate;\n    }\n}\n\n//_____________________Quiver Plot______________________________\n\n// Rotate coordinates in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\n// Generates a grid of arrows that point in the direction\nfloat quiverPlot(vec2 uv, vec2 direction, float gridSize) {\n    float lineThickness = 0.03;    // Thickness of the arrow line\n    float tipSteepness = 3.0;      // Controls the angle of the arrow tip\n\n    float maxSize = 0.9;           // Maximum arrow length (1 should be the max)\n    float minSize = 0.2;           // Minimum arrow length\n\n    // Calculate the square of the length of the vector\n    float lenSq = dot(direction, direction);\n    \n    // Check if the squared length is greater than a tiny threshold\n    if (lenSq > SMALLESTFLOAT) {\n    \n        // break UV coordinates into grid sections\n        uv = fract(uv * gridSize) - 0.5;\n\n        // caculate the direction vector length    \n        float vectorLen = sqrt(lenSq); \n\n        // Scale uv by vector size\n        float size = mix(minSize, maxSize, clamp(vectorLen, 0.,1.)); \n        uv /= size;\n\n        // Rotate UV coordinates based on the normalized direction vector\n        uv = rotateUV(uv, direction / vectorLen);\n\n        // absolute position\n        float absV = abs(uv.x);\n\n        // Calculate center line of the arrow shape\n        float lineOffset = tipSteepness * lineThickness; // offset so lines doesn't go over the tip\n        float line = max(absV, abs(uv.y + lineOffset) - 0.5 + lineOffset);\n\n        // Caculation of the Arror Tip\n        float tip = max(abs((uv.y / tipSteepness) + absV - (0.5 / tipSteepness) + lineThickness), -uv.y + 0.1);\n\n        // Combine line and tip to create the arrow shape\n        float arrowDist = min(tip, line) - lineThickness;\n\n        // Create a mask based on the arrow shape\n        return step(arrowDist, 0.0); // no AA\n        //float blur = (gridSize * 1.0)/(size * 720.);\n        //return  smoothstep(blur, -blur, arrowDist) ; // cheap AA\n        \n    } else {\n        // if the direction length is 0. then no arrows\n        return 0.;\n    }    \n}\n\n//_____________________Flow Plot______________________________\n\n// 3D cube grid with lines in RGB for XYZ axes\nvec3 cubeGrid(vec3 uvw, float lineThickness) {\n    // Side distance of the cube\n    vec3 sideDistBig = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Smaller scaled side distance of the cube\n    float detailScale = 4.0;\n    uvw *= detailScale;\n    vec3 sideDistDetail = abs(fract(uvw + 0.5) - 0.5);\n    \n    // Merge grids\n    vec3 joined = min(sideDistBig, sideDistDetail);\n    \n    // Create hard outlines of sides\n    return step(joined, vec3(lineThickness)); \n}\n\n// viszalizes 3D Vector\nvec3 flowPlot(vec3 uvw, vec3 direction, float time) {\n    // should probably be input paramters\n    float gridScale = 1.3;\n    float lineThickness = 0.02;\n    float vectorScale = 0.15;\n    \n    direction *= vectorScale;\n    \n    uvw *= gridScale;\n    \n    // Static grid (looks calmer)\n    vec3 grid = cubeGrid(uvw, lineThickness);\n    \n    // Animated grid\n    int count = 7;\n    for (int index = 1; index < count; index += 1) {\n        // Unique percentage of each individual grid \n        float percent = fract(float(index) / float(count - 1) + time);        \n        // Fading brightness\n        float brightness = 1.0 - percent;\n        \n        // Scale offset\n        vec3 offset = percent * direction;\n        \n        // Sample grid\n        vec3 aniGrid = cubeGrid(uvw - offset, lineThickness);\n        \n        // Apply brightness which fades with distance\n        aniGrid *= brightness;\n\n        // Add to the existing grid color output\n        grid = max(grid, aniGrid);\n    }\n    \n    return grid;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3BzS.jpg", "access": "api", "license": "mit", "functions": [[2795, 2833, 2878, 2930, 5773], [5920, 5920, 5941, 5941, 5993], [5995, 5995, 6034, 6034, 6187], [6189, 6189, 6246, 6246, 7179]], "test": "untested"}
{"id": "cdtBzl", "name": "Shader Color Practice", "author": "INCHMAN1900", "description": "Practice", "tags": ["glowing"], "likes": 1, "viewed": 171, "published": 3, "date": "1697539263", "time_retrieved": "2024-07-30T17:27:32.854166", "image_code": "#define PI 3.141592653\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float dist = distance(fragCoord, iResolution.xy * 0.5) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(\n        1. - ceil(dist * 10.) * 0.1,\n        cos(dist * PI) + abs(sin(iTime)),\n        sin(dist * PI)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtBzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 131, 468]], "test": "untested"}
{"id": "dd3Bzs", "name": "Complex Mappings 2", "author": "danzabarr", "description": "Samples a texture using a complex mapping.", "tags": ["complex", "complexplane", "mappings"], "likes": 4, "viewed": 134, "published": 3, "date": "1697529652", "time_retrieved": "2024-07-30T17:27:33.709879", "image_code": "\n// Multiply complex numbers a and b\nvec2 complexMultiply(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// Divide complex number a by b\nvec2 complexDivide(vec2 a, vec2 b) {\n    float denom = b.x * b.x + b.y * b.y;\n    return vec2((a.x * b.x + a.y * b.y) / denom, (a.y * b.x - a.x * b.y) / denom);\n}\n\n// Calculate the complex conjugate of a\nvec2 complexConjugate(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\n// Raise complex number a to the power of n\nvec2 complexPower(vec2 a, float n) {\n    float r = length(a);\n    float theta = atan(a.y, a.x);\n    float newR = pow(r, n);\n    float newTheta = theta * n;\n    return newR * vec2(cos(newTheta), sin(newTheta));\n}\n\n// Calculate cos(z) for complex number z\nvec2 complexCos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\n// Calculate sin(z) for complex number z\nvec2 complexSin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\n// Calculate exp(z) for complex number z\nvec2 complexExp(vec2 z) {\n    float r = exp(z.x);\n    return float(r) * vec2(cos(z.y), sin(z.y));\n}\n\n// Calculate log(z) for complex number z\n// This returns the principal value\nvec2 complexLog(vec2 z) {\n    float r = float(length(z));\n    float theta = atan(z.y, z.x);  // in range [-pi, pi]\n    return vec2(log(r), theta);\n}\n\n// Convert a vec3 from hsv to rgb colour space\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Convert 2D vector from cartesian (x,y) to polar (r, theta) coordinates\nvec2 toPolar(vec2 cartesian)\n{\n    float radius = length(cartesian);\n    float theta = atan(cartesian.y, cartesian.x) / 3.1415926535 / 2.0; // normalize to [0,1]\n    \n    // wrap theta\n    theta = theta - (1.0 * floor(theta));\n    theta += 1.0;\n    theta = theta - (1.0 * floor(theta));\n    \n    return vec2(radius, theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // complex number z as a vec2\n    vec2 z = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  // Centered and aspect-corrected\n    \n    \n    // ------- ADD YOUR MAPPING HERE ---------\n    // Map z to a complex function\n    \n    // z -> z^3\n    z = complexPower(z, 2.0);\n\n\n     //z -> z * cos(1/z);\n    //z = complexMultiply(z, complexCos(complexDivide(vec2(cos(iTime), sin(iTime)), z)));\n    \n    // z -> z * exp(1/z^2)\n    //z = complexMultiply(z, complexExp(complexDivide(vec2(cos(iTime), sin(iTime)), complexPower(z, 2.0) ) ));\n    \n    //z = complexDivide(vec2(1, 1), z);\n    \n    //z += vec2(0.5,0.5);\n    // -----------------------------------------\n    \n    \n\n    z -= iMouse.xy / iResolution.y;\n\n   // z += iTime;\n    \n    z *= 5.0;\n\n    // Output to screen\n    fragColor = texture(iChannel0, z);\n}\n", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3Bzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 37, 75, 75, 140], [142, 174, 210, 210, 336], [338, 378, 409, 409, 439], [441, 485, 521, 521, 696], [698, 739, 764, 764, 828], [830, 871, 896, 896, 959], [961, 1002, 1027, 1027, 1101], [1103, 1180, 1205, 1205, 1328], [1330, 1377, 1399, 1399, 1568], [1570, 1644, 1674, 1674, 1969], [1971, 1971, 2028, 2062, 2841]], "test": "untested"}
{"id": "dsGcDc", "name": "Spheremap Mip Fix", "author": "gehtsiegarnixan", "description": " This shader demonstrates a method to mitigate mipmapping issues in sphere mapping by alternating between two sets of partial derivatives, effectively eliminating flickering artifacts along the edge.", "tags": ["3d", "uv", "sphere", "mip", "mapping", "spheremap", "greenwich"], "likes": 2, "viewed": 177, "published": 3, "date": "1697524270", "time_retrieved": "2024-07-30T17:27:34.461869", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nWelcome to a simple demonstration of a method I've devised to address \nmipmapping issues that can arise in sphere mapping. Although this method \nis straightforward and likely not groundbreaking, it cheaply solves \nthe problem.\n\nHere's how it works: we sample the partial derivatives of sphere mapping \nand a 180-degree rotation of longitudinal coordinates. Then, we  \nswitch between these two sets of longitudinal partial derivatives on \nopposite sides of the sphere. This elegant solution resolves mip level \nproblems and eliminates flickering artifacts along the edge of sphere \nmapping, while maintaining the miplevel on the other regions. \n\nThe left side has the broken mips at the texture edge. The right side \nis my fixed version. Feel free to explore this interactive scene using \nmouse controls to adjust your viewpoint and move the border around.\n\nFor more exploration, see my tangent space matrix for spheremaps:\nhttps://www.shadertoy.com/view/ctXfDS\n*/\n\n// Spherical coordinate mapping (Mercator projection)\nvec2 sphereMap(vec3 uvw) {\n    // Mercator projection around the z-axis\n    float u = 0.5 + atan(uvw.y, uvw.x) / (2.0 * 3.1415);\n    float v = 0.5 + asin(uvw.z) / 3.1415;\n    return vec2(u, v);\n}\n\n// Simple spheremap texture sampler with broken mips\nvec4 sphereProjectionBroken(sampler2D tex, vec3 normal, float scale) {\n    // Sample spheremap\n    vec2 uv = sphereMap(normal);\n    \n    // Apply scale\n    uv *= scale;\n        \n    // Sample texture using default mip settings, which are broken\n    return texture(tex, uv);\n}\n\n// Simple spheremap texture sampler with corrected mips\nvec4 sphereProjectionFixed(sampler2D tex, vec3 normal, float scale) {\n    // Sample spheremap\n    vec2 uv = sphereMap(normal);\n    \n    // Append 180-degree flipped uv.x\n    vec3 uvn = vec3(uv, fract(uv.x - 0.5));\n    \n    // Apply scale\n    uvn *= scale;\n    \n    // Calculate partial derivatives of the 3 coordinates\n    vec3 duvndx = dFdx(uvn);\n    vec3 duvndy = dFdy(uvn);\n    \n    // Switch partial derivatives between sphere sides\n    vec2 duvdx;\n    vec2 duvdy;\n    if (normal.x < 0.0) {\n        // Fix edge side\n        duvdx = duvndx.zy;\n        duvdy = duvndy.zy;\n    } else {\n        // Default partial derivatives\n        duvdx = duvndx.xy;\n        duvdy = duvndy.xy;\n    }\n\n    // Sample texture using coordinates and the compound partial derivatives\n    return textureGrad(tex, uvn.xy, duvdx, duvdy);\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec2 iSphere(in vec3 ro, in vec3 rd) {\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    //if(h <0.0) return vec2(-1.);\n    return vec2(-b - sqrt(h), h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(1.5);\n        my = mm2(um.y*7.);\n    } else { \n        mx = mm2(mix(1.0,2.0,sin(iTime*.5)*0.5+0.5));\n        my = mm2(mix(-0.5,0.5,cos(iTime*.5)*0.5+0.5));\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec2 t = iSphere(ro,rd);\n    \n    // Calculate centered UV coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5;\n\n    // Enable mouse controls when clicked, otherwise animate\n    float border = 0.5;    \n    if (iMouse.x > 0.0) {\n        vec2 mouse = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y + 0.5;\n        border = mouse.x;\n    }\n\n    // Alternate between background and sphere mapping\n    vec3 colorA;\n    if (t.x > 0.) {\n        // Sphere mapping\n        vec3 normal = ro + rd * t.x; \n\n        // Alternate between fixed and broken spheremaps\n        vec4 projection;\n        if (uv.x > border) {\n            projection = sphereProjectionFixed(iChannel0, normal, 3.0);\n        } else {\n            projection = sphereProjectionBroken(iChannel0, normal, 3.0);\n        } \n        \n        // Latitude of the sphere projection for cosmetics\n        float lat = sphereMap(normal).x;\n        \n        // Apply looping colormap (rainbow unfortunatly makes the line hard to see)\n        vec3 colormap = twilight_shifted(fract(lat*2.));\n        \n        // Interpolate between Cat and Colormap\n        colorA = mix(colormap, projection.xyz, projection.w);\n        \n    }\n    // Background mapping\n    vec3 normal = rd;\n\n    // Latitude of the sphere projection for cosmetics\n    float lat = sphereMap(normal).x;\n\n    // Create a colorful background\n    vec3 colorB = twilight_shifted(fract((1.-lat) *3.));\n    \n    // Smooth blending of ball with background\n    vec3 color = mix(colorA, colorB, smoothstep(0.02, 0.0, t.y));\n\n    // Add a dividing line\n    color += step(abs(uv.x - border), 0.002);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_________________________GENERIC FUNCTIONS_____________________________________\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See desmos graph example (https://www.desmos.com/calculator/dpxa6mytnv)\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    vec2 powAlpha = pow(vec2(alpha, 1.-alpha), vec2(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha.x/(powAlpha.x + powAlpha.y);\n}\n\n// makes twilight_shifted colormap with polynimal 6\nvec3 twilight_shifted(float t) {\n    const vec3 c0 = vec3(0.120488,0.047735,0.106111);\n    const vec3 c1 = vec3(5.175161,0.597944,7.333840);\n    const vec3 c2 = vec3(-47.426009,-0.862094,-49.143485);\n    const vec3 c3 = vec3(197.225325,47.538667,194.773468);\n    const vec3 c4 = vec3(-361.218441,-146.888121,-389.642741);\n    const vec3 c5 = vec3(298.941929,151.947507,359.860766);\n    const vec3 c6 = vec3(-92.697067,-52.312119,-123.143476);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGcDc.jpg", "access": "api", "license": "mit", "functions": [[2048, 2102, 2128, 2173, 2297], [2299, 2352, 2422, 2446, 2627], [2629, 2685, 2754, 2778, 3501], [3648, 3648, 3669, 3669, 3721], [3723, 3723, 3761, 3761, 3931], [3933, 3933, 3990, 3990, 6215]], "test": "untested"}
{"id": "cs3fzl", "name": "Jwibullori", "author": "catking562", "description": "My First Shader", "tags": ["shader"], "likes": 10, "viewed": 210, "published": 3, "date": "1697506777", "time_retrieved": "2024-07-30T17:27:35.327553", "image_code": "float PI = 3.14159265359;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = 0.02;\n    float sx = iResolution.x;\n    float sy = iResolution.y;\n    float s = sqrt(sx*sx+sy*sy);\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    float j = 0.0;\n    while(size>=0.001) {\n        float x = (cos(iTime*5.0+size*150.0)*s/10.0)/sx;\n        float y = (sin(iTime*5.0+size*150.0)*s/10.0)/sy;\n        float dx = uv.x-x;\n        float dy = uv.y-y;\n        float k = sqrt(dx*dx+dy*dy);\n        j += (size/k)/100.0;\n        size-=0.0001;\n    }\n    float red = cos(PI*(j-1.0/3.0)*3.0/2.0);\n    float green = cos(PI*(j-2.0/3.0)*3.0/2.0);\n    float blue = cos(PI*(j-1.0)*3.0/2.0);\n    fragColor = vec4(red, green, blue, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3fzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 84, 84, 742]], "test": "untested"}
{"id": "WsGXR1", "name": "Squoval", "author": "domrally", "description": "2017 began my search for equations for rounder rects.\nIMPLICIT\ntanh²erf⁻¹x+tanh²erf⁻¹y=1\nPARAMETRIC\nx=erf atanh cos t\ny=erf atanh sin t\nThis has 4 square sides and C-∞ like a circle.\n[url=https://www.shadertoy.com/playlist/fXjyRd]GEOMETRY PLAYLIST[/url]", "tags": ["flat", "math", "sine", "cosine", "smooth", "squircle", "superellipse", "short", "roundrect", "errorfunction", "pade", "squoval", "hyperbolictangent"], "likes": 3, "viewed": 169, "published": 3, "date": "1697502597", "time_retrieved": "2024-07-30T17:27:36.321895", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nBased on domrally's Squoval project.\n    https://domrally.github.io/squoval\nAsymptotically smooth & periodically flat functions.\n    https://en.wikipedia.org/wiki/Smoothness\n    https://en.wikipedia.org/wiki/Flat_function\n*/\nvoid mainImage(out vec4 o, vec2 i)\n{\n    vec2 R = iResolution.xy;\n    i += i - R;\n    float r = min(R.x, R.y);\n\n    /*\n    Inverse error function method by Sergei Winitzki using Padé approximations\n        https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions    \n    */\n    vec2 x = 1.2 * i / r,\n         c = log(1. - x * x),\n         b = 4.33 + c / 2.,\n         a = sqrt(b * b - c / .147),\n         z = tanh(sign(x) * sqrt(a - b));\n    z *= z;\n    float d = 1. - z.x - z.y;\n    \n    o = vec4(smoothstep(0., 25. / r, d));\n}\n\n\n/*\nREFERENCES:\n\nRounded Squares.\nhttps://en.wikipedia.org/wiki/Squircle\nhttps://en.wiktionary.org/wiki/roundrect\nhttps://en.wikipedia.org/wiki/Superellipse\n\nSmoothing.\nhttps://en.wikipedia.org/wiki/Mollifier\nhttps://en.wikipedia.org/wiki/Smoothness\nhttps://en.wikipedia.org/wiki/Flat_function\nhttps://en.wikipedia.org/wiki/Bump_function\nhttps://en.wikipedia.org/wiki/Non-analytic_smooth_function\nhttps://en.wikipedia.org/wiki/Smoothness#Smooth_partitions_of_unity\nhttps://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGXR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 255, 291, 291, 811]], "test": "untested"}
{"id": "dstfRf", "name": "3D Water Box Particles only", "author": "michael0884", "description": "I liked this enough to fork it\n", "tags": ["particle", "sph"], "likes": 55, "viewed": 1291, "published": 3, "date": "1697489637", "time_retrieved": "2024-07-30T17:27:37.328204", "image_code": "// Fork of \"3D Water Box\" by michael0884. https://shadertoy.com/view/dscfRf\n// 2023-10-16 20:53:25\n\n#define SHADOWS \n//#define REFRACTION\n\n#define RADIUS 0.3\n#define NORMAL_SMOOTHNESS 0.0\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvoid iSphere(inout Ray ray, vec4 sphere, vec3 color)\n{\n    vec3 ro = ray.ro - sphere.xyz;\n    float b = dot(ro, ray.rd);\n    float c = dot(ro, ro) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if (h > 0.) \n    {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= 0.0 && d1 <= ray.td) {\n            ray.normal = normalize(ro + ray.rd*d1);\n            ray.color = color;\n            ray.td = d1;\n        } else if (d2 >= 0.0 && d2 <= ray.td) { \n            ray.normal = normalize(ro + ray.rd*d2); \n            ray.color = color;\n            ray.td = d2;\n        }\n    }\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    vec4 packed = LOAD3D(ch0, p);\n    Particle p0, p1;\n    unpackParticles(packed, p, p0, p1);\n\n    if(p0.mass > 0u) iSphere(ray, vec4(p0.pos, RADIUS*1.5), vec3(1.000,1.000,1.000));\n    if(p1.mass > 0u) iSphere(ray, vec4(p1.pos, RADIUS*1.5), vec3(1.000,1.000,1.000));\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec4 rho = voxel(ch1, p);\n    if(rho.z < 1e-3) return;\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\n\nfloat Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nfloat Shadow(vec3 p)\n{\n    float optical_density = trilinear(ch2, p).x;\n    return exp(-optical_density)+0.05;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nfloat TraceDensity(vec3 ro, vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(1.0))) || any(greaterThan(p, size3d - 1.0))) return dens;\n        float d = Density(p);\n        dens += d * 2.0;\n        td += 2.0;\n    }\n    return dens;\n}\n\n\n#define ISO_VALUE 0.5\nfloat ParticleDensity(vec3 p)\n{\n    vec3 p0 = floor(p);\n    float rho = voxel(ch1, p).z;\n    //if(rho < 0.001) return rho;\n    //rho = 0.0;\n    ////if larger then compute accurate density from particles\n    //range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    //{\n    //    //load the particles \n    //    vec3 p1 = p0 + vec3(i, j, k);\n    //    //load the particles\n    //    vec4 packed = LOAD3D(ch0, p1);\n    //    Particle p0_, p1_;\n    //    unpackParticles(packed, p1, p0_, p1_);\n    //    if(p0_.mass > 0u) rho += float(p0_.mass)*GD(length(p0_.pos - p), RADIUS);\n    //    if(p1_.mass > 0u) rho += float(p1_.mass)*GD(length(p1_.pos - p), RADIUS);\n    //}\n\n    return rho;\n}\n\nvec3 ParticleGradient(vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec3 grad = vec3(0.0);\n\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n\n        //load the particles\n        vec4 packed = LOAD3D(ch0, p1);\n        Particle p0_, p1_;\n\n        unpackParticles(packed, p1, p0_, p1_);\n\n        if(p0_.mass > 0u) grad += float(p0_.mass)*GGRAD(p0_.pos - p, RADIUS);\n        if(p1_.mass > 0u) grad += float(p1_.mass)*GGRAD(p1_.pos - p, RADIUS);\n    }\n\n    return grad;\n}\n\n\nfloat DE(vec3 p)\n{\n    return ISO_VALUE - ParticleDensity(p);\n}\n\nfloat TraceIsoSurface(Ray ray, float mint, float inside)\n{\n    const int step_count = 300;\n    float td = mint;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = ray.ro + ray.rd * td;\n        if(!all(lessThanEqual(p, size3d)) || !all(greaterThanEqual(p, vec3(0.))))\n        {\n            return ray.td;\n        }\n        float d = inside*4.0*DE(p);\n        if(d < 0.0)\n        {\n            return td;\n        }\n        td += d;\n    }\n    return td;\n}\n\nvec3 Background(vec3 rd)\n{\n    return 2.0*pow(texture(iChannel3,  rd.yzx).xyz, vec3(2.0));\n}\n\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{    \n    InitGrid(iResolution.xy);\n    \n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.04, -0.5);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.5;\n    vec3 ro = vec3(size3d)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n    \n    \n\n    vec2 tdBox = iBox(ro - vec3(size3d)*0.5, rd, 0.5*vec3(size3d));\n    col.xyz =Background(rd);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x+0.5, 0.0);\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n        int i = 0;\n        for(; i < 200; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n            td += 2.5;\n            if(td > tdBox.y-1.0)\n            {\n                break;\n            }\n            if(ray.td < tdBox.y-1.0)\n            {\n                break;\n            }\n        }\n        \n        //col.xyz = vec3(i)/200.0;\n        //return;\n        \n        //float liq_td = TraceIsoSurface(ray, td);\n        //ray.td = min(liq_td, ray.td);\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal = normalize(-ParticleGradient(p0));\n            vec3 normal1 = normalize(calcNormal(p0, 0.5).xyz);\n            normal = -normalize(mix(normal, normal1, NORMAL_SMOOTHNESS));\n            vec3 albedo = vec3(0.039,0.153,1.000);\n            float LdotN = 0.5*dot(normal, light_dir)+0.5;\n            #ifdef SHADOWS\n                float shadow_d = TraceDensity(p0+light_dir*1.0, light_dir);\n                float shadow = exp(-shadow_d) + 0.3*exp(-0.1*shadow_d);\n            #else\n                float shadow = 1.0;\n            #endif\n            vec3 refl_d = reflect(ray.rd, normal);\n            vec3 refl = Background(refl_d);\n            float K = 1. - pow(max(dot(normal,refl_d),0.), 2.);\n            K = mix(0.0, K, 0.1);\n            \n            #ifdef REFRACTION\n            vec3 refr_d = refract(ray.rd, normal, 1.0/1.33);\n            \n            float liquid_density = TraceDensity(p0, refr_d);\n            \n            vec3 liquid_color = exp(-0.5*liquid_density*vec3(0.953,0.353,0.247));\n            vec3 refr_color = Background(refr_d) * liquid_color;\n            col.xyz = 2.5*shadow*refr_color*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n            #else\n            col.xyz = 2.5*shadow*albedo*LdotN*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n            #endif\n        }\n        \n        //col.xyz = 0.01*vec3(1,1,1)*TraceDensity(ro + rd*max(tdBox.x+0.001,0.0), rd);\n    }\n    \n    col.xyz = 1.0 - exp(-2.5*pow(col.xyz,vec3(1.0/1.4)));\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define R iResolution.xy\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.741,1.000,0.580))\n\n#define initial_particle_density 1u\n#define dt 1.0\n#define rest_density 0.45\n#define gravity 0.01\n\n#define PRESSURE 2.5\n#define PRESSURE_RAD 0.8\n#define VISCOSITY 0.65\n#define SPIKE_KERNEL 0.5\n#define SPIKE_RAD 0.75\n\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 1.0\n#define cooling 0.0\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\nfloat cub(float x)\n{\n    return x*x*x;\n}\n\nfloat Pressure(float rho)\n{\n    return (rho/rest_density - 1.0)/max(rho*rho, 0.001);\n}\n\nfloat Gaussian(float r, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    return norm * exp(-0.5*sqr(r/d));\n}\n\nvec3 GaussianGrad(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return - (norm/sqr(d)) * exp(-0.5*sqr(r/d)) * dx;\n}\n\nvec4 GaussianGrad2(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return norm * exp(-0.5*sqr(r/d)) * vec4(-dx /sqr(d), 1.0);\n}\n\n#define KERNEL_POLY6_NORMALIZATION (315.0 / (64.0 * PI))\n#define KERNEL_SPIKE_NORMALIZATION (45 / PI)\n#define KERNEL_RADIUS 1.0\n\nfloat KernelPoly6(float r, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    return (r <= d) ? c * cub(sqr(d) - sqr(r)) : 0.0;\n}\n\nvec3 KernelPoly6Grad(vec3 dx, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    float r = length(dx);\n    return (r <= d) ? clamp(-6.0 * c * sqr(sqr(d) - sqr(r)), -3.0, 0.0) * dx : vec3(0.0);\n}\n\n#define GD(x, R) Gaussian(length(x),R)\n#define GGRAD(x, R) GaussianGrad(x, R)\n#define GGRAD2(x,R) GaussianGrad2(x, R)\n//#define GD(x, R) 12.0*KernelPoly6(length(x),R*4.0/2.0)\n//#define GGRAD(x, R) 12.0*KernelPoly6Grad(x, R*4.0/2.0)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//3d slice aspect ratio \n#define ar vec2(1.0,0.5)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    p3d = clamp(p3d, vec3(0.0), size3d);\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\n//#define pixel(a, p, s) texture(a, (p+0.5)/vec2(s))\n\nvec4 pixel(sampler2D ch, vec2 pos)\n{\n    vec2 d = pos - floor(pos);\n    vec4 p00 = texelFetch(ch, ivec2(pos), 0);\n    vec4 p01 = texelFetch(ch, ivec2(pos) + ivec2(0, 1), 0);\n    vec4 p10 = texelFetch(ch, ivec2(pos) + ivec2(1, 0), 0);\n    vec4 p11 = texelFetch(ch, ivec2(pos) + ivec2(1, 1), 0);\n    return mix(mix(p00, p01, d.y), mix(p10, p11, d.y), d.x);\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 udir(vec2 rng)\n{\n    float phi = 2.*PI*rng.x;\n    float ctheta = 2.*rng.y-1.;\n    float stheta = sqrt(1.0-ctheta*ctheta);\n    return vec3(cos(phi)*stheta, sin(phi)*stheta, ctheta);\n}\n\nstruct Particle \n{\n    uint mass;\n    vec3 pos;\n    vec3 vel;\n    vec3 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    uvec3 sv = uvec3(round(clamp(v*scale, -1.0, 1.0) * 255.0) + 255.0);\n    uint packed = uint(exp + 15) | (sv.x << 5) | (sv.y << 14) | (sv.z << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nuint packmasspos(uint mass, vec3 p0)\n{\n    uvec3 pos0 = uvec3(clamp(p0, 0.0, 1.0) * 255.0);\n    return mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n}\n\nuint packMassPos(uint mass, vec3 pos)\n{\n    uvec3 pos0 = uvec3(clamp(pos, 0.0, 1.0) * 255.0); // Assuming pos range [0, 1] in a cell\n    uint data1 = mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n    return data1;\n}\n\nvoid unpackMassPos(uint packed, out uint mass, out vec3 pos)\n{\n    mass = packed & 0xFFu;\n    uvec3 pos0 = uvec3((packed >> 8) & 0xFFu, (packed >> 16) & 0xFFu, (packed >> 24) & 0xFFu);\n    pos = vec3(pos0) / 255.0;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec3 pos)\n{\n    p0.pos -= pos;\n    p1.pos -= pos;\n\n    uvec4 data = uvec4(\n        packMassPos(p0.mass, p0.pos),\n        packMassPos(p1.mass, p1.pos),\n        packvec3(p0.vel),\n        packvec3(p1.vel)\n    );\n\n    return uintBitsToFloat(data);\n}\n\nvoid unpackParticles(vec4 packed, vec3 pos, out Particle p0, out Particle p1)\n{\n    uvec4 data = floatBitsToUint(packed);\n    \n    unpackMassPos(data.x, p0.mass, p0.pos);\n    unpackMassPos(data.y, p1.mass, p1.pos);\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    p0.vel = unpackvec3(data.z);\n    p1.vel = unpackvec3(data.w);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec3 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    vec3 pos = p1.pos;\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec3 dir = udir(hash23(pos));\n    p1.pos = pos - dir*5e-3;\n    p2.pos = pos + dir*5e-3;\n    p2.vel = p1.vel;\n}\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    if(incoming.mass == 0u) return;\n\n    vec3 dx = incoming.pos - p.pos;\n    vec3 dv = incoming.vel - p.vel;\n    float d = length(dx);\n    vec3 dir = dx / max(d, 1e-3);\n    \n    float rho0 = p.density;\n    float rho1 = incoming.density;\n    float mass0 = float(p.mass);\n    float mass1 = float(incoming.mass);\n  \n    vec3 ggrad = GGRAD(dx, PRESSURE_RAD);\n    float pressure = 0.5*p.density*(Pressure(p.density) + Pressure(incoming.density));\n    vec3 F_SPH = - PRESSURE * pressure * ggrad;\n    vec3 F_VISC = VISCOSITY * dot(dir, dv) * ggrad;\n    vec3 F_SPIKE = SPIKE_KERNEL * GD(d, SPIKE_RAD) * dir;\n   \n    p.force += - (F_SPH + F_VISC + F_SPIKE) * mass1;\n    \n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid IntegrateParticle(inout Particle p, vec3 pos, vec2 iR, vec4 iM, float time)\n{\n    p.force = p.force;/// max(0.0001, float(p.mass));\n    p.force += gravity*vec3(0.4*sin(1.5*time), 0.2*cos(0.75*time), -1.0); //gravity\n    \n\n    vec4 border = border_grad(p.pos);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    p.force += force_boundary*bound*dt;\n    //p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    //if(iM.z > 0.)\n    //{\n    //    vec3 dx = pos - vec3(iM.xy, 0.0);\n    //    p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    //}\n        \n    p.vel += p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}\n\nvoid InitGrid(vec2 iR)\n{\n    SCALE = floor(ar*pow(iR.x*iR.y,0.1666666));\n    size3d = vec3(floor(iR.xy/SCALE), SCALE.x*SCALE.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1;\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 pos1 = pos + vec3(i, j, k);\n        if(!all(lessThanEqual(pos1, size3d)) || !all(greaterThanEqual(pos1, vec3(0.0))))\n        {\n            continue;\n        }\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming, float rad)\n{\n    if(incoming.mass == 0u) return;\n    float d = distance(p.pos, incoming.pos);\n    float mass = float(incoming.mass);\n    p.density += mass*GD(d,rad);\n}\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        if(i == 0 && j == 0 && k == 0) continue;\n        vec3 pos1 = pos + vec3(i, j, k);\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n        if(p0.mass > 0u)\n        {\n            AddDensity(p0, p0_, KERNEL_RADIUS);\n            AddDensity(p0, p1_, KERNEL_RADIUS);\n        }\n        if(p1.mass > 0u)\n        {\n            AddDensity(p1, p0_, KERNEL_RADIUS);\n            AddDensity(p1, p1_, KERNEL_RADIUS);\n        }\n        \n        AddDensity(pV, p0_, 1.0);\n        AddDensity(pV, p1_, 1.0);\n    }\n\n    if(p0.mass > 0u)\n    {\n        AddDensity(p0, p0, KERNEL_RADIUS);\n        AddDensity(p0, p1, KERNEL_RADIUS);\n    }\n    if(p1.mass > 0u)\n    {\n        AddDensity(p1, p0, KERNEL_RADIUS);\n        AddDensity(p1, p1, KERNEL_RADIUS);\n    }\n    AddDensity(pV, p0, 1.0);\n    AddDensity(pV, p1, 1.0);\n\n    fragColor = vec4(p0.density, p1.density, pV.density, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define EMITTER_POS vec3(0.1,0.5,0.5)\n#define EMITTER_RAD 4.0\n#define EMITTER_VEL vec3(1.0, 0.0, 0.0)\n#define EMITTER_NUM 1\n\n#define VOID_POS vec3(0.8,0.5,0.1)\n#define VOID_RAD 12.0\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = voxel(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = voxel(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse, iTime);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse, iTime);\n        \n        if(isKeyPressed(KEY_UP))\n        {\n            float void_d = distance(p0.pos, size3d*VOID_POS);\n            if(void_d < VOID_RAD)\n            {\n                p0.mass = 0u;\n            }\n        }\n    \n        if(isKeyPressed(KEY_LEFT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(dx.y, -dx.x, 0.0)*0.003;\n        }\n        \n        if(isKeyPressed(KEY_RIGHT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(-dx.y, dx.x, 0.0)*0.003;\n        }\n    }\n    \n        \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.4*size3d.x && pos.x > 0.0*size3d.x && \n           pos.y < 0.85*size3d.y && pos.y > 0.15*size3d.y &&\n           pos.z < 0.85*size3d.z && pos.z > 0.15*size3d.z)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos;\n        p0.vel = vec3(0.0);\n        p1.pos = pos;\n        p1.vel = vec3(0.0);\n    }\n\n    if(all(equal(p0.pos, p1.pos)))\n    {\n        p1.pos += 1e-2;\n    }\n    \n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tfloat emitter_d = distance(pos, size3d*EMITTER_POS);\n        if(emitter_d < EMITTER_RAD && int(pos.y) % 2 == 0 && int(pos.z) % 2 == 0 && int(pos.x) % 2 == 0)\n        {\n            Particle emit;\n            emit.pos = pos;\n            emit.mass = 1u;\n            emit.vel = EMITTER_VEL;\n            \n            BlendParticle(p0, emit);\n        }\n    }\n    \n        \n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 234, 234, 626], [628, 628, 664, 664, 775], [892, 892, 946, 946, 1498], [1500, 1500, 1555, 1555, 1894], [1897, 1897, 1936, 1962, 2232], [2522, 2522, 2545, 2545, 2579], [2581, 2581, 2603, 2603, 2693], [2695, 2695, 2730, 2730, 2936], [2938, 2938, 2976, 2976, 3277], [3302, 3302, 3333, 3333, 3983], [4524, 4524, 4542, 4542, 4587], [4589, 4589, 4647, 4647, 5053], [5055, 5055, 5081, 5081, 5147], [5150, 5150, 5201, 5201, 7965]], "test": "untested"}
{"id": "DstyDj", "name": "Single-Pass Gaussian Blur", "author": "Kampfhund", "description": "Gaussian blur using one pass, kinda janky variables with the kernelSize and all but here we are. Less efficient -> O(n^2)", "tags": ["blur", "gaussianblur"], "likes": 0, "viewed": 215, "published": 3, "date": "1697484568", "time_retrieved": "2024-07-30T17:27:40.833831", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float kernelSize = 9.0;\n    //the -1.0 only if it's an odd number I think idk haven't tested\n    float halfKernelSize = (kernelSize-1.0) / 2.0;\n    \n    float[] gaussian = float[] (1.0, 8.0, 28.0, 56.0, 70.0, 56.0, 28.0, 8.0, 1.0);\n    //sum of all the values in the array\n    float sum = 256.0;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = -halfKernelSize; i <= halfKernelSize; i++)\n    {\n        for(float j = -halfKernelSize; j <= halfKernelSize; j++)\n        {\n            currentCoordinate = vec2(fragCoord.x + i, fragCoord.y + j);\n            color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r * (gaussian[int(j+halfKernelSize)] * gaussian[int(i+halfKernelSize)]);\n            color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g * (gaussian[int(j+halfKernelSize)] * gaussian[int(i+halfKernelSize)]);\n            color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b * (gaussian[int(j+halfKernelSize)] * gaussian[int(i+halfKernelSize)]);\n        }\n        //currentCoordinate = vec2(fragCoord.x + i, fragCoord.y);\n        //color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r * gaussian[int(i+halfKernelSize)];\n        //color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g * gaussian[int(i+halfKernelSize)];\n        //color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b * gaussian[int(i+halfKernelSize)];        \n    }\n    \n    color = vec4(color.r / (sum * sum), color.g / (sum * sum), color.b / (sum * sum), 1.0);\n    fragColor = color;\n    //fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DddyWj", "name": "A Simple Gaussian Blur", "author": "Kampfhund", "description": "Gaussian blur using two passes for higher efficiency, kinda janky variables with the kernelSize and all but here we are. \nO(2n)", "tags": ["blur", "gaussianblur"], "likes": 0, "viewed": 166, "published": 3, "date": "1697484543", "time_retrieved": "2024-07-30T17:27:41.995725", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float kernelSize = 9.0;\n    //the -1.0 only if it's an odd number I think idk haven't tested\n    float halfKernelSize = (kernelSize-1.0) / 2.0;\n    \n    float[] gaussian = float[] (1.0, 8.0, 28.0, 56.0, 70.0, 56.0, 28.0, 8.0, 1.0);\n    //sum of all the values in the array\n    float sum = 256.0;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = -halfKernelSize; i <= halfKernelSize; i++)\n    {\n        currentCoordinate = vec2(fragCoord.x, fragCoord.y + i);\n        color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r * gaussian[int(i+halfKernelSize)];\n        color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g * gaussian[int(i+halfKernelSize)];\n        color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b * gaussian[int(i+halfKernelSize)];\n    }\n    \n    color = vec4(color.r / sum, color.g / sum, color.b / sum, 1.0);\n    fragColor = color;\n    //fragColor = texture(iChannel1, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float kernelSize = 9.0;\n    //the -1.0 only if it's an odd number I think idk haven't tested\n    float halfKernelSize = (kernelSize-1.0) / 2.0;\n    \n    float[] gaussian = float[] (1.0, 8.0, 28.0, 56.0, 70.0, 56.0, 28.0, 8.0, 1.0);\n    //sum of all the values in the array\n    float sum = 256.0;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = -halfKernelSize; i <= halfKernelSize; i++)\n    {\n        currentCoordinate = vec2(fragCoord.x + i, fragCoord.y);\n        color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r * gaussian[int(i+halfKernelSize)];\n        color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g * gaussian[int(i+halfKernelSize)];\n        color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b * gaussian[int(i+halfKernelSize)];\n    }\n    \n    color = vec4(color.r / sum, color.g / sum, color.b / sum, 1.0);\n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DddyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cd3yDX", "name": "Grayscale Perceived Luminance", "author": "Kampfhund", "description": "Calculates the perceived luminance as described by this stackoverflow comment:\nhttps://stackoverflow.com/a/56678483", "tags": ["luminance", "gray", "grey"], "likes": 1, "viewed": 162, "published": 3, "date": "1697484519", "time_retrieved": "2024-07-30T17:27:43.039933", "image_code": "float sRGBtoLin(float colorChannel)\n{\n    //This converts a gamma encoded RGB to a linear value.\n    \n    if(colorChannel <= 0.04045)\n    {\n        return colorChannel / 12.92;\n    }\n    else\n    {\n        return pow(((colorChannel + 0.055) / 1.055), 2.4);\n    }\n}\n\nfloat lumToPerLight(float luminance)\n{\n    //This transforms the luminance value to the perceptual lightness as seen by humans\n    if(luminance <= 216.0/24389.0)\n    {\n        return luminance * (24389.0/27.0);\n    }\n    else\n    {\n        return pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    //This calculates the luminance\n    float lum = (0.2126 * sRGBtoLin(color.r) + 0.7152 * sRGBtoLin(color.g) + 0.0722 * sRGBtoLin(color.b));\n    float perLight = lumToPerLight(lum) / 100.0;\n    \n    fragColor = vec4(perLight, perLight, perLight, 1.0);\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3yDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 96, 264], [266, 266, 304, 392, 564], [567, 567, 624, 624, 976]], "test": "untested"}
{"id": "cddyWj", "name": "Simple box blur", "author": "Kampfhund", "description": "It's just a box blur that averages the pixel values around a given pixel in two passes", "tags": ["blur", "boxblur"], "likes": 0, "viewed": 129, "published": 3, "date": "1697484460", "time_retrieved": "2024-07-30T17:27:44.183874", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float blurAmount = 10.0;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = blurAmount * -1.0; i <= blurAmount; i++)\n    {\n        currentCoordinate = vec2(fragCoord.x, fragCoord.y + i);\n        color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r;\n        color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g;\n        color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b;\n    }\n    \n    color = vec4(color.r / (blurAmount*2.0+1.0), color.g / (blurAmount*2.0+1.0), color.b / (blurAmount*2.0+1.0), 1.0);\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float blurAmount = 10.0;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0); \n    vec2 currentCoordinate = vec2(0.0, 0.0);\n    \n    for(float i = blurAmount * -1.0; i <= blurAmount; i++)\n    {\n        currentCoordinate = vec2(fragCoord.x + i, fragCoord.y);\n        color.r += texture(iChannel0, currentCoordinate / iResolution.xy).r;\n        color.g += texture(iChannel0, currentCoordinate / iResolution.xy).g;\n        color.b += texture(iChannel0, currentCoordinate / iResolution.xy).b;\n    }\n    \n    color = vec4(color.r / (blurAmount*2.0+1.0), color.g / (blurAmount*2.0+1.0), color.b / (blurAmount*2.0+1.0), 1.0);\n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 740]], "test": "untested"}
{"id": "mddBzX", "name": "Complementary Flow", "author": "fishy", "description": "Just a little experiment. Colors are chosen such that when they add together they become 1. If it's laggy you can reduce the number of substeps in Buffer A", "tags": ["blur", "buffer", "trails", "substep"], "likes": 10, "viewed": 234, "published": 3, "date": "1697484454", "time_retrieved": "2024-07-30T17:27:45.239054", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = 1.0-exp(-texture(iChannel0, fragCoord/iResolution.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SUBSTEPS 8.0\n\n#define COLOR_0 vec3(1.000,0.525,0.000)\n#define COLOR_1 (1.0-COLOR_0)\n\nvec2 curve(float t, float k)\n{\n    return vec2(sin(t) - cos(t + k), cos(3.0*t) + sin(4.0 * - k))*0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec3 store = texture(iChannel0, fragCoord/iResolution.xy, 0.1).rgb;\n    \n    for(float i = 0.0; i < SUBSTEPS; i++)\n    {\n        float offset = i / SUBSTEPS * max(0.0, iTimeDelta);\n        float t = max(0.0001, iTime) * 0.5;\n        float k = max(0.0001, iTime) * 0.25;\n        float p0 = 0.3/distance(uv, curve(t + offset, k + offset));\n        float p1 = 0.3/distance(uv, curve(t + offset + 0.5, k + offset + 0.5));\n\n        vec3 col = COLOR_0 * p0 + COLOR_1 * p1;\n\n        store = mix(col, store, pow(0.5, max(0.0, iTimeDelta) / SUBSTEPS));\n    }\n    \n    fragColor = vec4(store, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 131]], "test": "untested"}
{"id": "msdfRX", "name": "Add stripes to dark areas", "author": "Kampfhund", "description": "Adds stripes to dark areas for a dithering-ish effect. The stripes should be a little darker than the base color but it's a little scuffed as I used RGB color space to determine this.", "tags": ["shadow", "stripes", "dithering", "dark"], "likes": 1, "viewed": 144, "published": 3, "date": "1697484155", "time_retrieved": "2024-07-30T17:27:46.379005", "image_code": "float sRGBtoLin(float colorChannel)\n{\n    //This converts a gamma encoded RGB to a linear value.\n    \n    if(colorChannel <= 0.04045)\n    {\n        return colorChannel / 12.92;\n    }\n    else\n    {\n        return pow(((colorChannel + 0.055) / 1.055), 2.4);\n    }\n}\n\nfloat lumToPerLight(float luminance)\n{\n    //This transforms the luminance value to the perceptual lightness as seen by humans\n    if(luminance <= 216.0/24389.0)\n    {\n        return luminance * (24389.0/27.0);\n    }\n    else\n    {\n        return pow(luminance, (1.0 / 3.0)) * 116.0 - 16.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    //This calculates the luminance\n    float lum = (0.2126 * sRGBtoLin(color.r) + 0.7152 * sRGBtoLin(color.g) + 0.0722 * sRGBtoLin(color.b));\n    float perLight = lumToPerLight(lum) / 100.0;\n    \n    \n    //mod() part checks if it's on on of the vertical lines. Play around with the 0.01 and the 0.003 if you want.\n    if(mod(uv.x - uv.y, 0.01) <= 0.003 && perLight <= 0.5)\n    {\n        color = vec4(color.r -(0.2126*0.1), color.g -(0.7152*0.1), color.b - (0.0722*1.0), 1.0);\n    }\n\n    fragColor = color;\n\n\n\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 96, 264], [266, 266, 304, 392, 564], [567, 567, 624, 624, 1228]], "test": "untested"}
{"id": "dscfRf", "name": "3D Water Box", "author": "michael0884", "description": "Tried to actually finalize the render somewhat, and use proper SPH kernels. Turns out gaussian wins in terms of smoothness, oh well.\n", "tags": ["particle", "sph"], "likes": 94, "viewed": 2559, "published": 3, "date": "1697483435", "time_retrieved": "2024-07-30T17:27:47.445155", "image_code": "#define SHADOWS \n#define REFRACTION\n\n#define RADIUS 0.65\n#define NORMAL_SMOOTHNESS 1.0\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvoid iSphere(inout Ray ray, vec4 sphere, vec3 color)\n{\n    vec3 ro = ray.ro - sphere.xyz;\n    float b = dot(ro, ray.rd);\n    float c = dot(ro, ro) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if (h > 0.) \n    {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= 0.0 && d1 <= ray.td) {\n            ray.normal = normalize(ro + ray.rd*d1);\n            ray.color = color;\n            ray.td = d1;\n        } else if (d2 >= 0.0 && d2 <= ray.td) { \n            ray.normal = normalize(ro + ray.rd*d2); \n            ray.color = color;\n            ray.td = d2;\n        }\n    }\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = MAX_DIST;\n    if(rd.x != 0.0) tF = min(tF, t2.x);\n    if(rd.y != 0.0) tF = min(tF, t2.y);\n    if(rd.z != 0.0) tF = min(tF, t2.z);\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    vec4 packed = LOAD3D(ch0, p);\n    Particle p0, p1;\n    unpackParticles(packed, p, p0, p1);\n\n    if(p0.mass > 0u) iSphere(ray, vec4(p0.pos, RADIUS*1.5), vec3(1.000,1.000,1.000));\n    if(p1.mass > 0u) iSphere(ray, vec4(p1.pos, RADIUS*1.5), vec3(1.000,1.000,1.000));\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec4 rho = voxel(ch1, p);\n    if(rho.z < 1e-3) return;\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\n\nfloat Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nfloat Shadow(vec3 p)\n{\n    float optical_density = trilinear(ch2, p).x;\n    return exp(-optical_density)+0.05;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nfloat TraceDensity(vec3 ro, vec3 rd)\n{\n    float dens = 0.0;\n    float td = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(any(lessThan(p, vec3(1.0))) || any(greaterThan(p, size3d - 1.0))) return dens;\n        float d = Density(p);\n        dens += d * 2.0;\n        td += 2.0;\n    }\n    return dens;\n}\n\n\n#define ISO_VALUE 0.5\nfloat ParticleDensity(vec3 p)\n{\n    vec3 p0 = floor(p);\n    float rho = voxel(ch1, p).z;\n    //if(rho < 0.001) return rho;\n    //rho = 0.0;\n    ////if larger then compute accurate density from particles\n    //range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    //{\n    //    //load the particles \n    //    vec3 p1 = p0 + vec3(i, j, k);\n    //    //load the particles\n    //    vec4 packed = LOAD3D(ch0, p1);\n    //    Particle p0_, p1_;\n    //    unpackParticles(packed, p1, p0_, p1_);\n    //    if(p0_.mass > 0u) rho += float(p0_.mass)*GD(length(p0_.pos - p), RADIUS);\n    //    if(p1_.mass > 0u) rho += float(p1_.mass)*GD(length(p1_.pos - p), RADIUS);\n    //}\n\n    return rho;\n}\n\nvec3 ParticleGradient(vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec3 grad = vec3(0.0);\n\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n\n        //load the particles\n        vec4 packed = LOAD3D(ch0, p1);\n        Particle p0_, p1_;\n\n        unpackParticles(packed, p1, p0_, p1_);\n\n        if(p0_.mass > 0u) grad += float(p0_.mass)*GGRAD(p0_.pos - p, RADIUS);\n        if(p1_.mass > 0u) grad += float(p1_.mass)*GGRAD(p1_.pos - p, RADIUS);\n    }\n\n    return grad;\n}\n\n\nfloat DE(vec3 p)\n{\n    return ISO_VALUE - ParticleDensity(p);\n}\n\nfloat TraceIsoSurface(Ray ray, float mint, float inside)\n{\n    const int step_count = 300;\n    float td = mint;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = ray.ro + ray.rd * td;\n        if(!all(lessThanEqual(p, size3d)) || !all(greaterThanEqual(p, vec3(0.0))))\n        {\n            return ray.td;\n        }\n        float d = inside*4.0*DE(p);\n        if(d < 0.0)\n        {\n            return td;\n        }\n        td += d;\n    }\n    return td;\n}\n\nvec3 Background(vec3 rd)\n{\n    return 2.0*pow(texture(iChannel3,  rd.yzx).xyz, vec3(2.0));\n}\n\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{    \n    InitGrid(iResolution.xy);\n    \n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.35, -0.5);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.5;\n    vec3 ro = vec3(size3d)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n    \n    \n\n    vec2 tdBox = iBox(ro - vec3(size3d)*0.5, rd, 0.5*vec3(size3d));\n    col.xyz =Background(rd);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x+0.5, 0.0);\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n        int i = 0;\n        for(; i < 200; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n            td += 2.5;\n            if(td > tdBox.y-1.0)\n            {\n                break;\n            }\n            if(ray.td < tdBox.y-1.0)\n            {\n                break;\n            }\n        }\n        \n        //col.xyz = vec3(i)/200.0;\n        //return;\n        \n        //float liq_td = TraceIsoSurface(ray, td);\n        //ray.td = min(liq_td, ray.td);\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal = normalize(-ParticleGradient(p0));\n            vec3 normal1 = normalize(calcNormal(p0, 0.5).xyz);\n            normal = -normalize(mix(normal, normal1, NORMAL_SMOOTHNESS));\n            vec3 albedo = vec3(0.039,0.153,1.000);\n            float LdotN = 0.5*dot(normal, light_dir)+0.5;\n            #ifdef SHADOWS\n                float shadow_d = TraceDensity(p0+light_dir*1.0, light_dir);\n                float shadow = exp(-shadow_d) + 0.3*exp(-0.1*shadow_d);\n            #else\n                float shadow = 1.0;\n            #endif\n            vec3 refl_d = reflect(ray.rd, normal);\n            vec3 refl = Background(refl_d);\n            float K = 1. - pow(max(dot(normal,refl_d),0.), 2.);\n            K = mix(0.0, K, 0.1);\n            \n            #ifdef REFRACTION\n            vec3 refr_d = refract(ray.rd, normal, 1.0/1.33);\n            \n            float liquid_density = TraceDensity(p0 + refr_d*1.0, refr_d);\n            \n            vec3 liquid_color = exp(-0.5*liquid_density*(1.0 - vec3(0.078,0.816,1.000)));\n            vec3 refr_color = Background(refr_d) * liquid_color;\n            col.xyz = 2.5*(0.5*shadow+0.5)*refr_color*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n            #else\n            col.xyz = 2.5*shadow*albedo*LdotN*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n            #endif\n        }\n        \n        //col.xyz = 0.01*vec3(1,1,1)*TraceDensity(ro + rd*max(tdBox.x+0.001,0.0), rd);\n    }\n    \n    col.xyz = 1.0 - exp(-2.5*pow(col.xyz,vec3(1.0/1.4)));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define R iResolution.xy\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.741,1.000,0.580))\n\n#define initial_particle_density 1u\n#define dt 1.0\n#define rest_density 0.5\n#define gravity 0.01\n\n#define PRESSURE 3.5\n#define PRESSURE_RAD 1.0\n#define VISCOSITY 0.65\n#define SURFACE_TENSION 0.1\n#define SURFACE_TENSION_RAD 2.0\n#define SPIKE_KERNEL 0.5\n#define SPIKE_RAD 0.75\n\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 1.0\n#define cooling 0.0\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\nfloat cub(float x)\n{\n    return x*x*x;\n}\n\nfloat Pressure(float rho)\n{\n    return (rho/rest_density - 1.0)/max(rho*rho, 0.001);\n}\n\nfloat Gaussian(float r, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    return norm * exp(-0.5*sqr(r/d));\n}\n\nvec3 GaussianGrad(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return - (norm/sqr(d)) * exp(-0.5*sqr(r/d)) * dx;\n}\n\nvec4 GaussianGrad2(vec3 dx, float d)\n{\n    float norm = 1.0/(cub(d)*sqrt(cub(TWO_PI)));\n    float r = length(dx);\n    return norm * exp(-0.5*sqr(r/d)) * vec4(-dx /sqr(d), 1.0);\n}\n\n#define KERNEL_POLY6_NORMALIZATION (315.0 / (64.0 * PI))\n#define KERNEL_SPIKE_NORMALIZATION (45 / PI)\n#define KERNEL_RADIUS 1.0\n\nfloat KernelPoly6(float r, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    return (r <= d) ? c * cub(sqr(d) - sqr(r)) : 0.0;\n}\n\nvec3 KernelPoly6Grad(vec3 dx, float d)\n{\n    float c = KERNEL_POLY6_NORMALIZATION / cub(cub(d));\n    float r = length(dx);\n    return (r <= d) ? clamp(-6.0 * c * sqr(sqr(d) - sqr(r)), -3.0, 0.0) * dx : vec3(0.0);\n}\n\n#define GD(x, R) Gaussian(length(x),R)\n#define GGRAD(x, R) GaussianGrad(x, R)\n#define GGRAD2(x,R) GaussianGrad2(x, R)\n//#define GD(x, R) 12.0*KernelPoly6(length(x),R*4.0/2.0)\n//#define GGRAD(x, R) 12.0*KernelPoly6Grad(x, R*4.0/2.0)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//3d slice aspect ratio \n#define ar vec2(1.0,0.5)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    p3d = clamp(p3d, vec3(0.0), size3d);\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\n\n//#define pixel(a, p, s) texture(a, (p+0.5)/vec2(s))\n\nvec4 pixel(sampler2D ch, vec2 pos)\n{\n    vec2 d = pos - floor(pos);\n    vec4 p00 = texelFetch(ch, ivec2(pos), 0);\n    vec4 p01 = texelFetch(ch, ivec2(pos) + ivec2(0, 1), 0);\n    vec4 p10 = texelFetch(ch, ivec2(pos) + ivec2(1, 0), 0);\n    vec4 p11 = texelFetch(ch, ivec2(pos) + ivec2(1, 1), 0);\n    return mix(mix(p00, p01, d.y), mix(p10, p11, d.y), d.x);\n}\n\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 udir(vec2 rng)\n{\n    float phi = 2.*PI*rng.x;\n    float ctheta = 2.*rng.y-1.;\n    float stheta = sqrt(1.0-ctheta*ctheta);\n    return vec3(cos(phi)*stheta, sin(phi)*stheta, ctheta);\n}\n\nstruct Particle \n{\n    uint mass;\n    vec3 pos;\n    vec3 vel;\n    vec3 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    uvec3 sv = uvec3(round(clamp(v*scale, -1.0, 1.0) * 255.0) + 255.0);\n    uint packed = uint(exp + 15) | (sv.x << 5) | (sv.y << 14) | (sv.z << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nuint packmasspos(uint mass, vec3 p0)\n{\n    uvec3 pos0 = uvec3(clamp(p0, 0.0, 1.0) * 255.0);\n    return mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n}\n\nuint packMassPos(uint mass, vec3 pos)\n{\n    uvec3 pos0 = uvec3(clamp(pos, 0.0, 1.0) * 255.0); // Assuming pos range [0, 1] in a cell\n    uint data1 = mass | (pos0.x << 8) | (pos0.y << 16) | (pos0.z << 24);\n    return data1;\n}\n\nvoid unpackMassPos(uint packed, out uint mass, out vec3 pos)\n{\n    mass = packed & 0xFFu;\n    uvec3 pos0 = uvec3((packed >> 8) & 0xFFu, (packed >> 16) & 0xFFu, (packed >> 24) & 0xFFu);\n    pos = vec3(pos0) / 255.0;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec3 pos)\n{\n    p0.pos -= pos;\n    p1.pos -= pos;\n\n    uvec4 data = uvec4(\n        packMassPos(p0.mass, p0.pos),\n        packMassPos(p1.mass, p1.pos),\n        packvec3(p0.vel),\n        packvec3(p1.vel)\n    );\n\n    return uintBitsToFloat(data);\n}\n\nvoid unpackParticles(vec4 packed, vec3 pos, out Particle p0, out Particle p1)\n{\n    uvec4 data = floatBitsToUint(packed);\n    \n    unpackMassPos(data.x, p0.mass, p0.pos);\n    unpackMassPos(data.y, p1.mass, p1.pos);\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    p0.vel = unpackvec3(data.z);\n    p1.vel = unpackvec3(data.w);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec3 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    vec3 pos = p1.pos;\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec3 dir = udir(hash23(pos));\n    p1.pos = pos - dir*5e-3;\n    p2.pos = pos + dir*5e-3;\n    p2.vel = p1.vel;\n}\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    if(incoming.mass == 0u) return;\n\n    vec3 dx = incoming.pos - p.pos;\n    vec3 dv = incoming.vel - p.vel;\n    float d = length(dx);\n    vec3 dir = dx / max(d, 1e-3);\n    \n    float rho0 = p.density;\n    float rho1 = incoming.density;\n    float mass0 = float(p.mass);\n    float mass1 = float(incoming.mass);\n  \n    vec3 ggrad = GGRAD(dx, PRESSURE_RAD);\n    float pressure = 0.5*p.density*(Pressure(p.density) + Pressure(incoming.density));\n    vec3 F_SPH = - PRESSURE * pressure * ggrad;\n    vec3 F_VISC = VISCOSITY * dot(dir, dv) * ggrad;\n    vec3 F_ST = SURFACE_TENSION * GGRAD(dx, SURFACE_TENSION_RAD);\n    vec3 F_SPIKE = SPIKE_KERNEL * GD(d, SPIKE_RAD) * dir;\n   \n    p.force += - (F_ST + F_SPH + F_VISC + F_SPIKE) * mass1;\n    \n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid IntegrateParticle(inout Particle p, vec3 pos, vec2 iR, vec4 iM, float time)\n{\n    p.force = p.force;/// max(0.0001, float(p.mass));\n    p.force += gravity*vec3(0.4*sin(1.5*time), 0.2*cos(0.75*time), -1.0); //gravity\n    \n\n    vec4 border = border_grad(p.pos);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    p.force += force_boundary*bound*dt;\n    //p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    //if(iM.z > 0.)\n    //{\n    //    vec3 dx = pos - vec3(iM.xy, 0.0);\n    //    p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    //}\n        \n    p.vel += p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}\n\nvoid InitGrid(vec2 iR)\n{\n    SCALE = floor(ar*pow(iR.x*iR.y,0.1666666));\n    size3d = vec3(floor(iR.xy/SCALE), SCALE.x*SCALE.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1;\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 pos1 = pos + vec3(i, j, k);\n        if(!all(lessThanEqual(pos1, size3d)) || !all(greaterThanEqual(pos1, vec3(0.0))))\n        {\n            continue;\n        }\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming, float rad)\n{\n    if(incoming.mass == 0u) return;\n    float d = distance(p.pos, incoming.pos);\n    float mass = float(incoming.mass);\n    p.density += mass*GD(d,rad);\n}\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        if(i == 0 && j == 0 && k == 0) continue;\n        vec3 pos1 = pos + vec3(i, j, k);\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n        if(p0.mass > 0u)\n        {\n            AddDensity(p0, p0_, KERNEL_RADIUS);\n            AddDensity(p0, p1_, KERNEL_RADIUS);\n        }\n        if(p1.mass > 0u)\n        {\n            AddDensity(p1, p0_, KERNEL_RADIUS);\n            AddDensity(p1, p1_, KERNEL_RADIUS);\n        }\n        \n        AddDensity(pV, p0_, 1.0);\n        AddDensity(pV, p1_, 1.0);\n    }\n\n    if(p0.mass > 0u)\n    {\n        AddDensity(p0, p0, KERNEL_RADIUS);\n        AddDensity(p0, p1, KERNEL_RADIUS);\n    }\n    if(p1.mass > 0u)\n    {\n        AddDensity(p1, p0, KERNEL_RADIUS);\n        AddDensity(p1, p1, KERNEL_RADIUS);\n    }\n    AddDensity(pV, p0, 1.0);\n    AddDensity(pV, p1, 1.0);\n\n    fragColor = vec4(p0.density, p1.density, pV.density, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define EMITTER_POS vec3(0.1,0.5,0.5)\n#define EMITTER_RAD 4.0\n#define EMITTER_VEL vec3(1.0, 0.0, 0.0)\n#define EMITTER_NUM 1\n\n#define VOID_POS vec3(0.8,0.5,0.1)\n#define VOID_RAD 12.0\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = voxel(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = voxel(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse, iTime);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse, iTime);\n        \n        if(isKeyPressed(KEY_UP))\n        {\n            float void_d = distance(p0.pos, size3d*VOID_POS);\n            if(void_d < VOID_RAD)\n            {\n                p0.mass = 0u;\n            }\n        }\n    \n        if(isKeyPressed(KEY_LEFT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(dx.y, -dx.x, 0.0)*0.003;\n        }\n        \n        if(isKeyPressed(KEY_RIGHT))\n        {\n            vec3 dx = normalize(p0.pos - size3d*0.5);\n            p0.vel += vec3(-dx.y, dx.x, 0.0)*0.003;\n        }\n    }\n    \n        \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.4*size3d.x && pos.x > 0.0*size3d.x && \n           pos.y < 0.85*size3d.y && pos.y > 0.15*size3d.y &&\n           pos.z < 0.85*size3d.z && pos.z > 0.15*size3d.z)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos;\n        p0.vel = vec3(0.0);\n        p1.pos = pos;\n        p1.vel = vec3(0.0);\n    }\n\n    if(all(equal(p0.pos, p1.pos)))\n    {\n        p1.pos += 1e-2;\n    }\n    \n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tfloat emitter_d = distance(pos, size3d*EMITTER_POS);\n        if(emitter_d < EMITTER_RAD && int(pos.y) % 2 == 0 && int(pos.z) % 2 == 0 && int(pos.x) % 2 == 0)\n        {\n            Particle emit;\n            emit.pos = pos;\n            emit.mass = 1u;\n            emit.vel = EMITTER_VEL;\n            \n            BlendParticle(p0, emit);\n        }\n    }\n    \n        \n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 133, 133, 525], [527, 527, 563, 563, 674], [791, 791, 845, 845, 1397], [1399, 1399, 1454, 1454, 1891], [1894, 1894, 1933, 1959, 2229], [2519, 2519, 2542, 2542, 2576], [2578, 2578, 2600, 2600, 2690], [2692, 2692, 2727, 2727, 2933], [2935, 2935, 2973, 2973, 3274], [3299, 3299, 3330, 3330, 3980], [4521, 4521, 4539, 4539, 4584], [4586, 4586, 4644, 4644, 5051], [5053, 5053, 5079, 5079, 5145], [5148, 5148, 5199, 5199, 7994]], "test": "untested"}
{"id": "DdXXWB", "name": "Inverse Complex Cubic Solver", "author": "mla", "description": "Shows the 3-valued inverse for the cubic map defined by three roots (use mouse to drag roots). Other controls & more details, see header.\n", "tags": ["function", "complex", "cubic", "equation", "rational"], "likes": 23, "viewed": 258, "published": 3, "date": "1697482644", "time_retrieved": "2024-07-30T17:27:48.562168", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Inverse Complex Cubic Solver, mla, 2023.\n//\n// Take three complex numbers and find the equation z³+Az²+Bz + C = 0 = f(z) of\n// which they are the roots, but instead of mapping each screen position z to\n// w = f(z), map w to to z = f⁻¹(w), ie. find z for which f(z) = w, ie. solve\n// the cubic equation z³+Az²+Bz+C-w = 0. This is 3-valued (for the three roots),\n// and we show all 3 branches overlaid (or use keys 1-3 to select \n// the branches to show - it can be difficult to interpret all three at once).\n//\n// The three selected roots are shown as black circles (in the z-plane, in the\n// w-plane they are all mapped to zero) and can be dragged with the mouse and\n// The real and imaginary axes are also shown in both z- and w-planes.\n//\n// <mouse>: drag roots (black circles) around\n// <up/down>: zoom in/out\n// '1','2','3': select branches to show\n// 'a': animation mode\n// 'd': use approximate derivative\n// 'r': rotation\n// 'x': show untransformed z-plane\n// 'w': hide w-axes\n// 'z': hide z-axes\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 ccbrt(vec2 z) {\n  float t = carg(z)/3.0;\n  return pow(length(z),1.0/3.0)*expi(t);\n}\n\nmat3x2 solvecubic(vec2 p, vec2 q) {\n  // Solve depressed cubic: x³+3px+q = 0 - note factor of 3!\n  // Put x = u+v and get x³ = u³+v³+3xuv\n  // Substitute in original equation and get:\n  // u³+v³+(3uv+3p)x + q = 0\n  // Now let's constrain u,v so that uv+p = 0, and then:\n  // uv = -p ie. u³v³ = -p³ and u³+v³ = -q\n  // This gives a quadratic equation in t with roots u³ and v³:\n  // t²+qt-p³ = 0 so try to solve as:\n  // u³ = -q + sqrt(q²+4p³), v³ = -q - sqrt(q²+4p³)\n  // and take cube roots to get solution x = u+v.\n  //\n  // HOWEVER, we can't just combine any cube roots of the\n  // quadratic solutions, the condition uv+p = 0 above must also\n  // hold, so what we do is take either one of the quadratic\n  // solutions with its three cube roots as the three values\n  // of u, and derive the corresponding v's directly as v = -p/u.\n  // As with solving a real quadratic equation, it seems prudent\n  // to use the quadratic root with the largest absolute magnitude,\n  // and given one cube root, we can easily find the others by\n  // multiplying by the cube roots of unity, ω and ω².\n  vec2 q2 = cmul(q,q);\n  vec2 p3 = cmul(p,cmul(p,p));\n  vec2 s = csqrt(q2+4.0*p3);\n  float sign = dot(q,s) > 0.0 ? -1.0 : 1.0; // Get largest magnitude root\n  vec2 u3 = 0.5*(-q+sign*s);\n  vec2 u = ccbrt(u3);\n  vec2 u1 = cmul(u,omega); // Get other cuberoots by multiplying by ω and ω².\n  vec2 u2 = cmul(u,omega2);\n  return mat3x2(u-cdiv(p,u), u1-cdiv(p,u1), u2-cdiv(p,u2));\n}\n\nmat3x2 solvecubic(vec2 B, vec2 C, vec2 D) {\n  // Solve x³+Bx²+Cx+D = 0\n  B /= 3.0; C /= 3.0;  // Simplifies sums\n  vec2 B2 = cmul(B,B); // Depress with x->x+B\n  // p = c-b*b\n  vec2 p = C-B2;\n  // q = 2.0*b*b*b - 3.0*b*c + d\n  vec2 q = cmul(B,2.0*B2-3.0*C) + D;\n  mat3x2 res = solvecubic(p,q);\n  // Undepress by subtracting B\n  return mat3x2(res[0]-B,res[1]-B,res[2]-B);\n}\n\n// d(z³+Az²+Bz+C)/dz = 3z²+2Az+B\nfloat dlen(vec2 A, vec2 B, vec2 z) {\n  // Inverse derivative length\n  vec2 w = 3.0*cmul(z,z) + 2.0*cmul(A,z) + B;\n  return 1.0/length(w); // This works!\n}\n\nfloat axes(vec2 z,float px) {      // Draw axes\n  float eps = 0.05;\n  float d = min(abs(z.x),abs(z.y));\n  float x = z.x-round(z.x);\n  float y = z.y-round(z.y);\n  d = min(d,segment(vec2(x,z.y),vec2(0,-eps),vec2(0,eps)));\n  d = min(d,segment(vec2(z.x,y),vec2(-eps,0),vec2(eps,0)));\n  return smoothstep(0.0,px,d);\n}\n\nvec3 draw(vec2 w, float px) {\n    vec3 col1 = vec3(1,1,0);\n    vec3 col2 = vec3(0,1,1);\n    vec3 neutral = vec3(1,0,0);\n    vec2 w0 = w;\n    float px0 = px;\n    if (!key(CHAR_R)) {\n      float t = 0.25*iTime;\n      w = cmul(w,expi(t));\n    }\n    px /= length(w);\n    float t = atan(0.25*length(w))/PI;\n    w = clog(w);\n    float alpha = w.y/PI;\n    vec3 basecol = alpha < 0.0 ? col1 : col2;\n    vec3 color = mix(neutral,basecol,abs(alpha));\n    vec2 uv = 10.0*w/PI;\n    px = 10.0*px/PI;\n    //px = fwidth(length(uv));// fwidth for function result\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    color = mix(vec3(3.0*t),color,smoothstep(0.0,px,min(uv.x,uv.y)));\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    setscale();\n    vec2 z = map(fragCoord);\n    vec2 a = getselection(0);\n    vec2 b = getselection(1);\n    vec2 c = getselection(2);\n    float px = 2.0*scale/iResolution.y; //fwidth(length(z));\n    // x³+Ax²+Bx+C = 0\n    vec2 A = -(a+b+c);\n    vec2 B = cmul(a,b)+cmul(b,c)+cmul(c,a);\n    vec2 C = -cmul(a,cmul(b,c));\n    mat3x2 roots = solvecubic(A,B,C-z);\n    vec3 dz;\n    if (!key(CHAR_D)) {\n      dz = vec3(dlen(A,B,roots[0]),\n                dlen(A,B,roots[1]),\n                dlen(A,B,roots[2]));\n      dz *= 1.414;\n    } else {\n      float eps = 1e-3;\n      mat3x2 roots2 = solvecubic(A,B,C-z-eps);\n      dz = vec3(length(roots2[0]-roots[0]),\n                length(roots2[1]-roots[1]),\n                length(roots2[2]-roots[2]))/eps;\n    }\n    vec3 color = vec3(0);\n    if (key(CHAR_X)) {\n      color += draw(z,px);\n    } else {\n      int t = 0;\n      if (!key(CHAR_0+1)) { t++; color += draw(roots[0],px*dz[0]); }\n      if (!key(CHAR_0+2)) { t++; color += draw(roots[1],px*dz[1]); }\n      if (!key(CHAR_0+3)) { t++; color += draw(roots[2],px*dz[2]); }\n      if (!key(CHAR_W)) {\n        if (!key(CHAR_0+1)) color = mix(vec3(0.2),color,axes(roots[0],px*dz[0]));\n        if (!key(CHAR_0+2)) color = mix(vec3(0.2),color,axes(roots[1],px*dz[1]));\n        if (!key(CHAR_0+3)) color = mix(vec3(0.2),color,axes(roots[2],px*dz[2]));\n      }\n      if (t == 2) color *= 0.7;\n      if (t == 3) color *= 0.5;\n    }\n    roots = solvecubic(A,B,C);\n    for (int i = 0; i < 3; i++) {\n      vec2 w = getselection(i);\n      // Draw a little circle around each root.\n      vec3 pcol = vec3(0);\n      //if (i == 0 && !key(CHAR_A)) pcol = vec3(1);\n      color = mix(pcol,color,smoothstep(0.0,px,abs(distance(w,z)-0.05)));\n    }\n    if (!key(CHAR_Z)) {\n      color = mix(vec3(0),color,axes(z,px));\n    }\n    color = pow(color,vec3(0.4545));\n    if (alert) color.r = 1.0;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n#define SELECTIONS\nconst int nselections = 3;\n#define getselection(i) (\\\n  (i == 0 && !key(CHAR_A)) ? 2.0*ppath(0.25*iTime) \\\n  : texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-sqrt(3.0),-1);\n  if (i == 1) return vec2( 0,-1.618);\n  if (i == 2) return vec2(-0.5,0);\n  return vec2(0);\n}\n\nconst float PI = 3.14159265;\nconst float TWOPI = 2.0*PI;\n\nvec2 ppath(float t) {\n  return vec2(cos(t),sin(0.618*t));\n}\n  \nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nvec2 expi(float t) {\n  return normalize(vec2(cos(t),sin(t)));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\nvec2 csqrt(vec2 z) {\n  float t = carg(z);\n  return sqrt(length(z))*vec2(cos(0.5*t),sin(0.5*t));\n}\n\n// cuberoots of 1.\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cmul(p,expi(t));\n}\n\nfloat scale = 1.0;\n#define setscale() (scale = 2.5,scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\nconst int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0 && iFrame != 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = getselection(i-1); //texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.z = 1234.0;\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdXXWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1182, 1182, 1202, 1202, 1270], [1272, 1272, 1307, 2379, 2758], [2760, 2760, 2803, 2832, 3133], [3135, 3171, 3207, 3238, 3325], [3327, 3327, 3356, 3374, 3639], [3641, 3641, 3670, 3670, 4322], [4324, 4324, 4375, 4375, 6272]], "test": "untested"}
{"id": "DstBzf", "name": "Fractal - Circles", "author": "AlexisCG", "description": "Créâtes a fractal composed of many circles of color.", "tags": ["fractal", "circles", "color"], "likes": 0, "viewed": 105, "published": 3, "date": "1697481990", "time_retrieved": "2024-07-30T17:27:49.687160", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n   \n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uv2 = fract(sin(uv / 5.0) * 10.0 * sin(iTime + 100.0));\n    \n    uv = fract(uv * 5.0 * sin(iTime)) - 0.5;\n    \n    float d = length(uv);\n    d *= d * 0.75 * cos(iTime) * sin(iTime);\n    \n    float mult = 1.0;\n    d = sin(d) * 10.0 + 5.0 * cos(d*5.0);\n    \n    float newTime = sin(iTime);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime + newTime * 5.0 + uv2.xyx+vec3(0,2,4) * d);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 680]], "test": "untested"}
{"id": "dd3BRB", "name": "Bilinear Filtered Gradient", "author": "MacSlow", "description": "foobar", "tags": ["2d", "filtering", "bilinear", "cineshader"], "likes": 9, "viewed": 924, "published": 3, "date": "1697475647", "time_retrieved": "2024-07-30T17:27:50.614681", "image_code": "const vec3 col0 = vec3 (111./255., 204./255., 221./255.);\nconst vec3 col1 = vec3 ( 51./255., 196./255., 243./255.);\nconst vec3 col2 = vec3 ( 67./255., 143./255., 205./255.);\nconst vec3 col3 = vec3 ( 63./255., 116./255., 186./255.);\nconst vec3 col4 = vec3 ( 54./255.,  79./255., 161./255.);\nconst vec3 col5 = vec3 ( 88./255.,  62./255., 153./255.);\nconst vec3 col6 = vec3 (112./255.,  36./255., 111./255.);\nconst vec3 col7 = vec3 (217./255.,  25./255.,  62./255.);\nconst vec3 col8 = vec3 (237./255.,  31./255.,  35./255.);\nconst vec3 col9 = vec3 (247./255., 112./255.,  31./255.);\nconst vec3 colA = vec3 (249./255., 164./255.,  21./255.);\nconst vec3 colB = vec3 (252./255., 204./255.,   8./255.);\nconst vec3 colC = vec3 (255./255., 228./255.,   4./255.);\nconst vec3 colD = vec3 (245./255., 235./255.,  16./255.);\nconst vec3 colE = vec3 (249./255., 244./255., 176./255.);\nconst vec3 colF = vec3 (253./255., 253./255., 253./255.);\n\nvec3 gradient (float v)\n{\n    float steps = 16.;\n    float step = 1./steps;\n    vec3 col = vec3 (1., .0, 1.); // something nasty as default\n\n    if (v >= .0 && v < step) {\n        col = mix (col0, col1, v*steps);\n    } else if (v >= step && v < 2.*step) {\n        col = mix (col1, col2, (v - step)*steps);\n    } else if (v >=  2.*step && v <  3.*step) {\n        col = mix (col2, col3, (v -  2.*step)*steps);\n    } else if (v >=  3.*step && v <  4.*step) {\n        col = mix (col3, col4, (v -  3.*step)*steps);\n    } else if (v >=  4.*step && v <  5.*step) {\n        col = mix (col4, col5, (v -  4.*step)*steps);\n    } else if (v >=  5.*step && v <  6.*step) {\n        col = mix (col5, col6, (v -  5.*step)*steps);\n    } else if (v >=  6.*step && v <  7.*step) {\n        col = mix (col6, col7, (v -  6.*step)*steps);\n    } else if (v >=  7.*step && v <  8.*step) {\n        col = mix (col7, col8, (v -  7.*step)*steps);\n    } else if (v >=  8.*step && v <  9.*step) {\n        col = mix (col8, col9, (v -  8.*step)*steps);\n    } else if (v >=  9.*step && v < 10.*step) {\n        col = mix (col9, colA, (v -  9.*step)*steps);\n    } else if (v >= 10.*step && v < 11.*step) {\n        col = mix (colA, colB, (v - 10.*step)*steps);\n    } else if (v >= 11.*step && v < 12.*step) {\n        col = mix (colB, colC, (v - 11.*step)*steps);\n    } else if (v >= 12.*step && v < 13.*step) {\n        col = mix (colC, colD, (v - 12.*step)*steps);\n    } else if (v >= 13.*step && v < 14.*step) {\n        col = mix (colD, colE, (v - 13.*step)*steps);\n    } else if (v >= 14.*step && v < 15.*step) {\n        col = mix (colE, colF, (v - 14.*step)*steps);\n    } else\n        col = colF;\n\n    return col;\n}\n\nvec2 noise2d (in vec2 p)\n{\n\tvec3 v = fract (p.xyx*vec3(123.34, 234.34, 345.65));\n\tv += dot (v, v + 34.45);\n\treturn fract (vec2 (v.x*v.y, v.y*v.z));\n}\n\nmat3 r3d (float deg)\n{\n\tfloat r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    mat3 m = mat3 (vec3 ( c,  s, .0),\n                   vec3 (-s,  c, .0),\n                   vec3 (.0, .0, .0));\n\n    return m;\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3. - 2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm (vec3 p)\n{\n    float f;\n    mat3 m = r3d (1.1);\n\n    f  = .5*noise( p ); p = m*p*2.02;\n    f += .25*noise( p ); p = m*p*2.23;\n    f += .125*noise( p ); p = m*p*2.71;\n    f += .0625*noise( p );\n\n    return f;\n}\n\nmat2 r2d (in float degree)\n{\n\tfloat rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n    return mat2 (c, s, -s, c);\n}\n\nfloat smoothheavy (float a, float b, float v)\n{\n    float k = .5 + 2.5*(0.5 + .5*sin(iTime)); //.5;\n    float _v = clamp (v, a, b);\n    return 0.5 + 0.5*tanh(k*(_v*6. - 3.));\n}\n// array is interpreted from 0..3 as:\n//\n//   - 0: bottom left value\n//   - 1: bottom right value\n//   - 2: top left value\n//   - 3: top right value\n//\nfloat blerp (vec2 uv, float array[4])\n{\n    float m = smoothstep (.0, 1., uv.x);\n    float a = mix (array[0], array[1], m);\n    float b = mix (array[2], array[3], m);\n    return mix (a, b, smoothstep (.0, 1., uv.y));\n}\n\nfloat blerp2 (vec2 uv, float array[4])\n{\n    float m = smoothheavy (.0, 1., uv.x);\n    float a = mix (array[0], array[1], m);\n    float b = mix (array[2], array[3], m);\n    return mix (a, b, smoothheavy (.0, 1., uv.y));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize 'canvas'\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // rotate 'canvas'\n    uv *= r2d (24.*iTime);\n\n    // scale 'canvas'\n    float scale = 2. + 6.*(.5 + .5*cos (iTime));\n    uv *= scale;\n\n    vec2 grid = fract (uv);\n    vec2 id = floor (uv);\n\n    vec2 p = id + noise2d (id);\n    float m = distance (uv, p) - .01;\n    float l = .7*length (grid);\n    float d = smoothstep (.02, .03, m);\n\n    vec3 col = vec3 (.25);\n\n    col = mix (col, gradient (l), 1. - d);\n\n    const vec2 offsets[4] = vec2[4](\n        vec2(.0, .0),\n        vec2(1., .0),\n        vec2(.0, 1.),\n        vec2(1., 1.));\n\n    float array[4];\n    \n    for (int i = 0; i < 4; i++) {\n        vec2 p = id + offsets[i];\n        //vec2 n = noise2d (p);\n        //float v = n.x*n.y;\n        float v = fbm (vec3 (p, p.x-p.y));\n        array[i] = v;\n        \n    }\n    col = gradient (blerp2 (grid, array));\n\n    /*if (grid.x < .0125 || grid.y < .0125)\n        col *= .85;*/\n\n    fragColor = vec4 (col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3BRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 929, 954, 954, 2610], [2612, 2612, 2638, 2638, 2761], [2763, 2763, 2785, 2785, 2989], [2991, 2991, 3014, 3014, 3053], [3055, 3055, 3080, 3080, 3475], [3477, 3477, 3497, 3497, 3696], [3698, 3698, 3726, 3726, 3840], [3842, 3842, 3889, 3889, 4018], [4019, 4171, 4210, 4210, 4389], [4391, 4391, 4431, 4431, 4612], [4614, 4614, 4671, 4697, 5714]], "test": "untested"}
{"id": "mdtBRj", "name": "Dot Message Writer & Eraser", "author": "misol101", "description": "Why is it so hard to think of a meaningful message? Sorry, you get nonsense and reused text instead :D\n\nPress SPACE to toggle amount of trailing, ENTER to restart.", "tags": ["2d", "text", "dots", "dot", "transform", "multipass", "writer"], "likes": 11, "viewed": 208, "published": 3, "date": "1697473595", "time_retrieved": "2024-07-30T17:27:51.480366", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 v3 = texelFetch( iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)), 0 ).xyz;\n\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    float blue = abs(uv.y) < 0.43 ? 0.12 : 0.;\n    float white = blue>0. && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? 1. : 0.;\n    \n    fragColor = vec4( white+v3.x*0.9, white+v3.y*0.95, white+blue+v3.z, 1.0 );\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// send away dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (readKey(KEY_ENTER)) { fragColor=vec4(0); return; }\n    if (int(texelFetch(iChannel1, ivec2(0,0), 0).w) != int(iResolution.x)) { fragColor=vec4(0); return; }\n    \n    int pxi = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - 3;\n    if (pxi > NOF_DOTS) discard;\n\n    ivec2 r = ivec2(iResolution.xy);\n\n    if (ivec2(0,0) == ivec2(fragCoord)) {\n        ivec4 val = ivec4(texelFetch(iChannel0, ivec2(0,0), 0 ));\n        int tv = (1-int(texelFetch(iChannel0, ivec2(1,0), 0 ).x))*2-1;\n        if (iFrame < 2) {\n            val = ivec4(0);\n        } else {\n            int v=val[DOTS_PER_FRAME-1];\n            for (int j = 0; j<DOTS_PER_FRAME; j++) {\n                for (int i = 0; i < 5000; i++) { // search for lit pixel\n                    v+=1*tv;\n                    vec2 p=vec2(v%r.x,r.y-v/r.x);\n\n                    if (texelFetch(iChannel1,ivec2(p),0).x > 0.1) {\n                        break;\n                    }\n                }\n                val[j] = v;\n            }\n        }\n        fragColor = vec4(val);\n        return;\n    }\n\n    if (ivec2(1,0) == ivec2(fragCoord)) {\n        ivec4 val = ivec4(texelFetch(iChannel0, ivec2(0,0), 0 ));\n        int tv =  int(texelFetch(iChannel0, ivec2(1,0), 0 ).x);\n        if (iFrame < 2) {\n            tv = 0;\n        } else {\n            if (val.x > int(iResolution.x*iResolution.y)+5000*NOF_STEPS*2) tv=1;\n            if (val.x < 0) tv=0;\n        }\n        fragColor = vec4(tv);\n        return;\n    }\n    if (ivec2(2,0) == ivec2(fragCoord)) {\n        fragColor = texelFetch(iChannel0, ivec2(0,0), 0 );\n        return;\n    }\n\n    vec2 sp=vec2(0), ep=vec2(0);\n    int dotFound = -1;\n    for (int i=0; i<DOTS_PER_FRAME; i++) {\n        if ((pxi+i*(NOF_STEPS+1)) % NOF_DOTS == iFrame % NOF_DOTS)\n            dotFound = i;\n    }\n\n    if (dotFound >= 0) { // initialize new dot\n        int i = int(texelFetch(iChannel0, ivec2(0,0), 0 )[dotFound]);\n        vec2 p=vec2(i%r.x,r.y-i/r.x);\n\n        if (texelFetch(iChannel1,ivec2(p),0).x > 0.1) {\n            float progr = float(i / r.x) / float(r.y);\n            if (progr > 0.7)\n                sp = vec2(iResolution.x*0.5+sin(iTime*8.)*(iResolution.x*0.25), iResolution.y*0.92);\n            else if (progr > 0.4)\n                sp = vec2(0.55*iResolution.x+sin(iTime*5.)*(iResolution.x*0.1), 0.44*iResolution.y+cos(iTime*5.)*(iResolution.y*0.16));\n            else\n                sp = vec2(iResolution.x*0.5+sin(iTime*15.)*(iResolution.x*0.15), iResolution.y*0.08);\n            ep = p;\n            if (int(texelFetch(iChannel0, ivec2(1,0), 0 ).x) == 1) { ep=sp; sp=p; }\n        }\n        fragColor = vec4(sp, ep);\n    }\n    else { // update active dot\n        vec4 cs = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n        int count = (int(cs.w) >> 12) + 1;\n        int ai = int(cs.w) & 4095;\n        cs.w = float((count<<12) | ai);\n        vec2 ep = vec2(cs.z, ai);\n        \n        if (count >= NOF_STEPS) {\n            cs.x=ep.x; cs.y=ep.y; cs.w=float((NOF_STEPS<<12) | ai);\n        } else {\n            vec2 cp = cs.xy;\n            vec2 ap = (ep-cp)/(float(NOF_STEPS)-float(count));\n            cs.x += ap.x;\n            cs.y += ap.y;\n        }\n        fragColor = cs;\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int NOF_STEPS = 66;\n\nconst int DOTS_PER_FRAME = 2; // 1-4, higher value writes faster\n\nconst int NOF_DOTS = (NOF_STEPS + 1) * DOTS_PER_FRAME;\n\nconst int NOF_REGIONS = 9; // 2-9\nconst int BPC = NOF_REGIONS * NOF_REGIONS /4 + 1;\n\n#define LARGE_DOTS\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_D     = 68;\n\n#define readKey(key) (texelFetch( iChannel3, ivec2(key, 0), 0).x > .5)\n#define readKeyToggle(key) (texelFetch( iChannel3, ivec2(key, 2), 0).x > .5)\n", "buffer_b_code": "// check which regions have dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int pxi = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - 3;\n    if (pxi > NOF_DOTS) discard;\n    \n    if (ivec2(0,0)==ivec2(fragCoord)) {\n\n        int xd=int(iResolution.x) / NOF_REGIONS + 1;\n        int yd=int(iResolution.y) / NOF_REGIONS + 1;\n        ivec2 r = ivec2(iResolution.xy);\n\n        ivec4 regions = ivec4(0);\n        for (int i=3; i<NOF_DOTS+3; i++) {\n            ivec2 p=ivec2(i%r.x,i/r.x); \n            vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n            \n            int xr=int(px.x) / xd;\n            int yr=int(px.y) / yd;\n            int reg = xr + yr * NOF_REGIONS;\n            int cp = reg / BPC;\n            int bp = reg % BPC;\n            regions[cp] |= (1<<bp);\n        }\n        fragColor = vec4(regions);\n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// draw dots in place and fade old ones\n\nconst float END_VAL = 10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (readKey(KEY_ENTER)) { fragColor=vec4(0); return; }\n    if (int(texelFetch(iChannel2, ivec2(0,0), 0).w) != int(iResolution.x)) { fragColor=vec4(0); return; }\n\n    ivec2 r = ivec2(iResolution.xy);\n\n    bool alt = readKeyToggle(KEY_SPACE);\n    vec4 org = max(vec4(0.),texelFetch(iChannel1, ivec2(fragCoord), 0 ) - (alt? vec4(0.15,0.15,0.15,0.) : vec4(0.3,0.3,0.25,0.)));\n    float val = org.x;\n    \n    if (org.w >= END_VAL) { // keep this finished dot, unless it is one of our current start dots when reversing\n        bool isInit = false;\n        ivec4 inits = ivec4(texelFetch(iChannel0, ivec2(2,0), 0 ));\n        for (int i=0; i<DOTS_PER_FRAME; i++) {\n            if(ivec2(fragCoord)==ivec2(inits[i]%r.x,r.y-inits[i]/r.x))\n                isInit = true;\n        }\n        fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ).xyz, isInit ? 0. : END_VAL);\n        return;\n    }\n\n    vec4 regions = texelFetch(iChannel0, ivec2(0,0), 0 ); //regions = vec4(2097151.0);\n    int xd=int(iResolution.x) / NOF_REGIONS + 1;\n    int xr=int(fragCoord.x) / xd;\n    int yd=int(iResolution.y) / NOF_REGIONS + 1;\n    int yr=int(fragCoord.y) / yd;\n    int reg = xr + yr * NOF_REGIONS;\n    int cp = reg / BPC;\n    int bp = reg % BPC;\n    if ((int(regions[cp]) & (1<<bp)) == 0) {\n        fragColor = vec4(min(1.,val));\n        if (readKeyToggle(KEY_D)) fragColor = vec4(0.5); // see skipped regions\n        return;\n    }\n\n    float hitadd = alt? 0.6 : 1.0;\n    int ended = 0;\n\n    for (int i=3; i<NOF_DOTS+3; i++) {\n        ivec2 p=ivec2(i%r.x,i/r.x); \n        vec3 pxw = texelFetch(iChannel0, p, 0 ).xyw;\n        vec2 px = pxw.xy;\n#ifdef LARGE_DOTS\n        if (distance(px,fragCoord) < 1.) {\n            if ((int(pxw.z) >> 12) >= NOF_STEPS) { if (ended==0) ended=1; if (ivec2(px) == ivec2(fragCoord)) ended = 2; }\n#else\n        if (ivec2(px) == ivec2(fragCoord)) {\n            if ((int(pxw.z) >> 12) >= NOF_STEPS) ended = 2;\n#endif\n            org += hitadd; hitadd=0.;\n            // break; // slows things down, a lot...\n        }\n    }\n    if (ended > 0) { fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0 ).xyz, ended == 1 ? org.w : END_VAL); return; }\n\tfragColor = min(vec4(1.),org);\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// text to write\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(0,0)==ivec2(fragCoord)) {\n        fragColor=vec4(0,0,0,iResolution.x); return;\n    }\n\n    fragColor = vec4(0.);\n    vec2 UO = 18.*(fragCoord)/iResolution.y;\n    vec2 U;\n\n    U = UO;\n    U.x -= 3.;\n    if (U.x >= 0. && U.x <= 6. && U.y >= 14. && U.y <= 15.) {\n        int i = int[](28,85,110,100,101,114)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n    U = UO;\n    U.x -= 3.;\n    if (U.x >= 0. && U.x <= 13. && U.y >= 13. && U.y <= 14.) {\n        int i = int[](99,111,110,115,116,114,117,99,116,105,111,110,33)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n    U = UO;\n    U.x -= 22.;\n    if (U.x >= 0. && U.x <= 6. && U.y >= 11. && U.y <= 14.) {\n        int i;\n        switch(int(U.y-11.)) {\n            case 2: i = int[](73,32,87,65,83,32,32)[int(U)]; break;\n            case 1: i = int[](73,78,32,84,72,69,32)[int(U)]; break;\n            case 0: i = int[](80,79,79,76,33,32,32)[int(U)]; break;\n        }\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n    \n    U = UO;\n    U.x -= 7.;\n    if (U.x >= 0. && U.x <= 4. && U.y >= 6. && U.y <= 10.) {\n        int i;\n        switch(int(U.y-6.)) {\n            case 3: i = int[](32,68,65,32)[int(U)]; break;\n            case 2: i = int[](33,32,32,77)[int(U)]; break;\n            case 1: i = int[](63,32,32,78)[int(U)]; break;\n            case 0: i = int[](32,84,73,32)[int(U)]; break;\n        }\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n    U = UO;\n    U.x -= 14.;\n    if (U.x >= 0. && U.x <= 14. && U.y >= 3. && U.y <= 4.) {\n        int i = int[](29,87,114,111,110,103,32,115,104,97,100,101,114,29)[int(U)];\n        fragColor = vec4(texture( iChannel0, fract(U)*.055 + vec2(i,15-i/16)/16. ).x);\n        if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.05 || fract(U.y) > 0.97) fragColor=vec4(0.);\n    }\n\n}\n", "buffer_d_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 423]], "test": "untested"}
{"id": "cddfzX", "name": "Chill travel", "author": "z0rg", "description": "Chill", "tags": ["water", "train", "travel", "chill"], "likes": 23, "viewed": 281, "published": 3, "date": "1697471194", "time_retrieved": "2024-07-30T17:27:52.586408", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n\n        f = (f -.5)*2.;\n                float of = 1.-abs(f);\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        col += of*texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    rgb = pow(rgb*1.2, vec3(2.2));\n    vec2 cuv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    // Trial to flare with mipmap\n    /*\n    rgb = vec3(0.);\n    float cnt =7.;\n    float acc = 0.;\n    for (float j = 0.; j < cnt; ++j)\n    {\n        float f = sat(j/cnt);\n        f = f*f*f;\n        acc += f;\n      rgb += texture(iChannel1, uv, j).xyz*f;\n    }\n    rgb /= acc;\n    */\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 40\n#define GLOW_DISTANCE 0.1\n#define GLOW_POW 1.7\n#define GLOW_OPACITY 1.76\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n#define TAU (PI*2.0)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat hash11(float seed)\n{\n    return mod(sin(seed*123.456789)*123.456,1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = .9;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cucube(vec3 p, vec3 s, vec3 th)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-th;\n    float x = max(l.y, l.z);\n    float y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    return max(min(min(x, y), z), cube);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}", "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _seed;\nfloat rand()\n{\n    _seed++;\n    return hash11(_seed);\n}\n\n// Thanks IQ !\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat soundsdf(vec3 p)\n{\n    p.x += .25;\n    float rep = .05;\n    float id = floor((p.x+rep*.5)/rep);\n    p.x = mod(p.x+rep*.5,rep)-rep*.5;\n    float h = texture(iChannel2, vec2(fract(id*.05),0.)).x; \n    float shape = _sqr(p.xy, vec2(.01,pow(h,3.)*.7));\n    shape = max(shape, p.y);\n    return shape;\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    //acc = _min(acc, vec2(length(p)-1., 0.));\n    \n    vec3 pw = p+vec3(-iTime, 0., iTime)*.5;\n    float waterH = \n    (pow(texture(iChannel0, pw.xz*.01+iTime*.005).x, 2.)-.5)*.1\n    +(pow(texture(iChannel0, pw.xz*.02+iTime*.002).x, 4.)-.5)*.05;\n    //waterH *= 1.-sat(length(p.xz)-55.);\n    acc = _min(acc, vec2(-p.y+waterH, 1.));\n    \n    vec3 ptrain = p;\n    ptrain.xz *= r2d(.75);\n    float wall = abs(ptrain.z+.5)-.1;\n    float window = sdRoundBox(ptrain.xy-vec2(0.,-2.5), vec2(1.2, .75), vec4(.25));\n    wall = max(wall, -window);\n    acc = _min(acc, vec2(wall, 2.));\n    \n    float bars = soundsdf(ptrain*.25-vec3(0.,-.43,1.));\n    bars = max(bars, abs(ptrain.z+.5+.095)-.005);\n    bars = max(bars, window+.05);\n    acc = _min(acc, vec2(bars, 3.));\n    \n    p.x += -iTime*.5;\n    p.x *= .25;\n    float mount = \n    p.y*2.+4.5\n    -sin(p.x*.5)\n    -sin(p.x)\n    -sin(p.x*2.3)*.7\n    -sin(p.x*5.)*.2\n    -sin(p.x*3.)*.2\n    -sin(p.x*12.)*.11\n    ;\n    float mountth = abs(ptrain.z-40.5)-.1;\n    mount = max(-mount, mountth);\n    acc = _min(acc, vec2(mount, 2.));\n    //acc = _min(acc, vec2(-p.y-sat(.8-abs(ptrain.z)*.5), 3.));\n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps && distance(p, ro) < 90.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.y == 3.)\n        {\n            //vec3(.2,1.,1.)\n            accCol += sat(1.+sin(p.y*100.))*.19*vec3(1.000,0.200,0.322)*(1.-sat(res.x/.1));\n            res.x += .02;\n        }\n        if (res.x < 0.001)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 rdrenv(vec3 rd)\n{\n    vec3 cols[4];\n    cols[0] = vec3(42, 72, 88);\n    cols[1] = vec3(0, 137, 138);\n    cols[2] = vec3(100, 201, 135);\n    cols[3] = vec3(250, 250, 110);\n    float f = acos(-rd.y)/PI-.41;\n    f = pow(sat(f*10.),2.);\n    float fscale = f*3.;\n    int cur = int(floor(fscale));\n    int next = min(int(floor(fscale))+1,3);\n    return mix(cols[cur]/255., cols[next]/255., fract(fscale));\n}\n\nvec3 rotateCol(vec3 col)\n{\n    vec3 cols[5];\n    cols[0] = col;\n    cols[1] = col.zxy;\n    cols[2] = col.zyx;\n    cols[3] = col.yxz;\n    cols[4] = col.yxz;\n    \n    float f = asin(sin(iTime*.02+4.))/(PI*.5);\n    f = f*.5+.5;\n    float fscale = f*4.;\n    int cur = int(floor(fscale));\n    int next = min(int(floor(fscale))+1,4);\n    return mix(cols[cur], cols[next], fract(fscale));\n\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(.0,-2.5,-3.5);\n    vec3 ta = vec3(0.,-2.3,1.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 128);\n    float depth = 100.;\n    col = rdrenv(rd);\n    vec3 acc = accCol;\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n\n        col = n*.5+.5;\n        vec3 refl = reflect(rd, n);\n        if (res.z == 2. || res.z == 3.)\n        {\n\n            col = vec3(0.043,0.035,0.102);\n            vec3 surftrain = vec3(1.,0.,0.);\n            surftrain.xz *= r2d(.75);\n            if (sat(abs(dot(surftrain, n))) < 0.9)\n            {\n                col = vec3(0.224,0.212,0.408);\n                refl = normalize(refl + (vec3(rand(), rand(), rand())-.5)*.5);\n                col += .5*pow(rdrenv(refl), vec3(2.));\n            }\n            \n        }\n        if (res.z == 1.)\n        {\n            //col = mix(vec3(0.239,0.071,0.349), vec3(1.000,0.302,0.000), sat((n.z*4.)));\n            col = vec3(0.090,0.106,0.227);\n\n            col += pow(rdrenv(refl), vec3(2.));\n        }\n    }\n    col += acc;\n    col = mix(col, mix(rdrenv(rd), vec3(1.), .3), sat(1.-exp(-depth*0.023)));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = iTime+texture(iChannel0, uv).x;\n    vec2 off = .75*(vec2(rand(), rand())-.5)*2.*1./iResolution.x;\n    vec3 col = rdr(uv+off);\n    \n\n    float t = iTime*1.;\n    float daynight =  mix(1.4,1.7,sat(sin(t*.1+1.)));\n    col *= daynight/(col+1.);\n    col = rotateCol(col);\n\n//col = pow(col, vec3(.4545));\n    if (iFrame != 0)\n        col = mix(col, texture(iChannel1, fragCoord/iResolution.xy).xyz, .9);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34917, "src": "https://soundcloud.com/oddlingmusic/forhill-oddling-supernal?si=6f0287cd27224b8b916e8941375f3255&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        \n        f = (f -.5)*2.;\n        float of = 1.-abs(f);\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        col += of*texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddfzX.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1368]], "test": "untested"}
{"id": "mscBRf", "name": "Balls In Motion 2", "author": "dr2", "description": "Mouseable balls in transparent box with obstacles", "tags": ["dynamics", "collisions"], "likes": 29, "viewed": 394, "published": 3, "date": "1697458800", "time_retrieved": "2024-07-30T17:27:53.662531", "image_code": "// \"Balls In Motion 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Hopefully the behavior looks natural (the physical model is used for\n  studying granular flow, so minimal strange artifacts).\n  Mouse does various things...\n\n  No. 39 in \"Ball Dynamics\" series\n    \"Balls Falling\"             (NsKGR3) - others listed here\n    \"Rock the Balls\"            (7ltXWX)\n\n  No.94 in \"Physical Dynamics\" series\n    \"Grid-Surfing Balls\"        (mlVGWy) - others listed here\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 OrAng (vec3 p);\nvec3 OrAngT (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nvec3 ltPos, vnBall, hbSize, blkAng, vnBlk;\nfloat dstFar, hbMarg, baseRad, baseUp;\nint nFrame, nBall, idObj, idBall, txOff;\nconst int idFrm = 1, idFrmEx = 2, idAx = 3, idObs = 4, idBas = 5, idFlr = 6;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  p.y -= baseUp;\n  q = abs (OrAng (p));\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.1),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.1)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.1));\n  DMIN (idFrm);\n  b = length (hbSize.xy - hbMarg);\n  f = 0.5 * (baseUp - 0.05);\n  tr = 0.25;\n  sLen.xyz = vec3 (b + 6. * tr, f - tr, hbSize.z - hbMarg + 2. * tr);\n  d = PrCylDf (vec3 (q.xy, abs (q.z) - sLen.z + tr), 0.8 * tr, tr);\n  DMIN (idAx);\n  if (abs (q.x) < abs (q.y)) q.xy = q.yx;\n  d = PrRoundBoxDf (vec3 (abs (q.x) - (hbSize.x - hbMarg - 1.9), q.yz),\n     vec3 (2. - hbMarg, 0.1, hbSize.z - hbMarg - 0.3), 0.1);\n  DMIN (idObs);\n  q = p;\n  q.xz = Rot2D (q.xz, blkAng.y);\n  q.yz = Rot2D (q.yz, blkAng.x);\n  d = min (PrRoundBoxDf (vec3 (q.xy, abs (q.z) - sLen.z),\n     vec3 (b + 4. * tr, tr, tr) - 0.1, 0.1),\n     PrRoundBoxDf (vec3 (abs (q.x) - b - 3. * tr, q.yz),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  DMIN (idFrmEx);\n  d = PrCylDf (vec3 (abs (q.x) - b - 4.5 * tr, q.yz).yzx, 0.8 * tr, tr);\n  DMIN (idAx);\n  q = p;\n  q.xz = Rot2D (q.xz, blkAng.y);\n  d = PrRoundBoxDf (vec3 (abs (q.xz) - sLen.xz, q.y + sLen.y).xzy,\n     vec3 (tr, f, tr) - 0.1, 0.1);\n  d = min (d, PrRoundBoxDf (vec3 (abs (q.x) - sLen.x, abs (q.y + sLen.y) - sLen.y, q.z),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y + 2. * sLen.y).xzy,\n     vec3 (sLen.x, tr, tr) - 0.1, 0.1));\n  DMIN (idFrmEx);\n  d = PrCylDf (vec3 (q.xz, q.y + 2. * sLen.y), 2. * tr, 1.4 * tr);\n  DMIN (idAx);\n  q = p;\n  q.y -= - 2. * f - 0.05;\n  d = PrRoundCylDf (q.xzy, baseRad, 0.1, 0.15);\n  DMIN (idBas);\n  p.y += baseUp;\n  q = p;\n  d = q.y;\n  DMIN (idFlr);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    if (p.w > 0.) {\n      u = ro - p.xyz;\n      rad = 0.46 * p.w;\n      b = dot (rd, u);\n      w = b * b - dot (u, u) + rad * rad;\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) {\n          dMin = d;\n          vnBall = (u + d * rd) / rad;\n          idBall = n;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.49 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  return step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, rob, rdb, vn, ltDir;\n  float dstBall, dstObj, db, att, nDotL, sh;\n  rob = OrAng (ro - vec3 (0., baseUp, 0.));\n  rdb = OrAng (rd);\n  db = BlkHit (rob, rdb);\n  dstBall = (db < dstFar) ? BallHit (rob, rdb) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idFrm) col4 = vec4 (0.85, 0.8, 0.8, 0.1);\n      else if (idObj == idFrmEx) col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      else if (idObj == idAx) col4 = vec4 (0.8, 0.7, 0.7, 0.1);\n      else if (idObj == idObs) col4 = vec4 (0.75, 0.7, 0.7, 0.1);\n      else if (idObj == idBas) col4 = vec4 (0.6, 0.6, 0.65, 0.05);\n      else if (idObj == idFlr) col4 = vec4 (0.6, 0.4, 0.1, 0.05);\n    } else {\n      ro += dstBall * rd;\n      vn = OrAngT (vnBall);\n      col4 = vec4 (HsvToRgb (vec3 (fract (33. * float (idBall) / float (nBall) +\n         0.5 * BallChqr (idBall, vnBall)), 0.8, 1.)), 0.2);\n    }\n    ltDir = normalize (ltPos - ro);\n    att = smoothstep (0., 0.01, dot (ltDir, normalize (ltPos)) - 0.95);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstBall && idObj <= idObs) nDotL *= nDotL;\n    sh = ObjSShadow (ro, ltDir, dstFar);\n    sh = min (sh, 0.5 + 0.5 * BallHitSh (OrAng (ro - vec3 (0., baseUp, 0.)), OrAng (ltDir), 80.));\n    col = att * (col4.rgb * (0.2 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * sh * nDotL) + col4.a * step (0.95, sh) * pow (max (0.,\n       dot (ltDir, reflect (rd, vn))), 32.));\n  } else {\n    col = vec3 (0.);\n  }\n  if (db < min (dstObj, dstFar)) {\n    ro = rob + db * rdb;\n    if (dstObj < dstBall) col *= 0.95;\n    vn = OrAngT (vnBlk);\n    col = mix (col, vec3 (0.5) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.), pow (1. - abs (dot (rd, vn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col)\n{\n  vec4 stDat;\n  vec3 wgBx;\n  vec2 cVec, w;\n  float mPtrz;\n  int wgSel;\n  wgBx = vec3 (1.4, 0., 0.25);\n  stDat = Loadv4 (2);\n  mPtrz = stDat.z;\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (3);\n  cVec = stDat.xy;\n  w = uv -  wgBx.xy;\n  col = mix (vec3 (0.35), col, 0.5 + 0.5 * smoothstep (4., 6., PrRoundBox2Df (w,\n     vec2 (wgBx.z), 0.03) * canvas.y));\n  col = mix (vec3 (0., 1., 1.), col, smoothstep (3., 4., abs (length (w) - wgBx.z) * canvas.y));\n  if (length (w) < wgBx.z) col = mix (vec3 (0., 1., 1.), col,\n       smoothstep (3., 4., Minv2 (abs (w) * canvas.y)));\n  if (length (cVec) < 1.) col = mix (vec3 (1., 1., 0.), col,\n     smoothstep (10., 15., length (w - cVec * wgBx.z) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 col, ro, rd;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  txOff = 4;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  baseRad = 1.8 * hbSize.x;\n  stDat = Loadv4 (1);\n  blkAng = stDat.xyz;\n  nBall = int (stDat.w);\n  stDat = Loadv4 (3);\n  el = stDat.z;\n  az = stDat.w;\n  zmFac = 6. - 5. * el;\n  el = 0.2 * (el + 0.05 * pi) - 0.05 * pi;\n  vuMat = StdVuMat (el, az);\n  hbMarg = 0.4;\n  baseUp = 1.1 * length (hbSize - hbMarg) + 0.1;\n  ro = vuMat * vec3 (0., 1., - 12. * hbSize.x);\n  ro.y += baseUp;\n  dstFar = 20. * length (hbSize);\n  ltPos = 100. * vec3 (0.4, 1., -1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = ShowWg (uv, canvas, col);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec3 OrAng (vec3 p)\n{\n  p.xz = Rot2D (p.xz, blkAng.y);\n  p.yz = Rot2D (p.yz, blkAng.x);\n  p.xy = Rot2D (p.xy, blkAng.z);\n  return p;\n}\n\nvec3 OrAngT (vec3 p)\n{\n  p.xy = Rot2D (p.xy, - blkAng.z);\n  p.yz = Rot2D (p.yz, - blkAng.x);\n  p.xz = Rot2D (p.xz, - blkAng.y);\n  return p;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Balls In Motion 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, gVec;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    diamN = p.w;\n    if (diamN > 0.) {\n      rmN = p.xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      diamAv = 0.5 * (diam + diamN);\n      if (n != mId && rSep < diamAv) {\n        fc = fOvlap * (diamAv / rSep - 1.);\n        vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n        wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n        dv = vm - vmN;\n        h = dot (dr, dv) / (rSep * rSep);\n        fc = max (fc - fricN * h, 0.);\n        am += fc * dr;\n        dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n        ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n        am -= ft * dv;\n        wam += (ft / rSep) * cross (dr, dv);\n      }\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 b, s;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 0.1);\n  b = hbSize.xy - 2.;\n  s = sign (rm.xy) * vec2 (-1., 1.);\n  dr.z = 0.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dr.xy = s * ((k == 0) ? max (vec2 (b.x - abs (rm.x), abs (rm.y)) - vec2 (2., 0.1), 0.) :\n       - max (vec2 (abs (rm.x), b.y - abs (rm.y)) - vec2 (0.1, 2.), 0.));\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 500.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  diam = p.w;\n  if (diam > 0.) {\n    rm = p.xyz;\n    p = Loadv4 (txOff + 4 * mId + 1);\n    vm = p.xyz;\n    qm = Loadv4 (txOff + 4 * mId + 2);\n    wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n    ms = diam * diam * diam;\n    am = vec3 (0.);\n    wam = vec3 (0.);\n    PairInt (mId, rm, vm, wm, diam, am, wam);\n    BdyInt (rm, vm, wm, diam, am, wam);\n    ObsInt (rm, vm, wm, diam, am, wam);\n    am -= grav * gVec + fDamp * vm;\n    wam -= fDamp * wm;\n    vm += dt * am / ms;\n    rm += dt * vm;\n    wm += dt * wam / (0.2 * ms * diam);\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n  w = hbSize.xy - 2. - abs (rm.xy);\n  if (length (max (vec2 (w.x, abs (rm.y)) - vec2 (2., 0.1), 0.)) < 1. ||\n      length (max (vec2 (w.y, abs (rm.x)) - vec2 (2., 0.1), 0.)) < 1.) diam = -1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng, wgBx, mVec;\n  vec2 iFrag, canvas, ust, mt, cVec;\n  float el, az, mPtrPz, asp, diam;\n  int mId, pxId, wgSel, wgReg, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (ivec2 (16), 2);\n  txOff = 4;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  wgReg = -2;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  dt = 0.01;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    nBall = nbMax;\n    wgSel = -1;\n    el = -0.05 * pi;\n    az = 0.;\n    blkAng = vec3 (0.);\n    cVec = vec2 (0.);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nBall = int (stDat.w);\n    stDat = Loadv4 (2);\n    mPtrPz = stDat.z;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (3);\n    cVec = stDat.xy;\n    el = stDat.z;\n    az = stDat.w;\n  }\n  wgBx = vec3 (1.4, 0., 0.25);\n  if (mPtr.z > 0.) {\n    mt = 2. * mPtr.xy * vec2 (asp, 1.) - wgBx.xy;\n    if (length (mt) < wgBx.z) {\n      cVec = mt / wgBx.z;\n      wgReg = 0;\n    }\n    if (mPtrPz <= 0.) wgSel = wgReg;\n  } else {\n    cVec = vec2 (0.);\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    blkAng.x = -1.3 * pi * cVec.y * smoothstep (0.15, 0.2, abs (cVec.y));\n    blkAng.z = -1.3 * pi * cVec.x;\n  } else {\n    blkAng.z = mod (blkAng.z + 0.0003 * pi, 2. * pi);\n  }\n  if (mPtr.z > 0. && wgSel < 0) {\n    blkAng.y = -2. * pi * mPtr.x;\n    el = clamp (pi * mPtr.y, -0.45 * pi, 0.03 * pi);\n  } else {\n    el = 0.98 * (el + 0.05 * pi) - 0.05 * pi;\n    blkAng.xy *= 0.98;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (blkAng, float (nBall));\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 3) stDat = vec4 (cVec, el, az);\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Balls In Motion 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, gVec;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    diamN = p.w;\n    if (diamN > 0.) {\n      rmN = p.xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      diamAv = 0.5 * (diam + diamN);\n      if (n != mId && rSep < diamAv) {\n        fc = fOvlap * (diamAv / rSep - 1.);\n        vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n        wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n        dv = vm - vmN;\n        h = dot (dr, dv) / (rSep * rSep);\n        fc = max (fc - fricN * h, 0.);\n        am += fc * dr;\n        dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n        ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n        am -= ft * dv;\n        wam += (ft / rSep) * cross (dr, dv);\n      }\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 b, s;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 0.1);\n  b = hbSize.xy - 2.;\n  s = sign (rm.xy) * vec2 (-1., 1.);\n  dr.z = 0.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dr.xy = s * ((k == 0) ? max (vec2 (b.x - abs (rm.x), abs (rm.y)) - vec2 (2., 0.1), 0.) :\n       - max (vec2 (abs (rm.x), b.y - abs (rm.y)) - vec2 (0.1, 2.), 0.));\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 500.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  diam = p.w;\n  if (diam > 0.) {\n    rm = p.xyz;\n    p = Loadv4 (txOff + 4 * mId + 1);\n    vm = p.xyz;\n    qm = Loadv4 (txOff + 4 * mId + 2);\n    wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n    ms = diam * diam * diam;\n    am = vec3 (0.);\n    wam = vec3 (0.);\n    PairInt (mId, rm, vm, wm, diam, am, wam);\n    BdyInt (rm, vm, wm, diam, am, wam);\n    ObsInt (rm, vm, wm, diam, am, wam);\n    am -= grav * gVec + fDamp * vm;\n    wam -= fDamp * wm;\n    vm += dt * am / ms;\n    rm += dt * vm;\n    wm += dt * wam / (0.2 * ms * diam);\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n  w = hbSize.xy - 2. - abs (rm.xy);\n  if (length (max (vec2 (w.x, abs (rm.y)) - vec2 (2., 0.1), 0.)) < 1. ||\n      length (max (vec2 (w.y, abs (rm.x)) - vec2 (2., 0.1), 0.)) < 1.) diam = -1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng, wgBx, mVec;\n  vec2 iFrag, canvas, ust, mt, cVec;\n  float el, az, mPtrPz, asp, diam;\n  int mId, pxId, wgSel, wgReg, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (ivec2 (16), 2);\n  txOff = 4;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  wgReg = -2;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  dt = 0.01;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    nBall = nbMax;\n    wgSel = -1;\n    el = -0.05 * pi;\n    az = 0.;\n    blkAng = vec3 (0.);\n    cVec = vec2 (0.);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nBall = int (stDat.w);\n    stDat = Loadv4 (2);\n    mPtrPz = stDat.z;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (3);\n    cVec = stDat.xy;\n    el = stDat.z;\n    az = stDat.w;\n  }\n  wgBx = vec3 (1.4, 0., 0.25);\n  if (mPtr.z > 0.) {\n    mt = 2. * mPtr.xy * vec2 (asp, 1.) - wgBx.xy;\n    if (length (mt) < wgBx.z) {\n      cVec = mt / wgBx.z;\n      wgReg = 0;\n    }\n    if (mPtrPz <= 0.) wgSel = wgReg;\n  } else {\n    cVec = vec2 (0.);\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    blkAng.x = -1.3 * pi * cVec.y * smoothstep (0.15, 0.2, abs (cVec.y));\n    blkAng.z = -1.3 * pi * cVec.x;\n  } else {\n    blkAng.z = mod (blkAng.z + 0.0003 * pi, 2. * pi);\n  }\n  if (mPtr.z > 0. && wgSel < 0) {\n    blkAng.y = -2. * pi * mPtr.x;\n    el = clamp (pi * mPtr.y, -0.45 * pi, 0.03 * pi);\n  } else {\n    el = 0.98 * (el + 0.05 * pi) - 0.05 * pi;\n    blkAng.xy *= 0.98;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (blkAng, float (nBall));\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 3) stDat = vec4 (cVec, el, az);\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscBRf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1406, 1406, 1428, 1428, 3242], [3244, 3244, 3277, 3277, 3461], [3463, 3463, 3484, 3484, 3740], [3742, 3742, 3791, 3791, 4033], [4035, 4035, 4069, 4069, 4549], [4551, 4551, 4598, 4598, 4975], [4977, 4977, 5019, 5019, 5153], [5155, 5155, 5188, 5188, 5536], [5538, 5538, 5573, 5573, 7484], [7486, 7486, 7532, 7532, 8244], [8246, 8246, 8299, 8299, 9531], [9533, 9533, 9579, 9579, 9626], [9628, 9628, 9675, 9675, 9722], [9724, 9724, 9766, 9766, 9817], [9819, 9819, 9876, 9876, 9952], [9954, 9954, 9978, 9978, 10294], [10296, 10296, 10317, 10317, 10430], [10432, 10432, 10454, 10454, 10573], [10575, 10575, 10597, 10597, 10624], [10626, 10626, 10648, 10648, 10675], [10677, 10677, 10722, 10722, 10814], [10816, 10816, 10873, 10873, 10956], [10958, 10958, 10994, 10994, 11200], [11202, 11202, 11232, 11232, 11345], [11347, 11347, 11371, 11371, 11493], [11587, 11587, 11612, 11612, 11735]], "test": "untested"}
{"id": "md3fzX", "name": "Rolling Arcs", "author": "INCHMAN1900", "description": "Trying to make arcs in shadertoy.", "tags": ["shapes", "arc"], "likes": 8, "viewed": 182, "published": 3, "date": "1697455697", "time_retrieved": "2024-07-30T17:27:54.514254", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(1.17, .5);\n    vec3 col = vec3(0.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    uv-=center;\n    \n    float dist = length(uv);\n    float radius = round(dist * 30.) / 30.;\n    float speed = 4. * (1.0 - radius);\n    float angle = acos(dot(normalize(vec2(sin(iTime * speed), cos(iTime * speed))), normalize(uv)));\n    if (angle > 0.7) {\n        col += smoothstep(.002, 0., abs(dist - radius));\n    }\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/md3fzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 554]], "test": "untested"}
{"id": "DsVcW1", "name": "Biom Texture Shuffle Dither", "author": "gehtsiegarnixan", "description": "simple demo on how to do a terrain with differen bioms and texture breakup in one. This uses a 1 sample version of Directional Flow. ", "tags": ["terrain", "texture", "dither", "normal", "height", "tiling", "bilinear", "stochastic", "directionalflow", "biom"], "likes": 19, "viewed": 274, "published": 3, "date": "1697453923", "time_retrieved": "2024-07-30T17:27:55.491641", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a demo that shows how to disrupt texture tiling, sample different \nbiomes, and blend them seamlessly. This technique is a slight variation of \nthe Directional Flow method.\n\nThis code is extensively commented to help you understand its inner workings. \nIt's important to note that it's designed to work with a range of features \nShadertoy does not have, such as Texture Arrays and Gather functions. If \nyou have access to these native functions, use them instead. The \nDirectional Flow algorithm is a versatile tool that can create a variety \nof effects, which go beyond the scope of this shader.\n\nThis shader uses dithering to switch between samples and is so able to use a\nsingle sample to achive similar results to bilinear interpolation. If you \nuse TemporalAA to blur the result it looks pretty much identical to a proper\nbilinear interpolation while being ~4x faster.\n\nThis demo includes mouse controls to adjust the light direction, zoom and \nvarious parameters mentioned below this header.\n\nAdditional reading material:\n\nCatlikeCoding's has a well explained guide on Directional Flow:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n\nCOD recently made a presentation outlining a similar method:\nhttps://advances.realtimerendering.com/s2023/index.html#CODTerrain\n\nHere's my 4-sample Bilinear Biom Texture Shuffle:\nhttps://www.shadertoy.com/view/dsVyRw\n\nSee here how to Dither Bilinear Weights:\nhttps://www.shadertoy.com/view/ddGcWh\n*/\n\n// The number of previous samples looked at to blur result, with a similar effect to\n// Temporal Anti-Aliasing (TAA) which you should use instead if you can.\n#define TEMPORALBLUR 8 \n\n// Enable debug grid where the two mappings blend with each other\n#define LINETHICKNESS 0.01\n//#define SHOWGRID\n\n// Size of interpolation grid\n#define GRIDSIZE 32.0\n\n// Power scale: 1 means no contrast, 50 means maximum contrast\n#define CONTRAST 2.0\n\n// Maximum noise offset in grid scale\n#define NOISESTRENGTH 1.2\n\n// Scale of noise in grid scale\n#define NOISESCALE 1.3 \n\n// Size of textures in grid scale\n#define DETAILSCALE 1.0\n\n// Function to select a texture using an index. Acts like a crude texture array.\nvec4 textureArray(int index, vec2 uv, vec2 duvdx, vec2 duvdy) {\n    vec4 color;    \n    if (index == 0) {\n        // the gravel texture is just greyscale so we make it pretty with a colormap\n        color = vec4(bone(textureGrad(iChannel0, uv, duvdx, duvdy).x),0);\n    } else if (index == 1) {\n        color = textureGrad(iChannel1, uv, duvdx, duvdy);\n    } else if (index == 2) {\n        color = textureGrad(iChannel2, uv, duvdx, duvdy);\n    } else {\n        color = textureGrad(iChannel3, uv, duvdx, duvdy);\n    }\n    return color;\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 HeightToNormal(int heightMap, vec2 uv, vec2 duvdx, vec2 duvdy, float strength) {\n    vec2 s = 1.0 / iChannelResolution[0].xy;\n    \n    float textureOffset = 1.0;\n    \n    float p = textureArray(heightMap, uv, duvdx, duvdy).y;\n    float h1 = textureArray(heightMap, uv + s * vec2(textureOffset,0), duvdx, duvdy).y;\n    float v1 = textureArray(heightMap, uv + s * vec2(0,textureOffset), duvdx, duvdy).y;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return normalize(vec3(xy * strength, 1.0));\n}\n\n// Struct to hold material values\nstruct materialVal {\n    vec3 color;\n    vec3 normal;\n};\n\n// Generate biomes blending with texture tiling breakup in one\nmaterialVal biomTexShuffle(sampler2D biomTex, vec2 uv, vec2 fragCoord, float time,\n    float gridSize, float contrast, float noiseStrength, float rndScale, float texScale) {\n\n    // Tiling Noise ________________________________________________________\n    // The tiling noise idea is from COD:\n    // https://advances.realtimerendering.com/s2023/index.html#CODTerrain\n    \n    // Scale noise coordinates to be independent of biome dimension for convenience\n    vec2 noiseUV = uv * gridSize / rndScale;\n    \n    // Sample noise vector; using a 2D texture of Perlin noise would be better\n    vec2 noiseVec = simplexNoiseVec(noiseUV);\n    \n    // Apply strength and correct for biome dimension again\n    noiseVec = noiseVec * noiseStrength / gridSize;\n    \n    // Distort the grid UVs to hide the tiling pattern\n    vec2 gridUV = uv - noiseVec;\n    \n    // Weights ____________________________________________________________\n        \n    // Generate zigzag pattern\n    vec2 zigZag = abs(fract(gridUV * gridSize/2.0 - 0.25)*2.0-1.0);\n    \n    // Invert zigzag as a partial of the weights\n    vec2 infZigZag = 1.0 - zigZag;\n\n    // Generate alpha values (weights) for bilinear interpolation.\n    float weightA = zigZag.x * zigZag.y;\n    float weightB = zigZag.x * infZigZag.y;\n    float weightC = infZigZag.x * zigZag.y;\n    float weightD = infZigZag.x * infZigZag.y;\n    \n    // Combine weight/alpha values. \n    vec4 weights = vec4(weightA, weightB, weightC, weightD);\n        \n    // Change the weights contrast for less blurry results.\n    weights = smoothContrast(weights, contrast);\n    \n    // Dither _____________________________________________________________\n    \n    // Sample dither noise\n    float dither = ScreenSpaceDither12(fragCoord, time);\n    \n    // Smooth contrast creates artifacts in the dither. Clamping removes them\n    dither = clamp(dither, 0.01, 0.99);\n    \n    // Applies float dither to weight values.\n    // The weights are grouped cumulatively, and if the dither value is within one \n    // cumulative section for one of the weights, that weight is selected\n    vec2 offset;\n    if (weights.x > dither) {\n        // Weight A\n        offset = vec2(0.0, 0.0);\n    } else if (weights.x + weights.y > dither) {\n        // Weight B\n        offset = vec2(0.0, 0.5);\n    } else if (1. - weights.w > dither) {\n        // Weight C\n        // because sum of all weights is 1, so 1-w = sum of xyz\n        offset = vec2(0.5, 0.0);\n    } else {\n        // Weight D\n        offset = vec2(0.5, 0.5);\n    }\n    \n    // Biom ________________________________________________________________\n    \n    // Coordinates of every other grid point\n    vec2 scaledCoords = (floor(gridUV * (gridSize/2.) +.25 +offset) -offset)*2.;\n    \n    // Get biome texture resolution\n    vec2 texSize = vec2(textureSize(biomTex, 0));\n    \n    // Modulo for looping biome textures\n    ivec2 texelCoords = ivec2(fract(scaledCoords/gridSize) * texSize);\n    \n    // Sample the texels.\n    float biom = texelFetch(biomTex, texelCoords, 0).x;\n    \n    // Increase to separate numbers\n    float biomCount = 4.; // Since we can only have 4 textures\n    \n    // Scale biom sample to seperate integers\n    //int biomID = int(biom * biomCount);\n    // Since I don't have an actual biom texture I'll do some modifications \n    int biomID = int(biom * 7.);\n    \n    // Sample Detail Textures ______________________________________________\n    \n    // This hash doesn't like 0. Mod is optional and makes it repeat at uv 0-1.\n    vec2 hashCoords = mod(scaledCoords, gridSize) + 1.; \n    \n    // Obtain a cheap random vector \n    vec2 rnd = hash22(hashCoords) * 2.0 - 1.0;\n    \n    // Scale UVs for detail textures, should be higher than texSize\n    vec2 detailUV = uv * gridSize * texScale;\n    \n    // Calculate mip as the automatic ones don't work for dithering\n    vec2 duvdx = dFdx(detailUV);\n    vec2 duvdy = dFdy(detailUV);\n    \n    // Normalize vector to prevent rotation from scaling the result\n    vec2 rotation = normalize(rnd);\n    \n    // Randomly rotate\n    detailUV = rotateUV(detailUV, rotation);\n    \n    // Randomly offset\n    detailUV += rnd;\n    \n    // Sample detail texture\n    vec3 color = textureArray(biomID, detailUV, duvdx, duvdy).xyz; \n    \n    // Sample Normal, if you can use an actual normal texture instead\n    vec3 normal = HeightToNormal(biomID, detailUV, duvdx, duvdy, 50.0);\n    \n    // Since we rotated the UVs we have to rotate the normals too\n    normal = vec3(rotateUV(normal.xy, rotation), normal.z);\n        \n    #ifdef SHOWGRID\n        // overlaying the edges of the alpha mask\n        vec4 mask = step(abs(weights - 0.1), vec4(LINETHICKNESS));\n        color = max(mask.xyz, color * (1.-mask.w));\n    #endif\n    \n    // Combine color and normal into a struct\n    return materialVal(color, normal);;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Square UVs, with 0.5 in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.x + 0.5; \n\n    // If the mouse was not clicked, animate light\n    vec3 lightDir;\n    float zoom;\n    if (iMouse.x > 0.0) {\n        // scale mouse coords to 0-1 range of screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomsteps = 10.;\n        zoom = mix(1.0, 0.10, pow(floor(mouse.y*zoomsteps)/zoomsteps,.5));\n    \n        // Mouse controls light direction\n        float angle = mouse.x * 3.14 * 3.;\n        lightDir = normalize(vec3(cos(angle), sin(angle), 1.0));\n    } else {\n        // Animated zoom\n        float zoomTime = iTime * 0.1;\n        zoom = mix(1.0, 0.10, cos(zoomTime) * 0.5 + 0.5);\n    \n        // Time controls light direction\n        float lightTime = iTime * 0.3;\n        lightDir = normalize(vec3(cos(lightTime), sin(lightTime), 1.0));\n    } \n    \n    // Apply zoom on the center\n    uv = (uv - 0.5) * zoom + 0.5;\n\n    // Initialize color and normal\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    \n    #if TEMPORALBLUR <= 1\n        // We just take a single sample from the ditheredSample function.\n        materialVal terrain = biomTexShuffle(iChannel3, uv, fragCoord, iTime,\n            GRIDSIZE, CONTRAST, NOISESTRENGTH, NOISESCALE, DETAILSCALE);\n        color = terrain.color;\n        normal = terrain.normal;\n        \n    #else\n        // We take multiple samples from the ditheredSample function and average them.\n        // This is normally done automatically by your TAA or motion blur\n        for(int i = 0; i < TEMPORALBLUR; i++) {\n            materialVal terrain = biomTexShuffle(iChannel3, uv, fragCoord, iTime - float(i),\n                GRIDSIZE, CONTRAST, NOISESTRENGTH, NOISESCALE, DETAILSCALE);\n            color += terrain.color;\n            normal += terrain.normal;\n        }\n        color /= float(TEMPORALBLUR);\n        \n        // technically wrong but looks the same as Slerp\n        normal = normalize(normal / float(TEMPORALBLUR)); \n    #endif\n    \n    #ifndef SHOWGRID           \n        // Apply lighting to show the normals too\n        color = phongLighting(color, normal, vec3(0,0,1), lightDir);\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________GENERIC FUNCTIONS______________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction){\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        -direction.x, direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos, float time) {\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + time); \n    return fract( vDither / 103.0);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// makes bone colormap with polynimal 6\nvec3 bone(float t) {\n    const vec3 c0 = vec3(-0.005007,-0.003054,0.004092);\n    const vec3 c1 = vec3(1.098251,0.964561,0.971829);\n    const vec3 c2 = vec3(-2.688698,-0.537516,2.444353);\n    const vec3 c3 = vec3(12.667310,-0.657473,-8.158684);\n    const vec3 c4 = vec3(-27.183124,8.398806,10.182004);\n    const vec3 c5 = vec3(26.505377,-12.576925,-5.329155);\n    const vec3 c6 = vec3(-9.395265,5.416416,0.883918);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.25;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.5, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 0.25;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float specular = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    specular *= specularStrength;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n//_____________________________Simplex Noise______________________________\n// Copyright © 2013 Inigo Quilez\n// https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// 4 layer simplex noise range -1 to 1\nfloat simplexNoise(vec2 uv) {    \n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f;\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\n// generates 2 vector of simplex noise\nvec2 simplexNoiseVec(vec2 uv) {\n    // sample noise function\n    float noiseX = simplexNoise(uv);    \n    float noiseY = simplexNoise(uv + 691.); // with prime offset\n    \n    // make noise vector\n    return vec2(noiseX, noiseY);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVcW1.jpg", "access": "api", "license": "mit", "functions": [[3165, 3246, 3309, 3309, 3781], [3783, 3901, 3986, 3986, 4404], [4498, 4561, 4734, 5017, 9379], [9381, 9381, 9436, 9478, 11721]], "test": "untested"}
{"id": "ddGcWh", "name": "Dither Bilinear Weights", "author": "gehtsiegarnixan", "description": "A simple demo on how to use a float noise value to dither a bilinear interpolation so you can use a single sample. ", "tags": ["dither", "interpolation", "bilinear"], "likes": 4, "viewed": 190, "published": 3, "date": "1697453914", "time_retrieved": "2024-07-30T17:27:56.240638", "image_code": "// The MIT License\n// Copyright © 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis shader explains how to use a single noise value to select from 4 \nweights of bilinear interpolation. But the principle can be easily \nexpanded to any number of weights.\n\nThis is useful for dither interpolation to cut down the 4 samples of \nbilinear interpolation to a single one. It also needs only a single\nnoise value, and gives a nice even pattern. \n\nYou can enable mouse controls with a click. X controls the border and \nY the contrast.\n\nSee here how to use dithered interpolation: \nhttps://www.shadertoy.com/view/dsjBzh\n\nAnd here is an application in a terrain material:\nhttps://www.shadertoy.com/view/DsVcW1\n*/\n\n// The number of previous samples looked at to blur result, with a similar \n// effect to Temporal Anti-Aliasing (TAA) which you should use instead.\n#define TEMPORALBLUR 1\n\n// Enable debug grid where the two mappings blend with each other\n#define LINETHICKNESS 0.005\n//#define SHOWGRID\n\n// enable to show the alpha/weights otherwise shows textures\n#define SHOWALPHA\n\n// Generates a bilienar weights in a grid\nvec4 bilinearWeights(vec2 uv) {\n    // Alpha, also known as weights for bilinear interpolation\n    vec2 infUV = 1.0 - uv;\n\n    // The order here corresponds to GatherRed (which itself is arbitrary)\n    float weightA = infUV.x * uv.y;\n    float weightB = uv.x * uv.y;\n    float weightC = uv.x * infUV.y;\n    float weightD = infUV.x * infUV.y;\n\n    // Combine alpha values\n    return vec4(weightA, weightB, weightC, weightD);\n}\n\n// simple use case for bilinear interpolation\nvec3 bilinearSample(vec2 uv, float contrast) {\n     // generate weights or alpha for interpolation\n    vec4 weights = bilinearWeights(uv);\n    \n    // Increase contrast of alpha (power scale: 1. no contrast, 50 max contrast)\n    weights = smoothContrast(weights, contrast);   \n\n    #ifdef SHOWALPHA\n        // alpha as rgb which doubles up as interpolated colors\n        vec3 color = weights.xyz; \n    #else \n         // scale UV coordinates, is static for this demo\n        float scale = 2.;\n        vec2 uvA = uv * scale;\n\n        // generate 3 more set's of UVs with arbitrary rotations\n        vec2 uvB = vec2(-uvA.y, uvA.x); // rotated 90 deg\n        vec2 uvC = vec2(uvA.x, -uvA.y); // rotated 180 deg\n        vec2 uvD = vec2(uvA.y, -uvA.x); // rotated 270 deg\n        \n        // Sample texture 4 times\n        vec3 colA = texture(iChannel0, uvA).xyz;\n        vec3 colB = texture(iChannel0, uvB).xyz;\n        vec3 colC = texture(iChannel0, uvC).xyz;\n        vec3 colD = texture(iChannel0, uvD).xyz;\n\n        // interpolate the 4 samples\n        vec3 color = colA * weights.x + colB * weights.y + \n                     colC * weights.z + colD * weights.w;\n    #endif\n    \n    #ifdef SHOWGRID\n        // Overlaying the edges of the alpha mask\n        vec4 mask = step(abs(weights - 0.1), vec4(LINETHICKNESS));\n        color = max(mask.xyz, color * (1.0 - mask.w));\n    #endif    \n    return color;\n}\n\n// simple use case for dithered bilinear interpolation\nvec3 ditheredSample(vec2 uv, vec2 fragCoord, float time, float contrast) {        \n    // scale UV coordinates, is static for this demo\n    float scale = 2.;\n    vec2 uvA = uv * scale;\n    \n    // Calculate mip as the automatic ones don't work for dithering\n    vec2 duvdx = dFdx(uvA);\n    vec2 duvdy = dFdy(uvA);\n    \n    // generate weights or alpha for interpolation\n    vec4 weights = bilinearWeights(uv);\n    \n    // Increase contrast of alpha (power scale: 1. no contrast, 50 max contrast)\n    weights = smoothContrast(weights, contrast);   \n    \n    // Sample dither noise\n    float dither = ScreenSpaceDither12(fragCoord, time);\n    \n    // Smooth contrast creates artifacts in the dither. Clamping removes them\n    dither = clamp(dither, 0.01, 0.99);\n\n    // Applies float dither to weight values.\n    // The order has to be in in sync with the weights and offsets\n    // The weights are grouped cumulatively, and if the dither value is within one \n    // cumulative section for one of the weights, that weight is selected\n    vec2 uvMix;\n    vec4 weightsDither;\n    if (dither < weights.x) {\n        // Weight A\n        uvMix = uvA;\n        weightsDither = vec4(1, 0, 0, 0);\n    } else if (dither < weights.x + weights.y) {\n        // Weight B\n        // generate 3 more set's of UVs with arbitrary rotations\n        uvMix = vec2(-uvA.y, uvA.x); // rotated 90 deg\n        weightsDither = vec4(0, 1, 0, 0);\n    } else if (dither < 1. - weights.w) {\n        // Weight C\n        // because sum of all weights is 1, so 1-w = sum of xyz\n        uvMix = vec2(-uvA.x, -uvA.y); // rotated 180 deg\n        weightsDither = vec4(0, 0, 1, 0);\n    } else {\n        // Weight D\n        uvMix = vec2(uvA.y, -uvA.x); // rotated 270 deg\n        weightsDither = vec4(0, 0, 0, 1);\n    }\n\n    #ifdef SHOWALPHA\n        // alpha as rgb which doubles up as interpolated colors\n        vec3 color = weightsDither.xyz; \n    #else \n        // Sample texture 4 times\n        vec3 color = textureGrad(iChannel0, uvMix, duvdx, duvdy).xyz;        \n    #endif\n    \n    #ifdef SHOWGRID\n        // Overlaying the edges of the alpha mask\n        vec4 mask = step(abs(weights - 0.1), vec4(LINETHICKNESS));\n        color = max(mask.xyz, color * (1.0 - mask.w));\n    #endif    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    // Calculate centered UV coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + 0.5;\n        \n    // enable mouse controls when clicked, otherwise animate\n    float contrast;\n    float border;    \n    if (iMouse.x > 0.0)\t{  \n        vec2 mouse = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y + 0.5;\n        border = mouse.x;\n        contrast = mix(1., 16., pow(mouse.y,2.));\n    } else {\n        float myTime = iTime * 0.5;\n        border = sin(myTime) * 0.5 + 0.5;\n        contrast = 1.;\n    }\n    \n    // Alternate between smooth alpha and dithered alpha\n    vec3 color;\n    if (uv.x > border) {\n        // Right dithered Side\n        #if TEMPORALBLUR <= 1\n            // We just take a single sample from the ditheredSample function.\n            color += ditheredSample(uv, fragCoord, iTime, contrast);\n        #else\n            // We take multiple samples from the ditheredSample function and average them.\n            // This is normally done automatically by your TAA or motion blur\n            for(int i = 0; i < TEMPORALBLUR; i++) {\n                color += ditheredSample(uv, fragCoord, iTime - float(i), contrast);\n            }\n            color /= float(TEMPORALBLUR);\n        \n        #endif\n    } else {\n        // Left control Bilinear Side \n        color += bilinearSample(uv, contrast);\n    }\n    \n    // mask values outside of 0 to 1\n    vec2 mask = step(abs(uv*2.-1.), vec2(1.0));\n    color *= min(mask.x, mask.y);\n    \n    // Add a dividing line\n    color += step(abs(uv.x - border), 0.002);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//_____________________________Generic Functions________________________________\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n// valve edition (slightly modified to be a true 12 dither)\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// input in pixels (ie not normalized uv)\nfloat ScreenSpaceDither12(vec2 vScreenPos, float time) {\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy + time); \n    return fract( vDither / 103.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGcWh.jpg", "access": "api", "license": "mit", "functions": [[2072, 2114, 2145, 2208, 2539], [2541, 2587, 2633, 2685, 3990], [3992, 4047, 4121, 4182, 6317], [6319, 6319, 6374, 6418, 7986]], "test": "untested"}
{"id": "msdfR2", "name": "Liquid 3D", "author": "michael0884", "description": "Particle cluster grid smoothed particle hydrodynamics. Now in 3D. Compared to 2D this is muuuch trickier, the effective resolution tolerances are much higher.\nI think this is probably the highest (visual) resolution fluid sim on shadertoy so far.\n", "tags": ["particle"], "likes": 58, "viewed": 754, "published": 3, "date": "1697430588", "time_retrieved": "2024-07-30T17:27:57.406521", "image_code": "// Fork of \"PCGSPH 3D\" by michael0884. https://shadertoy.com/view/mstfzS\n// 2023-10-16 03:59:48\n\n//Particle cluster grid smoothed particle hydrodynamics. Now in 3D.\n//Compared to 2D this is muuuch trickier, the effective resolution tolerances are much higher.\n//So before noone really made a liquid in 3d that looked even remotely \"liquid\"\n//I think this is probably the highest (visual) resolution fluid sim on shadertoy so far.\n//Right now I'm just tracing the particles, but I think maybe its possible to do an isosurface render somehow?\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvoid iSphere(inout Ray ray, vec4 sphere, vec3 color)\n{\n    vec3 ro = ray.ro - sphere.xyz;\n    float b = dot(ro, ray.rd);\n    float c = dot(ro, ro) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if (h > 0.) \n    {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= 0.0 && d1 <= ray.td) {\n            ray.normal = normalize(ro + ray.rd*d1);\n            ray.color = color;\n            ray.td = d1;\n        } else if (d2 >= 0.0 && d2 <= ray.td) { \n            ray.normal = normalize(ro + ray.rd*d2); \n            ray.color = color;\n            ray.td = d2;\n        }\n    }\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n#define radius 0.75\n#define zoom 0.25\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    vec4 packed = LOAD3D(ch0, p);\n    Particle p0, p1;\n    unpackParticles(packed, p, p0, p1);\n\n    if(p0.mass > 0u) iSphere(ray, vec4(p0.pos, 1.0), vec3(0.420,0.302,0.996) * length(p0.vel));\n    if(p1.mass > 0u) iSphere(ray, vec4(p1.pos, 1.0), vec3(0.420,0.302,0.996) * length(p0.vel));\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec4 rho = LOAD3D(ch1, p);\n    if(rho.z < 1e-5) return;\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\n\nfloat Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nfloat Shadow(vec3 p)\n{\n    float optical_density = trilinear(ch2, p).x;\n    return exp(-optical_density)+0.05;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nfloat TraceDensity(vec3 ro, vec3 rd)\n{\n    const float step_size = 1.0;\n    const int step_count = 100;\n    float dens = 0.0;\n    float td = 0.0;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = ro + rd * td;\n        if(!all(lessThanEqual(p, size3d)) || !all(greaterThanEqual(p, vec3(0.0))))\n        {\n            break;\n        }\n        float d = Density(p);\n        dens += d * step_size;\n        td += step_size;\n    }\n    return dens;\n}\n\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{    \n    InitGrid(iResolution.xy);\n    \n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.2*iTime, -0.3);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.5;\n    vec3 ro = vec3(size3d)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n    \n    \n\n    vec2 tdBox = iBox(ro - vec3(size3d)*0.5, rd, 0.5*vec3(size3d));\n    col = texture(iChannel3,  rd.yzx);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x, 0.0);\n        float step_size = 2.5;\n        const int step_count = 100;\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n\n        for(int i = 0; i < step_count; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n\n            td += step_size;\n            if(td > tdBox.y || ray.td < tdBox.y)\n            {\n                break;\n            }\n        }\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal = normalize(calcNormal(p0, 0.5).xyz);\n            normal = -normalize(mix(normal, ray.normal, 0.0));\n            vec3 albedo = vec3(0.220,0.349,1.000);\n            float LdotN = dot(normal, light_dir);\n            float shadow = Shadow(p0);\n            vec3 refl_d = reflect(ray.rd, normal);\n            vec3 refr_d = refract(ray.rd, normal, 1.0/1.33);\n            float liquid_density = TraceDensity(p0, refr_d);\n            vec3 liquid_color = exp(-0.1*liquid_density*vec3(0.953,0.353,0.247));\n            vec3 refr_color = texture(iChannel3,  refr_d.yzx).xyz * liquid_color;\n            vec3 refl = texture(iChannel3,  refl_d.yzx).xyz;\n            float K = 1. - pow(max(dot(normal,refl_d),0.), 2.);\n            K = mix(0.0, K, 0.5);\n            col.xyz = (0.25*shadow + 1.5)*refr_color*(1.0 - K) + 0.*ray.color + 0.75*shadow*refl*K;\n        }\n    }\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.820,1.000,0.702))\n\n#define surface_tension 0.5\n#define surface_tension_rad 2.0\n#define initial_particle_density 2u\n#define dt 0.7\n#define rest_density 1.0\n#define gravity 0.01\n#define force_k 0.15\n#define force_coef_a -4.0\n#define force_coef_b 0.0\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 2.0\n#define cooling 0.0\n\n#define R iResolution.xy\n\n#define GD(x, R) exp(-dot(x/R,x/R))/(R*R)\n#define GS(x) exp(-dot(x,x))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//3d slice aspect ratio \n#define ar vec2(1.0,0.5)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    p3d = clamp(p3d, vec3(0.0), size3d);\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\n\n#define pixel(a, p, s) texture(a, p/vec2(s))\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 udir(vec2 rng)\n{\n    float phi = 2.*PI*rng.x;\n    float ctheta = 2.*rng.y-1.;\n    float stheta = sqrt(1.0-ctheta*ctheta);\n    return vec3(cos(phi)*stheta, sin(phi)*stheta, ctheta);\n}\n\nstruct Particle \n{\n    uint mass;\n    vec3 pos;\n    vec3 vel;\n    vec3 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    uvec3 sv = uvec3(round(clamp(v*scale, -1.0, 1.0) * 255.0) + 255.0);\n    uint packed = uint(exp + 15) | (sv.x << 5) | (sv.y << 14) | (sv.z << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec3 pos)\n{\n    p0.pos -= pos;\n    p1.pos -= pos;\n\n    uvec3 pos0 = uvec3(clamp(p0.pos, 0.0, 1.0) * 255.0); // Assuming pos range [0, 1] in a cell\n    uvec3 pos1 = uvec3(clamp(p1.pos, 0.0, 1.0) * 255.0);\n\n    uint data1 = p0.mass | (p1.mass << 8) | (pos0.x << 16) | (pos0.y << 24);\n    float f1 = uintBitsToFloat(data1);\n    uint data2 = pos0.z | (pos1.x << 8) | (pos1.y << 16) | (pos1.z << 24);\n    float f2 = uintBitsToFloat(data2);\n    uint data3 = packvec3(p0.vel);\n    float f3 = uintBitsToFloat(data3);\n    uint data4 = packvec3(p1.vel);\n    float f4 = uintBitsToFloat(data4);\n    return vec4(f1,f2,f3,f4);\n}\n\nvoid unpackParticles(vec4 packed, vec3 pos, out Particle p0, out Particle p1)\n{\n    uint data1 = floatBitsToUint(packed.x);\n    uint data2 = floatBitsToUint(packed.y);\n    uint data3 = floatBitsToUint(packed.z);\n    uint data4 = floatBitsToUint(packed.w);\n\n    p0.mass = data1 & 0xFFu;\n    p1.mass = (data1 >> 8) & 0xFFu;\n\n    uvec3 pos0 = uvec3((data1 >> 16) & 0xFFu, (data1 >> 24) & 0xFFu, data2 & 0xFFu);\n    uvec3 pos1 = uvec3((data2 >> 8) & 0xFFu, (data2 >> 16) & 0xFFu, (data2 >> 24) & 0xFFu);\n\n    p0.pos = vec3(pos0) / 255.0 + pos;\n    p1.pos = vec3(pos1) / 255.0 + pos;\n\n    p0.vel = unpackvec3(data3);\n    p1.vel = unpackvec3(data4);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec3 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    vec3 pos = p1.pos;\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec3 dir = udir(hash23(pos));\n    p1.pos = pos - dir*5e-3;\n    p2.pos = pos + dir*5e-3;\n    p2.vel = p1.vel;\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec3 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    vec3 dvel = incoming.vel - p.vel;\n    float f = force_coef_a*GD(d, 1.5);\n    float irho = float(incoming.mass);\n    float rho = 0.5*(p.density + incoming.density);\n    float pressure = max(rho / rest_density - 1.0,-0.0);\n    float SPH_F = f *  pressure;\n    float F = surface_tension*GD(d, surface_tension_rad);\n    float Friction = 0.45* dot(dir, dvel) * GD(d, 1.5);\n    p.force += force_k * dir * (F + SPH_F + Friction) * irho / rest_density;\n    \n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid IntegrateParticle(inout Particle p, vec3 pos, vec2 iR, vec4 iM, float time)\n{\n    p.force = p.force;/// max(0.0001, float(p.mass));\n    p.force += gravity*vec3(0.4*sin(0.7*time), 0.2*cos(0.5*time), -1.0); //gravity\n    \n\n    vec4 border = border_grad(p.pos);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    p.force += force_boundary*bound*dt;\n    //p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    //if(iM.z > 0.)\n    //{\n    //    vec3 dx = pos - vec3(iM.xy, 0.0);\n    //    p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    //}\n        \n    p.vel += p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}\n\nvoid InitGrid(vec2 iR)\n{\n    SCALE = floor(ar*pow(iR.x*iR.y,0.1666666));\n    size3d = vec3(floor(iR.xy/SCALE), SCALE.x*SCALE.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1;\n    p0.mass = 0u;\n    p0.pos = vec3(0);\n    p0.vel = vec3(0);\n\n    p1.mass = 0u;\n    p1.pos = vec3(0);\n    p1.vel = vec3(0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        //load the particles \n        vec3 pos1 = pos + vec3(i, j, k);\n        if(!all(lessThanEqual(pos1, size3d)) || !all(greaterThanEqual(pos1, vec3(0.0))))\n        {\n            continue;\n        }\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming, float rad)\n{\n    if(incoming.mass == 0u) return;\n    float d = distance(p.pos, incoming.pos);\n    float irho = float(incoming.mass);\n    float rho = 0.25*irho*GD(d,rad);\n    p.density += rho;\n}\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        if(i == 0 && j == 0 && k == 0) continue;\n        vec3 pos1 = pos + vec3(i, j, k);\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n        if(p0.mass > 0u)\n        {\n            AddDensity(p0, p0_, 1.5);\n            AddDensity(p0, p1_, 1.5);\n        }\n        if(p1.mass > 0u)\n        {\n            AddDensity(p1, p0_, 1.5);\n            AddDensity(p1, p1_, 1.5);\n        }\n        \n        AddDensity(pV, p0_, 1.6);\n        AddDensity(pV, p1_, 1.6);\n    }\n\n    if(p0.mass > 0u)\n    {\n        AddDensity(p0, p0, 1.5);\n        AddDensity(p0, p1, 1.5);\n    }\n    if(p1.mass > 0u)\n    {\n        AddDensity(p1, p0, 1.5);\n        AddDensity(p1, p1, 1.5);\n    }\n    AddDensity(pV, p0, 1.6);\n    AddDensity(pV, p1, 1.6);\n\n    fragColor = vec4(p0.density, p1.density, pV.density, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = LOAD3D(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = LOAD3D(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse, iTime);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse, iTime);\n    }\n    \n        \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.4*size3d.x && pos.x > 0.0*size3d.x && \n           pos.y < 0.85*size3d.y && pos.y > 0.15*size3d.y &&\n           pos.z < 0.85*size3d.z && pos.z > 0.15*size3d.z)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos;\n        p0.vel = vec3(0.0);\n        p1.pos = pos;\n        p1.vel = vec3(0.0);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//compute shadows\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    //ray march in the -light_dir direction\n    const float step_size = 1.0;\n    const int step_count = 100;\n    float td = 0.0;\n    vec3 rd = light_dir;\n    float optical_density = 0.0;\n    vec3 normal = normalize(calcNormal(pos, 0.5).xyz);\n    pos += -normal*0.5;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = pos + rd * td;\n        if(!all(lessThanEqual(p, size3d)) || !all(greaterThanEqual(p, vec3(0.0))))\n        {\n            break;\n        }\n        float d = Density(p);\n        optical_density += d * step_size;\n        td += step_size;\n    }\n\n    fragColor = vec4(0.2*optical_density);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 587, 587, 979], [981, 981, 1017, 1017, 1128], [1245, 1245, 1299, 1299, 1851], [1853, 1853, 1908, 1908, 2247], [2288, 2288, 2327, 2353, 2643], [2934, 2934, 2957, 2957, 2991], [2993, 2993, 3015, 3015, 3105], [3107, 3107, 3142, 3142, 3348], [3350, 3350, 3388, 3388, 3805], [3808, 3808, 3859, 3859, 5868]], "test": "untested"}
{"id": "dstfR2", "name": "Solid and Liquid", "author": "wyatt", "description": " ", "tags": ["mpm"], "likes": 35, "viewed": 531, "published": 3, "date": "1697426754", "time_retrieved": "2024-07-30T17:27:58.317087", "image_code": "// Fork of \"Fluid Mimicry\" by wyatt. https://shadertoy.com/view/dd3fR2\n// 2023-10-16 02:52:23\n\nMain\n    vec4 c = C(U);\n    \n    Q = .4+.6*sin(2.-1.8*c.z/max(c.w,2.)+vec4(1,2,3,4));\n    Q *= 1.3*c.w;\n    Q = 1.-Q;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\nfloat erf(in float x) {\n    //x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\nfloat G (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat building(vec2 U) {\n    if (U.x < 5.||U.y<5.||R.x-U.x<5.||R.y-U.y<5.) return 0.;\n    vec2 u = mod(U*(.1+2.*U*U/R.x/R.x),80.);\n        \n    u = abs(u-40.)-20.;\n\n    if(max(u.x,u.y)<0. && U.y > .5*R.y) return 2.;\n    if (U.y < .3*R.y) return .51+.49*sin(U.x/R.x*3.);\n    return 0.;\n}\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\nfloat _12(vec2 U) {\n    U = floor(U);\n    return U.x+U.y*R.x;\n}\nvec2 _21(float i) {\n    return .5+vec2(mod(i,R.x),floor(i/R.x));\n}", "buffer_a_code": "Main\n    float bu = building(U);\n    if (bu==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-.4/R.y);\n    \n    for (float x = -2.; x <= 2.; x ++) \n    for (float y = -2.; y <= 2.; y ++)\n    if (x!=0.||y!=0.) {\n        vec2 u = vec2(x,y);\n        vec4 cc = C(Q.xy+u);\n        vec4 aa = A(U+u);\n        float b = building(U+u);\n        if (b>1.&&bu>1.) {\n            vec2 r = aa.xy-Q.xy;\n            float l = length(r);\n            float L = length(u);\n            if (l>0.&&abs(L-l)<2.)\n            f -= .04*r/l*(L-l);\n        } \n         f -= .04*cc.w*(cc.w+(cc.z<2.?-.8:0.))*u/dot(u,u)/length(u);\n    }\n    Q.zw = mix(Q.zw,c.xy,.5);\n    Q.zw += f;\n    Q.xy += 2.*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<5.) Q.w += .1;\n    if (Q.x<5.) Q.z += .1;\n    if (R.y-Q.y<5.) Q.w -= .1;\n    if (R.x-Q.x<5.) Q.z -= .1;\n\n    if (M.z>0.) Q.zw -= 1e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    vec4 d = D(U);\n    vec4 a = A(_21(d.x));\n    if (cell(a.xy-U)&&i<4\n        &&d.x!=Q.x&&d.x!=Q.y&&d.x!=Q.z&&d.x!=Q.w\n    ) Q[i]= d.x;\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    float w = 0.;\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        float s = 1.2;\n        float n = dot(vec4(b.x>0.,b.y>0.,b.z>0.,b.w>0.),vec4(1));\n        for (int k = 0; k < 4; k++) {\n            if (b[k]>0.) {\n                vec2 u = _21(b[k]);\n                vec4 a = A(u);\n                vec2 v = a.xy-U;\n                float e = G(length(v),s);\n                w += e;\n                Q.xyz += vec3(a.zw,building(u))*e;\n                Q.w += e;\n            } else break;\n        }\n    }\n    if (w>0.) Q.xy /= w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int y=-3;y<=3;y++) {\n        XY(U,Q,B(U+vec2(0,y)));\n        XY(U,Q,B(U+vec2(y,0)));\n    }\n    \n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    \n    if (I<1) Q = vec4(_12(U));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstfR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mstfzS", "name": "PCGSPH 3D", "author": "michael0884", "description": "Particle cluster grid smoothed particle hydrodynamics. Now in 3D. Compared to 2D this is muuuch trickier, the effective resolution tolerances are much higher.\nI think this is probably the highest (visual) resolution fluid sim on shadertoy so far.\n", "tags": ["particle", "sph"], "likes": 96, "viewed": 2673, "published": 3, "date": "1697422045", "time_retrieved": "2024-07-30T17:28:04.097631", "image_code": "//Particle cluster grid smoothed particle hydrodynamics. Now in 3D.\n//Compared to 2D this is muuuch trickier, the effective resolution tolerances are much higher.\n//So before noone really made a liquid in 3d that looked even remotely \"liquid\"\n//I think this is probably the highest (visual) resolution fluid sim on shadertoy so far.\n//Right now I'm just tracing the particles, but I think maybe its possible to do an isosurface render somehow?\n\n#define FOV 2.5\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,  cos(angles.y),  -sin(angles.y),\n                          0,  sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\n\n#define MAX_DIST 1e10\n\nstruct Ray \n{\n    vec3 ro;\n    vec3 rd;\n    float td;\n    vec3 normal;\n    vec3 color;\n};\n\nvoid iSphere(inout Ray ray, vec4 sphere, vec3 color)\n{\n    vec3 ro = ray.ro - sphere.xyz;\n    float b = dot(ro, ray.rd);\n    float c = dot(ro, ro) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if (h > 0.) \n    {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= 0.0 && d1 <= ray.td) {\n            ray.normal = normalize(ro + ray.rd*d1);\n            ray.color = color;\n            ray.td = d1;\n        } else if (d2 >= 0.0 && d2 <= ray.td) { \n            ray.normal = normalize(ro + ray.rd*d2); \n            ray.color = color;\n            ray.td = d2;\n        }\n    }\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return vec2(MAX_DIST);\n    } else {\n        return vec2(tN, tF);\n    }\n}\n\n#define radius 0.75\n#define zoom 0.25\n\nvoid TraceCell(inout Ray ray, vec3 p)\n{\n    //load the particles \n    vec4 packed = LOAD3D(ch0, p);\n    Particle p0, p1;\n    unpackParticles(packed, p, p0, p1);\n\n    if(p0.mass > 0u) iSphere(ray, vec4(p0.pos, 0.85), vec3(0.420,0.302,0.996) * length(p0.vel));\n    if(p1.mass > 0u) iSphere(ray, vec4(p1.pos, 0.85), vec3(0.420,0.302,0.996) * length(p0.vel));\n}\n\nvoid TraceCells(inout Ray ray, vec3 p)\n{\n    vec3 p0 = floor(p);\n    vec4 rho = LOAD3D(ch1, p);\n    if(rho.z < 1e-5) return;\n    range(i, -1, 1) range(j, -1, 1) range(k, -1, 1)\n    {\n        //load the particles \n        vec3 p1 = p0 + vec3(i, j, k);\n        TraceCell(ray, p1);\n    }\n}\n\n\nfloat Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nfloat Shadow(vec3 p)\n{\n    float optical_density = trilinear(ch2, p).x;\n    return exp(-optical_density)+0.05;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n\n\nvoid mainImage( out vec4 col, in vec2 fragCoord )\n{    \n    InitGrid(iResolution.xy);\n    \n    vec2 uv = (fragCoord - 0.5*R)/max(R.x, R.y);\n\n    vec2 angles = vec2(2.*PI, PI)*(iMouse.xy/iResolution.xy - 0.5);\n\n    if(iMouse.z <= 0.)\n    {\n        angles = vec2(0.2*iTime, -0.5);\n    }\n    vec3 rd = getRay(angles, uv);\n    vec3 center_rd = getRay(angles, vec2(0.));\n \n    float d = sqrt(dot(vec3(size3d), vec3(size3d)))*0.5;\n    vec3 ro = vec3(size3d)*vec3(0.5, 0.5, 0.5) - center_rd*d;\n    \n    \n\n    vec2 tdBox = iBox(ro - vec3(size3d)*0.5, rd, 0.5*vec3(size3d));\n    col = texture(iChannel3,  rd.yzx);\n    if(tdBox.x < MAX_DIST)\n    {\n        float td = max(tdBox.x, 0.0);\n        float step_size = 2.0;\n        const int step_count = 100;\n        Ray ray;\n        ray.ro = ro;\n        ray.rd = rd;\n        ray.td = tdBox.y;\n\n        for(int i = 0; i < step_count; i++)\n        {\n            vec3 p = ro + rd*td;\n            TraceCells(ray, p);\n\n            td += step_size;\n            if(td > tdBox.y || ray.td < tdBox.y)\n            {\n                break;\n            }\n        }\n        \n        if(ray.td < tdBox.y)\n        {\n            vec3 p0 = ray.ro + ray.rd*ray.td;\n            vec3 normal = normalize(calcNormal(p0, 0.5).xyz);\n            normal = -normalize(mix(normal, ray.normal, 0.25));\n            vec3 albedo = vec3(0.220,0.349,1.000);\n            float LdotN = dot(normal, light_dir);\n            float shadow = Shadow(p0);\n            vec3 refl_d = reflect(ray.rd, normal);\n            vec3 refl = texture(iChannel3,  refl_d.yzx).xyz;\n            float K = 1. - pow(max(dot(normal,refl_d),0.), 3.);\n            K = mix(0.0, K, 0.75);\n            col.xyz = 2.5*shadow*albedo*LdotN*(1.0 - K) + 0.1*ray.color + shadow*refl*K;\n        }\n    }\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n#define LOAD3D(ch, pos) texelFetch(ch, ivec2(dim2from3(pos)), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define light_dir normalize(vec3(0.820,1.000,0.702))\n\n#define surface_tension 0.5\n#define surface_tension_rad 2.0\n#define initial_particle_density 1u\n#define dt 0.7\n#define rest_density 1.0\n#define gravity 0.01\n#define force_k 0.15\n#define force_coef_a -4.0\n#define force_coef_b 0.0\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 2.0\n#define cooling 0.0\n\n#define R iResolution.xy\n\n#define GD(x, R) exp(-dot(x/R,x/R))/(R*R)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//3d slice aspect ratio \n#define ar vec2(1.0,0.7)\nvec2 SCALE;\nvec3 size3d;\n\nvec2 dim2from3(vec3 p3d)\n{\n    p3d = clamp(p3d, vec3(0.0), size3d);\n    float ny = floor(p3d.z/SCALE.x);\n    float nx = floor(p3d.z) - ny*SCALE.x;\n    return vec2(nx, ny)*vec2(size3d.xy) + p3d.xy;\n}\n\nvec3 dim3from2(vec2 p2d)\n{\n    return vec3(p2d - size3d.xy*floor(p2d/size3d.xy),(floor(p2d.x/size3d.x) + SCALE.x*floor(p2d.y/size3d.y)));\n}\n\n\n#define pixel(a, p, s) texture(a, p/vec2(s))\nvec4 voxel(sampler2D ch, vec3 p3d)\n{\n    return pixel(ch, dim2from3(p3d), textureSize(ch, 0));\n}\n\n//trilinear interpolation = linear interp between layers\nvec4 trilinear(sampler2D ch, vec3 p3d)\n{\n    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 udir(vec2 rng)\n{\n    float phi = 2.*PI*rng.x;\n    float ctheta = 2.*rng.y-1.;\n    float stheta = sqrt(1.0-ctheta*ctheta);\n    return vec3(cos(phi)*stheta, sin(phi)*stheta, ctheta);\n}\n\nstruct Particle \n{\n    uint mass;\n    vec3 pos;\n    vec3 vel;\n    vec3 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    uvec3 sv = uvec3(round(clamp(v*scale, -1.0, 1.0) * 255.0) + 255.0);\n    uint packed = uint(exp + 15) | (sv.x << 5) | (sv.y << 14) | (sv.z << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec3 pos)\n{\n    p0.pos -= pos;\n    p1.pos -= pos;\n\n    uvec3 pos0 = uvec3(clamp(p0.pos, 0.0, 1.0) * 255.0); // Assuming pos range [0, 1] in a cell\n    uvec3 pos1 = uvec3(clamp(p1.pos, 0.0, 1.0) * 255.0);\n\n    uint data1 = p0.mass | (p1.mass << 8) | (pos0.x << 16) | (pos0.y << 24);\n    float f1 = uintBitsToFloat(data1);\n    uint data2 = pos0.z | (pos1.x << 8) | (pos1.y << 16) | (pos1.z << 24);\n    float f2 = uintBitsToFloat(data2);\n    uint data3 = packvec3(p0.vel);\n    float f3 = uintBitsToFloat(data3);\n    uint data4 = packvec3(p1.vel);\n    float f4 = uintBitsToFloat(data4);\n    return vec4(f1,f2,f3,f4);\n}\n\nvoid unpackParticles(vec4 packed, vec3 pos, out Particle p0, out Particle p1)\n{\n    uint data1 = floatBitsToUint(packed.x);\n    uint data2 = floatBitsToUint(packed.y);\n    uint data3 = floatBitsToUint(packed.z);\n    uint data4 = floatBitsToUint(packed.w);\n\n    p0.mass = data1 & 0xFFu;\n    p1.mass = (data1 >> 8) & 0xFFu;\n\n    uvec3 pos0 = uvec3((data1 >> 16) & 0xFFu, (data1 >> 24) & 0xFFu, data2 & 0xFFu);\n    uvec3 pos1 = uvec3((data2 >> 8) & 0xFFu, (data2 >> 16) & 0xFFu, (data2 >> 24) & 0xFFu);\n\n    p0.pos = vec3(pos0) / 255.0 + pos;\n    p1.pos = vec3(pos1) / 255.0 + pos;\n\n    p0.vel = unpackvec3(data3);\n    p1.vel = unpackvec3(data4);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec3 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    vec3 pos = p1.pos;\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec3 dir = udir(hash23(pos));\n    p1.pos = pos - dir*5e-3;\n    p2.pos = pos + dir*5e-3;\n    p2.vel = p1.vel;\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec3 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    vec3 dvel = incoming.vel - p.vel;\n    float f = force_coef_a*GD(d, 1.5);\n    float irho = float(incoming.mass);\n    float rho = 0.5*(p.density + incoming.density);\n    float pressure = max(rho / rest_density - 1.0,-0.0);\n    float SPH_F = f *  pressure;\n    float F = surface_tension*GD(d, surface_tension_rad);\n    float Friction = 0.45* dot(dir, dvel) * GD(d, 1.5);\n    p.force += force_k * dir * (F + SPH_F + Friction) * irho / rest_density;\n    \n}\n\nfloat minv(vec3 a)\n{\n    return min(min(a.x, a.y),a.z);\n}\n\nfloat maxv(vec3 a)\n{\n    return max(max(a.x, a.y),a.z);\n}\n\nfloat distance2border(vec3 p)\n{\n    vec3 a = vec3(size3d - 1.) - p;\n    return min(minv(p),minv(a)) + 1.;\n}\n\nvec4 border_grad(vec3 p)\n{\n    const float dx = 0.001;\n    const vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*distance2border(p + k.xyy*dx) +\n\t\t\t k.yyxx*distance2border(p + k.yyx*dx) +\n\t\t\t k.yxyx*distance2border(p + k.yxy*dx) +\n\t\t\t k.xxxx*distance2border(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\nvoid IntegrateParticle(inout Particle p, vec3 pos, vec2 iR, vec4 iM, float time)\n{\n    p.force = p.force;/// max(0.0001, float(p.mass));\n    p.force += gravity*vec3(0.4*sin(0.7*time), 0.2*cos(0.5*time), -1.0); //gravity\n    \n\n    vec4 border = border_grad(p.pos);\n    vec3 bound =1.*normalize(border.xyz)*exp(-0.4*border.w*border.w);\n    p.force += force_boundary*bound*dt;\n    //p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    //if(iM.z > 0.)\n    //{\n    //    vec3 dx = pos - vec3(iM.xy, 0.0);\n    //    p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    //}\n        \n    p.vel += p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}\n\nvoid InitGrid(vec2 iR)\n{\n    SCALE = floor(ar*pow(iR.x*iR.y,0.1666666));\n    size3d = vec3(floor(iR.xy/SCALE), SCALE.x*SCALE.y);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1;\n    p0.mass = 0u;\n    p0.pos = vec3(0);\n    p0.vel = vec3(0);\n\n    p1.mass = 0u;\n    p1.pos = vec3(0);\n    p1.vel = vec3(0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        //load the particles \n        vec3 pos1 = pos + vec3(i, j, k);\n        if(!all(lessThanEqual(pos1, size3d)) || !all(greaterThanEqual(pos1, vec3(0.0))))\n        {\n            continue;\n        }\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming, float rad)\n{\n    if(incoming.mass == 0u) return;\n    float d = distance(p.pos, incoming.pos);\n    float irho = float(incoming.mass);\n    float rho = 0.25*irho*GD(d,rad);\n    p.density += rho;\n}\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    Particle p0, p1, pV;\n    pV.pos = pos + 0.5;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n    {\n        if(i == 0 && j == 0 && k == 0) continue;\n        vec3 pos1 = pos + vec3(i, j, k);\n        Particle p0_, p1_;\n        unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n\n        if(p0.mass > 0u)\n        {\n            AddDensity(p0, p0_, 1.5);\n            AddDensity(p0, p1_, 1.5);\n        }\n        if(p1.mass > 0u)\n        {\n            AddDensity(p1, p0_, 1.5);\n            AddDensity(p1, p1_, 1.5);\n        }\n        \n        AddDensity(pV, p0_, 1.2);\n        AddDensity(pV, p1_, 1.2);\n    }\n\n    if(p0.mass > 0u)\n    {\n        AddDensity(p0, p0, 1.5);\n        AddDensity(p0, p1, 1.5);\n    }\n    if(p1.mass > 0u)\n    {\n        AddDensity(p1, p0, 1.5);\n        AddDensity(p1, p1, 1.5);\n    }\n    AddDensity(pV, p0, 1.2);\n    AddDensity(pV, p1, 1.2);\n\n    fragColor = vec4(p0.density, p1.density, pV.density, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD3D(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = LOAD3D(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2) range(k, -2, 2)\n        {\n            if(i == 0 && j == 0 && k == 0) continue;\n            vec3 pos1 = pos + vec3(i, j, k);\n            Particle p0_, p1_;\n            unpackParticles(LOAD3D(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = LOAD3D(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse, iTime);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse, iTime);\n    }\n    \n        \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.5*size3d.x && pos.x > 0.0*size3d.x && \n           pos.y < 0.85*size3d.y && pos.y > 0.15*size3d.y &&\n           pos.z < 0.85*size3d.z && pos.z > 0.15*size3d.z)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos;\n        p0.vel = vec3(0.0);\n        p1.pos = pos;\n        p1.vel = vec3(0.0);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "float Density(vec3 p)\n{\n    return trilinear(ch1, p).z;\n}\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn   (k.xyyx*Density(p + k.xyy*dx) +\n\t\t\t k.yyxx*Density(p + k.yyx*dx) +\n\t\t\t k.yxyx*Density(p + k.yxy*dx) +\n\t\t\t k.xxxx*Density(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n//compute shadows\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitGrid(iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec3 pos = dim3from2(fragCoord);\n    \n    //ray march in the -light_dir direction\n    const float step_size = 1.0;\n    const int step_count = 100;\n    float td = 0.0;\n    vec3 rd = light_dir;\n    float optical_density = 0.0;\n    vec3 normal = normalize(calcNormal(pos, 0.5).xyz);\n    pos += -normal*0.5;\n    for(int i = 0; i < step_count; i++)\n    {\n        vec3 p = pos + rd * td;\n        if(!all(lessThanEqual(p, size3d)) || !all(greaterThanEqual(p, vec3(0.0))))\n        {\n            break;\n        }\n        float d = Density(p);\n        optical_density += d * step_size;\n        td += step_size;\n    }\n\n    fragColor = vec4(0.2*optical_density);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[461, 461, 490, 490, 882], [884, 884, 920, 920, 1031], [1148, 1148, 1202, 1202, 1754], [1756, 1756, 1811, 1811, 2150], [2191, 2191, 2230, 2256, 2548], [2839, 2839, 2862, 2862, 2896], [2898, 2898, 2920, 2920, 3010], [3012, 3012, 3047, 3047, 3253], [3257, 3257, 3308, 3308, 5022]], "test": "untested"}
{"id": "dstBzj", "name": "Simple Gradient Background", "author": "alphardex", "description": "A simple gradient background.", "tags": ["gradient"], "likes": 1, "viewed": 1042, "published": 3, "date": "1697419810", "time_retrieved": "2024-07-30T17:28:05.277476", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    // vec3 col1=vec3(1.,0.,0.);\n    // vec3 col2=vec3(0.,1.,0.);\n    // vec3 col3=vec3(0.,0.,1.);\n    vec3 col1=vec3(0.,.110,.329);\n    vec3 col2=vec3(.008,.247,.631);\n    vec3 col3=vec3(.149,.659,1.);\n    vec3 col=vec3(0.);\n    float stop1=.2;\n    float stop2=.6;\n    float y=1.-uv.y;\n    float mask1=1.-smoothstep(0.,stop1,y);\n    float mask2=smoothstep(0.,stop1,y)*(1.-smoothstep(stop1,stop2,y));\n    float mask3=smoothstep(stop1,stop2,y);\n    col+=col1*mask1;\n    col+=col2*mask2;\n    col+=col3*mask3;\n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 628]], "test": "untested"}
{"id": "cs3BRj", "name": "Mandelbrot Color Golf 1̶3̶0̶ 123", "author": "domrally", "description": "Inspired by: https://www.shadertoy.com/view/slyGz1\nMinimizing the code to render a mandelbrot with color and scale.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["mandelbrot", "short", "golf"], "likes": 5, "viewed": 188, "published": 3, "date": "1697414751", "time_retrieved": "2024-07-30T17:28:06.372548", "image_code": "/*\n123 characters: SnoopethDuckDuck\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    o.xyz = iResolution;\n    \n    mat2 z;\n    \n    for (i += i - o.xy; o.z++ < 21.;)\n        z = z * z + 2. * mat2(i, -i.y, i) / o.x;\n        \n    o = vec4(z);\n}\n\n\n/*\n130 characters: domrally\n*\nvoid mainImage(out vec4 o, vec2 i) {\n    o.xyz = iResolution;\n    i = 4. * i - 2. * o.xy;\n    mat2 z, c = mat2(i, -i.y, i) / o.x;\n    \n    for (; o.z++ < 21.;)\n        z = z * z + c;\n        \n    o = vec4(z);\n}\n*/\n\n\n/*\nREFERENCES\n\nmatrices\n\nakohdr 2021\nhttps://www.shadertoy.com/view/7tVGzh\n\ngolf\n\nhosted by incription (91 chars!)\nhttps://www.shadertoy.com/view/slyGz1\n\nhosted by FabriceNeyret2\nhttps://www.shadertoy.com/view/4sK3Dz\n\nhosted by isaacchurchill\nhttps://www.shadertoy.com/view/tt2cz1\n*/\n\n\n/*\nFURTHER READING\n\nhttps://en.wikipedia.org/wiki/Code_golf\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cs3BRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 75, 75, 237]], "test": "untested"}
{"id": "dstfRj", "name": "test-shader-1", "author": "deinondaemon", "description": "fractal tutorial", "tags": ["fractal"], "likes": 1, "viewed": 129, "published": 3, "date": "1697412630", "time_retrieved": "2024-07-30T17:28:07.299072", "image_code": "vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // sample shader gradient\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    for (float i = 0.0; i < 3.0; i++) {\n    \n        uv = fract(uv * 1.75) -.5;\n\n        float d = length(uv) * exp(-length(uv0));\n        vec3 col = palette(\n            length(uv0) + i *.4 + iTime*.5, \n            vec3(.5, .5, .5), \n            vec3(.5, .5, .5), \n            vec3(1.0, 1.0, .5), \n            vec3(.8, .6, .5)\n        );\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n        d = pow(.01/d, 1.4);\n\n        finalColor += col * d;\n\n  \n   }  \n   \n   fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 95], [97, 97, 154, 423, 1056]], "test": "untested"}
{"id": "csdfz2", "name": "Random function generator", "author": "jarble", "description": "This shader graphs a randomly generated function of a single variable.", "tags": ["random", "function", "generator"], "likes": 4, "viewed": 183, "published": 3, "date": "1697407784", "time_retrieved": "2024-07-30T17:28:08.448997", "image_code": "//from David Hoskins' \"Hash without sine\"\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//get the output of a random function with a random arity\nfloat func1(float seed, float param1, inout float arity){\n    //the function is determined by a random seed\n    \n    int func_id = int(hash11(seed*2.)*8.);\n    if(func_id == 0) return sin(param1);\n    else if(func_id == 1){ return cos(param1); arity = 1.;}\n    else if(func_id == 2){ return param1*param1; arity = 1.;}\n    else if(func_id == 3){ return param1+(hash11((seed+1.)*5.-10.)); arity = 2.;}\n    else if(func_id == 4){ return abs(param1); arity = 1.;}\n    else if(func_id == 5){ return log(param1); arity = 1.;}\n    else if(func_id == 6){ return log(param1); arity = 1.;}\n    else if(func_id == 7){ return param1*(hash11((seed+1.)*5.-10.)); arity = 2.;}\n    //else if(func_id == 8){ return pow(param1,(hash11((seed+1.)*5.-10.))); arity = 2.;}\n    else return param1;\n}\n\nfloat random_function_generator(float param1,float seed){\n    \n    float arity = 1.,\n    h1 = hash11(seed),\n    f1 = func1((seed+h1)*2.,param1,arity);\n    while(h1 > 0.25){\n        seed += arity;\n        h1 = hash11(seed);\n        f1 = func1((seed+h1)*2.,f1,arity);\n    }\n    return f1;\n}\n\n// ##### Y-Function Graph #####\n// Made by Zi7ar21 on February 12th, 2021\n// Last Updated: February 12th, 2021 at 13:30 Mountain Time\n\n// If you found this anywhere except Shadertoy, the original and possibly a newer version can be found at:\n// https://www.shadertoy.com/view/wl3fRf\n\n/*All of the other shaders that are supposed to plot functions (that I have used at least)\nseem to have variations in line thickness due to the fact that they simply take a function's\ndifference from the screen's y coordinate and draw it if it is a certain distance from the\ny coordinate at that point, however this shader solves that problem by drawing an aliased line\nwith uniform-ish thickness and then superampling it.*/\n\n// Super-Sample Levels\n#define samples 4\n\n// Y-Scale\n#define yscale 2.5\n\n// X-Scale\n#define xscale 4.0/iResolution.x\n\n// Pi (used for the example function)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// Example Function: y = (sin(x*pi*2.0+t)+cos(x*pi))/2.0\nfloat function(float x){\n    return random_function_generator(x,floor(iTime*4.));\n}\n\n// Plot\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Initialize the Color\n    vec3 color  = vec3(0.0);\n    // Initialize the Coordinates\n    vec2 coord = fragCoord;\n    // The Super-Sampling Loop\n    for(int y = -samples; y < samples; y++){for(int x = -samples; x < samples; x++){\n    // Set the Super-Sampled Coordinate\n    coord = (fragCoord+(vec2(x, y)/float(samples)));\n    // Find The Points for a Smooth yet Aliased Line\n    bool pointa =     round(function((coord.x-1.0)*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointb =     round(function((coord.x    )*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    bool pointc =     round(function((coord.x    )*xscale)*iResolution.y) >= yscale*(coord.y-0.5*iResolution.y);\n    bool pointd =     round(function((coord.x-1.0)*xscale)*iResolution.y) <= yscale*(coord.y-0.5*iResolution.y);\n    // Some Points take less than 2x to move up a pixel so we sample a point where the line is at every point\n    bool pointe = abs(round(function( coord.x*xscale)*iResolution.y)-yscale*(coord.y-0.5*iResolution.y)) <= 1.0;\n    // Check if the pixel is part of the line\n    if((pointa && pointb) || (pointc && pointd) || pointe){\n        color += vec3(1.0);\n    }\n    }}\n    // Output the Super-Sampled Line\n    fragColor = vec4(color/float(samples*samples*4), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csdfz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 42, 65, 65, 150], [152, 210, 267, 317, 987], [989, 989, 1046, 1046, 1277], [2230, 2287, 2311, 2311, 2370], [2372, 2380, 2434, 2462, 3735]], "test": "untested"}
{"id": "dd3fR2", "name": "Fluid liquid", "author": "wyatt", "description": "trying to mimic the behavior of a fluid", "tags": ["mpm"], "likes": 26, "viewed": 462, "published": 3, "date": "1697387181", "time_retrieved": "2024-07-30T17:28:09.618869", "image_code": "Main\n    vec4 c = C(U);\n    Q = sin(c.w-2.*c.z/R.x+vec4(1,2,3,4));\n    Q *= c.w/.8;\n    Q = 1.-Q;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\nfloat erf(in float x) {\n    //x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}\nfloat G (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\nfloat building(vec2 U) {\n    \n    if (U.x<.3*R.x) return 1.;\n    return 0.;\n\n}\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\nfloat _12(vec2 U) {\n    U = floor(U);\n    return U.x+U.y*R.x;\n}\nvec2 _21(float i) {\n    return .5+vec2(mod(i,R.x),floor(i/R.x));\n}", "buffer_a_code": "Main\n    \n    if (building(U)==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,-.15/R.y);\n    \n    for (float x = -2.; x <= 2.; x ++) \n    for (float y = -2.; y <= 2.; y ++)\n    if (x!=0.||y!=0.) {\n        vec2 u = vec2(x,y);\n        vec4 cc = C(Q.xy+u);\n        f -= .03*cc.w*(cc.w-.7)*u/dot(u,u)/length(u);\n    }\n    Q.zw = mix(Q.zw,c.xy,.1);\n    Q.zw += f;\n    Q.xy += 2.*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<5.) Q.w += .1;\n    if (Q.x<5.) Q.z += .1;\n    if (R.y-Q.y<5.) Q.w -= .1;\n    if (R.x-Q.x<5.) Q.z -= .1;\n\n    if (M.z>0.) Q.zw -= 1e-2*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    vec4 d = D(U);\n    vec4 a = A(_21(d.x));\n    if (cell(a.xy-U)&&i<4\n        &&d.x!=Q.x&&d.x!=Q.y&&d.x!=Q.z&&d.x!=Q.w\n    ) Q[i]= d.x;\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    Q = vec4(0);\n    float w = 0.;\n    for (float x = -3.; x<=3.; x++)\n    for (float y = -3.; y<=3.; y++)\n    {\n        \n        vec4 b = B(U+vec2(x,y));\n        float s = 1.2;\n        float n = dot(vec4(b.x>0.,b.y>0.,b.z>0.,b.w>0.),vec4(1));\n        for (int k = 0; k < 4; k++) {\n            if (b[k]>0.) {\n                vec2 u = _21(b[k]);\n                vec4 a = A(u);\n                vec2 v = a.xy-U;\n                float e = G(length(v),s);\n                w += e;\n                Q.xyz += vec3(a.zw,u.y)*e;\n                Q.w += e;\n            } else break;\n        }\n    }\n    if (w>0.) Q.xy /= w;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.x)).xy)<length(U-A(_21(Q.x)).xy)) Q.x = q.x;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(_21(q.y)).xy)<length(U-A(_21(Q.y)).xy)) Q.y = q.y;\n}\nMain\n    Q = B(U);\n    for (int y=-3;y<=3;y++) {\n        XY(U,Q,B(U+vec2(0,y)));\n        XY(U,Q,B(U+vec2(y,0)));\n    }\n    \n    if (I%12==0) \n        Q.y = _12(U);\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.yxzw);\n    \n    if (I<1) Q = vec4(_12(U));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3fR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mtjSWD", "name": "Some Worley noise", "author": "SpinningCube", "description": "A simple implementation of two-dimensional Worley Noise. Then I layer it multiple times before displaying it to the screen.", "tags": ["2d", "noise", "worley"], "likes": 4, "viewed": 209, "published": 3, "date": "1697386731", "time_retrieved": "2024-07-30T17:28:10.562346", "image_code": "// Worley noise implementation by SpinningCube\n\n// Hash by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// 2D Worley noise\nfloat worley(vec2 pos) {\n    // Find current grid cell within the infinite grid.\n    vec2 cell = floor(pos);\n    \n    // Each grid cell has a single point randomly placed within it.\n    // Find the distance from the sample position to the closest point\n    // by calculating the distance to every point in the nearest 9 cells.\n    \n    float dist = 10.0; // safe upper bound\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 offset = vec2(x, y);\n            dist = min(dist, distance(fract(pos), hash22(cell + offset) + offset));\n        }\n    }\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float weight = 1.0;\n    float scale = 3.0;\n    const int numOctaves = 10;\n    \n    float noise = 0.0;\n    \n    // Multiple combined octaves\n    for (int i = 0; i < numOctaves; i++) {\n        weight *= 0.5;\n        noise += weight * (worley(scale * uv + 0.2 * scale * iTime));\n        scale *= 2.0;\n    }\n    \n    //noise = 1.0 - noise; // Invert the noise\n    //noise = 2. * (noise - 0.5); // Threshold\n    \n    vec3 col = vec3(noise);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjSWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 114, 135, 135, 269], [271, 290, 314, 370, 902], [904, 904, 961, 961, 1507]], "test": "untested"}
{"id": "dscfRj", "name": "Ray-Tracing Andrei-Cn", "author": "AndreiCN", "description": "My ray tracing shader", "tags": ["raytracing"], "likes": 1, "viewed": 74, "published": 3, "date": "1697385862", "time_retrieved": "2024-07-30T17:28:11.569653", "image_code": "struct material {\n    vec3 color;\n    float reflectance;\n};\n\nstruct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 getAt(ray r, float t){\n    return r.origin + r.direction * t;\n}\n\nstruct sphere{\n    vec3 position;\n    float radius;\n    material mat;\n};\n\n\nstruct record{\n    vec3 normal;\n    float t;\n    bool didHit;\n    sphere target;\n    material mat;\n};\n\nvec2 projectPointOnPlane(vec3 pointOnSphere, sphere s) {\n    // Calculate the direction vector from the sphere's center to the point on the sphere\n    vec3 direction = normalize(pointOnSphere - s.position);\n    \n    // Convert the point's Cartesian coordinates to spherical coordinates relative to the sphere's center\n    float r = s.radius;\n    float rPrime = length(pointOnSphere - s.position);\n    float theta = acos(direction.z);\n    float phi = atan(direction.y, direction.x);\n    \n    // Convert spherical coordinates to Cartesian coordinates\n    float xPrime = rPrime * sin(theta) * cos(phi);\n    float yPrime = rPrime * sin(theta) * sin(phi);\n    float zPrime = rPrime * cos(theta);\n    \n    // Project onto (0,1) x-axis and (0,1) y-axis planes\n    float xNormalized = (xPrime - (s.position.x - r)) / (2.0 * r);\n    float yNormalized = (yPrime - (s.position.y - r)) / (2.0 * r);\n    \n    return vec2(xNormalized, yNormalized);\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n        // Use Schlick's approximation for reflectance.\n        float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n        r0 = r0*r0;\n        return r0 + (.01-r0)*(1.0 - cosine)*(1.0 - cosine)*(1.0 - cosine)*(1.0 - cosine)*(1.0 - cosine);\n    }\n\nvec3 refract2(vec3 uv, vec3 n, float etai_over_etat) {\n    float cos_theta = min(dot(-uv, n), 1.0);\n    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);\n    vec3 r_out_parallel = -sqrt(abs(1.0 - dot(r_out_perp, r_out_perp))) * n;\n    return r_out_perp + r_out_parallel;\n}\n\nrecord hit_sphere(in ray r, in sphere s, out record h){\n    vec3 oc = r.origin - s.position;\n    highp float half_b = dot(oc, r.direction);\n    highp float c = dot(oc, oc) - s.radius * s.radius;\n    highp float discriminant = half_b * half_b - c;\n    \n    if (discriminant < 0.0) {\n        return h;\n    }else {\n        highp float t = -half_b - sqrt(discriminant);\n        if (t > 0.00001 && t < h.t){\n            h.didHit = true;\n            h.t = t;\n            h.mat = s.mat;\n            h.target = s;\n            h.normal = (getAt(r, t) - s.position) / s.radius;\n            return h;\n        };\n    }\n    return h;\n}\n\nfloat RandomValue(inout int state){\n    state = state * 747796405 + 2891336453;\n    int result = ((state >> ((state >> 52 ) + 128567)) ^ state) * 277803737;\n    result = (result >> 522) ^ result;\n    return float(result) / 4294967295.0;\n}\n\nvec3 RandomVector(inout int state){\n    float x = RandomValue(state);\n    float y = RandomValue(state);\n    float z = RandomValue(state);\n    return vec3(x,y,z);\n}\n\nvec3 RandomVectorInSphere(inout int state){\n    while (true){\n        vec3 vec = RandomVector(state);\n        if (dot(vec, vec) <= 1.0){\n            return vec;\n        }\n    }\n}\n\nconst int numofspheres = 5;\nsphere SPHERES[numofspheres];\n\nvec3 ray_color(ray r, int index){\n    float persistence = - -2.0;\n    vec3 BACKGROUND = vec3(r.direction + 0.5);\n    vec3 color;\n\n    for (int j; j < 40; j ++){\n        record h;\n        h.t = 100000.0;\n        for (int i = 0; i < numofspheres; ++i){\n            sphere s = SPHERES[i];\n            h = hit_sphere(r, s, h);\n        };\n        \n        if (!h.didHit){\n            color += vec3(gl_FragCoord.xy/iResolution.xy, 0.2) * 0.3;\n            color == vec3(0,0,0);\n            break;\n        }\n        vec3 sphereclr = h.mat.color;\n        vec2 sphereUV = projectPointOnPlane(getAt(r, h.t), h.target);\n        int index = int(sphereUV.x * 100000.0 + sphereUV.y * 100000.0) * 200 ;\n        float nosieVal = RandomValue(index);\n\n        color += persistence * sphereclr + nosieVal / 2.0;\n        ray r2;\n        r2.origin = getAt(r, h.t);\n        float refractratio = 1.5;\n        float cos_theta = min(dot(-r.direction, h.normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n        bool cannot_refract = refractratio * sin_theta > 1.0;\n        vec3 direction;\n        \n        if (cannot_refract || reflectance(cos_theta, refractratio) > 0.1345)\n            direction = reflect(r.direction, h.normal);\n        else\n            direction = refract2(r.direction, h.normal, refractratio);\n        \n        //r2.direction = reflect(r.direction, h.normal);\n        r2.direction = direction + RandomVectorInSphere(index) * 3.6;\n        r2.direction = normalize(r2.direction);\n        r = r2;\n\n        persistence *= h.mat.reflectance;\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    highp float ratio = 640.0/360.0;\n    int samplereps = 25;\n    float viewportscale = 1.0;\n/*\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].position = vec3(-sin(iTime) * 0.5 - 0.5, 0.1, -2.0);\n    SPHERES[0].mat.color = vec3(.1, .1, 1.0);\n    SPHERES[0].mat.reflectance = 0.5;\n\n    SPHERES[3].radius = 0.5;\n    SPHERES[3].position = vec3(sin(iTime), 0.1, -2.0 + cos(iTime));\n    SPHERES[3].mat.color = vec3(1.0, .1, 1);\n    SPHERES[3].mat.reflectance = 0.4;\n    \n    SPHERES[4].radius = -1.0;\n    SPHERES[4].position = vec3(cos(iTime), sin(iTime), -2.0 + cos(iTime));\n    SPHERES[4].mat.color = vec3(0, 1.0, 1.0);\n    SPHERES[4].mat.reflectance = -1.0;\n\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].position = vec3(.6, 0.1, -2.0);\n    SPHERES[1].mat.color = vec3(0, 0, 0);\n    SPHERES[1].mat.reflectance = 0.1;\n\n    SPHERES[2].radius = 100.0;\n    SPHERES[2].position = vec3(.6, -100.0, 4.0);\n    SPHERES[2].mat.color = vec3(1, 1, 1);\n*/\n\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].position = vec3(0, 0.1, -0.8);\n    SPHERES[0].mat.color = vec3(0.05, 0.05, 0.05);\n    SPHERES[0].mat.reflectance = 3.0;\n\n    SPHERES[1].radius = 0.4;\n    SPHERES[1].position = vec3(sin(iTime) * 0.8, cos(iTime) * 0.8, -0.8);\n    SPHERES[1].mat.color = vec3(1, 0, 0);\n    SPHERES[1].mat.reflectance = 0.43;\n\n\n    vec2 uv = (FragCoord.xy / iResolution.xy) - 0.5;\n    vec3 pointOnViewport = vec3(uv.x * ratio, uv.y, 0) * viewportscale + vec3(0,0,-.2);\n    int index = int(gl_FragCoord.y * iResolution.x + gl_FragCoord.x);\n    vec3 normpov = normalize(pointOnViewport);\n\n    ray r;\n    r.origin = vec3(0,0,0);\n    r.direction = normpov;\n\n    vec3 color;\n    for (int x = 1; x <= samplereps; x++){\n        for (int y = 1; y <= samplereps; y++){\n            r.direction = normpov + vec3(float(x), float(y), 0) * 0.003;\n            color += ray_color(r, index);\n        }\n    }\n    color /= float(samplereps * samplereps);\n\n    color = vec3(sqrt(color.x), sqrt(color.y), sqrt(color.z));\n\n    FragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 142, 142, 183], [363, 363, 419, 509, 1299], [1301, 1301, 1349, 1405, 1586], [1588, 1588, 1642, 1642, 1866], [1868, 1868, 1923, 1923, 2490], [2492, 2492, 2527, 2527, 2730], [2732, 2732, 2767, 2767, 2895], [2897, 2897, 2940, 2940, 3075], [3136, 3136, 3169, 3169, 4718], [4720, 4720, 4775, 4775, 6772]], "test": "untested"}
{"id": "csKyzd", "name": "Subdivided Voxel Raymarching", "author": "Shane", "description": "Sparse subdivided voxel cell raymarch traversal. ", "tags": ["raymarch", "voxel", "menger", "cell", "sierpinski", "traversal", "sparse"], "likes": 90, "viewed": 1248, "published": 3, "date": "1697377096", "time_retrieved": "2024-07-30T17:28:12.628821", "image_code": "/*\n\n\tSubdivided Voxel Raymarching\n\t----------------------------\n    \n    I don't think I've posted a tunnel flythrough for a while, so here's \n    something that I've had sitting in my account in one form or another\n    for ages. I'd describe the aesthetic here as weird but interesting. :)\n    This particular scene style is not commonly seen because it relies on \n    a raymarching trick that's not often used. I'm not sure what it's \n    officially called, but Shadertoy user Nimitz called it sparse cell \n    raymarching in one of his examples, so that's as good a term as any. :)    \n\n\tTraversing sparse voxels inside a raymarching loop is not a new idea,\n    but it's one that's seldomly used, which surprises me since it opens\n    up so many possibilities. Basically, you can render a voxelized scene\n    with virtually all of the benefits of raymarching, and without putting\n    too much pressure on the GPU.\n    \n    The rendering speed is not too bad, all things considered, but I'll try \n    to tweak it more later to cater to those with slower machines. Anyway, \n    I have a few of these that I plan to post at some stage.\n    \n    \n\n\n\tOther examples: \n    \n\n    // Really stylish.\n    Sparse grid marching - nimitz\n    https://www.shadertoy.com/view/XlfGDs\n    \n\t// A cell be cell traversal with raymarching inside each cell.\n    // Amazing to think that this is over ten years old.\n    Cubescape - iq\n\thttps://www.shadertoy.com/view/Msl3Rr \n    \n    // A rectangular prism example that should be easier to understand.\n    Cell-By-Cell Raymarching - Shane\n    https://www.shadertoy.com/view/DdBfzt\n \n\n*/\n\n// Scene: There are four surfaces to voxelize... or quasi-voxelize. I quickly\n// put some simple ones in there, but you could code up any surface you can\n// dream up... that doesn't fry the GPU. :)\n//\n// Tunnel: 0, Noisy Tunnel: 1, Blobby Surface: 2, Warped double planes: 3.\n#define SCENE 1\n\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Object ID: Either the back plane, extruded object or beacons.\nint objID;\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // Depending on your machine, this should be faster than\n    // the block below it.\n    return texture(iChannel2, vec3(f*vec2(.2483, .3437), .5)).x;\n    /* \n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n    */\n}\n\n// IQ's \"uint\" based uvec3 to float hash.\nfloat hash31(vec3 f){\n\n    \n    //return texture(iChannel1, f.xy*vec2(.2483, .1437) + f.z*vec2(.4865, .5467)).x;\n    // Volume noise texture.\n    return texture(iChannel2, f*vec3(.2483, .4237, .4865)).x;\n    /* \n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32 >> 16);\n    return float(n & uint(0x7fffffffU))/float(0x7fffffff);\n    */ \n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Abosolute normal with a bit of tightning.\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.zy).xyz;\n    vec3 ty = texture(tex, p.xz).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture \n    // sample, represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like\n    // that. :) Once the final color value is gamma corrected, you should see correct \n    // looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, \n// and amplitudes.\nvec2 path(in float z){ \n    \n   \n    //return vec2(0); // Straight.\n    float a = sin(z*.11);\n    float b = cos(z*.14);\n    return vec2((a*4. -b*1.5), (b*1.7 + a*1.5)); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n \n\n \n/*\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), \n            fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n*/\n\n// Texture volume based 3D noise.\nfloat n3D(vec3 p){\n\t\n    return texture(iChannel2, p/32.).x; // Range: [0, 1].\n}\n\n\n// IQ's 3D signed box formula.\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\n\n\n// Scene: There are four surfaces to voxelize... or quasi-voxelize. I quickly\n// put some simple ones in there, but you could code up any surface you can\n// dream up... that doesn't fry the GPU. :)\n//\nfloat getFunc(vec3 p){\n\n    #if SCENE == 0\n    \n    // Standard perturbed tunnel function. It looks better without\n    // subdivision turned on.\n\n    // Offset the tunnel about the XY plane as we traverse Z.\n    p.xy -= path(p.z);\n    \n    \n    // Standard tunnel. Comment out the above first.\n    float n = 3.5 - length(p.xy*vec2(1, .7));\n\n    // Square tunnel. Almost redundant in a voxel renderer. :)\n    //float n = 3. - max(abs(p.x), abs(p.y)); \n\n    // Tunnel with a floor.\n    return min(p.y + 3., n); //n = min(-abs(p.y) + 3., n);\n\n    #elif SCENE == 1\n \n    // Simple noisy tunnel.\n    \n    float d = n3D(p/5.) - .55;//(.4 + sin(iTime/8.)*.125);\n\n    p.xy -= path(p.z);\n\n    float t = 2.5 - length(p.xy);\n    //float t2 = 1. - length(p.xy - vec2(0, 2)); // Tunnel for light, above \"t.\"\n\n\n    return smax(t, d, .5); \n    \n    #elif SCENE == 2 \n\n    // Blobby transcendental surface... Not really suited to this\n    // setup... Needs tweaking.\n    \n    p.xy -= path(p.z);\n\n    p /= 4.;\n\n    p = (cos(p*.315*2. + sin(p.zxy*.875*2.)));\n\n    float n = dot(p, p);\n\n    p = sin(p*3. + cos(p.yzx*3.));\n\n    n -= .9 + p.x*p.y*p.z*.35;\n\n    return n; \n    \n    #else \n    \n    // Warped double plane.\n    \n    p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n    p.xy = rot2(p.z/8.)*p.xy; // Twist it about XY with respect to distance.\n    \n    //float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.25)); // Timelapse effect.\n    float n = dot(sin(p*1. + sin(p.yzx*.5)), vec3(.25)); // Sinusoidal layer.\n     \n    return 2. - abs(p.y) + n; // Warped double planes, \"abs(p.y),\" plus surface layers.\n    \n    #endif\n     \n}\n\n// Global storage for the cell distance and ID.\nvec4 gVal;\n\n\n// The code here is a little fiddly, but if you ignore the individual logic, \n// you can see that we're partitioning space into repeat cells -- as is often \n// done -- then rendering (or not rendering, hence the sparse attribute) an \n// object inside each cell. The only difference between this example and a \n// regular one is a few lines at the end which involve raytracing from the \n// current point in each cell to the cell walls. That's it.\n//\nfloat map(vec3 q){\n    \n    \n    // Subdividing space into cells, resulting in\n    // the local coordinates and cell ID.\n    //\n    vec3 sc = vec3(1.36); // Scale.\n    vec3 p = q; // Global coordinates.\n    vec3 ip = (floor(p/sc) + .5)*sc; // Cell ID.\n    int split = 0; // No division.\n    if(hash31(ip + .03)<.35){ \n       sc /= 2.;\n       ip = (floor(p/sc) + .5)*sc; // New cell ID, if needed.\n       split = 1; // The cell has been divided.\n    } \n    p -= ip;  // Local coordinates.\n    \n    \n    // Plugging the cell's central coordinate ID into a 3D distance\n    // function.\n    float fn = getFunc(ip);\n    \n    // No object hit ID... Probably not necessary.\n    objID = 0;\n    \n    \n    // Voxel object and frameword distance.\n    float vox = 1e5, frame = 1e5;\n    \n   \n    // If we're below the 3D function threshold, render an object\n    // inside the cell space.\n    if(fn<0.){ \n    \n        // Render a slightly round cube that takes up the cell.\n        float minSc = min(min(sc.x, sc.y), sc.z);\n        vox = sBoxS(p, sc/2. - .0*minSc, .05*minSc);\n        float oVox = vox;\n\n        float hw = minSc/3.; // Hole dimension.\n \n        float xRnd = hash31(ip + .011) - .6;\n        //float yRnd = hash31(ip + .022) - .6;\n        float zRnd = hash31(ip + .033) - .6;\n        \n        float divF = 3.;\n        vec3 q = mod(p + sc/divF/2., sc/divF) - sc/2./divF;\n        \n        // Bore out random Sierpinski-style holes from the XY cube face.\n        if(zRnd<0.){ \n        \n            // Large hole.\n            float hXY = sBoxS(p.xy, mix(sc.xy, vec2(minSc), .5)/2., 0.);\n            vox = smax(vox, -hXY - hw, .05*minSc);\n            \n            // Smaller holes.\n            if(hash31(ip + .41)<.5){\n                float hXY2 = sBoxS(q.xy, vec2(minSc)/2./divF, 0.);\n                vox = smax(vox, -hXY2 - hw/divF, .05*minSc/divF);\n            }\n             \n        }\n        \n        // Bore out random Sierpinski-style holes from the YZ cube face.\n        if(xRnd<0.){\n        \n            // Large hole.\n            float hYZ = sBoxS(p.yz, mix(sc.yz, vec2(minSc), .5)/2., 0.);\n            vox = smax(vox, -hYZ - hw, .05*minSc);\n            \n            // Smaller holes.\n            if(hash31(ip + .43)<.5){\n                float hYZ2 = sBoxS(q.yz, vec2(minSc)/2./divF, 0.);\n                vox = smax(vox, -hYZ2 - hw/divF, .05*minSc/divF);\n            }\n             \n        }\n        \n        // XY cube face.\n        //if(yRnd<0.){\n        \n            //float hXZ = sBoxS(p.xz, sc.xz/2., 0.);\n            //vox = smax(vox, -hXZ - hw, .05*minSc);\n \n            //float hXZ2 = sBoxS(q.xz, sc.xy/2./divF, 0.);\n            //vox = smax(vox, -hXZ2 - hw/divF, .05*minSc/divF);\n            \n        //}\n        \n   \n        // Frame lattice of sorts. Only calculate the frame lattice when\n        // no cell subdivision has occurred. That's a design choice, not\n        // a necessity.\n        if(split==0){\n        \n            // Face selection.\n            vec3 dir = abs(p); \n            dir = step(dir.yzx, dir.xyz)*step(dir.zxy, dir.xyz)*sign(p); \n            int splitN = hash31(ip + dir*sc + .03)<.333? 1 : 0;\n\n            float fnN = getFunc(ip + dir*sc);\n\n            float wF = .1; // Width factor.\n            \n\n            frame = sBoxS(p, sc/2.*wF*1.5, minSc*.025);\n            //frame = length(p) - minSc/2.*wF*2.;\n\n            // Replace some of the silver boxes.\n            float met = hash31(floor(ip/3.) + .3) - .5;\n            if(met<0. && hash31(floor(ip) + .22)<.65) vox = 1e5;\n\n            if(fnN<0.){ // - dir*sc/2.\n\n\n                vec3 lSc = minSc/2.*wF + abs(dir)*minSc;//*(1. - wF)*2.;\n                frame = min(frame, sBoxS(p, lSc, .025*minSc));\n\n                //vox = length(p - dir*sc/4.) - minSc/8.;\n\n            } \n            \n            // The edge evaluation isn't really meant to be performed with\n            // a split lattice, so there's some untidy open edges. This hack \n            // cleans them up a bit.\n            frame = max(frame, oVox);\n     \n            \n             \n        \n        }  \n        \n         // Object ID.\n        objID = vox<frame? 1 : 2;\n   \n        \n    \n    }\n \n    // Storing the cell distance and cell ID for later usage.\n    gVal = vec4(vox, ip);\n    \n    \n    // Current position to the forward facing cubic cell wall \n    // plane intersection distances.\n    vec3 rC = (gDir*sc - vec3(p))/gRd;\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n \n    \n    // Return the minimum overall scene distance.\n    return min(vox, frame); \n\n    \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. \n// I tried to make it as concise as possible. Whether that translates to speed, or not, \n// I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset \n    // greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), \n                  tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n*/\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash31(ro + rd)*.15\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5; // Equivalent to: sign(rd)*.5;\n    gRd = rd; \n    \n     \n    const int iMax = 128;\n    for (int i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001 || t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d*.9, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    //                      map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n       \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d*.9, gCD), .02, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// A slight variation on a function from Nimitz's hash collection, here: \n// Quality hashes collection WebGL2 - https://www.shadertoy.com/view/Xt3cDn\nvec2 hash23(vec3 f){\n\n    uvec3 p = floatBitsToUint(f);\n    p = 1103515245U*((p >> 2U)^(p.yzx>>1U)^p.zxy);\n    uint h32 = 1103515245U*(((p.x)^(p.y>>3U))^(p.z>>6U));\n\n    uint n = h32^(h32>>16);\n\n    uvec2 rz = uvec2(n, n*48271U);\n    // Standard uvec2 to vec2 conversion with wrapping and normalizing.\n    return vec2((rz>>1)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir(in vec3 p, in vec3 n){\n\n    vec2 rnd = hash23(p);\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n    \n\n\tfloat sca = 3., occ = 0.;\n    for(int i = 0; i<12; i++){\n    \n        float hr = (float(i) + 1.)*.35/12.; \n        //float fi = float(i + 1);\n        //vec3 rnd = vec3(hash31(p + fi), hash31(p + fi + .1), hash31(p + fi + .3)) - .5;\n        //vec3 rn = normalize(n + rnd*.15);\n        vec3 rn = cosDir(p + n*hr, n); // Random half hemisphere vector.\n        float d = map(p + rn*hr);\n        \n        occ = occ + max(hr - d, 0.)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n \n///////////////////////////\n\n\n// Microfaceted normal distribution function.\nfloat D_GGX(float NoH, float roughness) {\n    float alpha = pow(roughness, 4.);\n    float b = (NoH*NoH*(alpha - 1.) + 1.);\n    return alpha/(3.14159265*b*b);\n}\n\n// Surface geometry function.\nfloat G1_GGX_Schlick(float NoV, float roughness) {\n    //float r = roughness; // original\n    float r = .5 + .5*roughness; // Disney remapping.\n    float k = (r*r)/2.;\n    float denom = NoV*(1. - k) + k;\n    return max(NoV, .001)/denom;\n}\n\nfloat G_Smith(float NoV, float NoL, float roughness) {\n    float g1_l = G1_GGX_Schlick(NoL, roughness);\n    float g1_v = G1_GGX_Schlick(NoV, roughness);\n    return g1_l*g1_v;\n}\n\n// Bidirectional Reflectance Distribution Function (BRDF). \n//\n// If you want a quick crash course in BRDF, see the following:\n// Microfacet BRDF: Theory and Implementation of Basic PBR Materials\n// https://www.youtube.com/watch?v=gya7x9H3mV0&t=730s\n//\nvec3 BRDF(vec3 col, vec3 n, vec3 l, vec3 v, \n          float type, float rough, float fresRef){\n     \n  vec3 h = normalize(v + l); // Half vector.\n\n  // Standard BRDF dot product calculations.\n  float nv = clamp(dot(n, v), 0., 1.);\n  float nl = clamp(dot(n, l), 0., 1.);\n  float nh = clamp(dot(n, h), 0., 1.);\n  float vh = clamp(dot(v, h), 0., 1.);  \n\n  \n  // Specular microfacet (Cook- Torrance) BRDF.\n  //\n  // F0 for dielectics in range [0., .16] \n  // Default FO is (.16 * .5^2) = .04\n  // Common Fresnel values, F(0), or F0 here.\n  // Water: .02, Plastic: .05, Glass: .08, Diamond: .17\n  // Copper: vec3(.95, .64, .54), Aluminium: vec3(.91, .92, .92), Gold: vec3(1, .71, .29),\n  // Silver: vec3(.95, .93, .88), Iron: vec3(.56, .57, .58).\n  vec3 f0 = vec3(.16*(fresRef*fresRef)); \n  // For metals, the base color is used for F0.\n  f0 = mix(f0, col, type);\n  vec3 F = f0 + (1. - f0)*pow(1. - vh, 5.);  // Fresnel-Schlick reflected light term.\n  // Microfacet distribution... Most dominant term.\n  float D = D_GGX(nh, rough); \n  // Geometry self shadowing term.\n  float G = G_Smith(nv, nl, rough); \n  // Combining the terms above.\n  vec3 spec = F*D*G/(4.*max(nv, .001));\n  \n  \n  // Diffuse calculations.\n  vec3 diff = vec3(nl);\n  diff *= 1. - F; // If not specular, use as diffuse (optional).\n  diff *= (1. - type); // No diffuse for metals.\n\n  \n  // Combining diffuse and specular.\n  // You could specify a specular color, multiply it by the base\n  // color, or multiply by a constant. It's up to you.\n  return (col*diff + spec*3.14159265);\n  \n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0, 0, iTime*5.); // Camera position, doubling as the ray origin.\n    vec3 lookAt = camPos + vec3(0, 0, .25);  // \"Look At\" position.\n \n    // Light positioning. \n \tvec3 lightPos = camPos + vec3(0, .5, 6);// Put it in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" \n    // function is synchronized with the distance function.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*right + uv.y*up + forward/FOV);\n    // Fisheye lens.\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.2));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/24.)*rd.xy;\n    \n\n    // Scene distance.\n\tfloat t = trace(camPos, rd);\n    \n    // Object ID: Back plane (0), or the metaballs (1).\n    int svObjID = objID;\n    \n    // Saving some 3D cell values. In this case, distance and ID.\n    vec4 svVal = gVal;\n    \n    \n    // Background fog color.\n    vec3 fog = mix(vec3(.32, .28, .16)*3., vec3(.32, .12, .08)*2., -rd.y*.5 + .5);\n    //vec3 fog = vec3(0);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = fog;\n    \n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR && svObjID>0){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        vec3 sn = getNormal(sp, t);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        //vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./3.;\n        // Texture-based bump mapping.\n\t    //sn = doBumpMap(iChannel0, sp*tSize0, sn, .003);\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        //sn = doBumpMap(sp, sn, .1);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calcAO(sp, sn) ;//calculateAO(sp, sn);//*.75 + .25;\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), .0001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.05); // + distlpsp*distlpsp*0.025\n    \t\n        // Ambient light.\n        // I wanted to use a little more than a constant for ambient light, but \n        // without having to resort to sophisticated methods, then I remembered \n        // Blackle's example, here:\n        // Quick Lighting Tech - blackle\n        // https://www.shadertoy.com/view/ttGfz1\n        //float ambience = pow(length(sin(sn*2.)*.45 + .5)/sqrt(3.), 2.)*.75; // Studio.\n        float ambience = length(sin(sn*2.)*.5 + .5)/sqrt(3.)*\n                         smoothstep(-1., 1., sn.y)*.5; // Outdoor.\n \n    \t\n    \t// Diffuse lighting.\n\t    float diff = max(dot(sn, ld), 0.);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Obtaining the texel color. \n        vec3 ref = reflect(sn, rd);\n\n        // Object texturing.\n        \n        // Coloring.\n        float rnd = hash31(svVal.yzw);\n\t    vec3 texCol = .5 + .45*cos(6.2831*rnd/3. + vec3(0, 1, 2) + .5);\n        \n        texCol = vec3(1)*dot(texCol, vec3(.299, .587, .114));\n        \n        // Metallic box threshold.\n        float met = hash31(floor(svVal.yzw/3.) + .3) - .5;\n        // Metallic coloring for some boxes and the frame.\n        if(met<0. || svObjID==2) texCol = vec3(.2);\n        //if(svObjID==2) texCol *= vec3(1, .8, .6)*1.2;\n \n        // Multiplying objects by respective texture colors.\n        if(met<0. || svObjID==2) texCol *= tex3D(iChannel1, sp/4., sn)*4.;\n\t    else texCol *= .1 + tex3D(iChannel0, sp*tSize0, sn)*4.;\n        \n         \n        // Shadows.\n        float shad = softShadow(sp, lightPos, sn, 8.);\n        \n        \n        float rnd2 = hash31(svVal.yzw + .2);\n        float matType = 0.; // Dielectric.\n        float roughness = min(dot(texCol, vec3(.299, .587, .114))*.5, 1.);\n        float reflectance = hash31(svVal.yzw)*.75;\n        // Metallic properties for some boxes and the framework.\n        if(met<0. || svObjID==2) { \n            texCol = texCol*2.*vec3(1, .8, .5); \n            matType = 1.; reflectance = .5; // Metallic.\n            roughness = min(roughness*5., 1.);\n        }\n\n        \n        // Requires \"St Peter's Basillica\" cube map loaded into \"iChannel3\".\n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 refTx = texture(iChannel3, ref, 1.).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        //spRef = mix(spRef/4., spRef, 1. - smoothstep(0., .01, d + .05));   \n        float rf = 8.;//(svObjID == 1)? 8. : 1.;\n        texCol += texCol*spRef*dot(refTx, vec3(.299, .587, .114))*rf;\n\n\n        \n        // Cook-Torrance based lighting.\n        vec3 ct = BRDF(texCol, sn, ld, -rd, matType, roughness, reflectance);\n        \n        // Combining the ambient and microfaceted terms to form the final color:\n        // None of it is technically correct, but it does the job. Note the hacky \n        // ambient shadow term. Shadows on the microfaceted metal doesn't look \n        // right without it... If an expert out there knows of simple ways to \n        // improve this, feel free to let me know. :)\n        sceneCol = (texCol*ambience*(shad*.5 + .5) + ct*(shad));\n\n\n\t    // Shading.\n        sceneCol *= atten*ao;\n        \n        // \"XT95\" did such a good job with the AO, that it's worth a look on its own. :)\n        //sceneCol = vec3(ao); \n\n\t   \n\t\n\t}\n       \n    // Blend in a bit of fog for atmospheric effect.    \n    sceneCol = mix(sceneCol, fog, smoothstep(.2, .99, t/FAR)); // exp(-.002*t*t), etc.\n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1952, 1985, 2007, 2007, 2065], [2146, 2229, 2250, 2339, 2552], [2554, 2596, 2617, 2737, 3050], [3052, 3275, 3313, 3313, 3390], [3392, 3615, 3653, 3653, 3734], [3737, 3891, 3939, 3997, 4861], [4863, 4967, 4989, 5034, 5233], [5714, 5748, 5766, 5766, 5828], [5831, 5862, 5900, 5900, 5995], [5997, 6053, 6091, 6091, 6176], [6395, 6596, 6618, 6618, 8233], [8296, 8745, 8763, 8872, 13549], [14348, 14369, 14405, 14454, 15533], [16396, 16591, 16643, 16724, 18004], [18007, 18157, 18177, 18177, 18523], [18527, 18646, 18680, 18680, 19277], [20016, 20062, 20103, 20103, 20221], [20223, 20253, 20303, 20342, 20491], [20493, 20493, 20547, 20547, 20669], [20671, 20924, 21019, 21019, 22472], [22476, 22476, 22532, 22558, 29613]], "test": "untested"}
{"id": "msj3DW", "name": "Cubic Solver Test", "author": "mla", "description": "For testing cubic equation solvers. Image is the Euclidean plane, showing solver accuracy at each point (see header for coordinate to equation conversion). Use mouse to select point for numeric display.", "tags": ["solver", "cubic", "equation"], "likes": 10, "viewed": 210, "published": 3, "date": "1697354170", "time_retrieved": "2024-07-30T17:28:13.789717", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// Cubic Solver Test, mla 2023\n//\n// Testing some solvers for depressed cubics: x³+px+q = 0\n// \n// Implements several versions of the usual analytic solver, also \n// for comparison Kahan's semi-iterative solver, which produces pretty \n// good results across the board. dcubic1 is a fairly standard trigonometric\n// solver. dcubic2 and dcubic3 use a complex cube root operation that\n// can be refined with Newton-Raphson to reduce errors from trig functions.\n// nrcubic is the solver from Numerical Recipes.\n//\n// Shader shows complex plane/ℝ² under (inverse of) map z -> z/(1-z²),\n// that maps the entire plane to the unit disc. Color indicates accuracy\n// of solution, red most accurate, magenta least.\n//\n// For position pos = (x,y), roots are a, b±√c, where a = x, c = y.\n// For depressed cubics, sum of roots = 0, so b = -a/2.\n// If y < 0 then only one real root, else three real roots (maybe coincident).\n\n// Numeric solution shown for mouse selection (x,y) if in the image:\n// p q\n// error\n// input roots 1-3\n// found roots 1-3\n// \n// 'c': don't refine complex cube root in dcubic2 & dcubic3\n// 'k': use semi-iterative Kahan solver\n// 'p': polish final roots with one round of Newton-Raphson\n// 's': scale projection\n// 't': no projection\n// 'z': zoom in\n//\n//////////////////////////////////////////////////////////////////////\n\n//#define DCUBIC dcubic1\n#define DCUBIC dcubic2\n//#define DCUBIC dcubic3\n//#define DCUBIC nrcubic\n\n// A proper sign function that returns 1 for sign(0) (even -0)\nfloat sgn(float x) {\n  if (x < 0.0) return -1.0;\n  else return 1.0;\n}\n\nvec2 ccuberoot(vec2 z) {\n  // Complex cube root. \n  float r = length(z);\n  z /= r;\n  float t = carg(z)/3.0;\n  vec2 u = vec2(cos(t),sin(t));\n  if (!key(CHAR_C)) {\n    // Newton-Raphson refinement\n    vec2 u2 = cmul(u,u);\n    u -= cdiv(cmul(u,u2)-z,3.0*u2);\n  }\n  return cuberoot(r)*u;\n}\n\n// cuberoots of 1.\nconst vec2 omega = 0.5*vec2(-1,sqrt(3.0));\nconst vec2 omega2 = omega*vec2(1,-1);\n\n// Standard depressed cubic solver. This works OK, but\n// GPU trig functions often aren't all that accurate which\n// can cause problems.\nint dcubic1(float p, float q, out vec3 roots) {\n  p /= 3.0;\n  float h = q*q + 4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r); // Largest root of quadratic\n    float t = cuberoot(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    float theta = atan(r,-q); // 0 <= theta < PI\n    float k = 2.0*sqrt(abs(p));\n    roots = k*cos((theta+PI*vec3(0,-2,2))/3.0);\n    // And we return them in order\n    assert(roots[0] >= roots[1]);\n    assert(roots[1] >= roots[2]);\n    return 3;\n  }\n}\n\n// Annotated and with a different way of doing the multiple roots\n// case (uses Newton-Raphson to get more accurate complex cube root).\nint dcubic2(float p, float q, out vec3 roots) {\n  // Divide p immediately by 3 to make life easier later\n  p /= 3.0;\n  // Now we are solving x³+3px+q = 0\n  // Put x = u+v and get x³ = u³+v³+3xuv\n  // Substitute in original equation and get:\n  // u³+v³+3(uv+p)x + q = 0\n  // Now we seek u,v such that uv+p = 0, so then:\n  // uv = -p ie. u³v³ = -p³ and u³+v³ = -q\n  // This gives a quadratic equation with roots u,v:\n  // t²+qt-p³ = 0\n  // Discriminant is h = q²+4p³\n  float h = q*q+4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = 0.5*(-q-sgn(q)*r); // Largest root\n    float t = cuberoot(u);\n    roots[0] = t - p/t;\n    return 1;\n  } else {\n    // Again we have v = -p/u = -pu'/|u|² where u' is conjugate of u\n    // So given u³ = 0.5(-q ± sqrt(-(q²+4p³))i) = 0.5*(-q ± ri)\n    // |u³|² = |u|²³ = 0.25(q²-q²-4p³) = -p³\n    // So |u|² = -p, so v = u' and u = √|p|(cos θ + i sin θ) with θ = atan(±r,-q)/3\n    // Since u,v are complex conjugates their sum is just twice their\n    // real parts, and using polar coordinates, Re(r,θ) = r cos θ\n    float k = sqrt(abs(p));\n    float theta = atan(r,-q)/3.0;\n    vec2 z = vec2(cos(theta),sin(theta));\n    if (!key(CHAR_C)) {\n      // Newton-Raphson to refine the complex cube root.\n      // This will compensate nicely for any trig inaccuracy.\n      // Want z³-t = 0, and |t| = 1\n      vec2 t = vec2(-q,r)/(2.0*k*k*k);\n      vec2 z2 = cmul(z,z);\n      z -= cdiv(cmul(z,z2)-t,3.0*z2);\n    }\n    float x0 = z.x, x2 = rmul(z,omega), x1 = -x0-x2;\n    // Note that roots add up to 0 for reduced cubic.\n    roots = 2.0*k*vec3(x0,x1,x2); // Just want the real parts here\n    // Check the roots are in order\n    assert(roots[0] >= roots[1]);\n    assert(roots[1] >= roots[2]);\n    return 3;\n  }\n}\n\n// Super simple solution, just to illustrate the idea.\n// Actually, this one produces pretty good results, though since\n// it's more complex arithmetic, it might be a little slower\nint dcubic3(float p, float q, out vec3 roots) {\n  p /= 3.0;\n  float B = q, C = -p*p*p;\n  float D = B*B-4.0*C;\n  if (D > 0.0) {\n    // The 2 complex cube roots don't lead to real solutions\n    float u = cuberoot(0.5*(-B-sgn(B)*sqrt(D)));\n    roots[0] = u-p/u;\n    return 1;\n  } else {\n   // But here, 3 complex cube roots all lead to real solutions\n    vec2 u0 = ccuberoot(0.5*vec2(-B,sqrt(-D)));\n    vec2 u1 = cmul(omega,u0);\n    vec2 u2 = cmul(omega2,u0);\n    roots.x = (u0-p*cinv(u0)).x;\n    roots.y = (u1-p*cinv(u1)).x;\n    roots.z = (u2-p*cinv(u2)).x;\n    if (roots.y < roots.z) roots.yz = roots.zy;\n    return 3;\n  }\n}\n\n// Numerical Recipes algorithm for solving cubic equations.\n// Single root is OK, but upper half vulnerable to\n// trig inaccuracies.\nint nrcubic(float p, float q, out vec3 x) {\n  float b = p, c = q;\n  // solve x^3 + bx + c = 0\n  float Q = -b/3.0;\n  float R = 0.5*c;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = R/sqrt(Q3);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    x[0] = -2.0*S*cos(theta/3.0);\n    x[1] = -2.0*S*cos((theta+2.0*PI)/3.0);\n    x[2] = -2.0*S*cos((theta+4.0*PI)/3.0);\n    return 3;\n  } else {\n    float A = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),1.0/3.0);\n    float B = A == 0.0 ? 0.0 : Q/A;\n    x[0] = A+B;\n    return 1;\n  }\n}\n\nfloat cbrt(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0);\n}\n\n// The Kahan cubic algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint kahansolve(float C, float D, out vec3 res) {\n  float A = 1.0, B = 0.0;\n  float X,b1,c2;\n  //assert(abs(D) > 1e-6);\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      // 5 iterations does the job\n      for (int i = 0; i < 5; i++) {\n        X = x0;\n        // We only need b1,c2 at the end for deflation\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        x0 -= (q/dq);\n      }\n      eval(X,A,B,C,D,q,dq,b1,c2); // Get c1, c2\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\nfloat error(float x, float y) {\n  return abs(x-y)/(abs(x)+abs(y));\n}\n\nvec3 sort(vec3 a) {\n  if (a.y > a.x) a.xy = a.yx;\n  if (a.z > a.y) a.yz = a.zy;\n  if (a.y > a.x) a.xy = a.yx;\n  return a;\n}\n\nfloat polish(float x, float p, float q) {\n  // A single round should be enough\n  for (int i = 0; i < 1; i++) {\n    float x2 = x*x;\n    float t = x2+p;\n    x -= (x*t+q)/(t+2.0*x2);\n  }\n  return x;\n}\n\nint dcubic(float p, float q, out vec3 roots) {\n  if (key(CHAR_K)) return kahansolve(p,q,roots);\n  return DCUBIC(p,q,roots);\n}\n\nint getdata(vec2 pos, out vec2 coeffs, out vec3 inroots, out vec3 roots, out float err) {\n  if (pos == vec2(0)) {\n    // An exact triple root generates NaN\n    roots = vec3(0), err = 0.0; coeffs = vec2(0);\n    return 3;\n  }\n  float a = pos.x;\n  float b = -0.5*a;\n  float c = pos.y;\n  coeffs = vec2(2.0*a*b+b*b-c, -a*(b*b-c));\n  float p = coeffs.x, q = coeffs.y;\n  int nroots = dcubic(p,q,roots);\n  assert(nroots == 1+2*int(c >= 0.0)); // This can happen, what to do?\n  for (int i = 0; i < nroots; i++) {\n    if (key(CHAR_P)) roots[i] = polish(roots[i],p,q);\n    assert(!isnan(roots[i]));\n  }\n  err = 0.0;\n  if (nroots == 1) {\n    err = error(a,roots[0]);\n    inroots.x = a;\n  } else {\n    vec3 test = vec3(a,b-sqrt(c),b+sqrt(c));\n    test = sort(test);\n    inroots = test;\n    roots = sort(roots);\n    err = max(err,error(test[0],roots[0]));\n    err = max(err,error(test[1],roots[1]));\n    err = max(err,error(test[2],roots[2]));\n  }\n  return nroots;\n}\n\nbool gethudval(int row, int col, vec2 pos, out float x) {\n  vec2 coeffs; vec3 inroots, roots; float err;\n  int nroots = getdata(pos,coeffs,inroots,roots,err);\n  if (row == 0) {\n    if (col == 0) { x = coeffs[0]; return true; }\n    if (col == 1) { x = coeffs[1]; return true; }\n  }\n  if (row == 1) {\n    if (col == 0) { x = err; return true; }\n  }\n  for (int i = 0; i < nroots; i++) {\n    if (col == i && row == 2) { x = inroots[nroots-1-i]; return true; }\n    if (col == i && row == 3) { x = roots[nroots-1-i]; return true; }\n  }\n  return false;\n}\n\nfloat hud(vec2 fragCoord, vec2 pos) {\n  const int digits = 7, nrows = 15, ncols = 4;\n  // Table structure\n  vec2 cellsize = iResolution.xy/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(fragCoord/cellsize);\n  int column = cellindex.x;\n  int row = nrows-cellindex.y-1; // Reverse order of rows\n  float x;\n  if (!gethudval(row,column,pos,x)) return 0.0;\n  \n  float fsize = cellsize.y; // \"Font size\" = line height in pixels\n  vec2 p = mod(fragCoord,cellsize)/fsize;\n  float uvscale = 0.5/(16.0*fsize);   // 0.5 to sharpen a little\n  vec2 dx = vec2(uvscale,0), dy = vec2(0,uvscale);\n\n  // Draw the character\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float charwidth = metrics.y-metrics.x;\n  float colwidth = cellsize.x/fsize-1.0; // Cell width in chars, with padding\n  int charpos = int(p.x/charwidth);\n  vec2 uv = vec2(0);\n  int c = printfloat(x,digits,charpos); // Get character at charpos, 0 if out of range\n  if (c > 0) {\n    float charstart = charwidth*float(charpos); // character start\n    uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  }\n  vec4 t = textureGrad(iChannel0,uv,dx,dy);\n  if (c > 0) return t.x;\n  return 0.0;  \n}\n\n\nbool map(inout vec2 z) {\n  if (!key(CHAR_T)) {\n    if (length(z) > 1.0) return false;\n    // Inverse stereographic followed by gnomonic projection.\n    z /= 1.0-dot(z,z);\n  } else {\n    z *= 2.0;\n  }\n  if (key(CHAR_S)) z *= exp(0.2*iTime);\n  return true;\n}\n\nvec3 getcolor(vec2 pos) {\n  if (!map(pos)) return vec3(1,1,0.8);\n  vec2 coeffs; vec3 inroots, roots; float err;\n  int nroots = getdata(pos,coeffs,inroots,roots,err);\n  vec3 color = h2rgb(0.9*2.0*atan(1000.0*sqrt(err))/PI);\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0);\n  vec2 pos = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec2 mouse = vec2(0);\n  bool showmouse = iMouse.x > 0.0;\n  if (showmouse) {\n    mouse = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    if (key(CHAR_Z)) {\n      float zoom = 4.0;\n      pos = 0.25*pos + 0.75*mouse;\n    }\n  }\n  vec3 color = getcolor(pos);\n  vec2 mpos = mouse;\n  if (showmouse && map(mpos)) {\n    color = mix(color,vec3(0),hud(fragCoord,mpos));\n  }\n  if (alert) color.rb = vec2(1);\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat cuberoot(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0); // Sign OK here though\n}\n\n// Complex arithmetic\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\n// Just return real part of zw\nfloat rmul(vec2 z, vec2 w) {\n  return z.x*w.x-z.y*w.y;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nfloat carg(vec2 z) {\n  return atan(z.y,z.x);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\nconst int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  const int SPACE = 0x20;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS) // No semicolon!\n    else CHAR(SPACE);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msj3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1517, 1580, 1600, 1600, 1649], [1651, 1651, 1675, 1700, 1936], [2039, 2176, 2223, 2223, 2698], [2700, 2836, 2883, 2940, 4624], [4626, 4807, 4854, 4854, 5430], [5432, 5565, 5608, 5608, 6133], [6135, 6135, 6156, 6156, 6196], [6312, 6312, 6368, 6368, 6600], [6602, 6602, 6722, 6722, 6809], [6811, 6896, 6944, 6944, 7784], [7786, 7786, 7817, 7817, 7854], [7856, 7856, 7875, 7875, 7979], [7981, 7981, 8022, 8059, 8178], [8180, 8180, 8226, 8226, 8305], [8307, 8307, 8396, 8396, 9259], [9261, 9261, 9318, 9318, 9808], [9810, 9810, 9847, 9847, 10938], [10941, 10941, 10965, 10965, 11197], [11199, 11199, 11224, 11224, 11439], [11441, 11441, 11496, 11496, 12015]], "test": "untested"}
{"id": "mdtfzS", "name": "Mediano's shader 1", "author": "mediano228", "description": "Shader based on fract", "tags": ["abstract", "neon"], "likes": 1, "viewed": 104, "published": 3, "date": "1697329810", "time_retrieved": "2024-07-30T17:28:14.743168", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++)\n    {\n    \n        vec2 uv0 = uv;\n\n        uv = fract(uv * 1.2) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv - uv0) + iTime * 0.2 + i * 0.1, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));  \n\n        d = sin(d * 8. + iTime) / 8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.5);\n\n        finalColor += col * d;\n     }\n        \n    fragColor = vec4(finalColor, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 115], [117, 117, 174, 174, 809]], "test": "untested"}
{"id": "DstfW7", "name": "Tower of Powers", "author": "domrally", "description": "z₀ = c\nz -> c^z\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "orbit", "derivative", "trap", "exponential", "differential", "chaotic", "tetration", "hyperoperation"], "likes": 8, "viewed": 205, "published": 3, "date": "1697313789", "time_retrieved": "2024-07-30T17:28:16.044688", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nhttps://mathworld.wolfram.com/ComplexExponentiation.html\n*/\nmat3x2 exponentiate(mat3x2 a, mat3x2 b) {\n    mat3x2 c;\n    \n    float mag = dot(a[0], a[0]);\n    float arg = atan(a[0].g, a[0].r);\n    \n    float scale = pow(mag, b[0].r / 2.) * exp(-b[0].g * arg);\n    float angle = b[0].r * arg + b[0].g * log(mag) / 2.;\n    \n    c[0].r = scale * cos(angle);\n    c[0].g = scale * sin(angle);\n    \n    c[1].r = (.5 * log(mag)) \n           * cos(angle) * pow(mag, b[0].r / 2.) * exp(-b[0].g * arg) \n           - scale * sin(angle) * (arg + 1. / (2. * (2. * a[0].r)));\n    c[1].g = (- arg) \n           * sin(angle) * pow(mag, b[0].r / 2.) * exp(-b[0].g * arg) \n           + scale * cos(angle) * (arg + 1. / (2. * (2. * a[0].g)));\n           \n    c[2].r = log(mag)\n           * cos(angle) * pow(mag, b[0].r / 2.) * exp(-b[0].g * arg) \n           / (4. * mag)\n           + log(mag) * log(mag)\n           * cos(angle) * pow(mag, b[0].r / 2.) * exp(-b[0].g * arg) \n           / (4.)\n           - scale * sin(angle) * (arg + 1. / (2. * (2. * a[0].r)));\n    c[2].g = -arg\n           * sin(angle) * pow(mag, b[0].r / 2.) * exp(-b[0].g * arg) \n           -arg\n           * sin(angle) * pow(mag, b[0].r / 2.) * exp(-b[0].g * arg) \n           + scale * cos(angle) * (arg + 1. / (2. * (2. * a[0].g)));\n    \n    return c;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel space to view space\n    vec2 uv = 3.2 * (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvMouse = 2. * iMouse.xy - iResolution.xy;\n      \n    mat3x2 orbit, initial;\n\n    orbit[0] = initial[0] = uv;\n    orbit[1] = initial[1] = vec2(1);\n            \n    // Simulate the trajectory for this pixel relative to the center of the image.\n    vec2 trapped;\n    float radius = 9e9;\n    float escape;\n    for (float i; i < 31.; i++) {\n        // This recursion generates chaotic behavior\n        orbit = exponentiate(initial, orbit);\n        // We want to record the nearest approach as the pixel orbits around the image center.\n        float flyby = dot(orbit[0], orbit[0]);\n        //flyby = distance(orbit, uv);\n        //flyby = abs(orbit.y - uv.y);\n        radius = min(radius, flyby);\n        // The closest point is called the orbit trap.\n        //    https://en.wikipedia.org/wiki/Orbit_trap#Point_based\n        trapped = trapped * float(radius != flyby) + float(radius == flyby) * orbit[0];\n        \n        if (flyby > 9e9) break;\n        \n        escape += float(escape == 0.) * step(400., flyby) * i;\n    }\n    \n    // Find the angle of closest approach of the orbit trap: \n    //    https://en.wikipedia.org/wiki/Argument_(complex_analysis)\n    float angle = atan(trapped.y, trapped.x);\n    //angle = atan(accumulated.y, accumulated.x);\n    // Match the angle to the color wheel: \n    //    https://en.wikipedia.org/wiki/Color_wheel\n    float hue = angle - atan(uvMouse.y, uvMouse.x) + iTime;\n    hue *= float(!isnan(hue)); \n    hue += -float(isnan(hue)) * atan(uvMouse.y, uvMouse.x) + iTime;\n    \n    // shade crab by escape time\n    float estimate = smoothstep(0., 30., escape);\n    // The derivatives need to be scaled by their binomial taylor coefficients\n    vec3 differentials = vec3(\n        length(orbit[0]),\n        length(orbit[1]),\n        2. * length(orbit[2])\n    );\n    // calculate derivative based estimate\n    float test = log(differentials[0]) * .5 * (differentials[0] / differentials[1] +  differentials[1] / differentials[2]);\n    estimate = max(estimate, smoothstep(0., 1.5, pow(test, .2)));\n    // add shading from orbit traps for bifurcation structure\n    estimate = max(estimate, smoothstep(0., 2., pow(2., length(trapped))));\n    \n    // Paint the pixel\n    fragColor = oklch2rgb(estimate, estimate, hue);\n}\n\n\n/*\nREFERENCES\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n*/\n\n\n/*\nFUTHER READING\n\nhyperoperations\n\nhttps://en.wikipedia.org/wiki/Tetration\nhttps://en.wikipedia.org/wiki/Iterated_function#Fractional_iterates_and_flows,_and_negative_iterates\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Orbit_trap\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\n*/\n", "image_inputs": [], "common_code": "/// This page of color space tools adapted from (2022): \n///    https://www.shadertoy.com/view/flSyWz\n/// by Björn Ottosson: \n///    https://www.shadertoy.com/user/bjornornorn\n\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float middle = 0.2;\n    \n    vec3 x = color-middle;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-middle);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return middle + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvec2 approximateShape(float a, float b)\n{\n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1qQA3xhBX3iB8FT8558e5QQnmVZ5Jh1Fb?usp=sharing\n    return vec2(\n        1.63804674 + -0.08431713*a +  0.27624179*b +  0.08737741*a2 +  0.13917503*b2 + 0.03691021*a3 +  0.03060615*b3,\n        0.23438507 + 0.05736278*a  +  -0.09674117*b +  0.024447*a2 + 0.00469441*b2 + 0.01253234*a3 + 0.00741058*b3\n    );\n}\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec4 oklch2rgb(float lightness, float chroma, float hue) {\n    chroma = mix(.0, -.25 * log(.55), chroma);\n    // Translate to Lab color space\n    float a = cos(hue);\n    float b = sin(hue);\n    vec2 gamut = approximateShape(a, b);\n    float saturation = 1. / (gamut.y / (1. - lightness) + gamut.x / lightness);\n    float colorfulness = min(chroma, saturation);\n    a *= colorfulness;\n    b *= colorfulness;\n    vec3 color = oklab_to_linear_srgb(vec3(lightness, a, b));\n    color = softClipColorOutsideGamutOnly(color);\n    color = clamp(color, 0., 1.);\n    color = Srgb3(color);\n    \n    return vec4(color, 1.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 90, 131, 131, 1333], [1336, 1336, 1391, 1424, 3753]], "test": "untested"}
{"id": "Ds3BzB", "name": "Geometric Dot Transform", "author": "misol101", "description": "Naive approach, but it does work.\n\nPress SPACE to toggle amount of trailing. ENTER to toggle time dilation.", "tags": ["2d", "dots", "morph", "dot", "transform", "multipass", "linearinterpolation"], "likes": 9, "viewed": 224, "published": 3, "date": "1697312890", "time_retrieved": "2024-07-30T17:28:16.862502", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float v = texelFetch( iChannel0, ivec2(int(fragCoord.x),int(fragCoord.y)), 0 ).x;\n\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy)) / iResolution.y;\n    float blue = abs(uv.y) < 0.43 ? 0.13 : 0.;\n    float white = blue>0. && abs(uv.y) > 0.427 && abs(uv.x)<0.85 ? 1. : 0.;\n    \n    fragColor = vec4( white+v*0.9, white+v*0.95, white+blue+v, 1.0 );\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// prepare shape\n\nvec2 iResHalf;\n\nvec2 circle(float i, float xradius, float yradius, float epm, float tm, vec2 pos) {\n    float cp = (PI*2. / float(NOF_DOTS)) * (i*epm);\n    float asp = iResolution.y / iResolution.x;\n    return vec2(iResHalf.x+pos.x+sin(cp)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+cos(cp*tm)*(iResolution.y*yradius));\n}\n\nvec2 randbox(float i, float xradius, float yradius, float rp, vec2 pos) {\n    float asp = iResolution.y / iResolution.x;\n    return vec2(iResHalf.x+pos.x+(hash1(i*0.1+rp)-.5)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+(hash1(i*0.1+0.11+rp)-.5)*(iResolution.y*yradius));\n}\n\nvec2 boxr(float i, float xradius, float yradius, float rp, vec2 pos) {\n    float asp = iResolution.y / iResolution.x;\n    if ((int(i) & 1) == 1)\n        return vec2(iResHalf.x+pos.x+(hash1(i*0.1+rp)-.5)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+(hash1(i*0.1+0.11+rp)>0.5?0.5:-0.5)*(iResolution.y*yradius));\n    else\n        return vec2(iResHalf.x+pos.x+(hash1(i*0.1+rp)>0.5?0.5:-0.5)*(asp*iResolution.x*xradius), iResHalf.y+pos.y+(hash1(i*0.1+0.11+rp)-.5)*(iResolution.y*yradius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pxi = floor(fragCoord.y * iResolution.x + fragCoord.x - 1.);\n    if (fragCoord.y > 2.5) discard;\n\n    int frame= iFrame;\n    if (readKeyToggle(KEY_ENTER)) frame += int(pxi*0.25);\n\n    iResHalf = iResolution.xy * 0.5;\n    vec2 v0 = vec2(0.);\n    vec2 v1 = vec2((iResHalf.x*0.5) * (((frame/(NOF_SEQ_STEPS*NOF_ANIMS))&1)==1?1.:-1.), 0.);\n\n    vec2 sp=v0, ep=v0;\n    int animIndex = (frame / NOF_SEQ_STEPS) % NOF_ANIMS;\n    switch(animIndex) {\n        case 0:\n            sp = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            ep = circle(pxi, 0.1, 0.1,  40.5, 1., v0);\n            break;\n        case 1:\n            sp = circle(pxi, 0.1, 0.1,  4.5, 1., v0);\n            ep = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            break;\n        case 2:\n            sp = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            ep = circle(pxi, 0.0, 0.35,  125.5, 1., v1);\n            break;\n        case 3:\n            sp = circle(pxi, 0.0, 0.35,  125.5, 1., v1);\n            ep = circle(pxi, 0.65, 0.25,  1., 1., v0); \n            break;\n        case 4:\n            sp = circle(pxi, 0.65, 0.25,  1., 1., v0); \n            ep = randbox(pxi, 0.7, 0.7,  0., v0);\n            break;\n        case 5:\n            sp = randbox(pxi, 0.7, 0.7,  0., v0);\n            ep = circle(pxi, 0.2, 0.2,  3., 3., v0); \n            break;\n        case 6:\n            sp = circle(pxi, 0.2, 0.2,  3., 3., v0); \n            ep = boxr(pxi, 1.7, 0.8,  0.17, v0);\n            break;\n        case 7:\n            sp = boxr(pxi, 1.7, 0.8,  0.17, v0);\n            ep = circle(pxi, 0.2, 0.2,  3., 4., v0); \n            break;\n        case 8:\n            sp = circle(pxi, 0.2, 0.2,  3., 4., v0); \n            ep = circle(pxi, 0.4, 0.4,  1., 1., v0); \n            break;\n    }\n\n    float FNS = float(NOF_STEPS);\n\n#ifdef SMOOTH_TRANSITION\n    float lpsm =  min(1., float(frame % NOF_SEQ_STEPS) / FNS);\n    vec2 fp = sp + ((ep-sp)/FNS) * smoothstep(0.,1.,lpsm)*FNS;\n#else\n    vec2 fp = sp + ((ep-sp)/FNS) * min(FNS, float(frame % NOF_SEQ_STEPS));\n#endif\n\tfragColor = vec4(fp, 0.,0.);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int NOF_DOTS = 950;\nconst int NOF_STEPS = 100;\nconst int NOF_WAIT_STEPS = 8;\nconst int NOF_SEQ_STEPS = NOF_STEPS + NOF_WAIT_STEPS;\nconst int NOF_ANIMS = 9;\n\nconst int NOF_REGIONS = 9;\nconst int BPC = NOF_REGIONS * NOF_REGIONS /4 + 1;\n\n#define SMOOTH_TRANSITION\n\n//#define LARGE_DOTS\n\nconst float PI = 3.14159265359;\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_D     = 68;\n\n#define readKeyToggle(key) (texelFetch( iChannel3, ivec2(key, 2), 0).x > .5)\n", "buffer_b_code": "//check which regions have dots\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 2.5) discard;\n    \n    if (ivec2(0,0)==ivec2(fragCoord)) {\n\n        int xd=int(iResolution.x) / NOF_REGIONS + 1;\n        int yd=int(iResolution.y) / NOF_REGIONS + 1;\n        ivec2 r = ivec2(textureSize(iChannel0, 0));\n\n        ivec4 regions = ivec4(0);\n        for (int i=0; i<NOF_DOTS; i++) {\n            ivec2 p=ivec2(i%r.x,i/r.x); \n            vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n            \n            int xr=int(px.x) / xd;\n            int yr=int(px.y) / yd;\n            int reg = xr + yr * NOF_REGIONS;\n            int cp = reg / BPC;\n            int bp = reg % BPC;\n            regions[cp] |= (1<<bp);\n        }\n        fragColor = vec4(regions);\n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0 );\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// draw dots in place and fade old ones\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    bool alt = !readKeyToggle(KEY_SPACE);\n    float val = max(0.,texelFetch(iChannel1, ivec2(fragCoord), 0 ).x - (alt? 0.02 : 0.25));\n\n    vec4 regions = texelFetch(iChannel0, ivec2(0,0), 0 ); \n    int xd=int(iResolution.x) / NOF_REGIONS + 1;\n    int xr=int(fragCoord.x) / xd;\n    int yd=int(iResolution.y) / NOF_REGIONS + 1;\n    int yr=int(fragCoord.y) / yd;\n    int reg = xr + yr * NOF_REGIONS;\n    int cp = reg / BPC;\n    int bp = reg % BPC;\n    if ((int(regions[cp]) & (1<<bp)) == 0) {\n        fragColor = vec4(min(1.,val));\n        if (readKeyToggle(KEY_D)) fragColor = vec4(0.5); // see skipped regions\n        return;\n    }\n\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    float hitadd = alt? 0.33 : 1.0;\n\n    for (int i=1; i<=NOF_DOTS; i++) {\n        ivec2 p=ivec2(i%r.x,i/r.x); \n        vec2 px = texelFetch(iChannel0, p, 0 ).xy;\n#ifdef LARGE_DOTS\n        if (distance(px,fragCoord) < 3.0) {\n#else\n        if (ivec2(px) == ivec2(fragCoord)) {\n#endif\n            val += hitadd; hitadd=0.;\n            // break; // slows things down, a lot...\n        }\n    }\n\tfragColor = vec4(min(1.,val));\n}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3BzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 412]], "test": "untested"}
{"id": "ds3fDM", "name": "XPBD Rope", "author": "beans_please", "description": "Finally implemented XPBD!\nWatch this amazing video: https://youtube.com/watch?v=jrociOAYqxA\n\n* Drag to move the tail\n\n* Long ish compile time (22 seconds for me), so be patient\n\n* Does not work well on my phone, presumably because of 16-bit floats.", "tags": ["2d", "simulation", "solver", "physics", "rope", "xpbd"], "likes": 14, "viewed": 278, "published": 3, "date": "1697312887", "time_retrieved": "2024-07-30T17:28:17.717217", "image_code": "void mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // Don't display the bottom row\n    if (frag_coord.y < 1.)\n    {\n        frag_col = vec4(0);\n        return;\n    }\n\n    // Output buffer A\n    vec3 col = texelFetch(iChannel0, ivec2(frag_coord), 0).xyz;\n    col = pow(col, vec3(1. / 2.2));\n    frag_col = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Particle\nstruct particle_t\n{\n    vec2 pos;\n    vec2 pos_prev;\n    vec2 vel;\n    float inv_mass;\n    bool no_gravity;\n};\n\n// Constants\nconst float eps = .0001;\nconst float damp = .4;\nconst float rest_dist = .11;\n\n// Particles\nconst int n_particles = 10;\nparticle_t p[n_particles];\n\n// UV stuff\nfloat px2uv;\nvec2 screen_to_uv(vec2 coord)\n{\n    return px2uv * (coord - .5 * iResolution.xy);\n}\n\nbool is_initializing()\n{\n    return iFrame < 2 || iTime < .02;\n}\n\nvoid load_particles()\n{\n    for (int i = 0; i < n_particles; i++)\n    {\n        vec4 data = texelFetch(iChannel0, ivec2(i, 0), 0);\n        p[i].pos = data.xy;\n        p[i].vel = data.zw;\n        p[i].inv_mass = (i == 0 ? 0. : 1.);\n        p[i].no_gravity = (i == 0);\n    }\n}\n\nvoid output_particle(in particle_t p, out vec4 frag_col)\n{\n    frag_col = vec4(p.pos, p.vel);\n}\n\nconst int n_constraints = n_particles;\nfloat constraint_err(int constraint_idx, out float inv_stiffness)\n{\n    // Distance constraints\n    if (constraint_idx < (n_particles - 1))\n    {\n        inv_stiffness = 1. / 1000.;\n        return distance(\n            p[constraint_idx].pos,\n            p[constraint_idx + 1].pos\n        ) - rest_dist;\n    }\n    // Mouse constraint\n    else if (constraint_idx == (n_particles - 1))\n    {\n        inv_stiffness = 1. / 100.;\n        \n        if (iMouse.z < .5)\n            return 0.;\n        \n        vec2 uv_mouse = screen_to_uv(iMouse.xy);\n        return distance(uv_mouse, p[n_particles - 1].pos);\n    }\n    return 0.;\n}\n\nfloat constraint_err(int constraint_idx)\n{\n    float useless;\n    return constraint_err(constraint_idx, useless);\n}\n\nvec2 constraint_err_grad(int constraint_idx, int particle_idx)\n{\n    // Base constraint error without any modifications\n    float base_err = constraint_err(constraint_idx);\n    \n    // Make a copy of the particle's position\n    vec2 base_pos = p[particle_idx].pos;\n    \n    // Nudge the particle slightly in the X axis, then,\n    // re-evaluate the constraint error, and take the\n    // difference of the new error and the base error.\n    p[particle_idx].pos = base_pos + vec2(eps, 0);\n    float grad_x = constraint_err(constraint_idx) - base_err;\n    \n    // Same as above, with the Y axis\n    p[particle_idx].pos = base_pos + vec2(0, eps);\n    float grad_y = constraint_err(constraint_idx) - base_err;\n    \n    // Reset the particle's position\n    p[particle_idx].pos = base_pos;\n    \n    // Return the gradient\n    return vec2(grad_x, grad_y) / eps;\n}\n\nvoid solve_constraints(float dt)\n{\n    for (int constraint_idx = 0; constraint_idx < n_constraints; constraint_idx++)\n    {\n        // Calculate lambda\n        float inv_stiffness;\n        float numer = -constraint_err(constraint_idx, inv_stiffness);\n        float denom = inv_stiffness / (dt * dt);\n        for (int i = 0; i < n_particles; i++)\n        {\n            denom += p[i].inv_mass * len_sqr(\n                constraint_err_grad(constraint_idx, i)\n            );\n        }\n        if (denom == 0.) continue;\n        float lambda = numer / denom;\n        \n        // Update the particles\n        for (int i = 0; i < n_particles; i++)\n        {\n            p[i].pos +=\n                lambda\n                * p[i].inv_mass\n                * constraint_err_grad(constraint_idx, i);\n        }\n    }\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    // Slope and intercept\n    float temp = b.x - a.x;\n    if (temp == 0.) temp = 1e-9;\n    float slope = (b.y - a.y) / temp;\n    float intercept = a.y - slope * a.x;\n    \n    // Should we use the endpoints or the line?\n    if (min(dot(p - a, b - a), dot(p - b, a - b)) < 0.)\n    {\n        // Distance from the endpoints\n        return min(distance(p, a), distance(p, b));\n    }\n    else\n    {\n        // Distance from the line\n        return abs(slope * p.x - p.y + intercept) / sqrt(slope * slope + 1.);\n    }\n}\n\nvoid mainImage(out vec4 frag_col, in vec2 frag_coord)\n{\n    // UV (2D world position of the current pixel)\n    px2uv = 2. / min(iResolution.x, iResolution.y);\n    vec2 uv = screen_to_uv(frag_coord);\n    \n    // Get the current values from the last frame\n    load_particles();\n    \n    // Use the bottom row for data and simulation\n    if (frag_coord.y < 1.)\n    {\n        int curr_idx = int(floor(frag_coord.x));\n        \n        if (curr_idx >= n_particles)\n            return;\n\n        // Initial values\n        if (is_initializing())\n        {\n            particle_t p;\n            p.pos = vec2(\n                float(curr_idx) * rest_dist,\n                .72\n            );\n            p.vel = vec2(0);\n            output_particle(p, frag_col);\n            \n            return;\n        }\n\n        // Delta time\n        float actual_dt = min(iTimeDelta, .02);\n\n        // Substeps\n        const int n_steps = 50;\n        float dt = actual_dt / float(n_steps);\n\n        // Step forward\n        for (int i = 0; i < n_steps; i++)\n        {\n            // Iterate through the particles\n            for (int j = 0; j < n_particles; j++)\n            {\n                // Gravity\n                const vec2 gravity = vec2(0, -9.81);\n                if (!p[j].no_gravity)\n                    p[j].vel += dt * gravity;\n                \n                // Dampen velocity\n                p[j].vel *= exp(-damp * dt);\n                \n                // Make a backup of the position\n                p[j].pos_prev = p[j].pos;\n                \n                // Position\n                p[j].pos += dt * p[j].vel;\n            }\n            \n            // Solve constraints\n            solve_constraints(dt);\n            \n            // Update the velocities\n            for (int j = 0; j < n_particles; j++)\n            {\n                p[j].vel = (p[j].pos - p[j].pos_prev) / dt;\n            }\n        }\n\n        // Output\n        output_particle(p[curr_idx], frag_col);\n\n        return;\n    }\n    \n    // Background color\n    vec3 col = vec3(0, .02, .07);\n    \n    // Don't render anything while initializing\n    if (is_initializing())\n    {\n        frag_col = vec4(col, 1);\n        return;\n    }\n\n    // Draw line segments connecting the particles\n    {\n        float min_dist = 1e9;\n        for (int i = 0; i < (n_particles - 1); i++)\n        {\n            min_dist = min(min_dist, sd_segment(uv, p[i].pos, p[i + 1].pos));\n        }\n        \n        const float thickness = .01;\n        col = mix(\n            col,\n            vec3(1),\n            .25 * remap01(min_dist, thickness, thickness - px2uv)\n        );\n    }\n\n    // Draw dots on the particles\n    {\n        float min_dist = 1e9;\n        for (int i = 0; i < n_particles; i++)\n        {\n            min_dist = min(min_dist, dist_sqr(uv, p[i].pos));\n        }\n        min_dist = sqrt(min_dist);\n        \n        const float radius = .03;\n        col = mix(\n            col,\n            vec3(1, .75, .1),\n            remap01(min_dist, radius, radius - px2uv)\n        );\n    }\n\n    frag_col = vec4(col, 1);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*_________________ Math Utils ________________*/\n\n#define PI 3.1415926535897932384626433832\n#define TAU 6.283185307179586476925286766\n#define PI_OVER_2 1.57079632679489661923132169163\n\n#define FUNC_LERP(T) \\\nT lerp(T a, T b, float t) \\\n{ \\\n    return a + t*(b-a); \\\n}\n\n#define FUNC_WRAP(T) \\\nT wrap(T inp, float start, float end) \\\n{ \\\n    return start + mod(inp - start, end - start); \\\n}\n\n#define FUNC_REMAP(T) \\\nT remap(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start); \\\n}\n\n#define FUNC_REMAP_CLAMP(T) \\\nT remap_clamp(T inp, float inp_start, float inp_end, float out_start, float out_end) \\\n{ \\\n    T t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n    return out_start + t * (out_end - out_start); \\\n}\n\n#define FUNC_REMAP01(T) \\\nT remap01(T inp, float inp_start, float inp_end) \\\n{ \\\n    return clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0); \\\n}\n\n#define FUNC_LEN_SQR(T) \\\nfloat len_sqr(T inp) \\\n{ \\\n    return dot(inp, inp); \\\n}\n\n#define FUNC_DIST_SQR(T) \\\nfloat dist_sqr(T a, T b) \\\n{ \\\n    a -= b; \\\n    return dot(a, a); \\\n}\n\nFUNC_LERP(float)\nFUNC_LERP(vec2)\nFUNC_LERP(vec3)\nFUNC_LERP(vec4)\n\nFUNC_WRAP(float)\nFUNC_WRAP(vec2)\nFUNC_WRAP(vec3)\nFUNC_WRAP(vec4)\n\nFUNC_REMAP(float)\nFUNC_REMAP(vec2)\nFUNC_REMAP(vec3)\nFUNC_REMAP(vec4)\n\nFUNC_REMAP_CLAMP(float)\nFUNC_REMAP_CLAMP(vec2)\nFUNC_REMAP_CLAMP(vec3)\nFUNC_REMAP_CLAMP(vec4)\n\nFUNC_REMAP01(float)\nFUNC_REMAP01(vec2)\nFUNC_REMAP01(vec3)\nFUNC_REMAP01(vec4)\n\nFUNC_LEN_SQR(vec2)\nFUNC_LEN_SQR(vec3)\nFUNC_LEN_SQR(vec4)\n\nFUNC_DIST_SQR(vec2)\nFUNC_DIST_SQR(vec3)\nFUNC_DIST_SQR(vec4)\n\n/*____________________ End ____________________*/\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3fDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 91, 330]], "test": "untested"}
{"id": "DstfRS", "name": "PCGSPH (improved)", "author": "michael0884", "description": "Particle cluster grid smoothed particle hydrodynamics.\nSPACE to zoom. UP to see velocity view.", "tags": ["particle"], "likes": 58, "viewed": 1447, "published": 3, "date": "1697310954", "time_retrieved": "2024-07-30T17:28:18.676651", "image_code": "// Fork of \"Particle clustering (SPH)\" by michael0884. https://shadertoy.com/view/ddcfRB\n// 2023-10-14 18:26:55\n\n// Fork of \"Particle clustering (LIQUID)\" by michael0884. https://shadertoy.com/view/mscBRB\n// 2023-10-14 16:17:15\n\n// Fork of \"Particle clustering (GAS)\" by michael0884. https://shadertoy.com/view/ddcfzS\n// 2023-10-14 15:53:28\n\n// Fork of \"Particle clustering (MD)\" by michael0884. https://shadertoy.com/view/mscfW7\n// 2023-10-14 15:02:57\n\n//By having the initial particle count be way larger than what can fit in the simulation domain, \n//the particles are always splitting, meaning they fill the domain like a gas. \n//Here the effective virtual particle count is in the hundreds of millions.\n//Naturally the mass is conserved exactly, since we are working with uint particle counts per cluster.\n//SPACE to ZOOM in!\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_UP    = 38;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\nvoid ComputeProp(inout float rho, inout vec2 vel, in float prad, in vec2 pos, in Particle p)\n{\n    float d = length(p.pos - pos);\n    float g = smoothstep(prad, 0.0, d) / (prad*prad);\n    float m = g*float(p.mass)/float(initial_particle_density);\n    vel = (rho * vel + p.vel * m) / max(m + rho, 1e-4); \n    rho += m;\n}\n\n\n#define radius 0.75\n#define zoom 0.25\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n\n    float prad = 2.1;\n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n        prad = radius;\n    }\n\n    //pos = floor(pos);\n    //compute the smoothed density\n    float rho = 0.00;\n    vec2 vel = vec2(0.001);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 p = floor(pos) + vec2(i, j);\n        vec4 packed = LOAD(ch0, p);\n        Particle p0, p1;\n        unpackParticles(packed, p, p0, p1);\n\n        //compute the density\n        ComputeProp(rho, vel, prad, pos, p0);\n        ComputeProp(rho, vel, prad, pos, p1);\n    }\n    \n    if(isKeyPressed(KEY_UP))\n    {\n        col.xyz = vec3(0.0);\n        float vel_ang = atan(vel.y, vel.x) / TWO_PI;\n        col.xyz += hsv2rgb(vec3(vel_ang, length(vel), rho));\n    }\n    else\n    {\n        col.xyz = 1.0 - 0.25*vec3(3,2,1)*(0.25*smoothstep(0.2, 0.25, rho) + 2.0*rho);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define surface_tension 1.5\n#define surface_tension_rad 4.0\n#define initial_particle_density 2u\n#define dt 0.6\n#define rest_density 2.0\n#define gravity 0.005\n#define force_k 0.2\n#define force_coef_a -4.0\n#define force_coef_b 0.0\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define viscosity 3.0\n#define boundary_h 5.0\n#define max_velocity (2.0/dt)\n#define cooling 0.0\n\n#define R iResolution.xy\n\n#define GD(x, R) exp(-dot(x/R,x/R))/(R*R)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\nstruct Particle \n{\n    uint mass;\n    vec2 pos;\n    vec2 vel;\n    vec2 force;\n    float density;\n};\n\n//5 bits for shared exponent, 9 bits for each component\nuint packvec3(vec3 v)\n{\n    //get the exponent\n    float maxv = max(abs(v.x), max(abs(v.y), abs(v.z)));\n    int exp = clamp(int(ceil(log2(maxv))), -15, 15);\n    float scale = exp2(-float(exp));\n    vec3 sv = v*scale;\n    sv = round(clamp(sv, -1.0, 1.0) * 255.0);\n    sv = sv + 255.0;\n    uint packed = uint(exp + 15) | (uint(sv.x) << 5) | (uint(sv.y) << 14) | (uint(sv.z) << 23);\n    return packed;\n}\n\nvec3 unpackvec3(uint packed)\n{\n    int exp = int(packed & 0x1Fu) - 15;\n    vec3 sv = vec3((packed >> 5) & 0x1FFu, (packed >> 14) & 0x1FFu, (packed >> 23) & 0x1FFu);\n    vec3 v = (sv - 255.0) / 255.0;\n    v *= exp2(float(exp));\n    return v;\n}\n\nvec4 packParticles(Particle p0, Particle p1, vec2 pos)\n{\n    // 1. Mass\n    uint mass0 = p0.mass; \n    uint mass1 = p1.mass;\n    uint packedMass = (mass0 << 16) | mass1;\n    float massFloat = uintBitsToFloat(packedMass);\n\n    // 2. Position\n    p0.pos -= pos;\n    p1.pos -= pos;\n    \n    uint pos0x = uint(round(clamp(p0.pos.x, 0.0, 1.0) * 255.0)); // Assuming pos range [0, 1] in a cell\n    uint pos0y = uint(round(clamp(p0.pos.y, 0.0, 1.0) * 255.0));\n    uint pos1x = uint(round(clamp(p1.pos.x, 0.0, 1.0) * 255.0));\n    uint pos1y = uint(round(clamp(p1.pos.y, 0.0, 1.0) * 255.0));\n    uint packedPos = (pos0x << 24) | (pos0y << 16) | (pos1x << 8) | pos1y;\n    float posFloat = uintBitsToFloat(packedPos);\n\n    // 3. Velocity\n    uint vel0Packed = packvec3(vec3(p0.vel, 0.0));\n    uint vel1Packed = packvec3(vec3(p1.vel, 0.0));\n\n    float vel0Float = uintBitsToFloat(vel0Packed);\n    float vel1Float = uintBitsToFloat(vel1Packed);\n\n    return vec4(massFloat, posFloat, vel0Float, vel1Float);\n}\n\nvoid unpackParticles(vec4 packed, vec2 pos, out Particle p0, out Particle p1)\n{\n    // 1. Unpack Mass\n    uint packedMass = floatBitsToUint(packed.x);\n    p0.mass = (packedMass >> 16) & 0xFFFFu;\n    p1.mass = packedMass & 0xFFFFu;\n\n    // 2. Unpack Position\n    uint packedPos = floatBitsToUint(packed.y);\n    p0.pos.x = float((packedPos >> 24) & 0xFFu) / 255.0;\n    p0.pos.y = float((packedPos >> 16) & 0xFFu) / 255.0;\n    p1.pos.x = float((packedPos >> 8) & 0xFFu) / 255.0;\n    p1.pos.y = float(packedPos & 0xFFu) / 255.0;\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    // 3. Unpack Velocity\n    uint vel0Packed = floatBitsToUint(packed.z);\n    uint vel1Packed = floatBitsToUint(packed.w);\n    p0.vel = unpackvec3(vel0Packed).xy;\n    p1.vel = unpackvec3(vel1Packed).xy;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec2 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    float hash = fract(sin(p1.pos.x*54352354.5 + p1.pos.y*473594.5));\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec2 pos = p1.pos;\n    vec2 weight = vec2(p1.mass, p2.mass)/float(newMass);\n    vec2 dir = DIR(hash);\n    p2.pos = p1.pos + dir*5e-3;\n    p1.pos = p1.pos - dir*5e-3;\n    p2.vel = p1.vel;\n}\n\n\nfloat border(vec2 p, vec2 iR)\n{\n    float bound = -sdBox(p+0.001 - iR*0.5, iR*vec2(0.49, 0.49)); \n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p, vec2 iR)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, iR)\n           + idx.xyw*border(p + dx.xy, iR)\n           + idx.yzw*border(p + dx.yz, iR)\n           + idx.yxw*border(p + dx.yx, iR);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec2 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    vec2 dvel = incoming.vel - p.vel;\n    float f = force_coef_a*GD(d, 1.5);\n    float irho = float(incoming.mass);\n    float rho = 0.5*(p.density + incoming.density);\n    float pressure = max(rho / rest_density - 1.0,-0.0);\n    float SPH_F = f *  pressure;\n    float F = surface_tension*GD(d, surface_tension_rad);\n    float Friction = viscosity * dot(dir, dvel) * GD(d, 2.5);\n    p.force += force_k * dir * (F + SPH_F + Friction) * irho / rest_density;\n    \n}\n\nvoid IntegrateParticle(inout Particle p, vec2 pos, vec2 iR, vec4 iM)\n{\n    p.force = p.force ;/// max(0.0001, float(p.mass));\n    p.force += vec2(0.0, -gravity); //gravity\n    \n    vec3 BORD = bN(p.pos, iR);\n    p.force += force_boundary * smoothstep(0., boundary_h, -BORD.z) * BORD.xy;\n    \n    p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    if(iM.z > 0.)\n    {\n        vec2 dx = pos - iM.xy;\n        p.force -= force_mouse*dx*GS(dx/force_mouse_rad);\n    }\n        \n    p.vel += p.force * dt;\n    p.pos += cooling * p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0.25, 0.25);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    float irho = float(incoming.mass);\n    float rho = irho*GD(d,2.0);\n    p.density += rho;\n}\n\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            AddDensity(p0, p0_);\n            AddDensity(p0, p1_);\n            AddDensity(p1, p0_);\n            AddDensity(p1, p1_);\n        }\n\n        AddDensity(p0, p1);\n        AddDensity(p0, p0);\n        AddDensity(p1, p0);\n        AddDensity(p1, p1);\n    }\n\n    fragColor = vec4(p0.density, p1.density, 0.0, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = LOAD(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = LOAD(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DstfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[832, 832, 859, 859, 1037], [1091, 1091, 1119, 1119, 1179], [1181, 1181, 1275, 1275, 1500]], "test": "untested"}
{"id": "cddfRS", "name": "Conic sections study", "author": "sig", "description": "Intersection of the plane (through the three control points) and the z-right circular cone on origin (center of screen being xy-origin).", "tags": ["gizmo", "conicsection"], "likes": 1, "viewed": 139, "published": 3, "date": "1697308126", "time_retrieved": "2024-07-30T17:28:19.483494", "image_code": "vec2 expi(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nvec4 tex_gizmo(vec2 p, float R) {\n    if (length(p) > R) { return vec4(0); }\n    return vec4(1, 0, 0, 1);\n}\n\n// maps R -> ]0, 1[\nfloat S(float x) {\n    return 0.5 + 0.5 / exp(-x);\n}\n\nvec4 rgbFromHue(float H) {\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n\n    return clamp(vec4(R, G, B, 1.0), 0.0, 1.0);\n}\n\nvec3 cone(vec2 p) {\n    return vec3(p.x, p.y, length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float R_gizmo = 0.05;\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 dir = normalize(p);\n    \n    // control points\n    vec2 c1 = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 c2 = vec2(0.1, 0.5) + expi(iTime) * 0.3;\n    vec2 c3 = vec2(-1.0, -0.5);\n    \n    // 3d plane through control points projected on z-cone\n    vec3 p0 = cone(c1);\n    vec3 b1 = cone(c2) - p0;\n    vec3 b2 = cone(c3) - p0;\n    vec3 normal = normalize(cross(b1, b2));\n    \n    float d = dot(cone(p), normal) - dot(p0, normal);\n    \n    float w = 0.02; // / abs(dot(normalize(cone(-p)), normalize(normal)));\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime + d + dir.xyx+vec3(0,2,4));\n    //vec4 col = rgbFromHue(0.5 + 0.5*cos(iTime + d1));\n    vec4 col = abs(d) > w ? rgbFromHue(mod(iTime + d, 1.)) : vec4(0);\n    \n    vec4 giz1 = tex_gizmo(p - c1, R_gizmo);\n    vec4 giz2 = tex_gizmo(p - c2, R_gizmo);\n    vec4 giz3 = tex_gizmo(p - c3, R_gizmo);\n\n    // Draw gizmos on top\n    fragColor = mix(mix(mix(col, giz1, giz1.a), giz2, giz2.a), giz3, giz3.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddfRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 67], [69, 69, 102, 102, 176], [178, 198, 216, 216, 250], [252, 252, 278, 278, 449], [451, 451, 470, 470, 510], [512, 512, 569, 569, 1666]], "test": "untested"}
{"id": "cdtBRS", "name": "Focus-directrix study", "author": "sig", "description": "Color representation of \"eccentricity\" of conic sections with given focus point and directrix line.\n\nIf anyone has a good idea how to make all control points mouse-draggable, let me know in the comments!", "tags": ["gizmo", "conicsection"], "likes": 2, "viewed": 142, "published": 3, "date": "1697306370", "time_retrieved": "2024-07-30T17:28:20.373115", "image_code": "vec2 expi(float angle) {\n    return vec2(cos(angle), sin(angle));\n}\n\nvec4 tex_gizmo(vec2 p, float R) {\n    if (length(p) > R) { return vec4(0); }\n    return vec4(1, 0, 0, 1);\n}\n\n// maps R -> ]0, 1[\nfloat S(float x) {\n    return 1. / (1. + exp(-x));\n}\n\nvec4 rgbFromHue(float H) {\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n\n    return clamp(vec4(R, G, B, 1.0), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float R_gizmo = 0.05;\n\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 dir = normalize(p);\n    \n    // control points\n    vec2 c1 = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 c2 = vec2(0.1, 0.5) + expi(iTime) * 0.3;\n    vec2 c3 = vec2(0, -0.5);\n    \n    vec2 linedir = normalize(c1 - c3);\n    vec2 n = vec2(linedir.y, -linedir.x);\n    float d1 = dot(p - c1, n);\n    float d2 = length(p - c2);\n    \n    float ecc = d2 / abs(d1);\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime + d + dir.xyx+vec3(0,2,4));\n    //vec4 col = rgbFromHue(0.5 + 0.5*cos(iTime + d1));\n    vec4 col = mod(15. * S(ecc), 1.) > 0.1 ? vec4(0) : rgbFromHue(mod(-iTime + S(ecc), 1.));\n    \n    vec4 giz1 = tex_gizmo(p - c1, R_gizmo);\n    vec4 giz2 = tex_gizmo(p - c2, R_gizmo);\n    vec4 giz3 = tex_gizmo(p - c3, R_gizmo);\n\n    // Draw gizmos on top\n    fragColor = mix(mix(mix(col, giz1, giz1.a), giz2, giz2.a), giz3, giz3.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 67], [69, 69, 102, 102, 176], [178, 198, 216, 216, 250], [252, 252, 278, 278, 449], [451, 451, 508, 508, 1479]], "test": "untested"}
{"id": "mscfzB", "name": "Water on rocks", "author": "AyoubProgramming", "description": "A simple water shader.", "tags": ["2d", "water"], "likes": 1, "viewed": 151, "published": 3, "date": "1697306359", "time_retrieved": "2024-07-30T17:28:21.434278", "image_code": "// A simple water shader. (c) Ajarus, viktor@ajarus.com.\n//\n// Attribution-ShareAlike CC License.\n\nconst float PI = 3.1415926535897932;\n\n// play with these parameters to custimize the effect\n// ==================================================\n\n//speed\nconst float speed_x = 0.93;\nconst float speed_y = 0.95;\nconst float speed = speed_x * speed_y;\n// refraction\nconst float emboss = 0.870;\nconst float intensity = 34.0;\nconst int steps = 10558;\nconst float frequency = 54.0;\nconst int angle = 11; // better when a prime\n\n// reflection\nconst float delta = 69.1;\nconst float gain = 1000.596589;\nconst float reflectionCutOff = 0.12;\nconst float reflectionIntensity = 2000000000000000.;\n\n// ===================================================\n\n\n  float col(vec2 coord,float time)\n  {\n    float delta_theta = 2.0 * PI / float(angle);\n    float col = 0.1;\n    float theta = 0.2;\n    for (int i = 0; i < steps+1; i++)\n    {\n      vec2 adjc = coord;\n      theta = delta_theta*float(i);\n      adjc.x += cos(theta)*time*speed + time * speed_x;\n      adjc.y -= sin(theta)*time*speed - time * speed_y;\n      col = col + cos( (adjc.x*cos(theta) - adjc.y*sin(theta))*frequency)*intensity;\n    }\n\n    return cos(col);\n  }\n\n//---------- main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*1.3;\n\n    vec2 p = (fragCoord.xy) / iResolution.xy, c1 = p, c2 = p;\n    float cc1 = col(c1,time);\n\n    c2.x += iResolution.x/delta;\n    float dx = emboss*(cc1-col(c2,time))/delta;\n\n    c2.x = p.x;\n    c2.y += iResolution.y/delta;\n    float dy = emboss*(cc1-col(c2,time))/delta;\n\n    c1.x += dx*2.;\n    c1.y = -(c1.y+dy*2.);\n\n    float alpha = 1.+dot(dx,dy)*gain;\n\n    float ddx = dx - reflectionCutOff;\n    float ddy = dy - reflectionCutOff;\n    if (ddx > 0. && ddy > 0.)\n        alpha = pow(alpha, ddx*ddy*reflectionIntensity);\n\n    vec4 col = texture(iChannel0,c1)*(alpha);\n    fragColor = col;\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscfzB.jpg", "access": "api", "license": "other-copyleft", "functions": [[744, 744, 780, 780, 1207], [1228, 1228, 1285, 1285, 1907]], "test": "untested"}
{"id": "ddcfRB", "name": "Particle clustering (SPH)", "author": "michael0884", "description": "Currently the clustering seems to introduce a significant amount of noise. Need to think of how to improve that", "tags": ["particle"], "likes": 27, "viewed": 472, "published": 3, "date": "1697305275", "time_retrieved": "2024-07-30T17:28:22.499430", "image_code": "// Fork of \"Particle clustering (LIQUID)\" by michael0884. https://shadertoy.com/view/mscBRB\n// 2023-10-14 16:17:15\n\n// Fork of \"Particle clustering (GAS)\" by michael0884. https://shadertoy.com/view/ddcfzS\n// 2023-10-14 15:53:28\n\n// Fork of \"Particle clustering (MD)\" by michael0884. https://shadertoy.com/view/mscfW7\n// 2023-10-14 15:02:57\n\n//By having the initial particle count be way larger than what can fit in the simulation domain, \n//the particles are always splitting, meaning they fill the domain like a gas. \n//Here the effective virtual particle count is in the hundreds of millions.\n//Naturally the mass is conserved exactly, since we are working with uint particle counts per cluster.\n//SPACE to ZOOM in!\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.25\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    float prad = 2.1;\n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n        prad = radius;\n    }\n\n\n    //compute the smoothed density\n    float rho = 0.00;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 p = floor(pos) + vec2(i, j);\n        vec4 packed = LOAD(ch0, p);\n        Particle p0, p1;\n        unpackParticles(packed, p, p0, p1);\n\n        //compute the density\n        rho += float(p0.mass)*smoothstep(prad, prad*0.01, length(p0.pos - pos))/(prad*prad)/float(initial_particle_density);\n        rho += float(p1.mass)*smoothstep(prad, prad*0.01, length(p1.pos - pos))/(prad*prad)/float(initial_particle_density);\n    }\n\n    col.xyz = 1.0 - 0.5*vec3(3,2,1)*rho;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define surface_tension 0.75\n#define surface_tension_rad 4.0\n#define initial_particle_density 5u\n#define dt 0.6\n#define rest_density 5.0\n#define gravity 0.005\n#define force_k 0.2\n#define force_coef_a -4.0\n#define force_coef_b 0.0\n#define force_mouse 0.005\n#define force_mouse_rad 40.0\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 2.0\n#define cooling 1.5\n\n#define R iResolution.xy\n\n#define GD(x, R) exp(-dot(x/R,x/R))/(R*R)\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\nstruct Particle \n{\n    uint mass;\n    vec2 pos;\n    vec2 vel;\n    vec2 force;\n    float density;\n};\n\nvec4 packParticles(Particle p0, Particle p1, vec2 pos)\n{\n    // 1. Mass\n    uint mass0 = p0.mass; \n    uint mass1 = p1.mass;\n    uint packedMass = (mass0 << 16) | mass1;\n    float massFloat = uintBitsToFloat(packedMass);\n\n    // 2. Position\n    p0.pos -= pos;\n    p1.pos -= pos;\n    \n    uint pos0x = uint(round(clamp(p0.pos.x, 0.0, 1.0) * 255.0)); // Assuming pos range [0, 1] in a cell\n    uint pos0y = uint(round(clamp(p0.pos.y, 0.0, 1.0) * 255.0));\n    uint pos1x = uint(round(clamp(p1.pos.x, 0.0, 1.0) * 255.0));\n    uint pos1y = uint(round(clamp(p1.pos.y, 0.0, 1.0) * 255.0));\n    uint packedPos = (pos0x << 24) | (pos0y << 16) | (pos1x << 8) | pos1y;\n    float posFloat = uintBitsToFloat(packedPos);\n\n    // 3. Velocity\n    p0.vel /= 2.0;\n    p1.vel /= 2.0;\n    \n    uint vel0Packed = packSnorm2x16(p0.vel);\n    uint vel1Packed = packSnorm2x16(p1.vel);\n\n    float vel0Float = uintBitsToFloat(vel0Packed);\n    float vel1Float = uintBitsToFloat(vel1Packed);\n\n    return vec4(massFloat, posFloat, vel0Float, vel1Float);\n}\n\nvoid unpackParticles(vec4 packed, vec2 pos, out Particle p0, out Particle p1)\n{\n    // 1. Unpack Mass\n    uint packedMass = floatBitsToUint(packed.x);\n    p0.mass = (packedMass >> 16) & 0xFFFFu;\n    p1.mass = packedMass & 0xFFFFu;\n\n    // 2. Unpack Position\n    uint packedPos = floatBitsToUint(packed.y);\n    p0.pos.x = float((packedPos >> 24) & 0xFFu) / 255.0;\n    p0.pos.y = float((packedPos >> 16) & 0xFFu) / 255.0;\n    p1.pos.x = float((packedPos >> 8) & 0xFFu) / 255.0;\n    p1.pos.y = float(packedPos & 0xFFu) / 255.0;\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    // 3. Unpack Velocity\n    uint vel0Packed = floatBitsToUint(packed.z);\n    uint vel1Packed = floatBitsToUint(packed.w);\n    p0.vel = unpackSnorm2x16(vel0Packed);\n    p1.vel = unpackSnorm2x16(vel1Packed);\n    \n    p0.vel *= 2.0;\n    p1.vel *= 2.0;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.01*float(p1.mass) || float(p1.mass) < 0.01*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec2 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    float hash = fract(sin(p1.pos.x*54352354.5 + p1.pos.y*473594.5));\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec2 pos = p1.pos;\n    vec2 weight = vec2(p1.mass, p2.mass)/float(newMass);\n    vec2 dir = DIR(hash);\n    p2.pos = p1.pos + dir*1e-1;\n    p1.pos = p1.pos - dir*1e-1;\n    p2.vel = p1.vel;\n}\n\n\nfloat border(vec2 p, vec2 iR)\n{\n    float bound = -sdBox(p+0.001 - iR*0.5, iR*vec2(0.49, 0.49)); \n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p, vec2 iR)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, iR)\n           + idx.xyw*border(p + dx.xy, iR)\n           + idx.yzw*border(p + dx.yz, iR)\n           + idx.yxw*border(p + dx.yx, iR);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec2 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    float f = force_coef_a*GD(d, 1.5);\n    float irho = float(incoming.mass);\n    float rho = 0.5*(p.density + incoming.density);\n    float pressure = max(rho / rest_density - 1.0,-0.0);\n    float SPH_F = f *  pressure;\n    float F = surface_tension*GD(d, surface_tension_rad);\n    p.force += force_k * dir * (F + SPH_F) * irho / rest_density;\n    \n}\n\nvoid IntegrateParticle(inout Particle p, vec2 pos, vec2 iR, vec4 iM)\n{\n    p.force = p.force ;/// max(0.0001, float(p.mass));\n    p.force += vec2(0.0, -gravity); //gravity\n    \n    vec3 BORD = bN(p.pos, iR);\n    p.force += force_boundary * smoothstep(0., boundary_h, -BORD.z) * BORD.xy;\n    \n    p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/force_mouse_rad);\n \n    if(iM.z > 0.)\n    {\n        vec2 dx = pos - iM.xy;\n        p.force -= force_mouse*dx*GS(dx/30.);\n    }\n        \n    p.vel += p.force * dt;\n    p.pos += cooling * p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0.25, 0.25);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void AddDensity(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    float irho = float(incoming.mass);\n    float rho = irho*GD(d,1.25);\n    p.density += rho;\n}\n\n\n//compute particle SPH densities\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            AddDensity(p0, p0_);\n            AddDensity(p0, p1_);\n            AddDensity(p1, p0_);\n            AddDensity(p1, p1_);\n        }\n\n        AddDensity(p0, p1);\n        AddDensity(p0, p0);\n        AddDensity(p1, p0);\n        AddDensity(p1, p1);\n    }\n\n    fragColor = vec4(p0.density, p1.density, 0.0, 0.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    //load density\n    vec2 densities = LOAD(ch1, pos).xy;\n    p0.density = densities.x;\n    p1.density = densities.y;\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n            \n            vec2 densities_ = LOAD(ch1, pos1).xy;\n            p0_.density = densities_.x;\n            p1_.density = densities_.y;\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[719, 719, 746, 746, 924], [952, 952, 980, 980, 1040]], "test": "untested"}
{"id": "mscBRB", "name": "Particle clustering (LIQUID)", "author": "michael0884", "description": "Here I'm computing the pressure from the particle mass. Ofc this results in a LOT of noise, so ideally I would instead be using a smoothing kernel like in SPH.", "tags": ["particle"], "likes": 12, "viewed": 336, "published": 3, "date": "1697299733", "time_retrieved": "2024-07-30T17:28:24.182929", "image_code": "// Fork of \"Particle clustering (GAS)\" by michael0884. https://shadertoy.com/view/ddcfzS\n// 2023-10-14 15:53:28\n\n// Fork of \"Particle clustering (MD)\" by michael0884. https://shadertoy.com/view/mscfW7\n// 2023-10-14 15:02:57\n\n//By having the initial particle count be way larger than what can fit in the simulation domain, \n//the particles are always splitting, meaning they fill the domain like a gas. \n//Here the effective virtual particle count is in the hundreds of millions.\n//Naturally the mass is conserved exactly, since we are working with uint particle counts per cluster.\n//SPACE to ZOOM in!\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    float prad = 2.1;\n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n        prad = radius;\n    }\n\n\n    //compute the smoothed density\n    float rho = 0.00;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 p = floor(pos) + vec2(i, j);\n        vec4 packed = LOAD(ch0, p);\n        Particle p0, p1;\n        unpackParticles(packed, p, p0, p1);\n\n        //compute the density\n        rho += float(p0.mass)*smoothstep(prad, prad*0.5, length(p0.pos - pos))/(prad*prad)/float(initial_particle_density);\n        rho += float(p1.mass)*smoothstep(prad, prad*0.5, length(p1.pos - pos))/(prad*prad)/float(initial_particle_density);\n    }\n\n    col.xyz = 0.25*vec3(1,2,3)*rho;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define initial_particle_density 1024u\n#define dt 0.6\n#define rest_density 512.0\n#define gravity 0.001\n#define force_k 0.05\n#define force_coef_a -4.0\n#define force_coef_b 0.0\n#define force_mouse 0.0025\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 2.0\n#define cooling 3.5\n\n#define R iResolution.xy\n\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\nstruct Particle \n{\n    uint mass;\n    vec2 pos;\n    vec2 vel;\n    vec2 force;\n};\n\nvec4 packParticles(Particle p0, Particle p1, vec2 pos)\n{\n    // 1. Mass\n    uint mass0 = p0.mass; \n    uint mass1 = p1.mass;\n    uint packedMass = (mass0 << 16) | mass1;\n    float massFloat = uintBitsToFloat(packedMass);\n\n    // 2. Position\n    p0.pos -= pos;\n    p1.pos -= pos;\n    \n    uint pos0x = uint(round(clamp(p0.pos.x, 0.0, 1.0) * 255.0)); // Assuming pos range [0, 1] in a cell\n    uint pos0y = uint(round(clamp(p0.pos.y, 0.0, 1.0) * 255.0));\n    uint pos1x = uint(round(clamp(p1.pos.x, 0.0, 1.0) * 255.0));\n    uint pos1y = uint(round(clamp(p1.pos.y, 0.0, 1.0) * 255.0));\n    uint packedPos = (pos0x << 24) | (pos0y << 16) | (pos1x << 8) | pos1y;\n    float posFloat = uintBitsToFloat(packedPos);\n\n    // 3. Velocity\n    p0.vel /= 2.0;\n    p1.vel /= 2.0;\n    \n    uint vel0Packed = packSnorm2x16(p0.vel);\n    uint vel1Packed = packSnorm2x16(p1.vel);\n\n    float vel0Float = uintBitsToFloat(vel0Packed);\n    float vel1Float = uintBitsToFloat(vel1Packed);\n\n    return vec4(massFloat, posFloat, vel0Float, vel1Float);\n}\n\nvoid unpackParticles(vec4 packed, vec2 pos, out Particle p0, out Particle p1)\n{\n    // 1. Unpack Mass\n    uint packedMass = floatBitsToUint(packed.x);\n    p0.mass = (packedMass >> 16) & 0xFFFFu;\n    p1.mass = packedMass & 0xFFFFu;\n\n    // 2. Unpack Position\n    uint packedPos = floatBitsToUint(packed.y);\n    p0.pos.x = float((packedPos >> 24) & 0xFFu) / 255.0;\n    p0.pos.y = float((packedPos >> 16) & 0xFFu) / 255.0;\n    p1.pos.x = float((packedPos >> 8) & 0xFFu) / 255.0;\n    p1.pos.y = float(packedPos & 0xFFu) / 255.0;\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    // 3. Unpack Velocity\n    uint vel0Packed = floatBitsToUint(packed.z);\n    uint vel1Packed = floatBitsToUint(packed.w);\n    p0.vel = unpackSnorm2x16(vel0Packed);\n    p1.vel = unpackSnorm2x16(vel1Packed);\n    \n    p0.vel *= 2.0;\n    p1.vel *= 2.0;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.8*float(p1.mass) || float(p1.mass) < 0.8*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 1 : 0;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec2 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    float hash = fract(sin(p1.pos.x*54352354.5 + p1.pos.y*473594.5));\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec2 pos = p1.pos;\n    vec2 weight = vec2(p1.mass, p2.mass)/float(newMass);\n    vec2 dir = DIR(hash);\n    p2.pos = p1.pos + dir*1e-2;\n    p1.pos = p1.pos - dir*1e-2;\n    p2.vel = p1.vel;\n}\n\n\nfloat border(vec2 p, vec2 iR)\n{\n    float bound = -sdBox(p+0.001 - iR*0.5, iR*vec2(0.49, 0.49)); \n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p, vec2 iR)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, iR)\n           + idx.xyw*border(p + dx.xy, iR)\n           + idx.yzw*border(p + dx.yz, iR)\n           + idx.yxw*border(p + dx.yx, iR);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec2 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    float f = clamp(force_coef_a*exp(-d*d*1.0)+force_coef_b*exp(-d*d*0.3), -0.5, 0.5);\n    float irho = float(incoming.mass);\n    float rho = 0.5*(irho + float(p.mass));\n    float pressure = clamp(rho / rest_density - 1.0, -1.0, 1.0);\n    vec2 F = force_k * f * dir * pressure * irho / rest_density;\n    p.force += F;\n    \n}\n\nvoid IntegrateParticle(inout Particle p, vec2 pos, vec2 iR, vec4 iM)\n{\n    p.force = p.force ;/// max(0.0001, float(p.mass));\n    p.force += vec2(0.0, -gravity); //gravity\n    \n    vec3 BORD = bN(p.pos, iR);\n    p.force += force_boundary * smoothstep(0., boundary_h, -BORD.z) * BORD.xy;\n    \n    p.force += vec2(0.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/30.);\n \n    if(iM.z > 0.)\n    {\n        vec2 dx = pos - iM.xy;\n        p.force -= force_mouse*dx*GS(dx/30.);\n    }\n        \n    p.vel += p.force * dt;\n    p.pos += cooling * p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = initial_particle_density;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0.25, 0.25);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = initial_particle_density;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0., 0.);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n\n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[603, 603, 630, 630, 808], [836, 836, 864, 864, 924]], "test": "untested"}
{"id": "ddcfzS", "name": "Particle clustering (GAS)", "author": "michael0884", "description": "By having the initial particle count be way larger than what can fit in the simulation domain, the particles are always splitting, meaning they fill the domain like a gas. Here the effective virtual particle count is in the hundreds of millions.", "tags": ["particle"], "likes": 22, "viewed": 550, "published": 3, "date": "1697297115", "time_retrieved": "2024-07-30T17:28:27.492081", "image_code": "// Fork of \"Particle clustering (MD)\" by michael0884. https://shadertoy.com/view/mscfW7\n// 2023-10-14 15:02:57\n\n//By having the initial particle count be way larger than what can fit in the simulation domain, \n//the particles are always splitting, meaning they fill the domain like a gas. \n//Here the effective virtual particle count is in the hundreds of millions.\n//Naturally the mass is conserved exactly, since we are working with uint particle counts per cluster.\n//SPACE to ZOOM in!\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.0\n#define zoom 0.3\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    float prad = 2.1;\n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n        prad = radius;\n    }\n\n\n    //compute the smoothed density\n    float rho = 0.00;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 p = floor(pos) + vec2(i, j);\n        vec4 packed = LOAD(ch0, p);\n        Particle p0, p1;\n        unpackParticles(packed, p, p0, p1);\n\n        //compute the density\n        rho += float(p0.mass)*smoothstep(prad, prad*0.5, length(p0.pos - pos))/(prad*prad)/float(initial_particle_density);\n        rho += float(p1.mass)*smoothstep(prad, prad*0.5, length(p1.pos - pos))/(prad*prad)/float(initial_particle_density);\n    }\n\n    col.xyz = 0.25*vec3(1,2,3)*rho;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define initial_particle_density 1024u\n#define dt 0.6\n#define gravity 0.00\n#define force_k 0.1\n#define force_coef_a -4.0\n#define force_coef_b 0.0\n#define force_mouse 0.0025\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 2.0\n#define cooling 3.5\n\n#define R iResolution.xy\n\n#define GS(x) exp(-dot(x,x))\n#define DIR(phi) vec2(cos(TWO_PI*phi),sin(TWO_PI*phi))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\nstruct Particle \n{\n    uint mass;\n    vec2 pos;\n    vec2 vel;\n    vec2 force;\n};\n\nvec4 packParticles(Particle p0, Particle p1, vec2 pos)\n{\n    // 1. Mass\n    uint mass0 = p0.mass; \n    uint mass1 = p1.mass;\n    uint packedMass = (mass0 << 16) | mass1;\n    float massFloat = uintBitsToFloat(packedMass);\n\n    // 2. Position\n    p0.pos -= pos;\n    p1.pos -= pos;\n    \n    uint pos0x = uint(round(clamp(p0.pos.x, 0.0, 1.0) * 255.0)); // Assuming pos range [0, 1] in a cell\n    uint pos0y = uint(round(clamp(p0.pos.y, 0.0, 1.0) * 255.0));\n    uint pos1x = uint(round(clamp(p1.pos.x, 0.0, 1.0) * 255.0));\n    uint pos1y = uint(round(clamp(p1.pos.y, 0.0, 1.0) * 255.0));\n    uint packedPos = (pos0x << 24) | (pos0y << 16) | (pos1x << 8) | pos1y;\n    float posFloat = uintBitsToFloat(packedPos);\n\n    // 3. Velocity\n    p0.vel /= 2.0;\n    p1.vel /= 2.0;\n    \n    uint vel0Packed = packSnorm2x16(p0.vel);\n    uint vel1Packed = packSnorm2x16(p1.vel);\n\n    float vel0Float = uintBitsToFloat(vel0Packed);\n    float vel1Float = uintBitsToFloat(vel1Packed);\n\n    return vec4(massFloat, posFloat, vel0Float, vel1Float);\n}\n\nvoid unpackParticles(vec4 packed, vec2 pos, out Particle p0, out Particle p1)\n{\n    // 1. Unpack Mass\n    uint packedMass = floatBitsToUint(packed.x);\n    p0.mass = (packedMass >> 16) & 0xFFFFu;\n    p1.mass = packedMass & 0xFFFFu;\n\n    // 2. Unpack Position\n    uint packedPos = floatBitsToUint(packed.y);\n    p0.pos.x = float((packedPos >> 24) & 0xFFu) / 255.0;\n    p0.pos.y = float((packedPos >> 16) & 0xFFu) / 255.0;\n    p1.pos.x = float((packedPos >> 8) & 0xFFu) / 255.0;\n    p1.pos.y = float(packedPos & 0xFFu) / 255.0;\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    // 3. Unpack Velocity\n    uint vel0Packed = floatBitsToUint(packed.z);\n    uint vel1Packed = floatBitsToUint(packed.w);\n    p0.vel = unpackSnorm2x16(vel0Packed);\n    p1.vel = unpackSnorm2x16(vel1Packed);\n    \n    p0.vel *= 2.0;\n    p1.vel *= 2.0;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.1*float(p1.mass) || float(p1.mass) < 0.1*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec2 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    float hash = fract(sin(p1.pos.x*54352354.5 + p1.pos.y*473594.5));\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec2 pos = p1.pos;\n    vec2 weight = vec2(p1.mass, p2.mass)/float(newMass);\n    vec2 dir = DIR(hash);\n    p2.pos = p1.pos + dir*1e-2;\n    p1.pos = p1.pos - dir*1e-2;\n    p2.vel = p1.vel;\n}\n\n\nfloat border(vec2 p, vec2 iR)\n{\n    float bound = -sdBox(p+0.001 - iR*0.5, iR*vec2(0.49, 0.49)); \n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p, vec2 iR)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, iR)\n           + idx.xyw*border(p + dx.xy, iR)\n           + idx.yzw*border(p + dx.yz, iR)\n           + idx.yxw*border(p + dx.yx, iR);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec2 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    float f = clamp(force_coef_a*exp(-d*d*0.6)+force_coef_b*exp(-d*d*0.3), -0.5, 0.5);\n    vec2 F = force_k * f * dir * float(incoming.mass);\n    p.force += F;\n    \n}\n\nvoid IntegrateParticle(inout Particle p, vec2 pos, vec2 iR, vec4 iM)\n{\n    p.force = p.force / max(0.0001, float(p.mass));\n    p.force += vec2(0.0, -gravity); //gravity\n    \n    vec3 BORD = bN(p.pos, iR);\n    p.force += force_boundary * smoothstep(0., boundary_h, -BORD.z) * BORD.xy;\n    \n    p.force += vec2(1.0, 0.0)*GS(distance(p.pos, iR*vec2(0.2,0.5))/30.);\n \n    if(iM.z > 0.)\n    {\n        vec2 dx = pos - iM.xy;\n        p.force -= force_mouse*dx*GS(dx/30.);\n    }\n        \n    p.vel += p.force * dt;\n    p.pos += cooling * p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = initial_particle_density;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0.25, 0.25);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = initial_particle_density;\n            p1.mass = initial_particle_density;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0., 0.);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n\n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcfzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 490, 517, 517, 695], [723, 723, 751, 751, 811]], "test": "untested"}
{"id": "sdBfWw", "name": "Nine Point Conic and Circle", "author": "mla", "description": "More delights of projective geometry: the eleven point conic, but with defining line at infinity, so only nine finite points. This conic then becomes a circle when one red point is at the orthocentre of the others. Use mouse to drag red and yellow points.", "tags": ["conic", "projective", "ninepoint"], "likes": 12, "viewed": 192, "published": 3, "date": "1697292291", "time_retrieved": "2024-07-30T17:28:28.657964", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Nine Point Conic and Circle. mla, 2023.\n//\n// Take 4 points (red, one with a cross) and the 6 lines (yellow) through\n// pairs of points, forming a complete quadrangle.\n//\n// There are 3 diagonal points where the line through two points meets\n// the line through the other two points (cyan).\n//\n// Given a line l, here the line at infinity, the six quadrangle lines\n// meet l in six points and each point has a harmonic conjugate with\n// the two points of the quadrangle on the same line (green), since\n// l is at infinity, these are the midpoints of the sides.\n//\n// The three diagonal points and the six harmonic points, all lie on\n// a conic, the nine point conic (white).\n//\n// The four points of the quadrangle define a pencil of conics through\n// those points & the pencil contains three degenerate conics composed\n// of two lines (in fact two from the six diagonals of the quadrangle).\n// Furthermore, if one point of the quadrangle, p0 say, is at the \n// orthocentre of the triangle formed by the other points p1-p3, then \n// the 3 degenerate members of the pencil are orthogonal lines, and in\n// fact every member of the pencil is a rectangular hyperbola (ie. \n// has orthogonal asymptotes). In this case, the nine point conic passes\n// through the feet of the altitudes as well as the midpoints, and \n// it becomes the familiar nine point circle.\n//\n// In the shader, position the three plain red points and the yellow point\n// as desired, then move the red point with the cross to the orthocentre,\n// also a cross. At this point, the white conic becomes a circle and the\n// grey asymptotes of the blue hyperbola become orthogonal.\n//\n// Use mouse to drag red and yellow points.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint configuration = 2;\n\nfloat lwidth = 0.007;\nfloat pwidth = 0.03;\n\nconst vec3 pcolor0 = vec3(1,0,0);\nconst vec3 pcolor1 = vec3(0,1,0);\nconst vec3 pcolor2 = vec3(1,1,0);\nconst vec3 pcolor3 = vec3(0,1,1);\nconst vec3 pcolor4 = pcolor1;\nconst vec3 lcolor0 = pcolor0;\nconst vec3 lcolor1 = pcolor1;\nconst vec3 lcolor2 = vec3(1,1,0.2);\nconst vec3 ccolor0 = vec3(1,1,1);\nconst vec3 ccolor1 = vec3(0,0,1);\nconst vec3 ccolor2 = vec3(0.5,0.5,1);\n\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic(float A, float B, float C,\n               out float x1, out float x2) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   if (B < 0.0) D = -D;\n   x1 = (-B-D)/A;\n   x2 = C/(A*x1);\n   return true;\n}\n\n// Return either intersection of lines p and q\n// or line through points p and q, r = kp + jq\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Find a projective mapping taking p0,p1,p2,p4 to\n// triangle of reference and unit point, ie:\n// p0 -> (1,0,0), p1 -> (0,1,0), p2 -> (0,0,1), p3 -> (1,1,1)\n// No three points collinear.\nmat3 rproject(vec3 p0, vec3 p1, vec3 p2, vec3 p3) {\n  // Just an inverse for the first three points\n  // (the triangle of reference). No inverse if collinear.\n  mat3 m = inverse(mat3(p0,p1,p2)); // column major!\n  p3 = m*p3; \n  // Then scale each row so the unit point (1,1,1) is correct\n  m = transpose(m);\n  // zero components here only if not collinear\n  m[0] /= p3[0];\n  m[1] /= p3[1];\n  m[2] /= p3[2];\n  return transpose(m);\n}\n\n// Represent a projective conic as a 3x3 matrix:\n//\n// M = (a,d,e,\n//      d,b,f,\n//      e,f,c)\n//\n// is: ax² + by² + cz² + 2(dxy + exz + fyz) = 0\n// calculated as pMp for p = (x,y,z).\n//\n// We can treat this as a distance field, scaled by the\n// (x,y) derivative in order to get correct line widths.\n\n// With this representation, the dual conic is just the inverse;\n// if the determinant is zero then there is no dual and the\n// conic is degenerate.\n\n// Construct the conic defined by 5 points.\n// Method taken from \"Geometry\", Brannan, Esplan & Gray, CUP, 2012\nmat3 conic5points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // Now construct a conic through the images of p0-p4,\n  p4 = p*p4;\n  float a = p4.x, b = p4.y, c = p4.z;\n  float d = c*(a-b);\n  float e = b*(c-a);\n  float f = a*(b-c);\n  mat3 m = mat3(0,d,e,\n                d,0,f,\n                e,f,0);\n  // And combine the two.\n  return transpose(p)*m*p;\n}\n\n// Conic through 4 points and tangent to a line - there are 2 solutions,\n// so need to solve quadratic. I'm sure I didn't invent this but\n// can't remember the source.\n// l.p = l'p == l'(MinvM)p = (Minv'l)'Mp\nbool conic4points(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 l4, out mat3 M0, out mat3 M1) {\n  // p takes p0,p1,p2,p3 to triangle of reference and unit point\n  mat3 p = rproject(p0,p1,p2,p3);\n  // and then to the square (1,1),(1,-1),(-1,1),(-1,-1)\n  mat3 q = rproject(vec3(1,-1,1), vec3(-1,1,1),vec3(-1,-1,1),vec3(1,1,1));\n  p = inverse(q)*p; // q is constant\n  // Now construct a conic through the images of p0-p3 and l4\n  l4 = transpose(inverse(p))*l4;\n  float i = l4.x, j = l4.y, k = l4.z;\n  float A = -j*j, B = 0.5*(i*i+j*j-k*k), C = -i*i;\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  M0 = mat3(t0, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t0);\n  M0 = transpose(p)*M0*p;\n  if (isnan(determinant(M0))) return false;\n  M1 = mat3(t1, 0, 0,\n            0, -1, 0,\n            0,  0, 1.0-t1);\n  M1 = transpose(p)*M1*p;\n  if (isnan(determinant(M1))) return false;\n  return true;\n}\n\n// Find the two points of intersection of a line through p0 and\n// p1 with the conic defined by M.\nbool lineconic(vec3 p0, vec3 p1, mat3 M, out vec3 q0, out vec3 q1) {\n  // (tp0 + p1)M(tp0 + p1) == 0\n  float A = dot(p0,M*p0);\n  float B = dot(p0,M*p1);\n  float C = dot(p1,M*p1);\n  float t0,t1;\n  if (!quadratic(A,B,C,t0,t1)) return false;\n  q0 = t0*p0+p1;\n  q1 = t1*p0+p1;\n  return true;\n}\n\n// Find the two points of intersection of the line l\n// with the conic defined by c.\nbool lineconic(vec3 l, mat3 M, out vec3 i0, out vec3 i1) {\n  // Intersect l with two of the axes. This might of course\n  // be the same point (1,0,0) here, so really should check\n  // the third axis too.\n  vec3 p0 = join(l,vec3(0,0,1));\n  vec3 p1 = join(l,vec3(0,1,0));\n  return lineconic(p0,p1,M,i0,i1);\n}\n\n// Harmonic conjugate of p,q and intersection of p,q with l.\nvec3 harmonic(vec3 p, vec3 q, vec3 l) {\n  // kp + jq is conjugate of kp - lq:\n  // l.(kp - jq) = 0\n  // k(l.p) = j(l.q)\n  float k = dot(l,q);\n  float j = dot(l,p);\n  return k*p+j*q;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Drawing functions\n////////////////////////////////////////////////////////////////////////////////\n\nfloat px;\n\n// Just a point\nfloat point(vec3 pos, vec3 p) {\n  //if (abs(p.z) < 1e-4) return 0.0;\n  pos /= pos.z; p /= p.z; // Normalize\n  float dist = distance(pos,p);\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(-px,px,dist-pwidth);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\n// A point drawn with a cross.\nfloat point2(vec3 pos, vec3 p) {\n  pos /= pos.z; p /= p.z; // Normalize\n  float t = 0.707*pwidth;\n  float d = segment(pos.xy,p.xy+vec2(t,t),p.xy-vec2(t,t));\n  d = min(d,segment(pos.xy,p.xy+vec2(-t,t),p.xy-vec2(-t,t)));\n  if (isnan(d)) return 0.0;\n  return 1.0-smoothstep(-px,px,d-0.5*lwidth);\n}\n\nfloat line(vec3 pos, vec3 l) {\n  float dist = dot(pos,l)/(pos.z*length(l.xy));\n  if (isnan(dist)) return 0.0;\n  return 1.0-smoothstep(-px,px,abs(dist)-lwidth);\n}\n\nfloat conic(vec3 pos, mat3 m) {\n  float dist = dot(pos,m*pos);   // Distance from the conic\n  vec3 grad = m*pos*2.0;         // The gradient uses the same matrix.\n  dist /= pos.z*length(grad.xy); // Normalize for Euclidean distance\n  if (isinf(dist)) return 0.0;\n  return 1.0-smoothstep(-px,px,abs(dist)-lwidth);\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(vec3 p) {\n  float t = 0.5*iTime;\n  p.x *= 1.0+0.5*sin(t);\n  p.y *= 1.0+0.3*sin(0.618*t);\n  p.xy = rotate(p.xy,0.2*t);\n  //p.yz = rotate(p.yz,0.1*t);\n  return p;\n}\n\nvec3 cmix(vec3 color0, vec3 color1, float level) {\n  return mix(color0,color1,0.95*level);\n}\n\nvec2 orthocentre(vec2 p, vec2 q, vec2 r) {\n  p -= r; q -= r;\n  float a = dot(p,q), b = dot(p,p), c = dot(q,q);\n  // (p-h).q = 0 = (q-h).p and h = up+vq\n  // gives linear system\n  vec2 uv = inverse(mat2(a,b,c,a))*vec2(a);\n  return mat2(p,q)*uv+r;\n}\n\n// Find asymptotes of conic, ie. tangents at\n// intersection with line at infinity.\n// Derived from a simplification of the equation,\n// putting z = 0.\nbool asymptotes(mat3 s, out vec3 a0, out vec3 a1) {\n  // Solve quadratic to find (real) intersections\n  // with line at infinity, then take tangents.\n  // Should really check for a = 0 (and b = 0)\n  float a = s[0][0], b = s[1][1], d = s[0][1];\n  float t = d*d-a*b;\n  if (t < 0.0) return false;\n  t = sqrt(t);\n  a0 = s*vec3((-d+t)/a,1,0);\n  a1 = s*vec3((-d-t)/a,1,0);\n  return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  setscale();\n  vec3 pos = vec3(map(fragCoord.xy),1);\n  px = fwidth(pos.x);\n  // p0-p3 are the quadrangle\n  vec3 p0 = vec3(getselection(0),1), p1 = vec3(getselection(1),1);\n  vec3 p2 = vec3(getselection(2),1), p3 = vec3(getselection(3),1);\n  vec3 p4 = vec3(getselection(4),1); // Arbitrary point on pencilconic\n  vec3 h = vec3(orthocentre(p1.xy,p2.xy,p3.xy),1);\n  vec3 l4 = vec3(0,0,1); // line at infinity\n  // pencilconic is a typical conic in the pencil through p0-p3.\n  mat3 pencilconic = conic5points(p0,p1,p2,p3,p4);\n  \n  vec3 l01 = join(p0,p1);\n  vec3 l02 = join(p0,p2);\n  vec3 l03 = join(p0,p3);\n  vec3 l12 = join(p1,p2);\n  vec3 l13 = join(p1,p3);\n  vec3 l23 = join(p2,p3);\n\n  // diagonal points\n  vec3 d0 = join(l01,l23);\n  vec3 d1 = join(l02,l13);\n  vec3 d2 = join(l03,l12);\n\n  // harmonic points\n  vec3 h01 = harmonic(p0,p1,l4);\n  vec3 h02 = harmonic(p0,p2,l4);\n  vec3 h03 = harmonic(p0,p3,l4);\n  vec3 h12 = harmonic(p1,p2,l4);\n  vec3 h13 = harmonic(p1,p3,l4);\n  vec3 h23 = harmonic(p2,p3,l4);\n\n  // conics\n  mat3 ninepoint = conic5points(d0,d1,d2,h01,h23);\n#if 0\n  // Not needed for now\n  mat3 M1,M2;\n  bool doM1M2 = doM1M2 = conic4points(p0,p1,p2,p3,l4,M1,M2); // Don't need these\n  vec3 i0,i1;\n  bool doN = lineconic(l4,elevenpoint,i0,i1);\n#endif\n\n  vec3 tex = texture(iChannel1,0.5*fragCoord/iResolution.y).xyz;\n  vec3 color = 0.1*tex;\n  float t = lwidth*0.5*length(tex);\n  lwidth += t;\n  pwidth += t;\n  \n  // The diagonal lines of the quadrangle\n  color = cmix(color,lcolor2,line(pos,l01));\n  color = cmix(color,lcolor2,line(pos,l02));\n  color = cmix(color,lcolor2,line(pos,l03));\n  color = cmix(color,lcolor2,line(pos,l12));\n  color = cmix(color,lcolor2,line(pos,l13));\n  color = cmix(color,lcolor2,line(pos,l23));\n\n  // The moving line\n  //color = cmix(color,lcolor0,line(pos,l4));\n  \n  // The conics\n  color = cmix(color,ccolor0,conic(pos,ninepoint));\n  color = cmix(color,ccolor1,conic(pos,pencilconic));\n  vec3 a0, a1;\n  if (asymptotes(pencilconic,a0,a1)) {\n    color = cmix(color,vec3(0.5),line(pos,a0));\n    color = cmix(color,vec3(0.5),line(pos,a1));\n    color = cmix(color,vec3(1),point(pos,join(a0,a1)));\n  }\n#if 0\n  if (doM1M2) {\n    color = cmix(color,ccolor2,conic(pos,M1));\n    color = cmix(color,ccolor2,conic(pos,M2));\n  }\n#endif\n\n  // The midpoints of the sides of the quadrangle\n  color = cmix(color,pcolor1,point(pos,h01));\n  color = cmix(color,pcolor1,point(pos,h02));\n  color = cmix(color,pcolor1,point(pos,h03));\n  color = cmix(color,pcolor1,point(pos,h12));\n  color = cmix(color,pcolor1,point(pos,h13));\n  color = cmix(color,pcolor1,point(pos,h23));\n\n  // Vertices of the diagonal triangle\n  color = cmix(color,pcolor3,point(pos,d0));\n  color = cmix(color,pcolor3,point(pos,d1));\n  color = cmix(color,pcolor3,point(pos,d2));\n\n  // The six conjugates on each diagonal\n  color = cmix(color,pcolor4,point(pos,join(l01,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l02,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l03,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l12,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l13,l4)));\n  color = cmix(color,pcolor4,point(pos,join(l23,l4)));\n  \n  // The points of the quadrangle\n  color = cmix(color,pcolor0,point(pos,p0));\n  color = cmix(color,pcolor0,point(pos,p1));\n  color = cmix(color,pcolor0,point(pos,p2));\n  color = cmix(color,pcolor0,point(pos,p3));\n  color = cmix(color,pcolor2,point(pos,p4));\n  \n  // Draw a cross at the orthocentre and at p0\n  color = cmix(color,vec3(1),point2(pos,h));\n  color = cmix(color,vec3(1),point2(pos,p0));\n  fragColor = vec4(pow(1.0*color,vec3(0.4545)),1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\nfloat scale = 1.2;\n\n#define nselections 5\n\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0,0);\n  if (i == 1) return vec2(-0.5,1);\n  if (i == 2) return vec2(-1,-1);\n  if (i == 3) return vec2(1.5,-0.5);\n  if (i == 4) return vec2(1.4,0.6);\n  if (i == 5) return vec2(0.5);\n  return vec2(0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2297, 2325, 2411, 2411, 2559], [2561, 2655, 2682, 2682, 2705], [2707, 2895, 2946, 3053, 3326], [3784, 3895, 3959, 4024, 4353], [4355, 4564, 4654, 4719, 5466], [5468, 5567, 5635, 5667, 5856], [5858, 5943, 6001, 6146, 6249], [6251, 6312, 6351, 6431, 6495], [6692, 6708, 6739, 6776, 6925], [6927, 6927, 6966, 6966, 7067], [7069, 7100, 7132, 7132, 7394], [7396, 7396, 7426, 7426, 7557], [7559, 7559, 7590, 7590, 7873], [7875, 7973, 8009, 8009, 8061], [8063, 8063, 8087, 8087, 8240], [8242, 8242, 8292, 8292, 8334], [8336, 8336, 8378, 8378, 8583], [8585, 8737, 8788, 8933, 9120], [9122, 9122, 9179, 9179, 12771]], "test": "untested"}
{"id": "Dd3fzS", "name": "Fork AI oleg304", "author": "oleg304", "description": "forked from  https://www.shadertoy.com/view/ctd3Rl", "tags": ["2d", "heart"], "likes": 7, "viewed": 192, "published": 3, "date": "1697283285", "time_retrieved": "2024-07-30T17:28:29.654300", "image_code": "// CC0: AI not included\n// Tinkering around with old shaders.\n// No AI and very little human intelligence used ;)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.58;\nconst vec3 dbcol = HSV2RGB(vec3(hoff+0.96, 0.8, 0.75));\nconst vec3 sbcol = HSV2RGB(vec3(hoff+0.95, 0.4, 1.0));\nconst vec3 gbcol = HSV2RGB(vec3(hoff+0.98, 0.9, 0.001));\nconst vec3 fbcol = HSV2RGB(vec3(hoff+0.95, 0.7, 2.0));\n\n// License: Unknown, author: Claude Brezinski, found: https://mathr.co.uk/blog/2017-09-06_approximating_hyperbolic_tangent.html\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat dot2(vec2 p) {\n  return dot(p, p);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  p.x = pabs(p.x, 0.05);\n\n  if( p.y+p.x>1.0 )\n      return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                  dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat df(vec2 p) {\n  vec2 hp = p;\n  const float hz = 1.0;\n  hp /= hz;\n  hp.y -= -0.6;\n  float d = heart(hp)*hz;\n  return d;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float h = (-20.0*d);\n  h = tanh_approx(h);\n  h -= 3.0*length(p);\n  h = pmin(h, 0.0, 1.);\n  h *= 0.25;\n  return h;\n}\n\nvec3 nf(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = hf(p + e.yx) - hf(p - e.yx);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  float f = (aggr * 0.5) + 0.5;\n  \n  return f;\n}\n\nfloat divf(float offset, float f) {\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  float r = abs(goff + offset - f);\n  r = max(r, gfloor);\n  return r;\n}\n\n// This way of computing \"lightning\" I found at shadertoy. Unfortunately I don't remember where.\nvec3 lightning(vec2 pos, vec2 pp, float offset) {\n  vec3 sub = 0.03*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n\n  float time = TIME+123.4;\n  float stime = time/200.0;\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*cos(vec2(sqrt(0.5), 1.0)*stime)+vec2(0.0, -11.0)*stime;\n  const float glow = 0.0125;\n  const float goff = 0.2;\n  const float gfloor = 0.001;\n  for (float i = 0.0; i < 3.0; ++i) {\n    vec3 gcol0 = (1.0+cos(0.50*vec3(0.0, 1.0, 2.0) +time+3.0*pos.x-0.33*i));\n    vec3 gcol1 = (1.0+cos(1.25*vec3(0.0, 1.0, 2.0) +2.*time+pos.y+0.25*i));\n    float btime = stime*85.0 + (i);\n    float rtime = stime*75.0 + (i);\n    float div1 = divf(offset, fbm((pos + f) * 3.0, rtime));\n    float div2 = divf(offset, fbm((pos + f) * 2.0, btime));\n    float d1 = offset * glow / div1;\n    float d2 = offset * glow / div2;\n    col += (d1 * gcol0)-sub;\n    col += (d2 * gcol1)-sub;\n  }\n    \n  return col;\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 4.0/RESOLUTION.y;\n  float d = df(p)*-5.;  \n  float gd = d+0.0;\n  vec2 gp = p;\n  vec3 gcol = lightning(gp, pp, gd);  \n  vec3 col = vec3(0.0);\n  col = vec3(.9,.0,.0);\n  col = mix(vec3(0), col, d);\n  col += gcol;  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, pp); \n  fragColor = vec4(col.xyz, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3fzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 425, 425, 571], [1115, 1243, 1271, 1337, 1413], [1415, 1522, 1548, 1548, 1733], [1735, 1835, 1874, 1874, 1959], [1961, 2049, 2079, 2079, 2107], [2109, 2109, 2129, 2129, 2151], [2153, 2271, 2292, 2292, 2509], [2511, 2511, 2529, 2529, 2636], [2638, 2638, 2656, 2656, 2793], [2795, 2795, 2812, 2812, 3002], [3004, 3004, 3023, 3023, 3146], [3148, 3148, 3169, 3169, 3596], [3598, 3598, 3629, 3629, 3990], [3992, 3992, 4027, 4027, 4155], [4157, 4254, 4303, 4303, 5134], [5136, 5136, 5166, 5166, 5407], [5409, 5409, 5464, 5464, 5641]], "test": "untested"}
{"id": "mstBD7", "name": "1 sample Bi-linear 3D noise tex", "author": "El_Sargo", "description": "Store noise in a 3D texture and sample it once!", "tags": ["3d", "cloud", "texture", "volumetric"], "likes": 1, "viewed": 208, "published": 3, "date": "1697276897", "time_retrieved": "2024-07-30T17:28:30.937868", "image_code": "// Read 3D noise values with filtering and only one texture lookup!\n// This is achieved through spliting the buffer into slices\n// and storing three layers in each slice.\n// The red and alpha channels are shared across slice boundaries\n// to allow linear interpolation without a second lookup\n//\n// Noise code is from https://www.shadertoy.com/view/mtjfzW\n// which is what i'm hoping to imporve on.\n// \n// Change settings in common\nvoid mainImage( out vec4 O, in vec2 I ) {\n    vec2 uv = I/iResolution.y;\n    float horizontal_slices = floor( iResolution.x / SIZE );\n    #if 1\n    //uv *= 0.15;\n    vec3 p = vec3(uv.x,iTime*0.1,uv.y);\n    float V=0.,W=0.,s=1.,a=1.,k=0.;\n    float vs = 0.5;\n    int m = int(uv.x*3.)+1;\n    for (int i=0;i<m;i++){\n        if (uv.y < 1./3.) {\n            W += a*sample_tex(\n                p*s,\n                iChannel0,\n                horizontal_slices,\n                iResolution.xy\n            );\n            V += a;\n        } else if (uv.y < 2./3.){\n            V += a*t3x(iChannel1,p*s*vs).x;\n            W += a;\n        } else {\n                W += a*sample_tex(\n                p*s,\n                iChannel0,\n                horizontal_slices,\n                iResolution.xy\n            );\n            V += a*t3x(iChannel1,p*s*vs).x;\n        }\n        k+=a;s*=2.;a*=0.5;\n    }\n    O = vec4(sqrt( (V*(W))/k) );\n    #else\n    vec4 data = texture(iChannel0,uv);\n    //vec3 p = vec3(fc_to_slice_coord(I),0.);\n    //float v = PeriodicalCellularNoise(p,4.,vec3(1.));\n    O = vec4(sqrt(data.rrrr));\n    #endif\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, in vec2 I ) {\n    vec2 uv = I/iResolution.xy;\n    if (iFrame==0){\n        float horizontal_slices = floor( iResolution.x / SIZE );\n        float vertical_slices = floor( iResolution.y / SIZE );\n        vec2 slice_coord = fc_to_slice_coord(I);\n        slice_coord -= 1./SIZE;\n        slice_coord /= SIZE/(SIZE+2.0);\n        float slice_base_layer = id_to_slice_layer(fc_to_slice_id(I),horizontal_slices);\n        vec3 repetition = vec3(1.0);\n        float r = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer),\n            SCALE,repetition\n         );\n        float g = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+1./SIZE),\n            SCALE,repetition\n         );\n        float b = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+2./SIZE),\n            SCALE,repetition\n         );\n         float a = PeriodicalCellularNoise(\n            vec3(slice_coord,slice_base_layer+3./SIZE),\n            SCALE,repetition\n         );\n            \n        O = vec4( r,g,b,a );\n        \n    } else {\n        O = texture(iChannel0,I/iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ACTUAL_SIZE 64.0\n#define SIZE (ACTUAL_SIZE+2.0)\n#define SCALE 10.\nvec2 layer_to_slice_id( float z_layer, float horizontal_slices ) {\n    z_layer = floor( z_layer / 3.0 );\n    float x_offset = mod( z_layer, horizontal_slices );\n    float y_offset = ( z_layer - x_offset ) / horizontal_slices;\n    return vec2( x_offset, y_offset );\n}\n\nfloat id_to_slice_layer( vec2 slice_id, float horizontal_slices ){\n    return ( slice_id.y * horizontal_slices + slice_id.x ) * 3. /SIZE ;\n}\n\nvec2 fc_to_slice_coord( vec2 fc ) {\n    return mod( fc, SIZE ) / SIZE;\n}\n\nvec4 t3x( sampler3D sam, vec3 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec3 iuv = floor( uv );\n    vec3 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}\n\nvec2 fc_to_slice_id( vec2 fc ) {\n    return ( fc - mod( fc, SIZE ) ) / SIZE;\n}\n\nfloat sample_tex( vec3 p, sampler2D sam, float horizontal_slices, vec2 res) {\n    vec3 s = mod( p, 1.0 );\n    float z = s.y * SIZE;\n    vec2 w = fwidth(p.xz)*2.;\n    s.xz *= SIZE/(SIZE+2.0);\n    s.xz += 1./SIZE;\n    \n    float blend = mod( z, 3.0 );\n    int blend_id = int( blend );\n    float blend_factor = fract( blend );\n    vec2 id = layer_to_slice_id( z, horizontal_slices );\n    vec2 fc = ( id + s.xz ) * SIZE;\n    vec2 uv = fc / res;\n    vec4 data = texture(sam, uv);\n    float a,b;\n    if ( blend_id == 0 ) {\n        a = data.r;\n        b = data.g;\n    } else if ( blend_id == 1 ) {\n        a = data.g;\n        b = data.b;\n        \n    } else if ( blend_id == 2 ) {\n        a = data.b;\n        b = data.a;\n    }\n    return mix(a,b,blend_factor);\n}\n\n/////////////////////////////////////////////////////////\n// Noise                                               //\n/////////////////////////////////////////////////////////\n\n\n#define wrap(x, _min, _max) (_min + mod(_max - _min + mod(x - _min, _max - _min), _max - _min))\n\nfloat Repeat(float t, float len)\n{\n    //return wrap(t, 0., len);\n    return clamp(t - floor(t / len) * len, 0., len);\n}\nvec2 Repeat(vec2 t, vec2 size)\n{\n    return vec2(Repeat(t.x, size.x), Repeat(t.y, size.y));\n}\n\nvec3 Repeat(vec3 t, vec3 size)\n{\n    return vec3(\n        Repeat(t.x, size.x),\n        Repeat(t.y, size.y),\n        Repeat(t.z, size.z)\n    );\n}\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return t;\n}\n\nvec3 NextVec3(inout uint state)\n{\n    float x = NextFloat(state);\n    float y = NextFloat(state);\n    float z = NextFloat(state);\n\n    return vec3(x, y, z);\n}\n\n\n//Convert functions based on https://www.shadertoy.com/view/XddXW7\n\nfloat Convert2DTo1D(vec2 p, vec2 s) \n{\n    //p = Repeat(p, s);\n    p = mod(p, s);\n    return floor(p.y) * s.x + p.x;\n}\n\nvec2 Convert1DTo2D(float p, vec2 size)\n{\n    float x = mod(p, size.x);\n    float y = (p - x) / size.x + 0.5;\n    return vec2(x, y);\n}\n\nfloat Convert3DTo1D(vec3 p, vec3 size)\n{\n    //p = Repeat(p, size);\n    p = mod(p, size);\n    return floor(p.z) * size.x * size.y + floor(p.y) * size.x + p.x;\n}\n\nvec3 Convert1DTo3D(float p, vec3 size)\n{\n    float x = mod(p, size.x);\n    float y = mod((p - x) / size.x, size.y);\n    float z = (p - x - floor(y) * size.x) / (size.x * size.y);\n    return vec3(x, y + 0.5, z + 0.5);\n}\n\n\n//\nfloat PeriodicalCellularNoise(vec3 p, float scale, vec3 size)\n{\n    p *= scale;\n    vec3 mainCell = floor(p);\n\n    float minDist = 999999.;\n\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n    {\n        vec3 cellIndex = mainCell + vec3(x, y, z);\n        \n        vec3 repeatCellIndex = Repeat(cellIndex, size * scale);\n        uint seed = uint(137. + repeatCellIndex.x * 11. + repeatCellIndex.y * 17. + repeatCellIndex.z * 13.);\n        uint state = WangHash(seed);\n        \n        vec3 cellPoint = cellIndex + NextVec3(state);\n        vec3 diff = p - cellPoint;\n        float dist = dot(diff,diff);\n        minDist = min(minDist, dist);\n    }\n\n    return exp(-4.0*minDist);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mstBD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 432, 473, 473, 1546]], "test": "untested"}
{"id": "Ds3fRS", "name": "spqr domain trick 9a", "author": "spqr", "description": "a", "tags": ["a"], "likes": 3, "viewed": 145, "published": 3, "date": "1697275672", "time_retrieved": "2024-07-30T17:28:31.898300", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n   // return max(max(q.x,q.y),q.z);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm( vec2 a)\n{\n    vec3 p = vec3(a,1.);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat surge ( float t){ \n    float i = floor(t);\n    float r = fract(t);\n    r = pow(r,30.);\n    return r + i;\n}\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float ball = box(p, vec3(f1 * (.4 + .1 * sin(surge(iTime/2.)) ) ));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\nfloat map (vec3 p){\n    // geo\n    float pos = p.y+1.;\n\n    for (float i = 1.; i < 8.; i++) {\n        pos = max(pos, -field(p,pow(2.,i)/16.));\n    }\n    \n    return pos;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.0001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\nfloat glider(float t) {\n    float dip_interval = 20.0;\n    float dip_depth = 10.0;\n    \n    // Up and down fluctuating motion\n    float y_sine = 5.0 * sin(0.2 * t);\n    \n    // Time since last dip\n    float time_since_last_dip = mod(t, dip_interval);\n    \n    // Modulating function that drops quickly but recovers slowly\n    float modulating_func = 1.0 - sin(time_since_last_dip + 0.5 * sin(time_since_last_dip));\n    \n    // Gaussian dip function\n    float y_gauss = -dip_depth * exp(-pow((time_since_last_dip - dip_interval / 2.0), 2.0) / (2.0 * pow((dip_interval / 6.0), 2.0)));\n    \n    // Continuously blend the Gaussian and sinusoidal functions, modulated by the new function\n    float h = y_sine + y_gauss * modulating_func;\n    \n    // Scale the output by a factor of 3\n    h /= 3.0;\n    \n    return h;\n}\n\nfloat gliderfbm(float t) {\n  float n = 0.;\n  n += glider(t);\n  n += glider((t+5.12) * 2.)/2.;\n  //n += glider((t+11.42) * 4.)/4.;\n  return n;\n  \n}\nfloat fbmao (vec3 p, vec3 n, float aodist ) {\n    float val = 0.;\n    for (float i = 0.; i < 2.; i++) {\n        val += (getao(p,n,aodist *.2 * pow(1.5,i))* 0.5 + 0.5)/(i+1.);\n    }\n    return +val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime;\n \n  // nav\n\n\n\n  vec3 s = vec3(0.,3.,-6);\n  vec3 t = vec3(0,1.,0);\n  \n  vec3 fwd = vec3(0,0,3) * iTime;\n  \n  s += fwd;\n  t += fwd;\n \n  s += 5. * (lattice(tt) - lattice(tt)/2.);\n  t += 5. * (lattice(tt+.1) - lattice(tt+.1)/2.);\n\n  \n  s += gliderfbm(tt*2.)/2. - gliderfbm(tt*2.)/4.;\n  t += gliderfbm(tt*2. + 11.)/2. - gliderfbm(tt*2.+11.)/4.;\n  \n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <100.; ++z) {\n    i = z;\n    d=abs(map(p));\n    if(d<0.0001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light1 = normalize(vec3(-1));// + t)/2.;//normalize(vec3(5,-5,-1));\n  vec3 light2 = normalize(vec3(2,3,-5));// + t)/2.;//normalize(vec3(5,-5,-1));\n\n  \n  if (dot(n,light1) < 0.) {\n      light1 = -light1;\n  }\n   if (dot(n,light2) < 0.) {\n      light2 = -light2;\n  }\n  \n  \n  vec3 col = vec3(.6)*1.3;\n  float aodist = .4;\n  \n  float fresnel = 1. - dot(n,r);\n  float ao =(getao(p,n,aodist*0.35)*0.5+0.5);\n  //float ao =// fbmao(p,n,aodist *.2);\n  //    (getao(p,n,aodist*.2)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.35)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.5)*0.5+0.5);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff1 = dot(n,light1)*.5+.5;\n  float diff2 = dot(n,light2)*.5+.5;\n \n  float spec1 =pow(max(dot(reflect(-light1,n),-r),0.),1.) * 1.;\n  float spec2 =pow(max(dot(reflect(-light2,n),-r),0.),1.) * 1.;\n  //float iff = pow(1.-i/100.,2.);\n  \n  \n  //col *= diff;\n  col *= ao;\n  col *= (spec1 + spec2)/2.;\n  col *= (diff1 + diff2)/2.;\n // col *= spec2;\n  \n  //col += fresnel;\n  //col *= diff;\n\n  \n \n \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n  //col = vec3(1) * fbm(uv*10.+iTime);\n \n  //col = vec3(1) * fbm(uv*10.);\n  if (length(col) > 1.5) {\n      col = vec3(0);\n  }\n  col = smoothstep(0.,1.,col)*2.;\n  //col = sqrt(col);\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3fRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [950, 950, 973, 973, 1068], [1070, 1070, 1097, 1097, 1179], [1181, 1181, 1209, 1209, 1336], [1338, 1338, 1360, 1360, 1450], [1451, 1451, 1472, 1472, 1763], [1765, 1765, 1785, 1785, 1968], [1969, 1969, 1998, 1998, 2026], [2027, 2027, 2050, 2050, 2139], [2140, 2140, 2175, 2175, 2451], [2452, 2452, 2471, 2482, 2623], [2625, 2625, 2644, 2644, 2765], [2767, 2767, 2787, 2787, 2884], [2886, 2886, 2927, 2927, 2973], [2974, 2974, 2996, 2996, 3053], [3054, 3054, 3078, 3078, 3216], [3218, 3218, 3241, 3241, 4031], [4033, 4033, 4059, 4059, 4179], [4180, 4180, 4225, 4225, 4379], [4381, 4381, 4438, 4438, 6708]], "test": "untested"}
{"id": "ftV3WD", "name": "Voronoi Night Sky", "author": "Zi7ar21", "description": "Idk this is from a while ago, don't trust the code style too much", "tags": ["sky", "night"], "likes": 14, "viewed": 262, "published": 3, "date": "1697264557", "time_retrieved": "2024-07-30T17:28:32.748028", "image_code": "#define fov 1.0\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi = 3.141592653589793;\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n    p4 *= vec4(0.1031, 0.1030, 0.0973, 0.1099);\n    p4  = fract(p4);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    p4  = (p4.xxyz + p4.yzzw) * p4.zywx;\n    p4  = fract(p4);\n    return p4;\n}\n\n//\nfloat voronoi(in vec3 p, out vec3 c)\n{\n    float d = 10.0;\n\n    for(int pos_x = -1; pos_x <= 1; pos_x++) {\n    for(int pos_y = -1; pos_y <= 1; pos_y++) {\n    for(int pos_z = -1; pos_z <= 1; pos_z++) {\n        vec4 h = hash44( vec4(vec3(pos_x, pos_y, pos_z) + floor(p), 0.0) );\n\n        vec3 point = vec3(pos_x, pos_y, pos_z) + h.xyz;\n\n        float t = dot( point - fract(p), point - fract(p) );\n\n        if(t < d)\n        {\n            c = hash44(h.xyzw).rgb;\n        }\n\n        d = min(t, d);\n    }\n    }\n    }\n\n    return d;\n}\n\n//\nfloat gradient_noise(vec3 p, float t)\n{\n    vec3 f = smoothstep( 0.0, 1.0, fract(p) );\n    vec3 i = floor(p);\n\n    float h0 = hash44( vec4(i + vec3(0.0, 0.0, 0.0), t) ).x;\n    float h1 = hash44( vec4(i + vec3(1.0, 0.0, 0.0), t) ).x;\n    float h2 = hash44( vec4(i + vec3(0.0, 1.0, 0.0), t) ).x;\n    float h3 = hash44( vec4(i + vec3(1.0, 1.0, 0.0), t) ).x;\n    float h4 = hash44( vec4(i + vec3(0.0, 0.0, 1.0), t) ).x;\n    float h5 = hash44( vec4(i + vec3(1.0, 0.0, 1.0), t) ).x;\n    float h6 = hash44( vec4(i + vec3(0.0, 1.0, 1.0), t) ).x;\n    float h7 = hash44( vec4(i + vec3(1.0, 1.0, 1.0), t) ).x;\n\n    return mix(mix(mix(h0, h1, f.x), mix(h2, h3, f.x), f.y), mix(mix(h4, h5, f.x), mix(h6, h7, f.x), f.y), f.z);\n}\n\n//\nfloat fbm(vec3 p)\n{\n    float value = 0.0;\n    float accum = 0.0;\n    float atten = 0.5;\n    float scale = 1.0;\n\n    for(int i = 0; i < 8; i++)\n    {\n        value += atten * gradient_noise( scale * p, float(i) );\n        accum += atten;\n        atten *= 0.5;\n        scale *= 2.0;\n    }\n\n    return value / accum;\n}\n\n// https://www.shadertoy.com/view/llSyRD\nvec3 blackbody( float t )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8; // Speed of light\n\n    vec3 w = vec3(610.0, 549.0, 468.0) / 1e9; // sRGB approximate wavelength of primaries\n\n    // This would be more accurate if we integrate over a range of wavelengths\n    // rather than a single wavelength for r, g, b\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n\n    vec3 w5 = w * w * w * w * w;    \n    vec3 o = 2.0 * h * (c * c) / ( w5 * ( exp(h * c / (w * k * t) ) - 1.0) );\n\n    return o;\n}\n\n//\nvec3 sky_color(vec3 dir)\n{\n    const float t = 0.05;\n\n    vec3 c;\n\n    float v = (1.0 / t) * clamp(t - voronoi(80.0 * dir, c), 0.0, 1.0);\n\n    // https://www.shadertoy.com/view/llSyRD\n    vec3 b = 0.4 * clamp(1.0 - exp(-max(blackbody( (300.0 * c.x) + 600.0), 0.0) * 1.0), 0.0, 1.0) + 0.6;\n\n    float n0 = fbm( 3.0 *  dir        );\n    float n1 = fbm( 4.0 * (dir + 1.0) );\n\n    float d0 = 3.0 * (max(n0 - 0.4, 0.0) + 0.07);\n    float d1 = smoothstep( 0.0, 1.0, max(n1 - (4.0 * dir.y * dir.y), 0.0) );\n\n    return ( b * v * d0 * (1.0 - d1) ) + d1;\n}\n\n//\nvec2 rotate(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(\n    vec.x * c - vec.y * s,\n    vec.x * s + vec.y * c\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    vec3 rd = normalize( vec3(rotate(vec2(fov * uv.x, -1.0), 0.03 * pi * iTime), fov * uv.y).xzy );\n\n    fragColor.rgb = sky_color(rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftV3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 193, 215, 215, 399], [401, 404, 442, 442, 933], [935, 938, 977, 977, 1652], [1654, 1657, 1676, 1676, 1973], [1975, 2016, 2043, 2043, 2588], [2590, 2593, 2619, 2619, 3140], [3142, 3145, 3179, 3179, 3296], [3298, 3298, 3355, 3355, 3629]], "test": "untested"}
{"id": "DsdBWM", "name": "Spectral Path-Tracing", "author": "Zi7ar21", "description": "Renders stuff in 3D with SPDs using the CIE 1931 XYZ Color Matching Functions (2-degree observer) and matricies to transform into IEC 61966-2-1:1999 sRGB, along with the EOTF", "tags": ["ray", "traced", "tracer", "path"], "likes": 15, "viewed": 281, "published": 3, "date": "1697250908", "time_retrieved": "2024-07-30T17:28:34.038578", "image_code": "// ##### Spectral Path-Tracing #####\n// Made by Jacob Bingham (Zi7ar21) on October 24, 2023\n// Last Updated on October 24, 2023 at 08:37 Mountain Daylight Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/DsdBWM\n\n// ## About\n// This shader path traces spheres with different Spectral Power Distributions (SPDs) and displays them\n// in IEC 61966-2-1:1999 sRGB (so if your monitor is sRGB calibrated, along with sRGB gamma then this\n// is really what the spectral data would look like, clamped to the sRGB gamut).\n//\n// ## Performance Tips\n// If the shader performs poorly for you (probably integrated graphics users) try\n// changing the defines at the top of the common tab. You can disable the expensive\n// lookup tables.\n//\n// ## List of SPDs\n// - The background is a flat plane with equal-energy reflectance,\n// - The top sphere is an approximate tomato (yes, the fruit) SPD based on a chart I found online\n// - The bottom left sphere is a 445 nm shortpass filter\n// - The middle sphere is a 530 nm bandpass filter\n// - The bottom right sphere is a smooth longpass filter\n//\n// ## Colorimetry Technical Details\n// By default this shader uses a lookup table for the \"CIE 1931 XYZ Colour-Matching Functions, 2-degree observer\"\n// and \"CIE Standard Illuminant D65\", and displays it in IEC 61966-2-1:1999 sRGB with a D65 white point\n// and sRGB gamma (not the same as 2.2! Most displays use 2.2 now but I wanted this to be sRGB-compliant)\n// along with tonemapping and undoing the sRGB transform that happens between Shadertoy and your monitor\n//\n// Buffer C contains the accumulated XYZ data if you want to export renders\n// for evaluation in something like GIMP (use the Shadertoy EXR export in the\n// bottom right of the editor while Buffer C is selected, then open the EXR\n// in GIMP and tag it with a CIE 1931 XYZ color profile)\n//\n// Buffer D contains the untonemapped linear IEC 61966-2-1:1999 sRGB data,\n// same thing with the EXR export thingy\n//\n// In the case of sRGB, beware of negative color values! (this is because the colors are out-of-gamut, can be\n// visualized by uncommenting the dfeine below)\n\n// Highlight sRGB out-of-gamut colors in magenta\n//#define MARK_OUT_OF_GAMUT\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n\n    // render out-of-srgb-gamut pixels as magenta\n    #ifdef MARK_OUT_OF_GAMUT\n    /*\n    if(fragColor.r < 0.0) { fragColor.rgb = vec3(1.0, 0.0, 1.0); return; }\n    if(fragColor.g < 0.0) { fragColor.rgb = vec3(1.0, 0.0, 1.0); return; }\n    if(fragColor.b < 0.0) { fragColor.rgb = vec3(1.0, 0.0, 1.0); return; }\n    if(fragColor.r > 1.0) { fragColor.rgb = vec3(1.0, 0.0, 1.0); return; }\n    if(fragColor.r > 1.0) { fragColor.rgb = vec3(1.0, 0.0, 1.0); return; }\n    if(fragColor.r > 1.0) { fragColor.rgb = vec3(1.0, 0.0, 1.0); return; }\n    */\n    if(any(lessThan(fragColor.rgb,vec3(0)))||any(greaterThan(fragColor.rgb,vec3(1)))) { fragColor.rgb = vec3(1,0,1); return; }\n    #endif\n\n    fragColor.rgb *= 2.0; // exposure\n\n    fragColor.rgb = tanh(fragColor.rgb); // tonemapping\n\n    fragColor.rgb = clamp(fragColor.rgb, 0.0, 1.0); // clamp negative values\n\n    fragColor.rgb = linear_to_srgb(fragColor.rgb); // undo monitor gamma\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Faster, especially on integrated graphics\n// Turn off for exact colorimetry experiments\n//#define USE_CMF_APPROXIMATION\n\n// Use the CIE Standard Illuminant E (equal-energy) instead of D65 Table\n// Faster but results have a different white point than D65!\n//#define USE_STANDARD_ILLUMINANT_E\n\n\n\n#ifndef USE_CMF_APPROXIMATION\n// CIE 1931 XYZ Colour-Matching Functions, 2-degree observer, [360, 830] nanometers with 1 nm step size\nconst vec3[471] cie1931 = vec3[471] (\nvec3(0.000129900000,0.000003917000,0.000606100000),\nvec3(0.000145847000,0.000004393581,0.000680879200),\nvec3(0.000163802100,0.000004929604,0.000765145600),\nvec3(0.000184003700,0.000005532136,0.000860012400),\nvec3(0.000206690200,0.000006208245,0.000966592800),\nvec3(0.000232100000,0.000006965000,0.001086000000),\nvec3(0.000260728000,0.000007813219,0.001220586000),\nvec3(0.000293075000,0.000008767336,0.001372729000),\nvec3(0.000329388000,0.000009839844,0.001543579000),\nvec3(0.000369914000,0.000011043230,0.001734286000),\nvec3(0.000414900000,0.000012390000,0.001946000000),\nvec3(0.000464158700,0.000013886410,0.002177777000),\nvec3(0.000518986000,0.000015557280,0.002435809000),\nvec3(0.000581854000,0.000017442960,0.002731953000),\nvec3(0.000655234700,0.000019583750,0.003078064000),\nvec3(0.000741600000,0.000022020000,0.003486000000),\nvec3(0.000845029600,0.000024839650,0.003975227000),\nvec3(0.000964526800,0.000028041260,0.004540880000),\nvec3(0.001094949000,0.000031531040,0.005158320000),\nvec3(0.001231154000,0.000035215210,0.005802907000),\nvec3(0.001368000000,0.000039000000,0.006450001000),\nvec3(0.001502050000,0.000042826400,0.007083216000),\nvec3(0.001642328000,0.000046914600,0.007745488000),\nvec3(0.001802382000,0.000051589600,0.008501152000),\nvec3(0.001995757000,0.000057176400,0.009414544000),\nvec3(0.002236000000,0.000064000000,0.010549990000),\nvec3(0.002535385000,0.000072344210,0.011965800000),\nvec3(0.002892603000,0.000082212240,0.013655870000),\nvec3(0.003300829000,0.000093508160,0.015588050000),\nvec3(0.003753236000,0.000106136100,0.017730150000),\nvec3(0.004243000000,0.000120000000,0.020050010000),\nvec3(0.004762389000,0.000134984000,0.022511360000),\nvec3(0.005330048000,0.000151492000,0.025202880000),\nvec3(0.005978712000,0.000170208000,0.028279720000),\nvec3(0.006741117000,0.000191816000,0.031897040000),\nvec3(0.007650000000,0.000217000000,0.036210000000),\nvec3(0.008751373000,0.000246906700,0.041437710000),\nvec3(0.010028880000,0.000281240000,0.047503720000),\nvec3(0.011421700000,0.000318520000,0.054119880000),\nvec3(0.012869010000,0.000357266700,0.060998030000),\nvec3(0.014310000000,0.000396000000,0.067850010000),\nvec3(0.015704430000,0.000433714700,0.074486320000),\nvec3(0.017147440000,0.000473024000,0.081361560000),\nvec3(0.018781220000,0.000517876000,0.089153640000),\nvec3(0.020748010000,0.000572218700,0.098540480000),\nvec3(0.023190000000,0.000640000000,0.110200000000),\nvec3(0.026207360000,0.000724560000,0.124613300000),\nvec3(0.029782480000,0.000825500000,0.141701700000),\nvec3(0.033880920000,0.000941160000,0.161303500000),\nvec3(0.038468240000,0.001069880000,0.183256800000),\nvec3(0.043510000000,0.001210000000,0.207400000000),\nvec3(0.048995600000,0.001362091000,0.233692100000),\nvec3(0.055022600000,0.001530752000,0.262611400000),\nvec3(0.061718800000,0.001720368000,0.294774600000),\nvec3(0.069212000000,0.001935323000,0.330798500000),\nvec3(0.077630000000,0.002180000000,0.371300000000),\nvec3(0.086958110000,0.002454800000,0.416209100000),\nvec3(0.097176720000,0.002764000000,0.465464200000),\nvec3(0.108406300000,0.003117800000,0.519694800000),\nvec3(0.120767200000,0.003526400000,0.579530300000),\nvec3(0.134380000000,0.004000000000,0.645600000000),\nvec3(0.149358200000,0.004546240000,0.718483800000),\nvec3(0.165395700000,0.005159320000,0.796713300000),\nvec3(0.181983100000,0.005829280000,0.877845900000),\nvec3(0.198611000000,0.006546160000,0.959439000000),\nvec3(0.214770000000,0.007300000000,1.039050100000),\nvec3(0.230186800000,0.008086507000,1.115367300000),\nvec3(0.244879700000,0.008908720000,1.188497100000),\nvec3(0.258777300000,0.009767680000,1.258123300000),\nvec3(0.271807900000,0.010664430000,1.323929600000),\nvec3(0.283900000000,0.011600000000,1.385600000000),\nvec3(0.294943800000,0.012573170000,1.442635200000),\nvec3(0.304896500000,0.013582720000,1.494803500000),\nvec3(0.313787300000,0.014629680000,1.542190300000),\nvec3(0.321645400000,0.015715090000,1.584880700000),\nvec3(0.328500000000,0.016840000000,1.622960000000),\nvec3(0.334351300000,0.018007360000,1.656404800000),\nvec3(0.339210100000,0.019214480000,1.685295900000),\nvec3(0.343121300000,0.020453920000,1.709874500000),\nvec3(0.346129600000,0.021718240000,1.730382100000),\nvec3(0.348280000000,0.023000000000,1.747060000000),\nvec3(0.349599900000,0.024294610000,1.760044600000),\nvec3(0.350147400000,0.025610240000,1.769623300000),\nvec3(0.350013000000,0.026958570000,1.776263700000),\nvec3(0.349287000000,0.028351250000,1.780433400000),\nvec3(0.348060000000,0.029800000000,1.782600000000),\nvec3(0.346373300000,0.031310830000,1.782968200000),\nvec3(0.344262400000,0.032883680000,1.781699800000),\nvec3(0.341808800000,0.034521120000,1.779198200000),\nvec3(0.339094100000,0.036225710000,1.775867100000),\nvec3(0.336200000000,0.038000000000,1.772110000000),\nvec3(0.333197700000,0.039846670000,1.768258900000),\nvec3(0.330041100000,0.041768000000,1.764039000000),\nvec3(0.326635700000,0.043766000000,1.758943800000),\nvec3(0.322886800000,0.045842670000,1.752466300000),\nvec3(0.318700000000,0.048000000000,1.744100000000),\nvec3(0.314025100000,0.050243680000,1.733559500000),\nvec3(0.308884000000,0.052573040000,1.720858100000),\nvec3(0.303290400000,0.054980560000,1.705936900000),\nvec3(0.297257900000,0.057458720000,1.688737200000),\nvec3(0.290800000000,0.060000000000,1.669200000000),\nvec3(0.283970100000,0.062601970000,1.647528700000),\nvec3(0.276721400000,0.065277520000,1.623412700000),\nvec3(0.268917800000,0.068042080000,1.596022300000),\nvec3(0.260422700000,0.070911090000,1.564528000000),\nvec3(0.251100000000,0.073900000000,1.528100000000),\nvec3(0.240847500000,0.077016000000,1.486111400000),\nvec3(0.229851200000,0.080266400000,1.439521500000),\nvec3(0.218407200000,0.083666800000,1.389879900000),\nvec3(0.206811500000,0.087232800000,1.338736200000),\nvec3(0.195360000000,0.090980000000,1.287640000000),\nvec3(0.184213600000,0.094917550000,1.237422300000),\nvec3(0.173327300000,0.099045840000,1.187824300000),\nvec3(0.162688100000,0.103367400000,1.138761100000),\nvec3(0.152283300000,0.107884600000,1.090148000000),\nvec3(0.142100000000,0.112600000000,1.041900000000),\nvec3(0.132178600000,0.117532000000,0.994197600000),\nvec3(0.122569600000,0.122674400000,0.947347300000),\nvec3(0.113275200000,0.127992800000,0.901453100000),\nvec3(0.104297900000,0.133452800000,0.856619300000),\nvec3(0.095640000000,0.139020000000,0.812950100000),\nvec3(0.087299550000,0.144676400000,0.770517300000),\nvec3(0.079308040000,0.150469300000,0.729444800000),\nvec3(0.071717760000,0.156461900000,0.689913600000),\nvec3(0.064580990000,0.162717700000,0.652104900000),\nvec3(0.057950010000,0.169300000000,0.616200000000),\nvec3(0.051862110000,0.176243100000,0.582328600000),\nvec3(0.046281520000,0.183558100000,0.550416200000),\nvec3(0.041150880000,0.191273500000,0.520337600000),\nvec3(0.036412830000,0.199418000000,0.491967300000),\nvec3(0.032010000000,0.208020000000,0.465180000000),\nvec3(0.027917200000,0.217119900000,0.439924600000),\nvec3(0.024144400000,0.226734500000,0.416183600000),\nvec3(0.020687000000,0.236857100000,0.393882200000),\nvec3(0.017540400000,0.247481200000,0.372945900000),\nvec3(0.014700000000,0.258600000000,0.353300000000),\nvec3(0.012161790000,0.270184900000,0.334857800000),\nvec3(0.009919960000,0.282293900000,0.317552100000),\nvec3(0.007967240000,0.295050500000,0.301337500000),\nvec3(0.006296346000,0.308578000000,0.286168600000),\nvec3(0.004900000000,0.323000000000,0.272000000000),\nvec3(0.003777173000,0.338402100000,0.258817100000),\nvec3(0.002945320000,0.354685800000,0.246483800000),\nvec3(0.002424880000,0.371698600000,0.234771800000),\nvec3(0.002236293000,0.389287500000,0.223453300000),\nvec3(0.002400000000,0.407300000000,0.212300000000),\nvec3(0.002925520000,0.425629900000,0.201169200000),\nvec3(0.003836560000,0.444309600000,0.190119600000),\nvec3(0.005174840000,0.463394400000,0.179225400000),\nvec3(0.006982080000,0.482939500000,0.168560800000),\nvec3(0.009300000000,0.503000000000,0.158200000000),\nvec3(0.012149490000,0.523569300000,0.148138300000),\nvec3(0.015535880000,0.544512000000,0.138375800000),\nvec3(0.019477520000,0.565690000000,0.128994200000),\nvec3(0.023992770000,0.586965300000,0.120075100000),\nvec3(0.029100000000,0.608200000000,0.111700000000),\nvec3(0.034814850000,0.629345600000,0.103904800000),\nvec3(0.041120160000,0.650306800000,0.096667480000),\nvec3(0.047985040000,0.670875200000,0.089982720000),\nvec3(0.055378610000,0.690842400000,0.083845310000),\nvec3(0.063270000000,0.710000000000,0.078249990000),\nvec3(0.071635010000,0.728185200000,0.073208990000),\nvec3(0.080462240000,0.745463600000,0.068678160000),\nvec3(0.089739960000,0.761969400000,0.064567840000),\nvec3(0.099456450000,0.777836800000,0.060788350000),\nvec3(0.109600000000,0.793200000000,0.057250010000),\nvec3(0.120167400000,0.808110400000,0.053904350000),\nvec3(0.131114500000,0.822496200000,0.050746640000),\nvec3(0.142367900000,0.836306800000,0.047752760000),\nvec3(0.153854200000,0.849491600000,0.044898590000),\nvec3(0.165500000000,0.862000000000,0.042160000000),\nvec3(0.177257100000,0.873810800000,0.039507280000),\nvec3(0.189140000000,0.884962400000,0.036935640000),\nvec3(0.201169400000,0.895493600000,0.034458360000),\nvec3(0.213365800000,0.905443200000,0.032088720000),\nvec3(0.225749900000,0.914850100000,0.029840000000),\nvec3(0.238320900000,0.923734800000,0.027711810000),\nvec3(0.251066800000,0.932092400000,0.025694440000),\nvec3(0.263992200000,0.939922600000,0.023787160000),\nvec3(0.277101700000,0.947225200000,0.021989250000),\nvec3(0.290400000000,0.954000000000,0.020300000000),\nvec3(0.303891200000,0.960256100000,0.018718050000),\nvec3(0.317572600000,0.966007400000,0.017240360000),\nvec3(0.331438400000,0.971260600000,0.015863640000),\nvec3(0.345482800000,0.976022500000,0.014584610000),\nvec3(0.359700000000,0.980300000000,0.013400000000),\nvec3(0.374083900000,0.984092400000,0.012307230000),\nvec3(0.388639600000,0.987418200000,0.011301880000),\nvec3(0.403378400000,0.990312800000,0.010377920000),\nvec3(0.418311500000,0.992811600000,0.009529306000),\nvec3(0.433449900000,0.994950100000,0.008749999000),\nvec3(0.448795300000,0.996710800000,0.008035200000),\nvec3(0.464336000000,0.998098300000,0.007381600000),\nvec3(0.480064000000,0.999112000000,0.006785400000),\nvec3(0.495971300000,0.999748200000,0.006242800000),\nvec3(0.512050100000,1.000000000000,0.005749999000),\nvec3(0.528295900000,0.999856700000,0.005303600000),\nvec3(0.544691600000,0.999304600000,0.004899800000),\nvec3(0.561209400000,0.998325500000,0.004534200000),\nvec3(0.577821500000,0.996898700000,0.004202400000),\nvec3(0.594500000000,0.995000000000,0.003900000000),\nvec3(0.611220900000,0.992600500000,0.003623200000),\nvec3(0.627975800000,0.989742600000,0.003370600000),\nvec3(0.644760200000,0.986444400000,0.003141400000),\nvec3(0.661569700000,0.982724100000,0.002934800000),\nvec3(0.678400000000,0.978600000000,0.002749999000),\nvec3(0.695239200000,0.974083700000,0.002585200000),\nvec3(0.712058600000,0.969171200000,0.002438600000),\nvec3(0.728828400000,0.963856800000,0.002309400000),\nvec3(0.745518800000,0.958134900000,0.002196800000),\nvec3(0.762100000000,0.952000000000,0.002100000000),\nvec3(0.778543200000,0.945450400000,0.002017733000),\nvec3(0.794825600000,0.938499200000,0.001948200000),\nvec3(0.810926400000,0.931162800000,0.001889800000),\nvec3(0.826824800000,0.923457600000,0.001840933000),\nvec3(0.842500000000,0.915400000000,0.001800000000),\nvec3(0.857932500000,0.907006400000,0.001766267000),\nvec3(0.873081600000,0.898277200000,0.001737800000),\nvec3(0.887894400000,0.889204800000,0.001711200000),\nvec3(0.902318100000,0.879781600000,0.001683067000),\nvec3(0.916300000000,0.870000000000,0.001650001000),\nvec3(0.929799500000,0.859861300000,0.001610133000),\nvec3(0.942798400000,0.849392000000,0.001564400000),\nvec3(0.955277600000,0.838622000000,0.001513600000),\nvec3(0.967217900000,0.827581300000,0.001458533000),\nvec3(0.978600000000,0.816300000000,0.001400000000),\nvec3(0.989385600000,0.804794700000,0.001336667000),\nvec3(0.999548800000,0.793082000000,0.001270000000),\nvec3(1.009089200000,0.781192000000,0.001205000000),\nvec3(1.018006400000,0.769154700000,0.001146667000),\nvec3(1.026300000000,0.757000000000,0.001100000000),\nvec3(1.033982700000,0.744754100000,0.001068800000),\nvec3(1.040986000000,0.732422400000,0.001049400000),\nvec3(1.047188000000,0.720003600000,0.001035600000),\nvec3(1.052466700000,0.707496500000,0.001021200000),\nvec3(1.056700000000,0.694900000000,0.001000000000),\nvec3(1.059794400000,0.682219200000,0.000968640000),\nvec3(1.061799200000,0.669471600000,0.000929920000),\nvec3(1.062806800000,0.656674400000,0.000886880000),\nvec3(1.062909600000,0.643844800000,0.000842560000),\nvec3(1.062200000000,0.631000000000,0.000800000000),\nvec3(1.060735200000,0.618155500000,0.000760960000),\nvec3(1.058443600000,0.605314400000,0.000723680000),\nvec3(1.055224400000,0.592475600000,0.000685920000),\nvec3(1.050976800000,0.579637900000,0.000645440000),\nvec3(1.045600000000,0.566800000000,0.000600000000),\nvec3(1.039036900000,0.553961100000,0.000547866700),\nvec3(1.031360800000,0.541137200000,0.000491600000),\nvec3(1.022666200000,0.528352800000,0.000435400000),\nvec3(1.013047700000,0.515632300000,0.000383466700),\nvec3(1.002600000000,0.503000000000,0.000340000000),\nvec3(0.991367500000,0.490468800000,0.000307253300),\nvec3(0.979331400000,0.478030400000,0.000283160000),\nvec3(0.966491600000,0.465677600000,0.000265440000),\nvec3(0.952847900000,0.453403200000,0.000251813300),\nvec3(0.938400000000,0.441200000000,0.000240000000),\nvec3(0.923194000000,0.429080000000,0.000229546700),\nvec3(0.907244000000,0.417036000000,0.000220640000),\nvec3(0.890502000000,0.405032000000,0.000211960000),\nvec3(0.872920000000,0.393032000000,0.000202186700),\nvec3(0.854449900000,0.381000000000,0.000190000000),\nvec3(0.835084000000,0.368918400000,0.000174213300),\nvec3(0.814946000000,0.356827200000,0.000155640000),\nvec3(0.794186000000,0.344776800000,0.000135960000),\nvec3(0.772954000000,0.332817600000,0.000116853300),\nvec3(0.751400000000,0.321000000000,0.000100000000),\nvec3(0.729583600000,0.309338100000,0.000086133330),\nvec3(0.707588800000,0.297850400000,0.000074600000),\nvec3(0.685602200000,0.286593600000,0.000065000000),\nvec3(0.663810400000,0.275624500000,0.000056933330),\nvec3(0.642400000000,0.265000000000,0.000049999990),\nvec3(0.621514900000,0.254763200000,0.000044160000),\nvec3(0.601113800000,0.244889600000,0.000039480000),\nvec3(0.581105200000,0.235334400000,0.000035720000),\nvec3(0.561397700000,0.226052800000,0.000032640000),\nvec3(0.541900000000,0.217000000000,0.000030000000),\nvec3(0.522599500000,0.208161600000,0.000027653330),\nvec3(0.503546400000,0.199548800000,0.000025560000),\nvec3(0.484743600000,0.191155200000,0.000023640000),\nvec3(0.466193900000,0.182974400000,0.000021813330),\nvec3(0.447900000000,0.175000000000,0.000020000000),\nvec3(0.429861300000,0.167223500000,0.000018133330),\nvec3(0.412098000000,0.159646400000,0.000016200000),\nvec3(0.394644000000,0.152277600000,0.000014200000),\nvec3(0.377533300000,0.145125900000,0.000012133330),\nvec3(0.360800000000,0.138200000000,0.000010000000),\nvec3(0.344456300000,0.131500300000,0.000007733333),\nvec3(0.328516800000,0.125024800000,0.000005400000),\nvec3(0.313019200000,0.118779200000,0.000003200000),\nvec3(0.298001100000,0.112769100000,0.000001333333),\nvec3(0.283500000000,0.107000000000,0.000000000000),\nvec3(0.269544800000,0.101476200000,0.000000000000),\nvec3(0.256118400000,0.096188640000,0.000000000000),\nvec3(0.243189600000,0.091122960000,0.000000000000),\nvec3(0.230727200000,0.086264850000,0.000000000000),\nvec3(0.218700000000,0.081600000000,0.000000000000),\nvec3(0.207097100000,0.077120640000,0.000000000000),\nvec3(0.195923200000,0.072825520000,0.000000000000),\nvec3(0.185170800000,0.068710080000,0.000000000000),\nvec3(0.174832300000,0.064769760000,0.000000000000),\nvec3(0.164900000000,0.061000000000,0.000000000000),\nvec3(0.155366700000,0.057396210000,0.000000000000),\nvec3(0.146230000000,0.053955040000,0.000000000000),\nvec3(0.137490000000,0.050673760000,0.000000000000),\nvec3(0.129146700000,0.047549650000,0.000000000000),\nvec3(0.121200000000,0.044580000000,0.000000000000),\nvec3(0.113639700000,0.041758720000,0.000000000000),\nvec3(0.106465000000,0.039084960000,0.000000000000),\nvec3(0.099690440000,0.036563840000,0.000000000000),\nvec3(0.093330610000,0.034200480000,0.000000000000),\nvec3(0.087400000000,0.032000000000,0.000000000000),\nvec3(0.081900960000,0.029962610000,0.000000000000),\nvec3(0.076804280000,0.028076640000,0.000000000000),\nvec3(0.072077120000,0.026329360000,0.000000000000),\nvec3(0.067686640000,0.024708050000,0.000000000000),\nvec3(0.063600000000,0.023200000000,0.000000000000),\nvec3(0.059806850000,0.021800770000,0.000000000000),\nvec3(0.056282160000,0.020501120000,0.000000000000),\nvec3(0.052971040000,0.019281080000,0.000000000000),\nvec3(0.049818610000,0.018120690000,0.000000000000),\nvec3(0.046770000000,0.017000000000,0.000000000000),\nvec3(0.043784050000,0.015903790000,0.000000000000),\nvec3(0.040875360000,0.014837180000,0.000000000000),\nvec3(0.038072640000,0.013810680000,0.000000000000),\nvec3(0.035404610000,0.012834780000,0.000000000000),\nvec3(0.032900000000,0.011920000000,0.000000000000),\nvec3(0.030564190000,0.011068310000,0.000000000000),\nvec3(0.028380560000,0.010273390000,0.000000000000),\nvec3(0.026344840000,0.009533311000,0.000000000000),\nvec3(0.024452750000,0.008846157000,0.000000000000),\nvec3(0.022700000000,0.008210000000,0.000000000000),\nvec3(0.021084290000,0.007623781000,0.000000000000),\nvec3(0.019599880000,0.007085424000,0.000000000000),\nvec3(0.018237320000,0.006591476000,0.000000000000),\nvec3(0.016987170000,0.006138485000,0.000000000000),\nvec3(0.015840000000,0.005723000000,0.000000000000),\nvec3(0.014790640000,0.005343059000,0.000000000000),\nvec3(0.013831320000,0.004995796000,0.000000000000),\nvec3(0.012948680000,0.004676404000,0.000000000000),\nvec3(0.012129200000,0.004380075000,0.000000000000),\nvec3(0.011359160000,0.004102000000,0.000000000000),\nvec3(0.010629350000,0.003838453000,0.000000000000),\nvec3(0.009938846000,0.003589099000,0.000000000000),\nvec3(0.009288422000,0.003354219000,0.000000000000),\nvec3(0.008678854000,0.003134093000,0.000000000000),\nvec3(0.008110916000,0.002929000000,0.000000000000),\nvec3(0.007582388000,0.002738139000,0.000000000000),\nvec3(0.007088746000,0.002559876000,0.000000000000),\nvec3(0.006627313000,0.002393244000,0.000000000000),\nvec3(0.006195408000,0.002237275000,0.000000000000),\nvec3(0.005790346000,0.002091000000,0.000000000000),\nvec3(0.005409826000,0.001953587000,0.000000000000),\nvec3(0.005052583000,0.001824580000,0.000000000000),\nvec3(0.004717512000,0.001703580000,0.000000000000),\nvec3(0.004403507000,0.001590187000,0.000000000000),\nvec3(0.004109457000,0.001484000000,0.000000000000),\nvec3(0.003833913000,0.001384496000,0.000000000000),\nvec3(0.003575748000,0.001291268000,0.000000000000),\nvec3(0.003334342000,0.001204092000,0.000000000000),\nvec3(0.003109075000,0.001122744000,0.000000000000),\nvec3(0.002899327000,0.001047000000,0.000000000000),\nvec3(0.002704348000,0.000976589600,0.000000000000),\nvec3(0.002523020000,0.000911108800,0.000000000000),\nvec3(0.002354168000,0.000850133200,0.000000000000),\nvec3(0.002196616000,0.000793238400,0.000000000000),\nvec3(0.002049190000,0.000740000000,0.000000000000),\nvec3(0.001910960000,0.000690082700,0.000000000000),\nvec3(0.001781438000,0.000643310000,0.000000000000),\nvec3(0.001660110000,0.000599496000,0.000000000000),\nvec3(0.001546459000,0.000558454700,0.000000000000),\nvec3(0.001439971000,0.000520000000,0.000000000000),\nvec3(0.001340042000,0.000483913600,0.000000000000),\nvec3(0.001246275000,0.000450052800,0.000000000000),\nvec3(0.001158471000,0.000418345200,0.000000000000),\nvec3(0.001076430000,0.000388718400,0.000000000000),\nvec3(0.000999949300,0.000361100000,0.000000000000),\nvec3(0.000928735800,0.000335383500,0.000000000000),\nvec3(0.000862433200,0.000311440400,0.000000000000),\nvec3(0.000800750300,0.000289165600,0.000000000000),\nvec3(0.000743396000,0.000268453900,0.000000000000),\nvec3(0.000690078600,0.000249200000,0.000000000000),\nvec3(0.000640515600,0.000231301900,0.000000000000),\nvec3(0.000594502100,0.000214685600,0.000000000000),\nvec3(0.000551864600,0.000199288400,0.000000000000),\nvec3(0.000512429000,0.000185047500,0.000000000000),\nvec3(0.000476021300,0.000171900000,0.000000000000),\nvec3(0.000442453600,0.000159778100,0.000000000000),\nvec3(0.000411511700,0.000148604400,0.000000000000),\nvec3(0.000382981400,0.000138301600,0.000000000000),\nvec3(0.000356649100,0.000128792500,0.000000000000),\nvec3(0.000332301100,0.000120000000,0.000000000000),\nvec3(0.000309758600,0.000111859500,0.000000000000),\nvec3(0.000288887100,0.000104322400,0.000000000000),\nvec3(0.000269539400,0.000097335600,0.000000000000),\nvec3(0.000251568200,0.000090845870,0.000000000000),\nvec3(0.000234826100,0.000084800000,0.000000000000),\nvec3(0.000219171000,0.000079146670,0.000000000000),\nvec3(0.000204525800,0.000073858000,0.000000000000),\nvec3(0.000190840500,0.000068916000,0.000000000000),\nvec3(0.000178065400,0.000064302670,0.000000000000),\nvec3(0.000166150500,0.000060000000,0.000000000000),\nvec3(0.000155023600,0.000055981870,0.000000000000),\nvec3(0.000144621900,0.000052225600,0.000000000000),\nvec3(0.000134909800,0.000048718400,0.000000000000),\nvec3(0.000125852000,0.000045447470,0.000000000000),\nvec3(0.000117413000,0.000042400000,0.000000000000),\nvec3(0.000109551500,0.000039561040,0.000000000000),\nvec3(0.000102224500,0.000036915120,0.000000000000),\nvec3(0.000095394450,0.000034448680,0.000000000000),\nvec3(0.000089023900,0.000032148160,0.000000000000),\nvec3(0.000083075270,0.000030000000,0.000000000000),\nvec3(0.000077512690,0.000027991250,0.000000000000),\nvec3(0.000072313040,0.000026113560,0.000000000000),\nvec3(0.000067457780,0.000024360240,0.000000000000),\nvec3(0.000062928440,0.000022724610,0.000000000000),\nvec3(0.000058706520,0.000021200000,0.000000000000),\nvec3(0.000054770280,0.000019778550,0.000000000000),\nvec3(0.000051099180,0.000018452850,0.000000000000),\nvec3(0.000047676540,0.000017216870,0.000000000000),\nvec3(0.000044485670,0.000016064590,0.000000000000),\nvec3(0.000041509940,0.000014990000,0.000000000000),\nvec3(0.000038733240,0.000013987280,0.000000000000),\nvec3(0.000036142030,0.000013051550,0.000000000000),\nvec3(0.000033723520,0.000012178180,0.000000000000),\nvec3(0.000031464870,0.000011362540,0.000000000000),\nvec3(0.000029353260,0.000010600000,0.000000000000),\nvec3(0.000027375730,0.000009885877,0.000000000000),\nvec3(0.000025524330,0.000009217304,0.000000000000),\nvec3(0.000023793760,0.000008592362,0.000000000000),\nvec3(0.000022178700,0.000008009133,0.000000000000),\nvec3(0.000020673830,0.000007465700,0.000000000000),\nvec3(0.000019272260,0.000006959567,0.000000000000),\nvec3(0.000017966400,0.000006487995,0.000000000000),\nvec3(0.000016749910,0.000006048699,0.000000000000),\nvec3(0.000015616480,0.000005639396,0.000000000000),\nvec3(0.000014559770,0.000005257800,0.000000000000),\nvec3(0.000013573870,0.000004901771,0.000000000000),\nvec3(0.000012654360,0.000004569720,0.000000000000),\nvec3(0.000011797230,0.000004260194,0.000000000000),\nvec3(0.000010998440,0.000003971739,0.000000000000),\nvec3(0.000010253980,0.000003702900,0.000000000000),\nvec3(0.000009559646,0.000003452163,0.000000000000),\nvec3(0.000008912044,0.000003218302,0.000000000000),\nvec3(0.000008308358,0.000003000300,0.000000000000),\nvec3(0.000007745769,0.000002797139,0.000000000000),\nvec3(0.000007221456,0.000002607800,0.000000000000),\nvec3(0.000006732475,0.000002431220,0.000000000000),\nvec3(0.000006276423,0.000002266531,0.000000000000),\nvec3(0.000005851304,0.000002113013,0.000000000000),\nvec3(0.000005455118,0.000001969943,0.000000000000),\nvec3(0.000005085868,0.000001836600,0.000000000000),\nvec3(0.000004741466,0.000001712230,0.000000000000),\nvec3(0.000004420236,0.000001596228,0.000000000000),\nvec3(0.000004120783,0.000001488090,0.000000000000),\nvec3(0.000003841716,0.000001387314,0.000000000000),\nvec3(0.000003581652,0.000001293400,0.000000000000),\nvec3(0.000003339127,0.000001205820,0.000000000000),\nvec3(0.000003112949,0.000001124143,0.000000000000),\nvec3(0.000002902121,0.000001048009,0.000000000000),\nvec3(0.000002705645,0.000000977058,0.000000000000),\nvec3(0.000002522525,0.000000910930,0.000000000000),\nvec3(0.000002351726,0.000000849251,0.000000000000),\nvec3(0.000002192415,0.000000791721,0.000000000000),\nvec3(0.000002043902,0.000000738090,0.000000000000),\nvec3(0.000001905497,0.000000688110,0.000000000000),\nvec3(0.000001776509,0.000000641530,0.000000000000),\nvec3(0.000001656215,0.000000598090,0.000000000000),\nvec3(0.000001544022,0.000000557575,0.000000000000),\nvec3(0.000001439440,0.000000519808,0.000000000000),\nvec3(0.000001341977,0.000000484612,0.000000000000),\nvec3(0.000001251141,0.000000451810,0.000000000000)\n);\n#endif\n\nfloat g(float x, float mu, float sigma1, float sigma2) {\n    float x0 = (x-mu)/sigma1;\n    float x1 = (x-mu)/sigma2;\n    return x < mu ? exp(-0.5*x0*x0) : exp(-0.5*x1*x1);\n}\n\n// CIE 1931 XYZ CMFs, 2-degree observer\nvec3 cie_1931_xyz_cmf(float lambda) {\n    // lambda: wavelength in nanometers\n\n    #ifndef USE_CMF_APPROXIMATION\n    int index = int(lambda-360.0);\n\n    if((index < 0) || (index > 470)) return vec3(0);\n\n    return mix(cie1931[index+0], cie1931[index+1], fract(lambda)); // linear interpolation\n    #endif\n\n    return vec3(\n    1.056*g(lambda, 599.8, 37.9, 31.0)+0.362*g(lambda, 442.0, 16.0, 26.7)-0.065*g(lambda,501.1,20.4,26.2),\n    0.821*g(lambda, 568.8, 46.9, 40.5)+0.286*g(lambda, 530.9, 16.3, 31.1),\n    1.217*g(lambda, 437.0, 11.8, 36.0)+0.681*g(lambda, 459.0, 26.0, 13.8));\n}\n\n// CIE 1931 XYZ to Linear D65 sRGB\nvec3 xyz_to_linear(vec3 xyz) {\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    return xyz*mat3(\n     3.2404542, -1.5371385, -0.4985314,\n    -0.9692660,  1.8760108,  0.0415560,\n     0.0556434, -0.2040259,  1.0572252\n    );\n}\n\n// Linear D65 sRGB to CIE 1931 XYZ\nvec3 linear_to_xyz(vec3 rgb) {\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    return rgb*mat3(\n    0.4124564,  0.3575761, 0.1804375,\n    0.2126729,  0.7151522, 0.0721750,\n    0.0193339,  0.1191920, 0.9503041\n    );\n}\n\n// Linear Gamma to sRGB IEC 61966-2-1:1999 EOTF\nvec3 linear_to_srgb(vec3 rgb) {\n    return vec3(\n    rgb.r > 0.0031308 ? 1.055*pow(rgb.r,1.0/2.4)-0.055 : 12.92*rgb.r,\n    rgb.g > 0.0031308 ? 1.055*pow(rgb.g,1.0/2.4)-0.055 : 12.92*rgb.g,\n    rgb.b > 0.0031308 ? 1.055*pow(rgb.b,1.0/2.4)-0.055 : 12.92*rgb.b);\n}\n\n// IEC 61966-2-1:1999 sRGB EOTF to Linear Gamma\nvec3 srgb_to_linear(vec3 rgb) {\n    return vec3(\n    rgb.r > 0.04045 ? pow((rgb.r+0.055)/1.055,2.4) : rgb.r/12.92,\n    rgb.g > 0.04045 ? pow((rgb.g+0.055)/1.055,2.4) : rgb.g/12.92,\n    rgb.b > 0.04045 ? pow((rgb.b+0.055)/1.055,2.4) : rgb.b/12.92);\n}\n\n// CIE Standard Illuminant D65, [300, 830] nanometers with 1 nm step size\nconst float[531] cied65 = float[531] (\n0.000341,\n0.003601,\n0.006862,\n0.010122,\n0.013383,\n0.016643,\n0.019903,\n0.023164,\n0.026424,\n0.029685,\n0.032945,\n0.049887,\n0.066828,\n0.083770,\n0.100711,\n0.117652,\n0.134594,\n0.151535,\n0.168477,\n0.185418,\n0.202360,\n0.219177,\n0.235995,\n0.252812,\n0.269630,\n0.286447,\n0.303265,\n0.320082,\n0.336900,\n0.353717,\n0.370535,\n0.373430,\n0.376326,\n0.379221,\n0.382116,\n0.385011,\n0.387907,\n0.390802,\n0.393697,\n0.396593,\n0.399488,\n0.404451,\n0.409414,\n0.414377,\n0.419340,\n0.424302,\n0.429265,\n0.434228,\n0.439191,\n0.444154,\n0.449117,\n0.450844,\n0.452570,\n0.454297,\n0.456023,\n0.457750,\n0.459477,\n0.461203,\n0.462930,\n0.464656,\n0.466383,\n0.471834,\n0.477285,\n0.482735,\n0.488186,\n0.493637,\n0.499088,\n0.504539,\n0.509989,\n0.515440,\n0.520891,\n0.518777,\n0.516664,\n0.514550,\n0.512437,\n0.510323,\n0.508209,\n0.506096,\n0.503982,\n0.501869,\n0.499755,\n0.504428,\n0.509100,\n0.513773,\n0.518446,\n0.523118,\n0.527791,\n0.532464,\n0.537137,\n0.541809,\n0.546482,\n0.574589,\n0.602695,\n0.630802,\n0.658909,\n0.687015,\n0.715122,\n0.743229,\n0.771336,\n0.799442,\n0.827549,\n0.836280,\n0.845011,\n0.853742,\n0.862473,\n0.871204,\n0.879936,\n0.888667,\n0.897398,\n0.906129,\n0.914860,\n0.916806,\n0.918752,\n0.920697,\n0.922643,\n0.924589,\n0.926535,\n0.928481,\n0.930426,\n0.932372,\n0.934318,\n0.927568,\n0.920819,\n0.914069,\n0.907320,\n0.900570,\n0.893821,\n0.887071,\n0.880322,\n0.873572,\n0.866823,\n0.885006,\n0.903188,\n0.921371,\n0.939554,\n0.957736,\n0.975919,\n0.994102,\n1.012280,\n1.030470,\n1.048650,\n1.060790,\n1.072940,\n1.085080,\n1.097220,\n1.109360,\n1.121510,\n1.133650,\n1.145790,\n1.157940,\n1.170080,\n1.170880,\n1.171690,\n1.172490,\n1.173300,\n1.174100,\n1.174900,\n1.175710,\n1.176510,\n1.177320,\n1.178120,\n1.175170,\n1.172220,\n1.169270,\n1.166320,\n1.163360,\n1.160410,\n1.157460,\n1.154510,\n1.151560,\n1.148610,\n1.149670,\n1.150730,\n1.151800,\n1.152860,\n1.153920,\n1.154980,\n1.156040,\n1.157110,\n1.158170,\n1.159230,\n1.152120,\n1.145010,\n1.137890,\n1.130780,\n1.123670,\n1.116560,\n1.109450,\n1.102330,\n1.095220,\n1.088110,\n1.088650,\n1.089200,\n1.089740,\n1.090280,\n1.090820,\n1.091370,\n1.091910,\n1.092450,\n1.093000,\n1.093540,\n1.091990,\n1.090440,\n1.088880,\n1.087330,\n1.085780,\n1.084230,\n1.082680,\n1.081120,\n1.079570,\n1.078020,\n1.075010,\n1.072000,\n1.068980,\n1.065970,\n1.062960,\n1.059950,\n1.056940,\n1.053920,\n1.050910,\n1.047900,\n1.050800,\n1.053700,\n1.056600,\n1.059500,\n1.062390,\n1.065290,\n1.068190,\n1.071090,\n1.073990,\n1.076890,\n1.073610,\n1.070320,\n1.067040,\n1.063750,\n1.060470,\n1.057190,\n1.053900,\n1.050620,\n1.047330,\n1.044050,\n1.043690,\n1.043330,\n1.042970,\n1.042610,\n1.042250,\n1.041900,\n1.041540,\n1.041180,\n1.040820,\n1.040460,\n1.036410,\n1.032370,\n1.028320,\n1.024280,\n1.020230,\n1.016180,\n1.012140,\n1.008090,\n1.004050,\n1.000000,\n0.996334,\n0.992668,\n0.989003,\n0.985337,\n0.981671,\n0.978005,\n0.974339,\n0.970674,\n0.967008,\n0.963342,\n0.962796,\n0.962250,\n0.961703,\n0.961157,\n0.960611,\n0.960065,\n0.959519,\n0.958972,\n0.958426,\n0.957880,\n0.950778,\n0.943675,\n0.936573,\n0.929470,\n0.922368,\n0.915266,\n0.908163,\n0.901061,\n0.893958,\n0.886856,\n0.888177,\n0.889497,\n0.890818,\n0.892138,\n0.893459,\n0.894780,\n0.896100,\n0.897421,\n0.898741,\n0.900062,\n0.899655,\n0.899248,\n0.898841,\n0.898434,\n0.898026,\n0.897619,\n0.897212,\n0.896805,\n0.896398,\n0.895991,\n0.894091,\n0.892190,\n0.890290,\n0.888389,\n0.886489,\n0.884589,\n0.882688,\n0.880788,\n0.878887,\n0.876987,\n0.872577,\n0.868167,\n0.863757,\n0.859347,\n0.854936,\n0.850526,\n0.846116,\n0.841706,\n0.837296,\n0.832886,\n0.833297,\n0.833707,\n0.834118,\n0.834528,\n0.834939,\n0.835350,\n0.835760,\n0.836171,\n0.836581,\n0.836992,\n0.833320,\n0.829647,\n0.825975,\n0.822302,\n0.818630,\n0.814958,\n0.811285,\n0.807613,\n0.803940,\n0.800268,\n0.800456,\n0.800644,\n0.800831,\n0.801019,\n0.801207,\n0.801395,\n0.801583,\n0.801770,\n0.801958,\n0.802146,\n0.804209,\n0.806272,\n0.808336,\n0.810399,\n0.812462,\n0.814525,\n0.816588,\n0.818652,\n0.820715,\n0.822778,\n0.818784,\n0.814791,\n0.810797,\n0.806804,\n0.802810,\n0.798816,\n0.794823,\n0.790829,\n0.786836,\n0.782842,\n0.774279,\n0.765716,\n0.757153,\n0.748590,\n0.740027,\n0.731465,\n0.722902,\n0.714339,\n0.705776,\n0.697213,\n0.699101,\n0.700989,\n0.702876,\n0.704764,\n0.706652,\n0.708540,\n0.710428,\n0.712315,\n0.714203,\n0.716091,\n0.718831,\n0.721571,\n0.724311,\n0.727051,\n0.729790,\n0.732530,\n0.735270,\n0.738010,\n0.740750,\n0.743490,\n0.730745,\n0.718000,\n0.705255,\n0.692510,\n0.679765,\n0.667020,\n0.654275,\n0.641530,\n0.628785,\n0.616040,\n0.624322,\n0.632603,\n0.640885,\n0.649166,\n0.657448,\n0.665730,\n0.674011,\n0.682293,\n0.690574,\n0.698856,\n0.704057,\n0.709259,\n0.714460,\n0.719662,\n0.724863,\n0.730064,\n0.735266,\n0.740467,\n0.745669,\n0.750870,\n0.739376,\n0.727881,\n0.716387,\n0.704893,\n0.693398,\n0.681904,\n0.670410,\n0.658916,\n0.647421,\n0.635927,\n0.618752,\n0.601578,\n0.584403,\n0.567229,\n0.550054,\n0.532880,\n0.515705,\n0.498531,\n0.481356,\n0.464182,\n0.484569,\n0.504956,\n0.525344,\n0.545731,\n0.566118,\n0.586505,\n0.606892,\n0.627280,\n0.647667,\n0.668054,\n0.664631,\n0.661209,\n0.657786,\n0.654364,\n0.650941,\n0.647518,\n0.644096,\n0.640673,\n0.637251,\n0.633828,\n0.634749,\n0.635670,\n0.636592,\n0.637513,\n0.638434,\n0.639355,\n0.640276,\n0.641198,\n0.642119,\n0.643040,\n0.638188,\n0.633336,\n0.628484,\n0.623632,\n0.618779,\n0.613927,\n0.609075,\n0.604223,\n0.599371,\n0.594519,\n0.587026,\n0.579533,\n0.572040,\n0.564547,\n0.557054,\n0.549562,\n0.542069,\n0.534576,\n0.527083,\n0.519590,\n0.525072,\n0.530553,\n0.536035,\n0.541516,\n0.546998,\n0.552480,\n0.557961,\n0.563443,\n0.568924,\n0.574406,\n0.577278,\n0.580150,\n0.583022,\n0.585894,\n0.588765,\n0.591637,\n0.594509,\n0.597381,\n0.600253,\n0.603125);\n\n// CIE Standard Illuminant D65 Spectral Power Distribution\nfloat cie_d65_spd(float lambda) {\n    // lambda: wavelength in nanometers\n\n    int index = int(lambda-300.0);\n\n    if((index < 0) || (index > 530)) return 0.0;\n\n    return mix(cied65[index+0], cied65[index+1], fract(lambda)); // linear interpolation\n}", "buffer_a_code": "// Rendering buffer\n\nstruct rng_state_t {\n    uvec4 s0;\n};\n\n// https://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v) {\n    v = v * 0x0019660Du + 0x3C6EF35Fu;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v ^= v >> 16u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat urand1(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*float(rng_state.s0.x);\n}\n\nvec2 urand2(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*vec2(rng_state.s0.xy);\n}\n\nvec3 urand3(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*vec3(rng_state.s0.xyz);\n}\n\nvec4 urand4(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*vec4(rng_state.s0);\n}\n\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923\n\n//uniformly spherically distributed\nvec3 udir3(inout rng_state_t rng_state) {\n    vec2 rng = urand2(rng_state);\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nfloat sky(vec3 dir, float lambda) {\n    if(dot(dir,normalize(vec3(1,1,0.5)))>0.9) return 10.0;\n    return 0.95*smoothstep(0.0,1.0,dot(vec3(0,1,0),dir))+0.05;\n}\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    vec3 qc = oc - (b*rd);\n    float h = (ra*ra)-dot(qc,qc);\n    if(h < 0.0) return vec2(-1); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// plane degined by p (p.xyz must be normalized)\nvec2 plaIntersect(in vec3 ro, in vec3 rd, in vec4 p) {\n    p.xyz = normalize(p.xyz);\n    float t = -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n    return vec2(t,t+1.0);\n}\n\nstruct Ray {\n    float tMin;\n    float tMax;\n    int id;\n    bool is_sky;\n    bool is_hit;\n    float albedo;\n    vec3 normal;\n};\n\n// Tomato SPD\nfloat tomatospd(float x) {\n    return 0.59*(1.0-pow(smoothstep(0.7,0.6,0.001*x),2.0))+0.01;\n}\n\n// Gaussian SPD\nfloat customspd(float x, float mu) {\n    x *= 0.001; // nm to um\n    x -= mu; // mean\n    x *=  15.0; // sigma\n    return 0.99*exp(-x*x)+0.01;\n}\n\nRay raytrace(in vec3 ro, in vec3 rd) {\n    Ray ray = Ray(-1.0, -1.0, -1, false, false, 0.5, vec3(0));\n\n    for(int i = 0; i < 5; i++) {\n        vec3 x = vec3(0);\n        if(i == 0) x = 1.5*vec3(0.0, 1.0, 0.0);\n        if(i == 1) x = 1.5*vec3(sin(4.0*PI/3.0),cos(4.0*PI/3.0), 0.0);\n        if(i == 2) x = vec3( 0.0, 0.0, 0.0);\n        if(i == 3) x = 1.5*vec3(sin(2.0*PI/3.0),cos(2.0*PI/3.0), 0.0);\n\n        vec2 t = sphIntersect(ro, rd, x, i==2?0.8:1.0);\n\n        if(i == 4) t = plaIntersect(ro, rd, vec4(0.0,0.0,1.0,0.0));\n\n        if((t.x >= 0.0) && (t.y > t.x)) {\n            if(ray.is_hit) {\n                if(t.x < ray.tMin) {\n                    ray.tMin = t.x;\n                    ray.tMax = t.y;\n                    ray.id = i;\n                    ray.is_hit = true;\n                    ray.is_sky = false;\n                    ray.normal = normalize((ro+(t.x*rd))-x);\n                    if(i == 4) ray.normal = vec3(0,0,1);\n                }\n            } else {\n                ray.tMin = t.x;\n                ray.tMax = t.y;\n                ray.id = i;\n                ray.is_hit = true;\n                ray.is_sky = false;\n                ray.normal = normalize((ro+(t.x*rd))-x);\n                if(i == 4) ray.normal = vec3(0,0,1);\n            }\n        } else {\n        }\n    }\n\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    rng_state_t rng_state;\n\n    rng_state.s0 = uvec4(fragCoord.x, fragCoord.y, iFrame, 1)+uvec4(1);\n\n    fragCoord = floor(fragCoord) + urand2(rng_state); // box filter\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 0.5; // fov\n\n    vec3 ro = vec3( 0.0,  0.3, 10.0); // ray origin\n    vec3 rd = vec3(uv.x, uv.y, -1.0); // ray direction\n\n    rd = normalize(rd); // normalize ray direction\n\n    //float lambda = (470.0*(fragCoord.x/iResolution.x))+360.0; fragColor.xyz = cie_1931_xyz_cmf(lambda); return;\n\n    float lambda = 470.0*urand1(rng_state)+360.0; // uniform sampling 360–830 nm\n\n    #ifdef USE_STANDARD_ILLUMINANT_E\n    float d = 1.0;\n    #else\n    float d = cie_d65_spd(lambda);\n    #endif\n\n    fragColor.r = d;\n\n    float emm = 0.0;\n\n    vec3 raypos = ro;\n    vec3 raydir = rd;\n\n    for(int i = 0; i < 32; i++) {\n        Ray ray = raytrace(raypos, raydir);\n\n        if(ray.is_hit) {\n            if(ray.id == 0) fragColor.r *= tomatospd(lambda);\n            //if(ray.id == 1) fragColor.r *= customspd(lambda, 0.40);\n            if(ray.id == 1) fragColor.r *= 0.85*smoothstep(0.45,0.44,0.001*lambda)+0.05;\n            if(ray.id == 2) fragColor.r *= customspd(lambda, 0.53);\n            //if(ray.id == 3) fragColor.r *= customspd(lambda, 0.60);\n            if(ray.id == 3) fragColor.r *= 0.85*smoothstep(0.54,0.6,0.001*lambda)+0.05;\n            if(ray.id == 4) fragColor.r *= 0.85;\n\n            raypos += raydir*ray.tMin;\n            raypos += 0.0001*ray.normal;\n            raydir = reflect(raydir, normalize((ray.id==4?1.0:1.0)*udir3(rng_state)+ray.normal));\n\n            vec3 light_dir = normalize(0.1*udir3(rng_state)+vec3(1.0,1.0,0.5));\n            Ray ray2 =  raytrace(raypos, light_dir);\n            emm += ray2.is_hit?0.0:fragColor.r*0.5*d*max(dot(ray.normal,light_dir),0.0);\n            continue;\n        }\n\n        if(ray.is_sky) {\n            break;\n        }\n\n        break;\n    }\n\n    fragColor.xyz = cie_1931_xyz_cmf(lambda)*((sky(raydir, lambda)*fragColor.r)+emm);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Accumulation Buffer (used for progressive rendering)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame > 0 ? texelFetch(iChannel1, ivec2(fragCoord), 0) : vec4(0);\n\n    fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// CIE 1931 XYZ\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.xyz / fragColor.a : fragColor.xyz, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Linear IEC 61966-2-1:1999 sRGB\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(xyz_to_linear(fragColor.xyz), 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2288, 2288, 2343, 2343, 3350]], "test": "untested"}
{"id": "mscfW7", "name": "Particle clustering (MD)", "author": "michael0884", "description": "Clustering particles, with at most 2 particles per cell\nFor molecular dynamics clearly 2 is not sufficient for pixel-level densities, the particle distribution degenerates into a lattice.\nSPACE to ZOOM in!\nPerhaps for fluids this might work better..?", "tags": ["particle"], "likes": 28, "viewed": 586, "published": 3, "date": "1697248297", "time_retrieved": "2024-07-30T17:28:35.287239", "image_code": "//Clustering particles, with at most 2 particles per cell\n//For molecular dynamics clearly 2 is not sufficient for pixel-level densities, the particle distribution degenerates into a lattice.\n//SPACE to ZOOM in!\n//Perhaps for fluids this might work better..?\n//The density should be about 1.5x higher than in https://www.shadertoy.com/view/3s3cWr\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\n#define radius 1.5\n#define zoom 0.6\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    float prad = 1.6;\n    //zoom in\n    if(isKeyPressed(KEY_SPACE))\n    {\n    \tpos = iMouse.xy + pos*zoom - R*zoom*0.5;\n        prad = radius;\n    }\n\n\n    //compute the smoothed density\n    float rho = 0.00;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 p = floor(pos) + vec2(i, j);\n        vec4 packed = LOAD(ch0, p);\n        Particle p0, p1;\n        unpackParticles(packed, p, p0, p1);\n\n        //compute the density\n        rho += float(p0.mass)*smoothstep(prad, 0.0, length(p0.pos - pos))/(prad*prad);\n        rho += float(p1.mass)*smoothstep(prad, 0.0, length(p1.pos - pos))/(prad*prad);\n    }\n\n    col.xyz = cos(2.5*vec3(3,2,1)*clamp(rho,0.0,2.5));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define LOAD(ch, pos) texelFetch(ch, ivec2(pos), 0)\n\n#define PI 3.1415926535\n#define TWO_PI 6.28318530718\n\n#define dt 0.6\n#define gravity 0.001\n#define force_k 0.4\n#define force_coef_a -3.0\n#define force_coef_b 1.0\n#define force_mouse 0.0025\n#define force_boundary 5.0\n#define boundary_h 5.0\n#define max_velocity 2.0\n#define cooling 1.5\n\n#define R iResolution.xy\n\n#define GS(x) exp(-dot(x,x))\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n\nstruct Particle \n{\n    uint mass;\n    vec2 pos;\n    vec2 vel;\n    vec2 force;\n};\n\nvec4 packParticles(Particle p0, Particle p1, vec2 pos)\n{\n    // 1. Mass\n    uint mass0 = p0.mass; \n    uint mass1 = p1.mass;\n    uint packedMass = (mass0 << 16) | mass1;\n    float massFloat = uintBitsToFloat(packedMass);\n\n    // 2. Position\n    p0.pos -= pos;\n    p1.pos -= pos;\n    \n    uint pos0x = uint(round(clamp(p0.pos.x, 0.0, 1.0) * 255.0)); // Assuming pos range [0, 1] in a cell\n    uint pos0y = uint(round(clamp(p0.pos.y, 0.0, 1.0) * 255.0));\n    uint pos1x = uint(round(clamp(p1.pos.x, 0.0, 1.0) * 255.0));\n    uint pos1y = uint(round(clamp(p1.pos.y, 0.0, 1.0) * 255.0));\n    uint packedPos = (pos0x << 24) | (pos0y << 16) | (pos1x << 8) | pos1y;\n    float posFloat = uintBitsToFloat(packedPos);\n\n    // 3. Velocity\n    p0.vel /= 2.0;\n    p1.vel /= 2.0;\n    \n    uint vel0Packed = packSnorm2x16(p0.vel);\n    uint vel1Packed = packSnorm2x16(p1.vel);\n\n    float vel0Float = uintBitsToFloat(vel0Packed);\n    float vel1Float = uintBitsToFloat(vel1Packed);\n\n    return vec4(massFloat, posFloat, vel0Float, vel1Float);\n}\n\nvoid unpackParticles(vec4 packed, vec2 pos, out Particle p0, out Particle p1)\n{\n    // 1. Unpack Mass\n    uint packedMass = floatBitsToUint(packed.x);\n    p0.mass = (packedMass >> 16) & 0xFFFFu;\n    p1.mass = packedMass & 0xFFFFu;\n\n    // 2. Unpack Position\n    uint packedPos = floatBitsToUint(packed.y);\n    p0.pos.x = float((packedPos >> 24) & 0xFFu) / 255.0;\n    p0.pos.y = float((packedPos >> 16) & 0xFFu) / 255.0;\n    p1.pos.x = float((packedPos >> 8) & 0xFFu) / 255.0;\n    p1.pos.y = float(packedPos & 0xFFu) / 255.0;\n\n    p0.pos += pos;\n    p1.pos += pos;\n\n    // 3. Unpack Velocity\n    uint vel0Packed = floatBitsToUint(packed.z);\n    uint vel1Packed = floatBitsToUint(packed.w);\n    p0.vel = unpackSnorm2x16(vel0Packed);\n    p1.vel = unpackSnorm2x16(vel1Packed);\n    \n    p0.vel *= 2.0;\n    p1.vel *= 2.0;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nint ClosestCluster(Particle p0, Particle p1, Particle incoming)\n{\n    //first try to choose the particle with significantly smaller mass\n    if(float(p0.mass) < 0.1*float(p1.mass) || float(p1.mass) < 0.1*float(p0.mass))\n    {\n        return p0.mass < p1.mass ? 0 : 1;\n    }\n\n    //otherwise choose the closest one\n    float d0 = length(p0.pos - incoming.pos);\n    float d1 = length(p1.pos - incoming.pos);\n    return d0 < d1 ? 0 : 1;\n}\n\nvoid BlendParticle(inout Particle p, in Particle incoming)\n{\n    uint newMass = p.mass + incoming.mass;\n    vec2 weight = vec2(p.mass, incoming.mass) / float(newMass);\n    p.pos = p.pos*weight.x + incoming.pos*weight.y;\n    p.vel = p.vel*weight.x + incoming.vel*weight.y;\n    p.mass = newMass;\n}\n\nvoid Clusterize(inout Particle p0, inout Particle p1, in Particle incoming, vec2 pos)\n{\n    //check if the incoming particle is in the cell\n    if(!all(equal(pos, floor(incoming.pos))))\n    {\n        return;\n    }\n\n    int closest = ClosestCluster(p0, p1, incoming);\n    if(closest == 0)\n    {\n        BlendParticle(p0, incoming);\n    }\n    else\n    {\n        BlendParticle(p1, incoming);\n    }\n}\n\nvoid SplitParticle(inout Particle p1, inout Particle p2)\n{\n    uint newMass = p1.mass;\n    p1.mass = newMass/2u;\n    p2.mass = newMass - p1.mass;\n    vec2 pos = p1.pos;\n    vec2 weight = vec2(p1.mass, p2.mass)/float(newMass);\n    p2.pos = p1.pos + vec2(-1,1)*2e-2;\n    p1.pos = p1.pos - vec2(-1,1)*2e-2;\n    p2.vel = p1.vel;\n}\n\n\nfloat border(vec2 p, vec2 iR)\n{\n    float bound = -sdBox(p+0.001 - iR*0.5, iR*vec2(0.49, 0.49)); \n    return bound;\n}\n\n#define h 1.\nvec3 bN(vec2 p, vec2 iR)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy, iR)\n           + idx.xyw*border(p + dx.xy, iR)\n           + idx.yzw*border(p + dx.yz, iR)\n           + idx.yxw*border(p + dx.yx, iR);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvoid ApplyForce(inout Particle p, in Particle incoming)\n{\n    float d = distance(p.pos, incoming.pos);\n    vec2 dir = (incoming.pos - p.pos)/max(d, 1e-5);\n    float f = clamp(force_coef_a*exp(-d*d*0.6)+force_coef_b*exp(-d*d*0.3), -0.5, 0.5);\n    vec2 F = force_k * f * dir * float(incoming.mass);\n    p.force += F;\n    \n}\n\nvoid IntegrateParticle(inout Particle p, vec2 pos, vec2 iR, vec4 iM)\n{\n    p.force = p.force / max(0.0001, float(p.mass));\n    p.force += vec2(0.0, -gravity); //gravity\n    \n    vec3 BORD = bN(p.pos, iR);\n    p.force += force_boundary * smoothstep(0., boundary_h, -BORD.z) * BORD.xy;\n \n    if(iM.z > 0.)\n    {\n        vec2 dx = pos - iM.xy;\n        p.force -= force_mouse*dx*GS(dx/30.);\n    }\n        \n    p.vel += p.force * dt;\n    p.pos += cooling * p.force * dt;\n\n    //velocity limit\n    float v = length(p.vel)/max_velocity;\n    p.vel /= (v > 1.)?v:1.;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = 1u;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0.25, 0.25);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n    \n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n\n    p0.mass = 0u;\n    p0.pos = vec2(0.0, 0.0);\n    p0.vel = vec2(0.0, 0.0);\n\n    p1.mass = 0u;\n    p1.pos = vec2(0.0, 0.0);\n    p1.vel = vec2(0.0, 0.0);\n\n    //advect neighbors and accumulate + clusterize density if they fall into this cell\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        //load the particles \n        vec2 pos1 = pos + vec2(i, j);\n        Particle p0_, p1_;\n        unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n        \n        if(p0_.mass > 0u)\n        {\n            p0_.pos += p0_.vel*dt;\n            Clusterize(p0, p1, p0_, pos);\n        }\n   \n        if(p1_.mass > 0u)\n        {\n            p1_.pos += p1_.vel*dt;\n            Clusterize(p0, p1, p1_, pos);\n        }\n    }\n    \n    if(p1.mass == 0u && p0.mass > 0u)\n    {\n        SplitParticle(p0, p1);\n    }\n\n    if(p0.mass == 0u && p1.mass > 0u)\n    {\n        SplitParticle(p1, p0);\n    }\n    \n    if(iFrame < 10)\n    {\n        if(pos.x < 0.65*R.x && pos.x > 0.35*R.x && pos.y < 0.65*R.y && pos.y > 0.35*R.y)\n        {\n            p0.mass = 1u;\n            p1.mass = 0u;\n        }\n\n        p0.pos = pos+vec2(0.2, 0.2);\n        p0.vel = vec2(0., 0.);\n        p1.pos = pos+vec2(0.75, 0.75);\n        p1.vel = vec2(0.25, 0.25);\n    }\n\n    vec4 packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 pos )\n{\n    pos = floor(pos);\n    Particle p0, p1;\n    \n    //load the particles\n    vec4 packed = LOAD(ch0, pos);\n    unpackParticles(packed, pos, p0, p1);\n\n    if(p0.mass + p1.mass > 0u) \n    {\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            if(i == 0 && j == 0) continue;\n            //load the particles \n            vec2 pos1 = pos + vec2(i, j);\n            Particle p0_, p1_;\n            unpackParticles(LOAD(ch0, pos1), pos1, p0_, p1_);\n\n            //apply the force\n            ApplyForce(p0, p0_);\n            ApplyForce(p0, p1_);\n            ApplyForce(p1, p0_);\n            ApplyForce(p1, p1_);\n        }\n\n        ApplyForce(p0, p1);\n        ApplyForce(p1, p0);\n\n        IntegrateParticle(p0, pos, iResolution.xy, iMouse);\n        IntegrateParticle(p1, pos, iResolution.xy, iMouse);\n    }\n\n    packed = packParticles(p0, p1, pos);\n    fragColor = packed;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 375, 375, 553], [581, 581, 609, 609, 669]], "test": "untested"}
{"id": "cddBW4", "name": "Spectral Color Renderer", "author": "Zi7ar21", "description": "Renders SPDs (spectral power distributions) using the CIE 1931 XYZ Color Matching Functions (2-degree observer) and matricies to transform into IEC 61966-2-1:1999 sRGB, along with the EOTF", "tags": ["spectral"], "likes": 3, "viewed": 207, "published": 3, "date": "1697232659", "time_retrieved": "2024-07-30T17:28:36.441154", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n\n    fragColor.rgb = tanh(fragColor.rgb); // tonemapping\n\n    fragColor.rgb = linear_to_srgb(fragColor.rgb); // undo monitor gamma\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// CIE 1931 XYZ Colour-Matching Functions, 2-degree observer, [360, 830] nanometers with 1 nm step size\nconst vec3[471] cie1931 = vec3[471] (\nvec3(0.000129900000,0.000003917000,0.000606100000),\nvec3(0.000145847000,0.000004393581,0.000680879200),\nvec3(0.000163802100,0.000004929604,0.000765145600),\nvec3(0.000184003700,0.000005532136,0.000860012400),\nvec3(0.000206690200,0.000006208245,0.000966592800),\nvec3(0.000232100000,0.000006965000,0.001086000000),\nvec3(0.000260728000,0.000007813219,0.001220586000),\nvec3(0.000293075000,0.000008767336,0.001372729000),\nvec3(0.000329388000,0.000009839844,0.001543579000),\nvec3(0.000369914000,0.000011043230,0.001734286000),\nvec3(0.000414900000,0.000012390000,0.001946000000),\nvec3(0.000464158700,0.000013886410,0.002177777000),\nvec3(0.000518986000,0.000015557280,0.002435809000),\nvec3(0.000581854000,0.000017442960,0.002731953000),\nvec3(0.000655234700,0.000019583750,0.003078064000),\nvec3(0.000741600000,0.000022020000,0.003486000000),\nvec3(0.000845029600,0.000024839650,0.003975227000),\nvec3(0.000964526800,0.000028041260,0.004540880000),\nvec3(0.001094949000,0.000031531040,0.005158320000),\nvec3(0.001231154000,0.000035215210,0.005802907000),\nvec3(0.001368000000,0.000039000000,0.006450001000),\nvec3(0.001502050000,0.000042826400,0.007083216000),\nvec3(0.001642328000,0.000046914600,0.007745488000),\nvec3(0.001802382000,0.000051589600,0.008501152000),\nvec3(0.001995757000,0.000057176400,0.009414544000),\nvec3(0.002236000000,0.000064000000,0.010549990000),\nvec3(0.002535385000,0.000072344210,0.011965800000),\nvec3(0.002892603000,0.000082212240,0.013655870000),\nvec3(0.003300829000,0.000093508160,0.015588050000),\nvec3(0.003753236000,0.000106136100,0.017730150000),\nvec3(0.004243000000,0.000120000000,0.020050010000),\nvec3(0.004762389000,0.000134984000,0.022511360000),\nvec3(0.005330048000,0.000151492000,0.025202880000),\nvec3(0.005978712000,0.000170208000,0.028279720000),\nvec3(0.006741117000,0.000191816000,0.031897040000),\nvec3(0.007650000000,0.000217000000,0.036210000000),\nvec3(0.008751373000,0.000246906700,0.041437710000),\nvec3(0.010028880000,0.000281240000,0.047503720000),\nvec3(0.011421700000,0.000318520000,0.054119880000),\nvec3(0.012869010000,0.000357266700,0.060998030000),\nvec3(0.014310000000,0.000396000000,0.067850010000),\nvec3(0.015704430000,0.000433714700,0.074486320000),\nvec3(0.017147440000,0.000473024000,0.081361560000),\nvec3(0.018781220000,0.000517876000,0.089153640000),\nvec3(0.020748010000,0.000572218700,0.098540480000),\nvec3(0.023190000000,0.000640000000,0.110200000000),\nvec3(0.026207360000,0.000724560000,0.124613300000),\nvec3(0.029782480000,0.000825500000,0.141701700000),\nvec3(0.033880920000,0.000941160000,0.161303500000),\nvec3(0.038468240000,0.001069880000,0.183256800000),\nvec3(0.043510000000,0.001210000000,0.207400000000),\nvec3(0.048995600000,0.001362091000,0.233692100000),\nvec3(0.055022600000,0.001530752000,0.262611400000),\nvec3(0.061718800000,0.001720368000,0.294774600000),\nvec3(0.069212000000,0.001935323000,0.330798500000),\nvec3(0.077630000000,0.002180000000,0.371300000000),\nvec3(0.086958110000,0.002454800000,0.416209100000),\nvec3(0.097176720000,0.002764000000,0.465464200000),\nvec3(0.108406300000,0.003117800000,0.519694800000),\nvec3(0.120767200000,0.003526400000,0.579530300000),\nvec3(0.134380000000,0.004000000000,0.645600000000),\nvec3(0.149358200000,0.004546240000,0.718483800000),\nvec3(0.165395700000,0.005159320000,0.796713300000),\nvec3(0.181983100000,0.005829280000,0.877845900000),\nvec3(0.198611000000,0.006546160000,0.959439000000),\nvec3(0.214770000000,0.007300000000,1.039050100000),\nvec3(0.230186800000,0.008086507000,1.115367300000),\nvec3(0.244879700000,0.008908720000,1.188497100000),\nvec3(0.258777300000,0.009767680000,1.258123300000),\nvec3(0.271807900000,0.010664430000,1.323929600000),\nvec3(0.283900000000,0.011600000000,1.385600000000),\nvec3(0.294943800000,0.012573170000,1.442635200000),\nvec3(0.304896500000,0.013582720000,1.494803500000),\nvec3(0.313787300000,0.014629680000,1.542190300000),\nvec3(0.321645400000,0.015715090000,1.584880700000),\nvec3(0.328500000000,0.016840000000,1.622960000000),\nvec3(0.334351300000,0.018007360000,1.656404800000),\nvec3(0.339210100000,0.019214480000,1.685295900000),\nvec3(0.343121300000,0.020453920000,1.709874500000),\nvec3(0.346129600000,0.021718240000,1.730382100000),\nvec3(0.348280000000,0.023000000000,1.747060000000),\nvec3(0.349599900000,0.024294610000,1.760044600000),\nvec3(0.350147400000,0.025610240000,1.769623300000),\nvec3(0.350013000000,0.026958570000,1.776263700000),\nvec3(0.349287000000,0.028351250000,1.780433400000),\nvec3(0.348060000000,0.029800000000,1.782600000000),\nvec3(0.346373300000,0.031310830000,1.782968200000),\nvec3(0.344262400000,0.032883680000,1.781699800000),\nvec3(0.341808800000,0.034521120000,1.779198200000),\nvec3(0.339094100000,0.036225710000,1.775867100000),\nvec3(0.336200000000,0.038000000000,1.772110000000),\nvec3(0.333197700000,0.039846670000,1.768258900000),\nvec3(0.330041100000,0.041768000000,1.764039000000),\nvec3(0.326635700000,0.043766000000,1.758943800000),\nvec3(0.322886800000,0.045842670000,1.752466300000),\nvec3(0.318700000000,0.048000000000,1.744100000000),\nvec3(0.314025100000,0.050243680000,1.733559500000),\nvec3(0.308884000000,0.052573040000,1.720858100000),\nvec3(0.303290400000,0.054980560000,1.705936900000),\nvec3(0.297257900000,0.057458720000,1.688737200000),\nvec3(0.290800000000,0.060000000000,1.669200000000),\nvec3(0.283970100000,0.062601970000,1.647528700000),\nvec3(0.276721400000,0.065277520000,1.623412700000),\nvec3(0.268917800000,0.068042080000,1.596022300000),\nvec3(0.260422700000,0.070911090000,1.564528000000),\nvec3(0.251100000000,0.073900000000,1.528100000000),\nvec3(0.240847500000,0.077016000000,1.486111400000),\nvec3(0.229851200000,0.080266400000,1.439521500000),\nvec3(0.218407200000,0.083666800000,1.389879900000),\nvec3(0.206811500000,0.087232800000,1.338736200000),\nvec3(0.195360000000,0.090980000000,1.287640000000),\nvec3(0.184213600000,0.094917550000,1.237422300000),\nvec3(0.173327300000,0.099045840000,1.187824300000),\nvec3(0.162688100000,0.103367400000,1.138761100000),\nvec3(0.152283300000,0.107884600000,1.090148000000),\nvec3(0.142100000000,0.112600000000,1.041900000000),\nvec3(0.132178600000,0.117532000000,0.994197600000),\nvec3(0.122569600000,0.122674400000,0.947347300000),\nvec3(0.113275200000,0.127992800000,0.901453100000),\nvec3(0.104297900000,0.133452800000,0.856619300000),\nvec3(0.095640000000,0.139020000000,0.812950100000),\nvec3(0.087299550000,0.144676400000,0.770517300000),\nvec3(0.079308040000,0.150469300000,0.729444800000),\nvec3(0.071717760000,0.156461900000,0.689913600000),\nvec3(0.064580990000,0.162717700000,0.652104900000),\nvec3(0.057950010000,0.169300000000,0.616200000000),\nvec3(0.051862110000,0.176243100000,0.582328600000),\nvec3(0.046281520000,0.183558100000,0.550416200000),\nvec3(0.041150880000,0.191273500000,0.520337600000),\nvec3(0.036412830000,0.199418000000,0.491967300000),\nvec3(0.032010000000,0.208020000000,0.465180000000),\nvec3(0.027917200000,0.217119900000,0.439924600000),\nvec3(0.024144400000,0.226734500000,0.416183600000),\nvec3(0.020687000000,0.236857100000,0.393882200000),\nvec3(0.017540400000,0.247481200000,0.372945900000),\nvec3(0.014700000000,0.258600000000,0.353300000000),\nvec3(0.012161790000,0.270184900000,0.334857800000),\nvec3(0.009919960000,0.282293900000,0.317552100000),\nvec3(0.007967240000,0.295050500000,0.301337500000),\nvec3(0.006296346000,0.308578000000,0.286168600000),\nvec3(0.004900000000,0.323000000000,0.272000000000),\nvec3(0.003777173000,0.338402100000,0.258817100000),\nvec3(0.002945320000,0.354685800000,0.246483800000),\nvec3(0.002424880000,0.371698600000,0.234771800000),\nvec3(0.002236293000,0.389287500000,0.223453300000),\nvec3(0.002400000000,0.407300000000,0.212300000000),\nvec3(0.002925520000,0.425629900000,0.201169200000),\nvec3(0.003836560000,0.444309600000,0.190119600000),\nvec3(0.005174840000,0.463394400000,0.179225400000),\nvec3(0.006982080000,0.482939500000,0.168560800000),\nvec3(0.009300000000,0.503000000000,0.158200000000),\nvec3(0.012149490000,0.523569300000,0.148138300000),\nvec3(0.015535880000,0.544512000000,0.138375800000),\nvec3(0.019477520000,0.565690000000,0.128994200000),\nvec3(0.023992770000,0.586965300000,0.120075100000),\nvec3(0.029100000000,0.608200000000,0.111700000000),\nvec3(0.034814850000,0.629345600000,0.103904800000),\nvec3(0.041120160000,0.650306800000,0.096667480000),\nvec3(0.047985040000,0.670875200000,0.089982720000),\nvec3(0.055378610000,0.690842400000,0.083845310000),\nvec3(0.063270000000,0.710000000000,0.078249990000),\nvec3(0.071635010000,0.728185200000,0.073208990000),\nvec3(0.080462240000,0.745463600000,0.068678160000),\nvec3(0.089739960000,0.761969400000,0.064567840000),\nvec3(0.099456450000,0.777836800000,0.060788350000),\nvec3(0.109600000000,0.793200000000,0.057250010000),\nvec3(0.120167400000,0.808110400000,0.053904350000),\nvec3(0.131114500000,0.822496200000,0.050746640000),\nvec3(0.142367900000,0.836306800000,0.047752760000),\nvec3(0.153854200000,0.849491600000,0.044898590000),\nvec3(0.165500000000,0.862000000000,0.042160000000),\nvec3(0.177257100000,0.873810800000,0.039507280000),\nvec3(0.189140000000,0.884962400000,0.036935640000),\nvec3(0.201169400000,0.895493600000,0.034458360000),\nvec3(0.213365800000,0.905443200000,0.032088720000),\nvec3(0.225749900000,0.914850100000,0.029840000000),\nvec3(0.238320900000,0.923734800000,0.027711810000),\nvec3(0.251066800000,0.932092400000,0.025694440000),\nvec3(0.263992200000,0.939922600000,0.023787160000),\nvec3(0.277101700000,0.947225200000,0.021989250000),\nvec3(0.290400000000,0.954000000000,0.020300000000),\nvec3(0.303891200000,0.960256100000,0.018718050000),\nvec3(0.317572600000,0.966007400000,0.017240360000),\nvec3(0.331438400000,0.971260600000,0.015863640000),\nvec3(0.345482800000,0.976022500000,0.014584610000),\nvec3(0.359700000000,0.980300000000,0.013400000000),\nvec3(0.374083900000,0.984092400000,0.012307230000),\nvec3(0.388639600000,0.987418200000,0.011301880000),\nvec3(0.403378400000,0.990312800000,0.010377920000),\nvec3(0.418311500000,0.992811600000,0.009529306000),\nvec3(0.433449900000,0.994950100000,0.008749999000),\nvec3(0.448795300000,0.996710800000,0.008035200000),\nvec3(0.464336000000,0.998098300000,0.007381600000),\nvec3(0.480064000000,0.999112000000,0.006785400000),\nvec3(0.495971300000,0.999748200000,0.006242800000),\nvec3(0.512050100000,1.000000000000,0.005749999000),\nvec3(0.528295900000,0.999856700000,0.005303600000),\nvec3(0.544691600000,0.999304600000,0.004899800000),\nvec3(0.561209400000,0.998325500000,0.004534200000),\nvec3(0.577821500000,0.996898700000,0.004202400000),\nvec3(0.594500000000,0.995000000000,0.003900000000),\nvec3(0.611220900000,0.992600500000,0.003623200000),\nvec3(0.627975800000,0.989742600000,0.003370600000),\nvec3(0.644760200000,0.986444400000,0.003141400000),\nvec3(0.661569700000,0.982724100000,0.002934800000),\nvec3(0.678400000000,0.978600000000,0.002749999000),\nvec3(0.695239200000,0.974083700000,0.002585200000),\nvec3(0.712058600000,0.969171200000,0.002438600000),\nvec3(0.728828400000,0.963856800000,0.002309400000),\nvec3(0.745518800000,0.958134900000,0.002196800000),\nvec3(0.762100000000,0.952000000000,0.002100000000),\nvec3(0.778543200000,0.945450400000,0.002017733000),\nvec3(0.794825600000,0.938499200000,0.001948200000),\nvec3(0.810926400000,0.931162800000,0.001889800000),\nvec3(0.826824800000,0.923457600000,0.001840933000),\nvec3(0.842500000000,0.915400000000,0.001800000000),\nvec3(0.857932500000,0.907006400000,0.001766267000),\nvec3(0.873081600000,0.898277200000,0.001737800000),\nvec3(0.887894400000,0.889204800000,0.001711200000),\nvec3(0.902318100000,0.879781600000,0.001683067000),\nvec3(0.916300000000,0.870000000000,0.001650001000),\nvec3(0.929799500000,0.859861300000,0.001610133000),\nvec3(0.942798400000,0.849392000000,0.001564400000),\nvec3(0.955277600000,0.838622000000,0.001513600000),\nvec3(0.967217900000,0.827581300000,0.001458533000),\nvec3(0.978600000000,0.816300000000,0.001400000000),\nvec3(0.989385600000,0.804794700000,0.001336667000),\nvec3(0.999548800000,0.793082000000,0.001270000000),\nvec3(1.009089200000,0.781192000000,0.001205000000),\nvec3(1.018006400000,0.769154700000,0.001146667000),\nvec3(1.026300000000,0.757000000000,0.001100000000),\nvec3(1.033982700000,0.744754100000,0.001068800000),\nvec3(1.040986000000,0.732422400000,0.001049400000),\nvec3(1.047188000000,0.720003600000,0.001035600000),\nvec3(1.052466700000,0.707496500000,0.001021200000),\nvec3(1.056700000000,0.694900000000,0.001000000000),\nvec3(1.059794400000,0.682219200000,0.000968640000),\nvec3(1.061799200000,0.669471600000,0.000929920000),\nvec3(1.062806800000,0.656674400000,0.000886880000),\nvec3(1.062909600000,0.643844800000,0.000842560000),\nvec3(1.062200000000,0.631000000000,0.000800000000),\nvec3(1.060735200000,0.618155500000,0.000760960000),\nvec3(1.058443600000,0.605314400000,0.000723680000),\nvec3(1.055224400000,0.592475600000,0.000685920000),\nvec3(1.050976800000,0.579637900000,0.000645440000),\nvec3(1.045600000000,0.566800000000,0.000600000000),\nvec3(1.039036900000,0.553961100000,0.000547866700),\nvec3(1.031360800000,0.541137200000,0.000491600000),\nvec3(1.022666200000,0.528352800000,0.000435400000),\nvec3(1.013047700000,0.515632300000,0.000383466700),\nvec3(1.002600000000,0.503000000000,0.000340000000),\nvec3(0.991367500000,0.490468800000,0.000307253300),\nvec3(0.979331400000,0.478030400000,0.000283160000),\nvec3(0.966491600000,0.465677600000,0.000265440000),\nvec3(0.952847900000,0.453403200000,0.000251813300),\nvec3(0.938400000000,0.441200000000,0.000240000000),\nvec3(0.923194000000,0.429080000000,0.000229546700),\nvec3(0.907244000000,0.417036000000,0.000220640000),\nvec3(0.890502000000,0.405032000000,0.000211960000),\nvec3(0.872920000000,0.393032000000,0.000202186700),\nvec3(0.854449900000,0.381000000000,0.000190000000),\nvec3(0.835084000000,0.368918400000,0.000174213300),\nvec3(0.814946000000,0.356827200000,0.000155640000),\nvec3(0.794186000000,0.344776800000,0.000135960000),\nvec3(0.772954000000,0.332817600000,0.000116853300),\nvec3(0.751400000000,0.321000000000,0.000100000000),\nvec3(0.729583600000,0.309338100000,0.000086133330),\nvec3(0.707588800000,0.297850400000,0.000074600000),\nvec3(0.685602200000,0.286593600000,0.000065000000),\nvec3(0.663810400000,0.275624500000,0.000056933330),\nvec3(0.642400000000,0.265000000000,0.000049999990),\nvec3(0.621514900000,0.254763200000,0.000044160000),\nvec3(0.601113800000,0.244889600000,0.000039480000),\nvec3(0.581105200000,0.235334400000,0.000035720000),\nvec3(0.561397700000,0.226052800000,0.000032640000),\nvec3(0.541900000000,0.217000000000,0.000030000000),\nvec3(0.522599500000,0.208161600000,0.000027653330),\nvec3(0.503546400000,0.199548800000,0.000025560000),\nvec3(0.484743600000,0.191155200000,0.000023640000),\nvec3(0.466193900000,0.182974400000,0.000021813330),\nvec3(0.447900000000,0.175000000000,0.000020000000),\nvec3(0.429861300000,0.167223500000,0.000018133330),\nvec3(0.412098000000,0.159646400000,0.000016200000),\nvec3(0.394644000000,0.152277600000,0.000014200000),\nvec3(0.377533300000,0.145125900000,0.000012133330),\nvec3(0.360800000000,0.138200000000,0.000010000000),\nvec3(0.344456300000,0.131500300000,0.000007733333),\nvec3(0.328516800000,0.125024800000,0.000005400000),\nvec3(0.313019200000,0.118779200000,0.000003200000),\nvec3(0.298001100000,0.112769100000,0.000001333333),\nvec3(0.283500000000,0.107000000000,0.000000000000),\nvec3(0.269544800000,0.101476200000,0.000000000000),\nvec3(0.256118400000,0.096188640000,0.000000000000),\nvec3(0.243189600000,0.091122960000,0.000000000000),\nvec3(0.230727200000,0.086264850000,0.000000000000),\nvec3(0.218700000000,0.081600000000,0.000000000000),\nvec3(0.207097100000,0.077120640000,0.000000000000),\nvec3(0.195923200000,0.072825520000,0.000000000000),\nvec3(0.185170800000,0.068710080000,0.000000000000),\nvec3(0.174832300000,0.064769760000,0.000000000000),\nvec3(0.164900000000,0.061000000000,0.000000000000),\nvec3(0.155366700000,0.057396210000,0.000000000000),\nvec3(0.146230000000,0.053955040000,0.000000000000),\nvec3(0.137490000000,0.050673760000,0.000000000000),\nvec3(0.129146700000,0.047549650000,0.000000000000),\nvec3(0.121200000000,0.044580000000,0.000000000000),\nvec3(0.113639700000,0.041758720000,0.000000000000),\nvec3(0.106465000000,0.039084960000,0.000000000000),\nvec3(0.099690440000,0.036563840000,0.000000000000),\nvec3(0.093330610000,0.034200480000,0.000000000000),\nvec3(0.087400000000,0.032000000000,0.000000000000),\nvec3(0.081900960000,0.029962610000,0.000000000000),\nvec3(0.076804280000,0.028076640000,0.000000000000),\nvec3(0.072077120000,0.026329360000,0.000000000000),\nvec3(0.067686640000,0.024708050000,0.000000000000),\nvec3(0.063600000000,0.023200000000,0.000000000000),\nvec3(0.059806850000,0.021800770000,0.000000000000),\nvec3(0.056282160000,0.020501120000,0.000000000000),\nvec3(0.052971040000,0.019281080000,0.000000000000),\nvec3(0.049818610000,0.018120690000,0.000000000000),\nvec3(0.046770000000,0.017000000000,0.000000000000),\nvec3(0.043784050000,0.015903790000,0.000000000000),\nvec3(0.040875360000,0.014837180000,0.000000000000),\nvec3(0.038072640000,0.013810680000,0.000000000000),\nvec3(0.035404610000,0.012834780000,0.000000000000),\nvec3(0.032900000000,0.011920000000,0.000000000000),\nvec3(0.030564190000,0.011068310000,0.000000000000),\nvec3(0.028380560000,0.010273390000,0.000000000000),\nvec3(0.026344840000,0.009533311000,0.000000000000),\nvec3(0.024452750000,0.008846157000,0.000000000000),\nvec3(0.022700000000,0.008210000000,0.000000000000),\nvec3(0.021084290000,0.007623781000,0.000000000000),\nvec3(0.019599880000,0.007085424000,0.000000000000),\nvec3(0.018237320000,0.006591476000,0.000000000000),\nvec3(0.016987170000,0.006138485000,0.000000000000),\nvec3(0.015840000000,0.005723000000,0.000000000000),\nvec3(0.014790640000,0.005343059000,0.000000000000),\nvec3(0.013831320000,0.004995796000,0.000000000000),\nvec3(0.012948680000,0.004676404000,0.000000000000),\nvec3(0.012129200000,0.004380075000,0.000000000000),\nvec3(0.011359160000,0.004102000000,0.000000000000),\nvec3(0.010629350000,0.003838453000,0.000000000000),\nvec3(0.009938846000,0.003589099000,0.000000000000),\nvec3(0.009288422000,0.003354219000,0.000000000000),\nvec3(0.008678854000,0.003134093000,0.000000000000),\nvec3(0.008110916000,0.002929000000,0.000000000000),\nvec3(0.007582388000,0.002738139000,0.000000000000),\nvec3(0.007088746000,0.002559876000,0.000000000000),\nvec3(0.006627313000,0.002393244000,0.000000000000),\nvec3(0.006195408000,0.002237275000,0.000000000000),\nvec3(0.005790346000,0.002091000000,0.000000000000),\nvec3(0.005409826000,0.001953587000,0.000000000000),\nvec3(0.005052583000,0.001824580000,0.000000000000),\nvec3(0.004717512000,0.001703580000,0.000000000000),\nvec3(0.004403507000,0.001590187000,0.000000000000),\nvec3(0.004109457000,0.001484000000,0.000000000000),\nvec3(0.003833913000,0.001384496000,0.000000000000),\nvec3(0.003575748000,0.001291268000,0.000000000000),\nvec3(0.003334342000,0.001204092000,0.000000000000),\nvec3(0.003109075000,0.001122744000,0.000000000000),\nvec3(0.002899327000,0.001047000000,0.000000000000),\nvec3(0.002704348000,0.000976589600,0.000000000000),\nvec3(0.002523020000,0.000911108800,0.000000000000),\nvec3(0.002354168000,0.000850133200,0.000000000000),\nvec3(0.002196616000,0.000793238400,0.000000000000),\nvec3(0.002049190000,0.000740000000,0.000000000000),\nvec3(0.001910960000,0.000690082700,0.000000000000),\nvec3(0.001781438000,0.000643310000,0.000000000000),\nvec3(0.001660110000,0.000599496000,0.000000000000),\nvec3(0.001546459000,0.000558454700,0.000000000000),\nvec3(0.001439971000,0.000520000000,0.000000000000),\nvec3(0.001340042000,0.000483913600,0.000000000000),\nvec3(0.001246275000,0.000450052800,0.000000000000),\nvec3(0.001158471000,0.000418345200,0.000000000000),\nvec3(0.001076430000,0.000388718400,0.000000000000),\nvec3(0.000999949300,0.000361100000,0.000000000000),\nvec3(0.000928735800,0.000335383500,0.000000000000),\nvec3(0.000862433200,0.000311440400,0.000000000000),\nvec3(0.000800750300,0.000289165600,0.000000000000),\nvec3(0.000743396000,0.000268453900,0.000000000000),\nvec3(0.000690078600,0.000249200000,0.000000000000),\nvec3(0.000640515600,0.000231301900,0.000000000000),\nvec3(0.000594502100,0.000214685600,0.000000000000),\nvec3(0.000551864600,0.000199288400,0.000000000000),\nvec3(0.000512429000,0.000185047500,0.000000000000),\nvec3(0.000476021300,0.000171900000,0.000000000000),\nvec3(0.000442453600,0.000159778100,0.000000000000),\nvec3(0.000411511700,0.000148604400,0.000000000000),\nvec3(0.000382981400,0.000138301600,0.000000000000),\nvec3(0.000356649100,0.000128792500,0.000000000000),\nvec3(0.000332301100,0.000120000000,0.000000000000),\nvec3(0.000309758600,0.000111859500,0.000000000000),\nvec3(0.000288887100,0.000104322400,0.000000000000),\nvec3(0.000269539400,0.000097335600,0.000000000000),\nvec3(0.000251568200,0.000090845870,0.000000000000),\nvec3(0.000234826100,0.000084800000,0.000000000000),\nvec3(0.000219171000,0.000079146670,0.000000000000),\nvec3(0.000204525800,0.000073858000,0.000000000000),\nvec3(0.000190840500,0.000068916000,0.000000000000),\nvec3(0.000178065400,0.000064302670,0.000000000000),\nvec3(0.000166150500,0.000060000000,0.000000000000),\nvec3(0.000155023600,0.000055981870,0.000000000000),\nvec3(0.000144621900,0.000052225600,0.000000000000),\nvec3(0.000134909800,0.000048718400,0.000000000000),\nvec3(0.000125852000,0.000045447470,0.000000000000),\nvec3(0.000117413000,0.000042400000,0.000000000000),\nvec3(0.000109551500,0.000039561040,0.000000000000),\nvec3(0.000102224500,0.000036915120,0.000000000000),\nvec3(0.000095394450,0.000034448680,0.000000000000),\nvec3(0.000089023900,0.000032148160,0.000000000000),\nvec3(0.000083075270,0.000030000000,0.000000000000),\nvec3(0.000077512690,0.000027991250,0.000000000000),\nvec3(0.000072313040,0.000026113560,0.000000000000),\nvec3(0.000067457780,0.000024360240,0.000000000000),\nvec3(0.000062928440,0.000022724610,0.000000000000),\nvec3(0.000058706520,0.000021200000,0.000000000000),\nvec3(0.000054770280,0.000019778550,0.000000000000),\nvec3(0.000051099180,0.000018452850,0.000000000000),\nvec3(0.000047676540,0.000017216870,0.000000000000),\nvec3(0.000044485670,0.000016064590,0.000000000000),\nvec3(0.000041509940,0.000014990000,0.000000000000),\nvec3(0.000038733240,0.000013987280,0.000000000000),\nvec3(0.000036142030,0.000013051550,0.000000000000),\nvec3(0.000033723520,0.000012178180,0.000000000000),\nvec3(0.000031464870,0.000011362540,0.000000000000),\nvec3(0.000029353260,0.000010600000,0.000000000000),\nvec3(0.000027375730,0.000009885877,0.000000000000),\nvec3(0.000025524330,0.000009217304,0.000000000000),\nvec3(0.000023793760,0.000008592362,0.000000000000),\nvec3(0.000022178700,0.000008009133,0.000000000000),\nvec3(0.000020673830,0.000007465700,0.000000000000),\nvec3(0.000019272260,0.000006959567,0.000000000000),\nvec3(0.000017966400,0.000006487995,0.000000000000),\nvec3(0.000016749910,0.000006048699,0.000000000000),\nvec3(0.000015616480,0.000005639396,0.000000000000),\nvec3(0.000014559770,0.000005257800,0.000000000000),\nvec3(0.000013573870,0.000004901771,0.000000000000),\nvec3(0.000012654360,0.000004569720,0.000000000000),\nvec3(0.000011797230,0.000004260194,0.000000000000),\nvec3(0.000010998440,0.000003971739,0.000000000000),\nvec3(0.000010253980,0.000003702900,0.000000000000),\nvec3(0.000009559646,0.000003452163,0.000000000000),\nvec3(0.000008912044,0.000003218302,0.000000000000),\nvec3(0.000008308358,0.000003000300,0.000000000000),\nvec3(0.000007745769,0.000002797139,0.000000000000),\nvec3(0.000007221456,0.000002607800,0.000000000000),\nvec3(0.000006732475,0.000002431220,0.000000000000),\nvec3(0.000006276423,0.000002266531,0.000000000000),\nvec3(0.000005851304,0.000002113013,0.000000000000),\nvec3(0.000005455118,0.000001969943,0.000000000000),\nvec3(0.000005085868,0.000001836600,0.000000000000),\nvec3(0.000004741466,0.000001712230,0.000000000000),\nvec3(0.000004420236,0.000001596228,0.000000000000),\nvec3(0.000004120783,0.000001488090,0.000000000000),\nvec3(0.000003841716,0.000001387314,0.000000000000),\nvec3(0.000003581652,0.000001293400,0.000000000000),\nvec3(0.000003339127,0.000001205820,0.000000000000),\nvec3(0.000003112949,0.000001124143,0.000000000000),\nvec3(0.000002902121,0.000001048009,0.000000000000),\nvec3(0.000002705645,0.000000977058,0.000000000000),\nvec3(0.000002522525,0.000000910930,0.000000000000),\nvec3(0.000002351726,0.000000849251,0.000000000000),\nvec3(0.000002192415,0.000000791721,0.000000000000),\nvec3(0.000002043902,0.000000738090,0.000000000000),\nvec3(0.000001905497,0.000000688110,0.000000000000),\nvec3(0.000001776509,0.000000641530,0.000000000000),\nvec3(0.000001656215,0.000000598090,0.000000000000),\nvec3(0.000001544022,0.000000557575,0.000000000000),\nvec3(0.000001439440,0.000000519808,0.000000000000),\nvec3(0.000001341977,0.000000484612,0.000000000000),\nvec3(0.000001251141,0.000000451810,0.000000000000)\n);\n\n// CIE 1931 XYZ CMFs, 2-degree observer\nvec3 cie_1931_xyz_cmf(float lambda) {\n    // lambda: wavelength in nanometers\n\n    int index = int(lambda-360.0);\n\n    if((index < 0) || (index > 470)) return vec3(0);\n\n    return mix(cie1931[index+0], cie1931[index+1], fract(lambda)); // linear interpolation\n}\n\n// CIE 1931 XYZ to Linear D65 sRGB\nvec3 xyz_to_linear(vec3 xyz) {\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    return xyz*mat3(\n     3.2404542, -1.5371385, -0.4985314,\n    -0.9692660,  1.8760108,  0.0415560,\n     0.0556434, -0.2040259,  1.0572252\n    );\n}\n\n// Linear D65 sRGB to CIE 1931 XYZ\nvec3 linear_to_xyz(vec3 rgb) {\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    return rgb*mat3(\n    0.4124564,  0.3575761, 0.1804375,\n    0.2126729,  0.7151522, 0.0721750,\n    0.0193339,  0.1191920, 0.9503041\n    );\n}\n\n// Linear Gamma to sRGB IEC 61966-2-1:1999 EOTF\nvec3 linear_to_srgb(vec3 rgb) {\n    return vec3(\n    rgb.r > 0.0031308 ? 1.055*pow(rgb.r,1.0/2.4)-0.055 : 12.92*rgb.r,\n    rgb.g > 0.0031308 ? 1.055*pow(rgb.g,1.0/2.4)-0.055 : 12.92*rgb.g,\n    rgb.b > 0.0031308 ? 1.055*pow(rgb.b,1.0/2.4)-0.055 : 12.92*rgb.b);\n}\n\n// IEC 61966-2-1:1999 sRGB EOTF to Linear Gamma\nvec3 srgb_to_linear(vec3 rgb) {\n    return vec3(\n    rgb.r > 0.04045 ? pow((rgb.r+0.055)/1.055,2.4) : rgb.r/12.92,\n    rgb.g > 0.04045 ? pow((rgb.g+0.055)/1.055,2.4) : rgb.g/12.92,\n    rgb.b > 0.04045 ? pow((rgb.b+0.055)/1.055,2.4) : rgb.b/12.92);\n}\n\n// CIE Standard Illuminant D65, [300, 830] nanometers with 1 nm step size\nconst float[531] cied65 = float[531] (\n0.000341,\n0.003601,\n0.006862,\n0.010122,\n0.013383,\n0.016643,\n0.019903,\n0.023164,\n0.026424,\n0.029685,\n0.032945,\n0.049887,\n0.066828,\n0.083770,\n0.100711,\n0.117652,\n0.134594,\n0.151535,\n0.168477,\n0.185418,\n0.202360,\n0.219177,\n0.235995,\n0.252812,\n0.269630,\n0.286447,\n0.303265,\n0.320082,\n0.336900,\n0.353717,\n0.370535,\n0.373430,\n0.376326,\n0.379221,\n0.382116,\n0.385011,\n0.387907,\n0.390802,\n0.393697,\n0.396593,\n0.399488,\n0.404451,\n0.409414,\n0.414377,\n0.419340,\n0.424302,\n0.429265,\n0.434228,\n0.439191,\n0.444154,\n0.449117,\n0.450844,\n0.452570,\n0.454297,\n0.456023,\n0.457750,\n0.459477,\n0.461203,\n0.462930,\n0.464656,\n0.466383,\n0.471834,\n0.477285,\n0.482735,\n0.488186,\n0.493637,\n0.499088,\n0.504539,\n0.509989,\n0.515440,\n0.520891,\n0.518777,\n0.516664,\n0.514550,\n0.512437,\n0.510323,\n0.508209,\n0.506096,\n0.503982,\n0.501869,\n0.499755,\n0.504428,\n0.509100,\n0.513773,\n0.518446,\n0.523118,\n0.527791,\n0.532464,\n0.537137,\n0.541809,\n0.546482,\n0.574589,\n0.602695,\n0.630802,\n0.658909,\n0.687015,\n0.715122,\n0.743229,\n0.771336,\n0.799442,\n0.827549,\n0.836280,\n0.845011,\n0.853742,\n0.862473,\n0.871204,\n0.879936,\n0.888667,\n0.897398,\n0.906129,\n0.914860,\n0.916806,\n0.918752,\n0.920697,\n0.922643,\n0.924589,\n0.926535,\n0.928481,\n0.930426,\n0.932372,\n0.934318,\n0.927568,\n0.920819,\n0.914069,\n0.907320,\n0.900570,\n0.893821,\n0.887071,\n0.880322,\n0.873572,\n0.866823,\n0.885006,\n0.903188,\n0.921371,\n0.939554,\n0.957736,\n0.975919,\n0.994102,\n1.012280,\n1.030470,\n1.048650,\n1.060790,\n1.072940,\n1.085080,\n1.097220,\n1.109360,\n1.121510,\n1.133650,\n1.145790,\n1.157940,\n1.170080,\n1.170880,\n1.171690,\n1.172490,\n1.173300,\n1.174100,\n1.174900,\n1.175710,\n1.176510,\n1.177320,\n1.178120,\n1.175170,\n1.172220,\n1.169270,\n1.166320,\n1.163360,\n1.160410,\n1.157460,\n1.154510,\n1.151560,\n1.148610,\n1.149670,\n1.150730,\n1.151800,\n1.152860,\n1.153920,\n1.154980,\n1.156040,\n1.157110,\n1.158170,\n1.159230,\n1.152120,\n1.145010,\n1.137890,\n1.130780,\n1.123670,\n1.116560,\n1.109450,\n1.102330,\n1.095220,\n1.088110,\n1.088650,\n1.089200,\n1.089740,\n1.090280,\n1.090820,\n1.091370,\n1.091910,\n1.092450,\n1.093000,\n1.093540,\n1.091990,\n1.090440,\n1.088880,\n1.087330,\n1.085780,\n1.084230,\n1.082680,\n1.081120,\n1.079570,\n1.078020,\n1.075010,\n1.072000,\n1.068980,\n1.065970,\n1.062960,\n1.059950,\n1.056940,\n1.053920,\n1.050910,\n1.047900,\n1.050800,\n1.053700,\n1.056600,\n1.059500,\n1.062390,\n1.065290,\n1.068190,\n1.071090,\n1.073990,\n1.076890,\n1.073610,\n1.070320,\n1.067040,\n1.063750,\n1.060470,\n1.057190,\n1.053900,\n1.050620,\n1.047330,\n1.044050,\n1.043690,\n1.043330,\n1.042970,\n1.042610,\n1.042250,\n1.041900,\n1.041540,\n1.041180,\n1.040820,\n1.040460,\n1.036410,\n1.032370,\n1.028320,\n1.024280,\n1.020230,\n1.016180,\n1.012140,\n1.008090,\n1.004050,\n1.000000,\n0.996334,\n0.992668,\n0.989003,\n0.985337,\n0.981671,\n0.978005,\n0.974339,\n0.970674,\n0.967008,\n0.963342,\n0.962796,\n0.962250,\n0.961703,\n0.961157,\n0.960611,\n0.960065,\n0.959519,\n0.958972,\n0.958426,\n0.957880,\n0.950778,\n0.943675,\n0.936573,\n0.929470,\n0.922368,\n0.915266,\n0.908163,\n0.901061,\n0.893958,\n0.886856,\n0.888177,\n0.889497,\n0.890818,\n0.892138,\n0.893459,\n0.894780,\n0.896100,\n0.897421,\n0.898741,\n0.900062,\n0.899655,\n0.899248,\n0.898841,\n0.898434,\n0.898026,\n0.897619,\n0.897212,\n0.896805,\n0.896398,\n0.895991,\n0.894091,\n0.892190,\n0.890290,\n0.888389,\n0.886489,\n0.884589,\n0.882688,\n0.880788,\n0.878887,\n0.876987,\n0.872577,\n0.868167,\n0.863757,\n0.859347,\n0.854936,\n0.850526,\n0.846116,\n0.841706,\n0.837296,\n0.832886,\n0.833297,\n0.833707,\n0.834118,\n0.834528,\n0.834939,\n0.835350,\n0.835760,\n0.836171,\n0.836581,\n0.836992,\n0.833320,\n0.829647,\n0.825975,\n0.822302,\n0.818630,\n0.814958,\n0.811285,\n0.807613,\n0.803940,\n0.800268,\n0.800456,\n0.800644,\n0.800831,\n0.801019,\n0.801207,\n0.801395,\n0.801583,\n0.801770,\n0.801958,\n0.802146,\n0.804209,\n0.806272,\n0.808336,\n0.810399,\n0.812462,\n0.814525,\n0.816588,\n0.818652,\n0.820715,\n0.822778,\n0.818784,\n0.814791,\n0.810797,\n0.806804,\n0.802810,\n0.798816,\n0.794823,\n0.790829,\n0.786836,\n0.782842,\n0.774279,\n0.765716,\n0.757153,\n0.748590,\n0.740027,\n0.731465,\n0.722902,\n0.714339,\n0.705776,\n0.697213,\n0.699101,\n0.700989,\n0.702876,\n0.704764,\n0.706652,\n0.708540,\n0.710428,\n0.712315,\n0.714203,\n0.716091,\n0.718831,\n0.721571,\n0.724311,\n0.727051,\n0.729790,\n0.732530,\n0.735270,\n0.738010,\n0.740750,\n0.743490,\n0.730745,\n0.718000,\n0.705255,\n0.692510,\n0.679765,\n0.667020,\n0.654275,\n0.641530,\n0.628785,\n0.616040,\n0.624322,\n0.632603,\n0.640885,\n0.649166,\n0.657448,\n0.665730,\n0.674011,\n0.682293,\n0.690574,\n0.698856,\n0.704057,\n0.709259,\n0.714460,\n0.719662,\n0.724863,\n0.730064,\n0.735266,\n0.740467,\n0.745669,\n0.750870,\n0.739376,\n0.727881,\n0.716387,\n0.704893,\n0.693398,\n0.681904,\n0.670410,\n0.658916,\n0.647421,\n0.635927,\n0.618752,\n0.601578,\n0.584403,\n0.567229,\n0.550054,\n0.532880,\n0.515705,\n0.498531,\n0.481356,\n0.464182,\n0.484569,\n0.504956,\n0.525344,\n0.545731,\n0.566118,\n0.586505,\n0.606892,\n0.627280,\n0.647667,\n0.668054,\n0.664631,\n0.661209,\n0.657786,\n0.654364,\n0.650941,\n0.647518,\n0.644096,\n0.640673,\n0.637251,\n0.633828,\n0.634749,\n0.635670,\n0.636592,\n0.637513,\n0.638434,\n0.639355,\n0.640276,\n0.641198,\n0.642119,\n0.643040,\n0.638188,\n0.633336,\n0.628484,\n0.623632,\n0.618779,\n0.613927,\n0.609075,\n0.604223,\n0.599371,\n0.594519,\n0.587026,\n0.579533,\n0.572040,\n0.564547,\n0.557054,\n0.549562,\n0.542069,\n0.534576,\n0.527083,\n0.519590,\n0.525072,\n0.530553,\n0.536035,\n0.541516,\n0.546998,\n0.552480,\n0.557961,\n0.563443,\n0.568924,\n0.574406,\n0.577278,\n0.580150,\n0.583022,\n0.585894,\n0.588765,\n0.591637,\n0.594509,\n0.597381,\n0.600253,\n0.603125);\n\n// CIE Standard Illuminant D65 Spectral Power Distribution\nfloat cie_d65_spd(float lambda) {\n    // lambda: wavelength in nanometers\n\n    int index = int(lambda-300.0);\n\n    if((index < 0) || (index > 530)) return 0.0;\n\n    return mix(cied65[index+0], cied65[index+1], fract(lambda)); // linear interpolation\n}", "buffer_a_code": "struct rng_state_t {\n    uvec4 s0;\n};\n\n// https://www.jcgt.org/published/0009/03/02/\nuvec4 pcg4d(uvec4 v) {\n    v = v * 0x0019660Du + 0x3C6EF35Fu;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v ^= v >> 16u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat urand1(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*float(rng_state.s0.x);\n}\n\nvec2 urand2(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*vec2(rng_state.s0.xy);\n}\n\nvec3 urand3(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*vec3(rng_state.s0.xyz);\n}\n\nvec4 urand4(inout rng_state_t rng_state) {\n    rng_state.s0 = pcg4d(rng_state.s0);\n\n    return 2.32830629776081821092e-10*vec4(rng_state.s0);\n}\n\nfloat sky(vec3 dir, float lambda) {\n    return max(dot(vec3(0,1,0),dir),0.0);\n}\n\n// variable SPD\nfloat spd(float x, float lambda) {\n    float sigma = 1.0/20.0;\n    return exp(-pow((lambda-x)/20.0,2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    rng_state_t rng_state;\n\n    rng_state.s0 = uvec4(fragCoord.x, fragCoord.y, iFrame, 1)+uvec4(1);\n\n    fragCoord = floor(fragCoord) + urand2(rng_state);\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0.0,  0.0,  0.0);\n    vec3 rd = vec3(uv.x, uv.y, -1.0);\n\n    rd = normalize(rd);\n\n    //float lambda = (470.0*(fragCoord.x/iResolution.x))+360.0; fragColor.xyz = cie_1931_xyz_cmf(lambda); return;\n    float lambda = 470.0*urand1(rng_state)+360.0;\n\n    fragColor.r = cie_d65_spd(lambda);\n\n    // portion with spd\n    if(abs(uv.y) < 0.1) fragColor.r = spd(((470.0*(fragCoord.x/iResolution.x))+360.0), lambda);\n\n    fragColor.xyz = cie_1931_xyz_cmf(lambda)*fragColor.r;\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame > 0 ? texelFetch(iChannel1, ivec2(fragCoord), 0) : vec4(0);\n\n    fragColor += texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(fragColor.a != 0.0 ? fragColor.xyz / fragColor.a : fragColor.xyz, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(xyz_to_linear(fragColor.xyz), 1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 263]], "test": "untested"}
{"id": "ddKcDy", "name": "Sum Tetrabrot", "author": "domrally", "description": "Generated using the same formula as the Mandelbrot set, but using the tetration hyperoperation instead of exponentiation. \nx²↑₄ + c = x^x + c instead of x²↑₃ + c = x*x + c\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["fractal", "mandelbrot", "quadratic", "chaotic", "tetration", "hyperoperation"], "likes": 13, "viewed": 438, "published": 3, "date": "1697224268", "time_retrieved": "2024-07-30T17:28:37.682834", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nhttps://mathworld.wolfram.com/ComplexExponentiation.html\n*/\nvec2 exponentiate(vec2 a, vec2 b) {\n    vec2 c;\n    \n    float mag = dot(a, a);\n    float arg = atan(a.g, a.r);\n    \n    float scale = pow(mag, b.r / 2.) * exp(-b.g * arg);\n    float angle = b.r * arg + b.g * log(mag) / 2.;\n    \n    c.r = scale * cos(angle);\n    c.g = scale * sin(angle);\n    \n    return c;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Pixel space to view space\n    vec2 uv = 2. * (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvMouse = 2. * iMouse.xy - iResolution.xy;\n      \n    vec2 orbit, initial;\n\n    orbit = initial = uv;\n            \n    // Simulate the trajectory for this pixel relative to the center of the image.\n    vec2 trapped;\n    float radius = 9e9;\n    for (float i; i < 31.; i++) {\n        // This recursion generates chaotic behavior\n        orbit = exponentiate(orbit, orbit) + initial;\n        // We want to record the nearest approach as the pixel orbits around the image center.\n        float flyby = dot(orbit, orbit);\n        //flyby = distance(orbit, uv);\n        //flyby = abs(orbit.y - uv.y);\n        radius = min(radius, flyby);\n        // The closest point is called the orbit trap.\n        //    https://en.wikipedia.org/wiki/Orbit_trap#Point_based\n        trapped = trapped * float(radius != flyby) + float(radius == flyby) * orbit;\n    }\n    \n    float estimate = smoothstep(0., 1., exp(-length(trapped)));\n    // Find the angle of closest approach of the orbit trap: \n    //    https://en.wikipedia.org/wiki/Argument_(complex_analysis)\n    float angle = atan(trapped.y, trapped.x);\n    //angle = atan(accumulated.y, accumulated.x);\n    // Match the angle to the color wheel: \n    //    https://en.wikipedia.org/wiki/Color_wheel\n    float hue = angle - atan(uvMouse.y, uvMouse.x) + iTime;\n    \n    // Paint the pixel\n    fragColor = oklch2rgb(estimate, estimate, hue);\n}\n\n\n/*\nREFERENCES\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n*/\n\n\n/*\nFURTHER READING\n\nhyperoperations\n\nhttps://en.wikipedia.org/wiki/Tetration\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Spectral_sensitivity\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\n*/\n", "image_inputs": [], "common_code": "/// This page of color space tools adapted from (2022): \n///    https://www.shadertoy.com/view/flSyWz\n/// by Björn Ottosson: \n///    https://www.shadertoy.com/user/bjornornorn\n\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float middle = 0.2;\n    \n    vec3 x = color-middle;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-middle);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return middle + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvec2 approximateShape(float a, float b)\n{\n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1qQA3xhBX3iB8FT8558e5QQnmVZ5Jh1Fb?usp=sharing\n    return vec2(\n        1.63804674 + -0.08431713*a +  0.27624179*b +  0.08737741*a2 +  0.13917503*b2 + 0.03691021*a3 +  0.03060615*b3,\n        0.23438507 + 0.05736278*a  +  -0.09674117*b +  0.024447*a2 + 0.00469441*b2 + 0.01253234*a3 + 0.00741058*b3\n    );\n}\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec4 oklch2rgb(float lightness, float chroma, float hue) {\n    chroma = mix(.0, -.25 * log(.55), chroma);\n    // Translate to Lab color space\n    float a = cos(hue);\n    float b = sin(hue);\n    vec2 gamut = approximateShape(a, b);\n    float saturation = 1. / (gamut.y / (1. - lightness) + gamut.x / lightness);\n    float colorfulness = min(chroma, saturation);\n    a *= colorfulness;\n    b *= colorfulness;\n    vec3 color = oklab_to_linear_srgb(vec3(lightness, a, b));\n    color = softClipColorOutsideGamutOnly(color);\n    color = clamp(color, 0., 1.);\n    color = Srgb3(color);\n    \n    return vec4(color, 1.);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddKcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 90, 125, 125, 399], [402, 402, 457, 490, 1947]], "test": "untested"}
{"id": "ds3BW7", "name": "Elevator to infinity Live Rooms", "author": "iLancer", "description": "original by https://www.shadertoy.com/view/3dlyRN", "tags": ["3d", "raymarching", "ray", "light", "marching", "space", "repetition", "tower", "night", "city", "city", "infinite", "neon", "buildings", "building", "liminal"], "likes": 2, "viewed": 245, "published": 3, "date": "1697223180", "time_retrieved": "2024-07-30T17:28:38.793863", "image_code": "/* Elevator to infinity by @kishimisu (2023)  -  https://www.shadertoy.com/view/mddfW8\n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n   *****************************************\n   \n     Move the camera with the mouse!\n\n   \n   This is my first successful attempt at raymarching infinite buildings.\n   \n   In my previous attempts, I was adding details using domain repetition for\n   nearly all raymarching operators and it was too hard to maintain.\n   \n   In this version, I started with a simpler task, which is to generate only one\n   floor using regular raymarching, and then use domain repetition at the very \n   beginning to repeat the floor infinitely, thus creating infinite buildings.\n      \n   [Update 10/13]: Now with much more lights! (can be disabled)\n   \n   Do you have tips to reduce flickering in the distance ?\n*/\n\n// Comment out to disable all lights except elevators\n#define LIGHTS_ON\n#define LIVE_ROOMS // audio channel 1\n\nfloat acc = 0.; // Neon light accumulation\nfloat occ = 1.; // Ambient occlusion (Fake)\n\n// 2D rotation\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// Domain rep.\n#define rep(p, r) (mod(p+r, r+r) - r)\n\n// Domain rep. ID\n#define rid(p, r) floor((p+r)/(r+r))\n\n// Finite domain rep\n#define lrep(p, r, l) p-(r+r)*clamp(round(p/(r+r)), -l, l)\n\n// Fast random noise 2 -> 3\nvec3 hash(vec2 p) {\n    vec2 r = fract(sin(p*mat2(137.1, 12.7, 74.7, 269.5)) * 43478.5453);\n    return vec3(r, fract(r.x*r.y*1121.67));\n}\n// Random noise 3 -> 3 - https://shadertoyunofficial.wordpress.com/2019/01/02/\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\n\n// Distance functions - https://iquilezles.org/articles/distfunctions/\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\nfloat rect(vec2 p, vec2 b ) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\n#define ext 2.\nfloat opElevatorWindows(vec3 p, float b) {\n    float e  = box(p, vec3(ext*.8, 2.7, .3));\n    float lv = length(p.xz) - .1;   p.y += 1.;\n    float lh = length(p.yz) - .1;\n    lh = max(b, lh);\n    b  = max(b, -e);\n    b  = min(b, min(lv, lh));\n    return b;\n}\n\nfloat building(vec3 p0, vec3 p, float L) {\n    float B = rect(p.xz, vec2(L, 10)); // Main building   \n    float B2 = rect(vec2(abs(p.x)-L-ext, p.z), vec2(ext, 10)); // Elevator building\n    \n    // (Optim) Skip building calculations\n    if (min(B, B2) > .2) return min(B, B2);\n    \n    vec3 q = p;\n    float var = step(1., mod(rid(p.y, 3.), 6.)); // Railing variation\n    p.y = rep(p.y, 3.); // Infinite floor y-repetition\n    vec3 pb = vec3(abs(p.x), p.yz);\n\n#ifdef LIGHTS_ON\n    // Building lights\n    vec3  id = rid(vec3(q.xy, p0.z), vec3(21, 18, 48));\n    vec3  rn = hash33(id);\n    float rw = fract(rn.x*rn.z*1021.67);\n        \n    q.x += 14. * (rn.x*3.-1.);\n    q.y += 12. * (floor(rn.y*3.)-1.);\n    q.xy = rep(q.xy, vec2(21, 18));\n\n    float l = box(q, vec3(mix(3., 15., rw), rn.z*1.5+.5, 7));\n\n\t#ifdef LIVE_ROOMS\n\t\tacc += .5 / (1. + pow(abs(l)*20., 1.5)) \n\t\t\t\t\t* smoothstep(0., .4, iTime - rw * 20.)\n\t\t\t\t\t* step(p0.x, 10. + 2e2*step(20., abs(p0.z))) * texture(iChannel1, vec2(rn.y, 0.)).r;\n\t#else\n\t\tacc += .5 / (1. + pow(abs(l)*20., 1.5)) \n\t\t\t\t\t* smoothstep(0., .4, iTime - rw * 20.)\n\t\t\t\t\t* step(p0.x, 10. + 2e2*step(20., abs(p0.z)));\n\t#endif\n#endif\n    \n    // Occlusion\n    occ = min(occ, smoothstep(3.5, 0., -rect(p.xz, vec2(L+2.,10))));    \n    occ = min(occ, smoothstep(.6, 0., -rect(pb.xz-vec2(L+ext,0), vec2(ext,10))));\n    \n    // Front hole\n    q = p;\n    q.x = rep(q.x, 7.);    \n    q.y -= (1. - var)*1.01;\n    \n    float f = box(q + vec3(0,0,10), vec3(6.6, 2. + var, 3));\n    B = max(B, -f);\n    B = max(B, -rect(q.xz + vec2(0,10), vec2(6.6, .7)*var));\n    \n    // Railing\n    q = p;\n    q.x = rep(q.x, .8);\n    \n    float r = length(p.yz + vec2(1,9.5-var*.5)) - .2;\n    float rv = length(q.xz + vec2(0,9.5-var*.5)) - .16;\n    r = min(r, rv);\n    r = max(r, p.y + 1.);\n\n    // Back bars\n    q = p;\n    q.x = rep(q.x, 1.75);\n    \n    float b = length(q.xz + vec2(0,7.3)) - .2;\n    r = min(r, b);\n    \n    B = min(B, r);\n    B = max(B, abs(p.x) - L);\n            \n    // (Optim) Skip elevator calculations\n    if (B2 > .04) return min(B, B2);\n    \n    // Elevator\n    B2 = opElevatorWindows(pb - vec3(L+ext,0,-9.9), B2);\n    B2 = opElevatorWindows(vec3(pb.z+8., pb.y, pb.x-L-ext-1.9), B2);\n\n    // Side windows\n    q = vec3(pb.xy, pb.z - 1.8);\n    q.z = lrep(q.z, 1.25, 2.);\n    \n    float w = box(q - vec3(L+ext*2.,1.2,0), vec3(.5, 1.6, 1.2));\n    B2 = max(B2, -w);\n                \n    return min(B, B2);\n}\n\nfloat map(vec3 p) {\n    vec3 p0 = p;\n    vec2 id = vec2(step(40., p.x), rid(p.z, 140.));  \n    vec3 rn = mix(vec3(1, -.5, 0), hash(id), step(.5, id.x+id.y));\n        \n    // Buildings\n    p.x = abs(abs(p.x - 40.) - 80.);\n    p.z = rep(p.z - id.x*200., 200.);\n    \n    float bL = 21.4 + id.y*3.;\n    float b1 = building(p0, p - vec3(30,0,0), bL);\n    float b2 = building(p0, vec3(p.z,p.y,-p.x), 185.);\n    \n    // Elevator lights\n    float rpy = 80. + 150. * rn.x;;\n    p.y = rep(p.y - iTime * 40. * (rn.y*.5+.5), rpy);\n    p -= vec3(30.+bL+ext, rn.z*rpy*.5, ext-10.);\n\n    float l = box(p, vec3(ext*.8, 2.7, ext*.8));\n    acc += .5 / (1. + pow(abs(l)*18., 1.2));\n    \n    // Fix broken distance before 20s\n    b2 = min(b2, abs(p0.x + p0.z - 30.) + 6.);\n\n    return min(b1, b2);\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 normal(vec3 p) {\n    const vec2 k = vec2(1,-1)*.0001;\n    return normalize(k.xyy*map(p + k.xyy) + k.yyx*map(p + k.yyx) + \n                     k.yxy*map(p + k.yxy) + k.xxx*map(p + k.xxx));\n}\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2  R = iResolution.xy,\n          u = (F+F-R)/R.y,\n          M = iMouse.xy/R * 2. - 1.;\n          M *= step(1., iMouse.z);\n    \n    // Animations\n    float T  = 1. - pow(1. - clamp(iTime*.025, 0., 1.), 3.);\n    float ax = mix(-.8, .36, T);\n    float ay = mix(-40., -140., T);\n    float rx = ax + M.x*.45 - .75 - (cos(iTime*.1)*.5+.5) *.4 + .2;\n    rx = clamp(rx, min(iTime*.05 - 1.6, -.9), .1);\n     \n    // Ray origin & direction\n    vec3 ro = vec3(0, iTime*10., ay);\n    vec3 rd = normalize(vec3(u, 3));\n    \n    rd.zy *= rot(M.y * 1.3); \n    rd.zx *= rot(rx); \n    ro.zx *= rot(rx); \n   \n    // Raymarching\n    vec3  p; \n    float t, d; \n    for (int i = 0; i < 60; i++) {\n        p = ro + t * rd; \n        t += d = map(p);\n        if (d < .01 || t > 2200.) break;\n    }\n    \n    // Base color\n    vec3 col = vec3(.13,.11,.26) - vec3(1,1,0)*abs(p.x-40.)*.001;\n    col *= clamp(1. + dot(normal(p), normalize(vec3(0,0,1))), .5, 1.);\n    \n    // Texture\n    col *= 1. - texture(iChannel1, vec2(p.x+p.z, p.y+p.z)*.05).rgb*.7;\n    \n    // Occlusion\n    col *= occ;\n    \n    // Exponential fog\n    col = mix(vec3(.002,.005,.015), col, exp(-t*.0025*vec3(.8,1,1.2) - length(u)*.5));\n\n    // Light accumulation\n    col += acc * mix(vec3(1,.97,.76), vec3(1,.57,.36), t*.0006);\n       \n    // Color correction\n    col = pow(col, .45*vec3(.98,.96,1));\n    \n    // Vignette\n    u = F/R; u *= 1. - u.yx;\n    col *= pow(clamp(u.x * u.y * 80., 0., 1.), .2);\n                   \n    O = vec4(col, 1);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3BW7.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1416, 1444, 1463, 1463, 1581], [1779, 1850, 1877, 1877, 1966], [1967, 1967, 1996, 1996, 2079], [2096, 2096, 2138, 2138, 2353], [2355, 2355, 2397, 2397, 4780], [4782, 4782, 4801, 4801, 5561], [5563, 5610, 5631, 5631, 5805], [5807, 5807, 5843, 5843, 7338]], "test": "untested"}
{"id": "dd3fWN", "name": "Shifting effect", "author": "fishy", "description": "A thing I tried to make as small as I possibly could. Update 10/17/2023: replaced variable c with o", "tags": ["lens", "sine", "chromatic", "diffraction", "abberation", "shift"], "likes": 10, "viewed": 225, "published": 3, "date": "1697220553", "time_retrieved": "2024-07-30T17:28:39.734349", "image_code": "void mainImage(out vec4 o, vec2 u)\n{\n    u = (u*2.-iResolution.xy)/iResolution.y;\n    \n    o = sin(length(u)*vec4(9, 10, 11, 0)-iTime)*.5+.5;\n    float h = .5-u.x*u.x*u.x*u.x*.04;\n    o *= smoothstep(h, h-.5,  u.y)*smoothstep(h, h-.5, -u.y);\n    \n    o = 3.*o*o-2.*o*o*o;\n}\n\n\n/* old version 228 chars\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u = (u*2.-iResolution.xy)/iResolution.y;\n    \n    vec3 c = sin(length(u)*vec3(9, 10, 11)-iTime)*.5+.5;\n    float h = .5-u.x*u.x*u.x*u.x*.04;\n    c *= smoothstep(h, h-.5,  u.y)*smoothstep(h, h-.5, -u.y);\n    \n    o = vec4(3.*c*c-2.*c*c*c, 1);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3fWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 273]], "test": "untested"}
{"id": "ddcBWM", "name": "3D Sierpinksi [322 Chars]", "author": "SnoopethDuckDuck", "description": "Forked from iq, its not super pretty :|:|:|:|:|:|:|:", "tags": ["3d", "raymarching", "fractal", "distancefield", "distance", "sierpinski", "golf"], "likes": 11, "viewed": 202, "published": 3, "date": "1697217719", "time_retrieved": "2024-07-30T17:28:40.919182", "image_code": "#define F(n) for(int i; i < n; i++)\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    float t, // Distance travelled\n          m, // Min distance to scene\n          d, // Temp distance\n          f = .5;\n    \n\tvec3 p, // Position\n         q, // Temp position\n         R = iResolution;\n         \n    // Marching loop\n\tF(99)\n    {\n        // Move in ray direction, and rotate\n        //p = .8-t + t * (u+u-R.xy).xyx/R.y * vec3(f, .7, -f);  \n        p = f-t + t * (vec3(u+u, 0)-R)/R.y;\n        p.xz *= mat2(cos(.3*iTime+ vec4(0,11,33,0)));\n        \n        // Fun\n        // p.z -= .05*cos(p.y*9.-iTime*4.);        \n        \n        // Four tetrahedron points\n        mat4x3 M = -mat4x3(0, -f,  0,\n                           0,  1,  -1,\n                          -1,  1,  f,\n                           1,  1,  f);      \n         \n        // SDF fractal loop\n        F(9) \n        {\n            // Ensure d<m for i=0 in loop below\n            m += d;\n            \n            // Find closest distance d and tetrahedron point q\n            F(4)\n                d = length(p-M[i]), d<m ? m=d, q=M[i] : q;\n                \n            // Rescale and centre toward closest tetrahedron point\n            p += p - q;\n        }        \n        \n        if (m < 1. || t > 5.) \n            break;\n            \n        t += m / 1e3;\n    }\n\n    //o.rgb = t < 5. ? cos(p) : p/p;\n    o = 0.*o + t; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "dstfD4", "name": "Walk on Spooky Distance Field", "author": "minHieu", "description": "walk-on-sphere implementation of curve inflation", "tags": ["sdf", "spooky", "wos", "walkonsphere"], "likes": 5, "viewed": 246, "published": 3, "date": "1697191291", "time_retrieved": "2024-07-30T17:28:41.758936", "image_code": "/*\nvec2 intensity(float d) {\n    float i = min(sin(d*330.+ 20.2*iTime), 0.4);\n    // return vec2(min(sin(d*330.+ 20.2*iTime), 0.4));\n    return vec2(0);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(data.xyz / data.w, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI  3.14159\n#define PI2 6.28319\n#define EPS 0.0001\nconst int MAX_WALKS = 20;\nconst int MAX_SAMPLES = 10;\n// misc function \nfloat get_t() {\n  return 20.*fract(float(iFrame)*0.005);\n}\n\n// Scene geometry\nfloat circ_sdf(vec2 q, vec2 c, float r) {\n    return length(q-c)-r;\n}\nfloat rect_sdf(vec2 q, vec2 c, vec2 halfsize) {\n    vec2 d = abs(q-c)-halfsize;\n    float idist = length(max(d,0.));\n    float odist = min(max(d.x,d.y),0.);\n    return idist+odist;\n}\nfloat union_sdf(float d1, float d2) {\n    return min(d1,d2);\n}\nfloat sub_sdf(float d1, float d2) {\n    return max(d1,-d2);\n}\n// scene sdf. \n// negative indicates outside (red).\n// positive indicates inside (blue).\nfloat main_sdf(vec2 uv) { \n    float d1 = circ_sdf(uv, vec2(.5,.6), .25);\n    float d2 = rect_sdf(uv, vec2(.5,.5), vec2(0.1, 0.3));\n    float eye1 = circ_sdf(uv, vec2(.58,.58), .05);\n    float eye2 = circ_sdf(uv, vec2(.42,.58), .05);\n    float head = sub_sdf(sub_sdf(union_sdf(d1,d2),eye1),eye2);\n    // float head = union_sdf(d1,d2);\n    float mouth = union_sdf(\n        union_sdf(circ_sdf(uv, vec2(.5,.45), .05),\n                  circ_sdf(uv, vec2(.5,.35), .05)),\n        rect_sdf(uv, vec2(.5,.4), vec2(.05, 0.05))\n    );\n    return -sub_sdf(head, mouth);\n}\n\n\n// from Alex Jacobson's Curve Inflation \n// https://www.shadertoy.com/view/7tyyzW\nint  seed = 1;\nvoid srand(int s) {\n    seed = s;\n}\nint randi(void) {\n    seed = seed * 0x343fd + 0x269ec3;\n    return (seed >> 16) & 32767;\n}\nfloat rand(void) {\n    return float(randi())/32767.0;\n}\nint hash( int n ) {\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\nvec2 rand_circ(void) {\n    float theta = PI2*rand();\n    return vec2(cos(theta),sin(theta));\n}\n\n// green function of ball at x B(x) of radius R\n// following https://dl.acm.org/doi/abs/10.1145/3386569.3392374\n// Supplementary B1. This evaluate G at a random sample.\nfloat G(float R) {\n    float r = R*sqrt(rand()+0.001);\n    return log(R/r)/PI2;\n}\nvec2 grad_G(float R) {\n    float r = R*sqrt(rand());\n    float theta = rand() * PI2;\n    vec2 dir = vec2(cos(theta),sin(theta));\n    return dir / PI2 * (1./(r*r) - 1./(R*R));\n}\n\n// Curve inflation is the solution to the \n// poisson equation: \n// ∆u = -4 on Ω  (f = -4) \n//  u = 0  on ∂Ω (g = 0)\n// return  u and grad_u.\nvec3 wos(vec2 x) {\n    float R = main_sdf(x);      // distance to border\n    float u = 0.;               // PDE estimator \n    vec2 grad_u = vec2(0.);\n    \n    float R1 = R;\n    vec2 v1;\n    \n    if (R <= 0.) return vec3(0.);       // outside scene\n    \n    for (int k = 0; k < MAX_WALKS; k++) {\n        if (R < EPS) break;\n        u += PI*R*R*G(R);\n        // u += R*R;\n        vec2 v = rand_circ();\n        \n        x += R * v;\n        R = main_sdf(x);\n        \n        if (k == 0) v1 = v;\n    }\n    \n    grad_u = 2./R1*u*v1;\n    return vec3(u, grad_u);\n}\n\n// return color value at point with inflated height z\n// https://www.shadertoy.com/view/7tyyzW\nvec4 shading(vec2 uv, float u, vec2 grad_u) {    \n    vec3 Kd = vec3(0.76, 0.31, 0.31); // diffuse\n    vec3 Ks = vec3(1.,1.,1.);         // specular \n    vec3 Kf = 0.4*Ks;\n    vec3 Ka = 0.1*Kd;               \n    \n    if(u <= 0.0) return vec4(Ka, 1.0);\n\n    float z = sqrt(u);\n    vec3 n = normalize(vec3(-grad_u*0.5/z,1));\n    \n    const int nlights = 2;\n    vec3 lights[nlights];\n    lights[0] = normalize(vec3(1.5,2.,1.));\n    lights[1] = normalize(vec3(-1.5,2.,1.));\n    vec3 Kl[nlights];\n    Kl[0] = vec3(1.,0.6,0.6);\n    Kl[1] = vec3(.6,0.6,1.0);\n    vec3 color = vec3(0.,0.,0.);\n    vec3 p = vec3(uv,z);\n    vec3 c = vec3(0.,0.,5.);\n    vec3 v = normalize(c-p);\n    for(int i = 0;i<2;i++) {\n        vec3 l = lights[i];\n        float d = max(dot(n,l),0.);\n        vec3 h = normalize(l+v);\n        float s = pow(max(dot(n,h),0.),100.);\n        color += Kl[i]*(Kd*d+Ks*s);\n    }\n    float NE = dot(n,v);\n    float f = pow(max(sqrt(1. - NE*NE),0.0), 50.);\n    color += Kf*f+Ka;\n    \n    return vec4(color,1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize coordinate\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iResolution.x > iResolution.y) {\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x += .5 * (1. - iResolution.x / iResolution.y);\n    } else {        \n        uv.y *= iResolution.y / iResolution.x;\n        uv.y += .5 * (1. - iResolution.y / iResolution.x);\n    }\n    \n    // set random seed \n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x + hash(q.y + hash(iFrame))));\n    \n    // poisson solve \n    vec3 u_gradu = vec3(0.);\n    for (int i = 0; i < MAX_SAMPLES; i++) {\n        u_gradu += wos(uv);\n    }\n    u_gradu /=  float(MAX_SAMPLES);\n    \n    // rendering \n    vec4 fColor = shading(uv, u_gradu.x, u_gradu.yz);\n    \n    if(get_t() < 0.3) {\n        fragColor = fColor;\n    } else {\n        vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        fragColor = data + fColor;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 216, 216, 325]], "test": "untested"}
{"id": "msdBD4", "name": "Canny Edge", "author": "nickooms", "description": "canny edge", "tags": ["cannyedge"], "likes": 1, "viewed": 329, "published": 3, "date": "1697189646", "time_retrieved": "2024-07-30T17:28:42.654541", "image_code": "// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n#define tickness 3.\n\nfloat getAve(vec2 uv){\n    vec3 rgb = texture(iChannel0, uv).rgb;\n    vec3 lum = vec3(0.299, 0.587, 0.114);\n    return dot(lum, rgb);\n}\n\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir){\n    vec4 mous = iMouse/iResolution.xyxy*.1;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n    float np = getAve(uv + (vec2(-1,+1) + dir ) * texel * tickness);\n    float zp = getAve(uv + (vec2( 0,+1) + dir ) * texel * tickness);\n    float pp = getAve(uv + (vec2(+1,+1) + dir ) * texel * tickness);\n    \n    float nz = getAve(uv + (vec2(-1, 0) + dir ) * texel * tickness);\n    // zz = 0\n    float pz = getAve(uv + (vec2(+1, 0) + dir ) * texel * tickness);\n    \n    float nn = getAve(uv + (vec2(-1,-1) + dir ) * texel * tickness);\n    float zn = getAve(uv + (vec2( 0,-1) + dir ) * texel * tickness);\n    float pn = getAve(uv + (vec2(+1,-1) + dir ) * texel * tickness);\n    \n    // np zp pp\n    // nz zz pz\n    // nn zn pn\n    \n    #if 0\n    float gx = (np*-1. + nz*-2. + nn*-1. + pp*1. + pz*2. + pn*1.);\n    float gy = (np*-1. + zp*-2. + pp*-1. + nn*1. + zn*2. + pn*1.);\n    #else\n    // https://www.shadertoy.com/view/Wds3Rl\n    float gx = (np*-3. + nz*-10. + nn*-3. + pp*3. + pz*10. + pn*3.);\n    float gy = (np*-3. + zp*-10. + pp*-3. + nn*3. + zn*10. + pn*3.);\n    #endif\n    \n    vec2 G = vec2(gx,gy);\n    \n    float grad = length(G);\n    \n    float angle = atan(G.y, G.x);\n    \n    return vec4(G, grad, angle);\n}\n\n// Make edge thinner.\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx){\n\n    vec4 edge = sobel(fragCoord, vec2(0));\n\n    vec2 dir = vec2(cos(edge.w), sin(edge.w));\n    dir *= vec2(-1,1); // rotate 90 degrees.\n    \n    vec4 edgep = sobel(fragCoord, dir);\n    vec4 edgen = sobel(fragCoord, -dir);\n\n    if(edge.z < edgep.z || edge.z < edgen.z ) edge.z = 0.;\n    \n    return vec2(\n        (edge.z > mn) ? edge.z : 0.,\n        (edge.z > mx) ? edge.z : 0.\n    );\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx){\n\n    vec2 np = hysteresisThr(fragCoord + vec2(-1,+1), mn, mx);\n    vec2 zp = hysteresisThr(fragCoord + vec2( 0,+1), mn, mx);\n    vec2 pp = hysteresisThr(fragCoord + vec2(+1,+1), mn, mx);\n    \n    vec2 nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx);\n    vec2 zz = hysteresisThr(fragCoord + vec2( 0, 0), mn, mx);\n    vec2 pz = hysteresisThr(fragCoord + vec2(+1, 0), mn, mx);\n    \n    vec2 nn = hysteresisThr(fragCoord + vec2(-1,-1), mn, mx);\n    vec2 zn = hysteresisThr(fragCoord + vec2( 0,-1), mn, mx);\n    vec2 pn = hysteresisThr(fragCoord + vec2(+1,-1), mn, mx);\n    \n    // np zp pp\n    // nz zz pz\n    // nn zn pn\n    //return min(1., step(1e-3, zz.x) * (zp.y + nz.y + pz.y + zn.y)*8.);\n    //return min(1., step(1e-3, zz.x) * (np.y + pp.y + nn.y + pn.y)*8.);\n    return min(1., step(1e-2, zz.x*8.) * smoothstep(.0, .3, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y)*8.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 mous = iMouse/iResolution.xyxy*.1;\n    float edge = cannyEdge(fragCoord, mous.x*5., mous.y*30.);\n    fragColor = mix(vec4(0,0,0,1), vec4(1,1,1,0), 1.-edge);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 125, 125, 238], [240, 256, 293, 293, 1538], [1540, 1562, 1617, 1617, 2004], [2006, 2006, 2058, 2058, 2948], [2950, 2950, 3006, 3006, 3174]], "test": "untested"}
{"id": "dddBD4", "name": "Simple square", "author": "spit1ire", "description": "Simple square", "tags": ["square"], "likes": 0, "viewed": 103, "published": 3, "date": "1697189395", "time_retrieved": "2024-07-30T17:28:43.439442", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    uv.x /= iResolution.y/iResolution.x;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float size = sin(iTime);\n    vec2 min = step(-size, uv);\n    vec2 max = step(size, uv);\n    \n    float rect = (min.x - max.x) * (min.y - max.y);\n\n    // Output to screen\n    fragColor = vec4(vec3(rect), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 504]], "test": "untested"}
{"id": "ctfGR8", "name": "Spatial Aliasing", "author": "mla", "description": "Spatial Aliasing: a nice example from Keenan Crane: sin(|z|²) for varying large z. Either zooms out rapidly, or if mouse pressed, scales (exponentially) according to mouse x.", "tags": ["aliasing", "spatial"], "likes": 10, "viewed": 367, "published": 3, "date": "1697182275", "time_retrieved": "2024-07-30T17:28:44.276205", "image_code": "// Spatial Aliasing, mla, 2023.\n// A nice example from Keenan Crane\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 z = fragCoord-0.5*iResolution.xy;\n    z *= 2.0/iResolution.y;\n    if (iMouse.z > 0.0) z *= exp2(20.0*iMouse.x/iResolution.x);\n    else z *= pow(1.0+0.5*iTime,2.0);\n    float t = mod(dot(z,z),TWOPI);\n    vec3 col = vec3(sin(t+0.5*vec3(0,2,4)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctfGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 179, 179, 465]], "test": "untested"}
{"id": "DsdfRn", "name": "spqr domin trick 9", "author": "spqr", "description": "a", "tags": ["a"], "likes": 5, "viewed": 145, "published": 3, "date": "1697181223", "time_retrieved": "2024-07-30T17:28:45.190760", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n   // return max(max(q.x,q.y),q.z);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm( vec2 a)\n{\n    vec3 p = vec3(a,1.);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat field (vec3 p, float scale) {\n  \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n  \n   float ball = box(p, vec3(f1 * .4));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\nfloat map (vec3 p){\n    // geo\n    float pos = p.y+1.;\n\n    for (float i = 1.; i < 8.; i++) {\n        pos = max(pos, -field(p,pow(2.,i)/16.));\n    }\n    \n    return pos;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\nfloat glider(float t) {\n    float dip_interval = 20.0;\n    float dip_depth = 10.0;\n    \n    // Up and down fluctuating motion\n    float y_sine = 5.0 * sin(0.2 * t);\n    \n    // Time since last dip\n    float time_since_last_dip = mod(t, dip_interval);\n    \n    // Modulating function that drops quickly but recovers slowly\n    float modulating_func = 1.0 - sin(time_since_last_dip + 0.5 * sin(time_since_last_dip));\n    \n    // Gaussian dip function\n    float y_gauss = -dip_depth * exp(-pow((time_since_last_dip - dip_interval / 2.0), 2.0) / (2.0 * pow((dip_interval / 6.0), 2.0)));\n    \n    // Continuously blend the Gaussian and sinusoidal functions, modulated by the new function\n    float h = y_sine + y_gauss * modulating_func;\n    \n    // Scale the output by a factor of 3\n    h /= 3.0;\n    \n    return h;\n}\n\nfloat gliderfbm(float t) {\n  float n = 0.;\n  n += glider(t);\n  n += glider((t+5.12) * 2.)/2.;\n  //n += glider((t+11.42) * 4.)/4.;\n  return n;\n  \n}\nfloat fbmao (vec3 p, vec3 n, float aodist ) {\n    float val = 0.;\n    for (float i = 0.; i < 2.; i++) {\n        val += (getao(p,n,aodist *.2 * pow(1.5,i))* 0.5 + 0.5)/(i+1.);\n    }\n    return +val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime;\n \n  // nav\n\n\n\n  vec3 s = vec3(0.,3.,-6);\n  vec3 t = vec3(0,-1,0);\n  \n  vec3 fwd = vec3(0,0,3) * iTime;\n  \n  s += fwd;\n  t += fwd;\n \n  s += lattice(tt)*7.;\n  t += lattice(tt+3.9)*7.;\n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <100.; ++z) {\n    i = z;\n    d=abs(map(p));\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light1 = normalize(vec3(-1));// + t)/2.;//normalize(vec3(5,-5,-1));\n  vec3 light2 = normalize(vec3(2,3,-5));// + t)/2.;//normalize(vec3(5,-5,-1));\n\n  \n  if (dot(n,light1) < 0.) {\n      light1 = -light1;\n  }\n   if (dot(n,light2) < 0.) {\n      light2 = -light2;\n  }\n  \n  \n  vec3 col = vec3(.6)*1.3;\n  float aodist = .4;\n  \n  float fresnel = 1. - dot(n,r);\n  float ao =(getao(p,n,aodist*0.35)*0.5+0.5);\n  //float ao =// fbmao(p,n,aodist *.2);\n  //    (getao(p,n,aodist*.2)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.35)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.5)*0.5+0.5);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff1 = dot(n,light1)*.5+.5;\n  float diff2 = dot(n,light2)*.5+.5;\n \n  float spec1 =pow(max(dot(reflect(-light1,n),-r),0.),1.) * 1.;\n  float spec2 =pow(max(dot(reflect(-light2,n),-r),0.),1.) * 1.;\n  //float iff = pow(1.-i/100.,2.);\n  \n  \n  //col *= diff;\n  col *= ao;\n  col *= (spec1 + spec2)/2.;\n  col *= (diff1 + diff2)/2.;\n // col *= spec2;\n  \n  //col += fresnel;\n  //col *= diff;\n\n  \n \n \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n  //col = vec3(1) * fbm(uv*10.+iTime);\n \n  //col = vec3(1) * fbm(uv*10.);\n  if (length(col) > 1.5) {\n      col = vec3(0);\n  }\n  col = smoothstep(0.,1.,col)*2.;\n  //col = sqrt(col);\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [950, 950, 973, 973, 1068], [1070, 1070, 1097, 1097, 1179], [1181, 1181, 1209, 1209, 1336], [1338, 1338, 1360, 1360, 1450], [1451, 1451, 1472, 1472, 1763], [1765, 1765, 1785, 1785, 1968], [1969, 1969, 1998, 1998, 2026], [2027, 2027, 2062, 2062, 2306], [2307, 2307, 2326, 2337, 2478], [2480, 2480, 2499, 2499, 2618], [2620, 2620, 2640, 2640, 2737], [2739, 2739, 2780, 2780, 2826], [2827, 2827, 2849, 2849, 2906], [2907, 2907, 2931, 2931, 3069], [3071, 3071, 3094, 3094, 3884], [3886, 3886, 3912, 3912, 4032], [4033, 4033, 4078, 4078, 4232], [4234, 4234, 4291, 4291, 6399]], "test": "untested"}
{"id": "DdSGWm", "name": "voxel_traversal", "author": "danzabarr", "description": "voxel traversal", "tags": ["voxel", "traversal"], "likes": 1, "viewed": 130, "published": 3, "date": "1697181049", "time_retrieved": "2024-07-30T17:28:46.070408", "image_code": "\nconst int MAX_STEPS = 100;\nconst int SIZE = 8;\n\n\nint blocks[SIZE * SIZE * SIZE] = int[SIZE * SIZE * SIZE]\n(\n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0,\n    \n    1,1,1,1,1,1,1,1, \n    0,0,0,0,0,0,0,1, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,2, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0, \n    0,0,0,0,0,0,0,0\n    \n   \n    \n    \n);\n\n\n\nstruct Result {\n\n    vec3 position;\n    vec3 cell;\n    vec3 normal;\n    float depth;\n    int block_id;\n};\n\n    \nfloat Frac0(float x)\n{\n    return x - floor(x);\n}\n\nfloat Frac1(float x)\n{\n    return 1. + ceil(x) - x;\n}\n\nvec3 color(int block_id)\n{\n\n    if (block_id == 1) return vec3(1, 0, 0);\n    if (block_id == 2) return vec3(0, 1, 0);\n    if (block_id == 3) return vec3(0, 0, 1);\n\n    return vec3(0);\n}\n    \n\n\nint getBlock(int x, int y, int z)\n{\n    if (x < 0 || x >= SIZE)\n        return 0;\n    if (y < 0 || y >= SIZE)\n        return 0;\n    if (z < 0 || z >= SIZE)\n        return 0;\n\n    int index = (x + y * SIZE + z * SIZE * SIZE);\n    \n    return blocks[index];\n}\n\nint setBlock(int x, int y, int z, int block_id)\n{\n    if (x < 0 || x >= SIZE)\n        return -1;\n    if (y < 0 || y >= SIZE)\n        return -1;\n    if (z < 0 || z >= SIZE)\n        return -1;\n\n    int index = (x + y * SIZE + z * SIZE * SIZE);\n    \n    int old_id = blocks[index];\n\n    blocks[index] = block_id;\n    \n    return old_id;\n}\n\nfloat intbound(float s, float ds) \n{\n\n    if (ds < 0. && abs(round(s) - s) < 0.0001)\n        return 0.;\n\n    if (ds > 0.)\n        return (1. + ceil(s) - s) / abs(ds);\n    else\n        return (s - floor(s)) / abs(ds);\n}\n\nvec3 intbound(vec3 s, vec3 ds)\n{\n    return vec3\n    (\n        intbound(s.x, ds.x),\n        intbound(s.y, ds.y),\n        intbound(s.z, ds.z)\n    );\n}\n\n\nResult voxelTraversal(vec3 ro, vec3 rd)\n{\n    \n    vec3 tMax, tDelta;\n    vec3 cell = floor(ro);\n    vec3 st = sign(rd);\n    vec3 normal;\n\n    tDelta = st / rd;\n    tMax = intbound(ro, rd);\n    \n    cell = floor(ro);\n    float depth = 0.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd * depth;\n        int block_id = getBlock(int(cell.x), int(cell.y), int(cell.z));\n\n        if (block_id != 0)\n            return Result(pos, cell, normal, depth, block_id);\n        \n        depth = min(tMax.x, min(tMax.y, tMax.z));\n\n        \n        if (tMax.x < tMax.y)\n        {\n        \n            if (tMax.x < tMax.z)\n            {\n                tMax.x += tDelta.x;\n                cell.x += st.x;\n                normal = vec3(-st.x, 0, 0);\n            }\n            else \n            {\n                tMax.z += tDelta.z;\n                cell.z += st.z;\n                normal = vec3(0, 0, -st.z);\n            }\n        }\n        else\n        {\n            if (tMax.y < tMax.z)\n            {\n                tMax.y += tDelta.y;\n                cell.y += st.y;\n                normal = vec3(0, -st.y, 0);\n            }\n            else \n            {\n                tMax.z += tDelta.z;\n                cell.z += st.z;\n                normal = vec3(0, 0, -st.z);\n            }\n        }\n    }\n    \n\n    return Result(vec3(0), vec3(0), vec3(0), 10000000000000.0, 0);\n}\n\nfloat GetLight(vec3 p, vec3 cell, vec3 n) {\n    vec3 lightPos = vec3(-1, 5, -3);\n    lightPos.xz -= vec2(sin(iTime), cos(iTime)) * 8.;\n    vec3 l = normalize(lightPos);\n    \n    //diffuse\n    float dif = 1.;\n    dif = clamp(dot(l, n), 0., 1.);\n\n    float lightDist = 30.0;\n    //shadows\n    \n    Result traversal = voxelTraversal(p + n * 0.01, l);\n    float d = traversal.depth;\n    \n    //float d = RayMarch(p + n * SURF_DIST * 2., l);\n    if (traversal.block_id != 0 && d <= lightDist) dif *= .1;\n    \n    return dif;\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat PI = 3.1415926535;\nfloat EPSILON = 0.001;\n\n\n// a[0]i + a[1]j + a[2]k + a[3]\nvec4 qmult(vec4 a, vec4 b) {\n    return vec4(\n        a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0],\n        -a[0] * b[2] + a[1] * b[3] + a[2] * b[0] + a[3] * b[1],\n        a[0] * b[1] - a[1] * b[0] + a[2] * b[3] + a[3] * b[2],\n        - a[0] * b[0] - a[1] * b[1] - a[2] * b[2] + a[3] * b[3]\n    );\n}\n\n// rotation by quaternion\nvec3 qrot(vec4 q, vec3 x) {\n    vec4 x_prime = vec4(x, 0.0);\n    vec4 q_bar = vec4(-q.xyz, q.w);\n    return qmult(qmult(q, x_prime), q_bar).xyz;\n}\n\nbool mouse_dragging(out vec2 disp) {\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 p_mouse = 2.0 * texture(iChannel0, du) - 1.0;\n    vec4 mouse = iMouse / iResolution.xyxy;\n    disp = mouse.xy - p_mouse.xy;\n    return p_mouse.z > 0.0 && mouse.z > 0.0;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return b * t + a * (1. - t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n\n    vec2 du = vec2(1.0, 1.0) / iResolution.xy;\n    vec4 rot = 2.0 * texture(iChannel0, vec2(1.0, 1.0) - du) - 1.0;\n    \n    vec3 ro = vec3(4.,14.,-4.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n    \n    float tilt = PI / 3.;//mouse.y;//PI / 12.; //15 degree tilt\n    float pan = 0.;//-mouse.x;//0.;\n\n    rd *= rotateX(tilt) * rotateY(pan);\n    \n    //ro = rd * -10.;\n    //rd *= -1.;\n    \n    //vec3 pos = qrot(rot, vec3(0.0, 0.0, 1.0));\n    //rd = qrot(rot, vec3(0.0, 0.0, 1.0));\n\n    //rd = qrot(rot, rd);\n\n    Result vt = voxelTraversal(ro, rd);\n\n    vec3 color = color(vt.block_id);\n    float light = GetLight(vt.position, vt.cell, vt.normal);\n    float depth = vt.depth;\n    \n    color *= light;\n    \n    \n    color = lerp(color, vec3(.2,.23,.4), 1. - clamp(30000. / pow(depth, 4.), 0., 1.));\n    \n    //color *= 12. / depth / depth;\n    \n    fragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdSGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1680, 1680, 1702, 1702, 1729], [1731, 1731, 1753, 1753, 1784], [1786, 1786, 1812, 1812, 1971], [1979, 1979, 2014, 2014, 2236], [2238, 2238, 2287, 2287, 2573], [2575, 2575, 2611, 2611, 2793], [2795, 2795, 2827, 2827, 2944], [2947, 2947, 2988, 2988, 4334], [4336, 4336, 4379, 4379, 4857], [4859, 4897, 4924, 4924, 5071], [5073, 5111, 5138, 5138, 5285], [5287, 5325, 5352, 5352, 5499], [5551, 5583, 5611, 5611, 5891], [5893, 5919, 5946, 5946, 6065], [6067, 6067, 6103, 6103, 6330], [6332, 6332, 6368, 6368, 6403], [6406, 6406, 6463, 6463, 7469]], "test": "untested"}
{"id": "DsSGDw", "name": "tests_in_3D", "author": "danzabarr", "description": "test in 3D", "tags": ["3d", "test"], "likes": 0, "viewed": 102, "published": 3, "date": "1697181040", "time_retrieved": "2024-07-30T17:28:46.888222", "image_code": "\n#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURF_DIST .00001\n\n\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n    return dot(p, n) - d;\n}\n\nfloat quad(vec3 p, mat4 transform)\n{\n    return 0.;\n}\n\nfloat metaball(vec3 p, vec3 c, float r)\n{\n \treturn pow(r, 2.0) / (pow(p.x - c.x, 2.0) + pow(p.y - c.y, 2.0) + pow(p.z - c.z, 2.0));\t   \n}\n\n\nfloat aabb(vec3 p, vec3 pos, vec3 size)\n{\n  vec3 q = abs(p - pos) - size;\n  return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat GetDist(vec3 p) \n{\n\n    float d = MAX_DIST;\n\n\n    //for (int sx = -50; sx < 50; sx++)\n    //    for (int sy = -50; sy < 50; sy++)\n    //    {\n    //        vec3 pos = vec3(sx, 0, sy);\n    //        \n    //        d = min(d, sphere(p, pos, 1.));\n    //    }\n    \n    d = min(d, aabb(p, vec3(2., 2., 10.), vec3(3.,1.,5.)));\n    \n    \n    /*\n    for (float i = 0.; i < 100.; i++)\n    {\n        float x = mod(i, 10.);\n        float y = floor(i / 10.);\n        vec3 pos = vec3(x, 0., y + 10.);\n        \n        pos.y += sin(x + iTime);\n        \n        d = min(d, sphere(p, pos, .5));\n\n    }\n    */\n\n    \n    d = min(d, plane(p, vec3(0., 1., 0.), 0.));\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\n    float da = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 ri = ro + rd * da;\n        float d = GetDist(ri);\n        da += d;\n        \n        \n        if (da > MAX_DIST || d < SURF_DIST)\n            break;\n    }\n    \n    return da;\n\n}\n\nfloat sdSphere(vec3 p, float r )\n{\n  vec3 offset = vec3(0, 0, -2);\n  return length(p - offset) - r;\n}\n\n\nvec3 GetNormal(vec3 point) \n{\n    float EPSILON = SURF_DIST;\n\n    float a = GetDist(vec3(point.x + EPSILON, point.y, point.z));\n    float b = GetDist(vec3(point.x - EPSILON, point.y, point.z));\n    float c = GetDist(vec3(point.x, point.y + EPSILON, point.z));\n    float d = GetDist(vec3(point.x, point.y - EPSILON, point.z));\n    float e = GetDist(vec3(point.x, point.y, point.z  + EPSILON));\n    float f = GetDist(vec3(point.x, point.y, point.z - EPSILON));\n    return normalize(vec3(a - b, c - d, e - f));\n}\n\nvec3 GetNormalold(vec3 p) {\n\n/*\n    vec2 e = vec2(SURF_DIST, 0);\n    \n    return normalize(\n      e.xyy * GetDist(p + e.xyy) +\n      e.yyx * GetDist(p + e.yyx) +\n      e.yxy * GetDist(p + e.yxy) +\n      e.xxx * GetDist(p + e.xxx));\n\t\n    */\n    float d = GetDist(p);\n    vec2 e = vec2(SURF_DIST, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 15, 2);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    //diffuse\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    //shadows\n    float d = RayMarch(p + n * SURF_DIST * 2., l);\n    if (d < length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nvec2 r;\nbool stored = false;\n\nfloat PI = 3.1415926535;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n\n    float tilt = PI / 12.; //15 degree tilt\n    float pan = 0.;\n\n    rd *= rotateX(tilt) * rotateY(pan);\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsSGDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 111, 111, 143], [145, 145, 183, 183, 211], [213, 213, 249, 249, 266], [268, 268, 309, 309, 405], [408, 408, 449, 449, 547], [549, 549, 573, 573, 1223], [1226, 1226, 1260, 1260, 1522], [1524, 1524, 1558, 1558, 1625], [1628, 1628, 1657, 1657, 2137], [2139, 2139, 2166, 2379, 2577], [2579, 2579, 2603, 2603, 2951], [2952, 2990, 3017, 3017, 3164], [3166, 3204, 3231, 3231, 3378], [3380, 3418, 3445, 3445, 3592], [3650, 3650, 3707, 3707, 4207]], "test": "untested"}
{"id": "DsdBWN", "name": "spqr domain trick 12", "author": "spqr", "description": "a", "tags": ["a"], "likes": 4, "viewed": 168, "published": 3, "date": "1697180763", "time_retrieved": "2024-07-30T17:28:47.719998", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(sin((p3.x + p3.y) * p3.z)*3523.252);\n}\nvec3 hash33 (vec3 p) {\n    float x = hash31(p);\n    float y = hash31(p + vec3(1231.41, 48.42, 77.12));\n    float z = hash31(p + vec3(17.94, 111.42, 212.55));\n    return vec3(x,y,z);\n    \n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n   // return max(max(q.x,q.y),q.z);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm31( vec3 a)\n{\n    vec3 p = vec3(a);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nvec3 fbm33 (vec3 a) {\n    float x = fbm31(a);\n    float y = fbm31(a + vec3(12.99,53.12,193.11));\n    float z = fbm31(a + vec3(83.11, 121.53, 221.59));\n    \n    return vec3(x,y,z);\n    \n    \n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat jerk (float t) {\n    float i =floor(t);\n    float r =fract(t);\n    r = pow(r,6.);\n \n    \n    return i + r;\n}\nfloat field (vec3 p, float scale) {\n   \n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   vec3 f1 = hash33(id*10.);\n \n \n  \n   float ball = box(p + vec3(f1*sin(jerk(iTime))*.3), vec3(.1));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball*.8)/scale;\n}\nfloat map (vec3 p){\n    // geo\n\n   float a =field(p,1.);\n   return a;\n  \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\nfloat glider(float t) {\n    float dip_interval = 20.0;\n    float dip_depth = 10.0;\n    \n    // Up and down fluctuating motion\n    float y_sine = 5.0 * sin(0.2 * t);\n    \n    // Time since last dip\n    float time_since_last_dip = mod(t, dip_interval);\n    \n    // Modulating function that drops quickly but recovers slowly\n    float modulating_func = 1.0 - sin(time_since_last_dip + 0.5 * sin(time_since_last_dip));\n    \n    // Gaussian dip function\n    float y_gauss = -dip_depth * exp(-pow((time_since_last_dip - dip_interval / 2.0), 2.0) / (2.0 * pow((dip_interval / 6.0), 2.0)));\n    \n    // Continuously blend the Gaussian and sinusoidal functions, modulated by the new function\n    float h = y_sine + y_gauss * modulating_func;\n    \n    // Scale the output by a factor of 3\n    h /= 3.0;\n    \n    return h;\n}\n\nfloat gliderfbm(float t) {\n  float n = 0.;\n  n += glider(t);\n  n += glider((t+5.12) * 2.)/2.;\n  //n += glider((t+11.42) * 4.)/4.;\n  return n;\n  \n}\nfloat fbmao (vec3 p, vec3 n, float aodist ) {\n    float val = 0.;\n    for (float i = 0.; i < 2.; i++) {\n        val += (getao(p,n,aodist *.2 * pow(1.5,i))* 0.5 + 0.5)/(i+1.);\n    }\n    return +val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime * .4;\n \n  // nav\n\n\n\n  vec3 s = vec3(0);\n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(cos(tt*.2));\n  arm.zy *= rot(cos(tt*.3));\n  vec3 t = s + arm;\n  \n  vec3 fwd = vec3(0,0,1) * tt;\n  \n  s += fwd;\n  t += fwd;\n \n\n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <200.; ++z) {\n    i = z;\n    d=abs(map(p));\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light1 = normalize(vec3(-1));// + t)/2.;//normalize(vec3(5,-5,-1));\n  vec3 light2 = normalize(vec3(2,3,-5));// + t)/2.;//normalize(vec3(5,-5,-1));\n\n  \n  if (dot(n,light1) < 0.) {\n      light1 = -light1;\n  }\n   if (dot(n,light2) < 0.) {\n      light2 = -light2;\n  }\n  \n  \n  vec3 col = vec3(.6)*1.3;\n  float aodist = .4;\n  \n  float fresnel = 1. - dot(n,r);\n  float ao =(getao(p,n,aodist*0.35)*0.5+0.5);\n  //float ao =// fbmao(p,n,aodist *.2);\n  //    (getao(p,n,aodist*.2)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.35)*0.5+0.5) * \n  //    (getao(p,n,aodist*0.5)*0.5+0.5);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff1 = dot(n,light1)*.9+.5;\n  float diff2 = dot(n,light2)*.9+.5;\n \n  float spec1 =pow(max(dot(reflect(-light1,n),-r),0.),1.) * 1.;\n  float spec2 =pow(max(dot(reflect(-light2,n),-r),0.),1.) * 1.;\n  //float iff = pow(1.-i/100.,2.);\n  \n  \n  //col *= diff;\n  col *= ao;\n  col *= (spec1 + spec2)/2.;\n  col *= (diff1 + diff2)/2.;\n // col *= spec2;\n  \n  //col += fresnel;\n  //col *= diff;\n\n  \n \n \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n  //col = vec3(1) * fbm(uv*10.+iTime);\n \n  //col = vec3(1) * fbm(uv*10.);\n  if (length(col) > 1.5) {\n      col = vec3(0);\n  }\n  col = smoothstep(0.,1.,col)*2.;\n  //col = sqrt(col);\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdBWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 963], [964, 964, 986, 986, 1152], [1153, 1153, 1176, 1176, 1271], [1273, 1273, 1300, 1300, 1382], [1384, 1384, 1412, 1412, 1539], [1541, 1541, 1563, 1563, 1653], [1654, 1654, 1675, 1675, 1966], [1968, 1968, 1990, 1990, 2170], [2171, 2171, 2192, 2192, 2362], [2363, 2363, 2392, 2392, 2420], [2421, 2421, 2443, 2443, 2535], [2536, 2536, 2571, 2571, 2850], [2851, 2851, 2870, 2881, 2925], [2927, 2927, 2946, 2946, 3065], [3067, 3067, 3087, 3087, 3184], [3186, 3186, 3227, 3227, 3273], [3274, 3274, 3296, 3296, 3353], [3354, 3354, 3378, 3378, 3516], [3518, 3518, 3541, 3541, 4331], [4333, 4333, 4359, 4359, 4479], [4480, 4480, 4525, 4525, 4679], [4681, 4681, 4738, 4738, 6871]], "test": "untested"}
{"id": "DdtfWN", "name": "Complex Mappings", "author": "danzabarr", "description": "draw some complex mappings in happy colours", "tags": ["plane", "complex", "colours", "mappings"], "likes": 2, "viewed": 180, "published": 3, "date": "1697179442", "time_retrieved": "2024-07-30T17:28:48.569726", "image_code": "\n// Multiply complex numbers a and b\nvec2 complexMultiply(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// Divide complex number a by b\nvec2 complexDivide(vec2 a, vec2 b) {\n    float denom = b.x * b.x + b.y * b.y;\n    return vec2((a.x * b.x + a.y * b.y) / denom, (a.y * b.x - a.x * b.y) / denom);\n}\n\n// Calculate the complex conjugate of a\nvec2 complexConjugate(vec2 a) {\n    return vec2(a.x, -a.y);\n}\n\n// Raise complex number a to the power of n\nvec2 complexPower(vec2 a, float n) {\n    float r = length(a);\n    float theta = atan(a.y, a.x);\n    float newR = pow(r, n);\n    float newTheta = theta * n;\n    return newR * vec2(cos(newTheta), sin(newTheta));\n}\n\n// Calculate cos(z) for complex number z\nvec2 complexCos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\n// Calculate sin(z) for complex number z\nvec2 complexSin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\n// Calculate exp(z) for complex number z\nvec2 complexExp(vec2 z) {\n    float r = exp(z.x);\n    return float(r) * vec2(cos(z.y), sin(z.y));\n}\n\n// Calculate log(z) for complex number z\n// This returns the principal value\nvec2 complexLog(vec2 z) {\n    float r = float(length(z));\n    float theta = atan(z.y, z.x);  // in range [-pi, pi]\n    return vec2(log(r), theta);\n}\n\n// Convert a vec3 from hsv to rgb colour space\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Convert 2D vector from cartesian (x,y) to polar (r, theta) coordinates\nvec2 toPolar(vec2 cartesian)\n{\n    float radius = length(cartesian);\n    float theta = atan(cartesian.y, cartesian.x) / 3.1415926535 / 2.0; // normalize to [0,1]\n    \n    // wrap theta\n    theta -= floor(theta);\n    theta += 1.0;\n    theta -= floor(theta);\n    \n    return vec2(radius, theta);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // complex number z as a vec2\n    vec2 z = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;  // Centered and aspect-corrected\n    \n    \n    // ------- ADD YOUR MAPPING HERE ---------\n    // Map z to a complex function\n    \n    //z = complexPower(z, 2.0);\n\n    z = complexMultiply(z, complexCos(complexDivide(vec2(cos(iTime), sin(iTime)), z)));\n    \n    //z = complexMultiply(z, complexExp(complexDivide(vec2(cos(iTime), sin(iTime)), complexPower(z, 2.0) ) ));\n    \n    //z = complexDivide(vec2(1,1), z);\n    \n    //z += vec2(0.5,0.5);\n    // -----------------------------------------\n    \n    \n    \n    // Convert Cartesian to polar coordinates\n    vec2 polar = toPolar(z);\n    \n    // convert hsv to rgb\n    vec3 hsv = vec3(polar.y, 1.0, polar.x);\n    vec3 rgb = hsv2rgb(hsv);\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdtfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 37, 75, 75, 140], [142, 174, 210, 210, 336], [338, 378, 409, 409, 439], [441, 485, 521, 521, 696], [698, 739, 764, 764, 828], [830, 871, 896, 896, 959], [961, 1002, 1027, 1027, 1101], [1103, 1180, 1205, 1205, 1328], [1330, 1377, 1399, 1399, 1568], [1570, 1644, 1674, 1674, 1939], [1941, 1941, 1998, 2032, 2842]], "test": "untested"}
{"id": "Ds3fWH", "name": "Flow mapping: 2-tap vs 6-tap", "author": "Suslik", "description": "Press LMB to see a single layer in both techniques and also redirect the flowmap.\n", "tags": ["flowmapping"], "likes": 9, "viewed": 382, "published": 3, "date": "1697173948", "time_retrieved": "2024-07-30T17:28:49.495251", "image_code": "//Note that both of these can work with native mipmapping (no textureGrad or textureLod needed).\n//Both techniques also use exclusively int hashes, which means they will perform the same way regardless of floating point\n//shenanigans. For example, they'll perform the same between the GPU and the CPU. This is different from most techniques that\n//rely on vec3 hash33(vec3) and such, where the result of the hash is unstable to small pertrubations.\n\nvec2 GetFlowField(vec2 pixel_pos, vec2 focus_point)\n{\n    vec2 delta = pixel_pos - focus_point;\n    vec2 n = delta / (length(delta) + iResolution.x / 10.0f);\n    float l = length(delta) / (iResolution.x / 2.0f);\n    return \n        100.0f * n +\n        cos(length(delta) / (iResolution.x / 10.0f)) * vec2(-n.y, n.x) * iResolution.x / 10.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_pos = fragCoord.xy;\n    vec2 pixel_velocity = GetFlowField(pixel_pos, iMouse.xy);\n    \n    vec3 linear_col = vec3(0.0f);\n    vec2 moments = vec2(0.0f);\n\n    float grid_step2 = 0.5f;\n    float grid_step3 = iResolution.x / 15.0f;\n    \n    float uv_tiling = iResolution.x / 20.0f;\n    float debug_pos = (sin(iTime) * 0.5f + 0.5f) * iResolution.y;\n\n    bool mouse_was_pressed = texelFetch(iChannel2, ivec2(0), 0).r > 0.5f;\n    float mouse_pressed_time = texelFetch(iChannel2, ivec2(0), 0).g;\n\n    float debug_draw = mix(\n        1.0f - clamp((pixel_pos.y - debug_pos) / 10.0f - 0.5f, 0.0f, 1.0f),\n        clamp(mouse_pressed_time, 0.0f, 1.0f),\n        mouse_was_pressed);\n        \n        \n    int quad_index = 0;\n    float width = 2.0f;\n    if(pixel_pos.x < iResolution.x * 0.5f - width)\n        quad_index = 1;\n    if(pixel_pos.x > iResolution.x * 0.5f + width)\n        quad_index = 2;\n    \n    if(quad_index == 1)\n    {\n        float time_pos = iTime;\n        vec2 gyroid_pos = fragCoord.xy / (iResolution.x * 0.05f);\n        float smooth_noise = sin(gyroid_pos.x) * cos(gyroid_pos.y) + sin(gyroid_pos.y) + cos(gyroid_pos.x);\n        float time_offset = smooth_noise * grid_step2 * 0.5f;\n        InterpNodes2 interp_nodes2 = GetLinearInterpNodes(time_pos + time_offset, grid_step2);\n        for(int j = 0; j < 2; j++)\n        {\n            vec3 node2_hash = hash3i3f(ivec3(0, 0, interp_nodes2.indices[j]));\n            float time_delta = time_pos - (interp_nodes2.positions[j]);\n\n            vec2 uv = Rotate2(pixel_pos + pixel_velocity * time_delta, 2.0f * pi * node2_hash.x) / uv_tiling + node2_hash.yz;\n            float weight = interp_nodes2.weights[j];\n            linear_col += SrgbToLinear(texture(iChannel0, uv).rgb) * weight * mix(1.0f, (j > 0) ? 0.0f : 1.0f, debug_draw);\n            moments += vec2(weight, weight * weight);\n        }\n    }\n    if(quad_index == 2)\n    {\n        InterpNodes3 interp_nodes3 = GetHexGridInterpNodes(pixel_pos, vec2(grid_step3));\n        for(int i = 0; i < 3; i++)\n        {\n            vec3 node3_hash = hash3i3f(interp_nodes3.indices[i].xyy);\n\n            float time_pos = node3_hash.x * grid_step2 + iTime;\n            InterpNodes2 interp_nodes2 = GetLinearInterpNodes(time_pos, grid_step2);\n\n            vec2 pixel_delta = pixel_pos - interp_nodes3.positions[i];\n            vec3 debug_col = vec3(0.0f);\n            debug_col[i] = 1.0f;\n            for(int j = 0; j < 2; j++)\n            {\n                vec3 node2_hash = hash3i3f(ivec3(interp_nodes3.indices[i].xy, interp_nodes2.indices[j]));\n                float time_delta = time_pos - interp_nodes2.positions[j];\n                vec2 uv = Rotate2(pixel_delta + pixel_velocity * time_delta, 2.0f * pi * node2_hash.x) / uv_tiling + node2_hash.yz;\n                float weight = interp_nodes3.weights[i] * interp_nodes2.weights[j];\n                linear_col += SrgbToLinear(texture(iChannel0, uv).rgb) * weight * mix(1.0f, (j > 0 || i > 0) ? 0.0f : 1.0f, debug_draw);\n                moments += vec2(weight, weight * weight);\n            }\n        }\n    }    \n\n    vec3 mean_col = SrgbToLinear(textureLod(iChannel0, vec2(0.5f), 10.0f).rgb);\n    vec3 linear_res = mix(PreserveVariance(linear_col, mean_col, moments.y), linear_col, debug_draw);\n    fragColor = vec4(LinearToSrgb(linear_res), 1.0f);\n    //InterpNodes2 interp_nodes2 = GetLinearInterpNodes(fragCoord.x, 200.0f);\n    //fragColor = vec4(abs(interp_nodes2.positions[1] - fragCoord.x) / 20.0f);\n    //fragColor = vec4(interp_nodes2.weights[1]);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Inspired by https://www.shadertoy.com/view/dtySDy\n\n//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\nvec3 hash3i3f(ivec3 seed)\n{\n    uvec3 hash_uvec3 = hash33UintPcg(uvec3(seed));\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nconst float pi = 3.141592f;\n\n//Amazing resource explaining cube coordinates of hexagon grids:\n//https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#justin-pombrio\nmat2 skewed_to_grid = mat2(1.0f, 0.0f, 0.5f, sqrt(3.0f) / 2.0f);\n\nvec2 GridToSkewed(vec2 grid_pos)\n{\n    return inverse(skewed_to_grid) * grid_pos;\n}\n\nvec2 SkewedToGrid(vec2 skewed_pos)\n{\n    return skewed_to_grid * skewed_pos;\n}\n\nvec3 SkewedToCube(vec2 skewed_pos)\n{\n    return vec3(skewed_pos.xy, -skewed_pos.x - skewed_pos.y);\n}\n\n//https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 CubeToTri(vec3 cube_pos)\n{\n    return floor(cube_pos.xyz - cube_pos.zxy);\n}\n\nvec3 TriToHex(vec3 tri_index)\n{\n    return round((tri_index.xyz - tri_index.yzx) / 3.0f);\n}\n\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\nfloat HexOuterDist(vec3 cube_delta)\n{\n    return 1.0f - max3(abs(cube_delta.xyz - cube_delta.yzx));\n}\n\nfloat HexInnerDist(vec3 cube_delta)\n{\n    return length(cube_delta) / (sqrt(2.0f) / sqrt(3.0f)); //(sqrt(2.0f) / 2.0f) for inscribed normalization\n}\n\nstruct InterpNodes3\n{\n    vec2 positions[3];\n    ivec2 indices[3];\n    vec3 weights;\n};\n\nInterpNodes3 GetHexGridInterpNodes(vec2 pos, vec2 grid_step)\n{\n    vec2 hex_size = grid_step * sqrt(3.0f);\n    InterpNodes3 interp_nodes3;\n    for(int i = 0; i < 3; i++)\n    {\n        vec2 grid_pos = pos / hex_size;\n        vec2 skewed_offset = vec2(float(i) / 3.0f);\n        vec2 skewed_pos = GridToSkewed(grid_pos) + skewed_offset;\n        vec3 cube_pos = SkewedToCube(skewed_pos);\n        vec3 hex_index = TriToHex(CubeToTri(cube_pos));\n        vec2 hex_skewed_pos = hex_index.xy - skewed_offset;\n        vec2 hex_grid_pos = SkewedToGrid(hex_skewed_pos);\n        interp_nodes3.positions[i] = hex_grid_pos * hex_size;\n        interp_nodes3.indices[i] = ivec2(hex_index.xy) * ivec2(3, 1) + ivec2(i, 0);\n        interp_nodes3.weights[i] = HexOuterDist(cube_pos - hex_index);\n    }\n    return interp_nodes3;\n}\n\nmat2 Rotate2Mat(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\nvec2 Rotate2(vec2 vec, float ang)\n{\n    return Rotate2Mat(ang) * vec;\n}\n\nstruct InterpNodes2\n{\n    vec2 positions;\n    ivec2 indices;\n    vec2 weights;\n};\nInterpNodes2 GetLinearInterpNodes(float position, float grid_step)\n{\n    float grid_pos = position / grid_step;\n    vec2 global_phases = vec2(grid_pos * 0.5f) + vec2(0.5f, 0.0);\n    vec2 indices = floor(global_phases) * 2.0f + vec2(0.0f, 1.0f);\n    vec2 weights = vec2(1.0f) - abs(grid_pos - indices);\n    return InterpNodes2(indices * grid_step, ivec2(indices), weights);\n}\n\nvec3 SrgbToLinear(vec3 srgb_col)\n{\n    return pow(srgb_col.rgb, vec3(2.2f));\n}\n\nvec3 LinearToSrgb(vec3 linear_col)\n{\n    return pow(linear_col.rgb, vec3(1.0f / 2.2f));\n}\n\n//Qizhi Yu, Fabrice Neyret, Eric Bruneton, and Nicolas Holzschuch. 2011. \n//Lagrangian Texture Advection: Preserving Both Spectrum and Velocity Field.\n//IEEE Transactions on Visualization and Computer Graphics 17, 11 (2011), 1612–1623\nvec3 PreserveVariance(vec3 linear_col, vec3 mean_col, float moment2)\n{\n    return (linear_col - mean_col) / sqrt(moment2) + mean_col;\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel_coord = ivec2(fragCoord.xy);\n    fragColor = texelFetch(iChannel0, pixel_coord, 0);\n    if(pixel_coord == ivec2(0, 0))\n    {\n        fragColor.r = max(fragColor.r, iMouse.z);\n        fragColor.g = clamp(fragColor.g + (iMouse.z > 0.5f ? iTimeDelta : -iTimeDelta) * 4.0f, 0.0f, 1.0f);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ds3fWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 450, 503, 503, 792], [794, 794, 851, 851, 4372]], "test": "untested"}
{"id": "DddBD4", "name": "Zellij pattern 19 (music)", "author": "jarble", "description": "A zellij tile pattern.", "tags": ["fractal", "mosaic", "arabesque", "zellij"], "likes": 5, "viewed": 301, "published": 3, "date": "1697171227", "time_retrieved": "2024-07-30T17:28:50.641187", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return\n        abs(fract(a1*(a2.x+a2.y))-.5)\n    ;\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    bool b = true;\n    for(int k = 0; k < 6; k++){\n        uv =\n            -abs(.5-uv-t2)/1.5\n        ;\n        \n        //makes a black and white zellij pattern\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        \n        b =\n            uv.y<uv.x\n        ;\n        if(b){\n            uv = uv.yx;\n        }\n        t2 =\n            triangle_wave(uv-.5).yx\n        ;\n        uv =\n            t2-triangle_wave(uv.yx).yx\n        ;\n        vec2 uv1 =\n            uv\n        ;\n        col.x =\n            max(.5,col.x)            \n        ;\n        \n        col =\n            abs(col-(1.+col.x*sign(uv1.x-uv1.y)))\n            //abs(col-(float(b)))\n            //abs(col-(.5+sign(uv.x-uv.y)/2.))\n            //vec3(col.zx,max(col.y,max(uv.y-uv.x,0.)))\n            //max((col-1.+col.x/1.5),(1.-col-col.yzx))\n        ;\n        //if(!b) col=col.yzx;\n\n    }\n    if (!b) col = abs(1.-col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.x/t1/2.0;\n    uv += vec2(iTime/6.0,iTime/2.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    col = fractal(uv);\n    fragColor = vec4(min(col,vec3(1.)),1.0);\n}", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\n\nint collatz(int initial, int steps){\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\n\nfloat fibonacci(float nthNumber_) {\n        int nthNumber = int(nthNumber_);\n        int previouspreviousNumber, previousNumber = 0, currentNumber = 1;\n        for (int i = 1; i < nthNumber ; i++) {\n\n            previouspreviousNumber = previousNumber;\n\n            previousNumber = currentNumber;\n\n            currentNumber = previouspreviousNumber + previousNumber;\n\n        }\n        return float(currentNumber);\n}\n\nfloat mod1(float a,float b){\n\n    //a += collatz(a/8./2.,b)*4.;\n    //a += mod(a/8.,2.) - mod(a/8.,3.);\n    \n    return \n        mod(a,b)\n        //mod(a+mod(a,b*2.+7.),b)\n        //mod(a+floor(a/4.),b)\n        //mod(a-mod(a,5.)+mod(a,4.),b)\n        //mod(a+mod(a+mod(-a,3.),5.)+mod(a+mod(-a,5.),3.),b)\n        //mod(a+floor(floor(a/8.)/3.)-floor(floor(a/8.)/2.),b)\n        //mod(a+3.*floor(floor(a)/3.),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a +=\n            mod1(floor(a/2.),b)\n            //mod1(floor(a/2.),b)*i\n        ;\n    }\n}\n\nfloat fmod(float a, float b){\n    \n    //distort(a,b);\n    \n    //a *= (mod(a/8.,3.)-mod(a/8.,2.));\n\n    \n    //a += (mod(a/8.,3.)-mod(a/8.,2.));\n    \n    //a += floor(16.*fractal(vec2(floor(a),floor(a/2.))).y);\n    \n    float\n    t1 = mod1(floor(b/2.),2.),\n    a1 =\n        floor(a+t1),\n    a2 = mod1(a1,3.),\n    a3 =\n        //mod(a1,4.+a2)\n        //mod1(a1+a1*sign(1.-t1),4.)\n        mod1(a1,4.)\n    ;\n    \n    return\n        //abs(mod(a1-mod(a1,3.+t1)-mod(a1,4.+t1),b+t1)-t1)\n        //mod(a1-mod(a1,3.+t1)-mod(a1,4.+t1),b)\n        //mod1(a1*sign(1.-t1)-a2-a3,b)\n        //floor(mod(a,b)-mod(a/2.,b)+1.)\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat prime_rhythm(float time){\n    \n    //time += mod(time,5.)-mod(time,3.);\n    //time += mod(time/8.,2.) - mod(time/8.,3.);\n    //time += collatz(time/4.,8.)*2.;\n    \n    return (1.+fmod(time/4.,2.))/(1.+fmod(time/2.,2.));\n}\n\nfloat fmod1(float a, float b){\n    //a += collatz(a,mod(a,b))*2.;\n    \n    //a += collatz(mod(floor(a),4.)+floor(a/8.),4.);\n    \n    //a += ((mod(a/2.,3.)-mod(a/2.,5.)));\n    \n    //a += fibonacci(mod(floor(a),64.));\n    //a -= floor((a)/8./8./2.);\n    //a += prime_rhythm(a);\n    return fmod(a,b);\n}\n\n\n//oud\n//#define fract1(a) (1.-pow(fract(-a),1./(2.-fract(-a))))\n\n//gamelan\n#define fract1(a) (1.-pow(fract(-a),2.))\n\n//#define fract1(a) fract(a)*fract(a)\n\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n//#define fract1(a) pow(fract(a),1.+atan(2.)-atan(1.+fract(a)))\n\n//#define fract1(a) log(1.+fract(a)*fract(a))/log(2.)\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\n    return a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  //time += collatz(time,mod(time,8.));\n  \n  //time += mod(time/8.,2.) - mod(time/8.,3.);\n  \n  //time += prime_rhythm(time*8.);\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time)\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 =\n       fmod(t4,2.)\n       //fmod(t4+fmod(t4/2.,2.),2.)\n  ,\n\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 =\n      (1.+fmod(t5,2.))\n      //(1.+fmod(t5+fmod(t5/2.,2.),2.))\n  ,\n\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6,s1/2.)/2.),\n  m2 =\n      1. + fmod1(t/t3/2.,s1/2.);\n      //1. + fmod1(t/t3/2.+fmod1(time,8.),s1/2.)\n  ;\n  vec2 a=\n      //vec2(log(fract(t/2./prime_rhythm(time+14.))/8.)*log(fract(t/prime_rhythm(time+7.))/8.))\n      //vec2((1.-log(fract(t/2./prime_rhythm(time+14.))/2.))*(1.-log(fract(t/prime_rhythm(time+7.))/4.)))\n      -vec2((log(1./64.+fract1(t/2./prime_rhythm(time+14.))/2./duration)),(log(1./64.+fract1(t/prime_rhythm(time+7.))/4./duration)))\n  ,\n  nb =\n      t*vec2(pow(2.,(m3+m2-t1*4.)/7.+scale),pow(2.,(m3+m2-t1*4.)/7.+scale))*tempo1\n      //vec2(t*pow(2.,(m3+m2-t1*4.*sign(1.-t3))/7.+6.)*tempo1)\n  ;\n  return\n      //log(abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y)))*a)\n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb.x+.5),fract(nb.y)))*a))\n      //abs(log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.))))))\n      \n      //sitar\n      //a/16./2.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      //+.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*.998/2.),fract1(nb.y/2.)))/2.)))   \n      \n      //sitar2(a,nb)\n\n      \n      //banjo\n      //a/16./8.*abs(log(1./8.+a*abs(1./8.-.5*abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))))\n      //-log(1./8.+.5*a*abs(abs(1./2.-vec2(fract1(nb.x*.998),fract1(nb.y))))))\n      \n      //synth drum\n      //a/16./4.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))*2.))\n      //+ log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))\n\n      //oud\n      a/16./2.*abs(\n      log(.5+a*abs(abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))\n      +.5*synth(1./8.,a,1./8.,1.,nb,1./2.))/2.\n\n      //sitar3(a,nb)\n\n      //harp\n      //a/16./4.*abs(\n      //synth(1./4.,a,1./8.,1.,nb*4.,2.)\n      //+ synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n  ;\n}\n\nvec2 mainSound1(int samp, float time,float scale){\n    return mainSound1(samp,time,scale,1.);\n}\n\nvec2 mainSound(int a,float b){\n    //b += mod(-b,3.)+mod(b,5.);\n    return\n        //sounds like sitar (using oud)\n        //abs(mainSound1(a,b,6.5,1./2.)-mainSound1(a,b,7.5)/2.)\n        //abs(mainSound1(a,b,6.25,1./2.)-mainSound1(a,b,7.25,2.)/2.)/2.\n        \n        //sounds like violin (using sitar3)\n        //(2.*mainSound1(a,b,6.,1./2.)-mainSound1(a,b,6.,1./4.))\n        //-(mainSound1(a,b,5.,1./2.)-mainSound1(a,b,5.,1./4.))\n        \n        //abs(mainSound1(a,b,6.5)-mainSound1(a,b/2.,6.5)/8.)/2.\n        (mainSound1(a,b,6.5)-mainSound1(a,b,5.5))/2.\n\n        //using sitar2\n        //(mainSound1(a,b,7.,1./2.)-mainSound1(a,b,6.,2.))\n        \n        //sqrt(mainSound1(a,b,5.5)*mainSound1(a,b,6.5))\n        \n        //abs(mainSound1(a,b,7.,2.)/4.+mainSound1(a,b,6.,1./2.))\n\n        //abs(mainSound1(a,b*2.,7.)-mainSound1(a,b,6.))\n        //abs(mainSound1(a,b,6.)-mainSound1(a,b,7.)/4.)\n        //(mainSound1(a,b,6.)+mainSound1(a,b/2.,5.))/2.\n    ;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DddBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 140], [142, 142, 164, 164, 1129], [1131, 1131, 1188, 1188, 1489]], "test": "untested"}
{"id": "ds3fDN", "name": "Skinbox", "author": "tdhooper", "description": "Not entirely happy with parts of this texture, but some bits look convincing\n", "tags": ["sss", "pathtrace", "skin"], "likes": 76, "viewed": 1394, "published": 3, "date": "1697162115", "time_retrieved": "2024-07-30T17:28:51.716313", "image_code": "vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DOF\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq https://www.shadertoy.com/view/tl23Rm\nvec2 rndunit2(vec2 seed ) {\n    vec2 h = seed * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nconst float sqrt3 = 1.7320508075688772;\n\n\n//========================================================\n// Modeling\n//========================================================\n\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n    bool sss;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    int id;\n    float understep;\n};\n\n\nMaterial shadeModel(float rlen, Model model, inout vec3 nor) {\n    vec3 skin = pow(vec3(0.890,0.769,0.710), vec3(2.2));\n    skin = mix(skin, vec3(.4,.5,.5), .25);\n    skin = mix(skin, vec3(1,1,0) * .5, .02);\n   \n    // seams\n    skin = mix(skin, skin * vec3(.8,0,0), model.uvw.y * .5);\n\n    \n    if (model.id == 1) {\n        return Material(skin, .005, .2, true);\n    }\n    \n    return Material(vec3(0.50,0.70,1.00) * .05, .02, .3, false);\n}\n\nfloat sin3(vec3 x) {\n    return sin(x.x) * sin(x.y) * sin(x.z);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\nfloat time = 0.;\n\nModel map2(vec3 p) {\n    vec3 uvw = vec3(0);\n\n    float scl = .85;\n\n    if (iMouse.x > 0.)\n    {\n        pR(p.yz, (.5 - iMouse.y / iResolution.y) * PI / 2.);\n        pR(p.xz, (.5 - iMouse.x / iResolution.x) * PI * 2.);\n    } else {  \n        //pR(p.yz, (.5 - .8) * PI / 2.);\n        //pR(p.xz, (.5 - .84) * PI * 2.);\n        pR(p.yz, (.5 - .25) * PI / 2.);\n        pR(p.xz, (.5 - .6) * PI * 2.);\n    }\n\n    float o = 0.;\n        \n    p /= scl;\n    \n    \n    float d = fBox(p, vec3(.4)) - .1;\n    \n    \n    vec3 pp = p;\n    \n    p = abs(p);\n    p.xy = p.x < p.y ? p.yx : p.xy;\n    p.xz = p.x < p.z ? p.zx : p.xz;\n    //d = smax(d, -(length(p.yz) - .35), .08);\n\n    \n    p.x -= 1.;\n    d = smax(d, -(length(p) - .6), .2);\n\n    \n    float thin = smoothstep(.3, .5, length(p.yz));\n\n    \n    p = pp;\n   // p -= sin(p * 20. + 1.3) * .03;\n    float cut = length(p) - .47;\n    d = smax(d, -cut, .005);\n    //d = cut;\n    \n    //d = smin(d, abs(p.x - .45) - .01, .1);\n    //d = smax(d, -(length(p.yz) - .1), .15);\n    \n    p = pp;\n    //d = smin(d, fBox(p, vec3(.43)), .05);\n    \n\n    \n    float sc = 3.;\n\n    vec3 p3 = p * 30.;\n    pR45(p3.xy);\n    pR45(p3.yz);\n    pR45(p3.zx);\n    p3 += sin3(p * 30.);\n\n    vec3 p2 = p;\n    pR45(p2.xy);\n    pR45(p2.yz);\n    pR45(p2.zx);\n    float l = 0.;\n\n    float spots = (pow(abs(sin3(p2 * 10.)), 10.));\n    l += spots * 12.; // spots\n    float spotMask = max(spots, smoothstep(.1, .4, spots));\n    spotMask *= thin;\n\n    p2 += sin3(p * 2. + .5) * 1.5;\n    \n    float seam = abs(sin3(p2 * 25.));\n    seam = min(seam, mix(1., abs(sin3(p2 * 75.)), .95));\n    float seamMask = seam;\n    uvw.y = (1. - pow(seamMask, .15)) * (1. - spotMask);\n    seam = (1. - pow(seam, .02)) * (1. - spotMask);\n    l -= seam * 20.; // seams\n    l *= -.005;\n\n    // wrinkles\n    float w = 0.;\n    w -= -(abs(sin3(p * 1. + sin(p3 * 5.) * 2.)) * 2. - 1.) * .5;\n    w += abs(sin3(p3 * 250. / 30.));\n    w *= .00001;\n    w *= pow(seamMask, .5) * (1. - spotMask * .5);\n\n    l *= thin;\n    //w *= mix(.2, 1., ss);\n    w *= thin;\n    //l *= 0.;\n\n    \n    float understep = 1.;\n        \n    if (abs(d) < .1) {\n        d += l;\n    }\n    \n    if (abs(d) < .01) {\n        d += w * 600.;\n    }\n    \n    //p.y += .028;\n    float d2 = p.y + .5;\n    \n    float lip = length(p - vec3(0,1.47,0)) - 2.2;\n    lip = smin(lip, (length(p - vec3(0,2.56,0)) - 3.2), .005);\n    d2 = smin(d2, -lip, .005);    \n    d2 = abs(d2) - .03;\n    d2 = smax(d2, length(p) - 1.3, .03);\n    \n    int id = 1;\n    \n    if (d2 < d) {\n        d = d2;\n        id = 2;\n        understep = 1.;\n    }\n    \n        d *= scl;\n\n\n    return Model(d, uvw, id, understep);\n}\n\nconst float boundRadius = .3;\n\nModel map(vec3 p) {\n    float sc = .25;\n    Model m = map2(p / sc);\n    m.d *= sc;\n\n    return m;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).d;\n    }\n    return normalize(n);\n}\n\n\nvec3 sunPos = normalize(vec3(-1,1,-.75)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\nvec3 sunColor = vec3(8.10,6.00,4.20) * 3. * .1;\n\nvec3 env(vec3 dir, bool includeSun) {\n   vec3 col = mix(vec3(.5,.7,1) * .0, vec3(.5,.7,1) * 1., smoothstep(-.2, .2, dir.y));\n   return col * .5;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 500; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep * model.understep;\n\n        if (model.d < .0002) break;\n\n        if (rayLength > maxDist || length(rayPosition) > (boundRadius + .001)) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3 dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// Walk on spheres subsurface scattering\n// inspired by blackle https://www.shadertoy.com/view/wsfBDB\nHit walkOnSpheres(vec3 origin, vec3 normal, float startdepth, inout vec2 seed) {\n    Model model;\n    \n    vec2 lastSeed = seed;\n    seed = hash22(seed);\n    normal = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n    \n    float understep = .4;\n    \n    model = map(origin - normal * startdepth);\n    origin -= normal * abs(model.d * understep);\n    \n    for (int v = 0; v < 256; v++) {\n        model = map(origin);\n\n        if (abs(model.d) < .0002) break;\n        \n        vec2 lastSeed = seed;\n        seed = hash22(seed);\n        vec3 dir = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n        \n        origin += dir * abs(model.d * understep);\n    }\n    return Hit(model, origin);\n}\n\nvec3 sampleDirect(Hit hit, vec3 nor, vec3 throughput, inout vec2 seed) {\n    vec3 col = vec3(0);\n    vec3 lightDir = (sunPos - hit.pos);\n    vec3 lightSampleDir = getConeSample(lightDir, .0005, seed);\n    seed = hash22(seed);\n    float diffuse = dot(nor, lightSampleDir);\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n    if (diffuse > 0.) {\n        Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += throughput * sunColor * diffuse;\n        }\n    }\n    return col;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n// noby https://www.shadertoy.com/view/lllBDM\nfloat ggx(vec3 nor, vec3 rayDir, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(-rayDir + l);\n    float dnl = clamp(dot(nor,l), 0.0, 1.0);\n    float dnv = clamp(dot(nor,rayDir), 0.0, 1.0);\n    float dnh = clamp(dot(nor,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nvec3 sphereLight(vec3 lightPos, float radius, vec3 pos, vec3 rayDir, vec3 nor) {\n    vec3 L = (lightPos - pos);\n    vec3 ref = reflect(rayDir, nor);\n    vec3 centerToRay = dot(L, ref) * ref - L;\n    vec3 closestPoint = L + centerToRay * clamp(radius / length(centerToRay), 0., 1.);\n    return closestPoint;\n}\n\nvec3 sampleDirectSpec(Hit hit, vec3 rayDir, vec3 nor, float rough) {\n    vec3 lpos = sphereLight(sunPos, 5., hit.pos, rayDir, nor);\n    \n    vec3 lightDir = normalize(lpos - hit.pos);\n    vec3 h = normalize(rayDir + lightDir);\n    float specular = pow(clamp(dot(h, nor), 0., 1.), 64.0);\n\n    vec3 col = vec3(0);\n\n    float fresnel = pow(max(0., 1. + dot(nor, rayDir)), 5.);\n    specular = ggx(nor, rayDir, lightDir, rough, fresnel);\n\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightDir, nor)));\n    if (specular > 0.) {\n        Hit sh = march(shadowOrigin, lightDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += sunColor * specular;\n        }\n    }\n    return col;\n}\n\n// origin sphere intersection\n// returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    p /= 2.;\n   \n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(0,0,.4) * focalLength * 1.;\n    vec3 camTar = vec3(0,-.02,0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    #ifdef DOF\n    float fpd = .385 * focalLength;\n    vec3 fp = origin + rayDir * fpd;\n    origin = origin + camMat * vec3(rndunit2(seed), 0.) * .05;\n    rayDir = normalize(fp - origin);\n    #endif\n\n    Hit hit;\n    vec3 nor, ref;\n    Material material;\n    vec3 throughput = vec3(1);\n    vec3 bgCol = skyColor * .05;\n    bool doSpecular = true;\n\n    vec2 bound = iSphere(origin, rayDir, boundRadius);\n    if (bound.x < 0.) {\n    //\treturn vec4(bgCol, 1);\n    }\n    \n    const int MAX_BOUNCE = 2;\n    \n    origin += rayDir * bound.x;\n\n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n\n        hit = march(origin, rayDir, 100., 1.);\n   \n        if (hit.model.id == 0)\n        {\n            if (bounce > 0) {\n                col += env(rayDir, doSpecular) * throughput;\n            } else {\n                col = bgCol;\n            } \n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(distance(camPos, hit.pos), hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        seed = hash22(seed);\n        doSpecular = hash12(seed) < material.specular;\n        \n        if (bounce == 0) { // fix fireflies from diffuse-bounce specular\n            col += sampleDirectSpec(hit, rayDir, nor, material.roughness) * throughput * material.specular;\n        }\n\n        bool doSSS = material.sss && bounce < 1 && ! doSpecular;\n        if (doSSS) {\n            seed = hash22(seed);\n            doSSS = hash12(seed) < .9;\n        }\n        \n        if ( ! doSpecular) {\n            throughput *= material.albedo;\n        }\n\n        if (doSSS) {\n            origin = hit.pos;\n            \n            seed = hash22(seed);\n            hit = walkOnSpheres(origin, nor, .015, seed);\n            nor = calcNormal(hit.pos);\n\n            float extinctionDist = distance(origin, hit.pos) * 20.;\n            vec3 extinctionCol = material.albedo;\n            extinctionCol = mix(mix(extinctionCol, vec3(0,0,1), .25), vec3(1,0,0), clamp(1. - extinctionDist, 0., 1.));\n            extinctionCol = vec3(1,0,0);\n            vec3 extinction = (1. - extinctionCol);\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            extinction = clamp(extinction, vec3(0), vec3(1));\n            throughput *= extinction;\n            \n        }\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular)\n        {\n        \n            seed = hash22(seed);\n            col += sampleDirect(hit, nor, throughput, seed);\n            rayDir = diffuseRayDir;\n        }\n        else\n        {\n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 col = draw(fragCoord, iFrame);\n    if (iFrame > 0 && iMouse.z <= 0.) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3fDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 210], [212, 212, 267, 267, 453]], "test": "untested"}
{"id": "ddcfDN", "name": "magma 2368", "author": "ArmandB", "description": "this", "tags": ["2d", "noise"], "likes": 0, "viewed": 44, "published": 3, "date": "1697161743", "time_retrieved": "2024-07-30T17:28:52.681731", "image_code": "//based on\n//https://shop-us.kurzgesagt.org/collections/new-stuff/products/cosmic-web-poster?variant=40612030119984\n\nvec4 bokeh(sampler2D sampler, ivec2 uv, int r){\n    vec4 col = vec4(0);\n    float maxbright = 0.0;\n    for (int x = -r; x <= r; x++){\n        for (int y = -r; y <= r; y++){\n            if (x*x + y*y < r*r){\n                vec4 newcol = texture(sampler,(vec2(uv)+vec2(x,y))/iResolution.xy);\n                float w = dot(newcol.rgb,newcol.rgb);\n                if (w > maxbright){\n                    col = newcol;\n                    maxbright = w;\n                }\n            }\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = bokeh(iChannel0,ivec2(fragCoord),5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//based on\n//https://shop-us.kurzgesagt.org/collections/new-stuff/products/cosmic-web-poster?variant=40612030119984\n\n//blackbody by fishy: https://www.shadertoy.com/view/DtX3W8\n#define responseCurve(w, p, v) sin(6.28318530718*clamp((v-p)/w + 0.5,0.0,1.0) - 1.57079632679)*0.5+0.5\nvec3 getBlackbodyColor(float t)\n{\n    vec3 col = vec3(0), m = vec3(0);\n    for(float v = 400.; v < 700.; v += 75.)\n    {\n        vec3 r = vec3(responseCurve(100., 440., v),\n                      responseCurve(200., 550., v),\n                      responseCurve(200., 600., v));\n        m += r;\n        col += 2.*v*v*v*(1./(exp(v/t) - 1.))*r;\n    }\n    return col/m;\n}\n\n//random functions from Dave Hoskins: //https://www.shadertoy.com/view/4djSRW\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec2 voronoicell(vec2 uv){\n    float n = 999.0;\n    vec2 cell = vec2(0);\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            vec2 cellpos = floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y));\n            float d = distance(cellpos,uv);\n            if (d < n){\n                n = d;\n                cell = cellpos;\n            }\n        }\n    }\n    return cell;\n}\n\nfloat voronoi3dedges(vec3 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                float d = distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv);\n                if (d < d1) {\n                    d2 = d1;\n                    d1 = d;\n                } else if (d < d2){\n                    d2 = d;\n                }\n            }\n        }\n    }\n    return (abs(d1-d2) + 1.0 - d1)/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*128.0;\n    vec2 cell = voronoicell(uv)/16.0;\n    \n    float rand = 0.1*voronoi3dedges(vec3(cell*5.0,10));\n    float cracks = voronoi3dedges(vec3(cell,0));\n    float lines = voronoi3dedges(vec3(cell,10));\n    float temp = 30.0 - cracks*30.0 - rand*40.0;\n\n    // Time varying pixel color\n    vec3 base = mix(vec3(0.3,0.2,0.4),vec3(0.1,0.1,0.2),smoothstep(0.0,0.3,lines + rand));\n    vec3 col = mix(base,getBlackbodyColor(temp)+vec3(0.1,0.1,0.2),smoothstep(0.0,1.0,(temp-20.0)*0.25));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcfDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 164, 164, 632], [634, 634, 691, 691, 746]], "test": "untested"}
{"id": "Dsdfz7", "name": "circular slider", "author": "ArmandB", "description": "a simple circular slider for your input needs\n", "tags": ["mouse", "sdf", "input"], "likes": 2, "viewed": 177, "published": 3, "date": "1697146792", "time_retrieved": "2024-07-30T17:28:53.723945", "image_code": "//features:\n//relative mouse position taken into account\n//offsets properly resolve\n//center dead zone\n//tunable parameters (see common)\n//color picker as an example use\n\nvec3 hsvToRgb(vec3 hsv){ //hsv.x = hue, hsv.y = saturation, hsv.z = value\n    vec3 col = vec3(hsv.x, hsv.x + 2.0/3.0, hsv.x + 4.0/3.0); //inputs for r, g, and b\n    col = clamp(abs(mod(col*2.0, 2.0)-1.0)*3.0 - 1.0, 0.0, 1.0)*hsv.z*hsv.y + hsv.z - hsv.z*hsv.y; //hue function (graph it on desmos)\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //make sure your mouse coordinates in buffer A are in uv coords\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    float pxunit = 1.0/iResolution.y; //the size of a pixel for blending\n\n    //angle of slider\n    float a = texelFetch(iChannel0, ivec2(0,0), 0).x;\n    //position of slider handle\n    vec2 pos = vec2(cos(a),sin(a))*sliderRadius;\n    \n    vec3 col = mix(vec3(0.8),vec3(1),float(abs(mod(uv.x,0.1) - mod(uv.y,0.1)) > 0.05));\n    float innerdist = sliderWidth - abs(length(uv) - sliderRadius);\n    float handledist = sliderWidth - distance(uv,pos);\n    col = mix(col, hsvToRgb(vec3(atan(uv.y,uv.x)/2.0/PI,1.0,1.0)), smoothstep(0.0, pxunit, innerdist)); //slider background\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(innerdist))); //slider border\n    col = mix(col, hsvToRgb(vec3(a/2.0/PI,1.0,1.0)), smoothstep(0.0, pxunit, handledist)); //handle\n    col = mix(col, vec3(0.2), smoothstep(0.0, pxunit, 0.002-abs(handledist))); //handle border\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = vec4(0);\n    //x: angle of slider (radians)\n    //y: initial offset (radians)\n    //z: handle is held (bool)\n    if (floor(fragCoord) == vec2(0,0)){\n        vec4 prevdata = texelFetch(iChannel0, ivec2(0,0), 0); //previous slider pos\n        if (iMouse.w > 0.0){ //setup on click\n            vec2 m = (iMouse.zw - iResolution.xy/2.0)/iResolution.y; //last click pos in uv coords\n            if (distance(m,vec2(cos(prevdata.x), sin(prevdata.x))*sliderRadius) <= sliderWidth){\n                vec2 d = normalize(m);\n                data.y = atan(d.y,d.x) - prevdata.x;\n                data.x = prevdata.x;\n                data.z = 1.0;\n            }\n        }\n        if (iMouse.z > 0.0 && (prevdata.z == 1.0 || data.z == 1.0)){ //update while held\n            data.z = 1.0;\n            data.y = iMouse.w > 0.0 ? data.y : prevdata.y;\n            vec2 m = (iMouse.xy - iResolution.xy/2.0)/iResolution.y;\n            float r1 = length(m);\n            vec2 d = m/r1; //direction from (0,0) to mouse in uv coords\n            if (r1 < sliderRadius-sliderWidth && doDeadZone) { //creates center dead zone\n                data.x = prevdata.x;\n            } else {\n                vec2 h = vec2(cos(prevdata.x + data.y),sin(prevdata.x + data.y))*r1;\n                vec2 p = vec2(cos(prevdata.x),sin(prevdata.x))*sliderRadius;\n                data.x = atan(d.y,d.x);\n                if (distance(h,p) > sliderWidth){ //keeps the handle under the cursor\n                    if (sliderWidth - abs(r1 - sliderRadius) < 0.0){ //cursor isn't on the track\n                        data.y = 0.0;\n                    } else { //don't ask\n                        float o = acos((r1*r1 + p.x*p.x + p.y*p.y - sliderWidth*sliderWidth)/(2.0*r1*sliderRadius));\n                        data.y = sign(dot(vec2(-p.y,p.x),h))*o;\n                    }\n                }\n                data.x -= data.y;\n            }\n        } else { //store when not clicked\n            data.z = 0.0;\n            data.x = prevdata.x;\n        }\n        if (iFrame == 0) data.x = sliderInitialValue; //set initial value\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float sliderWidth = 0.1;\nconst float sliderRadius = 0.35;\nconst bool doDeadZone = false;\nconst float sliderInitialValue = 1.5;\n#define PI 3.14159", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dsdfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 195, 244, 484], [486, 486, 542, 610, 1590]], "test": "untested"}
{"id": "mscBW4", "name": " Relic", "author": "wyatt", "description": " ", "tags": ["fractal"], "likes": 29, "viewed": 363, "published": 3, "date": "1697146762", "time_retrieved": "2024-07-30T17:28:54.596612", "image_code": "Main {\n\n    Q = B(U);\n\n    Q *= 1.-.8*exp(-.08*U.y);\n    Q *= 1.-.8*exp(-.08*(R.y-U.y));\n    Q *= 1.-.8*exp(-.01*U.x);\n    Q *= 1.-.8*exp(-.01*(R.x-U.x));\n    \n    Q *= 2.*exp(-3.*dot(U-.5*R,U-.5*R)/R.x/R.x);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\nvec4 map (vec2 u) {\n\n    \n    for (float i = 0.; i < 100.; i++) {\n    \n        //u = vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y)-vec2(.45,0.);\n        \n        u.x = abs(u.x)-.2;\n        float a = 5.12;\n        u *= mat2(cos(a),sin(a),-sin(a),cos(a));\n        u = .2*u/dot(u,u);\n        \n    }\n    \n    return atan(length(u))*vec4(1);\n\n}", "buffer_a_code": "Main {\n    if (iFrame < 1||iMouse.z>0.) {\n        Q = vec4(0);\n        #define aa 2\n        for (int x = -aa; x <= aa; x++)\n        for (int y = -aa; y <= aa; y++)\n        {\n            vec2 u = 2.8*(U+vec2(x,y)/float(aa*2)-.5*R)/R.y;\n            u.y += 0.38;\n            Q += map(u)/float((aa*2+1)*(aa*2+1));\n        }\n    } else {\n    \n        Q = A(U);\n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    #define aa 2\n    Q = vec4(0);\n    for (int x = 0; x < aa; x++)\n    for (int y = 0; y < aa; y++)\n    {\n        vec2 u = vec2(x,y)/float(aa*2)*2.-1.;\n        #define X 5.\n        vec4 n = A(U+u+vec2(0,1))+.3*C(X*(U+u)+vec2(0,1))+.6*A(X*(U+u)+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0))+.3*C(X*(U+u)+vec2(1,0))+.6*A(X*(U+u)+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1))+.3*C(X*(U+u)-vec2(0,1))+.6*A(X*(U+u)-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0))+.3*C(X*(U+u)-vec2(1,0))+.6*A(X*(U+u)-vec2(1,0));\n\n        vec2 g = vec2(e.x-w.x,n.x-s.x);\n\n        vec3 no = normalize(vec3(g,.5));\n\n        Q += (.4+1.3*A(U+u))*C(X*(U+u))*(1.-dot(no,normalize(vec3(cos(iTime),sin(iTime),1))))/float(aa*aa);\n    \n    }\n    \n}", "buffer_b_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cd3BDN", "name": "square, circle, star pattern", "author": "punpun", "description": "square, circle, star pattern", "tags": ["circle", "square", "starpattern"], "likes": 1, "viewed": 117, "published": 3, "date": "1697143637", "time_retrieved": "2024-07-30T17:28:55.709636", "image_code": "\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat circle(in vec2 _st, in float _radius) {\n    vec2 dist = _st - vec2(0.5);\n    return 1. - smoothstep(_radius - (_radius * 0.15), _radius + (_radius * 0.01), dot(dist, dist) * 4.0);\n    // return 1. - step(_radius - (_radius * 0.8), dot(dist, dist) * 4.0);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,PI);\n    }\n\n\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = tile(st, 5.0);\n    st = rotateTilePattern(1.*st);\n\n    st = vec2(st.x > .5 || st.y > .5 ? circle(st, 1.07): 0.);\n    \n    fragColor = vec4(vec3(st, 1.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3BDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 174, 174, 314], [316, 316, 351, 351, 394], [396, 396, 441, 441, 658], [660, 660, 693, 737, 1490], [1492, 1492, 1548, 1548, 1798]], "test": "untested"}
{"id": "cscfD4", "name": "rotating circle pattern", "author": "punpun", "description": "rotating circle pattern", "tags": ["rotatingcirclepattern"], "likes": 2, "viewed": 114, "published": 3, "date": "1697142374", "time_retrieved": "2024-07-30T17:28:56.484564", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nvec2 rotate2D (vec2 _st, float _angle) {\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvec2 tile (vec2 _st, float _zoom) {\n    _st *= _zoom;\n    return fract(_st);\n}\n\nfloat circle(in vec2 _st, in float _radius) {\n    vec2 dist = _st - vec2(0.5);\n    return 1. - smoothstep(_radius - (_radius * 0.08), _radius + (_radius * 0.01), dot(dist, dist) * 4.0);\n}\n\nvec2 rotateTilePattern(vec2 _st){\n\n    //  Scale the coordinate system by 2x2\n    _st *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(_st.x,2.0));\n    index += step(1., mod(_st.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    _st = fract(_st);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        _st = rotate2D(_st,PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        _st = rotate2D(_st,PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        _st = rotate2D(_st,PI);\n    }\n\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = tile(st, 2.0);\n    st = rotateTilePattern(st);\n    st = (st.x > .5 && st.y > .5 ?rotate2D(st,-PI*iTime*0.25) : st = rotate2D(st,PI*iTime*0.25));\n    st = vec2(st.x <= .5 ? circle(st, .3): 0.);\n    st = rotate2D(st,-PI*iTime*0.25);\n    \n    fragColor = vec4(vec3(st, 1.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cscfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 171, 171, 311], [313, 313, 348, 348, 391], [393, 393, 438, 438, 580], [582, 582, 615, 659, 1411], [1413, 1413, 1469, 1469, 1837]], "test": "untested"}
{"id": "DdcBW4", "name": "colors and triangles", "author": "The_Snek12", "description": "this ones really simple but i like it ^w^\nFrom a different thing I'm working on, this was mostly accidental \nThis does not run well whatsoever btw", "tags": ["2d"], "likes": 2, "viewed": 136, "published": 3, "date": "1697140329", "time_retrieved": "2024-07-30T17:28:57.401113", "image_code": "//triangle sdf from https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nmat2 rotationMatrix(float theta){\n    float s = sin(theta);\n    float c = cos(theta);\n    \n    return mat2(\n    vec2(c, -s),\n    vec2(s,c));\n    \n}\n\nvec2 hash12(float p)\n{\n\treturn fract(vec2(sin(p * 591.32), cos(p * 391.32)));\n}\n\nstruct Triangle{\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n};\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 col = vec3(0);\n    \n    float combinedTriangles = 0.0;\n    \n    for (float i=0.0; i<150.0; i++){\n        vec2 tpos = hash12(i*0.1)*4.-2.;\n        mat2 rot = rotationMatrix((hash12(i).y-0.5)*iTime+hash12(i).x*3.0);\n        Triangle t = Triangle(\n        vec2(hash12(i).x,hash12(i).y)*rot+tpos,\n        vec2(hash12(i+0.1).x,hash12(i+0.1).y)*rot+tpos,\n        vec2(hash12(i+0.2).x,hash12(i+0.2).y)*rot+tpos);\n        float triDist = sdTriangle(uv, t.p1, t.p2, t.p3);\n        \n        col += smoothstep(0.1, 0.0, smoothstep(0.0, 0.0, triDist));\n        \n        col += smoothstep(0.03,0.0,triDist)/3.;\n        combinedTriangles = min(combinedTriangles, triDist);\n    }\n    \n    \n    \n    \n    //float uvDilation = abs(min(0.0, combinedTriangles*10.0)+1.0); //this one is cool but an accident\n    float uvDilation = abs(min(0.0, combinedTriangles*10.0))+1.0;\n    \n    \n    uv /= uvDilation;\n    uv *=2.;\n    \n    \n    col += texture(iChannel0, uv/4.).rgb;\n    //col += 0.5 + 0.5*cos(iTime+(uv.xyx)+vec3(0,2,4));\n    fragColor = vec4(col, 1);\n\n}\n\n//Hoping to make a shattering glass look that distorts some image or a rainbow color underneath", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdcBW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 69, 135, 135, 700], [702, 702, 735, 735, 849], [851, 851, 873, 873, 930], [994, 994, 1051, 1108, 2256]], "test": "untested"}
{"id": "mdVyR3", "name": "Hot Guy (Significant Shrinkage)", "author": "misol101", "description": "As promised: a companion piece (and Seinfeld hommage :) )\n\nPress mouse to remove censorship.\n\nSpace toggles animation, Enter shows control points. V and W switches drawing method.", "tags": ["2d", "cartoon", "spline", "catmullrom", "nude", "seinfeld", "shrinkage"], "likes": 16, "viewed": 831, "published": 3, "date": "1697140309", "time_retrieved": "2024-07-30T17:28:58.429364", "image_code": "/*--------------------------------------------------------------------------------------\n\n Hot Guy (Significant Shrinkage) by misol101\n\n Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n--------------------------------------------------------------------------------------*/\n\n// from https://www.shadertoy.com/view/slyGW1 by FabriceNeyret2\n#define R iResolution.xy\n#define S(d,r) smoothstep( 3.,0., (d)*R.y -r )\n  \nfloat line(vec2 p, vec2 a,vec2 b, float r) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.), // proj coord on line\n          d = length(p - b * h);                    // dist to segment\n    return S(  d , max(0.,r-1.) ) * min(r,1.);\n}\n\n#define V(a,b) vec2((a),(b))\n\n// from https://www.shadertoy.com/view/lsKSWR by Ippokratis\nfloat vignette(vec2 FC, float extent, float intensity) {\n\tvec2 uv = FC.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * intensity;\n    return pow(vig, extent);\n}\n\nvoid censor(inout vec4 fc, vec2 uv, vec2 p) {\n    float asp = iResolution.y/iResolution.x;\n    float xd = abs(uv.x - p.x + (uv.y - p.y)*asp);\n    float xd2 = abs(uv.x - p.x - (uv.y - p.y)*asp);\n    float yd = abs(uv.y - p.y);\n    if ((xd < 0.014 || xd2 < 0.014) && yd < 0.038) { fc = vec4(0.75,0.,0.,0.); }\n}\n\nvoid excl(inout vec4 fc, vec2 uv, vec2 p) {\n    float asp = iResolution.y/iResolution.x;\n    float xd = abs(uv.x - p.x);\n    float yd = abs(uv.y - p.y);\n    if ((xd < 0.012) && (yd < 0.038 || (yd>0.05 && yd < 0.08 && p.y > uv.y) )) { fc = vec4(0.75,0.,0.,0.); } // vec4(0.35,0.65,0.99,0.);\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 U = ( 2.*fragCoord - R ) / R.y;\n    vec2 bpos = vec2(-0.23, -0.05);\n    if (length(U-bpos) > 1.0 && U.x>0.2) {\n        for (float a=0.075*7.; a<3.141-0.075*7.; a+=0.075) {\n            float b=a+(hash1(a+0.43)-0.5)*0.1;\n            vec2 rot = vec2(sin(b), cos(b)*1.23);\n            fragColor -= line( U, bpos+rot*(1.1+(hash1(a+0.23)-0.5)*0.45), bpos+rot*10., ((2.3+(hash1(a)-0.3)*3.) * (iResolution.y/360.)) * ((length(U)-0.93)*(iMouse.z>0.5?5.:3.)));\n        }\n    }\n    bpos = vec2(-0.75, -0.05);\n    if (length(U-bpos) > 0.8 && U.x<-0.9) {\n        for (float a=4.08; a<3.141*2.-0.075*7.; a+=0.075) {\n            float b=a+(hash1(a+0.43)-0.5)*0.1;\n            vec2 rot = vec2(sin(b), cos(b)*1.23);\n            fragColor -= line( U, bpos+rot*(1.1+(hash1(a+0.23)-0.5)*0.45), bpos+rot*10., ((2.3+(hash1(a)-0.3)*3.) * (iResolution.y/360.)) * ((length(U+vec2(0.7,0.))-0.93)*(iMouse.z>0.5?5.:3.)));\n        }\n    }\n\n    if (iMouse.z < 0.5) {\n        censor(fragColor, uv, vec2(0.328, 0.066));\n        excl(fragColor, uv, vec2(0.59, 0.675));\n    } else {\n        U = 18.*(fragCoord)/iResolution.y;                                     \\\n        U.x -= 16.;\n        if (U.x >= 0. && U.x <= 7. && U.y >= 10. && U.y <= 13.) {\n            int i;\n            switch(int(U.y-10.)) {\n                case 0: i = int[](80,79,79,76,33,32,32)[int(U)]; break;\n                case 1: i = int[](73,78,32,84,72,69,32)[int(U)]; break;\n                case 2: i = int[](73,32,87,65,83,32,32)[int(U)]; break;\n            }\n            float tc= 1.-texture( iChannel1, fract(U)*.055 + vec2(i,15-i/16)/16. ).x;\n            fragColor *= vec4(tc,tc,tc*1.0,0.); // 3.0\n            if (fract(U.x) < 0.1 || fract(U.x) > 0.97|| fract(U.y) < 0.1 || fract(U.y) > 0.97) fragColor=vec4(1.);\n        }\n    }\n\n\tfragColor *= 1.0 - 0.03 * length(fragCoord / iResolution.xy - 0.5);\n    fragColor *= vignette(fragCoord, 0.04, 95.0);\n}\n\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n/**\n * Tension. Default Catmul-Rom matrix has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.6\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n#define V(a,b) vec2((a),(b))\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey(int key) { return texelFetch( iChannel1, ivec2(key, 0), 0).x > .5; }\nbool readKeyToggle(int key) { return texelFetch( iChannel1, ivec2(key, 2), 0).x > .5; }\n\nconst int NUM = 12;\nconst int WNUM = NUM-2;\n\nvoid drawPath(out vec4 fragColor, vec2 fragCoord, vec2 path[NUM], float linew[WNUM], int nofP) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(1.0);\n\n    float scale = iResolution.x/1920.;\n    \n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\tif (readKeyToggle(KEY_ENTER)) {\n\t\tvec2 d = vec2(1000.0);\n        int j = 1;\n\t\tfor (int i = 0; i < (nofP - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n            \n            vec2 tmp = vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a));\n            if (tmp.y < d.y) {\n                j = i;\n            }\n\t\t\td = min(d, tmp);\n\t\t}\n\t\t//d.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[nofP - 1])));\n\t\tcol = mix(col, j==0?vec3(0.3, 0.8, 0.3):j==nofP-2?vec3(1.0, 0.0, 0.0):vec3(0.9, 0.6, 0.0), 1.0 - smoothstep(12.0 * scale * e, 13.0 * scale * e, d.y));\n\t}\n\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = (cos(max(0.,iTime-0.0))*0.4+0.4)*float(nofP); //min(mod(iTime / 8., 1.0), 1.0) * float(nofP);\n        if (!readKeyToggle(KEY_SPACE)) ani = 1.0 * float(nofP); // draw entire thing\n\n\t\tvec2 p = path[0];\n        float lm=0.5;\n\n\t\tfor (int i = 0; i < nofP - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n            \n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n            \n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n                float dt = sdSegmentSq(uv, p, q);\n                // adjust/interpolate line width for each segment (added by misol101)\n                if (dt < d) {\n                    d = dt;\n                    lm = linew[i];\n                    \n                    float l1 = length((i==0?A:B)-C);\n                    float l2 = length(C-uv);\n                    if (!readKeyToggle(KEY_V)) lm = mix(linew[i+1], linew[i], smoothstep(0.1,0.9,l2/l1) );\n                }\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (readKeyToggle(KEY_W)) lm=0.8;\n\t\td = sqrt(d);\n\n        float bsize = 12.0*scale*lm;\n        float aa = bsize - 4.*scale;\n\n\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.0 - smoothstep(aa * e, bsize * e, d));\n        //col *= 0.75 + 0.25 * smoothstep(0.0, 0.11*lm, sqrt(d));\n\t}\n\n\tfragColor = vec4(col, 1.0);\n}\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\n// first line between points is drawn straight\n\n#define NECK_ARM_RIGHT\n#define NECK_ARM_LEFT\n#define TUMMY_BREAST_ARM_RIGHT\n#define GENITALS\n#define NECK_FACE_RIGHT\n#define FACE_EAR_LEFT\n#define TUMMY_BREAST_LEFT\n#define ARM_LEFT\n#define NAVEL\n#define NIPPLES\n#define MOUTH\n#define NOSE\n#define BROWS\n#define EYES\n#define EAR\n#define HAIR\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    const vec2 P = vec2(0.); // padding\n    vec4 colC=vec4(1.), colT;\n\n#ifdef NECK_ARM_RIGHT\n    if (length(vec2((uv.x-0.431)*8.5,uv.y-0.319)*0.8) < 0.35) {\n        const vec2 cN = V(0.45, 0.001); // last point, to add twice\n        vec2 armRU[NUM] =  vec2[] ( V(0.405, 0.673), V(0.438, 0.643), V(0.455, 0.571), V(0.459, 0.419), V(0.463, 0.323), V(0.47, 0.243), V(0.47, 0.148), cN, cN, P, P, P );\n\n        float xmv = sin(iTime*29.)*(iMouse.z>0.5?0.0025:0.);\n        armRU[5].x+=xmv*0.5; armRU[6].x+=xmv; armRU[7].x+=xmv; armRU[8].x+=xmv*0.5; armRU[9].x+=xmv*0.5;\n\n        float linewArmRU[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.8, 0.7, 0.8, 0.5, -0., -0., -0. );\n        drawPath(colT, fragCoord, armRU, linewArmRU, 9);\n        colC=min(colC,colT);\n}\n#endif\n\n#ifdef NECK_ARM_LEFT\n    if (abs(uv.x-0.211)<0.085 && uv.y < 0.785) {\n        vec2 armRD[NUM] =  vec2[] ( V(0.29, 0.785), V(0.286, 0.724), V(0.245, 0.676), V(0.191, 0.61), V(0.158, 0.487), V(0.134, 0.284), V(0.142, 0.094), V(0.146, 0.002), V(0.146, 0.002),P,P,P );\n        float linewArmRD[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.95, 0.5, 0.5, 0.5, -0., -0., -0. );\n\n        float xmv = sin(iTime*29.)*(iMouse.z>0.5?0.0039:0.);\n        armRD[6].x+=xmv; armRD[7].x+=xmv; armRD[8].x+=xmv; armRD[9].x+=xmv;\n\n        drawPath(colT, fragCoord, armRD, linewArmRD, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef TUMMY_BREAST_ARM_RIGHT\n    if (length(vec2((uv.x-0.415)*6.2,uv.y-0.246)*0.8) < 0.21) {\n        const vec2 cN = V(0.431, 0.48);\n        vec2 legRL[NUM] =  vec2[] ( V(0.419, 0.000), V(0.414, 0.106), V(0.366, 0.121), V(0.414, 0.106), V(0.438, 0.193), V(0.428, 0.360), V(0.385, 0.373), V(0.437, 0.384), V(0.432, 0.439), cN, cN,P );\n        float linewLegRL[WNUM] = float[] ( 0.7, 0.0, 0.5, 0.6, 0.6, 0.75, 0.7, 0.5, 0.5, -0. );\n        drawPath(colT, fragCoord, legRL, linewLegRL, 11);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef GENITALS\n    if (length(uv-V(0.33,0.047)) < 0.05) {\n        const vec2 cN = V(0.32, 0.089);\n        vec2 legRR[NUM] = vec2[] ( V(0.337, 0.087), V(0.340, 0.062), V(0.337, 0.042), V(0.332, 0.041), V(0.330, 0.064), V(0.325, 0.046), V(0.323, 0.0), V(0.323, 0.047), V(0.315, 0.07), cN, cN, P );\n        float linewLegRR[WNUM] = float[] ( 0.3, 0.5, 0.35, 0.6, 0.5, 0.5, 0.5, 0.6, 0.3, -0. );\n        drawPath(colT, fragCoord, legRR, linewLegRR, 11);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NECK_FACE_RIGHT\n    if (length(vec2((uv.x-0.372)*2.8,uv.y-0.8)*0.9) < 0.16) {\n        const vec2 cN = V(0.428,0.062);\n        vec2 legL[NUM] =  vec2[] ( V(0.367-0.042, 0.668+0.064), V(0.367-0.042, 0.668+0.064), V(0.365-0.04, 0.668+0.063), V(0.338, 0.724-0.02), V(0.367, 0.674), V(0.407, 0.679), V(0.414, 0.718), V(0.421, 0.778), V(0.415, 0.824), V(0.417, 0.848), V(0.402, 0.928), V(0.378, 0.961));\n        float linewLegL[WNUM] = float[] ( 0.35, 0.5, 0.8, 0.8, 0.6, 0.5, 0.6, 0.5, 0.5, 0.4 );\n        drawPath(colT, fragCoord, legL, linewLegL, 12);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef FACE_EAR_LEFT\n    if (length(uv-V(0.344,0.86)) < 0.13) {\n        const vec2 cN = V(0.312, 0.82);\n        vec2 breastR[NUM] =  vec2[] ( V(0.402, 0.928),V(0.402, 0.928), V(0.371, 0.967), V(0.313, 0.948), V(0.279, 0.871), V(0.285, 0.813), V(0.293, 0.779), V(0.315, 0.754), V(0.32, 0.789), V(0.304, 0.805), cN,cN );\n        float linewBreastR[WNUM] = float[] ( 0.4, 0.6, 0.4, 0.4, 0.55, 0.5, 0.85, 0.5, 0.5, 0.5 );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef TUMMY_BREAST_LEFT\n    if (length(uv-V(0.292,0.282)) < 0.16) {\n        const vec2 cN = V(0.352, 0.398);\n        vec2 breastL[NUM] =  vec2[] ( V(0.278, 0.14), V(0.238, 0.16), V(0.209, 0.2), V(0.209, 0.2), V(0.238, 0.368), V(0.238, 0.366), V(0.303, 0.346), cN, cN, P,P,P );\n        float linewBreastL[WNUM] = float[] ( 0.4, 0.5, 0.0, 0.0, 0.3, 0.7, 0.9, -0., -0., -0. );\n        drawPath(colT, fragCoord, breastL, linewBreastL, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef ARM_LEFT\n    if (length(vec2((uv.x-0.228)*4.4,uv.y-0.239)*0.9) < 0.3) {\n        const vec2 cN = V(0.19, 0.0);\n        vec2 hairR[NUM] =  vec2[] ( V(0.264, 0.493), V(0.258, 0.47), V(0.209, 0.287), V(0.196, 0.298), V(0.206, 0.199), V(0.187, 0.083), cN, cN, P,P,P,P);\n\n        float xmv = sin(iTime*29.)*(iMouse.z>0.5?0.0019:0.);\n        hairR[6].x+=xmv; hairR[7].x+=xmv; hairR[8].x+=xmv; hairR[5].x+=xmv;\n\n        float linewHairR[WNUM] = float[] ( 0.5, 0.8, 0.5, 0.5, 0.6, 0.4, 0.05, 0.8, 0.4, 0.5 );\n        drawPath(colT, fragCoord, hairR, linewHairR, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef EYES\n    float esz=0.009, esz2=0.006;\n    if (iMouse.z > 0.5) { esz = 0.0095; esz2 = 0.0055;}\n    vec4 vc = vec4(0.0,0.0,0.0,1.);\n    \n    float pup;\n\n    if (iMouse.z > 0.5) {\n        pup=length(uv-V(0.378,0.821)); // left\n        if (pup > esz-0.006 && pup < esz) {\n            float aap = smoothstep(esz-0.002,esz, pup);\n            if (pup < esz-0.003) {\n                pup -= esz-0.006;\n                aap = 0.0016/pup;\n            }\n            colC=min(colC, vec4(aap)+vc);\n        }\n        \n        pup=length(uv-V(0.408,0.823)); // right\n        if (pup > esz-0.006 && pup < esz) {\n            float aap = smoothstep(esz-0.002,esz, pup);\n            if (pup < esz-0.003) {\n                pup -= esz-0.006;\n                aap = 0.0016/pup;\n            }\n            colC=min(colC, vec4(aap)+vc);\n        }\n    }\n    \n    float xmv = sin(iTime*24.)*(iMouse.z>0.5?0.0011:0.);\n    pup=length(uv-V(0.379+xmv,0.822));\n    if (pup < esz2) {\n        float aap = smoothstep(esz2-0.002,esz2, pup);\n        colC=min(colC, vec4(aap)+vc);\n    }\n    \n    pup=length(uv-V(0.408+xmv,0.824));\n    if (pup < esz2) {\n        float aap = smoothstep(esz2-0.002,esz2, pup);\n        colC=min(colC, vec4(aap)+vc);\n    }\n#endif\n\n#ifdef MOUTH\n    if (length(uv-V(0.394,0.733)) < 0.16) {\n        const vec2 cN = V(0.384, 0.73);\n        vec2 mouth[NUM] =  vec2[] ( V(0.384, 0.728), V(0.384, 0.728), V(0.388, 0.728), V(0.396, 0.728), V(0.403, 0.728), V(0.405, 0.737),V(0.400, 0.737), cN, cN, P, P, P);\n\n        if (iMouse.z > 0.5) {\n            float m=min(1.,sin(iTime*13.)*0.7+1.1);\n            mouth[0]+=vec2(-0.005,-0.008)*m;\n            mouth[1]+=vec2(-0.006,-0.02)*m;\n            mouth[2].y -= 0.035*m;\n            mouth[3]+=vec2(0.006,-0.03)*m;\n            mouth[4].x += 0.003*m;\n            mouth[5].x -= 0.003*m;\n            mouth[6].x -= 0.01*m;\n            mouth[7]+=vec2(-0.005,-0.008)*m;\n            mouth[8].y -= 0.008*m;\n        }\n\n        float linewMouth[WNUM] = float[] ( 0.5, 0.7, 0.7, 0.7, 0.7, 0.7, 0.5, -0., -0., -0. );\n        drawPath(colT, fragCoord, mouth, linewMouth, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NOSE\n    if (length(uv-V(0.4,0.787)) < 0.04) {\n        vec2 armL[NUM] =  vec2[] ( V(0.401, 0.822), V(0.405, 0.794), V(0.408, 0.776), V(0.402, 0.761), V(0.386, 0.764), V(0.386, 0.776), V(0.386, 0.776), P, P, P, P, P);\n        float linewArmL[WNUM] = float[] ( 0.3, 0.4, 0.7, 0.55, 0.35, -0., -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, armL, linewArmL, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef BROWS\n    if (length(uv-V(0.391,0.831)) < 0.06) {\n        vec2 armL[NUM] =  vec2[] ( V(0.36, 0.83),V(0.36, 0.83),V(0.375, 0.842),V(0.389, 0.842),V(0.395,0.841), V(0.396, 0.841), V(0.401, 0.842), V(0.41, 0.847), V(0.416, 0.843), V(0.416, 0.843), P,P  );\n        float linewArmL[WNUM] = float[] ( 0.4, 0.9, 0.4, 0.0, 0.0, 0.4, 0.8, 0.7, -0., -0. );\n        \n        if (iMouse.z > 0.5) { for (int i=0; i<10;i++) armL[i].y+=0.015; }\n        \n        drawPath(colT, fragCoord, armL, linewArmL, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef EAR\n    if (length(uv-V(0.305,0.805)) < 0.07) {\n        vec2 armL[NUM] =  vec2[] ( V(0.318, 0.832),V(0.318, 0.832),V(0.301, 0.83),V(0.295, 0.811),V(0.298,0.78), V(0.316, 0.754), V(0.32, 0.765), V(0.306, 0.804), V(0.318, 0.808), V(0.318, 0.808), P,P  );\n        float linewArmL[WNUM] = float[] ( 0.4, 0.9, 0.6, 0.6, 0.8, 0.0, 0.6, 0.6, -0., -0. );\n        drawPath(colT, fragCoord, armL, linewArmL, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n    vec2 navel[NUM] =  vec2[] ( V(0.427,0.430), V(0.427,0.430), V(0.429,0.404), V(0.4249,0.393), V(0.422,0.402), V(0.424,0.412), V(0.424,0.412), P, P,P,P,P );\n    for (int i=0; i < NUM; i++) navel[i] +=  vec2(-0.075, -0.2);\n    float linewNavel[WNUM] = float[] ( 0.1, 0.3, 0.6, 0.3, 0.3, -0., -0., -0., -0., -0. );\n#ifdef NAVEL\n    if (length(uv-V(0.350,0.21)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NIPPLES\n    for (int i=0; i < NUM; i++) navel[i] +=  vec2(0.07, 0.21); // right\n    if (length(uv-V(0.350+0.07,0.21+0.21)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n\n    if (length(uv-V(0.350+0.07-0.110,0.21+0.21-0.01)) < 0.025) {\n        for (int i=0; i < NUM; i++) navel[i] +=  vec2(-0.110, -0.01); // left\n        linewNavel[4] = 0.;\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef HAIR\n    if (length(uv-V(0.344,0.86)) < 0.13) {\n        const vec2 cN = V(0.29, 0.915);\n        vec2 breastR[NUM] =  vec2[] ( V(0.385, 0.968),V(0.385, 0.968), V(0.371, 0.957), V(0.313, 0.948), V(0.279, 0.891), V(0.291, 0.782), V(0.285, 0.824), V(0.284, 0.829), V(0.284, 0.889), V(0.285, 0.915), cN,cN );\n        float linewBreastR[WNUM] = float[] ( 0.25, 0.6, 1.8, 0.7, 1.35, 1.95, 7.0, 7.1, 6.8, 0.8 );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 12);\n        colC=min(colC,colT);\n        \n        breastR =  vec2[] ( V(0.331, 0.910),V(0.329, 0.914), V(0.30, 0.93), V(0.35, 0.978), V(0.37, 0.96), V(0.36, 0.94), V(0.291, 0.92), V(0.312, 0.91), V(0.340, 0.95), V(0.312, 0.955), V(0.312, 0.955),V(0.331, 0.918) );\n        linewBreastR = float[] ( 0.65, 0.8, 0.2, 0.4, 0.35, 1.7, 0.5, 0.5, 0.5, 0.5 );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n    fragColor = colC; \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 441, 485, 485, 700], [732, 792, 848, 848, 977], [979, 979, 1024, 1024, 1287], [1289, 1289, 1332, 1332, 1580], [1582, 1582, 1606, 1606, 1646]], "test": "untested"}
{"id": "DsdfRM", "name": "Ink Filter", "author": "domrally", "description": "Experiment with edge detection, highlihgts, and cross hatching.\nWith some shortcuts thanks @SnoopethDuckDuck!\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]", "tags": ["dither", "cross", "hatching", "ordered"], "likes": 8, "viewed": 236, "published": 3, "date": "1697138161", "time_retrieved": "2024-07-30T17:28:59.281087", "image_code": "/// by Dom Mandy in 2023\n\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    // Edge distortion\n    vec4 c = .01 * sqrt(texture(iChannel1, i / iResolution.xy));\n\n    // Gamma correction\n    vec4 s = sqrt(texture(iChannel0, c.xy + i / iResolution.xy));\n    \n    // Luma * 8\n    float v = dot(s, vec4(2, 7, .7, 0));\n    \n    // Edges\n    vec4 f = fwidth(s);\n\n    o = min(1., log(.07 / max(max(f.x, f.y), f.z))) \n        * vec4(\n            vec4(0, 4, 2, 6)[int(i.x) % 4] < v && \n            vec4(1, 5, 3, 7)[int(i.y) % 4] < v\n        );    \n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 63, 86, 531]], "test": "untested"}
{"id": "dstfWH", "name": "Peach Beach", "author": "Blobvispis", "description": "Let the peach come to the beach", "tags": ["blue"], "likes": 1, "viewed": 110, "published": 3, "date": "1697134998", "time_retrieved": "2024-07-30T17:29:00.049033", "image_code": "vec3 palette( float t ) {\n\n    vec3 a = vec3(0.498, 0.498, 0.098);\n    vec3 b = vec3(-0.172, -0.222, 1.068);\n    vec3 c = vec3(-2.082, -1.242, 0.268);\n    vec3 d = vec3(0.000, 0.098, 0.667);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n        pos = abs(pos);\n        pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n        float p = (he+pos.y-0.55/he)/(5.5*he);\n        float q = pos.x/(he*he*16.0);\n        float h = q*q - p*p*p;\n\n        float x;\n        if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n        else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n        x = min(x,sqrt(2.0)/2.0);\n\n        vec2 z = vec2(x,he*(1.0*2.0*x*x)) - pos;\n        return length(z) * sign(z.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float d = sdBlobbyCross(uv, 1.);\n    \n    vec3 kleur = vec3(0.0);\n    \n    for (float i = 0.0; i < 2.0; i++) {\n    \n        d = sin(d*15. + iTime*2.);\n        vec3 col = palette(length(uv) + i*0.6);\n\n        d = pow(0.1/d, 0.9);\n        \n        kleur += col*d;\n    }\n    \n    fragColor = vec4(kleur, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dstfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 234], [236, 236, 282, 282, 803], [805, 805, 862, 862, 1242]], "test": "untested"}
{"id": "Dd3cWn", "name": "Hyperbolic Rings", "author": "mla", "description": "Concentric rings in the complex plane, each mapped to the hyperbolic plane and decorated with a 6,6 tesselation.\n\nTexture offset set automatically or by mouse. Keys 1,2,3,a,d,f,p,q,r,x also do things (see code).", "tags": ["wheel", "tesselation", "hyperbolic"], "likes": 17, "viewed": 240, "published": 3, "date": "1697133873", "time_retrieved": "2024-07-30T17:29:00.923695", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Rings: mla, 2023\n//\n// The map z -> tan(log(z)) maps concentric rings of the complex plane\n// onto the unit disc, which is the tesselated with a 6,6 hyperbolic\n// tesselation (press 'x' to see untransformed disc). Some extra\n// symmetry operations (p,q,r) produce wallpaper group effects.\n//\n// <mouse>: sets offset into texture (unless 'a' pressed)\n// 1,2,3: show tile edges\n// a: automatic mode (no mouse action)\n// d: display outside disc/halfplane\n// f: display principal region only\n// p,q,r: apply extra symmetry operations\n// x: toggle transform\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Hexagonal tiling for maximum symmetry\nconst int P = 6;\nconst int Q = 6;\nconst int MAXITER = 100; // Number of folding iterations\n\nvec3 getcolor(vec2 fragCoord) {\n  vec2 mousepos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  // Just show one fundamental region\n  bool fundamental = key(CHAR_F);\n  vec2 C = vec2(icos(P),icos(Q));\n  float R2 = 1.0/(dot(C,C)-1.0);\n  float R = sqrt(R2);\n  C *= R;\n\n  vec2 ci = vec2(0,1); // Complex i\n\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  if (!key(CHAR_X)) {\n    // Annulus\n    //z *= 2.0;\n    z = clog(z); // (1,0)-> (0,0)\n    // The constant here depends on the tiling\n    z = ctan(1.8237*z-vec2(0.5*iTime,0));\n  }\n  //z = cdiv(ci-z,ci+z);\n  bool flip = dot(z,z) > 1.0;\n  if (flip) {\n    if (key(CHAR_D)) return vec3(0);\n    else z /= dot(z,z);\n  }\n  //return texture(iChannel1,(z+1.0)/2.0).xyz; // For comparison\n  int maxiter = MAXITER;\n  int xflips = 0;\n  int yflips = 0;\n  int zflips = 0;\n  for ( ; zflips < maxiter; zflips++) {\n    xflips += int(z.x < 0.0);\n    yflips += int(z.y < 0.0);\n    z = abs(z);\n    if (!tryinvert(z,C,R2)) break;\n    if (fundamental) return vec3(0);\n    //assert(zflips < 20);\n  }\n  if (zflips == maxiter) return vec3(0);\n  vec2 z0 = z;\n  vec2 dx = dFdx(z0);\n  vec2 dy = dFdy(z0);\n  \n  float ldist = 1e8;\n  if (!key(CHAR_0+1)) ldist = min(ldist,abs(length(C-z)-R));\n  if (key(CHAR_0+2)) ldist = min(ldist,abs(z.x));\n  if (key(CHAR_0+3)) ldist = min(ldist,abs(z.y));\n  if (key(CHAR_P)) {\n    if (xflips%2 == 1) z.x = -z.x; //p4m again P = 2n\n  }\n  if (key(CHAR_Q)) {\n    if (yflips%2 == 1) z.y = -z.y; //and p4m again Q = 2n\n  }\n  if (key(CHAR_R)) {\n    if (zflips%2 == 1) z = -z; // Rotation by 180\n  }\n  vec2 uv = z;\n  uv = rotate(uv,0.25*PI);\n  float k = 2.0/(1.0+dot(uv,uv)); // Transform to Beltrami-Klein\n  k *= 0.5; // Extra scaling\n  uv *= k; dx *= k; dy *= k; \n  if (iMouse.x > 0.0 && !key(CHAR_A)) {\n    uv += 2.0*(iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n  } else {\n    float t = 0.5*iTime;\n    uv += 0.5*vec2(cos(t),sin(0.618*t));\n  }\n  vec3 col = textureGrad(iChannel0,uv,dx,dy).zyx;\n  if (!flip) col = col.yzx;\n  col = pow(col,vec3(2.2));\n  col *= 1.5;\n  col = smoothstep(vec3(0),vec3(1),col);//pow(col,vec3(0.8));\n  col = mix(vec3(0),col,smoothstep(0.0,0.02,ldist)); // Gridlines\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = getcolor(fragCoord);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nbool alert = false;\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0*PI;\n\n/// Complex arithmetic ///\n\n// Normal vec2 operations work for\n// addition, subtraction and\n// multiplication by a scalar.\n      \n// Multiplication\nvec2 cmul(vec2 z0, vec2 z1) {\n  float x0 = z0.x; float y0 = z0.y; \n  float x1 = z1.x; float y1 = z1.y;\n  return vec2(x0*x1-y0*y1,x0*y1+x1*y0);\n}\n\n// Reciprocal\nvec2 cinv(vec2 z) {\n  float x = z.x; float y = z.y;\n  float n = 1.0/(x*x + y*y);\n  return vec2(n*x,-n*y);\n}\n\n// Division\nvec2 cdiv(vec2 z0, vec2 z1) {\n  return cmul(z0,cinv(z1));\n}\n\n// Exponentiation - e^ix\nvec2 expi(float x) {\n  return normalize(vec2(cos(x),sin(x)));\n}\n\nvec2 clog(vec2 z) {\n  return vec2(log(length(z)),atan(z.y,z.x));\n}\n\nvec2 clog(float x) {\n  return clog(vec2(x,0));\n}\n\n// e^iz\nvec2 cexp(vec2 z) {\n  return exp(z.x) * expi(z.y);\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(cmul(clog(z),w));\n}\n\nvec2 cpow(vec2 z, float x) {\n  return cexp(x*clog(z));\n}\n\nvec2 cexp(float k, vec2 z) {\n  // return k^z\n  return cexp(cmul(clog(k),z));\n}\n\nvec2 csqrt(vec2 z) {\n  float r = length(z);\n  return vec2(sqrt(0.5*(r+z.x)),sign(z.y)*sqrt(0.5*(r-z.x)));\n}\n\nvec2 csin(vec2 z) {\n  float x = z.x, y = z.y;\n  return cdiv(cexp(vec2(-y,x))-cexp(vec2(y,-x)), vec2(0,2.0));\n}\n\nvec2 ccos(vec2 z) {\n  float x = z.x, y = z.y;\n  return 0.5*(cexp(vec2(-y,x))+cexp(vec2(y,-x)));\n}\n\nvec2 ctan(vec2 z) {\n  return cdiv(csin(z),ccos(z));\n}\n\nvec2 csinh(vec2 z) {\n  return 0.5*(cexp(z)-cexp(-z));\n}\n\nvec2 ccosh(vec2 z) {\n  return 0.5*(cexp(z)+cexp(-z));\n}\n\nvec2 ctanh(vec2 z) {\n  return cdiv(csinh(z),ccosh(z));\n}\n\nvec2 catan(vec2 z) {\n  vec2 iz = vec2(-z.y,z.x);\n  vec2 t = clog(cdiv(vec2(1,0)-iz,vec2(1,0)+iz));\n  return 0.5*vec2(-t.y,t.x);\n}\n\nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n  return 0.5*(clog(vec2(1,0)+z)-clog(vec2(1,0)-z)); // Alternative - invertable?\n}\n\n// Taken from NR, simplified by using a fixed number of\n// iterations and removing negative modulus case.\n// Modulus is passed in as k^2 (_not_ 1-k^2 as in NR).\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n  float emc = 1.0-k2;\n  float a,b,c;\n  const int N = 4;\n  float em[N],en[N];\n  a = 1.0;\n  dn = 1.0;\n  for (int i = 0; i < N; i++) {\n    em[i] = a;\n    emc = sqrt(emc);\n    en[i] = emc;\n    c = 0.5*(a+emc);\n    emc = a*emc;\n    a = c;\n  }\n  // Nothing up to here depends on u, so\n  // could be precalculated.\n  u = c*u; sn = sin(u); cn = cos(u);\n  if (sn != 0.0) {\n    a = cn/sn; c = a*c;\n    for(int i = N-1; i >= 0; i--) {\n      b = em[i];\n      a = c*a;\n      c = dn*c;\n      dn = (en[i]+a)/(b+a);\n      a = c/b;\n    }\n    a = 1.0/sqrt(c*c + 1.0);\n    if (sn < 0.0) sn = -a;\n    else sn = a;\n    cn = c*sn;\n  }\n}\n\n// Complex sn. uv are coordinates in a rectangle, map to\n// the upper half plane with a Jacobi elliptic function.\n// Note: uses k^2 as parameter.\nvec2 sn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(snu*dnv, cnu*dnu*snv*cnv);\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(cnu*cnv,-snu*dnu*snv*dnv);\n}\n\nvec2 dn(vec2 z, float k2) {\n  float snu,cnu,dnu,snv,cnv,dnv;\n  sncndn(z.x,k2,snu,cnu,dnu);\n  sncndn(z.y,1.0-k2,snv,cnv,dnv);\n  float a = 1.0/(1.0-dnu*dnu*snv*snv);\n  return a*vec2(dnu*cnv*dnv,-k2*snu*cnu*snv);\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n    \nvec2 rotate(float t) {\n  return expi(t);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  //return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n  // This produces more accurate results on some platforms\n  return cmul(p,rotate(t));\n}\n\nfloat COS[] =\n  // Don't trust cos on the GPU to be accurate enough: cos(PI/n) for n = 0..31\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n\n// Invert z in circle radius r, centre w\nvec2 invert(vec2 z, vec2 w, float r2) {\n  vec2 z1 = z - w;\n  float k = r2/dot(z1,z1);\n  return z1*k+w;\n}\n\n// Invert z in circle p, r2, if it is inside\nbool tryinvert(inout vec2 z, vec2 p, float r2) {\n  vec2 z1 = z - p;\n  float d2 = dot(z1,z1);\n  if (d2 >= r2) return false;\n  z = z1*r2/d2 + p;\n  return true;\n}\n\nbool tryreflect(inout vec2 z, vec2 norm) {\n  float k = dot(z,norm);\n  if (k <= 0.0) {\n    return false;\n  } else {\n    z -= 2.0*k*norm;\n    return true;\n  }\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3cWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[869, 869, 900, 900, 3042], [3044, 3044, 3101, 3101, 3223]], "test": "untested"}
{"id": "dddBD8", "name": "Spectral rendered atmosphere", "author": "robobo1221", "description": "Doing some experiments with spectral rendering", "tags": ["atmosphere", "pbr", "spectral"], "likes": 20, "viewed": 383, "published": 3, "date": "1697131283", "time_retrieved": "2024-07-30T17:29:01.899088", "image_code": "const float earthRadius = 2.0;\nconst float atmosphereOffset = 0.1;\nconst vec3 earthPosition = vec3(0.0, 0.0, 3.0);\n\nfloat PI = acos(-1.0);\n\nfloat bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n\nvec2 iSphere(in vec3 ro, in vec3 rd, in vec3 sph, in float rad) {\n\tvec3 oc = ro - sph;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - rad*rad;\n\tvec2 t = vec2(b*b - c);\n\tif( t.x > 0.0) \n\t\treturn -b - sqrt(t) * vec2(1.0, -1.0);\n\treturn vec2(-1.0);\n\n}\n\nstruct spectralWave {\n\tfloat wavelength;\n\tfloat amp;\n};\n\t\nspectralWave createWave(float freq, float amp) {\n\treturn spectralWave(freq, amp);\n}\n\t\nvec3 calculateConeColor(spectralWave wave) {\n\tvec3 dist1 = (wave.wavelength - vec3(580.0, 520.0, 445.0)) / vec3(60.0, 50.0, 50.0);\n\tfloat dist2 = (wave.wavelength - 380.0) / 25.0;\n\t\n\treturn (exp(-dist1 * dist1) * vec3(0.92, 1.0, 0.95) + exp(-dist2 * dist2) * vec3(0.006, 0.0, 0.0)) * wave.amp;\n}\n\nfloat calculateDensity(vec3 worldPosition) {\n\treturn exp(-(length(worldPosition - earthPosition) - earthRadius) * 100.) * 2000000000000.0;\n}\n\nfloat calculateTransmittanceOverT(vec3 rayPosition, vec3 lightDir, float scatteringAmount) {\n\tconst int steps = 8;\n\tfloat stepLength = 0.01;\n\t\n\tfloat od = 0.0;\n\t\n\tfor (int i = 0; i < steps; i++) {\n\t\tod += calculateDensity(rayPosition) * stepLength;\n\t\trayPosition += lightDir * stepLength;\n\t\tstepLength *= 2.0;\n\t}\n\t\n\treturn exp(-od * scatteringAmount);\n}\n\nspectralWave rayleighScattering(vec3 origin, vec3 worldVector, vec3 lightDir, float wavelength, vec2 sphereEarth, vec2 sphereAtmo, float dither, float phase) {\n\tif (sphereAtmo.x <= 0.0) {\n\t\treturn createWave(wavelength, 0.0);\n\t}\n\t\n\tconst int steps = 10;\n\t\n\tvec3 startPos = origin + worldVector * max(sphereAtmo.x, 0.0);\n\tvec3 endPos = origin + worldVector * (sphereEarth.x > 0.0 ? sphereEarth.x : sphereAtmo.y);\n\t\n\tvec3 increment = (endPos - startPos) / float(steps);\n\tfloat stepSize = length(increment);\n\t\n\tvec3 rayPosition = startPos + increment * dither;\n\t\n\tfloat scatteringAmount = 1.0 / pow(wavelength, 4.0);\n\tfloat transmittence = 1.0;\n\tfloat scattering = 0.0;\n\t\n\tfor (int i = 0; i < steps; i++) {\n\t\tfloat depth = calculateDensity(rayPosition) * stepSize;\n\t\tfloat stepTransmittance = exp(-scatteringAmount * depth);\n\t\t\n\t\tscattering += (1.0 - stepTransmittance) * transmittence * calculateTransmittanceOverT(rayPosition, lightDir, scatteringAmount);\n\t\ttransmittence *= stepTransmittance;\n\t\t\n\t\trayPosition += worldVector * stepSize;\n\t}\n\t\n\treturn createWave(wavelength, scattering * phase);\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tvec2 wPos = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 worldVector = normalize(vec3(wPos, 1.0));\n\t\n\tvec3 color = vec3(0.0);\n\tvec3 bbColor = vec3(0.0);\n\tconst float minFreq = 400.0;\n\tconst float maxFreq = 650.0;\n\tconst float freqStep = 50.0;\n\tvec3 totalWeight = vec3(0.0);\n    \n    float rotation = iTime;\n    \n    if (iMouse.x > 1.0) {\n        rotation = (0.5 - iMouse.x / iResolution.x) * 2.0 * PI;\n    }\n\t\n\tvec3 lightDir = normalize(vec3(sin(rotation), 1.0, cos(rotation)));\n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n\t\n\tvec2 sphereEarth = iSphere(rayOrigin, worldVector, earthPosition, earthRadius);\n\tvec2 sphereAtmo = iSphere(rayOrigin, worldVector, earthPosition, earthRadius + atmosphereOffset);\n\tfloat VoL = dot(lightDir, worldVector);\n\t\n\tfloat phase = (VoL * VoL + 1.0) / PI;\n\t\n\tfloat dither = bayer16(gl_FragCoord.xy);\n\n\tfor (float freq = minFreq; freq <= maxFreq; freq += freqStep) {\n\t\tvec3 currConeColor = calculateConeColor(createWave(freq, 1.0));\n\t\tvec3 weight = currConeColor;\n\t\ttotalWeight += weight;\n\t\tbbColor += calculateConeColor(rayleighScattering(rayOrigin, worldVector, lightDir, freq, sphereEarth, sphereAtmo, dither, phase)) * weight;\n\t}\n\n\tcolor = bbColor / totalWeight;\n\tcolor = pow(color, vec3(2.2));\n\tcolor *= 20.0;\n    color /= color + 1.0;\n\tcolor = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 161, 161, 230], [389, 389, 454, 454, 639], [699, 699, 747, 747, 782], [785, 785, 829, 829, 1080], [1082, 1082, 1126, 1126, 1222], [1224, 1224, 1316, 1316, 1577], [1579, 1579, 1738, 1738, 2675], [2678, 2678, 2735, 2735, 4144]], "test": "untested"}
{"id": "dtfBWX", "name": "Hello KENDAMA", "author": "derSchamane", "description": "First Kendama on Shadertoy!\n\nUse the mouse to move the camera.\nJust deactivate the AA (line 21: true -> false) if the shader is running too slowly.", "tags": ["3d", "raymarching", "wood", "kendama"], "likes": 9, "viewed": 187, "published": 3, "date": "1697127104", "time_retrieved": "2024-07-30T17:29:02.995156", "image_code": "//                     = Hello KENDAMA =         \n//               by Maximilian Knape ·∑>| 2023            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA 2.2\n\n#define MAX_STEPS 120\n#define STEP_FAC 0.6\n#define MAX_DIST 1.\n#define MIN_DIST .01\n\n#define GLOW_INT 0.5\n#define PP_ACES 0.5\n#define PP_CONT 0.5\n#define PP_VIGN 1.5\n#define AO_OCC 0.3\n#define AO_SCA 0.8\n\n#define AA_ENAB true\n#define AA_THRE .01\n\n#define iTime iTime\n#define PI 3.14159265\n#define TAU 6.28318531\n#define S(x,y,t) smoothstep(x,y,t)\n\n\nvec2 Map(in vec3 p) \n{    \n    float d = MAX_DIST, col = 0., l = length(p);\n    \n    //TAMA\n    vec3 tamp = p - vec3(0,.0745 + Move(iTime)*.06,0);\n    float taml = length(tamp);\n    if (taml < .1)\n    {\n        float tama = length(tamp) - .03;\n        tama = smax(tama, -sdCone(tamp + vec3(0.,.016,0.), vec2(0.7), .02), .001);\n        tama = max(tama, -sdCylinder(tamp + vec3(0,.01,0), vec2(.007, .03)));\n        tama = max(tama, -sdCylinder(tamp - vec3(0,.01,0), vec2(.001, .03)));\n        tama = max(tama, -(length(tamp - vec3(0,.0325,0))-0.0035));\n        \n        col = tamp.y > -.015 && taml > .029 ? \n                mix(col, 3.85, step(tama, d)) : \n                mix(col, Wood(tamp.yzx), step(tama, d));\n                \n        d = min(tama, d);\n    }\n    else d = .1;\n    \n    //KEN\n    vec3 kenp = p;\n    if (length(kenp) < .3)\n    {\n        float ken = sdCappedCone(p, 0.075, .015, .0001) - (kenp.y*kenp.y)/1.5;\n        \n        if (kenp.y > -.02) \n        {\n            ken = smin(ken, length(kenp - vec3(0,0.080,0)) - .0008, .0045);\n            \n            float cups = sdEllipsoid(kenp - vec3(0.012, .035, 0.), vec3(.1, .025, .025));\n            cups = max(cups, -sdTorus(kenp.zxy - vec3(0., .0, .035), vec2(.04, .031))); \n            cups = max(cups, sdBox(kenp - vec3(0.001, .035, 0.), vec3(.038)));\n            cups = max(cups, -(length(kenp - vec3(0.059, .035, 0.)) - .03));\n            cups = max(cups, -(length(kenp - vec3(-0.059, .035, 0.)) - .03));\n\n            col = mix(col, Wood(kenp.zxy), step(cups, d));\n            d = min(cups, d);\n        }\n        else\n        {\n            ken = smin(ken, sdCylinder(kenp + vec3(0,.0715,0), vec2(.02, .006)), .003);\n            ken = smin(ken, sdCylinder(kenp + vec3(0,.035,0), vec2(.017, .002)), .01);\n            float bcup = length(kenp + vec3(0.,.1,0.)) - .029; \n            bcup = min(bcup, sdCylinder(kenp + vec3(0,.1,0), vec2(.007, .05)));\n            ken = max(ken, -bcup);\n        }\n        \n        col = mix(col, Wood(kenp), step(ken, d));\n        d = min(ken, d);\n    }\n    else d = .1;\n\n    return vec2(d, col);\n}\n\nfloat String(in vec3 ro, in vec3 rd)\n{\n    float m = Move(iTime);\n    \n    vec3 p0 = vec3(0., 0.04, -.0085);\n    vec3 p1 = vec3(-.08*cos(iTime*1.3), -.7 + m*.03, -.14);\n    vec3 p2 = vec3(-.03*sin(iTime*0.5), .105 + m*.06, .15);\n    vec3 p3 = vec3(0, .105 + m*.06, 0);\n    \n    float t = iBezier( ro, rd, p0, p1, p2, p3, 0.0005);\n    \n    return t > 0.0 ? t : MAX_DIST;\n}\n\nfloat SurfDis(float depth) { return depth / iResolution.y / 2.; }\n\nvec3 Normal(in vec3 p, in float depth)\n{\n    float h = SurfDis(depth);\n    vec2 k = vec2(1.,-1.);\n\n    return normalize(   k.xyy * Map(p + k.xyy * h).x + \n                        k.yyx * Map(p + k.yyx * h).x + \n                        k.yxy * Map(p + k.yxy * h).x + \n                        k.xxx * Map(p + k.xxx * h).x );\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, vec2 fc) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    dO += (fract(1e3* sin( dot(fc,vec2(114,211.1) )))-.5)*MIN_DIST; //fabrice like\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Map(p);\n        col = dS.y;\n        dO += dS.x * mix(STEP_FAC, 1., dO/MAX_DIST);\n        \n        if (dO > MAX_DIST || dS.x < SurfDis(dO)) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float dis, float w) //iq mk\n{\n    float res = 1.;\n    float t = .01;\n    float d = (MAX_DIST-dis)*.5;\n    \n    for( int i=0; i<12 && t<d; i++ )\n    {\n        float h = Map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n        t += clamp(log(h+1.), .001, .1);\n        if( res<-1.0 || t>d) break;\n    }\n    res = clamp(res*2., -1., 1.);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nfloat CalcAO(const in vec3 p, const in vec3 n) //iq\n{\n    float occ = AO_OCC;\n    float sca = AO_SCA;\n\n    for( int i = 0; i < 5 ; i++ )\n    {\n        float h = 0.001 + 0.150 * float(i) / 4.0;\n        float d = Map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return S(0.0, 1.0 , 1.0 - 1.5 * occ);    \n}\n\nconst vec3 ambCol = vec3(.03,.05,.1) * 2.0;\nconst vec3 sunCol = vec3(1., .8, .6) * 1.0;\nconst vec3 skyCol = vec3(.3, .5, 1.) * 1.0;\nconst float specExp = 5.;\n\nvec3 Sky(vec3 rd, vec3 lPos, float depth)\n{\n    float gnd = smoothstep(-.2, .3, dot(vec3(0,1,0), rd));\n    vec3 col = mix((ambCol + skyCol + sunCol) / 8., skyCol, gnd);\n\n    return S(vec3(0), vec3(1), col);\n}\n\nvec3 Shade(vec3 col, float mat, vec3 p, vec3 n, vec3 rd, vec3 lp, float dis) \n{\n\n    vec3    lidi = normalize(lp - p);\n    float   mafa = max(mat, .0),\n            amoc = CalcAO(p, n),\n            shad = softshadow(p, normalize(lp), dis, 0.5),\n            diff = max(dot(n, lidi), 0.) * shad,\n            spec = pow(diff, max(1., specExp * mafa)),\n            refl = pow(max(0., dot(lidi, reflect(rd, n))), max(1., specExp * 3. * mafa)) * shad;\n\n    return  col * (amoc * ambCol +                                       \n                   (1. - mafa) * diff * sunCol +                         \n                   mafa * (spec + refl) * sunCol +                       \n                   max(-mat, 0.) * smoothstep(0., 1., amoc * amoc + .5));\n}\n\nvec3 Palette(int index)\n{\n    switch (index)\n    {\n        case 0: return vec3(1.);\n        case 1: return vec3(1., .6, .3) *.7;\n        case 2: return vec3(1., .02, .01) *.3 * S(0.,1.,cos(iTime/21.));\n        case 3: return hsv2rgb_smooth(vec3(fract(iTime/36.+.3), .8, .85));\n    }\n    return vec3(0.);\n}\n\nvec3 R(in vec2 uv, in vec3 p, in vec3 l)\n{\n    vec3   f = normalize(l - p),\n           r = normalize(cross(vec3(0,1,0), f)),\n           u = cross(f,r),\n           c = p + f,\n           i = c + uv.x*r + uv.y*u;\n    return normalize(i - p);\n}\n\nvoid Render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.5);\n\n    vec3 ro = vec3(0., 0., -.3);\n    ro.yz *= Rot(-m.y * PI + PI*.5);\n    ro.xz *= Rot(-m.x * PI*2. - PI);\n    vec3 rd = R(uv, ro, vec3(0., 0.03, 0.));\n    \n    vec3 lPos = vec3(sin(iTime*2.*PI/10.)*5., sin(iTime*2.*PI/20.)*5.+00., cos(iTime*2.*PI/30.)*5.-10.);\n    \n    vec3 p = vec3(0.);\n    vec3 rmd = RayMarch(ro, rd, fragCoord);\n    \n    vec3 bg = Sky(rd, lPos, rmd.x/MAX_DIST);\n    vec3 col = bg;\n    \n    float str = String(ro, rd);\n    \n    if (str < rmd.x)\n    {\n        col = Palette(2) * S(1.,-1., dot(rd, normalize(lPos))) + vec3(.02);\n        //col *= softshadow( ro + rd*str, normalize(lPos), str, 0.5);\n        rmd.x = str;\n        rmd.y = 1.;\n    }\n    else if(rmd.x < MAX_DIST) \n    {\n        p = ro + rd * rmd.x;\n        vec3 n = Normal(p, rmd.x);\n        if (rmd.z < 2. && rmd.z > 1.) \n            n *= 1. - (rmd.z-1.5) * .5;\n        \n        float shine = fract(rmd.z)*abs(rmd.z)/rmd.z;\n        col = Palette(int(floor(abs(rmd.z))));\n        col = Shade(col, shine, p, n, rd, lPos, rmd.x);   \n        \n        //col = vec3(1) * CalcAO(p, n);\n    }\n    \n    float disFac = S(0., 1., pow(rmd.x / MAX_DIST, 2.));\n    \n    col = mix(col, bg, disFac);\n    col += pow(rmd.y / float(MAX_STEPS), 2.) * normalize(ambCol) * GLOW_INT;\n    \n    fragColor = vec4(col * S(0., 10., iTime*iTime),1.0);\n}\n\nvec4 PP(vec3 col, vec2 uv)\n{\n    col = mix(col, (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14), PP_ACES); \n    col = mix(col, S(vec3(0.), vec3(1.), col), PP_CONT);    \n    col *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    col = pow(col, vec3(1) / GAMMA);\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 U) //Fabrice\n{\n    Render(O,U);\n    \n    if (AA_ENAB && fwidth(length(O)) > AA_THRE)\n    {\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { Render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++; //Show sampled area\n    }\n    \n    O = PP(vec3(O), (U-.5 * iResolution.xy) / iResolution.y);\n}", "image_inputs": [], "common_code": "//   -----= Inigo Quilez =-----\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) // vertical\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h ) // vertical\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n    \n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n}\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float width)\n{\n    const int kNum = 42;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        float s = 1.0-t;\n        vec3 b = p0*s*s*s + p1*3.0*s*s*t + p2*3.0*s*t*t + p3*t*t*t;\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n}\n\n//   -------= IQ END =-------\n\n\nfloat Move(in float t) { return smoothstep(-.0, 1., -sin(t/3.)); }\n\nfloat Wood(in vec3 p)\n{\n    p *= vec3(50,10,30);\n    //p += vec3(3,2,1);\n    return 1. + fract(dot(sin(p), cos(p))*10.)*.4;\n}\n\nmat2 Rot(in float a) //2D\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dtfBWX.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[663, 663, 685, 685, 2758], [2760, 2760, 2798, 2798, 3131], [3133, 3133, 3161, 3161, 3198], [3200, 3200, 3240, 3240, 3524], [3526, 3526, 3569, 3569, 4033], [4035, 4035, 4109, 4109, 4466], [4962, 4962, 5005, 5005, 5170], [5172, 5172, 5251, 5251, 5915], [5917, 5917, 5942, 5942, 6222], [6224, 6224, 6266, 6266, 6464], [6466, 6466, 6520, 6520, 7969], [7971, 7971, 7999, 7999, 8274], [8276, 8276, 8322, 8322, 8643]], "test": "untested"}
{"id": "dscBDn", "name": "Fluid Lava Lamp", "author": "Peace", "description": "Fluid Lava Lamp", "tags": ["fluid", "lava", "lamp"], "likes": 3, "viewed": 244, "published": 3, "date": "1697103856", "time_retrieved": "2024-07-30T17:29:03.948607", "image_code": "const float SMOOTHNESS = 0.5;\nconst vec3 BLOB_COL_BASE = vec3(1.0, 0.11, 0.8);\nconst vec3 BLOB_COL_GLOW = vec3(1.0, 0.9, 0.0);\nconst float ROWS = 6.0;\n\nconst float RND[30] = float[30](0.2884, 0.3388, 0.5121, 0.8102, 0.5609, 0.6835, 0.0417, 0.3324, 0.0942, 0.9385, 0.4919, 0.9025, 0.4005, 0.1238, 0.3975, 0.5206, 0.6451, 0.2493, 0.3134, 0.6284, 0.6825, 0.2130, 0.4290, 0.5830, 0.2942, 0.3272, 0.3090, 0.1650, 0.6657, 0.5425);\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h / k * 0.25;\n}\n\nvec4 perm(vec4 x) { x *= x * 34.0 + 1.0; return x - floor(x / 289.0) * 289.0; }\n\nfloat noise(vec3 p) {\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0, 1, 0, 1);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.z;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * 0.02439024);\n    vec4 o2 = fract(k4 * 0.02439024);\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat hash11(float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(p * p * 2.0);\n}\n\nfloat noise1d(float p)  {\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(hash11(fl), hash11(fl + 1.0), fc);\n}\n\nfloat blob(vec2 uv, float n, float i) { \n    float r = noise1d(i + iTime * 0.1) * 1.2 + 0.4 * max(iResolution.x / iResolution.y, iResolution.y / iResolution.x);    \n    float t = fract((iTime * 0.02 + i * 84.7291) / (1.0 + RND[int(i + ROWS)]));\n    vec2 pos = vec2(i * max(1.0, iResolution.x / iResolution.y) * 0.8, \n                   (smoothstep(0.0, 0.4, t) * smoothstep(0.8, 0.5, t) * 2.0 - 1.0) * (ROWS - 1.0) * iResolution.y / min(iResolution.x, iResolution.y));\n    return length(uv - pos + n) - r;\n}\n\nfloat sdf(vec2 uv, float n) {\n    float d = 9999.9;\n    for (float i = -ROWS; i <= ROWS; ++i) {\n        d = smin(d, blob(uv, n, i), SMOOTHNESS);\n    }\n    return d;\n}\n\nfloat specular(vec3 light_dir, vec3 normal) {\n    vec3 halfway = normalize(light_dir + vec3(0, 0, -3));\n    float s = dot(normal, halfway);\n    s *= s * s;\n    return s * s;\n}\n\nvec3 getNormal(vec2 uv, float d, float n) {\n    vec2 e = vec2(12, 0);\n    float nx = d - sdf(uv + e.xy, n);\n    float ny = d - sdf(uv + e.yx, n);\n    return normalize(vec3(nx, ny, e.x * 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * ROWS;\n    \n    float n2 = noise(vec3((fragCoord * 2.0 - iResolution.xy) / min_res * 5.0, iTime * 0.1) * 0.7) * 0.7;\n    float d = sdf(uv, n2); \n    vec3 background = BLOB_COL_BASE * 1.0 / (6.0 + d);\n    if (d > 0.0) {\n        fragColor = vec4(background, 1);\n        return;\n    }\n    vec3 n = getNormal(uv, d, n2);\n    float m = smoothstep(0.0, -16.0 / min_res, d);\n    vec3 uvn = normalize(vec3(uv, 3));\n    float spec = max(0.0, uvn.y) * specular(vec3(uvn.x, -3, 0), n);\n    spec += min(1.0, 1.0 - uvn.y) * specular(vec3(uvn.x, 3, 0), n);\n    spec /= (spec + 3.0) * 0.2;\n\n    vec3 col = spec * spec * (BLOB_COL_GLOW * 0.3 + 0.7) + mix(BLOB_COL_BASE, BLOB_COL_GLOW, spec);\n    col -= max(0.0, 1.0 - sqrt(sqrt(-d))) * 0.7;\n    fragColor = vec4(mix(background, col, m), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[426, 426, 465, 465, 548], [550, 550, 569, 569, 629], [631, 631, 652, 652, 1128], [1130, 1130, 1153, 1153, 1233], [1235, 1235, 1260, 1260, 1353], [1355, 1355, 1394, 1394, 1862], [1864, 1864, 1893, 1893, 2030], [2032, 2032, 2077, 2077, 2207], [2209, 2209, 2252, 2252, 2403], [2405, 2405, 2457, 2457, 3349]], "test": "untested"}
{"id": "DsdfDr", "name": "Simple hue-to-RGB function", "author": "ruudhelderman", "description": "Function hue2rgb is simple, but not optimized for performance (it uses sin).\n", "tags": ["rainbow", "hue"], "likes": 3, "viewed": 289, "published": 3, "date": "1697052591", "time_retrieved": "2024-07-30T17:29:04.890090", "image_code": "// Simple hue-to-RGB function\n// by Ruud Helderman, 2023-10-11 - MIT License\n\nconst float saturation = 1.0;   // lower for gray, higher for discrete color bands\n\nvec3 hue2rgb(float hue)\n{\n    const vec3 offset = vec3(0, 2.0944, 4.1888);    // 2*PI full circle, divided into 3\n    return clamp(saturation * sin(hue + offset) + 0.5, 0.0, 1.0);\n}\n\nvec3 freaky(float y)        // playing with more silly effects...\n{\n    return hue2rgb(y);                                // rainbow\n    //return vec3(1.0 - pow(abs(sin(y * 5.0)), 9.0));   // thin stripes\n    //return vec3(fract(y));                            // gradient stripes\n    //return vec3(1);                                   // none\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float mono = length(texture(iChannel0, uv).rgb);\n    fragColor = vec4(mono * freaky(4.0 * mono - 30.0 * uv.y + iTime), 1);\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdfDr.jpg", "access": "api", "license": "mit", "functions": [[162, 162, 187, 187, 343], [345, 345, 412, 412, 691], [693, 693, 748, 748, 919]], "test": "untested"}
{"id": "DddBWr", "name": "Xorverse", "author": "Virgill", "description": "Just a quick compofiller for the 4k intro compo @Deadline Berlin 2023\n\nMusic done with Sointu, a great 4klang fork \n\n\nhttps://www.youtube.com/watch?v=s-5jykcgHd8&ab_channel=JochenFeldk%C3%B6tter", "tags": ["4k", "demoscene", "intrro"], "likes": 16, "viewed": 450, "published": 3, "date": "1697045167", "time_retrieved": "2024-07-30T17:29:05.939284", "image_code": "// Xorverse\n\n// Virgill/Alcatraz 4k intro for Deadline Demoparty Berlin 2023\n\n// Xor rox, Sointu rox, Las rox\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 34890, "src": "https://soundcloud.com/virgill/xorverse", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Xorverse\n\n// Virgill/Alcatraz 4k intro for Deadline Demoparty Berlin 2023\n\n// Xor rox, Sointu rox, Las rox\n\n\n#define ITER 60\n#define BOUNCES 2\n#define PI 3.14159265\n#define PHI 1.618033988749\n\nvec3 hashHs(vec3 n, uint seed)\n{\n\tfloat a = (float((seed * 0x73493U) & 0xfffffU) / float(0x100000))*2. - 1.;\n\tfloat b = 6.283*(float((seed * 0xAF71fU) & 0xfffffU) / float(0x100000));\n\tfloat c = sqrt(1. - a * a);\n\tvec3 r = vec3(c*cos(b), a, c*sin(b));\n\treturn dot(r, n) > 0. ? r : -r;\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 ip = floor(p);\n\tp -= ip;\n\tvec3 s = vec3(7, 157, 113);\n\tvec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp = p * p*(3. - 2.*p);\n\th = mix(fract(sin(h)*43758.5), fract(sin(h + s.x)*43758.5), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Lasball by Mercury\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI + 1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - .5 *sin(0.33*iTime)* (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.));\n\n}\n\nvec2 pMod(inout vec2 p, vec2 size)\n{\n\tvec2 hz = size / 2.;\n\tvec2 c = floor((p + hz) / size);\n\tp = mod(p + hz, size) - hz;\n\tp *= mod(c, vec2(2))*2. - vec2(1);\n\tp -= hz;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c / 2.);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\n// alcatraz logo by slerpy/lj/gopher/xtr1m\nfloat atz(vec3 p)\n{\n\tvec3 a=abs(p);\n\treturn max(min(max(max(\n\t\tmin(length(vec2(mod(p.x+.067,.134)-.067,p.z)),max(a.x-.02,a.y)-.1),\n\t\t-min(length(p.xy-vec2(0,.03))-.06,max(a.x,abs(p.y+.02)-.03)-.04)\n    ),abs(a.x+a.y)-.4),abs(abs(a.x+a.y)-.41)*.707-.01),a.z)-.03;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h*(1.0 - h);\n}\n\nvoid dmin(inout vec3 d, in float x, in float y, in float z)\n{\n\tif (x < d.x) d = vec3(x, y, z);\n}\n\nfloat tunnel(vec3 p)\n{\n    float time = iTime+22.5;\n\tp = p.xzy; p.z -= time;\n\tp.xy = vec2((atan(p.x, p.y) + 1.5*sin(0.9*sqrt(dot(p.xy, p.xy)) - 0.1*time))*1.0187, 1. - length(p.xy));\n\tvec2 ku = pMod(p.xz, vec2(.8));\n\tpR(p.xz, time*.16);\n\tpMod(p.xz, vec2(.7));\n\tfloat box = sdBox(p - vec3(0), vec3(.4));\n\treturn box;\n}\n\n//*******************************************************************\n\nvec3 map(vec3 p)\n{\n\tvec3 d = vec2(0, 1e+31).yxx;\n\tfloat wireframe = 0.;\n\tif (fract(0.25*iTime) < 0.3125&&fract(4.*iTime) < 0.25&&iTime > 8.) wireframe = 1.;\n\tdmin(d, sdCapsule(p, vec3(-5., -2.5, 0), vec3(5., -2.5, 0), .5), 3., 0.);\n\n    if (iTime < 32.)\n\t{\n\t\t// noise floor\n\t\tvec3 q = p;\n\t\tq.x += iTime;\n\t\tfloat floornoise = .9*noise(.7*q);\n\t\tdmin(d, smin(5. - p.z, 1.5 - p.y, 8.) + floornoise, 0.9, 0.0);\n\t\t// wireframe cube\n\t\tif (iTime > 16.)pR(p.yz, 0.25*(iTime - 16.));\n\t\tif (iTime > 20.)pR(p.xz, 0.5*(iTime - 20.));\n\t\twireframe = (.98 + length(max(abs(p) - 0.8802, 0.0)))*wireframe;\n\t\tdmin(d, sdBox(p, vec3(.9)), .9, wireframe);  //;\n\t}\n\n\n\tif (iTime > 32.&&iTime < 48.)\n\t{\n\t\t// tunnel1\n\t\tvec3 q = p;\n\t\tpR(q.yz, PI*.5);\n\t\tdmin(d, tunnel(q), .7, 0.);\n\t\tdmin(d, sdSphere(q + vec3(0., 1. + sin(iTime), 0.), .3), 4., wireframe);\n\t}\n\n\tif (iTime > 48. && iTime<72.)\n\t{\n\t\t// walls\n\t\tvec3 q = p;\n\t\tpR(q.zx, 0.5 + 0.5*sin(0.2*iTime));\n\t\tpR(q.yz, .2 + 0.2*sin(0.5*iTime));\n\t\tdmin(d, 2. - q.y, 0.5 + 0.5*sin(4.*q.x), 0.);\n\t\tdmin(d, 7.9 + q.x, .7, 0.);\n\t\tdmin(d, 8. - q.z, 2., 1. - sin(4.*q.x));\n\t\t// lasball\n\t\tq = p;\n\t\tpR(q.xy, 0.4*iTime);\n\t\tpR(q.zy, 0.25*iTime);\n\t\tdmin(d, fBlob(q*1. + 0.1*sin(iTime)), 0.5, 0.);\n\t}\n    \n    if (iTime >72.)\n    {\n        // logo\n        vec3 q = p;\n        float moise=0.25-0.5*noise(6.*q+iTime*0.5)-0.1*noise(30.*p+iTime);\n        dmin(d, sdCapsule(p, vec3(-10., moise, -1.9), vec3(10.,moise , -1.9), .23), 1.01, 1.);\n        q=p+vec3(0.,0.,2.1);\n        pR(q.zy,PI+0.25*sin(iTime));\n        dmin(d, atz(q),.99,0.);\n    }    \n    return d;\n}\n\nvec3 normal(vec3 p, float k)\n{\n\tfloat m = map(p).x;\n\tvec2 e = vec2(0.0, k);\n\treturn normalize(m - vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\nvec3 tracer(vec3 ro, vec3 rd)\n{\n\tvec3 m;\n\tfloat t = .0001;\n\tfor (int i = 0; i < ITER; i++)\n\t{\n\t\tm = map(ro + rd * t);\n\t\tt += m.x;\n\t}\n\treturn vec3(t, m.yz);\n}\n\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n\tvec2 uv = (2.*p.xy - iResolution.xy) / iResolution.x*vec2(1, -1);\n\tro = vec3(0, 0, -3);\n\trd = normalize(vec3(uv, 1));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec3 emit = vec3(0), ro, rd, t, sp, sn;\n\t\tvec2 uv = (fragCoord.xy / iResolution.xy);\n        // get last frame\n\t\tvec4 buffer = texture(iChannel0, uv);\t\t  \n\t\tfloat amplify = .1, blur = .8;\n\t\tfloat zoom = 3.;\n\t\tfloat shift = 0.;\n\t\tif (iTime > 16.) shift = 0.25 + .25*-cos((iTime*PI*0.25));\n\t\tif (fract(iTime*0.0625) < 0.5) shift = 0.;\n\t\tif (iTime > 72.) shift = 0.;\n\t\tif (uv.y > 0.5 - shift && uv.y < 0.5 + shift)\n\t\t{\n\t\t\tzoom = 1.;\n\t\t}\n        // calculate first seed\n\t\tuint seed = uint((fragCoord.x / zoom)) ^ uint(fragCoord.y / zoom) ^ uint(floor(iTime+2.)); \n\t\tcamera(ro, rd, fragCoord);\n\n\t\tfor (int i = 0; i < BOUNCES; i++)\n\t\t{\n\t\t\tt = tracer(ro, rd);\n\t\t\tsp = ro + rd * t.x;\n\t\t\tsn = normal(sp, 5e-5);\n\t\t\tif (t.y > 1.&& i > 0) emit = t.y * vec3(0.7, 1., 0.7); \n             // wireframe \n\t\t\tif (t.z >= 1.&&i == 0) emit = t.z*vec3(1.4, 2., 1.4);\n\n\n\t\t\tif (uv.y > 0.5 - shift && uv.y < 0.5 + shift)\n\t\t\t{\n                // calculate new seed\n\t\t\t\tseed += uint(iTime*30.); \n\t\t\t\tif ((uv.y > 0.5 - shift && uv.y < 0.505 - shift) || (uv.y > 0.495 + shift && uv.y < 0.5 + shift)) emit = vec3(1., 2., 1.);\n\t\t\t\tamplify += .05;\n\t\t\t}\n            // reflect ray over hemisphere. dependent on material\n\t\t\trd = mix(reflect(rd, sn), hashHs(sn, seed), clamp(t.y, 0., 1.));  \n\t\t\tro = sp;\n\t\t}\n\n\t\temit *= amplify;\n\t\tfloat fade = min(iTime*0.2, 1.);\n\t\tfloat fadeout = clamp(1. - min((iTime - 80.)*0.1, 1.), 0., 1.);\n\t\tfragColor = (vec4(emit.x, emit.y, emit.z, 1.) + buffer * blur)*fadeout*fade;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DddBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 168, 168, 252]], "test": "untested"}
{"id": "mdcBDn", "name": "Flubbly˚", "author": "zhonkvision", "description": "Original Fork :\n\nhttps://www.shadertoy.com/view/4slyRs", "tags": ["raymarching", "tunnel", "postprocess", "alien", "corridor"], "likes": 10, "viewed": 403, "published": 3, "date": "1697029485", "time_retrieved": "2024-07-30T17:29:06.712219", "image_code": "//bloom & vignet effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =  fragCoord.xy/iResolution.xy;\n   \n    vec4 tex = texture(iChannel1, uv);\n    vec4 texBlurred = texture(iChannel0, uv);\n    float vignet = length(uv - vec2(0.5))*1.5;\n        \n\tfragColor = mix(tex, texBlurred*texBlurred, vignet) + texBlurred*texBlurred*0.5;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float EPSILON = 0.002;\nvec2 twist = vec2(2.0,7.0);\nfloat planesDistance = 0.3;\nvec4 bumpMapParams1 = vec4(3.0,7.0,0.02,-0.01);\nvec4 bumpMapParams2 = vec4(3.0,3.0,-0.02,0.01);\nvec4 heightMapParams = vec4(3.0,1.0,0.0,0.01);\nvec4 heightInfluence = vec4(-0.035,-0.05,0.8,1.8);\nfloat fogDensity = 0.2;\nfloat fogDistance = 0.1;\nvec3 groundColor1 = vec3(0.2,0.3,0.3);\nvec3 groundColor2 = vec3(0.4,0.8,0.4);\nvec3 columnColors = vec3(0.9,0.3,0.3);\nvec4 ambient = vec4(0.2,0.3,0.4,0.0);\nvec3 lightColor = vec3(0.4,0.7,0.7);\nvec4 fogColor = vec4(0.0,0.1,0.5,1.0);\nvec3 rimColor = vec3(1.0,0.75,0.75);\n\nfloat pi = 3.14159265359;\n\nmat2 rot(float a) \n{\n    vec2 s = sin(vec2(a, a + pi/2.0));\n    return mat2(s.y,s.x,-s.x,s.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 pos, float radius, vec3 scale)\n{\n    return length(pos*scale)-radius;\n}\n\nfloat heightmap(vec2 uv)\n{\n    return heightMapParams.x*texture(iChannel0, (uv + iTime*heightMapParams.zw)*heightMapParams.y).x;\n}\n\nfloat bumpmap(vec2 uv)\n{\n    float b1 = bumpMapParams1.x*(1.0 - texture(iChannel0, (uv + iTime*bumpMapParams1.zw)*bumpMapParams1.y).x);\n    float b2 = bumpMapParams2.x*(1.0-texture(iChannel0, (uv + iTime*bumpMapParams2.zw)*bumpMapParams2.x).x);\n    return b1+b2;\n}\n\nfloat distfunc(vec3 pos)\n{\n    vec3 p2 = pos;\n    p2.x += sin(p2.z*3.0 + p2.y*5.0)*0.15;\n    p2.xy *= rot(floor(p2.z*2.0)*twist.y);\n    pos.xy *= rot(pos.z*twist.x);\n    \n    float h = heightmap(pos.xz)*heightInfluence.x;\n    \n    vec3 columnsrep = vec3(0.75,1.0,0.5);\n    vec3 reppos = (mod(p2 + vec3(iTime*0.01 + sin(pos.z*0.5),0.0,0.0),columnsrep)-0.5*columnsrep);\n    \n    float columnsScaleX = 1.0 + sin(p2.y*20.0*sin(p2.z) + iTime*5.0 + pos.z)*0.15;\n    float columnsScaleY = (sin(iTime + pos.z*4.0)*0.5+0.5);\n    \n    float columns = sphere(vec3(reppos.x, pos.y+0.25, reppos.z), 0.035, vec3(columnsScaleX,columnsScaleY,columnsScaleX));\n    float corridor = planesDistance - abs(pos.y) + h;\n    float d = smin(corridor, columns, 0.25); \n           \n    return d;\n}\n\nfloat rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int MAX_ITER = 50;\n\tconst float MAX_DIST = 30.0;\n    \n    float totalDist = 0.0;\n    float totalDist2 = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n    vec3 col = vec3(0.0);\n    float glow = 0.0;\n    \n    for(int j = 0; j < MAX_ITER; j++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist = totalDist + dist;\n\t\tpos += dist*rayDir;\n        \n        if(dist < EPSILON || totalDist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return totalDist  ;\n}\n\n//Taken from https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 calculateNormals(vec3 pos)\n{\n\tvec2 eps = vec2(0.0, EPSILON*1.0);\n\tvec3 n = normalize(vec3(\n\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n    \n\treturn n;\n}\n\n//Taken from https://www.shadertoy.com/view/XlXXWj\nvec3 doBumpMap(vec2 uv, vec3 nor, float bumpfactor)\n{\n   \n    const float eps = 0.001;\n    float ref = bumpmap(uv); \n    \n    vec3 grad = vec3(bumpmap(vec2(uv.x-eps, uv.y))-ref, 0.0, bumpmap(vec2(uv.x, uv.y-eps))-ref); \n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 cameraOrigin = vec3(0.0, 0.0, iTime*-0.1);\n    vec3 cameraTarget = cameraOrigin + vec3(0.0, 0.0, 1.0);;\n    \n\tvec2 screenPos = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n\tmat3 cam = setCamera(cameraOrigin, cameraTarget, 0.0 );\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos.xy,2.0) );\n    rayDir.xy *= rot(iTime*0.1);\n    float dist = rayMarch(rayDir, cameraOrigin);\n   \n    vec3 pos = cameraOrigin + dist*rayDir;\n    vec2 uv = pos.xy * rot(pos.z*twist.x);\n    float h = heightmap(vec2(uv.x, pos.z));\n    vec3 n = calculateNormals(pos);\n    vec3 bump = doBumpMap(vec2(uv.x, pos.z), n, 3.0);\n    float m = smoothstep(-0.15,0.2, planesDistance - abs(uv.y) + h*heightInfluence.y + sin(iTime)*0.05);\n    vec3 color = mix(mix(groundColor1, groundColor2, smoothstep(heightInfluence.z,heightInfluence.w,h)), columnColors, m);\n    float fog = dist*fogDensity-fogDistance;\n    float heightfog = pos.y;\n    float rim = (1.0-max(0.0, dot(-normalize(rayDir), bump)));\n    vec3 lightPos = pos - (cameraOrigin + vec3(0.0,0.0,1.0));\n    vec3 lightDir = -normalize(lightPos);\n    float lightdist = length(lightPos);\n    float atten = 1.0 / (1.0 + lightdist*lightdist*3.0);\n    float light = max(0.0, dot(lightDir, bump));\n   \tvec3 r = reflect(normalize(rayDir), bump);\n    float spec = clamp (dot (r, lightDir),0.0,1.0);\n    float specpow = pow(spec,20.0);\n    vec3 c = color*(ambient.xyz + mix(rim*rim*rim, rim*0.35+0.65, m)*rimColor + lightColor*(light*atten*2.0 + specpow*1.5));\n    vec4 res = mix(vec4(c, rim), fogColor, clamp(fog+heightfog,0.0,1.0));\n\n    \n\tfragColor = res;\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Blur Pass1\nvec2 sampleDist = vec2(2.0,2.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex /= 25.0;\n    \n\tfragColor = tex;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Blur Pass2\nvec2 sampleDist = vec2(4.0,4.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex /= 25.0;\n    \n\tfragColor = tex;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Blur Pass3\nvec2 sampleDist = vec2(8.0,8.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex /= 25.0;\n    \n\tfragColor = tex;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdcBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 356]], "test": "untested"}
{"id": "Dddfz7", "name": "Hex grid on cube coordinates", "author": "Suslik", "description": "My study on cube coordinate systems associated with hexagonal lattices, described in https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html\n\nMost of these functions actually work with ivec2 in disguise.", "tags": ["cube", "hexgrid", "adorable"], "likes": 8, "viewed": 296, "published": 3, "date": "1697028691", "time_retrieved": "2024-07-30T17:29:07.581893", "image_code": "//Controls: push the left mouse button, drag it around\n\n//Inspired by https://www.shadertoy.com/view/dtySDy\n\n//Amazing resource explaining cube coordinates of hexagon grids:\n//https://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html#justin-pombrio\nmat2 skewed_to_grid = mat2(1.0f, 0.0f, 0.5f, sqrt(3.0f) / 2.0f);\n\nvec2 GridToSkewed(vec2 grid_pos)\n{\n    return inverse(skewed_to_grid) * grid_pos;\n}\n\nvec2 SkewedToGrid(vec2 skewed_pos)\n{\n    return skewed_to_grid * skewed_pos;\n}\n\nvec3 SkewedToCube(vec2 skewed_pos)\n{\n    return vec3(skewed_pos.xy, -skewed_pos.x - skewed_pos.y);\n}\n\n//Brachless version that achieves the same thing a bunch of if's do in the article above:\nvec3 CubeToHex(vec3 cube_pos)\n{\n    vec3 i = round(cube_pos);\n    vec3 d = abs(i - cube_pos);\n    return mix(i, -i.yzx - i.zxy, step(d.yzx, d.xyz) * step(d.zxy, d.xyz));\n}\n\n\n//An alternative formulation involves 3x floor + 3x round:\n//https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 CubeToTri(vec3 cube_pos)\n{\n    return floor(cube_pos.xyz - cube_pos.zxy);\n}\n\nvec3 TriToHex(vec3 tri_index)\n{\n    return round((tri_index.xyz - tri_index.yzx) / 3.0f);\n}\n\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\nfloat HexOuterDist(vec3 cube_delta)\n{\n    return max3(abs(cube_delta.xyz - cube_delta.yzx));\n}\n\nfloat HexInnerDist(vec3 cube_delta)\n{\n    return length(cube_delta) / (sqrt(2.0f) / sqrt(3.0f)); //(sqrt(2.0f) / 2.0f) for inscribed normalization\n}\n\nvec2 Rotate2(vec2 vec, float ang)\n{\n    mat2 m = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    return m * vec;\n}\n\nfloat SmoothFract(float val)\n{\n    float f = fract(val);\n    return f * clamp((1.0f - f) * 10.0f, 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //inputs\n    bool mouse_was_pressed = texelFetch(iChannel0, ivec2(0), 0).r > 0.5f;\n    float mouse_pressed_time = texelFetch(iChannel0, ivec2(0), 0).g;\n    vec2 grid_pos = fragCoord.xy/iResolution.x * 15.0f;\n    float straight_fade = mouse_was_pressed ? mouse_pressed_time : clamp(0.5f - cos(iTime * 0.5f) * 4.0f, 0.0f, 1.0f);\n    vec2 skewed_pos = mix(GridToSkewed(grid_pos), grid_pos, straight_fade);\n    float width = 0.05f;\n    vec2 grid = step(width, fract(skewed_pos.xy + vec2(width * 0.5f)));\n    \n    vec2 wiggle_pos = vec2(-sin(0.3f * iTime), -sin(0.42f * iTime)) * 0.4f + vec2(0.5f);\n    vec2 quad_index2f = step(mouse_was_pressed ? iMouse.xy : (iResolution.xy * wiggle_pos), fragCoord.xy);\n    int quad_index = int(quad_index2f.y * 2.0f + quad_index2f.x);\n    \n    //hex stuff\n    vec3 cube_pos = SkewedToCube(skewed_pos);\n    vec3 tri_index = CubeToTri(cube_pos); //this is an ivec2\n    vec3 hex_index = TriToHex(tri_index); //this is an ivec2\n    //vec3 hex_index2 = CubeToHex(cube_pos); //same result, calculated in a different way\n    //note that distances are calcualted based in cube coordinates, so they're independent of whether the grid is skewed or not\n    float outer_dist = HexOuterDist(hex_index.xyz - cube_pos.xyz); //0..1\n    float inner_dist = HexInnerDist(hex_index.xyz - cube_pos.xyz); //0..1\n    vec2 hex_skewed_pos = hex_index.xy;\n    vec2 hex_grid_pos = mix(SkewedToGrid(hex_skewed_pos), hex_skewed_pos, straight_fade);\n\n\n    if(quad_index == 3)\n    {\n        fragColor = vec4(fract((hex_index + vec3(-0.5f)) / 6.0f).xyz * (1.0f - inner_dist) * SmoothFract(outer_dist * 4.0f) * 1.5f, 1.0f);    \n    }\n    if(quad_index == 0)\n    {\n        fragColor = vec4(fract((tri_index + vec3(-0.5f)) / 6.0f).xyz * grid.x * grid.y, 1.0f);    \n        //fragColor = vec4(vec3(fract(tri_index / 6.0f)[int(iTime / 3.0f) % 3]) * grid.x * grid.y, 1.0f);    \n    }\n    if(quad_index == 1)\n    {\n        fragColor = vec4(vec3(fract((hex_index + vec3(-0.5f)) / 6.0f).xyz) * inner_dist * grid.x * grid.y, 1.0f);\n        //fragColor = vec4(vec3(fract(hex_index / 6.0f)[int(iTime / 3.0f) % 3]) * inner_dist * grid.x * grid.y, 1.0f);\n    }    \n    if(quad_index == 2)\n    {\n        fragColor = vec4(fract(Rotate2(grid_pos - hex_grid_pos, iTime)) * grid.x * grid.y * (1.0f - pow(outer_dist, 5.0f)), 0.0f, 1.0f);\n    }\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0f / 2.2f));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel_coord = ivec2(fragCoord.xy);\n    fragColor = texelFetch(iChannel0, pixel_coord, 0);\n    if(pixel_coord == ivec2(0, 0))\n    {\n        fragColor.r = max(fragColor.r, iMouse.z);\n        fragColor.g = clamp(fragColor.g + (iMouse.z > 0.5f ? iTimeDelta : -iTimeDelta) * 4.0f, 0.0f, 1.0f);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dddfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 358, 358, 407], [409, 409, 445, 445, 487], [489, 489, 525, 525, 589], [591, 681, 712, 712, 852], [855, 983, 1014, 1014, 1063], [1065, 1065, 1096, 1096, 1156], [1158, 1158, 1178, 1178, 1216], [1217, 1217, 1254, 1254, 1311], [1313, 1313, 1350, 1350, 1461], [1463, 1463, 1498, 1498, 1580], [1582, 1582, 1612, 1612, 1694], [1696, 1696, 1753, 1766, 4142]], "test": "untested"}
{"id": "mscfWn", "name": "the crystallized flow of colors", "author": "oatmealine", "description": "something silly i got out of playing around for a while", "tags": ["2d", "post", "abstract"], "likes": 0, "viewed": 160, "published": 3, "date": "1697028431", "time_retrieved": "2024-07-30T17:29:08.333882", "image_code": "#define PI 3.141592654\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    float rem = col.r + col.g + col.b;\n    float simRed = (2.0 - length(col - vec3(1.0, 0.0, 0.0) + sin(uv.x * 2.0 - iTime * 0.8)));\n    rem -= simRed;\n    float simBlue = (2.0 - length(col - vec3(0.0, 0.0, 1.0) - cos(uv.y * 2.0 + iTime)));\n    rem -= simBlue;\n    rem += sin(iTime);\n    \n    float diff = (simRed - simBlue) * uv.y * 20.0;\n    float dir = (1.0 - pow(2.0, -abs(diff))) * sign(diff) * 0.5 + 0.5;\n    \n    vec3 colA = vec3(\n        sin(iTime) * 0.5 + 0.5,\n        sin(iTime + PI * 0.333) * 0.5 + 0.5,\n        sin(iTime + PI * 0.666) * 0.5 + 0.5\n    ) * vec3(1.0, 0.1, 0.15);\n    vec3 colB = vec3(\n        cos(iTime * 1.42) * 0.5 + 0.5,\n        cos(iTime * 1.42 + PI * 0.333) * 0.5 + 0.5,\n        cos(iTime * 1.42 + PI * 0.666) * 0.5 + 0.5\n    ) * vec3(0.1, 0.15, 1.0);\n    \n\n    fragColor = vec4(mix(vec3(rem), mix(colA, colB, dir), (simRed + simBlue) / rem), 1.0);\n    //fragColor = vec4(vec3(dir, diff, rem), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mscfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 79, 79, 1100]], "test": "untested"}
{"id": "cd3fDr", "name": "Two Square Hinged Tiling", "author": "fad", "description": "Drag your mouse to change the size of the pink squares\nSee also: [url=/view/Ds3BW8]textured version[/url]", "tags": ["tessellation", "parallelogram", "hinge"], "likes": 26, "viewed": 335, "published": 3, "date": "1697024346", "time_retrieved": "2024-07-30T17:29:09.329221", "image_code": "const float PI = 3.1415927;\n\nvoid mainImage(out vec4 O, vec2 I) {\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0 * I - R) / R.y * 6.0;\n    float t = 1.0 - abs(1.0 - mod(iTime / 2.0, 2.0));\n    float a = (smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t)) - 0.5) * PI;\n    float b = iMouse.z > 0.0 ? mix(0.2, 1.5, iMouse.x / R.x) : 0.6;\n    float c = cos(a);\n    float s = sin(a);\n    vec3 o = vec3(0.0, 1.0, -1.0);\n    mat2 A = mat2((c * o.yzyy + s * o.yyzy) * b + o.yzyy);\n    mat2 B = inverse(A);\n    vec2 P = B * p;\n    vec4 Q = 2.0 * round((P.xyxy + o.xxyy) / 2.0) - o.xxyy;\n    vec4 d = abs(vec4(A * Q.xy - p, A * Q.zw - p));\n    mat2 C = mat2(c, -s, s, c);\n    vec4 f = abs(vec4(C * (A * Q.xw - p), C * (A * Q.zy - p)));\n    float g = b - min(max(f.x, f.y), max(f.z, f.w));\n    float h = 1.0 - min(max(d.x, d.y), max(d.z, d.w));\n    O = g >= 0.0\n        ? vec4(1.000,0.302,0.533,1.0)\n        : h >= 0.0\n        ? vec4(0.204,0.490,0.957,1.0)\n        : vec4(1.0);\n    float i = min(abs(g), abs(h));\n    O *= smoothstep(0.0, length(vec2(dFdx(i), dFdy(i))), i - 0.02);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3fDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 65, 65, 1067]], "test": "untested"}
{"id": "DscfDn", "name": "Bulb Testing", "author": "zhonkvision", "description": "Bulb Testing", "tags": ["spheres", "rgb", "liquid", "smooth", "hypnotizing", "pulsating"], "likes": 6, "viewed": 270, "published": 3, "date": "1697018700", "time_retrieved": "2024-07-30T17:29:10.213856", "image_code": "\n#define time mod(iTime, 100.)\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin(float a, float b, float h)\n{\n    float k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h)\n{\n    vec3 k = clamp((a-b)/ h * .2 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nvec3 kifs(vec3 p, float t)\n{\n    float s = 0.1 + sin(time * 0.3) * 0.1;\n    for(float i = 0.; i < 5.; ++i)\n    {\n        float t2 = t + i;\n        p.xz *= rot(t2);\n        p.xy *= rot(t2 * .3);\n        p = smin(p, -p, -1.);\n        p -= s;\n        //p -= s + sin(t- length(p));\n        s *= 0.7;\n    }\n\n    return p;\n}\n\nfloat map(vec3 p, inout vec3 col)\n{\n    float d;\n    \n    vec3 p1 = p;\n    p1 = kifs(p, time * 1.);\n    float d1 = length(p1) - 0.01;\n\n    p.xy *= rot(time * 0.5);\n    p.xz *= rot(time * 0.3);\n    \n    float y = sin(time)*.5+2.;\n    float x = sqrt(y*y + y*y);\n\n    float sph = length(p) - 10.;\n\n    float sph1 = length(vec3(-x,-y,0.) - p) - sin(time * 10.)*0.015-.3;\n    vec3 sph1col = vec3(1., 3., 0.) * (1. / sph1);\n    float sph2 = length(vec3(x,-y,0.) - p) - sin(time * 8.)*0.015-.3;\n    vec3 sph2col = vec3(0., 0., 1.) * (1. / sph2);\n    float sph3 = length(vec3(0.,y,0.) - p) - sin(time * 6.)*0.015-.3;\n    vec3 sph3col = vec3(1., 1., 0.) * (1. / sph3);\n\n    \n    d = smin(sph1, sph2, (sin(time*4.)*.2+ 6.2) * 0.8);\n    d = smin(d, sph3, (sin(time*4.)*.5+ 7.0) * 0.8);\n    d = smin(d, d1, 6.);\n    col = smin(sph1col, sph2col, -.5);\n    col = smin(col, sph3col, -.5);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n    vec3 s = vec3(0.,0.,-10.);\n    vec3 r = normalize(vec3(uv, 1.));\n    vec3 col = vec3(0);\n    vec3 acol = vec3(0);\n    float at = 0.;\n    vec3 p = s;\n    float i = 0.;\n    for(i = 0.; i < 100.; ++i)\n    {\n        float d = abs(map(p, acol));\n        at += 0.09 / (0.015 + d);\n        d *= 0.1;\n        if(d < 0.01)\n        {\n            break;\n        }\n        col += pow(at * 0.026, 3.);\n        p += r * d;\n    }\n    col *= acol;\n    //col += pow(1.-i/101., 6.);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 51, 51, 103], [105, 105, 144, 144, 235], [237, 237, 273, 273, 363], [365, 365, 393, 393, 683], [685, 685, 720, 720, 1579], [1581, 1581, 1636, 1636, 2284]], "test": "untested"}
{"id": "stySzG", "name": "Aperiodic Wang Tiling", "author": "mla", "description": "Aperiodic Wang Tiling. The four quadrants of each tile are coloured and in a valid tiling, the quadrant colours match across tile edges. Here, there are 16 tile types or colour combinations. Mouse to pan, up/down to zoom.", "tags": ["tiles", "wang", "aperiodic"], "likes": 14, "viewed": 301, "published": 3, "date": "1697008958", "time_retrieved": "2024-07-30T17:29:11.199221", "image_code": "////////////////////////////////////////////////////////////////////\n//\n// Aperiodic Wang Tiling, mla, 2023\n//\n// Wang tilings, introduced by Hao Wang (王浩) in 1961, are\n// square tiles with colored edges. A valid tiling is one where\n// the colors on the edges of adjacent tiles match. The first set of\n// aperiodic tiles discovered, by Robert Berger in 1964, was a set of \n// 20476 Wang tiles. This number has been reduced since & in fact the\n// smallest aperiodic set of Wang tiles now known contains 11\n// tiles and it has been proved that no smaller set is possible.\n//\n// This shader uses the substitution rules for the 16 tile tiling \n// described in Grünbaum & Shephard. The grid is NxN where N is a \n// Fibonacci number and the recurrence splits the grid into two squares\n// and two rectangles, which are then treated as parts of a larger square.\n//\n// <mouse>: pan image\n// <up/down>: zoom in/out\n// m: disable mouse\n// r: rotate by 45°\n// x,y: grid line display\n//\n////////////////////////////////////////////////////////////////////\n\nconst float phi = 0.618033989; // NB, not 1.618..\n\n// 6 colors, 16 tile types\nconst int X = -1, A = 10, B = 11, C = 12, D = 13, E = 14, F = 15;\nivec4 transitions[] =\n  ivec4[](ivec4(X,X,X,2),ivec4(0,9,C,3),ivec4(0,B,E,3),ivec4(0,8,D,1),\n          ivec4(0,B,C,3),ivec4(0,8,C,7),ivec4(0,9,E,3),ivec4(0,9,D,5),\n          ivec4(X,X,D,1),ivec4(X,X,F,6),ivec4(X,X,C,7),ivec4(X,X,F,2),\n          ivec4(X,A,X,4),ivec4(X,8,X,1),ivec4(X,A,X,2),ivec4(X,9,X,5));\n\nivec4 colors[] =\n  ivec4[](ivec4(1,2,1,2),ivec4(3,4,3,4),ivec4(4,5,4,5),ivec4(6,3,6,3),\n          ivec4(4,5,3,4),ivec4(6,3,3,4),ivec4(3,4,4,5),ivec4(3,4,6,3),\n          ivec4(5,1,2,3),ivec4(4,1,2,6),ivec4(5,1,1,4),ivec4(3,2,2,6),\n          ivec4(2,6,4,1),ivec4(2,3,5,1),ivec4(2,6,3,2),ivec4(1,4,5,1));\n\nconst vec3 palette[] =\n  // \"Party Pastels\"\n  vec3[](vec3(182,230,189),vec3(172,154,241),vec3(247,200,238),\n         vec3(255,239,176),vec3(255,202,150),vec3(245,154,142));\n\nvec3 getcol(int i) {\n  vec3 col = palette[i-1]/255.0;\n  col = pow(col,vec3(2.2));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = mod(iTime,40.0);\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  float k = pow(phi,time);\n  if (!key(CHAR_Z)) z *= 10.0*k;\n  if (!key(CHAR_M) && iMouse.x > 0.0) z -= (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  if (key(CHAR_R)) z *= mat2(1,1,-1,1);\n  if (key(CHAR_C)) z = abs(z);\n  else z = (z+1.0);\n  z *= 0.5;\n  vec3 col = vec3(0.1,0,0);\n  int M = 1, N = 0;\n  for (int i = 0; i < int(time); i++) {\n    M = M+N; N = M-N; // I could just have a table of fib(i)\n  }\n  if (z.x >= 0.0 && z.x < 1.0 && z.y >= 0.0 && z.y < 1.0) {\n    int state = 1; // 1-7 are valid start states\n    z *= float(N+M);\n    float pwidth = fwidth(length(z));\n    ivec2 p = ivec2(z);\n    vec2 dx = dFdx(z), dy = dFdy(z);\n    z = fract(z);\n    while (N != 0) {\n      // Split region into (N+M)x(N+M) regions\n      // and recurse into the region our point is in,\n      // after applying the relevant state transition.\n      // Non-square subregions are treated as part of\n      // a larger square.\n      int sector = 2*int(p.x >= N)+int(p.y >= N);\n      state = transitions[state][sector];\n      assert(state >= 0);\n      if (p.x < N) p.x += M-N;\n      else p.x -= N;\n      if (p.y < N) p.y += M-N;\n      else p.y -= N;\n      N = M-N; M = M-N; // Think about it!\n    }\n    int icol = colors[state][int(z.x+z.y >= 1.0) + 2*int(z.x>=z.y)];\n    col = getcol(icol);\n    vec2 uv = 0.25*(vec2(state/4,state%4)+z);\n    col *= 2.0*textureGrad(iChannel0,uv,0.25*dx,0.25*dy).xyz;\n    if (!key(CHAR_X)) {\n      vec2 z1 = min(z,1.0-z);\n      float d = min(z1.x,z1.y);\n      col *= smoothstep(0.0,pwidth,d-0.0125);\n    }\n    if (!key(CHAR_Y)) {\n      float d = min(abs(z.x-z.y),abs(z.x+z.y-1.0));\n      col *= smoothstep(0.0,pwidth,d-0.01);\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (keystate(KEY_ALT,0).x == 0.0 && w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stySzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1979, 1979, 1999, 1999, 2076], [2078, 2078, 2135, 2135, 4025]], "test": "untested"}
{"id": "mddBzM", "name": "Fork Two colors ersteller 398", "author": "ersteller", "description": "this is a simple shader for displaying two seperate colors\nyes i could have use MS Paint ... ", "tags": ["twosolidcolorsstatictgrivial"], "likes": 0, "viewed": 159, "published": 3, "date": "1697006552", "time_retrieved": "2024-07-30T17:29:12.210517", "image_code": "\nvec4 solidblack = vec4(0,0.0,0.0,1.0); //This is actually black right now\nvec4 solidBlue = vec4(0.2,0.2,1.0,1.0); //This is actually black right now\nvec4 solidorang = vec4(1.0,0.65,0.0,1.0); //This is actually black right now\nvec4 solidgelb = vec4(1.0,1.,0.0,1.0); //This is actually black right now\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy; //We obtain our coordinates for the current pixel\n    xy.x = xy.x / iResolution.x; //We divide the coordinates by the screen size\n    xy.y = xy.y / iResolution.y;\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 st = vec2(atan(uv.x, uv.y)/(2.*3.1415)+0.5,length(uv));\n    uv = st;\n    \n    // Now x is 0 for the leftmost pixel, and 1 for the rightmost pixel\n    vec4 solidRed = vec4(0,0.0,0.0,1.0); //This is actually black right now\n    \n    if(xy.x > 0.75) {\n        fragColor = solidBlue;\n    }\n    else if(xy.x > 0.25) {\n        fragColor = solidblack;\n    }\n    else{\n        fragColor = solidgelb;\n    }\n    \n    \n    float x = uv.x * 5.; \n    float m = min(fract(x), fract(1.-x));\n    \n    float c = smoothstep(.09, .1, m*.3+.2-uv.y);\n    float d = smoothstep(.09, .1, m*.4+.2-uv.y);\n    \n    if (d > 0.5){\n        fragColor = vec4(1);\n    }\n    \n    if (c > 0.5){\n        fragColor = vec4(0);\n    }\n    \n\n    \n    \n\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 359, 359, 1350]], "test": "untested"}
{"id": "dd3fzN", "name": "Peeling Squares (482 chars)", "author": "fenix", "description": "Reproduction of this tweet by dave @beesandbombs \n\nhttps://twitter.com/beesandbombs/status/1376676133425590278", "tags": ["loop", "codegolf", "reproduction"], "likes": 35, "viewed": 359, "published": 3, "date": "1696981800", "time_retrieved": "2024-07-30T17:29:13.375402", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Reproduction of this tweet by Dave @beesandbombs \n//\n//  https://twitter.com/beesandbombs/status/1376676133425590278\n//\n//  To generate the correct order to animate the squares, I started with the code from\n//  elenzil's Ulam Spiral. However, I did apparently run into a bug...I had to add 2\n//  to the diagonal case, or else my squares animated out of order.\n//\n//  To speed it up, instead of iterating over all 81 squares, I only iterate over the\n//  25 squares crossing each quadrant. I feel like there's probably a way to render\n//  this with even fewer loops, although I think there has to be some because the squares\n//  cross each other's paths.\n//\n//  I tried golfing it, but please feel free to try to reduce the character count if you\n//  have any ideas!\n//\n// ---------------------------------------------------------------------------------------\n\n// From SnoopethDuckDuck: 482 chars!\n//*\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t = fract(iTime * .13);\n    \n    vec2 R = iResolution.xy, \n         U = 20. * exp(-t * 2.2) * (R-u-u) / R.y - t / 22.,\n         v,\n         z = fract(U / 3.6 + .5) * 3.6 - 1.8,\n         w = sign(z);\n    \n    O = 0.*O;\n    \n    for (int x; x < 5; x++)\n    for (int y; y < 5; y++)\n    {\n        int I = x * int(w.x),\n            J = y * int(w.y),\n            K = 4*J*J,\n            L = 4*I*I,\n            m = I > 0 && I == -J     ? K - 4*J + 3 :     // squares diagonal - bottom right\n                I > 0 && I >= abs(J) ? L - 3*I + J + 1 : // right region\n                J > 0 && J >= abs(I) ? K - I - J + 1 :   // top region\n                I < 0 && J >= I      ? L - I - J + 1 :   // left region\n                                       K + I - 3*J + 3;  // bottom region\n\n        // inject for -2 (scary)\n        v = mix(v = vec2(I, J) * .1 - .05,\n                v * 4. + .15,\n                clamp(vec2(m) / 6. - 16. + 18.*t - length(U-z)/4., 0., 1.));\n                          \n        O += smoothstep(3./R.y, 0., length(max(abs(z-v)-.05, 0.)));\n    }\n}\n/**/\n\n// My golf attempt: 550 chars\n/*\n#define s(X) (X) * (X)\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    float t = fract(iTime * .13);\n    vec2 R = iResolution.xy, U = 40. * exp(-t * 2.2) * (.5 * R - u) / R.y - t / 22.,\n         v, z = fract(U / 3.6 + .5) * 3.6 - 1.8;\n    O = vec4(0);\n    \n    for (int y, x = 0; x < 5; x++)\n    for (y = 0; y < 5; y++)\n    {\n        ivec2 w = ivec2(x, y) * ivec2(sign(z));\n        int I = w.x,\n            J = w.y,\n            m = I > 0 && I == -J     ? s(1 - 2 * J) + 2 :         // squares diagonal - bottom right\n                I > 0 && I >= abs(J) ? s(2 * I - 1) + I + J :     // right region\n                J > 0 && J >= abs(I) ? s(2 * J - 1) + 3 * J - I : // top region\n                I < 0 && J >= I      ? s(-2 * I) - I - J + 1 :    // left region\n                                       s(-2 * J) + I - 3 * J + 3; // bottom region\n\n        v = mix(v = vec2(w) * .1 - .05,\n                          v * 4. + .15,\n                          clamp(float(m) / 6. - 16. + 18. * t - length(U - z) * .25, 0., 1.));\n                          \n        O += smoothstep(3. / R.y, 0.,\n                        length(max(v = abs(z - v) - .05, 0.)) +\n                               min(max(v.x,v.y), 0.));\n    }\n}\n/**/\n\n// Original: 797 chars\n/*\n#define R iResolution.xy\n\nint sqr(int x) { return x*x; }\n\n// from Ulam Spiral by elenzil\n// https://www.shadertoy.com/view/ssjBRm\nint ulam(int I, int J)\n{\n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J)) + 2;\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    return n;\n}\n\nvoid mainImage(out vec4 O, vec2 U )\n{\n    float t = fract(float(iFrame) / 500.);\n    U = exp(-t * 2.2) * ((U - .5 * R) / R.y) - t * .0011;\n    float f = .045;\n    vec2 u = mod(U + f, vec2(f + f)) - f;\n    vec2 d = U - u;\n    float o = length(d);\n    u *= 40.;\n    \n    O = vec4(0);\n    \n    for (float x = 0.; x < 5.; x++)\n    for (float y = 0.; y < 5.; y++)\n    {\n        vec2 v = vec2(x, y) * sign(u) + 4.;\n        int m = ulam(4 - int(v.x), 4 - int(v.y));\n\n        float a = v == vec2(4) ? 0. : clamp(float(m) / 6. - 16. + 18. * t - o * 10., 0., 1.);\n        v = (v - 4.5) * .1;\n        v = mix(v, v * 4. + .15, a);\n        vec2 e = abs(u - v)-.05;\n        float d = length(max(e,0.0)) + min(max(e.x,e.y),0.0);\n        O += smoothstep(3./R.y, 0., d);\n    }\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dd3fzN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1073, 1114, 1150, 1150, 2220]], "test": "untested"}
{"id": "DddBzM", "name": "Hinged Squares", "author": "fad", "description": "Hinged square tessellation with uv-mapping", "tags": ["grid", "texture", "uv", "animation", "square", "squares", "tesselation", "hinged"], "likes": 30, "viewed": 372, "published": 3, "date": "1696979717", "time_retrieved": "2024-07-30T17:29:14.274997", "image_code": "const float PI = 3.1415927;\n\nvoid mainImage(out vec4 O, vec2 I) {\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0 * I - R) / R.y * 8.0;\n    float t = 1.0 - abs(1.0 - mod(iTime / 2.0, 2.0));\n    float a = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, t)) * PI / 2.0;\n    float c = cos(a);\n    float s = sin(a);\n    float b = c + s;\n    vec2 d = mat2(c, s, -s, c) * asin(cos(p / b)) * b / PI;\n    vec2 q = PI * floor(p / PI / b);\n    vec2 uv = q + PI * (0.5 - d * cos(q));\n    uv = (uv / 8.0 * R.y + R) / 2.0 / R;\n    O = step(max(abs(d.x), abs(d.y)), 0.5) * texture(iChannel0, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DddBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 65, 65, 577]], "test": "untested"}
{"id": "ds3fzM", "name": "Crosshatch Dither Golf 2̶1̶1̶174", "author": "domrally", "description": "Experiment with cross hatching based on an ordered bayer dither sequence for each axis.\n[url=https://www.shadertoy.com/playlist/fX2cWm]PIXEL PLAYLIST[/url]", "tags": ["pixel", "dither", "cross", "hatching", "ordered", "golf"], "likes": 3, "viewed": 197, "published": 3, "date": "1696974233", "time_retrieved": "2024-07-30T17:29:15.526651", "image_code": "/*\n174 by SnoopethDuckDuck\n*/\nvoid mainImage(out vec4 o, vec2 i) {\n    float v = dot(\n        vec4(1.6, 5.6, .8, 0), \n        sqrt(texture(iChannel0, i / iResolution.xy))\n    );\n    \n    o = vec4(vec4(0,4,2,6)[int(i.x)%4] < v \n          && vec4(1,5,3,7)[int(i.y)%4] < v);\n}\n\n\n/*\n211 by domrally\n*\nvoid mainImage(out vec4 o, vec2 i)\n{  \n    // Get the gamma corrected luminance\n    float v = dot(\n        vec3(.2, .7, .1), \n        pow(texture(iChannel0, i / iResolution.xy).rgb, vec3(.5))\n    );\n    \n    // Tiling\n    ivec2 n = ivec2(mod(i, 4.));\n    \n    // Thresholds\n    mat2x4 t = mat2x4(\n        0, 4, 2, 6,\n        1, 5, 3, 7\n    ) / 8.;\n    \n    // Quantize pixel brightness on both axes\n    o = vec4(t[0][n.x] < v && t[1][n.y] < v);\n}\n*/\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ds3fzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 30, 66, 66, 273]], "test": "untested"}
{"id": "cdtBRM", "name": "OKLAB", "author": "Peace", "description": "OKLAB color space implementation", "tags": ["color", "lab", "colorspace", "ok", "oklab"], "likes": 2, "viewed": 262, "published": 3, "date": "1696973595", "time_retrieved": "2024-07-30T17:29:16.397323", "image_code": "const float PI  = 3.14159265358;\nconst float TAU = 6.28318530717;\n\n// lch = (lightness, chromaticity, hue)\nvec3 oklch2oklab(vec3 lch) {\n  return vec3(lch.x, lch.y * cos(lch.z * TAU), lch.y * sin(lch.z * TAU));\n}\n\n// oklab = (lightness, red_greenness, blue_yelowness)\nvec3 oklab2lrgb(vec3 oklab) {\n    vec3 lms = oklab * mat3(1,  0.3963377774,  0.2158037573,\n                            1, -0.1055613458, -0.0638541728,\n                            1, -0.0894841775, -1.2914855480);\n    lms *= lms * lms;\n    return lms * mat3( 4.0767416621, -3.3077115913,  0.2309699292, \n                      -1.2684380046,  2.6097574011, -0.3413193965, \n                      -0.0041960863, -0.7034186147,  1.7076147010);\n}\n\nvec3 lrgb2oklab(vec3 lrgb) {\n    vec3 lms = lrgb * mat3(0.4121656120, 0.5362752080, 0.0514575653,\n                           0.2118591070, 0.6807189584, 0.1074065790,\n                           0.0883097947, 0.2818474174, 0.6302613616);\n    return pow(lms, vec3(1.0 / 3.0)) * mat3(0.2104542553,  0.7936177850, -0.0040720468,\n                                            1.9779984951, -2.4285922050,  0.4505937099,\n                                            0.0259040371,  0.7827717662, -0.8086757660);\n}\n\nvec3 lrgb2rgb(vec3 x) {\n    vec3 xlo = 12.92 * x;\n    vec3 xhi = 1.055 * pow(x, vec3(1.0 / 2.4)) - 0.055;\n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n}\n\nvec3 rgb2lrgb(vec3 x) {\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055) / 1.055, vec3(2.4));\n    return mix(xlo, xhi, step(0.04045, x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float hue = uv.x;\n    vec3 ok = oklch2oklab(vec3(0.8, 0.2, hue));\n    vec3 col = oklab2lrgb(ok);\n    col = lrgb2rgb(col);\n    col = clamp(col, vec3(0), vec3(1));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdtBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 107, 135, 135, 211], [213, 267, 296, 296, 708], [710, 710, 738, 738, 1213], [1215, 1215, 1238, 1238, 1374], [1376, 1376, 1399, 1399, 1523], [1525, 1525, 1580, 1580, 1820]], "test": "untested"}
{"id": "dsdBR4", "name": "ilovelensdistortions", "author": "kwyntes", "description": "( turn off VFlip for images the lens distortion function flips the image for some reason idkk didn't write it )\nalso the code quality was pretty decent before i started to endlessly mess with it...\nshit happening before the transition is actually unwanted", "tags": ["lensdistortions"], "likes": 2, "viewed": 311, "published": 3, "date": "1696970578", "time_retrieved": "2024-07-30T17:29:17.153302", "image_code": "// adapted from https://www.shadertoy.com/view/4lSGRw\n\n#define PI 3.14159265358979\n\nfloat someBezierThing(float t /* [0, 1] */)\n{\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 2.0;\n    \n    float T = 1.0 - t;\n    \n    // a (1-t)^3 + 3b (1-t)^2 t + 3c (1-t) t^2 + d t^3 - 1\n    return a*T*T*T + 3.*b*T*T*t + 3.*c*T*t*t + d*t*t*t - 1.;\n}\n\nvec2 computeUV(vec2 uv, float k, float kcube, bool yes)\n{   \n    // temp, for debugging only\n    if (!yes) return uv;\n\n\n    vec2  t  = uv - 0.5;\n    float r2 = t.x * t.x + t.y * t.y;\n    \n    float f = 1.0 + r2 * (k + kcube * sqrt(r2));\n    \n    vec2  nUV = f * t + 0.5;\n    nUV.y = 1.0 - nUV.y;\n    \n    return nUV;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n \n    // Duration idea: pi/2 seconds   ** cos(4*pi/2)-1 = 0 which should be nice for this.\n    // TODO: make this configurable....\n \n \n    float t    = (PI/2.0)*(iMouse.x/iResolution.x); //iTime;\n    float tmod = mod(t, PI/2.0);\n    \n    // -- Lens distortion + chromatic abberation + zoom --\n\n    float intensity = 0.9;\n    bool doSIN = false; // makes it freeze a little bit (or bouncy for high intensities)\n                        // also limits the intensity of the effect a lot.\n\n    //float x      = intensity * (cos(4.0 * t) * tmod*tmod - 1.0);//someBezierThing(sin(iTime)) * 2.;\n    \n    \n    bool  doStupidWobble = false;\n    bool  doStupidMix    = true;\n    float mixval         = 0.7;\n    \n    \n    //float w = 1.8; // arbitrary, but lots of values don't work? see https://www.desmos.com/calculator/euovdhkgsw\n    float x = 0.9 * (doStupidWobble ? sin(4.0 * tmod) : cos(4.0 * tmod) - 1.0);\n    \n    if (doStupidMix)\n    {\n        x = 0.9 * mix(sin(4.0 * tmod), cos(4.0 * tmod) - 1.0, mixval);\n    }\n    \n    \n    \n    \n    \n    float k      = 1.0 * (doSIN ? sin(x * 0.9) : x);\n    float kcube  = 0.5 * (doSIN ? sin(x      ) : x);\n    float offset = 0.1 * (doSIN ? sin(x * 0.5) : x);\n    \n    // Zoom [TODO: in slightly, then out]\n    \n    // 1.31945... is approx. the y-value of the third peek of this function\n    //float theta /* greek letters make you sound smarter */ = -sin(6.0 * tmod) * tmod / 1.31945;\n    \n    // stupid piecewise thing i made up\n    float w = 1.8; // arbitrary, but lots of values don't work? see https://www.desmos.com/calculator/euovdhkgsw\n    float theta = tmod <= PI/6.0 ? -sin(6.0 * tmod) * tmod :\n                  tmod <= PI/3.0 ? pow(6.0/PI, w) * pow(tmod - PI/6.0, w) :\n                /*tmod <= PI/2.0*/ -pow(6.0/PI, 2.0) * pow(tmod - PI/2.0, 2.0);                                               //mix(pow(6.0/PI, w) * pow(tmod - PI/6.0, w),   -pow(6.0/PI, 2.0) * pow(tmod - PI/2.0, 2.0), sqrt(tmod/(PI/2.0)));\n    \n    \n    bool doZOOM = true;\n    \n    float zoom = pow(2.0, theta);//pow(2.0, (x+0.5)/4.);//pow(2.0, sin(t)); // This should go from 1.0 to <...> to 2.0 to 1.0\n    uv = doZOOM ? (uv - 0.5) * zoom + 0.5 : uv;\n    \n    \n    // Offset each colour seperately to achieve the chromatic abberation effect\n    bool doLD = true;\n    bool doCHROMABB = true;\n    \n    float r, g, b;\n    \n    // why is there no nicer way to do this .........\n    if (tmod <= PI/3.0) {\n        r = texture(iChannel0, computeUV(uv, k + (doCHROMABB ? offset : 0.0), kcube, doLD)).r; \n        g = texture(iChannel0, computeUV(uv, k                              , kcube, doLD)).g; \n        b = texture(iChannel0, computeUV(uv, k - (doCHROMABB ? offset : 0.0), kcube, doLD)).b;\n    } else {\n        r = texture(iChannel1, computeUV(uv, k + (doCHROMABB ? offset : 0.0), kcube, doLD)).r; \n        g = texture(iChannel1, computeUV(uv, k                              , kcube, doLD)).g; \n        b = texture(iChannel1, computeUV(uv, k - (doCHROMABB ? offset : 0.0), kcube, doLD)).b;\n    }\n    \n    fragColor = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsdBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 129, 129, 360], [362, 362, 419, 454, 680], [682, 682, 737, 737, 3833]], "test": "untested"}
{"id": "csSfDh", "name": "gradient hearts", "author": "The_Snek12", "description": "hearts<3", "tags": ["2d"], "likes": 1, "viewed": 151, "published": 3, "date": "1696969153", "time_retrieved": "2024-07-30T17:29:18.014998", "image_code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(1.168, -0.552, 0.618); \n    vec3 b = vec3(-0.719, 0.597, 0.234);\n    vec3 c = vec3(0.350, 0.350, 0.350);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y += 0.6;\n    vec3 color = vec3(0.);\n    \n    for(int i = 0; i < 2; i++){\n        float dist = sdHeart(uv)+ float(i);\n    \n        dist= abs(cos(dist*8.+iTime)/8.)*0.5;\n        dist+= smoothstep(0.2,3., sdHeart(uv));\n        \n        color += 0.03/length(uv-vec2(0.0,0.6)+vec2(2,1.5))*palette(length(uv)*float(i));\n        color += 0.03/length(uv-vec2(0.0,0.6)+vec2(2,-1.5))*palette(length(uv)*float(i));\n        color += 0.03/length(uv-vec2(0.0,0.6)+vec2(-2,1.5))*palette(length(uv)*float(i));\n        color += 0.03/length(uv-vec2(0.0,0.6)+vec2(-2,-1.5))*palette(length(uv)*float(i));\n        color += 0.02/smoothstep(0.,0.1,dist) * palette(length(uv)*float(i));\n    }\n    \n    \n    fragColor = vec4(color,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csSfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 44], [45, 45, 73, 73, 293], [295, 295, 322, 322, 528], [530, 530, 587, 587, 1401]], "test": "untested"}
{"id": "ddcfzM", "name": "2d waves grid (rainbow!!)", "author": "The_Snek12", "description": "it rainbow now!", "tags": ["2d"], "likes": 3, "viewed": 175, "published": 3, "date": "1696967217", "time_retrieved": "2024-07-30T17:29:18.771974", "image_code": "#define EPSILON 0.01\n#define RED vec3(1, 0,0)\nfloat circle(vec2 uv, vec2 pos, float r){\n    return smoothstep(r+EPSILON, r, length(uv+pos));\n}\nvec2 getpos(vec2 id, vec2 offset){\n    \n    return vec2( cos((iTime+offset.x+id.x)*2.))/2.+offset;\n    //return vec2(cos(iTime*(offset.x+id.x)), sin(iTime*(offset.y+id.y)))/2.+offset;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return smoothstep(.05 , 0.04,length( pa - ba*h ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*10.-5.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0);\n   //col += sdSegment(localuv, vec2(1,-1)/2., vec2(1,1)/2.) * vec3(1,0,0);\n   //col += sdSegment(localuv, vec2(-1,1)/2., vec2(1,1)/2.)* vec3(1,0,0);\n       \n    \n    \n    \n    for(float depth = 10.; depth>1.; depth--){\n       \n        \n        \n        \n        vec2 id = floor(uv);\n        \n        \n        vec2 localuv = fract(uv)-.5;\n        \n        vec2 p[9];\n        \n        \n        int i = 0;\n        \n        \n        for(int x = -1; x < 2; x+=1){\n           for(int y = -1; y < 2; y+=1){\n               p[i++] = getpos(id, vec2(x,y));\n               \n               \n           }\n        }\n        \n        vec3 segColor = 0.5 + 0.5*cos(iTime+(uv.xyx/4.)+vec3(0,2,4));\n        \n        for (i=0; i<9; i++){\n            col += circle(localuv, -p[i], 0.10) * vec3(1,1,1);\n            col += sdSegment(localuv, p[4], p[i]) * segColor;\n        \n        }\n        col += sdSegment(localuv, p[1], p[3])* segColor;\n        col += sdSegment(localuv, p[1], p[5])* segColor;\n        col += sdSegment(localuv, p[3], p[7])* segColor;\n        col += sdSegment(localuv, p[5], p[7])* segColor;\n        col *=1.5/depth;\n        uv /= 1.1;\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 87, 87, 142], [143, 143, 177, 177, 328], [330, 330, 382, 382, 524], [525, 525, 582, 632, 1959]], "test": "untested"}
{"id": "cd3Bz7", "name": "Analytic 2D Circle Occlusion", "author": "me_123", "description": "Ambient occlusion of circles", "tags": ["2d", "2d", "circle", "occlusion", "analytic", "exact"], "likes": 1, "viewed": 192, "published": 3, "date": "1696958452", "time_retrieved": "2024-07-30T17:29:19.688523", "image_code": "#define PI 3.1415926\n#define PI2 6.28318531\nvec2 getAO(in vec2 p, in float r) {\n    float disc = dot(p, p)-r*r;\n    if (disc < 0.0) return vec2(0, 2.0*PI);\n    float a = atan(r/sqrt(disc));\n    float b = atan(p.x, p.y)+PI;\n    return vec2(b-a, b+a);\n}\nconst int count = 50;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.5*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 t = getAO(uv, 0.5);\n    vec2 x[count*4];\n    int n = 0;\n    fragColor = vec4(0);\n    for (int i = 0; i < count; i += 1) {\n        float theta = 2.0*PI*(float(i)/float(count));\n        vec3 pos = vec3(vec2(sin(theta), cos(theta*1.5))*0.5, 0.04);\n        //if (i == 0) pos = vec3(2.0*(iMouse.xy-iResolution.xy*0.5)/iResolution.y, 0.4);\n        vec2 ao = getAO(uv-pos.xy, pos.z);\n        x[n++] = vec2(max(ao.x, 0.0), 1); //start\n        x[n++] = vec2(min(ao.y, PI2), -1); //end\n        if (ao.x < 0.0) {\n            x[n++] = vec2(ao.x+PI2, 1) ;\n            x[n++] = vec2(PI2, -1);\n        }\n        if (ao.y > PI2) {\n            x[n++] = vec2(0, 1);\n            x[n++] = vec2(ao.y-PI2, -1);\n        }\n    }\n    vec2 tmp;\n    for (int r = 0; r < n; r += 1) {\n        bool swaped = false;\n        for (int m = 0; m < n-1; m += 1) {\n            if (x[m].x > x[m+1].x) {\n                tmp = x[m];\n                x[m] = x[m+1];\n                x[m+1] = tmp;\n                swaped = true;\n            }\n        }\n        if (!swaped) break;\n    }\n    int state = 0;\n    float k = 0.0;\n    float occ = 0.0;\n    bool set = true;\n    for (int i = 0; i < n; i += 1) {\n        state += int(x[i].y);\n        if (state == 1 && set) {\n            k = x[i].x;\n            set = false;\n        }\n        if (state == 0) {\n            occ += x[i].x-k;\n            set = true;\n        }\n    }\n    vec3 col = 1.-vec3(occ)/PI2;\n    fragColor += vec4(sqrt(col), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cd3Bz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 79, 79, 251]], "test": "untested"}
{"id": "DdGyWy", "name": "2d waves grid", "author": "The_Snek12", "description": ":)", "tags": ["2d"], "likes": 2, "viewed": 124, "published": 3, "date": "1696954919", "time_retrieved": "2024-07-30T17:29:20.615046", "image_code": "#define EPSILON 0.01\n#define RED vec3(1, 0,0)\nfloat circle(vec2 uv, vec2 pos, float r){\n    return smoothstep(r+EPSILON, r, length(uv+pos));\n}\nvec2 getpos(vec2 id, vec2 offset){\n    \n    return vec2( cos((iTime+offset.x+id.x)*2.))/2.+offset;\n    //return vec2(cos(iTime*(offset.x+id.x)), sin(iTime*(offset.y+id.y)))/2.+offset;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return smoothstep(.05 , 0.04,length( pa - ba*h ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*10.-5.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0);\n   //col += sdSegment(localuv, vec2(1,-1)/2., vec2(1,1)/2.) * vec3(1,0,0);\n   //col += sdSegment(localuv, vec2(-1,1)/2., vec2(1,1)/2.)* vec3(1,0,0);\n       \n    \n    \n    \n    for(float depth = 10.; depth>1.; depth--){\n       \n        \n        \n        \n        vec2 id = floor(uv);\n        \n        \n        vec2 localuv = fract(uv)-.5;\n        \n        vec2 p[9];\n        \n        \n        int i = 0;\n        \n        \n        for(int x = -1; x < 2; x+=1){\n           for(int y = -1; y < 2; y+=1){\n               p[i++] = getpos(id, vec2(x,y));\n               \n               \n           }\n        }\n        \n        for (i=0; i<9; i++){\n            col += circle(localuv, -p[i], 0.10) * vec3(0,1,1);\n            col += sdSegment(localuv, p[4], p[i]) * vec3(0,0,1);\n        \n        }\n        col += sdSegment(localuv, p[1], p[3])* vec3(0,0,1);\n        col += sdSegment(localuv, p[1], p[5])* vec3(0,0,1);\n        col += sdSegment(localuv, p[3], p[7])* vec3(0,0,1);\n        col += sdSegment(localuv, p[5], p[7])* vec3(0,0,1);\n        col *=1.5/depth;\n        uv /= 1.1;\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 87, 87, 142], [143, 143, 177, 177, 328], [330, 330, 382, 382, 524], [525, 525, 582, 632, 1895]], "test": "untested"}
{"id": "msdBR8", "name": "Tiny Lighthouse", "author": "Lewie4", "description": "A little scene lighthouse inspired by Just Passing Icon - Jonathan Quintin\nhttps://www.behance.net/gallery/11242115/The-Big-Wide-World", "tags": ["2d", "sea", "sdf", "water", "loop", "boat", "reproduction"], "likes": 30, "viewed": 311, "published": 3, "date": "1696950780", "time_retrieved": "2024-07-30T17:29:21.491702", "image_code": "// SDFs: https://iquilezles.org/articles/distfunctions2d/\n// Inspiration: Just Passing Icon - Jonathan Quintin\n#define PI 3.14159265359\n\nfloat sdCircle(vec2 p, float r)\n{\n    return (length(p) - r);\n}\n\nfloat sdBox(vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTrapezoid( in vec2 p, in float ra, float rb, float he)\n{\n    float sy = (p.y<0.0)?-1.0:1.0;\n\n    p.x = abs(p.x);\n\n    vec4 res;\n    \n    // bottom and top edges\n    {\n        float h = min(p.x,(p.y<0.0)?ra:rb);\n        vec2  c = vec2(h,sy*he);\n        vec2  q = p - c;\n        float d = dot(q,q);\n        float s = abs(p.y) - he;\n        res = vec4(d,q,s);\n    }\n    \n    // side edge\n    {\n        vec2  k = vec2(rb-ra,2.0*he);\n        vec2  w = p - vec2(ra, -he);\n        float h = clamp(dot(w,k)/dot(k,k),0.0,1.0);\n        vec2  c = vec2(ra,-he) + h*k;\n        vec2  q = p - c;\n        float d = dot(q,q);\n        float s = w.x*k.y - w.y*k.x;\n        if( d<res.x ) { res.xyz = vec3(d,q); }\n        if( s>res.w ) { res.w = s; }\n    }\n   \n    // distance and sign\n    float d = sqrt(res.x)*sign(res.w);\n    \n    return d;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 lighthouse(vec2 p)\n{\n    vec3 red = vec3(.839,.318,.188);\n    vec3 dred = vec3(.45,.133,.1);\n    \n    float shape = sdTrapezoid(p+vec2(0.,.1), .25, .15, .4);    \n    shape = smoothstep(.02,.0, shape);\n    vec4 col = vec4(shape * mix(red, vec3(1.), smoothstep(-.01, .01,fract((p.y+.1)* 2.4)*2.-1.)), shape);\n\n    shape = sdBox(p+vec2(0.,-.42), vec2(.15,.1));\n    shape = smoothstep(.01,.0, shape);\n    col = vec4(mix(col.xyz, vec3(.4,.77,.82), shape), max(col.w, shape * .5));\n\n    shape = abs(sdBox(p+vec2(0.,-.42), vec2(.15,.1)));\n    shape = min(shape,sdBox(p+vec2(0.,-.31), vec2(.225,.01)));\n    shape = min(shape,sdBox(p+vec2(0.,-.42), vec2(.15,.001)));\n    shape = min(shape,sdBox(p+vec2(.05,-.42), vec2(.001,.1)));\n    shape = min(shape,sdBox(p+vec2(-.05,-.42), vec2(.001,.1)));\n    shape = min(shape,sdTriangle(p+vec2(.0,-.52), vec2(0.,.2), vec2(.2,0.),vec2(-.2,0.)));\n    shape = smoothstep(.01, .0, shape);\n    col = vec4(mix(col.xyz, red, shape), max(col.w, shape));\n\n    shape = sdBox(p+vec2(0.,-.29), vec2(.225,.005));\n    shape = min(shape, sdCircle(p + vec2(0.,.1), .04));\n    shape = min(shape, sdCircle(p + vec2(0.,-.1), .04));\n    shape = min(shape, sdCircle(p + vec2(0.,.35), .08));\n    shape = min(shape, sdBox(p+vec2(0.,.435), vec2(.08,.07)));    \n    shape = smoothstep(.01, .0, shape);    \n    col = vec4(mix(col.xyz, dred, shape), max(col.w, shape));\n\n    col.xyz = col.xyz - smoothstep(-.01, .01, p.x) *.2;        // Shadow    \n    return col;\n}\n\nvec4 ice1(vec2 p)\n{\n    vec3 ice = vec3(.871,.871,.906);\n    vec3 dice = vec3(.686,.784,.847);\n    \n    float shape = sdTriangle(p + vec2(.18,.0), vec2(0.,.2), vec2(.15,0.), vec2(-.15,0.));\n    shape = min(shape,sdTriangle(p + vec2(.0,.0), vec2(0.,.25), vec2(.15,0.), vec2(-.3,0.)));\n    shape = min(shape,sdTriangle(p + vec2(-.14,.0), vec2(0.,.2), vec2(.15,0.), vec2(-.15,0.)));\n    shape = smoothstep(.01, .0, shape);\n    \n    vec4 col = vec4(mix(vec3(1.), ice, shape), shape);\n\n    shape = sdTriangle(p + vec2(.18,.0), vec2(.0,.2), vec2(.15,0.), vec2(-.02,0.));\n    shape = min(shape,sdTriangle(p + vec2(.18,.0), vec2(0.,.1), vec2(.35,0.), vec2(-.0,0.)));\n    shape = min(shape,sdTriangle(p + vec2(.0,.0), vec2(0.,.25), vec2(.15,0.), vec2(-.0,0.)));\n    shape = min(shape,sdTriangle(p + vec2(-.14,.0), vec2(0.,.2), vec2(.15,0.), vec2(-.0,0.)));    \n    shape = smoothstep(.01, .0, shape);\n\n    col = vec4(mix(col.xyz, dice, shape), max(col.w,shape));\n\n    return col;\n}\n\nvec4 ice2(vec2 p)\n{\n    vec3 ice = vec3(.871,.871,.906);\n    vec3 dice = vec3(.686,.784,.847);\n    \n    float shape = sdTriangle(p + vec2(-.04,.0), vec2(0.,.12), vec2(.06,0.), vec2(-.1,0.));\n    shape = min(shape,sdTriangle(p + vec2(.05,.0), vec2(0.,.09), vec2(.1,0.), vec2(-.05,0.)));\n    shape = smoothstep(.01, .0, shape);\n    \n    vec4 col = vec4(mix(vec3(1.), ice, shape), shape);\n\n    shape = sdTriangle(p + vec2(-.04,.0), vec2(.0,.12), vec2(.06,0.), vec2(-.0,0.));\n    shape = min(shape,sdTriangle(p + vec2(.05,.0), vec2(0.,.09), vec2(.1,0.), vec2(-.0,0.)));\n    shape = smoothstep(.01, .0, shape);\n\n    col = vec4(mix(col.xyz, dice, shape), max(col.w,shape));\n\n    return col;\n}\n\nvec4 ice3(vec2 p)\n{\n    vec3 ice = vec3(.871,.871,.906);\n    vec3 dice = vec3(.686,.784,.847);\n    \n    float shape = sdTriangle(p + vec2(-.02,.0), vec2(0.,.08), vec2(.05,0.), vec2(-.05,0.));\n    shape = min(shape,sdTriangle(p + vec2(.02,.0), vec2(0.,.05), vec2(.03,0.), vec2(-.03,0.)));\n    shape = smoothstep(.01, .0, shape);\n    \n    vec4 col = vec4(mix(vec3(1.), ice, shape), shape);\n\n    shape = sdTriangle(p + vec2(-.02,.0), vec2(.0,.08), vec2(.05,0.), vec2(-.0,0.));\n    shape = min(shape,sdTriangle(p + vec2(.02,.0), vec2(0.,.05), vec2(.03,0.), vec2(-.0,0.)));\n    shape = smoothstep(.01, .0, shape);\n\n    col = vec4(mix(col.xyz, dice, shape), max(col.w,shape));\n\n    return col;\n}\n\nvec4 boat(vec2 p)\n{\n    vec3 white = vec3(.98,.98,.945);\n    vec3 dwhite = vec3(.929,.902,.859);\n    vec3 yel = vec3(1.,.725,.063);\n    vec3 dyel = vec3(.871,.529,.075);\n    vec3 brown = vec3(.278, .165, .122);\n\n    float shape = sdTriangle(p + vec2(.05,.05), vec2(0.,.15), vec2(.14,.02), vec2(-.14,.02));\n    shape = min(shape,sdBox(p + vec2(.0,-.05), vec2(.05,.05)));\n    shape = smoothstep(.01, .0, shape);\n    \n    vec4 col = vec4(mix(vec3(.5), white, shape), shape);\n    \n    shape = sdBox(p + vec2(-.045,-.02), vec2(.03,.08));\n    shape = min(shape,sdBox(p + vec2(-.11,.005), vec2(.08,.035)));\n    shape = smoothstep(.01, .0, shape);\n    \n    col = vec4(mix(col.xyz, dwhite, shape), max(col.w,shape));\n\n    shape = sdTriangle(p + vec2(.18,.0), vec2(0.,-.15), vec2(.14,.02), vec2(-.14,.02));\n    shape = min(shape,sdTriangle(p + vec2(.04,.0), vec2(0.,.02), vec2(.14,-.15), vec2(-.14,-.15)));\n    shape = min(shape,sdBox(p + vec2(-.121,-.076), vec2(.022,.075)));\n    shape = smoothstep(.01, .0, shape);\n    \n    col = vec4(mix(col.xyz, yel, shape), max(col.w,shape));\n\n    shape = sdTriangle(p + vec2(.18,.0), vec2(0.,-.155), vec2(.14,-.05), vec2(-.085,-.05));\n    shape = min(shape,sdTriangle(p + vec2(-.23,.0), vec2(0.,-.155), vec2(.03,-.05), vec2(-.13,-.05)));\n    shape = min(shape,sdBox(p + vec2(-.025,.1025), vec2(.2,.053)));\n    shape = smoothstep(.01, .0, shape);\n    \n    col = vec4(mix(col.xyz, dyel, shape), max(col.w,shape));\n\n    shape = sdSegment(p, vec2(-.055,.105), vec2(.08,.105));\n    shape = min(shape,sdSegment(p, vec2(.095,.085), vec2(.146,.085)));\n    shape = min(shape,sdSegment(p, vec2(.095,.075), vec2(.146,.075)));\n    shape = min(shape,sdBox(p + vec2(.025,-.06), vec2(.012,.025)));\n    shape = min(shape,sdBox(p + vec2(-.015,-.06), vec2(.012,.025)));\n    shape = min(shape,sdBox(p + vec2(-.055,-.06), vec2(.012,.025)));\n    shape = min(shape,sdSegment(p, vec2(.015,-.04), vec2(.075,-.04)) - .005);\n    shape = min(shape,sdSegment(p, vec2(.105,-.04), vec2(.165,-.04)) - .005);\n    shape = min(shape,sdSegment(p, vec2(.195,-.04), vec2(.255,-.04)) - .005);\n    shape = min(shape,sdSegment(p, vec2(-.24,-.085), vec2(.125,-.085)) - .002);\n    shape = min(shape,sdCircle(p+ vec2(.1,.02), .005)); \n    shape = min(shape,abs(sdCircle(p+ vec2(.1,.04), .02) - .003));\n    shape = min(shape,sdCircle(p+ vec2(.21,.02), .005)); \n    shape = min(shape,abs(sdCircle(p+ vec2(.21,.04), .02) - .003));  \n    shape = smoothstep(.01, .0, shape);    \n    col = vec4(mix(col.xyz, brown, shape), max(col.w,shape));\n    \n    return col;\n}\n\nvec4 cloud(vec2 p)\n{\n    vec3 cloud = vec3(.718,.863,.906);\n\n    p *= vec2(1., 1.5);\n    \n    float shape = sdCircle(p+ vec2(.1,.0), .4);\n    shape = min(shape,sdCircle(p + vec2(.4,.1), .3));\n    shape = min(shape,sdCircle(p + vec2(-.2,.05), .35));\n    shape = min(shape,sdCircle(p + vec2(-.4,.1), .3));\n    shape = smoothstep(.2, .0, shape);\n    \n    vec4 col = vec4(mix(vec3(0.9), cloud, shape), shape);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor -= fragColor;\n    fragCoord = (fragCoord+fragCoord-iResolution.xy)/iResolution.y;\n    float duration = .1;\n    float time = iTime + 5.;\n    \n    float center = smoothstep(-.001, .001, fragCoord.y);\n    vec4 sky = mix(vec4(.969, 1., .969,1.), vec4(.737, .804,.8,1.), length(fragCoord));\n    vec4 water = mix(vec4(.094,.286,.286,1.), vec4(.063,.063,.125,1.), pow(length(fragCoord + vec2(.3,0.)), .5));\n    vec4 image = mix(water, sky, center);    \n    \n    float prog = fract(time * duration);\n    vec4 item = cloud((fragCoord + vec2(mix(.2, -.2, prog),-.2)) * 10.);\n    image = mix(image, item, item.w);\n\n    item = cloud((fragCoord + vec2(mix(.6, .2, prog),-.4)) * 10.);\n    image = mix(image, item, item.w);\n\n    item = cloud((fragCoord + vec2(mix(-.2, -.6, prog),-.5)) * 10.);\n    image = mix(image, item, item.w);\n\n    item = ice1(fragCoord + vec2(-.28,-.002));\n    image = mix(image, item, item.w * center);\n\n    item = ice2(fragCoord + vec2(.6,.01));\n    image = mix(image, item, item.w);\n    \n    vec2 lhuv = (fragCoord + vec2(.3,-.169)) * 3.;\n    item = lighthouse(lhuv);\n    image = mix(image, item, item.w * center);\n    \n    item = ice3(fragCoord + vec2(.2,.03));\n    image = mix(image, item, item.w);\n\n    prog = smoothstep(0.,1.,fract(time*duration));\n    vec2 boatuv = mix(fragCoord + vec2(-1.1,.0), fragCoord + vec2(1.1,.0), prog);\n    boatuv.y += sin(time*4.) * .01;\n    vec2 wuv = (fragCoord+vec2(-time*.2,.15)) * 4.;\n    wuv.y *= 2.;\n    float wave = wuv.y - pow(2.*abs(wuv.x-(floor(wuv.x+.5))),2.) * .5;\n    item = boat(boatuv);\n    image = mix(image, item, item.w * smoothstep(0.,.05, wave));\n\n    prog = smoothstep(0.,1.,abs(sin(time*PI*.1)) * 2.);\n    float mask = smoothstep(.01, .0,sdCircle(fragCoord, .75*prog));\n    float shadow = smoothstep(.05, .0,sdCircle(fragCoord+vec2(-.05,.05), .75*prog));\n    fragColor = vec4(.941,.945,.933,1.);\n    fragColor = mix(fragColor, image, mask);\n    fragColor -= (shadow - mask) * .25;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msdBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 170, 170, 200], [202, 202, 232, 232, 312], [314, 314, 378, 378, 1146], [1148, 1148, 1215, 1215, 1780], [1782, 1782, 1834, 1834, 1953], [1955, 1955, 1980, 1980, 3429], [3431, 3431, 3450, 3450, 4403], [4405, 4405, 4424, 4424, 5091], [5093, 5093, 5112, 5112, 5782], [5784, 5784, 5803, 5803, 8329], [8331, 8331, 8351, 8351, 8754], [8756, 8756, 8811, 8811, 10779]], "test": "untested"}
{"id": "Dd3fRM", "name": "Cursed Camera", "author": "feldgendler", "description": "Randomly replaces colors.", "tags": ["color", "webcam"], "likes": 1, "viewed": 228, "published": 3, "date": "1696949347", "time_retrieved": "2024-07-30T17:29:22.338438", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = vec2(1.0-fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    vec4 c = texture(iChannel0, pos);\n    switch (int(iTime)/5%6) {\n    case 0: fragColor = c.grba; break;\n    case 1: fragColor = c.gbra; break;\n    case 2: fragColor = c.rbga; break;\n    case 3: fragColor = c.brga; break;\n    case 4: fragColor = c.bgra; break;\n    case 5: fragColor = c.rgba; break;\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dd3fRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 446]], "test": "untested"}
{"id": "msS3DD", "name": "Infinite Rolodex", "author": "mla", "description": "A nice way to map the entire Euclidean plane to the unit circle. Useful for filing an infinite amount of data.\n\nControls: up/down,mouse,m,r,t,x. See code for details.", "tags": ["mapping", "stereographic", "gnomonic", "rolodex"], "likes": 6, "viewed": 207, "published": 3, "date": "1696933937", "time_retrieved": "2024-07-30T17:29:23.227062", "image_code": "////////////////////////////////////////////////////////////////\n//\n// Infinite Rolodex. mla, 2023\n//\n// Map unit circle to plane with mapping z -> z/(1-|z|²),\n// geometrically this is like doing a stereographic projection\n// from the circle to a hemisphere, then a gnomonic\n// projection from the hemisphere to the entire plane.\n//\n// The plane is divided into cells, each containing mysterious\n// images & writing, every one different, at least up to the\n// limitations of the hash function.\n//\n// <mouse> to scroll\n// <up/down> to zoom in and out\n// 'm': mouse selection\n// 'r': y-rotation\n// 't': use tan map\n// 'x': transform\n//\n////////////////////////////////////////////////////////////////\n\nint textchar(ivec2 cindex, ivec2 ix) {\n  uint h = ihash(ivec4(cindex,ix));\n  return int(256.0*hfloat(h));\n}\n\nfloat text(vec2 pos, ivec2 ix) {\n  vec4 metrics = vec4(0.25,0.75,0,1);\n  float cwidth = metrics.y-metrics.x;\n  float cheight = metrics.w-metrics.z;\n  float ar = cheight/cwidth;\n  int nrows = 10; \n  int ncols = int(float(nrows)*ar);\n  // Grid structure\n  vec2 cellsize = 1.0/vec2(ncols,nrows);\n  ivec2 cellindex = ivec2(pos/cellsize);\n  cellindex.y = nrows-cellindex.y-1; // Reverse order of rows\n  int c = textchar(cellindex,ix);\n  if (c < 0) return 0.0;\n  vec2 p = mod(pos,cellsize)/cellsize.y;\n  vec2 dx = dFdx(pos), dy = dFdy(pos);\n  // Draw the character\n  int charpos = int(p.x/cwidth);\n  float charstart = cwidth*float(charpos); // character start\n  vec2 uv = char(vec2(p.x-charstart+metrics.x,p.y),c);\n  return textureGrad(iChannel1,uv,dx/16.0,dy/16.0).x;  \n}\n\nvec3 pcolor(vec2 pos, vec2 mpos) {\n  vec3 col = vec3(0,0,0.1);\n  float scale = exp(0.1*(float(keycount(KEY_DOWN)-keycount(KEY_UP))));\n  if (!key(CHAR_X)) {\n    if (length(pos) > 1.0) return col;\n    if (!key(CHAR_T)) {\n      // Inverse stereographic followed by gnomonic projection.\n      pos /= 1.0-dot(pos,pos);\n    } else {\n      float t = tan(0.5*PI*length(pos));\n      pos *= t/length(pos);\n    }\n    if (dot(mpos,mpos) < 1.0) {\n      mpos /= 1.0-dot(mpos,mpos);\n    }\n  }\n  pos *= scale;\n  if (!key(CHAR_M)) pos -= mpos;\n  //pos *= scale;\n  if (!key(CHAR_R) && iMouse.z <= 0.0) pos.y += 10.0*iTime;\n  ivec2 ix = ivec2(floor(pos));\n  pos = fract(pos);\n  col = texture(iChannel0,pos).xyz;\n  col *= 1.2;\n  col = pow(col,vec3(2.2));\n  col *= 0.5+0.5*h2rgb(rand(ix));\n  col = mix(col,vec3(0),text(pos,ix));\n  float d = min(pos.x,pos.y);\n  float px = fwidth(pos.x);\n  float py = fwidth(pos.y);\n  pos = fract(pos);\n  pos = min(pos,1.0-pos);\n  col *= 0.25+0.75*smoothstep(0.0,0.05,min(pos.x,pos.y));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 mpos = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  float AA = 2.0;\n  vec3 aacol = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 pos = ((2.0*(fragCoord+vec2(i,j)/AA))-iResolution.xy)/iResolution.y;\n      aacol += pcolor(pos,mpos);\n    }\n  }\n  aacol /= AA*AA;\n  aacol = pow(aacol,vec3(0.4545));\n  fragColor = vec4(aacol,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.141592654;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint ihash(ivec4 t) {\n  uint h = 0u;\n  // Need a better 4->1 hash\n  h = ihash(h^uint(t.x));\n  h = ihash(h^uint(t.y));\n  h = ihash(h^uint(t.z));\n  h = ihash(h^uint(t.w));\n  return h;\n}\n\nfloat hfloat(uint h) {\n  return float(h)/exp2(32.0);\n}\n\nfloat rand(ivec2 ix) {\n uint h = ihash(uint(ix.x));\n h = ihash(h^uint(ix.y));\n return hfloat(h);\n}\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msS3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[701, 701, 739, 739, 808], [810, 810, 842, 842, 1576], [2593, 2593, 2650, 2650, 3037]], "test": "untested"}
{"id": "DddfzN", "name": "HYPERPLAID", "author": "ENDESGA", "description": "anti-aliased checkerboard and grid lines.\nnot sure if this is the best implementation or not", "tags": ["grid", "checkerboard", "inversion", "plaid"], "likes": 4, "viewed": 168, "published": 3, "date": "1696931329", "time_retrieved": "2024-07-30T17:29:24.022935", "image_code": "float checker(vec2 pos){\n    vec2 checker = mod(floor(pos), 2.0);\n    vec2 dist = min(fract(pos), 1.0 - fract(pos));\n    return mix(\n        1.0,\n        checker.x + checker.y,\n        smoothstep(0.0, fwidth(length(pos)), min(dist.x, dist.y))\n    );\n}\n\nfloat liner(vec2 pos){\n    vec2 grid = abs(fract(pos - 0.25) - 0.25) / fwidth(length(pos));\n    return 1.-clamp(min(grid.x, grid.y), 0., 1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 I ){\n    vec2 uv = (2.0*I-iResolution.xy)/min(iResolution.x, iResolution.y);\n    uv = (uv/dot(uv,uv)) * (5.+(sin(iTime*.5)*4.5));\n    float l = checker(uv);\n    O = vec4(vec3(l)*vec3(.5,0,.125), 1.0);\n    O += liner(uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DddfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 251], [253, 253, 275, 275, 396], [398, 398, 438, 438, 656]], "test": "untested"}
{"id": "dscfRN", "name": "Rotate in Spherical projection", "author": "o0CHT0o", "description": "Rotate the sphere by mat3", "tags": ["3d", "mouse", "rotate"], "likes": 2, "viewed": 173, "published": 3, "date": "1696924308", "time_retrieved": "2024-07-30T17:29:24.951452", "image_code": "vec4 textxy(vec2 uv){\n    vec3 xyz = GETR1*vu2xyz(uv);\n    return TEXT0(vec2(atan(xyz.y,xyz.x)/pi/2.+.75,asin(xyz.z)/pi+.5));\n}\n\nvoid mainImage( out vec4 Clr, in vec2 Crd ){\n    // Normalized pixel coordinates\n    float sc = min(iResolution.x, iResolution.y);\n    vec2 uv = (Crd*2.-iResolution.xy)/sc;\n\n    // Output to screen\n    Clr = (smoothstep(1., 1.-3./sc, length(uv))/2.+.5) * textxy(uv);\n    Clr = (smoothstep(0., 3./sc, abs(length(uv)-D))/2.+.5) * textxy(uv);\n    //Clr = vec4(vu2xyz(uv),1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 Clr, in vec2 Crd ){\n    vec2 uv = Crd/iResolution.xy-0.5;\n    Clr = vec4(cos(uv.x*pi*2.)*cos(uv.y*pi),\n               sin(uv.x*pi*2.)*cos(uv.y*pi),\n               sin(uv.y*pi),\n               1.0)/2.+.5;\n}", "buffer_a_inputs": [], "common_code": "#define TEXT0(x) texture(iChannel0, vec2(x))\n\n\n#define R1X int(iChannelResolution[1].x)\n#define XY2ID(X) (int(X.y) * R1X + int(X.x))\n#define ID2XY(I) ivec2(I - I / R1X * R1X, I / R1X)\n#define GET1(I) texelFetch(iChannel1, ID2XY(I), 0)\n#define GETR1 mat3(GET1(1).xyz, GET1(2).xyz, GET1(3).xyz)\n\nconst float pi = 4. * atan(1.), D=.9;\n\nvec3 vu2xyz(vec2 uv){\n    float l = length(uv), t = 2. * atan(l / D);\n    return vec3(uv/l*sin(t),-cos(t));\n}", "buffer_b_code": "// reference https://www.shadertoy.com/view/Mss3zH\n#define P_NUM 4\n#define TXTF1(x) texelFetch(iChannel1, ivec2(x), 0)\n\nmat3 rotate(vec3 v1, vec3 v2){\n    if(v1==v2) return mat3(1.);\n    float c = dot(v1, v2);\n    vec3 A = cross(v1, v2);\n    mat3 B = mat3(   0, -A.z,  A.y,\n                   A.z,    0, -A.x,\n                  -A.y,  A.x,    0);\n    A = normalize(A);\n    return mat3(c) + (1.-c) * outerProduct(A, A) + B;\n}\n\nvoid mainImage( out vec4 Clr, in vec2 Crd ){\n\n    int id = XY2ID(Crd);\n    if( id>=P_NUM ) {Clr=vec4(0); return;}\n    \n    if( iFrame==0 && id!=0){\n        Clr = vec4(mat3(1)[id-1],1);\n        return;\n    }\n    \n    vec4 m = iMouse;\n    if( m.z<0.0 ) {Clr = TXTF1(Crd); return;}\n    \n    float sc = min(iResolution.x, iResolution.y);\n    vec3 xyz = vu2xyz((m.xy*2.-iResolution.xy)/sc);\n    if( id==0 ){    \n        Clr = vec4(xyz,1);\n        return;\n    }\n    if( m.w>0.0 ) {Clr = TXTF1(Crd); return;}\n    mat3 MR = GETR1*rotate(GET1(0).xyz, xyz);\n    Clr = vec4(MR[id-1],1);\n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 127], [129, 129, 173, 209, 503]], "test": "untested"}
{"id": "msKcWG", "name": "Asthetic clouds", "author": "El_Sargo", "description": "Trying to make some nice clouds, use the mouse to control the sun. Turn on half res render in common if to slow.", "tags": ["3d", "raymarching", "clouds", "cloud", "sky", "volumetric", "mie"], "likes": 31, "viewed": 714, "published": 3, "date": "1696899177", "time_retrieved": "2024-07-30T17:29:25.945793", "image_code": "// Asthetic clouds by El_Sargo\n// First serious attempt at making some nice clouds, \n// performance is rubish though :( ( Compared to more \n// advanced systems that use TAA ect ), I guess it's fine for\n// a shadertoy though.\n// Next step is to do some fancy temporal reprojection type things\n// and various other optimisztions.\n// Turn on HALF_RESOLUTION in common if it's to slow\n\nvec3 aces_tonemap(vec3 color) {\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 f ) {\n    vec2 uv = f/iResolution.xy;\n    vec3 col;\n    #ifdef HALF_RESOLUTION\n        col = tx(iChannel0,uv*0.5).rgb;\n    #else\n        col = texture(iChannel0,uv).rgb;\n    #endif\n    col /= 8.;\n    col = pow(col,vec3(.8));\n    col *= smoothstep(.9,0.1,length(uv-0.5));\n    fragColor =  vec4(aces_tonemap(col),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const mat3 m = mat3(\n    1.0,0.0,0.0,\n    0.0,1.0,0.0,\n    0.0,0.0,1.0\n);\n\n#define SAMPLE t3x(iChannel0,x*0.02).x\n#define NEXT_OCTAVE a += b*n;b *= s;x = f*m*(x+vec3(iTime*0.2*k,0,0));k *= -1.;\nvec2 fb( in vec3 x ){\n    float f = 1.78;\n    float s = 0.54;\n    float a = 0.0;\n    float z = 0.0;\n    float b = 0.5;\n    float k = 1.;\n    for( int i=0; i < 4; i++ ) {\n        float n = SAMPLE;\n        n *= tx(iChannel1,x.xz*0.01).x;\n        z += b*n; \n        NEXT_OCTAVE\n    }\n    for( int i=0; i < 4 ; i++ ) {\n        float n = SAMPLE*1.6;\n        NEXT_OCTAVE\n    }\n    return  vec2(a,z);\n}\n\nfloat fbb( in vec3 x ) {\n    float f = 1.78;\n    float s = 0.54;\n    float a = 0.0;\n    float b = 0.5;\n    float k = 1.;\n    for (int i=0;i<4;i++) {\n        float n = SAMPLE;\n        n *= tx(iChannel1,x.xz*0.01).x;\n        NEXT_OCTAVE\n    }\n    return a;\n}\n\nvec2 getMouse(){\n    if (iMouse.z > 0.5) {\n       return iMouse.xy/iResolution.xy;\n    } else {\n        return vec2(1.46,0.3);\n    }\n}\n\n// Physicaly based, shmisicaly shmased\nfloat simpleMie(float costh) {\n  return ((costh+0.7)*costh*costh*costh+0.2)*2.;\n}\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 sun){\n    float mouse = getMouse().y;\n    float rds = dot(sun, rd);\n    vec3 sunset = exp(-0.01*vec3(1,2,4)/mouse-0.4);\n    vec3 light = vec3(smoothstep(0.997, 1.2, rds))*100000.*vec3(1,0.8,0.6)*sunset;\n\tfloat g = 0.;\n    float mid = CLOUD_HEIGHT;\n    float delt = 40. ;\n    float idelt = 1./delt;\n    float start = (mid - delt)/rd.y;\n    float end = (mid + delt)/rd.y;\n    float j=start;\n\tvec3 ccol = vec3(0.);\n    float m = simpleMie(rds);\n    float T = 0.;\n\tif (rd.y > 0.) {\n        float dj = 1.5/rd.y;\n\t\tfor (; j<end;j+=dj){\n            vec3 s = (rd*j+vec3(ro.x,0.,ro.z))*0.01;\n            float ddd = 0.2;\n            float xj = fbb(s+sun*ddd); \n            float sub = (s.y-mid)*idelt*0.01-0.2;\n            float subb = ((s.y+sun.y*ddd)-mid)*idelt*0.01-0.2;\n\t\t\tvec2 d = fb(s)+sub;\n\t\t\tfloat dd = xj+subb;\n            float dir_deriv = (d.y-dd)/ddd;\n\t\t\tg +=  max(0.,d.x*3.);\n\t\t\tvec3 col = sunset*( \n                (max(0.,dir_deriv)*3.+0.2)*m+\n                d.y*vec3(0.1,0.2,0.3)*exp((g+2.)*0.1)\n            );\n\t\t\tccol += col*exp(g*-vec3(.3,0.4,0.5));\n            if (g > 9.){\n                break;\n            }\n\t\t}\n     } \n     light = mix(mix(ccol,light,exp(-1.5*g)),vec3(0.7), smoothstep(0.,-.1,rd.y));\n     float at = CLOUD_HEIGHT/rd.y*0.0001;\n     \n     return \n         light*exp(-vec3(1,2,4)*1.3*at)+\n         7.*(1.-exp(-at*3.5*vec3(1,2,4)*sunset));\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec2 mou = getMouse();\n    float mx = -mou.x*10.;\n    float my = mou.y*2.;\n    vec3 sun = normalize(vec3(sin(mx),max(0.,sin(my-0.3)*2.),cos(mx)));\n    return getSky(ro,rd,sun);\n}\n\nvoid mainImage( out vec4 fragColor , in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    #ifdef HALF_RESOLUTION\n    if (max(uv.x,uv.y) <= 0.502) {\n        uv *= 2.0;\n        #endif\n        vec2 nuv = (uv-0.5)*vec2(1.,iResolution.y/iResolution.x);\n        vec3 ro = vec3(iTime*20.0+1550.,0., 4.);\n        vec3 rd = normalize(vec3(nuv, -0.7));\n        rd.yz *= mat2(12./13.,-5./13.,5./13.,12./13.);\n        col = render(ro, rd);\n    #ifdef HALF_RESOLUTION\n    }\n    #endif\n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define HALF_RESOLUTION\n#define CLOUD_HEIGHT (250.0)\n\n// https://www.shadertoy.com/view/XsfGDn\nvec4 tx( sampler2D sam, vec2 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec2 iuv = floor( uv );\n    vec2 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}\n\n// Same as above but 3D\nvec4 t3x( sampler3D sam, vec3 uv ) {\n    float textureResolution = float(textureSize(sam,0).x);\n    uv = uv*textureResolution + 0.5;\n    vec3 iuv = floor( uv );\n    vec3 fuv = fract( uv );\n    uv = iuv + fuv*fuv*(3.0-2.0*fuv);\n    uv = (uv - 0.5)/textureResolution;\n    return texture( sam, uv );\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 413, 413, 860], [862, 862, 911, 911, 1224]], "test": "untested"}
{"id": "clScRK", "name": "3D XY Model", "author": "thepinkpanzer", "description": "The XY model is similar to the Ising model (https://www.shadertoy.com/view/DljyRy) but each cell is allowed to take any 2D vector as opposed to just being up or down. This allows the domains to blend continuously. ", "tags": ["raymarching", "simulation", "volumetric", "cubemap", "physics", "cubemapa"], "likes": 11, "viewed": 272, "published": 3, "date": "1696890711", "time_retrieved": "2024-07-30T17:29:26.915201", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec4 bloom = texture(iChannel1, uv);\n    vec4 raw   = texture(iChannel0, uv);\n    fragColor  = tanh(0.9*bloom + 0.9*raw);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    int  dataPage;\n    vec3 worldPos = WorldPosFromCube(fragCoord, rayDir, dataPage);\n    if (dataPage == 1)\n    {\n        vec2  currentSpin  = texture(iChannel0, rayDir).rg;\n        vec2  neighbourSum = texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 1, 0, 0)), dataPage)).rg\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3(-1, 0, 0)), dataPage)).rg\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 1, 0)), dataPage)).rg\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0,-1, 0)), dataPage)).rg\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 0, 1)), dataPage)).rg\n                            +texture(iChannel0, CubeFromWorldPos((worldPos+vec3( 0, 0,-1)), dataPage)).rg;\n        float energy       = dot(H + J*neighbourSum, currentSpin);\n        float flip_rand    = Random(length(worldPos/54.12345 + vec3(1.65546, 0.654323, 0.73243)) + fract(iTime/13.));\n        vec2 newSpin       = RandomCircle(flip_rand/DT);\n        float energy_flip  = dot(H + J*neighbourSum, (currentSpin-newSpin));\n        if      (iFrame <= 5)\n        {\n            currentSpin = RandomCircle(flip_rand + 1.);\n        }\n        else if ((flip_rand < DT) && (exp(-max(energy_flip/T, 0.)) > Random(flip_rand*2./DT)))\n        {\n            currentSpin  = newSpin;\n        }\n        fragColor = vec4(currentSpin, 1., -dot(neighbourSum, currentSpin)-length(neighbourSum));\n    }\n    else\n    {\n        fragColor = vec4(1,0,1,0);\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// MARCHING\n#define STEPDIST    1./128.\n#define NUMSTEPS    100\n// BLOOM\n#define BLOOMRADIUS 30.\n#define BLOOMLOD 2.\n// COLORS AND LIGHTING\n#define ABSORPTIVITY 10.\n#define HAZE         0.01\n#define RED   vec4( 1., 1., 1., 0.)\n#define BLUE  vec4( 1., 1., 1., 0.)\n#define WHITE vec4( 1., 1., 1., 0.)*6000.\n// SIMULATION PARAMETERS\n// External field\n#define H  vec2(0., 0.)\n// Temperature (periodic flashing)  \n#define T  (fract(iTime/100.) < 0.001 ? 10. : 0.2)\n// Inter-atom alignment strength\n#define J  1.\n// Timestep per frame\n#define DT 0.5\n// Number of cells set to 0 (instead of ±1)\n#define IMPURITYDENSITY 0.\n\nvec3 WorldPosFromCube(vec2 fragCoord, vec3 rayDir, out int dataPage)\n{\n    /*\n    Function to be used (primarily) in Cube A. Converts the fragCoord and ray direction\n    into world position, while storing the Data Page on the side.\n    \n    Note that while the cubemap has 6 faces, there are only 3 data pages as two faces\n    are required to fill out the 128x128x128 cube.\n    */\n    vec3 ard = abs(rayDir);\n    float m  = max(ard.x, max(ard.y, ard.z));\n    int bigCoord = int(fragCoord.x) + 1024*int(fragCoord.y);\n    if      (m ==  rayDir.x)\n    {\n        dataPage = 1;\n    }\n    else if (m ==  rayDir.y)\n    {\n        dataPage = 2;\n    }\n    else if (m ==  rayDir.z)\n    {\n        dataPage = 3;\n    }\n    else if (m == -rayDir.x)\n    {\n        dataPage = 1;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.y)\n    {\n        dataPage = 2;\n        bigCoord+= 1024*1024;\n    }\n    else if (m == -rayDir.z)\n    {\n        dataPage = 3;\n        bigCoord+= 1024*1024;\n    }\n    int x = (bigCoord        )%128;\n    int y = (bigCoord/128    )%128;\n    int z = (bigCoord/128/128)%128; // % is unnecessary but why not\n    return (vec3(x,y,z));\n}\nvec3 RoundWorldPos(vec3 worldPos)\n{\n    worldPos += 0.5;\n    worldPos *= 128.;\n    worldPos  = floor(worldPos);\n    return worldPos;\n}\nvec3 CubeFromWorldPos(vec3 worldPos, int dataPage)\n{\n    /*\n    The inverse of WorldPosFromCube (well, kind of). Converts world position into the\n    ray direction needed to read that voxel (on that Data Page). Not exactly the inverse \n    of WorldPosFromCube in that WPFC uses the frag coords as primary input, while CFWP\n    spits out the ray direction.\n    \n    Note: worldPos is the **ROUNDED** world position.\n    */\n    worldPos = mod(worldPos, 128.);\n    worldPos = floor(worldPos);\n    if (worldPos.x > 127. || worldPos.y > 127. || worldPos.z > 127.\n     || worldPos.x < 0.   || worldPos.y < 0.   || worldPos.z < 0.  )\n    {\n        return vec3(0);\n    }\n    else\n    {\n        int bigCoord = ((int(worldPos.z)*128+int(worldPos.y))*128+int(worldPos.x));\n        bigCoord -= int(worldPos.z+1.) > 64 ?   1024*1024 : 0;\n        dataPage += int(worldPos.z+1.) > 64 ?           3 : 0;\n        dataPage -= 1;\n        vec3 rgVex[6] = vec3[6](vec3( 0, 0,-1),vec3( 1, 0, 0),vec3( 1, 0, 0),vec3( 0, 0, 1),vec3( 1, 0, 0),vec3(-1, 0, 0));\n        vec3 upVex[6] = vec3[6](vec3( 0,-1, 0),vec3( 0, 0, 1),vec3( 0,-1, 0),vec3( 0,-1, 0),vec3( 0, 0,-1),vec3( 0,-1, 0));\n        vec3 fwVex[6] = vec3[6](vec3( 1, 0, 0),vec3( 0, 1, 0),vec3( 0, 0, 1),vec3(-1, 0, 0),vec3( 0,-1, 0),vec3( 0, 0,-1));\n        vec2 uvs      = (vec2(bigCoord % 1024, (bigCoord/1024)%1024) + 0.5)/1024.;\n        uvs           = 2.*uvs - 1.;\n        vec3 rayDir   = (rgVex[dataPage]*uvs.x + upVex[dataPage]*uvs.y);\n        rayDir       += (fwVex[dataPage]);\n        return normalize(rayDir);\n    }\n}\nfloat Random(float seed)\n{\n    seed = fract(seed*(104.643 - seed) + 6.2341);\n    seed = fract(seed*( 42.123 - seed) + 2.8583);\n    seed = fract(seed*( 36.131 - seed) + 1.6235);\n    return seed;\n}\nvec2 RandomCircle(float seed)\n{\n    float r0 = Random(seed);\n    float r1 = r0 + Random(r0)*628.318531;\n    return vec2(cos(r1), sin(r1));\n}", "buffer_a_code": "#define PI      3.1415926\n#define ROTFREQ 0.06\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse  = (iMouse.xy == vec2(0) ? vec4(iResolution.x*(iTime*ROTFREQ), iResolution.y*0.3, 1., 0) : iMouse);\n    float theta = (mouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (mouse.y - iResolution.y / 2.) / iResolution.y * PI*0.55;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = -2.*iCameraFwd;\n    \n    float m = 1.2;\n    \n    // Anti-aliasing by randomly jittering the pixel\n    fragCoord += vec2(Random(fract(iTime) + dot(fragCoord, vec2(0.123, 0.215))), Random(fract(iTime) + dot(fragCoord, vec2(.053, 0.253))));\n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // SORTING FACES\n    float distXP =  (0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYP =  (0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZP =  (0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    float distXM = (-0.5-iCameraPosition.x)/iViewDirection.x;\n    float distYM = (-0.5-iCameraPosition.y)/iViewDirection.y;\n    float distZM = (-0.5-iCameraPosition.z)/iViewDirection.z;\n    \n    vec3 faceList[6] = vec3[6]( vec3( 1,0,0), vec3(0, 1,0), vec3(0,0, 1),\n                                vec3(-1,0,0), vec3(0,-1,0), vec3(0,0,-1));\n\n    float distList[6] = float[6]( distXP, distYP, distZP,\n                                  distXM, distYM, distZM);\n    \n    for (int n = 0; n < 5; n++)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            if (distList[i] > distList[i+1])\n            {\n                vec3 c        = faceList[i];\n                faceList[i]   = faceList[i+1];\n                faceList[i+1] = c;\n                \n                float r       = distList[i];\n                distList[i]   = distList[i+1];\n                distList[i+1] = r;\n            }\n        }\n    }\n    \n    // MARCH!\n    fragColor   = vec4(0);\n    vec4 absorb = vec4(1);\n    if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n    {\n        vec3 pos = iCameraPosition + distList[2]*iViewDirection;\n        vec3 dir = refract(iViewDirection, faceList[2], 0.7);\n        for (int n = 0; n < NUMSTEPS; n++)\n        {\n            vec3 samplePos = pos + dir*STEPDIST*Random(pos.x + fract(iTime/13.));\n            vec4 sampleVal = texture(iChannel0, CubeFromWorldPos(RoundWorldPos(samplePos), 1));\n            float theta    = atan(sampleVal.r,sampleVal.g);\n            vec4 color     =  0.5*(vec4(cos(1.5*theta), cos(1.5*theta + 2.0943951), cos(1.5*theta + 4.1887902), 0)+1.);\n            vec4 glow      = (exp(0.75*sampleVal.a)*WHITE + HAZE*ABSORPTIVITY)*STEPDIST;\n            absorb        *= exp(-color*ABSORPTIVITY*STEPDIST);\n            fragColor     += glow*absorb;\n            pos           += dir*STEPDIST;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS; x < BLOOMRADIUS+1.; x++)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*textureLod(iChannel0, (fragCoord + vec2(1,0)*(x*BLOOMLOD))/iResolution.xy, (BLOOMLOD));\n    }\n    fragColor /= BLOOMRADIUS;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    for (float x = -BLOOMRADIUS; x < BLOOMRADIUS+1.; x++)\n    {\n        fragColor += exp(-(4.*x*x)/(BLOOMRADIUS*BLOOMRADIUS))*textureLod(iChannel0, (fragCoord + vec2(0,1)*(x*BLOOMLOD))/iResolution.xy, (BLOOMLOD));\n    }\n    fragColor /= BLOOMRADIUS;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/clScRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 300]], "test": "untested"}
{"id": "DscBz4", "name": "fuck i just cant get this rightt", "author": "kwyntes", "description": "i just cannot\nit shouldnt be hard\nbut im stupid\nwtf is smoothstep even doing btw\nlike wtf\nits so weird\nit never does what i expect it to do\naaaaaaa\nthis is the best version i can do probably\nwe just need to get rid of thta little section where the tan is", "tags": ["fuck", "transition", "barreldistortion", "opticaltransition", "wannabeaftereffects"], "likes": 1, "viewed": 206, "published": 3, "date": "1696887954", "time_retrieved": "2024-07-30T17:29:27.773905", "image_code": "// Given a vec2 in [-1,+1], generate a texture coord in [0,+1]\nvec2 Distort(vec2 uv, float power)\n{\n    float theta  = atan(uv.y, uv.x);\n    float radius = length(uv);\n    radius = pow(radius, power);\n    uv.x = radius * cos(theta);\n    uv.y = radius * sin(theta);\n    return 0.5 * (uv + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalised vector adjusted for aspect ratio with origin at the center of the screen\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.xy;\n    //vec2 uv = fragCoord / iResolution.xy;\n    \n    float speed = 4.;\n    float wait = 2.;\n    float end = radians(180.);\n    float lim = 3.;\n    float div = 4.;\n    \n    \n    \n    float MUL = 4.;\n    \n    \n    \n    \n    float x = clamp(iTime*speed, wait+0., wait+end)-wait;\n    //float power = (sin(x) * sign(cos(x))) * MUL + 1.; // no distortion when power=1\n    // it's literally a power, as in math.pow.\n    \n    float pi = radians(180.);\n    //float power = asin(clamp(iTime - pi/2., -pi/2., pi/2.)) + 1.;\n    float power = clamp(-tan(x), -lim, lim) / div + 1.;\n   \n       // smoothstep actually makes our lives harder for some reason wtfffffffffffffffffff\n       /// liek wiehfiuwerhfiuerhgifubeirufgeryuifhbie4rfh what\n       // jdiwefuiwhuioh what ha=eeven fucking happeneddd\n       // fefuwehufihwuifhiwu wWHYY whyyYYy hwhyshauishn WHY DOES NOTGHIBN WORKKkk kk,d,.d.,d.d.d.d.d.... .. , , , \n   \n    //float delay = 2.;\n    //float duration = 1.;\n    //float delayed = max(iTime/duration, delay) - delay;\n    //float power = smoothstep(-1., 1., delayed*2. - 1.) + 1.;\n    \n    //float peek = 4.;\n    \n    //float t = iTime * 2.;\n    //float power = smoothstep(-1., 1., t*2. - 1.) * peek + (t > 0.5 ? (1. - peek) : 1.);\n    \n    vec2 duv = Distort(uv, power);\n    \n    if (x<end/2.) {\n    //if (delayed > 0.5) {\n    //if (t > 0.5) {\n        fragColor = texture(iChannel0, duv);\n    } else {\n        fragColor = texture(iChannel1, duv);\n    }\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DscBz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 99, 99, 295], [297, 297, 354, 445, 1963]], "test": "untested"}
{"id": "DsdBRH", "name": "3d worley noise", "author": "Mik0", "description": "An efficient worley function.", "tags": ["noise", "worley"], "likes": 1, "viewed": 206, "published": 3, "date": "1696863588", "time_retrieved": "2024-07-30T17:29:29.079415", "image_code": "//Feel free to copy all functions used. No credits are needed.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat worley(vec3 p, float power)\n{\n    float finalDist = 9999999.0;\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                float dist = pow(distance(p, floor(p)+offset+hash33(floor(p)+offset)), power);\n                finalDist = min(finalDist, dist);\n            }\n        }\n    }\n   return finalDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    // Output to screen\n    fragColor = vec4(vec3(1.0-worley(vec3(uv*16.0, 0)+iTime, 1.5)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsdBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 86, 86, 211], [213, 213, 248, 248, 665], [667, 667, 724, 749, 941]], "test": "untested"}
{"id": "msKcDV", "name": "Simple Dot Animation", "author": "Shane", "description": "Using a grid and very basic keyframing concepts to create a simple repetitive dot animation.", "tags": ["grid", "circle", "random", "animation", "motion", "tween", "keyframe"], "likes": 47, "viewed": 568, "published": 3, "date": "1696859094", "time_retrieved": "2024-07-30T17:29:29.834396", "image_code": "/*\n\n    Simple Dot Animation\n    --------------------\n    \n    As you can see, this is a very basic animation sequence. There's \n    nothing particularly original about it, since it can be found in \n    various forms all over the internet, but I thought it was fun to watch, \n    and would provide a way to give anyone not familiar with motion tweening \n    concepts a place to start.    \n    \n    I love those cute geometric keyframe-based animations that pop up all \n    over the internet, often in gif form. They exist on Shadertoy too, and\n    some are amazing, but they're not what I'd call common.\n    \n    I guess one of the reasons is that pixelshaders can be restrictive,\n    since there's generally no random pixel access and calculations occur \n    on a per-pixel basis. Basically pixelshaders are not really designed for \n    motion tweening. However, it's all pretty doable. This particular \n    animation didn't require too much effort at all.\n    \n    I remember back in the day when democoders finally started giving people \n    a look at the code magic behind the productions and I was amazed at how \n    simple the key framing component was: Divide time up into time blocks,\n    each with their own start and end node markers. Determine which time  \n    block you're in, set some start time entities (like position, color, \n    orientation, etc.), set the corresponding end time entities, interpolate \n    all entities over the block's time period, then proceed to the next time \n    block.\n    \n    Anyway, for this particular animation sequence, I'm breaking time into \n    three blocks, interpolating the object position between the first two, \n    then interpolating position and rotation on the last. The process is \n    repeated ad infinitum, and is all pretty straight forward. The details \n    can be found in the code below.\n    \n    The animation rendering itself was put together pretty quickly. This is\n    a 2D example, so speed wasn't really a consideration, but I did it in a\n    way that would allow me to extrude it at a later date. Therefore, there\n    are more than likely cleverer ways to render this, which I'll leave to \n    the code golfing crowd. :)\n    \n    \n    \n    Other examples:\n    \n    // Animated squares. 104 makes a lot of cool shaders. I've only \n    // skimmed the code, but I'm pretty sure this was created using \n    // similar principles.\n    90's Mirrored Squares - 104\n    https://www.shadertoy.com/view/3lBSzW\n    \n    \n    // You can't mention keyframes without referencing this one. \n    // Clever on so many levels.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n// Showing the background grid pattern can spoil the illusion, but it\n// helps show how the animation is made.\n//#define GRID\n\n\n// Total running time, tmID, and time segment.\nfloat tmTotal, tmID, tmSeg;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n \n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n \n\n// Animated dots.\nfloat dots(vec2 p, vec2 ip, vec2 sc){\n\n   \n    // Vertices: Clockwise from the bottom left. We're only using two\n    // of them, but I'm including the other two for completeness.\n    mat4x2 v = mat4x2(vec2(-1), vec2(-1, 1), vec2(1), vec2(1, -1));\n    // Mid edges corrsponding to the above.\n    mat4x2 e = mat4x2(vec2(-1, 0), vec2(0, 1), vec2(1, 0), vec2(0, -1));\n    \n     // Fractional time segment: Same as fract(tmTotal).\n    float fTm = tmTotal - tmID; // Range: [0. 1].\n    \n    // Using smoothstep to smoothly interpolate the time period between\n    // zero and one. You could also use any number of easing functions, \n    // but I'm trying to keep things simple. The following roughly\n    // emulates a fast-in-the-middle motion... Not the technical term. :D\n    fTm = smoothstep(.25, .75, fTm);\n   \n    \n    // Object position and direction.\n    vec2 pos = vec2(0), dir;\n    \n    // Object (dot) size. \n    float sz = .2*min(sc.x, sc.y);\n    \n    // The resultant field distance.\n    float d;\n    \n    \n    if(tmSeg<.001){\n    \n        // Verticle direction.\n        dir = vec2(0, 1);\n \n        \n        vec2 di;\n        // Left wall semi-circle moving up from v[0].\n        di.x = length(p - (v[0] + dir*fTm)*sc/2.) - sz;\n        di.x = max(di.x, -(p.x + sc.x/2.));\n        \n        // Right wall semi-circle moving down from v[2].\n        di.y = length(p - (v[2] - dir*fTm)*sc/2.) - sz;\n        di.y = max(di.y, (p.x - sc.x/2.));\n            \n            \n        d = min(di.x, di.y);\n \n     \n    }\n    else if(tmSeg<1.001){\n    \n        // Horizontal direction.\n        dir = vec2(1, 0);\n         \n        // Splitting a semi circle running between \n        // the left and right edge midpoints and\n        // moving them in opposite directions.\n        \n        vec2 di;\n        // Moving left from e[2].\n        di.x = length(p - (e[2] - dir*fTm)*sc/2.) - sz;\n        di.x = max(di.x, p.y);\n        \n        // Moving right from e[0].\n        di.y = length(p - (e[0] + dir*fTm)*sc/2.) - sz;\n        di.y = max(di.y, -p.y);\n            \n            \n        d = min(di.x, di.y);\n \n  \n    }\n    else {\n    \n        // Instead of rendering four quarter circles in the center then moving\n        // them to the corners, we're saving some rendering (kind of), but splitting\n        // the cell into four smaller cells, then rendering diagonally from the\n        // appropriate vertex to the opposite diagonal one.\n\n\n         // We've effectively split each cell into fours, so based on the cell\n         // ID, we need to determine which clockwise quadrant we're in.\n         vec2 mIP = mod(ip, 2.);\n         int j = mIP.x==0.? mIP.y==0.? 0 : 1 : mIP.y==0.? 3 : 2;\n\n         // Starting vertex and ending vertex.\n         pos = mix(v[(j + 2)&3], v[j], fTm); \n         // The diagonal direction vector.\n         dir = (v[(j + 2)&3] - v[j]);\n\n         // Interpolating a half spin over time.\n         mat2 m2 = rot2(mix(0., 3.14159, fTm));\n\n         // Moving a square (the same size as the dot) to the dot's central\n         // point, rotating it about that point according to the rotational \n         // factor, then moving the edges to the dot center to create a rotating\n         // quarter circle... Yeah, transformations can get a little confusing,\n         // but they're not hard to learn, and you get better with practice.\n         vec2 q = abs(m2*(p - pos*sc/2.) + sign(dir)*sz) - sz;\n         float bound = max(q.x, q.y); // Bounding square.\n          \n         // The object position itself.\n         float di = length(p - pos*sc/2.) - sz*2.;\n         di = max(di, bound); // CSG with the bound to form a quarter circle.\n         d = di; // Setting as the distance.\n     \n    }\n    \n\n    \n    return d;\n}\n\nvoid mainImage( out vec4 o, in vec2 p){\n \n    // Coordinates: They're already in aspect correct form, so a \n    // simple translation and scaling is all that is necessary.\n    p = (p - iResolution.xy*.5)/iResolution.y; \n    \n    vec2 op = p;\n    \n    // Last minute subtle plane warping.\n    p *= .95 + length(p)*.1;\n    // Screen rotation. I liked this angle, but you could choose another.\n    p = rot2(3.14159/6.)*(p - vec2(2, 1)*iTime/60.);\n   \n    \n    \n    // Obviously, timing is important in keyframing. This breaks time into\n    // three equal segments lasting 1.5 seconds each.\n    tmTotal = iTime/1.5; \n    tmID = floor(tmTotal);\n    tmSeg = mod(tmID, 3.);\n    \n    // Grid scale: I've set it to squares, but rectangles work too. \n    vec2 sc0 = vec2(1)/6.;\n    vec2 sc = tmSeg<1.01? sc0 : sc0/2.;\n    \n    \n    // A gradient background.\n    vec3 c = mix(vec3(1, .7, .3), vec3(1, .8, .2), op.y + .5);\n    #ifdef GRID \n    float rnd = hash21(floor(p/sc0));\n    vec3 bCol = .5 + .45*cos(6.2831*rnd - op.y/2. + vec3(0, 1, 2));\n    float ch = mod(dot(floor(p/sc0*2.), vec2(1)), 2.)<.5? -.1 : .1;\n    c = mix(c, max(bCol + ch, 0.), .5);\n    #endif \n    \n    \n    // Grid distance and shadow.\n    float d = 1e5, dSh = 1e5;\n    \n    // Light direction: Used to cast shadows.\n    vec2 ld = rot2(3.14159/6.)*vec2(-1);\n    \n    // Rendering the grid: Some of the objects move slightly outside the\n    // cell bounds and into the neighboring cells, which means you need\n    // to render the neighbors also. The following is a standard way to \n    // do that.\n    for(int i = 0; i<4; i++){\n        \n        // Neighbor offset.\n        vec2 offs = vec2(i&1, i/2) - .5;\n\n        // Grid partitioning -- ID and local coordinates.\n        vec2 q = p;\n        vec2 iq = floor(q/sc + offs);\n        q -= (iq + .5)*sc;\n\n        // The dot field and shadow field.\n        d = min(d, dots(q, iq, sc));\n        dSh = min(dSh, dots(q - ld*.015, iq, sc));\n    }\n    \n    // Smoothing factor.\n    float sf = 1.5/iResolution.y;\n    \n    \n    // Shadow, edge and face color.\n    vec3 svC = mix(c*.2, vec3(.14), .75);\n    c = mix(c, vec3(0), (1. - smoothstep(0., sf*2., dSh - .007))*.5);\n    c = mix(c, vec3(0), 1. - smoothstep(0., sf, d - .007));\n    c = mix(c, vec3(.14)*0. + svC, 1. - smoothstep(0., sf, d));\n\n    // Rough gamma correction.\n    o = vec4(sqrt(max(c, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2867, 3019, 3040, 3040, 3106], [3110, 3193, 3214, 3379, 3512], [3516, 3534, 3571, 3712, 7257], [7259, 7259, 7298, 7430, 9621]], "test": "untested"}
{"id": "Dt3GzB", "name": "Type 3 Hexagonal Tilings", "author": "mla", "description": "Hexagonal tilings of the third kind. See code for more details & for controls (a,c,d,g,x,z,mouse,up,down).\n\nSee: [url]https://en.wikipedia.org/wiki/Hexagonal_tiling#Monohedral_convex_hexagonal_tilings[/url]", "tags": ["deformation", "hexagon", "tilings", "parquet"], "likes": 27, "viewed": 334, "published": 3, "date": "1696847539", "time_retrieved": "2024-07-30T17:29:30.769895", "image_code": "// Type 3 Hexagonal Tilings\n//\n// There are three types of hexagonal tile that tile the plane\n// isohedrally (every tile vertex is the same). Type 3 is based\n// on a hexagon grid and is symmetric under 120° rotations. The\n// tiling is essentially a (3,6) irregular snub dual, with a\n// control vertex for each rhomoboidal fundamental region with a line\n// from the control point to 3 of the vertices of the fundamental\n// region. Rotational symmetry then does the rest.\n//\n// Easier to see than to explain - 'g' shows underlying grid, 'z' \n// zooms in a little.\n//\n// Moving the control point as we go across the screen produces\n// a parquet deformation effect. The default vertex position is\n// either set automatically in animation mode, or can be set by the\n// mouse. Note that some mouse positions can result in incomplete\n// drawing of the tiling.\n//\n// <mouse>: if not in animation mode, click & drag control point\n// <up/down>: zoom in/out\n// a: toggle animation mode\n// c: toggle random coloring\n// d: toggle parquet deformation\n// g: show grid\n// x: show control point\n// z: zoom in\n\nint wind(vec2 p, vec2 q, vec2 r) {\n  // NR winding number computation, extending ray\n  // vertically, not that it matters much here.\n  q -= p; r -= p; // Relative to p\n  float t = determinant(mat2(q,r));\n  if (q.x <= 0.0) {\n    if (r.x > 0.0 && t > 0.0) return 1;\n  } else {\n    if (r.x <= 0.0 && t < 0.0) return -1;\n  }\n  return 0;\n}\n\nconst float X = 1.732050808; // sqrt(3)\nconst float Y = 0.577350269; // 1/sqrt(3)\nconst mat2 M = 0.5*mat2(1,-X,1,X);\nconst mat2 Minv = Y*mat2(X,X,-1,1);\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  setscale();\n  vec2 p = map(fragCoord);\n  vec2 p0 = p;\n  float px = 1.4*2.0*scale/iResolution.y;\n  p.x += 1.0;\n  p *= M; // Convert to square grid\n  ivec3 ix = ivec3(floor(p),0); // Remember cell in grid\n  p -= floor(p);\n  p *= Minv; // Back to triangles\n  p.x -= 1.0;\n\n  vec2 A = vec2(0,Y);\n  vec2 B = vec2(0,-Y);\n  vec2 C = vec2(1,0);\n  vec2 D = vec2(-1,0);\n  vec2 E = -vec2(1.0/3.0,0);\n  vec2 F = -E;\n  vec2 G = getselection(0);\n  if (!key(CHAR_A)) {\n    // Animation\n    vec2 q = 0.1*iTime*vec2(1,0.618);\n    //q += 0.01*p0;\n    q = 2.0*fract(q);\n    q = min(q,2.0-q);\n    q *= Minv;\n    q.x -= 1.0;\n    G = q;\n  }\n  if (!key(CHAR_D)) G += 0.01*p0*Minv;\n  vec2 H = E+rotate(G-E,TWOPI/3.0);\n  vec2 I = E+rotate(G-E,2.0*TWOPI/3.0);\n  vec2 J = F+rotate(G-F,TWOPI/3.0);\n  vec2 K = F+rotate(G-F,2.0*TWOPI/3.0);\n  vec2 O = F+vec2(-1,Y);\n  vec2 M = vec2(1,-1)*O;\n  vec2 Q = -O;\n  vec2 S = -M;\n  \n  int k;\n  k = wind(p,D,I)+wind(p,I,E)+wind(p,E,H)+wind(p,H,O)+wind(p,O,D);\n  if (k > 0) { ix.z = 1; }\n  k = wind(p,O,H)+wind(p,H,A)+wind(p,A,O);\n  if (k > 0) { ix.x--; ix.z = 2; }\n  k = wind(p,A,K)+wind(p,K,S)+wind(p,S,A);\n  if (k > 0) { ix.y++; ix.z = 1; }\n  k = wind(p,S,K)+wind(p,K,F)+wind(p,F,J)+wind(p,J,C);\n  if (k > 0) { ix.z = 2; }\n  k = wind(p,C,J)+wind(p,J,Q)+wind(p,Q,C);\n  if (k > 0) { ix.x++; }\n  k = wind(p,Q,J)+wind(p,J,F)+wind(p,F,G)+wind(p,G,B)+wind(p,B,Q);\n  if (k > 0) { ix.x++; ix.z = 1; }\n  k = wind(p,B,G)+wind(p,G,E)+wind(p,E,I)+wind(p,I,M)+wind(p,M,B);\n  if (k > 0) { ix.y--; ix.z = 2; }\n  k = wind(p,M,I)+wind(p,I,D)+wind(p,D,M);\n  if (k > 0) { ix.y--; }\n  vec3 col = vec3(1,1,0.8);\n  if (!key(CHAR_C)) col = hsv2rgb(rand(ix),0.5,0.8);\n\n  float d = 1e8; \n  d = min(d,segment(p,B,G));\n  d = min(d,segment(p,C,J));\n  d = min(d,segment(p,D,I));\n  d = min(d,segment(p,E,G));\n  d = min(d,segment(p,E,H));\n  d = min(d,segment(p,E,I));\n  d = min(d,segment(p,F,G));\n  d = min(d,segment(p,F,K));\n  d = min(d,segment(p,F,J));\n  d = min(d,segment(p,A,K));\n  d = min(d,segment(p,A,H));\n  d = min(d,segment(p,H,O));\n  d = min(d,segment(p,I,M));\n  d = min(d,segment(p,J,Q));\n  d = min(d,segment(p,K,S));\n\n  // Lines for G outside the rhombus\n  // This also needs extra colouring.\n  d = min(d,segment(p,S,C+G-B));\n  d = min(d,segment(p,S+F-E,C+G-B));\n  d = min(d,segment(p,Q,Q+I-E));\n  d = min(d,segment(p,Q+F-S,Q+I-E));\n  \n  // Next six just fill some potential gaps\n  d = min(d,segment(p,B,B+rotate(G-B,TWOPI/3.0)));\n  d = min(d,segment(p,B,B+rotate(G-B,2.0*TWOPI/3.0)));\n  d = min(d,segment(p,C,C+rotate(J-C,TWOPI/3.0)));\n  d = min(d,segment(p,C,C+rotate(J-C,2.0*TWOPI/3.0)));\n  d = min(d,segment(p,D,D+rotate(I-D,TWOPI/3.0)));\n  d = min(d,segment(p,D,D+rotate(I-D,2.0*TWOPI/3.0)));\n  col *= smoothstep(0.0,px,d-0.01);\n  if (key(CHAR_G)) {\n    // Show grid\n    d = 1e8;\n    d = min(d,line(p,A,C));\n    d = min(d,line(p,C,B));\n    d = min(d,line(p,B,D));\n    d = min(d,line(p,D,A));\n    col *= smoothstep(0.0,px,d);\n  }\n  if (!key(CHAR_X)) {\n    // Show control point\n    float d = distance(p0,G);\n    col *= smoothstep(0.0,px,d-0.05);\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat scale = 1.5;\nconst float PI = 3.1415927;\nconst float TWOPI = 2.0*PI;\n\n#define map(screen) (scale*(2.0*screen-iResolution.xy)/iResolution.y)\n\nint nselections = 1;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(0.0);\n  return vec2(0);\n}\n\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define setscale() \\\n  (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))), \\\n   scale *= key(CHAR_Z) ? 2.0 : 4.0)\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);       \n  return v * mix(vec3(1.0),rgb,s);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}\n\nint idiv(int a,int b) {\n  return a >= 0 ? a/b : -((-a+b-1)/b);\n}\n\nint imod(int a, int b) {\n  int d = idiv(a,b);\n  return a-d*b;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nfloat rand(ivec3 p) {\n  uint h = ihash(uint(p.x));\n  h = ihash(uint(p.y)^h);\n  h = ihash(uint(p.z)^h);\n  return float(h)/exp2(32.0);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\n// const int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\nconst int CHAR_K = 75;\n// const int CHAR_L = 76;\nconst int CHAR_M = 77;\n// const int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))", "buffer_a_code": "#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.xyz = vec3(initselection(i-1),1234); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Dt3GzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1094, 1094, 1128, 1226, 1428], [1584, 1584, 1636, 1636, 4769]], "test": "untested"}
{"id": "ddcBz8", "name": "AtmosphereLUT", "author": "barth", "description": "A LUT generator for volumetric atmospheric scattering", "tags": ["atmosphere"], "likes": 2, "viewed": 192, "published": 3, "date": "1696845319", "time_retrieved": "2024-07-30T17:29:31.583720", "image_code": "#define PI 3.1415926535897932\n#define POINTS_FROM_CAMERA 120// number sample points along camera ray\n#define OPTICAL_DEPTH_POINTS 120// number sample points along light ray\n\n// rotation using https://www.wikiwand.com/en/Rodrigues%27_rotation_formula\nvec3 rotateAround(vec3 vector, vec3 axis, float theta) {\n    // Please note that unit vector are required, i did not divided by the norms\n    return cos(theta) * vector + cross(axis, vector) * sin(theta) + axis * dot(axis, vector) * (1.0 - cos(theta));\n}\n\n// A narrower version of line intersect sphere. It will return true only when the intersection is at a positive distance from the ray origin.\nbool rayIntersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePosition, float sphereRadius, out float t0, out float t1) {\n    vec3 relativeOrigin = rayOrigin - spherePosition;// rayOrigin in sphere space\n\n    float a = 1.0;\n    float b = 2.0 * dot(relativeOrigin, rayDir);\n    float c = dot(relativeOrigin, relativeOrigin) - sphereRadius*sphereRadius;\n\n    float d = b*b - 4.0*a*c;\n\n    if (d < 0.0) return false;// no intersection\n\n    float s = sqrt(d);\n\n    float r0 = (-b - s) / (2.0*a);\n    float r1 = (-b + s) / (2.0*a);\n\n    t0 = min(r0, r1);\n    t1 = max(r0, r1);\n\n    //return true;\n    return t1 > 0.0;\n}\n\nconst float EARTH_RADIUS = 1000e3;\nconst float ATMOSPHERE_RADIUS = 100e3;\nconst vec3 SUN_DIR = vec3(0.0, 1.0, 0.0);\n\nstruct Object {\n    float radius;\n    vec3 position;\n};\nconst Object object = Object(EARTH_RADIUS, vec3(0.0));\n\nstruct Atmosphere {\n    float radius;// atmosphere radius (calculate from planet center)\n    float falloff;// controls exponential opacity falloff\n    float sunIntensity;// controls atmosphere overall brightness\n    float rayleighStrength;// controls color dispersion\n    float mieStrength;// controls mie scattering\n    float densityModifier;// density of the atmosphere\n    float redWaveLength;// the wave length for the red part of the scattering\n    float greenWaveLength;// same with green\n    float blueWaveLength;// same with blue\n    float mieHaloRadius;// mie halo radius\n};\nconst Atmosphere atmosphere = Atmosphere(EARTH_RADIUS + ATMOSPHERE_RADIUS, 1.0, 10.0, 1.0, 1.0, 1.0, 700.0, 530.0, 440.0, 0.6);\n\n// based on https://www.youtube.com/watch?v=DxfEbulyFcY by Sebastian Lague\nvec2 densityAtPoint(vec3 samplePoint) {\n    float heightAboveSurface = length(samplePoint - object.position) - object.radius;\n    float height01 = heightAboveSurface / (atmosphere.radius - object.radius);// normalized height between 0 and 1\n\n    vec2 localDensity = vec2(\n    atmosphere.densityModifier * exp(-height01 * atmosphere.falloff),\n    atmosphere.densityModifier * exp(-height01 * atmosphere.falloff * 0.5)\n    );\n\n    localDensity *= (1.0 - height01);\n\n    return localDensity;// density with exponential falloff\n}\n\n\nvec2 opticalDepth(vec3 rayOrigin, vec3 rayDir, float rayLength) {\n\n    vec3 densitySamplePoint = rayOrigin;// that's where we start\n\n    float stepSize = rayLength / float(OPTICAL_DEPTH_POINTS - 1);// ray length between sample points\n\n    vec2 accumulatedOpticalDepth = vec2(0.0);\n\n    for (int i = 0; i < OPTICAL_DEPTH_POINTS; i++) {\n        accumulatedOpticalDepth += densityAtPoint(densitySamplePoint) * stepSize;// linear approximation : density is constant between sample points\n        densitySamplePoint += rayDir * stepSize;// we move the sample point\n    }\n\n    return accumulatedOpticalDepth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 vUV = fragCoord/iResolution.xy;\n\n    float height01 = vUV.y;\n    float lutx = vUV.x;\n    float costheta = lutx * 2.0 - 1.0;\n    float theta = acos(costheta);\n\n    vec3 surfacePoint = rotateAround(vec3(0.0, EARTH_RADIUS, 0.0), vec3(0.0, 0.0, 1.0), theta);\n    vec3 surfaceNormal = normalize(surfacePoint);\n    vec3 atmospherePoint = surfacePoint + surfaceNormal * ATMOSPHERE_RADIUS * height01;\n\n    float t0, t1;\n    rayIntersectSphere(atmospherePoint, SUN_DIR, vec3(0.0), EARTH_RADIUS + ATMOSPHERE_RADIUS, t0, t1);\n\n    vec2 sunRayOpticalDepth = opticalDepth(atmospherePoint, SUN_DIR, t1);\n\n    vec3 color = vec3(sunRayOpticalDepth.x, sunRayOpticalDepth.y, 0.0);\n    //color = log(1.0 + color);\n    \n    color = 1.0 / (1.0 + 1e-5 * color);\n    //color = exp(-1e-5 * color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 250, 306, 387, 504], [506, 648, 771, 771, 1264], [2208, 2283, 2322, 2322, 2808], [2811, 2811, 2876, 2876, 3415], [3417, 3417, 3474, 3524, 4348]], "test": "untested"}
{"id": "cdcfR8", "name": "Wild Spiral", "author": "martymarty", "description": "A more intense version of https://www.shadertoy.com/view/DsGcWd. The size and speed have wider ranges. The values are divided by length not area, so more snakes! Weird patterns appear at high sizes and speeds. Fewer characters too.", "tags": ["2d", "interactive", "blackandwhite", "animated", "golfing"], "likes": 3, "viewed": 218, "published": 3, "date": "1696824710", "time_retrieved": "2024-07-30T17:29:32.338700", "image_code": "//New version of https://www.shadertoy.com/view/DsGcWd with wider range of size, speed and more snakes.\n//Some golfing ideas from Fabrice Neyret, Cesium_137 change -3 chars\n//223 chars\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec4 m = 6.+iMouse;\n    float s = ceil(m.x), r, h;\n    p = floor(s*p/iResolution.y);\n    p.y > p.x ? h = 1., p = p.yx :p;\n    r = min(p.y, s-1.-p.x);\n    c = fract(vec4(4.*(r+h)*(s-r-h) + sign(.5-h)*(p.x+p.y-r-r))/s+.3*iTime*log(m.y));\n}\n\n//First 259 chars\n//Got my snake spiral idea down to a few lines so decided to do a golf version of it.\n//Original idea https://www.shadertoy.com/view/DtjBWR\n/* \nvoid mainImage( out vec4 c, in vec2 p )\n{\n    float s = ceil(m.x/40.0);\n    p = floor(s*p/iResolution.y);\n    float r = min(min(p.x,p.y),min(s-p.x-1.,s-p.y-1.));\n    float h = float(p.y>p.x);\n    c = fract(vec4(4.*(r+h)*(s-r-h) + sign(0.5-h)*(p.x+p.y-2.*r)+iTime*m.y)/(s*s-1.));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdcfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 227, 227, 469]], "test": "untested"}
{"id": "mdtfRr", "name": "diamboy's infinite cubes", "author": "Diamboy", "description": "infinite cubes\nthe sdf is slightly incorrect but it's good enough", "tags": ["raymarching"], "likes": 1, "viewed": 149, "published": 3, "date": "1696817867", "time_retrieved": "2024-07-30T17:29:33.209372", "image_code": "float sdf(vec3 p)\n{\n    p -= vec3(iTime * 0.31, iTime * 0.1, -1.01);\n    vec3 idx = round(p / 2.0);\n    p -= idx * 2.0;\n\n    float angle = iTime + idx.x + idx.y * 1.2 + idx.z * 2.3;\n    vec3 az = vec3(cos(angle), sin(angle), 1) * sqrt(0.5);\n    vec3 ax = normalize(cross(vec3(0,1,0), az));\n    vec3 ay = cross(az, ax);\n    vec3 q = vec3(dot(p, ax), dot(p, ay), dot(p, az));\n    vec3 r = abs(q);\n    return max(max(r.x, r.y), r.z) - 0.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv, 1));\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n        t += sdf(rd * t);\n    vec3 c = fract(vec3(0.45 / pow(t,0.3)));\n    fragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdtfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 438], [440, 440, 497, 497, 760]], "test": "untested"}
{"id": "sd2BWc", "name": "spqr: lit variable spheres", "author": "spqr", "description": "a", "tags": ["a"], "likes": 4, "viewed": 168, "published": 3, "date": "1696813916", "time_retrieved": "2024-07-30T17:29:34.151852", "image_code": "\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = sqrt(r);\n  return r + i;\n\n}\nfloat grid(vec3 p) {\n  \n  \n  vec3 p2 = p;\n  p2.y = (fract(p.y)-0.5);\n  float d = box(p2, vec3(10.0,0.2,0.05));\n  \n  p.x = (fract(p.x)-0.5);\n  \n  d = min(d, box(p, vec3(0.2,5,0.05)));\n  \n  return d;\n}\nfloat hash(vec3 p)  \n{\n    p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) );\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\nfloat sph(vec3 i, vec3 f, vec3 c) {\n    return length(f-c) - hash(i+c)*.3;\n}\nfloat spheres( in vec3 p )\n{\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n\n    \n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n\n}\n\nfloat map(vec3 p) {\n\n  // geo\n  \n \n  float d =  spheres(p);\n \n\n  \n  return d;\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*754.655+uv.yx*942.742),vec2(3847.554)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*472.355)*655.644);\n}\n\nfloat curve(float t) {\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), smoothstep(0.0,1.0,fract(t)));  \n}\n\n\n\n\nfloat shadow(vec3 p, vec3 l, float maxdist, int stepcount, float limit) {\n  float shad=1.0;\n  float dd=0.0;\n  for(int i=0; i<stepcount; ++i) {\n    float d=min(map(p), maxdist);\n    if(d<limit) {\n      shad=0.0;\n      break;\n    }\n    if(dd>=maxdist) {\n      break;\n    }\n  \n    p += l*d;\n    dd+= d;\n \n  }\n  return shad;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  \n  \n  \n  \n\n\n // vec3 r=normalize(vec3(-uv, 1));\n  \n  \n  // nav\n  \n  vec3 s =vec3(0,0,10);\n  s.xz *= rot(iTime * .1);\n  s.yz *= rot(iTime * .04);\n  s.yx *= rot(iTime * .061);\n  vec3 t = vec3(0,0,0);\n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,-1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  \n\n \n\n  \n  // march\n  \n  vec3 p=s;\n  float dd=0.0;\n  const float maxdist = 100.0;\n  \n  for(int i=0; i<100; ++i) {\n  \n    float d=map(p);\n    if(d<0.001) break;\n    if(dd>maxdist) { dd=maxdist; break;}\n    p+=r*d;\n    dd+=d;\n    \n  }\n  \n  \n  \n  // volume\n  \n  float rand=rnd(uv);\n  \n  vec3 lightpos = vec3(3);\n  vec3 lightfocus = vec3(3);\n  float lightangle = .1;\n \n  float t1 = tick(iTime);\n  float t2 = tick(iTime * .71);\n  float t3 = tick(iTime * .55);\n  lightpos.yz *= rot(t1);\n  lightpos.xz *= rot(t2);\n  lightpos.yx *= rot(t3);\n  \n  lightfocus.yz *= rot(t1 * .7);\n  lightfocus.xz *= rot(t2 * .8);\n  lightfocus.yx *= rot(t3 * .91);\n  \n\n\n  \n  const int volsteps=50;\n  float voldist = 15.0;\n  float stepsize = voldist/float(volsteps);\n  vec3 lr=r*stepsize;\n  vec3 lp=s + lr*rand;\n  float stepdist=rand*stepsize;\n  vec3 atcol=vec3(0);\n  \n  for(int i=0; i<volsteps; ++i) {\n  \n    if(stepdist>dd) {\n      break;\n    }\n    \n    vec3 lv = lightpos-lp;\n    float ldistvol = length(lv);\n    lv = normalize(lv);\n    float shadvol = shadow(lp, lv, ldistvol, 10, 0.01);\n    if ( dot( normalize(lv), normalize(lp) ) > -1.) {\n      atcol += 5./(0.01+(pow(ldistvol,1.5))) * shadvol;\n    }\n \n    lp+=lr;\n    stepdist+=stepsize;\n    \n  }\n \n \n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  vec3 l=normalize(lightpos - p);\n\n  float ldist = length(lightpos - p);\n\n  \n  float shad = shadow(p + n * 0.2, l, ldist, 30, 0.01);\n  \n  vec3 col=vec3(0);\n\n  col += atcol * .02;\n\n\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2BWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 70, 70, 119], [121, 121, 140, 140, 211], [214, 214, 237, 237, 315], [316, 316, 336, 336, 515], [516, 516, 538, 538, 641], [644, 644, 679, 679, 720], [721, 721, 749, 749, 1173], [1175, 1175, 1194, 1204, 1254], [1256, 1256, 1276, 1276, 1345], [1347, 1347, 1367, 1367, 1409], [1411, 1411, 1433, 1433, 1515], [1520, 1520, 1593, 1593, 1842], [1846, 1846, 1903, 1903, 3958]], "test": "untested"}
{"id": "cddBRr", "name": "Transparent Tri-Towers 🔺", "author": "SnoopethDuckDuck", "description": "🔺", "tags": ["fractal", "25d", "bw", "sierpinksi", "bitwise", "towers", "golf"], "likes": 18, "viewed": 256, "published": 3, "date": "1696811365", "time_retrieved": "2024-07-30T17:29:35.065410", "image_code": "vec4 getCol(ivec4 P) \n{\n    P = abs(P) % 99;\n    //P = abs(P*P.w/49) % 99;\n    return vec4(P ^ P.yzxw&P.zxyw) * (.6+.4*cos(float(P.w)));\n}\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float d,        // distance\n          acc,      // accumulator\n          inc = 1., // accumulator increment size\n          i,        // index\n          l,        // distance at hit position\n          t = iTime;\n    \n    vec2 R = iResolution.xy,\n         p; // 2.5D position\n    u = (u+u-R)/R.y;             \n         \n    ivec4 P; // integer positions for 3 (coplanar) axes, and int(d)\n    \n    vec4 col, \n         hitcol;\n    \n    bool hasHit = false;\n    \n    // use > 330. for more depth (and more lag!)\n    // alternatively, iterate with d and remove i\n    while(i++ < 330.)\n    {       \n        if ((abs((P.x^P.y^P.z)-P.w*3)) % 128 < int(d)) {\n            if (!hasHit) {\n                hasHit = true;\n                l = d;\n                hitcol = getCol(P);\n            }\n            inc *= .95; // accumulate less after every hit\n            acc += inc; \n             \n            // add to color (use weighted average)\n            col += inc * getCol(P);\n            \n            // less accumulation / iterations / lag\n            if (inc < .25)\n                break;            \n        }\n        p = u*d + 5.*t;\n        p += d*vec2(cos(.31*t), sin(.2*t));\n       \n        d += .15;\n             \n        P = ivec4(p.x,             // dot(p, dir(0))  \n                  .5*p.x+.866*p.y, // dot(p, dir(pi/3)) \n                  .5*p.x-.866*p.y, // dot(p, dir(-pi/3))\n                  d + 0.*iTime);\n    }              \n\n    o = mix(hitcol, col/acc, .5) / 1e2;\n    o = sqrt(o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cddBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 138], [140, 140, 176, 176, 1672]], "test": "untested"}
{"id": "cstBRr", "name": "test api key", "author": "tovernaar123", "description": "test api key", "tags": ["test"], "likes": 0, "viewed": 197, "published": 3, "date": "1696810172", "time_retrieved": "2024-07-30T17:29:35.827373", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cstBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "untested"}
{"id": "mdVcWK", "name": "RayMarching-PhongLightSimulation", "author": "mokasiri", "description": "rayMarching + spotlight source", "tags": ["raymarching"], "likes": 0, "viewed": 149, "published": 3, "date": "1696802367", "time_retrieved": "2024-07-30T17:29:36.731954", "image_code": "#define PI 3.14159265358979\n#define MAX_DIST 1000.\n#define MAX_STEPS 100\n#define SURFACE_DIST 0.01\n\nfloat random (vec2 st) \n{\n    return fract(sin(dot(st.xy,\n    vec2(12.9898,78.233)))*\n    43758.5453123);\n}\n\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0.0,1.,6.0, 1.0);\n    //sphere.xz += vec2(-sin(iTime) * 2., -cos(iTime) * 2.);\n    float sphereDist = length(p - sphere.xyz) - sphere.w; // distance to the sphere\n    \n    float planeDist = p.y; // distance to the plane \n    float dis = min(sphereDist, planeDist); // picking the smallest distance\n    return dis;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.0;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + d0 * rd; // blue points on the circles\n        float ds = GetDist(p);\n        d0 += ds;\n        if (ds < SURFACE_DIST || d0 > MAX_DIST) break;\n    }\n    return d0; // Returns the distance of the camera origin (based on the specific pixel) to the sphere of plane\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0.0);\n    vec3 dists = vec3(GetDist(p- e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx)); //\n    vec3 n = d - dists;\n    return normalize(n);\n}\n\n\nvec3 GetLight (vec3 p,vec3 ro){\n    vec3 MainlightDirection = vec3(.0, 1.0, .0); // for creating spot light\n    vec3 rgb = vec3(0.925,0.714,0.514); // light color\n    vec4 sphere = vec4(0.0, 1.0, 6.0, 1.0);\n    vec3 lightPos = vec3(0., 4., 5.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    //lightPos.y += 2. * iMouse.y;\n    //lightPos.x += 2. * iMouse.x;\n    float distance2light = length(lightPos - p);\n    vec3 lightDirection = normalize(lightPos - p);\n    //vec3 viewDirection = normalize(p - \n    ro = vec3(ro.x, ro.y, ro.z);\n    vec3 h = normalize((lightDirection + ro)/length(lightDirection + ro));\n    \n    vec3 n = GetNormal(p);\n    //float dif = dot(n,lightDirection);\n    float dif = clamp(dot(n,lightDirection), 0., 1.0); \n    \n    float d = RayMarch(p + n * SURFACE_DIST * 2.0, lightDirection); // distance from point p to the direction of light\n    // if we do not add any number value to the p, it will be smaller than SURFACE_DIST and the raymarching loop does not work\n    // addition of n (normal) ensures that the point does not go inside of the sphere.\n    //because if it goes inside of the sphere, it reaches the inner surface instantly and will be considered as being in the shadow\n    \n    // Implementing light sternght reduction based on distance\n    float kc = 0.1;\n    float kl = 0.1;\n    float kq = 0.01;\n    \n    \n    float spec = max(pow(dot(h,n),30.), 0.01);\n    dif += spec;\n    \n    /* Directional Light*/\n    float kWide = 1.2;\n    dif = dif * max(dot(MainlightDirection,lightDirection) * kWide, 0.0) /max(kc + kl * distance2light + kq * distance2light * distance2light, 1.0);\n    \n    /* Point Light */\n    //dif = dif/max(kc + kl * distance2light + kq * distance2light * distance2light, 1.0);\n    \n    \n    \n    \n    // shadow\n    if(d <length(lightPos - p)) dif *= 0.05; \n    if(length(p) < MAX_DIST) dif += 0.1; // Ambient Light, except points in far away (sky)\n    \n   // return dif;\n   return dif * rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * gl_FragCoord.xy - iResolution.xy)/ iResolution.y;\n    //vec2 p = vUv;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0.0, 1., 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    float d = RayMarch(ro,rd); // The distanse from the origin (based on pixel direction) to the collision point\n\n    vec3 p = ro + rd * d;   // The coordinate of the collision point based on the ray casted from camera origin (based on pixel direction)\n                            // another word: if you cast a ray from each pixel it will collid to a point,\n                            // the coordination of that specific point is 'vec3 p = ro + rd * d' which d was calculated by raymarching\n\n    vec3 dif = GetLight(p,ro);\n    col = dif;\n\n    //vec3 normcol = normalize(vec3(col));\n    //col = GetNormal(p);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 125, 125, 207], [210, 210, 232, 232, 571], [574, 574, 607, 607, 949], [952, 952, 976, 976, 1167], [1170, 1170, 1201, 1201, 3124], [3127, 3127, 3184, 3184, 4025]], "test": "untested"}
{"id": "ddcfzr", "name": "weirdlife", "author": "Retr0id", "description": "Inspired by https://github.com/andandandand/1d-continuous-cellular-automata\n\nresolution dependent, looks best at ~4k", "tags": ["automata"], "likes": 0, "viewed": 24, "published": 3, "date": "1696797556", "time_retrieved": "2024-07-30T17:29:37.689394", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 draw = texture(iChannel0, uv);\n    //draw.r = pow(draw.b, 0.9);\n    //draw.b = pow(draw.b, 0.8);\n    //fragColor = vec4(pow(draw.rgb, vec3(2.8)),1.);\n    fragColor = vec4(pow(cos(fract(draw.rgb*1.0)*3.14159265358979*2.0+3.14159265358979*0.5)*0.5+0.5, vec3(2.2)),1.);\n    //float val = smoothstep(1.0, 0.0, abs(fract(draw.x*10.0-iTime*1.0-fragCoord.x*0.019)-0.5) * 10.0);\n    //float val = smoothstep(1.0, 0.0, abs(fract(draw.x*10.0-iTime*1.0)-0.5) * 10.0);\n    //fragColor = vec4(vec3(val), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float PI = 3.1415926535;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1.5*1.618033988749;//+gaussian_rand(vec2(0.0,0.0))*0.1;\n    float sum = 0.0;\n    float divisor = 0.0;\n    float steps = 32.0;\n    float radius = 10.0;\n    // ensure symmetry\n    //fragCoord.y = fragCoord.y > iResolution.y / 2.0 ? iResolution.y - fragCoord.y: fragCoord.y;\n    for (float i=0.0; i<PI*2.0; i+=PI/steps) {\n        float weight = 1.0;//cos(i)+1.0;\n        sum += texture(iChannel0, (fragCoord.xy + vec2(sin(i)*radius, cos(i)*radius)) / iResolution.xy).x * weight;\n        divisor += weight;\n    }\n    float foo = sum/divisor;\n    float prev = texture(iChannel0, fragCoord.xy / iResolution.xy).x;\n    float interp = 1.0;\n    vec4 val = vec4(fract(foo*1.005)*interp+prev*(1.0-interp));\n    fragColor = iTime < 0.1 ? vec4(vec3(sin(fragCoord.x/50.0)*sin(fragCoord.y/60.0)+1.0),1.0) : vec4(val.rgb,1.0);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddcfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 610]], "test": "untested"}
{"id": "dscfzn", "name": "Triangle Towers ◀️ [225 Chars]", "author": "SnoopethDuckDuck", "description": "◀️ golfing welcome ◀️", "tags": ["fractal", "25d", "bw", "sierpinksi", "bitwise", "towers", "golf"], "likes": 20, "viewed": 238, "published": 3, "date": "1696790795", "time_retrieved": "2024-07-30T17:29:38.638855", "image_code": "// When changing, include \"&& d < 1e2\" in for loop\n// to avoid crash etc.\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec2 v = iResolution.xy,\n         d;\n         \n    ivec4 V;\n            \n    for(u = (u+u-v)/v.y; \n        ((V.x^V.y^V.z)-V.w) % 99 > V.w-99;\n        v = u*d +9.*iTime)\n        V = ivec4(v.x,              // dir 0\n                  .5*v.x+.866*v.y,  // dir pi/3\n                  .5*v.x-.866*v.y,  // dir 2pi/3\n                  d += .1);\n                  \n    V = abs(V) % 99;\n    o = vec4(V ^ V.yzxw&V.zxyw) * d.r/4e3;\n   // + .2*cos(4.*d.r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dscfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 111, 111, 563]], "test": "untested"}
{"id": "DdKyRR", "name": "The Ring Of Fire", "author": "zma", "description": "just can feel it.", "tags": ["darksouls"], "likes": 6, "viewed": 233, "published": 3, "date": "1696779985", "time_retrieved": "2024-07-30T17:29:39.542440", "image_code": "vec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\n\n#define OCTAVES 10\n#define PI 3.141592653589793\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 2.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * (noise(st));\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat squared(float a){\n\n    return a*a;\n}\n\n\nvec3 getColor(float c){\n    return vec3(1.5*c, c*c*c, c*c*c*c*c*c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 uv0 = 1.*uv;\n    \n     \n    //distorted uv0 to uv1\n    float n1 = fbm(uv0);\n    float n2 = fbm(uv - vec2(0., 1.*iTime));\n    vec2 uv1 = (uv0 + vec2(0.2*n1, 0.22*n1));\n            \n    //ring shape\n        \n    float radius = 0.7;\n    float c = abs(length(uv1) - radius);    \n    float m =fbm(uv1);\n    float f = 1.- smoothstep(0.0, 0.03, c);\n   \n       \n    //fire mod https://www.shadertoy.com/view/XsXSWS \n    \n    uv0= vec2(c); //attach fire mod to ring\n    vec2 timing = iTime*vec2(0.0,-1.);\n    float n = fbm(uv1+timing);\n    float e = 1. - 16. * pow( max( 0., length(uv0*vec2(2.8+uv0.y*1.5,.75) ) - n*max( 0., uv0.y+0.25 ) ),1.7);\n    float e1 = n * e * (1.5-pow(2.50*uv0.y,2.));\n\te1=1. - clamp(e1,0.,1.);\n    \n       \n    //Attach color\n    vec3 col = vec3(0.);\n    vec3 ring = getColor(f);\n    vec3 flame =mix(vec3(0.), getColor(0.7*e1), e);\n    \n    \n    col = (ring + flame);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 140], [143, 143, 169, 169, 627], [678, 678, 702, 724, 980], [982, 982, 1005, 1005, 1024], [1027, 1027, 1050, 1050, 1096], [1099, 1099, 1156, 1207, 2233]], "test": "untested"}
{"id": "cldXDN", "name": "Sound circle", "author": "fifa_s", "description": "Reacts to your mic.", "tags": ["2d", "sound", "circle", "microphone"], "likes": 3, "viewed": 284, "published": 3, "date": "1696778000", "time_retrieved": "2024-07-30T17:29:40.429069", "image_code": "float pi = 3.14159265358979;\n\nfloat w(float n) {\n    return cos(n*pi)*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    \n \n\n\n    vec2 tex = texture(iChannel0, vec2(uv.x/2.+1.,0.0)).xy;\n    float tx = tex.x;\n    float ty = tex.y;\n    \n\n    float d = length(suv);\n    \n    d /= tx;\n    \n    vec3 c = vec3(\n        w(uv.x+t),\n        w(uv.x+t+1.3),\n\n        w(uv.x+t+1.6)\n    );\n    \n    if (abs(d)>0.8) {\n        c /= (d*d*d*d*d*d);\n        //c = vec3(0.0);\n    };\n\n \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cldXDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 48, 48, 80], [82, 82, 139, 139, 665]], "test": "untested"}
{"id": "fd2czG", "name": "Year of Truchets #056", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n \nturn AA on (AA=2)", "tags": ["raymarching", "refraction", "truchet", "aa"], "likes": 14, "viewed": 207, "published": 3, "date": "1696766239", "time_retrieved": "2024-07-30T17:29:41.406456", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #056\n    10/08/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n// AA 1 = OFF 2 = ON > depending on GPU <\n#define ZERO (min(iFrame,0))\n#define AA 1\n// AA\n\n#define R    \t\tiResolution\n#define T \t    \tiTime\n#define M \t    \tiMouse\n\n#define PI          3.141592653\n#define PI2         6.283185307\n\n#define MIN_DIST    1e-5\n#define MAX_DIST    25.\n\nmat2 flip,turn,r90;\n\nconst vec3 size = vec3(1.);\nconst vec3 hlf =  size/2.;\nconst vec3 bs = vec3(hlf);\nconst vec3 grid = vec3(2,1,2);\nconst float thick = .12;\n\nfloat speed=0.,tspeed=0.,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nmat2 cam;\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(23.53,84.21+iDate.z)))*4832.3234); }\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat trs( vec3 p,vec2 t){\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 q1,q2,q3;\nfloat trh,trx,jre;\nconst float bg = .035;\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n\n    p.yz*=flip; p.xz*=turn;\n\n    vec3 q = p;\n\n    vec3 id = floor((q + hlf)/size)-grid;\n    float chk = mod(id.y+mod(id.z+id.x,2.),2.)*2.-1.;\n    \n    q = q-size*clamp(round(q/size),-grid,grid);\n    \n    float hs = hash21(id.xz+id.y);\n\n    if( hs>.5) q.xz*=r90;\n    if(chk>.5) q.zy*=r90;\n    \n    float sn = mod(hs,5.)*5.;\n    float t1 = lsp(sn,sn+2.,tmod);\n    float t2 = lsp(sn+8.,sn+10.,tmod);\n    \n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    \n    cam=rot((t1-t2)*1.5707);\n    \n    if(chk>.5) { q.zx*=cam; } else { q.xy*=cam; }\n    \n    float xhs = fract(2.31*hs+id.y);\n\n    q1 = vec3(q+vec3(0,hlf.x,-hlf.y)).yxz;\n    q2 = q+vec3(hlf.x,0,hlf.z);\n    q3 = vec3(q-vec3(hlf.xy,0)).yzx;\n\n    \n    trh = trs(q1,vec2(hlf.x,thick));\n    trx = trs(q2,vec2(hlf.x,thick));\n    jre = trs(q3,vec2(hlf.x,thick));\n\n    float cut = box(q,bs*.90);\n\n    trh=max(abs(trh)-bg,trh);\n    jre=max(abs(jre)-bg,jre);\n    trx=max(abs(trx)-bg,trx);\n    \n    trh=max(trh,cut);\n    jre=max(jre,cut);\n    trx=max(trx,cut);\n    \n    if(trh<res.x ) {\n        res = vec2(trh,2.);\n    } \n    if(jre<res.x ) {\n        res = vec2(jre,4.);\n    }\n    if(trx<res.x ) {\n        res = vec2(trx,6.);\n    } \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//@iq hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.)-3.)-1., 0., 1. );\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(2,-9,7);\n    vec3 l = normalize(lpos);\n    float diff = clamp(dot(n,l),.0,1.);\n    vec3 h = m==1.? vec3(.15) : hsv2rgb(vec3((T*.015)+(m*.075),.7,.3))*.35;\n    return h*diff;\n}\n\nvec3 render(in vec2 uv, in vec2 F )\n{    \n    vec3 C = hsv2rgb(vec3(T*.015,.7,.3))*.25;\n    vec3 ro = vec3(0,0,4.25),\n         rd = normalize(vec3(uv,-1));\n    \n    tspeed = T*.6;\n    tmod = mod(tspeed,25.);\n\n    // bounces - set lower if slow 10. to 5.\n    float b = 7.;\n\n    vec3  p = ro + rd * .1;\n    float atten = 1., k = 1., iv = 1., alpha = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<128;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n\n        float d = i<42? ray.x*.25: ray.x*.65;\n        float m = ray.y;\n\n        p += rd * d * k;\n        \n        if (d*d < 1e-7) {\n            C+=shade(p,rd,d,ray.y,n)*atten;\n\n            b -= 1.;\n            if(b<1.) break;\n            \n            atten *= .8;\n            p += rd* .02;\n            k = sign(map(p).x);\n        \n            vec3 rf=refract(rd,n,iv>0.?.875:1.1);\n            iv *= -1.;\n            \n            if(length(rf) == 0.) rf = reflect(rd,n);\n            \n            rd=rf;\n            p+=-n*.001;\n        } \n        if(distance(p,rd)>45.) { break; }\n    }\n    \n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    // mouse //\n    float x = M.xy==vec2(0) ? .0 : (M.y/R.y * .5-.25)*PI2;\n    float y = M.xy==vec2(0) ? .0 : (M.x/R.x * 1.-.5)*PI2;\n\n    flip=rot(x-T*.075);\n    turn=rot(y+T*.05);\n    r90=rot(1.5707);\n\n    vec3 C = vec3(0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5;\n        vec2 uv = (-R.xy + 2.*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.*F)/max(R.x,R.y);\n#endif\n        vec3 color = render(uv,F);       \n        color = 1.35*color/(1.+color);\n        C += color;\n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    C = pow(clamp(C,0.,1.), vec3(.4545));\n\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2czG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[786, 786, 804, 804, 849], [850, 850, 871, 871, 936], [937, 937, 974, 974, 1008], [1009, 1009, 1028, 1028, 1055], [1057, 1057, 1082, 1082, 1167], [1169, 1169, 1195, 1195, 1264], [1323, 1323, 1340, 1340, 2584], [2586, 2655, 2700, 2700, 2923], [2925, 2939, 2966, 2966, 3079], [3081, 3081, 3142, 3142, 3363], [3365, 3365, 3402, 3402, 4513]], "test": "untested"}
{"id": "DsVcDt", "name": "Phong Shaded Sphere (268 chars)", "author": "Nguyen2007", "description": "Based on https://scratch.mit.edu/projects/364538564", "tags": ["3d", "phong", "ball", "short"], "likes": 8, "viewed": 219, "published": 3, "date": "1696761168", "time_retrieved": "2024-07-30T17:29:42.320013", "image_code": "// -5 chars thanks to Fabrice\n// -1 chars thanks to SnoopethDuckDuck\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 R = iResolution.xy, p = 1.2 * (I + I - R) / R.y;\n    \n    #define l(d) pow(max(dot(vec3(p, sqrt(max(1. - dot(p, p), 0.))), d), 0.), 2.)\n    O = (abs(p.x) < 1.6 ? 1.4 : 0.) * sin(atan(sqrt(vec4(2, .7, .2, 0) * l(vec3( 2, 1,  3))\n                                                  + vec4(1,  4,  4, 0) * l(vec3(-1, 2, -2))) / (1. + dot(p, p) * .36)) / 2.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 106, 106, 471]], "test": "untested"}
{"id": "NdjyDy", "name": "spqr decal tangled", "author": "spqr", "description": "a", "tags": ["a"], "likes": 5, "viewed": 146, "published": 3, "date": "1696750979", "time_retrieved": "2024-07-30T17:29:43.218610", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the  and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat pi = 3.141592;\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\n\n\n\nvec2 replim( in vec2 p, in float c, in vec2 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\nfloat cube( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return max(q.x,q.y);\n}\n\nfloat m1(vec3 uv, vec3 d, float f1) {\n  \n \n  \n  \n  float t = iTime ;\n  float a = 3.141592/4.;\n  \n  \n  float thing = 10000.;\n  \n  for( float i = 0.; i <5.; i++){\n  \n    uv.xz *= rot(i * a * 2.);\n   \n    uv = abs(uv); \n    uv -= vec3(2.,4.1,7.3);\n    uv = -abs(uv);\n   \n    float f2 = 1.;//f1 * 2.;\n    float x1 =  cube(uv.xz , vec2(1,1));\n    float x2 =  cube(uv.xz + vec2(2,11)+f2, vec2(1.,5.));\n    float x3 =  cube(uv.xz + vec2(14,14)-f2, vec2(.2,53.));\n    vec2  q  =    replim(uv.xz, 10., vec2(11,2));\n    float x4 =  cube(q , vec2(.2,2.));\n   \n    float x = min(x4,min(x1,(min(x2,x3))));\n    \n    thing = min(thing,x);\n   \n    \n \n\n  }\n  return thing ;\n\n}\n/*\nfloat hash31(vec3 p)\n{   \n  \n\tvec3 p3  = fract(vec3(p.xyx) * 223.531);\n    p3 += dot(p3, p3.yzx + 313.153);\n    return fract((p3.x + p3.y) * p3.z);\n}\n*/\n\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\nfloat a = 3.141592;\n\n\nfloat m2(vec3 uv, vec3 d, float f1) {\n\n  \n \n  \n  float q = 1.21;\n  \n  float z = 10000.;\n  vec3 off = vec3(58.,0.,20.);\n  for (float i = 0.; i <5.; i++) {\n    off.xz *= rot(i/(4.));\n   \n    uv.xz *= q + (f1/10.) * 3.14 ;\n    \n   \n    \n    uv.xz *= rot(a/2.);\n    \n    \n    float a1 =m1(uv  + off, d, f1 );\n    z = min(z,a1);\n  \n  }\n \n  return z;\n}\n\nfloat decal(vec3 p,vec3 d) {\n \n   vec3 id = floor(p / d);\n   p =  mod(p,d) - p/2.;\n   float f1 = hash31(id);\n\n\n  return m2(p,d,f1);\n\n}\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(floor(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\n\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\n\n\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nint matter = 0;\n// ddd\nvec3 domain = vec3(100, 10., 100);\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\nfloat hash21(vec2 p) {\n    float a = sin(p.x*1831.424)*9918.3232;\n    float b = sin(p.y*4254.001)*7742.4342;\n\n    float d = fract(a+b);\n    float e = sin(d * 4225.2421) * 9003.131;\n    return fract(e);\n\n}\n\nfloat box(vec3 p, float w, float h) {\n\n  vec3 b = vec3(w,w,h);\n  vec3 q = abs(p) - b;\n  return max(q.x,max(q.y,q.z)) ;\n\n}\n\nfloat spires(vec3 p) {\n\n  \n\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n   \n    vec2 dom = vec2(1.);\n     \n      \n    vec2 id = floor(p.yx/dom);\n    float f1 = hash21(id);\n    \n\n    float widthlimit = .4;\n    float heightlimit = 200.;\n    \n  \n    float factor = f1;\n\n    factor = 1. - f1;\n    factor = pow(factor,.8);\n  \n    \n    //float me   = cyl(p - vec3(center, 0),    widthlimit, heightlimit * pow(f1,5.) );\n    //float next = cyl(p - vec3(neighbour, 0), widthlimit, heightlimit );\n    \n    float me   = box(p - vec3(center, 0),    widthlimit, heightlimit * factor) ;\n    float next = box(p - vec3(neighbour, 0), widthlimit, heightlimit);\n    return min(me, next);\n}\nfloat box3d( vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return max(max(p.x,p.y),p.z);\n}\nfloat map(vec3 p) {\n\n// geo\n  \n  //p.xz = abs(p.xz) - 10.;\n\n  p = mod(p, domain) - domain/2.;\n \n  float level = box3d(p, vec3(domain.x, .1, domain.z));\n  return level;\n  \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat sss(vec3 p, vec3 l, float d) {\n  return smoothstep(0.0,1.0,map(p+l*d)/d);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat tick (float t) {\n  float i = floor(t);\n  float r = fract(t);\n  for (int z = 0; z < 1; z++) {\n    r = smoothstep(0.,1.,r);\n  }\n  \n  return i + r;\n}\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat hash11 (float t) {\n  return fract(sin(t * 4551.7749) * 3561.582);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n   float tt = iTime;\n  \n\n  // nav\n  vec3 s = lattice(tt     ) * 277.;\n  vec3 t = lattice(tt + 3.) * 122.;\n  //vec3 s = vec3(0,iTime * 40., 0.);\n  //vec3 t = s + vec3(0.4,1.0,0.4);\n\n\n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n \n  float mask=1.0;\n  float d = 0.;\n  float dd = 0.;\n  float rand=rnd(uv); \n  \n\n  // march\n  \n  bool hit = false;\n  float i;\n  for(float z=0.; z < 400.; ++z) {\n    i = z;\n    d=map(p);\n    \n   if(d<0.01) {\n   \n      float ii = decal(p, domain);\n      \n      if (ii >= 0.0) {\n          d=0.1;\n      } else {\n          hit = true;\n          break;\n      }\n    }\n    \n    if ( dd > 5000.) {\n      break;\n    }\n    \n    dd += d;\n    p+=r*d;\n  }\n  \n  // hue\n  \n  vec3 col;\n  \n  \n  if (! hit ) {\n \n     col = vec3(.5);\n     \n  } else {\n\n     col = vec3(0);\n\n     float ii = decal(p, domain);\n  \n     if ( ii < 0.0) {\n          col = vec3(0);\n     }\n     if ( ii < -0.14) {\n        col = vec3(.8, .5, .2);\n     }\n\n\n    }\n    //vec3 fog = vec3(.5);\n    //col = mix(col, fog, exp(-.000003 * dd * dd * dd));\n  \n  \n    fragColor = vec4(col, 1);\n\n\n\n \n  \n}\n\n/*\n\n  \n     //vec3 light =normalize(vec3(4,12.,2.));\n     //light.xz *= rot(iTime);\n\n     //light = abs(light);\n  \n \n     //vec3 n = norm(p);\n  \n     //float diff = max(0.0,dot(n,light)*0.5+0.5);\n     //float fren = pow(1.+dot(n,r),2.);\n     //float sss = sss(p,r,4.) * 2.;\n     //float spec= pow(max(dot(reflect(-light,n),-r),.0), 10.) * 5.;\n      //loat shad = shadow(p, normalize(-light), .1, length(light-p));\n     //float fog =  pow(i/1000.,2.);\n  \n   \n     //col -= diff  * .7;\n*/\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[348, 348, 367, 367, 436], [438, 438, 459, 459, 508], [513, 513, 560, 560, 606], [607, 607, 637, 637, 685], [687, 687, 724, 724, 1346], [1543, 1543, 1566, 1566, 1681], [1704, 1704, 1741, 1741, 2050], [2052, 2052, 2080, 2080, 2186], [2188, 2188, 2215, 2215, 2283], [2285, 2285, 2313, 2313, 2337], [2339, 2339, 2381, 2381, 2488], [2490, 2490, 2518, 2518, 2544], [2546, 2546, 2574, 2574, 2607], [2610, 2610, 2657, 2657, 2703], [2707, 2707, 2748, 2748, 2916], [2919, 2919, 2940, 2940, 3231], [3233, 3233, 3252, 3252, 3360], [3362, 3362, 3401, 3401, 3478], [3480, 3480, 3516, 3516, 3594], [3596, 3596, 3616, 3616, 3710], [3713, 3713, 3737, 3737, 3792], [3797, 3797, 3822, 3822, 4291], [4351, 4351, 4370, 4370, 4516], [4517, 4517, 4539, 4539, 4721], [4723, 4723, 4760, 4760, 4844], [4846, 4846, 4868, 4868, 5560], [5561, 5561, 5591, 5591, 5647], [5648, 5648, 5667, 5706, 5820], [5822, 5822, 5841, 5841, 5960], [5962, 5962, 6003, 6003, 6049], [6051, 6051, 6087, 6087, 6132], [6134, 6134, 6154, 6154, 6197], [6199, 6199, 6218, 6218, 6297], [6299, 6299, 6321, 6321, 6451], [6452, 6452, 6509, 6509, 6604], [6606, 6606, 6630, 6630, 6680], [6681, 6681, 6738, 6738, 8103]], "test": "untested"}
{"id": "cdKyWd", "name": "KawaseBlur-test", "author": "nomkcode_g", "description": "对距离当前像素越来越远的地方对四个角进行采样，利用4个buffer实现5次迭代", "tags": ["kawaseblur"], "likes": 0, "viewed": 163, "published": 3, "date": "1696750655", "time_retrieved": "2024-07-30T17:29:43.980573", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float pixelOffset = 0.0;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col = col * 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float pixelOffset = 0.0;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col = col * 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float pixelOffset = 0.0;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col = col * 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float pixelOffset = 0.0;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col = col * 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float pixelOffset = 0.0;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, pixelOffset + 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(-pixelOffset - 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col += texture(iChannel0, uv + vec2(pixelOffset + 0.5, -pixelOffset - 0.5) / iResolution.xy).rgb;\n    col = col * 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 696]], "test": "untested"}
{"id": "7sffDX", "name": "Exact Dual Polyhedron SDF", "author": "mla", "description": "Dual polyhedra with an exact SDF - each fundamental region gives rise to a single triangular face. Use mouse to adjust face position. For other controls, see code.", "tags": ["dual", "polyhedron", "wythoff"], "likes": 25, "viewed": 218, "published": 3, "date": "1696750555", "time_retrieved": "2024-07-30T17:29:44.793400", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wythoff construction for dual polyhedra, with an exact SDF.\n// Matthew Arcus, mla, 2023\n//\n// https://en.wikipedia.org/wiki/Wythoff_construction\n//\n// Controls:\n// Mouse control is modal: rotation mode applies a rotation,\n// configuration mode sets face position. Key 'x' toggles\n// between modes. 'a' sets animation mode when the face\n// configuration is automatic, so mouse mode is always\n// rotation.\n// <up>/<down>: zoom\n// a: animation mode (ignore mouse setting)\n// e: show edges\n// f: color edges\n// m: mirror faces\n// r: rotation\n// s: exploded view\n// x: toggle mouse mode between rotation & configuration\n//\n// Uses exact distance to triangular faces (or subdivisions of faces) \n// rather than distance to face planes, enabling, eg. SDF rounding\n// to work.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat maxdist = 10.0;\nfloat lradius = 0.05;\nbool coloredges = true;\nbool doedges = false;\n\n// Any P,Q,R with 1/P + 1/Q + 1/R > 1, which means:\n// 2:2:2, 3:2:2, 4:2:2, ...\n// 3:3:2, 4:3:2, 5:3:2\nint P = 2, Q = 3, R = 5;\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (5 3 2) or (10 2 2)\nint NFOLDS = 5;\n\n// Types of feature\nint FACE0 = 0;\nint FACE1 = 1;\nint EDGE = 2;\n\n// 3 mirror planes (passing through origin) define a fundamental\n// region, which intersects the unit sphere in a spherical\n// triangle with angles PI/P, PI/Q, PI/R.\nmat3 ABC;    // normal vectors for mirror planes\nmat3 abc;    // dual vertices\nvec3 vertex; // centre point of region\nvoid initgeometry() {\n  // Setup folding planes\n  float p = PI/float(P);\n  float q = PI/float(Q);\n  float r = PI/float(R);\n  // |A| = |B| = |C| = 1\n  // A.B = -cos(p)\n  // A.C = -cos(r)\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  vec3 A = vec3(1,0,0);\n  vec3 B = vec3(-cos(p),sin(p),0);\n  float x = -cos(r);\n  float y = -(cos(p)*cos(r)+cos(q))/sin(p);\n  float z = sqrt(1.0-x*x-y*y);\n  vec3 C = vec3(x,y,z);\n  ABC = mat3(A,B,C);\n  // Convert trilinear to cartesian coordinates\n  vec3 trilinear = vec3(1,1,1);\n  vertex = normalize(mat3(cross(B,C),cross(C,A),cross(A,B))*trilinear);\n\n  // abc is basically inverse(ABC), but with normalized columns\n  vec3 a = normalize(cross(B,C));\n  vec3 b = normalize(cross(C,A));\n  vec3 c = normalize(cross(A,B));\n  vec2 params = 1.0+sin(0.1*iTime*PI*vec2(1,0.618));\n  if (!key(CHAR_A)) {\n    vec2 mouse = store(CHAR_X,2).zw; // Default setting\n    if (mouse.x > 0.0) params = 4.0*mouse.xy/iResolution.xy;\n  }\n  b *= params.x; c *= params.y;\n  abc = mat3(a,b,c);\n}\n\n// Adapted from function by iq: https://www.shadertoy.com/view/ttfGWl\n// Return square of the distance to the triangle.\nfloat triangleDistance2(vec3 p, mat3 abc, out bool isedge) {\n  vec3 v0 = abc[0], v1 = abc[1], v2 = abc[2];\n  vec3 v10 = v1-v0; vec3 p0 = p-v0;\n  vec3 v21 = v2-v1; vec3 p1 = p-v1;\n  vec3 v02 = v0-v2; vec3 p2 = p-v2;\n  vec3 n = cross(v10,v02);\n  // If we are outside the triangle (one of the triple products is negative)\n  // then the closest point might be on any of the edges.\n  isedge = doedges || triple(p0,v10,n) < 0.0 || triple(p1,v21,n) < 0.0 || triple(p2,v02,n) < 0.0;\n  if (isedge) return min(segment2(p0,v10),min(segment2(p1,v21),segment2(p2,v02)));\n  return length2(n*dot(n,p0)/dot(n,n));\n}\n\nfloat scene(vec3 pos, int parity, out int type, out vec2 uv) {\n  uv = pos.xy + pos.yz;\n  if (key(CHAR_S)) pos -= (1.0+sin(iTime))*vertex;\n  bool isedge;\n  float d = sqrt(triangleDistance2(pos,abc,isedge))-lradius;\n  type = parity%2 == 0 ? FACE0 : FACE1;\n  if (coloredges && isedge) type = EDGE;\n  return d;\n}\n\nvec3 fold(vec3 pos,out int parity) {\n  vec3 A = ABC[0], B = ABC[1], C = ABC[2];\n  parity = 0;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A);\n    int parity0 = 0;\n    parity0 += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*A;\n    k = dot(pos,B);\n    parity0 += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*B;\n    k = dot(pos,C);\n    parity0 += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*C;\n    if (parity0 == 0) break;\n    parity += parity0;\n  }\n  return pos;\n}\n\nfloat map(vec3 pos, out int type, out int parity, out vec2 uv) {\n  pos = fold(pos,parity);\n  return scene(pos,parity,type,uv);\n}\n\nfloat map(vec3 pos) {\n  int type, parity; vec2 uv;\n  return map(pos,type,parity,uv);\n}\n\n// Tetrahedron technique, from:\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) {\n  float h = 0.001;\n  vec2 k = vec2(1,-1);\n  return normalize( k.xyy*map( p + k.xyy*h ) + \n                    k.yyx*map( p + k.yyx*h ) + \n                    k.yxy*map( p + k.yxy*h ) + \n                    k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float precis = 0.001;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 200; i++) {\n    //assert(i < 30);\n    if (t > maxdist) break;\n    float h = map(ro+rd*t);\n    if (key(CHAR_Z) && h < precis) break;\n    t += h;\n    if (h < precis) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  vec2 mouse = iMouse.xy;\n  if (!key(CHAR_A)) mouse = store(CHAR_X,2).xy;\n  if (mouse.x > 0.0) {\n    float theta = (2.0*mouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*mouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    //p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 basecolor(int type) {\n  if (type == FACE0) return vec3(1,1,0.5);\n  if (type == FACE1) return vec3(1,0.25,0.25);\n  if (type == EDGE) return vec3(0.2);\n  return vec3(1,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  doedges = key(CHAR_E);\n  coloredges = key(CHAR_F);\n  vec3 ro = vec3(0,0,camera);\n  vec3 rd = vec3(uv, -2);\n  vec3 light = vec3(0.5, 0.8, 3.0);\n  ro = transform(ro);\n  rd = transform(rd);\n  light = transform(light);\n  light = normalize(light);\n  rd = normalize(rd);\n  initgeometry();\n  vec3 col = vec3(0);\n  //col = texture(iChannel1,uv).xyz; col = pow(col,vec3(2.2));\n  float t = march(ro, rd);\n  if (t < maxdist) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    int type, parity;\n    vec2 uv;\n    map(pos,type,parity,uv);\n    if (key(CHAR_M)) {\n      col = texture(iChannel0,reflect(rd,n)).xyz;\n    } else {\n      col = basecolor(type);\n      col *= texture(iChannel1,uv).xyz;\n      float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      col *= 0.2 + 0.8*diffuse;\n      float specular = pow(max(0.0,dot(reflect(light,n),rd)),10.0);\n      col += 0.3*specular*vec3(1);\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 map(vec2 screenpos) {\n  return (2.0*screenpos-iResolution.xy)/iResolution.y;\n}\n\nvec2 initselection(int i) {\n  return vec2(0);\n}\n \nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2) {\n    if (key(i)) t.xy = iMouse.xy;\n    else t.zw = iMouse.xy;\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse down\n        for (int i = 1; i <= 4; i++) {\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < 0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI\t= 3.14159265359;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat length2(vec3 p) {\n  return dot(p,p);\n}\n\n// Perpendicular distance from p to segment from origin to b\nfloat segment2(vec3 p, vec3 b) {\n  float t = dot(p,b)/dot(b,b);\n  t = clamp(t,0.0,1.0);\n  return length2(p-t*b);\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment2(vec3 p, vec3 a, vec3 b) {\n  return segment2(p-a,b-a);\n}\n\n// Triple product\nfloat triple(vec3 p,vec3 q, vec3 r) { return dot(cross(p,q),r); }\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_SHIFT = 16;\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sffDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1341, 1625, 1646, 1672, 2625], [2627, 2747, 2807, 2807, 3346], [3348, 3348, 3410, 3410, 3656], [3658, 3658, 3694, 3694, 4128], [4130, 4130, 4194, 4194, 4258], [4260, 4260, 4281, 4281, 4346], [4348, 4426, 4451, 4451, 4687], [4689, 4689, 4726, 4726, 5004], [5006, 5006, 5033, 5033, 5439], [5441, 5441, 5467, 5467, 5619], [5621, 5621, 5678, 5678, 6813]], "test": "untested"}
{"id": "DdVyDt", "name": "TiltShiftBlur-IrisBlur-test", "author": "nomkcode_g", "description": "移轴模糊与光圈模糊，通过mask与全屏图像模糊算法配合，获得对应效果。\n", "tags": ["tiltshiftblur", "irirblur"], "likes": 0, "viewed": 194, "published": 3, "date": "1696748357", "time_retrieved": "2024-07-30T17:29:45.868526", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 accumulator = vec3(0.0);\n    vec3 divisor = vec3(0.0);\n    \n    float r = 1.0;\n    // 移轴模糊和光圈模糊的偏移\n    //float my = 1.0-2.0*iMouse.y/iResolution.y;\n    vec2 mxy = 1.0-2.0*iMouse.xy/iResolution.xy;\n\n    // 移轴模糊和光圈模糊的角度\n    //vec2 angle = vec2(0.0, _Radius * saturate(TiltShiftMask(uv, my)));\n    vec2 angle = vec2(0.0, _Radius * saturate(IrisMask(uv, mxy)));\n    for (int j = 0; j < _Iteration; j ++)\n    {\n        r += 1.0 / r;\n        angle = angle * _Rot;\n        vec3 bokeh = texture(iChannel0, uv + (r-1.0)*angle/vec2(iResolution.x, iResolution.y)).rgb;\n        accumulator += bokeh * bokeh;\n        divisor += bokeh;\n    }\n    vec3 col = accumulator / divisor;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat2 _Rot = mat2(cos(2.39996323), sin(2.39996323), -sin(2.39996323), cos(2.39996323));\nfloat _Offset = 0.0;\nfloat _Area = 1.0;\nfloat _Spread = 1.2f;\nint _Iteration = 32;\nfloat _Radius = 2.0;\n\n\nfloat TiltShiftMask(vec2 uv, float offset)\n{\n    float centerY = uv.y * 2.0 - 1.0 + offset;\n    return pow(abs(centerY * _Area), _Spread);\n}\n\nfloat IrisMask(vec2 uv, vec2 offset)\n{\n    vec2 center = uv * 2.0 - 1.0 + offset;\n    return dot(center, center)*_Area;\n}\n\nfloat saturate(float r)\n{\n    if(r<0.0){\n        return 0.0;\n    }\n    if(r>1.0){\n        return 1.0;\n    }\n    return r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 930]], "test": "untested"}
{"id": "msGyRV", "name": "Fractal of Julia", "author": "domrally", "description": "Click & drag to rotate color wheel!\nGenerated by squaring a complex number repeatedly. White boundary between frag positions starting stable orbits & ones diverging to infinity.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]", "tags": ["orbit", "derivative", "complex", "dual", "trap", "imaginary", "automatic", "differential", "chaotic"], "likes": 10, "viewed": 178, "published": 3, "date": "1696747248", "time_retrieved": "2024-07-30T17:29:46.794051", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nComplex arithmetic.\n*/\nvec2 power(vec2 a, float b) { \n    float angle = atan(a.y, a.x);\n    vec2 direction = vec2(\n        cos(b * angle), \n        sin(b * angle) \n    ); \n    \n    return direction * pow(dot(a, a), b / 2.);\n}\nvec2 divide(vec2 a, vec2 b)  { \n    vec2 dividend = vec2( \n        dot(a, b), \n        dot(vec2(a.y, -a.x), b)\n    );\n    \n    return dividend / dot(b, b);\n}\nvec2 multiply(vec2 a, vec2 b) { \n    return vec2( \n        a[0] * b[0] - a[1] * b[1], \n        a[0] * b[1] + a[1] * b[0]\n    ); \n}\n\n\n/*\nDifferential multiplication.\n*/\nmat4x2 multiply(mat4x2 a, mat4x2 b) {\n    mat4x2 products;\n    int degree, i, j;\n    // Wedge product.\n    for (; degree < 4; degree++) {\n        for (i = 0; i <= degree; i++) {\n            j = degree - i;\n            // Differential product rule.\n            products[degree] += multiply(a[i], b[j]);\n        }\n    }\n    \n    return products;\n}\n\n\n/*\nBöttcher's Map\n*/\nvec2 bottcher(vec2 a, vec2 b, float count) {\n    vec2 base = divide(a, a - b);\n    float exponent = pow(.5, count);\n    return power(base, exponent);        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Zoom pixel space to view space\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvStart = 2.2 * (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvEnd = (uvStart * .03) + vec2(.4, .5);\n    vec2 uvMouse = 2. * iMouse.xy - iResolution.xy;\n    uv = mix(uvStart, uvEnd, .5 - .5 * cos(iTime / 4.));\n    \n    // 4th order differential supernumbers as higher order differential forms\n    mat4x2 orbit, offset;\n    vec2 mapped;\n\n    // Rules for mandelbrot set\n    orbit[0] = mapped = uv;\n    // Image space is a linear grid, so it has constant 1st order derivatives.\n    // No higher order derivatives (those grow while orbiting).\n    orbit[1] = vec2(1.);\n    \n    float time = 1.3 + iTime / 2.;\n    float r = .618;\n    offset[0] = vec2(\n        r * cos(time),\n        r * sin(time)\n    );\n    \n    // Simulate the trajectory for this pixel relative to the center of the image.\n    vec2 trapped;\n    float radius = 9e9;\n    for (float i; i < 47.; i++) {\n        // This recursion generates chaotic behavior\n        orbit = multiply(orbit, orbit) + offset;\n        // Track coordinate deformation\n        mapped = multiply(mapped, bottcher(orbit[0], offset[0], i));\n        // We want to record the nearest approach as the pixel orbits around the image center.\n        float flyby = dot(orbit[0], orbit[0]);\n        radius = min(radius, flyby);\n        // The closest point is called the orbit trap.\n        trapped = trapped * float(radius != flyby) + float(radius == flyby) * orbit[0];\n        // Stop in case of overflow\n        if(flyby > 9e7) break;\n    }\n    \n    // The derivatives need to be scaled by their binomial taylor coefficients\n    vec4 differentials = vec4(\n        length(orbit[0]),\n        length(orbit[1]),\n        2. * length(orbit[2]),\n        6. * length(orbit[3])\n    );\n    \n    // The solution curve is everywhere flat.\n    // This means that the ratios of the derivatives should be \n    // the same for all degrees when we are close to the solution.\n    vec3 estimates = vec3(\n        differentials[0] / differentials[1], \n        differentials[1] / differentials[2], \n        differentials[2] / differentials[3]\n    );\n    // Weight by relative convergence rate\n    vec3 weights = vec3(2., 3., 4.);\n    // Combine for smoother distance estimate.\n    float est = dot(estimates, weights) / dot(weights, vec3(1.));\n    // Distance = log|f| |f|/|f'|\n    float dist = est * log(differentials[0]);\n    float lightness = smoothstep(1.3, 0., pow(dist, .1));\n    // Grid\n    float approach = length(trapped);\n    float scale = 64.;\n    float grid = .5 + .5 * pow(clamp(max(cos(scale * mapped.x), cos(scale * mapped.y)), 0., 1.), 99.);\n    float outside = float(lightness > 0.);\n    lightness = outside * mix(lightness, 2.2 * lightness, grid * smoothstep(0., 1.4, log(approach)));\n    // Highlight the chaotic tree structure inside the fractal\n    float inside = float(dist < 0. || lightness <= 0.);\n    lightness += inside * smoothstep(.8, .0, approach);\n    lightness = clamp(lightness, 0., 1.);\n    // Find the angle of closest approach of the orbit trap\n    float angle = atan(trapped.y, trapped.x);\n    // Match the angle to the color wheel\n    float hue = angle - atan(uvMouse.y, uvMouse.x) + iTime;\n    // The pixel gets greyer the farther the orbit trap\n    float chroma = mix(.95, .3, smoothstep(0., 3., approach));\n    \n    // Paint the pixel\n    fragColor.rgb = oklch2rgb(lightness, chroma, hue);\n    fragColor.a = 1.;\n}\n\n\n/*\nREFERENCES\n\ncolor\n\nbjornornorn 2022\nhttps://www.shadertoy.com/view/flSyWz\n\ndomain warping\n\ngcgac 2022\nhttps://www.shadertoy.com/view/NtyfWD\n\niq 2013\nhttps://www.shadertoy.com/view/MdX3zN\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n*/\n\n\n/*\nFUTHER READING\n\nnumbers\n\nhttps://en.wikipedia.org/wiki/Dual_number#Differentiation\nhttps://en.wikipedia.org/wiki/Grassmann_number#Generalisations\nhttps://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Julia_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\nhttps://en.wikipedia.org/wiki/Exterior_algebra#Oriented_areas_in_space\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n*/\n", "image_inputs": [], "common_code": "/// This page of color space tools adapted from (2022): \n///    https://www.shadertoy.com/view/flSyWz\n/// by Björn Ottosson: \n///    https://www.shadertoy.com/user/bjornornorn\n\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float middle = 0.2;\n    \n    vec3 x = color-middle;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-middle);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return middle + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvec2 approximateShape(float a, float b)\n{\n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1qQA3xhBX3iB8FT8558e5QQnmVZ5Jh1Fb?usp=sharing\n    return vec2(\n        1.63804674 + -0.08431713*a +  0.27624179*b +  0.08737741*a2 +  0.13917503*b2 + 0.03691021*a3 +  0.03060615*b3,\n        0.23438507 + 0.05736278*a  +  -0.09674117*b +  0.024447*a2 + 0.00469441*b2 + 0.01253234*a3 + 0.00741058*b3\n    );\n}\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 oklch2rgb(float lightness, float chroma, float hue) {\n    chroma = mix(.0, -.25 * log(.55), chroma);\n    // Translate to Lab color space\n    float a = cos(hue);\n    float b = sin(hue);\n    vec2 gamut = approximateShape(a, b);\n    float saturation = 1. / (gamut.y / (1. - lightness) + gamut.x / lightness);\n    float colorfulness = min(chroma, saturation);\n    a *= colorfulness;\n    b *= colorfulness;\n    vec3 color = oklab_to_linear_srgb(vec3(lightness, a, b));\n    color = softClipColorOutsideGamutOnly(color);\n    color = clamp(color, 0., 1.);\n    color = Srgb3(color);\n    \n    return color;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 53, 82, 82, 255], [256, 256, 286, 286, 413], [414, 414, 445, 445, 544], [547, 582, 619, 619, 927], [930, 952, 996, 996, 1111], [1114, 1114, 1169, 1207, 4655]], "test": "untested"}
{"id": "DdGyRK", "name": "Fractal of Mandelbrot", "author": "domrally", "description": "Click & drag to rotate color wheel!\nGenerated by squaring a complex number repeatedly. White boundary between fragment positions starting stable orbits & ones diverging to infinity.\n[url=https://www.shadertoy.com/playlist/s3BcD1]FRACTAL PLAYLIST[/url]\n\n", "tags": ["orbit", "derivative", "complex", "dual", "trap", "imaginary", "automatic", "differential", "autodiff", "differentiation", "chaotic"], "likes": 5, "viewed": 171, "published": 3, "date": "1696741366", "time_retrieved": "2024-07-30T17:29:47.939987", "image_code": "/// by Dom Mandy in 2023\n\n\n/*\nComplex arithmetic.\n*/\nvec2 power(vec2 a, float b) { \n    float angle = atan(a.y, a.x);\n    vec2 direction = vec2(\n        cos(b * angle), \n        sin(b * angle) \n    ); \n    \n    return direction * pow(dot(a, a), b / 2.);\n}\nvec2 divide(vec2 a, vec2 b)  { \n    vec2 dividend = vec2( \n        dot(a, b), \n        dot(vec2(a.y, -a.x), b)\n    );\n    \n    return dividend / dot(b, b);\n}\nvec2 multiply(vec2 a, vec2 b) { \n    return vec2( \n        a[0] * b[0] - a[1] * b[1], \n        a[0] * b[1] + a[1] * b[0]\n    ); \n}\n\n\n/*\nDifferential multiplication.\n*/\nmat4x2 multiply(mat4x2 a, mat4x2 b) {\n    mat4x2 products;\n    int degree, i, j;\n    // Wedge product.\n    for (; degree < 4; degree++) {\n        for (i = 0; i <= degree; i++) {\n            j = degree - i;\n            // Differential product rule.\n            products[degree] += multiply(a[i], b[j]);\n        }\n    }\n    \n    return products;\n}\n\n\n/*\nBöttcher's Map\n*/\nvec2 bottcher(vec2 a, vec2 b, float count) {\n    vec2 base = divide(a, a - b);\n    float exponent = pow(.5, count);\n    return power(base, exponent);        \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Zoom pixel space to view space\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvStart = 2.2 * (2. * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 uvEnd = (uvStart * .03) + vec2(-.1011, .9563);\n    vec2 uvMouse = 2. * iMouse.xy - iResolution.xy;\n    uv = mix(uvStart, uvEnd, .5 - .5 * cos(iTime / 4.));\n    \n    // 4th order differential supernumbers as higher order differential forms\n    mat4x2 orbit, initial;\n    vec2 mapped;\n\n    // Rules for mandelbrot set\n    orbit[0] = initial[0] = mapped = uv;\n    // Image space is a linear grid, so it has constant 1st order derivatives.\n    // No higher order derivatives (those grow while orbiting).\n    orbit[1] = initial[1] = vec2(1.);\n    \n    // Simulate the trajectory for this pixel relative to the center of the image.\n    vec2 trapped;\n    float radius = 9e9;\n    for (float i; i < 47.; i++) {\n        // This recursion generates chaotic behavior\n        orbit = multiply(orbit, orbit) + initial;\n        // Track coordinate deformation\n        mapped = multiply(mapped, bottcher(orbit[0], initial[0], i));\n        // We want to record the nearest approach as the pixel orbits around the image center.\n        float flyby = dot(orbit[0], orbit[0]);\n        radius = min(radius, flyby);\n        // The closest point is called the orbit trap.\n        trapped = trapped * float(radius != flyby) + float(radius == flyby) * orbit[0];\n        // Stop in case of overflow\n        if(flyby > 9e7) break;\n    }\n    \n    // The derivatives need to be scaled by their binomial taylor coefficients\n    vec4 differentials = vec4(\n        length(orbit[0]),\n        length(orbit[1]),\n        2. * length(orbit[2]),\n        6. * length(orbit[3])\n    );\n    \n    // The solution curve is everywhere flat.\n    // This means that the ratios of the derivatives should be \n    // the same for all degrees when we are close to the solution.\n    vec3 estimates = vec3(\n        differentials[0] / differentials[1], \n        differentials[1] / differentials[2], \n        differentials[2] / differentials[3]\n    );\n    // Weight by relative convergence rate\n    vec3 weights = vec3(2., 3., 4.);\n    // Combine for smoother distance estimate.\n    float est = dot(estimates, weights) / dot(weights, vec3(1.));\n    // Distance = log|f| |f|/|f'|\n    float dist = est * log(differentials[0]);\n    float lightness = smoothstep(1.3, 0., pow(dist, .1));\n    // Grid\n    float approach = length(trapped);\n    float scale = 64.;\n    float grid = .5 + .5 * pow(clamp(max(cos(scale * mapped.x), cos(scale * mapped.y)), 0., 1.), 99.);\n    float outside = float(lightness > 0.);\n    lightness = outside * mix(lightness, 2.2 * lightness, grid * smoothstep(0., 1.4, log(approach)));\n    // Highlight the chaotic tree structure inside the fractal\n    float inside = float(dist < 0. || lightness <= 0.);\n    lightness += inside * smoothstep(.8, .0, approach);\n    lightness = clamp(lightness, 0., 1.);\n    // Find the angle of closest approach of the orbit trap\n    float angle = atan(trapped.y, trapped.x);\n    // Match the angle to the color wheel\n    float hue = angle - atan(uvMouse.y, uvMouse.x) + iTime;\n    // The pixel gets greyer the farther the orbit trap\n    float chroma = mix(.95, .3, smoothstep(0., 3., approach));\n    \n    // Paint the pixel\n    fragColor.rgb = oklch2rgb(lightness, chroma, hue);\n    fragColor.a = 1.;\n}\n\n\n/*\nREFERENCES\n\ncolor\n\nbjornornorn 2022\nhttps://www.shadertoy.com/view/flSyWz\n\ndomain warping\n\ngcgac 2022\nhttps://www.shadertoy.com/view/NtyfWD\n\niq 2013\nhttps://www.shadertoy.com/view/MdX3zN\n\ndistance\n\niq 2013\nhttps://www.shadertoy.com/view/lsX3W4\n\norbit traps\n\nDeltaT 2023\nhttps://www.shadertoy.com/view/csSyzy\n\nathibaul 2021\nhttps://www.shadertoy.com/view/fdt3zX\n\npiotrekli 2016\nhttps://www.shadertoy.com/view/4lK3Dc\n\nKramin 2015\nhttps://www.shadertoy.com/view/4st3Wn\n*/\n\n\n/*\nFUTHER READING\n\nnumbers\n\nhttps://en.wikipedia.org/wiki/Dual_number#Differentiation\nhttps://en.wikipedia.org/wiki/Grassmann_number#Generalisations\nhttps://en.wikipedia.org/wiki/Complex_number#Multiplication_and_square\n\nfractals\n\nhttps://en.wikipedia.org/wiki/Mandelbrot_set\nhttps://en.wikipedia.org/wiki/Bifurcation_diagram\nhttps://en.wikipedia.org/wiki/Orbit_trap#Point_based\n\ndifferentials\n\nhttps://en.wikipedia.org/wiki/Product_rule\nhttps://en.wikipedia.org/wiki/Gradient_descent\nhttps://en.wikipedia.org/wiki/Newton%27s_method\nhttps://en.wikipedia.org/wiki/Householder%27s_method\nhttps://en.wikipedia.org/wiki/Automatic_differentiation\nhttps://en.wikipedia.org/wiki/Exterior_algebra#Oriented_areas_in_space\n\ncolor mapping\n\nhttps://en.wikipedia.org/wiki/Color_wheel\nhttps://en.wikipedia.org/wiki/Versine#Definitions\nhttps://en.wikipedia.org/wiki/Argument_(complex_analysis)\n*/\n", "image_inputs": [], "common_code": "/// This page of color space tools adapted from (2022): \n///    https://www.shadertoy.com/view/flSyWz\n/// by Björn Ottosson: \n///    https://www.shadertoy.com/user/bjornornorn\n\n\nconst float M_PI = 3.1415926535897932384626433832795;\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\nfloat srgb_transfer_function(float a)\n{\n\treturn .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;\n}\n\nfloat srgb_transfer_function_inv(float a)\n{\n\treturn .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 softSaturate(vec3 x, vec3 a)\n{\n    a = 1.0+a;\n    x = min(x, a);\n    vec3 b = (a-1.0)*sqrt(a/(2.0-a));\n    return 1.0 - (sqrt((x-a)*(x-a) + b*b) - b)/(sqrt(a*a+b*b)-b);\n}\n\nvec3 softClipColorOutsideGamutOnly(vec3 color)\n{\n    // soft clipping scaled to only have an effect if the color is outside the gamut\n    \n    float middle = 0.2;\n    \n    vec3 x = color-middle;\n\n    vec3 xsgn = sign(x);\n    vec3 xscale = 0.5 + xsgn*(0.5-middle);\n    x /= xscale;\n    \n    vec3 absX = abs(x);\n    \n    float maxX = max(max(1.0,absX.r), max(absX.g, absX.b));\n    \n    float softness_scale = 0.5;\n    float softness = softness_scale*(maxX-1.0);\n    softness = softness/(1.0+softness);\n    \n    return middle + xscale*xsgn*softSaturate(absX, vec3(softness));\n}\n\nvec2 approximateShape(float a, float b)\n{\n    float C = sqrt(a*a+b*b);\n    a /= C;\n    b /= C;\n    \n    float a2 = 2.0*a*b;\n    float b2 = a*a - b*b;\n    float a3 = 3.0*a - 4.0*a*a*a;\n    float b3 = -3.0*b + 4.0*b*b*b;    \n  \n    // softness_scale 0.0\n    // Estimated using https://colab.research.google.com/drive/1qQA3xhBX3iB8FT8558e5QQnmVZ5Jh1Fb?usp=sharing\n    return vec2(\n        1.63804674 + -0.08431713*a +  0.27624179*b +  0.08737741*a2 +  0.13917503*b2 + 0.03691021*a3 +  0.03060615*b3,\n        0.23438507 + 0.05736278*a  +  -0.09674117*b +  0.024447*a2 + 0.00469441*b2 + 0.01253234*a3 + 0.00741058*b3\n    );\n}\n\nfloat Srgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 Srgb3(vec3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\nvec3 oklch2rgb(float lightness, float chroma, float hue) {\n    chroma = mix(.0, -.25 * log(.55), chroma);\n    // Translate to Lab color space\n    float a = cos(hue);\n    float b = sin(hue);\n    vec2 gamut = approximateShape(a, b);\n    float saturation = 1. / (gamut.y / (1. - lightness) + gamut.x / lightness);\n    float colorfulness = min(chroma, saturation);\n    a *= colorfulness;\n    b *= colorfulness;\n    vec3 color = oklab_to_linear_srgb(vec3(lightness, a, b));\n    color = softClipColorOutsideGamutOnly(color);\n    color = clamp(color, 0., 1.);\n    color = Srgb3(color);\n    \n    return color;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdGyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 53, 82, 82, 255], [256, 256, 286, 286, 413], [414, 414, 445, 445, 544], [547, 582, 619, 619, 927], [930, 952, 996, 996, 1111], [1114, 1114, 1169, 1207, 4557]], "test": "untested"}
{"id": "ddGcDd", "name": "BokehBlur-test", "author": "nomkcode_g", "description": "散景模糊，圆形散景，基于对大量离散螺旋型分布的点的渲染，不同的模糊半径变化，可以控制不同的Bokeh半径的变化", "tags": ["bokehblur"], "likes": 0, "viewed": 179, "published": 3, "date": "1696735196", "time_retrieved": "2024-07-30T17:29:48.831603", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    if(uv.x > iMouse.x / iResolution.x){\n        col = texture(iChannel0, uv).rgb;\n    }else{\n        col = texture(iChannel1, uv).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float _BlurRadius = 1.0;\nint _Iteration = 32;\nmat2 _Rot = mat2(cos(2.39996323), sin(2.39996323), -sin(2.39996323), cos(2.39996323));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 accumulator = vec3(0.0);\n    vec3 divisor = vec3(0.0);\n    \n    float r = 1.0;\n    vec2 angle = vec2(0.0, _BlurRadius);\n    for(int j = 0; j < _Iteration; j++)\n    {\n        r += 1.0 / r;\n        angle = angle*_Rot;\n        vec3 bokeh = texture(iChannel0, uv + (r-1.0)*angle/vec2(iResolution.x,iResolution.y)).rgb;\n        accumulator += bokeh * bokeh;\n        divisor += bokeh;\n    }\n    vec3 col = accumulator / divisor;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]], "test": "untested"}
{"id": "dsGyDt", "name": "spqr domain trick 8", "author": "spqr", "description": "Lament the Leviathan", "tags": ["a"], "likes": 5, "viewed": 178, "published": 3, "date": "1696735071", "time_retrieved": "2024-07-30T17:29:49.586584", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm( vec2 a)\n{\n    vec3 p = vec3(a,1.);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat field (vec3 p, float scale) {\n   scale *= .25;\n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n   //float ball = sph(p, f1 * .5);\n   float ball = box(p, pow(f1,sin(iTime*.5)*.5+.5) * vec3(.49));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\nfloat map (vec3 p){\n    p.xz *= rot(iTime*.3);\n    //p.zy *= rot(cos(iTime)*.1);\n    float planet = box(p, vec3(3));//sph(p, 3.2);\n\n   // geo\n   \n    for (float i = 0.; i < 7.; i++) {\n\n        for (int j = 0; j < 1;j++) {\n            //p.xz *= rot(1.3);\n            //p.zy *= rot(1.);\n            planet = max(planet, -field(p,pow(2.,i)));\n        }\n    }\n\n\n    \n    return planet;//abs(planet) + .001;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\nfloat glider(float t) {\n    float dip_interval = 20.0;\n    float dip_depth = 10.0;\n    \n    // Up and down fluctuating motion\n    float y_sine = 5.0 * sin(0.2 * t);\n    \n    // Time since last dip\n    float time_since_last_dip = mod(t, dip_interval);\n    \n    // Modulating function that drops quickly but recovers slowly\n    float modulating_func = 1.0 - sin(time_since_last_dip + 0.5 * sin(time_since_last_dip));\n    \n    // Gaussian dip function\n    float y_gauss = -dip_depth * exp(-pow((time_since_last_dip - dip_interval / 2.0), 2.0) / (2.0 * pow((dip_interval / 6.0), 2.0)));\n    \n    // Continuously blend the Gaussian and sinusoidal functions, modulated by the new function\n    float h = y_sine + y_gauss * modulating_func;\n    \n    // Scale the output by a factor of 3\n    h /= 3.0;\n    \n    return h;\n}\n\nfloat gliderfbm(float t) {\n  float n = 0.;\n  n += glider(t);\n  n += glider((t+5.12) * 2.)/2.;\n  //n += glider((t+11.42) * 4.)/4.;\n  return n;\n  \n}\nfloat fbmao (vec3 p, vec3 n, float aodist ) {\n    float val = 0.;\n    for (float i = 0.; i < 2.; i++) {\n        val += (getao(p,n,aodist *.2 * pow(1.5,i))* 0.5 + 0.5)/(i+1.);\n    }\n    return +val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime;\n \n  // nav\n  vec3 s = vec3(0,1.,-6);\n  vec3 t = vec3(0);\n  \n  s += lattice(tt)*7.;\n \n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <100.; ++z) {\n    i = z;\n    d=map(p)*.8;\n    if(d<0.01) {\n      hit = true;\n      break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light = normalize(vec3(-1));// + t)/2.;//normalize(vec3(5,-5,-1));\n\n  \n  if (dot(n,light) < 0.) {\n      light = -light;\n  }\n  \n  vec3 col = vec3(.6)*1.3;\n  float aodist = .4;\n  float ao =// fbmao(p,n,aodist *.2);\n      (getao(p,n,aodist*.2)*0.5+0.5) * \n      (getao(p,n,aodist*0.35)*0.5+0.5) * \n      (getao(p,n,aodist*0.5)*0.5+0.5);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff = max(0., dot(n,light));\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),3.) * 1.;\n  //float iff = pow(1.-i/100.,2.);\n  \n  \n  //col *= diff;\n  col *= ao;\n  col *= spec;\n  \n \n \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n  //col = vec3(1) * fbm(uv*10.+iTime);\n \n  //col = vec3(1) * fbm(uv*10.);\n  if (length(col) > 1.5) {\n      col = vec3(0);\n  }\n  \n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [950, 950, 973, 973, 1068], [1070, 1070, 1097, 1097, 1179], [1181, 1181, 1209, 1209, 1265], [1266, 1266, 1288, 1288, 1378], [1379, 1379, 1400, 1400, 1691], [1693, 1693, 1713, 1713, 1896], [1897, 1897, 1926, 1926, 1954], [1955, 1955, 1990, 1990, 2306], [2307, 2307, 2326, 2326, 2711], [2712, 2712, 2731, 2731, 2851], [2853, 2853, 2873, 2873, 2970], [2972, 2972, 3013, 3013, 3059], [3060, 3060, 3082, 3082, 3139], [3140, 3140, 3164, 3164, 3302], [3304, 3304, 3327, 3327, 4117], [4119, 4119, 4145, 4145, 4265], [4266, 4266, 4311, 4311, 4465], [4467, 4467, 4524, 4524, 6039]], "test": "untested"}
{"id": "ddGcWd", "name": "GrainyBlur-test", "author": "nomkcode_g", "description": "粒状模糊", "tags": ["grainyblur"], "likes": 0, "viewed": 143, "published": 3, "date": "1696733389", "time_retrieved": "2024-07-30T17:29:50.341566", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    if(uv.x > iMouse.x / iResolution.x){\n        col = texture(iChannel0, uv).rgb;\n    }else{\n        col = texture(iChannel1, uv).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float Rand( vec2 n )\n{\n    return sin(dot(n, vec2(1233.224, 1743.335)));\n}\n\nfloat frac(float v)\n{\n    return v - floor(v);\n}", "buffer_a_code": "float _Iteration = 10.0;\nfloat _BlurRadius = 0.003;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec2 randomOffset = vec2(0.0, 0.0);\n    vec3 col = vec3(0.0);\n    float random = Rand(uv);\n    \n    for(int k = 0; k < int(_Iteration); k++){\n        random = frac(43758.5453 * random + 0.61432);\n        randomOffset.x = (random - 0.5) * 2.0;\n        random = frac(43758.5453 * random + 0.61432);\n        randomOffset.y = (random - 0.5) * 2.0;\n        col += texture(iChannel0, uv+vec2(randomOffset.x*_BlurRadius, randomOffset.y*_BlurRadius)).rgb;\n    }\n    col = col / _Iteration;\n    \n    //vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]], "test": "untested"}
{"id": "msyyWd", "name": "DirectionalBlur-test", "author": "nomkcode_g", "description": "可以看做是径向模糊的一个变体，通过传入一个角度实现", "tags": ["directionblur"], "likes": 0, "viewed": 146, "published": 3, "date": "1696733150", "time_retrieved": "2024-07-30T17:29:51.645081", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    if(uv.x > iMouse.x / iResolution.x){\n        col = texture(iChannel0, uv).rgb;\n    }else{\n        col = texture(iChannel1, uv).rgb;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float _Iteration = 10.0;\nfloat _BlurRadius = 1.0;\nfloat _Angle = 30.0*3.1415926/180.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sinVal = sin(_Angle)*_BlurRadius*0.05 / _Iteration;\n    float cosVal = cos(_Angle)*_BlurRadius*0.05 / _Iteration;\n    vec3 col = vec3(0.0);\n    for(int k = int(-_Iteration); k < int(_Iteration); k++)\n    {\n        col += texture(iChannel0, uv-vec2(sinVal*float(k), cosVal*float(k))).rgb;\n    }\n    col = col / (_Iteration * 2.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]], "test": "untested"}
{"id": "cdGcWd", "name": "Random Pipes Golf 445 chars", "author": "bailesdtd", "description": "Gotta do something about that hash ", "tags": ["2d", "noise", "pipes"], "likes": 2, "viewed": 55, "published": 3, "date": "1696729933", "time_retrieved": "2024-07-30T17:29:53.316612", "image_code": "// 445 chars\nfloat h( ivec2 x ) {\n    ivec2 q = 1103515245 *  (x>>1 ^ x.yx)   ;\n    return float((1103515245 * (q.x^q.y>>3))) * (1./float(0xffffffff)); }\nvoid mainImage(out vec4 o,in vec2 p){\n    vec2 u = p/iResolution.y+iTime*.2,\n         F=fract(u*9.-.5)*2.-1.;\n    float d=1.;\n    for(float i=0.;i<4.;i++){\n        vec2 k = round(u*9.)+.1*(abs(mod(vec2(i,i-1.),4.)-2.)-1.);\n        d=min(d,max(h(ivec2(k.x+k.y,k.y-k.x))<.5?0.:1.,\n          length(F-vec2(max(F.x,0.),0)))), F=vec2(F.y,-F.x); }\n    o=vec4(vec3(smoothstep(0.,.05,abs(d-.5*.7)-.1)),1); }\n    \n// 303 chars done by Fabrice in the comments!\n// 301 chars done by Xor!", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 13, 33, 33, 153], [154, 154, 191, 191, 553]], "test": "untested"}
{"id": "dsGyWt", "name": "spqr domain trick 7", "author": "spqr", "description": "a", "tags": ["a"], "likes": 13, "viewed": 197, "published": 3, "date": "1696726103", "time_retrieved": "2024-07-30T17:29:54.299982", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm( vec2 a)\n{\n    vec3 p = vec3(a,1.);\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n  \n    return f;\n}\nfloat sph (vec3 p, float n) {\n    return length(p) -n ;\n}\nfloat field (vec3 p, float scale) {\n   scale *= .25;\n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n   //float ball = sph(p, f1 * .5);\n   float ball = box(p, pow(f1,sin(iTime*.5)*.5+.5) * vec3(.5));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\nfloat map (vec3 p){\n   \n    float planet = sph(p, 3.2);\n\n   // geo\n   \n    for (float i = 0.; i < 7.; i++) {\n\n        for (int j = 0; j < 1;j++) {\n            //p.xz *= rot(1.3);\n            //p.zy *= rot(1.);\n            planet = max(planet, -field(p,pow(2.,i)));\n        }\n    }\n\n\n    \n    return planet;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat tick(float t){\n    float i = floor(t);\n    float f = fract(t);\n    f = smoothstep(0.,1.,f);\n    return i + f;\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\nfloat path (float t) {\n    float a = sin(sin(t) + .3 * t);\n    return a;\n    \n}\nfloat pathfbm(float t) {\n    float a = 0.;\n    \n    a += path( (t+0. ) );\n    a += path( (t+21.)*2.)/2.1;\n    a += path( (t+211.)*5.)/5.1;\n    \n    return a/2.;\n}\n\nfloat glider(float t) {\n    float dip_interval = 20.0;\n    float dip_depth = 10.0;\n    \n    // Up and down fluctuating motion\n    float y_sine = 5.0 * sin(0.2 * t);\n    \n    // Time since last dip\n    float time_since_last_dip = mod(t, dip_interval);\n    \n    // Modulating function that drops quickly but recovers slowly\n    float modulating_func = 1.0 - sin(time_since_last_dip + 0.5 * sin(time_since_last_dip));\n    \n    // Gaussian dip function\n    float y_gauss = -dip_depth * exp(-pow((time_since_last_dip - dip_interval / 2.0), 2.0) / (2.0 * pow((dip_interval / 6.0), 2.0)));\n    \n    // Continuously blend the Gaussian and sinusoidal functions, modulated by the new function\n    float h = y_sine + y_gauss * modulating_func;\n    \n    // Scale the output by a factor of 3\n    h /= 3.0;\n    \n    return h;\n}\n\nfloat gliderfbm(float t) {\n  float n = 0.;\n  n += glider(t);\n  n += glider((t+5.12) * 2.)/2.;\n  //n += glider((t+11.42) * 4.)/4.;\n  return n;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n\n  float tt = iTime;\n \n  // nav\n  vec3 s = vec3(0,.3,-6);\n  vec3 t = vec3(0);\n  s.xz *= rot(iTime*.3);\n  s.zy *= rot(iTime*.3);\n\n  \n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z <100.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 10.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light = normalize(s + vec3(4));// + t)/2.;//normalize(vec3(5,-5,-1));\n  //light.xz *= rot(iTime);\n  //light.zy *= rot(iTime);\n  \n  if (dot(n,light) < 0.) {\n      //light = -light;\n  }\n  \n  vec3 col = vec3(.3,.5,.7)*1.3;\n  float aodist = .4;\n  float ao = getao(p,n,aodist*.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n  float diff = max(0., dot(n,light));\n  float spec =pow(max(dot(reflect(-light,n),-r),.4),10.) * 1.;\n  //float iff = pow(1.-i/100.,2.);\n  \n  \n  //col *= diff;\n  col *= ao ;\n \n \n  if ( ! hit ) {\n\n    col = vec3(1) - pow(r.y,.2);\n  }\n\n  //col = vec3(1) * fbm(uv*10.+iTime);\n \n  //col = vec3(1) * fbm(uv*10.);\n  if (length(col) > 1.5) {\n      col = vec3(0);\n  }\n  \n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [950, 950, 973, 973, 1068], [1070, 1070, 1097, 1097, 1179], [1181, 1181, 1209, 1209, 1265], [1266, 1266, 1288, 1288, 1378], [1379, 1379, 1400, 1400, 1691], [1693, 1693, 1713, 1713, 1896], [1897, 1897, 1926, 1926, 1954], [1955, 1955, 1990, 1990, 2305], [2306, 2306, 2325, 2325, 2614], [2615, 2615, 2634, 2634, 2754], [2756, 2756, 2776, 2776, 2873], [2875, 2875, 2916, 2916, 2962], [2963, 2963, 2985, 2985, 3042], [3043, 3043, 3067, 3067, 3205], [3207, 3207, 3230, 3230, 4020], [4022, 4022, 4048, 4048, 4168], [4171, 4171, 4228, 4228, 5759]], "test": "untested"}
{"id": "DsycDd", "name": "Bouncing SDF Ball", "author": "tristanantonsen", "description": "A simple bouncing ball animation test", "tags": ["raymarching", "sdf", "animated", "animation"], "likes": 0, "viewed": 126, "published": 3, "date": "1696723167", "time_retrieved": "2024-07-30T17:29:55.182622", "image_code": "// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r) {\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -(m.x+1.)*TAU + PI * 0.95);\n    return p;\n}\n\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching & Map Functions\n////////////////////////////////////////////////////////////////\n\nfloat ramp(float t, float inMin, float inMax, float outMin, float outMax) {\n\n    return mix(outMin, outMax, smoothstep(inMin, inMax, t));\n\n}\n\nfloat ball(vec3 p, float x, float t) {\n    \n    float ymin = -0.85;     // max height (t = 1)\n    float ymax = 0.625;     // min height (t = 0)\n        \n    float r = 0.35;\n    float dry = 0.5;\n    float drxz = 0.625;\n\n    float sxz = ramp(t, 0., 0.3, drxz + 1., 1.);         // xz radius ramp\n    float sy = ramp(abs(t-0.35), 0., 0.6, dry + 1., 1.); // y radius ramp\n\n    float rt = sxz * r; // - r * sy * 0.5;\n    float ry = sy * r;\n    \n    \n    rt *= ramp(abs(t-0.35), 0., 0.6, 0.625, 1.);;\n    ry *= ramp(t, 0., 0.3, 0.5, 1.);\n    \n\n    float b = sdEllipsoid(p, vec3(x, mix(ymin, ymax, t), 0.), vec3(rt, ry, rt));\n    \n    return b;\n\n}\n\nvec2 map(vec3 po) {\n\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = po;\n\n    vec2 res;\n    \n    float speed = 3.;\n    float t = abs(sin(iTime * speed)); // 0 to 1\n\n    float b = ball(p, 0., t);\n    \n    res = vec2(b, 1.0); \n    \n    // Ground\n    float g = sdRoundedBox(p-vec3(0.,-1.2,0.), vec3(3.,0.2,3.), 0.1);\n    \n    if (g < res.x) {res.y = 2.;};\n    res.x = opUnion(res.x,g);\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., -0.5, -60.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd); \n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        if (d.y == 1.0) color = vec3(0.9,0.1,0.1);\n        if (d.y == 2.0) color = vec3(0.2,0.8,1.);\n        if (d.y == 3.0) color = vec3(0.1,0.9,0.1);\n        color *= illumination; \n        \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n         \n         \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n       \n        fragColor = vec4(color, 1.0);\n\n        \n    }\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsycDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 310, 352, 352, 388], [390, 390, 433, 433, 463], [465, 465, 510, 510, 602], [604, 604, 650, 650, 759], [910, 910, 946, 946, 967], [969, 969, 1010, 1070, 1097], [1098, 1098, 1140, 1140, 1166], [1168, 1168, 1218, 1218, 1317], [1318, 1318, 1374, 1374, 1474], [1475, 1475, 1531, 1531, 1630], [1776, 1776, 1804, 1804, 1954], [1956, 1956, 1984, 1984, 2134], [2136, 2136, 2165, 2165, 2307], [2474, 2474, 2549, 2549, 2614], [2616, 2616, 2654, 2654, 3256], [3258, 3258, 3277, 3291, 3701], [3703, 3703, 3736, 3736, 4126], [4128, 4128, 4151, 4151, 4485], [4487, 4487, 4532, 4559, 5160], [5163, 5163, 5220, 5270, 6644]], "test": "untested"}
{"id": "DsGcWd", "name": "Simple Square Spiral", "author": "martymarty", "description": "Turned my snake idea into a couple lines of code. Tried my hand at making a golf version of it. Click to change, x is size and y is speed. Updated to smaller code and better initial values. 234 chars", "tags": ["2d", "interactive", "blackandwhite", "animated", "golfing"], "likes": 2, "viewed": 186, "published": 3, "date": "1696721584", "time_retrieved": "2024-07-30T17:29:55.964532", "image_code": "//Update:it's no longer black intially and recommendations from Fabrice Neyret.\n//234 chars\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec2 m = 1e2+iMouse.xy;\n    float s = ceil(m.x/35.), r, h;\n    p = floor(s*p/iResolution.y);\n    p.y > p.x ? h = 1., p = p.yx :p;\n    r = min(p.y, s-1.-p.x);\n    c = fract(vec4(4.*(r+h)*(s-r-h) + sign(.5-h)*(p.x+p.y-r-r))/(s*s-1.)+iTime*3e2/m.y);\n}\n\n//First 259 chars\n//Got my snake spiral idea down to a few lines so decided to do a golf version of it.\n//Original idea https://www.shadertoy.com/view/DtjBWR\n/* \nvoid mainImage( out vec4 c, in vec2 p )\n{\n    float s = ceil(m.x/40.0);\n    p = floor(s*p/iResolution.y);\n    float r = min(min(p.x,p.y),min(s-p.x-1.,s-p.y-1.));\n    float h = float(p.y>p.x);\n    c = fract(vec4(4.*(r+h)*(s-r-h) + sign(0.5-h)*(p.x+p.y-2.*r)+iTime*m.y)/(s*s-1.));\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 134, 134, 387]], "test": "untested"}
{"id": "csGcWd", "name": "Julia set burning ship + blend", "author": "Elyades", "description": "Burning ship Julia", "tags": ["juliaset"], "likes": 0, "viewed": 152, "published": 3, "date": "1696717299", "time_retrieved": "2024-07-30T17:29:56.939924", "image_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nvec2 ix(vec2 uv)\n{\n    //this computes i*uv;\n    return vec2(-uv.y,uv.x);\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return vec2(uv.x/squaremodulus, -uv.y/squaremodulus);\n}\n\nvec2 log2d(vec2 uv)\n{\n    return vec2(log(length(uv)) , atan2(uv.y,uv.x));\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return vec2( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    vec2 expo = exp2d(ix(uv));\n    return 0.5*( expo + oneoverz(expo) );\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    vec2 expo = exp2d(ix(uv));\n    return ix(0.5*( expo - oneoverz(expo) ) );\n}\n\nvec2 square(vec2 uv)\n{\n    return vec2(uv.x*uv.x - uv.y*uv.y , 2.0*uv.x*uv.y);\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2( uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y, 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y );\n}\n\nvec2 degree2(vec2 uv, vec2 a, vec2 b, vec2 c)\n{\n    \n    return(times(a,square(uv)) + times(b,uv) + c);\n}\n\nvec2 degree3(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 prod1 = square(uv);\n    vec2 prod2 = times(prod1,uv);\n    \n    return(times(a,prod2) + times(b,prod1) + times(c,uv) + d);\n}\n\nvec2 function(vec2 uv, vec2 c)\n{   \n    vec2 result = square(uv) + c;\n    return result;\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,0.0);\n    vec3 d = vec3(0.3,0.1,0.6);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette4(float iteration)\n{\n    float value = 0.8;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.0,0.0);\n    \n    return (a + b*cos(TWOPI*(c*iteration + d)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //Offset\n    uv = uv - 0.5;\n    uv.x += 0.0;\n    \n    //Scale\n    uv *= 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n     //Choosing the Zoom\n    vec2 zoomPoint = vec2(0.0);\n    \n    //Zoom\n    float zoomAmount = min(1.0,1.0/pow(max(iTime-3.0,1.0),3.0));\n    //uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    // Algorithm to color the pixel\n    float tol = pow(10.0,-6.0);\n    \n    \n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    vec2 c = 2.0*(iMouse.xy/iResolution.xy - 0.5);\n    //float residue = mod(iTime,15.0)/15.0;\n    //vec2 c = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = uv;\n        uv = function(uv,c);\n        currentModulus = length(uv);\n        DistanceToPrevious = length(uv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 300000000.0){break;}\n    }\n    \n    \n    \n    if(currentModulus < 300000000.0)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    else\n    {\n            iterationAmount = int(log(float(iterationAmount)));\n            int periodFast = 5;\n            int residueFast = iterationAmount%periodFast;\n            float indexFast = float(residueFast)/float(periodFast);\n            vec3 colorFast = palette4(indexFast);\n            \n            int periodMedium = 20;\n            int residueMedium = iterationAmount%periodMedium;\n            float indexMedium = float(residueMedium)/float(periodMedium);\n            vec3 colorMedium = palette4(indexMedium);\n            \n            int periodSlow = 50;\n            int residueSlow = iterationAmount%periodSlow;\n            float indexSlow = float(residueSlow)/float(periodSlow);\n            vec3 colorSlow = palette4(indexSlow);\n           \n            float finalIndex = (indexSlow + indexMedium + indexFast)*0.333333333;\n            vec3 finalColor = (colorSlow + colorMedium + colorFast)*0.3333333333;\n            fragColor = vec4(finalColor,1.0);\n    }\n}", "image_inputs": [], "buffer_a_code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return vec2( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return(vec2(0.5*( exp2d(times(uv,vec2(0.0,1.0))) + exp2d(times(-uv,vec2(0.0,1.0))))));\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    return(times(0.5*( exp2d(times(uv,vec2(0.0,1.0))) - exp2d(times(-uv,vec2(0.0,1.0)))),vec2(0.0,1.0)));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,2.0);\n    vec3 d = vec3(0.0,0.2,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.33,0.66);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette3( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.5,1.0);\n    vec3 d = vec3(0.0,0.8,0.0);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette4( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette5 (float t)\n{\n    float value = 0.61;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.0,0.0);\n    \n    return (a + b*cos(TWOPI*(c*t + d)));\n}\n\nvec2 square(vec2 uv)\n{\n    return vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y);\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y);\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    float cosine = cos(angle); float sine = sin(angle);\n    return (vec2(cosine*uv.x - sine*uv.y, sine*uv.x + cosine*uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 127, 159, 245], [314, 314, 332, 358, 389], [391, 391, 422, 422, 488], [490, 490, 514, 514, 610], [612, 612, 633, 633, 688], [690, 690, 711, 711, 769], [771, 771, 792, 792, 867], [870, 870, 891, 891, 971], [973, 973, 995, 995, 1053], [1055, 1055, 1075, 1075, 1170], [1172, 1172, 1219, 1219, 1277], [1279, 1279, 1334, 1334, 1467], [1469, 1469, 1501, 1501, 1559], [1561, 1561, 1587, 1609, 1795], [1797, 1797, 1829, 1829, 2028], [2030, 2030, 2087, 2138, 4306]], "test": "untested"}
{"id": "DsyyWd", "name": "exp_001", "author": "punpun", "description": "exp_001", "tags": ["exp001"], "likes": 0, "viewed": 90, "published": 3, "date": "1696715609", "time_retrieved": "2024-07-30T17:29:57.983135", "image_code": "// Author @patriciogv - 2015\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return (1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0));\n}\n\nfloat triangle(in vec2 st, float num){\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Number of sides of your shape\n  float N = num;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n\n  // Shaping function that modulate the distance\n  float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  return (1.0-smoothstep(.4,.41,d));\n\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nvec2 tile(in vec2 st, float space){\n    return vec2(fract(st.x*space), fract(st.y*space));\n    // return vec2(fract(st.x*space), st.y);\n    // return vec2(st.x, fract(st.y*space));\n    // return vec2(st.x,st.y);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st = tile(st, 4.0);\n    st = rotate2D(st, PI*.25*iTime*.2);\n    st = tile(st, 4.0);\n    st = rotate2D(st, PI*.25*iTime*.5);\n\n\n    // color = vec3(st,0.0);\n    // color = vec3(circle(st,0.5));\n    // color = vec3(circle(tile(st, 9.0),0.5));\n    // color = vec3(triangle(st));\n    // if(mod(st.x, 2.0) == 1.0) {\n    //     color = vec3(box(st, vec2(.7), .1), mod(fract(iTime)*.5, 2.), sin(iTime));\n    // }else if(st.y >= .2) {\n    //     color = vec3(triangle(st), mod(fract(iTime)*.5, 2.), sin(iTime));\n    // }\n\n    // 001\n    // color = vec3(triangle(st, sin(iTime+3.)*10.), mod(fract(iTime)*.5, 2.), sin(iTime));\n\n    // 002\n    // if(st.x <= .5 && st.y <= .5) color = vec3(triangle(st, sin(iTime+3.)*10.), mod(fract(iTime)*.5, 2.), sin(iTime));\n    // if(st.x > .5 && st.y > .5) color = vec3(triangle(st, sin(iTime+3.)*10.), mod(fract(iTime)*.5, 2.), sin(iTime));\n\n    // 003\n    float vr = 1.0;\n    if(st.x > .5 && st.y > .5) color = vec3(box(st, vec2(.7), .1), mod(fract(vr)*.5, 2.), sin(vr));\n    st = tile(st, 4.0);\n    if(st.x <= .5 && st.y <= .5) color = vec3(box(st, vec2(.7), .1), mod(fract(vr)*.5, 2.), sin(vr));\n\tfragColor = vec4(color.x, color.y, abs(sin(vr)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsyyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 225, 225, 395], [397, 397, 435, 470, 786], [788, 788, 840, 840, 1033], [1036, 1036, 1071, 1071, 1249], [1251, 1251, 1289, 1289, 1429], [1431, 1431, 1487, 1487, 2785]], "test": "untested"}
{"id": "csGcDt", "name": "Cloaked Predator effect (102 ch)", "author": "ruudhelderman", "description": "Experimenting with displacement mapping is fun.\nTry swapping the images; it will give a frosted glass effect.", "tags": ["displacement"], "likes": 4, "viewed": 229, "published": 3, "date": "1696714391", "time_retrieved": "2024-07-30T17:29:58.747092", "image_code": "void mainImage(out vec4 O, vec2 U)\n{\n    U /= iResolution.xy;\n    O = texture(iChannel1, U + texture(iChannel0, U).r * .2);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 125]], "test": "untested"}
{"id": "DdyyWt", "name": "Semi-circle Wave Animation(367ch", "author": "FabriceNeyret2", "description": "golfing Shane \"Semi-circle Wave Animation\"  https://shadertoy.com/view/cdycRt  ( unlisted because he is very shy :-) ).\ninspired from which one of https://twitter.com/beesandbombs ?", "tags": ["wave", "animation", "reproduction"], "likes": 38, "viewed": 528, "published": 3, "date": "1696709119", "time_retrieved": "2024-07-30T17:29:59.499081", "image_code": "// golfing 685 \"Semi-circle Wave Animation\" by Shane. https://shadertoy.com/view/cdycRt\n// -10 by SnoopethDuckDuck -2 by Xor\n\nvoid mainImage( out vec4 O,  vec2 u ){\n    vec2  R = iResolution.xy,\n          p = ( u+u - R ) / R.y;\n    float N = 24., T = 6.283, H = .5, Z,\n          a = atan( p.y+=H, p.x ) / T, \n          l = min( length(p*=N), N),\n          i = floor( l ),\n          A = sin(iTime/H + i*T/N*.75 ) *.243 + .25;\n\n    p *= mat2(cos( T* ( p.x<Z && p.y<Z ? H : A ) - T*vec4(H,1,0,H)*H )); \n    \n    p.y = fract( clamp(p.y, Z, N) ) - H; \n    \n    O = sqrt( ( H + H*cos(i*T/N*.8 + vec4(2,4,6,0)) )\n             *  smoothstep( 3.*N/R.y, Z, min( length(p), a < A ? N : abs(l-i-H) ) - .2 ));\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 164, 164, 698]], "test": "untested"}
{"id": "dsVyWc", "name": "Bitwise Wavelet Pattern [158 Ch]", "author": "SnoopethDuckDuck", "description": "n > 3 looks more irregular, making this 3D could be interesting", "tags": ["fractal", "sierpinksi", "bitwise", "wavelet"], "likes": 21, "viewed": 182, "published": 3, "date": "1696705137", "time_retrieved": "2024-07-30T17:30:00.404660", "image_code": "// -52 thanks to Fabrice🍓\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u = .2*u + vec2(7, 16) * iTime;\n    int j;   \n    for (float n = 3., i ; i < n; i++) \n        j ^= int(dot(u, cos(3.14*i/n + vec2(0,11))));\n\n    o *= 0.;\n    o[abs(j-(j&36)) % 11]++;\n}\n\n\n// Original [210]\n/*\n#define pi 3.14159\n#define dir(a) vec2(cos(a),sin(a))\n\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u = .2 * (u + vec2(35, 80) * iTime);\n    \n    int n = 3,\n        i,\n        j;\n        \n    for (; i < n; i++) \n        j ^= int(dot(u, dir(pi*float(i)/float(n))));\n\n    o = 0.*o;\n    o[abs(j-(j&36)) % 11]++;\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 29, 67, 67, 256]], "test": "untested"}
{"id": "dsycDc", "name": "Drunk effect test", "author": "ianertson", "description": "Experiment", "tags": ["3d", "ray", "effect", "fx", "march"], "likes": 10, "viewed": 223, "published": 3, "date": "1696704281", "time_retrieved": "2024-07-30T17:30:01.640358", "image_code": "#define R (iResolution.xy)\n#define T (iTime)\n#define ZERO min(iFrame, 0)\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n#define adot(v1, v2) abs(dot(v1, v2))\n\n#define STEPS 100\n#define SHADOW_STEPS 24\n#define NEAR 0.003\n#define FAR 128.0\n#define AMBIENT 0.3\n#define FX 1\n#define FX_AMOUNT cos(T*0.5)*0.1\n\n\nvec3 noise(in vec2 p, in float s) {\n    p += s * 256.0;\n    return textureLod(iChannel3, p / 256.0, 0.0).rgb;\n}\n\nvec3 noise(in vec2 p, in float s, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < oct; i++) {\n        n += amp * noise(p*freq, s);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoise(in vec2 p, in float s) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    return mix(\n        mix(noise(id, s), noise(id+vec2(1, 0), s), lv.x),\n        mix(noise(id+vec2(0, 1), s), noise(id+vec2(1, 1), s), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float s, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < oct; i++) {\n        n += amp * snoise(p*freq, s);\n        div += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\n\nstruct Translation {\n    vec3 p;\n    vec3 r;\n};\n\n#define NEW_TRANSLATION Translation(vec3(0.0), vec3(0.0))\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 pointRotInv(in vec3 p, in vec3 r) {\n    p.yz *= inverse(rot(r.x));\n    p.xz *= inverse(rot(r.y));\n    p.xy *= inverse(rot(r.z));\n    return p;\n}\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    int t;\n    float s;\n};\n\n#define LIGHT_POINT 0\n#define LIGHT_DIR 1\n#define LIGHT_AMB 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.t == LIGHT_POINT ? normalize(light.p - p) : \n        light.t == LIGHT_DIR ? normalize(light.d) : normalize(light.p);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 N) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(N, L));\n    \n    switch (light.t) {\n        case LIGHT_POINT: {\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.001, pow(distance(light.p, p), 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            light.s * light.c * NdotL * smoothstep(0.8, 1.0, dot(\n                normalize(light.p - p),\n                L\n            ));\n        }; break;\n        case LIGHT_AMB: {\n            return NdotL * light.c * light.s;\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n    Translation t;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, -1, NEW_TRANSLATION)\n\n#define SAMPLE(D, TRANS, T, dist, t, trans) if (D < dist) { dist = D; t = T; trans = TRANS; }\n\n#define ID_GROUND 0\n#define ID_BOX 1\n#define ID_STONE 2\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat stoneSDF(in vec3 p, in float s) {\n    vec3 n = snoise(p.xz*2.2+p.y, s, 1.1, 4);\n    \n    float d = distance(p, vec3(0.0)) - n.x;\n    \n    return d;\n\n}\n\nfloat sdf(in vec3 p, inout Data data) {\n    float dist = FAR;\n    int t = -1;\n    Translation tr = NEW_TRANSLATION;\n   \n    float ground = groundSDF(p);\n    SAMPLE(ground, tr, ID_GROUND, dist, t, tr);\n    \n    if (p.y < 0.5 && p.x > 1.0) {\n        float stone = stoneSDF(p - vec3(2.3, 0.1, 0), 0.03921);\n        SAMPLE(stone, tr, ID_STONE, dist, t, tr);\n    }\n\n    Translation boxTrans = Translation(vec3(0, -0.69 - 0.333*(0.5+0.5*cos(T)), 0), vec3(sin(T)*0.25, T, 0));\n    float box = boxSDF(pointRot(p + boxTrans.p, boxTrans.r), vec3(0.5))-0.06;\n    vec3 boxP = pointRot(p + boxTrans.p, boxTrans.r);\n    float boxInside = boxSDF(boxP, vec3(1.0, 0.3, 0.3))-0.05;\n    float boxInside2 = boxSDF(boxP, vec3(0.3, 0.3, 1.0))-0.05;\n    boxInside = min(boxInside, boxInside2);\n    box = max(box, -boxInside);\n    SAMPLE(box, boxTrans, ID_BOX, dist, t, tr);\n    \n    \n\n    data.id = t;\n    data.t = tr;\n    return dist;\n}\n\nbool march(in vec3 ro, in vec3 rd, inout Data data) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(p, data);\n        \n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= FAR) return false;\n        \n        d += next;\n    }\n    \n    d = abs(d);\n    vec3 p = ro+rd*d;\n    data.p = p;\n    data.d = d;\n    vec2 e = vec2(0.001, 0.0);\n    Data tmp = NEW_DATA;\n    data.n = normalize(sdf(p, tmp) - vec3(\n        sdf(p - e.xyy, tmp),\n        sdf(p - e.yxy, tmp),\n        sdf(p - e.yyx, tmp)\n    ));\n    \n    return true;\n\n}\n\n// Modified version of iq's https://www.shadertoy.com/view/lsKcDD\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    float NdotL = dot(n, rd);\n    float nl = max(0.0, NdotL);\n    float res = 1.0;\n    float ep = 1e20;\n    float t = NEAR+0.03;\n    float ss = (far/FAR)+0.2;\n    float tot = 0.0;\n    int lastId = -1;\n    float jumps = 0.0;\n    for(int i = ZERO; i < SHADOW_STEPS && t < far; i++){\n        vec3 p = ro + rd*t;\n        float j = float(i);\n        \n        // Move point away from surface\n        float jump = 0.5*clamp(pow(max(0.0, dot(normalize(rd+p), n)), 2.)*clamp(t/far, 0.5, 1.0), 0.0, 0.56)*\n             (1.0 + 0.5*float(lastId == skip)) * (1.0 + 1.5*max(0.0, dot(n, vec3(0, 1, 0))));\n        p += n*jump;\n        jumps += jump;\n        \n        \n        float h = sdf(p, data);\n        lastId = data.id;\n        tot += h;\n        float y = h*h / (2.9 * ep);\n        float d = sqrt(h*h-y*y);\n        res = min(res, d/(ss*max(0.0, t-y)));\n        ep = h;\n        t += h;\n        \n        if (t <= -0.5 || h <= -0.5 || d <= -0.5) break;\n    }\n    jumps /= float(SHADOW_STEPS);\n    float ra = far*0.5; // radius\n    float fe = ra*0.9; // feather\n    res = max(res, 0.0002);\n    res = max(mix(res*res,\n        (1.0-smoothstep(ra-fe, ra+fe, far-tot)),\n        0.8*smoothstep(0.0, 0.63, res+smoothstep(0.0, 0.9, tot / (1.0+tot*6.)))\n    ), 0.);\n    \n    res += (((0.5*res)*res*res) + (max(0.0, (t/far)*0.25*res*res)))*(1.0+(res*0.1));\n    res += max(0.0, 1.0-(res*res))*(res / (1.0 + res));\n    res /= (1.0 + ((jumps*(0.2+(res*res*2.5))) / (1.0+(nl*nl*2.*(1.0+nl)))));\n    res = mix(res, res / (1.0+res), 0.5*jumps*jumps);\n    res += 0.25*(0.5*(0.45+(res*res)));\n    res /= (1.0+((res+0.05)*max(0.0, 0.5-(nl*nl*2.))));\n    return clamp(res, AMBIENT, 1.);\n}\n\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\nvec3 grassTexture(in vec2 uv) {\n    vec3 col = vec3(0.2, 0.8, 0.1);\n    vec3 hf = noise(uv, 0.03214, 32.0, 2);\n    vec3 lf = noise(uv, 0.19882, 1.0, 3);\n    vec3 lf2 = noise(uv+0.04, 0.0012455, 1.5, 3);\n    \n    col *= hf.x;\n    col = mix(col, vec3(0.5, 0.2, 0.3), hf.y*lf.z*0.8);\n    col = mix(col, vec3(0.8, 0.5, 0.2), smoothstep(lf.x, 0.02, 0.3+0.1*hf.z));\n    col = mix(col, col*col, smoothstep(0.25, 0.5, lf2.z*hf.y));\n    \n    return col;\n}\n\nvec3 stoneTexture(in vec2 uv) {\n    vec3 col = vec3(0.89, 0.81, 0.91);\n    vec3 hf = noise(uv, 1.49818, 32.0, 2);\n    \n    col *= hf.x;\n    return col;\n}\n\nvec3 getAlbedo(in vec3 p, inout Data data) {\n    vec3 n = data.n;\n    \n    switch (data.id) {\n        case ID_BOX: {\n            \n            \n            p = pointRot(p + data.t.p, data.t.r);\n            n = pointRot(n, data.t.r);\n            vec2 uv = boxUv(p, n);\n            return checkerTexture(uv*9., 0.05) * vec3(1.0);\n        }; break;\n        case ID_GROUND: {\n            vec2 uv = p.xz;\n            return grassTexture(uv);\n        }; break;\n        case ID_STONE: {\n            vec2 uv = boxUv(p, n);\n            return stoneTexture(uv);\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.96, 0.87, 0.59), LIGHT_AMB, 1.6);\n    \n    Data data = NEW_DATA;\n    float up = max(0.0, dot(rd, vec3(0, 1, 0)));\n    if (march(ro, rd, data)) {\n        vec3 albedo = getAlbedo(data.p, data);\n        vec3 diffuse = albedo / M_PI;\n        vec3 L = getLightDir(light, data.p);\n        vec3 att = getLightAtt(light, data.p, data.n);\n        float shadow = getShadow((data.p+L*0.0001)+data.n*0.0001, L, data.n, data.d, FAR, -1);\n        col += albedo * att * shadow;\n    } else {\n        vec3 sky = vec3(0.02, 0.6, 0.89);\n        sky = pow(sky, 3.0*up*vec3(up));\n        col += sky;\n    }\n    \n    float depth = data.d / FAR;\n    col += light.c*depth*smoothstep(0.15, 0.0, up)*(0.5+0.5*depth);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec2 uv = (fc - R.xy * 0.5) / R.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 1., -4.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec4 m = vec4((iMouse.xy - R.xy * 0.5)/R.y, iMouse.zw);\n    \n    if (m.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    \n      \n    #if FX > 0\n    vec3 rd2 = rd;\n    rd2.yx *= rot(FX_AMOUNT);\n    col += (render(ro, rd) + render(ro, rd2))*0.5;\n    #else\n    col += render(ro, rd);\n    #endif\n    \n    col += col*col*0.5;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsycDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[302, 302, 337, 337, 413], [723, 723, 759, 759, 1009], [1430, 1430, 1452, 1452, 1516], [1518, 1518, 1555, 1555, 1637], [1639, 1639, 1679, 1679, 1788], [1932, 1932, 1977, 1977, 2113], [2115, 2115, 2171, 2171, 2732], [3043, 3043, 3071, 3071, 3089], [3091, 3091, 3127, 3127, 3215], [3217, 3217, 3256, 3256, 3373], [3375, 3375, 3414, 3414, 4289], [4291, 4291, 4344, 4344, 4888], [4890, 4956, 5050, 5050, 6732], [6735, 6735, 6769, 6769, 6872], [6874, 6874, 6920, 6920, 7236], [7238, 7238, 7269, 7269, 7684], [7686, 7686, 7717, 7717, 7839], [7841, 7841, 7885, 7885, 8444], [8446, 8446, 8483, 8483, 9285], [9288, 9288, 9330, 9330, 9907]], "test": "untested"}
{"id": "msVyW3", "name": "Wallpalump", "author": "Spueli", "description": "This is the first shader I made. I hope, you like it!", "tags": ["experiment", "shader", "first"], "likes": 0, "viewed": 129, "published": 3, "date": "1696699345", "time_retrieved": "2024-07-30T17:30:02.574858", "image_code": "float possin(float val) {\n    return sin(val) / 2. + 0.5;\n}\n\n\nfloat poscos(float val) {\n    return cos(val) / 2. + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv0 = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float pi0 = 0.9;\n    uv0 *= pi0;\n\n    vec2 uv = uv0;\n\n    vec3 color;\n    float myTime = iTime / 1.;\n\n    float closeness = 30.;\n\n    uv.y += sin(myTime) * pi0 / closeness;\n    uv.x += cos(myTime) * pi0 / closeness;\n    for (float i = 0.0; i < 2.0; i++) {\n        uv = fract(uv) * 2. - 1.;\n\n        color.z = length(uv);\n\n        color.z = smoothstep(0.5, 1., color.z);\n        color.z = 0.1 / color.z;\n\n        if (abs(uv.x) + abs(uv.y) < 0.1) {\n            color.z = 0.0;\n        }\n    }\n\n    uv = uv0;\n    uv.y -= sin(myTime) * pi0 / closeness;\n    uv.x -= cos(myTime) * pi0 / closeness;\n    for (float i = 0.0; i < 2.0; i++) {\n        uv = fract(uv) * 2. - 1.;\n\n        color.x = length(uv);\n\n        color.x = smoothstep(0.5, 1., color.x);\n        color.x = 0.1 / color.x;\n\n\n        if (length(uv) < 0.1) {\n            color.x = 0.0;\n        }\n    }\n\n    uv = uv0;\n\n    uv.y += sin(-myTime) * pi0 / closeness;\n    uv.x -= myTime / 10.;\n\n    uv.x += sin(-myTime) * pi0 / closeness;\n    uv.y += myTime / 10.;\n    for (float i = 0.0; i < 2.0; i++) {\n        uv = fract(uv) * 2. - 1.;\n        uv *= possin(myTime) / 7. + 0.9;\n\n        if (i < 1. || abs(uv.x) + abs(uv.y) > 0.7) {\n            continue;\n        }\n\n        color = 1.0 - color;\n        color = 1. / color;\n\n        color /= 5.;\n\n        if (abs(uv.x) > 0.3 || abs(uv.y) > 0.3) {\n            continue;\n        }\n\n        float cap = 0.5;\n        float av = (color.x + color.y) / round((abs(uv.x) + abs(uv.y)) * 10.) / 10.;\n\n        if (av > cap) {\n            cap = av;\n        }\n\n        color.x = av;\n        color.y = av;\n        color.xy *= 5.;\n\n        color.x = color.x > cap ? cap : color.x;\n        color.y = color.y > cap ? cap : color.y;\n    }\n    fragColor = vec4(color, 0.1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msVyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 59], [62, 62, 87, 87, 121], [123, 123, 180, 180, 2008]], "test": "untested"}
{"id": "cljyWc", "name": "Pigeon Dolly Zoom", "author": "tristanantonsen", "description": "Pigeon be pidging. Mouse Y controls focal length", "tags": ["raymarching", "sdf", "penguin"], "likes": 21, "viewed": 361, "published": 3, "date": "1696692157", "time_retrieved": "2024-07-30T17:30:03.661951", "image_code": "// Ray marching constants\n#define MAX_STEPS 250\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCutSphere( vec3 po, vec3 c, float r, float h )\n{\n    vec3 p = po-c;\n    float w = sqrt(r*r-h*h);\n    \n    vec2 q = vec2( length((p).xz), p.y );\n    \n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x * 2.*TAU);\n    //p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = orbitControls(po);\n    //vec3 p = po;\n    vec3 pSym = vec3(abs(p.x), p.y, p.z);\n    vec2 res;\n    \n    // body + head\n    float s1 = sdEllipsoid(p, vec3(0., -0.3, 0.),vec3(0.65, 0.54, 0.7));\n    float s2 = sdEllipsoid(p, vec3(0., -0.4, 0.4),vec3(0.4, 0.3, 0.4));\n    res = vec2(s1, 1.0); // id to track color\n    float h = sdCapsule(p, vec3(0.0, 0., -0.35), vec3(0.0, 0.7, -0.4), 0.3);\n    h += 0.07 * p.y;\n    res.x = opSmoothUnion(s1, h, 0.2);\n    \n    // tail\n    float s31 = sdEllipsoid(p, vec3(0., -0.4, 1.),vec3(0.15, 0.06, 0.4));\n    \n    res.x = opSmoothUnion(res.x, s2, 0.2);\n\n    // wings\n    vec3 psw = vec3(pSym.x, pSym.y * (1.0 + 0.6 * pSym.z) + 0.2 * pSym.z, pSym.z);\n    vec3 prw = rotZ(rotY(psw, 0.15), 0.4);\n    float w = sdEllipsoid(prw, vec3(0.45, -0.48, 0.1), vec3(0.1, 0.35, 0.45));\n    \n    res.x = opSmoothUnion(res.x, w, 0.05);\n    \n    // eyelids\n    float lidAngle = 0.3;\n    vec3 pre = rotX(pSym-vec3(0.135, 0.65, -0.6), lidAngle); // translate then rotate\n    pre = rotZ(pre, 0.3);\n    float el = sdCutSphere(pre, vec3(0.0), 0.08\n    , 0.02)-0.01;\n    res.x = opSmoothUnion(res.x, el, 0.02);\n    if (el < res.x+SURF_DIST) res.y = .0;\n    \n    // eyes\n    float e = sdSphere(pSym, vec3(0.135, 0.65, -0.6), 0.07);\n    res.x = opSmoothUnion(res.x, e, 0.);\n    if (e < res.x+SURF_DIST) res.y = 2.0;\n    \n    float pupil = sdSphere(pSym, vec3(0.16, 0.66, -0.63), 0.045);\n    pupil = opIntersection(pupil, e);\n    res.x = opSmoothUnion(res.x, pupil, 0.);\n    if (pupil < res.x+SURF_DIST) res.y = 5.0;\n    \n    \n    // beak\n    float bk = sdEllipsoid(p, vec3(0., 0.55, -0.65), vec3(0.11, 0.06, 0.12));\n    float bkb = sdEllipsoid(p, vec3(0., 0.53, -0.65), vec3(0.09, 0.06, 0.07));\n    bk = opSmoothUnion(bk, bkb, 0.0);\n    \n    res.x = opSmoothUnion(res.x, bk, 0.0);\n    if (bk < res.x+SURF_DIST) res.y = 3.0;\n    \n    float bkc = sdEllipsoid(p, vec3(0., 0.575, -0.65), vec3(0.09, 0.06, 0.05));\n    if (bkc < res.x+SURF_DIST) res.y = 2.0;\n    res.x = opSmoothUnion(res.x, bkc, 0.0);\n    \n    \n    \n    // foots\n    \n    vec3 heel = vec3(0.25, -1.1, -0.);\n    vec3 hip = vec3(0.25, -0.75, -0.);\n    res.x = opSmoothUnion(res.x, sdSphere(pSym, hip-vec3(0.02,0.,0.), 0.125), 0.06);\n    \n    \n    float l = sdCapsule(pSym, hip, heel + vec3(0., 0.02, 0.), 0.04);\n    float t1 = sdCapsule(pSym, heel, heel + vec3(0., 0., -0.15), 0.04);\n    float t2 = sdCapsule(pSym, heel, heel + vec3(0.1, 0., -0.15), 0.04);\n    float t3 = sdCapsule(pSym, heel, heel + vec3(-0.1, 0., -0.15), 0.04);\n    float toes = opUnion(t1, opUnion(t2, t3));\n    \n    l = opSmoothUnion(l, toes, 0.02);\n    \n    \n    res.x = opSmoothUnion(res.x, l, 0.);\n    if (l < res.x+SURF_DIST) res.y = 3.0;\n\n\n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    \n    // Dolly Zoom and re-center by shifting/squeezing ray origin & target\n    float my = (2.*iMouse.y-iResolution.y)/iResolution.y;  \n    float shift = min(10. * my, 8.5);\n    \n    vec3 rt = vec3(0., -0.05, -0.5);\n    vec3 ro = vec3(0., -0.05, -10. + shift);\n    \n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        vec3 c1 = vec3(0.2,0.8,1.);\n        vec3 c2 = vec3(0.8,0.2,1.);\n        \n        vec3 color = c1;\n        \n        if (d.y == 2.) color.xyz = vec3(1.);        \n        if (d.y == 3.) color.xyz = vec3(1., 0.9, 0.4);        \n        if (d.y == 4.) color.xyz = vec3(1.);        \n        if (d.y == 5.) color.xyz = vec3(0.);        \n        \n        \n        \n        color *= illumination; \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n                \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45 + specular * 0.08;\n        \n        \n        fragColor = vec4(color, 1.0);\n        \n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cljyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 310, 352, 352, 388], [390, 390, 433, 433, 463], [465, 465, 511, 511, 620], [622, 622, 674, 674, 795], [797, 797, 853, 853, 1135], [1287, 1287, 1323, 1323, 1344], [1346, 1346, 1387, 1447, 1474], [1475, 1475, 1517, 1517, 1543], [1545, 1545, 1595, 1595, 1694], [1695, 1695, 1751, 1751, 1851], [1852, 1852, 1908, 1908, 2007], [2153, 2153, 2181, 2181, 2331], [2333, 2333, 2361, 2361, 2511], [2513, 2513, 2541, 2541, 2691], [2693, 2693, 2722, 2722, 2891], [3051, 3051, 3070, 3083, 5857], [5859, 5859, 5892, 5892, 6205], [6207, 6207, 6230, 6230, 6564], [6566, 6566, 6611, 6638, 7239], [7242, 7242, 7299, 7349, 9089]], "test": "untested"}
{"id": "DdKcW3", "name": "Advancing  circular tunnel", "author": "eudaimon", "description": "Nice walk through a never ending simple tunnel that changes color with time.\nIntended to work as a wallpaper, so no excessive attention is drawn.\nFirst created in the Shader Editor Android app.", "tags": ["tunnel", "calm", "wallpaper"], "likes": 3, "viewed": 168, "published": 3, "date": "1696687809", "time_retrieved": "2024-07-30T17:30:04.612410", "image_code": "#define SPEED 4.\n#define PI 3.14159265\n\nfloat atan2(vec2 p) {\n\n      return atan(p.y/p.x) + ((p.x >0.) ? 0. : PI);\n\n  }\n\nvec2 c2uv (vec2 coord) {\n  float mn = min(iResolution.x, iResolution.y);\n  return (coord-iResolution.xy/2.)/mn;\n  }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = c2uv(fragCoord.xy);\n\n  float d=length(uv); //black fog\n  float ang=atan2(uv)+iTime;\n  float v=sin(4./d + iTime * SPEED);\n  v=smoothstep(.9,1.,v);\n\n  float r=.5*sin(ang)+.5;\n  float g=.5*sin(ang+(2.*PI/3.))+.5;\n  float b=.5*sin(ang+(4.*PI/3.))+.5;\n  vec3 ctint=vec3(r,g,b);\n\n\n  vec3 col=vec3(v);\n\n  \n\n\n  col *= d*ctint;\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 61, 61, 119], [121, 121, 145, 145, 236], [241, 241, 298, 298, 663]], "test": "untested"}
{"id": "mdl3RN", "name": "Exact Polyhedron SDF", "author": "mla", "description": "Exact SDF for Wythoffian polyhedra. See code header for controls etc.", "tags": ["sdf", "polyhedra", "exact"], "likes": 29, "viewed": 281, "published": 3, "date": "1696687283", "time_retrieved": "2024-07-30T17:30:05.572842", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wythoff construction for convex polyhedra, with an exact SDF.\n// Matthew Arcus, mla, 2023\n//\n// https://en.wikipedia.org/wiki/Wythoff_construction\n//\n// Controls:\n// Mouse changes orientation\n// up/down: zoom\n// 1-3: show face types 1-3\n// a: AA\n// e: just show edges\n// m: mirror faces\n// r: rotation\n// t: texture faces\n// z: slice at z = 0\n//\n// Uses exact distance to triangular faces (or subdivisions of faces) \n// rather than distance to face planes, enabling, eg. SDF rounding\n// to work.\n//\n// Snubs can be done in the same way, but omitted here as this\n// considerably complicates the code.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float precis = 0.0001; // Ray marching precision, scaled by distance\nconst float attenuation = 0.75; // Ray marching fiddle factor\nfloat maxdistance = 5.0;\n\n// Any P,Q,R with 1/P + 1/Q + 1/R > 1, which means:\n// 2:2:2, 3:2:2, 4:2:2, ...\n// 3:3:2, 4:3:2, 5:3:2\n\nfloat P = 2.0, Q = 3.0, R = 5.0;\n//float P = 10.0, Q = 2.0, R = 2.0;\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (5 3 2) or (10 2 2)\nint NFOLDS = 5;\n\n// Types of feature\nint FACE0 = 1;\nint FACE1 = 2;\nint FACE2 = 3;\nint EDGE = 4;\n\n// 3 mirror planes (passing through origin) define a fundamental\n// region, which intersects the unit sphere in a spherical\n// triangle with angles PI/P, PI/Q, PI/R.\n// The normal polyhedron has a vertex in the fundamental region,\n// edges from the vertex perpendicular to the mirror planes, and\n// faces perpendicular to the lines of intersection of the mirror\n// planes.\n// The dual polyhedron has faces perpendicular to the vector to\n// the region vertex, and vertices on the mirror plane intersections.\n\nvec3 A,B,C;    // normal vectors for mirror planes\nvec3 D,E,F;    // face centre axes of normal faces\nvec3 X;        // the vertex point & face centre of dual\nvec3 G,H,I; // vertices of the dual\nvec3 trilinear = vec3(1);\n\nvoid initgeometry() {\n  // Setup folding planes\n  float p = PI/P, q = PI/Q, r = PI/R;\n  // |A| = |B| = |C| = 1\n  // A.B = -cos(p)\n  // A.C = -cos(r)\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  // It's more convenient to make A,B,C point _out_ of\n  // the fundamental region (away from the region vertex)\n  A = vec3(-1,0,0);\n  B = vec3(cos(p),-sin(p),0);\n  float x = cos(r);\n  float y = (cos(p)*cos(r)+cos(q))/sin(p);\n  float z = -sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n\n  // Convert trilinear to normal coordinates\n  D = cross(B,C), E = cross(C,A), F = cross(A,B);\n  X = mat3(D,E,F)*trilinear;\n  X = normalize(X); // vertex at unit distance\n\n  // Scale so edge centres (for both normal and dual) are on unit sphere.\n  float scale = min3(edgedistance(X,A),\n                     edgedistance(X,B),\n                     edgedistance(X,C));\n  X /= scale;\n\n  D = normalize(D);\n  E = normalize(E);\n  F = normalize(F);\n\n  // Dual vertices\n  G = D/dot(X,D);\n  H = E/dot(X,E);\n  I = F/dot(X,F);\n}\n\nvec3 fold(vec3 pos,out int parity) {\n  parity = 0;\n  if (key(CHAR_F)) return pos;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A);\n    parity += int(k > 0.0);\n    pos -= 2.0*max(0.0,k)*A;\n    k = dot(pos,B);\n    parity += int(k > 0.0);\n    pos -= 2.0*max(0.0,k)*B;\n    k = dot(pos,C);\n    parity += int(k > 0.0);\n    pos -= 2.0*max(0.0,k)*C;\n  }\n  return pos;\n}\n\n// Distance to triangular wedge,vertex at origin, sides (normalized) vectors s,t,\n// n is normalized normal (ie. normalize(cross(s,t)))\nfloat wedgeDistance(const vec3 p, vec3 s, vec3 t, vec3 n, out bool isedge, vec2 uv) {\n  float edgeradius = 0.03;\n  isedge = true;\n  bool justedges = key(CHAR_E);\n  // If p not directly above the wedge, return the distance to edges\n  float d = sqrt(min(ray2(p,s),ray2(p,t)))-edgeradius;\n  if (justedges || dot(p,cross(s,n)) > 0.0 ||  dot(p,cross(t,n)) < 0.0) return d;\n  float d0 = dot(n,p); // Projection onto wedge\n  if (!key(CHAR_T)) d0 += 0.01*cos(100.0*uv.x)*cos(100.0*uv.y); // Displacement\n  d0 = abs(d0) - 0.005; // Thickness\n  if (d0 < d) {\n    d = d0; isedge = false;\n  }\n  return d;\n}\n\nfloat scene(vec3 pos, int parity, out int type, out vec2 uv) {\n  float d = 1e8, d0;\n  vec2 uv0 = pos.xy;\n  bool isedge,isedge0;\n  float off = 0.2; //0.5-0.5*cos(0.5*iTime);\n  if (!key(CHAR_0+1)) {\n    d0 = wedgeDistance(pos-X-off*F,A,B,F,isedge0,uv0);\n    if (d0 < d) { d = d0; isedge = isedge0; type = FACE0; uv = uv0; }\n  }\n  if (!key(CHAR_0+2)) {\n    d0 = wedgeDistance(pos-X-off*D,B,C,D,isedge0,uv0);\n    if (d0 < d) { d = d0; isedge = isedge0; type = FACE1; uv = uv0; }\n  }\n  if (!key(CHAR_0+3)) {\n    d0 = wedgeDistance(pos-X-off*E,C,A,E,isedge0,uv0);\n    if (d0 < d) { d = d0; isedge = isedge0; type = FACE2; uv = uv0; }\n  }\n  if (isedge) type = EDGE;\n  return d;\n}\n\nfloat map(vec3 pos, out int type, out vec2 uv) {\n  float d = -1e8;\n  if (key(CHAR_Z)) d = pos.z-0.1;\n  int parity;\n  pos = fold(pos,parity);\n  return max(d,scene(pos,parity,type,uv));\n}\n\nfloat map(vec3 pos) {\n  int type; vec2 uv;\n  return map(pos,type,uv);\n}\n\n// Tetrahedron technique, from:\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(vec3 p) {\n  float h = 0.0002;\n  vec2 k = vec2(1,-1);\n  return normalize( k.xyy*map( p + k.xyy*h ) + \n                    k.yyx*map( p + k.yyx*h ) + \n                    k.yxy*map( p + k.yxy*h ) + \n                    k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 200; i++) {\n    //assert(i < 10);\n    if (t > maxdistance) break;\n    float h = map(ro+rd*t);\n    t += attenuation*h;\n    if (h < t*precis) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p;\n}\n\nvec3 circuit[] = vec3[](\n   vec3(1,1,1),vec3(1,1,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,0),vec3(1,1,0),vec3(0,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,1,1),vec3(0,0,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,1)\n );\n\nconst int nsteps = circuit.length();\n\nvec3 PQR[] = vec3[](\n  vec3(2,3,5), vec3(2,3,4),vec3(2,3,3),vec3(2,2,3),vec3(2,2,10)\n);\n\nvec3 gettrilinear(float t) {\n  int i = int(floor(t));\n  int cycle = (i/nsteps)%PQR.length();\n  i %= nsteps;\n  P = PQR[cycle][0], Q = PQR[cycle][1], R = PQR[cycle][2];\n  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));\n}\n\nvec3 speccolor(int type) {\n  if (type == FACE0) return vec3(1,0,0);\n  if (type == FACE1) return vec3(1,1,0);\n  if (type == FACE2) return vec3(0,0,1);\n  return vec3(1);\n}\n\n// softshadow from iq.\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w) {\n  float t = mint;\n  float res = 1.0;\n  for (int i = 0; i < 200; i++) {\n    float h = map(ro + t*rd);\n    res = min(res, h/(w*t));\n    t += clamp(h, 0.0, max(0.5,0.1*t));\n    if (res < -1.0 || t > tmax) break;\n  }\n  res = max(res,-1.0); // clamp to [-1,1]\n  res = 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n  return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Trilinear coordinates of vertex point (ie. proportional distance\n  // from sides of fundamental region).\n  trilinear = gettrilinear(0.5*iTime);\n  initgeometry();\n  float camera = 3.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdistance = camera+5.0;\n  vec3 ro = vec3(0,0,camera);\n  vec3 light = vec3(0.5, 1.0, 2.0);\n  ro = transform(ro);\n  light = transform(light);\n  light = normalize(light);\n  vec3 aacol = vec3(0);\n  float AA = 1.0;\n  if (key(CHAR_A)) AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord.xy+vec2(i,j)/AA) - iResolution.xy) / iResolution.y;\n      vec3 rd = vec3(z,-2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      vec3 col = 0.75+0.25*rd; //texture(iChannel0,rd).xyz;\n      col = pow(col,vec3(2.2));\n      float t = march(ro, rd);\n      if (t < maxdistance) {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n        int type;\n        vec2 uv;\n        map(pos,type,uv); // Get type and uv\n        float specpow, specval;\n        if (type == EDGE) {\n          col = vec3(0);\n          specpow = 2.0;\n          specval = 0.1;\n        } else {\n          col = vec3(0.5);\n          specpow = 10.0;\n          specval = 1.0;\n        }\n        //col = vec3(0.5);\n        if (key(CHAR_M) && type < EDGE) {\n          col = texture(iChannel1,reflect(rd,n)).xyz;\n        } else {\n          float diffuse = clamp(dot(n, light), 0.0, 1.0);\n          float shadow = softshadow(pos,light,0.1,4.0,0.1);\n          diffuse *= shadow;\n          col *= 0.2 + 0.8*diffuse;\n          float specular = pow(max(0.0,dot(reflect(light,n),rd)),specpow);\n          col += specval*specular*speccolor(type);\n        }\n      }\n      aacol += col;\n    }\n  }\n  //assert(keystate(KEY_ALT,0).x == 0.0);\n  aacol /= AA*AA;\n  aacol = 2.0*aacol/(1.0+aacol);\n  aacol = clamp(aacol,0.0,1.0);\n  aacol = pow(aacol,vec3(0.4545));\n  if (alert) aacol.x = 1.0;\n  fragColor = vec4(aacol, 1.0);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.75 + 0.25*rayDir;\n\n    //col = 0.5*mix(vec3(1),col,0.8);\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "common_code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90; // rotation\n\nconst float PI\t= 3.14159265359;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat edgedistance(vec3 pos, vec3 X) {\n  return length(pos-dot(pos,X)*X);\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a,min(b,c));\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\n// Distance of p from ray in direction dir from origin\n// dir assumed normalized\nfloat ray2(vec3 p, vec3 dir) {\n  float h = dot(p,dir);\n  h = max(0.0,h);\n  p -= h*dir;\n  return dot(p,p);\n}", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdl3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2035, 2035, 2056, 2082, 3024], [3026, 3026, 3062, 3062, 3408], [3410, 3546, 3631, 3631, 4140], [4142, 4142, 4204, 4204, 4814], [4816, 4816, 4864, 4864, 5001], [5003, 5003, 5024, 5024, 5074], [5076, 5173, 5198, 5198, 5435], [5437, 5437, 5474, 5474, 5698], [5700, 5700, 5727, 5727, 6060], [6442, 6442, 6470, 6470, 6669], [6671, 6671, 6697, 6697, 6840], [6842, 6865, 6934, 6934, 7263], [7265, 7265, 7322, 7432, 9315]], "test": "untested"}
{"id": "csVcWV", "name": "Gloopy Rings", "author": "Lewie4", "description": "Super proud of this and how it turned out. Mostly just playing with polynomial smooth min and the motion. \n\nWould love to get this down to a tweet or two. Any help to make this cleaner would be greatly appreciated!", "tags": ["sdf", "circle", "ring", "glow", "loop", "cool"], "likes": 8, "viewed": 199, "published": 3, "date": "1696686141", "time_retrieved": "2024-07-30T17:30:06.456479", "image_code": "#define speed 1.5\n#define sc .75\n#define offset .35\n#define blend .1\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a,b)-h*h*k*(1.0/4.0);\n}\n\nvec2 target(float stage, float ring)\n{\n    vec2 o = vec2(0.);\n    float p = 0.;\n    \n    if (stage <= 0.)\n    {\n        p = (mod(ring, 2.)*2.-1.)*offset;\n        o = vec2(0.,p);\n    }\n    else if (stage <= 1.)\n    {\n        p = (step(1.5,mod(ring,4.))*2.-1.)*offset;\n        o = vec2(p,p*.5);\n    }\n    else if(stage <= 2.)\n    {\n        p = (step(3.5,mod(ring,8.))*2.-1.)*offset;\n        o = vec2(-p, p*.5);\n    }\n    else if(stage <= 3.)\n    {\n        p = (step(1.5,mod(ring,4.))*2.-1.)*offset;\n        o = vec2(-p,-p*.5);\n    }\n    else if (stage <=4.)\n    {\n        p = (step(3.5,mod(ring,8.))*2.-1.)*offset;\n        o = vec2(p, -p*.5);\n    }\n    else if (stage <=5.)\n    {\n        p = (mod(ring,2.)*2.-1.)*offset;\n        o = vec2(0.,-p);\n    }\n\n    return o;\n}\n\nvoid motion(float stage, float prog, inout float scale, float ring, out float t, out vec2 p)\n{\n    float change = sc;\n\n    if(stage >= 3.)\n    {\n        change = 1./sc;\n    }\n    \n    p = target(stage,ring);\n    t = smoothstep(0.,1.,prog - stage);\n    scale = mix(scale, scale * change, t);\n    p = p * t;\n}\n\nvoid steps(float prog, float ring, out vec2 cur, out float val)\n{\n    float scale = .35;\n\n    cur = vec2(0.);\n    val = scale;\n    for(float i = 0.; i < 6.; i++ )\n    {\n        float t = 0.;\n        vec2 p = vec2(0.);\n        motion(i, prog, scale, ring, t ,p);\n        cur += p;\n        val = mix(val, scale, t);\n    } \n        \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor -= fragColor;\n    fragCoord = (fragCoord+fragCoord-iResolution.xy)/iResolution.y;\n\n    fragCoord = fragCoord*rotate(iTime*.25);\n    \n    float prog = mod(iTime * speed, 6.);\n    float c = 1.;\n    \n    for(float i = 0.; i < 8.; i++)\n    {\n        vec2 cur = vec2(0.);\n        float val = 0.;\n        steps(prog, i, cur, val);\n        val = length(fragCoord+cur)-val;\n        c = smin(c, val, blend);        \n    }\n\n    c = pow(0.01 / abs(c), 1.2);\n    vec3 col = c * (cos(vec3(0,1,2) + iTime)+1.2);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 92, 92, 168], [170, 170, 209, 209, 286], [288, 288, 326, 326, 1054], [1056, 1056, 1150, 1150, 1363], [1365, 1365, 1430, 1430, 1696], [1698, 1698, 1753, 1753, 2302]], "test": "untested"}
{"id": "mdGyDc", "name": "SpecialBlur", "author": "nomkcode", "description": "test", "tags": ["specialblur"], "likes": 0, "viewed": 103, "published": 3, "date": "1696682175", "time_retrieved": "2024-07-30T17:30:07.288256", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = vec2(0.0, 1.0) / iResolution.xy;\n\n    // 通过鼠标点击设定模糊边界\n    vec3 col = specialBlur(iChannel0, iChannel1, uv, offset);\n    if(uv.x > iMouse.x / iResolution.x){\n        col = texture(iChannel2, uv).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// now we got img's border info. we can use this to blur img in similar region(not cross the border)\n\nconst float weight[20] = float[20](0.12238567125008,\n        0.11682268619326,\n        0.10158494451587,\n        0.080421414408401,\n        0.057903418374049,\n        0.037859927398416,\n        0.022435512532395,\n        0.012019024570926,\n        0.0058022877238952,\n        0.0025143246803546,\n        0.00097328697304049,\n        0.00033456739698267,\n        0.00010138405969172,\n        2.6836956977219e-05,\n        6.134161594793e-06,\n        1.192753643432e-06,\n        1.9341950974573e-07,\n        2.5449935492859e-08,\n        2.6102497941393e-09,\n        1.9576873456045e-10);\nconst int R = 20;\n\nvec3 specialBlur(in sampler2D originTex, in sampler2D borderTex, in vec2 uv, in vec2 offset)\n{\n    float f = texture(borderTex, uv).r;\n    vec3 ansColor = vec3(0.0);\n    if(f >= 0.5)\n        ansColor = texture(originTex, uv).rgb;\n    else{\n    \tansColor = texture(originTex, uv).rgb * weight[0];\n        float norm = weight[0];\n        for(int i = 1; i < R; i++){\n            float f_t = texture(borderTex, uv + float(i) * offset).r;\n            if(f_t > 0.5)\tbreak;\n        \tansColor += texture(originTex, uv + float(i) * offset).rgb * weight[i];\n            norm += weight[i];\n        }\n        \n        for(int i = 1; i < R; i++){\n        \tfloat f_t = texture(borderTex, uv - float(i) * offset).r;\n            if(f_t > 0.5)\tbreak;\n        \tansColor += texture(originTex, uv - float(i) * offset).rgb * weight[i];\n            norm += weight[i];\n        }\n        \n        ansColor /= norm;\n \n    }\n    \n    return   ansColor; \n}", "buffer_a_code": "// gaussian blur\n// first step we apply gaussian blur to remove Noise\n// which is helpful to border detection\n\n// for efficient we can separate our 2-dimensional Gaussian function into two 1-dimensional one  \n// (http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/) \n// Because of the limit of the number of buffers we can't do this on shadertoy\n\n\n// 3 * 3 gaussian blur\nconst float w[9] = float[9](\n\t0.095, 0.118, 0.085, 0.118, 0.147, 0.118, 0.095, 0.118, 0.095\n);\n\nvec3 gaussianBlur(in sampler2D tex, in vec2 uv){\n\tvec3 sumColor = vec3(0.0);\n    for(int x = 0; x < 3; x++){\n        for(int y = 0; y < 3; y++){\n        \tint index = x * 3 + y;\n            vec2 offset = vec2(float(x - 1), float(y - 1)) / iResolution.xy;\n            sumColor += texture(tex, uv + offset).rgb * w[index];\n        }\n    }\n    return sumColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec3 blurColor = gaussianBlur(iChannel0, uv);\n    fragColor = vec4(blurColor, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//soble border detection\n//guassian blur can remove Noise\n//then we apply soble operator on image\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = 1.0 / iResolution.x;\n\tfloat h = 1.0 / iResolution.y;\n\n\tn[0] = texture(tex, coord + vec2( -w, -h));\n\tn[1] = texture(tex, coord + vec2(0.0, -h));\n\tn[2] = texture(tex, coord + vec2(  w, -h));\n\tn[3] = texture(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture(tex, coord);\n\tn[5] = texture(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture(tex, coord + vec2( -w, h));\n\tn[7] = texture(tex, coord + vec2(0.0, h));\n\tn[8] = texture(tex, coord + vec2(  w, h));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec4 n[9];\n    make_kernel(n, iChannel0, uv);\n    // sobel\n    vec4 gx = (n[6] + 2.0 * n[7] + n[8])  - (n[0] + 2.0 * n[1] + n[2]);\n    vec4 gy = (n[0] + 2.0 * n[3] + n[6]) - (n[2] + 2.0 * n[5] + n[8]);\n    \n    vec4 finalColor = vec4(0.0);\n    //finalColor = sqrt(gx * gx) + sqrt(gy * gy);\n    finalColor = sqrt(gx * gx + gy * gy);\n    \n    fragColor = vec4(clamp(finalColor.rgb, 0.0, 1.0), sqrt(length(gy) / length(gx)));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const float threshold = 0.5;\n//NMS\nbool NMS(in vec2 fragCoord){\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec4 c = texture(iChannel0, uv);\n    float gp = length(c.rgb);\n    float xita = c.a;\n    float p1 = 0.0, p2 = 0.0,p3 = 0.0, p4 = 0.0;\n    float step_x = 1.0 / iResolution.x;\n    float step_y = 1.0 / iResolution.y;\n    if(xita > 1.0){\n    \tp1 = length(texture(iChannel0, uv + vec2(0.0, -step_y)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(step_x, -step_y)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(0.0, step_y)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(-step_x, step_y)).rgb);\n    }else if(xita > 0.0){\n    \tp1 = length(texture(iChannel0, uv + vec2(step_x, -step_y)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(step_x, 0.0)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(-step_x, step_y)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(-step_x, 0.0)).rgb);\n    }else if(xita > -1.0){\n    \tp1 = length(texture(iChannel0, uv + vec2(step_x, 0.0)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(step_x, step_y)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(-step_x, 0.0)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(-step_x, -step_y)).rgb);\n    }else{\n    \tp1 = length(texture(iChannel0, uv + vec2(step_x, step_y)).rgb);\n        p2 = length(texture(iChannel0, uv + vec2(0.0, step_y)).rgb);\n        p3 = length(texture(iChannel0, uv + vec2(-step_x, -step_y)).rgb);\n        p4 = length(texture(iChannel0, uv + vec2(0.0, -step_y)).rgb);\n    }\n    \n    float gp1 = xita * p2 + (1.0 - xita) * p1;\n    float gp2 = xita * p4 + (1.0 - xita) * p3;\n    //float gp1 = xita * p1 + (1.0 - xita) * p2;\n    //float gp2 = xita * p3 + (1.0 - xita) * p4;\n    \n    if(gp >= gp1 && gp >= gp2){\n        if((c.r + c.b + c.g) / 3.0 > threshold)\n            return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(NMS(fragCoord))\n        fragColor = vec4(vec3(1.0),1.0);\n    else\n        fragColor = vec4(vec3(0.0),1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// special blur Horizontal\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = vec2(1.0, 0.0) / iResolution.xy;\n    vec3 ansColor = specialBlur(iChannel0, iChannel1, uv, offset);\n    fragColor = vec4(ansColor, 1.0);\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 452]], "test": "untested"}
{"id": "mdGyD3", "name": "SurfaceBlur1-test", "author": "nomkcode", "description": "对r，g，b三通道分别计算，复杂度高，可以发现单击鼠标在移动过程中有延时", "tags": ["surfaceblur"], "likes": 0, "viewed": 95, "published": 3, "date": "1696682029", "time_retrieved": "2024-07-30T17:30:08.089115", "image_code": "const float R = 5.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 offset = vec2(1.0) / iResolution.xy;\n    \n    vec3 final_c = surfaceBlur(iChannel0, uv, R, offset);\n    // 通过鼠标点击设定模糊边界\n    vec3 col = texture(iChannel0, uv).rgb;\n    if(uv.x > iMouse.x / iResolution.x){\n        col = final_c.rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Y = 78.0;\n\nvec3 surfaceBlur(in sampler2D tex, in vec2 uv, float r, in vec2 offset){\n    vec3 center_c = texture(tex, uv).rgb;\n    vec3 sum_color = vec3(0.0);\n    for(int i = 0; i < 3; i++){\n        float sum_i = 0.0;\n        float norm = 0.0;\n        for(float x = -r; x <= r; x++){\n            for(float y = -r; y <= r; y++){\n                vec2 uv2 = uv + vec2(x * offset.x, y * offset.y);\n                vec3 cur_c = texture(tex, uv2).rgb;\n                \n                float para = 1.0 - abs(center_c[i] - cur_c[i]) * 255.0 / (2.5 * Y);\n                sum_i += para * cur_c[i] * 255.0;\n                norm += para;\n            }\n        }\n        sum_color[i] = sum_i / norm;\n    }\n    return sum_color/255.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 129, 497]], "test": "untested"}
{"id": "mdycWc", "name": "RadiaBlur", "author": "nomkcode", "description": "径向模糊", "tags": ["radiablur"], "likes": 0, "viewed": 107, "published": 3, "date": "1696681996", "time_retrieved": "2024-07-30T17:30:08.863046", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= 2.0;\n    if(uv.x <= 1.0)\n        fragColor = texture(iChannel0, uv);\n    else\n         fragColor = texture(iChannel1, uv - vec2(1.0, 0.0));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(0.0);\n    //vec2 uv = fragCoord / iResolution.xy;\n    //uv *= 2.0;\n    //uv -= 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    vec2 offset = uv - center;\n    \n    fragColor = vec4(vec3(length(offset)) * 0.57, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 stepp = vec2(1.0) / iResolution.xy;\n    float R = 0.0 + 20.0 * (0.5 + 0.5 * sin(iTime * 4.23));\n    int type = 1;\n    vec3 fianl_c = RadialBlur(iChannel0, iChannel1, uv, type, R, stepp);\n    \n    fragColor = vec4(fianl_c, 1.0);\n}", "buffer_b_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ROTATE 1\n#define SCALE 2\nconst vec2 center = vec2(0.5);\n\nvec3 RadialBlur(in sampler2D mulriple_tex, in sampler2D origin_tex, in vec2 uv, int type, float R, vec2 stepp)\n{    \n    vec2 offset = uv - center;\n    offset = normalize(offset);\n    vec2 direction = offset;\n    if(type == ROTATE){\n    \tdirection = vec2(-offset.y,offset.x);\n    }\n    \n    float mulriple = texture(mulriple_tex, uv).r;\n    float r = R * mulriple;\n    vec3 sum_c = vec3(0.0);\n    float norm = 0.0;\n    for(float i = -r; i < r; i++){\n    \tvec2 uv2 = uv + direction * i * stepp;\n        sum_c += texture(origin_tex, uv2).rgb;\n        norm += 1.0;\n    }\n    sum_c /= norm;\n    return sum_c;\n}", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 stepp = vec2(1.0) / iResolution.xy;\n    float R = 0.0 + 20.0 * (0.5 + 0.5 * sin(iTime* 4.23));\n    int type = 2;\n    vec3 fianl_c = RadialBlur(iChannel0, iChannel1, uv, type, R, stepp);\n    \n    fragColor = vec4(fianl_c, 1.0);\n}", "buffer_c_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdycWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 298]], "test": "untested"}
{"id": "dsGczt", "name": "holes in dough/rubber", "author": "FabriceNeyret2", "description": "Simulates a deforming material preserving the amount of yellow matter: \nEach cell contains the same yellow area.\nNext step: accounts for stretching anisotropy.", "tags": ["stretching", "conservation", "dough"], "likes": 16, "viewed": 304, "published": 3, "date": "1696675700", "time_retrieved": "2024-07-30T17:30:09.619024", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    float t = .3*iTime, s;\n    vec2  R = iResolution.xy, U;\n    s = 14./R.y;// * exp2(5.*(iMouse.y/R.y-.5));\n    U = s * u;                                               // scaling\n    U += vec2( 1.7*sin(t+.3*U.y) -    cos(2.3*t-.2*U.x),     // distortion\n               cos(1.2*t-.4*U.y) - .4*sin(2.7*t+.3*U.x) );\n\n    float a0 = // .6,  // bubble can totally close           // target yellow cell surface. \n                  .5,  // max bubble opening\n           a = s*s / determinant(  mat2(dFdx(U),dFdy(U)) ),  // surface in s*fragCoord units. \n           l = length( fract(U)-.5 ),                        // polar coord per tile cell\n        // r = sqrt(max(0.,a-a0))/1.77;                      // a - pi.r^2 = a0 → r = sqrt( (a-a0)/pi )\n           r = sqrt(max(0.,1.-a0/a))/1.77;                   // a*(1 - pi.r^2) = a0 → r = sqrt( (1-a0/a)/pi )\n           \n    O = vec4( smoothstep(-1.,1., (l-r)/fwidth(l)   ) );      // draw yellow material \n // O *= .6 / a;                                                                      // debug: intensity = contraction\n    if ( r==0. ) O *= vec4(1,0,0,0);                                                  // debug: negative area\n    U = fract(U)-.5; l = U.x*U.y; O.b = smoothstep(1.,0., abs(l)/min(.1,fwidth(l)) ); // debug: show grid\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1331]], "test": "untested"}
{"id": "csGcDc", "name": "BoxBlur-test", "author": "nomkcode", "description": "test", "tags": ["boxblur"], "likes": 0, "viewed": 146, "published": 3, "date": "1696672289", "time_retrieved": "2024-07-30T17:30:10.368021", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // 通过鼠标点击设定模糊边界\n    vec3 col = texture(iChannel0, uv).rgb;\n    if(uv.x > iMouse.x / iResolution.x){\n        col = texture(iChannel1, uv).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float weight = 1.0/9.0;\nfloat offset[5] = float[5](0.0, 1.0, 2.0, 3.0, 4.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 sum_color = texture(iChannel0, uv).rgb * weight;\n    for(int i = 1; i < 5; ++i){\n        sum_color += texture(iChannel0, uv + vec2(0.0, offset[i] / iResolution.y)).rgb * weight;\n        sum_color += texture(iChannel0, uv - vec2(0.0, offset[i] / iResolution.y)).rgb * weight;\n    }\n    fragColor = vec4(sum_color, 1.0);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float weight = 1.0/9.0;\nfloat offset[5] = float[5](0.0, 1.0, 2.0, 3.0, 4.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 sum_color = texture(iChannel0, uv).rgb * weight;\n    for(int i = 1; i < 5; ++i){\n        sum_color += texture(iChannel0, uv + vec2(offset[i] / iResolution.x, 0.0)).rgb * weight;\n        sum_color += texture(iChannel0, uv - vec2(offset[i] / iResolution.x, 0.0)).rgb * weight;\n    }\n    fragColor = vec4(sum_color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGcDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 382]], "test": "untested"}
{"id": "cdyyD3", "name": "GaussianBlur-test", "author": "nomkcode", "description": "test", "tags": ["test"], "likes": 0, "viewed": 106, "published": 3, "date": "1696668024", "time_retrieved": "2024-07-30T17:30:11.117019", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // 通过鼠标点击设定模糊边界\n    vec3 col = texture(iChannel0, uv).rgb;\n    if(uv.x > iMouse.x / iResolution.x){\n        col = texture(iChannel1, uv).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float weight[5] = float[5](70.0/256.0, 56.0/256.0, 28.0/256.0, 8.0/256.0, 1.0/256.0);\nfloat offset[5] = float[5](0.0, 1.0, 2.0, 3.0, 4.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec3 sum_color = texture(iChannel0, uv).rgb * weight[0];\n    for(int i = 1; i < 5; ++i){\n    \tsum_color += texture(iChannel0, uv + vec2(offset[i] / iResolution.x, 0.0)).rgb * weight[i];\n        sum_color += texture(iChannel0, uv - vec2(offset[i] / iResolution.x, 0.0)).rgb * weight[i];\n    }\n    fragColor = vec4(sum_color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float weight[5] = float[5](70.0/256.0, 56.0/256.0, 28.0/256.0, 8.0/256.0, 1.0/256.0);\nfloat offset[5] = float[5](0.0, 1.0, 2.0, 3.0, 4.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 sum_color = texture(iChannel0, uv).rgb * weight[0];\n    for(int i = 1; i < 5; ++i){\n        sum_color += texture(iChannel0, uv + vec2(0.0, offset[i] / iResolution.y)).rgb * weight[i];\n        sum_color += texture(iChannel0, uv - vec2(0.0, offset[i] / iResolution.x)).rgb * weight[i];\n    }\n    fragColor = vec4(sum_color, 1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdyyD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 383]], "test": "untested"}
{"id": "mdVcDV", "name": "Mousable High-order FDTD", "author": "fishy", "description": "added mouse functionality. also this is very cool", "tags": ["fdtd"], "likes": 3, "viewed": 128, "published": 3, "date": "1696652245", "time_retrieved": "2024-07-30T17:30:11.866115", "image_code": "// Standard FDTD vs. fourth order FDTD\n\n// Finite Difference Time-Domain (FDTD) methods are a family of numerical schemes\n// which allow to compute wave propagation on a regular grid.\n// They compute an approximate solution of the wave equation \n// by using approximate formulas for the partial derivatives.\n// The results therefore contain some errors, mostly in the form of \"dispersion\",\n// which manifests itself as a \"ripple\" effect.\n//\n// The most common version of FDTD uses second-order approximation in space and time using\n// five neighboring samples (the current pixel and its four neighbors).\n// This results in strong dispersion when fewer than about 20 points per wavelength are used.\n// The use of a finer grid allows to reduce this dispersion error, at an increased computational cost.\n//\n// Another way to reduce the dispersion error is to use higher-order methods.\n// Higher-order methods compute a more accurate approximation of the partial derivatives by looking\n// at more samples.\n// They allow to use fewer points per wavelength, at the cost of an increased number of operations\n// per point.\n//\n// The scheme implemented here is a fourth order FDTD, as described by Shubin and Bell in 1987.\n// The computation uses a 14-point stencil.\n//\n// The displayed graphics compare the two techniques: standard FDTD is shown in red,\n// whereas fourth-order FDTD is shown in green.\n// In the beginning they overlap; however, they very soon start to diverge, as numerical\n// dispersion spoils the results of the second-order method faster: this is indicated\n// by the presence of red ripples.\n//\n// Note that the simulation results depend on the screen resolution: higher resolution will\n// make both methods more accurate, so that it will take more time before they start to look\n// different. Conversely, at small resolutions, they will start differing almost instantly.\n\nMain {\n    float v4 = A(U).x;\n    float v2 = A(U).z;\n    \n    // Red is standard (second order), green is fourth order\n    vec4 col = vec4(100,0,0,0) * abs(v2) + vec4(0,100,0,0) * abs(v4);\n    Q = mix(vec4(0.5), col, isInDomain(uu(U)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 init(vec2 u) {\n    //u -= vec2(-1.0,0.62);\n    //return vec4(1) * exp(-1000.*dot(u,u)) * (u.x * u.y) * 3000.;\n    return vec4(1,1,1,1) * exp(-10000.*dot(u,u));\n    //return 0.1 * vec4(1) * exp(-5000.*u.x*u.x);\n}\n\nMain {\n    Q = A(U);\n    \n    // This is the value of (c * Δt^2/Δx^2)\n    float dt2 = 0.5;\n    // Any number between zero and 0.5 may be used.\n    // Smaller values mean slower simulation, but do not make the simulation more accurate.\n    // On the contrary, the most accurate value to use is 0.5, for which\n    // the dispersion of the 2nd order scheme is minimal in the four diagonal directions\n    // (notice the directional pattern of the ripples).\n    \n    // Basic FDTD\n    {\n        float n = A(U+vec2(0,1)).z;\n        float s = A(U-vec2(0,1)).z;\n        float w = A(U-vec2(1,0)).z;\n        float e = A(U+vec2(1,0)).z;\n        float pn = Q.z;\n        float pnm1 = Q.w;\n\n\n        float p_next = 2.*pn - pnm1 + dt2 * (n+s+w+e - 4.*Q.z);\n        Q.z = p_next;\n        Q.w = pn;\n    }\n    \n    // Fourth-order FDTD\n    // as described in\n    // A Modified Equation Approach to Constructing Fourth Order Methods for Acoustic Wave Propagation\n    // Shubin and Bell\n    // SIAM 1987\n    // https://doi.org/10.1137/0908026\n    // It is based on a modified equation technique to compensate terms of the Taylor expansion\n    // up to the fourth order. \n    {\n        float n = A(U+vec2(0,1)).x;\n        float s = A(U-vec2(0,1)).x;\n        float w = A(U-vec2(1,0)).x;\n        float e = A(U+vec2(1,0)).x;\n        float pn = Q.x;\n        float pnm1 = Q.y;\n\n        float nn = A(U+vec2(0,2)).x;\n        float nw = A(U+vec2(-1,1)).x;\n        float ne = A(U+vec2(1,1)).x;\n        float ww = A(U+vec2(-2,0)).x;\n        float ee = A(U+vec2(2,0)).x;\n        float sw = A(U+vec2(-1,-1)).x;\n        float se = A(U+vec2(1,-1)).x;\n        float ss = A(U+vec2(0,-2)).x;\n\n        float D2xp = w - 2.*pn + e;\n        float D2yp = s - 2.*pn + n;\n        float D4xp = ww - 4.*w + 6.*pn - 4.*e + ee;\n        float D4yp = ss - 4.*s + 6.*pn - 4.*n + nn;\n        float D2xD2yp = sw + se + nw + ne - 2.*(s + w + n + e) + 4.*pn;\n        float p_next = 2.*pn - pnm1 + dt2 * (D2xp + D2yp) \n                      - dt2/12. * ( (1.-dt2) * (D4xp+D4yp) - 2.*dt2*D2xD2yp);\n\n\n        Q.y = pn;\n        Q.x = p_next;\n    }\n    \n    // Initial conditions or resolution change\n    if(iFrame == 0 || A(vec2(0)).xy != R) {\n        Q = vec4(0);\n    }\n    \n    if(iMouse.z > 0.0)\n    Q += init(uu(U) - uu(iMouse.xy)) * 0.05;\n    \n    Q *= isInDomain(uu(U));\n    \n    if(floor(U) == vec2(0)) {\n        Q.xy = R;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define R (iResolution.xy)\n#define uu(U) ((2.*U-R)/R.y)\n\n//#define FOURTH_ORDER\n\nfloat isInDomain(vec2 u) {\n    float rectangle = step(abs(u.x), 1.0) * step(abs(u.y), 0.618);\n    float obstacle = step(0.1, length(u - vec2(0.3,0.5)));\n    return rectangle;// * obstacle;\n    //return step(u.x, 1.618) * step(u.y, 1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "DsKyWK", "name": "High-order FDTD", "author": "athibaul", "description": "Red is standard (second-order) finite differences, green is fourth order finite differences. Notice the decreased dispersion.", "tags": ["ripples", "grid", "wavelength", "finitedifferences", "waveequation", "fdtd", "yee"], "likes": 20, "viewed": 247, "published": 3, "date": "1696636970", "time_retrieved": "2024-07-30T17:30:12.625984", "image_code": "// Standard FDTD vs. fourth order FDTD\n\n// as described in\n// A Modified Equation Approach to Constructing Fourth Order Methods for Acoustic Wave Propagation\n// Shubin and Bell\n// SIAM 1987\n// https://doi.org/10.1137/0908026\n\n// Finite Difference Time-Domain (FDTD) methods are a family of numerical schemes\n// which allow to compute wave propagation on a regular grid.\n// They compute an approximate solution of the wave equation \n// by using approximate formulas for the partial derivatives.\n// The results therefore contain some errors, mostly in the form of \"dispersion\",\n// which manifests itself as a \"ripple\" effect.\n//\n// The most common version of FDTD uses second-order approximation in space and time using\n// five neighboring samples (the current pixel and its four neighbors).\n// This results in strong dispersion when fewer than about 20 points per wavelength are used.\n// The use of a finer grid allows to reduce this dispersion error, at an increased computational cost.\n//\n// Another way to reduce the dispersion error is to use higher-order methods.\n// Higher-order methods compute a more accurate approximation of the partial derivatives by looking\n// at more samples.\n// They allow to use fewer points per wavelength, at the cost of an increased number of operations\n// per point.\n//\n// The scheme implemented here is a fourth order FDTD, as described by Shubin and Bell in 1987.\n// The computation uses a 14-point stencil.\n//\n// The displayed graphics compare the two techniques: standard FDTD is shown in red,\n// whereas fourth-order FDTD is shown in green.\n// In the beginning they overlap; however, they very soon start to diverge, as numerical\n// dispersion spoils the results of the second-order method faster: this is indicated\n// by the presence of red ripples.\n//\n// Note that the simulation results depend on the screen resolution: higher resolution will\n// make both methods more accurate, so that it will take more time before they start to look\n// different. Conversely, at small resolutions, they will start differing almost instantly.\n\nMain {\n    float v4 = A(U).x;\n    float v2 = A(U).z;\n    \n    // Red is standard (second order), green is fourth order\n    vec4 col = vec4(100,0,0,0) * abs(v2) + vec4(0,100,0,0) * abs(v4);\n    Q = mix(vec4(0.5), col, isInDomain(uu(U)));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 init(vec2 u) {\n    #if SETUP == 0\n    //u -= vec2(-1.0,0.62);\n    //return vec4(1) * exp(-1000.*dot(u,u)) * (u.x * u.y) * 3000.;\n    return vec4(1,1,1,1) * exp(-10000.*dot(u,u));\n    //return 0.1 * vec4(1) * exp(-5000.*u.x*u.x);\n    #elif SETUP == 1\n    vec2 v = u - vec2(-0.7-0.3,0.2);\n    vec4 Q = vec4(0,0,1,1) * exp(-8000.*dot(v,v));\n    v = u - vec2(0.7-0.3,0.2);\n    Q += vec4(1,1,0,0) * exp(-8000.*dot(v,v));\n    return Q;\n    #endif\n}\n\nMain {\n    Q = A(U);\n    \n    // This is the value of (c * Δt^2/Δx^2)\n    float dt2 = 0.5;\n    // Any number between zero and 0.5 may be used.\n    // Smaller values mean slower simulation, but do not make the simulation more accurate.\n    // On the contrary, the most accurate value to use is 0.5, for which\n    // the dispersion of the 2nd order scheme is minimal in the four diagonal directions\n    // (notice the directional pattern of the ripples).\n    \n    // Basic FDTD\n    {\n        float n = A(U+vec2(0,1)).z;\n        float s = A(U-vec2(0,1)).z;\n        float w = A(U-vec2(1,0)).z;\n        float e = A(U+vec2(1,0)).z;\n        float pn = Q.z;\n        float pnm1 = Q.w;\n\n\n        float p_next = 2.*pn - pnm1 + dt2 * (n+s+w+e - 4.*Q.z);\n        Q.z = p_next;\n        Q.w = pn;\n    }\n    \n    // Fourth-order FDTD\n    // as described in\n    // A Modified Equation Approach to Constructing Fourth Order Methods for Acoustic Wave Propagation\n    // Shubin and Bell\n    // SIAM 1987\n    // https://doi.org/10.1137/0908026\n    // It is based on a modified equation technique to compensate terms of the Taylor expansion\n    // up to the fourth order. \n    {\n        float n = A(U+vec2(0,1)).x;\n        float s = A(U-vec2(0,1)).x;\n        float w = A(U-vec2(1,0)).x;\n        float e = A(U+vec2(1,0)).x;\n        float pn = Q.x;\n        float pnm1 = Q.y;\n\n        float nn = A(U+vec2(0,2)).x;\n        float nw = A(U+vec2(-1,1)).x;\n        float ne = A(U+vec2(1,1)).x;\n        float ww = A(U+vec2(-2,0)).x;\n        float ee = A(U+vec2(2,0)).x;\n        float sw = A(U+vec2(-1,-1)).x;\n        float se = A(U+vec2(1,-1)).x;\n        float ss = A(U+vec2(0,-2)).x;\n\n        float D2xp = w - 2.*pn + e;\n        float D2yp = s - 2.*pn + n;\n        float D4xp = ww - 4.*w + 6.*pn - 4.*e + ee;\n        float D4yp = ss - 4.*s + 6.*pn - 4.*n + nn;\n        float D2xD2yp = sw + se + nw + ne - 2.*(s + w + n + e) + 4.*pn;\n        float p_next = 2.*pn - pnm1 + dt2 * (D2xp + D2yp) \n                      - dt2/12. * ( (1.-dt2) * (D4xp+D4yp) - 2.*dt2*D2xD2yp);\n\n\n        Q.y = pn;\n        Q.x = p_next;\n    }\n    \n    // Initial conditions or resolution change\n    if(iFrame == 0 || A(vec2(0)).xy != R) {\n        Q = init(uu(U));\n    }\n    \n    Q *= isInDomain(uu(U));\n    \n    if(floor(U) == vec2(0)) {\n        Q.xy = R;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0, ivec2(U), 0)\n#define R (iResolution.xy)\n#define uu(U) ((2.*U-R)/R.y)\n\n//#define FOURTH_ORDER\n\n#define SETUP 1\n\nfloat isInDomain(vec2 u) {\n    #if SETUP == 0\n    float rectangle = step(abs(u.x), 1.0) * step(abs(u.y), 0.618);\n    float obstacle = step(0.1, length(u - vec2(0.3,0.5)));\n    return rectangle;// * obstacle;\n    //return step(u.x, 1.618) * step(u.y, 1.0);\n    #elif SETUP == 1\n    u.x = abs(u.x) - 0.7;\n    return step(abs(u.x), 0.6) * step(abs(u.y), 0.6);\n    #endif\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsKyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cdKyWV", "name": "ozone", "author": "Trixelized", "description": "ozone fx", "tags": ["ozone"], "likes": 11, "viewed": 168, "published": 3, "date": "1696624181", "time_retrieved": "2024-07-30T17:30:13.371989", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x /= iResolution.y / iResolution.x;\n    uv += 0.5;\n    \n    vec2 warp = uv * 4.0;\n    \n    float t = iTime / 4.0;\n    \n    for (int i=0; i<3; i++) {\n        \n        float tmul = float(i) * 0.75 + 1.0;\n        warp.x += sin(warp.y * tmul + sin(t));\n        warp.y += sin(warp.x * tmul + cos(t));\n        \n    }\n    \n    float val = abs(mod(warp.x, 2.0) - 1.0);\n    \n    val *= smoothstep(0.0, 1.0, length(uv - 0.5) * 2.0);\n    \n    vec3 col = mix(\n        mix(vec3(1.0, 0.1, 0.7), vec3(0.0, 0.05, 0.1), length(uv - 0.4) * 0.6),\n        mix(vec3(1.0, 0.7, 0.9), vec3(1.0, 0.0, 0.3), length(uv - 0.6) * 0.6),\n        smoothstep(0.8, 0.9, val) + val\n    );\n    \n    fragColor = vec4(col, 1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdKyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 820]], "test": "untested"}
{"id": "msycDV", "name": "Flow Fields͏", "author": "01000001", "description": "I have no idea what I'm doing :D", "tags": ["simulation", "particles", "slime", "life", "automaton", "voronoitracking"], "likes": 6, "viewed": 207, "published": 3, "date": "1696616254", "time_retrieved": "2024-07-30T17:30:14.130960", "image_code": "// Buffer A : Particle control\n// Buffer B : Voronoi Tracking\n// Buffer C : Rendering\n// Buffer D : Post processing\n\n// See Buffer A to play around with particle configurations\n// I've included a few fun presets to try :D\n\n// You may wanna use the shadertoy unofficial plugin\n// to speed it up by increasing drawcalls\n// For interactivity though, realtime is nice\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef display_voronoi\n        O = uv.x>.5?\n            texture(iChannel2, uv):\n            texture(iChannel1, uv).xyzw/r.x/r.y;\n    #else \n        O = texture(iChannel2, uv);\n        \n        //*    \n        O = vec4(\n            O.x*O.x, \n            O.x, \n            sqrt(O.x), \n        1.);//*/\n\n    #endif\n}\n\n// Next up: Ant simulation!\n// And then turbulent particles 👀\n// ^ I wanna recreate this render I made in Blender\n// https://cdn.discordapp.com/attachments/1134975470526537879/1156789266739900456/still_particles.png\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Particle Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    // if (uv.x * scale > 1. || uv.y * scale > 1.) return;\n    // Prevent simulation of particles out of bounds\n    // If we allow it then can resize at runtime\n    \n    \n    if (iFrame < 30){\n    \n        O.xy = uv*scale;\n        O.zw = normalize(hash(uvec3(U, iDate.w)).xy*2.-1.);\n        return;\n        \n    }\n\n    O = texture(iChannel0, uv);\n\n    vec2 pos = O.xy;        \n    vec2 vel = O.zw;\n\n    \n    vel += field(pos*6.2 + 2.1)*1e-2;\n    \n    \n    float l = length(vel);\n    if (l > 1.) vel = normalize(vel);\n    vel *= 0.997; // try .998 with pos*2.2 above\n    \n    \n    \n    pos += vel*1e-3 * vec2(1, aspect);\n\n\n    pos = mod(pos, 1.);\n\n    O = vec4(pos, vel);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Voronoi buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (iFrame < 10){\n        O = vec4(0);\n        return;\n    }\n    \n    \n    O = texture(iChannel1, uv);\n    \n    vec2 myParticles[4];\n    vec4 particleDists;\n    \n    for (int i = 4; i-->0;){\n        myParticles[i] = texture(iChannel0, decrypt(O[i], r)/scale).xy;\n        particleDists[i] = length(myParticles[i] - uv);\n    }\n    \n    \n    for (int i = 10; i-->0;){\n\n        for (int j = 4; j-->0;){\n        \n            vec3 a = hash(uvec3(U, iFrame - i + j*8))*2.-1.;\n            vec3 b = hash(uvec3(U, iFrame * i - j  ))*2.-1.;\n            vec3 c = hash(uvec3(U, iFrame + i - j*8))*2.-1.;\n        \n            vec2 samp = decrypt(\n                texture(iChannel1,\n                    mod(myParticles[j]\n                        + (a.xy + vec2(a.z, b.x) + b.yz + c.xy) / (r.x/scale) \n                        // Gaussian-ish sampling\n                        // we can use two vec3s to get three vec2s \n                        // and then another one for good measure\n                    ,1.) // Mod loops around overflow coordinates\n                )[i%5]\n            ,r);\n\n            vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n            push(O, samp, r, particleDists[j], length(newParticle-uv));\n            // Stores four particle IDs in the floats\n        }\n    }\n    \n    \n    for (int i = 0; i < 2; i++){\n        vec2 samp = hash(uvec3(U, iFrame * i)).xy;\n        \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n        push(O, samp, r, particleDists[0], length(newParticle-uv));\n        // Completely random samples may not seem too critical, \n        // but they significantly improve the stability of the simulation\n    }\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n     // I am become pixel, creator of shaders\n    // - 01000001 2023\n\nconst float pi = 3.14159;\nconst float scale = 3.;\n// Try big number to see what's going on. 3 is about the minimum that works semi coherently.\n// Any improvements to accurately render an even larger quanitity of particles would be appreciated :D\n// I have a few ideas but I'd love to learn about the community's knowledge\n\n\n// #define debug\n// Render particles directly, no visual processing\n\n// #define display_voronoi\n// Show the voronoi buffer\n\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\nmat2 rot( float rad ){\n    return mat2(\n        cos(rad), sin(rad),\n        -sin(rad), cos(rad)\n    );\n}\n\nvec2 decrypt(float d, vec2 r){\n    return vec2(mod(d, r.x), floor(d/r.x))/r;\n}\n\nfloat encrypt(vec2 uv, vec2 r){\n    return uv.x*r.x + floor(uv.y*r.y)*r.x;\n}\n\nvoid push(inout vec4 O, vec2 uv, vec2 res, float me, float new){\n    ivec2 iuv = ivec2(floor(uv*res));\n    ivec2 ires = ivec2(floor(res));\n    \n    float e = encrypt(uv, res);\n    if (new < me && e != O.x && e != O.y && e != O.z && e != O.w){\n        O.w = O.z; O.z = O.y; O.y = O.x;\n        O.x = e;\n    }\n    \n}\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 field(vec2 uv){\n    return vec2(noise(uv), noise(uv + 500.));\n}", "buffer_c_code": "// Render Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    O = vec4(0);\n    \n    float minD = 2.;\n    float x = 0.;\n    for (int i = 0; i<2; i++){\n    \n        for (int j = 4; j-->0;){\n            vec2 samp = decrypt(\n                texture(iChannel1, \n                    uv + (circleSample(uvec3(U, iFrame * i << j)) / (r.x / scale))\n                )[j]\n            ,r)/scale;\n\n            x = length(\n                (texture(iChannel0, samp).xy - uv) * vec2(1, 1./aspect)\n            );\n\n            if (x < minD){\n                minD = x;\n            }\n        }\n    }\n    \n    #ifdef debug\n    #else\n        O = texture(iChannel2, uv\n            //+ (vec2(scale*3e-3)/r)*rot(float(iFrame) * pi/2.)\n        );\n        O *= .96;\n    #endif\n    O += smoothstep(scale/r.x * .25, 0., minD);\n        \n    \n    if (iMouse.z > 0.){\n        if (texelFetch(iChannel3, ivec2(16, 0), 0).x > .0){\n            O.x += max(0., 1.-length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 500.);\n        } else {\n            O *= min(1., length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 200.);   \n        }\n    }\n    \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Post Processing\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef debug\n        O = texture(iChannel2, uv);\n    #else\n        O = texture(iChannel3, uv);\n        O *= .95;\n        O += texture(iChannel2, uv)*1e-2;\n    #endif\n    \n    // Because of SIMD, vector as opposed to operating on only O.x\n    // should be the same speed right? I hope? Pls lmk in comments :)\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msycDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 404, 404, 775]], "test": "untested"}
{"id": "msyyWV", "name": "Colourful Tree", "author": "Retr0id", "description": "a more colourful (and actually infinite) variant of my previous iteration.", "tags": ["tree", "rainbow"], "likes": 15, "viewed": 504, "published": 3, "date": "1696609222", "time_retrieved": "2024-07-30T17:30:14.878960", "image_code": "\nfloat factor = 2.0;\nfloat segments = 16.0;\nfloat zoom = 4.0;\nfloat smoothfactor = .01;\nfloat tau = 3.14159265359*2.0;\nfloat gamma = 1.0/2.2;\n\n\n// via https://www.shadertoy.com/view/lldBRn\nfloat noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nvec4 test(vec2 uv) {\n    return vec4(uv.x, 0.0, uv.y, 1.0);\n}\n\nvec4 basic(vec2 uv) {\n    return vec4(vec3(pow(smoothstep(0.0, 1.0, sin(-uv.y*tau)*(smoothfactor*iResolution.y)+0.5), 1.0/2.2)), 1.0);\n}\n\nvec4 trees(vec2 uv, float foo, float bar) {\n    float blah = (abs(uv.y-0.5)-(uv.x*0.25*sqrt(2.0)/pow(sqrt(2.0), uv.x))<0.0?round(foo*2.0):(uv.y>0.5?ceil(foo*2.0):floor(foo*2.0)))/2.0/bar;\n    float linedist = abs(abs(uv.y-0.5)-(uv.x*0.25*sqrt(2.0)/pow(sqrt(2.0), uv.x)));\n    float thiccness = 0.05*pow(factor, -uv.x);\n    float brightness = smoothstep(0.0, 1.0, linedist/thiccness);\n    float hueseed = noise1d(blah*10000.0)*tau;\n    vec3 hue = cos(vec3(0.0+hueseed, (1.0/3.0)*tau+hueseed, (2.0/3.0)*tau+hueseed))*0.5+0.5;\n    return vec4(pow(hue*brightness, vec3(0.75)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv = uv0;\n    //uv = vec2(1.0-uv.y, uv.x);\n\n    float t = iTime / pow(factor, segments-4.0);\n\n    uv.x = uv.x * segments + 1.0; // repeat n times\n    uv.y -= 0.5; // vertical centering\n    uv.y *= pow(factor, 1.0-fract(uv.x)) * zoom; // exponential scaling\n    float speed = pow(factor, uv.x-fract(uv.x));\n    uv.y += t * speed; // make each wheel faster than the previous\n   \n    // Output to screen\n    //fragColor = test(mod(uv, 1.0));\n    fragColor = trees(mod(uv, 1.0), uv.y, speed);\n    //fragColor = abs(uv0.y-0.5) <0.004 ? vec4(1.0, 0.0, 0.0, 1.0) : fragColor; // red line\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 189, 212, 212, 253], [255, 255, 275, 275, 316], [318, 318, 339, 339, 454], [456, 456, 499, 499, 1036], [1038, 1038, 1095, 1145, 1778]], "test": "untested"}
{"id": "mdycDK", "name": "Milky Mosh", "author": "s_fx", "description": "Weird cream.\nR = reset, F = fade", "tags": ["2d", "fade", "milk"], "likes": 2, "viewed": 139, "published": 3, "date": "1696608064", "time_retrieved": "2024-07-30T17:30:15.636934", "image_code": "/* (c) 2023 s.fx */\n\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    o = texture(iChannel0, c / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* (c) 2023 s.fx */\n\nconst float S = .005; // step size\n\nvoid mainImage( out vec4 o, in vec2 c )\n{\n    vec2 uv = c / iResolution.xy;\n    vec3 col;\n    bool r = texelFetch(iChannel2, ivec2(82, 0), 0).x == 1.;\n    bool f = texelFetch(iChannel2, ivec2(70, 0), 0).x == 1.;\n    \n    if (r || iFrame <= 10)\n        col = texture(iChannel1, uv).rgb;\n    else\n    {\n        col = texture(iChannel0, uv).rgb;\n        \n        // normalize dark color to continue movement\n        if (f) col = normalize(col);\n        \n        // go top right and down left\n        //if (iFrame % 2 == 0)\n            col -= .5;\n        \n        col = texture(iChannel0, uv + normalize(col.xy) * S).rgb;\n    \n        if (f) col *= .97;\n    }\n    \n    o = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdycDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 62, 62, 112]], "test": "untested"}
{"id": "dsGyDK", "name": "animated pattern", "author": "punpun", "description": "animated pattern", "tags": ["animatedpattern"], "likes": 0, "viewed": 111, "published": 3, "date": "1696602396", "time_retrieved": "2024-07-30T17:30:16.384934", "image_code": "// Author @patriciogv - 2015\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return (1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0));\n}\n\nfloat triangle(in vec2 st, float num){\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Number of sides of your shape\n  float N = num;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n\n  // Shaping function that modulate the distance\n  float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  return (1.0-smoothstep(.4,.41,d));\n\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nvec2 tile(in vec2 st, float space){\n    return vec2(fract(st.x*space), fract(st.y*space));\n    // return vec2(fract(st.x*space), st.y);\n    // return vec2(st.x, fract(st.y*space));\n    // return vec2(st.x,st.y);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st = rotate2D(st, PI*.25*iTime*.2);\n    st = tile(st, 4.0);\n    st = rotate2D(st, PI*.25*iTime*.5);\n\n\n    // color = vec3(st,0.0);\n    // color = vec3(circle(st,0.5));\n    // color = vec3(circle(tile(st, 9.0),0.5));\n    // color = vec3(triangle(st));\n    // if(mod(st.x, 2.0) == 1.0) {\n    //     color = vec3(box(st, vec2(.7), .1), mod(fract(u_time)*.5, 2.), sin(u_time));\n    // }else if(st.y >= .2) {\n    //     color = vec3(triangle(st), mod(fract(u_time)*.5, 2.), sin(u_time));\n    // }\n\n    // 001\n    // color = vec3(triangle(st, sin(u_time+3.)*10.), mod(fract(u_time)*.5, 2.), sin(u_time));\n\n    // 002\n    // if(st.x <= .5 && st.y <= .5) color = vec3(triangle(st, sin(u_time+3.)*10.), mod(fract(u_time)*.5, 2.), sin(u_time));\n    // if(st.x > .5 && st.y > .5) color = vec3(triangle(st, sin(u_time+3.)*10.), mod(fract(u_time)*.5, 2.), sin(u_time));\n\n    // 003\n    if(st.x > .5 && st.y > .5) color = vec3(box(st, vec2(.7), .1), mod(fract(iTime)*.5, 2.), sin(iTime));\n    if(st.x <= .5 && st.y <= .5) color = vec3(box(st, vec2(.7), .1), mod(fract(iTime)*.5, 2.), sin(iTime));\n\n\tfragColor = vec4(color.x, color.y, abs(sin(iTime)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 225, 225, 395], [397, 397, 435, 470, 786], [788, 788, 840, 840, 1033], [1036, 1036, 1071, 1071, 1249], [1251, 1251, 1289, 1289, 1429], [1431, 1431, 1487, 1487, 2746]], "test": "untested"}
{"id": "dsGcWK", "name": "exp: 001", "author": "punpun", "description": "exp 001", "tags": ["exp001"], "likes": 0, "viewed": 130, "published": 3, "date": "1696601220", "time_retrieved": "2024-07-30T17:30:17.212721", "image_code": "\n\n//#ifdef GL_ES\n//precision mediump float;\n//#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n//uniform vec2 u_resolution;\n//uniform float u_time;\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return (1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0));\n}\n\nfloat triangle(in vec2 st){\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Number of sides of your shape\n  int N = 3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x,st.y)+PI;\n  float r = TWO_PI/float(N);\n\n  // Shaping function that modulate the distance\n  float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n  return (1.0-smoothstep(.4,.41,d));\n\n}\n\nfloat box(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\n\nvec2 tile(in vec2 st, float space){\n    return vec2(fract(st.x*space), fract(st.y*space));\n    // return vec2(fract(st.x*space), st.y);\n    // return vec2(st.x, fract(st.y*space));\n    // return vec2(st.x,st.y);\n}\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    st.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st = tile(st, 4.0);\n    st = rotate2D(st, PI*.25*iTime);\n\n\n    // color = vec3(st,0.0);\n    // color = vec3(circle(st,0.5));\n    // color = vec3(circle(tile(st, 9.0),0.5));\n    // color = vec3(triangle(st));\n    if(mod(st.x, 2.0) == 1.0) {\n        color = vec3(box(st, vec2(.7), .1), mod(fract(iTime)*.5, 2.), sin(iTime));\n    }else if(st.y >= .2) {\n        color = vec3(triangle(st), mod(fract(iTime)*.5, 2.), sin(iTime));\n    }\n\n\tfragColor = vec4(color.x, color.y, abs(sin(iTime)), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 207, 207, 377], [379, 379, 406, 441, 753], [755, 755, 807, 807, 1000], [1003, 1003, 1038, 1038, 1216], [1218, 1218, 1256, 1256, 1396], [1398, 1398, 1454, 1454, 2064]], "test": "untested"}
{"id": "mdGcWK", "name": "Infinite Tree", "author": "Retr0id", "description": "That's a lie, it's actually finite! If you watch for long enough (~34 minutes), you will run out of tree.", "tags": ["tree"], "likes": 6, "viewed": 217, "published": 3, "date": "1696601173", "time_retrieved": "2024-07-30T17:30:17.971691", "image_code": "\nfloat factor = 2.0;\nfloat segments = 16.0;\nfloat zoom = 4.0;\nfloat smoothfactor = .01;\nfloat tau = 3.14159265359*2.0;\n\nvec4 test(vec2 uv) {\n    return vec4(uv.x, 0.0, uv.y, 1.0);\n}\n\nvec4 basic(vec2 uv) {\n    return vec4(vec3(pow(smoothstep(0.0, 1.0, sin(-uv.y*tau)*(smoothfactor*iResolution.y)+0.5), 1.0/2.2)), 1.0);\n}\n\nvec4 trees(vec2 uv, float foo, float bar) {\n    float linedist = abs(abs(uv.y-0.5)-(uv.x*0.25*sqrt(2.0)/pow(sqrt(2.0), uv.x)));\n    float thiccness = 0.1*pow(factor, -uv.x);\n    return vec4(vec3(pow(smoothstep(1.0, 0.0, linedist/thiccness), 1.0/2.2)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv = uv0;\n    //uv = vec2(1.0-uv.y, uv.x);\n\n    float t = iTime / pow(factor, segments-5.0);\n\n    uv.x = uv.x * segments; // repeat n times\n    uv.y -= 0.5; // vertical centering\n    uv.y *= pow(factor, mod(-uv.x, 1.0)) * zoom; // exponential scaling\n    float speed = pow(factor, floor(uv.x));\n    uv.y += t * speed; // make each wheel faster than the previous\n   \n    // Output to screen\n    //fragColor = test(mod(uv, 1.0));\n    fragColor = uv.y < 0.0 || uv.y > speed ? vec4(vec3(0.0), 1.0) : trees(mod(uv, 1.0), uv.y, speed);\n    //fragColor = abs(uv0.y-0.5) <0.004 ? vec4(1.0, 0.0, 0.0, 1.0) : fragColor; // red line\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 140, 140, 181], [183, 183, 204, 204, 319], [321, 321, 364, 364, 580], [582, 582, 639, 689, 1363]], "test": "untested"}
{"id": "msGyzK", "name": "Analytic Radial Motion Blur", "author": "fenix", "description": "Companion shader to this one, where this function is used:\n\nStarlight Mint Cascade https://shadertoy.com/view/csVyWw#\n\nI built this shader first just to test the motion blur function, but I figured it might be a good technical reference in itself.", "tags": ["blur", "radial", "motion", "analytic"], "likes": 14, "viewed": 179, "published": 3, "date": "1696572428", "time_retrieved": "2024-07-30T17:30:18.733655", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Companion shader to this one, where this function is used:\n//\n//    Starlight Mint Cascade         https://shadertoy.com/view/csVyWw#\n//\n//  I built this shader first just to test the motion blur function, but I figured it\n//  might be a good technical reference in itself. Is radial even the right term for\n//  this kind of blur? Googling, it seems that a radial blur can mean either this kind\n//  or a \"zoom\" blur. Anyway, what I mean by the title is the kind of motion blur you\n//  would need to render a rapidly spinning object with a stripe on it.\n//\n//  On the top is the analytic blur, while the multisample blur is on the bottom. On the\n//  right, the result is applied to an actual circle. On the left you can see the same\n//  function unrolled linearly. There are graph plots at the top and bottom, and a render\n//  in the middle.\n//\n//  It might be easier to see what's going on by taking control with the mouse. With the\n//  mouse clicked all the way to the left, the blur amount is zero, showing the clear\n//  signal. Mouse Y can control the width of the signal. Increasing mouse X increases\n//  the blur amount.\n//\n//  You are encouraged to experiment with SAMPLES. A much higher value serves as ground\n//  truth: I hope/believe that the top and bottom matching in that test is proof that the\n//  results are correct. A lower value cause the artifacts to be more easily visible in the\n//  multisampled result. I chose a middle value for demo purposes to try to show general\n//  correctness while still demonstrating some artifacts at high blur values. The multi\n//  sample artifacts are most visible in the graph view as little bumps, but they can\n//  be seen as stripes, especially when the circle is nearly full or empty.\n//\n//  The key observation that this runs on is that a perfect analytic blur of a square\n//  signal can be built by adding two ramp functions. And then to make it work correctly,\n//  you have to realize that for a radial blur, the ramp functions can wrap multiple times\n//  around the circle. I solve that here by just adding up all the ramps...is there a more\n//  efficient method? It clearly gets better results with fewer samples than basic multi\n//  sampling, anyway. You only need as many iterations as your blur \"wraps around\" which is\n//  probably not more than a handful of times before the circle becomes a uniform color.\n//\n//  I found a few things about this to be counterintuitive. First, as the blur amount\n//  gets pretty large, there develops a large \"flat\" area with no gradient. A uniform\n//  pink color, in between red and white. But actually this makes logical sense, because\n//  if we have a perfect camera, our sweeping signal will pass by all of those pixels\n//  exactly the same duration of time for each pixel, just offset in phase depending\n//  on the angle.\n//\n//  Second, it surprises me that as the blur increases further, there's a period of time\n//  when the circle *opposite* the signal is reddest. But, I guess that's correct if it\n//  matches our \"ground truth\" test. And going back to our perfect camera, all the other\n//  pixels will see the signal once, but some of those opposite pixels will see the signal\n//  *twice*.\n// ---------------------------------------------------------------------------------------\n\n#define R iResolution.xy\nconst float PI = 3.141592543589793;\nconst int SAMPLES = 30; // number of samples (x2) in oversampling\n\n// the actual signal\nfloat f(float x, float a, float b)\n{\n    x = fract(x);\n    if (x < a) return 0.;\n    if (x < b) return 1.;\n    return 0.;\n}\n\n// multisample motion blur on the signal\n// t - value being rendered\n// a - signal begin\n// b - signal end\n// m - blur amount\nfloat motionBlurMs(float t, float a, float b, float m)\n{\n    float x;\n    for (int i = -SAMPLES; i <= SAMPLES; ++i)\n        x += f(t + m * float(i) / float(SAMPLES), a, b);\n    return x / float(SAMPLES * 2 + 1);\n}\n\n// the ramp function is kind of a linear smoothstep. If t is:\n//   below a:         returns zero\n//   above b:         returns one\n//   between a and b: 1D barycentric coordinate\nfloat ramp(float a, float b, float t)\n{\n    return clamp((t - a) / (b - a), 0., 1.);\n}\n\n// analytic motion blur, adding up ramps\n// t - value being rendered\n// a - signal begin\n// b - signal end\n// m - blur amount\nfloat motionBlurAnalytic(float t, float a, float b, float m)\n{\n    float o = ceil(m); // add up as many ramps as the number of times we wrap around due to the huge blur\n    \n    float r = 0.;\n    for (float s = -o; s <= o; ++s)\n        r += ramp(b - m, b + m, s + t) - ramp(a - m, a + m, s + t);\n    return -r;\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    u *= 2. / R;\n\n    vec2 m = iMouse.xy / R;\n    if (iMouse.z <= 0.) m = vec2(-cos(iTime) * .5 - .5, sin(iTime * .2)) * .5 + .5; // animate if no mouse\n        \n    float A = .01, B = m.y; // signal begin/end\n    float M = 2. * max(m.x - .1, 0.); // blur amount\n\n// swappable color schemes:\n#define col(X) mix(vec4(1), vec4(1, 0, 0, 1), X)\n//#define col(X) mix(vec4(.2, .5, .1, 1), vec4(.1, .1, .3, 1), X)\n//#define col(X) mix(vec4(1, .7, .1, 1), vec4(.3, .1, .5, 1), X)\n//#define col(X) mix(vec4(.01), vec4(.7, .5, .1, 1), X)\n    \n    if (u.x < 1.)\n    {\n        // left side (linear graphs)\n        if (u.y < 1.)\n        {\n            // bottom: multisample\n            float ms = motionBlurMs(u.x, A, B, M);\n            \n            if (u.y < .5)\n                O = vec4(1. - step(3./R.y, abs(u.y - ms * .35 - .075))); // multisample graph\n            else if (u.y < 1.)\n                O = col(ms); // multisample color stripe\n        }\n        else\n        {\n            // top: analytic\n            float ma = motionBlurAnalytic(u.x, A, B, M);\n            \n            if (u.y < 1.5)\n                O = col(ma); // analytic colored stripe\n            else\n                O = vec4(1. - step(3./R.y, abs(u.y - ma * .35 - 1.6))); // analytic graph\n        }\n    }\n    else\n    {\n        // right side (circles)\n        vec2 U = u;\n        U.x = U.x - 1.5;\n        U.x *= R.x / R.y;\n        if (length(U - vec2(0., .5)) < .5)\n        {\n            // bottom: multisample circle\n            float a = atan(U.y - .5, U.x) / (PI * 2.) + .5;\n            float ms = motionBlurMs(a, A, B, M);\n            O = col(ms);\n        }\n        else if (length(U - vec2(0., 1.5)) < .5)\n        {\n            // top: analytic circle\n            float a = atan(U.y - 1.5, U.x) / (PI * 2.) + .5;\n            float ma = motionBlurAnalytic(a, A, B, M);\n            O = col(ma);\n        }\n    }\n    \n    // blue dividing lines\n    if (abs(u.y - 1.) < 3. / R.y || abs(u.x - 1.) < 3. / R.x)\n        O = vec4(0, 0, 1, 1);\n    \n    if (u.x < 1. &&\n        (abs(u.y - 1.5) < 3. / R.y || abs(u.y -  .5) < 3. / R.x))\n        O = vec4(0, 0, 1, 1);\n    \n    O = pow(O, vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msGyzK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3628, 3649, 3685, 3685, 3772], [3774, 3900, 3956, 3956, 4113], [4115, 4294, 4333, 4333, 4380], [4382, 4508, 4570, 4570, 4820], [4822, 4822, 4858, 4858, 7020]], "test": "untested"}
{"id": "csVyWw", "name": "Starlight Mint Cascade", "author": "fenix", "description": "An upgrade to my previous shader Peppermint Waterfall, adding a follow cam, wooden shelves, more colors, better motion blur, and more.\n\n*mouse to interact*\n*shift to render shock directions*\n*space to reset*", "tags": ["2d", "voronoi", "simulation", "particles", "dynamics", "tracking", "physics"], "likes": 37, "viewed": 403, "published": 3, "date": "1696572408", "time_retrieved": "2024-07-30T17:30:19.665163", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Based on FabriceNeyret2's comment on Peppermint Waterfall (this shader's fork parent),\n//  with the idea to follow the particles as they fall, plus a few rendering upgrades. I\n//  figured it needed a new look to be worth of being its own shader, plus it needed more\n//  attention to detail to hold up to zooming in.\n//\n//  I don't know if \"starlight mint\" is exactly the right term for this kind of candy. I\n//  just found an image with google called \"assorted startlight mints\" in roughly these\n//  colors. I thought a few more colors would look nice so I went with it.\n//\n//  Adding the follow cam presented some interesting challenges. It became more important\n//  for the particles to interact well off-screen, so that as the camera moves down, the\n//  particles that come into view are already stacked nicely. But, the particle neighbor\n//  update in Peppermint Waterfall depends on sampling the render voronoi buffer. So I\n//  added a neighbors-of-neighbors search to the particle tracking to give it more power.\n//\n//  The construction of the scene is that the candies are essentially flat, existing only\n//  in the z equals zero plane. Their normals and shading are a purely 2.5D effect. This\n//  makes it easy to locate the particles needed for a ray in the 3D scene, for a\n//  reflection or a shadow, since you just need to compute the ray's z crossing point.\n//\n//  The bumpy reflective wood effect is borrowed from my previous shader:\n//\n//      Flowing Water 3D               https://shadertoy.com/view/clScRG\n//\n//  Which is in turn based on iq's:\n//\n//      Screen space bump mapping      https://shadertoy.com/view/ldSGzR\n//\n//  The motion blur on the candies was another area of improvement. In the previous shader\n//  I just sort of fudged something that looked kinda OK. This time I slowed down and did\n//  a study of this kind of motion blur on its own, which I'm releasing as a companion\n//  shader. See this shader for more explanation of the motion blur effect:\n//\n//      Analytic Radial Motion Blur    https://shadertoy.com/view/msGyzK\n//\n//  The camera follows candy zero...can you figure out which particle that is? Hint: it's\n//  red. An alternate way to reset the shader is to use the mouse input to kick that candy\n//  off the shelves. It's necessary to reset the shader once in a while (it does happen\n//  automatically) because the candies start to get more and more spaced out as the\n//  simulation runs. Unlike Peppermint Waterfall, all the candies are created at the\n//  beginning of the simulation in this one, so nothing is helping to keep them clumped\n//  together.\n//\n//  I struggled with the shadows more than I expected. When w is lower in calcSoftShadow,\n//  really bad banding artifacts develop on the shadows under the shelves, which of course\n//  now we zoom in on. I tried covering it up with noise, but that created other artifacts,\n//  so reducing the umbra ended up being the best option. If anyone knows of a better\n//  solution I'd be excited to hear about it.\n//\n//      *mouse to interact*\n//      *up/down arrows to control zoom*\n//      *shift to render shock directions*\n//      *space to reset*\n//\n//  Buffer A and B perform particle simulation. Only A updates the particle neighbors.\n//  Buffer C computes screen-space voronoi for render.\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 LDIR = normalize(vec3(-10, 10, -1)); // light direction\nconst vec3 SHDIR = normalize(vec3(-1, 1, -4.5)); // shadow direction (not the same as the shadow direction)\nconst float THICK = .3; // how wide is the shelf\n\nvec3 marchScene(vec3 p, vec3 rd);\nvoid renderParticles(vec2 p, inout vec4 O);\nvoid renderScene(vec3 hit, vec3 ro, vec3 rd, vec3 ddx_rd, vec3 ddy_rd, inout vec4 O);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    fxGetState();\n    \n    vec2 p = g_State.zoom * (u - .5 * R.xy) / R.y;\n    O = vec4(0);\n\n    // render scene\n    vec3 rd = normalize(vec3(p - vec2(0, 1), 10));\n    vec3 ddx_rd = normalize(vec3(p + vec2(1, 0) / R.x - vec2(0, 1), 10));\n    vec3 ddy_rd = normalize(vec3(p + vec2(0, 1) / R.y - vec2(0, 1), 10));\n\n    vec3 ro = vec3(g_State.cam.x, 1. + g_State.cam.y, -10);\n    vec3 hit = marchScene(ro, rd);\n\n    if (hit.z > 0.) // don't render particles where blocked by a shelf\n        renderParticles(p, O);\n    \n    if (O.a < 1.) // only render shadows where it is not completely blocked by a particle\n        renderScene(hit, ro, rd, ddx_rd, ddy_rd, O);\n\n    O.rgb = pow((O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n\n// From iq's Extrusion and Revolution SDF\n// https://www.shadertoy.com/view/4lyfzw\nfloat opExtrusion(vec3 p, float sdf, float h)\n{\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n// 3D SDF of shelves/wall\nfloat mapScene(vec3 p)\n{\n    float d = opExtrusion(p, sdScene(p.xy, R), THICK);\n    return min(d, THICK - p.z - .1);\n}\n\n// normal of shelves/wall\nvec3 normScene(vec3 p)\n{\n    const vec2 e = vec2(.001, 0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\n// raymarch shelves/wall\nvec3 marchScene(vec3 p, vec3 rd)\n{\n    for (int i = 0; i < 100; ++i)\n    {\n        float d = mapScene(p);\n        if (d < .001) return p;\n        p += rd * d;\n    }\n    return p;\n}\n\n// 3D SDF of particles, for shadow render\nfloat mapParticles(vec3 p)\n{\n    uint id = fxGetClosest(ivec2((p.xy - g_State.cam) * R.y + .5 * R)).x;\n    float d = 1e6;\n    if (id < g_MaxParticles)\n    {\n        fxParticle v = fxGetParticle(id);\n\n        d = length(vec3(v.pos - p.xy, p.z)) - CANDY_R;\n    }\n\n    return d;\n}\n\n// From iq's Soft Shadow Variation\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float maxt, bool par)\n{\n\tfloat res = 1.;\n    float t = mint;\n    float ph = 1e10;\n    const float w = 50.;\n    \n    for (int i = 0; i < 32; i++)\n    {\n\t\tfloat h = mapScene(ro + rd * t);\n        if (par) h = min(h, mapParticles(ro + rd * t)); // only render particles into shadow if rendering background\n     \n        float y = i == 0 ? 0. : h*h/(2.*ph); \n        float d = sqrt(h * h - y * y);\n        \n        res = min(res, w * d / max(0., t - y));\n        ph = h;\n        t += h;\n\n        if (res < .0001 || t > maxt) break;\n    }\n    res = clamp(res, 0., 1.);\n    return res * res * (3. - 2. * res);\n}\n\n// from my Analytic Radial Motion Blur: https://shadertoy.com/view/msGyzK\n\n// analytic motion blur, adding up ramps\n// t - value being rendered\n// a - signal begin\n// b - signal end\n// m - blur amount\nfloat motionBlurAnalytic(float t, float a, float b, float m)\n{\n    float o = ceil(m);\n    \n    float r = 1.;\n    for (float s = -o; s <= o; ++s)\n        r += ramp(b - m, b + m, s + t) - ramp(a - m, a + m, s + t);\n    return r;\n}\n\n// color for a particle\nvec3 particleColor(uint id)\n{\n    switch (id % 5U)\n    {\n        case 0U:\n            return vec3(0.59,0.01,0.05);\n        case 1U:\n            return vec3(0.36,0.16,0.36);\n        case 2U:\n            return vec3(1.00,0.69,0.00);\n        case 3U:\n            return vec3(0.07,0.36,0.02);\n        case 4U:\n            return vec3(1.00,0.29,0.00);\n    }\n}\n\n// render a single particle\nvoid renderParticle(fxParticle p, vec2 u, uint id, inout vec4 O)\n{\n    float e = g_State.zoom / R.y;\n    vec2 del = u - p.pos + g_State.cam;\n    float d2 = length2(del);\n    if (d2 < sqr(CANDY_R + e))\n    {\n        float d = sqrt(d2);\n        float sp = (id & 2U) == 0U ? 1. : -1.; // spiral direction\n        float a = atan(del.y, del.x) + p.r + d / CANDY_R * sp; // stripe angle\n\n        vec3 col = particleColor(id);\n        float blur = abs(p.av) / (PI * 2.) + 15. * g_State.zoom / R.y;\n        float t = abs(mod(a / (2. * PI), .2) -  .1);\n        float m = motionBlurAnalytic(t, .01, .08, blur);\n        \n        col = mix(col, vec3(1), m); // stripes\n        col = mix(col, vec3(1), smoothstep(CANDY_R * .3 + e, 0., d)); // center\n        \n        if (keyDown(KEY_SHIFT)) // debug draw shock directions\n            col = sin(atan(abs(p.sd.y * .1), p.sd.x) + vec3(0, 11, 33)) * .5 + .5;\n\n        del *= smoothstep(CANDY_R * .6, CANDY_R, d); // make flat spot\n        vec3 n = normalize(vec3(del, CANDY_R - sqrt(del.x * del.x + del.y * del.y))); // compute normal\n\n        float sh = calcSoftshadow(vec3(u + g_State.cam, 0), SHDIR, .01, .25, false); // shadow\n        float diff = max(-.2, dot(n, LDIR)) * .4 + .2; // diffuse\n        col *= diff * (.5 * sh + .5); // shadows only darken diffuse\n        \n        vec3 re = reflect(LDIR, n); // reflected\n        vec3 rd = normalize(vec3(u, -1)); // ray dir\n        float spec = pow(max(0., dot(rd, re)), 8.) * sh; // specular\n\n        float alp = smoothstep(CANDY_R + e, CANDY_R - e, d); // alpha\n        if (alp > 1e-6)\n        {\n            O.rgb = mix(O.rgb, col + spec, alp / (alp + O.a)); // weighted average by alpha\n            O.a = max(O.a, alp);\n        }\n    }\n}\n\n// render all the closest particles, called from main render and also for wood reflection\nvoid renderParticles(vec2 p, inout vec4 O)\n{\n    uvec4 ids = fxGetClosest(ivec2(p * R.y + .5 * R));\n    for (int i = 0; i < 4; ++i)\n    {\n        uint id = ids[i];\n        if (id >= g_MaxParticles) break;\n        fxParticle v = fxGetParticle(id);\n        renderParticle(v, p, id, O);\n    }\n}\n\n// from iq's Screen space bump mapping: https://www.shadertoy.com/view/ldSGzR\nvec3 doBump(vec3 dpdx, vec3 dpdy, vec3 nor, \n            float dbdx, float dbdy,\n            float scale)\n{\n    vec3  u = cross(dpdy, nor);\n    vec3  v = cross(nor, dpdx);\n    float d = dot(dpdx, u);\n\t\n\tvec3 surfGrad = dbdx * u + dbdy*v;\n    return normalize(abs(d) * nor - sign(d) * scale * surfGrad);\n}\n\n// returns uv + material for the shelves/wall at a 3D position\nvec3 uvmScene(vec3 p, vec3 n, vec2 res)\n{\n    if (p.z > 0. && n.z < 0.) return vec3(p.xy, 0); // wall\n    vec2 u = p.xy;\n    u.y = mod(u.y, .8);\n    vec2 d1 = sdShelf(u.xy, res);\n    vec2 uv = p.xz;\n    u.y = mod(u.y - .4, .8);\n    u.x = -u.x;\n    vec2 d2 = sdShelf(u.xy, res);\n    if (n.z < -abs(n.x) && n.z < -abs(n.y))\n    {\n        if (d1.x < d2.x)\n        {\n            if (d1.y == 0.)\n                return vec3(p.xy * rot2(-.2), 1);\n            else\n                return vec3(p.yx, 1);\n        }\n        else\n        {\n            if (d2.y == 0.)\n                return vec3(p.xy * rot2(.2), 1);\n            else\n                return vec3(p.yx, 1);\n        }\n    }\n    \n    return vec3(uv, 1);\n}\n\nvoid renderScene(vec3 hit, vec3 ro, vec3 rd, vec3 ddx_rd, vec3 ddy_rd, inout vec4 O)\n{\n    // render scene\n    vec3 n = normScene(hit);\n    vec3 uvm = uvmScene(hit, n, R); // uv, material\n\n    vec3 col = vec3(1,.9,.81);\n    vec3 spec = vec3(0);\n    if (uvm.z != 0.)\n    {\n        // render wood\n        const float l = 0.;\n        vec3 mate = texture(iChannel2, uvm.xy, l).xyz;\n\n        vec3 ddx_pos = ro - ddx_rd * dot(ro - hit, n) / dot(ddx_rd, n);\n        vec3 ddy_pos = ro - ddy_rd * dot(ro - hit, n) / dot(ddy_rd, n);\n        vec3 dposdx = ddx_pos - hit;\n        vec3 dposdy = ddy_pos - hit;\n\n        float signal = dot(mate,vec3(.33));\n        vec2 uvx = uvmScene(ddx_pos, n, R).xy / iChannelResolution[2].xy;\n        vec2 uvy = uvmScene(ddy_pos, n, R).xy / iChannelResolution[2].xy;\n        float dsignaldx = dot(texture(iChannel2, uvx, l).xyz, vec3(.33)) - signal;\n        float dsignaldy = dot(texture(iChannel2, uvy, l).xyz, vec3(.33)) - signal;\n\n        n = doBump(dposdx, dposdy, n, dsignaldx, dsignaldy, .003);\n\n        if (hit.z < 0.) // add reflection if we hit the shelf in front of the candies\n        {\n            vec3 rfl = reflect(rd, n);\n            vec2 rfp = hit.xy - hit.z * rfl.xy / rfl.z; // z crossing\n            float fre = 1. - max(dot(n, -rd), 0.); // fresnel\n            fre = pow(fre, 8.);\n            vec4 P = vec4(1, 1, 1, 0);\n            renderParticles(rfp - g_State.cam, P); // render particles for reflection\n            spec = fre * P.rgb * P.a * .3;\n        }\n        col = mate * .4;\n    }\n    \n    float sh = calcSoftshadow(hit, SHDIR, .01, .5, true) * .2 + .3;\n    col = max(0., dot(n, LDIR) * .2 + .2) * vec3(sh) * col + spec * sh;\n    O.rgb = mix(col, O.rgb, O.a);\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    particleMain(O, u);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ---------------------------------------------------------------------------------------\n//\tParticle simulation\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    particleMain(O, u);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const uint IDEAL_MAX_PARTICLES = 1500U; // how many particles to create if there's enough room for them\nconst float CANDY_R = .015; // pappermint radius\nconst float PI = 3.141592653589793;\n\n#define R iResolution.xy\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 cam;   // camera pos\n    float zoom; // camera zoom\n    float res;  // tracks resolution changes\n    float att;  // timer to resume attract mode (automatic zoom)\n    float avgDt;\n} g_State;\n\n#define fxGetState() fxGetStateImpl(iChannel1)\nvoid fxGetStateImpl(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(0, 1), 0);\n    \n    g_State.cam = data0.xy;\n    g_State.zoom = data0.z;\n    g_State.res = data0.w;\n    g_State.att = data1.x;\n    g_State.avgDt = data1.y;\n}\n\nvec4 fxPutState(vec2 u)\n{\n    if (ivec2(u) == ivec2(0))\n        return vec4(g_State.cam, g_State.zoom, g_State.res);\n    else\n        return vec4(g_State.att, g_State.avgDt, 0, 0);\n}\n\nbool fxIsStatePixel(vec2 u)\n{\n    return ivec2(u) == ivec2(0) || ivec2(u) == ivec2(0, 1);\n}\n\n// returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\nuvec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return floatBitsToUint(texelFetch(sampler, xy, 0));\n}\n\n// PARTICLE STRUCTURE\n\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS_VEL 4U\n#define SDAV 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\nuint g_MaxParticles = 0U;\n\n// must be called in each buffer before g_MaxParticles is correct\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 res)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \n#define fxLocFromID(A, B) fxLocFromIDImpl(int(R.x), A, B)\nivec2 fxLocFromIDImpl(uint width, uint id, uint dataType)\n{\n    uint index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2(index % width, index / width);\n}\n\nstruct fxParticle\n{\n    uvec4 nbs[4]; // neighbors\n    vec2 pos;     // position\n    vec2 vel;     // velocity\n    vec2 sd;      // shock direction\n    float r;      // rotation\n    float av;     // angular velocity\n};\n\n//get the particle corresponding to the input id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D sampler, uint resolutionWidth, uint id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, SDAV), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = floatBitsToUint(particleData0);\n    particle.nbs[1] = floatBitsToUint(particleData1);\n    particle.nbs[2] = floatBitsToUint(particleData2);\n    particle.nbs[3] = floatBitsToUint(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.sd = particleData5.xy;\n    particle.r = particleData5.z;\n    particle.av = particleData5.w;\n    \n    return particle;\n}\n\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return uintBitsToFloat(p.nbs[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SDAV:  \n        return vec4(p.sd, p.r, p.av);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D sampler, uint resolutionWidth, uint id, uint dataType)\n{\n    return texelFetch(sampler, fxLocFromIDImpl(resolutionWidth, id, dataType), 0);\n}\n\n// UTILITIES\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat sqr(float x) { return x * x; }\nfloat ramp(float a, float b, float t) { return clamp((t - a) / (b - a), 0., 1.); } // linear smoothstep\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// insert new particle at distance d_ with index i_ into i, d arrays, sorting by d\nvoid insertionSort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n// SCENE FUNCTIONS\n\n// 2D SDF of walls\nvec2 sdShelf(vec2 p, vec2 res)\n{\n    float d1 = sdBox((p - vec2(-.12 * res.x / res.y,  .3)) * rot2(-.2), vec2(.6, .01));\n    float d2 = sdBox((p - vec2(-.45 * res.x / res.y,  .51)), vec2(.01, .1));\n    if (d1 < d2)\n        return vec2(d1, 0);\n    else\n        return vec2(d2, 1);\n}\n\n// scene (walls) signed distance field, for rendering and collision\nfloat sdScene(vec2 p, vec2 res)\n{\n    // slanted walls\n    p.y = mod(p.y, .8);\n    float d = sdShelf(p, res).x;\n    p.y = mod(p.y - .4, .8);\n    p.x = -p.x;\n    d = min(d, sdShelf(p, res).x);\n    \n    return d;\n}\n\n/// the outward normal of the scene at a point\nvec2 normScene(vec2 p, vec2 res)\n{\n\tconst vec2 d = vec2(.001, 0);\n    \n   \tfloat x1 = sdScene(p + d.xy, res); \n    float x0 = sdScene(p - d.xy, res); \n    float dx = x1 - x0;\n    \n    float y1 = sdScene(p + d.yx, res); \n    float y0 = sdScene(p - d.yx, res); \n    float dy = y1 - y0;\n    \n\treturn normalize(vec2(dx, dy));\n}\n\n// PARTICLE SIM\n\nconst vec2 GRAV = vec2(0., -.003);  // gravity\nconst float COLLISION_STIFFNESS = .3; // how fast we correct position errors\nconst float BOUNDARY_ELAS = 1.5;      // elasticity of boundary\nconst float PARTICLE_ELAS = 1.;       // elasticity of particles\nconst float FRIC_COEF = .25;          // Coulomb friction coefficient\n\n// resolve velocity errors against another particle or the boundary\n//\n//  rv   - relative velocity\n//  n    - normal\n//  nav  - neighbor angular velocity\n//  elas - elasticity\n//  lv   - linear velocity\n//  av   - angular velocity\nvoid constraint(vec2 rv, vec2 n, float nav, float elas, inout vec2 lv, inout float av)\n{\n    vec2 t = vec2(n.y, -n.x); // tangent\n    float nv = dot(rv, -n); // normal velocity\n    float ni = elas * max(0., nv); // normal impulse\n    float tv = dot(rv, t) - (av + nav) * CANDY_R; // tangent velocity\n    float fi = clamp(tv, -ni * FRIC_COEF, ni * FRIC_COEF); // friction impulse\n\n    lv += ni * n - fi * t; // apply linear impulse\n    av += fi / CANDY_R;    // apply angular impulse\n}\n\n#define updateParticle(A, B, C) updateParticleImpl(iChannel0, R, iFrame, iMouse, A, B, C)\nvec4 updateParticleImpl(sampler2D par, vec2 res, int iFrame, vec4 iMouse, fxParticle p, uint id, uint dataType)\n{\n    if (iFrame == 0 || g_State.res != res.x * res.y)\n    {\n        vec3 h1 = hash3((id + uvec3(iFrame)) * uvec3(3, 6, 9)) - .5;\n        p.pos = vec2(h1.x, 4. * h1.y );\n        if (id == 0U) p.pos = vec2(0);\n        p.vel = vec2(0);\n        p.sd = vec2(0, 1);\n        p.r = 0.;\n        p.av = 0.;\n    }\n    else\n    {\n        p.vel = p.vel + GRAV * g_State.avgDt; // integrate velocity        \n        p.pos += p.vel; // integrate position\n        p.r += p.av; // integrate rotation\n        p.sd *= .5; // dissipate shock direction\n\n        vec2 imp = vec2(0); // collision linear impulse\n        vec2 nsd = p.sd; // new shock direction\n        for(int i = 0; i < 4; i++)\n        {\n            uvec4 nbs = p.nbs[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                uint cid = nbs[j];\n                if(cid==id || cid >= g_MaxParticles) continue;\n\n                fxParticle n = fxGetParticleImpl(par, uint(res.x), cid);\n\n                vec2 dp = p.pos - n.pos;\n                float d2 = length2(dp) + CANDY_R * 1e-4;\n\n                if (d2 < sqr(CANDY_R * 5.))\n                {\n                    nsd += n.sd; // diffuse shock direction\n                    \n                    if (d2 < sqr(CANDY_R * 2.))\n                    {\n                        vec2 dir = dp / sqrt(d2);\n\n                        // position correction (ignore if shock direction disagrees)\n                        if (dot(p.sd, dir) > -.2)\n                            p.pos = mix(p.pos, n.pos + 2. * CANDY_R * dir, COLLISION_STIFFNESS);\n                        \n                        constraint(p.vel - n.vel, dir, n.av, PARTICLE_ELAS, imp, p.av);\n                    }\n                }\n            }\n        }\n\n        float sd2 = length2(nsd);\n        if (sd2 > 1e-9)\n            p.sd = mix(p.sd, nsd / sqrt(sd2), .9); // record new shock direction\n\n        if (dot(p.sd, imp) < -.2) // resist impulses against the shock direction\n            imp *= .5;\n\n        p.vel += imp; // apply collision impulse\n        \n        // handle mouse input\n        if (iMouse.z > 0.)\n        {\n            vec2 m = g_State.zoom * (iMouse.xy - .5 * res) / res.y + g_State.cam;\n            const float MOUSE_RANGE = .1;\n            if (distance(m, p.pos) < MOUSE_RANGE)\n            {\n                const float MOUSE_STRENGTH = .005;\n                p.vel += (p.pos - m) * MOUSE_STRENGTH;\n            }\n        }\n\n        // handle boundary\n        float ds = sdScene(p.pos, res);\n        if (ds < CANDY_R * 2.)\n        {\n            vec2 n = normScene(p.pos, res);\n            p.sd = n; // seed shock direction\n            \n            if (ds < CANDY_R) // collide with boundary\n            {\n                p.pos -= n * (ds - CANDY_R);\n                \n                constraint(p.vel, n, 0., BOUNDARY_ELAS, p.vel, p.av);\n            }            \n        }\n    }\n    \n    return fxSaveParticle(p, dataType);\n}\n\n// PARTICLE NEIGHBOR UPDATE\n\nbool iscoincidence(uvec4 bestIds, uint currentId, uint id)\n{\n    return id >= g_MaxParticles || id == currentId || any(equal(bestIds,uvec4(id)));\n}\n\nvoid sort0(sampler2D par, uint wd, inout uvec4 bestIds, inout vec4 bestDists, uint currentId, uint searchId, uint dataType, vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleDataImpl(par, wd, searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    uint dir = uint(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertionSort(bestIds, bestDists, searchId, t);\n}\n\n#define voronoiParticle(A, B, C) voronoiParticleImpl(iChannel0, iChannel1, R, iFrame, A, B, C)\nvec4 voronoiParticleImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, fxParticle p, uint id, uint dataType)\n{\n    uvec4 clo = uvec4(-1); // closest particles to screen pixel (if on screen)\n    ivec2 sp = ivec2((p.pos - g_State.cam) * res.y + .5 * res); // screen pixel address\n    if (all(lessThan(sp, ivec2(res))) && all(not(lessThan(sp, ivec2(0)))))\n        clo = fxGetClosestImpl(vor, sp);\n        \n    uvec4 bestIds = uvec4(-1);  // new closest particles\n    vec4 bestDists = vec4(1e6); // distances of new closest particles\n\n    if (iFrame > 0)\n    {\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[0][i], dataType, p.pos); // re-sort previous frame's neighbors\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[1][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[2][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, p.nbs[3][i], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, clo[i], dataType, p.pos);  // check the screen-space voronoi\n            \n            fxParticle n = fxGetParticleImpl(par, uint(res.x), p.nbs[i][0]); // check the closest neighbors of each closest neighbor\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[0][0], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[1][0], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[2][0], dataType, p.pos);\n            sort0(par, uint(res.x), bestIds, bestDists, id, n.nbs[3][0], dataType, p.pos);\n        }\n\n        // search randomly a few times too\n        uint iter = 8U;\n        for(uint k = 0U; k < iter; k++)\n        {\n            float h = hash3(uvec3(id + k, id * k, k * uint(iFrame))).x;\n            uint s = uint(mod(h*34534.0, float(g_MaxParticles)));\n            sort0(par, uint(res.x), bestIds, bestDists, id, s, dataType, p.pos);  //sort this\n        }\n    }\n    \n    return uintBitsToFloat(bestIds);\n}\n\n// PARTICLE MAIN\n\n#define particleMain(A, B) particleMainImpl(iChannel0, iChannel1, R, iFrame, iMouse, A, B)\nvoid particleMainImpl(sampler2D par, sampler2D vor, vec2 res, int iFrame, vec4 iMouse, out vec4 O, vec2 u)\n{\n    uvec2 ufc = uvec2(u);\n    \n    computeMaxParticlesImpl(res);\n    uint index = ufc.x + ufc.y * uint(res.x); // \"1D array\" index\n    uint id = index / NUM_PARTICLE_DATA_TYPES; // which particle\n    uint dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of particle structure\n    if (id >= g_MaxParticles) return;\n    \n    fxParticle p = fxGetParticleImpl(par, uint(res.x), id);\n    fxGetStateImpl(vor);\n    \n    if (dataType >= POS_VEL)\n        O = updateParticleImpl(par, res, iFrame, iMouse, p, id, dataType);\n    else\n        O = voronoiParticleImpl(par, vor, res, iFrame, p, id, dataType);\n}\n", "buffer_c_code": "// ---------------------------------------------------------------------------------------\n//\tVoronoi tracking buffer and persistent state\n// ---------------------------------------------------------------------------------------\n\nvec4 voronoiScreen(vec2 u);\nvec4 updateState(vec2 u);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxGetState();\n    computeMaxParticles();\n\n    if (fxIsStatePixel(u))\n        O = updateState(u);\n    else\n        O = voronoiScreen(u);\n}\n\nvec4 updateState(vec2 u)\n{\n    if (iFrame == 0 || R.x * R.y != abs(g_State.res) || keyDown(KEY_SPACE))\n    {\n        g_State.cam = vec2(0);\n        g_State.zoom = 1.;\n        g_State.res = -R.x * R.y;\n        g_State.att = 0.;\n        g_State.avgDt = 1./60.;\n    }\n    else\n    {\n        g_State.res = abs(g_State.res); // track resolution changes\n        fxParticle p = fxGetParticle(0U);\n        \n        if (p.vel.y < -.6 * g_State.avgDt || p.pos.y < -20.) // reset if particle zero falls\n        {\n            g_State.res = -R.x * R.y;\n            g_State.cam = vec2(0);\n        }\n        else\n        {\n            vec2 c = p.pos; // track particle zero ...\n            c.x = mix(c.x, 0., g_State.zoom); // ... but keep the view centered when zoomed out\n            g_State.cam = mix(g_State.cam, c, .03); // blend to desired camera position\n        }\n        \n        g_State.avgDt = mix(g_State.avgDt, iTimeDelta, .05);\n        \n        // manual zoom\n        if (keyDown(KEY_UP))\n            g_State.zoom *= .99, g_State.att = 5.; \n        if (keyDown(KEY_DOWN))\n            g_State.zoom /= .99, g_State.att = 5.;\n            \n        // attract mode\n        g_State.att = max(0., g_State.att - iTimeDelta);\n        if (g_State.att == 0.)\n            g_State.zoom = mix(g_State.zoom, cos(iTime * .2) * .35 + .65, .02);\n        g_State.zoom = min(1., g_State.zoom);\n    }\n\n    return fxPutState(u);\n}\n\n// find the squared distance from the screen position to a particular particle\nfloat distance2Particle(uint id, vec2 u)\n{\n    fxParticle v = fxGetParticle(id);\n    \n    return min(length2(v.pos - u - g_State.cam), length2(v.pos - v.vel - u - g_State.cam));\n}\n\n// get all the existing neighbors of a cell and consider them as possible improvements for ourselves\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 new, inout vec4 dis)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = old[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        float dis2 = distance2Particle(id, p);\n        insertionSort(new, dis, id, dis2);\n    }\n}\n\nvec4 voronoiScreen(vec2 u)\n{\n\tvec2 p = (u - .5 * R.xy) / R.y;\n    uvec4 new = uvec4(-1); // the four new closest particles\n    vec4 dis = vec4(1e6);  // the distances of the four newest particles\n    fxGetState();\n    \n    if (iFrame > 0 && !keyClick(KEY_SPACE))\n    {\n        uvec4 old = fxGetClosest(ivec2(u));\n                \n        sortNbs(old, p, new, dis); // start with our previous frame's values, and look up the distances\n        \n        const float SEARCH_RANGE = 20.;\n        const int SEARCH_COUNT = 8;\n        for (int i = 0; i < SEARCH_COUNT; ++i)\n        {\n            vec3 h = hash3(uvec3(u, iFrame * 4 + i));\n            sortNbs(fxGetClosest(ivec2(u + vec2((h.xy - .5) * SEARCH_RANGE))), p, new, dis);\n        }\n\n        // random searching to kick start the process\n        vec3 h = hash3(uvec3(u, iFrame * 4));\n        uint id = uint(h.z * float(g_MaxParticles));\n        insertionSort(new, dis, id, distance2Particle(id, p));\n    }\n    \n    return uintBitsToFloat(new);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVyWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3995, 3995, 4031, 4031, 4773], [4775, 4858, 4905, 4905, 5000], [5002, 5028, 5052, 5052, 5146], [5148, 5174, 5198, 5198, 5443], [5445, 5470, 5504, 5504, 5650], [5652, 5694, 5722, 5722, 5971], [5973, 6049, 6123, 6123, 6705], [6782, 6908, 6970, 6970, 7136], [7138, 7162, 7191, 7191, 7516], [7518, 7546, 7612, 7612, 9272], [9274, 9364, 9408, 9408, 9655], [9657, 9735, 9842, 9842, 10039], [10041, 10104, 10145, 10145, 10811], [10813, 10813, 10899, 10919, 12526]], "test": "untested"}
{"id": "ctdSDX", "name": "Year of Truchets #055", "author": "byt3_m3chanic", "description": "All year long I'm going to just focus on truchet tiles and the likes!\n\nNote* I'm so ready to do something new - just two more months left - finish what you start and learn something along the way!", "tags": ["raymarching", "truchet", "cylinder", "uvmap"], "likes": 17, "viewed": 218, "published": 3, "date": "1696547663", "time_retrieved": "2024-07-30T17:30:20.420145", "image_code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #055\n    10/05/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    see all https://www.shadertoy.com/user/byt3_m3chanic/sort=newest\n    \n*/\n\n\n#define ZERO (min(iFrame,0))\n#define AA 2\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define P9          1.57078\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-5\n#define MAX_DIST    50.\n\n// globals\nvec3 hit=vec3(0),hitpoint=vec3(0);\nvec4 FC=vec4(vec3(.05),0);\n\nmat2 turn,spin;\nfloat glow,px,stime,gid=0.,sid=0.;\n\n// standard bag of tricks\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\n//@iq cylinder & hsv2rgb\nfloat cylinder(vec3 p,float h,float r){vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);return min(max(d.x,d.y),0.) + length(max(d,0.));}\nvec3 hsv2rgb(in vec3 c){vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);return c.z * mix(vec3(1),rgb,c.y);}\n\nfloat tile(vec3 hp, float type){\n    //@Fabrice - based off https://www.shadertoy.com/view/sdtGRn\n    vec2 uv   = vec2(atan(hp.z,hp.x)/PI2,hp.y);\n \n    vec2 scale = vec2(26.,1);\n    float px = fwidth(uv.x); \n\n    vec2 id = floor(uv*scale);\n    vec2 q = fract(uv*scale)-.5;\n    float hs = hash21(id);\n\n    float m = floor(mod(id.y,3.)+1.);\n    float n = floor(mod(id.x,5.)+1.);\n    \n    float ck = mod(id.x+id.y,m)*2.-1.;\n    float rk = mod(id.x+id.y,n)*2.-1.;\n    \n    float wd = .075;\n    \n    if(rk>.5) q *= rot(1.5707);\n\n    vec2 p = length(q-.5)<length(q+.5)? q-.5 : q+.5;\n\n    // main pattern\n    float d = abs(length(p)-.5)-wd;\n\n    if (ck>.85) d = min(length(q.x)-wd,length(q.y)-wd);\n    hs = fract(hs*415.372);\n \n    // accents\n    float b = length(abs(q)-.5)-.325;\n    d=min(d,b);\n \n    return d;\n}\n\nvec2 map(vec3 p, float sg) {\n    vec2 res = vec2(1e5,0.);\n    vec3 q = p;\n\n    gid=1.;\n    q.zy*=spin;\n    q.zx*=turn;\n    float d1 = cylinder(q,4.5,2.1);\n    float dx = cylinder(q,3.5,2.2);\n    float d2=max(d1,-dx);\n    \n    float t1 = tile(q,1.);\n    \n    d2=max(d2,-t1);\n    \n    if(d2<res.x) {\n        res=vec2(d2,d1<d2?3.:1.);\n        hit=q;\n    }\n    \n\n    float d3 = cylinder(q,.1,3.55)-.2;\n    if(sg==1.) { glow += .0025/(.001+d3*d3);}\n    if(d3<res.x) {\n        res=vec2(d3,4.);\n        hit=q;\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd) {\n    float d = 0., m = 0.;\n    for(int i=0;i<100;i++){\n        vec2 ray = map(ro + rd * d,1.);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32?ray.x*.35:ray.x;\n        m  = ray.y;\n    }\n    return vec2(d,m);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, float last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd);\n    float m =ray.y; d=ray.x;\n    \n    hitpoint=hit;\n    sid=gid;\n    float aph = 0.;\n    if(d<MAX_DIST)\n    {\n        aph=1.;\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        // light\n        vec3 lpos =vec3(-25.,15.,10.);\n        vec3 l = normalize(lpos-p);\n        // difused\n        float diff = clamp(dot(n,l),.09,.99);\n\n        // color\n        vec3 h = vec3(.0);\n        vec3 hp = hitpoint;\n        \n        if(m==1.) {\n            float d = tile(hp,1.);\n            d=smoothstep(px,-px,abs(abs(d-.16)-.0725)-.025);\n            h = mix(vec3(.45),vec3(.85),d);\n            ref = h*.1;\n        }\n        if(m==2.) {\n            float d = tile(hp*.5,2.);\n            d=smoothstep(px,-px,abs(abs(d)-.05)-.025);\n            vec3 clr = hsv2rgb(vec3((hp.x-hp.z)*.1,1.,.5));\n            h = mix(vec3(.01),clr,d);\n            ref = vec3(d*.9);\n        }\n        if(m==3.) {\n            h = hsv2rgb(vec3((p.y*.65+T*.25+sid)*.2,.9,.4));\n            ref = h*.5;\n        }\n        if(m==4.) {h = vec3(1);ref=vec3(.5);}\n  \n        C = diff*h;\n        ref=h;\n        ro = p+n*.005;\n        rd = reflect(rd,n);\n    } \n    if(last>0.) C = mix(FC.rgb,C,exp(-.0008*d*d*d));\n    return vec4(C,aph);\n}\n\nvec3 renderALL( in vec2 uv, in vec2 F )\n{   \n\n    // standard setup uv/ro/rd\n    //vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,8.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    // mouse\n    float x = M.xy==vec2(0) || M.z <1. ? 0. :  (M.y/R.y*1.-.5)*PI;\n    float y = M.xy==vec2(0) || M.z <1. ? 0. : -(M.x/R.x*1.-.5)*PI;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.zy *= rx; ro.xz *= ry; \n    rd.zy *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0), ref=vec3(0), fil=vec3(.95);\n    float d =0.,a=0.;\n  \n    // reflection loop (@BigWings)\n    for(float i=0.; i<2.; i++) {\n        vec4 pass = render(ro, rd, ref, i, d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.&&pass.w>0.)a=1.;\n    }\n  \n    float mask = smoothstep(.1,.75,length(uv)-.45);\n    vec3 clr = mix(vec3(.5),vec3(.0),mask);\n    \n    uv += vec2(T*.25,0);\n    uv *= rot(.785);\n  \n    float f = clamp(mod(floor(uv*8.).x,2.)*1.-.5,0.,1.);\n    C = mix(mix(clr*.5,clr*.2,f),C,a);\n    C = mix(C,vec3(.89),clamp(glow*.5,0.,1.));\n\n    return C;\n}\n\n// AA from @iq https://www.shadertoy.com/view/3lsSzf\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    spin = rot(.1*sin(T*.5));\n    turn = rot(T*.075);\n    px  = 10./R.x;\n    stime=T*.1;\n    \n    vec3 C = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (-R.xy + 2.0*(F+o))/max(R.x,R.y);\n#else    \n        vec2 uv = (-R.xy + 2.0*F)/max(R.x,R.y);\n#endif\n        glow=0.;\n        vec3 color = renderALL(uv,F);\n        // compress        \n        color = 1.35*color/(1.0+color);\n        // gamma\n        color = pow( color, vec3(0.4545) );\n\n        C += color;\n       \n#if AA>1\n    }\n    C /= float(AA*AA);\n#endif\n    // Output to screen\n    O = vec4(C,1.);\n}\n//end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ctdSDX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[677, 703, 721, 721, 766], [767, 767, 788, 788, 843], [845, 870, 909, 909, 1007], [1008, 1008, 1032, 1032, 1129], [1131, 1131, 1163, 1228, 1938], [1940, 1940, 1968, 1968, 2467], [2469, 2469, 2499, 2499, 2750], [2752, 2752, 2784, 2784, 3011], [3013, 3013, 3108, 3108, 4368], [4370, 4370, 4411, 4491, 5396]], "test": "untested"}
{"id": "cdVyWG", "name": "Portal to the Hell Shader", "author": "misterprada", "description": "[url]https://github.com/MisterPrada[/url]", "tags": ["portal", "neon"], "likes": 12, "viewed": 834, "published": 3, "date": "1696540524", "time_retrieved": "2024-07-30T17:30:21.236961", "image_code": "// Simplex 2D noise\n//\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float noice = snoise(vec2(uv.x * 3.4 - 2.0, uv.y - iTime) * 2.3);\n        \n    \n    vec2 circleParams = vec2(cos(noice) + 4.0, abs(sin(noice) + 2.5));\n    \n    float circleRatio = circleParams.y/circleParams.x;\n    \n    float circle = pow(circleParams.y,-abs(length((fragCoord+fragCoord-iResolution.xy)/iResolution.y)-circleRatio)*20.) * atan(iTime) * 1.3;\n   \n    circle += 2. * pow(circleParams.y,-abs(length((fragCoord+fragCoord-iResolution.xy)/iResolution.y -circleRatio*vec2(cos(iTime),sin(iTime))))*circleParams.x); \n    \n\n    // Output to screen\n    fragColor.rgb = circle * vec3(circleParams*.1,.5);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdVyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 45, 45, 84], [86, 86, 107, 107, 927], [929, 929, 986, 986, 1645]], "test": "untested"}
{"id": "dsGyWy", "name": "Cubemap texel solid angle", "author": "Zavie", "description": "Visualisation of the relative solid angle of texels from a cubemap. The reference is shown on the left, and an approximation is proposed on the right. The error between the reference and the approximation is shown as well.", "tags": ["cubemap", "solidangle"], "likes": 4, "viewed": 166, "published": 3, "date": "1696538779", "time_retrieved": "2024-07-30T17:30:21.994934", "image_code": "/*\n\nThis shader visualises the relative solid angle of the texels\nof the face of a cubemap (compared to the center texel).\n\nA very simple approximation is proposed. The approximation is\ntoo crude for very low resolutions, but beyond 8x8 it seems\nto result in under 1% error.\n\nMaybe a fitting or offset could correct the error for the\nvery low resolutions as well?\n\n\nTop center: texels of the cubemap face.\nBottom left: relative solid angle of the texels.\nBottom right: approximation of the relative solid angle.\nCenter: (200x exaggerated) error of the approximation.\n\nThe bottom histogram shows the error accross the diagonal, on\na squeezed scale. The short dashed graduations indicate the\n0.125%, 0.25%, 0.5%, 1% and 2% error. The longer dashed\ngraduations indicate the 10%, 20%, 40% and 80% error.\n\nLicense: CC BY 4.0\n\n-- \nZavie\n*/\n\nfloat approximateRelativeSolidAngle(vec2 uv, float resolution)\n{\n    vec2 p = uv * 2. - 1.;\n\n#if 0\n    // Verbose version:\n\n    // The more off-center the texel, the further the distance.\n    // So we scale by the inverse square distance.\n    float invSqrDist = 1. / (dot(p, p) + 1.);\n\n    // The more off-center the texel, the more it's facing away.\n    // So we scale by the cosine.\n    float cos_factor = 1. / sqrt(dot(p, p) + 1.);\n\n    // Combine the two factors:\n    return invSqrDist * cos_factor;\n#else\n    // Short version:\n\n    // After derivation, the whole thing becomes just\n    float sqrDist = dot(p, p) + 1.;\n    return 1. / sqrt(sqrDist * sqrDist * sqrDist);\n#endif\n}\n\n//\n// areaElement and texelSolidAngle are adapted from\n// AMD cubemapgen source code:\n// https://code.google.com/archive/p/cubemapgen/\n//\n// See the derivation here:\n// https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n//\nfloat areaElement(float x, float y)\n{\n    return atan(x * y, sqrt(x * x + y * y + 1.));\n}\n\nfloat texelSolidAngle(vec2 uv, float resolution)\n{\n    vec2 p = uv * 2. - 1.;\n\n    float invResolution = 1. / resolution;\n \n    // p is the -1..1 texture coordinate on the current face.\n    // Get projected area for this texel\n    vec2 pmin = p - invResolution;\n    vec2 pmax = p + invResolution;\n    float solidAngle = (\n        areaElement(pmin.x, pmin.y) -\n        areaElement(pmin.x, pmax.y) -\n        areaElement(pmax.x, pmin.y) +\n        areaElement(pmax.x, pmax.y));\n \n    return solidAngle;\n}\n\nfloat exactRelativeSolidAngle(vec2 uv, float resolution)\n{\n    return texelSolidAngle(uv, resolution) / texelSolidAngle(vec2(0.5), resolution);\n}\n\n// ----------------------------------------------------------\n\nvec2 remap(vec2 a, vec2 b, vec2 u)\n{\n    return (u - a) / (b - a);\n}\n\nvec2 getMask(vec2 uv)\n{\n    vec2 du = 2.*vec2(dFdx(uv.x), dFdy(uv.y));\n    return smoothstep(vec2(0.), du, uv) * (1. - smoothstep(vec2(1.) - du, vec2(1.), uv));\n}\n\nvec2 getRectangle(vec2 uv, float x, float y, float width, float height)\n{\n    vec2 p = vec2(x, y);\n    vec2 size = vec2(width, height);\n    return remap(p - size/2., p + size/2., uv);\n}\n\nvec2 getSquare(vec2 uv, float x, float y, float size)\n{\n    vec2 p = vec2(x, y);\n    return remap(p - size/2., p + size/2., uv);\n}\n\nvec2 discretise(vec2 uv, float resolution)\n{\n    return (floor(uv * resolution) + 0.5) / resolution;\n}\n\nvec3 errorToColor(float error)\n{\n    // Colours picked from:\n    // https://www.kennethmoreland.com/color-advice/\n    // The publication explains how to properly interpolate,\n    // but I was too lazy to implement it.\n    vec3 midPoint = vec3(0.865, 0.865, 0.865);\n    vec3 positive = vec3(0.230, 0.299, 0.754);\n    vec3 negative = vec3(0.706, 0.016, 0.150);\n\n    if (error > 0.)\n    {\n        if (error <= 1.)\n            return mix(midPoint, positive, error);\n        // Saturate to blue above 1:\n        return vec3(0., 0., 1.);\n    }\n    else\n    {\n        if (error >= -1.)\n            return mix(midPoint, negative, -error);\n        // Saturate to red below -1:\n        return vec3(1., 0., 0.);\n    }\n}\n\nfloat logScale(float x)\n{\n    float scale = 9.;\n    return (exp(scale * x) - 1.) / (exp(scale) - 1.);\n}\n\nvec4 errorHistogram(vec2 uvPlot, vec2 uvFace, float error)\n{\n    float x = uvPlot.x;\n    float dx = dFdy(x);\n    float y = logScale(uvPlot.y);\n    float dy = dFdy(y);\n    vec4 color = vec4(errorToColor(0.), 0.1);\n    if (error > 0.)\n    {\n        float e = (error);\n        color = mix(color, vec4(errorToColor(200. * error), 1.), smoothstep(y, y + dy, e));\n    }\n    else if (error < 0.)\n    {\n        float e = (-error);\n        color = mix(color, vec4(errorToColor(200. * -error), 1.), smoothstep(y, y + dy, e));\n    }\n\n    // Draw graduations at 0.125%, 0.25%, 0.5%, 1% and 2%\n    for (float graduation = 0.00125; graduation <= 0.02; graduation *= 2.)\n    {\n        float line = smoothstep(y - dy, y, graduation) * (1. - smoothstep(y, y + dy, graduation));\n        float dotted = fract(100. * x);\n        float dottedLine = line * smoothstep(0., dx, dotted) * (1. - smoothstep(0.75, 0.75 + dx, dotted));\n        color = mix(color, vec4(1. - color.rgb, 1.), 0.5*dottedLine);\n    }\n\n    // Draw graduations at 10%, 20%, 40% and 80%\n    for (float graduation = 0.1; graduation < 1.0; graduation *= 2.0)\n    {\n        float line = smoothstep(y - dy, y, graduation) * (1. - smoothstep(y, y + dy, graduation));\n        float dotted = fract(25. * x);\n        float dottedLine = line * smoothstep(0., dx, dotted) * (1. - smoothstep(0.85, 0.85 + dx, dotted));\n        color = mix(color, vec4(1. - color.rgb, 1.), 0.5*dottedLine);\n    }\n\n    return color;\n}\n\n// ----------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float evolution = abs(fract(iTime * 0.05) * 2. - 1.);\n    float cubeMapResolution = pow(2., 1. + floor(evolution * 10.));\n\n    vec2 uv = fragCoord/iResolution.x;\n    vec3 color = vec3(0.2);\n\n    // Visualise the texels depending on the cubemap resolution\n    {\n        vec2 uvFace = getSquare(uv, 0.5, 0.45, 0.22);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        vec3 texels = vec3(uvFace, 0.);\n        color = mix(color, texels, mask.x * mask.y);\n    }\n\n    // Visualise the texel relative solid angle\n    {\n        vec2 uvFace = getSquare(uv, 0.2, 0.32, 0.35);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float ersa = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        color = mix(color, vec3(ersa), mask.x * mask.y);\n    }\n\n    // Visualise the approximated texel relative solid angle\n    {\n        vec2 uvFace = getSquare(uv, 1. - 0.2, 0.32, 0.35);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        color = mix(color, vec3(arsa), mask.x * mask.y);\n    }\n\n    // Visualise the difference between the texel relative\n    // solid angle and the approximation\n    {\n        vec2 uvFace = getSquare(uv, 0.5, 0.22, 0.22);\n        vec2 mask = getMask(uvFace);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa2 = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        float ersa2 = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        float error = ersa2 - arsa2;\n        color = mix(color, errorToColor(200. * error), mask.x * mask.y);\n    }\n    \n    // Visualise more precisely the error across the diagonal\n    {\n        vec2 uvPlot = getRectangle(uv, 0.5, 0.05, 1., 0.1);\n        vec2 mask5 = getMask(uvPlot);\n        vec2 uvFace = vec2(uvPlot.x);\n        uvFace = discretise(uvFace, cubeMapResolution);\n\n        float arsa2 = approximateRelativeSolidAngle(uvFace, cubeMapResolution);\n        float ersa2 = exactRelativeSolidAngle(uvFace, cubeMapResolution);\n        float error = ersa2 - arsa2;\n\n        vec4 histogram = errorHistogram(uvPlot, uvFace, error);\n        color = mix(color, histogram.rgb, mask5.x * mask5.y * histogram.a);\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGyWy.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[835, 835, 899, 899, 1517], [1519, 1758, 1795, 1795, 1847], [1849, 1849, 1899, 1899, 2349], [2351, 2351, 2409, 2409, 2496], [2561, 2561, 2597, 2597, 2629], [2631, 2631, 2654, 2654, 2793], [2795, 2795, 2868, 2868, 2980], [2982, 2982, 3037, 3037, 3112], [3114, 3114, 3158, 3158, 3216], [3218, 3218, 3250, 3435, 3926], [3928, 3928, 3953, 3953, 4031], [4033, 4033, 4093, 4093, 5484], [5549, 5549, 5606, 5606, 7986]], "test": "ok"}
{"id": "mdyyWy", "name": "Topographic Map", "author": "fishy", "description": "A simple noise shader that utilizes derivatives to get consistent line widths and antialiasing", "tags": ["noise"], "likes": 5, "viewed": 2472, "published": 3, "date": "1696533386", "time_retrieved": "2024-07-30T17:30:22.745926", "image_code": "#define PERIOD 50.0\n#define PIXEL_THICKNESS 1.0\n#define AA_SCALE 1.0\n\n#define BG_COLOR vec3(0.059,0.082,0.008)\n#define FG_COLOR vec3(0.682,0.969,0.490)\n\n#define smooth(x) (3.0*x*x - 2.0*x*x*x)\n\nmat2 r(float t)\n{\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float t)\n{    \n    vec2 tlVal = r(t * hash22(vec2(floor(p.x),  ceil(p.y)) + 20.0).x)*(hash22(vec2(floor(p.x),  ceil(p.y))) - 0.5) * 2.0;\n    vec2 blVal = r(t * hash22(vec2(floor(p.x), floor(p.y)) + 20.0).x)*(hash22(vec2(floor(p.x), floor(p.y))) - 0.5) * 2.0;\n    vec2 trVal = r(t * hash22(vec2( ceil(p.x),  ceil(p.y)) + 20.0).x)*(hash22(vec2( ceil(p.x),  ceil(p.y))) - 0.5) * 2.0;\n    vec2 brVal = r(t * hash22(vec2( ceil(p.x), floor(p.y)) + 20.0).x)*(hash22(vec2( ceil(p.x), floor(p.y))) - 0.5) * 2.0;\n    \n    float tl = dot(p - vec2(floor(p.x),  ceil(p.y)), tlVal);\n    float bl = dot(p - vec2(floor(p.x), floor(p.y)), blVal);\n    float tr = dot(p - vec2( ceil(p.x),  ceil(p.y)), trVal);\n    float br = dot(p - vec2( ceil(p.x), floor(p.y)), brVal);\n    \n    return mix(mix(bl, tl, smooth(fract(p.y))), \n               mix(br, tr, smooth(fract(p.y))),\n                           smooth(fract(p.x)))*0.5 + 0.5;\n}\n\nfloat fbm(vec2 p, float t)\n{\n    float v = 0.0;\n    for(float i = 0.0; i < 4.0; i++)\n    {\n        v += perlinNoise(p * exp(i), t * exp(i)) * exp(-i);\n    }\n    return v * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n\n    float v = fbm(uv + iTime*0.03, iTime*0.05);\n    float av = abs(sin(v*PERIOD));\n    av = smoothstep(0.0, fwidth(av)*AA_SCALE, av - fwidth(v*PERIOD)*0.5*PIXEL_THICKNESS);\n\n    // Output to screen\n    fragColor = vec4(sqrt(mix(BG_COLOR * BG_COLOR, FG_COLOR * FG_COLOR, 1.0-av)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 211, 211, 263], [265, 265, 286, 286, 416], [418, 418, 454, 454, 1357], [1359, 1359, 1387, 1387, 1537], [1539, 1539, 1596, 1646, 1995]], "test": "untested"}
{"id": "DsVcRt", "name": "Gradient Circley", "author": "Peace", "description": "Available on Wallpaper Engine", "tags": ["circle", "gradient"], "likes": 13, "viewed": 289, "published": 3, "date": "1696532093", "time_retrieved": "2024-07-30T17:30:23.493926", "image_code": "const float OPACITY = 0.2;\nconst vec3 HALO_COL = vec3(0.2, 0.6, 1.0);\nconst vec3 EDGE1_COL = vec3(1.0, 0.68, 0.66);\nconst vec3 EDGE2_COL = vec3(1.0, 0.3, 0.2);\nconst vec3 BACKGROUND_COL = vec3(0, 0, 0.11);\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat noise(vec3 p)\n{\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat rand1d(float n) { return fract(sin(n) * 43758.5453123); }\n\nfloat noise1d(float p) \n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand1d(fl), rand1d(fl + 1.0), fc);\n}\n\nvec2 rot(vec2 v, float a) \n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvec3 circle(vec2 uv, float off) \n{\n    vec3 col = HALO_COL;\n    float t = iTime * 0.5 + off;\n    float rt = t * 0.4;\n    float f = fwidth(uv).y * 4.0;\n    uv = rot(uv, 6.2831853 * (noise1d(rt - 6816.6) * 0.5 + noise1d(rt * 1.25 - 3743.16) * 0.4 + noise1d(rt * 1.5 + 1741.516) * 0.3));\n    float n = noise(vec3(uv * 1.2, t)) * 0.2 + noise(vec3(-uv * 1.7, t)) * 0.15 + noise(vec3(uv * 2.2, t)) * 0.1;\n    float d = dot(uv, uv);\n    float hd = d + n;\n    col = pow(vec3(hd), vec3(3.5, 3.5, 2.0)) * HALO_COL * smoothstep(1.0, 1.0 - f, hd);\n    float cd = d * hd * hd * smoothstep(1.0, 1.0 - f, hd) * 1.25;\n    col += cd * cd * mix(EDGE1_COL, EDGE2_COL, pow(hd, 8.0)) - (cd * cd * cd) * col;\n    col = mix(BACKGROUND_COL, col, smoothstep(1.0, 1.0 - f, hd));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float min_res = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min_res * 1.1;\n    \n    vec3 col = mix(mix(mix(mix(\n    circle(uv, 0.0), \n    circle(uv, 1000.0), OPACITY), \n    circle(uv, 2000.0), OPACITY), \n    circle(uv, 3000.0), OPACITY), \n    circle(uv, 4000.0), OPACITY);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 230, 230, 277], [278, 278, 299, 299, 346], [347, 347, 366, 366, 407], [409, 409, 430, 430, 921], [923, 923, 946, 946, 986], [988, 988, 1013, 1013, 1106], [1108, 1108, 1136, 1136, 1220], [1222, 1222, 1256, 1256, 1992], [1994, 1994, 2051, 2051, 2404]], "test": "untested"}
{"id": "mdGyDG", "name": "Bitwise Pattern Thingy", "author": "SnoopethDuckDuck", "description": "golfing welcome but I havent tried cutting many characters", "tags": ["bitwise"], "likes": 22, "viewed": 222, "published": 3, "date": "1696529026", "time_retrieved": "2024-07-30T17:30:24.239932", "image_code": "// -10 thanks to iq 🦦\nvoid mainImage( out vec4 o, vec2 u )\n{\n    u = u/3. + iTime*vec2(5,20);\n    o *= 0.;\n    for( float k; k++ < 32.; )\n        o[(int(u.y)+(4^int(18.*o.a))^int(u.x)+int(22.*o.a))%53/3] += k/528.;\n\n    o += .6 * abs(o.r-o.b);\n    o += .04 + .6 * o.b * (o.rrba-o);\n}\n\n// Original\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    ivec2 i = ivec2(u/3. + iTime*vec2(5,20));  \n    o *= 0.;\n    for (int k; k++ < 32;) \n        o[((4^int(9.*o.a))+i.y^i.x+int(11.*o.a))%53/3] += float(k)/264.;\n\n    o = .5 * o + .3 * abs(o.r-o.b);\n    o += .04 + .6 * o.b * (o.rrba-o);\n}\n//*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "cdGcDy", "name": "Twinkling Stars - 101 chars", "author": "GregRostami", "description": "A time-lapse of the universe where you can see the birth and death of stars!! ;-)", "tags": ["2d", "noise", "stars", "short", "golfing"], "likes": 7, "viewed": 197, "published": 3, "date": "1696524576", "time_retrieved": "2024-07-30T17:30:24.983942", "image_code": "void mainImage(out vec4 o,vec2 u) {\n    //u = ceil(u/4.); // Uncomment to see pixelated stars.\n    o = .003/fract( tan(dot(u+=vec2(iFrame/4),u) / u.x+1e-4*iTime) * u.xxxx); }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 94, 174]], "test": "untested"}
{"id": "csyyDy", "name": "graphene extracts", "author": "chenxianming", "description": "a random steps and color extracts of graphene art", "tags": ["generativeart", "cineshader"], "likes": 4, "viewed": 787, "published": 3, "date": "1696523968", "time_retrieved": "2024-07-30T17:30:25.748897", "image_code": "#define I iResolution\n#define PI 3.1415926\n#define T( s ) fract( iTime * s ) * PI * 4.\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n\nfloat cg( vec3 p ){\n    float py = p.y;\n\n    py = abs( py ) - .5; // equal to each side\n    py = abs( py );\n    \n    return max(\n      max( abs( p.x ) - .5 * py, abs( p.z ) - .5 * py ),\n      abs( p.y ) - .5\n    );\n}\n\nfloat df(vec3 p)\n{\n\n  p.z -= 2.5;\n  p.xz *= rot( T( .005 ) );\n  \n  float k = .8;\n  \n  for( float i = 0.; i < 16.; i++ ){\n      p.xz *= rot( i );\n      k += i / 5.;\n      p.xz = abs( p.xz ) - .01 * i;\n      p.y -= ( k * .01 ) * ( round( fract( iTime * .05 + .12345 * i ) * 10. ) * .1 );\n      p.zy *= -rot( i );\n  }\n\n  return cg( p );\n}\n\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -2) * 2.;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = (V * 2.0 - I.xy) / I.y;\n    \n    vec3 c = vec3( 1. - smoothstep( 0., 2., length( u ) - .5 ) ) * vec3( .4, .6, .9 ) * .2, p, n, o = vec3( 0., 0., -3. ), r = vec3( u * .2, 1. );\n    float t, d, i, dp, e = sqrt( 1e-4 );\n    for( ; i < 32.; i++ )\n        p = o + r * t,\n        d = df( p ),\n        dp = ( 1. - abs( d ) / e ),\n        c += ( dp > 0. ) ? .1 * dp / t : 0., // sub but color not rich\n        t += max( abs( d ), e * 2. );\n\n    p = vec3( 0. );\n    t = 0.,\n    i = 0.,\n    dp = 0.;\n    \n    for( ; i < 16.; i++ )\n        p = o + r * t,\n        d = df( p ),\n        dp = ( 1. - abs( d ) / e ),\n        n = dp > 0. ? l( p ) : vec3( 0. ),\n        n = normalize( reflect( p, n ) ) * .25,\n        n += dot( reflect( p, r ), n ) * .7,\n        c += ( dp > 0. ) ? ( n + .25 * ( dp / t ) ) * .6 : vec3(0.),\n        t += max( abs( d ) * .88889, e * .6 );\n\n    // Output to screen\n    U = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csyyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 163, 163, 360], [362, 362, 380, 380, 697], [699, 699, 718, 718, 911], [913, 913, 954, 1004, 1918]], "test": "untested"}
{"id": "DdyyWR", "name": "Backroom Pools", "author": "servostar", "description": "Backrooms inspired scenery shader with hacky water and a VHS filter.", "tags": ["sdf", "water", "pool", "backroom"], "likes": 35, "viewed": 629, "published": 3, "date": "1696522133", "time_retrieved": "2024-07-30T17:30:26.683399", "image_code": "\n#define CIRCLE\n\nconst float TWO_PI = 6.283185307179586;\n\nfloat seed = 0.0;\nfloat rand()\n{\n    seed += .2874365;\n    return fract(sin(seed * 475.89756) * 45.487);\n}\n\nfloat luminance(in vec3 rgb)\n{\n    return dot(rgb, vec3(0.21, 0.72, 0.07));\n}\n\n/**\n* Intensifies the brightest pixels of the applied kernel based on the luminance() function\n* This is a modified dilation filter\n*/\nvec3 bokeh(in sampler2D tex, in vec2 uv, in float sep)\n{\n    vec3 cc = texture(tex, uv).rgb;\n    vec3 tc = cc;\n    float cl = luminance(cc);\n\n    vec2 texSize = sep/vec2(textureSize(tex, 0));\n\n    for (float i = 0.0; i < 64.0; i++)\n    {\n        vec2 rr = vec2(rand(), rand())*vec2(TWO_PI, 1);\n        vec2 xy = vec2(sin(rr.x), cos(rr.x))*rr.y;\n\n        vec2 off = xy*texSize;\n        vec3 s = texture(tex, uv + off).rgb;\n        float b = luminance(s);\n\n        if (cl < b)\n        {\n            cl = b;\n            tc = s;\n        }\n    }\n    \n    return tc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // linear RGB\n    vec3 col = bokeh(iChannel0, uv, 12.*pow(length(uv-.5), 3.));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Noise/hash algorithms from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(vec3 n) { \n\treturn fract(sin(dot(n, vec3(12.9898, 4.1414, 7.829754))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n", "buffer_a_code": "// Rotate a 2D vector\nvoid mkrot(inout vec2 v, in float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    v *= mat2(c,-s,s,c);\n}\n\n// SDF of box\nfloat box(in vec3 p, in vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// SDF of cylinder\nfloat cylinder(in vec3 p, in float h, in float r)\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat map(in vec3 p, in vec3 bp)\n{\n    float h = max(p.y-5., -box(p-vec3(0,1,0), vec3(12, 3, 11)) );\n    h = max(h, -cylinder( (p.xyz*vec3(1,.85,1)-vec3(-.3, 0, 10)).xzy, 8.0, 3.0));\n    h = max(h, -(box(p-vec3(1, 1, 23), vec3(1.5,2,5))-1.));\n\n    h = min(h,  box(p-vec3( 3.5,-1.5,10), vec3(2,2,9)));\n\n    h = max(h, -cylinder(p - vec3(0,4,6), 9.0, 1.4) );\n\n    h = max(h, -cylinder(p - vec3(-2,0,6), 3.0, 2.0) );\n    h = max(h, -cylinder(p - vec3(-1,0,6), 4.0, 2.0) );\n\n    h = max(h, -box(p - vec3(-1,4,20), vec3(2)) );\n    \n    h = min(h, cylinder(vec3(p.x-.5,p.y, p.z - 4.*round(p.z*.25)) - vec3(+3.5,2,0), 12.0, .4) );\n    h = min(h, cylinder(vec3(p.x+2.,p.y, p.z - 3.*round(p.z*.33)) - vec3(-3.5,2,0), 12.0, .4) );\n    h = min(h, cylinder(vec3(p.x+2.,p.y-2.8, p.z - 3.*round(p.z*.33)) - vec3(-3.5,2,0), 1.0, .6) );\n    h = min(h, cylinder(vec3(p.x+2.,p.y+2.8, p.z - 3.*round(p.z*.33)) - vec3(-3.5,2,0), 1.0, .86) );\n    \n    h = max(h, -box(p-vec3(0, 2, 18), vec3(6,3,4)));\n    \n    h = min(h, length(p - bp)-.5 );\n    \n    return h;\n}\n\nconst float eps = 1e-3;\n\nfloat water(in vec3 p, in vec3 bp)\n{\n    return p.y + noise(p.xz * 6. - vec2(iTime*.5, iTime)) * .01\n            + sin(length(p.xz - bp.xz) * 10. - iTime * 6.)*.01 / length(p.xz - bp.xz)*2.;\n}\n\nconst vec3 sun = normalize(vec3(.2, 1, -.1));\n\nfloat shadow(in vec3 ro, in vec3 rd, in float d, in vec3 bp)\n{\n    float k = 8.;\n    float res = 1.0;\n    float t = 1e-1;\n    for(int i = 0; i < 128 && t < d; i++)\n    {\n        float h = map(ro + rd * t, bp);\n\n        if (h < 5e-3)\n            return 0.0;\n\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\n// Compute point light intensitywith soft shadows\nfloat pointlight(in vec3 p, in vec3 n, in vec3 t, in float i, in vec3 bp)\n{\n    vec3 d = normalize(t - p);\n    float l = shadow(p, d, length(p-t), bp);\n    return l * dot(-d, n) / length(t-p) * i;\n}\n\n// Compute specular reflection with no reflection depth \nvec3 spec(in vec3 p, in vec3 n, in vec3 rd, in vec3 bp)\n{\n    float t = 1e-2;\n    vec3 d = reflect(rd, n);\n    for(int i = 0; i < 256; i++)\n    {\n        float h = map(p + d * t, bp);\n\n        if (h < 1e-3)\n            return max(mix(vec3(.7,1,1), vec3(0,.1,.4), rand(floor((p + d * t) * 16.)) ) * clamp(0., 1., t*.1), vec3(0));\n\n        t += h;\n    }\n    return vec3(5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(2, 1.8, sin(iTime*2.)*.05 );\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    // static camera rotation\n    mkrot(rd.yz, 0.12);\n    mkrot(rd.xz, 0.2);\n    \n    // dynamic camera wiggle\n    mkrot(rd.xy, sin(iTime*1.)*.02 );\n    mkrot(rd.yz, cos(iTime*2.2)*.01 );\n\n    vec3 col = vec3(0);\n    \n    vec3 p = ro;\n    vec4 wr = vec4(0); // water reflection and cos theta\n    bool ref = true;   // if water surface was hit\n\n    // precompute position of water ball\n    float bt = iTime * .16;\n    vec3 bp = vec3(-2. +cos(bt) , sin(iTime*3.)*.05 + .2, 5. +sin(bt) );\n    \n    for (int i = 0; i < 256; i++)\n    {\n        float h = map(p, bp);\n        float wh = water(p, bp);\n    \n        if (h < 1e-3)\n        {\n            // normal of geometry\n            vec3 nor = normalize(map(p, bp) - vec3(\n                map(p + vec3(eps, 0, 0), bp),\n                map(p + vec3(0, eps, 0), bp),\n                map(p + vec3(0, 0, eps), bp)\n            ));\n\n            // direct sun light\n            float lum = shadow(p, sun, 1e3, bp) * 3.;\n            float key = lum; // save direct sun light for later\n\n            // atrium\n            lum = max(lum, pointlight(p, nor, vec3(0,0,6), 3., bp) );\n            lum = max(lum, pointlight(p, nor, vec3(-1,2,6), 2., bp) );\n\n            // back room\n            lum = max(lum, pointlight(p, nor, vec3(-2.5,0,20), 2., bp) );\n            lum = max(lum, pointlight(p, nor, vec3(-.5,1,23), .5, bp) );\n\n            // albedo for tiles\n            vec3 alb = mix(vec3(.7,1,1), vec3(0,.1,.4), rand(floor(p * 12.)) );\n            \n            // specular reflection\n            vec3 spec = spec(p, nor, rd, bp);\n\n            // mask out water ball for custom material\n            if (distance(bp, p) < 1.)\n            {\n                // offset origin to center of ball\n                // rotate ball\n                vec3 pm = p - bp;\n                mkrot(pm.xz, -iTime * .2);\n                mkrot(pm.yz,  iTime * .3);\n                \n                // texture the ball\n                alb = mix(vec3(1,0,0), vec3(1,1,0), step(.0, sin(atan(pm.z/pm.x) * 4.)) );\n                alb = mix(alb, vec3(1), step(.49, abs(pm.y)) );\n                \n                // apply specular and diffuse illumination\n                col = mix(spec, alb * (lum * .7 + .3), pow(dot(nor, rd), .6) );\n            }\n            else\n                // we hit the tile environment\n                // apply specular and diffuse illumination\n                col = mix(spec, alb * lum, pow(dot(nor, rd), .2) );\n\n            // check if water surface was hit before geometry\n            if (!ref)\n            {\n                // water caustics\n                vec3 s = smoothstep(0.95, 1., cos(p*16. + (noise(p.xy) + noise(p.yz)) * 32. + iTime*6.));\n                col += (s.x+s.z+s.y) * lum * key;\n\n                col = mix(col, vec3(.2,.8,1) * lum, clamp( pow(abs(p.y), 2.) * 7e-2, .0, .7) );\n                col = mix(wr.rgb, col, wr.a);\n            }\n\n            break;\n        } else if (ref && wh < 1e-6)\n        {\n            vec3 n = normalize(wh + vec3(\n                water(p + vec3(eps, 0, 0), bp),\n                water(p + vec3(0, eps, 0), bp),\n                water(p + vec3(0, 0, eps), bp)\n            ));\n\n            rd = refract(rd, n, 1./1.45);\n            ref = false;\n            wr = vec4(spec(p, n, rd, bp), dot(-n, rd));\n        }\n\n        h = ref ? min(h, wh) : h;\n        p += rd * h;\n    }\n    \n    col = mix(max(col, vec3(0)), texture(iChannel0, (fragCoord.xy+.5)/iResolution.xy).rgb, .5);\n\n    fragColor = vec4(col, distance(ro, p));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 uncharted2_tonemap_partial(vec3 x)\n{\n    float A = 0.15f;\n    float B = 0.50f;\n    float C = 0.10f;\n    float D = 0.20f;\n    float E = 0.02f;\n    float F = 0.30f;\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 uncharted2_filmic(vec3 v)\n{\n    float exposure_bias = 2.0f;\n    vec3 curr = uncharted2_tonemap_partial(v * exposure_bias);\n\n    vec3 W = vec3(11.2f);\n    vec3 white_scale = vec3(1.0f) / uncharted2_tonemap_partial(W);\n    return curr * white_scale;\n}\n\nvec3 conv(in sampler2D tex, in vec2 uv, in mat3 ker)\n{\n    vec3 sum = vec3(0);\n    \n    for (int x = 0; x < 3; x++)\n    for (int y = 0; y < 3; y++)\n    {\n        vec2 off = (vec2(x,y)*.3333-.5)/iResolution.xy;\n        sum += texture(tex, uv + off).rgb * ker[x][y];\n    }\n    \n    return sum;\n}\n\nvec3 laplace(in sampler2D tex, in vec2 uv, in float strength)\n{\n    float k = -strength;\n    mat3 ker = mat3(\n        vec3(k, k, k),\n        vec3(k, 8.*strength+1., k),\n        vec3(k, k, k)\n    );\n    \n    return conv(tex, uv, ker);\n}\n\nvec3 emboss(in sampler2D tex, in vec2 uv, in float theta)\n{\n    // init kernel\n    mat3 ker = mat3(\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    // direction of edge detection\n    vec2 dir = vec2(sin(theta), cos(theta));\n    \n    // fill kernel with values\n    for (int x = -1; x < 2; x++)\n    for (int y = -1; y < 2; y++)\n        ker[x+1][y+1] = dot(dir, vec2(x,y));\n    \n    return conv(tex, uv, ker)+.5;\n}\n\nconst float Samples = 4.;\nconst float Strength = 0.02;\n\nvec3 chromatic_aberration(in sampler2D tex, in vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    uv -= .5;\n    \n    vec3 f = 1. - length(uv) * Strength*vec3(2.,1.,0.);\n    \n    for (float i = 0.; i < Samples; i++)\n    {\n        vec3 fs = mix(f, vec3(1), i/Samples);\n        col += vec3(\n            texture(tex, uv * fs.x+.5).r,\n            texture(tex, uv * fs.y+.5).g,\n            texture(tex, uv * fs.z+.5).b\n        );\n    }\n    return col / Samples;\n}\n\nvec3 vhs(in vec2 uv)\n{\n    // sharpen the image\n    // + filmic tonemap\n    vec3 col = laplace(iChannel0, uv, 1.3);\n    \n    // add chromatic aberration\n    vec3 abbr = chromatic_aberration(iChannel0, uv);\n    col = col + (abbr - texture(iChannel0, uv).rgb);\n    \n    // add grunge\n    col *= texture(iChannel1, uv).rgb * .8 + .2 + .4;\n    \n    // bleach out\n    col = col * .92 + rand(uv * 345.3567 + iTime)*.08;\n     \n    return uncharted2_filmic(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // VHS glitch\n    float i = sin(iTime / 5.);\n    i *= i * i;\n    i *= i * i;  // <<-- pow() function generated some weird NaN value\n    i *= i * i;  //            while testing on AMD GPU\n    i *= i * i;\n    i *= i * i;\n    uv.x += fract(uv.y * uv.y + iTime * 4.) * sign(sin(iTime + uv.y * rand(vec2(iTime)) * 8.)) * i * 5e-2;\n\n    // linear RGB\n    vec3 col = texture(iChannel0, uv).rgb * 2.;\n    \n    col = vhs(uv);\n    \n    // grainy stripe\n    col += rand(uv.yy+iTime) * .01;\n    col -= rand(uv.yy-iTime) * .01;\n\n    fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdyyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 90, 90, 164], [166, 166, 196, 196, 243], [245, 380, 436, 436, 942], [944, 944, 999, 999, 1158]], "test": "untested"}
{"id": "DlsyRj", "name": "BC - Water Sphere", "author": "BackwardsCap", "description": "A little experiment around stylized shading and using a cool displacement technique I had found ( https://www.shadertoy.com/view/4scSW4 )", "tags": ["raymarching", "displacement", "water", "fx", "stylized"], "likes": 18, "viewed": 315, "published": 3, "date": "1696512954", "time_retrieved": "2024-07-30T17:30:27.432396", "image_code": "// https://www.shadertoy.com/view/4scSW4\t\nfloat displacement(vec3 p)\n{\n    vec2 d1 = p.xy * 0.3;\n    vec2 d2 = d1 * 0.2;\n    d1.x+=d1.y*2.;\n    d1.x += iTime*0.05;\n    d2.x += iTime *0.1;\n    d2.y -= iTime * 0.025;\n    d2.x += d2.y*2.;\n    \n    float h1 = texture(iChannel0, d2).x;\n    float h2 = texture(iChannel0, d1).x;\n    \n    return h1 * .6 + h2 * 0.1* (1.0 - h1 );\n}\n\nvec2 map(vec3 p)\n{\n    vec2 r;\n    \n\n    float d = displacement(p);\n    float warp = cos(p.y*.3*cos(iTime/10.+1.56));\n    float column1 = sphere(p * warp,3.0) + d;\n        \n    r = vec2(column1, 1.0);\n    return r ;\n}\n\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    float t=0.,m;\n    for(int i=0;i<128;i++)\n    {\n        vec3 p = ro+rd*t;\n        vec2 s = map(p);\n        m=s.y;\n        if(s.x<0.001)break;\n        t+=s.x;\n        if(t>MAX_DIST){t=-1.;break;}\n    }\n    return vec2(t,m);\n}\n\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01,0);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n        ));\n}\nfloat fresnel(vec3 n, vec3 dir, float power)\n{\n    return pow(1.0+dot(dir, n), power);\n}\nfloat shine(vec3 p, vec3 n)\n{\n    p.y = 0.;\n    float d = (dot(normalize(p), n));\n    \n    float r = 0.0;\n    if(d >= .99)\n        r += 0.2*d;\n    return r;\n}\nvec3 down(vec3 c, float s)\n{\n    c.rg*=s;\n    c.rg = floor(c.rg);\n    c.rg/=s;\n    return c;\n}\n\nvoid mainImage( out vec4 c, in vec2 f)\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.067,0.502,0.933)*(((cos(uv.x)+cos(uv.y))))/2.75;\n    col = down(col,60.);\n    vec3 bg = col;\n    float t = cos(iTime/5.)/3.;\n    float d = 9.5+(1.0+cos(iTime/2.));\n    vec3 ro = vec3(0,sin(t/.1),cos(t)*d);\n    vec3 ta = vec3(0);\n    vec3 rd = cam(ro,ta,uv);\n    \n    vec2 r = ray(ro,rd);\n    \n    if(r.x>0.0)\n    {\n        vec3 p = ro+rd*r.x;\n        vec3 n = normal(p);\n        \n        \n        vec3 mate=vec3(.0,.5,1.0);\n        vec3 sun = normalize(vec3(0.5,.5,.5));\n        vec3 backlight = normalize(vec3(-0.5,-.5,-.5));\n        float dif = clamp(dot(sun,n),0.,1.);\n        float bdif = clamp(dot(backlight,n),0.,1.);\n        float sky = clamp(dot(n,vec3(0,1,0)),0.,1.);\n        float bou = clamp(dot(n,vec3(0,-1,0)),0.,1.);\n        float sha = clamp(ray(p+n*.001,sun).x,0.,1.);\n        \n        \n        col=dif * mate;\n        col+=bdif * mate;\n        col+=sky * mate;\n        col+=bou * mate;\n        col += fresnel(n, rd, 3.) * vec3(0.6,0.9,1.0);\n        \n        vec3 ref = texture(iChannel1, n).rgb;\n        float s = shine(p,n);\n        col = mix(col, ref, 0.5 + s);\n        col = mix(col, bg, fresnel(n,rd,2.)*1.5);\n        col=down(col,8.);\n        col = mix(col, bg, clamp(r.x/MAX_DIST,0.,1.));\n    }\n    \n\n    \n    c.rgb=col;\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_DIST 60.0\n#define PI 3.1415927\n\nvec3 cam(vec3 ro, vec3 ta, vec2 uv)\n{\n    vec3 cf = normalize(ta-ro);\n    vec3 cu = normalize(cross(cf,vec3(0,1,0)));\n    vec3 cr = normalize(cross(cu,cf));\n    return normalize(uv.x*cu+uv.y*cr+2.*cf);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DlsyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 42, 70, 70, 373], [375, 375, 393, 393, 592], [595, 595, 623, 623, 851], [854, 854, 875, 875, 1059], [1060, 1060, 1106, 1106, 1148], [1149, 1149, 1178, 1178, 1307], [1308, 1308, 1336, 1336, 1402], [1404, 1404, 1444, 1444, 2768]], "test": "untested"}
{"id": "cdGyWG", "name": "Burning torch", "author": "ianertson", "description": "A burning torch", "tags": ["fire", "torch"], "likes": 9, "viewed": 194, "published": 3, "date": "1696509016", "time_retrieved": "2024-07-30T17:30:28.266167", "image_code": "#define R iResolution.xy\n#define T (iTime)\n\n\nfloat hash21(in vec2 ip, in float seed) {\n    uvec2 p = floatBitsToUint(ip);\n    uint s = floatBitsToUint(seed);\n    uvec2 k = (~p >> 3U) * (s + 561U);\n    uint j = ~s; \n    p ^= p << 17U;\n    p ^= p >> 13U;\n    p += (p.x * j + p.y);\n    p ^= p << 5U; \n    p = (p + (p * k) * (p * s)) * 1013U;  \n    return float((p.x*p.y)*5013U) / float(0xFFFFFFFFU);\n}\n\nfloat noise21(in vec2 p, in float seed) {\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    vec2 id = floor(p);  \n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1, 0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat noise21(in vec2 p, in float seed, in float freq, const in int oct) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < oct; i++) {\n        n += amp * noise21(p*freq, seed);\n        div += amp;\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n\n    return n / div;\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float d = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(1.0 - length(pa - ba * d) / t, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec2 uv = fc/R.y;\n    vec3 col = vec3(0.0);\n    vec2 dir = normalize(mix(vec2(0, -1), vec2(cos(T), sin(T)), 0.2));\n    float len = 0.26;\n    vec2 start = vec2((R.x/R.y)*0.5, 0.5);\n    vec2 end = start+dir*len;\n    float n0 = noise21(uv-dir, 0.34981, 3.0, 3);\n    vec2 toff = vec2(sin(T+n0), cos(T+n0));\n    float n = noise21(mix(\n    uv+toff, (uv+toff)-end,\n    distance(uv, start)/max(0.1, distance(uv, end))), 0.181813, 6.0, 3);\n    vec2 off = vec2(cos(n*6.28), sin(n*6.28))*0.021;\n    float lrp = smoothstep(0.02, 1.4, distance(uv + off, end));\n    vec2 lp = mix(start, end, lrp);\n    float l = line(uv, start, end, max(0.01, lrp));\n    col += l;\n    col = mix(col, col*vec3(1, 0, 0), smoothstep(0.0, 0.4, distance(uv + off, end)));\n    col = mix(col, vec3(1.0, 0.9, 0.25), l*smoothstep(0.3, 1.0, distance(uv + off, end)));\n    col = pow(col, vec3(1.0 / 2.2));\n    O = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 86, 86, 398], [400, 400, 441, 441, 709], [1021, 1021, 1078, 1078, 1239], [1242, 1242, 1284, 1284, 2178]], "test": "untested"}
{"id": "mddcRB", "name": "RTGI", "author": "sirjofri", "description": "realtime GI test", "tags": ["rtgi"], "likes": 1, "viewed": 69, "published": 3, "date": "1696493687", "time_retrieved": "2024-07-30T17:30:29.211639", "image_code": "// postprocess\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = texture(iChannel0, uv).rgba;\n    vec3 lm = texture(iChannel1, uv).rgb;\n    \n    // place mouse in top half to show lightmap\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (m.y > .5)\n        color = vec4(lm, 1.);\n\n    fragColor = vec4(color);\n}\n\n/* text for converting mesh data from blender */\n/*\n\nimport bpy\nimport struct\n\ntid = 0\narrname = \"triangles\"\n\ndef f2h(f):\n    return hex(struct.unpack('=I', struct.pack('=f', f))[0])\n\ndef v2s(vector):\n    v1 = f2h(vector[0])\n    v2 = f2h(vector[1])\n    v3 = f2h(vector[2])\n    return [v1, v2, v3]\n\ndef u2s(vector):\n    v1 = f2h(vector[0])\n    v2 = f2h(vector[1])\n    return [v1, v2]\n\ndef validlm(vector):\n    if (vector[0] > 0 and vector[0] < 1 and vector[1] > 0 and vector[1] < 1):\n        return \"valid\"\n    else:\n        return \"invalid\"\n\nmylist = []\n\nfor obj in bpy.context.selected_objects:\n    data = obj.data\n    for triangle in data.polygons:\n        uvid1 = -1\n        uvid2 = -1\n        uvid3 = -1\n        for vert_idx, loop_idx in zip(triangle.vertices, triangle.loop_indices):\n            if vert_idx == triangle.vertices[0]:\n                uvid1 = loop_idx\n            if vert_idx == triangle.vertices[1]:\n                uvid2 = loop_idx\n            if vert_idx == triangle.vertices[2]:\n                uvid3 = loop_idx\n        if uvid1 < 0 or uvid2 < 0 or uvid3 < 0:\n            print(\"error: invalid uvid\")\n        v1 = data.vertices[triangle.vertices[0]].co\n        v2 = data.vertices[triangle.vertices[1]].co\n        v3 = data.vertices[triangle.vertices[2]].co\n        n1 = data.vertex_normals[triangle.vertices[0]].vector\n        n2 = data.vertex_normals[triangle.vertices[1]].vector\n        n3 = data.vertex_normals[triangle.vertices[2]].vector\n        u1 = data.uv_layers[0].data[uvid1].uv\n        #u1[0] = 1-u1[0]\n        u2 = data.uv_layers[0].data[uvid2].uv\n        #u2[0] = 1-u2[0]\n        u3 = data.uv_layers[0].data[uvid3].uv\n        #u3[0] = 1-u3[0]\n        l1 = data.uv_layers[1].data[uvid1].uv\n        l1[0] = 1-l1[0]\n        l2 = data.uv_layers[1].data[uvid2].uv\n        l2[0] = 1-l2[0]\n        l3 = data.uv_layers[1].data[uvid3].uv\n        l3[0] = 1-l3[0]\n        m = triangle.material_index\n        n = triangle.normal\n        print(f\"   - new triangle -\")\n        print(f\"PointA = vec3({v1[0]}, {v1[1]}, {v1[2]});\")\n        print(f\"PointB = vec3({v2[0]}, {v2[1]}, {v2[2]});\")\n        print(f\"PointC = vec3({v3[0]}, {v3[1]}, {v3[2]});\")\n#        print(f\"NormalA = vec3({n1[0]}, {n1[1]}, {n1[2]});\")\n#        print(f\"NormalB = vec3({n2[0]}, {n2[1]}, {n2[2]});\")\n#        print(f\"NormalC = vec3({n3[0]}, {n2[1]}, {n3[2]});\")\n        print(f\"NormalA = vec3({n[0]}, {n[1]}, {n[2]});\")\n        print(f\"Material = {m};\")\n        print(f\"UVA = vec2({u1[0]}, {u1[1]});\")\n        print(f\"UVB = vec2({u2[0]}, {u2[1]});\")\n        print(f\"UVC = vec2({u3[0]}, {u3[1]});\")\n        print(f\"LUVA = vec2({l1[0]}, {l1[1]}); // {validlm(l1)}\")\n        print(f\"LUVB = vec2({l2[0]}, {l2[1]}); // {validlm(l2)}\")\n        print(f\"LUVC = vec2({l3[0]}, {l3[1]}); // {validlm(l3)}\")\n        mylist.extend(v2s(v1))\n        mylist.extend(v2s(v2))\n        mylist.extend(v2s(v3))\n        mylist.extend(v2s(n)) # take face normal\n        mylist.extend(v2s(n))\n        mylist.extend(v2s(n))\n        mylist.append(hex(m))\n        mylist.extend(u2s(u1))\n        mylist.extend(u2s(u2))\n        mylist.extend(u2s(u3))\n        mylist.extend(u2s(l1))\n        mylist.extend(u2s(l2))\n        mylist.extend(u2s(l3))\n\ntry:\n    mytext = bpy.data.texts[\"triangle_data\"]\nexcept:\n    bpy.data.texts.new(\"triangle_data\")\n    mytext = bpy.data.texts[\"triangle_data\"]\n\nmytext.clear()\nmytext.write(f\"{'u,'.join(mylist)}u\")\n\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// generate lightmap using pathtracing\n\n#define MAXLIGHT .3\n#define MAXBOUNCES 2\n\n//#define LIGHTINGONLY\n\nvec3 shader0(vec2 uv) {\n#ifdef LIGHTINGONLY\n    return vec3(.7);\n#else\n    return texture(iChannel1, uv*2.).rgb;\n#endif\n}\n\nvec3 shader1(vec2 uv) {\n#ifdef LIGHTINGONLY\n    return vec3(.7);\n#else\n    return texture(iChannel2, uv).rgb;\n#endif\n}\n\nvec3 shader2(vec2 uv) {\n#ifdef LIGHTINGONLY\n    return vec3(.7);\n#else\n    return texture(iChannel3, uv*.5).rgb;\n#endif\n}\n\nvec3 shadecol(int triangle, vec3 bary)\n{\n    Triangle t = unpackTriangle(triangle);\n    vec2 uv = t.UVA*bary.x + t.UVB*bary.y + t.UVC*bary.z;\n    if (t.MaterialID == 0) return shader0(uv);\n    if (t.MaterialID == 1) return shader1(uv);\n    if (t.MaterialID == 2) return shader2(uv);\n    return vec3(1., 0., 1.);\n}\n\nvec3 tuv2wp(Triangle t, vec3 bary)\n{\n    return t.PointA*bary.x + t.PointB*bary.y + t.PointC*bary.z;\n}\n\nHitPoint trace(vec3 wp, vec3 wn, vec3 raydir, int triangle)\n{\n    HitPoint ret;\n    ret.triangle = -1;\n    ret.bary = vec3(-1.);\n    ret.dist = -1.;\n    \n    int hit = -1;\n    float hitdist = -1.;\n    vec3 hitbary = vec3(0.);\n    for (int j = 0; j < triangleLength(); j++) {\n        if (j == triangle) continue;\n        Triangle t = unpackTriangle(j);\n        vec3 center = (((t.PointB - t.PointA)/2. + t.PointA) - t.PointC)/2. + t.PointC;\n        vec3 normal = normalize((t.NormalA + t.NormalB + t.NormalC) * 0.5); // average normal of triangle\n\n        // check if we hit plane\n        float denom = dot(normal, raydir);\n        if (!(abs(denom) > 0.0001f)) continue;\n\n        float testt = dot((center - wp), normal) / denom;\n        if (testt < 0.) continue;\n\n        // if not inside triangle, continue\n        vec3 b = bary3d(t.PointA, t.PointB, t.PointC, wp + testt*raydir);\n        if (!baryinside(b))\n            continue;\n\n        if (hit >= 0) {\n            if (hitdist < testt)\n                continue;\n            hit = j;\n            hitdist = testt;\n            hitbary = b;\n        } else {\n            hit = j;\n            hitdist = testt; // distance from wp. hitpos = wp + hitdist*raydir\n            hitbary = b;\n        }\n    }\n    \n    if (hit < 0)\n        return ret;\n    \n    ret.triangle = hit;\n    ret.bary = hitbary;\n    ret.dist = hitdist;\n    return ret;\n}\n\nvec4 tracerow(vec3 wp, vec3 wn, vec3 raydir, int triangle)\n{\n    vec3 color = vec3(.8, .9, 1.);\n    float totaldist = -1.;\n    vec3 rd = raydir;\n    for (int i = 0; i < MAXBOUNCES; i++) {\n        HitPoint h = trace(wp, wn, rd, triangle);\n        if (h.triangle < 0) {\n            //color *= vec3(1.); //vec3(1., 0., 1.); // sky\n            totaldist += 50.;\n            break;\n        }\n        color *= shadecol(h.triangle, h.bary); // * clamp(MAXLIGHT - h.dist, 0., 1.); // needs lighting model from distance\n        totaldist += h.dist;\n        wp = wp + rd*h.dist;\n        triangle = h.triangle;\n        wn = hit2n(h);\n        rd = reflect(rd, wn);\n    }\n    \n    return vec4(color, totaldist);\n    \n    // todo: trace in loop\n    HitPoint h = trace(wp, wn, raydir, triangle);\n    if (h.triangle < 0)\n        return vec4(-1.);\n    \n    return vec4(shadecol(h.triangle, h.bary), h.dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    buildscene();\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec3 thissample = col; // default to nop\n    for (int i = 0; i < triangleLength(); i++) {\n        Triangle t = unpackTriangle(i);\n        \n        float m = edge(t.LUVC, t.LUVB, uv);\n        float n = edge(t.LUVA, t.LUVC, uv);\n        float o = edge(t.LUVB, t.LUVA, uv);\n        bool inside = m > 0. && n > 0. && o > 0.;\n        if (!inside)\n            continue;\n        \n        float area = edge(t.LUVB, t.LUVA, t.LUVC);\n        vec3 bary = vec3(\n            m/area, n/area, o/area\n        );\n        \n        vec3 wp = tuv2wp(t, bary);\n        vec3 wn = t.NormalA*bary.x + t.NormalB*bary.y + t.NormalC*bary.z;\n        \n        vec3 matcol = shadecol(i, bary);\n        thissample = matcol;\n        \n        vec3 raydir = normalize(vrand(iTime + fract(wp.x+wp.y+wp.z)));\n        if (dot(raydir, wn) < 0.)\n            raydir *= -1.;\n        \n        vec4 result = tracerow(wp, wn, raydir, i);\n        \n        if (result.a < 0.)\n            continue;\n        \n        thissample = result.rgb * matcol;\n    }\n    \n    float m = clamp(pow(clamp((5.-iTime)/5., 0., 1.), 2.), 0.005, 1.);\n    fragColor = vec4(mix(col, thissample, m), 1.0);\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Triangle {\n    vec3 PointA;     // 0\n    vec3 PointB;     // 3\n    vec3 PointC;     // 6\n    vec3 NormalA;    // 9\n    vec3 NormalB;    // 12\n    vec3 NormalC;    // 15\n    int MaterialID;  // 18\n    vec2 UVA;        // 19\n    vec2 UVB;        // 21\n    vec2 UVC;        // 23\n    vec2 LUVA;       // 25\n    vec2 LUVB;       // 27\n    vec2 LUVC;       // 29\n};                   // 31\n\nTriangle SceneTriangles[6];\n\n// prepare for data serialization\nconst uint data[] = uint[](\n0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbf1d8bc3u,0x3d108918u,0x0u,0xbef03518u,0xbdcf1af0u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0x1u,0x372c0000u,0x40400000u,0x3f800056u,0x40000001u,0x3f800056u,0x40400000u,0x3de359c8u,0x3e63a870u,0x38d1c000u,0x3eaa9d8fu,0x38d1c000u,0x3e63a870u,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x0u,0xbf1d8bc3u,0x3d108918u,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0x1u,0x3f800056u,0x3f800000u,0x372e0000u,0x0u,0x3f800056u,0x34000000u,0x3de359c8u,0x3de3c2a7u,0x38d1c000u,0x3e637402u,0x38d1c000u,0x3de3c2a7u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x0u,0xbef53fa6u,0x3e39e720u,0x0u,0x3f2e9babu,0x3f3b360eu,0x0u,0x3f2e9babu,0x3f3b360eu,0x0u,0x3f2e9babu,0x3f3b360eu,0x0u,0x1u,0x372c0000u,0x40000000u,0x3f800056u,0x3f800000u,0x3f800056u,0x40000000u,0x3f7ff972u,0x3f6394c7u,0x3f6394c7u,0x3f7ff972u,0x3f6394c7u,0x3f6394c7u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x0u,0xbeaa5d39u,0x3d38dd88u,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x2u,0x3f800057u,0x3f800000u,0x4000002cu,0x0u,0x4000002cu,0x3f800000u,0x3de359c8u,0x38d1b717u,0x38d1c000u,0x3de359cbu,0x38d1c000u,0x38d1b717u,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x4000002bu,0x3f800001u,0x3f800056u,0x40000001u,0x3f800057u,0x3f800001u,0x3f6387abu,0x3f6394c7u,0x3f472300u,0x3f7ff972u,0x3f472300u,0x3f6394c7u,0x3f800000u,0xbf800000u,0x0u,0xbf800000u,0x3f800000u,0x0u,0xbf800000u,0xbf800000u,0x0u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f7ff972u,0x38d1b717u,0x3de3c2a8u,0x3f6387abu,0x3de3c2a8u,0x38d1b717u,0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbf1d8bc3u,0x3d108918u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0xbf2e9baau,0xbf3b3610u,0x0u,0x1u,0x372c0000u,0x40400000u,0x372c0000u,0x40000001u,0x3f800056u,0x40000001u,0x3de359c8u,0x3e63a870u,0x3de359c8u,0x3eaa9d8fu,0x38d1c000u,0x3eaa9d8fu,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0xbef53fa6u,0x3e39e720u,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0xbf3b360du,0x3f2e9badu,0x0u,0x1u,0x3f800056u,0x3f800000u,0x372c0000u,0x3f800000u,0x372e0000u,0x0u,0x3de359c8u,0x3de3c2a7u,0x3de359c8u,0x3e637402u,0x38d1c000u,0x3e637402u,0xbef53fa6u,0x3e39e720u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x0u,0x3f2e9babu,0x3f3b360eu,0x80000000u,0x3f2e9babu,0x3f3b360eu,0x80000000u,0x3f2e9babu,0x3f3b360eu,0x80000000u,0x1u,0x372c0000u,0x40000000u,0x372c0000u,0x3f800000u,0x3f800056u,0x3f800000u,0x3f7ff972u,0x3f6394c7u,0x3f7ff972u,0x3f7ff972u,0x3f6394c7u,0x3f7ff972u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x3f3b360eu,0xbf2e9babu,0x0u,0x2u,0x3f800057u,0x3f800000u,0x3f800057u,0x0u,0x4000002cu,0x0u,0x3de359c8u,0x38d1b717u,0x3de359c8u,0x3de359cbu,0x38d1c000u,0x3de359cbu,0xbf1d8bc3u,0x3d108918u,0x3e4cccd0u,0xbef03518u,0xbdcf1af0u,0x3e4cccd0u,0xbeaa5d39u,0x3d38dd88u,0x3e4cccd0u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x0u,0x3f800000u,0x0u,0x4000002bu,0x3f800001u,0x4000002bu,0x40000001u,0x3f800056u,0x40000001u,0x3f6387abu,0x3f6394c7u,0x3f6387abu,0x3f7ff972u,0x3f472300u,0x3f7ff972u,0x3f800000u,0xbf800000u,0x0u,0x3f800000u,0x3f800000u,0x0u,0xbf800000u,0x3f800000u,0x0u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x80000000u,0x0u,0x3f800000u,0x0u,0x3f800000u,0x0u,0x3f800000u,0x3f800000u,0x0u,0x3f800000u,0x3f7ff972u,0x38d1b717u,0x3f7ff972u,0x3f6387abu,0x3de3c2a8u,0x3f6387abu\n);\n\nTriangle unpackTriangle(int id)\n{\n    //return SceneTriangles[id];\n    Triangle t;\n    int offset = 31;\n    int i = id*offset;\n    \n    t.PointA  = vec3(uintBitsToFloat(data[i   ]), uintBitsToFloat(data[i+ 1]), uintBitsToFloat(data[i+ 2]));\n    t.PointB  = vec3(uintBitsToFloat(data[i+ 3]), uintBitsToFloat(data[i+ 4]), uintBitsToFloat(data[i+ 5]));\n    t.PointC  = vec3(uintBitsToFloat(data[i+ 6]), uintBitsToFloat(data[i+ 7]), uintBitsToFloat(data[i+ 8]));\n    t.NormalA = vec3(uintBitsToFloat(data[i+ 9]), uintBitsToFloat(data[i+10]), uintBitsToFloat(data[i+11]));\n    t.NormalB = vec3(uintBitsToFloat(data[i+12]), uintBitsToFloat(data[i+13]), uintBitsToFloat(data[i+14]));\n    t.NormalC = vec3(uintBitsToFloat(data[i+15]), uintBitsToFloat(data[i+16]), uintBitsToFloat(data[i+17]));\n    t.MaterialID = int(data[i+18]);\n    t.UVA  = vec2(uintBitsToFloat(data[i+19]), uintBitsToFloat(data[i+20]));\n    t.UVB  = vec2(uintBitsToFloat(data[i+21]), uintBitsToFloat(data[i+22]));\n    t.UVC  = vec2(uintBitsToFloat(data[i+23]), uintBitsToFloat(data[i+24]));\n    t.LUVA = vec2(uintBitsToFloat(data[i+25]), uintBitsToFloat(data[i+26]));\n    t.LUVB = vec2(uintBitsToFloat(data[i+27]), uintBitsToFloat(data[i+28]));\n    t.LUVC = vec2(uintBitsToFloat(data[i+29]), uintBitsToFloat(data[i+30]));\n    \n    return t;\n}\n\nint triangleLength()\n{\n    //return SceneTriangles.length();\n    return data.length() / 31;\n}\n\nstruct HitPoint {\n    int triangle;\n    vec3 bary;\n    float dist;\n};\n\nvec3 hit2n(HitPoint h)\n{\n    Triangle t = unpackTriangle(h.triangle);\n    return normalize(t.NormalA*h.bary.x + t.NormalB*h.bary.y + t.NormalC*h.bary.z);\n}\n\nvec3 hit2w(HitPoint h)\n{\n    Triangle t = unpackTriangle(h.triangle);\n    return t.PointA*h.bary.x + t.PointB*h.bary.y + t.PointC*h.bary.z;\n}\n\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat frand(float x)\n{\n    return rand(x) * 2. - 1.;\n}\n\nvec3 vrand(float x)\n{\n    return vec3(frand(fract(x)), frand(fract(x+0.1)), frand(fract(x+0.2)));\n}\n\n\nfloat edge(vec2 v0, vec2 v1, vec2 p) {\n    return (p.x-v0.x)*(v1.y-v0.y)-(p.y-v0.y)*(v1.x-v0.x);\n}\n\n// from https://math.stackexchange.com/questions/544946/determine-if-projection-of-3d-point-onto-plane-is-within-a-triangle/544947\nvec3 bary3d(vec3 A, vec3 B, vec3 C, vec3 P)\n{\n    vec3 u = B - A;\n    vec3 v = C - A;\n    vec3 n = cross(u, v);\n    vec3 w = P - A;\n    \n    float a = dot(n, n);\n    \n    float gamma = dot(cross(u, w), n) / a;\n    float beta  = dot(cross(w, v), n) / a;\n    float alpha = 1. - gamma - beta;\n    return vec3(alpha, beta, gamma);\n}\n\nbool baryinside(vec3 b)\n{\n    return b.x >= 0. && b.x <= 1.\n        && b.y >= 0. && b.y <= 1.\n        && b.z >= 0. && b.z <= 1.;\n}\n\nvoid calclightmap(int tid, float scale, vec2 offset)\n{\n    Triangle t = SceneTriangles[tid];\n    SceneTriangles[tid].LUVA = t.UVA*scale + offset;\n    SceneTriangles[tid].LUVB = t.UVB*scale + offset;\n    SceneTriangles[tid].LUVC = t.UVC*scale + offset;\n}\n\nvoid addplane(int tid, vec3 v1, vec3 v2, vec3 v3, vec3 v4, float scale, vec2 offset, int mat)\n{\n    vec3 t1n = normalize(cross(v2-v1, v3-v1));\n    vec3 t2n = normalize(cross(v3-v1, v4-v1));\n    SceneTriangles[tid] = Triangle(\n        v1,\n        v2,\n        v3,\n        t1n,\n        t1n,\n        t1n,\n        mat,\n        vec2(0., 0.),\n        vec2(1., 0.),\n        vec2(1., 1.),\n        vec2(0.),\n        vec2(0.),\n        vec2(0.)\n    );\n    SceneTriangles[tid+1] = Triangle(\n        v1,\n        v3,\n        v4,\n        t2n,\n        t2n,\n        t2n,\n        mat,\n        vec2(0., 0.),\n        vec2(1., 1.),\n        vec2(0., 1.),\n        vec2(0.),\n        vec2(0.),\n        vec2(0.)\n    );\n    calclightmap(tid, scale, offset);\n    calclightmap(tid+1, scale, offset);\n}\n\nvoid addbox(int tid, vec3 p, vec3 q, float scale, vec2 offset, int mat)\n{\n    vec3 v1, v2, v3, v4;\n    \n    // x-\n    v1 = p;\n    v2 = vec3(q.x, p.y, p.z);\n    v3 = vec3(q.x, p.y, q.z);\n    v4 = vec3(p.x, p.y, q.z);\n    addplane(tid, v1, v2, v3, v4, scale/2., offset, mat);\n    \n    // y-\n    v1 = vec3(p.x, q.y, p.z);\n    v2 = p;\n    v3 = vec3(p.x, p.y, q.z);\n    v4 = vec3(p.x, q.y, q.z);\n    addplane(tid+2, v1, v2, v3, v4, scale/2., offset+offset*vec2(scale/2., 0.), mat);\n}\n\nvoid buildscene()\n{\n    addplane(0, vec3(0.), vec3(1., 0., 0.), vec3(1., 1., 0.), vec3(0., 1., 0.), 0.5, vec2(0.), 1);\n    addplane(2, vec3(.5, .4, 0.), vec3(.7, .4, 0.), vec3(.7, .4, .2), vec3(.5, .4, .2), .25, vec2(.5, 0.), 2);\n    addplane(4, vec3(.5, .6, 0.), vec3(.5, .4, 0.), vec3(.5, .4, .2), vec3(.5, .6, .2), .25, vec2(.75, 0.), 3);\n    \n    //addbox(4, vec3(.5, .7, 0.), vec3(.7, .9, .2), .1, vec2(0., .5), 2);\n}", "buffer_b_code": "// raytrace and composite final colors\n\nvec3 rotation = vec3(0.);\nvec3 rotate(vec3 p)\n{\n    mat3 yaw = mat3(\n        cos(rotation.x), -sin(rotation.x), 0.,\n        sin(rotation.x),  cos(rotation.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(rotation.y), -sin(rotation.y),\n        0., sin(rotation.y),  cos(rotation.y)\n    );\n    mat3 roll = mat3(\n         cos(rotation.z), 0., sin(rotation.z),\n               0., 1.,       0.,\n        -sin(rotation.z), 0., cos(rotation.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 lm = texture(iChannel0, uv).rgb;\n    \n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float ts = iTime*.3;\n    \n    vec3 ro = vec3(sin(ts)*.2-.7, -2.2, 1.3);\n    rotation = vec3(-0.3-cos(ts)*.1, -.6, 0.);\n    vec2 randr = vec2(frand(float(iFrame+3)), frand(float(iFrame+5)))/iResolution.xy/3.;\n    vec3 rd = rotate(normalize(vec3(uv.x+randr.x, 1., uv.y+randr.y)));\n    \n    bool validfragment = false;\n    \n    vec3 color = vec3(0.);\n    \n    buildscene();\n    \n    int hit = -1;\n    float hitdist;\n    vec3 hitbary;\n    for (int i = 0; i < triangleLength(); i++) {\n        Triangle t = unpackTriangle(i);\n        \n        vec3 center = (((t.PointB - t.PointA)/2. + t.PointA) - t.PointC)/2. + t.PointC;\n        vec3 normal = normalize((t.NormalA + t.NormalB + t.NormalC) * 0.5); // average normal of triangle\n        \n        // check if we hit plane\n        float denom = dot(normal, rd);\n        if (!(abs(denom) > 0.0001f)) continue;\n        \n        float testt = dot((center - ro), normal) / denom;\n        if (testt < 0.) continue;\n        \n        vec3 b = bary3d(t.PointA, t.PointB, t.PointC, ro + testt*rd);\n        if (!baryinside(b))\n            continue;\n        \n        if (hit >= 0) {\n            if (hitdist < testt)\n                continue;\n            hit = i;\n            hitdist = testt;\n            hitbary = b;\n        } else {\n            hit = i;\n            hitdist = testt; // distance from wp. hitpos = wp + hitdist*raydir\n            hitbary = b;\n        }\n    }\n    \n    if (hit < 0)\n        color = vec3(0.);\n    else {\n        Triangle t = unpackTriangle(hit);\n        vec3 hitpos = ro + hitdist*rd;\n        vec2 luv = t.LUVA*hitbary.x + t.LUVB*hitbary.y + t.LUVC*hitbary.z;\n        color = texture(iChannel0, luv).rgb;\n    }\n\n    fragColor = mix(texture(iChannel1, ouv), vec4(color, hitdist), 0.4);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec3 pow3(vec3 p, float e)\n{\n    return vec3(pow(p.x, e), pow(p.y, e), pow(p.z, e));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = pow3(texture(iChannel0, uv).rgb, 1.5);\n\n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(vec3(fract(texture(iChannel0, uv).a)), 1.);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mddcRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 374]], "test": "untested"}
{"id": "msjfWG", "name": "Rotate Sphere by Mouse", "author": "o0CHT0o", "description": "Rotate the sphere by mat3", "tags": ["3d", "mouse", "rotate"], "likes": 1, "viewed": 187, "published": 3, "date": "1696477911", "time_retrieved": "2024-07-30T17:30:29.962631", "image_code": "vec4 textxy(vec2 uv){\n    vec3 xyz = GETR1*vu2xyz(uv);\n    return TEXT0(vec2(atan(xyz.y,xyz.x)/pi/2.+.75,asin(xyz.z)/pi+.5));\n}\n\nvoid mainImage( out vec4 Clr, in vec2 Crd ){\n    // Normalized pixel coordinates\n    float sc = min(iResolution.x, iResolution.y);\n    vec2 uv = (Crd*2.-iResolution.xy)/sc;\n\n    // Output to screen\n    Clr = (smoothstep(1., 1.-3./sc, length(uv))/2.+.5) * textxy(uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 Clr, in vec2 Crd ){\n    vec2 uv = Crd/iResolution.xy-0.5;\n    Clr = vec4(cos(uv.x*pi*2.)*cos(uv.y*pi),\n               sin(uv.x*pi*2.)*cos(uv.y*pi),\n               sin(uv.y*pi),\n               1.0)/2.+.5;\n}", "buffer_a_inputs": [], "common_code": "#define TEXT0(x) texture(iChannel0, vec2(x))\n\n\n#define R1X int(iChannelResolution[1].x)\n#define XY2ID(X) (int(X.y) * R1X + int(X.x))\n#define ID2XY(I) ivec2(I - I / R1X * R1X, I / R1X)\n#define GET1(I) texelFetch(iChannel1, ID2XY(I), 0)\n#define GETR1 mat3(GET1(1).xyz, GET1(2).xyz, GET1(3).xyz)\n\nconst float pi = 4. * atan(1.);\n\nvec3 vu2xyz(vec2 uv){\n    float l = dot(uv,uv);\n    return l>1.?vec3(uv/l,-sqrt(1. - 1./l)):vec3(uv,sqrt(1. - l));\n}", "buffer_b_code": "// reference https://www.shadertoy.com/view/Mss3zH\n#define P_NUM 4\n#define TXTF1(x) texelFetch(iChannel1, ivec2(x), 0)\n\nmat3 rotate(vec3 v1, vec3 v2){\n    if(v1==v2) return mat3(1.);\n    float c = dot(v1, v2);\n    vec3 A = cross(v1, v2);\n    mat3 B = mat3(   0, -A.z,  A.y,\n                   A.z,    0, -A.x,\n                  -A.y,  A.x,    0);\n    A = normalize(A);\n    return mat3(c) + (1.-c) * outerProduct(A, A) + B;\n}\n\nvoid mainImage( out vec4 Clr, in vec2 Crd ){\n\n    int id = XY2ID(Crd);\n    if( id>=P_NUM ) {Clr=vec4(0); return;}\n    \n    if( iFrame==0 && id!=0){\n        Clr = vec4(mat3(1)[id-1],1);\n        return;\n    }\n    \n    vec4 m = iMouse;\n    if( m.z<0.0 ) {Clr = TXTF1(Crd); return;}\n    \n    float sc = min(iResolution.x, iResolution.y);\n    vec3 xyz = vu2xyz((m.xy*2.-iResolution.xy)/sc);\n    if( id==0 ){    \n        Clr = vec4(xyz,1);\n        return;\n    }\n    if( m.w>0.0 ) {Clr = TXTF1(Crd); return;}\n    mat3 R = GETR1*rotate(GET1(0).xyz, xyz);\n    Clr = vec4(R[id-1],1);\n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msjfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 127], [129, 129, 173, 209, 397]], "test": "untested"}
{"id": "csVcRd", "name": "Smooth Binary Counter", "author": "Retr0id", "description": "Enough said. I have another variation planned where each layer forks into branches of a binary tree.", "tags": ["counter"], "likes": 3, "viewed": 114, "published": 3, "date": "1696470673", "time_retrieved": "2024-07-30T17:30:30.785431", "image_code": "\nfloat factor = 2.0;\nfloat segments = 16.0;\nfloat zoom = 4.0;\nfloat smoothfactor = .01;\nfloat tau = 3.14159265359*2.0;\n\nvec4 test(vec2 uv) {\n    return vec4(uv.x, 0.0, uv.y, 1.0);\n}\n\nvec4 basic(vec2 uv) {\n    return vec4(vec3(pow(smoothstep(0.0, 1.0, sin(-uv.y*tau)*(smoothfactor*iResolution.y)+0.5), 1.0/2.2)), 1.0);\n}\n\nvec4 trees(vec2 uv) {\n    return vec4(vec3(uv.y>0.5), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord/iResolution.xy;\n    vec2 uv = uv0;\n    //uv = vec2(1.0-uv.y, uv.x);\n\n    float t = iTime / pow(factor, segments-5.0);\n\n    uv.x = uv.x * segments; // repeat n times\n    uv.y -= 0.5; // vertical centering\n    uv.y *= pow(factor, mod(-uv.x, 1.0)) * zoom; // exponential scaling\n    uv.y += t * pow(factor, floor(uv.x)); // make each wheel faster than the previous\n   \n    // Output to screen\n    //fragColor = test(mod(uv, 1.0));\n    fragColor = basic(mod(uv, 1.0));\n    fragColor = abs(uv0.y-0.5) <0.004 ? vec4(1.0, 0.0, 0.0, 1.0) : fragColor; // red line\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 140, 140, 181], [183, 183, 204, 204, 319], [321, 321, 342, 342, 382], [384, 384, 441, 491, 1073]], "test": "untested"}
{"id": "dsGyzd", "name": "spqr domain trick 2", "author": "spqr", "description": "another application of the domain trick, using a size of 0 to make empty domains", "tags": ["a"], "likes": 6, "viewed": 172, "published": 3, "date": "1696457063", "time_retrieved": "2024-07-30T17:30:31.591277", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    p = abs(p) - s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat map (vec3 p){\n\n\n   // geo\n   float tt = iTime;\n  \n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n   float f2 = sin(iTime) * .5+ .5;\n   float f3 = step(f1,f2);\n   \n   float box = box(p, vec3(.3) *f3);\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .01, box);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float tt = iTime * 2.;\n\n  // nav\n  \n  vec3 s,t;\n  \n  s = lattice(tt*.1) * 10.;\n  t = lattice(tt *.1 + 2.) * 18.;\n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z < 500.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 1000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light =normalize(vec3(0,1,-1));\n  float fresnel = pow(1.-dot(n, -r),1.)* .9 + .1;\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.);\n  vec3 hue = vec3(1.);\n  vec3 col = hue  *  (fresnel + spec);\n\n  if ( ! hit ) {\n      col = vec3(.2,.2,.5);\n  }\n\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsGyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [952, 952, 979, 979, 1061], [1063, 1063, 1091, 1091, 1147], [1148, 1148, 1167, 1179, 1459], [1461, 1461, 1480, 1480, 1600], [1604, 1604, 1661, 1661, 2662]], "test": "untested"}
{"id": "DsGyRd", "name": "Electra", "author": "Lewie4", "description": "Animated Electric Square logo", "tags": ["sdf", "logo", "loop"], "likes": 13, "viewed": 181, "published": 3, "date": "1696455918", "time_retrieved": "2024-07-30T17:30:32.700312", "image_code": "#define PI 3.14159265359\n\nvec2 centerUV(vec2 UV)\n{\n    return (UV - .5) * 2.;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdCircle(vec2 uv, float r)\n{\n    return (length(uv) - r);\n}\n\nfloat sdBox(vec2 uv, vec2 b)\n{\n    vec2 d = abs(uv)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor;       \n    vec2 UV =(fragCoord+fragCoord-iResolution.xy)/iResolution.y;\n    \n    float ct = smoothstep(0.,0.7,sin(iTime + 2.)+.7);\n    \n    // Outer Glow\n    float dist = (pow(1.-length(UV)/2.,2.)) * ct;\n    fragColor = vec4(dist);\n    \n    // Outer Box    \n    float size = 5.5 * ct;\n    //float size = 5.5;\n    float outer = sdBox(UV,vec2(1.,1.))*size;\n    outer = mod(2., outer+.01);\n    fragColor = max(fragColor,vec4(1.-step(-1.,outer)));\n\n    // Mid Angled Box\n    vec2 rUV = rotate(PI*2.*ct + PI/4.) * UV;\n    //vec2 rUV = rotate(PI/4.)*UV;\n    float p = sdBox(rUV, vec2(.84));\n    float mid = distance(p+.2, .0);\n    mid = step(.03,fract(mid-.03));\n    mid = 1.-mid;\n    fragColor = vec4(mix(mid, fragColor.x, step(.0,p+.14)));\n    \n    // Inner details\n    vec2 tUV = UV * ct;    \n    float inner = smoothstep(0.675,0.68,length(tUV));\n    inner = (1. - inner) * smoothstep(0.645,0.65,length(tUV));\n    inner = max(inner, 1.-smoothstep(0.445,0.45,length(tUV)));\n    inner = min(inner, smoothstep(0.245,0.25,length(tUV)));    \n    //inner = mix(inner,fragColor.x,step(0.,p+.26));  // Clip inside of angled box\n    \n    // Electra\n    float elec = texture(iChannel0,((fragCoord/iResolution.xy) - vec2(0.0833, -0.01))*1.2).x;\n    \n    // Smoothing Electra outline\n    float mask = sdBox(UV+vec2(0.,.3), vec2(.127,.2));\n    float ring = 1.-smoothstep(0.415,0.42,length(UV));\n    ring = max(ring, 1.-smoothstep(0.315,0.62,length(UV)));   // Inner Circle Glow\n    ring *= smoothstep(0.395,0.40,length(UV));\n    ring *= mix(0., ring, step(0.02, mask));\n    \n    elec = max(elec, ring);    \n\n    inner = mix(elec, inner,smoothstep(.352,.347,(1.-length(UV))*ct));     \n    \n    fragColor = vec4(mix(inner,fragColor.x,step(.0,p+.26)));\n\n    // Colour\n    vec3 col = vec3(1.);\n    \n    fragColor = fragColor * vec4(col, 1.) ;\n    \n    //fragColor = vec4(inner);\n    //fragColor = vec4(fract(((fragCoord/iResolution.xy) - .14)*1.4), 0.,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const vec3 positions[734] = vec3[734](vec3(0.44049276169265045, -0.5167037861915365, 0), vec3(0.7171231208240536, -0.5722960746102446, 0), vec3(0.8350903483435412, -0.6108387562639197, 0), vec3(0.8814368301085747, -0.6407533233574607, 0), vec3(0.8808637249443206, -0.6608674658964366, 0), vec3(0.8086546492204899, -0.6886679600501111, 0), vec3(0.6089922048997772, -0.7655380011135857, 0), vec3(0.2818763919821826, -0.8914775890868596, 0), vec3(0.08221394766146993, -0.9683476301503338, 0), vec3(0.010004871937639197, -0.9961481243040087, 0), vec3(-0.010004871937639197, -0.9961481243040087, 0), vec3(-0.08221394766146993, -0.9683476301503338, 0), vec3(-0.2818763919821826, -0.8914775890868596, 0), vec3(-0.6089922048997772, -0.7655380011135857, 0), vec3(-0.8086546492204899, -0.6886679600501111, 0), vec3(-0.8808637249443206, -0.6608674658964366, 0), vec3(-0.8814612985453786, -0.6407533233574607, 0), vec3(-0.8352812021506124, -0.6108387562639197, 0), vec3(-0.7177103633073496, -0.5722960746102446, 0), vec3(-0.44143234966592426, -0.5167037861915365, 0), vec3(-0.3080456570155902, -0.47313474387527843, 0), vec3(-0.24902561247216035, -0.42552895322939843, 0), vec3(-0.23127783964365248, -0.35798301781737174, 0), vec3(-0.2297466592427616, -0.18530762806236067, 0), vec3(-0.2286330734966592, -0.11696130289532292, 0), vec3(-0.22376113585746105, -0.11118457683741623, 0), vec3(-0.2072661469933185, -0.11191536748329622, 0), vec3(-0.1490812917594655, -0.12416481069042296, 0), vec3(-0.13550946547884185, -0.12694877505567925, 0), vec3(-0.133978285077951, -0.12694877505567925, 0), vec3(-0.13258630289532292, -0.12660077951002213, 0), vec3(-0.12799276169265042, -0.1250695991091313, 0), vec3(-0.13756263919821837, -0.12075445434298415, 0), vec3(-0.19553869710467706, -0.09277561247216015, 0), vec3(-0.24161330734966593, -0.052408129175946616, 0), vec3(-0.2766216592427617, 0.0020183741648107656, 0), vec3(-0.2966314031180401, 0.05470489977728299, 0), vec3(-0.30665367483296224, 0.09813474387527854, 0), vec3(-0.31201280623608013, 0.13592706013363043, 0), vec3(-0.3227310690423162, 0.2048301781737195, 0), vec3(-0.31945991091314035, 0.2182628062360803, 0), vec3(-0.30721046770601335, 0.21380846325167036, 0), vec3(-0.2932210467706013, 0.20994571269487772, 0), vec3(-0.27498608017817366, 0.20750974387527854, 0), vec3(-0.2636414253897549, 0.20712694877505577, 0), vec3(-0.2575167037861914, 0.20712694877505577, 0), vec3(-0.25041759465478836, 0.20740534521158127, 0), vec3(-0.23816815144766146, 0.20963251670378624, 0), vec3(-0.2287374721603562, 0.21196408685968848, 0), vec3(-0.22630150334075713, 0.21440005567928755, 0), vec3(-0.22731069042316246, 0.2179844097995549, 0), vec3(-0.2284242761692649, 0.22021158129175977, 0), vec3(-0.2347925946547883, 0.22421353006681555, 0), vec3(-0.24725083518930951, 0.23333101336302908, 0), vec3(-0.2710189309576837, 0.24993040089086882, 0), vec3(-0.2977449888641425, 0.28152839643652594, 0), vec3(-0.3104816258351892, 0.307976057906459, 0), vec3(-0.32426224944320703, 0.3401308463251672, 0), vec3(-0.3254454342984409, 0.3563474387527842, 0), vec3(-0.32321826280623595, 0.3741648106904234, 0), vec3(-0.2965618040089086, 0.39159938752783985, 0), vec3(-0.2546631403118039, 0.41533268374164833, 0), vec3(-0.23482739420935397, 0.43081848552338553, 0), vec3(-0.2270322939866368, 0.4363864142538978, 0), vec3(-0.22059437639198204, 0.43081848552338553, 0), vec3(-0.21300807349665915, 0.41745545657015615, 0), vec3(-0.20608296213808452, 0.4123747216035637, 0), vec3(-0.20148942093541194, 0.41390590200445465, 0), vec3(-0.20079342984409795, 0.41460189309576867, 0), vec3(-0.2023246102449888, 0.4161330734966596, 0), vec3(-0.2085189309576837, 0.42093541202672635, 0), vec3(-0.21520044543429834, 0.43402004454343013, 0), vec3(-0.20931932071269488, 0.4442859131403122, 0), vec3(-0.19505150334075727, 0.45006263919821865, 0), vec3(-0.19129315144766135, 0.44971464365256153, 0), vec3(-0.19553869710467706, 0.4424067371937642, 0), vec3(-0.19484270601336284, 0.4338460467706017, 0), vec3(-0.18753479955456553, 0.42653814031180437, 0), vec3(-0.18081848552338511, 0.42556375278396463, 0), vec3(-0.1713530066815143, 0.43008769487750587, 0), vec3(-0.1687430400890867, 0.43586442093541233, 0), vec3(-0.17298858574610226, 0.4337068485523389, 0), vec3(-0.17921770601336282, 0.43506403118040105, 0), vec3(-0.18408964365256106, 0.4399359688195993, 0), vec3(-0.1844724387527837, 0.4461650890868599, 0), vec3(-0.18203646993318465, 0.45041063474387555, 0), vec3(-0.17932210467705983, 0.45246380846325185, 0), vec3(-0.17382377505567895, 0.4539949888641428, 0), vec3(-0.170796213808463, 0.4543429844097998, 0), vec3(-0.16773385300668117, 0.4543429844097998, 0), vec3(-0.16355790645879711, 0.454203786191537, 0), vec3(-0.15576280623607994, 0.4530902004454346, 0), vec3(-0.15144766146993283, 0.44988864142538987, 0), vec3(-0.15144766146993283, 0.44543429844098026, 0), vec3(-0.15186525612472115, 0.4368040089086862, 0), vec3(-0.15520601336302864, 0.4256681514476617, 0), vec3(-0.15847717149220447, 0.42058741648106923, 0), vec3(-0.16000835189309534, 0.4190562360801784, 0), vec3(-0.15931236080178135, 0.4187082405345214, 0), vec3(-0.15471881959910874, 0.4187082405345214, 0), vec3(-0.14946408685968784, 0.4241021714922051, 0), vec3(-0.14521854120267236, 0.43656041202672624, 0), vec3(-0.14476614699331816, 0.44529510022271734, 0), vec3(-0.14476614699331816, 0.44863585746102475, 0), vec3(-0.13265590200445396, 0.44585189309576856, 0), vec3(-0.11595211581291717, 0.4361080178173722, 0), vec3(-0.1094097995545653, 0.43207126948775076, 0), vec3(-0.10718262806236034, 0.43207126948775076, 0), vec3(-0.10394626948775017, 0.4324888641425392, 0), vec3(-0.09970072383073468, 0.4358296213808466, 0), vec3(-0.09709075723830707, 0.4404231625835192, 0), vec3(-0.09862193763919792, 0.4437639198218265, 0), vec3(-0.12280762806236047, 0.45806653674833, 0), vec3(-0.16380150334075702, 0.47080317371937663, 0), vec3(-0.21920239420935383, 0.46652282850779536, 0), vec3(-0.26813056792873025, 0.440214365256125, 0), vec3(-0.2828855790645876, 0.4291481069042318, 0), vec3(-0.2968749999999997, 0.4258073496659245, 0), vec3(-0.31166481069042284, 0.4257377505567931, 0), vec3(-0.32140868596881933, 0.42726893095768403, 0), vec3(-0.32335746102449875, 0.4476614699331851, 0), vec3(-0.32001670378619135, 0.4877505567928734, 0), vec3(-0.31514476614699294, 0.5079342984409803, 0), vec3(-0.3129175946547882, 0.5090478841870827, 0), vec3(-0.30794125835189284, 0.517051781737194, 0), vec3(-0.2826767817371935, 0.5469793986636975, 0), vec3(-0.25226197104677034, 0.564518374164811, 0), vec3(-0.223378340757238, 0.5696687082405347, 0), vec3(-0.20183741648106884, 0.5700167037861918, 0), vec3(-0.18847438752783943, 0.5689031180400894, 0), vec3(-0.17016982182628035, 0.564622772828508, 0), vec3(-0.1218680400890866, 0.5588460467706016, 0), vec3(-0.08651169265033393, 0.5567928730512253, 0), vec3(-0.08498051224944296, 0.5567928730512253, 0), vec3(-0.07683741648106879, 0.5583588530066818, 0), vec3(-0.06709354120267232, 0.5690075167037865, 0), vec3(-0.06716314031180384, 0.5778814031180404, 0), vec3(-0.06869432071269471, 0.5824749443207129, 0), vec3(-0.07147828507795087, 0.5884256681514479, 0), vec3(-0.07969097995545639, 0.5957335746102452, 0), vec3(-0.09893513363028955, 0.5972647550111361, 0), vec3(-0.12503479955456573, 0.5997007238307352, 0), vec3(-0.15190005567928713, 0.6033198775055681, 0), vec3(-0.18287165924276153, 0.6072870267260582, 0), vec3(-0.20726614699331838, 0.6078786191536751, 0), vec3(-0.22174276169265023, 0.6067650334075727, 0), vec3(-0.24693763919821818, 0.6021714922049, 0), vec3(-0.27700445434298426, 0.5857461024498889, 0), vec3(-0.2658685968819599, 0.6085746102449892, 0), vec3(-0.1918151447661469, 0.6648106904231628, 0), vec3(-0.11080178173719367, 0.6905275612472164, 0), vec3(-0.05790645879732725, 0.6965826837416483, 0), vec3(-0.0268652561247215, 0.6971046770601339, 0), vec3(-0.010161469933184812, 0.6971046770601339, 0), vec3(-0.002227171492204753, 0.6971046770601339, 0), vec3(-0.0018791759465477576, 0.6971046770601339, 0), vec3(-0.00034799554565689687, 0.6971046770601339, 0), vec3(1.9781256563477175e-16, 0.6971046770601339, 0), vec3(0.005846325167038083, 0.6971046770601339, 0), vec3(0.02255011135857487, 0.6971046770601339, 0), vec3(0.05661887527839657, 0.6965826837416483, 0), vec3(0.10888780623608044, 0.6905275612472164, 0), vec3(0.18990116926503356, 0.6648106904231628, 0), vec3(0.26458101336302925, 0.6085746102449892, 0), vec3(0.2747772828507796, 0.5857461024498889, 0), vec3(0.24471046770601332, 0.6021714922049001, 0), vec3(0.21951559020044556, 0.6067650334075727, 0), vec3(0.20503897550111344, 0.6078786191536751, 0), vec3(0.18189727171492237, 0.6072870267260582, 0), vec3(0.15092566815144787, 0.6033198775055681, 0), vec3(0.12284242761692674, 0.5997007238307352, 0), vec3(0.09764755011135877, 0.5972647550111361, 0), vec3(0.07969097995545689, 0.5957335746102452, 0), vec3(0.07147828507795127, 0.5884256681514479, 0), vec3(0.0686943207126951, 0.5824749443207129, 0), vec3(0.06716314031180425, 0.5778814031180404, 0), vec3(0.06591035634743894, 0.5731486636971048, 0), vec3(0.0674415367483298, 0.5649359688195993, 0), vec3(0.07238307349665948, 0.559611636971047, 0), vec3(0.07906458797327423, 0.5571756681514479, 0), vec3(0.0831013363028955, 0.5567928730512253, 0), vec3(0.08616369710467742, 0.5567928730512253, 0), vec3(0.12152004454343009, 0.5588460467706016, 0), vec3(0.16829064587973297, 0.564622772828508, 0), vec3(0.18617761692650373, 0.5692163140311807, 0), vec3(0.2010718262806239, 0.5701211024498889, 0), vec3(0.2233783407572387, 0.5696687082405347, 0), vec3(0.252261971046771, 0.564518374164811, 0), vec3(0.2823287861915371, 0.5466662026726061, 0), vec3(0.30606208240534555, 0.5161121937639201, 0), vec3(0.31069042316258383, 0.5090478841870827, 0), vec3(0.31291759465478863, 0.5079342984409803, 0), vec3(0.3177895322939868, 0.4877505567928734, 0), vec3(0.3211302895322943, 0.4476614699331851, 0), vec3(0.31918151447661497, 0.42726893095768403, 0), vec3(0.3094376391982185, 0.4257377505567931, 0), vec3(0.2955874164810696, 0.4258073496659245, 0), vec3(0.2809716035634748, 0.4291481069042318, 0), vec3(0.2662165924276173, 0.440214365256125, 0), vec3(0.21791481069042337, 0.46652282850779536, 0), vec3(0.16251391982182664, 0.47080317371937663, 0), vec3(0.12089365256124764, 0.45806653674833, 0), vec3(0.0967079621380849, 0.4437639198218265, 0), vec3(0.09580317371937669, 0.4404231625835192, 0), vec3(0.09747355233853043, 0.4358296213808466, 0), vec3(0.10171909799554611, 0.4324888641425392, 0), vec3(0.10579064587973305, 0.43207126948775076, 0), vec3(0.1080178173719379, 0.43207126948775076, 0), vec3(0.11375974387527858, 0.4361080178173722, 0), vec3(0.13136831848552377, 0.44585189309576856, 0), vec3(0.143791759465479, 0.44863585746102475, 0), vec3(0.14267817371937677, 0.44529510022271734, 0), vec3(0.14309576837416502, 0.4366648106904233, 0), vec3(0.14755011135857493, 0.42441536748329645, 0), vec3(0.1524916481069044, 0.4187082405345214, 0), vec3(0.157085189309577, 0.4187082405345214, 0), vec3(0.15778118040089098, 0.4190562360801784, 0), vec3(0.1562500000000001, 0.42058741648106923, 0), vec3(0.15297884187082417, 0.4256681514476617, 0), vec3(0.1496380846325169, 0.4368040089086862, 0), vec3(0.14935968819599132, 0.44543429844098026, 0), vec3(0.15047327394209375, 0.44988864142538987, 0), vec3(0.15492761692650348, 0.4530902004454346, 0), vec3(0.16272271714922065, 0.454203786191537, 0), vec3(0.16738585746102477, 0.4543429844097998, 0), vec3(0.16891703786191564, 0.4543429844097998, 0), vec3(0.17253619153674865, 0.4539949888641428, 0), vec3(0.177408129175947, 0.45246380846325185, 0), vec3(0.18012249443207162, 0.4507238307349668, 0), vec3(0.18234966592427668, 0.44626948775055697, 0), vec3(0.18144487750556826, 0.4393443763919824, 0), vec3(0.17323218262806264, 0.4341244432071272, 0), vec3(0.16818624721603598, 0.4319668708240536, 0), vec3(0.17549415367483337, 0.42619014476614714, 0), vec3(0.18624721603563507, 0.42653814031180426, 0), vec3(0.19292873051224982, 0.43384604677060157, 0), vec3(0.19334632516703826, 0.4420587416481071, 0), vec3(0.19000556792873077, 0.44783546770601357, 0), vec3(0.1937639198218269, 0.44849665924276194, 0), vec3(0.207126948775056, 0.4440423162583521, 0), vec3(0.2129732739420941, 0.4330456570155905, 0), vec3(0.20629175946547915, 0.4196826280623611, 0), vec3(0.20114142538975543, 0.41390590200445465, 0), vec3(0.20420378619153737, 0.4123747216035637, 0), vec3(0.21109409799554632, 0.41745545657015615, 0), vec3(0.21930679287305174, 0.43081848552338553, 0), vec3(0.22480512249443274, 0.4363864142538978, 0), vec3(0.23260022271714992, 0.43081848552338553, 0), vec3(0.2527491648106912, 0.41533268374164833, 0), vec3(0.29527422048997837, 0.39159938752783985, 0), vec3(0.3209910913140316, 0.3740256124721606, 0), vec3(0.32321826280623667, 0.35509465478841906, 0), vec3(0.3220350779510029, 0.3382516703786195, 0), vec3(0.30825445434298515, 0.3076280623608021, 0), vec3(0.29649220489977784, 0.2814935968819602, 0), vec3(0.27004454342984474, 0.24899081291759473, 0), vec3(0.24596325167037922, 0.2311386414253901, 0), vec3(0.2326002227171501, 0.22292594654788445, 0), vec3(0.22619710467706072, 0.21937639198218295, 0), vec3(0.2250835189309581, 0.21714922048997787, 0), vec3(0.22532711581291817, 0.21436525612472168, 0), vec3(0.22776308463251724, 0.2110244988864144, 0), vec3(0.23594097995545718, 0.20837973273942112, 0), vec3(0.24819042316258427, 0.2072661469933187, 0), vec3(0.2552895322939875, 0.20712694877505589, 0), vec3(0.2614142538975509, 0.20712694877505589, 0), vec3(0.2717149220489985, 0.2074053452115816, 0), vec3(0.2895322939866377, 0.20963251670378635, 0), vec3(0.3076280623608025, 0.21359966592427637, 0), vec3(0.320991091314032, 0.21847160356347461, 0), vec3(0.32238307349665996, 0.20483017817371962, 0), vec3(0.3101336302895331, 0.13592706013363054, 0), vec3(0.30456570155902096, 0.0971603563474388, 0), vec3(0.29565701559020113, 0.05261692650334082, 0), vec3(0.27533407572383173, 0.0007655902004458648, 0), vec3(0.23942093541202775, -0.0533825167037858, 0), vec3(0.19365952115813007, -0.09277561247215993, 0), vec3(0.13721464365256225, -0.12075445434298415, 0), vec3(0.12764476614699433, -0.12506959910913107, 0), vec3(0.13070712694877604, -0.1266007795100219, 0), vec3(0.13175111358574712, -0.12694877505567903, 0), vec3(0.133282293986638, -0.12694877505567903, 0), vec3(0.14685412026726172, -0.12451280623607985, 0), vec3(0.20503897550111463, -0.11379454342984374, 0), vec3(0.22153396436525719, -0.11215896436525563, 0), vec3(0.22640590200445532, -0.11793569042316232, 0), vec3(0.22755428730512361, -0.18656041202672569, 0), vec3(0.22999025612472268, -0.35895740534521114, 0), vec3(0.24777282850779603, -0.42552895322939843, 0), vec3(0.306792873051226, -0.47313474387527776, 0), vec3(0.01900055679287318, 0.3081152561247217, 0), vec3(0.02721325167037879, 0.30018095768374153, 0), vec3(0.038001113585746156, 0.2933254454342984, 0), vec3(0.04468262806236091, 0.2908894766146993, 0), vec3(0.049728563474387796, 0.2908546770601338, 0), vec3(0.05397410913140328, 0.2923858574610244, 0), vec3(0.05637527839643688, 0.2968054008908686, 0), vec3(0.04941536748329637, 0.3074540645879733, 0), vec3(0.035112750556792985, 0.31695434298440983, 0), vec3(0.025995267260579356, 0.3202951002227171, 0), vec3(0.02115812917594669, 0.32057349665924284, 0), vec3(0.018930957683741836, 0.3194599109131404, 0), vec3(0.016564587973274106, 0.31646714922049, 0), vec3(0.016564587973274106, 0.3115952115812918, 0), vec3(-0.05620128062360784, 0.2926990534521158, 0), vec3(-0.05195573496659215, 0.29179426503340755, 0), vec3(-0.04690979955456556, 0.2918290645879732, 0), vec3(-0.04022828507795101, 0.29363864142538976, 0), vec3(-0.029440423162583346, 0.30018095768374153, 0), vec3(-0.02122772828507783, 0.3081152561247217, 0), vec3(-0.018791759465478564, 0.31288279510022277, 0), vec3(-0.018791759465478564, 0.31865952115812934, 0), vec3(-0.021158129175946293, 0.32071269487750564, 0), vec3(-0.023385300668151345, 0.32071269487750564, 0), vec3(-0.02822243875278391, 0.320329899777283, 0), vec3(-0.03733992204899754, 0.3178939309576838, 0), vec3(-0.05164253897550102, 0.3083936525612473, 0), vec3(-0.058602449888641335, 0.29684020044543447, 0), vec3(-0.0946547884187081, 0.092845211581292, 0), vec3(-0.07461024498886414, 0.08950445434298449, 0), vec3(-0.06236080178173715, 0.08908685968819618, 0), vec3(-0.05790645879732725, 0.08908685968819618, 0), vec3(-0.05567928730512249, 0.08908685968819618, 0), vec3(-0.05331291759465486, 0.08908685968819618, 0), vec3(-0.04774498886414243, 0.08908685968819618, 0), vec3(-0.029510022271714984, 0.0894348552338532, 0), vec3(-0.00946547884187072, 0.09096603563474404, 0), vec3(-0.003340757238307476, 0.09131403118040105, 0), vec3(-0.0011135857461024262, 0.09131403118040105, 0), vec3(0, 0.09131403118040105, 0), vec3(0.00013919821826267962, 0.09131403118040105, 0), vec3(0.0012527839643651057, 0.09131403118040105, 0), vec3(0.008212694877505615, 0.09096603563474404, 0), vec3(0.028535634743875236, 0.0894348552338532, 0), vec3(0.04677060133630269, 0.08908685968819618, 0), vec3(0.05122494432071259, 0.08908685968819618, 0), vec3(0.05345211581291764, 0.08908685968819618, 0), vec3(0.05567928730512249, 0.08908685968819618, 0), vec3(0.06013363028953239, 0.08908685968819618, 0), vec3(0.07321826280623595, 0.08950445434298449, 0), vec3(0.09326280623608021, 0.092845211581292, 0), vec3(0.11456013363028938, 0.09980512249443207, 0), vec3(0.13126391982182617, 0.10954899777282867, 0), vec3(0.13780623608017825, 0.11581291759465495, 0), vec3(0.1400334075723831, 0.12026726057906456, 0), vec3(0.14017260579064597, 0.12374721603563466, 0), vec3(0.13905902004454315, 0.12708797327394217, 0), vec3(0.1339782850779508, 0.13498747216035634, 0), vec3(0.12242483296213791, 0.15078646993318479, 0), vec3(0.09528118040089084, 0.18513363028953222, 0), vec3(0.06006403118040086, 0.21547884187082378, 0), vec3(0.04342984409799521, 0.2227171492204898, 0), vec3(0.04120267260579056, 0.2227171492204898, 0), vec3(0.040089086859687935, 0.22369153674832953, 0), vec3(0.040089086859687935, 0.22480512249443185, 0), vec3(0.038975501113585505, 0.22494432071269477, 0), vec3(0.03674832962138065, 0.22494432071269477, 0), vec3(0.035634743875278034, 0.22494432071269477, 0), vec3(0.03466035634743828, 0.22494432071269477, 0), vec3(0.03354677060133586, 0.22494432071269477, 0), vec3(0.03229398663697075, 0.22508351893095757, 0), vec3(0.030066815144765703, 0.22619710467706, 0), vec3(0.02672605790645862, 0.22717149220489963, 0), vec3(0.02227171492204872, 0.22717149220489963, 0), vec3(0.013780623608017548, 0.22678869710467686, 0), vec3(0.0037583518930953174, 0.22435272828507768, 0), vec3(-2.9671884845215765e-16, 0.2227171492204898, 0), vec3(-0.0009743875278400432, 0.2227171492204898, 0), vec3(-0.0020879732739423704, 0.2227171492204898, 0), vec3(-0.005045935412027082, 0.22435272828507768, 0), vec3(-0.01569459910913167, 0.22678869710467686, 0), vec3(-0.024498886414254066, 0.22717149220489963, 0), vec3(-0.02895322939866397, 0.22717149220489963, 0), vec3(-0.032293986636971445, 0.22619710467706, 0), vec3(-0.0345211581291762, 0.22508351893095757, 0), vec3(-0.0357739420935416, 0.22494432071269477, 0), vec3(-0.03688752783964393, 0.22494432071269477, 0), vec3(-0.03786191536748367, 0.22494432071269477, 0), vec3(-0.0389755011135861, 0.22494432071269477, 0), vec3(-0.04120267260579115, 0.22494432071269477, 0), vec3(-0.04231625835189358, 0.22480512249443185, 0), vec3(-0.04231625835189358, 0.22369153674832953, 0), vec3(-0.043429844097995905, 0.2227171492204898, 0), vec3(-0.04565701559020105, 0.2227171492204898, 0), vec3(-0.061351614699332424, 0.21547884187082378, 0), vec3(-0.09719515590200486, 0.18513363028953211, 0), vec3(-0.12465200445434355, 0.15078646993318479, 0), vec3(-0.13620545657015654, 0.13498747216035634, 0), vec3(-0.14128619153674898, 0.12708797327394183, 0), vec3(-0.14239977728285133, 0.12374721603563466, 0), vec3(-0.14226057906458855, 0.12026726057906456, 0), vec3(-0.1400334075723837, 0.11581291759465473, 0), vec3(-0.1334910913140318, 0.10954899777282856, 0), vec3(-0.11678730512249502, 0.09980512249443196, 0), vec3(-0.07234827394209341, 0.1404858017817373, 0), vec3(-0.06476197104677045, 0.14779370824053462, 0), vec3(-0.04889337416481053, 0.16126113585746105, 0), vec3(-0.01973134743875254, 0.17587694877505566, 0), vec3(0.01562500000000023, 0.17587694877505566, 0), vec3(0.04631820712694898, 0.16126113585746105, 0), vec3(0.05902004454342997, 0.15130846325167058, 0), vec3(0.061247216035635016, 0.15019487750556815, 0), vec3(0.06250000000000012, 0.14810690423162576, 0), vec3(0.06361358574610256, 0.145879732739421, 0), vec3(0.06570155902004492, 0.14379175946547895, 0), vec3(0.06792873051224978, 0.1426781737193762, 0), vec3(0.07001670378619214, 0.14142538975501118, 0), vec3(0.07113028953229457, 0.1391982182628061, 0), vec3(0.07252227171492255, 0.13676224944320692, 0), vec3(0.07252227171492255, 0.13495267260579058, 0), vec3(0.05606208240534565, 0.13690144766146983, 0), vec3(0.016460189309577294, 0.14177338530066796, 0), vec3(-0.00034799554565669906, 0.14253897550111339, 0), vec3(-0.0018791759465475596, 0.14253897550111339, 0), vec3(-0.018687360801781357, 0.14177338530066796, 0), vec3(-0.05828925389754981, 0.1369014476614696, 0), vec3(-0.07478424276169247, 0.13495267260579058, 0), vec3(-0.07568903118040068, 0.13676224944320692, 0), vec3(0.5107878619153675, 0.11090618040089095, 0), vec3(0.5142678173719377, 0.15621520044543435, 0), vec3(0.47410913140311806, 0.2149916481069043, 0), vec3(0.42873051224944314, 0.2872355233853007, 0), vec3(0.42779092427616905, 0.3519974944320712, 0), vec3(0.4350335815701559, 0.4861628271158128, 0), vec3(0.4081074262249441, 0.6101449401447661, 0), vec3(0.3729816258351891, 0.6903187639198218, 0), vec3(0.3341453229398661, 0.746624443207127, 0), vec3(0.25027839643652544, 0.8200515033407572, 0), vec3(0.14645392538975474, 0.867853041481069, 0), vec3(0.05496589643652547, 0.8860619084075724, 0), vec3(0.0018791759465477576, 0.888641425389755, 0), vec3(0.00034799554565689687, 0.888641425389755, 0), vec3(-0.05337816675946569, 0.8860619084075724, 0), vec3(-0.14520549136971073, 0.867853041481069, 0), vec3(-0.24836442093541222, 0.8200515033407572, 0), vec3(-0.3332057349665926, 0.746624443207127, 0), vec3(-0.37294682628062387, 0.6903187639198218, 0), vec3(-0.40737228563474404, 0.6101449401447662, 0), vec3(-0.43335015311804026, 0.48616282711581293, 0), vec3(-0.42559855233853017, 0.3519974944320713, 0), vec3(-0.4265033407572384, 0.2872355233853007, 0), vec3(-0.4718819599109133, 0.2149916481069043, 0), vec3(-0.5120406458797329, 0.15621520044543435, 0), vec3(-0.5085606904231628, 0.11090618040089095, 0), vec3(-0.49947800668151465, 0.0782641982182628, 0), vec3(-0.4822870267260581, 0.02404649220489985, 0), vec3(-0.4532293986636973, -0.017225779510022132, 0), vec3(-0.429008908685969, -0.061421213808463104, 0), vec3(-0.3989420935412028, -0.08511971046770594, 0), vec3(-0.383073496659243, -0.10335467706013346, 0), vec3(-0.3565214365256127, -0.15492761692650325, 0), vec3(-0.288383908685969, -0.2047605790645879, 0), vec3(-0.24721603563474412, -0.24084771714922026, 0), vec3(-0.24721603563474412, -0.3074540645879731, 0), vec3(-0.34107478424276194, -0.29628340757238303, 0), vec3(-0.5019618248886416, -0.1697522271714922, 0), vec3(-0.6188970281180403, -0.0014615812917593285, 0), vec3(-0.68206691954343, 0.19856625835189323, 0), vec3(-0.6868779579621384, 0.37786552582126953, 0), vec3(-0.6595342079621382, 0.5125028274638086, 0), vec3(-0.6074479746659245, 0.6363087677477728, 0), vec3(-0.5333336233296215, 0.7465167820851893, 0), vec3(-0.4399055192093543, 0.8403603058880846, 0), vec3(-0.32987802756124734, 0.9150727745684855, 0), vec3(-0.20596551364142557, 0.9678876235384187, 0), vec3(-0.07088234270601368, 0.9960382882099109, 0), vec3(0.07051531615395296, 0.9960382882099109, 0), vec3(0.20513848047744943, 0.9678876235384187, 0), vec3(0.3288911339434852, 0.9150727745684856, 0), vec3(0.43898061229816204, 0.8403603058880846, 0), vec3(0.5326142512875832, 0.7465167820851893, 0), vec3(0.6069993866578507, 0.6363087677477728, 0), vec3(0.6593433541550667, 0.5125028274638086, 0), vec3(0.6868534895253336, 0.37786552582126953, 0), vec3(0.6819755707126948, 0.19856625835189323, 0), vec3(0.6183097856347437, -0.0014615812917593285, 0), vec3(0.5009830874164808, -0.1697522271714922, 0), vec3(0.34043534242761647, -0.29628340757238303, 0), vec3(0.24592845211581257, -0.3074540645879733, 0), vec3(0.24502366369710435, -0.24084771714922049, 0), vec3(0.28744432071269455, -0.2038209910913138, 0), vec3(0.3564866369710464, -0.1546144209354119, 0), vec3(0.3830734966592423, -0.10429426503340733, 0), vec3(0.3989420935412022, -0.08543290645879709, 0), vec3(0.42772132516703754, -0.062360801781737196, 0), vec3(0.45103702672605755, -0.01753897550111372, 0), vec3(0.4813822383073494, 0.02404649220489985, 0), vec3(0.5003827951002223, 0.07826419821826303, 0), vec3(-0.3229398663697105, 0.41870824053452116, 0), vec3(-0.3229398663697105, 0.4231625835189309, 0), vec3(-0.31782433184855224, 0.421179008908686, 0), vec3(-0.302582126948775, 0.41693346325167036, 0), vec3(-0.29551781737193766, 0.4164810690423163, 0), vec3(-0.292455456570156, 0.4164810690423163, 0), vec3(-0.2988237750556793, 0.410565144766147, 0), vec3(-0.31462277282850776, 0.4020740534521158, 0), vec3(-0.3229398663697105, 0.4031180400890869, 0), vec3(-0.3229398663697105, 0.41202672605790647, 0), vec3(-0.3229398663697105, 0.4164810690423163, 0), vec3(0.30035495545657015, 0.41693346325167036, 0), vec3(0.3155971603563476, 0.421179008908686, 0), vec3(0.32071269487750564, 0.4231625835189309, 0), vec3(0.32071269487750564, 0.41870824053452116, 0), vec3(0.32071269487750564, 0.4164810690423163, 0), vec3(0.32071269487750564, 0.41202672605790647, 0), vec3(0.32071269487750564, 0.4031180400890869, 0), vec3(0.312395601336303, 0.4020740534521158, 0), vec3(0.29659660356347445, 0.410565144766147, 0), vec3(0.29064587973273975, 0.4164810690423163, 0), vec3(0.2928730512249444, 0.4164810690423163, 0), vec3(-0.8908685968819599, -0.6570155902004453, 0), vec3(-0.6904231625835191, 0.30734966592427626, 0), vec3(-0.4988864142538978, 0.09576837416481077, 0), vec3(-0.4966592427616928, 0.18262806236080187, 0), vec3(-0.45657015590200467, -0.00222717149220486, 0), vec3(-0.4142538975501115, 0.3095768374164811, 0), vec3(-0.40311804008908714, -0.0801781737193763, 0), vec3(-0.37861915367483306, 0.6792873051224944, 0), vec3(-0.3763919821826283, -0.11581291759465473, 0), vec3(-0.3429844097995546, -0.4944320712694874, 0), vec3(-0.32739420935412017, 0.34743875278396463, 0), vec3(-0.32516703786191536, 0.22048997772828516, 0), vec3(-0.3229398663697105, 0.3986636971046771, 0), vec3(-0.3229398663697105, 0.42538975501113585, 0), vec3(-0.3229398663697104, 0.38307349665924306, 0), vec3(-0.32293986636971017, 0.42761692650334104, 0), vec3(-0.31625835189309554, 0.5077951002227175, 0), vec3(-0.31180400890868576, 0.5100222717149223, 0), vec3(-0.309576837416481, 0.12026726057906467, 0), vec3(-0.30734966592427615, 0.3006681514476617, 0), vec3(-0.30512249443207096, 0.4253897550111361, 0), vec3(-0.3006681514476614, 0.2115812917594656, 0), vec3(-0.29621380846325185, 0.7839643652561247, 0), vec3(-0.2962138084632517, 0.4164810690423163, 0), vec3(-0.29175946547884185, 0.4164810690423163, 0), vec3(-0.28953229398663693, 0.03340757238307368, 0), vec3(-0.28953229398663693, 0.5746102449888644, 0), vec3(-0.27839643652561225, 0.43207126948775076, 0), vec3(-0.265033407572383, 0.20712694877505577, 0), vec3(-0.26503340757238275, 0.5590200445434301, 0), vec3(-0.25612472160356337, 0.20712694877505577, 0), vec3(-0.2538975501113585, 0.23830734966592448, 0), vec3(-0.24721603563474412, -0.3407572383073496, 0), vec3(-0.24721603563474412, -0.21380846325167013, 0), vec3(-0.23830734966592412, 0.42761692650334104, 0), vec3(-0.23162583518930957, -0.39420935412026714, 0), vec3(-0.2316258351893095, 0.2115812917594656, 0), vec3(-0.22939866369710463, 0.605790645879733, 0), vec3(-0.22939866369710463, 0.22048997772828538, 0), vec3(-0.22939866369710463, -0.12026726057906445, 0), vec3(-0.22717149220489968, 0.21603563474387544, 0), vec3(-0.2249443207126949, -0.07126948775055664, 0), vec3(-0.22271714922048988, 0.43875278396436546, 0), vec3(-0.22048997772828502, -0.10913140311804015, 0), vec3(-0.21603563474387522, 0.44097995545657054, 0), vec3(-0.20935412026726027, 0.5701559020044547, 0), vec3(-0.2071269487750556, 0.4120267260579067, 0), vec3(-0.2026726057906458, 0.41648106904231663, 0), vec3(-0.20044543429844086, 0.41425389755011166, 0), vec3(-0.20044543429844086, 0.6080178173719379, 0), vec3(-0.19599109131403114, 0.43875278396436557, 0), vec3(-0.18708240534521153, 0.45211581291759506, 0), vec3(-0.18485523385300648, 0.4432071269487753, 0), vec3(-0.18262806236080165, 0.4253897550111362, 0), vec3(-0.18262806236080154, 0.5679287305122497, 0), vec3(-0.18262806236080154, 0.472160356347439, 0), vec3(-0.1804008908685966, 0.45211581291759484, 0), vec3(-0.17594654788418687, 0.43429844097995574, 0), vec3(-0.17149220489977698, 0.4543429844097998, 0), vec3(-0.16703786191536726, 0.4365256124721606, 0), vec3(-0.16703786191536718, 0.4543429844097998, 0), vec3(-0.16035634743875232, 0.4187082405345214, 0), vec3(-0.15812917594654746, 0.42093541202672624, 0), vec3(-0.15367483296213777, 0.4187082405345214, 0), vec3(-0.15144766146993283, 0.4432071269487753, 0), vec3(-0.15144766146993283, 0.45211581291759484, 0), vec3(-0.14476614699331816, 0.44988864142539, 0), vec3(-0.14476614699331816, 0.4432071269487753, 0), vec3(-0.1425389755011142, 0.12249443207126942, 0), vec3(-0.14031180400890925, 0.1291759465478841, 0), vec3(-0.1380846325167043, 0.11358574610244987, 0), vec3(-0.1380846325167037, 0.6837416481069045, 0), vec3(-0.1380846325167037, 0.6013363028953231, 0), vec3(-0.13585746102449894, -0.12694877505567925, 0), vec3(-0.133630289532294, -0.12694877505567925, 0), vec3(-0.12694877505567934, -0.12472160356347417, 0), vec3(-0.11804008908686023, 0.1603563474387527, 0), vec3(-0.11135857461024469, 0.43207126948775076, 0), vec3(-0.10690423162583479, 0.43207126948775076, 0), vec3(-0.10467706013363082, 0.09576837416481077, 0), vec3(-0.10022271714922013, 0.44543429844098026, 0), vec3(-0.09799554565701528, 0.43875278396436546, 0), vec3(-0.08685968819599092, 0.5567928730512253, 0), vec3(-0.08463251670378616, 0.5968819599109134, 0), vec3(-0.08463251670378596, 0.5567928730512253, 0), vec3(-0.07572383073496655, 0.1380846325167039, 0), vec3(-0.07349665924276151, 0.13363028953229383, 0), vec3(-0.0690423162583518, 0.583518930957684, 0), vec3(-0.06681514476614685, 0.5768374164810692, 0), vec3(-0.0645879732739421, 0.08908685968819618, 0), vec3(-0.0601336302895322, 0.15144766146993327, 0), vec3(-0.05790645879732725, 0.293986636971047, 0), vec3(-0.04899777282850774, 0.2917594654788419, 0), vec3(-0.04677060133630338, 0.2227171492204898, 0), vec3(-0.04454342984409803, 0.08908685968819618, 0), vec3(-0.04231625835189358, 0.2227171492204898, 0), vec3(-0.04231625835189358, 0.22494432071269477, 0), vec3(-0.042316258351892885, 0.3162583518930959, 0), vec3(-0.03563474387527872, 0.22494432071269477, 0), vec3(-0.03563474387527823, 0.29621380846325174, 0), vec3(-0.03563474387527823, 0.6971046770601339, 0), vec3(-0.03118040089086892, 0.22717149220489963, 0), vec3(-0.02449888641425377, 0.32071269487750564, 0), vec3(-0.022271714922049313, 0.22717149220489963, 0), vec3(-0.020044543429843867, 0.32071269487750564, 0), vec3(-0.020044543429843867, 0.3095768374164811, 0), vec3(-0.004454342984409903, 0.09131403118040105, 0), vec3(-0.002227171492205248, 0.2227171492204898, 0), vec3(-0.002227171492204753, 0.17817371937639215, 0), vec3(-0.002227171492204654, 0.14253897550111339, 0), vec3(-2.9671884845215765e-16, 1, 0), vec3(-1.9781256563477175e-16, 0.888641425389755, 0), vec3(0, -1, 0), vec3(3.956251312695435e-16, 0.14253897550111339, 0), vec3(0.0022271714922048524, 0.888641425389755, 0), vec3(0.0022271714922048524, 0.09131403118040105, 0), vec3(0.017817371937639215, 0.3184855233853007, 0), vec3(0.017817371937639215, 0.3095768374164811, 0), vec3(0.02004454342984367, 0.22717149220489963, 0), vec3(0.022271714922049116, 0.32071269487750553, 0), vec3(0.028953229398663276, 0.22717149220489963, 0), vec3(0.03340757238307318, 0.22494432071269477, 0), vec3(0.033407572383073576, 0.29621380846325174, 0), vec3(0.033407572383073576, 0.6971046770601339, 0), vec3(0.040089086859687935, 0.22494432071269477, 0), vec3(0.040089086859687935, 0.2227171492204898, 0), vec3(0.04008908685968833, 0.31403118040089084, 0), vec3(0.044543429844097836, 0.2227171492204898, 0), vec3(0.04454342984409803, 0.08908685968819618, 0), vec3(0.046770601336303085, 0.2917594654788419, 0), vec3(0.05567928730512269, 0.29398663697104677, 0), vec3(0.057906458797327545, 0.15144766146993327, 0), vec3(0.06236080178173705, 0.08908685968819618, 0), vec3(0.062360801781737446, 0.1492204899777283, 0), vec3(0.06458797327394229, 0.14476614699331847, 0), vec3(0.06681514476614715, 0.5768374164810692, 0), vec3(0.069042316258352, 0.561247216035635, 0), vec3(0.069042316258352, 0.583518930957684, 0), vec3(0.0690423162583522, 0.1425389755011135, 0), vec3(0.07126948775055725, 0.13363028953229383, 0), vec3(0.07126948775055725, 0.13808463251670366, 0), vec3(0.08240534521158151, 0.5567928730512253, 0), vec3(0.08463251670378637, 0.5968819599109134, 0), vec3(0.08685968819599141, 0.5567928730512253, 0), vec3(0.09576837416481102, 0.43875278396436546, 0), vec3(0.09799554565701588, 0.44543429844098026, 0), vec3(0.10244988864142518, 0.09576837416481077, 0), vec3(0.10467706013363043, 0.43207126948775076, 0), vec3(0.10913140311804033, 0.43207126948775076, 0), vec3(0.11581291759465469, 0.1603563474387527, 0), vec3(0.12694877505568034, -0.12472160356347417, 0), vec3(0.13140311804009022, -0.12694877505567903, 0), vec3(0.13363028953229508, -0.12694877505567903, 0), vec3(0.13585746102449875, 0.11358574610244987, 0), vec3(0.13585746102449914, 0.6013363028953231, 0), vec3(0.13585746102449914, 0.6837416481069045, 0), vec3(0.1380846325167036, 0.1291759465478841, 0), vec3(0.14031180400890866, 0.12249443207126942, 0), vec3(0.1425389755011139, 0.4432071269487753, 0), vec3(0.14476614699331875, 0.44988864142539, 0), vec3(0.14922048997772847, 0.4432071269487753, 0), vec3(0.15144766146993352, 0.45211581291759484, 0), vec3(0.15144766146993352, 0.4187082405345214, 0), vec3(0.1559020044543432, 0.42093541202672624, 0), vec3(0.15812917594654807, 0.4187082405345214, 0), vec3(0.16703786191536787, 0.4365256124721606, 0), vec3(0.16703786191536787, 0.4543429844097998, 0), vec3(0.16926503340757273, 0.4543429844097998, 0), vec3(0.17817371937639234, 0.45211581291759484, 0), vec3(0.18040089086859717, 0.4253897550111361, 0), vec3(0.18040089086859717, 0.472160356347439, 0), vec3(0.18040089086859717, 0.5679287305122497, 0), vec3(0.18262806236080223, 0.4432071269487753, 0), vec3(0.18708240534521195, 0.44988864142539, 0), vec3(0.1937639198218267, 0.43875278396436546, 0), vec3(0.1982182628062362, 0.6080178173719379, 0), vec3(0.20044543429844144, 0.41425389755011166, 0), vec3(0.20489977728285136, 0.4120267260579067, 0), vec3(0.20935412026726086, 0.5701559020044547, 0), vec3(0.21380846325167097, 0.4409799554565704, 0), vec3(0.21826280623608124, -0.11135857461024457, 0), vec3(0.2204899777282857, 0.43875278396436546, 0), vec3(0.22271714922049096, -0.07126948775055664, 0), vec3(0.2249443207126956, 0.21603563474387544, 0), vec3(0.22717149220489988, 0.605790645879733, 0), vec3(0.22717149220490046, 0.22048997772828538, 0), vec3(0.22717149220490085, -0.12249443207126909, 0), vec3(0.22939866369710532, 0.20935412026726086, 0), vec3(0.23162583518931057, -0.3942093541202667, 0), vec3(0.23608017817372007, 0.42761692650334104, 0), vec3(0.24498886414253868, -0.21380846325167013, 0), vec3(0.24721603563474354, -0.3407572383073496, 0), vec3(0.2538975501113593, 0.20712694877505589, 0), vec3(0.2538975501113593, 0.23608017817371973, 0), vec3(0.2628062360801789, 0.20712694877505589, 0), vec3(0.26503340757238336, 0.5590200445434301, 0), vec3(0.28730512249443224, 0.5746102449888644, 0), vec3(0.27616926503340783, 0.43207126948775076, 0), vec3(0.2895322939866371, 0.4164810690423163, 0), vec3(0.28953229398663793, 0.03118040089086893, 0), vec3(0.2939866369710468, 0.4164810690423163, 0), vec3(0.2984409799554563, 0.7839643652561247, 0), vec3(0.2984409799554573, 0.21158129175946572, 0), vec3(0.30289532293986665, 0.4253897550111361, 0), vec3(0.30512249443207184, 0.3006681514476618, 0), vec3(0.3073496659242771, 0.1202672605790649, 0), vec3(0.3095768374164814, 0.5100222717149223, 0), vec3(0.3140311804008913, 0.5077951002227175, 0), vec3(0.32071269487750564, 0.3986636971046771, 0), vec3(0.32071269487750564, 0.42538975501113585, 0), vec3(0.3207126948775058, 0.42761692650334104, 0), vec3(0.32071269487750625, 0.38307349665924306, 0), vec3(0.32516703786191614, 0.22048997772828538, 0), vec3(0.3251670378619159, 0.3452115812917598, 0), vec3(0.34298440979955475, -0.4944320712694874, 0), vec3(0.37639198218262776, -0.11581291759465473, 0), vec3(0.3786191536748328, 0.6792873051224944, 0), vec3(0.4031180400890866, -0.0801781737193763, 0), vec3(0.4164810690423161, 0.3095768374164811, 0), vec3(0.45434298440979914, -0.00222717149220486, 0), vec3(0.49888641425389757, 0.18262806236080187, 0), vec3(0.501113585746102, 0.09576837416481077, 0), vec3(0.6904231625835187, 0.30734966592427626, 0), vec3(0.8908685968819599, -0.6570155902004453, 0));\nconst ivec3 triangles[730] = ivec3[730](ivec3(0, 1, 6), ivec3(0, 6, 7), ivec3(0, 7, 724), ivec3(1, 2, 5), ivec3(1, 5, 6), ivec3(2, 3, 4), ivec3(2, 4, 5), ivec3(3, 733, 4), ivec3(7, 8, 288), ivec3(7, 288, 289), ivec3(7, 289, 724), ivec3(8, 9, 11), ivec3(8, 11, 288), ivec3(9, 10, 11), ivec3(9, 622, 10), ivec3(11, 12, 21), ivec3(11, 21, 288), ivec3(12, 13, 19), ivec3(12, 19, 519), ivec3(12, 20, 21), ivec3(12, 519, 20), ivec3(13, 14, 18), ivec3(13, 18, 19), ivec3(14, 15, 17), ivec3(14, 17, 18), ivec3(15, 16, 17), ivec3(15, 510, 16), ivec3(21, 545, 288), ivec3(22, 23, 584), ivec3(22, 30, 31), ivec3(22, 31, 585), ivec3(22, 287, 545), ivec3(22, 584, 30), ivec3(22, 585, 287), ivec3(23, 26, 27), ivec3(23, 27, 583), ivec3(23, 28, 29), ivec3(23, 29, 584), ivec3(23, 549, 26), ivec3(23, 583, 28), ivec3(24, 25, 549), ivec3(25, 26, 549), ivec3(25, 553, 26), ivec3(32, 33, 318), ivec3(32, 318, 319), ivec3(32, 319, 585), ivec3(33, 393, 589), ivec3(33, 551, 393), ivec3(33, 589, 318), ivec3(34, 35, 392), ivec3(34, 392, 393), ivec3(34, 393, 551), ivec3(35, 535, 580), ivec3(35, 580, 392), ivec3(36, 37, 390), ivec3(36, 390, 391), ivec3(36, 391, 535), ivec3(37, 528, 578), ivec3(37, 578, 390), ivec3(38, 39, 42), ivec3(38, 42, 43), ivec3(38, 43, 538), ivec3(38, 44, 45), ivec3(38, 45, 540), ivec3(38, 46, 528), ivec3(38, 538, 44), ivec3(38, 540, 46), ivec3(39, 40, 41), ivec3(39, 41, 531), ivec3(39, 521, 40), ivec3(39, 531, 42), ivec3(46, 47, 528), ivec3(47, 48, 389), ivec3(47, 389, 578), ivec3(47, 546, 48), ivec3(47, 578, 528), ivec3(48, 49, 387), ivec3(48, 387, 579), ivec3(48, 388, 389), ivec3(48, 579, 388), ivec3(49, 50, 385), ivec3(49, 385, 586), ivec3(49, 386, 387), ivec3(49, 550, 50), ivec3(49, 586, 386), ivec3(50, 51, 385), ivec3(51, 52, 556), ivec3(51, 66, 67), ivec3(51, 67, 571), ivec3(51, 317, 601), ivec3(51, 548, 52), ivec3(51, 556, 66), ivec3(51, 571, 317), ivec3(51, 601, 385), ivec3(52, 53, 556), ivec3(53, 541, 556), ivec3(54, 55, 556), ivec3(54, 556, 541), ivec3(55, 529, 556), ivec3(56, 57, 60), ivec3(56, 60, 61), ivec3(56, 61, 556), ivec3(56, 556, 529), ivec3(57, 58, 60), ivec3(57, 520, 58), ivec3(58, 59, 60), ivec3(59, 524, 60), ivec3(61, 65, 556), ivec3(61, 544, 65), ivec3(62, 63, 64), ivec3(62, 64, 544), ivec3(63, 552, 64), ivec3(64, 65, 544), ivec3(67, 558, 571), ivec3(68, 69, 77), ivec3(68, 77, 558), ivec3(69, 557, 77), ivec3(70, 71, 76), ivec3(70, 76, 557), ivec3(71, 72, 560), ivec3(71, 554, 72), ivec3(71, 560, 76), ivec3(72, 73, 75), ivec3(72, 75, 560), ivec3(73, 74, 75), ivec3(73, 561, 74), ivec3(76, 77, 557), ivec3(77, 563, 558), ivec3(78, 79, 571), ivec3(78, 558, 563), ivec3(78, 571, 558), ivec3(79, 95, 572), ivec3(79, 96, 97), ivec3(79, 97, 571), ivec3(79, 569, 95), ivec3(79, 572, 96), ivec3(80, 81, 567), ivec3(80, 86, 87), ivec3(80, 87, 568), ivec3(80, 567, 86), ivec3(80, 568, 569), ivec3(82, 83, 84), ivec3(82, 84, 567), ivec3(83, 562, 84), ivec3(84, 85, 567), ivec3(85, 86, 567), ivec3(85, 566, 86), ivec3(88, 89, 569), ivec3(88, 569, 568), ivec3(89, 570, 569), ivec3(90, 91, 93), ivec3(90, 93, 569), ivec3(90, 569, 570), ivec3(91, 92, 93), ivec3(91, 575, 92), ivec3(93, 574, 569), ivec3(94, 95, 569), ivec3(94, 569, 574), ivec3(98, 99, 317), ivec3(98, 317, 571), ivec3(99, 573, 317), ivec3(100, 101, 105), ivec3(100, 105, 587), ivec3(100, 587, 573), ivec3(101, 104, 105), ivec3(101, 577, 104), ivec3(102, 103, 104), ivec3(102, 104, 577), ivec3(103, 576, 104), ivec3(106, 107, 316), ivec3(106, 316, 587), ivec3(107, 588, 316), ivec3(108, 109, 315), ivec3(108, 315, 607), ivec3(108, 316, 588), ivec3(108, 607, 316), ivec3(109, 314, 315), ivec3(109, 591, 612), ivec3(109, 612, 314), ivec3(110, 111, 134), ivec3(110, 134, 646), ivec3(110, 202, 203), ivec3(110, 203, 654), ivec3(110, 312, 313), ivec3(110, 313, 612), ivec3(110, 612, 591), ivec3(110, 614, 312), ivec3(110, 646, 202), ivec3(110, 654, 614), ivec3(111, 590, 134), ivec3(112, 113, 131), ivec3(112, 131, 592), ivec3(112, 132, 133), ivec3(112, 133, 594), ivec3(112, 592, 132), ivec3(112, 594, 590), ivec3(113, 130, 131), ivec3(113, 565, 130), ivec3(114, 115, 124), ivec3(114, 124, 125), ivec3(114, 125, 539), ivec3(114, 126, 127), ivec3(114, 127, 555), ivec3(114, 539, 126), ivec3(114, 555, 565), ivec3(115, 120, 121), ivec3(115, 121, 527), ivec3(115, 527, 124), ivec3(115, 537, 120), ivec3(116, 117, 120), ivec3(116, 120, 537), ivec3(117, 530, 120), ivec3(118, 119, 120), ivec3(118, 120, 530), ivec3(119, 525, 120), ivec3(121, 122, 123), ivec3(121, 123, 527), ivec3(121, 526, 122), ivec3(128, 129, 565), ivec3(128, 565, 555), ivec3(129, 564, 565), ivec3(130, 565, 564), ivec3(134, 135, 646), ivec3(134, 590, 594), ivec3(135, 176, 177), ivec3(135, 177, 646), ivec3(135, 598, 176), ivec3(136, 137, 174), ivec3(136, 174, 175), ivec3(136, 175, 598), ivec3(137, 597, 647), ivec3(137, 647, 174), ivec3(138, 139, 610), ivec3(138, 152, 153), ivec3(138, 153, 154), ivec3(138, 154, 155), ivec3(138, 155, 597), ivec3(138, 610, 152), ivec3(139, 151, 610), ivec3(139, 593, 151), ivec3(140, 141, 150), ivec3(140, 150, 593), ivec3(141, 581, 150), ivec3(141, 582, 581), ivec3(142, 143, 149), ivec3(142, 149, 581), ivec3(142, 581, 582), ivec3(143, 559, 149), ivec3(144, 145, 149), ivec3(144, 149, 559), ivec3(145, 547, 149), ivec3(146, 147, 148), ivec3(146, 148, 547), ivec3(147, 536, 148), ivec3(148, 149, 547), ivec3(150, 151, 593), ivec3(155, 156, 597), ivec3(156, 157, 597), ivec3(157, 158, 173), ivec3(157, 173, 647), ivec3(157, 647, 597), ivec3(158, 159, 173), ivec3(159, 633, 173), ivec3(160, 161, 652), ivec3(160, 172, 633), ivec3(160, 652, 172), ivec3(161, 170, 171), ivec3(161, 171, 652), ivec3(161, 665, 170), ivec3(162, 163, 694), ivec3(162, 166, 167), ivec3(162, 167, 685), ivec3(162, 168, 169), ivec3(162, 169, 665), ivec3(162, 685, 168), ivec3(162, 694, 166), ivec3(163, 164, 165), ivec3(163, 165, 694), ivec3(163, 706, 164), ivec3(169, 664, 665), ivec3(170, 665, 664), ivec3(172, 173, 633), ivec3(175, 645, 598), ivec3(176, 598, 645), ivec3(178, 179, 655), ivec3(178, 655, 646), ivec3(179, 651, 655), ivec3(180, 181, 201), ivec3(180, 201, 655), ivec3(180, 655, 651), ivec3(181, 653, 201), ivec3(182, 183, 200), ivec3(182, 200, 201), ivec3(182, 201, 653), ivec3(183, 680, 200), ivec3(183, 681, 680), ivec3(184, 185, 680), ivec3(184, 680, 681), ivec3(185, 688, 680), ivec3(186, 187, 199), ivec3(186, 199, 688), ivec3(187, 705, 199), ivec3(188, 189, 199), ivec3(188, 199, 705), ivec3(189, 198, 199), ivec3(189, 716, 198), ivec3(190, 191, 192), ivec3(190, 192, 716), ivec3(191, 717, 192), ivec3(192, 193, 198), ivec3(192, 198, 716), ivec3(193, 194, 195), ivec3(193, 195, 713), ivec3(193, 196, 197), ivec3(193, 197, 707), ivec3(193, 707, 198), ivec3(193, 713, 196), ivec3(193, 720, 194), ivec3(199, 680, 688), ivec3(202, 646, 655), ivec3(204, 205, 298), ivec3(204, 298, 299), ivec3(204, 299, 629), ivec3(204, 629, 654), ivec3(205, 297, 636), ivec3(205, 636, 298), ivec3(205, 657, 297), ivec3(206, 207, 297), ivec3(206, 297, 657), ivec3(207, 658, 672), ivec3(207, 672, 297), ivec3(208, 209, 212), ivec3(208, 212, 213), ivec3(208, 213, 658), ivec3(209, 210, 211), ivec3(209, 211, 668), ivec3(209, 668, 212), ivec3(209, 669, 210), ivec3(213, 672, 658), ivec3(214, 215, 296), ivec3(214, 296, 672), ivec3(215, 674, 296), ivec3(216, 217, 232), ivec3(216, 232, 674), ivec3(217, 673, 232), ivec3(218, 219, 675), ivec3(218, 232, 673), ivec3(218, 675, 232), ivec3(219, 670, 675), ivec3(220, 221, 222), ivec3(220, 222, 675), ivec3(220, 675, 670), ivec3(221, 671, 222), ivec3(222, 223, 675), ivec3(223, 676, 675), ivec3(224, 225, 675), ivec3(224, 675, 676), ivec3(225, 677, 675), ivec3(226, 227, 675), ivec3(226, 675, 677), ivec3(227, 229, 230), ivec3(227, 230, 675), ivec3(227, 678, 229), ivec3(228, 229, 678), ivec3(229, 682, 230), ivec3(230, 231, 675), ivec3(232, 233, 674), ivec3(233, 679, 674), ivec3(234, 235, 686), ivec3(234, 686, 679), ivec3(235, 240, 241), ivec3(235, 241, 686), ivec3(235, 684, 240), ivec3(236, 237, 238), ivec3(236, 238, 239), ivec3(236, 239, 684), ivec3(237, 683, 238), ivec3(239, 240, 684), ivec3(239, 689, 240), ivec3(242, 243, 674), ivec3(242, 674, 686), ivec3(243, 687, 674), ivec3(244, 245, 699), ivec3(244, 248, 687), ivec3(244, 699, 248), ivec3(245, 246, 247), ivec3(245, 247, 699), ivec3(245, 691, 246), ivec3(248, 249, 253), ivec3(248, 253, 687), ivec3(249, 250, 251), ivec3(249, 251, 252), ivec3(249, 252, 253), ivec3(249, 721, 250), ivec3(251, 723, 252), ivec3(253, 714, 687), ivec3(254, 255, 687), ivec3(254, 687, 714), ivec3(255, 703, 687), ivec3(256, 257, 695), ivec3(256, 687, 703), ivec3(256, 695, 687), ivec3(258, 259, 349), ivec3(258, 296, 695), ivec3(258, 349, 640), ivec3(258, 640, 296), ivec3(259, 693, 349), ivec3(260, 261, 347), ivec3(260, 347, 348), ivec3(260, 348, 659), ivec3(260, 659, 693), ivec3(261, 697, 347), ivec3(262, 263, 715), ivec3(262, 667, 697), ivec3(262, 715, 667), ivec3(263, 271, 715), ivec3(263, 702, 271), ivec3(264, 265, 271), ivec3(264, 271, 702), ivec3(265, 704, 271), ivec3(266, 267, 271), ivec3(266, 271, 704), ivec3(267, 270, 271), ivec3(267, 712, 270), ivec3(268, 269, 270), ivec3(268, 270, 712), ivec3(269, 722, 270), ivec3(272, 273, 344), ivec3(272, 344, 667), ivec3(272, 667, 715), ivec3(273, 343, 344), ivec3(273, 709, 343), ivec3(274, 275, 342), ivec3(274, 342, 663), ivec3(274, 663, 709), ivec3(275, 341, 342), ivec3(275, 692, 341), ivec3(276, 277, 340), ivec3(276, 340, 656), ivec3(276, 341, 692), ivec3(276, 656, 341), ivec3(277, 339, 340), ivec3(277, 660, 339), ivec3(278, 279, 287), ivec3(278, 287, 660), ivec3(279, 661, 287), ivec3(280, 281, 286), ivec3(280, 286, 661), ivec3(281, 662, 286), ivec3(282, 283, 286), ivec3(282, 286, 662), ivec3(283, 690, 696), ivec3(283, 696, 286), ivec3(284, 285, 690), ivec3(285, 696, 690), ivec3(286, 287, 661), ivec3(287, 585, 660), ivec3(287, 698, 545), ivec3(288, 545, 698), ivec3(290, 291, 309), ivec3(290, 309, 615), ivec3(290, 615, 627), ivec3(291, 308, 309), ivec3(291, 364, 370), ivec3(291, 370, 308), ivec3(291, 632, 364), ivec3(292, 293, 630), ivec3(292, 362, 363), ivec3(292, 363, 628), ivec3(292, 628, 632), ivec3(292, 630, 362), ivec3(293, 294, 634), ivec3(293, 634, 630), ivec3(293, 639, 294), ivec3(294, 295, 637), ivec3(294, 637, 634), ivec3(295, 350, 637), ivec3(295, 640, 350), ivec3(296, 297, 672), ivec3(296, 674, 695), ivec3(300, 301, 614), ivec3(300, 614, 654), ivec3(300, 654, 629), ivec3(301, 626, 614), ivec3(302, 303, 310), ivec3(302, 310, 311), ivec3(302, 311, 626), ivec3(303, 615, 310), ivec3(303, 627, 615), ivec3(304, 305, 603), ivec3(304, 384, 601), ivec3(304, 603, 384), ivec3(305, 602, 606), ivec3(305, 606, 603), ivec3(306, 307, 611), ivec3(306, 606, 602), ivec3(306, 611, 606), ivec3(307, 371, 372), ivec3(307, 372, 611), ivec3(307, 609, 613), ivec3(307, 613, 371), ivec3(308, 370, 609), ivec3(311, 614, 626), ivec3(316, 317, 573), ivec3(316, 573, 587), ivec3(319, 599, 585), ivec3(320, 321, 585), ivec3(320, 585, 599), ivec3(321, 322, 585), ivec3(322, 323, 585), ivec3(323, 324, 585), ivec3(324, 604, 585), ivec3(325, 326, 585), ivec3(325, 585, 604), ivec3(326, 327, 328), ivec3(326, 328, 332), ivec3(326, 332, 585), ivec3(326, 616, 327), ivec3(328, 329, 332), ivec3(329, 330, 332), ivec3(330, 331, 332), ivec3(331, 625, 332), ivec3(332, 333, 660), ivec3(332, 660, 585), ivec3(333, 638, 660), ivec3(334, 335, 660), ivec3(334, 660, 638), ivec3(335, 336, 660), ivec3(336, 337, 660), ivec3(337, 338, 660), ivec3(338, 642, 660), ivec3(339, 660, 642), ivec3(343, 709, 663), ivec3(345, 346, 697), ivec3(345, 697, 667), ivec3(346, 666, 697), ivec3(347, 697, 666), ivec3(349, 350, 640), ivec3(349, 693, 659), ivec3(351, 352, 354), ivec3(351, 354, 634), ivec3(351, 634, 637), ivec3(352, 353, 354), ivec3(352, 635, 353), ivec3(355, 356, 630), ivec3(355, 630, 634), ivec3(356, 357, 630), ivec3(357, 358, 630), ivec3(358, 359, 630), ivec3(359, 360, 361), ivec3(359, 361, 630), ivec3(359, 631, 360), ivec3(364, 365, 369), ivec3(364, 369, 370), ivec3(364, 632, 628), ivec3(365, 366, 367), ivec3(365, 367, 369), ivec3(367, 368, 369), ivec3(368, 617, 369), ivec3(370, 613, 609), ivec3(373, 374, 375), ivec3(373, 375, 611), ivec3(374, 608, 375), ivec3(375, 376, 611), ivec3(376, 377, 611), ivec3(377, 378, 611), ivec3(378, 379, 611), ivec3(379, 606, 611), ivec3(380, 381, 382), ivec3(380, 382, 383), ivec3(380, 383, 606), ivec3(381, 605, 382), ivec3(383, 603, 606), ivec3(384, 385, 601), ivec3(391, 580, 535), ivec3(394, 395, 415), ivec3(394, 415, 596), ivec3(394, 416, 417), ivec3(394, 417, 595), ivec3(394, 596, 416), ivec3(395, 600, 415), ivec3(396, 397, 414), ivec3(396, 414, 415), ivec3(396, 415, 600), ivec3(397, 618, 619), ivec3(397, 619, 414), ivec3(398, 399, 411), ivec3(398, 411, 623), ivec3(398, 623, 618), ivec3(399, 410, 411), ivec3(399, 641, 410), ivec3(400, 401, 402), ivec3(400, 402, 641), ivec3(401, 643, 402), ivec3(402, 403, 410), ivec3(402, 410, 641), ivec3(403, 644, 410), ivec3(404, 405, 410), ivec3(404, 410, 644), ivec3(405, 406, 407), ivec3(405, 407, 650), ivec3(405, 648, 406), ivec3(405, 650, 410), ivec3(408, 409, 649), ivec3(408, 649, 650), ivec3(410, 650, 649), ivec3(412, 413, 618), ivec3(412, 618, 623), ivec3(413, 619, 618), ivec3(418, 419, 474), ivec3(418, 474, 475), ivec3(418, 475, 487), ivec3(418, 487, 731), ivec3(419, 730, 474), ivec3(420, 421, 732), ivec3(420, 732, 730), ivec3(421, 422, 732), ivec3(421, 728, 422), ivec3(422, 423, 473), ivec3(422, 473, 732), ivec3(423, 424, 471), ivec3(423, 471, 472), ivec3(423, 472, 473), ivec3(424, 470, 471), ivec3(424, 726, 470), ivec3(425, 426, 469), ivec3(425, 469, 470), ivec3(425, 470, 726), ivec3(426, 711, 469), ivec3(427, 428, 467), ivec3(427, 467, 468), ivec3(427, 468, 711), ivec3(428, 429, 466), ivec3(428, 466, 467), ivec3(429, 620, 466), ivec3(429, 624, 620), ivec3(430, 431, 620), ivec3(430, 620, 624), ivec3(431, 621, 620), ivec3(432, 433, 465), ivec3(432, 465, 620), ivec3(432, 620, 621), ivec3(433, 434, 464), ivec3(433, 464, 465), ivec3(434, 463, 464), ivec3(434, 532, 463), ivec3(435, 436, 462), ivec3(435, 462, 532), ivec3(436, 461, 462), ivec3(436, 517, 461), ivec3(437, 438, 460), ivec3(437, 460, 461), ivec3(437, 461, 517), ivec3(438, 439, 458), ivec3(438, 458, 459), ivec3(438, 459, 460), ivec3(439, 440, 511), ivec3(439, 511, 458), ivec3(439, 515, 440), ivec3(440, 441, 511), ivec3(441, 513, 511), ivec3(442, 443, 457), ivec3(442, 457, 513), ivec3(443, 444, 456), ivec3(443, 456, 457), ivec3(443, 512, 444), ivec3(444, 445, 456), ivec3(445, 446, 456), ivec3(445, 514, 446), ivec3(446, 447, 455), ivec3(446, 455, 456), ivec3(447, 516, 455), ivec3(448, 449, 455), ivec3(448, 455, 516), ivec3(449, 518, 455), ivec3(450, 451, 454), ivec3(450, 454, 455), ivec3(450, 455, 518), ivec3(451, 452, 454), ivec3(451, 543, 452), ivec3(452, 453, 454), ivec3(453, 542, 454), ivec3(457, 511, 513), ivec3(462, 463, 532), ivec3(468, 469, 711), ivec3(474, 730, 732), ivec3(475, 476, 485), ivec3(475, 485, 486), ivec3(475, 486, 487), ivec3(476, 477, 481), ivec3(476, 481, 725), ivec3(476, 482, 483), ivec3(476, 483, 727), ivec3(476, 484, 485), ivec3(476, 725, 482), ivec3(476, 727, 484), ivec3(477, 478, 479), ivec3(477, 479, 480), ivec3(477, 480, 481), ivec3(477, 701, 478), ivec3(479, 700, 480), ivec3(485, 729, 486), ivec3(488, 489, 490), ivec3(488, 490, 498), ivec3(489, 523, 490), ivec3(490, 491, 495), ivec3(490, 495, 497), ivec3(490, 497, 498), ivec3(491, 494, 495), ivec3(491, 533, 494), ivec3(492, 493, 494), ivec3(492, 494, 533), ivec3(493, 534, 494), ivec3(495, 496, 497), ivec3(495, 522, 496), ivec3(499, 500, 506), ivec3(499, 506, 507), ivec3(499, 507, 710), ivec3(500, 501, 502), ivec3(500, 502, 503), ivec3(500, 503, 504), ivec3(500, 504, 506), ivec3(500, 719, 501), ivec3(504, 505, 506), ivec3(505, 718, 506), ivec3(507, 508, 509), ivec3(507, 509, 710), ivec3(507, 708, 508), ivec3(674, 679, 686), ivec3(674, 687, 695));\nconst int len = 730;\n\nbool sameSide( vec3 p1, vec3 p2, vec3 a, vec3 b ) {\n    vec3 cp1 = cross(b-a, p1-a);\n    vec3 cp2 = cross(b-a, p2-a);\n      \n    return dot(cp1, cp2) >= 0.0;\n}\n\nbool pointInTriangle( vec3 p, vec3 a, vec3 b, vec3 c ) {\n    return sameSide(p, a, b, c) && sameSide(p, b, a, c) && sameSide(p, c, a, b);\n}\n\nbool inPath( vec2 p ) {\n    for (int i=0; i<len; i++) {\n        ivec3 triangle = triangles[i];\n        vec3 a = positions[triangle[0]];\n        vec3 b = positions[triangle[1]];\n        vec3 c = positions[triangle[2]];\n  \n        if (pointInTriangle(vec3(p, 0.0), a, b, c)) {\n            return true;\n        }\n    }\n  \n    return false;\n}\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float step = 1.0 / iResolution.y;\n  \n    fragColor = vec4(vec3(0.0), 1.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= vec2(1.0);\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.4;\n\n    if (inPath(uv)) {\n        fragColor = vec4(1.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsGyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 50, 50, 79], [81, 81, 103, 103, 179], [181, 181, 215, 215, 246], [248, 248, 278, 278, 359], [361, 361, 418, 418, 2385]], "test": "untested"}
{"id": "mdyczt", "name": "Warped Counter", "author": "Retr0id", "description": "iterating further on the concept of an odometer without discrete wheels.", "tags": ["clock", "counter", "exponential"], "likes": 5, "viewed": 172, "published": 3, "date": "1696454972", "time_retrieved": "2024-07-30T17:30:33.446317", "image_code": "// A selection of fonts generated from Shadertoy's font texture.\n// by Hazel Quantock 2019\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n\n// quality of font anti-aliasing - number of samples doubles with each level of quality\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - this looks more photographic, but blurrier\n#define AA_ROUND false\n#define AA_ROUND_RADIUS 0.7071\n\n\n// Font Definitions\nstruct Typeface\n{\n    vec2 scale;\n    vec2 padding;\n    vec2 bias;\n    float biasAngle;\n    float threshold;\n};\n\nconst Typeface Deco = Typeface( vec2(.6,.7), vec2(0), vec2(-.02,.025), 0., -.02 );\nconst Typeface Deco_Light = Typeface( vec2(.63,.7), vec2(-1,0), vec2(-.01,.04), 0., -.02 );\n\nconst Typeface Impactful = Typeface( vec2(.5,1), vec2(4,2), vec2(-.02,.01), 0., .01 );\n\nconst Typeface Elegant = Typeface( vec2(.6,.9), vec2(-2,0), vec2(.05,-.005), -1.04, -.022 );\nconst Typeface Elegant_Condensed = Typeface( vec2(.5,1.), vec2(0,1), vec2(.0,.1), -1., -.02 );\n\nconst Typeface Timely = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), -.5, -.02 );\nconst Typeface Timely_Light = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.02,.02), -.5, -.01 );\nconst Typeface Timely_Heavy = Typeface( vec2(.8,.7), vec2(4,1), vec2(-.03,.02), 2.5, .01 );\n\nconst Typeface Neat = Typeface( vec2(.6,.7), vec2(-1,1), vec2(-.017,.02), -.3, -.02 );\n\nconst Typeface Comic = Typeface( vec2(.8,.7), vec2(2,1), vec2(-.05,.0), 1., -.02 );\nconst Typeface Comic_Title = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.0), 1., .0 );\n\nconst Typeface WildWest = Typeface( vec2(.9), vec2(2,0), vec2(-.05,.0), 0., -.02 );\nconst Typeface WildWest_Wide = Typeface( vec2(1,.7), vec2(0,2), vec2(.05,.0), 0., .02 );\n\nconst Typeface Gothic = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., .01 );\nconst Typeface Gothic_Light = Typeface( vec2(.9,.7), vec2(0,2), vec2(.05,.0), 1., -.01 );\nconst Typeface Gothic_Condensed = Typeface( vec2(.5,1.), vec2(0), vec2(.05,.0), -1.04, .02 );\nconst Typeface Gothic_Book = Typeface( vec2(.6,.7), vec2(0,2), vec2(.1,.0), 1., .0 );\n\nconst Typeface Haunted = Typeface( vec2(.75,.9), vec2(2,0), vec2(.0,.03), 0., .01 );\nconst Typeface Haunted_Condensed = Typeface( vec2(.5,1), vec2(4,0), vec2(-.02,.03), 0., .01 );\nconst Typeface Haunted_Script = Typeface( vec2(.6,.7), vec2(2,1), vec2(-.05,.05), .7, .0 );\n\n// Round-tipped font (actually not round in close-up)\nconst Typeface Round = Typeface( vec2(1), vec2(0,6), vec2(-.02,-.02), 0., -.01 );\nconst Typeface Round_Bold = Typeface( vec2(1), vec2(4,6), vec2(-.04,-.04), 0., -.01 );\n\n\nfloat RenderFont_NoAA\n    (\n        vec2 uv,\n        Typeface font,\n        uint text[8]\n    )\n{\n    // each char is in a 64x64 space, trim off the white boundary\n    vec2 charBottomLeft = vec2(18,3) - font.padding/2.;\n    vec2 charDims = vec2(28,52) + font.padding;\n\n    uv = uv/font.scale; //+vec2(iTime*200.,0);\n    \n    if ( uv.y < .0 || uv.y >= charDims.y ) return 1.;\n    \n    uint index = uint(uv.x/charDims.x);\n    ivec2 res = ivec2(iResolution.xy);\n    uint index4 = index/4u;\n\n    if ( index4 >= uint(text.length()) ) return 1.;\n    \n    uint char = ( text[index4] >> (8u*(index&3u)) )&0xffu;\n    \n    char = char^0xf0u; // flip the y coord\n    \n    uv.x = fract(uv.x/charDims.x)*charDims.x;\n    uv += vec2(ivec2(char&0xfu,char>>4u)) * iChannelResolution[0].xy/16.;\n    uv += charBottomLeft;\n                            \n    vec4 v = texture( iChannel0, uv/iChannelResolution[0].xy ) -.5;\n                            \n    vec2 bias = 2.*v.yz;\n    bias = bias*cos(font.biasAngle) + bias.yx*sin(font.biasAngle)*vec2(1,-1);\n    bias = pow(abs(bias),vec2(3));\n    \n    // view the SDF\n//    float f = v.w + dot( font.bias, bias ) - font.threshold; return .5+.5*f/(abs(f)+.04);\n    \n    return step( font.threshold, v.w + dot( font.bias, bias ) );\n}\n\n\n\n// RenderFont\n//\n// Output:\n//\t\tA linear brightness value where 0 = text, 1 = background.\n//\t\tI recommend applying a gamma curve before displaying.\n//\n// uv\n//\t\tRelative to the bottom left of the line of text, most fonts are about 40 units tall\n//\n// font\n//\t\tOne of the Typefaces defined earlier\n//\n// text\n//\t\tA line of text, encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n//\t\tEach byte is 4-bit u, 4-bit v coord of a character in the font texture.\n//\nfloat RenderFont\n    (\n        vec2 uv,\n        Typeface font,\n\t\tuint text[8]\n    )\n{\n    const int numSamples = 1<<(AA_QUALITY);\n    \n    float sum = 0.;\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n\n    // anti-alias the font\n    // this would be more efficient run per-character inside the font render function\n    // (the SDFs on some of the fonts are good enough that I could probably just soften the step function)\n    for ( int i=0; i < numSamples; i++ )\n    {\n        // ideal 2D quasirandom sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        sum += RenderFont_NoAA( uv + jitter.x*duvdx + jitter.y*duvdy, font, text );\n    }\n   \n    return sum/float(numSamples);\n}\n\n\n\nfloat factor = 10.0;\nfloat segments = 4.0;\nfloat zoom = 0.30;\n\nvec4 test(vec2 uv) {\n    return vec4(uv.x, 0.0, uv.y, 1.0);\n}\n\nvec4 digits(vec2 uv) {\n    float f = RenderFont( vec2((uv.y)*170.0, (1.0-uv.x)*25.0 + 8.0), Deco, uint[]( 0x33323130U, 0x37363534U, 0x20203938U, 0U, 0U, 0U, 0U, 0U ) );\n    return texture(iChannel1, uv) * vec4(0.7, 0.9, 1.6, 1.0) * f + vec4(1.0) * (1.0-f);\n    //return vec4(vec3( pow( f, 1./2.2 ) ), 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(1.0-uv.y, uv.x);\n\n    float t = iTime / 1000.0;\n\n    uv.x = uv.x * segments; // repeat n times\n    uv.y -= 0.5; // vertical centering\n    uv.y *= pow(factor, mod(-uv.x, 1.0)) * zoom; // exponential scaling\n    uv.y += t * pow(factor, floor(uv.x)); // make each wheel faster than the previous\n   \n    // Output to screen\n    //fragColor = test(mod(uv, 1.0));\n    fragColor = digits(mod(uv, 1.0));\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyczt.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[3894, 4380, 4465, 4465, 5855], [5922, 5922, 5942, 5942, 5983], [6297, 6297, 6354, 6404, 6856]], "test": "untested"}
{"id": "DdGyzd", "name": "Interactive Mandelbrot loop", "author": "willwombell", "description": "Interactive Mandelbrot fractal, mouse x position alters number of loops.\nPhase colouring using time dependent mapping.", "tags": ["fractal", "math", "complex"], "likes": 7, "viewed": 157, "published": 3, "date": "1696440293", "time_retrieved": "2024-07-30T17:30:34.370845", "image_code": "// Fork of \"Just some lines\" by willwombell. https://shadertoy.com/view/msKczK\n// 2023-10-04 17:23:22\n\n# define PLAY true\n\nvec2 resnrmx(vec2 x){return (x - 0.5*iResolution.xy)/iResolution.y;}\nvec2 resnrmy(vec2 x){return (x - 0.5*iResolution.xy)/iResolution.x;}\n\n\nfloat f1(vec2 x, vec2 params){\n    return x.y-params.y*sin(exp(x.x-params.x));\n}\n\nfloat f2(vec2 x, vec2 params){\n    return x.y*x.y - params.y*sin(x.y*exp(x.x*x.y-params.x));\n}\n\nfloat f3(vec2 x, vec2 params){\n    float val = 0.;\n    for (int i = 0; i < 5; i++){\n        val += sin(x.y + params.x*val + exp(val*x.x));\n        val *= params.y*tanh(val)+params.x;\n    };\n    return val;\n}\n\nfloat f(vec2 x, vec2 params){\n    vec2 c = x;\n    vec2 z = vec2(0.);\n    for (int i = 0; i < 160; i++){\n        z = vec2(pow(z.x, 2.)-pow(z.y, 2.), 2.*z.x*z.y) + c;\n        if (i > int((5+iFrame)/5)%160) break;\n    };\n    return length(z);\n}\n\nvec2 m(vec2 x, vec2 params){\n    vec2 c = x;\n    vec2 z = vec2(0.);\n    for (int i = 0; i < 40; i++){\n        z = vec2(pow(z.x, 2.)-pow(z.y, 2.), 2.*z.x*z.y) + c;\n        if (i > int(10.*(params.x + 1.5))) break;\n    };\n    return z;\n}\n\nvec3 huer(float ang, float offset, vec3 params){\n    return vec3(nrm(cos(ang + params.x + offset)),\n                nrm(cos(ang + params.y + offset)),\n                nrm(cos(ang + params.z + offset)));\n}\n\nvec3 autohue(float ang){\n    float pi = 3.141592653589793238,\n          phi = 1.618033988749,\n          rate = 1.0;\n    vec3 params = PI*cos(rate*vec3(iTime, iTime*PHI, iTime*PHI*PHI));\n    return vec3(nrm(cos(ang + params.x)),\n                nrm(cos(ang + params.y)),\n                nrm(cos(ang + params.z)));\n}\n\nvec3 autocol(float r, float t){\n    float pi = 3.141592653589793238,\n          phi = 1.618033988749,\n          rate = 1.0;\n    vec3 params = PI*cos(rate*vec3(iTime, iTime*PHI, iTime*PHI*PHI));\n    return vec3(nrm(cos(t + params.x)),\n                nrm(cos(t + params.y)),\n                nrm(cos(t + params.z)));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = resnrmx(fragCoord) - vec2(.25,0.);\n    vec2 mouse = resnrmx(iMouse.xy);\n    \n    float scale = 2.3;\n    float t = PLAY ? iTime : 0.;\n    \n    uv *= scale;\n    mouse *= scale;\n    \n    \n    float rate = 0.3;\n    vec3 params = PI*cos(rate*vec3(iTime, iTime*PHI, iTime*PHI*PHI));\n    \n    vec2 z = m(uv, mouse);\n    \n    float ilum = pow(0.5*cos(t)+0.5, 10.*(mouse.y+scale))+.1;\n    \n    fragColor = vec4(nrm(tanh(f(uv, mouse+scale/2.))));\n    fragColor = vec4(vec3(tanh(1./cmod(z))), 1.);\n    fragColor = tanh(ilum/cmod(z))*vec4(huer(atan(z.y, z.x), 0., params), 1.);\n}", "image_inputs": [], "common_code": "#define norm_scale 1.0\n#define PHI 1.618033988749\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat sdfLine1(vec2 p, vec2 a, vec2 b){\n    return min(length(p-a), length(p-b));\n}\n\nfloat sdfLine(vec2 p, vec2 a, vec2 b){\n    vec2 line = b-a;\n    vec2 offs = p-a;\n    float h = clamp(dot(line, offs)/dot(line, line), 0., 1.);\n    \n    return length(offs-h*line);\n}\n\nfloat outline(float sd, float w){\n    return abs(sd) - w;\n}\n\nfloat nrm(float x){return 0.5*(1. + x);}\nfloat mrn(float x){return 2.*(x - 0.5);}\n\nvec2 nrm(vec2 x){return 0.5*(1. + x);}\nvec2 mrn(vec2 x){return 2.*(x - 0.5);}\n\nvec3 nrm(vec3 x){return 0.5*(1. + x);}\nvec3 mrn(vec3 x){return 2.*(x - 0.5);}\n\nvec4 nrm(vec4 x){return 0.5*(1. + x);}\nvec4 mrn(vec4 x){return 2.*(x - 0.5);}\n\n\n\n\n// Complex functions copied from work by Ricky Reusser (rreusser)\n\n// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n\n\nvec4 cmul (vec4 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec2 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw)\n  );\n}\n\nvec4 cmul (vec4 a, vec2 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec4 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\n\nvec4 csqr (vec4 a) {\n  return vec4(\n    csqr(a.xy),\n    2.0 * cmul(a.xy, a.zw)\n  );\n}\nvec4 cdiv (vec4 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw) - cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec2 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(-cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec4 a, vec2 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw), csqr(b.xy))\n  );\n}\n\nvec4 csub(vec4 a, vec4 b) {\n  return a - b;\n}\n\nvec4 csub(vec2 a, vec4 b) {\n  return vec4(a.xy - b.xy, -b.zw);\n}\n\nvec4 csub(vec4 a, vec2 b) {\n  return vec4(a.xy - b.xy, a.zw);\n}\n\nvec4 cadd(vec4 a, vec4 b) {\n  return a + b;\n}\n\nvec4 cadd(vec2 a, vec4 b) {\n  return vec4(a.xy + b.xy, b.zw);\n}\n\nvec4 cadd(vec4 a, vec2 b) {\n  return vec4(a.xy + b.xy, a.zw);\n}\n\n\nvec4 cinv(vec4 a) {\n  vec2 ainv = cinv(a.xy);\n  return vec4(ainv, cmul(a.zw, -csqr(ainv)));\n}\n\nvec4 cexp(vec4 a) {\n  vec2 expa = cexp(a.xy);\n  return vec4(expa, cmul(expa, a.zw));\n}\n\nvec4 csqrt(vec4 a) {\n  float r = hypot(a.xy);\n  float b = sqrt(2.0 * (r + a.x));\n  float c = sqrt(2.0 * (r - a.x));\n  float re = a.x >= 0.0 ? 0.5 * b : abs(a.y) / c;\n  float im = a.x <= 0.0 ? 0.5 * c : abs(a.y) / b;\n  vec2 s = vec2(re, a.y < 0.0 ? -im : im);\n  return vec4(s, cmul(a.zw, 0.5 * cinv(s)));\n}\n\n/*vec4 cpow(vec4 a, float n) {\n  float theta = atan(a.y, a.x);\n  float r = hypot(a.xy);\n  float tn = theta * n;\n  float rn = pow(r, n);\n  vec2 s = rn * vec2(sin(tn), cos(tn));\n  float rn1 = pow(r, n - 1.0);\n  float tn1 = theta * (n - 1.0);\n  return vec4(s, cmul(a.zw, n * rn1 * vec2(sin(tn1), cos(tn1))));\n}*/\n\nvec4 clog(vec4 z) {\n  return vec4(\n    log(hypot(z.xy)),\n    atan(z.y, z.x),\n    cdiv(z.zw, z.xy)\n  );\n}\n\nvec4 csin(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.xy, cmul(asincos.zw, a.zw));\n}\n\nvec4 ccos(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.zw, cmul(-asincos.xy, a.zw));\n}\n\nvec4 ctan(vec4 a) {\n  return cdiv(csin(a), ccos(a));\n}\n\nvec4 casin(vec4 z) {\n  vec4 s = clog(vec4(-z.y, z.x, -z.w, z.z) + csqrt(csub(vec2(1, 0), csqr(z))));\n  return vec4(s.y, -s.x, s.w, -s.z);\n}\n\nvec4 cacos(vec4 z) {\n  vec4 s = -casin(z);\n  s.x += HALF_PI;\n  return s;\n}\n\nvec4 catan(vec4 z) {\n  vec2 s = clog(cdiv(cadd(vec2(0, 1), z.xy), csub(vec2(0, 1), z.xy)));\n  return vec4(\n     0.5 * vec2(-s.y, s.x),\n     cmul(z.zw, cinv(cadd(vec2(1, 0), csqr(z))))\n  );\n}\n\nvec4 csinh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez - cinv(ez));\n}\n\nvec4 ccosh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez + cinv(ez));\n}\n\nvec4 ctanh(vec4 z) {\n  vec4 ez = cexp(z);\n  vec4 ezinv = cinv(ez);\n  return 0.5 * cdiv(ez - ezinv, ez + ezinv);\n}\n\nvec4 casinh(vec4 z) {\n  return clog(cadd(z, csqrt(cadd(vec2(1, 0), csqr(z)))));\n}\n\nvec4 cacosh(vec4 z) {\n  return clog(z + cmul(csqrt(cadd(z, vec2(1, 0))), csqrt(csub(z, vec2(1, 0)))));\n}\n\nvec4 catanh(vec4 z) {\n  return 0.5 * clog(cdiv(cadd(z, vec2(1,  0)), csub(vec2(1, 0), z)));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdGyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 144, 144, 191], [192, 192, 213, 213, 260], [263, 263, 293, 293, 343], [345, 345, 375, 375, 439], [441, 441, 471, 471, 648], [650, 650, 679, 679, 891], [893, 893, 921, 921, 1128], [1130, 1130, 1178, 1178, 1334], [1336, 1336, 1360, 1360, 1650], [1652, 1652, 1683, 1683, 1967], [1971, 1971, 2028, 2028, 2610]], "test": "untested"}
{"id": "3tyBW3", "name": "Dot Waves 2", "author": "Retr0id", "description": "Made this ages ago, thought I might as well publish it. IIRC I was trying to recreate an effect I saw in a GIF somewhere. No idea why the title is Dot Waves 2 - what happened to Dot Waves 1?", "tags": ["waves", "dots"], "likes": 6, "viewed": 261, "published": 3, "date": "1696438658", "time_retrieved": "2024-07-30T17:30:35.200626", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float cellsize = 32.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 divpos = floor(fragCoord / cellsize);\n    vec2 modpos = mod(fragCoord, cellsize) - (cellsize * 0.5);\n    \n    float rot = iTime*4.0 + sin(divpos.x*0.5) + sin(divpos.y*0.5) + divpos.x*0.4;\n    vec2 offset = vec2(sin(rot)*10.0, cos(rot)*10.0);\n    modpos += offset;\n    \n    float c = 1.0 - sqrt(modpos.x*modpos.x + modpos.y*modpos.y) * 0.5;\n\n    // Output to screen\n    fragColor = vec4(c,c,c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tyBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 544]], "test": "untested"}
{"id": "DdycRt", "name": "Exponential Fractal Rain", "author": "Retr0id", "description": "I was thinking about how odometers and similar counters have each drum rotating exponentially faster than the next (or slower, depending on which end you're looking from). I thought, what if instead of having discrete drums rotating, it was continuous?", "tags": ["rain", "fractalnoise"], "likes": 2, "viewed": 299, "published": 3, "date": "1696427342", "time_retrieved": "2024-07-30T17:30:35.956605", "image_code": "float hash(float x)\n{\n\treturn fract(sin(cos(x*12.13)*19.123)*17.321);\n}\n\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\tfloat v0=hash(pd.x+pd.y*41.0);\n\tfloat v1=hash(pd.x+1.0+pd.y*41.0);\n\tfloat v2=hash(pd.x+pd.y*41.0+41.0);\n\tfloat v3=hash(pd.x+pd.y*41.0+42.0);\n\tv0 = mix(v0,v1,smoothstep(0.0,1.0,pm.x));\n\tv2 = mix(v2,v3,smoothstep(0.0,1.0,pm.x));\n\treturn mix(v0,v2,smoothstep(0.0,1.0,pm.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float shift = ((1.0 - uv.x) * 12.0);\n\n    // Time varying pixel color\n    //float v = mod((iTime / pow(2.0, shift)) + uv.y + hash(uv.x)+hash(uv.x*3.0)+hash(uv.x*69.0), 1.0) > 0.5 ? 0.0 : 1.0;\n    //v = mod(v+hash(uv.x)+hash(uv.x*3.0)+hash(uv.x*69.0), 1.0);\n    float col = mod((iTime / exp2(shift) * 16.0) + uv.y, 1.0);\n\n    // fractal noise yoinked from https://www.shadertoy.com/view/Msf3Wr by mu6k\n    float v =0.0;\n    float octaves = 24.0;\n    for (float i = 0.0; i<octaves; i+=1.0)\n\t{\n\t\tfloat t = i;\n\t\tfloat l = t;\n\t\tfloat e = exp2(t);\n\t\tv+=noise(vec2(uv.x, mod(uv.y+col+hash(uv.x)+hash(uv.x*3.0)+hash(uv.x*69.0), 1.0))*e+vec2(cos(l)*53.0,sin(l)*100.0))*(1.0-(t/octaves))*(t/octaves);\n\t\t\n\t}\n\t\n\tv-=0.5;\n    v *= 0.5;\n\n    // Output to screen\n    //fragColor = vec4((uv.y > 0.498 && uv.y < 0.502) ? vec3(0.0) : vec3(v),1.0);\n    fragColor = vec4(vec3(v)*vec3(0.3, 1.0, 0.3), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdycRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 71], [74, 74, 95, 95, 410], [412, 412, 469, 519, 1450]], "test": "untested"}
{"id": "dsKczc", "name": "Mandelbrot-prim", "author": "f_x", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 1, "viewed": 142, "published": 3, "date": "1696425909", "time_retrieved": "2024-07-30T17:30:36.701613", "image_code": "\n\nvec2 init(vec2 fragCoord, vec2 res) {\n    float ratio = res.y/res.x;\n    vec2 mr = vec2(min(res.x, res.y));\n    vec2 uv = (fragCoord/mr) + vec2(-0.5/ratio, -0.5);\n    return uv;\n}\n\nvec2 sq(vec2 c) {\n    float re = c.x*c.x - c.y*c.y;\n    float im = 2.*c.x*c.y;\n    return vec2(re,im);\n}\n\nfloat amount(vec2 c) {\n    return sqrt(c.x*c.x + c.y*c.y);\n}\n\nint mandel(vec2 c0, vec2 c00, int maxIter) {\n    vec2 c = sq(c0);\n    \n    int iter;\n    for (iter=0;iter < maxIter && amount(c) < 4.; iter++) {\n        c = sq(c - c00);\n    }\n    \n    return iter;\n}\n\nfloat band(int hz) { \n    int ix = int(float(hz)/23.); \n    float fft  = texelFetch( iChannel0, ivec2(ix,0), 0 ).x; \n    return fft;\n}\n\n\nfloat sinp(float x) {\n    return (1. + sin(x)) / 2.;\n}\n\nfloat sinp(int n) {\n    return sinp(float(n));\n}\n\nfloat nn(int n) {\n    if (n < 8) return float(n);\n    return float(n) + band(180)*250.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = init(fragCoord,iResolution.xy*.4) - vec2(1.3, 0.8);\n\n    int N = 10000;\n    \n    float ra = band(200)*.1;//sin(iTime * 1.012) * 0.02;\n    float rb = band(200)*(.35-band(4000))/.6;//sin(iTime * 1.037) * 0.08;\n    \n    \n    int n = mandel(uv.yx, vec2(.57+ra, .57+rb), N);\n    \n    \n    vec3 col = n == N ? vec3(0) : vec3(\n        sinp(nn(n) / 43.), sinp(nn(n) / 27.), sinp(nn(n) * .2)\n    );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 34844, "src": "https://soundcloud.com/f_x/so-techno-halt", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsKczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 39, 39, 181], [183, 183, 200, 200, 287], [289, 289, 311, 311, 349], [351, 351, 395, 395, 550], [552, 552, 572, 572, 686], [689, 689, 710, 710, 743], [745, 745, 764, 764, 793], [795, 795, 812, 812, 884], [886, 886, 943, 943, 1381]], "test": "untested"}
{"id": "msKyR3", "name": "Hexcopter Flying", "author": "dr2", "description": "Fly the drone; slider controls speed, ring click changes view (multiple views including fpv)", "tags": ["interactive", "forest", "flight", "drone", "fpv"], "likes": 30, "viewed": 490, "published": 3, "date": "1696412057", "time_retrieved": "2024-07-30T17:30:37.630130", "image_code": "// \"Hexcopter Flying\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 FlMat (float pit, float yaw, float rol);\nmat3 StdVuMat (float el, float az);\nfloat Ssign (float x);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define VAR_ZERO min (nFrame, 0)\n\nmat3 flMat;\nvec3 qHit, flPos, tOff, sunDir;\nvec2 cIdB, cIdS, cMidB, cMidS;\nfloat tCur, dstFar, flSz, hgSizeB, hgSizeS, cDir, cType, csOcc, pWid;\nint nFrame, idObj;\nbool flHide;\nconst int idGrnd = 1, idFrm = 2, idTrnk = 3, idLvs = 4, idCab = 11, idBod = 12, idArm = 13,\n   idGard = 14, idMot = 15, idSup = 16, idAnt = 17, idSkd = 18, idCam = 19, idProp = 20;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a, s, r;\n  dMin = dstFar / flSz;\n  p = flMat * (p - flPos) / flSz;\n  p.xz = vec2 (p.z, - p.x);\n  q = p;\n  q.y -= 0.6;\n  d = max ((abs (q.y) + abs (q.z)) / sqrt(2.) - 0.5, max (q.y - 0.35, abs (q.x) - 0.7));\n  DMINQ (idCab);\n  d = PrRoundCylDf (vec3 (q.x, q.y - 0.17, abs (q.z) - 0.53).yzx, 0.03, 0.07, 0.5);\n  DMINQ (idCab);\n  d = min (min (PrSphDf (vec3 (abs (q.x) - 0.7, q.y, q.z), 0.2),\n     PrSphDf (vec3 (q.x - 0.7, q.y, abs (q.z) - 0.4), 0.1)),\n     PrSphDf (vec3 (q.x, q.y - 0.35, q.z), 0.15));\n  DMINQ (idCam);\n  d = PrRoundCylDf (vec3 (abs (q.xz) - vec2 (0.5, 0.2), q.y - 0.6), 0.02, 0.01, 0.3);\n  DMINQ (idAnt);\n  q = p;\n  d = PrSphDf (vec3 (abs (q.x) - 0.6, q.y + 0.35, q.z), 0.15);\n  DMINQ (idCam);\n  q.y -= -0.6;\n  d = min (PrRoundBoxDf (vec3 (q.x, q.y, abs (q.z) - 0.55), vec3 (0.7, 0.01, 0.06), 0.02),\n     PrCylDf (vec3 (abs (q.xz) - vec2 (0.55, 0.55), q.y - 0.2), 0.04, 0.2));\n  DMINQ (idSkd);\n  q = p;\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  s = sign (fract (3. * a) - 0.5);\n  q.xz = Rot2Cs (q.xz, CosSin (2. * pi * (floor (6. * a) + 0.5) / 6.));\n  d = min (max ((abs (q.y) - q.x) / sqrt(2.) - 0.85, max (-1. - q.x, abs (q.y) - 0.35)),\n     max ((abs (q.y) + abs (q.z)) / sqrt(2.) - 0.14, abs (q.x + 1.) - 0.1));\n  DMINQ (idBod);\n  d = max ((abs (abs (q.y) - 0.1) + abs (q.z)) / sqrt(2.) - 0.04, abs (q.x + 2.5) - 1.5);\n  DMINQ (idArm);\n  d = (abs (length (q.xz) - 3.06) + abs (abs (q.y) - 0.22)) / sqrt(2.) - 0.04;\n  q.x += 2.8;\n  r = length (q.xz) - 1.2;\n  d = max (d, - r);\n  DMINQ (idSup);\n  d = PrRoundCylDf (q.xzy, 0.15, 0.05, 0.25);\n  DMINQ (idMot);\n  q.y = abs (q.y) - 0.22;\n  d = max (Maxv2 (abs (abs (Rot2Cs (q.xz, CosSin (pi/4.))) - 0.85)) - 0.04, q.y);\n  DMINQ (idSup);\n  d = (abs (r) + abs (q.y)) / sqrt(2.) - 0.04;\n  DMINQ (idGard);\n  q.xz = Rot2Cs (q.xz, CosSin (10.1 * s * pi * tCur));\n  d = PrRoundBoxDf (q, vec3 (1.1, 0.01, 0.07), 0.01);\n  DMINQ (idProp);\n  return flSz * dMin;\n}\n\nfloat FlObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat FlObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = FlObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 10.) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 FlCol ()\n{\n  vec4 col4, fCol4, gCol4, lCol4;\n  float a;\n  fCol4 = vec4 (0.8, 0.8, 0.9, 0.2);\n  gCol4 = vec4 (0.7, 0.6, 0.2, 0.5);\n  lCol4 = vec4 (1., 0.3, 0.3, -1.);\n  if (idObj == idMot || idObj == idGard) a = atan (qHit.z, - qHit.x) / (2. * pi) + 0.5;\n  if (idObj == idCab) {\n    col4 = mix (gCol4, fCol4 * ((qHit.y < 0.) ? 1.2 : 1.), step (0.02, abs (qHit.y)));\n    if (qHit.y > 0.) col4 = mix (gCol4, col4, step (0.05, abs (abs (qHit.x - 0.4 +\n       0.6 * abs (qHit.z) - 0.05) - 0.1)));\n    col4 = mix (lCol4.rrga, col4, step (0.21, length (qHit.yz)));\n    if (qHit.x < 0.) col4 = mix (mix (lCol4.rgga, lCol4.ggra, step (0.5, fract (2. * tCur +\n       0.25 * sign (qHit.z)))), col4, step (0.05, length (vec2 (qHit.y, abs (qHit.z) - 0.4))));\n  } else if (idObj == idBod) {\n    col4 = mix (gCol4, fCol4 * ((qHit.y < 0.) ? 1.2 : 1.), step (0.02, abs (qHit.y)));\n    if (qHit.y < 0.) col4 = mix (lCol4.grba, col4, step (0.02, abs (qHit.x + 0.3)));\n  } else if (idObj == idMot) {\n    col4 = gCol4;\n    if (abs (qHit.y) < 0.18) col4 *= 0.5 + 0.5 * step (0.5, fract (16. * a));\n    else col4 = mix (lCol4.grba, col4, step (0.03, length (qHit.xz)));\n  } else if (idObj == idArm) {\n    col4 = mix (fCol4, gCol4, step (0.7, fract (8. * qHit.x)));\n  } else if (idObj == idSup) {\n    col4 = mix (fCol4, gCol4, step (0.7, fract (16. * qHit.y)));\n  } else if (idObj == idGard) {\n    col4 = mix (fCol4, gCol4, step (0.7, fract (64. * a)));\n  } else if (idObj == idAnt) {\n    col4 = vec4 (0.8, 0.8, 0.8, 0.2);\n  } else if (idObj == idSkd) {\n    col4 = vec4 (0.4, 0.4, 0.4, 0.05);\n  } else if (idObj == idCam) {\n    col4 = vec4 (0.1, 0.1, 0.1, 0.3);\n  } else if (idObj == idProp)  {\n    col4 = vec4 (0.9, 0.9, 1., 0.3) * (0.5 + 0.5 * step (0.5, fract (2. * abs (qHit.x))));\n  }\n  return col4;\n}\n\nfloat Ddot (vec2 p)\n{\n  return dot (p, p);\n}\n\nvec3 TruchSDist (vec2 p)\n{\n  vec2 pc, pc1, pc2, dp;\n  float d, d1, d2, cxy, rc, ac, s, ss;\n  bool ct;\n  ct = (cType == 2. || cType == 4.);\n  if (ct) {\n    pc1 = - vec2 (0., cDir);\n    pc2 = vec2 (sqrt3/2. * Ssign (p.x), 0.5 * cDir);\n    d1 = Ddot (p - pc1);\n    d2 = Ddot (p - pc2);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = 0.5;\n    d = abs (sqrt (d) - rc);\n  } else {\n    if (cDir != 0.) p = 0.5 * vec2 (p.x - cDir * sqrt3 * p.y, cDir * sqrt3 * p.x + p.y);\n    pc1 = vec2 (sqrt3/2. * Ssign (p.x), 0.);\n    pc2 = vec2 (sqrt3 * Ssign (p.x), 0.);\n    d1 = sqrt (Ddot (p - pc1));\n    d2 = abs (sqrt (Ddot (p - pc2)) - 1.5);\n    d = min (d1, d2);\n    pc = (d == d1) ? pc1 : pc2;\n    rc = (d == d1) ? 0.: 1.5;\n  }\n  dp = p - pc;\n  cxy = cIdB.x - cIdB.y;\n  s = (ct && cxy < 0. || ! ct && abs (cxy - 2.) == 1.) ? -1. : 1.;\n  ac = (0.5 - atan (dp.y, - dp.x) / (2. * pi)) * s;\n  if (! ct && abs (cxy - 2.) <= 1.) ac += 1./6.;\n  ss = Ssign (length (dp) - rc);\n  return vec3 (d * ss, rc * ss * s, ac);\n}\n\nbool OnTrk (vec2 w)\n{\n  vec2 wp, wm;\n  float cxy;\n  bool cyo, offTrk;\n  cxy = cIdB.x - cIdB.y;\n  cyo = (mod (cIdB.y, 2.) == 1.);\n  wm = Rot2Cs (w, sin (- pi / 3. + vec2 (0.5 * pi, 0.))) - vec2 (0., 0.3);\n  wp = Rot2Cs (w, sin (pi / 3. + vec2 (0.5 * pi, 0.)));\n  offTrk = (cxy == -2. && wm.y > 0. ||\n     ! cyo && (cxy == -3. && w.y > -0.3 || cxy == -2. || cxy == -1. && wm.y > 0. ||\n     cxy == 1. && wm.y < 0. || (cxy == 2. || cxy == 3.) && w.x < 0. || cxy == 4. || cxy == 5.) ||\n     cyo && (cxy == -3. || cxy == 0. && wp.x > 0. || (cxy == 1. || cxy == 2.) && w.x > 0. ||\n     cxy == 3. || cxy == 4. && wm.x < 0. || cxy == 5. && wm.y < 0.));\n     return ! offTrk;\n}\n\nvoid BConf ()\n{\n  float h, cxy;\n  cMidB = HexToPix (cIdB * hgSizeB);\n  h = Hashfv2 (cIdB);\n  if (Hashfv2 (17.11 * cIdB) > 0.4) {\n    cDir = floor (3. * h) - 1.;\n    cType = 3.;\n  } else {\n    cDir = 2. * floor (2. * h) - 1.;\n    cType = 4.;\n  }\n  cxy = cIdB.x - cIdB.y;\n  if (cxy == 0.) cType = 1.;\n  else if (abs (cxy) == 1.) cType = mod (cIdB.x, 2.) + 1.;\n  else if (cxy == -2. || cxy == -3. || cxy == 5.) cType = 2.;\n  else if (cxy == 2. || cxy == 3. || cxy == 4.) cType = 1.;\n  if (cType <= 2.) {\n    if (cType == 1. && (cxy == 1. || cxy == 2. || cxy == 3.)) cDir = 0.;\n    else if (cType == 1. && cxy == 4.) cDir = -1.;\n    else if (cType == 2. && cxy == 5.) cDir = 1.;\n    else cDir = 2. * mod (cIdB.x, 2.) - 1.;\n  }\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 q, cm3;\n  vec2 w;\n  float dMin, d;\n  dMin = dstFar;\n  if (cType > 0.) {\n    q = p;\n    d = q.y - 0.02;\n    DMIN (idGrnd);\n    w = (q.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (w);\n    if (cType <= 2. && cm3.y != 0. && OnTrk (w)) {\n      d = PrTorusBxDf (vec3 (hgSizeB * abs (cm3.x), q.y - 0.6, hgSizeB * HexEdgeDist (w)),\n         vec3 (pWid, 0.6, 0.2), 0.05);\n      DMIN (idFrm);\n    }\n  }\n  return dMin;\n}\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 1e-3;\n  if (rd.z == 0.) rd.z = 1e-3;\n  eps = 0.002;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeB / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeB;\n  dHit = 0.;\n  cIdB = PixToHex (ro.xz / hgSizeB);\n  pM = HexToPix (cIdB);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      BConf ();\n      cNu = false;\n    }\n    d = BObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdB = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeB);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdB = PixToHex (p.xz / hgSizeB);\n    if (cIdB != cIdP) {\n      cIdP = cIdB;\n      BConf ();\n    }\n    h = BObjDf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05 || d > 10.) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 BObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4;\n  vec3 col, cm3;\n  vec2 w;\n  float dt;\n  vf = vec2 (0.);\n  if (idObj == idGrnd) {\n    w = (ro.xz - cMidB) / hgSizeB;\n    cm3 = TruchSDist (w);\n    col = mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), 2. * Fbm2 (ro.xz));\n    vf = vec2 (8., 1.);\n    if (cType <= 2. && cm3.y != 0. && OnTrk (w)) {\n      dt = hgSizeB * abs (cm3.x);\n      col = mix (vec3 (0.6, 0.6, 0.5), col, smoothstep (0., 0.01, abs (dt - pWid) - 0.03));\n      if (dt < pWid) {\n        col = vec3 (0.5, 0.4, 0.2) * (1. - 0.1 * Noisefv2 (16. * ro.xz));\n        vf = vec2 (64., 0.2);\n      }\n    }\n    col4 = vec4 (col, 0.);\n  } else if (idObj == idFrm) {\n    col4 = (ro.y > 0.05) ? vec4 (0.8, 0.6, 0.2, -1.) : vec4 (0.7, 0.7, 0.8, 0.);\n  }\n  return col4;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, ff, fd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n     col = mix (vec3 (0.4, 0.5, 0.8) + 0.05, vec3 (0.3, 0.41, 0.65) + 0.07,\n        smoothstep (-0.02, 0.01, rd.y));\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((50. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.02, 0.05, rd.y));\n  }\n  return col;\n}\n\nvoid SConf ()\n{\n  vec2 r;\n  cMidS = HexToPix (cIdS * hgSizeS);\n  r = Hashv2v2 (73. * cIdS + 1.1);\n  tOff.xz = 0.26 * sqrt3 * hgSizeS * (0.5 + 0.5 * r.x) * CosSin (2. * pi * r.y );\n  tOff.y = r.x + r.y;\n}\n\nvoid SBConf (vec2 cIdBT, vec2 u)\n{\n  cIdB = cIdBT;\n  BConf ();\n  csOcc = (hgSizeB * abs (TruchSDist ((u - cMidB) / hgSizeB).x) < pWid + 0.4) ? 0. :\n     0.01 + 0.99 * Hashfv2 (17.11 * cIdS);\n}\n\nfloat SObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  if (csOcc > 0.) {\n    q = p;\n    q.xz = (q.xz - cMidS) / hgSizeS;\n    q.xz -= tOff.xz;\n    h = 0.15 + 0.15 * tOff.y;\n    q.y -= h;\n    d = PrCylDf (q.xzy, 0.05, h);\n    DMIN (idTrnk);\n    if (csOcc > 0.5) {\n      q.y -= h + 0.55;\n      d = PrConCapsDf (q.xzy, sin (0.085 * pi + vec2 (0.5 * pi, 0.)), 0.18, 0.4);\n    } else {\n      q.y -= h + 0.25;\n      d = SmoothMin (PrSphDf (q, 0.25), PrSphDf (vec3 (q.x, abs (q.y) - 0.25, q.z), 0.17), 0.2);\n    }\n    DMIN (idLvs);\n  }\n  return dMin;\n}\n\nfloat SObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv;\n  vec2 edN[3], pM, u, cIdBT;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 1e-3;\n  if (rd.z == 0.) rd.z = 1e-3;\n  eps = 0.002;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= Ssign (dot (edN[k], rd.xz));\n  vri = hgSizeS / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSizeS;\n  dHit = 0.;\n  cIdS = PixToHex (ro.xz / hgSizeS);\n  pM = HexToPix (cIdS);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    if (cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SConf ();\n    }\n    u = cMidS + tOff.xz;\n    cIdBT = PixToHex (u / hgSizeB);\n    if (cNu || cIdB != cIdBT) SBConf (cIdBT, u);\n    cNu = false;\n    d = SObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cIdS = PixToHex ((ro.xz + dHit * rd.xz) / hgSizeS);\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 SObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = SObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat SObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, u;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  cIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    cIdS = PixToHex (p.xz / hgSizeS);\n    if (cIdS != cIdP) {\n      cIdP = cIdS;\n      SConf ();\n    }\n    u = cMidS + tOff.xz;\n    SBConf (PixToHex (u / hgSizeB), u);\n    if (csOcc > 0.) {\n      h = SObjDf (p);\n      sh = min (sh, smoothstep (0., 0.1 * d, h));\n      d += h;\n    } else d += 0.1 * hgSizeS;\n    if (sh < 0.05 || d > 10.) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 SObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4;\n  if (idObj == idTrnk) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.1);\n    vf = vec2 (32., 1.);\n  } else if (idObj == idLvs) {\n    col4 = vec4 (HsvToRgb (vec3 (0.25 + 0.15 * csOcc, 0.7, 0.9)), 0.);\n    col4 = mix (col4, vec4 (0.9, 0.9, 0., 0.1), step (0.7, Fbm3 (64. * ro.xzy)));\n    vf = vec2 (16., 2.);\n  }\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec2 e, vf;\n  vec3 col, vn, qHitF;\n  float dstObj, dstObjB, dstObjS, dstObjFl, sh;\n  int idObjFl, idObjB, idObjS;\n  flSz = 0.12;\n  pWid = 0.7;\n  if (! flHide) {\n    dstObjFl = FlObjRay (ro, rd);\n    idObjFl = idObj;\n    qHitF = qHit;\n  } else dstObjFl = dstFar;\n  dstObjB = BObjRay (ro, rd);\n  idObjB = idObj;\n  dstObjS = SObjRay (ro, rd);\n  idObjS = idObj;\n  dstObj = dstFar;\n  if (min (min (dstObjB, dstObjS), dstObjFl) < dstFar) {\n    if (dstObjFl < min (dstObjB, dstObjS)) {\n      dstObj = dstObjFl;\n      idObj = idObjFl;\n    } else if (dstObjB < dstObjS) {\n      dstObj = dstObjB;\n      idObj = idObjB;\n    } else {\n      dstObj = dstObjS;\n      idObj = idObjS;\n    }\n    ro += dstObj * rd;\n    vf = vec2 (0.);\n    if (dstObj == dstObjFl) {\n      qHit = qHitF;\n      vn = FlObjNf (ro);\n      col4 = FlCol ();\n    } else if (dstObj == dstObjB) {\n      cIdB = PixToHex (ro.xz / hgSizeB);\n      BConf ();\n      vn = BObjNf (ro);\n      col4 = BObjCol (ro, vf);\n    } else if (dstObj == dstObjS) {\n      vn = SObjNf (ro);\n      col4 = SObjCol (ro, vf);\n    }\n    if (col4.a >= 0.) {\n      sh = min (FlObjSShadow (ro + 0.01 * vn, sunDir), BObjSShadow (ro + 0.01 * vn, sunDir));\n      sh = min (sh, SObjSShadow (ro + 0.01 * vn, sunDir));\n      if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    } else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n  } else if (rd.y < 0.) {\n    ro -= (ro.y / rd.y) * rd;\n    vn = vec3 (0., 1., 0.);\n    col = mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), 2. * Fbm2 (ro.xz)) *\n       (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    col = mix (col, 0.95 * vec3 (0.45, 0.55, 0.7), pow (1. + rd.y, 64.));\n  } else {\n    col = BgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float parmS)\n{\n  vec4 wgBx[2];\n  vec2 um;\n  float asp, s;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.45 * asp, -0.15, 0.012 * asp, 0.2);\n  wgBx[1] = vec4 (0.45 * asp, -0.45, 0.02, 0.);\n  um = 0.5 * uv - wgBx[0].xy;\n  s = Maxv2 (abs (um) - wgBx[0].zw);\n  if (abs (s) * canvas.y < 1. || s < 0. && mod (0.5 * ((0.5 * uv.y - wgBx[0].y) / wgBx[0].w -\n     0.99), 0.1) * canvas.y < 6.) col = vec3 (0.7);\n  col = mix (vec3 (1.), col, smoothstep (1.5, 3.5, abs (length (um - vec2 (0., (parmS - 0.5) *\n     2. * wgBx[0].w)) - 0.7 * wgBx[0].z) * canvas.y));\n  col = mix (vec3 (1.), col, smoothstep (1.2, 2.2, abs (length (0.5 * uv - wgBx[1].xy) -\n     wgBx[1].z) * canvas.y));\n  return col;\n}\n\n#define N_WIN 3\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 ro, rd, vd, col, vuPos, vuFarPos;\n  vec2 canvas, uv, us, mSize, ut[N_WIN], mMid[N_WIN], msw, g;\n  float zmFac, az, el, asp, sr, parmS, flPit, flDir, flRol, vuMode;\n  int vuId, vuIdS, regId, wgSel;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (1);\n  flPit = stDat.x;\n  flDir = stDat.y;\n  flRol = stDat.z;\n  parmS = stDat.w;\n  stDat = Loadv4 (2);\n  flPos = stDat.xyz;\n  stDat = Loadv4 (4);\n  vuPos = stDat.xyz;\n  vuMode = stDat.w;\n  stDat = Loadv4 (5);\n  vuFarPos = stDat.xyz;\n  hgSizeB = stDat.w;\n  flRol += 0.05 * smoothstep (0., 0.1, parmS) * pi * (Fbm1 (0.3 * tCur) - 0.5);\n  flMat = FlMat (flPit, flDir, flRol);\n  mSize = 0.2 * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (- asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  vuIdS = vuId;\n  vuId = int (mod (float (vuId) + vuMode, 4.));\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && wgSel < 0 && vuIdS == regId) {\n    az = 2. * pi * msw.x;\n    el = 0.5 * pi * msw.y;\n  }\n  hgSizeS = 1.;\n  dstFar = 300.;\n  flHide = false;\n  if (vuId == 0) {\n    ro = flPos;\n    az = - flDir;\n    el = 0.;\n    zmFac = 2.5;\n    flHide = true;\n  } else if (vuId == 1) {\n    ro = vuPos;\n    vd = normalize (flPos - ro);\n    az += atan (vd.z, - vd.x) - 0.5 * pi;\n    el += asin (vd.y);\n    zmFac = 6.;\n  } else if (vuId == 2) {\n    ro = vuFarPos;\n    vd = normalize (flPos - ro);\n    az = atan (vd.z, - vd.x) - 0.5 * pi;\n    el = asin (vd.y);\n    zmFac = 50.;\n  } else if (vuId == 3) {\n    ro = flPos;\n    ro.y += 4.;\n    az = - flDir;\n    el = -0.5 * pi;\n    zmFac = 1.5;\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (-0.5, 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.2 * pi * sin (0.01 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    if (vuId == 0 && parmS > 0.) rd.xy = Rot2D (rd.xy, flRol);\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 4.)\n       col = vec3 (0.8, 0.4, 0.);\n  }\n  if (vuIdS == 0) {\n    if (vuId == 0) {\n      col = mix (vec3 (1., 1., 0.5), col, 0.8 + 0.2 * smoothstep (0.002, 0.005,\n         PrBoxAn2Df (Rot2D (uv, flRol), vec2 (0.6, 0.3), 0.001)));\n      col = mix (vec3 (0.5, 1., 1.), col, 0.8 + 0.2 * smoothstep (0.002, 0.005,\n         PrBoxAn2Df (uv, vec2 (0.3, 0.15), 0.001)));\n    }\n    if (vuId == 1 && mPtr.z > 0. && wgSel < 0 && Maxv2 (abs (uv)) < 0.03 &&\n       Minv2 (abs (uv)) < 0.003) col = vec3 (0.8, 0.8, 0.1);\n    col = ShowWg (uv, canvas, col, parmS);\n    uv -= vec2 (0., -0.97) * vec2 (asp, 1.);\n    if (Maxv2 (abs (uv) - vec2 (0.22, 0.05)) < 0.) {\n      uv -= vec2 (0.06, -0.02);\n      us = vec2 (0.1, 0.06) * vec2 (asp, 1.);\n      g = floor (flPos.xz);\n      col = mix (mix (col, vec3 (0., 0., 1.), 0.2), vec3 (0., 1., 1.),\n         ShowInt (uv + vec2 (0.1, 0.), us, 5., g.x) + ShowInt (uv - vec2 (0.1, 0.), us, 5., g.y));\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  p = abs (p) - b;\n  return max (min (max (abs (p.x), w), max (abs (p.y), w)), max (max (p.x, p.y), w)) - w;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 FlMat (float pit, float yaw, float rol)\n{\n  vec3 ori, ca, sa;\n  ori = vec3 (pit, yaw, rol);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n         mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n         mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y , 0., ca.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (mod (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y),\n     2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Hexcopter Flying\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Ssign (float x);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 HexToPix (vec2 h);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define VAR_ZERO min (nFrame, 0)\n#define PLEN 17\n\nvec4 cPath[PLEN];\nfloat hgSizeB, tEnd[PLEN + 1], tLen;\n\nconst float txRow = 32.;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nvoid SetPath ()\n{\n  float ts, tl;\n  ts = 1.;\n  tl = 1.5;\n  cPath[ 0] = vec4 (0., 0., -1./6., tl);\n  cPath[ 1] = vec4 (1., 0., 1./3., - ts);\n  cPath[ 2] = vec4 (0., 1., 5./6., tl);\n  cPath[ 3] = vec4 (-1., 1., -1./3., ts);\n  cPath[ 4] = vec4 (-1., 2., 1., ts);\n  cPath[ 5] = vec4 (0., 1., - 1./6., tl);\n  cPath[ 6] = vec4 (1., 1., 1./6., tl);\n  cPath[ 7] = vec4 (1., 2., 1., ts);\n  cPath[ 8] = vec4 (2., 1., 1./2., - tl);\n  cPath[ 9] = vec4 (2., 0., -1./2., tl);\n  cPath[10] = vec4 (3., -1., -1./6., tl);\n  cPath[11] = vec4 (4., -1., 1./3., - ts);\n  cPath[12] = vec4 (3., 0., -1./2., - tl);\n  cPath[13] = vec4 (3., 1., 1./2., tl);\n  cPath[14] = vec4 (2., 2., 5./6., tl);\n  cPath[15] = vec4 (1., 2., -1./3., ts);\n  cPath[16] = vec4 (1., 3., 1., ts);\n  tEnd[0] = 0.;\n  for (int k = 0; k < PLEN; k ++) tEnd[k + 1] = tEnd[k] + abs (cPath[k].w);\n  tLen = tEnd[PLEN];\n}\n\nvec2 EvalPPos (float t)\n{\n  vec4 cp;\n  vec2 tp, vd;\n  float tt, r, a, dc;\n  t /= 3.;\n  tp = floor (t / tLen) * vec2 (2.);\n  t = mod (t, tLen);\n  for (int k = 0; k < PLEN; k ++) {\n    if (t >= tEnd[k] && t < tEnd[k + 1]) {\n      cp = cPath[k];\n      tt = 2. * (t - tEnd[k]) / (tEnd[k + 1] - tEnd[k]) - 1.;\n      break;\n    }\n  }\n  tp += cp.xy;\n  if (abs (cp.w) == 1.5) {\n    r = 1.5;\n    dc = sqrt3;\n    a = pi / 6.;\n    tt *= Ssign (cp.w);\n  } else {\n    r = 0.5;\n    dc = 1.;\n    a = - Ssign (cp.w) * pi / 3.;\n  }\n  vd = vec2 (-1., 1.) * sin (pi * cp.z + vec2 (0., 0.5 * pi));\n  return (HexToPix (tp) + dc * vd - r * Rot2Cs (vd, sin (tt * a + vec2 (0.5 * pi, 0.)))) * hgSizeB;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, tgPos, wgBx[2];\n  vec3 flPos, flVel, vuPos, vuFarPos, fp[3], va;\n  vec2 canvas, iFrag, ust;\n  float tCur, tCurP, flPit, flDir, flRol, dt, asp, s, spd, tsAccum, parmS, vuMode;\n  int nFrame, pxId, wgSel, wgReg;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 6) discard;\n  asp = canvas.x / canvas.y;\n  wgReg = -2;\n  if (nFrame <= 1) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    flPit = 0.;\n    flDir = 0.;\n    flRol = 0.;\n    parmS = 0.2;\n    flPos = vec3 (0., 1., 0.);\n    tsAccum = 0.;\n    flVel = vec3 (0.);\n    vuMode = 0.;\n    hgSizeB = 16.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    flPit = stDat.x;\n    flDir = stDat.y;\n    flRol = stDat.z;\n    parmS = stDat.w;\n    stDat = Loadv4 (2);\n    flPos = stDat.xyz;\n    tsAccum = stDat.w;\n    stDat = Loadv4 (3);\n    flVel = stDat.xyz;\n    tCurP = stDat.w;\n    stDat = Loadv4 (4);\n    vuPos = stDat.xyz;\n    vuMode = stDat.w;\n    stDat = Loadv4 (5);\n    vuFarPos = stDat.xyz;\n    hgSizeB = stDat.w;\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, -0.15, 0.012 * asp, 0.2);\n    wgBx[1] = vec4 (0.45 * asp, -0.45, 0.02, 0.);\n    ust = mPtr.xy * vec2 (asp, 1.);\n    if (Maxv2 (abs (ust - wgBx[0].xy) - wgBx[0].zw) < 0.) wgReg = 0;\n    if (length (ust - wgBx[1].xy) < wgBx[1].z) wgReg = 1;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    parmS = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n  } else if (wgSel == 1) {\n    if (mPtrP.z <= 0.) vuMode = mod (++ vuMode, 4.);\n  }\n  SetPath ();\n  spd = 3. * parmS;\n  tsAccum += (tCur - tCurP) * spd;\n  dt = max (0.3 * spd, 0.01);\n  fp[0] = vec3 (EvalPPos (tsAccum), 0.).xzy;\n  fp[1] = vec3 (EvalPPos (tsAccum + dt), 0.).xzy;\n  fp[2] = vec3 (EvalPPos (tsAccum - dt), 0.).xzy;\n  flPos.xz = fp[0].xz;\n  flPos.y = 0.8;\n  flVel = (fp[1] - fp[2]) / dt;\n  flPit = 0.1 * spd;\n  flDir = atan (flVel.z, flVel.x) - 0.5 * pi;\n  va = cross ((fp[1] - 2. * fp[0] + fp[2]) / (dt * dt), normalize (flVel));\n  flRol = 0.1 * length (va) * Ssign (va.y);\n  flRol = smoothstep (0.01, 0.03, abs (flRol)) * flRol * min (1., 0.5 * spd);\n  vuPos.xz = EvalPPos (tsAccum - 3.);\n  vuPos.y = 2.;\n  vuFarPos = vec3 (0., 20., (-1.5 * sqrt3 + (2. / tLen) * tsAccum) * hgSizeB);\n  vuFarPos.xz = Rot2D (vuFarPos.xz, - pi / 3.);\n  vuFarPos.x -= 1.5 * hgSizeB;\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = vec4 (flPit, flDir, flRol, parmS);\n  else if (pxId == 2) stDat = vec4 (flPos, tsAccum);\n  else if (pxId == 3) stDat = vec4 (flVel, tCur);\n  else if (pxId == 4) stDat = vec4 (vuPos, vuMode);\n  else if (pxId == 5) stDat = vec4 (vuFarPos, hgSizeB);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Ssign (float x)\n{\n  return (x != 0.) ? sign (x) : 1.;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKyR3.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[1740, 1740, 1764, 1764, 3734], [3736, 3736, 3771, 3771, 3957], [3959, 3959, 3982, 3982, 4240], [4242, 4242, 4281, 4281, 4522], [4524, 4524, 4539, 4539, 6311], [6313, 6313, 6334, 6334, 6357], [6359, 6359, 6385, 6385, 7373], [7375, 7375, 7396, 7396, 8042], [8044, 8044, 8059, 8059, 8768], [8770, 8770, 8793, 8793, 9210], [9212, 9212, 9246, 9246, 10411], [10413, 10413, 10435, 10435, 10692], [10694, 10694, 10732, 10732, 11132], [11134, 11134, 11171, 11171, 11908], [11910, 11910, 11941, 11941, 12616], [12618, 12618, 12633, 12633, 12821], [12823, 12823, 12857, 12857, 13015], [13017, 13017, 13040, 13040, 13579], [13581, 13581, 13615, 13615, 14898], [14900, 14900, 14922, 14922, 15179], [15181, 15181, 15219, 15219, 15746], [15748, 15748, 15785, 15785, 16116], [16118, 16118, 16153, 16153, 18103], [18105, 18105, 18164, 18164, 18838], [18857, 18857, 18913, 18913, 22972], [22974, 22974, 23020, 23020, 23067], [23069, 23069, 23113, 23113, 23224], [23226, 23226, 23259, 23259, 23286], [23288, 23288, 23330, 23330, 23381], [23383, 23383, 23440, 23440, 23516], [23518, 23518, 23573, 23573, 23839], [23841, 23841, 23887, 23887, 23968], [23970, 23970, 23993, 23993, 24031], [24033, 24033, 24055, 24055, 24082], [24084, 24084, 24106, 24106, 24133], [24135, 24135, 24157, 24157, 24195], [24197, 24197, 24242, 24242, 24334], [24336, 24336, 24366, 24366, 24479], [24481, 24481, 24512, 24512, 24576], [24578, 24578, 24624, 24624, 24901], [24903, 24903, 24939, 24939, 25145], [25147, 25147, 25171, 25171, 25401], [25403, 25403, 25427, 25427, 25487], [25489, 25489, 25517, 25517, 25597], [25599, 25599, 25623, 25623, 25740], [25742, 25742, 25765, 25765, 25869], [25942, 25942, 25974, 25974, 26522], [26524, 26524, 26584, 26584, 27126], [27160, 27160, 27184, 27184, 27259], [27261, 27261, 27285, 27285, 27338], [27340, 27340, 27364, 27364, 27491], [27493, 27493, 27517, 27517, 27680], [27682, 27682, 27707, 27707, 27853], [27855, 27855, 27880, 27880, 28064], [28066, 28066, 28091, 28091, 28316], [28318, 28318, 28340, 28340, 28494], [28496, 28496, 28517, 28517, 28672], [28674, 28674, 28695, 28695, 28850], [28852, 28852, 28881, 28881, 29093], [29095, 29095, 29134, 29134, 29386], [29479, 29479, 29504, 29504, 29627]], "test": "untested"}
{"id": "DdKcRc", "name": "async grid", "author": "FabriceNeyret2", "description": "inspiration: https://twitter.com/beesandbombs/status/1709240726469456317", "tags": ["short", "reproduction"], "likes": 24, "viewed": 350, "published": 3, "date": "1696406799", "time_retrieved": "2024-07-30T17:30:38.377133", "image_code": "#define S(v) smoothstep(17./R.y, 0., v)                     //\n#define C(v) S(length(F-.35*cos(A-v +vec2(0,33))) -.07)     //\n#define R    iResolution.xy\n\nvec4 grid(vec2 U){\n    vec2  I = round(U), F = U-I;\n    float A = 2.*iTime + 2.*sin(.2*iTime)*length(I),\n          a = atan(F.y,F.x) + A;     \n    return ( .6 + .6 * cos( 4.6+a  + vec4(0,23,21,0)  ) )\n        * max( S( abs( mod(a,6.28) -3.14 ) -2.1 ) , max( C(.9), C(-1.2) ) )\n        *      S( abs( length(F) - .35 ) -.07 );\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  U = 5. * ( u+u - R ) / R.y,\n          a = abs(U);\n    float r = max(a.x,a.y);\n    \n    vec4 A = grid(U)   * step(r,4.5),\n         B = grid(U+.5)* step(r,4. );\n    O = A.r > B.r ? A : B;\n // O = mix(A,B, smoothstep(-.1,.1,B.r-A.r));\n}\n\n\n\n\n\n/*  // --- 408 chars -  without round edges\n\n#define R    iResolution.xy//\n#define S(v) smoothstep(17./R.y, 0., v)\n\nvec4 grid(vec2 U){\n    vec2  I = round(U), F = U-I;\n    float a = atan(F.y,F.x) + 2.*iTime + 2.*sin(.2*iTime)*length(I);     \n    return ( .6 + .6 * cos( 4.6+a  + vec4(0,23,21,0)  ) )\n        * S( abs( mod(a,6.28) -3.14 ) -2.1 )\n        * S( abs( length(F) - .35 ) -.07 );\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  U = 5. * ( u+u - R ) / R.y,\n          a = abs(U);\n    float r = max(a.x,a.y);\n    \n    vec4 A = grid(U)   * step(r,4.5),\n         B = grid(U+.5)* step(r,4. );\n    O = A.r > B.r ? A : B;\n // O = mix(A,B, smoothstep(-.1,.1,B.r-A.r));\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdKcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 173, 173, 482], [484, 484, 522, 522, 766]], "test": "untested"}
{"id": "DsVcRc", "name": "Centred Hatch", "author": "spit1ire", "description": "Hatch", "tags": ["hatch"], "likes": 0, "viewed": 107, "published": 3, "date": "1696406711", "time_retrieved": "2024-07-30T17:30:39.136104", "image_code": "uniform bool showBrandIcon;\n\nconst float PI = 3.1415926535;\n\nconst float count = 4.0;\nconst float offset = 1.0 / count / 2.;\nconst float multiple = count * PI;\n\nfloat tWave(float x) {\n\treturn 1./PI*asin(sin(PI*x+PI/2.0))+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angleRad = iTime/50.;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord * 2.0 /iResolution.xy - 1.0;\n    \n    vec4 pixel = texture(iChannel0, uv);\n\n\tfloat rotatedX = sin(angleRad)*uv.x + cos(angleRad)*uv.y;\n\t//float wave = sin(rotatedX * multiple);\n    float wave = tWave(rotatedX * count);\n    \n    float animateWeight = sin(iTime/2.)/2.0+0.5;\n\n\tfloat hatch = step(0.3, wave);\n\n    // Output to screen\n    fragColor = vec4(vec3(hatch),1.0);\n    //fragColor = pixel;\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 183, 183, 226], [228, 228, 285, 285, 789]], "test": "untested"}
{"id": "DsVyz3", "name": "Simple 2D SDF smooth blending", "author": "TryAngle", "description": "very simple blending of two sdfs while coloring each", "tags": ["sdf"], "likes": 1, "viewed": 173, "published": 3, "date": "1696396187", "time_retrieved": "2024-07-30T17:30:39.881112", "image_code": "float circleSDF(vec2 p, vec2 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat boxSDF(vec2 p, vec2 center, vec2 size) {\n    vec2 d = abs(p - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n\nfloat smax(float a, float b, float k) {\n    return log(exp(k*a) + exp(k*b)) / k;\n}\n\nfloat smin(float a, float b, float k) {\n    return -smax(-a, -b, k);\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Calculate distances\n    float d1 = circleSDF(fragCoord, iMouse.xy, 20.0);\n    //if (d1 < 0.0) { fragColor = vec4(0.0, 1.0, 1.0, 1.0); }\n    float d2 = boxSDF(fragCoord, vec2(300, 300), vec2(200, 100));\n    //if (d2 < 0.0) { fragColor = vec4(1.0, 1.0, 0.0, 1.0); }\n    \n    // Compute smooth union\n    float smoothDist = smin(d1, d2, 0.1);\n    \n    // Define colors for each primitive and background\n    vec3 color1 = vec3(1.0, 0.0, 0.0); // Red for circle\n    vec3 color2 = vec3(0.0, 1.0, 0.0); // Green for box\n    vec3 bgColor = vec3(0.0); // Black for background\n    vec3 outlineColor = vec3(1.0, 1.0, 1.0); // White for outline\n\n\n    // Compute weights for color interpolation\n    float weight1 = 1.0 / (1.0 + exp(10.0 * d1)); // Adjust the multiplier as needed\n    float weight2 = 1.0 / (1.0 + exp(10.0 * d2)); // Adjust the multiplier as needed\n\n    // Normalize weights\n    float totalWeight = weight1 + weight2;\n    weight1 /= totalWeight;\n    weight2 /= totalWeight;\n\n    // antialiasing color mix\n    vec3 finalColor = mix( \n        weight1 * color1 + weight2 * color2,\n        bgColor,\n        smoothstep( -1.,1.,smoothDist/fwidth(smoothDist))\n    );\n    \n    // outline + antialiasing \n    float outlineWidth = 2.; \n    finalColor = mix(\n        outlineColor,\n        finalColor,\n        smoothstep( -1.,1.,( abs(smoothDist) - outlineWidth )/fwidth(smoothDist))\n    );\n\n\n\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DsVyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 94], [96, 96, 142, 142, 239], [242, 242, 281, 281, 324], [326, 326, 365, 365, 396], [403, 403, 460, 488, 1893]], "test": "untested"}
{"id": "ddyyR3", "name": "3d grapher", "author": "ArmandB", "description": "graphs stuff\nclick + drag to rotate", "tags": ["3d", "raymarching", "graph"], "likes": 9, "viewed": 317, "published": 3, "date": "1696387906", "time_retrieved": "2024-07-30T17:30:40.634099", "image_code": "/*\nchange eq() to change what you're graphing\n*/\nfloat eq(vec3 p){\n    return sin(p.x*2.0) + sin(p.y*2.0) + sin(p.z*2.0);\n}\n\n//increasing helps with equations with tigher turns, but increases other artifacts\nfloat fidelity = 1.0;\n//increase for more accurate renders (but more lag)\nint maxsteps = 1024;\n\n//estimate of partial derivative\nvec3 partialEstimate(vec3 p){\n    vec2 e = vec2(0,0.001);\n    return vec3(\n        eq(p + e.yxx) - eq(p - e.yxx),\n        eq(p + e.xyx) - eq(p - e.xyx),\n        eq(p + e.xxy) - eq(p - e.xxy)\n    )/(e.y*2.0);\n}\n\n//estimates distance to implicit function\n//https://iquilezles.org/articles/distance/\nfloat distEstimate(vec3 p){\n    return abs(eq(p))/length(partialEstimate(p));\n}\n\n//returns distance to hit point\nfloat castRay(Ray ray){\n    //set march start to bounding box\n    float t;\n    float t2;\n    boxIntersection(ray, vec3(-1), vec3(1), t, t2);\n    if (t == 1e20) return 1e20; //ray does not intersect with bounding box\n    ray.origin += ray.direction*t;\n    \n    //raymarch\n    for (int i = 0; i < maxsteps; i++){\n        float d = distEstimate(ray.origin);\n        d = d/(d + fidelity); //removes some artifacts as d gets bigger\n        if (d <= 1e-4) return t;\n        if (t >= t2) return 1e20; //ray has exited bounding box\n        if (i == 255) return t; //removes edge artifacts\n        ray.origin += ray.direction*d;\n        t += d;\n    }\n    return 1e20;\n}\n\n//draws a 3d line to the screen\nvoid drawLine(inout vec4 col, vec3 a, vec3 b, vec3 lineCol, Camera cam){\n    mat3 inverseRot = inverse(cam.rotmat);\n    a *= inverseRot;\n    b *= inverseRot;\n    \n    vec2 ab = b.xy - a.xy;\n    float t = dot(cam.uv - a.xy, ab)/dot(ab, ab);\n    vec2 p2 = a.xy + clamp(t,0.0,1.0)*ab;\n    float d = distance(cam.uv,p2);\n    \n    //if (mix(a.z,b.z,t) > col.a){\n    col.rgb = mix(lineCol, col.rgb, smoothstep(0.0, 0.005, d));\n    //}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam setup\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(1,-1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, rotation, 5.0);\n    Ray ray = cam.ray;\n    \n    vec4 col = vec4(0);\n    float t = castRay(ray);\n    col.a = t;\n    if (t < 1e20){\n        vec3 point = ray.direction*t + ray.origin;\n        vec3 normal = normalize(partialEstimate(point));\n        normal = faceforward(normal,ray.direction,normal);\n        col.rgb = mix(hsvToRgb(vec3(0.5,1.0,0.2)), hsvToRgb(vec3(0.3,0.9,1.0)), smoothstep(0.0,1.0,normal.y*0.5 + 0.5));\n    } else {\n        col.rgb = vec3(1);\n    }\n    \n    //bounding box & axis lines\n    drawLine(col, vec3(2,2,2), vec3(-2,2,2), vec3(0.4), cam);\n    drawLine(col, vec3(2,2,2), vec3(2,-2,2), vec3(0.4), cam);\n    drawLine(col, vec3(2,2,2), vec3(2,2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,-2,2), vec3(-2,2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,-2,2), vec3(2,-2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,-2,2), vec3(-2,-2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,-2,-2), vec3(-2,-2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,-2,-2), vec3(2,2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,-2,-2), vec3(2,-2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,2,-2), vec3(-2,-2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,2,-2), vec3(-2,2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,2,-2), vec3(2,2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,0,0), vec3(-2,0,0), vec3(1,0,0), cam);\n    drawLine(col, vec3(0,2,0), vec3(0,-2,0), vec3(0,1,0), cam);\n    drawLine(col, vec3(0,0,2), vec3(0,0,-2), vec3(0,0,1), cam);\n\n    // gamma correction\n    fragColor = vec4(pow(col.rgb,vec3(1.0/2.2)),1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    Ray ray;\n    mat3 rotmat;\n    vec2 res;\n    vec2 uv;\n};\n\n//fakes x^n for various effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n// https://iquilezles.org/articles/intersectors/\n// axis aligned box centered at the origin, with size boxSize\nvoid boxIntersection( Ray ray, vec3 aaa, vec3 bbb, out float t0, out float t1){\n    vec3 boxSize = abs(bbb - aaa);\n    vec3 m = 1.0/ray.direction; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ray.origin;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 h1 = -n - k;\n    vec3 h2 = -n + k;\n    float tN = max(max( h1.x, h1.y ), h1.z);\n    float tF = min(min( h2.x, h2.y ), h2.z);\n    if (tN > tF) { // no intersection\n        t0 = 1e20;\n        t1 = 1e20;\n        return;\n    }\n    t0 = min(tN, tF);\n    t1 = max(tN, tF);\n    return;\n}\n\nvec3 hsvToRgb(vec3 hsv){ //hsv.x = hue, hsv.y = saturation, hsv.z = value\n    vec3 col = vec3(hsv.x, hsv.x + 2.0/3.0, hsv.x + 4.0/3.0); //inputs for r, g, and b\n    col = clamp(abs(mod(col*2.0, 2.0)-1.0)*3.0 - 1.0, 0.0, 1.0)*hsv.z*hsv.y + hsv.z - hsv.z*hsv.y; //hue function (graph it on desmos)\n    return col;\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 camRot, float screensize){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, 0)*screensize;\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 rd = vec3(0,0,1)*rotmat;\n    vec3 ro = uv*rotmat - rd*100.0;\n    return Camera(Ray(ro, -rd), rotmat, resolution, uv.xy);\n}\n", "buffer_a_code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddyyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 66, 66, 123], [304, 337, 366, 366, 546], [548, 634, 661, 661, 713], [715, 747, 770, 808, 1407], [1409, 1441, 1513, 1513, 1871], [1873, 1873, 1930, 1946, 3634]], "test": "untested"}
{"id": "mdyczc", "name": "spqr domain trick", "author": "spqr", "description": "This uses a domain repetition trick where you take the minimum of the shape and the nearest lattice wall (plus a small epsilon). Blackle i think originated it, but this is (I think) a simpler implementation that was discussed in the discord.", "tags": ["a"], "likes": 7, "viewed": 177, "published": 3, "date": "1696387734", "time_retrieved": "2024-07-30T17:30:41.384093", "image_code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\n\n\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n\n  vec3 a =  \n  mix(\n      vec3(\n          hash11(mx)-.5,\n          hash11(my)-.5,\n          hash11(mz)-.5\n      ),\n      vec3(\n          hash11(nx)-.5,\n          hash11(ny)-.5,\n          hash11(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\n\nfloat map (vec3 p){\n\n\n   // geo\n   float tt = iTime;\n  \n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   float f1 = hash31(id);\n   \n   p.yx *= rot(f1 * 11.1 * ( sin(iTime)*.5+.5));\n   p.yz *= rot(f1 * 9.1 * ( sin(iTime)*.5+.5));\n  \n   float ball = cylcap(p, .03,.3);\n   float bound = closestWall(p);\n   \n   return min(bound + .03, ball);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float tt = iTime * 2.;\n\n  // nav\n  \n  vec3 s,t;\n  \n  s = lattice(tt*.1) * 18.;\n  t = lattice(tt *.1 + 2.) * 18.;\n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n\n  vec3 p=s;\n  float i=0.;\n  float dd = 0.;\n  float d;\n  \n  // march\n  \n  bool hit = false;\n  for(float z=0.; z < 500.; ++z) {\n    i = z;\n    d=map(p);\n    if(d<0.001) {\n      hit = true;\n      break;\n    }\n    if ( dd > 1000.) break;\n    dd += d;\n    p+=r*d;\n  }\n  \n\n  // color\n \n  vec3 n = norm(p);\n  vec3 light =normalize(vec3(0,1,-1));\n  float fresnel = pow(1.-dot(n, -r),1.)* .9 + .1;\n  float spec =pow(max(dot(reflect(-light,n),-r),0.),40.);\n  vec3 hue = vec3(1.);\n  vec3 col = hue  *  (fresnel + spec);\n\n  if ( ! hit ) {\n      col = vec3(.2,.2,.5);\n  }\n\n  fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 89], [93, 93, 135, 135, 242], [245, 245, 268, 268, 317], [319, 319, 344, 344, 819], [823, 823, 846, 846, 949], [952, 952, 979, 979, 1061], [1064, 1064, 1083, 1095, 1405], [1407, 1407, 1426, 1426, 1546], [1550, 1550, 1607, 1607, 2608]], "test": "untested"}
{"id": "mdGcR3", "name": "Polar Swirl", "author": "Lewie4", "description": "Experimenting with polar coordinates and voronoi", "tags": ["swirl", "loop", "polar"], "likes": 4, "viewed": 113, "published": 3, "date": "1696366827", "time_retrieved": "2024-07-30T17:30:42.140073", "image_code": "// Voronoi formula by iq - https://www.shadertoy.com/view/MslGD8\n\n#define TAU 6.28318530718\n\nvec2 hash( vec2 p )\n{\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\nvec2 voronoi(in vec2 x)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec3 m = vec3(8.,8.,8.);\n    for(int j=-1; j<=1; j++)\n        for(int i=-1; i<=1; i++)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = hash(n + g);\n            vec2 r = g - f + o;\n            float d = dot(r, r);\n            if(d<m.x)\n                m = vec3(d, o);\n        }\n\n    return vec2(sqrt(m.x), m.y+m.z );\n}\n\nvec2 toPolar(vec2 p)\n{\n    return vec2(atan(p.y, p.x)/TAU,length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = (fragCoord+fragCoord-iResolution.xy)/iResolution.y;\n    fragColor -= fragColor;\n    \n    vec2 offset = vec2(iTime * -.2, iTime * -.13);\n    vec2 p = toPolar(fragCoord);\n    p += offset;    \n    float a = voronoi(p).x;\n\n    p = toPolar(-fragCoord);\n    float l = smoothstep(.5, 0., distance(p.x, 0.));\n    p += offset;\n    float b = voronoi(p).x;\n\n    float c = mix(a, b, l);\n\n    c = pow(c, 3.);\n    float s = smoothstep(0., .22, c);\n\n    vec3 col = vec3(iTime + length(fragCoord) * 2.);\n    col += vec3(0.,1.,2.);\n    col = cos(col) + 1.9;\n    \n    fragColor = vec4(s * col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdGcR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 114, 114, 229], [231, 231, 256, 256, 655], [657, 657, 679, 679, 728], [730, 730, 787, 787, 1386]], "test": "untested"}
{"id": "mtjfRy", "name": "Magic circels", "author": "fifa_s", "description": "Simple but nice.", "tags": ["2d", "circles", "circle"], "likes": 3, "viewed": 154, "published": 3, "date": "1696362336", "time_retrieved": "2024-07-30T17:30:42.896051", "image_code": "void mainImage( out vec4 fragColor, in vec2 coord ) {\n    vec2 ruv = (coord-iResolution.xy*0.5)/min(iResolution.x,iResolution.y);\n    for (float i = 1.; i < 8.; i++) {\n        float d = smoothstep(.05,0.,abs(sin((length(fract(ruv*i)*2.-1.)-iTime*0.4)*5.)/5.));\n        fragColor.rgb = (fragColor.rgb+vec3(d*d*d,d*0.3,0.5*d))*1.2;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mtjfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 337]], "test": "untested"}
{"id": "csGyzc", "name": "Pretty ok post processing?", "author": "mrange", "description": "Post processing used in 'mrange & virgill - Delusions of mediocrity (Windows 4k intro)'", "tags": ["postproc"], "likes": 22, "viewed": 539, "published": 3, "date": "1696361698", "time_retrieved": "2024-07-30T17:30:43.646046", "image_code": "// CC0: Pretty ok post processing?\n// Virgill and I released 'mrange & virgill - Delusions of mediocrity (Windows 4k intro)' at Deadline 2023\n// https://www.youtube.com/watch?v=TgWmJAZIsXo\n\n// The work is a combination of Vertex and Fragment shader but AFAIK shadertoy has no vertex shading support\n// But I thought I share the post processing shader we used in the hope it helps someone.\n\n// Music by Virgill.\n\n// Shader being post processed by kishimisu: https://www.shadertoy.com/view/mtyGWy\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  vec3 col = texture(iChannel0, q).xyz;\n  fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// CC0: Pretty ok post processing?\n// Virgill and I released 'mrange & virgill - Delusions of mediocrity (Windows 4k intro)' at Deadline 2023\n// https://www.youtube.com/watch?v=TgWmJAZIsXo\n\n// The work is a combination of Vertex and Fragment shader but AFAIK shadertoy has no vertex shading support\n// But I thought I share the post processing shader we used in the hope it helps someone.\n\n// Music by Virgill.\n\n// Shader being post processed by kishimisu: https://www.shadertoy.com/view/mtyGWy\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n  return (1.0+cos(vec3(0.0, 1.0, 2.0)+TAU*t))*0.5;\n}\n\nvec3 effect(vec2 uv) {\n    float ltime = TIME*0.5;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + ltime*.4);\n\n        d = sin(d*8. + ltime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / max(d, 0.0005), 1.2);\n\n        finalColor += col * d;\n    }\n        \n    return finalColor;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Bunch of random tweaks to kishimisu's shader.\n  float ptime = TIME;\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float ntime = floor(ptime/12.0);\n  float h0 = hash(ntime+1234.5);\n  float h1 = fract(h0*3677.0);\n  float h2 = fract(h0*8677.0);\n\n  p *= mix(1.0, 0.5, h0*h0);\n  float a = 0.5*h2*(h1-0.5)*ptime;\n  p *= ROT(0.25*(h0-0.5)*ptime);\n  p -= vec2(h0, h1)-0.5;\n  if (h2 <  0.5) {\n    p =abs(p);\n  }\n  p *= ROT(a+sqrt(0.5)*sin(a)+h0*TAU);\n  vec3 col = effect(p);\n\n  col = 0.8*smoothstep(vec3(0.0), vec3(1.25, 1.5, 1.0), col);\n//  col = clamp(col, 0.0, 1.0);\n  col *= col;\n  \n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [{"id": 34842, "src": "https://soundcloud.com/virgill/delusions-of-mediocrity?si=b9dbd9fbdd99466aa5e619732633d4df&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// CC0: Pretty ok post processing?\n// Virgill and I released 'mrange & virgill - Delusions of mediocrity (Windows 4k intro)' at Deadline 2023\n// https://www.youtube.com/watch?v=TgWmJAZIsXo\n\n// The work is a combination of Vertex and Fragment shader but AFAIK shadertoy has no vertex shading support\n// But I thought I share the post processing shader we used in the hope it helps someone.\n\n// Music by Virgill.\n\n// Shader being post processed by kishimisu: https://www.shadertoy.com/view/mtyGWy\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PREV_PASS   iChannel0\n#define PREV_FRAME  iChannel1\n\n\nconst vec3\n  L = vec3(.2, 1., .114)\n, U = vec3(0.,1.,2.)\n;\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  // Used to map color valus in [0, Inf[ range to [0,1] range\n  v = max(v, 0.);\n  v *= .6;\n  const float a = 2.51 , b = .03 , c = 2.43 , d = .59 , e = .14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  float ptime = TIME;\n  float ntime = floor(ptime/12.0);\n  vec2 AA = 8.0/RESOLUTION.xy;\n  vec2 pp  = -1.+2.*q;\n  vec3 col = vec3(0.);\n  float ft0 = mod(ptime, 12.)-6.;\n  float ft = 6.-abs(ft0);\n  float pfade = smoothstep(6./8., 0., ft+.25*((pp.y*pp.x)+.5*pp.y)); \n\n  vec2 p = pp;\n  p.x *= AA.y/AA.x;\n\n  float eff = -1.0;\n  if (ntime == 3.0) {\n    eff = 0.0;\n  } else if (ntime == 5.0 || ntime == 7.0) {\n    eff = 0.5;\n  }\n\n  float pmul = 1.;\n  if (eff >= 0.) {\n    vec2 nnn  = vec2(sqrt(.5));\n    vec2 nn   = nnn.yx;\n    nn.y *= -1.0;\n    float off = ptime*.4 +dot(nn, p) + eff*sin(dot(nnn, p)+ptime);\n    pmul = smoothstep(0., 1., fract(off));\n    q += nn*.125*(1.-pmul);\n  }\n\n  vec3 pcol = pmul*texture(PREV_PASS,q).xyz;\n\n  pcol = mix(pcol + pfade*(2.+.25*U.yxz), pcol*(1.-pfade), .5+.5*sign(ft0)) ;\n\n  // \"CRT\" like line effect\n  // Not attempting to be accurate in anyway\n  pcol *= .75+.25*sin(TAU*(pp.y+U/3.)/AA.y);\n  pcol *= smoothstep(48., 42., abs(ptime-48.)+4.*length(p));\n\n  const int c = 4;\n\n  pp *= .975;\n  \n  vec2 pq = .5+.5*pp;\n\n  vec2 start = pq-float(c)*AA;\n  vec3 bcol = vec3(0); \n  for (int y = -c; y <= c; ++y) {\n    vec2 pp = start;\n    for (int x = -c; x <= c; ++x) {\n      vec3 fcol = texture(PREV_FRAME, pp).xyz;\n      bcol += fcol;\n      pp.x += AA.x;\n    }\n\n    start.y += AA.y;\n  }\n  \n  bcol /= float((2*c+1)*(2*c+1));\n  \n  col = pcol;\n  float l = dot(bcol, L);\n  col = aces_approx(col);\n  col += bcol*mix(vec3(.7, .5, .9), vec3(.6, .3, .4), l*l);\n  fragColor = vec4(col, 1);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 674, 729, 729, 844]], "test": "untested"}
{"id": "csycR3", "name": "Trance-Planet", "author": "ivaniceberg", "description": "Trance-Planet", "tags": ["tranceplanet"], "likes": 1, "viewed": 153, "published": 3, "date": "1696357932", "time_retrieved": "2024-07-30T17:30:44.397038", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csycR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]], "test": "untested"}
{"id": "dsVczK", "name": "Alt colour chromatic aboration", "author": "AnastasiaB", "description": "shader taht produces a chromatic aboration effect with colours other than your standard red green blue, with changable colours\nA generates a mask, B generates a new colour space, image moves that colour space and then remaps it back to image space", "tags": ["effect", "glitchy", "vhs"], "likes": 0, "viewed": 202, "published": 3, "date": "1696348475", "time_retrieved": "2024-07-30T17:30:45.165982", "image_code": "#define a1 1.\n#define a2 1.\n#define a3 -1.\n#define b1 -1.\n#define b2 1.\n#define b3 1.\n#define c1 1.\n#define c2 -1.\n#define c3 1.\n#define rpos ivec2(5,5)\n#define gpos ivec2(-6,2)\n#define bpos ivec2(7,-3)\n\n//these must be the inverse of the shit in buffer b\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nivec2 a= ivec2(fragCoord);\n   vec4 newcol = vec4(0,0,0,1);\n   float oldr = texelFetch(iChannel0,a+rpos,0).r*texelFetch(iChannel1,a+rpos,0).r;\n   float oldg = texelFetch(iChannel0,a+gpos,0).g*texelFetch(iChannel1,a+gpos,0).r;\n   float oldb = texelFetch(iChannel0,a+bpos,0).b*texelFetch(iChannel1,a+bpos,0).r;\n   newcol.r = oldr*a1 + oldg*b1 + oldb*c1;\n   newcol.g = oldr*a2 + oldg*b2 + oldb*c2;\n   newcol.b = oldr*a3 + oldg*b3 + oldb*c3;\n   newcol.rgb = newcol.rgb + texelFetch(iChannel2, a,0).rgb*(1.-texelFetch(iChannel1,a,0).r);\n   //newcol.r  = texelFetch(iChannel0,ivec2(fragCoord),0).r*a1 + texelFetch(iChannel0,ivec2(fragCoord),0).g*b1 + texelFetch(iChannel0,ivec2(fragCoord),0).b*c1;\n   //newcol.g  = texelFetch(iChannel0,ivec2(fragCoord),0).r*a2 + texelFetch(iChannel0,ivec2(fragCoord),0).g*b2 + texelFetch(iChannel0,ivec2(fragCoord),0).b*c2;\n   //newcol.b  = texelFetch(iChannel0,ivec2(fragCoord),0).r*a3 + texelFetch(iChannel0,ivec2(fragCoord),0).g*b3 + texelFetch(iChannel0,ivec2(fragCoord),0).b*c3;\nfragColor = newcol;\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define a1 0.5\n#define a2 0.\n#define a3 0.5\n#define b1 0.5\n#define b2 0.5\n#define b3 0.\n#define c1 0.\n#define c2 0.5\n#define c3 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 BaseC = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 NewC = vec4(a1*BaseC.r +b1*BaseC.g+ c1*BaseC.b,a2*BaseC.r +b2*BaseC.g+ c2*BaseC.b, a3*BaseC.r +b3*BaseC.g+ c3*BaseC.b,1.0);\n    fragColor = NewC;\n}", "buffer_b_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n //float BaseC = 0.;\n  float BaseC =  smoothstep(1.1,1.9, length(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb));\n    fragColor = vec4(BaseC,1.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsVczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 256, 313, 313, 1346]], "test": "untested"}
{"id": "DdVcRw", "name": "2d raytraced lighting", "author": "vainstains", "description": "Cool 2d raytraced lighting owo :3", "tags": ["2d", "raytracing", "raymarching", "lighting", "rainbow"], "likes": 17, "viewed": 505, "published": 3, "date": "1696342407", "time_retrieved": "2024-07-30T17:30:45.925950", "image_code": "// [Buffer A] : SDF texture\n// [Buffer B] : Accumulated raytraced image\n// [Image]    : Final image\n\n//   [Buffer A]\n//      |\n//      | +-------+\n//      | |       |\n//      V V       |\n//   [Buffer B]---+\n//       |\n//       V\n//    [Image]\n//\nvec2 pix(int x, int y)\n{\n    return vec2(x,y)/iResolution.xy;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 image = texture(iChannel0, uv);\n    fragColor = image / float(iFrame+1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ================\n// Pre-render SDF\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/(iResolution.y*2.0);\n    vec2 pos = uv*20.0;\n    vec2 dist = getDist(pos);\n    fragColor = vec4(pos, dist.x, dist.y);\n}", "buffer_a_inputs": [], "common_code": "// ================\n// World Data\n// ================\n#define TYPE_CIRCLE 0.0\n#define TYPE_RECT 1.0\n#define WORLD_COUNT 7\n#define WORLD_LENGTH WORLD_COUNT*9\n\n// object: { type, pos, (data), color }\n// data: { radius, unused } or { halfWidth, halfHeight }\nconst float[] world = float[]\n(\n    TYPE_CIRCLE,   -4.0, 4.0,   0.25, 0.0,   11.0, 1.0, 1.0,  0.0,\n    TYPE_CIRCLE,   0.0, 4.0,   0.25, 0.0,   1.0, 11.0, 1.0,  0.0,\n    TYPE_CIRCLE,   4.0, 4.0,   0.25, 0.0,   1.0, 1.0, 11.0,  0.0,\n    TYPE_RECT,   0.0, -5.0,   90.0, 2.0,   0.0,0.0,0.0,  1.0,\n    TYPE_CIRCLE,   -4.0, -1.0,   1.5, 0.0,   0.0, 0.0, 0.0,  1.0,\n    TYPE_CIRCLE,   0.0, -1.0,   1.5, 0.0,   0.0, 0.0, 0.0,  1.0,\n    TYPE_CIRCLE,   4.0, -1.0,   1.5, 0.0,   0.0, 0.0, 0.0,  1.0\n);\nvec4 getMat(float index)\n{\n    int i = int(floor(index+0.1));\n    return vec4(world[i+5], world[i+6], world[i+7], world[i+8]);\n}\nvec2 getSceneDist(vec2 p)\n{\n    float d = 99999.0;\n    float index = 0.0;\n    for(int i = 0; i < WORLD_LENGTH; i += 9)\n    {\n        float d1 = d;\n        if (world[i] == TYPE_CIRCLE)\n        {\n            vec2 rpos = vec2(world[i+1], world[i+2]);\n            \n            d1 = length(p - rpos)-world[i+3];\n        }\n        if (world[i] == TYPE_RECT)\n        {\n            vec2 rpos = vec2(world[i+1], world[i+2]);\n            vec2 rel1 = (p-rpos);\n            float mul = 1.0;\n            if (abs(rel1.x) >= world[i+3] || abs(rel1.y) >= world[i+4])\n            {\n                rel1.x = min(abs(rel1.x), world[i+3]) * sign(rel1.x);\n                rel1.y = min(abs(rel1.y), world[i+4]) * sign(rel1.y);\n            }\n            else\n            {\n                mul = -1.0;\n                vec2 dir = vec2(abs(rel1.x), abs(rel1.y));\n                float a = float(world[i+3] > world[i+4]);\n                float diff = max(world[i+3], world[i+4])-min(world[i+3], world[i+4]);\n                dir.x -= diff * a;\n                dir.y -= diff * (1.0-a);\n                if (dir.x > dir.y)\n                {\n                    rel1.x = world[i+3] * sign(rel1.x);\n                }\n                else\n                {\n                    rel1.y = world[i+4] * sign(rel1.y);\n                }\n            }\n            d1 = mul * length(p - (rel1+rpos));\n        }\n        if (d1 < d)\n        {\n            d = d1;\n            index = float(i);\n        }\n    }\n    return vec2(d, index);\n}\nvec2 getDist(vec2 p)\n{\n    vec2 pos = p;\n    return getSceneDist(pos);\n}", "buffer_b_code": "// ================\n// Raymarch\n// ================\nvec2 posToUv(vec2 pos)\n{\n    return ((pos/10.0)*iResolution.y+iResolution.xy*0.5)/iResolution.xy;\n}\nvec2 uvToPos(vec2 uv)\n{\n    return ((uv*iResolution.xy)-iResolution.xy*0.5)/(iResolution.y*2.0)*20.0;\n}\nvec2 getNormal(vec2 p)\n{\n    return normalize(vec2(\n                texture(iChannel0, posToUv(p+vec2(0.01,0.0))).z-texture(iChannel0, posToUv(p+vec2(-0.01,0.0))).z,\n                texture(iChannel0, posToUv(p+vec2(0.0,0.01))).z-texture(iChannel0, posToUv(p+vec2(0.0,-0.01))).z\n    ));\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy+iTime-iDate.w*0.001,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 randDir(vec2 pos)\n{\n    float r = rand(pos)*3.14159*2.0;\n    return vec2(cos(r),sin(r));\n}\nvec3 march(vec2 pos, vec2 dir)\n{\n    float prePenetration = 1.0;\n    vec2 d = dir;\n    vec2 p = pos;\n    vec3 addative = vec3(0);\n    if (texture(iChannel0, posToUv(pos)).z < 0.0001)\n    {\n        float depth = -texture(iChannel0, posToUv(pos)).z;\n        vec4 mat = getMat(texture(iChannel0, posToUv(pos)).w);\n        p += getNormal(pos) * depth;\n        prePenetration = ((depth*10.0)*(depth*10.0)+5.0)/(length(mat.xyz)+1.0);\n        addative = mat.xyz+vec3(0.03);\n    }\n    float[] dists = float[](0.0,0.0,0.0,0.0);\n    vec3[] hitColors = vec3[](vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0));\n    int hits = 0;\n    for(int i = 0; i < 200; i++)\n    {\n        vec4 sdfSample = texture(iChannel0, posToUv(p));\n        p += normalize(d) * sdfSample.z;\n        dists[hits] += sdfSample.z;\n        \n        if (sdfSample.z < 0.001)\n        {\n            vec4 mat = getMat(sdfSample.w);\n            hitColors[hits] = mat.xyz;\n            vec2 rd = randDir(p);\n            vec2 nrm = getNormal(p);\n            vec2 n = mix(reflect(d, nrm), rd*sign(dot(nrm, rd)), mat.w);\n            d = n;\n            p += d * 0.002 + n * 0.002;\n            sdfSample = texture(iChannel0, posToUv(p));\n            hits++;\n            if (hits == 4)\n            {\n                break;\n            }\n        }\n    }\n    vec3 light = vec3(0);\n    for(int i = hits; i >= 0; i--)\n    {\n        light += hitColors[i] / (pow(dists[i]*0.1+2.0, 2.0)*0.1);\n    }\n    if (texture(iChannel0, posToUv(pos)).z > 0.03)\n        light *= 0.6;\n    if (texture(iChannel0, posToUv(pos)).z < 0.03)\n        light *= 2.0;\n    return light/prePenetration + addative;\n}\nvec3 getSample(vec2 pos)\n{\n   return march(pos, randDir(pos))*0.5+march(pos, randDir(pos+1.0))*0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prev = texture(iChannel1, uv);\n    // Time varying pixel color\n    vec4 sdfSample = texture(iChannel0, uv);\n    vec2 sdfPos = sdfSample.xy;\n    float sdfDst = sdfSample.z;\n    fragColor = prev + vec4(getSample(sdfPos + 0.02 * vec2(rand(uv)*2.0-1.0, rand(uv+1.0)*2.0-1.0)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 246, 270, 270, 309], [310, 310, 367, 367, 491]], "test": "untested"}
{"id": "ddGyzK", "name": "palidas 002", "author": "palidas", "description": "im really high ", "tags": ["playingaround"], "likes": 1, "viewed": 108, "published": 3, "date": "1696310059", "time_retrieved": "2024-07-30T17:30:46.673951", "image_code": "vec3 palette( float t ) {\n  vec3 a = vec3(0.108, 0.500, 0.448);\n  vec3 b = vec3(-0.752, 0.588, -0.362);\n  vec3 c = vec3(-0.782, 0.838, 0.778);\n  vec3 d = vec3(-0.192, -0.300, 0.528);\n  \n  return a + b*cos( 6.28318*(c*t+d) );\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord * 6.0 - iResolution.xy) / iResolution.y;\n   \n   vec2 uv0 = uv;\n   \n   vec3 finalColor = vec3(0.0);\n   \n   for (float i = 0.0; i < 3.0; i++ ) {\n   uv = fract(uv * 4.0) - 1.5;\n   \n   float d = length(uv);\n   \n   vec3 col = palette(length(uv0) + iTime*.6);\n   \n   d = sin(d*8. + iTime)/8.;\n   d = abs(d);\n   \n   d = 0.02 / d;\n   \n   finalColor += col * d;\n   }\n   \n   \n   uv = fract(uv * 2.0) - 0.5;\n   \n   float d = length(uv);\n   \n   vec3 col = palette(length(uv0) + iTime);\n   \n   d = sin(d*8. + iTime)/8.;\n   d = abs(d);\n   \n   d = 0.02 / d;\n   \n   finalColor += col * d;\n\n   fragColor = vec4(finalColor, 1.0);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddGyzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 229], [231, 231, 288, 288, 931]], "test": "untested"}
{"id": "mlffzM", "name": "3D Bezier Curves with Capsules", "author": "tristanantonsen", "description": "Rendering 3D bezier curves by segmenting into line segments & rendering as capsules.", "tags": ["raymarching", "sdf"], "likes": 4, "viewed": 166, "published": 3, "date": "1696288192", "time_retrieved": "2024-07-30T17:30:47.430926", "image_code": "////////////////////////////////////////////////////////////////\n// Tristan Antonsen 2023\n////////////////////////////////////////////////////////////////\n// References\n// Distance functions & structure based on Inigo Quilez's (iq) shaders & functions https://iquilezles.org/\n// Ray marcher inspired by iq's work and The Art of Code's work (https://www.shadertoy.com/view/XlGBW3)\n\n// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n////////////////////////////////////////////////////////////////\n// Noise\n////////////////////////////////////////////////////////////////\n\n// Hash & voronoi from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// Main reference: https://iquilezles.org/articles/distfunctions/\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r)\n{\n    // Modified to account for the radius without changing the size of the box\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n////////////////////////////////////////////////////////////////\n// Bezier stuff\n////////////////////////////////////////////////////////////////\n\n\nvec3 bezier(vec3 p1, vec3 p2, vec3 p3, float t) {\n    \n    vec3 p12 = mix(p1, p2, t);\n    vec3 p23 = mix(p2, p3, t);\n    vec3 p123 = mix(p12, p23, t);\n    \n    \n    return p123;\n}\n\nfloat sdBezier3D(vec3 p, vec3 p1, vec3 p2, vec3 p3, float rad, float dt) {\n\n    float bez = 1e6;\n    for (float i = dt; i < 1.+dt; i += dt) {\n        \n        vec3 b0 = bezier(p1, p2, p3, max(i-dt, 0.));\n        vec3 b1 = bezier(p1, p2, p3, min(i, 1.));        \n        float seg = sdCapsule(p, b0, b1, rad);\n        \n        bez = opUnion(bez, seg);\n    }\n\n    return bez;\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU - PI);\n    //p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = rotY(po, iTime);\n\n    vec2 res;\n    vec3 pSym = vec3(abs(p.x), p.yz);\n    \n    vec3 p1 = vec3(-0.75, 0., 0.25*cos(iTime));\n    vec3 p2 = vec3(0., m.y, 0.);\n    vec3 p3 = vec3(0.75, 0., 0.25*sin(iTime));\n\n    \n    res.y = 1.0;\n    res.x = sdSphere(p, p1,0.1);\n    res.x = opUnion(res.x, sdSphere(p, p2,0.1));\n    res.x = opUnion(res.x, sdSphere(p, p3,0.1));\n    \n    \n    float dt = 0.05;\n    vec3 b0;\n    vec3 b1;\n    float bez = sdBezier3D(p, p1, p2, p3, 0.02, dt);\n    \n    if (bez < res.x) { res.y = 2.0; };\n    \n    res.x = opUnion(res.x, bez);\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 0., -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        if (d.y == 1.0) color = vec3(0.2,0.8,1.);\n        if (d.y == 2.0) color = vec3(0.9, 0.1, 0.1);\n        if (d.y == 3.0) color = vec3(0.8,0.,0.);\n        color *= illumination; \n        \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n         \n         \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n       \n        fragColor = vec4(color, 1.0);\n\n        \n    }\n\n        \n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mlffzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 736, 757, 757, 915], [916, 916, 943, 943, 1523], [1751, 1751, 1793, 1793, 1829], [1831, 1831, 1874, 1874, 1904], [1906, 1906, 1952, 1952, 2061], [2063, 2063, 2115, 2115, 2242], [2244, 2244, 2289, 2368, 2460], [2462, 2462, 2526, 2526, 2647], [2649, 2649, 2696, 2758, 3034], [3186, 3186, 3222, 3222, 3243], [3245, 3245, 3286, 3346, 3373], [3374, 3374, 3416, 3416, 3442], [3444, 3444, 3494, 3494, 3593], [3594, 3594, 3650, 3650, 3750], [3751, 3751, 3807, 3807, 3906], [4056, 4056, 4105, 4105, 4235], [4237, 4237, 4311, 4311, 4612], [4761, 4761, 4789, 4789, 4939], [4941, 4941, 4969, 4969, 5119], [5121, 5121, 5149, 5149, 5299], [5301, 5301, 5330, 5330, 5499], [5658, 5658, 5677, 5690, 6335], [6337, 6337, 6370, 6370, 6760], [6762, 6762, 6785, 6785, 7119], [7121, 7121, 7166, 7193, 7794], [7797, 7797, 7854, 7904, 9285]], "test": "untested"}
{"id": "msycWh", "name": "Highlight SDF on Click", "author": "tristanantonsen", "description": "Highlight SDF on Click. A little buggy but mostly works :)", "tags": ["raymarching", "sdf"], "likes": 6, "viewed": 192, "published": 3, "date": "1696288141", "time_retrieved": "2024-07-30T17:30:48.180921", "image_code": "////////////////////////////////////////////////////////////////\n// Tristan Antonsen 2023\n////////////////////////////////////////////////////////////////\n// References\n// Distance functions & structure based on Inigo Quilez's (iq) shaders & functions https://iquilezles.org/\n// Ray marcher inspired by iq's work and The Art of Code's work (https://www.shadertoy.com/view/XlGBW3)\n\n// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n////////////////////////////////////////////////////////////////\n// Noise\n////////////////////////////////////////////////////////////////\n\n// Hash & voronoi from iq: https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// Main reference: https://iquilezles.org/articles/distfunctions/\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 s, float r)\n{\n    // Modified to account for the radius without changing the size of the box\n    p = abs(p)-(s-r);\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU);\n    //p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nfloat body1(vec3 p) {\n    float f = 0.15;\n    float r = 0.1;\n    float R = 0.375;\n    \n    float d = sdSphere(p, vec3(0.45 * sin(f * iTime), 0.5 * cos(f * iTime + PI / 2.), 0.), R);\n    return d;\n}\n\nfloat body2(vec3 p) {\n    float f = 0.15;\n    float R = 0.375;\n    \n    vec3 center = p - vec3(0.45 * cos(f * iTime), 0.5 * sin(f * iTime), 0.);\n    center = rotY(center, 0.25 * iTime);\n    center = rotX(center, 0.25 * iTime);\n    \n    float d = sdRoundedBox(center, vec3(0.3), 0.05);\n    return d;\n}\n\nfloat body3(vec3 p) {\n    float f = 0.15;\n    float R = 0.375;\n    \n    vec3 center = p - vec3(0.5 * cos(f * iTime));\n    center = rotZ(center, 0.25 * iTime);\n    float d = sdRoundedCylinder(center, 0.125, 0.1, 0.5);\n    \n    return d;\n}\n\nvec2 map(vec3 p) {\n    vec2 res;\n    vec3 pSym = vec3(abs(p.x), p.yz);\n    \n    float r = 0.1;\n    \n    float s1 = body1(p);\n    res = vec2(s1, 0.0); // id to track color\n     \n    float s2 = body2(p);\n    if (s2 < res.x) { res.y = 1.0; };\n    res.x = opSmoothUnion(res.x, s2, r);\n\n    float s3 = body3(p);\n    if (s3 < res.x) { res.y = 2.0; };\n    \n    res.x = opSmoothUnion(res.x, s3, r);\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\nvec3 tripleGradient(float fac, float blend) {\n\n    vec3 c1 = vec3(1., 0., 0.);\n    vec3 c2 = vec3(0., 1., 0.);\n    vec3 c3 = vec3(0., 0., 1.);\n\n\n    \n    vec3 ca = mix(c1, c2, smoothstep(0.5 - blend, 0.5, fac));\n    vec3 cb = mix(c2, c3, smoothstep(0.5, 0.5 + blend, fac));\n    vec3 c = mix(ca, cb, smoothstep(0.5 - blend, 0.5 + blend, fac));\n    \n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0; // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 0., -10.02);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n    \n    // Casting a single ray\n    vec3 rdm = rayDirection(m, ro, rt);\n    vec3 dm = rayMarch(ro, rdm);\n    \n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        // re-calculation, might be a way to avoid this\n        float s1 = body1(p);\n        float s2 = body2(p);\n        float s3 = body3(p);\n        float sdfs[3] = float[3](s1, s2, s3);    \n        //\n        \n        color = vec3(0.,0.8,1.);\n        \n        float highlighted = sdfs[int(dm.y)];\n        \n        vec3 selectionColor = vec3(1., 0.9, 0.);\n        \n\n        if (iMouse.z > 0.0 && dm.x < 100.) {\n            color = mix(selectionColor, color, smoothstep(0., 0.1, highlighted));\n        };\n        \n        color *= illumination; \n        \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n        color += specular * 0.08;\n        \n        \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n       \n        fragColor = vec4(color, 1.0);\n\n        \n    }\n\n        \n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msycWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 736, 757, 757, 915], [916, 916, 943, 943, 1523], [1751, 1751, 1793, 1793, 1829], [1831, 1831, 1874, 1874, 1904], [1906, 1906, 1952, 1952, 2061], [2063, 2063, 2115, 2115, 2242], [2244, 2244, 2289, 2368, 2460], [2462, 2462, 2526, 2526, 2647], [2649, 2649, 2696, 2758, 3034], [3185, 3185, 3221, 3221, 3242], [3244, 3244, 3285, 3345, 3372], [3373, 3373, 3415, 3415, 3441], [3443, 3443, 3493, 3493, 3592], [3593, 3593, 3649, 3649, 3749], [3750, 3750, 3806, 3806, 3905], [4052, 4052, 4080, 4080, 4230], [4232, 4232, 4260, 4260, 4410], [4412, 4412, 4440, 4440, 4590], [4592, 4592, 4621, 4621, 4785], [4944, 4944, 4965, 4965, 5141], [5143, 5143, 5164, 5164, 5443], [5445, 5445, 5466, 5466, 5682], [5684, 5684, 5702, 5702, 6097], [6099, 6099, 6132, 6132, 6522], [6524, 6524, 6547, 6547, 6881], [6883, 6883, 6928, 6955, 7556], [7558, 7558, 7603, 7603, 7926], [7928, 7928, 7985, 7998, 9966]], "test": "untested"}
{"id": "ddycWW", "name": "web ready light font", "author": "User228", "description": "made a few changes to run it on three.js \nmakers comment:\nBedstead is one of my favorite fonts. It's the font used by the SAA50050 chip for the BBC Micro.", "tags": ["text", "bitmap", "font", "saa5050"], "likes": 1, "viewed": 144, "published": 3, "date": "1696273428", "time_retrieved": "2024-07-30T17:30:48.929918", "image_code": "const ivec2 char_space = ivec2(0, 0);\nconst ivec2 char_exclam = ivec2(-2147352576, 135274560);\nconst ivec2 char_quotedbl = ivec2(0, 338186240);\nconst ivec2 char_numbersign = ivec2(-494600192, 338229411);\nconst ivec2 char_dollar = ivec2(-2058944512, 475277538);\nconst ivec2 char_percent = ivec2(1179385856, 105660480);\nconst ivec2 char_ampersand = ivec2(-1572143104, 68429858);\nconst ivec2 char_quoteright = ivec2(0, 135270400);\nconst ivec2 char_parenleft = ivec2(1090781184, 269488160);\nconst ivec2 char_parenright = ivec2(16842752, 68173953);\nconst ivec2 char_asterisk = ivec2(-985530368, 139751489);\nconst ivec2 char_plus = ivec2(-2130706432, 1057264);\nconst ivec2 char_comma = ivec2(16908800, 0);\nconst ivec2 char_hyphen = ivec2(0, 224);\nconst ivec2 char_period = ivec2(131072, 0);\nconst ivec2 char_slash = ivec2(1077936128, 4210752);\nconst ivec2 char_zero = ivec2(578945024, 136874258);\nconst ivec2 char_one = ivec2(-2130247680, 135798848);\nconst ivec2 char_two = ivec2(1078951936, 474251456);\nconst ivec2 char_three = ivec2(71761920, 1044398274);\nconst ivec2 char_four = ivec2(-503054336, 271601811);\nconst ivec2 char_five = ivec2(71761920, 1040480514);\nconst ivec2 char_six = ivec2(608632832, 403179762);\nconst ivec2 char_seven = ivec2(1082195968, 1044398144);\nconst ivec2 char_eight = ivec2(608632832, 474253538);\nconst ivec2 char_nine = ivec2(33751040, 474253794);\nconst ivec2 char_colon = ivec2(131072, 8192);\nconst ivec2 char_semicolon = ivec2(16908800, 8192);\nconst ivec2 char_less = ivec2(1090781184, 269488144);\nconst ivec2 char_equal = ivec2(-536870912, 63491);\nconst ivec2 char_greater = ivec2(16842752, 68174081);\nconst ivec2 char_question = ivec2(-2147352576, 474234944);\nconst ivec2 char_at = ivec2(-1605959680, 474278227);\nconst ivec2 char_A = ivec2(-465010688, 136874259);\nconst ivec2 char_B = ivec2(608665600, 507807986);\nconst ivec2 char_C = ivec2(608632832, 474220560);\nconst ivec2 char_D = ivec2(608665600, 507808018);\nconst ivec2 char_E = ivec2(542081024, 1040451824);\nconst ivec2 char_F = ivec2(541097984, 1040451824);\nconst ivec2 char_G = ivec2(609157120, 474220563);\nconst ivec2 char_H = ivec2(608731136, 574917106);\nconst ivec2 char_I = ivec2(-2130247680, 470818880);\nconst ivec2 char_J = ivec2(71761920, 541098242);\nconst ivec2 char_K = ivec2(-1572306944, 572794928);\nconst ivec2 char_L = ivec2(542081024, 33818640);\nconst ivec2 char_M = ivec2(608731136, 577546578);\nconst ivec2 char_N = ivec2(608731136, 574921043);\nconst ivec2 char_O = ivec2(608632832, 474253586);\nconst ivec2 char_P = ivec2(541097984, 507807984);\nconst ivec2 char_Q = ivec2(-1572143104, 474253586);\nconst ivec2 char_R = ivec2(-1572306944, 507807984);\nconst ivec2 char_S = ivec2(71761920, 474220770);\nconst ivec2 char_T = ivec2(-2130575360, 1041244224);\nconst ivec2 char_U = ivec2(608632832, 574916882);\nconst ivec2 char_V = ivec2(1090650112, 574916769);\nconst ivec2 char_W = ivec2(-1522204672, 574916946);\nconst ivec2 char_X = ivec2(1145602048, 574902337);\nconst ivec2 char_Y = ivec2(-2130575360, 574902336);\nconst ivec2 char_Z = ivec2(1078951936, 1044398144);\nconst ivec2 char_bracketleft = ivec2(1083113472, 1007161376);\nconst ivec2 char_backslash = ivec2(67108864, 266305);\nconst ivec2 char_bracketright = ivec2(34045952, 505430145);\nconst ivec2 char_asciicircum = ivec2(0, 136873984);\nconst ivec2 char_underscore = ivec2(1015808, 0);\nconst ivec2 char_quotereversed = ivec2(0, 135282688);\nconst ivec2 char_a = ivec2(-1001455616, 28931);\nconst ivec2 char_b = ivec2(608665600, 33847570);\nconst ivec2 char_c = ivec2(542048256, 61456);\nconst ivec2 char_d = ivec2(609157120, 541126930);\nconst ivec2 char_e = ivec2(-532217856, 28947);\nconst ivec2 char_f = ivec2(-2130575360, 269492448);\nconst ivec2 char_g = ivec2(609161244, 61714);\nconst ivec2 char_h = ivec2(608731136, 33847570);\nconst ivec2 char_i = ivec2(-2130247680, 134230080);\nconst ivec2 char_j = ivec2(-2130574332, 134225984);\nconst ivec2 char_k = ivec2(-1031208960, 67670176);\nconst ivec2 char_l = ivec2(-2130247680, 202383424);\nconst ivec2 char_m = ivec2(-1521844224, 22866);\nconst ivec2 char_n = ivec2(608731136, 30994);\nconst ivec2 char_o = ivec2(608632832, 28946);\nconst ivec2 char_p = ivec2(608665858, 30994);\nconst ivec2 char_q = ivec2(609161248, 61714);\nconst ivec2 char_r = ivec2(1082195968, 53344);\nconst ivec2 char_s = ivec2(-1006141440, 61457);\nconst ivec2 char_t = ivec2(-2130444288, 135295040);\nconst ivec2 char_u = ivec2(609157120, 35090);\nconst ivec2 char_v = ivec2(1115815936, 35089);\nconst ivec2 char_w = ivec2(-1522204672, 35090);\nconst ivec2 char_x = ivec2(-2104983552, 34976);\nconst ivec2 char_y = ivec2(609161244, 35090);\nconst ivec2 char_z = ivec2(-2138079232, 63616);\nconst ivec2 char_braceleft = ivec2(-2129920000, 806363168);\nconst ivec2 char_brokenbar = ivec2(-2130575360, 135274496);\nconst ivec2 char_braceright = ivec2(-2130608128, 101720192);\nconst ivec2 char_asciitilde = ivec2(0, 72630272);\nconst ivec2 char_filledbox = ivec2(-405831680, 1048377843);\nconst ivec2 char_sterling = ivec2(1083146240, 407375984);\nconst ivec2 char_quotesingle = ivec2(0, 135274496);\nconst ivec2 char_arrowleft = ivec2(1090519040, 1053168);\nconst ivec2 char_onehalf = ivec2(-1543240648, 33818641);\nconst ivec2 char_arrowright = ivec2(16777216, 1065457);\nconst ivec2 char_arrowup = ivec2(-2130706432, 1077584);\nconst ivec2 char_emdash = ivec2(0, 496);\nconst ivec2 char_onequarter = ivec2(1175067680, 67637282);\nconst ivec2 char_dblverticalbar = ivec2(1116012544, 338186401);\nconst ivec2 char_threequarters = ivec2(1711938592, 101718082);\nconst ivec2 char_divide = ivec2(16777216, 1049072);\nconst ivec2 char_comma_saa5051 = ivec2(8454400, 0);\nconst ivec2 char_period_saa5051 = ivec2(25362432, 0);\nconst ivec2 char_colon_saa5051 = ivec2(65536, 32);\nconst ivec2 char_semicolon_saa5051 = ivec2(8454400, 4096);\nconst ivec2 char_section = ivec2(596119836, 474220770);\nconst ivec2 char_Adieresis = ivec2(-465010688, 335573267);\nconst ivec2 char_Odieresis = ivec2(608632832, 335573266);\nconst ivec2 char_Udieresis = ivec2(608632832, 335579410);\nconst ivec2 char_degree = ivec2(0, 407396352);\nconst ivec2 char_adieresis = ivec2(-1001455616, 335573251);\nconst ivec2 char_odieresis = ivec2(608632832, 2621666);\nconst ivec2 char_udieresis = ivec2(609157120, 2621714);\nconst ivec2 char_germandbls = ivec2(608600322, 203704530);\nconst ivec2 char_currency = ivec2(1133019136, 35041);\nconst ivec2 char_Eacute = ivec2(-531660800, 269547537);\nconst ivec2 char_D_saa5052 = ivec2(1149698048, 474517794);\nconst ivec2 char_L_saa5052 = ivec2(1083113472, 67637280);\nconst ivec2 char_Aring = ivec2(-465010688, 134246675);\nconst ivec2 char_eacute = ivec2(-532217856, 269512979);\nconst ivec2 char_aring = ivec2(-1001455616, 134246659);\nconst ivec2 char_ccedilla = ivec2(542050312, 61456);\nconst ivec2 char_ugrave = ivec2(609157120, 68192530);\nconst ivec2 char_agrave = ivec2(-1001455616, 68186371);\nconst ivec2 char_ograve = ivec2(608632832, 68157666);\nconst ivec2 char_egrave = ivec2(-532217856, 68186387);\nconst ivec2 char_igrave = ivec2(-2130247680, 68157536);\nconst ivec2 char_idieresis = ivec2(-2130247680, 335556672);\nconst ivec2 char_edieresis = ivec2(-532217856, 335573267);\nconst ivec2 char_ecircumflex = ivec2(-532217856, 136868115);\nconst ivec2 char_ugrave_saa5054 = ivec2(609157120, 136349970);\nconst ivec2 char_icircumflex = ivec2(-2130247680, 136839264);\nconst ivec2 char_acircumflex = ivec2(-1001455616, 136868099);\nconst ivec2 char_ocircumflex_saa5054 = ivec2(608632832, 136868114);\nconst ivec2 char_ucircumflex = ivec2(609157120, 136839442);\nconst ivec2 char_ccedilla_saa5054 = ivec2(542050328, 61456);\n\nivec2 text_box_chars = ivec2(62, 16);\n\nfloat draw_char(vec2 coord, ivec2 char) {\n    int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;\n    int num = pos_id < 32 ? char.x : char.y;\n    int val;\n\n    if (pos_id < 32) {\n        val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));\n    } else {\n        // Handle the case where pos_id is greater than or equal to 32\n        // by using a different bit manipulation technique.\n        int shifted_pos_id = pos_id - 32;\n        int pow_val = int(pow(2.0, float(shifted_pos_id)));\n        val = (num / pow_val);\n        val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1\n    }\n\n    float col = val == 0 ? 0.0 : 1.0;\n\n    return col;\n}\n\nvec3 draw_text(vec2 coord, vec2 pos) {\n    coord += pos;\n    coord *= 10.0;\n    int charIndex = int(coord.x);\n    coord.x -= float(int(coord.x));\n\n    ivec2 text_string_2[9];\n    ivec2 current_char = text_string_2[0]; // Initialize with a default character\n\n    if (charIndex == 1) current_char = ivec2(char_dollar);\n    else if (charIndex == 2) current_char = ivec2(char_E);\n    else if (charIndex == 3) current_char = ivec2(char_Z);\n    else if (charIndex == 4) current_char = ivec2(char_space);\n    else if (charIndex == 5) current_char = ivec2(char_T);\n    else if (charIndex == 6) current_char = ivec2(char_E);\n    else if (charIndex == 7) current_char = ivec2(char_X);\n    else if (charIndex == 8) current_char = ivec2(char_T);\n\n    // Calculate the color for the character and return it as a vec3.\n    return vec3(draw_char(coord, current_char));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = vec2(0.0, 0.0);\n    \n    // Get the text color by calling draw_text\n    vec3 col = draw_text(uv, pos);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ddycWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7597, 7597, 7638, 7638, 8267], [8269, 8269, 8307, 8307, 9124], [9126, 9126, 9181, 9232, 9451]], "test": "untested"}
{"id": "csVyzy", "name": "l'enveloppe", "author": "NinjaKoala", "description": "PC 4k intro for Linux released at Deadline 2023\nPouet: https://www.pouet.net/prod.php?which=95215", "tags": ["2d", "intro", "demoscene", "deadline2023"], "likes": 18, "viewed": 300, "published": 3, "date": "1696266220", "time_retrieved": "2024-07-30T17:30:49.687892", "image_code": "vec2 p0;\nvec2 p1;\nvec2 p2;\nvec2 p3;\n\nvec2 q0;\nvec2 q1;\nvec2 q2;\nvec2 q3;\n\nfloat spb;\nfloat spm;\n\nfloat eventm3;\nfloat eventm2;\nfloat eventm1;\nfloat event0;\nfloat event0p5;\nfloat event1;\nfloat event1p5;\nfloat event2;\nfloat event2p3;\nfloat event2p5;\nfloat event2p6;\nfloat event2p7;\nfloat event3;\nfloat event3p5;\nfloat event4;\nfloat event4p2;\nfloat event4p3;\nfloat event4p4;\nfloat event4p5;\nfloat event4p6;\nfloat event4p7;\nfloat event5;\nfloat event5p5;\nfloat event6;\nfloat event6p5;\nfloat event7;\nfloat event8;\nfloat event8p5;\nfloat event9;\nfloat event10;\nfloat event11;\nfloat event11p5;\nfloat event12;\nfloat event13;\nfloat event14;\nfloat event15;\nfloat event16;\nfloat event17;\nfloat event18;\nfloat event19;\nfloat event20;\n\nfloat pi = 3.1416;\n\nfloat rad = .4;\nfloat big = 1e6;\n\nvec3 col1 = vec3(.85,.3,.2);\nvec3 col2 = vec3(.2,.5,.2);\nvec3 col3 = vec3(.1,.4,.4);\n\nvec4 random_curve[] = vec4[](vec4(-5./14., 11./70., 17./80., 25./66.), vec4(-13./61., 33./89., -2./51., -3./92.), vec4(-15./56., -1./4., 1./63., 4./19.));\n\nmat2 rot(float deg){\n\treturn mat2(cos(deg),sin(deg),-sin(deg),cos(deg));\n}\n\nfloat beat_time(float t){\n\tfloat a = 2.*pi / spb;\n\treturn t + sin(a*t)/a;\n}\n\nvec2 cubic_bezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t){\n\treturn mix(mix(mix(p0,p1,t),mix(p1,p2,t),t),mix(mix(p1,p2,t),mix(p2,p3,t),t),t);\n}\n\nvec2 cubic_bezier_diff(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t){\n\treturn mix(mix(p1,p2,t),mix(p2,p3,t),t)-mix(mix(p0,p1,t),mix(p1,p2,t),t);\n}\n\n\n\nvec2 parametric(float t, float curve){\n\tif(curve == 4.){\n\t\tif(t < .5){\n\t\t\treturn cubic_bezier(p0,p1,p2,p3,2.*t);\n\t\t}\n\t\treturn cubic_bezier(q0,q1,q2,q3,2.*t-1.);\n\t}\n\n\tt *= 2.*pi;\n\n\tif(curve == 0.){\n\t\treturn rad*vec2(sin(t),cos(t));\n\t}\n\tif(curve == 1.){\n\t\tt*=.5;\n\t\treturn rad*cos(3.*t)*vec2(sin(t),cos(t));\n\t}\n\tif(curve == 2.){\n\t\treturn .4*rad*vec2(2.*cos(t)+cos(2.*t),-2.*sin(t)+sin(2.*t)).yx-vec2(0.,.12);\n\t}\n\tif(curve == 3.){\n\t\treturn 1.2*rad*t*vec2(sin(3.*t),cos(3.*t))/2./pi;\n\t}\n\tif(curve == 5.){\n\t\tvec2 val=vec2(0);\n\t\tfor(int i=1;i<4;i++){\n\t\t\tval += random_curve[i-1].xz * cos(float(i)*t) / float(i);\n\t\t\tval += random_curve[i-1].yw * sin(float(i)*t) / float(i);\n\t\t}\n\n\t\treturn val;\n\t}\n}\n\nvec2 parametric_diff(float t, float curve){\n\tif(curve == 4.){\n\t\tif(t < .5){\n\t\t\treturn 2.*cubic_bezier_diff(p0,p1,p2,p3,2.*t);\n\t\t}\n\t\treturn 2.*cubic_bezier_diff(q0,q1,q2,q3,2.*t-1.);\n\t}\n\n\tt *= 2.*pi;\n\t\n\tif(curve == 0.){\n\t\treturn 2.*pi*rad*vec2(cos(t),-sin(t));\n\t}\n\tif(curve == 1.){\n\t\tt*=.5;\n\t\treturn rad*2.*pi*vec2(cos(3.*t)*cos(t) - 3.*sin(3.*t)*sin(t),-3.*cos(t)*sin(3.*t) - cos(3.*t)*sin(t));\n\t}\n\tif(curve == 2.){\n\t\tif(abs(t) < 1./big){\n\t\t\treturn vec2(0,1);\n\t\t}\n\t\treturn .4*rad*4.*pi*vec2(-sin(t)-sin(2.*t),-cos(t)+cos(2.*t)).yx;\n\t}\n\tif(curve == 3.){\n\t\treturn 1.2*rad*vec2(3.*t*cos(3.*t) + sin(3.*t),-3.*t*sin(3.*t) + cos(3.*t));\n\t}\n\tif(curve == 5.){\n\t\tvec2 val = vec2(0);\n\t\tfor(int i=1;i<4;i++){\n\t\t\tval += float(i) * random_curve[i-1].yw * cos(float(i)*t) / float(i);\n\t\t\tval -= float(i) * random_curve[i-1].xz * sin(float(i)*t) / float(i);\n\t\t}\n\t\treturn pi*val;\n\t}\n}\n\nvec3 get_normal(float t, float curve){\n\tvec2 p0 = parametric(t,curve);\n\tvec2 tang = normalize(parametric_diff(t,curve));\n\n\treturn vec3(tang,-dot(tang,p0));\n}\n\nvec3 get_tangent(float t, float curve){\n\tvec2 p0 = parametric(t,curve);\n\tvec2 tang = parametric_diff(t,curve);\n\tvec2 nor = normalize(vec2(tang.y,-tang.x));\n\n\treturn vec3(nor,-dot(nor,p0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p0=vec2(-.5*iResolution.x/iResolution.y,.4);\n    p1=vec2(-.3,.2);\n    p2=vec2(.2,-.1);\n    p3=vec2(.0,-.5);\n\n    q0=vec2(.5*iResolution.x/iResolution.y,-.2);\n    q1=vec2(.4,-.1);\n    q2=vec2(.8,.2);\n    q3=vec2(.3,.5);\n\n\tspb = 60. / 130.;\n\tspm = 4. * spb ;\n\n\teventm3=0.;\n\teventm2=eventm3+1.*spb;\n\teventm1=eventm2+7.*spb;\n\tevent0=eventm1+7.*spb;\n\tevent0p5=event0+1.*spb;\n\tevent1=event0+5.*spb;\n\tevent1p5=event0+6.*spb;\n\tevent2=event1+4.*spb;\n\tevent2p3=event2+2.*spb;\n\tevent2p5=event2+4.*spb;\n\tevent2p6=event2+6.*spb;\n\tevent2p7=event2+8.*spb;\n\tevent3=event2+10.*spb;\n\tevent3p5=event3+1.*spb;\n\tevent4=event3+3.*spb;\n\tevent4p2=event3+10.*spb;\n\tevent4p3=event3+12.*spb;\n\tevent4p4=event3+22.*spb;\n\tevent4p5=event3+24.*spb;\n\tevent4p6=event3+28.*spb;\n\tevent4p7=event3+30.*spb;\n\tevent5=event4+26.*spb;\n\tevent5p5=event5+1.*spb;\n\tevent6=event5+3.*spb;\n\tevent6p5=event6+2.*spb;\n\tevent7=event6+8.*spb;\n\tevent8=event7+16.*spb;\n\tevent8p5=event8+1.*spb;\n\tevent9=event8+21.*spb;\n\tevent10=event9+20.*spb;\n\tevent11=event10+20.*spb;\n\tevent11p5=event11+1.*spb;\n\tevent12=event11+3.*spb;\n\tevent13=event12+2.*spb;\n\tevent14=event13+20.*spb;\n\tevent15=event14+2.*spb;\n\tevent16=event15+2.*spb;\n\tevent17=event16+18.*spb;\n\tevent18=event17+0.*spb;\n\tevent19=event18+8.*spb;\n\tevent20=96.;\n\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tuv -=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat border = 1./iResolution.y;\n\tfloat dis = big;\n\tfloat curve, speed, lb, ub, radius, stepsize, zoom, thickness, deg;\n\n\tvec3 bg_col = vec3(.11);\n\n\tvec3 col = bg_col;\n\tvec3 line_col;\n\n\tvec2 mid;\n\n\tcurve = 0.;\n\tstepsize = .01;\n\tmid = vec2(0);\n\tradius = 1.;\n\tlb = 0.;\n\tub = 0.;\n\tspeed = 0.;\n\tzoom = 1.;\n\tthickness = .001;\n\tdeg = 0.;\n\n\tif(iTime < event20){\n\t\tstepsize = .001;\n\t\tcurve = 5.;\n\t\tub = .69-clamp((iTime-event15)/(event17-event15),0.,.69);\n\t\tub = .47-ub*ub;\n\n\t\tfloat lb_offset = .1;\n\n\t\tlb = clamp(ub - lb_offset,0.,1.);\n\n\t}\n\tif(iTime < event14){\n\t\tub = (iTime-event11)/(event14-event11)*.7;\n\n\t\tfloat lb_offset = mix(0.,.1,clamp((iTime-event11p5)/(event12-event11p5),0.,1.));\n\t\tlb_offset = mix(lb_offset,0.,clamp((iTime-event13)/(event14-event13),0.,1.));\n\n\t\tlb = clamp(ub - lb_offset,0.,1.);\n\t}\n\tif(iTime < event11){\n\t\tcurve = 1.;\n\t\tzoom = .5;\n\t\tstepsize = .01;\n\n\t\tlb = floor(smoothstep(event10,event11,iTime)/stepsize)*stepsize;\n\t\tub = smoothstep(event8p5,event9,iTime);\n\n\t\tmid = -parametric(ub,curve);\n\n\t\tvec2 nor = get_tangent(ub,curve).xy;\n\t\tvec2 tang = get_normal(ub,curve).xy;\n\n\t\tspeed = 0.;\n\n\t\tif(iTime > event9){\n\t\t\tspeed = -2.*stepsize;\n\t\t}\n\t\tub *= (1.-stepsize);\n\t}\n\tif(iTime < event8){\n\t\tmid = vec2(0);\n\t\tcurve = 2.;\n\t\tradius = 1000.;\n\t\tlb = 0.;\n\t\tub = smoothstep(event5p5,event6,iTime) * (1. - stepsize);\n\t\tfloat pulse = .4*sin(beat_time(iTime-event5p5)*2.*pi);\n\t\tzoom = 1.;\n\t\tspeed = 0.;\n\t\tif(iTime > event6){\n\t\t\tzoom = 1. - pulse;\n\t\t}\n\t\tif(iTime > event7){\n\t\t\tlb = floor(smoothstep(event7,event8,iTime)/stepsize)*stepsize;\n\t\t}\n\t}\n\tif(iTime < event5){\n\t\tcurve = 1.;\n\t\tradius = 1.;\n\t\tlb = floor(smoothstep(event4p6,event4p7,iTime)/stepsize)*stepsize;\n\t\tub = smoothstep(event3p5,event4,iTime) * (1. - stepsize);\n\t\tspeed = -2.*stepsize;\n\t\tmid = mix(vec2(.5,0),vec2(-.3,-.1),smoothstep(event4p2,event4p3,iTime));\n\t\tzoom = mix(1.,.6,smoothstep(event4p2,event4p3,iTime));\n\t\tdeg = mix(0.,pi/3.,smoothstep(event4p2,event4p3,iTime));\n\t\tmid = mix(mid,vec2(-.6,.4),smoothstep(event4p4,event4p5,iTime));\n\t\tzoom = mix(zoom,1.2,smoothstep(event4p4,event4p5,iTime));\n\t\tdeg = mix(deg,pi*2./3.,smoothstep(event4p4,event4p5,iTime));\n\t}\n\tif(iTime < event3){\n\t\tdeg = 0.;\n\t\tstepsize = .005;\n\t\tzoom = .3;\n\t\tmid = vec2(-.1,.1);\n\t\tcurve = 3.;\n\t\tlb = floor(smoothstep(event2p7,event3,iTime)/stepsize)*stepsize;\n\t\tub = 1.;\n\t\tspeed = 0.;\n\t}\n\tif(iTime < event2p7){\n\t\tzoom = .3;\n\t\tlb = 0.;\n\t\tub = smoothstep(event2p6,event2p7,iTime);\n\t}\n\tif(iTime < event2p6){\n\t\tstepsize = .008;\n\t\tzoom = .5;\n\t\tmid = vec2(.2,.2);\n\t\tlb = floor(smoothstep(event2p5,event2p6,iTime)/stepsize)*stepsize;\n\t\tub = 1.;\n\t}\n\tif(iTime < event2p5){\n\t\tlb = 0.;\n\t\tub = smoothstep(event2p3,event2p5,iTime);\n\t}\n\tif(iTime < event2p3){\n\t\tstepsize = .01;\n\t\tzoom = 1.;\n\t\tmid = vec2(0);\n\t\tlb = floor(smoothstep(event2,event2p3,iTime)/stepsize)*stepsize;\n\t\tub = 1.;\n\t}\n\tif(iTime < event2){\n\t\tlb = 0.;\n\t\tub = smoothstep(event1p5,event2,iTime);\n\t}\n\tif(iTime < event1p5){\n\t\tcurve = 0.;\n\t\tlb = 0.;\n\t\tub = 1. - stepsize;\n\t\tzoom = mix(1.,.3,smoothstep(event1,event1p5,iTime));\n\t}\n\tif(iTime < event1){\n\t\tzoom = 1.;\n\t\tlb = 0.;\n\t\tub = smoothstep(event0p5,event1,iTime)*(1. - stepsize);\n\t}\n\tif(iTime < event0){\n\t\tcurve = 4.;\n\t\tlb = floor(smoothstep(eventm1,event0,iTime)/stepsize)*stepsize;\n\t\tub = 1.;\n\t}\n\tif(iTime < eventm1){\n\t\tlb = 0.;\n\t\tub = smoothstep(eventm2,eventm1,iTime);\n\t}\n\n\tborder *= zoom;\n\tuv *= zoom;\n\tuv -= mid;\n\n\tfor(float t=lb;t<ub;t+=stepsize){\n\t\tfloat tt = t+beat_time(iTime)*speed;\n\n\t\tvec2 p0 = parametric(tt,curve) * rot(deg);\n\t\tvec3 tang = get_tangent(tt,curve);\n\t\tvec3 nor = get_normal(tt,curve);\n\n\t\ttang.xy *= rot(deg);\n\t\tnor.xy *= rot(deg);\n\n\t\tdis = abs(length(p0+tang.xy*radius-uv)-radius)-thickness;\n\n\t\tfloat nor_dis = dot(vec3(uv,1),nor);\n\t\tline_col = mix(col1,mix(col2,col3,sign(nor_dis)*.5+.5),abs(nor_dis*2.));\n\n\t\tcol = mix(line_col,col,.5+.5*smoothstep(-border,border,dis));\n\n\t}\n\n\tcol = mix(col,bg_col,smoothstep(event18,event19,iTime));\n\n\tfragColor  = vec4(col,1);\n}\n", "image_inputs": [{"id": 34836, "src": "https://soundcloud.com/user-843867424/lenveloppe", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csVyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1017, 1017, 1037, 1037, 1091], [1093, 1093, 1118, 1118, 1168], [1170, 1170, 1233, 1233, 1317], [1319, 1319, 1387, 1387, 1464], [1468, 1468, 1506, 1506, 2157], [2159, 2159, 2202, 2202, 3027], [3029, 3029, 3067, 3067, 3186], [3188, 3188, 3227, 3227, 3378], [3380, 3380, 3437, 3437, 8736]], "test": "untested"}
{"id": "msyczy", "name": "domain warping", "author": "01000001", "description": "woah that's surprisingly easy", "tags": ["warp"], "likes": 6, "viewed": 257, "published": 3, "date": "1696258702", "time_retrieved": "2024-07-30T17:30:50.464814", "image_code": "#define s(x) smoothstep(0., 1., x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 10.;\n    \n    \n    float s = mod(iTime*.2, 3.);\n    \n    for (float i = 0.; i++<16.;){\n        \n        float b = 0.;\n        float a = i;\n        a = mix(a, i*i, s(s-b++));\n        a = mix(a, i, s(s-b++));\n        a = mix(a, sqrt(i), s(s-b++));\n        \n    \n        uv.x += sin(uv.y*a)/i;\n        uv.y += sin(uv.x*a)/i;\n\n    }\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msyczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 93, 143, 660]], "test": "untested"}
{"id": "mdyyzy", "name": "Infinite Jumpy Dumpty", "author": "alphardex", "description": "Unlimited bomb works!\nKlee must be happy :)", "tags": ["raymarching"], "likes": 7, "viewed": 274, "published": 3, "date": "1696255883", "time_retrieved": "2024-07-30T17:30:51.665604", "image_code": "// Thanks to this lib——lygia. (https://github.com/patriciogonzalezvivo/lygia)\n#define RESOLUTION iResolution.xy\n#define RAYMARCH_SAMPLES 128\n#define RAYMARCH_MULTISAMPLE 1\n#define RAYMARCH_BACKGROUND vec3(0.)\n#define RAYMARCH_CAMERA_FOV 2.\n\n#define COLOR_1 vec3(.757,.765,.729)\n#define COLOR_2 vec3(.553,.239,.227)\n#define COLOR_3 vec3(.278,.039,.063)\n#define COLOR_4 vec3(.001,.001,.001)\n#define COLOR_5 vec3(.745,.596,.341)\n#define COLOR_6 vec3(.302,.082,.098)\n\n#define BG_COLOR vec3(0.)\n\n// -- Here boilerplate code starts :) (Plz jump to line 754) --\n\n#define RAYMARCH_MATERIAL_FNC raymarchCustomMaterial\nvec3 raymarchCustomMaterial(vec3 ray,vec3 pos,vec3 nor,vec3 map);\n\n#ifndef RAYMARCH_CAMERA_MATRIX_FNC\n#define RAYMARCH_CAMERA_MATRIX_FNC raymarchCamera\n#endif\n\n#ifndef RAYMARCH_RENDER_FNC\n#define RAYMARCH_RENDER_FNC raymarchDefaultRender\n#endif\n\n#ifndef RAYMARCH_CAMERA_FOV\n#define RAYMARCH_CAMERA_FOV 3.0\n#endif\n\n#ifndef RAYMARCH_CAMERA_SCALE\n#define RAYMARCH_CAMERA_SCALE 0.11\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_SAMPLES\n#define RAYMARCH_SAMPLES 64\n#endif\n\n#ifndef RAYMARCH_MIN_DIST\n#define RAYMARCH_MIN_DIST 1.0\n#endif\n\n#ifndef RAYMARCH_MAX_DIST\n#define RAYMARCH_MAX_DIST 20.0\n#endif\n\n#ifndef RAYMARCH_MIN_HIT_DIST\n#define RAYMARCH_MIN_HIT_DIST 0.00001 * t\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef FNC_RAYMARCHCAST\n#define FNC_RAYMARCHCAST\n\nRAYMARCH_MAP_TYPE raymarchCast( in vec3 ro, in vec3 rd ) {\n    float tmin = RAYMARCH_MIN_DIST;\n    float tmax = RAYMARCH_MAX_DIST;\n   \n\n    \n    float t = tmin;\n    RAYMARCH_MAP_MATERIAL_TYPE m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    for ( int i = 0; i < RAYMARCH_SAMPLES; i++ ) {\n        RAYMARCH_MAP_TYPE res = RAYMARCH_MAP_FNC( ro + rd * t );\n        if ( res.RAYMARCH_MAP_DISTANCE < RAYMARCH_MIN_HIT_DIST || t > tmax ) \n            break;\n        t += res.RAYMARCH_MAP_DISTANCE;\n        m = res.RAYMARCH_MAP_MATERIAL;\n    }\n\n    #if defined(RAYMARCH_BACKGROUND) || defined(RAYMARCH_FLOOR)\n    if ( t > tmax ) \n        m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    #endif\n\n    return RAYMARCH_MAP_TYPE( m, t );\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCH_SAMPLES_AO\n#define RAYMARCH_SAMPLES_AO 5\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHAO\n#define FNC_RAYMARCHAO\n\nfloat raymarchAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < RAYMARCH_SAMPLES_AO; i++ ) {\n        float hr = 0.01 + 0.12 * float(i) * 0.2;\n        float dd = RAYMARCH_MAP_FNC( hr * nor + pos ).RAYMARCH_MAP_DISTANCE;\n        occ += (hr-dd)*sca;\n        sca *= 0.9;\n        if( occ > 0.35 ) \n            break;\n    }\n    return saturate( 1.0 - 3.0 * occ ) * (0.5+0.5*nor.y);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHNORMAL\n#define FNC_RAYMARCHNORMAL\n\nvec3 raymarchNormal(vec3 pos, vec2 pixel) {\n   vec2 offset = vec2(1.0, -1.0) * pixel;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal(vec3 pos, float e) {\n   vec2 offset = vec2(1.0, -1.0) * e;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal( in vec3 pos ) {\n   return raymarchNormal(pos, 0.5773 * 0.0005);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCHSOFTSHADOW_ITERATIONS\n#define RAYMARCHSOFTSHADOW_ITERATIONS 16\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHSOFTSHADOW\n#define FNC_RAYMARCHSOFTSHADOW\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax, float k ) {\n    float res = 1.0;\n    float t = tmin;\n    float ph = 1e20;\n    for (int i = 0; i < RAYMARCHSOFTSHADOW_ITERATIONS; i++) {\n        float h = RAYMARCH_MAP_FNC(ro + rd*t).RAYMARCH_MAP_DISTANCE;\n\n        if (t > tmax)\n            break;\n\n        else if (h < 0.001) {\n            res = 0.0;\n            break;\n        }\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax) { return raymarchSoftShadow(ro, rd, tmin, tmax, 12.0); }\nfloat raymarchSoftShadow( vec3 ro, vec3 rd) { return raymarchSoftShadow(ro, rd, 0.05, 5.0); }\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHNORMAL\n#define FNC_RAYMARCHNORMAL\n\nvec3 raymarchNormal(vec3 pos, vec2 pixel) {\n   vec2 offset = vec2(1.0, -1.0) * pixel;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal(vec3 pos, float e) {\n   vec2 offset = vec2(1.0, -1.0) * e;\n   return normalize( offset.xyy * RAYMARCH_MAP_FNC( pos + offset.xyy ).RAYMARCH_MAP_DISTANCE +\n                     offset.yyx * RAYMARCH_MAP_FNC( pos + offset.yyx ).RAYMARCH_MAP_DISTANCE +\n                     offset.yxy * RAYMARCH_MAP_FNC( pos + offset.yxy ).RAYMARCH_MAP_DISTANCE +\n                     offset.xxx * RAYMARCH_MAP_FNC( pos + offset.xxx ).RAYMARCH_MAP_DISTANCE );\n}\n\nvec3 raymarchNormal( in vec3 pos ) {\n   return raymarchNormal(pos, 0.5773 * 0.0005);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n\n#ifndef RAYMARCH_SAMPLES\n#define RAYMARCH_SAMPLES 64\n#endif\n\n#ifndef RAYMARCH_MIN_DIST\n#define RAYMARCH_MIN_DIST 1.0\n#endif\n\n#ifndef RAYMARCH_MAX_DIST\n#define RAYMARCH_MAX_DIST 20.0\n#endif\n\n#ifndef RAYMARCH_MIN_HIT_DIST\n#define RAYMARCH_MIN_HIT_DIST 0.00001 * t\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef FNC_RAYMARCHCAST\n#define FNC_RAYMARCHCAST\n\nRAYMARCH_MAP_TYPE raymarchCast( in vec3 ro, in vec3 rd ) {\n    float tmin = RAYMARCH_MIN_DIST;\n    float tmax = RAYMARCH_MAX_DIST;\n   \n\n    \n    float t = tmin;\n    RAYMARCH_MAP_MATERIAL_TYPE m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    for ( int i = 0; i < RAYMARCH_SAMPLES; i++ ) {\n        RAYMARCH_MAP_TYPE res = RAYMARCH_MAP_FNC( ro + rd * t );\n        if ( res.RAYMARCH_MAP_DISTANCE < RAYMARCH_MIN_HIT_DIST || t > tmax ) \n            break;\n        t += res.RAYMARCH_MAP_DISTANCE;\n        m = res.RAYMARCH_MAP_MATERIAL;\n    }\n\n    #if defined(RAYMARCH_BACKGROUND) || defined(RAYMARCH_FLOOR)\n    if ( t > tmax ) \n        m = RAYMARCH_MAP_MATERIAL_TYPE(-1.0);\n    #endif\n\n    return RAYMARCH_MAP_TYPE( m, t );\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCH_SAMPLES_AO\n#define RAYMARCH_SAMPLES_AO 5\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHAO\n#define FNC_RAYMARCHAO\n\nfloat raymarchAO( in vec3 pos, in vec3 nor ) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i = 0; i < RAYMARCH_SAMPLES_AO; i++ ) {\n        float hr = 0.01 + 0.12 * float(i) * 0.2;\n        float dd = RAYMARCH_MAP_FNC( hr * nor + pos ).RAYMARCH_MAP_DISTANCE;\n        occ += (hr-dd)*sca;\n        sca *= 0.9;\n        if( occ > 0.35 ) \n            break;\n    }\n    return saturate( 1.0 - 3.0 * occ ) * (0.5+0.5*nor.y);\n}\n\n#endif\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_TYPE\n#define RAYMARCH_MAP_TYPE vec4\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef FNC_RAYMARCHMAP\n#define FNC_RAYMARCHMAP\n\nRAYMARCH_MAP_TYPE RAYMARCH_MAP_FNC( in vec3 pos );\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCHSOFTSHADOW_ITERATIONS\n#define RAYMARCHSOFTSHADOW_ITERATIONS 16\n#endif\n\n#ifndef RAYMARCH_MAP_FNC\n#define RAYMARCH_MAP_FNC(POS) raymarchMap(POS)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef FNC_RAYMARCHSOFTSHADOW\n#define FNC_RAYMARCHSOFTSHADOW\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax, float k ) {\n    float res = 1.0;\n    float t = tmin;\n    float ph = 1e20;\n    for (int i = 0; i < RAYMARCHSOFTSHADOW_ITERATIONS; i++) {\n        float h = RAYMARCH_MAP_FNC(ro + rd*t).RAYMARCH_MAP_DISTANCE;\n\n        if (t > tmax)\n            break;\n\n        else if (h < 0.001) {\n            res = 0.0;\n            break;\n        }\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat raymarchSoftShadow( vec3 ro, vec3 rd, in float tmin, in float tmax) { return raymarchSoftShadow(ro, rd, tmin, tmax, 12.0); }\nfloat raymarchSoftShadow( vec3 ro, vec3 rd) { return raymarchSoftShadow(ro, rd, 0.05, 5.0); }\n\n#endif\n\n#ifndef LIGHT_POSITION\n#define LIGHT_POSITION vec3(0.0, 10.0, -50.0)\n#endif\n\n#ifndef LIGHT_COLOR\n#define LIGHT_COLOR vec3(0.5)\n#endif\n\n#ifndef RAYMARCH_AMBIENT\n#define RAYMARCH_AMBIENT vec3(1.0)\n#endif\n\n#ifndef RAYMARCH_BACKGROUND\n#define RAYMARCH_BACKGROUND vec3(0.0)\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_FNC\n#define RAYMARCH_MAP_MATERIAL_FNC \n#endif\n\n#ifndef RAYMARCH_MATERIAL_FNC\n#define RAYMARCH_MATERIAL_FNC(RAY, POSITION, NORMAL, ALBEDO) raymarchDefaultMaterial(RAY, POSITION, NORMAL, ALBEDO)\n#endif\n\n#ifndef FNC_RAYMARCHMATERIAL\n#define FNC_RAYMARCHMATERIAL\n\nvec3 raymarchDefaultMaterial(vec3 ray, vec3 position, vec3 normal, RAYMARCH_MAP_MATERIAL_TYPE color) {\n    vec3  env = RAYMARCH_AMBIENT;\n\n    if ( sum(color) <= 0.0 ) \n        return RAYMARCH_BACKGROUND;\n\n    vec3 ref = reflect( ray, normal );\n    float occ = raymarchAO( position, normal );\n\n    #if defined(LIGHT_DIRECTION)\n    vec3  lig = normalize( LIGHT_DIRECTION );\n    #else\n    vec3  lig = normalize( LIGHT_POSITION - position);\n    #endif\n    \n    vec3  hal = normalize( lig-ray );\n    float amb = saturate( 0.5+0.5*normal.y );\n    float dif = saturate( dot( normal, lig ) );\n    float bac = saturate( dot( normal, normalize(vec3(-lig.x, 0.0,-lig.z))) ) * saturate( 1.0-position.y );\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( saturate(1.0+dot(normal,ray) ), 2.0 );\n    \n    dif *= raymarchSoftShadow( position, lig, 0.02, 2.5 );\n    dom *= raymarchSoftShadow( position, ref, 0.02, 2.5 );\n\n    vec3 light = vec3(0.0);\n    light += 1.30 * dif * LIGHT_COLOR;\n    light += 0.40 * amb * occ * env;\n    light += 0.50 * dom * occ * env;\n    light += 0.50 * bac * occ * 0.25;\n    light += 0.25 * fre * occ;\n\n    return RAYMARCH_MAP_MATERIAL_FNC(color) * light;\n}\n\nvec3 raymarchMaterial(vec3 ray, vec3 position, vec3 normal, vec3 albedo) {\n    return RAYMARCH_MATERIAL_FNC(ray, position, normal, albedo);\n}\n\n#if defined(STR_MATERIAL)\nvoid raymarchMaterial( in vec3 ro, in vec3 rd, inout Material mat) { \n    RAYMARCH_MAP_TYPE res = raymarchCast(ro, rd);\n\n    vec3 col = vec3(0.0);\n    vec3 m = res.rgb;\n    float t = res.a;\n\n    vec3 pos = ro + t * rd;\n    vec3 nor = raymarchNormal( pos );\n    float occ = raymarchAO( pos, nor );\n\n    mat.albedo = res;\n    mat.normal = nor;\n    mat.ambientOcclusion = occ;\n\n    #if defined(SHADING_SHADOWS)\n    vec3 ref = reflect( rd, nor );\n    vec3 lig = normalize( LIGHT_POSITION );\n\n    vec3  hal = normalize( lig-rd );\n    float amb = saturate( 0.5+0.5*nor.y);\n    float dif = saturate( dot( nor, lig ));\n    float bac = saturate( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))))*saturate( 1.0-pos.y);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( saturate(1.0+dot(nor,rd) ), 2.0 );\n\n    dif *= raymarchSoftShadow( pos, lig, 0.02, 2.5 );\n    dom *= raymarchSoftShadow( pos, ref, 0.02, 2.5 );\n\n    mat.shadows = 1.30 * dif;\n    mat.shadows += 0.40 * amb * occ;\n    mat.shadows += 0.50 * dom * occ;\n    mat.shadows += 0.50 * bac * occ;\n    mat.shadows += 0.25 * fre * occ * 0.25;\n    #endif\n}\n#endif\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef RAYMARCH_MAP_DISTANCE\n#define RAYMARCH_MAP_DISTANCE a\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL\n#define RAYMARCH_MAP_MATERIAL rgb\n#endif\n\n#ifndef RAYMARCH_MAP_MATERIAL_TYPE\n#define RAYMARCH_MAP_MATERIAL_TYPE vec3\n#endif\n\n#ifndef RAYMARCHCAST_TYPE\n#define RAYMARCHCAST_TYPE vec4\n#endif\n\n#ifndef FNC_RAYMARCHDEFAULT\n#define FNC_RAYMARCHDEFAULT\n\nvec4 raymarchDefaultRender( in vec3 ray_origin, in vec3 ray_direction ) { \n    vec3 col = vec3(0.0);\n    \n    RAYMARCHCAST_TYPE res = raymarchCast(ray_origin, ray_direction);\n    float t = res.RAYMARCH_MAP_DISTANCE;\n\n    vec3 pos = ray_origin + t * ray_direction;\n    vec3 nor = raymarchNormal( pos );\n    col = raymarchMaterial(ray_direction, pos, nor, res.RAYMARCH_MAP_MATERIAL);\n\n    return vec4( saturate(col), t );\n}\n\n#endif\n\n#ifndef ENG_RAYMARCHING\n#define ENG_RAYMARCHING\nvec4 raymarch(vec3 camera, vec3 ta, vec2 st) {\n    mat3 ca = RAYMARCH_CAMERA_MATRIX_FNC(camera, ta);\n    \n#if defined(RAYMARCH_MULTISAMPLE)\n    vec4 color = vec4(0.0);\n    vec2 pixel = 1.0/RESOLUTION;\n    vec2 offset = rotate( vec2(0.5, 0.0), HALF_PI/4.);\n\n    for (int i = 0; i < RAYMARCH_MULTISAMPLE; i++) {\n        vec3 rd = ca * normalize(vec3((st + offset * pixel)*2.0-1.0, RAYMARCH_CAMERA_FOV));\n        color += RAYMARCH_RENDER_FNC( camera * RAYMARCH_CAMERA_SCALE, rd);\n        offset = rotate(offset, HALF_PI);\n    }\n    return color/float(RAYMARCH_MULTISAMPLE);\n#else\n    vec3 rd = ca * normalize(vec3(st*2.0-1.0, RAYMARCH_CAMERA_FOV));\n    return RAYMARCH_RENDER_FNC( camera * RAYMARCH_CAMERA_SCALE, rd);\n#endif\n}\n\nvec4 raymarch(vec3 camera, vec2 st) {\n    return raymarch(camera, vec3(0.0), st);\n}\n\n#endif\n\n// -- Here boilerplate code ends :) --\n\nvec3 worldPosToJumpyDumpty(vec3 p){\n    p.x-=1.5;\n    p.z-=iTime*2.;\n    p.y-=abs(sin(iTime*5.))*.2;\n    p=opRepite(p,vec3(3.));\n    return p;\n}\n\nvec3 raymarchCustomMaterial(vec3 ray,vec3 pos,vec3 nor,vec3 map){\n    vec3 posOrigin=pos;\n    \n    if(sum(map)<=0.){\n        return RAYMARCH_BACKGROUND;\n    }\n    \n    vec3 col=vec3(0.);\n    \n    // ambient\n    col+=map*.2;\n    \n    // diffuse and shadow\n    vec3 lightPos=vec3(2.,5.,10.);\n    vec3 lightDir=normalize(lightPos-pos);\n    float diff=max(dot(lightDir,nor),0.);\n    float shadow=raymarchSoftShadow(pos,lightDir,.05,1.5);\n    col+=map*diff*shadow;\n    \n    // specular\n    vec3 reflectDir=reflect(-lightDir,nor);\n    vec3 viewDir=normalize(-ray);\n    vec3 halfVec=normalize(lightDir+viewDir);\n    float spec=pow(max(dot(nor,halfVec),0.),32.);\n    col+=map*spec;\n    \n    if(pos.y>2.){\n        return RAYMARCH_BACKGROUND;\n    }\n    \n    pos=worldPosToJumpyDumpty(pos);\n    \n    if(map==COLOR_1){\n        // head\n        \n        // eye\n        vec2 uv1=pos.xy;\n        uv1.x=abs(uv1.x);\n        uv1/=vec2(.75,.5);\n        uv1-=vec2(-.15,.4);\n        float c1=circleSDF(uv1);\n        float eye=1.-smoothstep(.15,.151,c1);\n        col=mix(col,COLOR_3,eye);\n        \n        // mouth\n        vec2 uv2=pos.xy;\n        uv2.x=abs(uv2.x);\n        uv2.y-=.4;\n        uv2.y*=-1.;\n        float c2=lineSDF(uv2,vec2(0.),vec2(.05));\n        float mouth=1.-smoothstep(.0125,.01251,c2);\n        col=mix(col,COLOR_3,mouth);\n    }else if(map==COLOR_4){\n        // belt\n        vec2 uv3=pos.xy;\n        uv3/=vec2(.4);\n        uv3-=vec2(-.5,-.18);\n        uv3=fract(uv3);\n        float c3=circleSDF(uv3);\n        float polka=1.-smoothstep(.15,.151,c3);\n        col=mix(col,COLOR_5,polka);\n    }else if(map==COLOR_2){\n        // body\n        \n        vec2 uv4=pos.xy;\n        uv4/=vec2(.4);\n        uv4-=vec2(-.5,.05);\n        uv4.y/=.6;\n        uv4.y*=-1.;\n        float c4=triSDF(uv4);\n        float tri=1.-smoothstep(1.8,1.81,c4);\n        col=mix(col,COLOR_6,tri);\n        \n        vec2 uv5=pos.xy;\n        uv5/=vec2(.4);\n        uv5-=vec2(-.5,-1.05);\n        float c5=uv5.y;\n        float stripe=smoothstep(.09,.1,c5)-smoothstep(.19,.2,c5);\n        col=mix(col,COLOR_5,stripe);\n        \n        vec2 uv6=pos.xy;\n        uv6/=vec2(.4);\n        uv6-=vec2(-.7,-1.9);\n        uv6.y/=.7;\n        uv6.x/=1.4;\n        float c6=heartSDF(uv6);\n        float heart=1.-smoothstep(1.8,1.81,c6);\n        col=mix(col,COLOR_5,heart);\n    }\n    \n    // fog\n    float fog=exp(-.000005*pow(posOrigin.z,6.));\n    col=mix(col,RAYMARCH_BACKGROUND,1.-fog);\n    \n    return col;\n}\n\nvec4 jumpyDumpty(vec3 p,vec4 res){\n    \n    vec3 p1=p;\n    float head=sphereSDF(p1,.69);\n    head=opIntersection(head,boxSDF(p1-vec3(0.,1.3,0.),vec3(1.)));\n    res=opUnion(res,vec4(COLOR_1,head));\n    \n    \n    vec3 p2=p;\n    p2.x=abs(p2.x);\n    float ear=ellipsoidSDF(rotate(p2-vec3(.45,.7,0.),-PI/3.,vec3(0.,0.,1.)),vec3(.1,.25,.1));\n    res=opUnion(res,vec4(COLOR_1,ear),.025);\n    \n    \n    vec3 p3=p;\n    p3.y-=.3;\n    p3.y/=.8;\n    float body=coneSDF(p3-vec3(0.,-.6,0.),.75,.5,1.);\n    body=opIntersection(body,boxSDF(p3-vec3(0.,-1.,0.),vec3(1.)));\n    body*=.8;\n    res=opUnion(res,vec4(COLOR_2,body));\n    \n    \n    vec3 p4=p;\n    p4.y-=.14;\n    p4.y/=.8;\n    p4/=1.05;\n    p4.y*=-1.;\n    float skirt=coneSDF(p4-vec3(0.,-.6,0.),.75,.5,1.);\n    skirt=opIntersection(skirt,boxSDF(p4-vec3(0.,-1.,0.),vec3(1.)));\n    skirt*=.8;\n    p4*=1.05;\n    skirt=opIntersection(skirt,boxSDF(p4-vec3(0.,.8,0.),vec3(1.)));\n    res=opUnion(res,vec4(COLOR_2,skirt));\n    \n    \n    \n    vec3 p5=p;\n    p5.y-=.24;\n    p5.y/=.8;\n    p5/=1.04;\n    float belt=coneSDF(p5-vec3(0.,-.6,0.),.75,.5,1.);\n    belt=opIntersection(belt,boxSDF(p5-vec3(0.,-1.,0.),vec3(1.)));\n    belt*=.8;\n    p5*=1.04;\n    belt=opIntersection(belt,boxSDF(p5-vec3(0.,.8,0.),vec3(1.)));\n    res=opUnion(res,vec4(COLOR_4,belt));\n    return res;\n}\n\nvec4 raymarchMap(vec3 p){\n    vec4 res=vec4(1.);\n    \n    \n    \n    vec3 p1=p;\n    p1=worldPosToJumpyDumpty(p1);\n    res=jumpyDumpty(p1,res);\n    \n    \n    vec3 p2=p;\n    res=opUnion(res,vec4(vec3(1.),planeSDF(p2)+.75));\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    uv=ratio(uv,iResolution.xy);\n    vec3 col=vec3(0.);\n    \n    vec3 camera=vec3(-30.,15.,50.);\n    col=raymarch(camera,uv).rgb;\n    \n    fragColor=vec4(col,1.);\n}", "image_inputs": [{"id": 34841, "src": "https://soundcloud.com/kai-gamer-240922295/lets-go-crimson-knight", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#ifndef FNC_RATIO\n#define FNC_RATIO\nvec2 ratio(in vec2 st, in vec2 s) {\n    return mix( vec2((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                vec2(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                step(s.x,s.y));\n}\n#endif\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float radians){\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, -s, s, c);\n}\n#endif\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 st, in float radians, in vec2 center) {\n    return rotate2d(radians) * (st - center) + center;\n}\n\nvec2 rotate(in vec2 st, in float radians) {\n    #ifdef CENTER_2D\n    return rotate(st, radians, CENTER_2D);\n    #else\n    return rotate(st, radians, vec2(.5));\n    #endif\n}\n\nvec2 rotate(vec2 st, vec2 x_axis) {\n    #ifdef CENTER_2D\n    st -= CENTER_2D;\n    #endif\n    vec2 rta = vec2( dot(st, vec2(-x_axis.y, x_axis.x)), dot(st, x_axis) );\n    #ifdef CENTER_2D\n    rta += CENTER_2D;\n    #endif\n    return rta;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis, in vec3 center) {\n    return (rotate4d(axis, radians) * vec4(xyz - center, 1.)).xyz + center;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis) {\n    #ifdef CENTER_3D\n    return rotate(xyz, radians, axis, CENTER_3D);\n    #else\n    return rotate(xyz, radians, axis, vec3(0.));\n    #endif\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis, in vec4 center) {\n    return rotate4d(axis, radians) * (xyzw - center) + center;\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis) {\n    #ifdef CENTER_4D\n    return rotate(xyzw, radians, axis, CENTER_4D);\n    #else\n    return rotate(xyzw, radians, axis, vec4(0.));\n    #endif\n}\n#endif\n\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n#ifndef FNC_SUM\n#define FNC_SUM\n\nfloat sum( float v ) { return v; }\nfloat sum( vec2 v ) { return v.x+v.y; }\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\nfloat sum( vec4 v ) { return v.x+v.y+v.z+v.w; }\n\n#endif\n\n#ifndef FNC_LOOKAT\n#define FNC_LOOKAT\n\nmat3 lookAt(vec3 forward, vec3 up) {\n    vec3 xaxis = normalize(cross(forward, up));\n    vec3 yaxis = up;\n    vec3 zaxis = forward;\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nmat3 lookAt(vec3 target, vec3 eye, vec3 up) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nmat3 lookAt(vec3 target, vec3 eye, float roll) {\n    vec3 up = vec3(sin(roll), cos(roll), 0.0);\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = normalize(cross(xaxis, zaxis));\n    return mat3(xaxis, yaxis, zaxis);\n}\n\n#endif\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\n\nfloat rectSDF(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nfloat rectSDF(vec2 p, float b, float r) {\n    return rectSDF(p, vec2(b), r);\n}\n\nfloat rectSDF(in vec2 st, in vec2 s) {\n    st = st * 2. - 1.;\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n\nfloat rectSDF(in vec2 st, in float s) {\n    return rectSDF(st, vec2(s) );\n}\n\nfloat rectSDF(in vec2 st) {\n    return rectSDF(st, vec2(1.0));\n}\n\n#endif\n\n#ifndef FNC_CROSSSDF\n#define FNC_CROSSSDF\nfloat crossSDF(in vec2 st, in float s) {\n    vec2 size = vec2(.25, s);\n    return min(rectSDF(st.xy, size.xy),\n               rectSDF(st.xy, size.yx));\n}\n#endif\n#ifndef FNC_HEARTSDF\n#define FNC_HEARTSDF\nfloat heartSDF(vec2 st) {\n    st -= vec2(0.5, 0.8);\n    float r = length(st) * 5.0;\n    st = normalize(st);\n    return r - ((st.y * pow(abs(st.x), 0.67)) / (st.y + 1.5) - (2.0) * st.y + 1.26);\n}\n#endif\n#ifndef FNC_HEXSDF\n#define FNC_HEXSDF\nfloat hexSDF(in vec2 st) {\n    st = abs(st * 2. - 1.);\n    return max(abs(st.y), st.x * .866025 + st.y * .5);\n}\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_LINESDF\n#define FNC_LINESDF\nfloat lineSDF( in vec2 st, in vec2 a, in vec2 b ) {\n    vec2 b_to_a = b - a;\n    vec2 to_a = st - a;\n    float h = saturate(dot(to_a, b_to_a)/dot(b_to_a, b_to_a));\n    return length(to_a - h * b_to_a );\n}\n\nfloat lineSDF(vec3 p, vec3 a, vec3 b) {\n    \n    return length(cross(p - a, p - b))/length(b - a);\n}\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_POLYSDF\n#define FNC_POLYSDF\nfloat polySDF(in vec2 st, in int V) {\n    st = st * 2. - 1.;\n    float a = atan(st.x, st.y) + PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(.5 + a / v) * v - a ) * r;\n}\n#endif\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n\n#ifndef FNC_RHOMBSDF\n#define FNC_RHOMBSDF\nfloat rhombSDF(in vec2 st) {\n    return max(triSDF(st),\n               triSDF(vec2(st.x, 1. - st.y)));\n}\n#endif\n#ifndef FNC_SPIRALSDF\n#define FNC_SPIRALSDF\nfloat spiralSDF(vec2 st, float t) {\n    st -= 0.5;\n    float r = dot(st, st);\n    float a = atan(st.y, st.x);\n    return abs(sin(fract(log(r) * t + a * 0.159)));\n}\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_STARSDF\n#define FNC_STARSDF\nfloat starSDF(in vec2 st, in int V, in float s) {\n    st = st * 4. - 2.;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + .5) / float(V) +\n        mix(s, -s, step(.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)),\n                   st));\n}\n#endif\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n    st = (st * 2. - 1.) * 2.;\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * .5);\n}\n#endif\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 st, in vec2 center) {\n    return CIRCLESDF_FNC(st - center) * 2.;\n}\n\nfloat circleSDF(in vec2 st) {\n    return circleSDF(st, vec2(.5));\n}\n\n#endif\n\n#ifndef FNC_VESICASDF\n#define FNC_VESICASDF\nfloat vesicaSDF(in vec2 st, in float w) {\n    vec2 offset = vec2(w*.5,0.);\n    return max( circleSDF(st-offset),\n                circleSDF(st+offset));\n}\n#endif\n#ifndef FNC_FLOWERSDF\n#define FNC_FLOWERSDF\nfloat flowerSDF(vec2 st, int N) {\n    st = st * 2.0 - 1.0;\n    float r = length(st) * 2.0;\n    float a = atan(st.y, st.x);\n    float v = float(N) * 0.5;\n    return 1.0 - (abs(cos(a * v)) *  0.5 + 0.5) / r;\n}\n#endif\n\n#ifndef FNC_BOXFRAMESDF\n#define FNC_BOXFRAMESDF\n\nfloat boxFrameSDF( vec3 p, vec3 b, float e ) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n#endif\n#ifndef FNC_BOXSDF\n#define FNC_BOXSDF\n\nfloat boxSDF( vec3 p ) {\n    vec3 d = abs(p);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_CAPSULESDF\n#define FNC_CAPSULESDF\n\nfloat capsuleSDF( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p-a, ba = b-a;\n    float h = saturate( dot(pa,ba)/dot(ba,ba) );\n    return length( pa - ba*h ) - r;\n}\n\n#endif\n#ifndef FNC_CONESDF\n#define FNC_CONESDF\n\nfloat coneSDF( in vec3 p, in vec3 c ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat coneSDF( in vec3 p, in vec2 c, float h ) {\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat coneSDF( in vec3 p, in float r1, float r2, float h ) {\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n#endif\n#ifndef FNC_BOXSDF\n#define FNC_BOXSDF\n\nfloat boxSDF( vec3 p ) {\n    vec3 d = abs(p);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat boxSDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#endif\n\n#ifndef FNC_CUBESDF\n#define FNC_CUBESDF\nfloat cubeSDF(vec3 p, float s)  { return boxSDF(p, vec3(s)); }\n#endif\n#ifndef FNC_CYLINDERSDF\n#define FNC_CYLINDERSDF\n\nfloat cylinderSDF( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF( vec3 p, float h ) {\n    return cylinderSDF( p, vec2(h) );\n}\n\nfloat cylinderSDF( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_DODECAHEDRONSDF\n#define FNC_DODECAHEDRONSDF\n\nfloat dodecahedronSDF(vec3 p) {\n    vec3 n = normalize(vec3(PHI,1.0,0.0));\n    p = abs(p);\n    float a = dot(p,n.xyz);\n    float b = dot(p,n.zxy);\n    float c = dot(p,n.yzx);\n    \n    return (max(max(a,b),c)-n.x);\n}\n\nfloat dodecahedronSDF(vec3 p, float radius) {\n    vec3 n = normalize(vec3(PHI,1.0,0.0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a,b),c)-n.x) * radius;\n}\n\n#endif\n#ifndef FNC_ELLIPSOIDSDF\n#define FNC_ELLIPSOIDSDF\n\nfloat ellipsoidSDF( in vec3 p, in vec3 r ) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n#endif\n#ifndef FNC_HEXPRISMSDF\n#define FNC_HEXPRISMSDF\n\nfloat hexPrismSDF( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef FNC_ICOSAHEDRONSDF\n#define FNC_ICOSAHEDRONSDF\n\nfloat icosahedronSDF(vec3 p, float radius) {\n    float q = 2.61803398875; \n    vec3 n1 = normalize(vec3(q, 1,0));\n    vec3 n2 = vec3(0.57735026919);  \n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a,b),c)-n1.x,d) * radius;\n}\n\n#endif\n#ifndef FNC_LINKSDF\n#define FNC_LINKSDF\nfloat linkSDF( vec3 p, float le, float r1, float r2 ) {\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n#endif\n#ifndef FNC_OCTAHEDRONSDF\n#define FNC_OCTAHEDRONSDF\n\nfloat octahedronSDF(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n#ifdef OCTAHEDRON_EXACT_DISTANCE\n    \n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n\n    \n#else\n    \n    return m*0.57735027;\n#endif\n}\n\n#endif\n#ifndef FNC_OCTOGONPRISMSDF\n#define FNC_OCTOGONPRISMSDF\n\nfloat octogonPrismSDF( in vec3 p, in float r, float h ) {\n   vec3 k = vec3( -0.9238795325,   \n                  0.3826834323,   \n                  0.4142135623 ); \n   \n   p = abs(p);\n   p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n   p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n   \n   p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n   vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n   return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n#endif\n#ifndef FNC_PLANESDF\n#define FNC_PLANESDF\nfloat planeSDF( vec3 p ) { \n   return p.y; \n}\n\nfloat planeSDF(vec3 p, vec3 planePoint, vec3 planeNormal) {\n    return (dot(planeNormal, p) + dot(planeNormal, planePoint)) / length(planeNormal);\n}\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_PYRAMIDSDF\n#define FNC_PYRAMIDSDF\n\nfloat pyramidSDF( in vec3 p, in float h )  {\n   float m2 = h*h + 0.25;\n   \n   \n   p.xz = abs(p.xz);\n   p.xz = (p.z>p.x) ? p.zx : p.xz;\n   p.xz -= 0.5;\n\n   \n   vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n\n   float s = max(-q.x,0.0);\n   float t = saturate( (q.y-0.5*p.z)/(m2+0.25) );\n   \n   float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n   float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n   \n   float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n   \n   \n   return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n#endif\n#ifndef FNC_SPHERESDF\n#define FNC_SPHERESDF\nfloat sphereSDF(vec3 p) { return length(p); }\nfloat sphereSDF(vec3 p, float s) { return sphereSDF(p) - s; }\n#endif\n#ifndef FNC_TETRAHEDRONSDF\n#define FNC_TETRAHEDRONSDF\nfloat tetrahedronSDF(vec3 p, float h)  {\n    vec3 q = abs(p);\n    \n    float y = p.y;\n    float d1 = q.z-max(0.,y);\n    float d2 = max(q.x*.5 + y*.5,.0) - min(h, h+y);\n    return length(max(vec2(d1,d2),.005)) + min(max(d1,d2), 0.0);\n}\n#endif\n#ifndef FNC_TORUSSDF\n#define FNC_TORUSSDF\nfloat torusSDF( vec3 p, vec2 t ) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\n\nfloat torusSDF(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n#endif\n#ifndef FNC_TRIPRISMSDF\n#define FNC_TRIPRISMSDF\n\nfloat triPrismSDF( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n#endif\n\n#ifndef FNC_OPONION\n#define FNC_OPONION\n\nfloat opOnion( in float d, in float h ) {\n    return abs(d)-h;\n}\n\n#endif\n#ifndef FNC_OPREPITE\n#define FNC_OPREPITE\n\nvec2 opRepite( in vec2 p, in float s ) {\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\nvec3 opRepite( in vec3 p, in vec3 c ) {\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRepite( in vec2 p, in vec2 lima, in vec2 limb, in float s ) {\n    return p-s*clamp(floor(p/s),lima,limb);\n}\n\nvec3 opRepite( in vec3 p, in vec3 lima, in vec3 limb, in float s ) {\n    return p-s*clamp(floor(p/s),lima,limb);\n}\n\n#endif\n#ifndef FNC_OPREVOLVE\n#define FNC_OPREVOLVE\n\nvec2 opRevolve( in vec3 p, float w ) {\n    return vec2( length(p.xz) - w, p.y );\n}\n\n#endif\n#ifndef FNC_OPREVOLVE\n#define FNC_OPREVOLVE\n\nfloat opRound( in float d, in float h ) {\n    return d - h;\n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_OPSUBSTRACTION\n#define FNC_OPSUBSTRACTION\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1, d2); }\nvec4  opSubtraction( vec4 d1, vec4 d2 ) { return (-d1.a > d2.a) ? -d1 : d2; }\n\nfloat opSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nvec4 opSubtraction( vec4 d1, vec4 d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.a+d1.a)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_OPINTERSECTION\n#define FNC_OPINTERSECTION\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opIntersection( float d1, float d2, float k ) {\n    float h = saturate( 0.5 - 0.5*(d2-d1)/k );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(x) clamp(x, 0.0, 1.0)\n#endif\n\n#ifndef FNC_OPUNION\n#define FNC_OPUNION\n\nfloat opUnion( float d1, float d2 ) { return min(d1, d2); }\nvec4  opUnion( vec4 d1, vec4 d2 ) { return (d1.a < d2.a) ? d1 : d2; }\n\nfloat opUnion( float d1, float d2, float k ) {\n    float h = saturate( 0.5 + 0.5*(d2-d1)/k );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec4 opUnion( vec4 d1, vec4 d2, float k ) {\n    float h = saturate( 0.5 + 0.5*(d2.a - d1.a)/k );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n#endif\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float radians){\n    float c = cos(radians);\n    float s = sin(radians);\n    return mat2(c, -s, s, c);\n}\n#endif\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 axis, in float radians) {\n    axis = normalize(axis);\n    float s = sin(radians);\n    float c = cos(radians);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 st, in float radians, in vec2 center) {\n    return rotate2d(radians) * (st - center) + center;\n}\n\nvec2 rotate(in vec2 st, in float radians) {\n    #ifdef CENTER_2D\n    return rotate(st, radians, CENTER_2D);\n    #else\n    return rotate(st, radians, vec2(.5));\n    #endif\n}\n\nvec2 rotate(vec2 st, vec2 x_axis) {\n    #ifdef CENTER_2D\n    st -= CENTER_2D;\n    #endif\n    vec2 rta = vec2( dot(st, vec2(-x_axis.y, x_axis.x)), dot(st, x_axis) );\n    #ifdef CENTER_2D\n    rta += CENTER_2D;\n    #endif\n    return rta;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis, in vec3 center) {\n    return (rotate4d(axis, radians) * vec4(xyz - center, 1.)).xyz + center;\n}\n\nvec3 rotate(in vec3 xyz, in float radians, in vec3 axis) {\n    #ifdef CENTER_3D\n    return rotate(xyz, radians, axis, CENTER_3D);\n    #else\n    return rotate(xyz, radians, axis, vec3(0.));\n    #endif\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis, in vec4 center) {\n    return rotate4d(axis, radians) * (xyzw - center) + center;\n}\n\nvec4 rotate(in vec4 xyzw, in float radians, in vec3 axis) {\n    #ifdef CENTER_4D\n    return rotate(xyzw, radians, axis, CENTER_4D);\n    #else\n    return rotate(xyzw, radians, axis, vec4(0.));\n    #endif\n}\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef ONE_OVER_PI\n#define ONE_OVER_PI 0.31830988618\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n#ifndef RANDOM_SCALE\n#if defined(RANDOM_HIGHER_RANGE)\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#if defined(RANDOM_SINLESS)\n    return fract(sin(x) * 43758.5453);\n#else\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#endif\n}\n\nfloat random(in vec2 st) {\n#if defined(RANDOM_SINLESS)\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#if defined(RANDOM_SINLESS)\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#if defined(RANDOM_SINLESS)\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy+33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n#endif\n\n#ifndef FNC_RAYMARCHCAMERA\n#define FNC_RAYMARCHCAMERA\n\nmat3 raymarchCamera( in vec3 ro, in vec3 ta, in vec3 up ) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = up;\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 raymarchCamera( in vec3 ro, in vec3 ta, float cr ) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 raymarchCamera( in vec3 ro, in vec3 ta ) {\n    return raymarchCamera( ro, ta, vec3(0.0, 1.0, 0.0) );\n}\n\nmat3 raymarchCamera( in vec3 ro ) {\n    return raymarchCamera( ro, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0) );\n}\n\n#endif", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyyzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "mdVcDm", "name": "Neyret Hextiling Optimized", "author": "Ameo", "description": "Fork of hex tiling shader by @FabriceNeyret2 (https://www.shadertoy.com/view/MdyfDV) with small changes to reduce texture lookups. Weights are saturated and small factors dropped; can dramatically reduce texture lookups with only small diffs in output", "tags": ["noise", "texture", "blending", "fourier", "bombing", "gabor", "texturebombing", "splatting", "textons", "byexample", "contrastpreserving", "hpg"], "likes": 3, "viewed": 167, "published": 3, "date": "1696233537", "time_retrieved": "2024-07-30T17:30:52.421582", "image_code": "// ---------------------------------------------------------------------\n// With only 3 texture fetches, generates endless seamless non-repeating \n// same-properties texture from example. ( in the paper: +1 LUT fetch\n// to handle non-Gaussian correlated color histograms).\n\n// Simple implementation of our HPG'18 \n// \"High-Performance By-Example Noise using a Histogram-Preserving Blending Operator\"\n// https://hal.inria.fr/hal-01824773\n// ( color-histogram Gaussianisation not possible in shadertoy ;-) \n//   or possibly via this approx: https://www.shadertoy.com/view/slX3zr  ). \n// ---------------------------------------------------------------------\n\n#define CON 1      // contrast preserving interpolation. cf https://www.shadertoy.com/view/4dcSDr\n#define Z   8.     // patch scale inside example texture\n\n#define rnd22(p)    fract(sin((p) * mat2(127.1,311.7,269.5,183.3) )*43758.5453)\n#define srgb2rgb(V) pow( max(V,0.), vec4( 2.2 )  )          // RGB <-> sRGB conversions\n#define rgb2srgb(V) pow( max(V,0.), vec4(1./2.2) )\n\n// --- texture patch associated to vertex I in triangular/hexagonal grid. key 'P'\n// (textureGrad handles MIPmap through patch borders)\n#define C(I)  ( keyToggle(16) ? vec4( I==P, I==P+vec2(1,0), I==P+vec2(0,1), 1 ) \\\n                              : srgb2rgb( textureGrad(iChannel0, U/Z-rnd22(I) ,Gx,Gy)) - m*float(CON) )\n// --- for tests\n//#define C(I)     ( srgb2rgb( texture(iChannel0, U/8.-rnd22(I)) ) - m*float(CON) )\n//#define C(I)     ( srgb2rgb( textureGrad(iChannel0, U/Z-rnd22(I) ,Gx,Gy)) - m*float(CON) )\n//#define C(I)     H(I)\n//#define C(I)     vec4( I==P, I==P+vec2(1,0), I==P+vec2(0,1), 1 )\n#define S(v)       smoothstep( p,-p, v )                    // antialiased drawing\n#define hue(v)   ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) ) // from https://www.shadertoy.com/view/ll2cDc\n#define H(I)       hue( (I).x + 71.3*(I).y )\n#define keyToggle(c) ( texelFetch(iChannel3,ivec2(64+c,2),0).x > 0.) // keyboard. from https://www.shadertoy.com/view/llySRh\n\n// ---------------------------------------------------------------------\nvoid mainImage( out vec4 O, vec2 u )\n{\n    mat2 M0 = mat2( 1,0, .5,sqrt(3.)/2. ),\n          M = inverse( M0 );                           // transform matrix <-> tilted space\n    vec2 R = iResolution.xy,\n         z = iMouse.xy/R,\n         U = ( 2.*u - R ) / R.y  *Z/8.* exp2(z.y==0.?2.:4.*z.y+1.) + vec2(2.*iTime),\n         V = M * U,                                    // pre-hexa tilted coordinates\n         I = floor(V),                                 // hexa-tile id\n         P = floor( M * vec2(2.*iTime) );              // center tile (to show patches)\n    float p = .7*dFdy(U.y);                            // pixel size (for antialiasing)\n    vec2 Gx = dFdx(U/Z), Gy = dFdy(U/Z);               // (for cross-borders MIPmap)\n    vec4 m = srgb2rgb( texture(iChannel0,U,99.) );     // mean texture color\n    \n    vec3 F = vec3(fract(V),0), A, W; F.z = 1.-F.x-F.y; // local hexa coordinates\n    if ( F.z > 0. ) {\n        W = vec3(F.z, F.y, F.x);\n        W = pow(W, vec3(4.));\n        W = W / dot(W, vec3(1.));\n\n        if (W.x > 0.01) {\n            O += C(I) * W.x;\n        }\n        if (W.y > 0.01) {\n            O += C(I + vec2(0, 1)) * W.y;\n        }\n        if (W.z > 0.01) {\n            O += C(I + vec2(1, 0)) * W.z;\n        }\n    } else {            \n        W = vec3(-F.z, 1. - F.y, 1. - F.x);\n        W = pow(W, vec3(4.));\n        W = W / dot(W, vec3(1.));\n\n        if (W.x > 0.01) {\n            O += C(I + 1.) * W.x;\n        }\n        if (W.y > 0.01) {\n            O += C(I + vec2(1, 0)) * W.y;\n        }\n        if (W.z > 0.01) {\n            O += C(I + vec2(0, 1)) * W.z;\n        }\n    }\n#if CON    \n    O = m + O/length(W);  // contrast preserving interp. cf https://www.shadertoy.com/view/4dcSDr\n#endif\n    O = clamp( rgb2srgb(O), 0., 1.);\n    if (m.g==0.) O = O.rrrr;                           // handles B&W (i.e. \"red\") textures\n    \n    if (keyToggle(7)) O = mix( O, vec4(1), S(min(W.x,min(W.y,W.z))-p) ); // key 'G'; show grid   \n  //O = mix(O, H(floor(V+.5)), S(length(M0*(fract(V+.5)-.5))-.1));       // show nodes\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdVcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1999, 2072, 2110, 2110, 4111]], "test": "untested"}
{"id": "DdVyDm", "name": "spqr artifact domain", "author": "spqr", "description": "a", "tags": ["a"], "likes": 8, "viewed": 153, "published": 3, "date": "1696221311", "time_retrieved": "2024-07-30T17:30:53.173572", "image_code": "\n\n\n#define PI 3.14159265\n#define time iTime\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n#define BEAT (time*170.0/60.0)\nfloat seed;\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nfloat hash12(vec2 p ) {\n  float a = fract(sin(p.x * 4321.531) * 9831.113);\n float b = fract(sin(p.y * 5959.951) * 7891.517);\n float c = fract(\n sin(a * 4523.232 + b * 5490.954) * 9954.234);\n return c;\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 4.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return s;\n}\n\n\n\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat hash(in vec3 p)\n{\n    p = fract(p * vec3(821.35, 356.17, 671.313));\n    p += dot(p, p+23.5);\n    return fract(p.x*p.y*p.z);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    \n    float a = hash(ip + vec3(0, 0, 0));\n    float b = hash(ip + vec3(1, 0, 0));\n    float c = hash(ip + vec3(0, 1, 0));\n    float d = hash(ip + vec3(1, 1, 0));\n    float e = hash(ip + vec3(0, 0, 1));\n    float f = hash(ip + vec3(1, 0, 1));\n    float g = hash(ip + vec3(0, 1, 1));\n    float h = hash(ip + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(vec3(0), vec3(1), fp);\n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y), t.z);\n}\n\n\n\n\n\n\n\nfloat rand(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\nfloat rnd(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 lattice (float t ) {\n\n \n\n  float m = t;\n  float mx = floor((m-2.)/3.);\n  float my = floor((m-1.)/3.);\n  float mz = floor((m-0.)/3.);\n  \n  float n= m+1.;\n  float nx = floor((n-2.)/3.);\n  float ny = floor((n-1.)/3.);\n  float nz = floor((n-0.)/3.);\n  \n  \n \n\n\n  vec3 a =  \n  mix(\n      vec3(\n          rand(mx)-.5,\n          rand(my)-.5,\n          rand(mz)-.5\n      ),\n      vec3(\n          rand(nx)-.5,\n          rand(ny)-.5,\n          rand(nz)-.5\n      ) , \n      fract(t)\n  );\n  return a;\n}\n\nfloat tick (float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  r = smoothstep(0.,1.,r);\n  r = smoothstep(0.,1.,r);\n  return r + i;\n\n}\nvec3 flit(float t) {\n\n  vec3 x = normalize(vec3(1));\n  float t1 = tick(t);\n  float t2 = tick(t * .71);\n  float t3 = tick(t * .55);\n  x.yz *= rot(t1);\n  x.xz *= rot(t2);\n  x.yx *= rot(t3);\n  \n  return x;\n}\n\n\n\nvec3 lofi (vec3 a, float b) {\n  return floor(a/b) * b;\n \n}\n \n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\n\n\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\n\nfloat pi = 3.141592;\n\n\n\nfloat box (vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    //return max(max(q.x,q.y),q.z);\n   return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\n\nfloat sph ( vec3 p, float r) {\n  return length(p) - r;\n}\n\n\n\n\nvec3 opId(vec3 p, vec3 c) {\n     return floor(p/c);\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n  return mod(p, c)- 0.5 * c;\n}\n\n\nfloat hash21(vec2 p2)\n{\n\tp2  = fract(p2 * .1031);\n    p2 += dot(p2, p2.xy + 33.33);\n    return fract((p2.x + p2.y));\n}\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(sin((p3.x + p3.y) * p3.z)*3523.252);\n}\nvec3 hash33 (vec3 p) {\n    float x = hash31(p);\n    float y = hash31(p + vec3(1231.41, 48.42, 77.12));\n    float z = hash31(p + vec3(17.94, 111.42, 212.55));\n    return vec3(x,y,z);\n    \n}\n\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n    //pt.xz=pt.x<pt.z?pt.zx:pt.xz;\n  }\n  return pt;\n}\nfloat artifact(vec3 p, float f1) {\n  \n vec3 pt=p;\n  \n  float zz = 1.;//iTime;\n\n  float width = 13.;\n  float halfwidth = width/2.;\n  vec3 haha=lofi(pt,width);\n  \n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  \n \n  float clampBox=box(pt,vec3(2.));\n  \n  pt=ifs(pt,vec3(3.6,3.0+0.4+(zz + f1 * 121.1)/11.,3.1),vec3(3.0,2.3,3.5));\n\n  vec3 seed = floor(p/width);\n\n  float dist;\n  \n  dist=box(pt,vec3(.17));\n\n  dist=max(dist,clampBox);\n\n  return dist;\n \n}\n\n\n\n\n\nfloat field(vec3 p, vec3 dom) {\n\n    vec3 id = floor(p/dom-0.5);\n    \n    p = (fract(p/dom-0.5)-0.5)*dom;\n    \n    float f1 = hash13(id);\n  \n    float a = artifact(p,f1);\n    return a;\n}\nfloat holes (vec3 p, vec3 dom) {\n   \n   vec3 id = floor(p/dom-0.5);\n\n   p = (fract(p/dom-0.5)-0.5)*dom;\n \n \n   float prob = hash31(id);\n   \n   vec3 dim = hash33(id.zxy);\n  \n   \n  \n   \n   if ( prob < .95) {\n       dim = vec3(0);\n   }\n    \n   float b = box(p, dim);\n   \n   b = min(b, -box(p, vec3(dom/2. + .3)));\n   \n   return b;\n\n}\n\nfloat map (vec3 p) {\n  \n   vec3 dom = vec3(4.);\n \n   float f = field(p*2.,dom)/2.;\n   float h = holes(p,dom);\n    \n   // geo\n      \n\n   return max(h,f);\n  \n    \n\n}\n\nvec3 randsphere()\n{\n  float t=PI*2.*rand();\n  float p=acos(rand()*2.-1.);\n  return vec3(sin(p)*sin(t),cos(p),sin(p)*cos(t));\n}\n\n\nfloat aoFunc(vec3 p,vec3 n)\n{\n  float accum=0.;\n  for(int i=0;i<32;i++){\n    vec3 d=(0.02+0.02*float(i))*randsphere();\n    d=dot(d,n)<.0?-d:d;\n    //accum+=step(map(p+d).x,0.0)/64.0;\n    accum+=linearstep(0.02,0.0,map(p+d))/64.0;\n  }\n  return 1.0-sqrt(saturate(6.0*accum));\n}\n\n\n\n\nvec3 norm(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx)-map(p-d.yxx),\n    map(p+d.xyx)-map(p-d.xyx),\n    map(p+d.xxy)-map(p-d.xxy)\n  ));\n}\n\n\nvec3 norm3(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\nfloat hash( float p )\n{\n\tfloat h = dot(p,127.1);\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nvec3 hash13( float p )\n{\n\treturn vec3( hash(p), hash(p+653.13), hash(p+211.22) );\n    \n}\n\n\nfloat tock (float t){\n  return t + sin(t);\n}\n\n\nfloat hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); p = m*p*2.02;\n  //  f += 0.0312*noise( p );\n    \n    return f;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n \n \n // nav\n \n float tt = iTime;\n  vec3 s = vec3(0,4,-11);\n  vec3 fwd = vec3(.1,.22,1) * tt * 8.1;\n  vec3 nudge = vec3(0,0,10);\n  nudge.xz *= rot(tt*.15);\n  nudge.yz *= rot(tt*.21);\n  nudge.xy *= rot(tt*.31);\n  \n  s += fwd + nudge;\n  \n  vec3 arm = vec3(0,0,1);\n  arm.xz *= rot(tick(tt*.2));\n  arm.yz *= rot(tick(cos(tt*.43)));\n  \n  vec3 t = s + arm;\n\n\n  \n   \n \n \n \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(vec3(0,1,0),cz));\n  vec3 cy=normalize(cross(cz,cx));\n      // fisheye\n  cz += dot(uv,uv)/11.;\n  \n \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n \n  bool hit = false;\n  float d;\n  float edge = 0.;\n  float dd=0.;\n  float i = 0.;\n  vec3 p=s;\n  vec3 n1,n2;\n \n  \n \n  // march\n \n  for(float z=0.;z<200.;z++){ \n  \n    i = z;\n    d = map(p);\n\n    if ( d < .001 ) {\n      hit = true;\n      break;\n    } \n    \n    dd += d;\n    p += r * d;\n\n  }\n \n  \n  \n  // hue\n  \n  vec3 col = vec3(0);\n\n\n\n  \n  \n     vec3 n = norm(p);\n     vec3 l1 = normalize(vec3(-1,-4,-1));\n     l1.xz *= rot(tt);\n     l1.yz *= rot(tt*.55);\n     \n     vec3 l2 = normalize(vec3(1));\n     l2.xz *= rot(tt*.41);\n     l2.yx *= rot(tt*.35);\n   \n   \n     \n        \n     if ( dot(n,l1) < 0.) {\n              l1 = -l1;\n     }\n     if ( dot(n,l2) < 0.) {\n              l2 = -l2;\n     }\n     vec3 h1 = normalize(l1-r);\n     vec3 h2 = normalize(l2-r);\n     \n     float spec1 =( 0.4 + pow(max(0., dot(n,h1)),41.));\n     float spec2 =( 0.4 + pow(max(0., dot(n,h2)),22.));\n    \n     float diff = max(0., dot(n,l1));\n     \n     col += diff * (spec1 + spec2);\n     \n     //n2 = norm(p, vec2(0.0, 1.0E-2 ));\n    // n1 = norm(p, vec2(0.0, 1.9E-2 ));\n\n\n     //edge = saturate(length(n1-n2)/0.1);\n  \n     //col -= edge;\n\n     if (!hit) {\n        col =  vec3(.2,.2,.4) * dot(r,normalize(vec3(1.,1.,0.)));\n        col = abs(col+.1);\n     }\n\n  \n \n     fragColor = vec4(col, 1.0);\n\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 208, 208, 311], [312, 312, 334, 334, 542], [544, 544, 567, 567, 746], [748, 748, 802, 857, 1081], [1083, 1083, 1107, 1107, 1309], [1313, 1313, 1342, 1342, 1407], [1408, 1408, 1450, 1450, 1557], [1559, 1559, 1582, 1582, 1690], [1692, 1692, 1716, 1716, 2263], [2271, 2271, 2292, 2292, 2341], [2342, 2342, 2362, 2362, 2411], [2413, 2413, 2434, 2434, 2481], [2482, 2482, 2501, 2501, 2570], [2572, 2572, 2597, 2597, 3066], [3068, 3068, 3091, 3091, 3208], [3209, 3209, 3229, 3229, 3413], [3417, 3417, 3446, 3446, 3475], [3479, 3479, 3504, 3504, 3544], [3549, 3549, 3563, 3563, 3603], [3606, 3606, 3642, 3642, 3695], [3722, 3722, 3750, 3750, 3876], [3880, 3880, 3919, 3919, 3996], [3999, 3999, 4029, 4029, 4055], [4060, 4060, 4087, 4087, 4113], [4115, 4115, 4143, 4143, 4174], [4177, 4177, 4200, 4200, 4295], [4296, 4296, 4319, 4319, 4436], [4437, 4437, 4459, 4459, 4625], [4628, 4628, 4666, 4666, 4989], [4990, 4990, 5024, 5024, 5491], [5497, 5497, 5528, 5528, 5683], [5684, 5684, 5716, 5716, 6014], [6016, 6016, 6036, 6036, 6179], [6181, 6181, 6200, 6200, 6307], [6310, 6310, 6339, 6339, 6585], [6590, 6590, 6616, 6616, 6741], [6744, 6744, 6764, 6764, 6883], [6884, 6884, 6907, 6907, 6985], [6987, 6987, 7011, 7011, 7075], [7078, 7078, 7099, 7099, 7122], [7125, 7125, 7147, 7147, 7237], [7289, 7289, 7315, 7315, 7609], [7611, 7611, 7632, 7632, 7870], [7871, 7871, 7890, 7890, 8009], [8012, 8012, 8069, 8069, 10039]], "test": "untested"}
{"id": "dddcD4", "name": "psychadelia-1", "author": "yotter", "description": "Throwing math at a wall and seeing what sticks!", "tags": ["fractal", "psychedelic"], "likes": 0, "viewed": 32, "published": 3, "date": "1696201202", "time_retrieved": "2024-07-30T17:30:53.975428", "image_code": "// Made from expirimenting while following the legendary kishimisu tutorial:\n// https://www.youtube.com/watch?v=f4s1h2YETNY\n\nvec3 palette( in float t)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 1.0);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0.9, 0.2, 1.5);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        uv = fract((0.2*i+0.5*sin(0.2*iTime)+1.5)*uv) - 0.5;\n        float d = length(uv) * exp(sin(0.3*iTime) * length(uv0));\n        vec3 col = palette(d+ i*0.9 + length(uv0) + iTime*0.1);\n\n\n        float factor = 8.;\n        d = sin(d*factor + iTime)/factor;\n        d = abs(d);\n        d = pow(0.02/d, 1.2);\n\n        finalColor += col * d;\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dddcD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 152, 152, 328], [330, 330, 387, 387, 946]], "test": "untested"}
{"id": "DdVSzd", "name": "Phased Array Waves", "author": "Peace", "description": "Phased array waves generated by placing radial wave emitters together on a line, with same frequency, this technology is used in satellites. I was inspired by Code Parade, who made a laser, but instead of light waves it shot sound waves, it used this.", "tags": ["sound", "wave", "radar", "array", "satellite", "phased"], "likes": 10, "viewed": 398, "published": 3, "date": "1696197226", "time_retrieved": "2024-07-30T17:30:54.735396", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float w = getWave(uv, iTime);\n    \n    vec3 col = vec3(0);\n    col.rg = abs(vec2(w));\n    col.g *= col.g;\n    col.b = col.g * col.g;\n\n    fragColor = vec4(sqrt(col), 1.0);\n    fragColor.rgb = mix(vec3(0.2, 0.7, 1.0), fragColor.rgb, clamp(2048.0 * dot(uv - LISTENER_POS_L, uv - LISTENER_POS_L), 0.0, 1.0));\n    fragColor.rgb = mix(vec3(0.5, 1.0, 0.5), fragColor.rgb, clamp(2048.0 * dot(uv - LISTENER_POS_R, uv - LISTENER_POS_R), 0.0, 1.0));\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    vec2 w = vec2(getWave(LISTENER_POS_L, time), getWave(LISTENER_POS_R, time));\n    return w * 16.0;\n}", "sound_inputs": [], "common_code": "const float TWO_PI = 6.28318530718;\nconst vec2 LISTENER_POS_L = vec2(1.0, 0.0);\nconst vec2 LISTENER_POS_R = LISTENER_POS_L;\nconst float SPREAD = 0.4;\nconst float FREQ = 64.0;\nconst float MOVE_AMOUNT = 1.0;\nconst float MOVE_SPEED = 4.0;\nconst int EMITTER_COUNT = int(FREQ * 4.0 * SPREAD); // Set to atleast (FREQ * 4 * SPREAD) to avoid multiple transmitter lines\n\nfloat wave(vec2 uv, vec2 p, float o, float f, float t)\n{\n    float d = distance(uv, p);\n    float w = sin(((d - t) * f - o) * TWO_PI) / (1.0 + 256.0 * d * d);\n    return w;\n}\n\nfloat getWave(vec2 uv, float t)\n{\n    float w = 0.0;\n    // Higher frequency = Further travel (Until it glitches out and everything explodes, don't try at home)\n    // You can change direction by offsetting either frequency or phase (offsetting frequency has side effects, so usually phase is offset)\n    for (float i = 0.0; i <= SPREAD; i += SPREAD / float(EMITTER_COUNT - 1))\n        w += wave(uv, vec2(0, i * 2.0 - SPREAD), i * sin(t * MOVE_SPEED) * MOVE_AMOUNT * FREQ, FREQ, t);\n    w /= float(EMITTER_COUNT) * 0.04;\n    \n    return w;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/DdVSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 575]], "test": "untested"}
{"id": "dsyyDm", "name": "Fork: Sound Lanes", "author": "QuantumSuper", "description": "An auto-VJ with a 2D network of pseudo-random lanes with light-sparks wandering along them. Reactive to sound.\n\n - Use with music in iChannel0 -", "tags": ["2d", "music", "lanes"], "likes": 6, "viewed": 387, "published": 3, "date": "1696196198", "time_retrieved": "2024-07-30T17:30:55.480404", "image_code": "// Fork: Sound Lanes 0.4.231001 by QuantumSuper\n// Forked from Light Lanes 0.51.230927 by QuantumSuper \n// auto-vj with 2d pseudo-random lanes with light-\"sparks\" wandering along them reactive to sound\n// note: The scale of ftt.x seems sensitive for this one (scale down in compressFft() if too agitated).\n// \n// - use with music in iChannel0 -\n\n#define aTime 150./60.*iTime\n#define PI 3.14159265359\nvec4 fft, ffts; //compressed frequency amplitudes\n\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nfloat aaStep( float fun){return smoothstep( min(fwidth(fun),.001), .0, fun);} //simple antialiasing\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nfloat hash21(vec2 p){ //pseudorandom generator, see The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1./k;\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2., 0.);\n    return -length(p)*sign(p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    float amp = 0.;\n\tfloat delY = .1;\n\tfloat r, ox, fun;\n    compressFft(); //initializes fft, ffts\n\n    \n    // Lane generation\n\tfor (float m=-1.;m<=1.;m+=.05){\n        ox = m;\n        fun = uv.x-ox;\n        for (float n=0.;n<2./delY;n++){ //uv.y -1..1\n            r = floor(hash21(vec2(n+ceil(aTime/16.),ox+max(.98*step(fft.x,.96),fract(aTime/16.))))*3.-1.); //r {-1,0,1}\n            fun += (r*(uv.y-(delY*n-1.))+ox+m) * step(delY*n-1.,uv.y+.001) * step(uv.y+.001,delY*(n+1.)-1.); //+.001 to avoid weird? singularities for negative uv.y\n            ox = r*(delY*(n+1.)-1.) - (r*(delY*n-1.)-ox-m) - m; //? isnt that supposed to be: ox += r*delY ?\n        } \n\t\tamp += (.8+.5*ffts[int(m*m*3.)]) * ( //brightness on voice\n            aaStep(abs(fun)-.009*iResolution.y/iResolution.x) //lane\n            * (.1+.9*aaStep(abs(fragCoord.y/iResolution.y-fract(aTime/8.+m*(.6+.4*ffts.w)))-.005*(1.+17.*step(.95,fft.x))*iResolution.y/iResolution.x)) //step \"spark\"\n            + 1e-3 / length(vec2(fun, fragCoord.y/iResolution.y-fract(aTime/8.+m*(.6+.4*ffts.w))))); //glow \"spark\"\n\t} \n\n\n    // Color design\n    vec3 col = vec3(clamp(amp,.0,1.)); \n    col += col * max(.0,1.-5.*fragCoord.y/iResolution.y*(1.-fft.x*fft.x*fft.x)) //bass level dependend brightness, y-axis\n        + smoothstep(.0,1.,.2-amp) * fft.w; //lighten darker background\n    col *= abs( cos( .06*aTime + PI/vec3(.5,2.,4.) + ffts.xyz)); //color shift \n    col *= mix( .2+.8*(1.-length(uv)), 1., fft.z); //vignette\n\n    \n    // Center symbol\n    uv *= .8+.5*(1.-fft.x*fft.x); \n    fun = mix(\n        abs(length(uv)-.23)-.07, //circle\n        (sin(aTime/4.+fft.y-.5)<.0)? //switch when unused\n            abs(dot(abs(uv*rotM(PI/4.)),vec2(1))-.25)-.1 : //square\n            abs(sdEquilateralTriangle(uv*4.))-.27, //triangle\n        clamp( sin(aTime/2.+fft.y-.5), .0, 1.));\n        \n    col = vec3(ffts.x<=ffts.y,ffts.y<=ffts.z,ffts.z<=ffts.x) * fft.z * .08 //overall tint \n        + abs(1.-col) * aaStep(fun) * fft.y * .13 //symbol\n        + col * (1.-step(length(col),.9)*aaStep(fun)) * .8; //background\n      \n    fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 34835, "src": "https://soundcloud.com/mischluft/mischluft-just-rave", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsyyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 471, 562, 1684], [1686, 1686, 1711, 1711, 1763], [1787, 1787, 1806, 1806, 1859], [1882, 1882, 1903, 1973, 2066], [2068, 2068, 2104, 2163, 2367], [2370, 2370, 2425, 2425, 4647]], "test": "untested"}
{"id": "dsycDw", "name": "Lava con ondas", "author": "Sergeindamix", "description": "Este shader generará un paisaje abstracto que parece estar compuesto de lava en movimiento:", "tags": ["chatgpt"], "likes": 1, "viewed": 190, "published": 3, "date": "1696190572", "time_retrieved": "2024-07-30T17:30:56.237380", "image_code": "vec3 palette(float t){\n    return vec3(0.5 + 0.5 * sin(t * 5.0), 0.2 + 0.2 * sin(t * 3.0), 0.1 + 0.4 * sin(t));\n}\n\nfloat map(vec3 p, float time){\n    float d = length(p) - 1.0;\n    float displacement = 0.1 * sin(time + 3.0 * p.x) * sin(time + 3.0 * p.y);\n    return d + displacement;\n}\n\nvec4 rm(vec3 ro, vec3 rd, float time){\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float d;\n    for(float i = 0.0; i < 64.0; i++){\n        vec3 p = ro + rd * t;\n        d = map(p, time) * 0.5;\n        if(d < 0.02){\n            break;\n        }\n        if(d > 100.0){\n            break;\n        }\n        col += palette(time + length(p) * 0.1) / (400.0 * (d));\n        t += d;\n    }\n    return vec4(col, 1.0 / (d * 100.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\n    vec3 ro = vec3(0.0, 0.0, -15.0);\n    vec3 cf = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 cs = normalize(cross(cf, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cf, cs));\n    \n    vec3 uuv = ro + cf * 3.0 + uv.x * cs + uv.y * cu;\n    \n    vec3 rd = normalize(uuv - ro);\n    \n    vec4 col = rm(ro, rd, iTime);\n    \n    fragColor = col;\n}\n", "image_inputs": [{"id": 34833, "src": "https://soundcloud.com/technoso-under-klang/techno-set-2023-10-01-at-11h23m20s?si=c17341b6f7ab4edea3ce2a8e216ff359&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/dsycDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 113], [115, 115, 145, 145, 285], [287, 287, 325, 325, 716], [718, 718, 772, 772, 1186]], "test": "untested"}
{"id": "mdyyWw", "name": "bubble-test", "author": "WIzODE", "description": "playing with chatgpt", "tags": ["bubble"], "likes": 0, "viewed": 129, "published": 3, "date": "1696183510", "time_retrieved": "2024-07-30T17:30:56.989370", "image_code": "vec4 iridescent(in vec3 normal, in vec2 uv, in float alpha) {\n    // Convert to polar coordinates\n    float r = length(uv);\n    float theta = atan(uv.y * iTime, uv.x * iTime);\n\n    float factor = 20.0;\n\n    // Apply a twist\n    theta += factor / 4.0 * normal.x * r;\n\n    // Convert back to Cartesian coordinates\n    vec2 twistedUV = r * vec2(cos(theta), sin(theta));\n\n    \n    // Swirly pattern based on twisted UV\n    vec3 swirl = vec3(\n        sin(factor * twistedUV.x + 3.0 * sin(1.23 * iTime) ),\n        sin(factor * twistedUV.y + 3.0 * sin(1.59 * iTime)),\n        sin(factor * twistedUV.x + factor * twistedUV.y + 3.0 * sin(1.17 * iTime))\n    );\n\n    // Base iridescent color\n    float thickness = 500.0 + 100.0 * sin(iTime);\n    float R = abs(thickness - 400.0) / 400.0;\n    float G = abs(thickness - 500.0) / 500.0;\n    float B = abs(thickness - 600.0) / 600.0;\n    vec3 baseColor = vec3(R, G, B);\n\n    // Blend swirly pattern with base color\n    vec3 color = mix(baseColor, swirl, 0.8);\n\n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera parameters\n    vec3 camPos = vec3(0.0, 0.0, 5.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = cross(camDir, camUp);\n\n    // Construct a ray from the camera through the pixel\n    vec3 rayDir = normalize(camDir + uv.x * camRight + uv.y * camUp);\n\n    // Bubble parameters\n    vec3 bubbleCenter = vec3(sin(1.7 * iTime), sin(1.13 * iTime), sin(1.11 * iTime));\n    float radius = 0.55;\n\n    // Calculate the ray-sphere intersection\n    vec3 oc = camPos - bubbleCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - (radius * radius);\n    float discriminant = b*b - 4.0*a*c;\n\n    vec4 bgColor = texture(iChannel0, uv);\n\n    if (discriminant > 0.0) {\n        // If the ray intersects the sphere, calculate the distance along the ray to the intersection\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float t = min(t1, t2);\n\n        // Calculate the intersection point\n        vec3 intersection = camPos + t * rayDir;\n\n        // Compute the normal at the intersection\n        vec3 normal = normalize(intersection - bubbleCenter);\n\n        // Compute the distance from the camera to the intersection\n        float dist = length(intersection - camPos);\n\n        // Use the distance and normal to compute the iridescent color\n        fragColor = mix(iridescent(normal, uv, 0.2),bgColor,0.8);\n    } else {\n        fragColor = bgColor;\n    }\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/mdyyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 97, 1028], [1030, 1030, 1087, 1087, 2736]], "test": "untested"}
{"id": "csKcD1", "name": "Hot Girl (Spline Interpolation)", "author": "misol101", "description": "This is the most annoying way of \"drawing\" I have ever experienced #?%&%!! :) And compilation takes forever (help!)\n\nPress mouse to remove censorship.\n\nSpace toggles animation, Enter shows control points. V and W switches drawing method.", "tags": ["2d", "cartoon", "spline", "catmullrom", "sexy", "girl", "nude"], "likes": 37, "viewed": 4629, "published": 3, "date": "1696182421", "time_retrieved": "2024-07-30T17:30:57.923871", "image_code": "/*--------------------------------------------------------------------------------------\n\n Hot Girl by misol101\n\n Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n--------------------------------------------------------------------------------------*/\n\n#define V(a,b) vec2((a),(b))\n\n// from https://www.shadertoy.com/view/lsKSWR by Ippokratis\nfloat vignette(vec2 FC, float extent, float intensity) {\n\tvec2 uv = FC.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * intensity;\n    return pow(vig, extent);\n}\n\nvec4 curtain(vec2 uv) {\n    const int NUML = 12;\n    vec2 x_w[NUML] = vec2[] ( V(0.686,0.004), V(0.325,0.004),\n                              V(0.716,0.002), V(0.756,0.0025), V(0.816,0.003), V(0.906,0.003), V(0.976,0.003),\n                              V(0.299,0.002), V(0.265,0.0025), V(0.205,0.003), V(0.125,0.003), V(0.025,0.003) );\n    for (int i=0; i<NUML; i++) {\n        float xd = abs(uv.x - x_w[i].x);\n        if (xd < x_w[i].y) { return vec4(0.); }\n    }\n    return vec4(1.);\n}\n\nvoid censor(inout vec4 fc, vec2 uv, vec2 p) {\n    float asp = iResolution.y/iResolution.x;\n    float xd = abs(uv.x - p.x + (uv.y - p.y)*asp);\n    float xd2 = abs(uv.x - p.x - (uv.y - p.y)*asp);\n    float yd = abs(uv.y - p.y);\n    if ((xd < 0.007 || xd2 < 0.007) && yd < 0.024) { fc = vec4(0.75,0.,0.,0.); }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    if (uv.x>0.686 || uv.x < 0.325) fragColor=vec4(1.); //vec4(1.,0.9,0.9,0.);\n    fragColor=min(fragColor, curtain(uv)); // +sin(iTime*4.5)*.002\n\n    if (iMouse.z < 0.5) {\n        censor(fragColor, uv, vec2(0.524, 0.634));\n        censor(fragColor, uv, vec2(0.424, 0.663));\n        censor(fragColor, uv, vec2(0.424, 0.313));\n    }\n\n\tfragColor *= 1.0 - 0.03 * length(fragCoord / iResolution.xy - 0.5);\n    fragColor *= vignette(fragCoord, 0.04, 95.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Original spline routine by revers (https://www.shadertoy.com/view/MlGSz3)\n\n/**\n * Tension. Default Catmul-Rom matrix has tension equal to 0.5.\n *\n * Values below 0.5 will cause sharp edges,\n * values above 0.5 will produce more curly lines.\n */\n#define T 0.6\n\n/**\n * Catmull-Rom Matrix\n */\nconst mat4 CRM = mat4(-T,        2.0 - T,  T - 2.0,         T,\n                       2.0 * T,  T - 3.0,  3.0 - 2.0 * T,  -T,\n                      -T,        0.0,      T,               0.0,\n                       0.0,      1.0,      0.0,             0.0);\n/**\n * Catmull-Rom Spline Interpolation\n */\nvec2 interpolate(vec2 G1, vec2 G2, vec2 G3, vec2 G4, float t) {\n    vec2 A = G1 * CRM[0][0] + G2 * CRM[0][1] + G3 * CRM[0][2] + G4 * CRM[0][3];\n    vec2 B = G1 * CRM[1][0] + G2 * CRM[1][1] + G3 * CRM[1][2] + G4 * CRM[1][3];\n    vec2 C = G1 * CRM[2][0] + G2 * CRM[2][1] + G3 * CRM[2][2] + G4 * CRM[2][3];\n    vec2 D = G1 * CRM[3][0] + G2 * CRM[3][1] + G3 * CRM[3][2] + G4 * CRM[3][3];\n\n    return t * (t * (t * A + B) + C) + D;\n}\n//=======================================================================================\n\nfloat sdSegmentSq(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\tvec2 d = pa - ba * h;\n\treturn dot(d, d);\n}\n\nfloat sdPointSq(vec2 p, vec2 a) {\n\tvec2 d = p - a;\n\treturn dot(d, d);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n#define V(a,b) vec2((a),(b))\n\nconst int KEY_SPACE = 32;\nconst int KEY_ENTER = 13;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\n\nbool readKey(int key) { return texelFetch( iChannel1, ivec2(key, 0), 0).x > .5; }\nbool readKeyToggle(int key) { return texelFetch( iChannel1, ivec2(key, 2), 0).x > .5; }\n\nconst int NUM = 12;\nconst int WNUM = NUM-2;\n\nvoid drawPath(out vec4 fragColor, vec2 fragCoord, vec2 path[NUM], float linew[WNUM], int nofP) {\n\tfloat e = 1.0 / iResolution.x;\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(1.0);\n\n    float scale = iResolution.x/1920.;\n    \n\t//------------------------------------------------------\n\t// draw path\n\t//------------------------------------------------------\n\tif (readKeyToggle(KEY_ENTER)) {\n\t\tvec2 d = vec2(1000.0);\n        int j = 1;\n\t\tfor (int i = 0; i < (nofP - 1); i++) {\n\t\t\tvec2 a = path[i + 0];\n\t\t\tvec2 b = path[i + 1];\n            \n            vec2 tmp = vec2(sdSegmentSq(uv, a, b), sdPointSq(uv, a));\n            if (tmp.y < d.y) {\n                j = i;\n            }\n\t\t\td = min(d, tmp);\n\t\t}\n\t\t//d.x = sqrt(d.x);\n\t\td.y = sqrt(min(d.y, sdPointSq(uv, path[nofP - 1])));\n\t\tcol = mix(col, j==0?vec3(0.3, 0.8, 0.3):j==nofP-2?vec3(1.0, 0.0, 0.0):vec3(0.9, 0.6, 0.0), 1.0 - smoothstep(12.0 * scale * e, 13.0 * scale * e, d.y));\n\t}\n\n\t//------------------------------------------------------\n\t// Catmull-Rom interpolation\n\t//------------------------------------------------------\n\t{\n\t\tfloat d = 1e5;\n\t\tfloat ani = (cos(max(0.,iTime-0.0))*0.4+0.4)*float(nofP);\n        if (!readKeyToggle(KEY_SPACE)) ani = 1.0 * float(nofP); // draw entire thing\n\n\t\tvec2 p = path[0];\n        float lm=0.5;\n\n\t\tfor (int i = 0; i < nofP - 3; i++) {\n\t\t\tfloat fi = float(i);\n\n\t\t\tif (fi > ani) {\n\t\t\t\tbreak;\n\t\t\t}\n            \n\t\t\tvec2 A = path[i + 0];\n\t\t\tvec2 B = path[i + 1];\n\t\t\tvec2 C = path[i + 2];\n\t\t\tvec2 D = path[i + 3];\n            \n\t\t\tfor (float t = 0.0; t <= 1.01; t += 0.1) {\n\t\t\t\tvec2 q = interpolate(A, B, C, D, t);\n\n                float dt = sdSegmentSq(uv, p, q);\n                // adjust/interpolate line width for each segment (added by misol101)\n                if (dt < d) {\n                    d = dt;\n                    lm = linew[i];\n                    \n                    float l1 = length((i==0?A:B)-C);\n                    float l2 = length(C-uv);\n                    if (!readKeyToggle(KEY_V)) lm = mix(linew[i+1], linew[i], smoothstep(0.1,0.9,l2/l1) );\n                }\n\t\t\t\tp = q;\n\n\t\t\t\tif (fi + t > ani) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        if (readKeyToggle(KEY_W)) lm=0.8;\n\t\td = sqrt(d);\n\n        float bsize = 12.0*scale*lm;\n        float aa = bsize - 4.*scale;\n\n\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.0 - smoothstep(aa * e, bsize * e, d));\n        col *= 0.75 + 0.25 * smoothstep(0.0, 0.11*lm, sqrt(d));\n\t}\n\n\tfragColor = vec4(col, 1.0);\n}\n\nvoid animSingle(inout float result, float time, float startTime, float duration) {\n    if (time > startTime && time < startTime+duration) {\n        result = (time-startTime) / duration; \n    }\n}\n\nvoid getBlink(inout float bl, float time, float blTime, float blLen) {\n    if (time > blTime && time < blTime+blLen) {\n        bl = sin((time-blTime)/blLen*3.142);\n    }\n}\n\n// first line between points is drawn straight\n\n#define FACE\n#define HAIR_RIGHT\n#define HAIR_LEFT\n#define EYE_LEFT\n#define EYE_RIGHT\n#define MOUTH\n#define BREAST_STOMACH_LEFT\n#define BREAST_RIGHT\n#define ARM_LEFT\n#define ARM_RIGHT_UPPER\n#define ARM_RIGHT_LOWER\n#define LEG_LEFT\n#define LEG_RIGHT_L\n#define LEG_RIGHT_R\n#define NAVEL\n#define NIPPLES\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord / iResolution.xy;\n    const vec2 P = vec2(0.); // padding\n    vec4 colC=vec4(1.), colT;\n\n#ifdef ARM_RIGHT_UPPER\n    if (length(uv-V(0.613,0.6)) < 0.18) {\n        const vec2 cN = V(0.685,0.499); // last point, to add twice\n        vec2 armRU[NUM] =  vec2[] ( V(0.578,0.765), V(0.579,0.734), V(0.614,0.738), V(0.627,0.709), V(0.599,0.61), V(0.587,0.51), V(0.619,0.49), cN, cN, P, P, P );\n        float linewArmRU[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.8, 0.7, 0.8, 0.5, -0., -0., -0. );\n        \n        /*float amv = 0.;\n        animSingle(amv, mod(iTime,23.), 7.8, 9.2);\n        amv = sin(amv*4.*3.1416);\n        armRU[7].y -= amv*0.04*0.3;\n        armRU[8].y -= amv*0.04*0.3;*/\n        \n        drawPath(colT, fragCoord, armRU, linewArmRU, 9);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef ARM_RIGHT_LOWER\n    if (length(uv-V(0.607,0.502)) < 0.1) {\n        vec2 armRD[NUM] =  vec2[] ( V(0.563,0.568), V(0.563,0.568), V(0.548,0.476), V(0.568,0.439), V(0.609,0.429), V(0.68,0.447), V(0.68,0.447), P,P,P,P,P );\n        float linewArmRD[WNUM] = float[] ( 0.6, 1.0, 0.6, 0.95, 0.5, -0., -0., -0., -0., -0. );\n\n        /*float amv = 0.;\n        animSingle(amv, mod(iTime,23.), 7.8, 9.2);\n        amv = sin(amv*4.*3.1416);\n        armRD[5].y -= amv*0.03*0.3;\n        armRD[6].y -= amv*0.03*0.3;*/\n\n        drawPath(colT, fragCoord, armRD, linewArmRD, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef LEG_RIGHT_L\n    if (length(uv-V(0.442,0.187)) < 0.2) {\n        const vec2 cN = V(0.432,0.0);\n        vec2 legRL[NUM] =  vec2[] ( V(0.456,0.368), V(0.446,0.352), V(0.431,0.308), V(0.423,0.23), V(0.423,0.137), V(0.431,0.019), cN, cN,P,P,P,P );\n        float linewLegRL[WNUM] = float[] ( 0.3, 0.5, 0.6, 0.6, 0.75, 0.7, -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, legRL, linewLegRL, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef LEG_RIGHT_R\n    if (length(uv-V(0.517,0.261)) < 0.3) {\n        const vec2 cN = V(0.5535,0.529);\n        vec2 legRR[NUM] = vec2[] ( V(0.461,0.0), V(0.465,0.01), V(0.492,0.098), V(0.509,0.169), V(0.520,0.242), V(0.520,0.314), V(0.501,0.399), V(0.498,0.453), V(0.525,0.498), cN, cN, P );\n        float linewLegRR[WNUM] = float[] ( 0.6, 0.7, 0.85, 1.0, 0.95, 0.5, 0.5, 1.0, 1.0, -0. );\n        drawPath(colT, fragCoord, legRR, linewLegRR, 11);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef LEG_LEFT\n    if (length(uv-V(0.397,0.221)) < 0.19) {\n        const vec2 cN = V(0.428,0.062);\n        vec2 legL[NUM] =  vec2[] ( V(0.425,0.307), V(0.425,0.307), V(0.399,0.336), V(0.375,0.4), V(0.375,0.4), V(0.368,0.346), V(0.382,0.218), V(0.41,0.104), cN, cN ,P,P);\n        float linewLegL[WNUM] = float[] ( 0.9, 0.5, 0.0, 0.35, 0.5, 0.8, 0.6, 0.6, -0., -0. );\n        drawPath(colT, fragCoord, legL, linewLegL, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef BREAST_RIGHT\n    if (length(uv-V(0.54,0.634)) < 0.1) {\n        const vec2 cN = V(0.545,0.706);\n        vec2 breastR[NUM] =  vec2[] ( V(0.594,0.681), V(0.58,0.666), V(0.579,0.621), V(0.558,0.563), V(0.516,0.5552), V(0.492,0.589), V(0.489,0.649), V(0.511,0.7), cN, cN, P,P );\n        float linewBreastR[WNUM] = float[] ( 0.4, 0.6, 1.0, 0.0, 0.55, 0.5, 0.85, 0.5, -0., -0. );\n        drawPath(colT, fragCoord, breastR, linewBreastR, 10);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef FACE\n    if (length(uv-V(0.563,0.841)) < 0.1) {\n        const vec2 cN = V(0.594,0.923);\n        vec2 face[NUM] =  vec2[] ( V(0.515,0.845), V(0.522,0.812), V(0.535,0.776), V(0.56,0.754), V(0.589,0.783), V(0.601,0.844), V(0.598,0.911), cN, cN, P,P,P );\n        float linewFace[WNUM] = float[] ( 0.5, 0.8, 0.8, 0.6, 0.5, 0.3, 0.0, -0., -0., -0. );\n        drawPath(colT, fragCoord, face, linewFace, 9);\n        colC=min(colC,colT);\n\n        float nose=length(uv-V(0.563,0.841));\n        if (nose < 0.004 && uv.y <= 0.842) {\n            float aap = smoothstep(0.002,0.004, nose);\n            colC=min(colC, vec4(aap));\n        }\n    }\n#endif\n\n#ifdef BREAST_STOMACH_LEFT\n    if (length(uv-V(0.45,0.587)) < 0.22) {\n        const vec2 cN = V(0.372,0.388);\n        vec2 breastL[NUM] =  vec2[] ( V(0.51,0.719), V(0.50,0.717), V(0.462,0.728), V(0.428,0.704), V(0.421,0.634), V(0.443,0.587), V(0.474,0.575), V(0.465,0.551), V(0.421,0.506), V(0.392,0.461), cN, cN );\n        float linewBreastL[WNUM] = float[] ( 0.4, 0.5, 0.9, 0.7, 0.6, 0.7, 0.9, 0.9, 0.7, 0.3 );\n        drawPath(colT, fragCoord, breastL, linewBreastL, 12);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef HAIR_RIGHT\n    if (length(uv-V(0.563,0.841)) < 0.16) {\n        const vec2 cN = V(0.59,0.920);\n        vec2 hairR[NUM] =  vec2[] ( V(0.618,0.737), V(0.621,0.782), V(0.617,0.889), V(0.594,0.958), V(0.55,0.978), V(0.519,0.921), V(0.505,0.859), V(0.491,0.813), V(0.538,0.881), V(0.573,0.931), cN, cN);\n        float linewHairR[WNUM] = float[] ( 0.5, 0.8, 0.8, 0.6, 0.7, 0.4, 0.05, 0.8, 0.4, 0.5 );\n        drawPath(colT, fragCoord, hairR, linewHairR, 12);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef EYE_RIGHT\n    if (length(uv-V(0.584,0.864)) < 0.03) {\n        const vec2 cN = V(0.573,0.856);\n        vec2 eyeR[NUM] =  vec2[] ( V(0.57,0.862), V(0.57,0.862), V(0.585,0.87), V(0.605,0.865), V(0.587,0.859), cN, cN, P, P, P, P, P);\n\n        float bl = 0.;\n        float period = 7.;\n        float time = mod(iTime, period);\n        getBlink(bl, time, 2.1, 0.3);\n        if ((int(iTime/period) & 1) == 0) {\n            getBlink(bl, time, 4.7, 0.3);\n            getBlink(bl, time, 5.3, 0.3);\n        }\n        eyeR[2].y -= bl*0.009;\n\n        float linewEyeR[WNUM] = float[] ( 0.3, 0.6, 0.8, 0.6, 0.3, 0.4, -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, eyeR, linewEyeR, 7);\n        colC=min(colC,colT);\n\n        float pup=length(vec2((uv.x-0.584), (uv.y-0.864+0.003*bl)*(1.+bl)));\n        if (pup < 0.006) {\n            float aap = smoothstep(0.005,0.006, pup);\n            colC=min(colC, vec4(aap));\n        }\n    }\n#endif\n\n#ifdef EYE_LEFT\n    if (length(uv-V(0.541,0.862)) < 0.02) {\n        const vec2 cN = V(0.573,0.856);\n        vec2 eyeL[NUM] =  vec2[] ( V(0.553,0.858), V(0.553,0.858), V(0.532,0.869), V(0.528,0.859), V(0.551,0.856), cN, cN, P, P, P, P, P);\n        float linewEyeL[WNUM] = float[] ( 0.3, 0.6, 0.8, 0.3, -0., -0., -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, eyeL, linewEyeL, 6);\n        colC=min(colC,colT);\n\n        float pup=length(uv-V(0.541,0.862));\n        if (pup < 0.005) {\n            float aap = smoothstep(0.004,0.005, pup);\n            colC=min(colC, vec4(aap));\n        }\n    }\n#endif\n\n#ifdef MOUTH\n    if (length(uv-V(0.565,0.809)) < 0.04) {\n        const vec2 cN = V(0.544,0.812);\n        vec2 mouth[NUM] =  vec2[] ( V(0.541,0.817), V(0.544,0.812), V(0.564,0.821), V(0.585,0.821), V(0.575,0.791), V(0.555,0.787), cN, cN, P, P, P, P);\n        float linewMouth[WNUM] = float[] ( 0.3, 0.6, 0.3, 1.0, 1.0, 0.4, 0.4, -0., -0., -0. );\n        drawPath(colT, fragCoord, mouth, linewMouth, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef HAIR_LEFT\n    if (length(uv-V(0.521,0.77)) < 0.09) {\n        const vec2 cN = V(0.513,0.83);\n        vec2 hairL[NUM] =  vec2[] ( V(0.541,0.764), V(0.54,0.747), V(0.528,0.724), V(0.503,0.724), V(0.494,0.753), V(0.51,0.796), V(0.513,0.837), cN, cN, P,P,P);\n        float linewHairL[WNUM] = float[] ( 0.5, 0.8, 0.8, 0.6, 0.4, 0.8, -0., -0., -0., -0. );\n        drawPath(colT, fragCoord, hairL, linewHairL, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef ARM_LEFT\n    if (length(uv-V(0.382,0.502)) < 0.09) {\n        vec2 armL[NUM] =  vec2[] ( V(0.433,0.518), V(0.413,0.514), V(0.366,0.53), V(0.300,0.54), V(0.317,0.513), V(0.349,0.48), V(0.391,0.463), V(0.391,0.463), P,P,P,P );\n        float linewArmL[WNUM] = float[] ( 0.6, 0.6, 0.3, 0.3, 0.7, 0.95, -0., -0., -0., -0. );\n\n        drawPath(colT, fragCoord, armL, linewArmL, 8);\n        colC=min(colC,colT);\n    }\n#endif\n\n    vec2 navel[NUM] =  vec2[] ( V(0.427,0.430), V(0.427,0.430), V(0.429,0.404), V(0.4249,0.393), V(0.422,0.402), V(0.424,0.412), V(0.424,0.412), P, P,P,P,P );\n    float linewNavel[WNUM] = float[] ( 0.1, 0.3, 0.6, 0.3, 0.3, -0., -0., -0., -0., -0. );\n#ifdef NAVEL\n    if (length(uv-V(0.425,0.41)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n#ifdef NIPPLES\n    for (int i=0; i < NUM; i++) navel[i] +=  vec2(0.1, 0.23); // right\n    if (length(uv-V(0.425+0.1,0.41+0.23)) < 0.025) {\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n\n    if (length(uv-V(0.425+0.1-0.099,0.41+0.23+0.033)) < 0.025) {\n        for (int i=0; i < NUM; i++) navel[i] +=  vec2(-0.099, 0.033); // left\n        linewNavel[4] = 0.;\n        drawPath(colT, fragCoord, navel, linewNavel, 7);\n        colC=min(colC,colT);\n    }\n#endif\n\n    fragColor = colC; \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csKcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 369, 425, 425, 554], [1043, 1043, 1088, 1088, 1351], [1353, 1353, 1405, 1405, 1960]], "test": "untested"}
{"id": "msKcDD", "name": "autostereogram", "author": "silica163", "description": "far-eye autostereogram image create by using raymarching technique.\nInspired by this video [url]https://www.youtube.com/watch?v=-okxLz1UauA[/url]\nclick to view old version.", "tags": ["3d", "raymarch", "illusion", "autostereogram"], "likes": 2, "viewed": 165, "published": 3, "date": "1696176350", "time_retrieved": "2024-07-30T17:30:58.679850", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    m*=.1;\n    \n    vec3 ca = vec3(PI/2.+m.y*PI/2.,PI/2.+m.x*PI/1.,0);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n    \n    vec3 c = vec3(0);\n    vec3 ro = rotY*rotX*vec3(0,0,4);\n    vec3 rd = normalize(rotY*rotX*vec3(uv*2.,0)-ro);\n    vec3 rp = ro+rd;\n    \n    \n    /*vec4 hit = march(ro,rp,rd);\n    c += surfNormal(hit.rgb)*.5+.5;\n    c += texture(iChannel0,(fragCoord - vec2(LR-(1./hit.a)*LR,0))/iResolution.y*10.).r;*/\n    \n    vec2 dispUv = uv + texture(iChannel0,uv).rg/vec2(LR,1.);\n    \n    if(iMouse.z < 0.01){\n        c = texture(iChannel1,dispUv*(iResolution.xy)/LR).rgb;\n    } else {\n        c = texture(iChannel2,uv).rgb;\n    }\n    \n    uv = uv*2.-1. ;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x = abs(uv.x);\n    c += step(length(uv-vec2((LR*1.)/iResolution.y,.7)),20./iResolution.y);\n    \n    fragColor = vec4(c,1);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//depthmap\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    m*=.1;\n    m = vec2(.2,.1);\n    \n    vec3 ca = vec3(PI/2.+m.y*PI/2.,PI/2.+m.x*PI/1.,0);\n\t\n\tmat3 rotX = mat3(\n\t\t1,         0,        0,\n\t\t0, sin(ca.x),cos(ca.x),\n\t\t0,-cos(ca.x),sin(ca.x)\n\t);\n\t\n\tmat3 rotY = mat3(\n\t\t sin(ca.y),0, cos(ca.y),\n\t\t0,         1,         0,\n\t\t-cos(ca.y),0, sin(ca.y)\n\t);\n    \n    vec3 c = vec3(0);\n    vec3 ro = rotY*rotX*vec3(0,0,5);\n    vec3 rd = normalize(rotY*rotX*vec3(uv*2.5,0)-ro);\n    vec3 rp = ro;\n    \n    vec4 hit = march(ro,rp,rd);\n    c += 2./(hit.a);\n    \n    if(hit.a > 10.)c = vec3(0);\n    \n    fragColor = vec4(c,1);\n}", "buffer_a_inputs": [], "common_code": "#define MAX 5.\n#define MIN 0.007\n#define STEP 64\n#define PI 3.14159265\n#define LR 100.\n\nfloat dist(vec3 p);\n\n\nvec3 surfNormal(vec3 p){\n    vec2 t = vec2(MIN,0);\n\tfloat d = dist(p);\n\t\n\treturn normalize(d - vec3(\n\t\tdist(p-t.xyy),\n\t\tdist(p-t.yxy),\n\t\tdist(p-t.yyx)\n\t));\n}\n\nfloat cubeSDF(vec3 p,vec3 pos,vec3 size){\n    vec3 c = abs(p-pos)-size;\n    return length(max(c,0.)) + min(0.,max(c.x,max(c.y,c.z)));\n}\n\nfloat dist(vec3 p){\n    float d = MAX;\n    d = min(d,length(p-vec3(0,-.3,-1))-.6);\n    d = min(d,length(p-vec3(.4,-.5,1.7))-.2);\n    d = min(d,cubeSDF(p,vec3(0,-.7,0),vec3(1.1,.05,2)));\n    d = min(d,cubeSDF(p,vec3(-.7,-.1,1.5),vec3(.1,.7,.4)));\n    d = min(d,cubeSDF(p,vec3(.5,-.5,.5),vec3(.3,.2,.05)));\n    d = min(d,cubeSDF(p,vec3(-.6,-.5,-.5),vec3(.5,.3,.5)));\n    return d;\n}\n\nvec4 march(vec3 ro,vec3 rp, vec3 rd){\n    float travel = length(rp-ro);\n    for(int i = 0;i<STEP;i++){\n        rp = ro + travel*rd;\n        float d = dist(rp);\n        travel += d;\n        if(d <= MIN)break;\n        if(d >= MAX){\n            break;\n        }\n    }\n    return vec4(rp,travel);\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = vec3(0);\n    \n    float depthmap = texture(iChannel0,uv).x*2.;\n    c = texture(iChannel1,uv - vec2((LR/iResolution.x) - depthmap/LR,0.)).rgb;\n    if(fragCoord.x < LR) c = texture(iChannel2,((fragCoord-LR)/iResolution.xy)*iResolution.y*.01).rgb;\n    \n    fragColor = vec4(c,1.0);\n}\n", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = vec3(0);\n    float depthmap = texture(iChannel0,uv).x;\n    c = vec3(depthmap,0,0)*2.;\n    c += texture(iChannel1,uv - vec2(LR/iResolution.x - c.x/LR,0.)).rgb;\n    fragColor = vec4(c,1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/msKcDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 120, 1221]], "test": "untested"}
{"id": "csGyWw", "name": "The Perfect Playhouse", "author": "AlexAnimations", "description": "This Shader uses some trigonometry and pythagorian thereom to give calculate lighting.", "tags": ["lighting"], "likes": 0, "viewed": 132, "published": 3, "date": "1696170358", "time_retrieved": "2024-07-30T17:30:59.553514", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.,0.,0.);\n    if(uv.x<.5){\n        if(uv.y<.5){\n            col.x = .8-length(vec2(.5+cos(iTime*2.)/2.,.5+sin(iTime*2.)/2.)-uv);\n        }else{\n            col.z = .8-length(vec2(.5+cos(iTime*2.)/2.,.5+sin(iTime*2.)/2.)-uv);\n        }\n    }else{\n        if(uv.y<.5){\n            col.y = .8-length(vec2(.5+cos(iTime*2.)/2.,.5+sin(iTime*2.)/2.)-uv);\n        }else{\n            col.x = .8-length(vec2(.5+cos(iTime*2.)/2.,.5+sin(iTime*2.)/2.)-uv);\n            col.z = .8-length(vec2(.5+cos(iTime*2.)/2.,.5+sin(iTime*2.)/2.)-uv);\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/csGyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 692]], "test": "untested"}
{"id": "cdGyWw", "name": "Slow Graphics refresh", "author": "robinpdev", "description": "Slow Graphics refresh", "tags": ["dvd"], "likes": 1, "viewed": 96, "published": 3, "date": "1696169509", "time_retrieved": "2024-07-30T17:31:00.304506", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n\n    float period = 1.;\n    float time = mod(iTime, period);\n    float tfrac = 1. - time / period;\n    \n    float pfrac = uv.y - mod(uv.y,1./50.) - uv.x/50.;\n    \n    // Time varying pixel color\n    vec3 col = vec3(pfrac > tfrac, 0, 0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cdGyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 448]], "test": "untested"}
{"id": "cscczX", "name": "Slime Molds 3.0", "author": "01000001", "description": "Click to erase, shift to invert\n\nTracking now keeps track of 4 particles using ID.\n\nscale = 5 is completely stable, but 1 is actually viable for simulation. 1 on previous version was absolutely terrible. Pls help improve :)", "tags": ["simulation", "particles", "slime", "life", "automaton", "voronoitracking"], "likes": 22, "viewed": 556, "published": 3, "date": "1696131922", "time_retrieved": "2024-07-30T17:31:01.279898", "image_code": "// Buffer A : Particle control\n// Buffer B : Voronoi Tracking\n// Buffer C : Rendering\n// Buffer D : Post processing\n\n// See Buffer A to play around with particle configurations\n// I've included a few fun presets to try :D\n\n// You may wanna use the shadertoy unofficial plugin\n// to speed it up by increasing drawcalls\n// For interactivity though, realtime is nice\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef display_voronoi\n        O = uv.x>.5?\n            texture(iChannel2, uv):\n            texture(iChannel1, uv).xyzw/r.x/r.y;\n    #else \n        O = texture(iChannel2, uv);\n        \n        //*    \n        O = vec4(\n            O.x*O.x, \n            O.x, \n            sqrt(O.x), \n        1.);//*/\n\n    #endif\n}\n\n// Next up: Ant simulation!\n// And then turbulent particles 👀\n// ^ I wanna recreate this render I made in Blender\n// https://cdn.discordapp.com/attachments/1134975470526537879/1156789266739900456/still_particles.png\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Particle Buffer\n\n\n#define PRESET 3\n// 0 : Boring\n// 1 : Squiggly\n// 2 : High Velocity\n// 3 : Dendrites\n// 4 : Stable\n// 5 : Bipolar                          // I asked friends to help me find the word that means a system that\n                                        // will converge to a stable state, but explode at tiny perturbations\n                                        // and this is the suggestion I received. It works ¯\\_(ツ)_/¯\n// 6 : Angular\n// 7 : Cellular\n// 8 : Lattice\n\n// Alright that's enough. Have fun exploring :)\n\n\n#if PRESET == 0\n// Less than one gets funky\nconst float searchRange = 1.;\nconst float searchAngle = .4;\nconst float turnAngle = .02;\n#endif\n\n#if PRESET == 1\nconst float searchRange = 1.;\nconst float searchAngle = pi/3.;\nconst float turnAngle = .02;\n#endif\n\n#if PRESET == 2\nconst float searchRange = 5.;\nconst float searchAngle = .1;\nconst float turnAngle = .05;\n#endif\n\n#if PRESET == 3\nconst float searchRange = 5.;\nconst float searchAngle = .1;\nconst float turnAngle = .2;\n#endif\n\n#if PRESET == 4\nconst float searchRange = 1.;\nconst float searchAngle = 1.;\nconst float turnAngle = .2;\n#endif\n\n#if PRESET == 5\nconst float searchRange = 2.;\nconst float searchAngle = 2.*pi/3.;\nconst float turnAngle = 2.*pi/3.;\n#endif\n\n#if PRESET == 6\nconst float searchRange = 2.;\nconst float searchAngle = pi/2.;\nconst float turnAngle = pi/2.;\n#endif\n\n#if PRESET == 7\nconst float searchRange = 1.;\nconst float searchAngle = 0.01;\nconst float turnAngle = pi/7.;\n#endif\n\n#if PRESET == 8\nconst float searchRange = 50.;\nconst float searchAngle = .01;\nconst float turnAngle = .01;\n#endif\n\n\nconst float randomization = 5e-3;\n// Without this they'll converge to a stable state and then never do anything fun again :(\n\n\n\n\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    // if (uv.x * scale > 1. || uv.y * scale > 1.) return;\n    // Prevent simulation of particles out of bounds\n    // If we allow it then can resize at runtime\n    \n    \n    if (iFrame < 30){\n    \n        uvec3 a = uvec3(U, iDate.w);\n        O.xy = (circleSample(a))*.25 * vec2(1, aspect) + .5;\n        O.zw = normalize(hash(a).xy*2.-1.) * rot(pi/2.7);\n        return;\n        \n    }\n\n    O = texture(iChannel0, uv);\n\n    vec2 pos = O.xy;        \n    vec2 vel = O.zw;\n\n    const int rayCount = 3;\n    float rays[rayCount];\n\n    float x = 20.;\n\n    for (int ray = 0; ray < rayCount; ray++){\n        vec2 rayDir = vel * rot(-searchAngle+float(ray)*searchAngle);\n\n        x = texture(iChannel2, pos + rayDir*scale/r.x*searchRange).x;\n\n        rays[ray] = x;\n    }\n\n    vec3 h = hash(uvec3(U, iDate.w*1000.));\n    if (h.x < randomization){ // Crazy tiny amount of divergents.\n                     // That's all it takes to break up regularity with millions of particles :) \n        vel *= rot(h.y);\n    } else {\n        if (rays[0] > rays[2]){\n            // Left\n            vel *= rot(-turnAngle);\n        } else if (rays[2] > rays[0]) {\n            // Right\n            vel *= rot( turnAngle);\n        } else {\n            // Centre\n\n            //vel *= rot(h.y);\n        }\n    }\n\n    pos += vel * scale/r.x * 2e-2 * searchRange * vec2(1, aspect);\n\n    pos = mod(pos, 1.);\n\n    O = vec4(pos, vel);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Voronoi buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    if (iFrame < 10){\n        O = vec4(0);\n        return;\n    }\n    \n    \n    O = texture(iChannel1, uv);\n    \n    vec2 myParticles[4];\n    vec4 particleDists;\n    \n    for (int i = 4; i-->0;){\n        myParticles[i] = texture(iChannel0, decrypt(O[i], r)/scale).xy;\n        particleDists[i] = length(myParticles[i] - uv);\n    }\n    \n    \n    for (int i = 10; i-->0;){\n\n        for (int j = 4; j-->0;){\n        \n            vec3 a = hash(uvec3(U, iFrame - i + j*8))*2.-1.;\n            vec3 b = hash(uvec3(U, iFrame * i - j  ))*2.-1.;\n            vec3 c = hash(uvec3(U, iFrame + i - j*8))*2.-1.;\n        \n            vec2 samp = decrypt(\n                texture(iChannel1,\n                    mod(myParticles[j]\n                        + (a.xy + vec2(a.z, b.x) + b.yz + c.xy) / (r.x/scale) \n                        // Gaussian-ish sampling\n                        // we can use two vec3s to get three vec2s \n                        // and then another one for good measure\n                    ,1.) // Mod loops around overflow coordinates\n                )[i%5]\n            ,r);\n\n            vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n            push(O, samp, r, particleDists[j], length(newParticle-uv));\n            // Stores four particle IDs in the floats\n        }\n    }\n    \n    \n    for (int i = 0; i < 2; i++){\n        vec2 samp = hash(uvec3(U, iFrame * i)).xy;\n        \n        vec2 newParticle = texture(iChannel0, samp/scale).xy;\n\n        push(O, samp, r, particleDists[0], length(newParticle-uv));\n        // Completely random samples may not seem too critical, \n        // but they significantly improve the stability of the simulation\n    }\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n     // I am become pixel, creator of shaders\n    // - 01000001 2023\n\nconst float pi = 3.14159;\nconst float scale = 3.;\n// Try big number to see what's going on. 3 is about the minimum that works semi coherently.\n// Any improvements to accurately render an even larger quanitity of particles would be appreciated :D\n// I have a few ideas but I'd love to learn about the community's knowledge\n\n\n// #define debug\n// Render particles directly, no visual processing\n\n// #define display_voronoi\n// Show the voronoi buffer\n\n// #define blur\n// Blur the trails\n\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nvec2 circleSample(uvec3 x){\n    vec2 v,z;\n    for(int i = 0;v=hash(x+uint(v*1e9)).xy, z=v*2.-1., i++<9 && length(z) > 1.;);\n    return z;\n}\n\nmat2 rot( float rad ){\n    return mat2(\n        cos(rad), sin(rad),\n        -sin(rad), cos(rad)\n    );\n}\n\n\n/*\nvec2 decrypt(float d, vec2 r){\n    uint i = floatBitsToUint(d);\n    uvec2 ir = uvec2(r);\n\n    return vec2(\n        i%ir.x,\n        float(i-i%ir.x)/r.x\n    )/r;\n}\n\nfloat encrypt(vec2 uv, vec2 r){\n    uvec2 iuv = uvec2(uv*r);\n    uvec2 ir = uvec2(r);\n\n    return uintBitsToFloat(\n        iuv.x + iuv.y*ir.x\n    );\n}\n\n// This is better. BUT IT DOESN'T WORK WITH BUFFERS\n\n/*/\n\n\nvec2 decrypt(float d, vec2 r){\n    return vec2(mod(d, r.x), floor(d/r.x))/r;\n}\n\nfloat encrypt(vec2 uv, vec2 r){\n    return uv.x*r.x + floor(uv.y*r.y)*r.x;\n}\n\n\n//*/\n\nvoid push(inout vec4 O, vec2 uv, vec2 res, float me, float new){\n    ivec2 iuv = ivec2(floor(uv*res));\n    ivec2 ires = ivec2(floor(res));\n    \n    float e = encrypt(uv, res);\n    if (new < me && e != O.x && e != O.y && e != O.z && e != O.w){\n        O.w = O.z; O.z = O.y; O.y = O.x;\n        O.x = e;\n    }\n    \n}", "buffer_c_code": "// Render Buffer\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    float aspect = r.x/r.y;\n    \n    O = vec4(0);\n    \n    float minD = 2.;\n    float x = 0.;\n    for (int i = 0; i<2; i++){\n    \n        for (int j = 4; j-->0;){\n            vec2 samp = decrypt(\n                texture(iChannel1, \n                    uv + (circleSample(uvec3(U, iFrame * i << j)) / (r.x / scale))\n                )[j]\n            ,r)/scale;\n\n            x = length(\n                (texture(iChannel0, samp).xy - uv) * vec2(1, 1./aspect)\n            );\n\n            if (x < minD){\n                minD = x;\n            }\n        }\n    }\n    \n    #ifdef debug\n    #else\n        O = texture(iChannel2, uv\n            #ifdef blur\n            + (vec2(1.)/r)*rot(float(iFrame) * pi/2.)\n            #endif\n        );\n        O *= .96;\n    #endif\n    O += smoothstep(scale/r.x * .25, 0., minD);\n        \n    \n    if (iMouse.z > 0.){\n        if (texelFetch(iChannel3, ivec2(16, 0), 0).x > .0){\n            O.x += max(0., 1.-length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 500.);\n        } else {\n            O *= min(1., length((iMouse.xy - U)/r/scale * vec2(1, 1./aspect)) * 200.);   \n        }\n    }\n        \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Post Processing\n\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    \n    #ifdef debug\n        O = texture(iChannel2, uv);\n    #else\n        O = texture(iChannel3, uv);\n        O *= .95;\n        O += texture(iChannel2, uv)*1e-2;\n    #endif\n    \n    // Because of SIMD, vector as opposed to operating on only O.x\n    // should be the same speed right? I hope? Pls lmk in comments :)\n    \n    /*\n    float sum = 0.;\n    for (float i = 0.; i<8.; i++){\n        sum += texelFetch(iChannel2, ivec2(U) + ivec2(sin(i*pi/4.), cos(i*pi/4.)), 0).x;\n    }\n    O += sum*1e-3;\n    //*/\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/cscczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 367, 404, 404, 775]], "test": "untested"}
